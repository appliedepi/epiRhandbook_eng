{"title":"Epidemic curves","markdown":{"headingText":"Epidemic curves","headingAttr":{"id":"","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n```{r, out.width=c('75%'), echo=F, message=F}\nknitr::include_graphics(here::here(\"images\", \"epicurve_top.png\"))\n```    \n\n\nAn epidemic curve (also known as an \"epi curve\") is a core epidemiological chart typically used to visualize the temporal pattern of illness onset among a cluster or epidemic of cases.  \n\nAnalysis of the epicurve can reveal temporal trends, outliers, the magnitude of the outbreak, the most likely time period of exposure, time intervals between case generations, and can even help identify the mode of transmission of an unidentified disease (e.g. point source, continuous common source, person-to-person propagation). One online lesson on interpretation of epi curves can be found at the website of the [US CDC](https://www.cdc.gov/training/quicklearns/epimode/index.html).    \n\nIn this page we demonstrate making epidemic curves with the **ggplot2** package, which allows for advanced customizability.\n\nAlso addressed are specific use-cases such as:  \n\n* Plotting aggregated count data  \n* Faceting or producing small-multiples  \n* Applying moving averages  \n* Showing which data are \"tentative\" or subject to reporting delays  \n* Overlaying cumulative case incidence using a second axis  \n\nThe **incidence2** package offers alternative approach with easier commands, but as of this writing was undergoing revisions and was not stable. It will be re-added to this chapter when stable.  \n\n\n<!-- ======================================================= -->\n## Preparation\n\n\n### Packages {.unnumbered}  \n\nThis code chunk shows the loading of packages required for the analyses. In this handbook we emphasize `p_load()` from **pacman**, which installs the package if necessary *and* loads it for use. You can also load installed packages with  `library()` from **base** R. See the page on [R basics] for more information on R packages.  \n\n```{r message=F, warning=F}\npacman::p_load(\n  rio,          # file import/export\n  here,         # relative filepaths \n  lubridate,    # working with dates/epiweeks\n  aweek,        # alternative package for working with dates/epiweeks\n  incidence2,   # epicurves of linelist data\n  i2extras,     # supplement to incidence2\n  stringr,      # search and manipulate character strings\n  forcats,      # working with factors\n  RColorBrewer, # Color palettes from colorbrewer2.org\n  tidyverse     # data management + ggplot2 graphics\n) \n```\n\n\n### Import data {.unnumbered}\n\nTwo example datasets are used in this section:  \n\n* Linelist of individual cases from a simulated epidemic  \n* Aggregated counts by hospital from the same simulated epidemic  \n\nThe datasets are imported using the `import()` function from the **rio** package. See the page on [Import and export] for various ways to import data.  \n\n\n```{r, echo=F, message=F}\n# import the linelist into R\nlinelist <- rio::import(here::here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))\n\n# import the counts data into R\ncount_data <- linelist %>% \n  group_by(hospital, date_hospitalisation) %>% \n  summarize(n_cases = dplyr::n()) %>% \n  filter(date_hospitalisation > as.Date(\"2013-06-01\")) %>% \n  ungroup()\n```\n\n\n**Case linelist**\n\nWe import the dataset of cases from a simulated Ebola epidemic. If you want to download the data to follow step-by-step, see instruction in the [Download handbook and data] page. We assume the file is in the working directory so no sub-folders are specified in this file path.  \n\n```{r, eval=F}\nlinelist <- import(\"linelist_cleaned.xlsx\")\n```\n\nThe first 50 rows are displayed below.\n\n```{r, message=FALSE, echo=F}\n# display the linelist data as a table\nDT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )\n```\n\n\n\n**Case counts aggregated by hospital**  \n\nFor the purposes of the handbook, the dataset of weekly aggregated counts by hospital is created from the `linelist` with the following code. \n\n```{r, eval=F}\n# import the counts data into R\ncount_data <- linelist %>% \n  group_by(hospital, date_hospitalisation) %>% \n  summarize(n_cases = dplyr::n()) %>% \n  filter(date_hospitalisation > as.Date(\"2013-06-01\")) %>% \n  ungroup()\n```\n\nThe first 50 rows are displayed below:  \n\n```{r message=FALSE, echo=F}\n# display the linelist data as a table\nDT::datatable(head(count_data, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )\n```\n\n\n\n\n### Set parameters {.unnumbered}\n\nFor production of a report, you may want to set editable parameters such as the date for which the data is current (the \"data date\"). You can then reference the object `data_date` in your code when applying filters or in dynamic captions.\n\n```{r set_parameters}\n## set the report date for the report\n## note: can be set to Sys.Date() for the current date\ndata_date <- as.Date(\"2015-05-15\")\n```\n\n\n\n### Verify dates {.unnumbered}\n\nVerify that each relevant date column is class Date and has an appropriate range of values. You can do this simply using `hist()` for histograms, or `range()` with `na.rm=TRUE`, or with `ggplot()` as below.  \n\n```{r, out.width = c('50%', '50%', '50%'), fig.show='hold', warning=F, message=F}\n# check range of onset dates\nggplot(data = linelist)+\n  geom_histogram(aes(x = date_onset))\n```\n\n\n<!-- ======================================================= -->\n## Epicurves with ggplot2 { }\n\nUsing `ggplot()` to build your epicurve allows for flexibility and customization, but requires more effort and understanding of how `ggplot()` works.  \n\nYou must *manually* control the aggregation of the cases by time (into weeks, months, etc) *and* the intervals of the labels on the date axis. This must be carefully managed.  \n\nThese examples use a subset of the `linelist` dataset - only the cases from Central Hospital.  \n\n\n```{r, echo=F}\n# import the linelist into R\nlinelist <- rio::import(here::here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))\n```\n\n```{r}\ncentral_data <- linelist %>% \n  filter(hospital == \"Central Hospital\")\n```\n\n```{r, eval=F, echo=F}\ndetach(\"package:tidyverse\", unload=TRUE)\nlibrary(tidyverse)\n```\n\n\nTo produce an epicurve with `ggplot()` there are three main elements:  \n\n* A histogram, with linelist cases aggregated into \"bins\" distinguished by specific \"break\" points  \n* Scales for the axes and their labels  \n* Themes for the plot appearance, including titles, labels, captions, etc.\n\n\n### Specify case bins {.unnumbered}  \n\nHere we show how to specify how cases will be aggregated into histogram bins (\"bars\"). It is important to recognize that the aggregation of cases into histogram bins is **not** necessarily the same intervals as the dates that will appear on the x-axis. \n\nBelow is perhaps the most simple code to produce daily and weekly epicurves.  \n\nIn the over-arching `ggplot()` command the dataset is provided to `data = `. Onto this foundation, the geometry of a histogram is added with a `+`. Within the `geom_histogram()`, we map the aesthetics such that the column `date_onset` is mapped to the x-axis. Also within the `geom_histogram()` but *not* within `aes()` we set the `binwidth =` of the histogram bins, in days. If this **ggplot2** syntax is confusing, review the page on [ggplot basics].  \n\n<span style=\"color: orange;\">**_CAUTION:_** Plotting weekly cases by using `binwidth = 7` starts the first 7-day bin at the first case, which could be any day of the week! To create specific weeks, see section below .</span>\n\n\n``` {r ggplot_simple,  out.width = c('50%', '50%'), fig.show='hold', warning= F, message = F}\n# daily \nggplot(data = central_data) +          # set data\n  geom_histogram(                      # add histogram\n    mapping = aes(x = date_onset),     # map date column to x-axis\n    binwidth = 1)+                     # cases binned by 1 day \n  labs(title = \"Central Hospital - Daily\")                # title\n\n# weekly\nggplot(data = central_data) +          # set data \n  geom_histogram(                      # add histogram\n      mapping = aes(x = date_onset),   # map date column to x-axis\n      binwidth = 7)+                   # cases binned every 7 days, starting from first case (!) \n  labs(title = \"Central Hospital - 7-day bins, starting at first case\") # title\n```\n\nLet us note that the first case in this Central Hospital dataset had symptom onset on:  \n\n```{r}\nformat(min(central_data$date_onset, na.rm=T), \"%A %d %b, %Y\")\n```\n\n**To manually specify the histogram bin breaks, do *not* use the `binwidth = ` argument, and instead supply a vector of dates to `breaks = `.**  \n\nCreate the vector of dates with the **base** R function `seq.Date()`. This function expects arguments `to = `, `from = `, and `by = `. For example, the command below returns monthly dates starting at Jan 15 and ending by June 28.\n\n```{r}\nmonthly_breaks <- seq.Date(from = as.Date(\"2014-02-01\"),\n                           to = as.Date(\"2015-07-15\"),\n                           by = \"months\")\n\nmonthly_breaks   # print\n```\n\nThis vector can be provided to `geom_histogram()` as `breaks = `:  \n\n```{r, warning=F, message=F}\n# monthly \nggplot(data = central_data) +  \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    breaks = monthly_breaks)+         # provide the pre-defined vector of breaks                    \n  labs(title = \"Monthly case bins\")   # title\n```\n\nA simple weekly date sequence can be returned by setting `by = \"week\"`. For example: \n\n```{r}\nweekly_breaks <- seq.Date(from = as.Date(\"2014-02-01\"),\n                          to = as.Date(\"2015-07-15\"),\n                          by = \"week\")\n```\n\n \nAn alternative to supplying specific start and end dates is to write *dynamic* code so that weekly bins begin *the Monday before the first case*. **We will use these date vectors throughout the examples below.**  \n     \n```{r}\n# Sequence of weekly Monday dates for CENTRAL HOSPITAL\nweekly_breaks_central <- seq.Date(\n  from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 1), # monday before first case\n  to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # monday after last case\n  by   = \"week\")\n```  \n\nLet's unpack the rather daunting code above:  \n\n* The \"from\" value (earliest date of the sequence) is created as follows: the minimum date value (`min()` with `na.rm=TRUE`) in the column `date_onset` is fed to `floor_date()` from the **lubridate** package. `floor_date()` set to \"week\" returns the start date of that cases's \"week\", given that the start day of each week is a Monday (`week_start = 1`).  \n* Likewise, the \"to\" value (end date of the sequence) is created using the inverse function `ceiling_date()` to return the Monday *after* the last case.  \n* The \"by\" argument of `seq.Date()` can be set to any number of days, weeks, or months.   \n* Use `week_start = 7` for Sunday weeks  \n\nAs we will use these date vectors throughout this page, we also define one for the whole outbreak (the above is for Central Hospital only).  \n\n```{r}\n# Sequence for the entire outbreak\nweekly_breaks_all <- seq.Date(\n  from = floor_date(min(linelist$date_onset, na.rm=T),   \"week\", week_start = 1), # monday before first case\n  to   = ceiling_date(max(linelist$date_onset, na.rm=T), \"week\", week_start = 1), # monday after last case\n  by   = \"week\")\n```\n\nThese `seq.Date()` outputs can be used to create histogram bin breaks, but also the breaks for the date labels, which may be independent from the bins. Read more about the date labels in later sections.  \n\n<span style=\"color: darkgreen;\">**_TIP:_** For a more simple `ggplot()` command, save the bin breaks and date label breaks as named vectors in advance, and simply provide their names to `breaks = `.</span>  \n\n\n\n\n### Weekly epicurve example {.unnumbered}  \n\n**Below is detailed example code to produce weekly epicurves for Monday weeks, with aligned bars, date labels, and vertical gridlines.** This section is for the user who needs code quickly. To understand each aspect (themes, date labels, etc.) in-depth, continue to the subsequent sections. Of note:  \n\n* The *histogram bin breaks* are defined with `seq.Date()` as explained above to begin the Monday before the earliest case and to end the Monday after the last case  \n* The interval of *date labels* is specified by `date_breaks =` within `scale_x_date()`  \n* The interval of minor vertical gridlines between date labels is specified to `date_minor_breaks = `  \n* We use `closed = \"left\"` in the `geom_histogram()` to ensure the date are counted in the correct bins  \n* `expand = c(0,0)` in the x and y scales removes excess space on each side of the axes, which also ensures the date labels begin from the first bar.  \n\n```{r, warning=F, message=F}\n# TOTAL MONDAY WEEK ALIGNMENT\n#############################\n# Define sequence of weekly breaks\nweekly_breaks_central <- seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 1), # Monday before first case\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # Monday after last case\n      by   = \"week\")    # bins are 7-days \n\n\nggplot(data = central_data) + \n  \n  # make histogram: specify bin break points: starts the Monday before first case, end Monday after last case\n  geom_histogram(\n    \n    # mapping aesthetics\n    mapping = aes(x = date_onset),  # date column mapped to x-axis\n    \n    # histogram bin breaks\n    breaks = weekly_breaks_central, # histogram bin breaks defined previously\n      \n    closed = \"left\",  # count cases from start of breakpoint\n    \n    # bars\n    color = \"darkblue\",     # color of lines around bars\n    fill = \"lightblue\"      # color of fill within bars\n  )+ \n    \n  # x-axis labels\n  scale_x_date(\n    expand            = c(0,0),           # remove excess x-axis space before and after case bars\n    date_breaks       = \"4 weeks\",        # date labels and major vertical gridlines appear every 3 Monday weeks\n    date_minor_breaks = \"week\",           # minor vertical lines appear every Monday week\n    date_labels       = \"%a\\n%d %b\\n%Y\")+ # date labels format\n  \n  # y-axis\n  scale_y_continuous(\n    expand = c(0,0))+             # remove excess y-axis space below 0 (align histogram flush with x-axis)\n  \n  # aesthetic themes\n  theme_minimal()+                # simplify plot background\n  \n  theme(\n    plot.caption = element_text(hjust = 0,        # caption on left side\n                                face = \"italic\"), # caption in italics\n    axis.title = element_text(face = \"bold\"))+    # axis titles in bold\n  \n  # labels including dynamic caption\n  labs(\n    title    = \"Weekly incidence of cases (Monday weeks)\",\n    subtitle = \"Note alignment of bars, vertical gridlines, and axis labels on Monday weeks\",\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly incident cases reported\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))\n```\n\n\n#### Sunday weeks {.unnumbered}  \n\nTo achieve the above plot for Sunday weeks a few modifications are needed, because the `date_breaks = \"weeks\"` only work for Monday weeks.  \n\n* The break points of the *histogram bins* must be set to Sundays (`week_start = 7`)  \n* Within `scale_x_date()`, the similar date breaks should be provided to `breaks =` and `minor_breaks = ` to ensure the date labels and vertical gridlines align on Sundays.  \n\nFor example, the `scale_x_date()` command for Sunday weeks could look like this:  \n\n```{r, eval=F}\nscale_x_date(\n    expand = c(0,0),\n    \n    # specify interval of date labels and major vertical gridlines\n    breaks = seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7), # Sunday before first case\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # Sunday after last case\n      by   = \"4 weeks\"),\n    \n    # specify interval of minor vertical gridline \n    minor_breaks = seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7), # Sunday before first case\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # Sunday after last case\n      by   = \"week\"),\n   \n    # date label format\n    #date_labels = \"%a\\n%d %b\\n%Y\")+         # day, above month abbrev., above 2-digit year\n    label = scales::label_date_short())+ # automatic label formatting\n\n```\n\n\n\n### Group/color by value {.unnumbered}\n\nThe histogram bars can be colored by group and \"stacked\". To designate the grouping column, make the following changes. See the [ggplot basics] page for details.  \n\n* Within the histogram aesthetic mapping `aes()`, map the column name to the `group = ` and `fill = ` arguments  \n* Remove any `fill = ` argument *outside* of `aes()`, as it will override the one inside  \n* Arguments *inside* `aes()` will apply *by group*, whereas any *outside* will apply to all bars (e.g. you may still want `color = ` outside, so each bar has the same border)  \n\nHere is what the `aes()` command would look like to group and color the bars by gender:  \n\n```{r, eval=F}\naes(x = date_onset, group = gender, fill = gender)\n```\n\nHere it is applied:  \n\n```{r, warning=F, message=F}\nggplot(data = linelist) +     # begin with linelist (many hospitals)\n  \n  # make histogram: specify bin break points: starts the Monday before first case, end Monday after last case\n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = hospital,       # set data to be grouped by hospital\n      fill = hospital),       # bar fill (inside color) by hospital\n    \n    # bin breaks are Monday weeks\n    breaks = weekly_breaks_all,   # sequence of weekly Monday bin breaks for whole outbreak, defined in previous code       \n    \n    closed = \"left\",          # count cases from start of breakpoint\n\n    # Color around bars\n    color = \"black\")\n```\n\n\n### Adjust colors {.unnumbered}  \n\n* To *manually* set the fill for each group, use `scale_fill_manual()` (note: `scale_color_manual()` is different!).\n  * Use the `values = ` argument to apply a vector of colors.  \n  * Use `na.value = ` to specify a color for `NA` values.  \n  * Use the `labels = ` argument to change the text of legend items. To be safe, provide as a named vector like `c(\"old\" = \"new\", \"old\" = \"new\")` or adjust the values in the data itself.  \n  * Use `name = ` to give a proper title to the legend  \n* For more tips on color scales and palettes, see the page on [ggplot basics].  \n\n```{r, warning=F, message=F}\nggplot(data = linelist)+           # begin with linelist (many hospitals)\n  \n  # make histogram\n  geom_histogram(\n    mapping = aes(x = date_onset,\n        group = hospital,          # cases grouped by hospital\n        fill = hospital),          # bar fill by hospital\n    \n    # bin breaks\n    breaks = weekly_breaks_all,    # sequence of weekly Monday bin breaks, defined in previous code\n    \n    closed = \"left\",               # count cases from start of breakpoint\n\n    # Color around bars\n    color = \"black\")+              # border color of each bar\n  \n  # manual specification of colors\n  scale_fill_manual(\n    values = c(\"black\", \"orange\", \"grey\", \"beige\", \"blue\", \"brown\"),\n    labels = c(\"St. Mark's Maternity Hospital (SMMH)\" = \"St. Mark's\"),\n    name = \"Hospital\") # specify fill colors (\"values\") - attention to order!\n```\n\n\n\n\n### Adjust level order {.unnumbered}  \n\nThe order in which grouped bars are stacked is best adjusted by classifying the grouping column as class Factor. You can then designate the factor level order (and their display labels). See the page on [Factors] or [ggplot tips] for details.  \n\nBefore making the plot, use the `fct_relevel()` function from **forcats** package to convert the grouping column to class factor and manually adjust the level order, as detailed in the page on [Factors].  \n\n```{r}\n# load forcats package for working with factors\npacman::p_load(forcats)\n\n# Define new dataset with hospital as factor\nplot_data <- linelist %>% \n  mutate(hospital = fct_relevel(hospital, c(\"Missing\", \"Other\"))) # Convert to factor and set \"Missing\" and \"Other\" as top levels to appear on epicurve top\n\nlevels(plot_data$hospital) # print levels in order\n```\n\nIn the below plot, the only differences from previous is that column `hospital` has been consolidated as above, and we use `guides()` to reverse the legend order, so that \"Missing\" is on the bottom of the legend.  \n\n```{r, warning=F, message=F}\nggplot(plot_data) +                     # Use NEW dataset with hospital as re-ordered factor\n  \n  # make histogram\n  geom_histogram(\n    mapping = aes(x = date_onset,\n        group = hospital,               # cases grouped by hospital\n        fill = hospital),               # bar fill (color) by hospital\n    \n    breaks = weekly_breaks_all,         # sequence of weekly Monday bin breaks for whole outbreak, defined at top of ggplot section\n    \n    closed = \"left\",                    # count cases from start of breakpoint\n\n    color = \"black\")+                   # border color around each bar\n    \n  # x-axis labels\n  scale_x_date(\n    expand            = c(0,0),           # remove excess x-axis space before and after case bars\n    date_breaks       = \"3 weeks\",        # labels appear every 3 Monday weeks\n    date_minor_breaks = \"week\",           # vertical lines appear every Monday week\n    label = scales::label_date_short()) + # efficient label formatting\n  \n  # y-axis\n  scale_y_continuous(\n    expand = c(0,0))+                   # remove excess y-axis space below 0\n  \n  # manual specification of colors, ! attention to order\n  scale_fill_manual(\n    values = c(\"grey\", \"beige\", \"black\", \"orange\", \"blue\", \"brown\"),\n    labels = c(\"St. Mark's Maternity Hospital (SMMH)\" = \"St. Mark's\"),\n    name = \"Hospital\")+ \n  \n  # aesthetic themes\n  theme_minimal()+                      # simplify plot background\n  \n  theme(\n    plot.caption = element_text(face = \"italic\", # caption on left side in italics\n                                hjust = 0), \n    axis.title = element_text(face = \"bold\"))+   # axis titles in bold\n  \n  # labels\n  labs(\n    title    = \"Weekly incidence of cases by hospital\",\n    subtitle = \"Hospital as re-ordered factor\",\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly cases\")\n```\n\n<span style=\"color: darkgreen;\">**_TIP:_** To reverse the order of the legend only, add this **ggplot2** command: `guides(fill = guide_legend(reverse = TRUE))`.</span>  \n\n\n\n\n\n### Adjust legend {.unnumbered}\n\nRead more about legends and scales in the [ggplot tips] page. Here are a few highlights:  \n\n* Edit legend title either in the scale function or with `labs(fill = \"Legend title\")` (if your are using `color = ` aesthetic, then use `labs(color = \"\")`)  \n* `theme(legend.title = element_blank())` to have no legend title  \n* `theme(legend.position = \"top\")` (\"bottom\", \"left\", \"right\", or \"none\" to remove the legend)\n* `theme(legend.direction = \"horizontal\")` horizontal legend \n* `guides(fill = guide_legend(reverse = TRUE))` to reverse order of the legend  \n\n\n\n\n\n\n\n### Bars side-by-side {.unnumbered}  \n\nSide-by-side display of group bars (as opposed to stacked) is specified within `geom_histogram()` with `position = \"dodge\"` placed outside of `aes()`.  \n\nIf there are more than two value groups, these can become difficult to read. Consider instead using a faceted plot (small multiples). To improve readability in this example, missing gender values are removed.  \n\n```{r, warning=F, message=F}\nggplot(central_data %>% drop_na(gender))+   # begin with Central Hospital cases dropping missing gender\n    geom_histogram(\n        mapping = aes(\n          x = date_onset,\n          group = gender,         # cases grouped by gender\n          fill = gender),         # bars filled by gender\n        \n        # histogram bin breaks\n        breaks = weekly_breaks_central,   # sequence of weekly dates for Central outbreak - defined at top of ggplot section\n        \n        closed = \"left\",          # count cases from start of breakpoint\n        \n        color = \"black\",          # bar edge color\n        \n        position = \"dodge\")+      # SIDE-BY-SIDE bars\n                      \n  \n  # The labels on the x-axis\n  scale_x_date(expand            = c(0,0),          # remove excess x-axis space below and after case bars\n               date_breaks       = \"3 weeks\",       # labels appear every 3 Monday weeks\n               date_minor_breaks = \"week\",          # vertical lines appear every Monday week\n               label = scales::label_date_short())+ # efficient date labels\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+             # removes excess y-axis space between bottom of bars and the labels\n  \n  #scale of colors and legend labels\n  scale_fill_manual(values = c(\"brown\", \"orange\"),  # specify fill colors (\"values\") - attention to order!\n                    na.value = \"grey\" )+     \n\n  # aesthetic themes\n  theme_minimal()+                                               # a set of themes to simplify plot\n  theme(plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n        axis.title = element_text(face = \"bold\"))+               # axis titles in bold\n  \n  # labels\n  labs(title    = \"Weekly incidence of cases, by gender\",\n       subtitle = \"Subtitle\",\n       fill     = \"Gender\",                                      # provide new title for legend\n       x        = \"Week of symptom onset\",\n       y        = \"Weekly incident cases reported\")\n```\n\n\n\n\n### Axis limits {.unnumbered}  \n\nThere are two ways to limit the extent of axis values.  \n\nGenerally the preferred way is to use the command `coord_cartesian()`, which accepts `xlim = c(min, max)` and `ylim = c(min, max)` (where you provide the min and max values). This acts as a \"zoom\" without actually removing any data, which is important for statistics and summary measures.  \n\nAlternatively, you can set maximum and minimum date values using `limits = c()` within `scale_x_date()`. For example:  \n\n```{r eval=F}\nscale_x_date(limits = c(as.Date(\"2014-04-01\"), NA)) # sets a minimum date but leaves the maximum open.  \n```\n\nLikewise, if you want to the x-axis to extend to a specific date (e.g. current date), even if no new cases have been reported, you can use:  \n\n```{r eval=F}\nscale_x_date(limits = c(NA, Sys.Date()) # ensures date axis will extend until current date  \n```\n\n<span style=\"color: red;\">**_DANGER:_** Be cautious setting the y-axis scale breaks or limits (e.g. 0 to 30 by 5: `seq(0, 30, 5)`). Such static numbers can cut-off your plot too short if the data changes to exceed the limit!.</span>\n\n\n\n### Date-axis labels/gridlines {.unnumbered} \n\n<span style=\"color: darkgreen;\">**_TIP:_** Remember that date-axis **labels** are independent from the aggregation of the data into bars, but visually it can be important to align bins, date labels, and vertical grid lines.</span>\n\nTo **modify the date labels and grid lines**, use `scale_x_date()` in one of these ways:  \n\n* **If your histogram bins are days, Monday weeks, months, or years**:  \n  * Use `date_breaks = ` to specify the interval of labels and major gridlines (e.g. \"day\", \"week\", \"3 weeks\", \"month\", or \"year\")\n  * Use `date_minor_breaks = ` to specify interval of minor vertical gridlines (between date labels)  \n  * Add `expand = c(0,0)` to begin the labels at the first bar  \n  * Use `date_labels = ` to specify format of date labels - see the Dates page for tips (use `\\n` for a new line)  \n* **If your histogram bins are Sunday weeks**:  \n  * Use `breaks = ` and `minor_breaks = ` by providing a sequence of date breaks for each\n  * You can still use `date_labels = ` and `expand = ` for formatting as described above  \n\nSome notes:  \n\n* See the opening ggplot section for instructions on how to create a sequence of dates using `seq.Date()`.  \n* See [this page](https://rdrr.io/r/base/strptime.html) or the [Working with dates] page for tips on creating date labels.  \n\n\n\n\n#### Demonstrations {.unnumbered}\n\nBelow is a demonstration of plots where the bins and the plot labels/grid lines are aligned and not aligned:  \n\n```{r fig.show='hold', class.source = 'fold-hide', warning=F, message=F}\n# 7-day bins + Monday labels\n#############################\nggplot(central_data) +\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    binwidth = 7,                 # 7-day bins with start at first case\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n  \n  scale_x_date(\n    expand = c(0,0),                     # remove excess x-axis space below and after case bars\n    date_breaks = \"3 weeks\",             # Monday every 3 weeks\n    date_minor_breaks = \"week\",          # Monday weeks\n    label = scales::label_date_short())+ # automatic label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+              # remove excess space under x-axis, make flush\n  \n  labs(\n    title = \"MISALIGNED\",\n    subtitle = \"! CAUTION: 7-day bars start Thursdays at first case\\nDate labels and gridlines on Mondays\\nNote how ticks don't align with bars\")\n\n\n\n# 7-day bins + Months\n#####################\nggplot(central_data) +\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    binwidth = 7,\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n  \n  scale_x_date(\n    expand = c(0,0),                     # remove excess x-axis space below and after case bars\n    date_breaks = \"months\",              # 1st of month\n    date_minor_breaks = \"week\",          # Monday weeks\n    label = scales::label_date_short())+ # automatic label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                 # remove excess space under x-axis, make flush \n  \n  labs(\n    title = \"MISALIGNED\",\n    subtitle = \"! CAUTION: 7-day bars start Thursdays with first case\\nMajor gridlines and date labels at 1st of each month\\nMinor gridlines weekly on Mondays\\nNote uneven spacing of some gridlines and ticks unaligned with bars\")\n\n\n# TOTAL MONDAY ALIGNMENT: specify manual bin breaks to be mondays\n#################################################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # histogram breaks set to 7 days beginning Monday before first case\n    breaks = weekly_breaks_central,    # defined earlier in this page\n    \n    closed = \"left\",                   # count cases from start of breakpoint\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),                     # remove excess x-axis space below and after case bars\n    date_breaks = \"4 weeks\",             # Monday every 4 weeks\n    date_minor_breaks = \"week\",          # Monday weeks \n    label = scales::label_date_short())+ # label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                  # remove excess space under x-axis, make flush \n  \n  labs(\n    title = \"ALIGNED Mondays\",\n    subtitle = \"7-day bins manually set to begin Monday before first case (28 Apr)\\nDate labels and gridlines on Mondays as well\")\n\n\n# TOTAL MONDAY ALIGNMENT WITH MONTHS LABELS:\n############################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # histogram breaks set to 7 days beginning Monday before first case\n    breaks = weekly_breaks_central,    # defined earlier in this page\n    \n    closed = \"left\",                   # count cases from start of breakpoint\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),                     # remove excess x-axis space below and after case bars\n    date_breaks = \"months\",              # Monday every 4 weeks\n    date_minor_breaks = \"week\",          # Monday weeks \n    label = scales::label_date_short())+ # label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                  # remove excess space under x-axis, make flush \n  \n  theme(panel.grid.major = element_blank())+  # Remove major gridlines (fall on 1st of month)\n          \n  labs(\n    title = \"ALIGNED Mondays with MONTHLY labels\",\n    subtitle = \"7-day bins manually set to begin Monday before first case (28 Apr)\\nDate labels on 1st of Month\\nMonthly major gridlines removed\")\n\n\n# TOTAL SUNDAY ALIGNMENT: specify manual bin breaks AND labels to be Sundays\n############################################################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # histogram breaks set to 7 days beginning Sunday before first case\n    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                      by   = \"7 days\"),\n    \n    closed = \"left\",                    # count cases from start of breakpoint\n\n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),\n    # date label breaks and major gridlines set to every 3 weeks beginning Sunday before first case\n    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                      by   = \"3 weeks\"),\n    \n    # minor gridlines set to weekly beginning Sunday before first case\n    minor_breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                            to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                            by   = \"7 days\"),\n    \n    label = scales::label_date_short())+ # label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remove excess space under x-axis, make flush \n  \n  labs(title = \"ALIGNED Sundays\",\n       subtitle = \"7-day bins manually set to begin Sunday before first case (27 Apr)\\nDate labels and gridlines manually set to Sundays as well\")\n\n```\n\n\n\n\n\n### Aggregated data {.unnumbered} \n\nOften instead of a linelist, you begin with aggregated counts from facilities, districts, etc. You can make an epicurve with `ggplot()` but the code will be slightly different. This section will utilize the `count_data` dataset that was imported earlier, in the data preparation section. This dataset is the `linelist` aggregated to day-hospital counts. The first 50 rows are displayed below.  \n\n```{r message=FALSE, warning=F, echo=F}\n# display the linelist data as a table\nDT::datatable(head(count_data, 50), rownames = FALSE, filter=\"top\", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )\n```\n\n\n#### Plotting daily counts {.unnumbered}  \n\nWe can plot a daily epicurve from these *daily counts*. Here are the differences to the code:  \n\n* Within the aesthetic mapping `aes()`, specify `y = ` as the counts column (in this case, the column name is `n_cases`)\n* Add the argument `stat = \"identity\"` within `geom_histogram()`, which specifies that bar height should be the `y = ` value, not the number of rows as is the default  \n* Add the argument `width = ` to avoid vertical white lines between the bars. For daily data set to 1. For weekly count data set to 7. For monthly count data, white lines are an issue (each month has different number of days) - consider transforming your x-axis to a categorical ordered factor (months) and using `geom_col()`.\n\n\n```{r, message=FALSE, warning=F}\nggplot(data = count_data)+\n  geom_histogram(\n   mapping = aes(x = date_hospitalisation, y = n_cases),\n   stat = \"identity\",\n   width = 1)+                # for daily counts, set width = 1 to avoid white space between bars\n  labs(\n    x = \"Date of report\", \n    y = \"Number of cases\",\n    title = \"Daily case incidence, from daily count data\")\n```\n\n#### Plotting weekly counts {.unnumbered}\n\nIf your data are already case counts by week, they might look like this dataset (called `count_data_weekly`):  \n\n```{r, warning=F, message=F, echo=F}\n# Create weekly dataset with epiweek column\ncount_data_weekly <- count_data %>%\n  mutate(epiweek = lubridate::floor_date(date_hospitalisation, \"week\")) %>% \n  group_by(hospital, epiweek, .drop=F) %>% \n  summarize(n_cases_weekly = sum(n_cases, na.rm=T))   \n```\n\nThe first 50 rows of `count_data_weekly` are displayed below. You can see that the counts have been aggregated into weeks. Each week is displayed by the first day of the week (Monday by default).  \n\n```{r message=FALSE, echo=F}\n# display the linelist data as a table\nDT::datatable(count_data_weekly, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )\n```\n\nNow plot so that `x = ` the epiweek column. Remember to add `y = ` the counts column to the aesthetic mapping, and add `stat = \"identity\"` as explained above.  \n\n```{r, warning=F, message=F}\nggplot(data = count_data_weekly)+\n  \n  geom_histogram(\n    mapping = aes(\n      x = epiweek,           # x-axis is epiweek (as class Date)\n      y = n_cases_weekly,    # y-axis height in the weekly case counts\n      group = hospital,      # we are grouping the bars and coloring by hospital\n      fill = hospital),\n    stat = \"identity\")+      # this is also required when plotting count data\n     \n  # labels for x-axis\n  scale_x_date(\n    date_breaks = \"2 months\",      # labels every 2 months \n    date_minor_breaks = \"1 month\", # gridlines every month\n    label = scales::label_date_short())+ # label formatting\n     \n  # Choose color palette (uses RColorBrewer package)\n  scale_fill_brewer(palette = \"Pastel2\")+ \n  \n  theme_minimal()+\n  \n  labs(\n    x = \"Week of onset\", \n    y = \"Weekly case incidence\",\n    fill = \"Hospital\",\n    title = \"Weekly case incidence, from aggregated count data by hospital\")\n```\n\n\n\n\n### Moving averages {.unnumbered}\n\nSee the page on [Moving averages] for a detailed description and several options. Below is one option for calculating moving averages with the package **slider**. In this approach, *the moving average is calculated in the dataset prior to plotting*:  \n\n1) Aggregate the data into counts as necessary (daily, weekly, etc.) (see [Grouping data] page)  \n2) Create a new column to hold the moving average, created with `slide_index()` from **slider** package  \n3) Plot the moving average as a `geom_line()` on top of (after) the epicurve histogram  \n\nSee the helpful online [vignette for the **slider** package](https://cran.r-project.org/web/packages/slider/vignettes/slider.html)  \n\n\n```{r, warning=F, message=F}\n# load package\npacman::p_load(slider)  # slider used to calculate rolling averages\n\n# make dataset of daily counts and 7-day moving average\n#######################################################\nll_counts_7day <- linelist %>%    # begin with linelist\n  \n  ## count cases by date\n  count(date_onset, name = \"new_cases\") %>%   # name new column with counts as \"new_cases\"\n  drop_na(date_onset) %>%                     # remove cases with missing date_onset\n  \n  ## calculate the average number of cases in 7-day window\n  mutate(\n    avg_7day = slider::slide_index(    # create new column\n      new_cases,                       # calculate based on value in new_cases column\n      .i = date_onset,                 # index is date_onset col, so non-present dates are included in window \n      .f = ~mean(.x, na.rm = TRUE),    # function is mean() with missing values removed\n      .before = 6,                     # window is the day and 6-days before\n      .complete = FALSE),              # must be FALSE for unlist() to work in next step\n    avg_7day = unlist(avg_7day))       # convert class list to class numeric\n\n\n# plot\n######\nggplot(data = ll_counts_7day) +  # begin with new dataset defined above \n    geom_histogram(              # create epicurve histogram\n      mapping = aes(\n        x = date_onset,          # date column as x-axis\n        y = new_cases),          # height is number of daily new cases\n        stat = \"identity\",       # height is y value\n        fill=\"#92a8d1\",          # cool color for bars\n        colour = \"#92a8d1\",      # same color for bar border\n        )+ \n    geom_line(                   # make line for rolling average\n      mapping = aes(\n        x = date_onset,          # date column for x-axis\n        y = avg_7day,            # y-value set to rolling average column\n        lty = \"7-day \\nrolling avg\"), # name of line in legend\n      color=\"red\",               # color of line\n      size = 1) +                # width of line\n    scale_x_date(                # date scale\n      date_breaks = \"1 month\",\n      label = scales::label_date_short(), # label formatting\n      expand = c(0,0)) +\n    scale_y_continuous(          # y-axis scale\n      expand = c(0,0),\n      limits = c(0, NA)) +       \n    labs(\n      x=\"\",\n      y =\"Number of confirmed cases\",\n      fill = \"Legend\")+ \n    theme_minimal()+\n    theme(legend.title = element_blank())  # removes title of legend\n```\n\n\n\n\n### Faceting/small-multiples {.unnumbered}\n\nAs with other ggplots, you can create facetted plots (\"small multiples\"). As explained in the [ggplot tips] page of this handbook, you can use either `facet_wrap()` or `facet_grid()`. Here we demonstrate with `facet_wrap()`. For epicurves, `facet_wrap()` is typically easier as it is likely that you only need to facet on one column.  \n\nThe general syntax is `facet_wrap(rows ~ cols)`, where to the left of the tilde (~) is the name of a column to be spread across the \"rows\" of the facetted plot, and to the right of the tilde is the name of a column to be spread across the \"columns\" of the facetted plot. Most simply, just use one column name, to the right of the tilde: `facet_wrap(~age_cat)`.  \n\n\n**Free axes**  \nYou will need to decide whether the scales of the axes for each facet are \"fixed\" to the same dimensions (default), or \"free\" (meaning they will change based on the data within the facet). Do this with the `scales = ` argument within `facet_wrap()` by specifying \"free_x\" or \"free_y\", or \"free\".  \n\n\n**Number of cols and rows of facets**  \nThis can be specified with `ncol = ` and `nrow = ` within `facet_wrap()`. \n\n\n**Order of panels**  \nTo change the order of appearance, change the underlying order of the levels of the factor column used to create the facets.  \n\n\n**Aesthetics**  \nFont size and face, strip color, etc. can be modified through `theme()` with arguments like:  \n\n* `strip.text = element_text()` (size, colour, face, angle...)\n* `strip.background = element_rect()` (e.g. element_rect(fill=\"grey\"))  \n* `strip.position = ` (position of the strip \"bottom\", \"top\", \"left\", or \"right\")  \n\n\n**Strip labels**  \nLabels of the facet plots can be modified through the \"labels\" of the column as a factor, or by the use of a \"labeller\".  \n\nMake a labeller like this, using the function `as_labeller()` from **ggplot2**. Then provide the labeller to the `labeller = ` argument of `facet_wrap()` as shown below.  \n\n```{r, class.source = 'fold-show'}\nmy_labels <- as_labeller(c(\n     \"0-4\"   = \"Ages 0-4\",\n     \"5-9\"   = \"Ages 5-9\",\n     \"10-14\" = \"Ages 10-14\",\n     \"15-19\" = \"Ages 15-19\",\n     \"20-29\" = \"Ages 20-29\",\n     \"30-49\" = \"Ages 30-49\",\n     \"50-69\" = \"Ages 50-69\",\n     \"70+\"   = \"Over age 70\"))\n```\n\n**An example facetted plot** - facetted by column `age_cat`.\n\n\n```{r, warning=F, message=F}\n# make plot\n###########\nggplot(central_data) + \n  \n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = age_cat,\n      fill = age_cat),    # arguments inside aes() apply by group\n      \n    color = \"black\",      # arguments outside aes() apply to all data\n        \n    # histogram breaks\n    breaks = weekly_breaks_central, # pre-defined date vector (see earlier in this page)\n    closed = \"left\" # count cases from start of breakpoint\n    )+  \n                      \n  # The labels on the x-axis\n  scale_x_date(\n    expand            = c(0,0),          # remove excess x-axis space below and after case bars\n    date_breaks       = \"2 months\",      # labels appear every 2 months\n    date_minor_breaks = \"1 month\",       # vertical lines appear every 1 month \n    label = scales::label_date_short())+ # label formatting\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+                       # removes excess y-axis space between bottom of bars and the labels\n  \n  # aesthetic themes\n  theme_minimal()+                                           # a set of themes to simplify plot\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    strip.text = element_text(face = \"bold\", size = 10),\n    strip.background = element_rect(fill = \"grey\"))+         # axis titles in bold\n  \n  # create facets\n  facet_wrap(\n    ~age_cat,\n    ncol = 4,\n    strip.position = \"top\",\n    labeller = my_labels)+             \n  \n  # labels\n  labs(\n    title    = \"Weekly incidence of cases, by age category\",\n    subtitle = \"Subtitle\",\n    fill     = \"Age category\",                                      # provide new title for legend\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly incident cases reported\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))\n```\n\nSee this [link](https://ggplot2.tidyverse.org/reference/labellers.html) for more information on labellers.  \n\n\n\n\n#### Total epidemic in facet background {.unnumbered}\n\nTo show the total epidemic in the background of each facet, add the function `gghighlight()` with empty parentheses to the ggplot. This is from the package **gghighlight**. Note that the y-axis maximum in all facets is now based on the peak of the entire epidemic. There are more examples of this package in the [ggplot tips] page.  \n\n```{r, warning=F, message=F}\nggplot(central_data) + \n  \n  # epicurves by group\n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = age_cat,\n      fill = age_cat),  # arguments inside aes() apply by group\n    \n    color = \"black\",    # arguments outside aes() apply to all data\n    \n    # histogram breaks\n    breaks = weekly_breaks_central, # pre-defined date vector (see earlier in this page)\n    \n    closed = \"left\", # count cases from start of breakpoint\n    )+     # pre-defined date vector (see top of ggplot section)                \n  \n  # add grey epidemic in background to each facet\n  gghighlight::gghighlight()+\n  \n  # labels on x-axis\n  scale_x_date(\n    expand            = c(0,0),          # remove excess x-axis space below and after case bars\n    date_breaks       = \"2 months\",      # labels appear every 2 months\n    date_minor_breaks = \"1 month\",       # vertical lines appear every 1 month \n    label = scales::label_date_short())+ # label formatting\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+  # removes excess y-axis space below 0\n  \n  # aesthetic themes\n  theme_minimal()+                                           # a set of themes to simplify plot\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    strip.text = element_text(face = \"bold\", size = 10),\n    strip.background = element_rect(fill = \"white\"))+        # axis titles in bold\n  \n  # create facets\n  facet_wrap(\n    ~age_cat,                          # each plot is one value of age_cat\n    ncol = 4,                          # number of columns\n    strip.position = \"top\",            # position of the facet title/strip\n    labeller = my_labels)+             # labeller defines above\n  \n  # labels\n  labs(\n    title    = \"Weekly incidence of cases, by age category\",\n    subtitle = \"Subtitle\",\n    fill     = \"Age category\",                                      # provide new title for legend\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly incident cases reported\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))\n```\n\n\n#### One facet with data {.unnumbered}  \n\nIf you want to have one facet box that contains all the data, duplicate the entire dataset and treat the duplicates as one faceting value. A \"helper\" function `CreateAllFacet()` below can assist with this (thanks to this [blog post](https://stackoverflow.com/questions/18933575/easily-add-an-all-facet-to-facet-wrap-in-ggplot2)). When it is run, the number of rows doubles and there will be a new column called `facet` in which the duplicated rows will have the value \"all\", and the original rows have the their original value of the faceting colum. Now you just have to facet on the `facet` column.   \n\nHere is the helper function. Run it so that it is available to you.  \n\n```{r}\n# Define helper function\nCreateAllFacet <- function(df, col){\n     df$facet <- df[[col]]\n     temp <- df\n     temp$facet <- \"all\"\n     merged <-rbind(temp, df)\n     \n     # ensure the facet value is a factor\n     merged[[col]] <- as.factor(merged[[col]])\n     \n     return(merged)\n}\n```\n\nNow apply the helper function to the dataset, on column `age_cat`:  \n\n```{r}\n# Create dataset that is duplicated and with new column \"facet\" to show \"all\" age categories as another facet level\ncentral_data2 <- CreateAllFacet(central_data, col = \"age_cat\") %>%\n  \n  # set factor levels\n  mutate(facet = fct_relevel(facet, \"all\", \"0-4\", \"5-9\",\n                             \"10-14\", \"15-19\", \"20-29\",\n                             \"30-49\", \"50-69\", \"70+\"))\n\n# check levels\ntable(central_data2$facet, useNA = \"always\")\n```\n\nNotable changes to the `ggplot()` command are:  \n\n* The data used is now central_data2 (double the rows, with new column \"facet\")\n* Labeller will need to be updated, if used  \n* Optional: to achieve vertically stacked facets: the facet column is moved to rows side of equation and on right is replaced by \".\" (`facet_wrap(facet~.)`), and `ncol = 1`. You may also need to adjust the width and height of the saved png plot image (see `ggsave()` in [ggplot tips]).  \n\n```{r, fig.height=12, fig.width=5, warning=F, message=F}\nggplot(central_data2) + \n  \n  # actual epicurves by group\n  geom_histogram(\n        mapping = aes(\n          x = date_onset,\n          group = age_cat,\n          fill = age_cat),  # arguments inside aes() apply by group\n        color = \"black\",    # arguments outside aes() apply to all data\n        \n        # histogram breaks\n        breaks = weekly_breaks_central, # pre-defined date vector (see earlier in this page)\n        \n        closed = \"left\", # count cases from start of breakpoint\n        )+    # pre-defined date vector (see top of ggplot section)\n                     \n  # Labels on x-axis\n  scale_x_date(\n    expand            = c(0,0),          # remove excess x-axis space below and after case bars\n    date_breaks       = \"2 months\",      # labels appear every 2 months\n    date_minor_breaks = \"1 month\",       # vertical lines appear every 1 month \n    label = scales::label_date_short())+ # automatic label formatting\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+  # removes excess y-axis space between bottom of bars and the labels\n  \n  # aesthetic themes\n  theme_minimal()+                                           # a set of themes to simplify plot\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\")+               \n  \n  # create facets\n  facet_wrap(facet~. ,                            # each plot is one value of facet\n             ncol = 1)+            \n\n  # labels\n  labs(title    = \"Weekly incidence of cases, by age category\",\n       subtitle = \"Subtitle\",\n       fill     = \"Age category\",                                      # provide new title for legend\n       x        = \"Week of symptom onset\",\n       y        = \"Weekly incident cases reported\",\n       caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))\n```\n\n\n\n\n\n\n\n\n## Tentative data  \n\n\nThe most recent data shown in epicurves should often be marked as tentative, or subject to reporting delays. This can be done in by adding a vertical line and/or rectangle over a specified number of days. Here are two options:  \n\n1) Use `annotate()`:  \n    + For a line use `annotate(geom = \"segment\")`. Provide `x`, `xend`, `y`, and `yend`. Adjust size, linetype (`lty`), and color.  \n    + For a rectangle use `annotate(geom = \"rect\")`. Provide xmin/xmax/ymin/ymax. Adjust color and alpha.  \n2) Group the data by tentative status and color those bars differently  \n\n<span style=\"color: orange;\">**_CAUTION:_** You might try `geom_rect()` to draw a rectangle, but adjusting the transparency does not work in a linelist context. This function overlays one rectangle for each observation/row!. Use either a very low alpha (e.g. 0.01), or another approach. </span>\n\n### Using `annotate()` {.unnumbered}\n\n* Within `annotate(geom = \"rect\")`, the `xmin` and `xmax` arguments must be given inputs of class Date.  \n* Note that because these data are aggregated into weekly bars, and the last bar extends to the Monday after the last data point, the shaded region may appear to cover 4 weeks  \n* Here is an `annotate()` [online example](https://ggplot2.tidyverse.org/reference/annotate.html)\n\n\n```{r, warning=F, message=F}\nggplot(central_data) + \n  \n  # histogram\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    breaks = weekly_breaks_central,   # pre-defined date vector - see top of ggplot section\n    \n    closed = \"left\", # count cases from start of breakpoint\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") +\n\n  # scales\n  scale_y_continuous(expand = c(0,0))+\n  scale_x_date(\n    expand = c(0,0),                     # remove excess x-axis space below and after case bars\n    date_breaks = \"1 month\",             # 1st of month\n    date_minor_breaks = \"1 month\",       # 1st of month\n    label = scales::label_date_short())+ # automatic label formatting\n  \n  # labels and theme\n  labs(\n    title = \"Using annotate()\\nRectangle and line showing that data from last 21-days are tentative\",\n    x = \"Week of symptom onset\",\n    y = \"Weekly case indicence\")+ \n  theme_minimal()+\n  \n  # add semi-transparent red rectangle to tentative data\n  annotate(\n    \"rect\",\n    xmin  = as.Date(max(central_data$date_onset, na.rm = T) - 21), # note must be wrapped in as.Date()\n    xmax  = as.Date(Inf),                                          # note must be wrapped in as.Date()\n    ymin  = 0,\n    ymax  = Inf,\n    alpha = 0.2,          # alpha easy and intuitive to adjust using annotate()\n    fill  = \"red\")+\n  \n  # add black vertical line on top of other layers\n  annotate(\n    \"segment\",\n    x     = max(central_data$date_onset, na.rm = T) - 21, # 21 days before last data\n    xend  = max(central_data$date_onset, na.rm = T) - 21, \n    y     = 0,         # line begins at y = 0\n    yend  = Inf,       # line to top of plot\n    size  = 2,         # line size\n    color = \"black\",\n    lty   = \"solid\")+   # linetype e.g. \"solid\", \"dashed\"\n\n  # add text in rectangle\n  annotate(\n    \"text\",\n    x = max(central_data$date_onset, na.rm = T) - 15,\n    y = 15,\n    label = \"Subject to reporting delays\",\n    angle = 90)\n```\n\n\nThe same black vertical line can be achieved with the code below, but using `geom_vline()` you lose the ability to control the height:  \n\n```{r, eval=F}\ngeom_vline(xintercept = max(central_data$date_onset, na.rm = T) - 21,\n           size = 2,\n           color = \"black\")\n```\n\n\n\n### Bars color {.unnumbered}  \n\nAn alternative approach could be to adjust the color or display of the tentative bars of data themselves. You could create a new column in the data preparation stage and use it to group the data, such that the `aes(fill = )` of tentative data can be a different color or alpha than the other bars. \n\n```{r, message=F, warning=F}\n# add column\n############\nplot_data <- central_data %>% \n  mutate(tentative = case_when(\n    date_onset >= max(date_onset, na.rm=T) - 7 ~ \"Tentative\", # tenative if in last 7 days\n    TRUE                                       ~ \"Reliable\")) # all else reliable\n\n# plot\n######\nggplot(plot_data, aes(x = date_onset, fill = tentative)) + \n  \n  # histogram\n  geom_histogram(\n    breaks = weekly_breaks_central,   # pre-defined data vector, see top of ggplot page\n    closed = \"left\", # count cases from start of breakpoint\n    color = \"black\") +\n\n  # scales\n  scale_y_continuous(expand = c(0,0))+\n  scale_fill_manual(values = c(\"lightblue\", \"grey\"))+\n  scale_x_date(\n    expand = c(0,0),                     # remove excess x-axis space below and after case bars\n    date_breaks = \"3 weeks\",             # Monday every 3 weeks\n    date_minor_breaks = \"week\",          # Monday weeks \n    label = scales::label_date_short())+ # automatic label formatting\n  \n  # labels and theme\n  labs(title = \"Show days that are tentative reporting\",\n    subtitle = \"\")+ \n  theme_minimal()+\n  theme(legend.title = element_blank())                 # remove title of legend\n  \n```\n\n\n## Multi-level date labels  \n\nIf you want multi-level date labels (e.g. month and year) *without duplicating the lower label levels*, consider one of the approaches below:  \n\nRemember - you can can use tools like `\\n` *within* the `date_labels` or `labels` arguments to put parts of each label on a new line below. However, the codes below help you take years or months (for example) on a lower line *and only once*.   \n\nThe easiest method is to assign the `labels = ` argument in `scale_x_date()` to the function `label_date_short()` from the package **scales** (note: don't forget to include empty parentheses (), as shown below). This function will automatically construct efficient date labels (read more [here](https://scales.r-lib.org/reference/label_date.html)). An additional benefit of this function is that the labels will automatically adjust as your data expands over time: from days, to weeks, to months and years.  \n\n```{r, warning=F}\nggplot(central_data) + \n  \n  # histogram\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    breaks = weekly_breaks_central,   # pre-defined date vector - see top of ggplot section\n    closed = \"left\",                  # count cases from start of breakpoint\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n\n  # y-axis scale as before \n  scale_y_continuous(expand = c(0,0))+\n  \n  # x-axis scale sets efficient date labels\n  scale_x_date(\n    expand = c(0,0),                      # remove excess x-axis space below and after case bars\n    labels = scales::label_date_short())+ # auto efficient date labels\n  \n  # labels and theme\n  labs(\n    title = \"Using label_date_short()\\nTo make automatic and efficient date labels\",\n    x = \"Week of symptom onset\",\n    y = \"Weekly case indicence\")+ \n  theme_minimal()\n```\n\n\nA second option is to use faceting. Below:  \n\n* Case counts are aggregated into weeks for aesthetic reasons. See Epicurves page (aggregated data tab) for details.  \n* A `geom_area()` line is used instead of a histogram, as the faceting approach below does not work well with histograms.  \n\n\n**Aggregate to weekly counts**\n\n```{r out.width = c('50%', '50%'), fig.show='hold', warning=F, message=F}\n\n# Create dataset of case counts by week\n#######################################\ncentral_weekly <- linelist %>%\n  filter(hospital == \"Central Hospital\") %>%   # filter linelist\n  mutate(week = lubridate::floor_date(date_onset, unit = \"weeks\")) %>%  \n  count(week) %>%                              # summarize weekly case counts\n  drop_na(week) %>%                            # remove cases with missing onset_date\n  complete(                                    # fill-in all weeks with no cases reported\n    week = seq.Date(\n      from = min(week),   \n      to   = max(week),\n      by   = \"week\"),\n    fill = list(n = 0))                        # convert new NA values to 0 counts\n```\n\n**Make plots**  \n\n```{r, warning=F, message=F}\n# plot with no facet box border\n#################################\nggplot(central_weekly,\n       aes(x = week, y = n)) +              # establish x and y for entire plot\n  geom_line(stat = \"identity\",              # make line, line height is count number\n            color = \"#69b3a2\") +            # line color\n  geom_point(size=1, color=\"#69b3a2\") +     # make points at the weekly data points\n  geom_area(fill = \"#69b3a2\",               # fill area below line\n            alpha = 0.4)+                   # fill transparency\n  scale_x_date(date_labels=\"%b\",            # date label format show month \n               date_breaks=\"month\",         # date labels on 1st of each month\n               expand=c(0,0)) +             # remove excess space\n  scale_y_continuous(\n    expand  = c(0,0))+                      # remove excess space below x-axis\n  facet_grid(~lubridate::year(week),        # facet on year (of Date class column)\n             space=\"free_x\",                \n             scales=\"free_x\",               # x-axes adapt to data range (not \"fixed\")\n             switch=\"x\") +                  # facet labels (year) on bottom\n  theme_bw() +\n  theme(strip.placement = \"outside\",                  # facet label placement\n          strip.background = element_blank(),         # no facet lable background\n          panel.grid.minor.x = element_blank(),          \n          panel.border = element_blank(),             # no border for facet panel\n          panel.spacing=unit(0,\"cm\"))+                # No space between facet panels\n  labs(title = \"Nested year labels - points, shaded, no label border\")\n```\n\nThe above technique for faceting was adapted from [this](https://stackoverflow.com/questions/44616530/axis-labels-on-two-lines-with-nested-x-variables-year-below-months) and [this](https://stackoverflow.com/questions/20571306/multi-row-x-axis-labels-in-ggplot-line-chart) post on stackoverflow.com.  \n\n\n\n\n\n\n<!-- ======================================================= -->\n## Dual-axis { }  \n\nAlthough there are fierce discussions about the validity of dual axes within the data visualization community, many epi supervisors still want to see an epicurve or similar chart with a percent overlaid with a second axis. This is discussed more extensively in the [ggplot tips] page, but one example using the **cowplot** method is shown below:  \n\n* Two distinct plots are made, and then combined with **cowplot** package.  \n* The plots must have the exact same x-axis (set limits) or else the data and labels will not align  \n* Each uses `theme_cowplot()` and one has the y-axis moved to the right side of the plot  \n\n```{r, warning=F, message=F}\n#load package\npacman::p_load(cowplot)\n\n# Make first plot of epicurve histogram\n#######################################\nplot_cases <- linelist %>% \n  \n  # plot cases per week\n  ggplot()+\n  \n  # create histogram  \n  geom_histogram(\n    \n    mapping = aes(x = date_onset),\n    \n    # bin breaks every week beginning monday before first case, going to monday after last case\n    breaks = weekly_breaks_all)+  # pre-defined vector of weekly dates (see top of ggplot section)\n        \n  # specify beginning and end of date axis to align with other plot\n  scale_x_date(\n    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # min/max of the pre-defined weekly breaks of histogram\n  \n  # labels\n  labs(\n      y = \"Daily cases\",\n      x = \"Date of symptom onset\"\n    )+\n  theme_cowplot()\n\n\n# make second plot of percent died per week\n###########################################\nplot_deaths <- linelist %>%                        # begin with linelist\n  group_by(week = floor_date(date_onset, \"week\")) %>%  # create week column\n  \n  # summarise to get weekly percent of cases who died\n  summarise(n_cases = n(),\n            died = sum(outcome == \"Death\", na.rm=T),\n            pct_died = 100*died/n_cases) %>% \n  \n  # begin plot\n  ggplot()+\n  \n  # line of weekly percent who died\n  geom_line(                                # create line of percent died\n    mapping = aes(x = week, y = pct_died),  # specify y-height as pct_died column\n    stat = \"identity\",                      # set line height to the value in pct_death column, not the number of rows (which is default)\n    size = 2,\n    color = \"black\")+\n  \n  # Same date-axis limits as the other plot - perfect alignment\n  scale_x_date(\n    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # min/max of the pre-defined weekly breaks of histogram\n  \n  \n  # y-axis adjustments\n  scale_y_continuous(                # adjust y-axis\n    breaks = seq(0,100, 10),         # set break intervals of percent axis\n    limits = c(0, 100),              # set extent of percent axis\n    position = \"right\")+             # move percent axis to the right\n  \n  # Y-axis label, no x-axis label\n  labs(x = \"\",\n       y = \"Percent deceased\")+      # percent axis label\n  \n  theme_cowplot()                   # add this to make the two plots merge together nicely\n```\n\nNow use **cowplot** to overlay the two plots. Attention has been paid to the x-axis alignment, side of the y-axis, and use of `theme_cowplot()`.  \n\n```{r, warning=F, message=F}\naligned_plots <- cowplot::align_plots(plot_cases, plot_deaths, align=\"hv\", axis=\"tblr\")\nggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])\n```\n\n\n\n\n## Cumulative Incidence {}\n\nIf beginning with a case linelist, create a new column containing the cumulative number of cases per day in an outbreak using `cumsum()` from **base** R:    \n\n```{r}\ncumulative_case_counts <- linelist %>% \n  count(date_onset) %>%                # count of rows per day (returned in column \"n\")   \n  mutate(                         \n    cumulative_cases = cumsum(n)       # new column of the cumulative number of rows at each date\n    )\n```\n\nThe first 10 rows are shown below:  \n\n```{r message=FALSE, echo=F}\n# display the linelist data as a table\nDT::datatable(head(cumulative_case_counts, 10), rownames = FALSE, options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )\n```\n\n\n\nThis cumulative column can then be plotted against `date_onset`, using `geom_line()`:\n\n```{r, warning=F, message=F}\nplot_cumulative <- ggplot()+\n  geom_line(\n    data = cumulative_case_counts,\n    aes(x = date_onset, y = cumulative_cases),\n    size = 2,\n    color = \"blue\")\n\nplot_cumulative\n```\n\n\nIt can also be overlaid onto the epicurve, with dual-axis using the **cowplot** method described above and in the [ggplot tips] page:\n\n```{r, warning=F, message=F}\n#load package\npacman::p_load(cowplot)\n\n# Make first plot of epicurve histogram\nplot_cases <- ggplot()+\n  geom_histogram(          \n    data = linelist,\n    aes(x = date_onset),\n    binwidth = 1)+\n  labs(\n    y = \"Daily cases\",\n    x = \"Date of symptom onset\"\n  )+\n  theme_cowplot()\n\n# make second plot of cumulative cases line\nplot_cumulative <- ggplot()+\n  geom_line(\n    data = cumulative_case_counts,\n    aes(x = date_onset, y = cumulative_cases),\n    size = 2,\n    color = \"blue\")+\n  scale_y_continuous(\n    position = \"right\")+\n  labs(x = \"\",\n       y = \"Cumulative cases\")+\n  theme_cowplot()+\n  theme(\n    axis.line.x = element_blank(),\n    axis.text.x = element_blank(),\n    axis.title.x = element_blank(),\n    axis.ticks = element_blank())\n```\n\nNow use **cowplot** to overlay the two plots. Attention has been paid to the x-axis alignment, side of the y-axis, and use of `theme_cowplot()`.  \n\n```{r, warning=F, message=F}\naligned_plots <- cowplot::align_plots(plot_cases, plot_cumulative, align=\"hv\", axis=\"tblr\")\nggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])\n```\n\n\n<!-- ======================================================= -->\n## Resources { }\n\n\n\n\n\n\n\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"epicurves.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.340","lightbox":true,"theme":{"light":"cosmo","dark":["cosmo","theme-dark.scss"]}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}