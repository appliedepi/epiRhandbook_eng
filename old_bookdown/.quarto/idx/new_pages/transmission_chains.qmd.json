{"title":"Transmission chains","markdown":{"headingText":"Transmission chains","headingAttr":{"id":"","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n\n<!-- ======================================================= -->\n## Overview {  }\n\nThe primary tool to handle, analyse and visualise transmission chains and contact\ntracing data is the package **epicontacts**, developed by the folks at\nRECON. Try out the interactive plot below by hovering over the nodes for more\ninformation, dragging them to move them and clicking on them to highlight downstream cases.\n\n```{r out.width=c('25%', '25%'), fig.show='hold', echo=F}\n\n# install development version of epicontacts\nif(\n  !\"epicontacts\" %in% rownames(installed.packages()) |\n  packageVersion(\"epicontacts\") != \"1.2.0\"\n) remotes::install_github(\"reconhub/epicontacts@timeline\")\n\n## install and load packages\npacman::p_load(tidyverse,\n               #epicontacts,\n               magrittr, here, webshot, visNetwork)\n\nlibrary(epicontacts)\n\n## load linelist\nlinelist <- rio::import(here::here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\")) %>%\n  filter(!duplicated(case_id))\n## generate contacts\ncontacts <- linelist %>%\n  transmute(\n    from = infector,\n    to = case_id,\n    location = sample(c(\"Community\", \"Nosocomial\"), n(), TRUE),\n    duration = sample.int(10, n(), TRUE)\n  ) %>%\n  drop_na(from)\n\n## generate epicontacts\nepic <- epicontacts::make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n\n## subset object\n#epic %<>% subset(\nepic_small <- epic %>% \n  subset(\n    node_attribute = list(date_onset = c(as.Date(c(\"2014-06-01\", \"2014-07-01\"))))) %>%\n  epicontacts::thin(\"contacts\")\n\n# plot with date of onset as x-axis\nplot(\n  epic_small,\n  x_axis = \"date_onset\",\n  label = FALSE,\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  node_shape = \"gender\",\n  shapes = c(f = \"female\", m = \"male\"),\n  unlinked_pos = \"bottom\",\n  date_labels = \"%b %d %Y\",\n  node_size = 35,\n  font_size = 20,\n  arrow_size = 0.5,\n  height = 800,\n  width = 700,\n  edge_linetype = \"location\",\n  legend_width = 0.15,\n  highlight_downstream = TRUE,\n  selector = FALSE\n)\n\n```\n\n<!-- ======================================================= -->\n## Preparation {  }\n\n### Load packages {.unnumbered}  \n\nFirst load the standard packages required for data import and manipulation. In this handbook we emphasize `p_load()` from **pacman**, which installs the package if necessary *and* loads it for use. You can also load packages with `library()` from **base** R. See the page on [R basics] for more information on R packages.  \n \n\t\n```{r transmission_chains_packages, eval = FALSE}\npacman::p_load(\n   rio,          # File import\n   here,         # File locator\n   tidyverse,    # Data management + ggplot2 graphics\n   remotes       # Package installation from github\n)\n```\n\t\nYou will require the development version of **epicontacts**, which can be\ninstalled from github using the `p_install_github()` function from **pacman**. You only need to run this command\nbelow once, not every time you use the package (thereafter, you can use `p_load()` as usual).\n\n```{r transmission_chains_epicontacts_install, eval = FALSE}\npacman::p_install_gh(\"reconhub/epicontacts@timeline\")\n```\n\n\n### Import data {.unnumbered}\n\nWe import the dataset of cases from a simulated Ebola epidemic. If you want to download the data to follow step-by-step, see instructions in the [Download handbook and data] page. The dataset is imported using the `import()` function from the **rio** package. See the page on [Import and export] for various ways to import data.\n\n```{r, echo=F}\n# import the linelist into R\nlinelist <- rio::import(here::here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))\n```\n\n```{r, eval=F}\n# import the linelist\nlinelist <- import(\"linelist_cleaned.xlsx\")\n```\n\nThe first 50 rows of the linelist are displayed below. Of particular interest are the columns `case_id`, `generation`, `infector`, and `source`.  \n\n```{r, message=FALSE, echo=F}\n# display the linelist data as a table\nDT::datatable(head(linelist, 50), rownames = FALSE, filter=\"top\", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )\n```\n\n\n### Creating an epicontacts object {.unnumbered}\n\nWe then need to create an **epicontacts** object, which requires two types of\ndata:\n\n* a linelist documenting cases where columns are variables and rows correspond to unique cases\n* a list of edges defining links between cases on the basis of their unique IDs (these can be contacts,\n  transmission events, etc.)\n\nAs we already have a linelist, we just need to create a list of edges between\ncases, more specifically between their IDs. We can extract transmission links from the\nlinelist by linking the `infector` column with the `case_id` column. At this point we can also add \"edge\nproperties\", by which we mean any variable describing the link between the two\ncases, not the cases themselves. For illustration, we will add a `location`\nvariable describing the location of the transmission event, and a duration\nvariable describing the duration of the contact in days.\n\nIn the code below, the **dplyr** function `transmute` is similar to `mutate`, except it only keeps\nthe columns we have specified within the function. The `drop_na` function will\nfilter out any rows where the specified columns have an `NA` value; in this\ncase, we only want to keep the rows where the infector is known.\n\n```{r transmission_chains_create_contacts,}\n## generate contacts\ncontacts <- linelist %>%\n  transmute(\n    infector = infector,\n    case_id = case_id,\n    location = sample(c(\"Community\", \"Nosocomial\"), n(), TRUE),\n    duration = sample.int(10, n(), TRUE)\n  ) %>%\n  drop_na(infector)\n```\n\nWe can now create the **epicontacts** object using the `make_epicontacts`\nfunction. We need to specify which column in the linelist points to the unique case\nidentifier, as well as which columns in the contacts point to the unique\nidentifiers of the cases involved in each link. These links are directional in\nthat infection is going _from_ the infector _to_ the case, so we need to specify\nthe `from` and `to` arguments accordingly. We therefore also set the `directed`\nargument to `TRUE`, which will affect future operations.\n\n```{r transmission_chains_create_epicontacts,}\n## generate epicontacts object\nepic <- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts,\n  id = \"case_id\",\n  from = \"infector\",\n  to = \"case_id\",\n  directed = TRUE\n)\n```\nUpon examining the **epicontacts** objects, we can see that the `case_id` column\nin the linelist has been renamed to `id` and the `case_id` and `infector`\ncolumns in the contacts have been renamed to `from` and `to`. This ensures\nconsistency in subsequent handling, visualisation and analysis operations.\n\n```{r transmission_chains_view_epicontacts,}\n## view epicontacts object\nepic\n```\n\n<!-- ======================================================= -->\n## Handling {  }\n\n### Subsetting {.unnumbered}\n\nThe `subset()` method for `epicontacts` objects allows for, among other things,\nfiltering of networks based on properties of the linelist (\"node attributes\") and the contacts\ndatabase (\"edge attributes\"). These values must be passed as named lists to the\nrespective argument. For example, in the code below we are keeping only the\nmale cases in the linelist that have an infection date between April and\nJuly 2014 (dates are specified as ranges), and transmission links that occured\nin the hospital.\n\n```{r transmission_chains_subset_nodes,}\nsub_attributes <- subset(\n  epic,\n  node_attribute = list(\n    gender = \"m\",\n    date_infection = as.Date(c(\"2014-04-01\", \"2014-07-01\"))\n  ), \n  edge_attribute = list(location = \"Nosocomial\")\n)\nsub_attributes\n```\n\nWe can use the `thin` function to either filter the linelist to include cases\nthat are found in the contacts by setting the argument `what = \"linelist\"`, or\nfilter the contacts to include cases that are found in the linelist by setting\nthe  argument `what = \"contacts\"`. In the code below, we are further filtering the\nepicontacts object to keep only the transmission links involving the male cases\ninfected between April and July which we had filtered for above. We can see that\nonly two known transmission links fit that specification.\n\n```{r transmission_chains_thin,}\nsub_attributes <- thin(sub_attributes, what = \"contacts\")\nnrow(sub_attributes$contacts)\n```\n\nIn addition to subsetting by node and edge attributes, networks can be pruned to\nonly include components that are connected to certain nodes. The `cluster_id`\nargument takes a vector of case IDs and returns the linelist of individuals that\nare linked, directly or indirectly, to those IDs. In the code below, we can see\nthat a total of 13 linelist cases are involved in the clusters containing\n`2ae019` and `71577a`.\n\n```{r}\nsub_id <- subset(epic, cluster_id = c(\"2ae019\",\"71577a\"))\nnrow(sub_id$linelist)\n```\n\nThe `subset()` method for `epicontacts` objects also allows filtering by cluster\nsize using the `cs`, `cs_min` and `cs_max` arguments. In the code below, we are\nkeeping only the cases linked to clusters of 10 cases or larger, and can see that\n271 linelist cases are involved in such clusters.\n    \n```{r}   \nsub_cs <- subset(epic, cs_min = 10)\nnrow(sub_cs$linelist)\n```\n\n### Accessing IDs {.unnumbered}\n\nThe `get_id()` function retrieves information on case IDs in the\ndataset, and can be parameterized as follows:\n\n- **linelist**: IDs in the line list data\n- **contacts**: IDs in the contact dataset (\"from\" and \"to\" combined)\n- **from**: IDs in the \"from\" column of contact datset\n- **to** IDs in the \"to\" column of contact dataset\n- **all**: IDs that appear anywhere in either dataset\n- **common**: IDs that appear in both contacts dataset and line list\n    \nFor example, what are the first ten IDs in the contacts dataset?\n```{r transmission_chains_get_ids,}\ncontacts_ids <- get_id(epic, \"contacts\")\nhead(contacts_ids, n = 10)\n```\n\nHow many IDs are found in both the linelist and the contacts?\n```{r transmission_chains_get_both,}\nlength(get_id(epic, \"common\"))\n```\n\n<!-- ======================================================= -->\n## Visualization {  }\n\n### Basic plotting {.unnumbered}\n\nAll visualisations of **epicontacts** objects are handled by the `plot`\nfunction. We will first filter the **epicontacts** object to include only the\ncases with onset dates in June 2014 using the `subset` function, and only\ninclude the contacts linked to those cases using the `thin` function.\n\t\n```{r transmission_chains_basic_plot_sub,}\n## subset epicontacts object\nsub <- epic %>%\n  subset(\n    node_attribute = list(date_onset = c(as.Date(c(\"2014-06-30\", \"2014-06-01\"))))\n  ) %>%\n thin(\"contacts\")\n```\n\nWe can then create the basic, interactive plot very simply as follows:\n\n```{r transmission_chains_basic_plot,}\n## plot epicontacts object\nplot(\n  sub,\n  width = 700,\n  height = 700\n)\n```\n\nYou can move the nodes around by dragging them, hover over them for more\ninformation and click on them to highlight connected cases.\n\nThere are a large number of arguments to further modify this plot. We will cover\nthe main ones here, but check out the documentation via `?vis_epicontacts` (the\nfunction called when using `plot` on an **epicontacts** object) to get a full\ndescription of the function arguments.\n\n#### Visualising node attributes {.unnumbered}\n\nNode color, node shape and node size can be mapped to a given column in the linelist \nusing the `node_color`, `node_shape` and `node_size` arguments. This is similar\nto the `aes` syntax you may recognise from **ggplot2**. \n\nThe specific colors, shapes and sizes of nodes can be specified as follows:\n\n* **Colors** via the `col_pal` argument, either by providing a name list for manual\nspecification of each color as done below, or by providing a color palette\nfunction such as `colorRampPalette(c(\"black\", \"red\", \"orange\"))`, which would\nprovide a gradient of colours between the ones specified.\n\n* **Shapes** by passing a named list to the `shapes` argument, specifying one shape\n  for each unique element in the linelist column specified by the `node_shape`\n  argument. See `codeawesome` for available shapes.\n\n* **Size** by passing a size range of the nodes to the `size_range` argument.\n\nHere an example, where color represents the outcome, shape the gender and size\nthe age:\n\n```{r transmission_chains_node_attribute,}\nplot(\n  sub, \n  node_color = \"outcome\",\n  node_shape = \"gender\",\n  node_size = \"age\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  shapes = c(f = \"female\", m = \"male\"),\n  size_range = c(40, 60),\n  height = 700,\n  width = 700\n)\n```\n\n#### Visualising edge attributes {.unnumbered}\n\nEdge color, width and linetype can be mapped to a given column in the contacts\ndataframe using the `edge_color`, `edge_width` and `edge_linetype`\narguments. The specific colors and widths of the edges can be specified as follows:\n\n* **Colors** via the `edge_col_pal` argument, in the same manner used for `col_pal`.\n\n* **Widths** by passing a size range of the nodes to the `width_range` argument.\n\nHere an example:\n\n```{r transmission_chains_edge_attribute,}\n\nplot(\n  sub, \n  node_color = \"outcome\",\n  node_shape = \"gender\",\n  node_size = 'age',\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  shapes = c(f = \"female\", m = \"male\"),\n  size_range = c(40, 60),\n  edge_color = 'location',\n  edge_linetype = 'location',\n  edge_width = 'duration',\n  edge_col_pal = c(Community = \"orange\", Nosocomial = \"purple\"),\n  width_range = c(1, 3),\n  height = 700,\n  width = 700\n)\n\n```\n\n### Temporal axis {.unnumbered}\n\nWe can also visualise the network along a temporal axis by mapping the `x_axis`\nargument to a column in the linelist. In the example below, the x-axis\nrepresents the date of symptom onset. We have also specified the `arrow_size`\nargument to ensure the arrows are not too large, and set `label = FALSE` to make\n the figure less cluttered.\n\n```{r transmission_chains_x_axis,}\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n```\n\nThere are a large number of additional arguments to futher specify how this\nnetwork is visualised along a temporal axis, which you can check out\nvia `?vis_temporal_interactive` (the function called when using `plot` on\nan **epicontacts** object with `x_axis` specified). We'll go through some\nbelow.\n\n#### Specifying transmission tree shape {.unnumbered}\n\nThere are two main shapes that the transmission tree can assume, specified using\nthe `network_shape` argument. The first is a `branching` shape as shown above,\nwhere a straight edge connects any two nodes. This is the most intuitive\nrepresentation, however can result in overlapping edges in a densely connected\nnetwork. The second shape is `rectangle`, which produces a tree resembling a\nphylogeny. For example:\n\n```{r transmission_chains_rectangle,}\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n```\n\nEach case node can be assigned a unique vertical position by toggling the\n`position_dodge` argument. The position of unconnected cases (i.e. with no\nreported contacts) is specified using the `unlinked_pos` argument.\n\n```{r transmission_chains_dodge,}\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  position_dodge = TRUE,\n  unlinked_pos = \"bottom\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n```\n\nThe position of the parent node relative to the children nodes can be\nspecified using the `parent_pos` argument. The default option is to place the\nparent node in the middle, however it can be placed at the bottom (`parent_pos =\n'bottom'`) or at the top (`parent_pos = 'top'`).\n\n```{r transmission_chains_parent_pos,}\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  parent_pos = \"top\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n```\n\n#### Saving plots and figures {.unnumbered}\n\nYou can save a plot as an interactive, self-contained html file with the\n`visSave` function from the **VisNetwork** package:\n\n```{r transmission_chains_save, eval=F}\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  parent_pos = \"top\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n) %>%\n  visNetwork::visSave(\"network.html\")\n\n```\n\nSaving these network outputs as an image is unfortunately less easy and requires\nyou to save the file as an html and then take a screenshot of this file using\nthe `webshot` package. In the code below, we are converting the html file saved\nabove into a PNG:\n\n```{r transmission_chains_webshot, eval=F}\nwebshot(url = \"network.html\", file = \"network.png\")\n```\n\n### Timelines {.unnumbered}\n\nYou can also case timelines to the network, which are represented on the x-axis\nof each case. This can be used to visualise case locations, for example, or time\nto outcome. To generate a timeline, we need to create a data.frame of at least\nthree columns indicating the case ID, the start date of the \"event\" and the end\nof date of the \"event\". You can also add any number of other columns which can\nthen be mapped to node and edge properties of the timeline. In the code below,\nwe generate a timeline going from the date of symptom onset to the date of\noutcome, and keep the outcome and hospital variables which we use to define the\nnode shape and colour. Note that you can have more than one timeline row/event\nper case, for example if a case is transferred between multiple hospitals.\n\n```{r transmission_chains_create_timeline,}\n\n## generate timeline\ntimeline <- linelist %>%\n  transmute(\n    id = case_id,\n    start = date_onset,\n    end = date_outcome,\n    outcome = outcome,\n    hospital = hospital\n  )\n\n```\n\nWe then pass the timeline element to the `timeline` argument. We can map\ntimeline attributes to timeline node colours, shapes and sizes in the same way\ndefined in previous sections, except that we have _two_ nodes: the start and end\nnode of each timeline, which have seperate arguments. For example,\n`tl_start_node_color` defines which timeline column is mapped to the colour of\nthe start node, while `tl_end_node_shape` defines which timeline column is\nmapped to the shape of the end node. We can also map colour, width, linetype and\nlabels to the timeline _edge_ via the `tl_edge_*` arguments. \n\nSee `?vis_temporal_interactive` (the function called when plotting an\nepicontacts object) for detailed documentation on the arguments. Each argument\nis annotated in the code below too:\n\n```{r transmission_chains_vis_timeline,}\n\n## define shapes\nshapes <- c(\n  f = \"female\",\n  m = \"male\",\n  Death = \"user-times\",\n  Recover = \"heartbeat\",\n  \"NA\" = \"question-circle\"\n)\n\n## define colours\ncolours <- c(\n  Death = \"firebrick\",\n  Recover = \"green\",\n  \"NA\" = \"grey\"\n)\n\n## make plot\nplot(\n  sub,\n  ## max x coordinate to date of onset\n  x_axis = \"date_onset\",\n  ## use rectangular network shape\n  network_shape = \"rectangle\",\n  ## mape case node shapes to gender column\n  node_shape = \"gender\",\n  ## we don't want to map node colour to any columns - this is important as the\n  ## default value is to map to node id, which will mess up the colour scheme\n  node_color = NULL,\n  ## set case node size to 30 (as this is not a character, node_size is not\n  ## mapped to a column but instead interpreted as the actual node size)\n  node_size = 30,\n  ## set transmission link width to 4 (as this is not a character, edge_width is\n  ## not mapped to a column but instead interpreted as the actual edge width)\n  edge_width = 4,\n  ## provide the timeline object\n  timeline = timeline,\n  ## map the shape of the end node to the outcome column in the timeline object\n  tl_end_node_shape = \"outcome\",\n  ## set the size of the end node to 15 (as this is not a character, this\n  ## argument is not mapped to a column but instead interpreted as the actual\n  ## node size)\n  tl_end_node_size = 15,\n  ## map the colour of the timeline edge to the hospital column\n  tl_edge_color = \"hospital\",\n  ## set the width of the timeline edge to 2 (as this is not a character, this\n  ## argument is not mapped to a column but instead interpreted as the actual\n  ## edge width)\n  tl_edge_width = 2,\n  ## map edge labels to the hospital variable\n  tl_edge_label = \"hospital\",\n  ## specify the shape for everyone node attribute (defined above)\n  shapes = shapes,\n  ## specify the colour palette (defined above)\n  col_pal = colours,\n  ## set the size of the arrow to 0.5\n  arrow_size = 0.5,\n  ## use two columns in the legend\n  legend_ncol = 2,\n  ## set font size\n  font_size = 15,\n  ## define formatting for dates\n  date_labels = c(\"%d %b %Y\"),\n  ## don't plot the ID labels below nodes\n  label = FALSE,\n  ## specify height\n  height = 1000,\n  ## specify width\n  width = 1200,\n  ## ensure each case node has a unique y-coordinate - this is very important\n  ## when using timelines, otherwise you will have overlapping timelines from\n  ## different cases\n  position_dodge = TRUE\n)\n\n```\n\n<!-- ======================================================= -->\n## Analysis {  }\n\n### Summarising {.unnumbered}\n\nWe can get an overview of some of the network properties using the\n`summary` function.\n\n```{r transmission_chains_summarise_epicontacts,}\n## summarise epicontacts object\nsummary(epic)\n```\n\nFor example, we can see that only 57% of contacts have both cases in the\nlinelist; this means that the we do not have linelist data on a significant\nnumber of cases involved in these transmission chains.\n\n### Pairwise characteristics {.unnumbered}\n\nThe `get_pairwise()` function allows processing of variable(s) in the line list\naccording to each pair in the contact dataset. For the following example, date\nof onset of disease is extracted from the line list in order to compute the\ndifference between disease date of onset for each pair. The value that is\nproduced from this comparison represents the **serial interval (si)**.\n\n```{r transmission_chains_pairwise,}\nsi <- get_pairwise(epic, \"date_onset\")   \nsummary(si)\ntibble(si = si) %>%\n  ggplot(aes(si)) +\n  geom_histogram() +\n  labs(\n    x = \"Serial interval\",\n    y = \"Frequency\"\n  )\n```\n\nThe `get_pairwise()` will interpret the class of the column being used for\ncomparison, and will adjust its method of comparing the values accordingly. For\nnumbers and dates (like the **si** example above), the function will subtract\nthe values. When applied to columns that are characters or categorical,\n`get_pairwise()` will paste values together. Because the function also allows\nfor arbitrary processing (see \"f\" argument), these discrete combinations can be\neasily tabulated and analyzed.\n    \n```{r transmission_chains_pairwise_2,}\nhead(get_pairwise(epic, \"gender\"), n = 10)\nget_pairwise(epic, \"gender\", f = table)\nfisher.test(get_pairwise(epic, \"gender\", f = table))\n```\n\nHere, we see a significant association between transmission links and gender.\n\n### Identifying clusters {.unnumbered}\n\nThe `get_clusters()` function can be used for to identify connected components\nin an `epicontacts` object. First, we use it to retrieve a `data.frame`\ncontaining the cluster information:\n\n```{r transmission_chains_cluster,}\nclust <- get_clusters(epic, output = \"data.frame\")\ntable(clust$cluster_size)\nggplot(clust, aes(cluster_size)) +\n  geom_bar() +\n  labs(\n    x = \"Cluster size\",\n    y = \"Frequency\"\n  )\n```\n\nLet us look at the largest clusters. For this, we add cluster information to the\n`epicontacts` object and then subset it to keep only the largest clusters:\n\n```{r transmission_chains_cluster_2,}\nepic <- get_clusters(epic)\nmax_size <- max(epic$linelist$cluster_size)\nplot(subset(epic, cs = max_size))\n```\n\n### Calculating degrees {.unnumbered}\n\nThe degree of a node corresponds to its number of edges or connections to other\nnodes. `get_degree()` provides an easy method for calculating this value for\n`epicontacts` networks. A high degree in this context indicates an individual\nwho was in contact with many others. The `type` argument indicates that we want\nto count both the in-degree and out-degree, the `only_linelist` argument\nindicates that we only want to calculate the degree for cases in the linelist.\n\n```{r transmission_chains_degree,}\ndeg_both <- get_degree(epic, type = \"both\", only_linelist = TRUE)\n```\n\nWhich individuals have the ten most contacts?\n\n```{r}\nhead(sort(deg_both, decreasing = TRUE), 10)\n```\n\nWhat is the mean number of contacts?\n\n```{r}\nmean(deg_both)\n```\n\n<!-- ======================================================= -->\n## Resources {  }\n\nThe\n[epicontacts page](https://www.repidemicsconsortium.org/epicontacts/index.html)\nprovides an overview of the package functions and includes some more in-depth\nvignettes.\n\nThe [github page](http://github.com/reconhub/epicontacts) can be used to raise\nissues and request features.\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"transmission_chains.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.340","lightbox":true,"theme":{"light":"cosmo","dark":["cosmo","theme-dark.scss"]}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}