{"title":"Univariate and multivariable regression","markdown":{"headingText":"Univariate and multivariable regression","headingAttr":{"id":"","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n<!-- ======================================================= -->\n\nThis page demonstrates the use of **base** R regression functions such as `glm()` and the **gtsummary** package to \nlook at associations between variables (e.g. odds ratios, risk ratios and hazard\nratios). It also uses functions like `tidy()` from the **broom** package to clean-up regression outputs.  \n\n1.  Univariate: two-by-two tables \n2.  Stratified: mantel-haenszel estimates  \n3.  Multivariable: variable selection, model selection, final table\n4.  Forest plots\n\nFor Cox proportional hazard regression, see the [Survival analysis] page.  \n\n<span style=\"color: black;\">**_NOTE:_** We use the term *multivariable* to refer to a regression with multiple explanatory variables. In this sense a *multivariate* model would be a regression with several outcomes - see this [editorial](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3518362/) for detail </span> \n\n<!-- ======================================================= -->\n\n## Preparation {  }\n\n\n### Load packages {.unnumbered}\n\nThis code chunk shows the loading of packages required for the analyses. In this handbook we emphasize `p_load()` from **pacman**, which installs the package if necessary *and* loads it for use. You can also load installed packages with  `library()` from **base** R. See the page on [R basics] for more information on R packages.  \n\n```{r}\npacman::p_load(\n  rio,          # File import\n  here,         # File locator\n  tidyverse,    # data management + ggplot2 graphics, \n  stringr,      # manipulate text strings \n  purrr,        # loop over objects in a tidy way\n  gtsummary,    # summary statistics and tests \n  broom,        # tidy up results from regressions\n  lmtest,       # likelihood-ratio tests\n  parameters,   # alternative to tidy up results from regressions\n  see          # alternative to visualise forest plots\n  )\n```\n\n### Import data {.unnumbered}\n\nWe import the dataset of cases from a simulated Ebola epidemic. If you want to follow along, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>click to download the \"clean\" linelist</a> (as .rds file). Import your data with the `import()` function from the **rio** package (it accepts many file types like .xlsx, .rds, .csv - see the [Import and export] page for details).  \n\n\n```{r, echo=F}\n# import the linelist into R\nlinelist <- rio::import(here::here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))\n```\n\n```{r, eval=F}\n# import the linelist\nlinelist <- import(\"linelist_cleaned.rds\")\n```\n\nThe first 50 rows of the linelist are displayed below.\n\n```{r, message=FALSE, echo=F}\n# display the linelist data as a table\nDT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T) )\n```\n\n### Clean data {.unnumbered}\n\n#### Store explanatory variables {.unnumbered}  \n\nWe store the names of the explanatory columns as a character vector. This will be referenced later.  \n\n```{r}\n## define variables of interest \nexplanatory_vars <- c(\"gender\", \"fever\", \"chills\", \"cough\", \"aches\", \"vomit\")\n```\n\n\n#### Convert to 1's and 0's  {.unnumbered}   \n\nBelow we convert the explanatory columns from \"yes\"/\"no\", \"m\"/\"f\", and \"dead\"/\"alive\" to **1 / 0**, to cooperate with the expectations of logistic regression models. To do this efficiently, used `across()` from **dplyr** to transform multiple columns at one time. The function we apply to each column is `case_when()` (also **dplyr**) which applies logic to convert specified values to 1's and 0's. See sections on `across()` and `case_when()` in the [Cleaning data and core functions page](#clean_across)).  \n\nNote: the \".\" below represents the column that is being processed by `across()` at that moment.\n\n```{r}\n## convert dichotomous variables to 0/1 \nlinelist <- linelist %>%  \n  mutate(across(                                      \n    .cols = all_of(c(explanatory_vars, \"outcome\")),  ## for each column listed and \"outcome\"\n    .fns = ~case_when(                              \n      . %in% c(\"m\", \"yes\", \"Death\")   ~ 1,           ## recode male, yes and death to 1\n      . %in% c(\"f\", \"no\",  \"Recover\") ~ 0,           ## female, no and recover to 0\n      TRUE                            ~ NA_real_)    ## otherwise set to missing\n    )\n  )\n\n       \n      \n```\n\n#### Drop rows with missing values {.unnumbered}  \n\nTo drop rows with missing values, can use the **tidyr** function `drop_na()`. However, we only want to do this for rows that are missing values in the columns of interest.  \n\nThe first thing we must to is make sure our `explanatory_vars` vector includes the column `age` (`age` would have produced an error in the previous `case_when()` operation, which was only for dichotomous variables). Then we pipe the `linelist` to `drop_na()` to remove any rows with missing values in the `outcome` column or any of the `explanatory_vars` columns.  \n\nBefore running the code, the number of rows in the `linelist` is ` nrow(linelist)`.  \n\n```{r}\n## add in age_category to the explanatory vars \nexplanatory_vars <- c(explanatory_vars, \"age_cat\")\n\n## drop rows with missing information for variables of interest \nlinelist <- linelist %>% \n  drop_na(any_of(c(\"outcome\", explanatory_vars)))\n\n```\n\nThe number of rows remaining in `linelist` is ` nrow(linelist)`.  \n\n\n<!-- ======================================================= -->\n\n## Univariate {  }\n\nJust like in the page on [Descriptive tables](https://epirhandbook.com/descriptive-tables.html), your use case will determine which R package you use. We present two options for doing univariate analysis:  \n\n* Use functions available in **base** R to quickly print results to the console. Use the **broom** package to tidy up the outputs.  \n* Use the **gtsummary** package to model and get publication-ready outputs  \n\n\n\n<!-- ======================================================= -->\n\n### **base** R {.unnumbered}\n\n#### Linear regression {.unnumbered}  \n\nThe **base** R function `lm()` perform linear regression, assessing the relationship between numeric response and explanatory variables that are assumed to have a linear relationship.  \n\nProvide the equation as a formula, with the response and explanatory column names separated by a tilde `~`. Also, specify the dataset to `data = `. Define the model results as an R object, to use later.    \n\n```{r lin_reg}\nlm_results <- lm(ht_cm ~ age, data = linelist)\n```\n\nYou can then run `summary()` on the model results to see the coefficients (Estimates), P-value, residuals, and other measures.  \n\n```{r lin_reg_res}\nsummary(lm_results)\n```\n\nAlternatively you can use the `tidy()` function from the **broom** package to pull \nthe results in to a table. What the results tell us is that for each year increase in age the height increases\nby 3.5 cm and this is statistically significant. \n\n```{r lin_reg_res_tidy}\ntidy(lm_results)\n```\n\nYou can then also use this regression to add it to a **ggplot**, to do this we \nfirst pull the points for the observed data and the fitted line in to one data frame \nusing the `augment()` function from **broom**. \n\n```{r lin_reg_res_plot}\n\n## pull the regression points and observed data in to one dataset\npoints <- augment(lm_results)\n\n## plot the data using age as the x-axis \nggplot(points, aes(x = age)) + \n  ## add points for height \n  geom_point(aes(y = ht_cm)) + \n  ## add your regression line \n  geom_line(aes(y = .fitted), colour = \"red\")\n\n```\n\nIt is also possible to add a simple linear regression straight straight in **ggplot** \nusing the `geom_smooth()` function. \n\n```{r geom_smooth}\n\n## add your data to a plot \n ggplot(linelist, aes(x = age, y = ht_cm)) + \n  ## show points\n  geom_point() + \n  ## add a linear regression \n  geom_smooth(method = \"lm\", se = FALSE)\n```\n\nSee the Resource section at the end of this chapter for more detailed tutorials.  \n\n\n#### Logistic regression {.unnumbered}  \n\nThe function `glm()` from the **stats** package (part of **base** R) is used to fit Generalized Linear Models (GLM).  \n\n`glm()` can be used for univariate and multivariable logistic regression (e.g. to get Odds Ratios). Here are the core parts:  \n\n```{r, eval=F}\n# arguments for glm()\nglm(formula, family, data, weights, subset, ...)\n```\n\n* `formula = ` The model is provided to `glm()` as an equation, with the outcome on the left and explanatory variables on the right of a tilde `~`.  \n* `family = ` This determines the type of model to run. For logistic regression, use `family = \"binomial\"`, for poisson use `family = \"poisson\"`. Other examples are in the table below.  \n* `data = ` Specify your data frame  \n\n\nIf necessary, you can also specify the link function via the syntax `family = familytype(link = \"linkfunction\"))`. You can read more in the documentation about other families and optional arguments such as `weights = ` and `subset = ` (`?glm`).  \n\n\n\nFamily                 | Default link function \n-----------------------|-------------------------------------------  \n`\"binomial\"` | `(link = \"logit\")`  \n`\"gaussian\"` | `(link = \"identity\")`  \n`\"Gamma\"` | `(link = \"inverse\")`  \n`\"inverse.gaussian\"` | `(link = \"1/mu^2\")`  \n`\"poisson\"` | `(link = \"log\")`  \n`\"quasi\"` | `(link = \"identity\", variance = \"constant\")`  \n`\"quasibinomial\"` | `(link = \"logit\")`  \n`\"quasipoisson\"` | `(link = \"log\")`  \n\n\nWhen running `glm()` it is most common to save the results as a named R object. Then you can print the results to your console using `summary()` as shown below, or perform other operations on the results (e.g. exponentiate).  \n\nIf you need to run a negative binomial regression you can use the **MASS** package; the `glm.nb()` uses the same syntax as `glm()`. \nFor a walk-through of different regressions, see the [UCLA stats page](https://stats.idre.ucla.edu/other/dae/). \n\n#### Univariate `glm()` {.unnumbered}\n\nIn this example we are assessing the association between different age categories and the outcome of death (coded as 1 in the Preparation section). Below is a univariate model of `outcome` by `age_cat`. We save the model output as `model` and then print it with `summary()` to the console. Note the estimates provided are the *log odds* and that the baseline level is the first factor level of `age_cat` (\"0-4\").  \n\n```{r}\nmodel <- glm(outcome ~ age_cat, family = \"binomial\", data = linelist)\nsummary(model)\n```\n\nTo alter the baseline level of a given variable, ensure the column is class Factor and move the desired level to the first position with `fct_relevel()` (see page on [Factors]). For example, below we take column `age_cat` and set \"20-29\" as the baseline before piping the modified data frame into `glm()`.  \n\n```{r}\nlinelist %>% \n  mutate(age_cat = fct_relevel(age_cat, \"20-29\", after = 0)) %>% \n  glm(formula = outcome ~ age_cat, family = \"binomial\") %>% \n  summary()\n```\n\n#### Printing results {.unnumbered}\n\nFor most uses, several modifications must be made to the above outputs. The function `tidy()` from the package **broom** is convenient for making the model results presentable.  \n\nHere we demonstrate how to combine model outputs with a table of counts.  \n\n1) Get the *exponentiated* log odds ratio estimates and confidence intervals by passing the model to `tidy()` and setting `exponentiate = TRUE` and `conf.int = TRUE`.  \n\n```{r odds_base_single}\n\nmodel <- glm(outcome ~ age_cat, family = \"binomial\", data = linelist) %>% \n  tidy(exponentiate = TRUE, conf.int = TRUE) %>%        # exponentiate and produce CIs\n  mutate(across(where(is.numeric), round, digits = 2))  # round all numeric columns\n```\n\nBelow is the outputted tibble `model`:  \n\n```{r, message=FALSE, echo=F}\n# display the linelist data as a table\nDT::datatable(model, rownames = FALSE, options = list(pageLength = nrow(model), scrollX=T), class = 'white-space: nowrap' )\n```\n\n2) Combine these model results with a table of counts. Below, we create the a counts cross-table with the `tabyl()` function from **janitor**, as covered in the [Descriptive tables] page.  \n\n```{r}\ncounts_table <- linelist %>% \n  janitor::tabyl(age_cat, outcome)\n```\n\n\n<!-- * Group rows by outcome, and get counts by age category   -->\n<!-- * Pivot wider so the column are `age_cat`, `0`, and `1`   -->\n<!-- * Remove row for `NA` `age_cat`, if applicable, to align with the model results   -->\n\n<!-- ```{r} -->\n<!-- counts_table <- linelist %>%  -->\n<!--   filter(!is.na(outcome) & !is.na(age_cat)) %>%    # ensure outcome and age_cat are present  -->\n<!--   group_by(outcome) %>%                            # get counts of variable of interest grouped by outcome -->\n<!--   count(age_cat) %>%   ## gets number or rows by unique outcome-age category combinations   -->\n<!--   pivot_wider(names_from = outcome, values_from = n)    ## spread data to wide format (as in cross-tabulation) -->\n\n<!-- ``` -->\n\n\nHere is what this `counts_table` data frame looks like:  \n\n```{r, message=FALSE, echo=F}\n# display the linelist data as a table\nDT::datatable(counts_table, rownames = FALSE, options = list(pageLength = nrow(counts_table), scrollX=T), class = 'white-space: nowrap' )\n```\n\nNow we can bind the `counts_table` and the `model` results together horizontally with `bind_cols()` (**dplyr**). Remember that with `bind_cols()` the rows in the two data frames must be aligned perfectly. In this code, because we are binding within a pipe chain, we use `.` to represent the piped object `counts_table` as we bind it to `model`. To finish the process, we use `select()` to pick the desired columns and their order, and finally apply the **base** R `round()` function across all numeric columns to specify 2 decimal places.  \n\n```{r, message=F, warning=F}\ncombined <- counts_table %>%           # begin with table of counts\n  bind_cols(., model) %>%              # combine with the outputs of the regression \n  select(term, 2:3, estimate,          # select and re-order cols\n         conf.low, conf.high, p.value) %>% \n  mutate(across(where(is.numeric), round, digits = 2)) ## round to 2 decimal places\n```\n\nHere is what the combined data frame looks like, printed nicely as an image with a function from **flextable**. The [Tables for presentation] explains how to customize such tables with **flextable**, or or you can use numerous other packages such as **knitr** or **GT**.  \n\n```{r}\ncombined <- combined %>% \n  flextable::qflextable()\n```\n\n\n#### Looping multiple univariate models {.unnumbered}  \n\nBelow we present a method using `glm()` and `tidy()` for a more simple approach, see the section on **gtsummary**.  \n\nTo run the models on several exposure variables to produce univariate odds ratios (i.e. not controlling for each other), you can use the approach below. It uses `str_c()` from **stringr** to create univariate formulas (see [Characters and strings]), runs the `glm()` regression on each formula, passes each `glm()` output to `tidy()` and finally collapses all the model outputs together with `bind_rows()` from **tidyr**. This approach uses `map()` from the package **purrr** to iterate - see the page on [Iteration, loops, and lists] for more information on this tool.  \n\n1) Create a vector of column names of the explanatory variables. We already have this as `explanatory_vars` from the Preparation section of this page.  \n\n2) Use `str_c()` to create multiple string formulas, with `outcome` on the left, and a column name from `explanatory_vars` on the right. The period `.` substitutes for the column name in `explanatory_vars`.  \n\n```{r}\nexplanatory_vars %>% str_c(\"outcome ~ \", .)\n```\n\n3) Pass these string formulas to `map()` and set `~glm()` as the function to apply to each input. Within `glm()`, set the regression formula as `as.formula(.x)` where `.x` will be replaced by the string formula defined in the step above. `map()` will loop over each of the string formulas, running regressions for each one.  \n\n4) The outputs of this first `map()` are passed to a second `map()` command, which applies `tidy()` to the regression outputs.  \n\n5) Finally the output of the second `map()` (a list of tidied data frames) is condensed with `bind_rows()`, resulting in one data frame with all the univariate results.  \n\n\n```{r odds_base_multiple}\n\nmodels <- explanatory_vars %>%       # begin with variables of interest\n  str_c(\"outcome ~ \", .) %>%         # combine each variable into formula (\"outcome ~ variable of interest\")\n  \n  # iterate through each univariate formula\n  map(                               \n    .f = ~glm(                       # pass the formulas one-by-one to glm()\n      formula = as.formula(.x),      # within glm(), the string formula is .x\n      family = \"binomial\",           # specify type of glm (logistic)\n      data = linelist)) %>%          # dataset\n  \n  # tidy up each of the glm regression outputs from above\n  map(\n    .f = ~tidy(\n      .x, \n      exponentiate = TRUE,           # exponentiate \n      conf.int = TRUE)) %>%          # return confidence intervals\n  \n  # collapse the list of regression outputs in to one data frame\n  bind_rows() %>% \n  \n  # round all numeric columns\n  mutate(across(where(is.numeric), round, digits = 2))\n```\n\nThis time, the end object `models` is longer because it now represents the combined results of several univariate regressions. Click through to see all the rows of `model`.  \n\n```{r, message=FALSE, echo=F}\n# display the linelist data as a table\nDT::datatable(models, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )\n```\n\nAs before, we can create a counts table from the `linelist` for each explanatory variable, bind it to `models`, and make a nice table. We begin with the variables, and iterate through them with `map()`. We iterate through a user-defined function which involves creating a counts table with **dplyr** functions. Then the results are combined and bound with the `models` model results.  \n\n\n```{r, warning=F, message=F}\n\n## for each explanatory variable\nuniv_tab_base <- explanatory_vars %>% \n  map(.f = \n    ~{linelist %>%                ## begin with linelist\n        group_by(outcome) %>%     ## group data set by outcome\n        count(.data[[.x]]) %>%    ## produce counts for variable of interest\n        pivot_wider(              ## spread to wide format (as in cross-tabulation)\n          names_from = outcome,\n          values_from = n) %>% \n        drop_na(.data[[.x]]) %>%         ## drop rows with missings\n        rename(\"variable\" = .x) %>%      ## change variable of interest column to \"variable\"\n        mutate(variable = as.character(variable))} ## convert to character, else non-dichotomous (categorical) variables come out as factor and cant be merged\n      ) %>% \n  \n  ## collapse the list of count outputs in to one data frame\n  bind_rows() %>% \n  \n  ## merge with the outputs of the regression \n  bind_cols(., models) %>% \n  \n  ## only keep columns interested in \n  select(term, 2:3, estimate, conf.low, conf.high, p.value) %>% \n  \n  ## round decimal places\n  mutate(across(where(is.numeric), round, digits = 2))\n\n```\n\nBelow is what the data frame looks like. See the page on [Tables for presentation] for ideas on how to further convert this table to pretty HTML output (e.g. with **flextable**).  \n\n```{r, message=FALSE, echo=F}\n# display the linelist data as a table\nDT::datatable(univ_tab_base, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )\n```\n\n\n\n\n\n<!-- ======================================================= -->\n\n### **gtsummary** package {#reg_gt_uni .unnumbered}\n\nBelow we present the use of `tbl_uvregression()` from the **gtsummary** package. Just like in the page on [Descriptive tables](https://epirhandbook.com/descriptive-tables.html), **gtsummary** functions do a good job of running statistics *and* producing professional-looking outputs. This function produces a table of univariate regression results.  \n\nWe select only the necessary columns from the `linelist` (explanatory variables and the outcome variable) and  pipe them into `tbl_uvregression()`. We are going to run univariate regression on each of the columns we defined as `explanatory_vars` in the data Preparation section (gender, fever, chills, cough, aches, vomit, and age_cat).  \n\nWithin the function itself, we provide the `method = ` as `glm` (no quotes), the `y = ` outcome column (`outcome`), specify to `method.args = ` that we want to run logistic regression via `family = binomial`, and we tell it to exponentiate the results.  \n\nThe output is HTML and contains the counts\n\n```{r odds_gt, message=F, warning=F}\n\nuniv_tab <- linelist %>% \n  dplyr::select(explanatory_vars, outcome) %>% ## select variables of interest\n\n  tbl_uvregression(                         ## produce univariate table\n    method = glm,                           ## define regression want to run (generalised linear model)\n    y = outcome,                            ## define outcome variable\n    method.args = list(family = binomial),  ## define what type of glm want to run (logistic)\n    exponentiate = TRUE                     ## exponentiate to produce odds ratios (rather than log odds)\n  )\n\n## view univariate results table \nuniv_tab\n```\n\nThere are many modifications you can make to this table output, such as adjusting the text labels, bolding rows by their p-value, etc. See tutorials [here](http://www.danieldsjoberg.com/gtsummary/articles/tbl_regression.html) and elsewhere online.  \n\n\n\n<!-- ======================================================= -->\n\n## Stratified {  }\n\nStratified analysis is currently still being worked on for **gtsummary**, \nthis page will be updated in due course. \n\n\n\n\n## Multivariable  \n\nFor multivariable analysis, we again present two approaches:  \n\n* `glm()` and `tidy()`  \n* **gtsummary** package  \n\nThe workflow is similar for each and only the last step of pulling together a final table is different.\n\n\n### Conduct multivariable {.unnumbered}  \n\n\nHere we use `glm()` but add more variables to the right side of the equation, separated by plus symbols (`+`). \n\n\nTo run the model with all of our explanatory variables we would run:  \n\n```{r}\nmv_reg <- glm(outcome ~ gender + fever + chills + cough + aches + vomit + age_cat, family = \"binomial\", data = linelist)\n\nsummary(mv_reg)\n```\n\nIf you want to include two variables and an interaction between them you can separate them with an asterisk `*` instead of a `+`. Separate them with a colon `:` if you are only specifying the interaction. For example:  \n\n```{r, eval=F}\nglm(outcome ~ gender + age_cat * fever, family = \"binomial\", data = linelist)\n```\n\n\n*Optionally*, you can use this code to leverage the pre-defined vector of column names and re-create the above command using `str_c()`. This might be useful if your explanatory variable names are changing, or you don't want to type them all out again.  \n\n```{r mv_regression}\n\n## run a regression with all variables of interest \nmv_reg <- explanatory_vars %>%  ## begin with vector of explanatory column names\n  str_c(collapse = \"+\") %>%     ## combine all names of the variables of interest separated by a plus\n  str_c(\"outcome ~ \", .) %>%    ## combine the names of variables of interest with outcome in formula style\n  glm(family = \"binomial\",      ## define type of glm as logistic,\n      data = linelist)          ## define your dataset\n```\n\n\n#### Building the model {.unnumbered}  \n\nYou can build your model step-by-step, saving various models that include certain explanatory variables. You can compare these models with likelihood-ratio tests using `lrtest()` from the package **lmtest**, as below:  \n\n<span style=\"color: black;\">**_NOTE:_** Using **base** `anova(model1, model2, test = \"Chisq)` produces the same results </span> \n\n```{r}\nmodel1 <- glm(outcome ~ age_cat, family = \"binomial\", data = linelist)\nmodel2 <- glm(outcome ~ age_cat + gender, family = \"binomial\", data = linelist)\n\nlmtest::lrtest(model1, model2)\n```\n\nAnother option is to take the model object and apply the `step()` function from the **stats** package. Specify which variable selection direction you want use when building the model.      \n\n```{r}\n## choose a model using forward selection based on AIC\n## you can also do \"backward\" or \"both\" by adjusting the direction\nfinal_mv_reg <- mv_reg %>%\n  step(direction = \"forward\", trace = FALSE)\n```\n\n\nYou can also turn off scientific notation in your R session, for clarity:  \n\n```{r}\noptions(scipen=999)\n```\n\nAs described in the section on univariate analysis, pass the model output to `tidy()` to exponentiate the log odds and CIs. Finally we round all numeric columns to two decimal places. Scroll through to see all the rows.  \n\n```{r mv_regression_base}\n\nmv_tab_base <- final_mv_reg %>% \n  broom::tidy(exponentiate = TRUE, conf.int = TRUE) %>%  ## get a tidy dataframe of estimates \n  mutate(across(where(is.numeric), round, digits = 2))          ## round \n```\n\nHere is what the resulting data frame looks like: \n\n```{r, message=FALSE, echo=F}\nDT::datatable(mv_tab_base, rownames = FALSE, options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )\n```\n\n\n\n\n\n<!-- ======================================================= -->\n\n### Combine univariate and multivariable {.unnumbered}\n\n#### Combine with **gtsummary**  {.unnumbered}  \n\nThe **gtsummary** package provides the `tbl_regression()` function, which will \ntake the outputs from a regression (`glm()` in this case) and produce an nice \nsummary table. \n\n```{r mv_regression_gt}\n## show results table of final regression \nmv_tab <- tbl_regression(final_mv_reg, exponentiate = TRUE)\n```\n\nLet's see the table:  \n\n```{r}\nmv_tab\n```\n\nYou can also combine several different output tables produced by **gtsummary** with \nthe `tbl_merge()` function. We now combine the multivariable results with the **gtsummary** *univariate* results that we created [above](#reg_gt_uni):  \n\n```{r}\n## combine with univariate results \ntbl_merge(\n  tbls = list(univ_tab, mv_tab),                          # combine\n  tab_spanner = c(\"**Univariate**\", \"**Multivariable**\")) # set header names\n```\n\n\n\n#### Combine with **dplyr** {.unnumbered}  \n\nAn alternative way of combining the `glm()`/`tidy()` univariate and multivariable outputs is with the **dplyr** join functions.  \n\n* Join the univariate results from earlier (`univ_tab_base`, which contains counts) with the tidied multivariable results `mv_tab_base`  \n* Use `select()` to keep only the columns we want, specify their order, and re-name them  \n* Use `round()` with two decimal places on all the column that are class Double  \n\n```{r, warning=F, message=F}\n## combine univariate and multivariable tables \nleft_join(univ_tab_base, mv_tab_base, by = \"term\") %>% \n  ## choose columns and rename them\n  select( # new name =  old name\n    \"characteristic\" = term, \n    \"recovered\"      = \"0\", \n    \"dead\"           = \"1\", \n    \"univ_or\"        = estimate.x, \n    \"univ_ci_low\"    = conf.low.x, \n    \"univ_ci_high\"   = conf.high.x,\n    \"univ_pval\"      = p.value.x, \n    \"mv_or\"          = estimate.y, \n    \"mvv_ci_low\"     = conf.low.y, \n    \"mv_ci_high\"     = conf.high.y,\n    \"mv_pval\"        = p.value.y \n  ) %>% \n  mutate(across(where(is.double), round, 2))   \n\n```\n\n\n\n\n<!-- ======================================================= -->\n\n## Forest plot {  }\n\nThis section shows how to produce a plot with the outputs of your regression.\nThere are two options, you can build a plot yourself using **ggplot2** or use a \nmeta-package called **easystats** (a package that includes many packages).  \n\nSee the page on [ggplot basics] if you are unfamiliar with the **ggplot2** plotting package.  \n\n\n<!-- ======================================================= -->\n\n### **ggplot2** package {.unnumbered}\n\nYou can build a forest plot with `ggplot()` by plotting elements of the multivariable regression results. Add the layers of the plots using these \"geoms\":  \n\n* estimates with `geom_point()`  \n* confidence intervals with `geom_errorbar()`  \n* a vertical line at OR = 1 with `geom_vline()`  \n\nBefore plotting, you may want to use `fct_relevel()` from the **forcats** package to set the order of the variables/levels on the y-axis. `ggplot()` may display them in alpha-numeric order which would not work well for these age category values (\"30\" would appear before \"5\"). See the page on [Factors] for more details.  \n\n```{r ggplot_forest}\n\n## remove the intercept term from your multivariable results\nmv_tab_base %>% \n  \n  #set order of levels to appear along y-axis\n  mutate(term = fct_relevel(\n    term,\n    \"vomit\", \"gender\", \"fever\", \"cough\", \"chills\", \"aches\",\n    \"age_cat5-9\", \"age_cat10-14\", \"age_cat15-19\", \"age_cat20-29\",\n    \"age_cat30-49\", \"age_cat50-69\", \"age_cat70+\")) %>%\n  \n  # remove \"intercept\" row from plot\n  filter(term != \"(Intercept)\") %>% \n  \n  ## plot with variable on the y axis and estimate (OR) on the x axis\n  ggplot(aes(x = estimate, y = term)) +\n  \n  ## show the estimate as a point\n  geom_point() + \n  \n  ## add in an error bar for the confidence intervals\n  geom_errorbar(aes(xmin = conf.low, xmax = conf.high)) + \n  \n  ## show where OR = 1 is for reference as a dashed line\n  geom_vline(xintercept = 1, linetype = \"dashed\")\n  \n```\n\n\n<!-- ======================================================= -->\n\n### **easystats** packages {.unnumbered}\n\nAn alternative, if you do not want to the fine level of control that **ggplot2** provides, is to use a combination of **easystats** packages.  \n\nThe function `model_parameters()` from the **parameters** package does the equivalent\nof the **broom** package function `tidy()`. The **see** package then accepts those outputs\nand creates a default forest plot as a `ggplot()` object. \n\n```{r easystats_forest}\npacman::p_load(easystats)\n\n## remove the intercept term from your multivariable results\nfinal_mv_reg %>% \n  model_parameters(exponentiate = TRUE) %>% \n  plot()\n  \n```\n\n\n<!-- ======================================================= -->\n\n## Resources {  }\n\nThe content of this page was informed by these resources and vignettes online:  \n\n[Linear regression in R](https://www.datacamp.com/community/tutorials/linear-regression-R)  \n\n[gtsummary](http://www.danieldsjoberg.com/gtsummary/articles/tbl_regression.html)  \n\n[UCLA stats page](https://stats.idre.ucla.edu/other/dae/)  \n\n[sthda stepwise regression](http://www.sthda.com/english/articles/36-classification-methods-essentials/150-stepwise-logistic-regression-essentials-in-r/)   \n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"regression.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.340","lightbox":true,"theme":{"light":"cosmo","dark":["cosmo","theme-dark.scss"]}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}