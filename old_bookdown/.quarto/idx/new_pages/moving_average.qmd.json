{"title":"Moving averages","markdown":{"headingText":"Moving averages","headingAttr":{"id":"","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n```{r, out.width=c(\"100%\"), echo=F}\nknitr::include_graphics(here::here(\"images\", \"moving_avg_epicurve.png\"))\n```\n\n\nThis page will cover two methods to calculate and visualize moving averages:  \n\n1) Calculate with the **slider** package  \n2) Calculate *within* a `ggplot()` command with the **tidyquant** package  \n\n\n\n<!-- ======================================================= -->\n## Preparation {  }\n\n### Load packages {.unnumbered}\n\nThis code chunk shows the loading of packages required for the analyses. In this handbook we emphasize `p_load()` from **pacman**, which installs the package if necessary *and* loads it for use. You can also load installed packages with  `library()` from **base** R. See the page on [R basics] for more information on R packages. \n\n\n```{r}\npacman::p_load(\n  tidyverse,      # for data management and viz\n  slider,         # for calculating moving averages\n  tidyquant       # for calculating moving averages within ggplot\n)\n```\n\n\n### Import data {.unnumbered}\n\nWe import the dataset of cases from a simulated Ebola epidemic. If you want to follow along, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>click to download the \"clean\" linelist</a> (as .rds file). Import data with the `import()` function from the **rio** package (it handles many file types like .xlsx, .csv, .rds - see the [Import and export] page for details).  \n\n\n```{r, echo=F}\n# import the linelist into R\nlinelist <- rio::import(here::here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))\n```\n\n```{r, eval=F}\n# import the linelist\nlinelist <- import(\"linelist_cleaned.xlsx\")\n```\n\nThe first 50 rows of the linelist are displayed below.\n\n```{r, message=FALSE, echo=F}\n# display the linelist data as a table\nDT::datatable(head(linelist, 50), rownames = FALSE, filter=\"top\", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )\n```\n\n\n<!-- ======================================================= -->\n## Calculate with **slider** {  }\n\n**Use this approach to calculate a moving average in a data frame prior to plotting.**  \n\nThe **slider** package provides several \"sliding window\" functions to compute rolling averages, cumulative sums, rolling regressions, etc. It treats a data frame as a vector of rows, allowing iteration row-wise over a data frame.   \n\nHere are some of the common functions:  \n\n* `slide_dbl()` - iterates through a *numeric* (hence \"_dbl\") column performing an operation using a sliding window  \n  * `slide_sum()` - rolling sum shortcut function for `slide_dbl()`  \n  * `slide_mean()` - rolling average shortcut function for `slide_dbl()` \n* `slide_index_dbl()` - applies the rolling window on a numeric column using a separate column to *index* the window progression (useful if rolling by date with some dates absent)  \n  * `slide_index_sum()` - rolling sum shortcut function with indexing  \n  * `slide_index_mean()` - rolling mean shortcut function with indexing  \n  \nThe **slider** package has many other functions that are covered in the Resources section of this page. We briefly touch upon the most common.  \n\n**Core arguments**  \n\n* `.x`, the first argument by default, is the vector to iterate over and to apply the function to  \n* `.i = ` for the \"index\" versions of the **slider** functions - provide a column to \"index\" the roll on (see section [below](#roll_index))  \n* `.f = `, the second argument by default, either:  \n  * A function, written without parentheses, like `mean`, or  \n  * A formula, which will be converted into a function. For example `~ .x - mean(.x)` will return the result of the current value minus the mean of the window's value  \n  \n* For more details see this [reference material](https://davisvaughan.github.io/slider/reference/slide.html)\n\n\n\n**Window size**  \n\nSpecify the size of the window by using either `.before`, `.after`, or both arguments:   \n\n* `.before = ` - Provide an integer  \n* `.after = ` - Provide an integer  \n* `.complete = ` - Set this to `TRUE` if you only want calculation performed on complete windows  \n\nFor example, to achieve a 7-day window including the current value and the six previous, use `.before = 6`. To achieve a \"centered\" window provide the same number to both `.before = ` and `.after = `.    \n\nBy default, `.complete = ` will be FALSE so if the full window of rows does not exist, the functions will use available rows to perform the calculation. Setting to TRUE restricts so calculations are only performed on complete windows.  \n\n**Expanding window**  \n\nTo achieve *cumulative* operations, set the `.before = ` argument to `Inf`. This will conduct the operation on the current value and all coming before.  \n\n\n\n\n\n### Rolling by date  {#roll_index .unnumbered}  \n\nThe most likely use-case of a rolling calculation in applied epidemiology is to examine a metric *over time*. For example, a rolling measurement of case incidence, based on daily case counts. \n\nIf you have clean time series data with values for every date, you may be OK to use `slide_dbl()`, as demonstrated here in the [Time series and outbreak detection](#timeseries_moving) page.  \n\nHowever, in many applied epidemiology circumstances you may have dates absent from your data, where there are no events recorded. In these cases, it is best to use the \"index\" versions of the **slider** functions.  \n\n\n### Indexed data {.unnumbered}  \n\nBelow, we show an example using `slide_index_dbl()` on the case linelist. Let us say that our objective is to calculate a rolling 7-day incidence - the sum of cases using a rolling 7-day window. If you are looking for an example of rolling average, see the section below on [grouped rolling](#roll_slider_group).    \n\nTo begin, the dataset `daily_counts` is created to reflect the daily case counts from the `linelist`, as calculated with `count()` from **dplyr**.  \n\n```{r}\n# make dataset of daily counts\ndaily_counts <- linelist %>% \n  count(date_hospitalisation, name = \"new_cases\")\n```\n\n\nHere is the `daily_counts` data frame - there are ` nrow(daily_counts)` rows, each day is represented by one row, but especially early in the epidemic *some days are not present (there were no cases admitted on those days)*.  \n\n\n```{r, echo=F}\nDT::datatable(daily_counts, rownames = FALSE, options = list(pageLength = 6, scrollX=T) )\n```\n\n\n\nIt is crucial to recognize that a standard rolling function (like `slide_dbl()` would use a window of 7 *rows*, not 7 *days*. So, if there are any absent dates, some windows will actually extend more than 7 calendar days!  \n\nA \"smart\" rolling window can be achieved with `slide_index_dbl()`. The \"index\" means that the function uses a *separate column* as an \"index\" for the rolling window. The window is not simply based on the rows of the data frame.  \n\nIf the index column is a date, you have the added ability to specify the window extent to `.before = ` and/or `.after = ` in units of **lubridate** `days()` or `months()`. If you do these things, the function will include absent days in the windows as if they were there (as `NA` values).  \n\nLet's show a comparison. Below, we calculate rolling 7-day case incidence with regular and indexed windows.  \n\n\n```{r}\nrolling <- daily_counts %>% \n  mutate(                                # create new columns\n    # Using slide_dbl()\n    ###################\n    reg_7day = slide_dbl(\n      new_cases,                         # calculate on new_cases\n      .f = ~sum(.x, na.rm = T),          # function is sum() with missing values removed\n      .before = 6),                      # window is the ROW and 6 prior ROWS\n    \n    # Using slide_index_dbl()\n    #########################\n    indexed_7day = slide_index_dbl(\n        new_cases,                       # calculate on new_cases\n        .i = date_hospitalisation,       # indexed with date_onset \n        .f = ~sum(.x, na.rm = TRUE),     # function is sum() with missing values removed\n        .before = days(6))               # window is the DAY and 6 prior DAYS\n    )\n\n```\n\nObserve how in the regular column for the first 7 rows the count steadily increases *despite the rows not being within 7 days of each other*! The adjacent \"indexed\" column accounts for these absent calendar days, so its 7-day sums are much lower, at least in this period of the epidemic when the cases a farther between.  \n\n```{r, echo=F}\nDT::datatable(rolling, rownames = FALSE, options = list(pageLength = 12, scrollX=T) )\n```\n\n\n\nNow you can plot these data using `ggplot()`:  \n\n```{r}\nggplot(data = rolling)+\n  geom_line(mapping = aes(x = date_hospitalisation, y = indexed_7day), size = 1)\n```\n\n\n\n\n<!-- ### Rolling by month {.unnumbered}   -->\n\n<!-- If you want to calculate statistics by month (e.g. sum, mean, max) you can do this with **dplyr** as described in the [Grouping data] page. Simply create a \"month\" column, group the data, and run your calculations with `summarise()`.   -->\n\n<!-- If however, you want to calculate rolling statistics over several months (e.g a 2-month rolling window), you can use the `slide_period()` function from **slider**.   -->\n\n<!-- ```{r} -->\n<!-- monthly_mean = function(data){ -->\n<!--   summarise(data, mean = mean(new_cases, na.rm=T)) -->\n<!-- } -->\n\n<!-- linelist %>%  -->\n<!--   count(date_hospitalisation, name = \"new_cases\") %>%  -->\n<!--   mutate( -->\n<!--     slide_period_dfr( -->\n<!--       new_cases,  -->\n<!--       .i = date_hospitalisation, -->\n<!--       .period = \"month\", -->\n<!--       .f = monthly_mean))  #~mean(.x, na.rm=T))) -->\n\n<!--       #values_col = new_cases, -->\n<!--       #index_col = date_hospitalisation -->\n<!--     )) -->\n\n\n\n<!-- ``` -->\n\n\n### Rolling by group {#roll_slider_group .unnumbered}  \n\nIf you group your data prior to using a **slider** function, the sliding windows will be applied by group. Be careful to arrange your rows in the desired order *by group*.  \n\nEach time a new group begins, the sliding window will re-start. Therefore, one nuance to be aware of is that if your data are grouped *and* you have set `.complete = TRUE`, you will have empty values at each transition between groups. As the function moved downward through the rows, every transition in the grouping column will re-start the accrual of the minimum window size to allow a calculation.  \n\nSee handbook page on [Grouping data] for details on grouping data.\n\nBelow, we count linelist cases by date *and* by hospital. Then we arrange the rows in ascending order, first ordering by hospital and then within that by date. Next we set `group_by()`. Then we can create our new rolling average. \n\n\n```{r}\ngrouped_roll <- linelist %>%\n\n  count(hospital, date_hospitalisation, name = \"new_cases\") %>% \n\n  arrange(hospital, date_hospitalisation) %>%   # arrange rows by hospital and then by date\n  \n  group_by(hospital) %>%              # group by hospital \n    \n  mutate(                             # rolling average  \n    mean_7day_hosp = slide_index_dbl(\n      .x = new_cases,                 # the count of cases per hospital-day\n      .i = date_hospitalisation,      # index on date of admission\n      .f = mean,                      # use mean()                   \n      .before = days(6)               # use the day and the 6 days prior\n      )\n  )\n\n```\n\nHere is the new dataset:  \n\n```{r, echo=F}\nDT::datatable(grouped_roll, rownames = FALSE, options = list(pageLength = 12, scrollX=T) )\n```\n\n\nWe can now plot the moving averages, displaying the data by group by specifying `~ hospital` to `facet_wrap()` in `ggplot()`. For fun, we plot two geometries - a `geom_col()` showing the daily case counts and a `geom_line()` showing the 7-day moving average.  \n\n\n```{r, warning=F, message=F}\nggplot(data = grouped_roll)+\n  geom_col(                       # plot daly case counts as grey bars\n    mapping = aes(\n      x = date_hospitalisation,\n      y = new_cases),\n    fill = \"grey\",\n    width = 1)+\n  geom_line(                      # plot rolling average as line colored by hospital\n    mapping = aes(\n      x = date_hospitalisation,\n      y = mean_7day_hosp,\n      color = hospital),\n    size = 1)+\n  facet_wrap(~hospital, ncol = 2)+ # create mini-plots per hospital\n  theme_classic()+                 # simplify background  \n  theme(legend.position = \"none\")+ # remove legend\n  labs(                            # add plot labels\n    title = \"7-day rolling average of daily case incidence\",\n    x = \"Date of admission\",\n    y = \"Case incidence\")\n```\n\n\n<span style=\"color: red;\">**_DANGER:_** If you get an error saying *\"slide() was deprecated in tsibble 0.9.0 and is now defunct. Please use slider::slide() instead.\"*, it means that the `slide()` function from the **tsibble** package is masking the `slide()` function from **slider** package. Fix this by specifying the package in the command, such as `slider::slide_dbl()`.</span>\n\n\n\n\n<!-- You can group the data prior to using a **slider** function. For example, if you want to calculate the same 7-day rolling sum as above, but by hospital. above rolling mean delay from symptom onset to hospital admission (column `days_onset_hosp`).   -->\n\n<!-- You can group the data by the month of symptom onset using **lubridate**'s `floor_date()` as described in the [Grouping data] page. Then, use `slide_index_dbl()` as before but set your window extent using `months()` (also from **lubridate**).  -->\n\n<!-- f you want a rolling average by *months*, you can use **lubridate** to group the data by month, and then apply `slide_index_dbl()` as below shown for a three-month rolling average:   -->\n\n<!-- ```{r} -->\n<!-- months_delay <- linelist %>% -->\n<!--   arrange(date_onset) %>%    # drop rows missing date of onset -->\n<!--   group_by(hospital) %>%  -->\n<!--   #group_by(month_onset = floor_date(date_onset, \"month\")) %>% # create and group by month of onset  -->\n<!--   mutate( -->\n<!--     delay_7d = slide_index_dbl( -->\n<!--       days_onset_hosp,                  # calculate avg based on value in new_cases column -->\n<!--       .i = date_onset,                 # index column is date_onset, so non-present dates are included in 7day window  -->\n<!--       .f = ~mean(.x, na.rm = TRUE),     # function is mean() with missing values removed -->\n<!--       .before = days(7)), -->\n\n<!--     delay_month = slide_index_dbl( -->\n<!--       days_onset_hosp,                  # calculate avg based on value in new_cases column -->\n<!--       .i = date_onset,                 # index column is date_onset, so non-present dates are included in 7day window  -->\n<!--       .f = ~mean(.x, na.rm = TRUE),     # function is mean() with missing values removed -->\n<!--       .before = months(1)))               # window is the month and the prior month -->\n\n\n<!-- # window is the month and the prior month -->\n\n<!-- ``` -->\n\n<!-- ```{r} -->\n<!-- ggplot(data = months_delay, mapping = aes(x = month_onset))+ -->\n<!--   geom_line(mapping = aes(y = )) -->\n\n<!-- ``` -->\n\n\n\n\n\n\n<!-- ======================================================= -->\n## Calculate with **tidyquant** within `ggplot()` {  }\n\nThe package **tidyquant** offers another approach to calculating moving averages - this time from *within* a `ggplot()` command itself.  \n\nBelow the `linelist` data are counted by date of onset, and this is plotted as a faded line (`alpha` < 1). Overlaid on top is a line created with `geom_ma()` from the package **tidyquant**, with a set window of 7 days (`n = 7`) with specified color and thickness.  \n\nBy default `geom_ma()` uses a simple moving average (`ma_fun = \"SMA\"`), but other types can be specified, such as:  \n\n* \"EMA\" - exponential moving average (more weight to recent observations)  \n* \"WMA\" - weighted moving average (`wts` are used to weight observations in the moving average)  \n* Others can be found in the function documentation  \n\n```{r}\nlinelist %>% \n  count(date_onset) %>%                 # count cases per day\n  drop_na(date_onset) %>%               # remove cases missing onset date\n  ggplot(aes(x = date_onset, y = n))+   # start ggplot\n    geom_line(                          # plot raw values\n      size = 1,\n      alpha = 0.2                       # semi-transparent line\n      )+             \n    tidyquant::geom_ma(                 # plot moving average\n      n = 7,           \n      size = 1,\n      color = \"blue\")+ \n  theme_minimal()                       # simple background\n```\n\nSee this [vignette](https://cran.r-project.org/web/packages/tidyquant/vignettes/TQ04-charting-with-tidyquant.html) for more details on the options available within **tidyquant**.  \n\n\n<!-- ## Rolling regression  -->\n\n<!-- ```{r} -->\n<!-- a <- linelist %>% -->\n<!--   separate(time_admission, into = c(\"hour\", \"minute\"), sep = \":\") %>%  -->\n<!--   count(days_onset_hosp, hour) %>%  -->\n<!--   mutate(reg_admit_hour = slide(., ~lm(days_onset_hosp ~ hour), .before = 3, .complete = T)) %>%  -->\n<!--   mutate(coeff = reg_admit_hour[[1]]) -->\n\n<!-- ggplot()+ -->\n<!--   geom_point(aes(x = hour, y = days_onset_hosp)) -->\n\n<!-- ``` -->\n\n<!-- ```{r} -->\n<!-- linelist %>%  -->\n<!--   mutate( -->\n\n<!--   ) -->\n\n<!-- ``` -->\n\n\n<!-- ======================================================= -->\n## Resources {  }\n\n\nSee the helpful online [vignette for the **slider** package](https://cran.r-project.org/web/packages/slider/vignettes/slider.html)  \n\nThe **slider** [github page](https://github.com/DavisVaughan/slider)\n\nA **slider** [vignette](https://davisvaughan.github.io/slider/articles/slider.html)  \n\n[tidyquant vignette](https://cran.r-project.org/web/packages/tidyquant/vignettes/TQ04-charting-with-tidyquant.html)\n\nIf your use case requires that you “skip over” weekends and even holidays, you might like **almanac** package.\n\n\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"moving_average.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.340","lightbox":true,"theme":{"light":"cosmo","dark":["cosmo","theme-dark.scss"]}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}