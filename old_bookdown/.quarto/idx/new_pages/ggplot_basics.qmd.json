{"title":"ggplot basics","markdown":{"headingText":"ggplot basics","headingAttr":{"id":"","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n```{r, out.width=c('100%', '100%'), fig.align = \"center\", echo=F}\nknitr::include_graphics(here::here(\"images\", \"ggplot_basics_top.png\"))\n```\n\n\n**ggplot2** is the most popular data visualisation R package. Its `ggplot()` function is at the core of this package, and this whole approach is colloquially known as *\"ggplot\"* with the resulting figures sometimes affectionately called \"ggplots\". The \"gg\" in these names reflects the \"**g**rammar of **g**raphics\" used to construct the figures. **ggplot2** benefits from a wide variety of supplementary R packages that further enhance its functionality.  \n\nThe syntax is significantly different from **base** `R` plotting, and has a learning curve associated with it. Using **ggplot2** generally requires the user to format their data in a way that is highly **tidyverse** compatible, which ultimately makes using these packages together very effective.\n\nIn this page we will cover the fundamentals of plotting with **ggplot2**. See the page [ggplot tips] for suggestions and advanced techniques to make your plots really look nice.  \n\nThere are several extensive **ggplot2** tutorials linked in the resources section. You can also download this [data visualization with ggplot cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf) from the RStudio website. If you want inspiration for ways to creatively visualise your data, we suggest reviewing websites like the [R graph gallery](https://www.r-graph-gallery.com/) and [Data-to-viz](https://www.data-to-viz.com/caveats.html). \n\n\n\n<!-- ======================================================= -->\n## Preparation {}\n\n### Load packages {.unnumbered}\n\nThis code chunk shows the loading of packages required for the analyses. In this handbook we emphasize `p_load()` from **pacman**, which installs the package if necessary *and* loads it for use. You can also load installed packages with  `library()` from **base** R. See the page on [R basics] for more information on R packages.  \n\n```{r}\npacman::p_load(\n  tidyverse,      # includes ggplot2 and other data management tools\n  janitor,        # cleaning and summary tables\n  ggforce,        # ggplot extras\n  rio,            # import/export\n  here,           # file locator\n  stringr         # working with characters   \n)\n```\n\n### Import data {.unnumbered}  \n\nWe import the dataset of cases from a simulated Ebola epidemic. If you want to follow along, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>click to download the \"clean\" linelist</a> (as .rds file). Import your data with the `import()` function from the **rio** package (it accepts many file types like .xlsx, .rds, .csv - see the [Import and export] page for details).\n\n```{r,  echo=F}\nlinelist <- rio::import(here::here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))\n\n```\n\n```{r, eval=F}\nlinelist <- rio::import(\"linelist_cleaned.rds\")\n```\n\nThe first 50 rows of the linelist are displayed below. We will focus on the continuous variables `age`, `wt_kg` (weight in kilos), `ct_blood` (CT values), and `days_onset_hosp` (difference between onset date and hospitalisation).  \n\n```{r, message=FALSE, echo=F}\n# display the linelist data as a table\nDT::datatable(head(linelist, 50), rownames = FALSE, filter=\"top\", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )\n```\n\n\n\n### General cleaning {.unnumbered}\n\nWhen preparing data to plot, it is best to make the data adhere to [\"tidy\" data standards](https://r4ds.had.co.nz/tidy-data.html) as much as possible. How to achieve this is expanded on in the data management pages of this handbook, such as [Cleaning data and core functions]. \n\nSome simple ways we can prepare our data to make it better for plotting can include making the contents of the data better for display - which does not necessarily equate to better for data manipulation. For example:  \n\n* Replace `NA` values in a character column with the character string \"Unknown\"  \n* Consider converting column to class *factor* so their values have prescribed ordinal levels  \n* Clean some columns so that their \"data friendly\" values with underscores etc are changed to normal text or title case (see [Characters and strings])  \n\nHere are some examples of this in action:\n\n```{r, }\n# make display version of columns with more friendly names\nlinelist <- linelist %>%\n  mutate(\n    gender_disp = case_when(gender == \"m\" ~ \"Male\",        # m to Male \n                            gender == \"f\" ~ \"Female\",      # f to Female,\n                            is.na(gender) ~ \"Unknown\"),    # NA to Unknown\n    \n    outcome_disp = replace_na(outcome, \"Unknown\")          # replace NA outcome with \"unknown\"\n  )\n```\n\n### Pivoting longer {.unnumbered}\n\nAs a matter of data structure, for **ggplot2** we often also want to pivot our data into *longer* formats. Read more about this is the page on [Pivoting data].  \n\n\n```{r out.width = \"100%\", fig.align = \"center\", echo=F}\nknitr::include_graphics(here::here(\"images\", \"pivoting\", \"pivot_longer_new.png\"))\n```\n\n\nFor example, say that we want to plot data that are in a \"wide\" format, such as for each case in the `linelist` and their symptoms. Below we create a mini-linelist called `symptoms_data` that contains only the `case_id` and symptoms columns.  \n\n```{r}\nsymptoms_data <- linelist %>% \n  select(c(case_id, fever, chills, cough, aches, vomit))\n```\n\nHere is how the first 50 rows of this mini-linelist look - see how they are formatted \"wide\" with each symptom as a column: \n\n```{r, message=FALSE, echo=F}\n# display the linelist data as a table\nDT::datatable(head(symptoms_data, 50), rownames = FALSE, filter=\"top\", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )\n```\n\nIf we wanted to plot the number of cases with specific symptoms, we are limited by the fact that each symptom is a specific column. However, we can *pivot* the symptoms columns to a longer format like this:\n\n```{r, }\nsymptoms_data_long <- symptoms_data %>%    # begin with \"mini\" linelist called symptoms_data\n  \n  pivot_longer(\n    cols = -case_id,                       # pivot all columns except case_id (all the symptoms columns)\n    names_to = \"symptom_name\",             # assign name for new column that holds the symptoms\n    values_to = \"symptom_is_present\") %>%  # assign name for new column that holds the values (yes/no)\n  \n  mutate(symptom_is_present = replace_na(symptom_is_present, \"unknown\")) # convert NA to \"unknown\"\n\n```\n\n\nHere are the first 50 rows. Note that case has 5 rows - one for each possible symptom. The new columns `symptom_name` and `symptom_is_present` are the result of the pivot. Note that this format may not be very useful for other operations, but is useful for plotting.\n\n```{r, message=FALSE, echo=F}\nDT::datatable(head(symptoms_data_long, 50), rownames = FALSE, filter=\"top\", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )\n```\n\n\n\n\n\n\n<!-- ======================================================= -->\n## Basics of ggplot {}\n\n**\"Grammar of graphics\" - ggplot2**  \n\nPlotting with **ggplot2** is based on \"adding\" plot layers and design elements on top of one another, with each command added to the previous ones with a plus symbol (`+`). The result is a multi-layer plot object that can be saved, modified, printed, exported, etc.  \n\nggplot objects can be highly complex, but the basic order of layers will usually look like this:  \n\n1. Begin with the baseline `ggplot()` command - this \"opens\" the ggplot and allow subsequent functions to be added with `+`. Typically the dataset is also specified in this command  \n2. Add \"geom\" layers - these functions visualize the data as *geometries* (*shapes*), e.g. as a bar graph, line plot, scatter plot, histogram (or a combination!). These functions all start with `geom_` as a prefix.  \n3. Add design elements to the plot such as axis labels, title, fonts, sizes, color schemes, legends, or axes rotation  \n\nA simple example of skeleton code is as follows. We will explain each component in the sections below.  \n\n```{r, eval=F}\n# plot data from my_data columns as red points\nggplot(data = my_data)+                   # use the dataset \"my_data\"\n  geom_point(                             # add a layer of points (dots)\n    mapping = aes(x = col1, y = col2),    # \"map\" data column to axes\n    color = \"red\")+                       # other specification for the geom\n  labs()+                                 # here you add titles, axes labels, etc.\n  theme()                                 # here you adjust color, font, size etc of non-data plot elements (axes, title, etc.) \n```\n\n \n\n\n## `ggplot()`  \n\nThe opening command of any ggplot2 plot is `ggplot()`. This command simply creates a blank canvas upon which to add layers. It \"opens\" the way for further layers to be added with a `+` symbol.\n\nTypically, the command `ggplot()` includes the `data = ` argument for the plot. This sets the default dataset to be used for subsequent layers of the plot.  \n\nThis command will end with a `+` after its closing parentheses. This leaves the command \"open\". The ggplot will only execute/appear when the full command includes a final layer *without* a `+` at the end.  \n\n```{r, eval=F}\n# This will create plot that is a blank canvas\nggplot(data = linelist)\n```\n\n\n## Geoms  \n\nA blank canvas is certainly not sufficient - we need to create geometries (shapes) from our data (e.g. bar plots, histograms, scatter plots, box plots).  \n\nThis is done by adding layers \"geoms\" to the initial `ggplot()` command. There are many **ggplot2** functions that create \"geoms\". Each of these functions begins with \"geom_\", so we will refer to them generically as `geom_XXXX()`. There are over 40 geoms in **ggplot2** and many others created by fans. View them at the [ggplot2 gallery](https://exts.ggplot2.tidyverse.org/gallery/). Some common geoms are listed below:  \n\n* Histograms - `geom_histogram()`  \n* Bar charts - `geom_bar()` or `geom_col()` (see [\"Bar plot\" section](#ggplot_basics_bars))  \n* Box plots - `geom_boxplot()`  \n* Points (e.g. scatter plots) - `geom_point()`  \n* Line graphs - `geom_line()` or `geom_path()`  \n* Trend lines - `geom_smooth()`  \n\nIn one plot you can display one or multiple geoms. Each is added to previous **ggplot2** commands with a `+`, and they are plotted sequentially such that later geoms are plotted on top of previous ones.  \n\n\n\n## Mapping data to the plot {#ggplot_basics_mapping}  \n\nMost geom functions must be told *what to use* to create their shapes - so you must tell them how they should *map (assign) columns in your data* to components of the plot like the axes, shape colors, shape sizes, etc. For most geoms, the *essential* components that must be mapped to columns in the data are the x-axis, and (if necessary) the y-axis.  \n\nThis \"mapping\" occurs with the `mapping = ` argument. The mappings you provide to `mapping` must be wrapped in the `aes()` function, so you would write something like `mapping = aes(x = col1, y = col2)`, as shown below.\n\nBelow, in the `ggplot()` command the data are set as the case `linelist`. In the `mapping = aes()` argument the column `age` is mapped to the x-axis, and the column `wt_kg` is mapped to the y-axis.  \n\nAfter a `+`, the plotting commands continue. A shape is created with the \"geom\" function `geom_point()`. This geom *inherits* the mappings from the `ggplot()` command above - it knows the axis-column assignments and proceeds to visualize those relationships as *points* on the canvas.  \n\n```{r, warning=F, message=F}\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+\n  geom_point()\n```\n\nAs another example, the following commands utilize the same data, a slightly different mapping, and a different geom. The `geom_histogram()` function only requires a column mapped to the x-axis, as the counts y-axis is generated automatically.  \n\n```{r, warning=F, message=F}\nggplot(data = linelist, mapping = aes(x = age))+\n  geom_histogram()\n```\n\n\n### Plot aesthetics {.unnumbered}  \n\nIn ggplot terminology a plot \"aesthetic\" has a specific meaning. It refers to a visual property of *plotted data*. Note that \"aesthetic\" here refers to the *data being plotted in geoms/shapes* - not the surrounding display such as titles, axis labels, background color, that you might associate with the word \"aesthetics\" in common English. In ggplot those details are called \"themes\" and are adjusted within a `theme()` command (see [this section](#ggplot_basics_themes)).  \n\nTherefore, plot object *aesthetics* can be colors, sizes, transparencies, placement, etc. *of the plotted data*. Not all geoms will have the same aesthetic options, but many can be used by most geoms. Here are some examples:  \n\n* `shape =` Display a point with `geom_point()` as a dot, star, triangle, or square...  \n* `fill = ` The interior color (e.g. of a bar or boxplot)  \n* `color =` The exterior line of a bar, boxplot, etc., or the point color if using `geom_point()`  \n* `size = ` Size (e.g. line thickness, point size)  \n* `alpha = ` Transparency (1 = opaque, 0 = invisible)  \n* `binwidth = ` Width of histogram bins  \n* `width = ` Width of \"bar plot\" columns  \n* `linetype =` Line type (e.g. solid, dashed, dotted) \n\nThese plot object aesthetics can be assigned values in two ways:  \n\n1) Assigned a static value (e.g. `color = \"blue\"`) to apply across all plotted observations  \n2) Assigned to a column of the data (e.g. `color = hospital`) such that display of each observation depends on its value in that column  \n\n<!-- *These non-axis aesthetics can be assigned static values (e.g. `size = 1`) or can be mapped to a column (e.g. `size = age`).* If you want the aesthetic to be assigned a static value, the assignment is placed *outside* the `mapping = aes()`. If you want the aesthetic to be scaled/depend on the value in each row of data, the assignment is made *inside* the `mapping = aes()`.   -->\n\n### Set to a static value {.unnumbered}  \n\nIf you want the plot object aesthetic to be static, that is - to be the same for every observation in the data, you write its assignment within the geom but *outside* of any `mapping = aes()` statement. These assignments could look like `size = 1` or `color = \"blue\"`. Here are two examples:  \n\n* In the first example, the `mapping = aes()` is in the `ggplot()` command and the axes are mapped to age and weight columns in the data. The plot aesthetics `color = `, `size = `, and `alpha = ` (transparency) are assigned to static values. For clarity, this is done in the `geom_point()` function, as you may add other geoms afterward that would take different values for their plot aesthetics.  \n* In the second example, the histogram requires only the x-axis mapped to a column. The histogram `binwidth = `, `color = `, `fill = ` (internal color), and `alpha = ` are again set within the geom to static values.  \n\n```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}\n# scatterplot\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  # set data and axes mapping\n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)         # set static point aesthetics\n\n# histogram\nggplot(data = linelist, mapping = aes(x = age))+       # set data and axes\n  geom_histogram(              # display histogram\n    binwidth = 7,                # width of bins\n    color = \"red\",               # bin line color\n    fill = \"blue\",               # bin interior color\n    alpha = 0.1)                 # bin transparency\n```\n\n\n### Scaled to column values {.unnumbered}  \n\nThe alternative is to scale the plot object aesthetic by the values in a column. In this approach, the display of this aesthetic will depend on that observation's value in that column of the data. If the column values are continuous, the display scale (legend) for that aesthetic will be continuous. If the column values are discrete, the legend will display each value and the plotted data will appear as distinctly \"grouped\" (read more in the [grouping](#ggplotgroups) section of this page).  \n\nTo achieve this, you map that plot aesthetic to a *column name* (not in quotes). This must be done *within a `mapping = aes()` function* (note: there are several places in the code you can make these mapping assignments, as discussed [below](##ggplot_basics_map_loc)).  \n\nTwo examples are below.  \n\n* In the first example, the `color = ` aesthetic (of each point) is mapped to the column `age` - and a scale has appeared in a legend! For now just note that the scale exists - we will show how to modify it in later sections.  \n* In the second example two new plot aesthetics are also mapped to columns (`color = ` and `size = `), while the plot aesthetics `shape = ` and `alpha = ` are mapped to static values outside of any `mapping = aes()` function.  \n\n```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}\n# scatterplot\nggplot(data = linelist,   # set data\n       mapping = aes(     # map aesthetics to column values\n         x = age,           # map x-axis to age            \n         y = wt_kg,         # map y-axis to weight\n         color = age)\n       )+     # map color to age\n  geom_point()         # display data as points \n\n# scatterplot\nggplot(data = linelist,   # set data\n       mapping = aes(     # map aesthetics to column values\n         x = age,           # map x-axis to age            \n         y = wt_kg,         # map y-axis to weight\n         color = age,       # map color to age\n         size = age))+      # map size to age\n  geom_point(             # display data as points\n    shape = \"diamond\",      # points display as diamonds\n    alpha = 0.3)            # point transparency at 30%\n\n\n```\n\n\n\nNote: Axes assignments are always assigned to columns in the data (not to static values), and this is always done within `mapping = aes()`.  \n\n\nIt becomes important to keep track of your plot layers and aesthetics when making more complex plots - for example plots with multiple geoms. In the example below, the `size = ` aesthetic is assigned twice - once for `geom_point()` and once for `geom_smooth()` - both times as a static value.  \n\n```{r, warning=F, message=F}\nggplot(data = linelist,\n       mapping = aes(           # map aesthetics to columns\n         x = age,\n         y = wt_kg,\n         color = age_years)\n       ) + \n  geom_point(                   # add points for each row of data\n    size = 1,\n    alpha = 0.5) +  \n  geom_smooth(                  # add a trend line \n    method = \"lm\",              # with linear method\n    size = 2)                   # size (width of line) of 2\n```\n\n\n\n\n\n\n### Where to make mapping assignments {#ggplot_basics_map_loc .unnumbered}\n\n\nAesthetic mapping within `mapping = aes()` can be written in several places in your plotting commands and can even be written more than once. This can be written in the top `ggplot()` command, and/or for each individual geom beneath. The nuances include:  \n\n* Mapping assignments made in the top `ggplot()` command will be inherited as defaults across any geom below, like how `x = ` and `y = ` are inherited \n* Mapping assignments made within one geom apply only to that geom  \n\nLikewise, `data = ` specified in the top `ggplot()` will apply by default to any geom below, but you could also specify data for each geom (but this is more difficult).  \n\nThus, each of the following commands will create the same plot:  \n\n```{r, eval=F, warning=F, message=F}\n# These commands will produce the exact same plot\nggplot(data = linelist, mapping = aes(x = age))+\n  geom_histogram()\n\nggplot(data = linelist)+\n  geom_histogram(mapping = aes(x = age))\n\nggplot()+\n  geom_histogram(data = linelist, mapping = aes(x = age))\n```\n\n\n\n\n### Groups {#ggplotgroups .unnumbered}  \n\nYou can easily group the data and \"plot by group\". In fact, you have already done this!  \n\nAssign the \"grouping\" column to the appropriate plot aesthetic, within a `mapping = aes()`. Above, we demonstrated this using continuous values when we assigned point `size = ` to the column `age`. However this works the same way for discrete/categorical columns.  \n\nFor example, if you want points to be displayed by gender, you would set `mapping = aes(color = gender)`. A legend automatically appears. This assignment can be made within the `mapping = aes()` in the top `ggplot()` command (and be inherited by the geom), or it could be set in a separate `mapping = aes()` within the geom. Both approaches are shown below:  \n\n\n```{r, warning=F, message=F}\nggplot(data = linelist,\n       mapping = aes(x = age, y = wt_kg, color = gender))+\n  geom_point(alpha = 0.5)\n```\n\n\n```{r, eval=F}\n# This alternative code produces the same plot\nggplot(data = linelist,\n       mapping = aes(x = age, y = wt_kg))+\n  geom_point(\n    mapping = aes(color = gender),\n    alpha = 0.5)\n\n```\n\n\nNote that depending on the geom, you will need to use different arguments to group the data. For `geom_point()` you will most likely use `color =`, `shape = ` or `size = `. Whereas for `geom_bar()` you are more likely to use `fill = `. This just depends on the geom and what plot aesthetic you want to reflect the groupings.  \n\nFor your information - the most basic way of grouping the data is by using only the `group = ` argument within `mapping = aes()`. However, this by itself will not change the colors, fill, or shapes. Nor will it create a legend. Yet the data are grouped, so statistical displays may be affected.  \n\nTo adjust the order of groups in a plot, see the [ggplot tips] page or the page on [Factors]. There are many examples of grouped plots in the sections below on plotting continuous and categorical data.   \n\n\n\n## Facets / Small-multiples {#ggplot_basics_facet}  \n\nFacets, or \"small-multiples\", are used to split one plot into a multi-panel figure, with one panel (\"facet\") per group of data. The same type of plot is created multiple times, each one using a sub-group of the same dataset.  \n\nFaceting is a functionality that comes with **ggplot2**, so the legends and axes of the facet \"panels\" are automatically aligned. There are other packages discussed in the [ggplot tips] page that are used to combine completely different plots (**cowplot** and **patchwork**) into one figure.  \n\nFaceting is done with one of the following **ggplot2** functions:\n\n  1. `facet_wrap()` To show a different panel for each level of a *single* variable. One example of this could be showing a different epidemic curve for each hospital in a region. Facets are ordered alphabetically, unless the variable is a factor with other ordering defined.  \n  + You can invoke certain options to determine the layout of the facets, e.g. `nrow = 1` or `ncol = 1` to control the number of rows or columns that the faceted plots are arranged within.  \n  \n  2. `facet_grid()` This is used when you want to bring a second variable into the faceting arrangement. Here each panel of a grid shows the intersection between values in *two columns*. For example, epidemic curves for each hospital-age group combination with hospitals along the top (columns) and age groups along the sides (rows).  \n  + `nrow` and `ncol` are not relevant, as the subgroups are presented in a grid  \n\nEach of these functions accept a formula syntax to specify the column(s) for faceting. Both accept up to two columns, one on each side of a tilde `~`.  \n\n* For `facet_wrap()` most often you will write only one column preceded by a tilde `~` like `facet_wrap(~hospital)`. However you can write two columns `facet_wrap(outcome ~ hospital)` - each unique combination will display in a separate panel, but they will not be arranged in a grid. The headings will show combined terms and these won't be specific logic to the columns vs. rows.  If you are providing only one faceting variable, a period `.` is used as a placeholder on the other side of the formula - see the code examples.  \n\n* For `facet_grid()` you can also specify one or two columns to the formula (grid `rows ~ columns`). If you only want to specify one, you can place a period `.` on the other side of the tilde like `facet_grid(. ~ hospital)` or `facet_grid(hospital ~ .)`.  \n\nFacets can quickly contain an overwhelming amount of information - its good to ensure you don't have too many levels of each variable that you choose to facet by. Here are some quick examples with the malaria dataset (see [Download handbook and data]) which consists of daily case counts of malaria for facilities, by age group.  \n\nBelow we import and do some quick modifications for simplicity:  \n\n```{r, , warning=F, message=F}\n# These data are daily counts of malaria cases, by facility-day\nmalaria_data <- import(here(\"data\", \"malaria_facility_count_data.rds\")) %>%  # import\n  select(-submitted_date, -Province, -newid)                                 # remove unneeded columns\n\n```\n\nThe first 50 rows of the malaria data are below. Note there is a column `malaria_tot`, but also columns for counts by age group (these will be used in the second, `facet_grid()` example).  \n\n```{r, message=FALSE, echo=F}\nDT::datatable(head(malaria_data, 50), rownames = FALSE, filter=\"top\", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )\n```\n\n\n\n### `facet_wrap()` {.unnumbered}\n\nFor the moment, let's focus on the columns `malaria_tot` and `District`. Ignore the age-specific count columns for now. We will plot epidemic curves with `geom_col()`, which produces a column for each day at the specified y-axis height given in column `malaria_tot` (the data are already daily counts, so we use `geom_col()` - see [the \"Bar plot\" section below](#ggplot_basics_bars)).  \n\nWhen we add the command `facet_wrap()`, we specify a tilde and then the column to facet on (`District` in this case). You can place another column on the left side of the tilde, - this will create one facet for each combination - but we recommend you do this with `facet_grid()` instead. In this use case, one facet is created for each unique value of `District`.  \n\n```{r, warning=F, message=F}\n# A plot with facets by district\nggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1, fill = \"darkred\") +       # plot the count data as columns\n  theme_minimal()+                              # simplify the background panels\n  labs(                                         # add plot labels, title, etc.\n    x = \"Date of report\",\n    y = \"Malaria cases\",\n    title = \"Malaria cases by district\") +\n  facet_wrap(~District)                       # the facets are created\n```\n\n### `facet_grid()` {.unnumbered}  \n\nWe can use a `facet_grid()` approach to cross two variables. Let's say we want to cross `District` and age. Well, we need to do some data transformations on the age columns to get these data into ggplot-preferred \"long\" format. The age groups all have their own columns - we want them in a single column called `age_group` and another called `num_cases`. See the page on [Pivoting data] for more information on this process.  \n\n```{r, message=F, warning=F}\nmalaria_age <- malaria_data %>%\n  select(-malaria_tot) %>% \n  pivot_longer(\n    cols = c(starts_with(\"malaria_rdt_\")),  # choose columns to pivot longer\n    names_to = \"age_group\",      # column names become age group\n    values_to = \"num_cases\"      # values to a single column (num_cases)\n  ) %>%\n  mutate(\n    age_group = str_replace(age_group, \"malaria_rdt_\", \"\"),\n    age_group = forcats::fct_relevel(age_group, \"5-14\", after = 1))\n```\n\nNow the first 50 rows of data look like this:  \n\n```{r, message=FALSE, echo=F}\nDT::datatable(head(malaria_age, 50), rownames = FALSE, filter=\"top\", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )\n```\n\n\nWhen you pass the two variables to `facet_grid()`, easiest is to use formula notation (e.g. `x ~ y`) where x is rows and y is columns. Here is the plot, using `facet_grid()` to show the plots for each combination of the columns `age_group` and `District`.\n\n```{r, message=F, warning=F}\nggplot(malaria_age, aes(x = data_date, y = num_cases)) +\n  geom_col(fill = \"darkred\", width = 1) +\n  theme_minimal()+\n  labs(\n    x = \"Date of report\",\n    y = \"Malaria cases\",\n    title = \"Malaria cases by district and age group\"\n  ) +\n  facet_grid(District ~ age_group)\n```\n\n### Free or fixed axes {.unnumbered}  \n\nThe axes scales displayed when faceting are by default the same (fixed) across all the facets. This is helpful for cross-comparison, but not always appropriate.  \n\nWhen using `facet_wrap()` or `facet_grid()`, we can add `scales = \"free_y\"` to \"free\" or release the y-axes of the panels to scale appropriately to their data subset. This is particularly useful if the actual counts are small for one of the subcategories and trends are otherwise hard to see. Instead of \"free_y\" we can also write \"free_x\" to do the same for the x-axis (e.g. for dates) or \"free\" for both axes. Note that in `facet_grid`, the y scales will be the same for facets in the same row, and the x scales will be the same for facets in the same column.\n\nWhen using `facet_grid` only, we can add `space = \"free_y\"` or `space = \"free_x\"` so that the actual height or width of the facet is weighted to the values of the figure within. This only works if `scales = \"free\"` (y or x) is already applied. \n\n```{r, message=FALSE, warning=FALSE}\n\n# Free y-axis\nggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1, fill = \"darkred\") +       # plot the count data as columns\n  theme_minimal()+                              # simplify the background panels\n  labs(                                         # add plot labels, title, etc.\n    x = \"Date of report\",\n    y = \"Malaria cases\",\n    title = \"Malaria cases by district - 'free' x and y axes\") +\n  facet_wrap(~District, scales = \"free\")        # the facets are created\n```\n\n\n<!-- ```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')} -->\n<!-- # A) Facet hospitalsation date by hospital, free y axis -->\n<!-- ggplot(data = linelist %>% filter(hospital != \"Missing\"), # filter removes unknown hospital -->\n<!--        aes(x = date_hospitalisation ))+ -->\n<!--   geom_histogram(binwidth=7) + # Bindwidth = 7 days -->\n<!--   labs(title = \"A) Histogram with free y axis scales\")+ -->\n<!--   facet_grid(hospital~., # Facet with hospital as the row  -->\n<!--              scales = \"free_y\") # Free the y scale of each facet -->\n\n<!-- # B) Facet hospitalisation date by hospital, free y axis and vertical spacing -->\n<!-- ggplot(data = linelist %>% filter(hospital != \"Missing\"), # filter removes unknown hospital -->\n<!--        aes(x = date_hospitalisation ))+ -->\n<!--   geom_histogram(binwidth=7) + # Bindwidth = 7 days -->\n<!--   labs(title = \"B) Histogram with free y axis scales and spacing\")+ -->\n<!--   facet_grid(hospital~., # Facet with hospital as the row  -->\n<!--              scales = \"free_y\", # Free the y scale of each facet -->\n<!--              space = \"free_y\") # Free the vertical spacing of each facet to optimise space -->\n\n<!-- ``` -->\n\n### Factor level order in facets {.unnumbered}  \n\nSee this [post](https://juliasilge.com/blog/reorder-within/) on how to re-order factor levels *within* facets.  \n\n\n## Storing plots  \n\n### Saving plots {.unnumbered}\n\nBy default when you run a `ggplot()` command, the plot will be printed to the Plots RStudio pane. However, you can also save the plot as an object by using the assignment operator `<-` and giving it a name. Then it will not print unless the object name itself is run. You can also print it by wrapping the plot name with `print()`, but this is only necessary in certain circumstances such as if the plot is created inside a *for loop* used to print multiple plots at once (see [Iteration, loops, and lists] page).  \n\n```{r, warning=F, message=F}\n# define plot\nage_by_wt <- ggplot(data = linelist, mapping = aes(x = age_years, y = wt_kg, color = age_years))+\n  geom_point(alpha = 0.1)\n\n# print\nage_by_wt    \n```\n\n\n### Modifying saved plots {.unnumbered}  \n\nOne nice thing about **ggplot2** is that you can define a plot (as above), and then add layers to it starting with its name. You do not have to repeat all the commands that created the original plot! \n\nFor example, to modify the plot `age_by_wt` that was defined above, to include a vertical line at age 50, we would just add a `+` and begin adding additional layers to the plot.  \n\n```{r, warning=F, message=F}\nage_by_wt+\n  geom_vline(xintercept = 50)\n```\n\n\n### Exporting plots {.unnumbered}   \n\nExporting ggplots is made easy with the `ggsave()` function from **ggplot2**. It can work in two ways, either:  \n\n* Specify the name of the plot object, then the file path and name with extension  \n  * For example: `ggsave(my_plot, here(\"plots\", \"my_plot.png\"))`  \n* Run the command with only a file path, to save the last plot that was printed  \n  * For example: `ggsave(here(\"plots\", \"my_plot.png\"))`  \n  \nYou can export as png, pdf, jpeg, tiff, bmp, svg, or several other file types, by specifying the file extension in the file path.  \n\nYou can also specify the arguments `width = `, `height = `, and `units = ` (either \"in\", \"cm\", or \"mm\"). You can also specify `dpi = ` with a number for plot resolution (e.g. 300). See the function details by entering `?ggsave` or reading the [documentation online](https://ggplot2.tidyverse.org/reference/ggsave.html). \n\nRemember that you can use `here()` syntax to provide the desired file path. See the [Import and export] page for more information.  \n\n\n## Labels \n\nSurely you will want to add or adjust the plot's labels. These are most easily done within the `labs()` function which is added to the plot with `+` just as the geoms were.  \n\nWithin `labs()` you can provide character strings to these arguements:  \n\n* `x = ` and `y = ` The x-axis and y-axis title (labels)  \n* `title = ` The main plot title  \n* `subtitle = ` The subtitle of the plot, in smaller text below the title  \n* `caption = ` The caption of the plot, in bottom-right by default  \n\nHere is a plot we made earlier, but with nicer labels:  \n\n```{r, warning=F, message=F}\nage_by_wt <- ggplot(\n  data = linelist,   # set data\n  mapping = aes(     # map aesthetics to column values\n         x = age,           # map x-axis to age            \n         y = wt_kg,         # map y-axis to weight\n         color = age))+     # map color to age\n  geom_point()+           # display data as points\n  labs(\n    title = \"Age and weight distribution\",\n    subtitle = \"Fictional Ebola outbreak, 2014\",\n    x = \"Age in years\",\n    y = \"Weight in kilos\",\n    color = \"Age\",\n    caption = stringr::str_glue(\"Data as of {max(linelist$date_hospitalisation, na.rm=T)}\"))\n\nage_by_wt\n```\n\nNote how in the caption assignment we used `str_glue()` from the **stringr** package to implant dynamic R code within the string text. The caption will show the \"Data as of: \" date that reflects the maximum hospitalization date in the linelist. Read more about this in the page on [Characters and strings].  \n\nA note on specifying the *legend* title: There is no one \"legend title\" argument, as you could have multiple scales in your legend. Within `labs()`, you can write the argument for the plot aesthetic used to create the legend, and provide the title this way. For example, above we assigned `color = age` to create the legend. Therefore, we provide `color = ` to `labs()` and assign the legend title desired (\"Age\" with capital A). If you create the legend with `aes(fill = COLUMN)`, then in `labs()` you would write `fill = ` to adjust the title of that legend. The section on color scales in the [ggplot tips] page provides more details on editing legends, and an alternative approach using `scales_()` functions.  \n\n\n\n## Themes {#ggplot_basics_themes} \n\nOne of the best parts of **ggplot2** is the amount of control you have over the plot - you can define anything! As mentioned above, the design of the plot that is *not* related to the data shapes/geometries are adjusted within the `theme()` function. For example, the plot background color, presence/absence of gridlines, and the font/size/color/alignment of text (titles, subtitles, captions, axis text...). These adjustments can be done in one of two ways:  \n\n* Add a [*complete theme*](https://ggplot2.tidyverse.org/reference/ggtheme.html) `theme_()` function to make sweeping adjustments - these include `theme_classic()`, `theme_minimal()`, `theme_dark()`, `theme_light()` `theme_grey()`, `theme_bw()` among others  \n* Adjust each tiny aspect of the plot individually within `theme()`  \n\n\n### Complete themes {.unnumbered}  \n\nAs they are quite straight-forward, we will demonstrate the complete theme functions below and will not describe them further here. Note that any micro-adjustments with `theme()` should be made *after* use of a complete theme.  \n\nWrite them with empty parentheses.  \n\n```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme classic\")+\n  theme_classic()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme bw\")+\n  theme_bw()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme minimal\")+\n  theme_minimal()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme gray\")+\n  theme_gray()\n  \n\n\n```\n\n### Modify theme {.unnumbered}  \n\nThe `theme()` function can take a large number of arguments, each of which edits a very specific aspect of the plot. There is no way we could cover all of the arguments, but we will describe the general pattern for them and show you how to find the argument name that you need. The basic syntax is this:\n\n1. Within `theme()` write the argument name for the plot element you want to edit, like `plot.title = `  \n3. Provide an `element_()` function to the argument  \n  + Most often, use `element_text()`, but others include `element_rect()` for canvas background colors, or `element_blank()` to remove plot elements  \n4. Within the `element_()` function, write argument assignments to make the fine adjustments you desire  \n\nSo, that description was quite abstract, so here are some examples.  \n\nThe below plot looks quite silly, but it serves to show you a variety of the ways you can adjust your plot.  \n\n* We begin with the plot `age_by_wt` defined just above and add `theme_classic()`  \n* For finer adjustments we add `theme()` and include one argument for each plot element to adjust  \n\nIt can be nice to organize the arguments in logical sections. To describe just some of those used below:  \n\n* `legend.position = ` is unique in that it accepts simple values like \"bottom\", \"top\", \"left\", and \"right\". But generally, text-related arguments require that you place the details *within* `element_text()`.  \n* Title size with `element_text(size = 30)`  \n* The caption horizontal alignment with `element_text(hjust = 0)` (from right to left)  \n* The subtitle is italicized with `element_text(face = \"italic\")`  \n\n```{r, , warning=F, message=F}\nage_by_wt + \n  theme_classic()+                                 # pre-defined theme adjustments\n  theme(\n    legend.position = \"bottom\",                    # move legend to bottom\n    \n    plot.title = element_text(size = 30),          # size of title to 30\n    plot.caption = element_text(hjust = 0),        # left-align caption\n    plot.subtitle = element_text(face = \"italic\"), # italicize subtitle\n    \n    axis.text.x = element_text(color = \"red\", size = 15, angle = 90), # adjusts only x-axis text\n    axis.text.y = element_text(size = 15),         # adjusts only y-axis text\n    \n    axis.title = element_text(size = 20)           # adjusts both axes titles\n    )     \n```\n\nHere are some especially common `theme()` arguments. You will recognize some patterns, such as appending `.x` or `.y` to apply the change only to one axis.  \n\n\n`theme()` argument                 |What it adjusts\n-----------------------------------|----------------------------------\n`plot.title = element_text()`      |The title\n`plot.subtitle = element_text()`   |The subtitle\n`plot.caption = element_text()`    |The caption (family, face, color, size, angle, vjust, hjust...) \n`axis.title = element_text()`      |Axis titles (both x and y) (size, face, angle, color...)\n`axis.title.x = element_text()`    |Axis title x-axis only (use `.y` for y-axis only)\n`axis.text = element_text()`       |Axis text (both x and y)\n`axis.text.x = element_text()`     |Axis text x-axis only (use `.y` for y-axis only)  \n`axis.ticks = element_blank()`     |Remove axis ticks\n`axis.line = element_line()`       |Axis lines (colour, size, linetype: solid dashed dotted etc)\n`strip.text = element_text()`      |Facet strip text (colour, face, size, angle...)\n`strip.background = element_rect()`|facet strip (fill, colour, size...)  \n\nBut there are so many theme arguments! How could I remember them all? Do not worry - it is impossible to remember them all. Luckily there are a few tools to help you:  \n\nThe **tidyverse** documentation on [modifying theme](https://ggplot2.tidyverse.org/reference/theme.html), which has a complete list.  \n\n<span style=\"color: darkgreen;\">**_TIP:_** Run `theme_get()` from **ggplot2** to print a list of all 90+ `theme()` arguments to the console.</span>  \n\n<span style=\"color: darkgreen;\">**_TIP:_** If you ever want to remove an element of a plot, you can also do it through `theme()`. Just pass `element_blank()` to an argument to have it disappear completely. For legends, set `legend.position = \"none\".`</span>  \n\n\n\n\n## Colors  \n\n\nPlease see this [section on color scales of the ggplot tips page](#ggplot_tips_colors).  \n\n\n\n## Piping into **ggplot2**   \n\nWhen using pipes to clean and transform your data, it is easy to pass the transformed data into `ggplot()`.  \n\nThe pipes that pass the dataset from function-to-function will transition to `+` once the `ggplot()` function is called. Note that in this case, there is no need to specify the `data = ` argument, as this is automatically defined as the piped-in dataset.  \n\nThis is how that might look:  \n\n```{r, warning=F, message=F}\nlinelist %>%                                                     # begin with linelist\n  select(c(case_id, fever, chills, cough, aches, vomit)) %>%     # select columns\n  pivot_longer(                                                  # pivot longer\n    cols = -case_id,                                  \n    names_to = \"symptom_name\",\n    values_to = \"symptom_is_present\") %>%\n  mutate(                                                        # replace missing values\n    symptom_is_present = replace_na(symptom_is_present, \"unknown\")) %>% \n  \n  ggplot(                                                        # begin ggplot!\n    mapping = aes(x = symptom_name, fill = symptom_is_present))+\n  geom_bar(position = \"fill\", col = \"black\") +                    \n  theme_classic() +\n  labs(\n    x = \"Symptom\",\n    y = \"Symptom status (proportion)\"\n  )\n```\n\n\n\n\n\n\n\n\n\n## Plot continuous data\n\nThroughout this page, you have already seen many examples of plotting continuous data. Here we briefly consolidate these and present a few variations.  \nVisualisations covered here include:\n\n* Plots for one continuous variable:  \n  * **Histogram**, a classic graph to present the distribution of a continuous variable. \n  * **Box plot** (also called box and whisker), to show the 25th, 50th, and 75th percentiles, tail ends of the distribution, and outliers ([important limitations](https://www.data-to-viz.com/caveat/boxplot.html)).  \n  * **Jitter plot**, to show all values as points that are 'jittered' so they can (mostly) all be seen, even where two have the same value.  \n  * **Violin plot**, show the distribution of a continuous variable based on the symmetrical width of the 'violin'. \n  * **Sina plot**, are a combination of jitter and violin plots, where individual points are shown but in the symmetrical shape of the distribution (via **ggforce** package).  \n* **Scatter plot** for two continuous variables.  \n* **Heat plots** for three continuous variables (linked to [Heat plots] page)  \n\n\n\n### Histograms {.unnumbered}\n\nHistograms may look like bar charts, but are distinct because they measure the distribution of a *continuous* variable. There are no spaces between the \"bars\", and only one column is provided to `geom_histogram()`.\n\nBelow is code for generating **histograms**, which group continuous data into ranges and display in adjacent bars of varying height. This is done using `geom_histogram()`. See the [\"Bar plot\" section](#ggplot_basics_bars) of the ggplot basics page to understand difference between `geom_histogram()`, `geom_bar()`, and `geom_col()`.  \n\nWe will show the distribution of ages of cases. Within `mapping = aes()` specify which column you want to see the distribution of. You can assign this column to either the x or the y axis. \n\nThe rows will be assigned to \"bins\" based on their numeric age, and these bins will be graphically represented by bars. If you specify a number of bins with the `bins = ` plot aesthetic, the break points are evenly spaced between the minimum and maximum values of the histogram. If `bins = ` is unspecified, an appropriate number of bins will be guessed and this message displayed after the plot:  \n\n```\n## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n``` \n\nIf you do not want to specify a number of bins to `bins = `, you could alternatively specify `binwidth = ` in the units of the axis. We give a few examples showing different bins and bin widths:  \n\n```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}\n# A) Regular histogram\nggplot(data = linelist, aes(x = age))+  # provide x variable\n  geom_histogram()+\n  labs(title = \"A) Default histogram (30 bins)\")\n\n# B) More bins\nggplot(data = linelist, aes(x = age))+  # provide x variable\n  geom_histogram(bins = 50)+\n  labs(title = \"B) Set to 50 bins\")\n\n# C) Fewer bins\nggplot(data = linelist, aes(x = age))+  # provide x variable\n  geom_histogram(bins = 5)+\n  labs(title = \"C) Set to 5 bins\")\n\n\n# D) More bins\nggplot(data = linelist, aes(x = age))+  # provide x variable\n  geom_histogram(binwidth = 1)+\n  labs(title = \"D) binwidth of 1\")\n\n```\n\n\n\nTo get smoothed proportions, you can use `geom_density()`:  \n\n```{r, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}\n# Frequency with proportion axis, smoothed\nggplot(data = linelist, mapping = aes(x = age)) +\n  geom_density(size = 2, alpha = 0.2)+\n  labs(title = \"Proportional density\")\n\n# Stacked frequency with proportion axis, smoothed\nggplot(data = linelist, mapping = aes(x = age, fill = gender)) +\n  geom_density(size = 2, alpha = 0.2, position = \"stack\")+\n  labs(title = \"'Stacked' proportional densities\")\n```\n\n\nTo get a \"stacked\" histogram (of a continuous column of data), you can do one of the following:  \n\n1) Use `geom_histogram()` with the `fill = ` argument within `aes()` and assigned to the grouping column, or  \n2) Use `geom_freqpoly()`, which is likely easier to read (you can still set `binwidth = `)  \n3) To see proportions of all values, set the `y = after_stat(density)` (use this syntax exactly - not changed for your data). Note: these proportions will show *per group*.  \n\nEach is shown below (*note use of `color = ` vs. `fill = ` in each):  \n\n```{r, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}\n# \"Stacked\" histogram\nggplot(data = linelist, mapping = aes(x = age, fill = gender)) +\n  geom_histogram(binwidth = 2)+\n  labs(title = \"'Stacked' histogram\")\n\n# Frequency \nggplot(data = linelist, mapping = aes(x = age, color = gender)) +\n  geom_freqpoly(binwidth = 2, size = 2)+\n  labs(title = \"Freqpoly\")\n\n# Frequency with proportion axis\nggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), color = gender)) +\n  geom_freqpoly(binwidth = 5, size = 2)+\n  labs(title = \"Proportional freqpoly\")\n\n# Frequency with proportion axis, smoothed\nggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), fill = gender)) +\n  geom_density(size = 2, alpha = 0.2)+\n  labs(title = \"Proportional, smoothed with geom_density()\")\n```\n\nIf you want to have some fun, try `geom_density_ridges` from the **ggridges** package ([vignette here](https://cran.r-project.org/web/packages/ggridges/vignettes/introduction.html).  \n\nRead more in detail about histograms at the **tidyverse** [page on geom_histogram()](https://ggplot2.tidyverse.org/reference/geom_histogram.html).  \n\n\n\n### Box plots {.unnumbered}\n\nBox plots are common, but have important limitations. They can obscure the actual distribution - e.g. a bi-modal distribution. See this [R graph gallery](https://www.r-graph-gallery.com/boxplot.html) and this [data-to-viz article](https://www.data-to-viz.com/caveat/boxplot.html) for more details. However, they do nicely display the inter-quartile range and outliers - so they can be overlaid on top of other types of plots that show the distribution in more detail.  \n\nBelow we remind you of the various components of a boxplot:  \n\n```{r, out.width = \"100%\", fig.align = \"center\", echo=F}\nknitr::include_graphics(here::here(\"images\", \"boxplot.png\"))\n```\n\nWhen using `geom_boxplot()` to create a box plot, you generally map only one axis (x or y) within `aes()`. The axis specified determines if the plots are horizontal or vertical. \n\nIn most geoms, you create a plot per group by mapping an aesthetic like `color = ` or `fill = ` to a column within `aes()`. However, for box plots achieve this by assigning the grouping column to the un-assigned axis (x or y). Below is code for a boxplot of *all* age values in the dataset, and second is code to display one box plot for each (non-missing) gender in the dataset. Note that `NA` (missing) values will appear as a separate box plot unless removed. In this example we also set the `fill` to the column `outcome` so each plot is a different color - but this is not necessary.  \n\n```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}\n# A) Overall boxplot\nggplot(data = linelist)+  \n  geom_boxplot(mapping = aes(y = age))+   # only y axis mapped (not x)\n  labs(title = \"A) Overall boxplot\")\n\n# B) Box plot by group\nggplot(data = linelist, mapping = aes(y = age, x = gender, fill = gender)) + \n  geom_boxplot()+                     \n  theme(legend.position = \"none\")+   # remove legend (redundant)\n  labs(title = \"B) Boxplot by gender\")      \n```\n\nFor code to add a box plot to the edges of a scatter plot (\"marginal\" plots) see the page [ggplot tips].  \n\n\n\n\n\n### Violin, jitter, and sina plots {.unnumbered}\n\nBelow is code for creating **violin plots** (`geom_violin`) and **jitter plots** (`geom_jitter`) to show distributions. You can specify that the fill or color is also determined by the data, by inserting these options within `aes()`. \n\n```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}\n\n\n# A) Jitter plot by group\nggplot(data = linelist %>% drop_na(outcome),      # remove missing values\n       mapping = aes(y = age,                     # Continuous variable\n           x = outcome,                           # Grouping variable\n           color = outcome))+                     # Color variable\n  geom_jitter()+                                  # Create the violin plot\n  labs(title = \"A) jitter plot by gender\")     \n\n\n\n# B) Violin plot by group\nggplot(data = linelist %>% drop_na(outcome),       # remove missing values\n       mapping = aes(y = age,                      # Continuous variable\n           x = outcome,                            # Grouping variable\n           fill = outcome))+                       # fill variable (color)\n  geom_violin()+                                   # create the violin plot\n  labs(title = \"B) violin plot by gender\")    \n```\n\n\nYou can combine the two using the `geom_sina()` function from the **ggforce** package. The sina plots the jitter points in the shape of the violin plot. When overlaid on the violin plot (adjusting the transparencies) this can be easier to visually interpret.  \n\n```{r, warning=F, message=F}\n\n# A) Sina plot by group\nggplot(\n  data = linelist %>% drop_na(outcome), \n  aes(y = age,           # numeric variable\n      x = outcome)) +    # group variable\n  geom_violin(\n    aes(fill = outcome), # fill (color of violin background)\n    color = \"white\",     # white outline\n    alpha = 0.2)+        # transparency\n  geom_sina(\n    size=1,                # Change the size of the jitter\n    aes(color = outcome))+ # color (color of dots)\n  scale_fill_manual(       # Define fill for violin background by death/recover\n    values = c(\"Death\" = \"#bf5300\", \n              \"Recover\" = \"#11118c\")) + \n  scale_color_manual(      # Define colours for points by death/recover\n    values = c(\"Death\" = \"#bf5300\", \n              \"Recover\" = \"#11118c\")) + \n  theme_minimal() +                                # Remove the gray background\n  theme(legend.position = \"none\") +                # Remove unnecessary legend\n  labs(title = \"B) violin and sina plot by gender, with extra formatting\")      \n\n\n```\n\n\n\n### Two continuous variables  {.unnumbered}\n\nFollowing similar syntax, `geom_point()` will allow you to plot two continuous variables against each other in a **scatter plot**. This is useful for showing actual values rather than their distributions. A basic scatter plot of age vs weight is shown in (A). In (B) we again use `facet_grid()` to show the relationship between two continuous variables in the linelist. \n\n```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}\n# Basic scatter plot of weight and age\nggplot(data = linelist, \n       mapping = aes(y = wt_kg, x = age))+\n  geom_point() +\n  labs(title = \"A) Scatter plot of weight and age\")\n\n# Scatter plot of weight and age by gender and Ebola outcome\nggplot(data = linelist %>% drop_na(gender, outcome), # filter retains non-missing gender/outcome\n       mapping = aes(y = wt_kg, x = age))+\n  geom_point() +\n  labs(title = \"B) Scatter plot of weight and age faceted by gender and outcome\")+\n  facet_grid(gender ~ outcome) \n\n```\n\n\n### Three continuous variables {.unnumbered}  \n\nYou can display three continuous variables by utilizing the `fill = ` argument to create a *heat plot*. The color of each \"cell\" will reflect the value of the third continuous column of data. See the [ggplot tips] page and the page on on [Heat plots] for more details and several examples. \n\nThere are ways to make 3D plots in R, but for applied epidemiology these are often difficult to interpret and therefore less useful for decision-making.  \n\n\n\n\n\n\n\n\n\n## Plot categorical data  \n\nCategorical data can be character values, could be logical (TRUE/FALSE), or factors (see the [Factors] page). \n\n### Preparation  {.unnumbered}\n\n#### Data structure {.unnumbered}  \n\nThe first thing to understand about your categorical data is whether it exists as raw observations like a linelist of cases, or as a summary or aggregate data frame that holds counts or proportions. The state of your data will impact which plotting function you use:  \n\n* If your data are raw observations with one row per observation, you will likely use `geom_bar()`  \n* If your data are already aggregated into counts or proportions, you will likely use `geom_col()`  \n\n\n#### Column class and value ordering {.unnumbered}  \n\nNext, examine the class of the columns you want to plot. We look at `hospital`, first with `class()` from **base** R, and with `tabyl()` from **janitor**.  \n\n```{r}\n# View class of hospital column - we can see it is a character\nclass(linelist$hospital)\n\n# Look at values and proportions within hospital column\nlinelist %>% \n  tabyl(hospital)\n```\n\nWe can see the values within are characters, as they are hospital names, and by default they are ordered alphabetically. There are 'other' and 'missing' values, which we would prefer to be the last subcategories when presenting breakdowns. So we change this column into a factor and re-order it. This is covered in more detail in the [Factors] page.\n\n```{r}\n# Convert to factor and define level order so \"Other\" and \"Missing\" are last\nlinelist <- linelist %>% \n  mutate(\n    hospital = fct_relevel(hospital, \n      \"St. Mark's Maternity Hospital (SMMH)\",\n      \"Port Hospital\", \n      \"Central Hospital\",\n      \"Military Hospital\",\n      \"Other\",\n      \"Missing\"))\n\n```\n\n\n```{r}\nlevels(linelist$hospital)\n```\n\n### `geom_bar()` {#ggplot_basics_bars .unnumbered}  \n\nUse `geom_bar()` if you want bar height (or the height of stacked bar components) to reflect *the number of relevant rows in the data*. These bars will have gaps between them, unless the `width = ` plot aesthetic is adjusted.  \n\n* Provide only one axis column assignment (typically x-axis). If you provide x and y, you will get `Error: stat_count() can only have an x or y aesthetic.`  \n* You can create stacked bars by adding a `fill = ` column assignment within `mapping = aes()`  \n* The opposite axis will be titled \"count\" by default, because it represents the number of rows  \n\nBelow, we have assigned outcome to the y-axis, but it could just as easily be on the x-axis. If you have longer character values, it can sometimes look better to flip the bars sideways and put the legend on the bottom. This may impact how your factor levels are ordered - in this case we reverse them with `fct_rev()` to put missing and other at the bottom.    \n\n```{r, out.width=c('50%', '50%'), fig.show='hold'}\n# A) Outcomes in all cases\nggplot(linelist %>% drop_na(outcome)) + \n  geom_bar(aes(y = fct_rev(hospital)), width = 0.7) +\n  theme_minimal()+\n  labs(title = \"A) Number of cases by hospital\",\n       y = \"Hospital\")\n\n\n# B) Outcomes in all cases by hosptial\nggplot(linelist %>% drop_na(outcome)) + \n  geom_bar(aes(y = fct_rev(hospital), fill = outcome), width = 0.7) +\n  theme_minimal()+\n  theme(legend.position = \"bottom\") +\n  labs(title = \"B) Number of recovered and dead Ebola cases, by hospital\",\n       y = \"Hospital\")\n\n```\n\n\n\n\n\n### `geom_col()` {.unnumbered}  \n\nUse `geom_col()` if you want bar height (or height of stacked bar components) to reflect pre-calculated *values* that exists in the data. Often, these are summary or \"aggregated\" counts, or proportions.  \n\nProvide column assignments for *both* axes to `geom_col()`. Typically your x-axis column is discrete and your y-axis column is numeric. \n\nLet's say we have this dataset `outcomes`:  \n\n```{r, echo = F}\noutcomes <- linelist %>% \n  drop_na() %>% \n  group_by(outcome) %>% \n  count %>% \n  ungroup() %>% # Ungroup so proportion is out of total\n  mutate(proportion = n/sum(n)*100) # Caculate percentage\n  \noutcomes #View full table\n```\n\n\n\nBelow is code using `geom_col` for creating  simple bar charts to show the distribution of Ebola patient outcomes. With geom_col, both x and y need to be specified. Here x is the categorical variable along the x axis, and y is the generated proportions column `proportion`. \n\n```{r, fig.height = 3, fig.width=4.5}\n# Outcomes in all cases\nggplot(outcomes) + \n  geom_col(aes(x=outcome, y = proportion)) +\n  labs(subtitle = \"Number of recovered and dead Ebola cases\")\n\n```\n\nTo show breakdowns by hospital, we would need our table to contain more information, and to be in \"long\" format. We create this table with the frequencies of the combined categories `outcome` and `hospital` (see [Grouping data] page for grouping tips). \n\n```{r, fig.height = 4, fig.width=6}\noutcomes2 <- linelist %>% \n  drop_na(outcome) %>% \n  count(hospital, outcome) %>%  # get counts by hospital and outcome\n  group_by(hospital) %>%        # Group so proportions are out of hospital total\n  mutate(proportion = n/sum(n)*100) # calculate proportions of hospital total\n\nhead(outcomes2) # Preview data\n```\n\nWe then create the ggplot with some added formatting:\n\n  * **Axis flip**: Swapped the axis around with `coord_flip()` so that we can read the hospital names.\n  * **Columns side-by-side**: Added a `position = \"dodge\"` argument so that the bars for death and recover are presented side by side rather than stacked. Note stacked bars are the default.\n  * **Column width**: Specified 'width', so the columns are half as thin as the full possible width.\n  * **Column order**: Reversed the order of the categories on the y axis so that 'Other' and 'Missing' are at the bottom, with `scale_x_discrete(limits=rev)`. Note that we used that rather than `scale_y_discrete` because hospital is stated in the `x` argument of `aes()`, even if visually it is on the y axis. We do this because Ggplot seems to present categories backwards unless we tell it not to.  \n  * **Other details**: Labels/titles and colours added within `labs` and `scale_fill_color` respectively.\n  \n```{r, fig.height = 4, fig.width=8}\n\n# Outcomes in all cases by hospital\nggplot(outcomes2) +  \n  geom_col(\n    mapping = aes(\n      x = proportion,                 # show pre-calculated proportion values\n      y = fct_rev(hospital),          # reverse level order so missing/other at bottom\n      fill = outcome),                # stacked by outcome\n    width = 0.5)+                    # thinner bars (out of 1)\n  theme_minimal() +                  # Minimal theme \n  theme(legend.position = \"bottom\")+\n  labs(subtitle = \"Number of recovered and dead Ebola cases, by hospital\",\n       fill = \"Outcome\",             # legend title\n       y = \"Count\",                  # y axis title\n       x = \"Hospital of admission\")+ # x axis title\n  scale_fill_manual(                 # adding colors manually\n    values = c(\"Death\"= \"#3B1c8C\",\n               \"Recover\" = \"#21908D\" )) \n\n```\n\n\nNote that the proportions are binary, so we may prefer to drop 'recover' and just show the proportion who died. This is just for illustration purposes.  \n\n\nIf using `geom_col()` with dates data (e.g. an epicurve from aggregated data) - you will want to adjust the `width = ` argument to remove the \"gap\" lines between the bars. If using daily data set `width = 1`. If weekly, `width = 7`. Months are not possible because each month has a different number of days.  \n\n\n### `geom_histogram()` {.unnumbered}  \n\nHistograms may look like bar charts, but are distinct because they measure the distribution of a *continuous* variable. There are no spaces between the \"bars\", and only one column is provided to `geom_histogram()`. There are arguments specific to histograms such as `bin_width = ` and `breaks = ` to specify how the data should be binned. The section above on continuous data and the page on [Epidemic curves] provide additional detail.  \n\n\n\n## Resources  \n\nThere is a huge amount of help online, especially with ggplot. See:\n\n* [ggplot2 cheat sheet](http://r-statistics.co/ggplot2-cheatsheet.html)\n* [another cheat sheet](https://biostats.w.uib.no/the-ggplot2-cheat-sheet-by-rstudio/)\n* [tidyverse ggplot basics page](https://ggplot2.tidyverse.org/reference/)  \n* [plotting continuous variables](http://www.sthda.com/english/articles/32-r-graphics-essentials/131-plot-two-continuous-variables-scatter-graph-and-alternatives/)  \n* R for Data Science pages on [data visualization](https://r4ds.had.co.nz/data-visualisation.html)\n* [graphics for communicaton](https://r4ds.had.co.nz/graphics-for-communication.html)  \n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"ggplot_basics.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.340","lightbox":true,"theme":{"light":"cosmo","dark":["cosmo","theme-dark.scss"]}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}