{"title":"Pivoting data","markdown":{"headingText":"Pivoting data","headingAttr":{"id":"","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n<!-- ======================================================= -->\n<!-- ======================================================= -->\n<!-- ======================================================= -->\n\n```{r, warning=F, message=F, out.height = c('50%'), fig.align=\"center\", fig.show='hold', echo=F}\nknitr::include_graphics(here::here(\"images\", \"pivoting\", \"Pivoting_500x500.png\"))\n\n#knitr::include_graphics(here::here(\"images\", \"pivoting\", \"pivot_longer_new.png\"))\n#knitr::include_graphics(here::here(\"images\", \"pivoting\", \"pivot_bar.png\"))\n#knitr::include_graphics(here::here(\"images\", \"pivoting\", \"pivot_wider_new.png\"))\n```\n\n\n\nWhen managing data, *pivoting* can be understood to refer to one of two processes:  \n\n1. The creation of *pivot tables*, which are tables of statistics that summarise the data of a more extensive table  \n2. The conversion of a table from **long** to **wide** format, or vice versa. \n\n**In this page, we will focus on the latter definition.** The former is a crucial step in data analysis, and is covered elsewhere in the [Grouping data] and [Descriptive tables] pages. \n\nThis page discusses the formats of data. It is useful to be aware of the idea of \"tidy data\", in which each variable has it's own column, each observation has it's own row, and each value has it's own cell. More about this topic can be found [at this online chapter in R for Data Science](https://r4ds.had.co.nz/tidy-data.html). \n\n\n\n\n\n## Preparation  \n\n### Load packages {.unnumbered}  \n\nThis code chunk shows the loading of packages required for the analyses. In this handbook we emphasize `p_load()` from **pacman**, which installs the package if necessary *and* loads it for use. You can also load installed packages with  `library()` from **base** R. See the page on [R basics] for more information on R packages.  \n\n```{r}\npacman::p_load(\n  rio,          # File import\n  here,         # File locator\n  kableExtra,   # Build and manipulate complex tables\n  tidyverse)    # data management + ggplot2 graphics\n```\n\n\n\n### Import data {.unnumbered}\n\n\n### Malaria count data {-}  \n\nIn this page, we will use a fictional dataset of daily malaria cases, by facility and age group. If you want to follow along, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/malaria_facility_count_data.rds' class='download-button'>click here to download (as .rds file)<span></a>. Import data with the `import()` function from the **rio** package (it handles many file types like .xlsx, .csv, .rds - see the [Import and export] page for details).  \n\n```{r, echo=F}\ncount_data <- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\")) %>% \n  as_tibble()\n```\n\n```{r, eval=F}\n# Import data\ncount_data <- import(\"malaria_facility_count_data.rds\")\n```\n\nThe first 50 rows are displayed below.\n\n```{r, message=FALSE, echo=F}\n# display the linelist data as a table\nDT::datatable(head(count_data, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )\n```\n\n\n### Linelist case data {-}  \n\nIn the later part of this page, we will also use the dataset of cases from a simulated Ebola epidemic. If you want to follow along, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>click to download the \"clean\" linelist</a> (as .rds file). Import your data with the `import()` function from the **rio** package (it accepts many file types like .xlsx, .rds, .csv - see the [Import and export] page for details).  \n\n```{r, echo=F}\n# import the linelist into R\nlinelist <- rio::import(here::here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))\n```\n\n\n```{r, eval=F}\n# import your dataset\nlinelist <- import(\"linelist_cleaned.xlsx\")\n```\n\n\n\n\n\n\n\n<!-- ======================================================= -->\n## Wide-to-long {}\n\n```{r, warning=F, message=F, echo=F}\nknitr::include_graphics(here::here(\"images\", \"pivoting\", \"pivot_longer_new.png\"))\n```\n\n\n<!-- ======================================================= -->\n### \"Wide\" format {.unnumbered}\n\nData are often entered and stored in a \"wide\" format - where a subject's characteristics or responses are stored in a single row. While this may be useful for presentation, it is not ideal for some types of analysis.  \n\nLet us take the `count_data` dataset imported in the Preparation section above as an example. You can see that each row represents a \"facility-day\". The actual case counts (the right-most columns) are stored in a \"wide\" format such that the information for every age group on a given facility-day is stored in a single row.  \n\n```{r, echo=F}\nDT::datatable(count_data, rownames = FALSE, options = list(pageLength = 5, scrollX=T) )\n```\n\nEach observation in this dataset refers to the malaria counts at one of 65 facilities on a given date, ranging from ` count_data$data_date %>% min()` to ` count_data$data_date %>% max()`. These facilities are located in one `Province` (North) and four `District`s (Spring, Bolo, Dingo, and Barnard). The dataset provides the overall counts of malaria, as well as age-specific counts in each of three age groups - <4 years, 5-14 years, and 15 years and older.\n\n\"Wide\" data like this are not adhering to \"tidy data\" standards, because the column headers do not actually represent \"variables\" - they represent *values* of a hypothetical \"age group\" variable. \n\n\nThis format can be useful for presenting the information in a table, or for entering data (e.g. in Excel) from case report forms. However, in the analysis stage, these data typically should be transformed to a \"longer\" format more aligned with \"tidy data\" standards. The plotting R package **ggplot2** in particular works best when data are in a \"long\" format.  \n\n\nVisualising the *total* malaria counts over time poses no difficulty with the data in it's current format:\n\n```{r, warning=F, message=F}\nggplot(count_data) +\n  geom_col(aes(x = data_date, y = malaria_tot), width = 1)\n```\n\nHowever, what if we wanted to display the relative contributions of each age group to this total count? In this case, we need to ensure that the variable of interest (age group), appears in the dataset in a single column that can be passed to `{ggplot2}`'s \"mapping aesthetics\" `aes()` argument.\n\n\n\n\n<!-- ======================================================= -->\n### `pivot_longer()` {.unnumbered}\n\nThe **tidyr** function `pivot_longer()` makes data \"longer\". **tidyr** is part of the **tidyverse** of R packages.  \n\nIt accepts a range of columns to transform (specified to `cols = `). Therefore, it can operate on only a part of a dataset. This is useful for the malaria data, as we only want to pivot the case count columns.  \n\nIn this process, you will end up with two \"new\" columns - one with the categories (the former column names), and one with the corresponding values (e.g. case counts). You can accept the default names for these new columns, or you can specify your own to `names_to = ` and `values_to = ` respectively.  \n\nLet's see `pivot_longer()` in action... \n\n\n\n### Standard pivoting {.unnumbered}  \n\nWe want to use **tidyr**'s `pivot_longer()` function to convert the \"wide\" data to a \"long\" format. Specifically, to convert the four numeric columns with data on malaria counts to two new columns: one which holds the *age groups* and one which holds the corresponding *values*.  \n\n```{r, eval=F}\ndf_long <- count_data %>% \n  pivot_longer(\n    cols = c(`malaria_rdt_0-4`, `malaria_rdt_5-14`, `malaria_rdt_15`, `malaria_tot`)\n  )\n\ndf_long\n```\n\nNotice that the newly created data frame (`df_long`) has more rows (12,152 vs 3,038); it has become *longer*. In fact, it is precisely four times as long, because each row in the original dataset now represents four rows in df_long, one for each of the malaria count observations (<4y, 5-14y, 15y+, and total).\n\nIn addition to becoming longer, the new dataset has fewer columns (8 vs 10), as the data previously stored in four columns (those beginning with the prefix `malaria_`) is now stored in two. \n\nSince the names of these four columns all begin with the prefix `malaria_`, we could have made use of the handy \"tidyselect\" function `starts_with()` to achieve the same result (see the page [Cleaning data and core functions] for more of these helper functions).  \n\n```{r}\n# provide column with a tidyselect helper function\ncount_data %>% \n  pivot_longer(\n    cols = starts_with(\"malaria_\")\n  )\n```\n\nor by position: \n\n```{r, eval=F}\n# provide columns by position\ncount_data %>% \n  pivot_longer(\n    cols = 6:9\n  )\n```\n\nor by named range:\n\n```{r, eval=F}\n# provide range of consecutive columns\ncount_data %>% \n  pivot_longer(\n    cols = `malaria_rdt_0-4`:malaria_tot\n  )\n```\n\n\n\nThese two new columns are given the default names of `name` and `value`, but we can override these defaults to provide more meaningful names, which can help remember what is stored within, using the `names_to` and `values_to` arguments. Let's use the names `age_group` and `counts`:\n\n```{r}\ndf_long <- \n  count_data %>% \n  pivot_longer(\n    cols = starts_with(\"malaria_\"),\n    names_to = \"age_group\",\n    values_to = \"counts\"\n  )\n\ndf_long\n```\n\nWe can now pass this new dataset to `{ggplot2}`, and map the new column `count` to the y-axis and new column `age_group` to the `fill = ` argument (the column internal color). This will display the malaria counts in a stacked bar chart, by age group:\n\n```{r, warning=F, message=F}\nggplot(data = df_long) +\n  geom_col(\n    mapping = aes(x = data_date, y = counts, fill = age_group),\n    width = 1\n  )\n```\n\nExamine this new plot, and compare it with the plot we created earlier - *what has gone wrong?*  \n\nWe have encountered a common problem when wrangling surveillance data - we have also included the total counts from the `malaria_tot` column, so the magnitude of each bar in the plot is twice as high as it should be. \n\nWe can handle this in a number of ways. We could simply filter these totals from the dataset before we pass it to `ggplot()`:\n\n```{r, warning=F, message=F}\ndf_long %>% \n  filter(age_group != \"malaria_tot\") %>% \n  ggplot() +\n  geom_col(\n    aes(x = data_date, y = counts, fill = age_group),\n    width = 1\n  )\n```\n\nAlternatively, we could have excluded this variable when we ran `pivot_longer()`, thereby maintaining it in the dataset as a separate variable. See how its values \"expand\" to fill the new rows. \n\n```{r, warning=F, message=F}\ncount_data %>% \n  pivot_longer(\n    cols = `malaria_rdt_0-4`:malaria_rdt_15,   # does not include the totals column\n    names_to = \"age_group\",\n    values_to = \"counts\"\n  )\n```\n\n\n\n\n\n### Pivoting data of multiple classes {.unnumbered}\n\nThe above example works well in situations in which all the columns you want to \"pivot longer\" are of the same class (character, numeric, logical...). \n\nHowever, there will be many cases when, as a field epidemiologist, you will be working with data that was prepared by non-specialists and which follow their own non-standard logic - as Hadley Wickham noted (referencing Tolstoy) in his [seminal article](https://vita.had.co.nz/papers/tidy-data.pdf) on **Tidy Data** principles: \"Like families, tidy datasets are all alike but every messy dataset is messy in its own way.\"\n\nOne particularly common problem you will encounter will be the need to pivot columns that contain different classes of data. This pivot will result in storing these different data types in a single column, which is not a good situation. There are various approaches one can take to separate out the mess this creates, but there is an important step you can take using `pivot_longer()` to avoid creating such a situation yourself.\n\nTake a situation in which there have been a series of observations at different time steps for each of three items A, B and C. Examples of such items could be individuals (e.g. contacts of an Ebola case being traced each day for 21 days) or remote village health posts being monitored once per year to ensure they are still functional. Let's use the contact tracing example. Imagine that the data are stored as follows:\n\n\n```{r, message=FALSE, echo=F}\n\ndf <- \n  tibble::tribble(\n     ~id,   ~obs1_date, ~obs1_status,   ~obs2_date, ~obs2_status,   ~obs3_date, ~obs3_status,\n     \"A\", \"2021-04-23\",    \"Healthy\", \"2021-04-24\",    \"Healthy\", \"2021-04-25\",     \"Unwell\",\n     \"B\", \"2021-04-23\",    \"Healthy\", \"2021-04-24\",    \"Healthy\", \"2021-04-25\",    \"Healthy\",\n     \"C\", \"2021-04-23\",    \"Missing\", \"2021-04-24\",    \"Healthy\", \"2021-04-25\",    \"Healthy\"\n     ) \n\nDT::datatable(df, rownames = FALSE)\n\n```\n\nAs can be seen, the data are a bit complicated. Each row stores information about one item, but with the time series running further and further away to the right as time progresses. Moreover, the column classes alternate between date and character values.  \n\nOne particularly bad example of this encountered by this author involved cholera surveillance data, in which 8 new columns of observations were added *each day* over the course of __4 years__. Simply opening the Excel file in which these data were stored took >10 minuntes on my laptop!\n\nIn order to work with these data, we need to transform the data frame to long format, but keeping the separation between a `date` column and a `character` (status) column, for each observation for each item. If we don't, we might end up with a mixture of variable types in a single column (a very big \"no-no\" when it comes to data management and tidy data):\n\n```{r}\ndf %>% \n  pivot_longer(\n    cols = -id,\n    names_to = c(\"observation\")\n  )\n\n```\n\nAbove, our pivot has merged *dates* and *characters* into a single `value` column. R will react by converting the entire column to class character, and the utility of the dates is lost.  \n\nTo prevent this situation, we can take advantage of the syntax structure of the original column names. There is a common naming structure, with the observation number, an underscore, and then either \"status\" or \"date\". We can leverage this syntax to keep these two data types in separate columns after the pivot. \n\nWe do this by:  \n\n* Providing a character vector to the `names_to = ` argument, with the second item being (`\".value\"` ). This special term indicates that the pivoted columns will be split based on a character in their name...  \n* You must also provide the \"splitting\" character to the `names_sep = ` argument. In this case, it is the underscore \"_\".  \n\nThus, the naming and split of new columns is based around the underscore in the existing variable names.  \n\n```{r}\n\ndf_long <- \n  df %>% \n  pivot_longer(\n    cols = -id,\n    names_to = c(\"observation\", \".value\"),\n    names_sep = \"_\"\n  )\n\ndf_long\n\n```\n\n__Finishing touches__:\n\nNote that the `date` column is currently in *character* class - we can easily convert this into it's proper date class using the `mutate()` and `as_date()` functions described in the [Working with dates] page.  \n\nWe may also want to convert the `observation` column to a `numeric` format by dropping the \"obs\" prefix and converting to numeric. We cando this with `str_remove_all()` from the **stringr** package (see the [Characters and strings] page).  \n\n```{r}\n\ndf_long <- \n  df_long %>% \n  mutate(\n    date = date %>% lubridate::as_date(),\n    observation = \n      observation %>% \n      str_remove_all(\"obs\") %>% \n      as.numeric()\n  )\n\ndf_long\n\n```\n\nAnd now, we can start to work with the data in this format, e.g. by plotting a descriptive heat tile:  \n\n```{r}\nggplot(data = df_long, mapping = aes(x = date, y = id, fill = status)) +\n  geom_tile(colour = \"black\") +\n  scale_fill_manual(\n    values = \n      c(\"Healthy\" = \"lightgreen\", \n        \"Unwell\" = \"red\", \n        \"Missing\" = \"orange\")\n  )\n\n```\n\n\n\n\n\n<!-- ======================================================= -->\n## Long-to-wide {}\n\n```{r, warning=F, message=F, echo=F}\nknitr::include_graphics(here::here(\"images\", \"pivoting\", \"pivot_wider_new.png\"))\n```\n\n\nIn some instances, we may wish to convert a dataset to a wider format. For this, we can use the `pivot_wider()` function.\n\nA typical use-case is when we want to transform the results of an analysis into a format which is more digestible for the reader (such as a [Table for presentation][Tables for presentation]). Usually, this involves transforming a dataset in which information for one subject is are spread over multiple rows into a format in which that information is stored in a single row.\n\n### Data {.unnumbered}\n\nFor this section of the page, we will use the case linelist (see the [Preparation](#pivot_prep) section), which contains one row per case.  \n\nHere are the first 50 rows:  \n\n```{r, message=FALSE, echo=F}\n# display the linelist data as a table\nDT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )\n```\n\n\nSuppose that we want to know the counts of individuals in the different age groups, by gender:\n\n```{r}\ndf_wide <- \n  linelist %>% \n  count(age_cat, gender)\n\ndf_wide\n```\n\nThis gives us a long dataset that is great for producing visualisations in **ggplot2**, but not ideal for presentation in a table:\n\n```{r}\nggplot(df_wide) +\n  geom_col(aes(x = age_cat, y = n, fill = gender))\n```\n\n### Pivot wider {.unnumbered}  \n\nTherefore, we can use `pivot_wider()` to transform the data into a better format for inclusion as tables in our reports.  \n\nThe argument `names_from` specifies the column *from* which to generate the new column *names*, while the argument `values_from` specifies the column *from* which to take the *values* to populate the cells. The argument `id_cols = ` is optional, but can be provided a vector of column names that should not be pivoted, and will thus identify each row.  \n\n```{r}\ntable_wide <- \n  df_wide %>% \n  pivot_wider(\n    id_cols = age_cat,\n    names_from = gender,\n    values_from = n\n  )\n\ntable_wide\n```\n\nThis table is much more reader-friendly, and therefore better for inclusion in our reports. You can convert into a pretty table with several packages including **flextable** and **knitr**. This process is elaborated in the page [Tables for presentation].  \n\n```{r}\ntable_wide %>% \n  janitor::adorn_totals(c(\"row\", \"col\")) %>% # adds row and column totals\n  knitr::kable() %>% \n  kableExtra::row_spec(row = 10, bold = TRUE) %>% \n  kableExtra::column_spec(column = 5, bold = TRUE) \n```\n\n---\n\n\n<!-- ======================================================= -->\n## Fill \n\nIn some situations after a `pivot`, and more commonly after a `bind`, we are left with gaps in some cells that we would like to fill.  \n\n<!-- ======================================================= -->\n### Data {.unnumbered}\n\nFor example, take two datasets, each with observations for the measurement number, the name of the facility, and the case count at that time. However, the second dataset also has a variable `Year`. \n\n```{r}\ndf1 <- \n  tibble::tribble(\n       ~Measurement, ~Facility, ~Cases,\n                  1,  \"Hosp 1\",     66,\n                  2,  \"Hosp 1\",     26,\n                  3,  \"Hosp 1\",      8,\n                  1,  \"Hosp 2\",     71,\n                  2,  \"Hosp 2\",     62,\n                  3,  \"Hosp 2\",     70,\n                  1,  \"Hosp 3\",     47,\n                  2,  \"Hosp 3\",     70,\n                  3,  \"Hosp 3\",     38,\n       )\n\ndf1 \n\ndf2 <- \n  tibble::tribble(\n    ~Year, ~Measurement, ~Facility, ~Cases,\n     2000,            1,  \"Hosp 4\",     82,\n     2001,            2,  \"Hosp 4\",     87,\n     2002,            3,  \"Hosp 4\",     46\n  )\n\ndf2\n```\n\n\nWhen we perform a `bind_rows()` to join the two datasets together, the `Year` variable is filled with `NA` for those rows where there was no prior information (i.e. the first dataset):\n\n\n```{r}\ndf_combined <- \n  bind_rows(df1, df2) %>% \n  arrange(Measurement, Facility)\n\ndf_combined\n\n```\n\n<!-- ======================================================= -->\n### `fill()` {.unnumbered}\n\nIn this case, `Year` is a useful variable to include, particularly if we want to explore trends over time. Therefore, we use `fill()` to *fill* in those empty cells, by specifying the column to fill and the direction (in this case **up**):\n\n```{r}\ndf_combined %>% \n  fill(Year, .direction = \"up\")\n```\n\nAlternatively, we can rearrange the data so that we would need to fill in a downward direction:\n\n```{r}\ndf_combined <- \n  df_combined %>% \n  arrange(Measurement, desc(Facility))\n\ndf_combined\n\ndf_combined <- \n  df_combined %>% \n  fill(Year, .direction = \"down\")\n\ndf_combined\n```\n\nWe now have a useful dataset for plotting:\n\n```{r}\nggplot(df_combined) +\n  aes(Year, Cases, fill = Facility) +\n  geom_col()\n```\n\nBut less useful for presenting in a table, so let's practice converting this long, untidy dataframe into a wider, tidy dataframe:\n\n```{r}\ndf_combined %>% \n  pivot_wider(\n    id_cols = c(Measurement, Facility),\n    names_from = \"Year\",\n    values_from = \"Cases\"\n  ) %>% \n  arrange(Facility) %>% \n  janitor::adorn_totals(c(\"row\", \"col\")) %>% \n  knitr::kable() %>% \n  kableExtra::row_spec(row = 5, bold = TRUE) %>% \n  kableExtra::column_spec(column = 5, bold = TRUE) \n```\n\nN.B. In this case, we had to specify to only include the three variables `Facility`, `Year`, and `Cases` as the additional variable `Measurement` would interfere with the creation of the table:\n\n```{r}\ndf_combined %>% \n  pivot_wider(\n    names_from = \"Year\",\n    values_from = \"Cases\"\n  ) %>% \n  knitr::kable()\n```\n\n## Resources  \n\nHere is a helpful [tutorial](https://datacarpentry.org/r-socialsci/03-dplyr-tidyr/index.html)\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"pivoting.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.340","lightbox":true,"theme":{"light":"cosmo","dark":["cosmo","theme-dark.scss"]}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}