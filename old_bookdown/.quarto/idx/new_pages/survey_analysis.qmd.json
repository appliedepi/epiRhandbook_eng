{"title":"Survey analysis","markdown":{"headingText":"Survey analysis","headingAttr":{"id":"","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n<!-- ======================================================= -->\n## Overview {  }\n\nThis page demonstrates the use of several packages for survey analysis. \n\n\nMost survey R packages rely on the [**survey** package](https://cran.r-project.org/web/packages/survey/index.html) \nfor doing weighted analysis. \nWe will use **survey** as well as [**srvyr**](https://cran.r-project.org/web/packages/srvyr/index.html) \n(a wrapper for **survey** allowing for tidyverse-style coding) and\n[**gtsummary**](https://cran.r-project.org/web/packages/gtsummary/index.html) \n(a wrapper for **survey** allowing for publication ready tables). \nWhile the original **survey** package does not allow for tidyverse-style coding, \nit does have the added benefit of allowing for survey-weighted generalised linear \nmodels (which will be added to this page at a later date). \nWe will also demonstrate using a function from the [**sitrep**](https://github.com/R4EPI/sitrep)\npackage to create sampling weights (*n.b* this package is currently not yet on CRAN, \nbut can be installed from github).\n\nMost of this page is based off work done for the [\"R4Epis\" project](https://r4epis.netlify.app/); \nfor detailed code and R-markdown templates see the [\"R4Epis\" github page](https://github.com/R4EPI/sitrep). \nSome of the **survey** package based code is based off early versions of \n[EPIET case studies](https://github.com/EPIET/RapidAssessmentSurveys).\n\nAt current this page does not address sample size calculations or sampling. \nFor a simple to use sample size calculator see [OpenEpi](https://www.openepi.com/Menu/OE_Menu.htm). \nThe [GIS basics](https://epirhandbook.com/gis-basics.html) page of the handbook \nwill eventually have a section on spatial random sampling, and this page will \neventually have a section on sampling frames as well as sample size calculations. \n\n\n\n1.  Survey data \n2.  Observation time \n3.  Weighting \n4.  Survey design objects\n5.  Descriptive analysis \n6.  Weighted proportions\n7.  Weighted rates \n\n\n<!-- ======================================================= -->\n## Preparation {  }\n\n### Packages {.unnumbered}\n\nThis code chunk shows the loading of packages required for the analyses. In this handbook we emphasize `p_load()` from **pacman**, which installs the package if necessary *and* loads it for use. You can also load packages with `library()` from **base** R. See the page on [R basics] for more information on R packages.  \nHere we also demonstrate using the `p_load_gh()` function from **pacman** to install a load a package from github which has not yet been published on CRAN. \n\n```{r}\n\n## load packages from CRAN\npacman::p_load(rio,          # File import\n               here,         # File locator\n               tidyverse,    # data management + ggplot2 graphics\n               tsibble,      # handle time series datasets\n               survey,       # for survey functions\n               srvyr,        # dplyr wrapper for survey package\n               gtsummary,    # wrapper for survey package to produce tables\n               apyramid,     # a package dedicated to creating age pyramids\n               patchwork,    # for combining ggplots\n               ggforce       # for alluvial/sankey plots\n               ) \n\n## load packages from github\npacman::p_load_gh(\n     \"R4EPI/sitrep\"          # for observation time / weighting functions\n)\n\n``` \n\n### Load data {.unnumbered}\n\nThe example dataset used in this section:\n\n-   fictional mortality survey data.\n-   fictional population counts for the survey area. \n-   data dictionary for the fictional mortality survey data. \n\nThis is based off the MSF OCA ethical review board pre-approved survey. The \nfictional dataset was produced as part of the [\"R4Epis\" project](https://r4epis.netlify.app/). \nThis is all based off data collected using [KoboToolbox](https://www.kobotoolbox.org/), \nwhich is a data collection software based off [Open Data Kit](https://opendatakit.org/).\n\nKobo allows you to export both the collected data, as well as the data dictionary \nfor that dataset. We strongly recommend doing this as it simplifies data cleaning \nand is useful for looking up variables/questions. \n\n\n<span style=\"color: darkgreen;\">**_TIP:_** The Kobo data dictionary has variable\nnames in the \"name\" column of the survey sheet. \nPossible values for each variable are specified in choices sheet. \nIn the choices tab, \"name\" has the shortened value and the \"label::english\" and \n\"label::french\" columns have the appropriate long versions. \nUsing the **epidict** package `msf_dict_survey()` function to import a Kobo \ndictionary excel file will re-format this for you so it can be used easily to recode.  </span>\n\n<span style=\"color: orange;\">**_CAUTION:_** The example dataset is not the same \nas an export (as in Kobo you export different questionnaire levels individually) \n- see the survey data section below to merge the different levels.</span>\n\n\nThe dataset is imported using the `import()` function from the **rio** package. See the page on [Import and export](https://epirhandbook.com/import-and-export.html) for various ways to import data.\n\n```{r echo = FALSE}\n# import the survey into R\nsurvey_data <- rio::import(here::here(\"data\", \"surveys\", \"survey_data.xlsx\"))\n\n# import the dictionary into R\nsurvey_dict <- rio::import(here::here(\"data\", \"surveys\", \"survey_dict.xlsx\")) \n\n# import the population in to R \npopulation <- rio::import(here::here(\"data\", \"surveys\", \"population.xlsx\"))\n```\n\n```{r eval = FALSE}\n# import the survey data\nsurvey_data <- rio::import(\"survey_data.xlsx\")\n\n# import the dictionary into R\nsurvey_dict <- rio::import(\"survey_dict.xlsx\") \n```\n\nThe first 10 rows of the survey are displayed below.\n\n```{r, message = FALSE, echo = FALSE}\n# display the survey data as a table\nDT::datatable(head(survey_data, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )\n```\n\nWe also want to import the data on sampling population so that we can produce \nappropriate weights. This data can be in different formats, however we would \nsuggest to have it as seen below (this can just be typed in to an excel). \n\n\n```{r read_data_pop_show, eval = FALSE}\n# import the population data\npopulation <- rio::import(\"population.xlsx\")\n```\n\nThe first 10 rows of the survey are displayed below.\n\n```{r message=FALSE, echo=F}\n# display the survey data as a table\nDT::datatable(head(population, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )\n```\n\nFor cluster surveys you may want to add survey weights at the cluster level. \nYou could read this data in as above. \nAlternatively if there are only a few counts, these could be entered as below\nin to a tibble. \nIn any case you will need to have one column with a cluster identifier which \nmatches your survey data, and another column with the number of households in \neach cluster. \n\n```{r cluster_counts}\n\n## define the number of households in each cluster\ncluster_counts <- tibble(cluster = c(\"village_1\", \"village_2\", \"village_3\", \"village_4\", \n                                     \"village_5\", \"village_6\", \"village_7\", \"village_8\",\n                                     \"village_9\", \"village_10\"), \n                         households = c(700, 400, 600, 500, 300, \n                                        800, 700, 400, 500, 500))\n\n```\n\n### Clean data {.unnumbered}\n\nThe below makes sure that the date column is in the appropriate format. \nThere are several other ways of doing this (see the [Working with dates](https://epirhandbook.com/working-with-dates.html)\npage for details), however using the dictionary to define dates is quick and easy. \n\nWe also create an age group variable using the `age_categories()` function from \n**epikit** - see [cleaning data](https://epirhandbook.com/cleaning-data-and-core-functions.html#num_cats)\nhandbook section for details. \nIn addition, we create a character variable defining which district the various clusters\nare in. \n\nFinally, we recode all of the yes/no variables to TRUE/FALSE variables - otherwise\nthese cant be used by the **survey** proportion functions. \n\n```{r cleaning}\n\n## select the date variable names from the dictionary \nDATEVARS <- survey_dict %>% \n  filter(type == \"date\") %>% \n  filter(name %in% names(survey_data)) %>% \n  ## filter to match the column names of your data\n  pull(name) # select date vars\n  \n## change to dates \nsurvey_data <- survey_data %>%\n  mutate(across(all_of(DATEVARS), as.Date))\n\n\n## add those with only age in months to the year variable (divide by twelve)\nsurvey_data <- survey_data %>% \n  mutate(age_years = if_else(is.na(age_years), \n                             age_months / 12, \n                             age_years))\n\n## define age group variable\nsurvey_data <- survey_data %>% \n     mutate(age_group = age_categories(age_years, \n                                    breakers = c(0, 3, 15, 30, 45)\n                                    ))\n\n\n## create a character variable based off groups of a different variable \nsurvey_data <- survey_data %>% \n  mutate(health_district = case_when(\n    cluster_number %in% c(1:5) ~ \"district_a\", \n    TRUE ~ \"district_b\"\n  ))\n\n\n## select the yes/no variable names from the dictionary \nYNVARS <- survey_dict %>% \n  filter(type == \"yn\") %>% \n  filter(name %in% names(survey_data)) %>% \n  ## filter to match the column names of your data\n  pull(name) # select yn vars\n  \n## change to dates \nsurvey_data <- survey_data %>%\n  mutate(across(all_of(YNVARS), \n                str_detect, \n                pattern = \"yes\"))\n\n```\n\n\n\n<!-- ======================================================= -->\n## Survey data {  }\n\nThere numerous different sampling designs that can be used for surveys. Here \nwe will demonstrate code for: \n- Stratified \n- Cluster \n- Stratified and cluster \n\nAs described above (depending on how you design your questionnaire) the data for \neach level would be exported as a separate dataset from Kobo. In our example there\nis one level for households and one level for individuals within those households. \n\nThese two levels are linked by a unique identifier. \nFor a Kobo dataset this variable is \"_index\" at the household level, which \nmatches the \"_parent_index\" at the individual level.\nThis will create new rows for household with each matching individual, \nsee the handbook section on [joining](https://epirhandbook.com/joining-data.html)\nfor details. \n\n```{r merge_data_levels, eval = FALSE}\n\n## join the individual and household data to form a complete data set\nsurvey_data <- left_join(survey_data_hh, \n                         survey_data_indiv,\n                         by = c(\"_index\" = \"_parent_index\"))\n\n\n## create a unique identifier by combining indeces of the two levels \nsurvey_data <- survey_data %>% \n     mutate(uid = str_glue(\"{index}_{index_y}\"))\n\n```\n\n<!-- ======================================================= -->\n## Observation time {  }\n\nFor mortality surveys we want to now how long each individual was present for in \nthe location to be able to calculate an appropriate mortality rate for our period \nof interest. This is not relevant to all surveys, but particularly for mortality\nsurveys this is important as they are conducted frequently among mobile or displaced\npopulations. \n\nTo do this we first define our time period of interest, also known as a recall \nperiod (i.e. the time that participants are asked to report on when answering \nquestions). \nWe can then use this period to set inappropriate dates to missing, i.e. if deaths\nare reported from outside the period of interest. \n\n```{r recall_period}\n\n## set the start/end of recall period\n## can be changed to date variables from dataset \n## (e.g. arrival date & date questionnaire)\nsurvey_data <- survey_data %>% \n  mutate(recall_start = as.Date(\"2018-01-01\"), \n         recall_end   = as.Date(\"2018-05-01\")\n  )\n\n\n# set inappropriate dates to NA based on rules \n## e.g. arrivals before start, departures departures after end\nsurvey_data <- survey_data %>%\n      mutate(\n           arrived_date = if_else(arrived_date < recall_start, \n                                 as.Date(NA),\n                                  arrived_date),\n           birthday_date = if_else(birthday_date < recall_start,\n                                  as.Date(NA),\n                                  birthday_date),\n           left_date = if_else(left_date > recall_end,\n                              as.Date(NA),\n                               left_date),\n           death_date = if_else(death_date > recall_end,\n                               as.Date(NA),\n                               death_date)\n           )\n\n```\n\n\nWe can then use our date variables to define start and end dates for each individual. \nWe can use the `find_start_date()` function from **sitrep** to fine the causes for \nthe dates and then use that to calculate the difference between days (person-time). \n\nstart date: \nEarliest appropriate arrival event within your recall period\nEither the beginning of your recall period (which you define in advance), or a \ndate after the start of recall if applicable (e.g. arrivals or births)\n\nend date: \nEarliest appropriate departure event within your recall period\nEither the end of your recall period, or a date before the end of recall \nif applicable (e.g. departures, deaths)\n\n```{r observation_time}\n\n## create new variables for start and end dates/causes\nsurvey_data <- survey_data %>% \n     ## choose earliest date entered in survey\n     ## from births, household arrivals, and camp arrivals \n     find_start_date(\"birthday_date\",\n                  \"arrived_date\",\n                  period_start = \"recall_start\",\n                  period_end   = \"recall_end\",\n                  datecol      = \"startdate\",\n                  datereason   = \"startcause\" \n                 ) %>%\n     ## choose earliest date entered in survey\n     ## from camp departures, death and end of the study\n     find_end_date(\"left_date\",\n                \"death_date\",\n                period_start = \"recall_start\",\n                period_end   = \"recall_end\",\n                datecol      = \"enddate\",\n                datereason   = \"endcause\" \n               )\n\n\n## label those that were present at the start/end (except births/deaths)\nsurvey_data <- survey_data %>% \n     mutate(\n       ## fill in start date to be the beginning of recall period (for those empty) \n       startdate = if_else(is.na(startdate), recall_start, startdate), \n       ## set the start cause to present at start if equal to recall period \n       ## unless it is equal to the birth date \n       startcause = if_else(startdate == recall_start & startcause != \"birthday_date\",\n                              \"Present at start\", startcause), \n       ## fill in end date to be end of recall period (for those empty) \n       enddate = if_else(is.na(enddate), recall_end, enddate), \n       ## set the end cause to present at end if equall to recall end \n       ## unless it is equal to the death date\n       endcause = if_else(enddate == recall_end & endcause != \"death_date\", \n                            \"Present at end\", endcause))\n\n\n## Define observation time in days\nsurvey_data <- survey_data %>% \n  mutate(obstime = as.numeric(enddate - startdate))\n\n```\n\n\n<!-- ======================================================= -->\n## Weighting {  }\n\nIt is important that you drop erroneous observations before adding survey weights. \nFor example if you have observations with negative observation time, you will need\nto check those (you can do this with the `assert_positive_timespan()` function \nfrom **sitrep**. \nAnother thing is if you want to drop empty rows (e.g. with `drop_na(uid)`)\nor remove duplicates (see handbook section on [De-duplication] \nfor details). \nThose without consent need to be dropped too. \n\nIn this example we filter for the cases we want to drop and store them in a separate\ndata frame - this way we can describe those that were excluded from the survey. \nWe then use the `anti_join()` function from **dplyr** to remove these dropped cases\nfrom our survey data. \n\n<span style=\"color: red;\">**_DANGER:_** You cant have missing values in your weight variable, or any of the variables relevant to your survey design (e.g. age, sex, strata or cluster variables).</span>  \n\n```{r remove_unused_data}\n\n## store the cases that you drop so you can describe them (e.g. non-consenting \n## or wrong village/cluster)\ndropped <- survey_data %>% \n  filter(!consent | is.na(startdate) | is.na(enddate) | village_name == \"other\")\n\n## use the dropped cases to remove the unused rows from the survey data set  \nsurvey_data <- anti_join(survey_data, dropped, by = names(dropped))\n\n```\n\nAs mentioned above we demonstrate how to add weights for three different study \ndesigns (stratified, cluster and stratified cluster). These require information \non the source population and/or the clusters surveyed. \nWe will use the stratified cluster code for this example, but use whichever is\nmost appropriate for your study design. \n\n```{r survey_weights}\n\n# stratified ------------------------------------------------------------------\n# create a variable called \"surv_weight_strata\"\n# contains weights for each individual - by age group, sex and health district\nsurvey_data <- add_weights_strata(x = survey_data,\n                                         p = population,\n                                         surv_weight = \"surv_weight_strata\",\n                                         surv_weight_ID = \"surv_weight_ID_strata\",\n                                         age_group, sex, health_district)\n\n## cluster ---------------------------------------------------------------------\n\n# get the number of people of individuals interviewed per household\n# adds a variable with counts of the household (parent) index variable\nsurvey_data <- survey_data %>%\n  add_count(index, name = \"interviewed\")\n\n\n## create cluster weights\nsurvey_data <- add_weights_cluster(x = survey_data,\n                                          cl = cluster_counts,\n                                          eligible = member_number,\n                                          interviewed = interviewed,\n                                          cluster_x = village_name,\n                                          cluster_cl = cluster,\n                                          household_x = index,\n                                          household_cl = households,\n                                          surv_weight = \"surv_weight_cluster\",\n                                          surv_weight_ID = \"surv_weight_ID_cluster\",\n                                          ignore_cluster = FALSE,\n                                          ignore_household = FALSE)\n\n\n# stratified and cluster ------------------------------------------------------\n# create a survey weight for cluster and strata\nsurvey_data <- survey_data %>%\n  mutate(surv_weight_cluster_strata = surv_weight_strata * surv_weight_cluster)\n\n```\n\n\n<!-- ======================================================= -->\n## Survey design objects {  }\n\nCreate survey object according to your study design. \nUsed the same way as data frames to calculate weight proportions etc. \nMake sure that all necessary variables are created before this. \n\nThere are four options, comment out those you do not use: \n- Simple random \n- Stratified \n- Cluster \n- Stratified cluster\n\nFor this template - we will pretend that we cluster surveys in two separate \nstrata (health districts A and B). \nSo to get overall estimates we need have combined cluster and strata weights. \n\nAs mentioned previously, there are two packages available for doing this. The \nclassic one is **survey** and then there is a wrapper package called **srvyr** \nthat makes tidyverse-friendly objects and functions. We will demonstrate both, \nbut note that most of the code in this chapter will use **srvyr** based objects. \nThe one exception is that the **gtsummary** package only accepts **survey** objects. \n\n### **Survey** package  \n\nThe **survey** package effectively uses **base** *R* coding, and so it is not \npossible to use pipes (`%>%`) or other **dplyr** syntax. \nWith the **survey** package we use the `svydesign()` function to define a survey\nobject with appropriate clusters, weights and strata. \n\n<span style=\"color: black;\">**_NOTE:_** we need to use the tilde (`~`) in front of variables, this is because the package uses the **base** *R* syntax of assigning variables based on formulae. </span>\n\n```{r survey_design}\n\n# simple random ---------------------------------------------------------------\nbase_survey_design_simple <- svydesign(ids = ~1, # 1 for no cluster ids\n                   weights = NULL,               # No weight added\n                   strata = NULL,                # sampling was simple (no strata)\n                   data = survey_data            # have to specify the dataset\n                  )\n\n## stratified ------------------------------------------------------------------\nbase_survey_design_strata <- svydesign(ids = ~1,  # 1 for no cluster ids\n                   weights = ~surv_weight_strata, # weight variable created above\n                   strata = ~health_district,     # sampling was stratified by district\n                   data = survey_data             # have to specify the dataset\n                  )\n\n# cluster ---------------------------------------------------------------------\nbase_survey_design_cluster <- svydesign(ids = ~village_name, # cluster ids\n                   weights = ~surv_weight_cluster, # weight variable created above\n                   strata = NULL,                 # sampling was simple (no strata)\n                   data = survey_data              # have to specify the dataset\n                  )\n\n# stratified cluster ----------------------------------------------------------\nbase_survey_design <- svydesign(ids = ~village_name,      # cluster ids\n                   weights = ~surv_weight_cluster_strata, # weight variable created above\n                   strata = ~health_district,             # sampling was stratified by district\n                   data = survey_data                     # have to specify the dataset\n                  )\n```\n\n\n\n### **Srvyr** package  \n\nWith the **srvyr** package we can use the `as_survey_design()` function, which \nhas all the same arguments as above but allows pipes (`%>%`), and so we do not \nneed to use the tilde (`~`). \n\n```{r survey_design_srvyr}\n## simple random ---------------------------------------------------------------\nsurvey_design_simple <- survey_data %>% \n  as_survey_design(ids = 1, # 1 for no cluster ids \n                   weights = NULL, # No weight added\n                   strata = NULL # sampling was simple (no strata)\n                  )\n## stratified ------------------------------------------------------------------\nsurvey_design_strata <- survey_data %>%\n  as_survey_design(ids = 1, # 1 for no cluster ids\n                   weights = surv_weight_strata, # weight variable created above\n                   strata = health_district # sampling was stratified by district\n                  )\n## cluster ---------------------------------------------------------------------\nsurvey_design_cluster <- survey_data %>%\n  as_survey_design(ids = village_name, # cluster ids\n                   weights = surv_weight_cluster, # weight variable created above\n                   strata = NULL # sampling was simple (no strata)\n                  )\n\n## stratified cluster ----------------------------------------------------------\nsurvey_design <- survey_data %>%\n  as_survey_design(ids = village_name, # cluster ids\n                   weights = surv_weight_cluster_strata, # weight variable created above\n                   strata = health_district # sampling was stratified by district\n                  )\n```\n\n<!-- ======================================================= -->\n## Descriptive analysis {  }\n\nBasic descriptive analysis and visualisation is covered extensively in other \nchapters of the handbook, so we will not dwell on it here. \nFor details see the chapters on [descriptive tables](https://epirhandbook.com/descriptive-tables.html), \n[statistical tests](https://epirhandbook.com/simple-statistical-tests.html), \n[tables for presentation](https://epirhandbook.com/tables-for-presentation.html), \n[ggplot basics](https://epirhandbook.com/ggplot-basics.html) and \n[R markdown reports](https://epirhandbook.com/r-markdown-reports.html). \n\nIn this section we will focus on how to investigate bias in your sample and visualise this. \nWe will also look at visualising population flow in a survey setting using \nalluvial/sankey diagrams. \n\nIn general, you should consider including the following descriptive analyses:  \n\n- Final number of clusters, households and individuals included  \n- Number of excluded individuals and the reasons for exclusion \n- Median (range) number of households per cluster and individuals per household \n\n\n### Sampling bias \n\nCompare the proportions in each age group between your sample and \nthe source population. \nThis is important to be able to highlight potential sampling bias. \nYou could similarly repeat this looking at distributions by sex. \n\nNote that these p-values are just indicative, and a descriptive discussion (or\nvisualisation with age-pyramids below) of the distributions in your study sample \ncompared to the source population is more important than the binomial test itself.\nThis is because increasing sample size will more often than not lead to \ndifferences that may be irrelevant after weighting your data.\n\n```{r descriptive_sampling_bias, warning = FALSE}\n\n## counts and props of the study population\nag <- survey_data %>% \n  group_by(age_group) %>% \n  drop_na(age_group) %>% \n  tally() %>% \n  mutate(proportion = n / sum(n), \n         n_total = sum(n))\n\n## counts and props of the source population\npropcount <- population %>% \n  group_by(age_group) %>%\n    tally(population) %>%\n    mutate(proportion = n / sum(n))\n\n## bind together the columns of two tables, group by age, and perform a \n## binomial test to see if n/total is significantly different from population\n## proportion.\n  ## suffix here adds to text to the end of columns in each of the two datasets\nleft_join(ag, propcount, by = \"age_group\", suffix = c(\"\", \"_pop\")) %>%\n  group_by(age_group) %>%\n  ## broom::tidy(binom.test()) makes a data frame out of the binomial test and\n  ## will add the variables p.value, parameter, conf.low, conf.high, method, and\n  ## alternative. We will only use p.value here. You can include other\n  ## columns if you want to report confidence intervals\n  mutate(binom = list(broom::tidy(binom.test(n, n_total, proportion_pop)))) %>%\n  unnest(cols = c(binom)) %>% # important for expanding the binom.test data frame\n  mutate(proportion_pop = proportion_pop * 100) %>%\n  ## Adjusting the p-values to correct for false positives \n  ## (because testing multiple age groups). This will only make \n  ## a difference if you have many age categories\n  mutate(p.value = p.adjust(p.value, method = \"holm\")) %>%\n                      \n  ## Only show p-values over 0.001 (those under report as <0.001)\n  mutate(p.value = ifelse(p.value < 0.001, \n                          \"<0.001\", \n                          as.character(round(p.value, 3)))) %>% \n  \n  ## rename the columns appropriately\n  select(\n    \"Age group\" = age_group,\n    \"Study population (n)\" = n,\n    \"Study population (%)\" = proportion,\n    \"Source population (n)\" = n_pop,\n    \"Source population (%)\" = proportion_pop,\n    \"P-value\" = p.value\n  )\n```\n\n\n\n### Demographic pyramids \n\nDemographic (or age-sex) pyramids are an easy way of visualising the distribution\nin your survey population. It is also worth considering creating \n[descriptive tables](https://epirhandbook.com/descriptive-tables.html) of age \nand sex by survey strata. \nWe will demonstrate using the **apyramid** package as it allows for weighted \nproportions using our survey design object created above. Other options for creating\n[demographic pyramids](https://epirhandbook.com/demographic-pyramids-and-likert-scales.html)\nare covered extensively in that chapter of the handbook. We will also use a \nwrapper function from **apyramid** called `age_pyramid()` which saves a few lines\nof coding for producing a plot with proportions. \n\nAs with the formal binomial test of difference, seen above in the sampling bias \nsection, we are interested here in visualising whether our sampled population \nis substantially different from the source population and whether weighting corrects\nthis difference. To do this we will use the **patchwork** package to show our \n**ggplot** visualisations side-by-side; for details see the section on \ncombining plots in [ggplot tips](https://epirhandbook.com/ggplot-tips.html?q=patch#combine-plots)\nchapter of the handbook. \nWe will visualise our source population, our un-weighted survey population and \nour weighted survey population.\nYou may also consider visualising by each strata of your survey - in our example \nhere that would be by using the argument `stack_by  = \"health_district\"` \n(see `?plot_age_pyramid` for details). \n\n<span style=\"color: black;\">**_NOTE:_** The x and y axes are flipped in pyramids </span>\n\n```{r weighted_age_pyramid, warning = FALSE, message = FALSE, fig.show = \"hold\", fig.width = 15}\n\n## define x-axis limits and labels ---------------------------------------------\n## (update these numbers to be the values for your graph)\nmax_prop <- 35      # choose the highest proportion you want to show \nstep <- 5           # choose the space you want beween labels \n\n## this part defines vector using the above numbers with axis breaks\nbreaks <- c(\n    seq(max_prop/100 * -1, 0 - step/100, step/100), \n    0, \n    seq(0 + step / 100, max_prop/100, step/100)\n    )\n\n## this part defines vector using the above numbers with axis limits\nlimits <- c(max_prop/100 * -1, max_prop/100)\n\n## this part defines vector using the above numbers with axis labels\nlabels <-  c(\n      seq(max_prop, step, -step), \n      0, \n      seq(step, max_prop, step)\n    )\n\n\n## create plots individually  --------------------------------------------------\n\n## plot the source population \n## nb: this needs to be collapsed for the overall population (i.e. removing health districts)\nsource_population <- population %>%\n  ## ensure that age and sex are factors\n  mutate(age_group = factor(age_group, \n                            levels = c(\"0-2\", \n                                       \"3-14\", \n                                       \"15-29\",\n                                       \"30-44\", \n                                       \"45+\")), \n         sex = factor(sex)) %>% \n  group_by(age_group, sex) %>% \n  ## add the counts for each health district together \n  summarise(population = sum(population)) %>% \n  ## remove the grouping so can calculate overall proportion\n  ungroup() %>% \n  mutate(proportion = population / sum(population)) %>% \n  ## plot pyramid \n  age_pyramid(\n            age_group = age_group, \n            split_by = sex, \n            count = proportion, \n            proportional = TRUE) +\n  ## only show the y axis label (otherwise repeated in all three plots)\n  labs(title = \"Source population\", \n       y = \"\", \n       x = \"Age group (years)\") + \n  ## make the x axis the same for all plots \n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n  \n  \n## plot the unweighted sample population \nsample_population <- age_pyramid(survey_data, \n                 age_group = \"age_group\", \n                 split_by = \"sex\",\n                 proportion = TRUE) + \n  ## only show the x axis label (otherwise repeated in all three plots)\n  labs(title = \"Unweighted sample population\", \n       y = \"Proportion (%)\", \n       x = \"\") + \n  ## make the x axis the same for all plots \n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n\n\n## plot the weighted sample population \nweighted_population <- survey_design %>% \n  ## make sure the variables are factors\n  mutate(age_group = factor(age_group), \n         sex = factor(sex)) %>%\n  age_pyramid(\n    age_group = \"age_group\",\n    split_by = \"sex\", \n    proportion = TRUE) +\n  ## only show the x axis label (otherwise repeated in all three plots)\n  labs(title = \"Weighted sample population\", \n       y = \"\", \n       x = \"\")  + \n  ## make the x axis the same for all plots \n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n\n## combine all three plots  ----------------------------------------------------\n## combine three plots next to eachother using + \nsource_population + sample_population + weighted_population + \n  ## only show one legend and define theme \n  ## note the use of & for combining theme with plot_layout()\n  plot_layout(guides = \"collect\") & \n  theme(legend.position = \"bottom\",                    # move legend to bottom\n        legend.title = element_blank(),                # remove title\n        text = element_text(size = 18),                # change text size\n        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1) # turn x-axis text\n       )\n```\n\n\n### Alluvial/sankey diagram\n\nVisualising starting points and outcomes for individuals can be very helpful to \nget an overview. There is quite an obvious application for mobile populations, \nhowever there are numerous other applications such as cohorts or any other situation\nwhere there are transitions in states for individuals. These diagrams have several\ndifferent names including alluvial, sankey and parallel sets - the details are \nin the handbook chapter on [diagrams and charts](https://epirhandbook.com/diagrams-and-charts.html#alluvialsankey-diagrams). \n\n\n```{r visualise_population_flow}\n\n## summarize data\nflow_table <- survey_data %>%\n  count(startcause, endcause, sex) %>%  # get counts \n  gather_set_data(x = c(\"startcause\", \"endcause\"))     # change format for plotting\n\n\n## plot your dataset \n  ## on the x axis is the start and end causes\n  ## gather_set_data generates an ID for each possible combination\n  ## splitting by y gives the possible start/end combos\n  ## value as n gives it as counts (could also be changed to proportion)\nggplot(flow_table, aes(x, id = id, split = y, value = n)) +\n  ## colour lines by sex \n  geom_parallel_sets(aes(fill = sex), alpha = 0.5, axis.width = 0.2) +\n  ## fill in the label boxes grey\n  geom_parallel_sets_axes(axis.width = 0.15, fill = \"grey80\", color = \"grey80\") +\n  ## change text colour and angle (needs to be adjusted)\n  geom_parallel_sets_labels(color = \"black\", angle = 0, size = 5) +\n  ## remove axis labels\n  theme_void()+\n  ## move legend to bottom\n  theme(legend.position = \"bottom\")               \n\n```\n\n\n<!-- ======================================================= -->\n## Weighted proportions {  }\n\nThis section will detail how to produce tables for weighted counts and proportions,\nwith associated confidence intervals and design effect. \nThere are four different options using functions from the following packages: \n**survey**, **srvyr**, **sitrep** and **gtsummary**. \nFor minimal coding to produce a standard epidemiology style table, we would \nrecommend the **sitrep** function - which is a wrapper for **srvyr** code; note \nhowever that this is not yet on CRAN and may change in the future. \nOtherwise, the **survey** code is likely to be the most stable long-term, whereas \n**srvyr** will fit most nicely within tidyverse work-flows. While **gtsummary** \nfunctions hold a lot of potential, they appear to be experimental and incomplete\nat the time of writing. \n\n\n### **Survey** package \n\nWe can use the `svyciprop()` function from **survey** to get weighted proportions \nand accompanying 95% confidence intervals. An appropriate design effect can be \nextracted using the `svymean()` rather than `svyprop()` function. \nIt is worth noting that `svyprop()` only appears to accept variables between 0 and\n1 (or TRUE/FALSE), so categorical variables will not work.\n\n<span style=\"color: black;\">**_NOTE:_** Functions from **survey** also accept **srvyr** design objects, but here we have used the **survey** design object just for consistency </span>\n\n\n```{r survey_props}\n\n## produce weighted counts \nsvytable(~died, base_survey_design)\n\n## produce weighted proportions\nsvyciprop(~died, base_survey_design, na.rm = T)\n\n## get the design effect \nsvymean(~died, base_survey_design, na.rm = T, deff = T) %>% \n  deff()\n\n```\n\nWe can combine the functions from **survey** shown above in to a function which \nwe define ourselves below, called `svy_prop`; and we can then use that function \ntogether with `map()` from the purrr package to iterate over several variables \nand create a table. See the handbook [iteration](https://epirhandbook.com/iteration-loops-and-lists.html) \nchapter for details on **purrr**. \n\n```{r survey_prop_fun}\n# Define function to calculate weighted counts, proportions, CI and design effect\n# x is the variable in quotation marks \n# design is your survey design object\n\nsvy_prop <- function(design, x) {\n  \n  ## put the variable of interest in a formula \n  form <- as.formula(paste0( \"~\" , x))\n  ## only keep the TRUE column of counts from svytable\n  weighted_counts <- svytable(form, design)[[2]]\n  ## calculate proportions (multiply by 100 to get percentages)\n  weighted_props <- svyciprop(form, design, na.rm = TRUE) * 100\n  ## extract the confidence intervals and multiply to get percentages\n  weighted_confint <- confint(weighted_props) * 100\n  ## use svymean to calculate design effect and only keep the TRUE column\n  design_eff <- deff(svymean(form, design, na.rm = TRUE, deff = TRUE))[[TRUE]]\n  \n  ## combine in to one data frame\n  full_table <- cbind(\n    \"Variable\"        = x,\n    \"Count\"           = weighted_counts,\n    \"Proportion\"      = weighted_props,\n    weighted_confint, \n    \"Design effect\"   = design_eff\n    )\n  \n  ## return table as a dataframe\n  full_table <- data.frame(full_table, \n             ## remove the variable names from rows (is a separate column now)\n             row.names = NULL)\n  \n  ## change numerics back to numeric\n  full_table[ , 2:6] <- as.numeric(full_table[, 2:6])\n  \n  ## return dataframe\n  full_table\n}\n\n## iterate over several variables to create a table \npurrr::map(\n  ## define variables of interest\n  c(\"left\", \"died\", \"arrived\"), \n  ## state function using and arguments for that function (design)\n  svy_prop, design = base_survey_design) %>% \n  ## collapse list in to a single data frame\n  bind_rows() %>% \n  ## round \n  mutate(across(where(is.numeric), round, digits = 1))\n\n```\n\n\n\n### **Srvyr** package \n\nWith **srvyr** we can use **dplyr** syntax to create a table. Note that the \n`survey_mean()` function is used and the proportion argument is specified, and \nalso that the same function is used to calculate design effect. This is because \n**srvyr** wraps around both of the **survey** package functions `svyciprop()` and \n`svymean()`, which are used in the above section. \n\n<span style=\"color: black;\">**_NOTE:_** It does not seem to be possible to get proportions from categorical variables using **srvyr** either, if you need this then check out the section below using **sitrep** </span>\n\n```{r srvyr_prop}\n\n## use the srvyr design object\nsurvey_design %>% \n  summarise(\n    ## produce the weighted counts \n    counts = survey_total(died), \n    ## produce weighted proportions and confidence intervals \n    ## multiply by 100 to get a percentage \n    props = survey_mean(died, \n                        proportion = TRUE, \n                        vartype = \"ci\") * 100, \n    ## produce the design effect \n    deff = survey_mean(died, deff = TRUE)) %>% \n  ## only keep the rows of interest\n  ## (drop standard errors and repeat proportion calculation)\n  select(counts, props, props_low, props_upp, deff_deff)\n\n```\n\nHere too we could write a function to then iterate over multiple variables using\nthe **purrr** package. \nSee the handbook [iteration](https://epirhandbook.com/iteration-loops-and-lists.html) \nchapter for details on **purrr**. \n\n```{r srvyr_prop_fun}\n\n# Define function to calculate weighted counts, proportions, CI and design effect\n# design is your survey design object\n# x is the variable in quotation marks \n\n\nsrvyr_prop <- function(design, x) {\n  \n  summarise(\n    ## using the survey design object\n    design, \n    ## produce the weighted counts \n    counts = survey_total(.data[[x]]), \n    ## produce weighted proportions and confidence intervals \n    ## multiply by 100 to get a percentage \n    props = survey_mean(.data[[x]], \n                        proportion = TRUE, \n                        vartype = \"ci\") * 100, \n    ## produce the design effect \n    deff = survey_mean(.data[[x]], deff = TRUE)) %>% \n  ## add in the variable name\n  mutate(variable = x) %>% \n  ## only keep the rows of interest\n  ## (drop standard errors and repeat proportion calculation)\n  select(variable, counts, props, props_low, props_upp, deff_deff)\n  \n}\n  \n\n## iterate over several variables to create a table \npurrr::map(\n  ## define variables of interest\n  c(\"left\", \"died\", \"arrived\"), \n  ## state function using and arguments for that function (design)\n  ~srvyr_prop(.x, design = survey_design)) %>% \n  ## collapse list in to a single data frame\n  bind_rows()\n  \n\n```\n\n\n\n### **Sitrep** package \n\nThe `tab_survey()` function from **sitrep** is a wrapper for **srvyr**, allowing \nyou to create weighted tables with minimal coding. It also allows you to calculate\nweighted proportions for categorical variables. \n\n```{r sitrep_props}\n\n## using the survey design object\nsurvey_design %>% \n  ## pass the names of variables of interest unquoted\n  tab_survey(arrived, left, died, education_level,\n             deff = TRUE,   # calculate the design effect\n             pretty = TRUE  # merge the proportion and 95%CI\n             )\n\n```\n\n\n\n### **Gtsummary** package\n\nWith **gtsummary** there does not seem to be inbuilt functions yet to add confidence\nintervals or design effect. \nHere we show how to define a function for adding confidence intervals and then \nadd confidence intervals to a **gtsummary** table created using the `tbl_svysummary()` \nfunction. \n\n\n```{r gtsummary_table}\n\n\nconfidence_intervals <- function(data, variable, by, ...) {\n  \n  ## extract the confidence intervals and multiply to get percentages\n  props <- svyciprop(as.formula(paste0( \"~\" , variable)),\n              data, na.rm = TRUE)\n  \n  ## extract the confidence intervals \n  as.numeric(confint(props) * 100) %>% ## make numeric and multiply for percentage\n    round(., digits = 1) %>%           ## round to one digit\n    c(.) %>%                           ## extract the numbers from matrix\n    paste0(., collapse = \"-\")          ## combine to single character\n}\n\n## using the survey package design object\ntbl_svysummary(base_survey_design, \n               include = c(arrived, left, died),   ## define variables want to include\n               statistic = list(everything() ~ c(\"{n} ({p}%)\"))) %>% ## define stats of interest\n  add_n() %>%  ## add the weighted total \n  add_stat(fns = everything() ~ confidence_intervals) %>% ## add CIs\n  ## modify the column headers\n  modify_header(\n    list(\n      n ~ \"**Weighted total (N)**\",\n      stat_0 ~ \"**Weighted Count**\",\n      add_stat_1 ~ \"**95%CI**\"\n    )\n    )\n\n```\n\n\n\n<!-- ======================================================= -->\n## Weighted ratios {  }\n\nSimilarly for weighted ratios (such as for mortality ratios) you can use the \n**survey** or the **srvyr** package. \nYou could similarly write functions (similar to those above) to iterate over \nseveral variables. You could also create a function for **gtsummary** as above\nbut currently it does not have inbuilt functionality. \n\n\n### **Survey** package \n\n```{r survey_ratio}\n\nratio <- svyratio(~died, \n         denominator = ~obstime, \n         design = base_survey_design)\n\nci <- confint(ratio)\n\ncbind(\n  ratio$ratio * 10000, \n  ci * 10000\n)\n\n```\n\n\n### **Srvyr** package \n\n```{r srvyr_ratio}\n\nsurvey_design %>% \n  ## survey ratio used to account for observation time \n  summarise(\n    mortality = survey_ratio(\n      as.numeric(died) * 10000, \n      obstime, \n      vartype = \"ci\")\n    )\n\n```\n\n\n\n\n<!-- ======================================================= -->\n## Resources {  }\n\n[UCLA stats page](https://stats.idre.ucla.edu/r/seminars/survey-data-analysis-with-r/)  \n\n[Analyze survey data free](http://asdfree.com/)  \n\n[srvyr packge](http://gdfe.co/srvyr/)  \n\n[gtsummary package](http://www.danieldsjoberg.com/gtsummary/reference/index.html) \n\n[EPIET survey case studies](https://github.com/EPIET/RapidAssessmentSurveys)\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"survey_analysis.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.340","lightbox":true,"theme":{"light":"cosmo","dark":["cosmo","theme-dark.scss"]}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}