{"title":"Missing data","markdown":{"headingText":"Missing data","headingAttr":{"id":"","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n```{r, out.width=c(\"50%\"), echo=F}\nknitr::include_graphics(here::here(\"images\", \"missingness.png\"))\nknitr::include_graphics(here::here(\"images\", \"missingness_overview.png\"))\n```\n\nThis page will cover how to:  \n\n1) Assess missingness  \n2) Filter out rows by missingness  \n3) Plot missingness over time  \n4) Handle how `NA` is displayed in plots  \n5) Perform missing value imputation: MCAR, MAR, MNAR  \n\n\n\n<!-- ======================================================= -->\n## Preparation { }\n\n### Load packages {.unnumbered}  \n\nThis code chunk shows the loading of packages required for the analyses. In this handbook we emphasize `p_load()` from **pacman**, which installs the package if necessary *and* loads it for use. You can also load installed packages with  `library()` from **base** R. See the page on [R basics] for more information on R packages.  \n\n```{r}\npacman::p_load(\n  rio,           # import/export\n  tidyverse,     # data mgmt and viz\n  naniar,        # assess and visualize missingness\n  mice           # missing data imputation\n)\n```\n\n\n### Import data {.unnumbered}\n\nWe import the dataset of cases from a simulated Ebola epidemic. If you want to follow along, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>click to download the \"clean\" linelist</a> (as .rds file). Import your data with the `import()` function from the **rio** package (it accepts many file types like .xlsx, .rds, .csv - see the [Import and export] page for details).  \n\n```{r, echo=F}\n# import the linelist into R\nlinelist <- rio::import(here::here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))\n```\n\n```{r, eval=F}\n# import the linelist\nlinelist <- import(\"linelist_cleaned.rds\")\n```\n\nThe first 50 rows of the linelist are displayed below.\n\n```{r, message=FALSE, echo=F}\n# display the linelist data as a table\nDT::datatable(head(linelist, 50), rownames = FALSE, filter=\"top\", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )\n```\n\n\n### Convert missing on import {.unnumbered}  \n\nWhen importing your data, be aware of values that should be classified as missing. For example, 99, 999, \"Missing\", blank cells (\"\"), or cells with an empty space (\" \"). You can convert these to `NA` (R's version of missing data) during the data import command.  \nSee the page on importing page section on [Missing data](#import_missing) for details, as the exact syntax varies by file type.  \n\n\n<!-- ======================================================= -->\n## Missing values in R { }\n\nBelow we explore ways that missingness is presented and assessed in R, along with some adjacent values and functions.  \n\n### `NA` {.unnumbered}  \n\nIn R, missing values are represented by a reserved (special) value - `NA`. Note that this is typed *without* quotes. \"NA\" is different and is just a normal character value (also a Beatles lyric from the song Hey Jude).  \n\nYour data may have other ways of representing missingness, such as \"99\", or \"Missing\", or \"Unknown\" - you may even have empty character value \"\" which looks \"blank\", or a single space \" \". Be aware of these and consider whether to [convert them to `NA` during import](#import_missing) or during data cleaning with `na_if()`.  \n\nIn your data cleaning, you may also want to convert the other way - changing all `NA` to \"Missing\" or similar with `replace_na()` or with `fct_explicit_na()` for factors.  \n\n\n\n\n### Versions of `NA` {.unnumbered}  \n\nMost of the time, `NA` represents a missing value and everything works fine. However, in some circumstances you may encounter the need for *variations* of `NA` specific to an object class (character, numeric, etc). This will be rare, but you should be aware.    \nThe typical scenario for this is when creating a new column with the **dplyr** function `case_when()`. As described in the [Cleaning data and core functions](#clean_case_when) page, this function evaluates every row in the data frame, assess whether the rows meets specified logical criteria (right side of the code), and assigns the correct new value (left side of the code). *Importantly: all values on the right side must be the same class*.  \n\n```{r, eval=F}\nlinelist <- linelist %>% \n  \n  # Create new \"age_years\" column from \"age\" column\n  mutate(age_years = case_when(\n    age_unit == \"years\"  ~ age,       # if age is given in years, assign original value\n    age_unit == \"months\" ~ age/12,    # if age is given in months, divide by 12\n    is.na(age_unit)      ~ age,       # if age UNIT is missing, assume years\n    TRUE                 ~ NA_real_)) # any other circumstance, assign missing\n```\n\nIf you want `NA` on the right side, you may need to specify one of the special `NA` options listed below. If the other right side values are character, consider using \"Missing\" instead or otherwise use `NA_character_`. If they are all numeric, use `NA_real_`. If they are all dates or logical, you can use `NA`.  \n\n* `NA` - use for dates or logical TRUE/FALSE \n* `NA_character_` - use for characters  \n* `NA_real_`  - use for numeric\n\nAgain, it is not likely you will encounter these variations *unless* you are using `case_when()` to create a new column. See the [R documentation on NA](https://stat.ethz.ch/R-manual/R-devel/library/base/html/NA.html) for more information. \n\n\n\n\n\n### `NULL` {.unnumbered}  \n\n`NULL` is another reserved value in R. It is the logical representation of a statement that is neither true nor false. It is returned by expressions or functions whose values are undefined. Generally do not assign NULL as a value, unless writing functions or perhaps writing a [**shiny** app][Dashboards with Shiny] to return `NULL` in specific scenarios.  \n\nNull-ness can be assessed using `is.null()` and conversion can made with `as.null()`.  \n\nSee this [blog post](https://www.r-bloggers.com/2010/04/r-na-vs-null/) on the difference between `NULL` and `NA`.  \n\n\n\n\n### `NaN` {.unnumbered}  \n\nImpossible values are represented by the special value `NaN`. An example of this is when you force R to divide 0 by 0. You can assess this with `is.nan()`. You may also encounter complementary functions including `is.infinite()` and `is.finite()`.  \n\n\n### `Inf` {.unnumbered}  \n\n`Inf` represents an infinite value, such as when you divide a number by 0.  \n\nAs an example of how this might impact your work: let's say you have a vector/column `z` that contains these values: `z <- c(1, 22, NA, Inf, NaN, 5)`\n\nIf you want to use `max()` on the column to find the highest value, you can use the `na.rm = TRUE` to remove the `NA` from the calculation, but the `Inf` and `NaN` remain and `Inf` will be returned. To resolve this, you can use brackets `[ ]` and `is.finite()` to subset such that only finite values are used for the calculation: `max(z[is.finite(z)])`.  \n\n```{r, eval=F}\nz <- c(1, 22, NA, Inf, NaN, 5)\nmax(z)                           # returns NA\nmax(z, na.rm=T)                  # returns Inf\nmax(z[is.finite(z)])             # returns 22\n```\n\n\n### Examples {.unnumbered}  \n\n\nR command | Outcome\n----------|--------------\n`5 / 0` | `Inf`  \n`0 / 0` | `NaN`  \n`5 / NA` | `NA`  \n`5 / Inf | `0`  \n`NA - 5` | `NA`  \n`Inf / 5` | `Inf`  \n`class(NA)` | \"logical\"  \n`class(NaN)` | \"numeric\"  \n`class(Inf)` | \"numeric\"  \n`class(NULL)` | \"NULL\"  \n\n\"NAs introduced by coercion\" is a common warning message. This can happen if you attempt to make an illegal conversion like inserting a character value into a vector that is otherwise numeric.  \n\n```{r}\nas.numeric(c(\"10\", \"20\", \"thirty\", \"40\"))\n```\n\n`NULL` is ignored in a vector.  \n\n```{r}\nmy_vector <- c(25, NA, 10, NULL)  # define\nmy_vector                         # print\n```\n\n\nVariance of one number results in `NA`.  \n\n```{r}\nvar(22)\n```\n\n\n<!-- ======================================================= -->\n## Useful functions { }\n\nThe following are useful **base** R functions when assessing or handling missing values:  \n\n\n### `is.na()` and `!is.na()` {.unnumbered}  \n\nUse `is.na()`to identify missing values, or use its opposite (with `!` in front) to identify non-missing values. These both return a logical value (`TRUE` or `FALSE`). Remember that you can `sum()` the resulting vector to count the number `TRUE`, e.g. `sum(is.na(linelist$date_outcome))`.    \n\n```{r}\nmy_vector <- c(1, 4, 56, NA, 5, NA, 22)\nis.na(my_vector)\n!is.na(my_vector)\nsum(is.na(my_vector))\n```\n\n\n### `na.omit()` {.unnumbered}  \n\nThis function, if applied to a data frame, will remove rows with *any* missing values. It is also from **base** R.  \nIf applied to a vector, it will remove `NA` values from the vector it is applied to. For example:  \n\n```{r}\nna.omit(my_vector)\n```\n\n### `drop_na()` {.unnumbered}  \n\nThis is a **tidyr** function that is useful in a [data cleaning pipeline][Cleaning data and core functions]. If run with the parentheses empty, it removes rows with *any* missing values. If column names are specified in the parentheses, rows with missing values in those columns will be dropped. You can also use \"tidyselect\" syntax to specify the columns.  \n\n```{r, eval=F}\nlinelist %>% \n  drop_na(case_id, date_onset, age) # drops rows missing values for any of these columns\n```\n\n\n### `na.rm = TRUE` {.unnumbered}  \n\nWhen you run a mathematical function such as `max()`, `min()`, `sum()` or `mean()`, if there are any `NA` values present the returned value will be `NA`. This default behavior is intentional, so that you are alerted if any of your data are missing.  \n\nYou can avoid this by removing missing values from the calculation. To do this, include the argument `na.rm = TRUE` (\"na.rm\" stands for \"remove `NA`\").  \n\n\n```{r}\nmy_vector <- c(1, 4, 56, NA, 5, NA, 22)\n\nmean(my_vector)     \n\nmean(my_vector, na.rm = TRUE)\n```\n\n\n\n<!-- ======================================================= -->\n## Assess missingness in a data frame { }\n\nYou can use the package **naniar** to assess and visualize missingness in the data frame `linelist`.  \n\n```{r}\n# install and/or load package\npacman::p_load(naniar)\n```\n\n### Quantifying missingness {.unnumbered}\n\nTo find the percent of all values that are missing use `pct_miss()`. Use `n_miss()` to get the number of missing values.  \n\n```{r}\n# percent of ALL data frame values that are missing\npct_miss(linelist)\n```\n\nThe two functions below return the percent of rows with any missing value, or that are entirely complete, respectively. Remember that `NA` means missing, and that ``\"\"` or `\" \"` will not be counted as missing.  \n\n```{r}\n# Percent of rows with any value missing\npct_miss_case(linelist)   # use n_complete() for counts\n```\n\n```{r}\n# Percent of rows that are complete (no values missing)  \npct_complete_case(linelist) # use n_complete() for counts\n```\n\n\n\n### Visualizing missingness {.unnumbered}  \n\nThe `gg_miss_var()` function will show you the number (or %) of missing values in each column. A few nuances:  \n\n* You can add a column name (not in quote) to the argument `facet = ` to see the plot by groups  \n* By default, counts are shown instead of percents, change this with `show_pct = TRUE`  \n* You can add axis and title labels as for a normal `ggplot()` with `+ labs(...)`  \n\n\n```{r}\ngg_miss_var(linelist, show_pct = TRUE)\n```\n\nHere the data are piped `%>%` into the function. The `facet = ` argument is also used to split the data.  \n\n```{r}\nlinelist %>% \n  gg_miss_var(show_pct = TRUE, facet = outcome)\n```\n\n\nYou can use `vis_miss()` to visualize the data frame as a heatmap, showing whether each value is missing or not. You can also `select()` certain columns from the data frame and provide only those columns to the function.    \n\n```{r}\n# Heatplot of missingness across the entire data frame  \nvis_miss(linelist)\n```\n\n\n### Explore and visualize missingness relationships {.unnumbered} \n\nHow do you visualize something that is not there??? By default, `ggplot()` removes points with missing values from plots.  \n\n**naniar** offers a solution via `geom_miss_point()`. When creating a scatterplot of two columns, records with one of the values missing and the other value present are shown by setting the missing values to 10% lower than the lowest value in the column, and coloring them distinctly.  \n\nIn the scatterplot below, the red dots are records where the value for one column is present but the value for the other column is missing. This allows you to see the distribution of missing values in relation to the non-missing values.  \n\n\n\n```{r}\nggplot(\n  data = linelist,\n  mapping = aes(x = age_years, y = temp)) +     \n  geom_miss_point()\n```\n\nTo assess missingness in the data frame *stratified by another column*, consider `gg_miss_fct()`, which returns a heatmap of percent missingness in the data frame *by a factor/categorical (or date) column*:  \n\n```{r}\ngg_miss_fct(linelist, age_cat5)\n```\n\n\nThis function can also be used with a date column to see how missingness has changed over time:  \n\n```{r}\ngg_miss_fct(linelist, date_onset)\n```\n\n\n\n\n### \"Shadow\" columns {.unnumbered}\n\nAnother way to visualize missingness in one column by values in a second column is using the \"shadow\" that **naniar** can create. `bind_shadow()` creates a binary `NA`/not `NA` column for every existing column, and binds all these new columns to the original dataset with the appendix \"_NA\". This doubles the number of columns - see below:  \n\n\n```{r}\nshadowed_linelist <- linelist %>% \n  bind_shadow()\n\nnames(shadowed_linelist)\n```\n\nThese \"shadow\" columns can be used to plot the proportion of values that are missing, by any another column.  \n\nFor example, the plot below shows the proportion of records missing `days_onset_hosp` (number of days from symptom onset to hospitalisation), by that record's value in `date_hospitalisation`. Essentially, you are plotting the density of the x-axis column, but stratifying the results (`color = `) by a shadow column of interest. This analysis works best if the x-axis is a numeric or date column.  \n\n\n```{r, message = F}\nggplot(data = shadowed_linelist,          # data frame with shadow columns\n  mapping = aes(x = date_hospitalisation, # numeric or date column\n                colour = age_years_NA)) + # shadow column of interest\n  geom_density()                          # plots the density curves\n```\n\nYou can also use these \"shadow\" columns to stratify a statistical summary, as shown below:\n\n```{r}\nlinelist %>%\n  bind_shadow() %>%                # create the shows cols\n  group_by(date_outcome_NA) %>%    # shadow col for stratifying\n  summarise(across(\n    .cols = age_years,             # variable of interest for calculations\n    .fns = list(\"mean\" = mean,     # stats to calculate\n                \"sd\" = sd,\n                \"var\" = var,\n                \"min\" = min,\n                \"max\" = max),  \n    na.rm = TRUE))                 # other arguments for the stat calculations\n```\n\n\nAn alternative way to plot the proportion of a column's values that are missing over time is shown below. It does *not* involve **naniar**. This example shows percent of weekly observations that are missing).  \n\n1) Aggregate the data into a useful time unit (days, weeks, etc.), summarizing the proportion of observations with `NA` (and any other values of interest)  \n2) Plot the proportion missing as a line using `ggplot()`  \n\nBelow, we take the linelist, add a new column for week, group the data by week, and then calculate the percent of that week's records where the value is missing. (note: if you want % of 7 days the calculation would be slightly different).  \n\n```{r}\noutcome_missing <- linelist %>%\n  mutate(week = lubridate::floor_date(date_onset, \"week\")) %>%   # create new week column\n  group_by(week) %>%                                             # group the rows by week\n  summarise(                                                     # summarize each week\n    n_obs = n(),                                                  # number of records\n    \n    outcome_missing = sum(is.na(outcome) | outcome == \"\"),        # number of records missing the value\n    outcome_p_miss  = outcome_missing / n_obs,                    # proportion of records missing the value\n  \n    outcome_dead    = sum(outcome == \"Death\", na.rm=T),           # number of records as dead\n    outcome_p_dead  = outcome_dead / n_obs) %>%                   # proportion of records as dead\n  \n  tidyr::pivot_longer(-week, names_to = \"statistic\") %>%         # pivot all columns except week, to long format for ggplot\n  filter(stringr::str_detect(statistic, \"_p_\"))                  # keep only the proportion values\n```\n\nThen we plot the proportion missing as a line, by week. The [ggplot basics] page if you are unfamiliar with the **ggplot2** plotting package.  \n\n```{r, message=F, warning=F}\nggplot(data = outcome_missing)+\n    geom_line(\n      mapping = aes(x = week, y = value, group = statistic, color = statistic),\n      size = 2,\n      stat = \"identity\")+\n    labs(title = \"Weekly outcomes\",\n         x = \"Week\",\n         y = \"Proportion of weekly records\") + \n     scale_color_discrete(\n       name = \"\",\n       labels = c(\"Died\", \"Missing outcome\"))+\n    scale_y_continuous(breaks = c(seq(0,1,0.1)))+\n  theme_minimal()+\n  theme(legend.position = \"bottom\")\n```\n\n\n\n\n\n<!-- ======================================================= -->\n## Using data with missing values  \n\n\n### Filter out rows with missing values {.unnumbered}\n\nTo quickly remove rows with missing values, use the **dplyr** function `drop_na()`.  \n\nThe original `linelist` has ` nrow(linelist)` rows. The adjusted number of rows is shown below:  \n\n```{r}\nlinelist %>% \n  drop_na() %>%     # remove rows with ANY missing values\n  nrow()\n```\n\nYou can specify to drop rows with missingness in certain columns:  \n\n```{r}\nlinelist %>% \n  drop_na(date_onset) %>% # remove rows missing date_onset \n  nrow()\n```\n\nYou can list columns one after the other, or use [\"tidyselect\" helper functions](#clean_tidyselect):  \n\n```{r}\nlinelist %>% \n  drop_na(contains(\"date\")) %>% # remove rows missing values in any \"date\" column \n  nrow()\n```\n\n\n\n<!-- ======================================================= -->\n### Handling `NA` in `ggplot()` {.unnumbered}\n\nIt is often wise to report the number of values excluded from a plot in a caption. Below is an example:  \n\nIn `ggplot()`, you can add `labs()` and within it a `caption = `. In the caption, you can use `str_glue()` from **stringr** package to paste values together into a sentence dynamically so they will adjust to the data. An example is below:  \n\n* Note the use of `\\n` for a new line.  \n* Note that if multiple column would contribute to values not being plotted (e.g. age or sex if those are reflected in the plot), then you must filter on those columns as well to correctly calculate the number not shown.  \n\n```{r, eval=F}\nlabs(\n  title = \"\",\n  y = \"\",\n  x = \"\",\n  caption  = stringr::str_glue(\n  \"n = {nrow(central_data)} from Central Hospital;\n  {nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown.\"))  \n```\n\nSometimes, it can be easier to save the string as an object in commands prior to the `ggplot()` command, and simply reference the named string object within the `str_glue()`.  \n\n\n<!-- ======================================================= -->\n### `NA` in factors {.unnumbered}\n\nIf your column of interest is a factor, use `fct_explicit_na()` from the **forcats** package to convert `NA` values to a character value. See more detail in the [Factors] page. By default, the new value is \"(Missing)\" but this can be adjusted via the `na_level =` argument.   \n\n```{r}\npacman::p_load(forcats)   # load package\n\nlinelist <- linelist %>% \n  mutate(gender = fct_explicit_na(gender, na_level = \"Missing\"))\n\nlevels(linelist$gender)\n```\n\n\n\n<!-- ======================================================= -->\n## Imputation { }\n\n\nSometimes, when analyzing your data, it will be important to \"fill in the gaps\" and impute missing data While you can always simply analyze a dataset after removing all missing values, this can cause problems in many ways. Here are two examples: \n\n1) By removing all observations with missing values or variables with a large amount of missing data, you might reduce your power or ability to do some types of analysis. For example, as we discovered earlier, only a small fraction of the observations in our linelist dataset have no missing data across all of our variables. If we removed the majority of our dataset we'd be losing a lot of information! And, most of our variables have some amount of missing data--for most analysis it's probably not reasonable to drop every variable that has a lot of missing data either.\n\n2) Depending on why your data is missing, analysis of only non-missing data might lead to biased or misleading results. For example, as we learned earlier we are missing data for some patients about whether they've had some important symptoms like fever or cough. But, as one possibility, maybe that information wasn't recorded for people that just obviously weren't very sick. In that case, if we just removed these observations we'd be excluding some of the healthiest people in our dataset and that might really bias any results.\n\nIt's important to think about why your data might be missing in addition to seeing how much is missing. Doing this can help you decide how important it might be to impute missing data, and also which method of imputing missing data might be best in your situation.\n\n### Types of missing data {.unnumbered}\n\nHere are three general types of missing data:\n\n1) **Missing Completely at Random** (MCAR). This means that there is no relationship between the probability of data being missing and any of the other variables in your data. The probability of being missing is the same for all cases This is a rare situation. But, if you have strong reason to believe your data is MCAR analyzing only non-missing data without imputing won't bias your results (although you may lose some power). [TODO: consider discussing statistical tests for MCAR]\n\n2) **Missing at Random** (MAR). This name is actually a bit misleading as MAR means that your data is missing in a systematic, predictable way based on the other information you have. For example, maybe every observation in our dataset with a missing value for fever was actually not recorded because every patient with chills and and aches was just assumed to have a fever so their temperature was never taken. If true, we could easily predict that every missing observation with chills and aches has a fever as well and use this information to impute our missing data. In practice, this is more of a spectrum. Maybe if a patient had both chills and aches they were more likely to have a fever as well if they didn't have their temperature taken, but not always. This is still predictable even if it isn't perfectly predictable. This is a common type of missing data \n\n3) **Missing not at Random** (MNAR). Sometimes, this is also called **Not Missing at Random** (NMAR). This assumes that the probability of a value being missing is NOT systematic or predictable using the other information we have but also isn't missing randomly. In this situation data is missing for unknown reasons or for reasons you don't have any information about. For example, in our dataset maybe information on age is missing because some very elderly patients either don't know or refuse to say how old they are. In this situation, missing data on age is related to the value itself (and thus isn't random) and isn't predictable based on the other information we have. MNAR is complex and often the best way of dealing with this is to try to collect more data or information about why the data is missing rather than attempt to impute it. \n\nIn general, imputing MCAR data is often fairly simple, while MNAR is very challenging if not impossible. Many of the common data imputation methods assume MAR. \n\n### Useful packages {.unnumbered}\n\nSome useful packages for imputing missing data are Mmisc, missForest (which uses random forests to impute missing data), and mice (Multivariate Imputation by Chained Equations). For this section we'll just use the mice package, which implements a variety of techniques. The maintainer of the mice package has published an online book about imputing missing data that goes into more detail here (https://stefvanbuuren.name/fimd/).  \n\nHere is the code to load the mice package:\n\n```{r}\npacman::p_load(mice)\n```\n\n### Mean Imputation {.unnumbered}\n\nSometimes if you are doing a simple analysis or you have strong reason to think you can assume MCAR, you can simply set missing numerical values to the mean of that variable. Perhaps we can assume that missing temperature measurements in our dataset were either MCAR or were just normal values. Here is the code to create a new variable that replaces missing temperature values with the mean temperature value in our dataset. However, in many situations replacing data with the mean can lead to bias, so be careful.\n\n```{r}\nlinelist <- linelist %>%\n  mutate(temp_replace_na_with_mean = replace_na(temp, mean(temp, na.rm = T)))\n```\n\nYou could also do a similar process for replacing categorical data with a specific value. For our dataset, imagine you knew that all observations with a missing value for their outcome (which can be \"Death\" or \"Recover\") were actually people that died (note: this is not actually true for this dataset):\n\n```{r}\nlinelist <- linelist %>%\n  mutate(outcome_replace_na_with_death = replace_na(outcome, \"Death\"))\n```\n\n### Regression imputation {.unnumbered}\n\nA somewhat more advanced method is to use some sort of statistical model to predict what a missing value is likely to be and replace it with the predicted value. Here is an example of creating predicted values for all the observations where temperature is missing, but age and fever are not, using simple linear regression using fever status and age in years as predictors. In practice you'd want to use a better model than this sort of simple approach.\n\n```{r, warning=F, message=F}\nsimple_temperature_model_fit <- lm(temp ~ fever + age_years, data = linelist)\n\n#using our simple temperature model to predict values just for the observations where temp is missing\npredictions_for_missing_temps <- predict(simple_temperature_model_fit,\n                                        newdata = linelist %>% filter(is.na(temp))) \n```\n\nOr, using the same modeling approach through the mice package to create imputed values for the missing temperature observations:\n\n```{r}\nmodel_dataset <- linelist %>%\n  select(temp, fever, age_years)  \n\ntemp_imputed <- mice(model_dataset,\n                            method = \"norm.predict\",\n                            seed = 1,\n                            m = 1,\n                            print = F)\n\ntemp_imputed_values <- temp_imputed$imp$temp\n\n```\n\n\nThis is the same type of approach by some more advanced methods like using the missForest package to replace missing data with predicted values. In that case, the prediction model is a random forest instead of a linear regression. You can use other types of models to do this as well. However, while this approach works well under MCAR you should be a bit careful if you believe MAR or MNAR more accurately describes your situation. The quality of your imputation will depend on how good your prediction model is and even with a very good model the variability of your imputed data may be underestimated. \n\n### LOCF and BOCF {.unnumbered}\n\nLast observation carried forward (LOCF) and baseline observation carried forward (BOCF) are imputation methods for time series/longitudinal data. The idea is to take the previous observed value as a replacement for the missing data. When multiple values are missing in succession, the method searches for the last observed value.\n\nThe `fill()` function from the **tidyr** package can be used for both LOCF and BOCF imputation (however, other packages such as **HMISC**, **zoo**, and **data.table** also include methods for doing this). To show the `fill()` syntax we'll make up a simple time series dataset containing the number of cases of a disease for each quarter of the years 2000 and 2001. However, the year value for subsequent quarters after Q1 are missing so we'll need to impute them. The `fill()` junction is also demonstrated in the [Pivoting data] page.  \n\n```{r}\n#creating our simple dataset\ndisease <- tibble::tribble(\n  ~quarter, ~year, ~cases,\n  \"Q1\",    2000,    66013,\n  \"Q2\",      NA,    69182,\n  \"Q3\",      NA,    53175,\n  \"Q4\",      NA,    21001,\n  \"Q1\",    2001,    46036,\n  \"Q2\",      NA,    58842,\n  \"Q3\",      NA,    44568,\n  \"Q4\",      NA,    50197)\n\n#imputing the missing year values:\ndisease %>% fill(year)\n\n```\n\nNote: make sure your data are sorted correctly before using the `fill()` function. `fill()`  defaults to filling \"down\" but you can also impute values in different directions by changing the `.direction` parameter. We can make a similar dataset where the year value is recorded only at the end of the year and missing for earlier quarters: \n\n```{r}\n#creating our slightly different dataset\ndisease <- tibble::tribble(\n  ~quarter, ~year, ~cases,\n  \"Q1\",      NA,    66013,\n  \"Q2\",      NA,    69182,\n  \"Q3\",      NA,    53175,\n  \"Q4\",    2000,    21001,\n  \"Q1\",      NA,    46036,\n  \"Q2\",      NA,    58842,\n  \"Q3\",      NA,    44568,\n  \"Q4\",    2001,    50197)\n\n#imputing the missing year values in the \"up\" direction:\ndisease %>% fill(year, .direction = \"up\")\n\n```\nIn this example, LOCF and BOCF are clearly the right things to do, but in more complicated situations it may be harder to decide if these methods are appropriate. For example, you may have missing laboratory values for a hospital patient after the first day. Sometimes, this can mean the lab values didn't change...but it could also mean the patient recovered and their values would be very different after the first day! Use these methods with caution.\n\n\n### Multiple Imputation {.unnumbered}\n\nThe online book we mentioned earlier by the author of the mice package (https://stefvanbuuren.name/fimd/) contains a detailed explanation of multiple imputation and why you'd want to use it. But, here is a basic explanation of the method:\n\nWhen you do multiple imputation, you create multiple datasets with the missing values imputed to plausible data values (depending on your research data you might want to create more or less of these imputed datasets, but the mice package sets the default number to 5). The difference is that rather than a single, specific value each imputed value is drawn from an estimated distribution (so it includes some randomness). As a result, each of these datasets will have slightly different different imputed values (however, the non-missing data will be the same in each of these imputed datasets). You still use some sort of predictive model to do the imputation in each of these new datasets (mice has many options for prediction methods including *Predictive Mean Matching*, *logistic regression*, and *random forest*) but the mice package can take care of many of the modeling details. \n\nThen, once you have created these new imputed datasets, you can apply then apply whatever statistical model or analysis you were planning to do for each of these new imputed datasets and pool the results of these models together. This works very well to reduce bias in both MCAR and many MAR settings and often results in more accurate standard error estimates.\n\nHere is an example of applying the Multiple Imputation process to predict temperature in our linelist dataset using a age and fever status (our simplified model_dataset from above):  \n\n```{r}\n# imputing missing values for all variables in our model_dataset, and creating 10 new imputed datasets\nmultiple_imputation = mice(\n  model_dataset,\n  seed = 1,\n  m = 10,\n  print = FALSE) \n\nmodel_fit <- with(multiple_imputation, lm(temp ~ age_years + fever))\n\nbase::summary(mice::pool(model_fit))\n```\n\nHere we used the mice default method of imputation, which is Predictive Mean Matching. We then used these imputed datasets to separately estimate and then pool results from simple linear regressions on each of these datasets. There are many details we've glossed over and many settings you can adjust during the Multiple Imputation process while using the mice package. For example, you won't always have numerical data and might need to use other imputation methods (you can still use the mice package for many other types of data and methods). But, for a more robust analysis when missing data is a significant concern, Multiple Imputation is good solution that isn't always much more work than doing a complete case analysis. \n\n\n\n\n\n<!-- ======================================================= -->\n## Resources { }\n\nVignette on the [naniar package](https://cran.r-project.org/web/packages/naniar/vignettes/getting-started-w-naniar.html)\n\nGallery of [missing value visualizations](https://cran.r-project.org/web/packages/naniar/vignettes/naniar-visualisation.html)\n\n[Online book](https://stefvanbuuren.name/fimd/) about multiple imputation in R by the maintainer of the **mice** package \n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"missing_data.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.340","lightbox":true,"theme":{"light":"cosmo","dark":["cosmo","theme-dark.scss"]}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}