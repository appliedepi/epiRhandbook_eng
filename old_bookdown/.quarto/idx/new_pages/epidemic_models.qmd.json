{"title":"Epidemic modeling","markdown":{"headingText":"Epidemic modeling","headingAttr":{"id":"","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n\n<!-- ======================================================= -->\n## Overview {  }\n\nThere exists a growing body of tools for epidemic modelling that lets us conduct\nfairly complex analyses with minimal effort. This section will provide an\noverview on how to use these tools to:\n\n* estimate the effective reproduction number R<sub>t</sub> and related statistics\n  such as the doubling time\n* produce short-term projections of future incidence\n\nIt is *not* intended as an overview of the methodologies and statistical methods\nunderlying these tools, so please refer to the Resources tab for links to some\npapers covering this. Make sure you have an understanding of\nthe methods before using these tools; this will ensure you can accurately\ninterpret their results.\n\nBelow is an example of one of the outputs we'll be producing in this section.\n\n```{r out.width=c('100%', '100%'), fig.show='hold', echo=F, fig.width = 12, fig.height = 9, message=F, warning=F}\n\n## install and load packages\npacman::p_load(tidyverse, EpiNow2, EpiEstim, here, incidence2, epicontacts, rio, projections)\n\n## load linelist\nlinelist <- import(here::here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))\n\n## generate contacts\ncontacts <- linelist %>%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %>%\n  drop_na()\n\n## generate epicontacts\nepic <- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n\n## ## estimate gamma generation time\n## generation_time <- bootstrapped_dist_fit(\n##   get_pairwise(epic, \"date_infection\"),\n##   dist = \"gamma\",\n##   max_value = 20,\n##   bootstraps = 1\n## )\n\n## ## export for caching\n## export(\n##   generation_time,\n##   here(\"data/cache/epidemic_models/generation_time.rds\")\n## )\n\n## import cached generation time\ngeneration_time <- import(here(\"data/cache/epidemic_models/generation_time.rds\"))\n\n## ## estimate incubation period\n## incubation_period <- bootstrapped_dist_fit(\n##   linelist$date_onset - linelist$date_infection,\n##   dist = \"lognormal\",\n##   max_value = 100,\n##   bootstraps = 1\n## )\n\n## ## export for caching\n## export(\n##   incubation_period,\n##   here(\"data/cache/epidemic_models/incubation_period.rds\")\n## )\n\n## import cached incubation period\nincubation_period <- import(here(\"data/cache/epidemic_models/incubation_period.rds\"))\n\n## get incidence from onset date\ncases <- linelist %>%\n  group_by(date = date_onset) %>%\n  summarise(confirm = n())\n\n## ## run epinow\n## epinow_res <- epinow(\n##   reported_cases = cases,\n##   generation_time = generation_time,\n##   delays = delay_opts(incubation_period),\n##   target_folder = here(\"data/cache/epidemic_models\"),\n##   return_output = TRUE,\n##   output = \"samples\",\n##   verbose = TRUE,\n##   stan = stan_opts(samples = 750, chains = 4),\n##   horizon = 21\n## )\n\n## ## export for caching\n## export(\n##   epinow_res,\n##   here(\"data/cache/epidemic_models/epinow_res.rds\")\n## )\n\n## import cached epinow results\nepinow_res <- import(here(\"data/cache/epidemic_models/epinow_res.rds\"))\n\n## plot summary figure\nplot(epinow_res)\n\n```\n\n<!-- ======================================================= -->\n## Preparation {  }\n\nWe will use two different methods and packages for R<sub>t</sub> estimation,\nnamely **EpiNow** and **EpiEstim**, as well as the **projections** package for\nforecasting case incidence.  \n\nThis code chunk shows the loading of packages required for the analyses. \nIn this handbook we emphasize `p_load()` from **pacman**, which installs the package if necessary *and* loads it for use. \nYou can also load installed packages with  `library()` from **base** R. See the page on [R basics] for more information on R packages.  \n\n\t\n```{r epidemic_models_packages, }\npacman::p_load(\n   rio,          # File import\n   here,         # File locator\n   tidyverse,    # Data management + ggplot2 graphics\n   epicontacts,  # Analysing transmission networks\n   EpiNow2,      # Rt estimation\n   EpiEstim,     # Rt estimation\n   projections,  # Incidence projections\n   incidence2,   # Handling incidence data\n   epitrix,      # Useful epi functions\n   distcrete     # Discrete delay distributions\n)\n```\n\t\nWe will use the cleaned case linelist for all analyses in this section. If you want to follow along, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>click to download the \"clean\" linelist</a> (as .rds file). See the [Download handbook and data] page to download all example data used in this handbook.  \n\n```{r, echo=F}\n# import the linelist into R\nlinelist <- rio::import(here::here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))\n```\n\n```{r eval=F}\n# import the cleaned linelist\nlinelist <- import(\"linelist_cleaned.rds\")\n```\n\n\n<!-- ======================================================= -->\n## Estimating R<sub>t</sub> {  }\n\n### EpiNow2 vs. EpiEstim {.unnumbered}\n\nThe reproduction number R is a measure of the transmissibility of a disease and\nis defined as the expected number of secondary cases per infected case. In a\nfully susceptible population, this value represents the basic reproduction\nnumber R<sub>0</sub>. However, as the number of susceptible individuals in a\npopulation changes over the course of an outbreak or pandemic, and as various\nresponse measures are implemented, the most commonly used measure of\ntransmissibility is the effective reproduction number R<sub>t</sub>; this is\ndefined as the expected number of secondary cases per infected case at a given\ntime _t_.\n\nThe **EpiNow2** package provides the most sophisticated framework for estimating\nR<sub>t</sub>. It has two key advantages over the other commonly used package,\n**EpiEstim**:\n\n* It accounts for delays in reporting and can therefore estimate R<sub>t</sub>\n  even when recent data is incomplete.\n* It estimates R<sub>t</sub> on _dates of infection_ rather than the dates of\n  onset of reporting, which means that the effect of an intervention will\n  be immediately reflected in a change in R<sub>t</sub>, rather than with a\n  delay.\n\nHowever, it also has two key disadvantages:\n\n* It requires knowledge of the generation time distribution (i.e. distribution\n  of delays between infection of a primary and secondary cases), incubation\n  period distribution (i.e. distribution of delays between infection and symptom\n  onset) and any further delay distribution relevant to your data (e.g. if you\n  have dates of reporting, you require the distribution of delays from symptom\n  onset to reporting). While this will allow more accurate estimation of\n  R<sub>t</sub>, **EpiEstim** only requires the serial interval distribution\n  (i.e. the distribution of delays between symptom onset of a primary and a\n  secondary case), which may be the only distribution available to you.\n* **EpiNow2** is significantly slower than **EpiEstim**, anecdotally by a factor\n  of about 100-1000! For example, estimating R<sub>t</sub> for the sample outbreak\n  considered in this section takes about four hours (this was run for a large\n  number of iterations to ensure high accuracy and could probably be reduced if\n  necessary, however the points stands that the algorithm is slow in\n  general). This may be unfeasible if you are regularly updating your\n  R<sub>t</sub> estimates.\n  \nWhich package you choose to use will therefore depend on the data, time and\ncomputational resources available to you.\n\n### EpiNow2 {.unnumbered}\n\n#### Estimating delay distributions {.unnumbered}\n\nThe delay distributions required to run **EpiNow2** depend on the data you\nhave. Essentially, you need to be able to describe the delay from the date of\ninfection to the date of the event you want to use to estimate R<sub>t</sub>. If\nyou are using dates of onset, this would simply be the incubation period\ndistribution. If you are using dates of reporting, you require the\ndelay from infection to reporting. As this distribution is unlikely to be known\ndirectly, **EpiNow2** lets you chain multiple delay distributions together; in\nthis case, the delay from infection to symptom onset (e.g. the incubation\nperiod, which is likely known) and from symptom onset to reporting (which you\ncan often estimate from the data).\n\nAs we have the dates of onset for all our cases in the example linelist, we will\nonly require the incubation period distribution to link our data (e.g. dates of\nsymptom onset) to the date of infection. We can either estimate this distribution\nfrom the data or use values from the literature.\n\nA literature estimate of the incubation period of Ebola (taken\nfrom [this paper](https://www.nejm.org/doi/full/10.1056/nejmoa1411100)) with a\nmean of 9.1, standard deviation of 7.3 and maximum value of 30 would be\nspecified as follows:\n\n```{r epidemic_models_incubation_literature, eval=F}\nincubation_period_lit <- list(\n  mean = log(9.1),\n  mean_sd = log(0.1),\n  sd = log(7.3),\n  sd_sd = log(0.1),\n  max = 30\n)\n```\nNote that **EpiNow2** requires these delay distributions to be provided on a **log**\nscale, hence the `log` call around each value (except the `max` parameter which,\nconfusingly, has to be provided on a natural scale). The `mean_sd` and `sd_sd`\ndefine the standard deviation of the mean and standard deviation estimates. As\nthese are not known in this case, we choose the fairly arbitrary value of 0.1.\n\nIn this analysis, we instead estimate the incubation period distribution\nfrom the linelist itself using the function `bootstrapped_dist_fit`, which will\nfit a lognormal distribution to the observed delays between infection and onset\nin the linelist.\n\n```{r epidemic_models_incubation_estimate, eval=F}\n## estimate incubation period\nincubation_period <- bootstrapped_dist_fit(\n  linelist$date_onset - linelist$date_infection,\n  dist = \"lognormal\",\n  max_value = 100,\n  bootstraps = 1\n)\n```\n\nThe other distribution we require is the generation time. As we have data on\ninfection times __and__ transmission links, we can estimate this\ndistribution from the linelist by calculating the delay between infection times\nof infector-infectee pairs. To do this, we use the handy `get_pairwise` function\nfrom the package **epicontacts**, which allows us to calculate pairwise\ndifferences of linelist properties between transmission pairs. We first create an\nepicontacts object (see [Transmission chains] page for further\ndetails):\n\n```{r epidemic_models_epicontacts, eval=F}\n## generate contacts\ncontacts <- linelist %>%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %>%\n  drop_na()\n\n## generate epicontacts object\nepic <- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n```\n\nWe then fit the difference in infection times between transmission pairs,\ncalculated using `get_pairwise`, to a gamma distribution:\n\n```{r epidemic_models_generation_estimate, eval=F}\n## estimate gamma generation time\ngeneration_time <- bootstrapped_dist_fit(\n  get_pairwise(epic, \"date_infection\"),\n  dist = \"gamma\",\n  max_value = 20,\n  bootstraps = 1\n)\n```\n\n#### Running **EpiNow2** {.unnumbered}\n\nNow we just need to calculate daily incidence from the linelist, which we can do\neasily with the **dplyr** functions `group_by()` and `n()`. Note\nthat **EpiNow2** requires the column names to  be `date` and `confirm`.\n\n```{r epidemic_models_cases, eval=F}\n## get incidence from onset dates\ncases <- linelist %>%\n  group_by(date = date_onset) %>%\n  summarise(confirm = n())\n```\n\nWe can then estimate R<sub>t</sub> using the `epinow` function. Some notes on\nthe inputs:\n\n* We can provide any number of 'chained' delay distributions to the `delays`\n  argument; we would simply insert them alongside the `incubation_period` object\n  within the `delay_opts` function.\n* `return_output` ensures the output is returned within R and not just saved to\n  a file.\n* `verbose` specifies that we want a readout of the progress.\n* `horizon` indicates how many days we want to project future incidence for.\n* We pass additional options to the `stan` argument to specify how long\n  we want to run the inference for. Increasing `samples` and `chains` will give\n  you a more accurate estimate that better characterises uncertainty, however\n  will take longer to run.\n\n```{r epidemic_models_run_epinow, eval=F}\n## run epinow\nepinow_res <- epinow(\n  reported_cases = cases,\n  generation_time = generation_time,\n  delays = delay_opts(incubation_period),\n  return_output = TRUE,\n  verbose = TRUE,\n  horizon = 21,\n  stan = stan_opts(samples = 750, chains = 4)\n)\n```\n\n#### Analysing outputs {.unnumbered}\n\nOnce the code has finished running, we can plot a summary very easily as follows. Scroll the image to see the full extent.  \n\n\n```{r out.width=c('100%', '100%'), fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F }\n## plot summary figure\nplot(epinow_res)\n```\n\nWe can also look at various summary statistics:\n\n```{r epidemic_models_epinow_summary,}\n## summary table\nepinow_res$summary\n```\n\nFor further analyses and custom plotting, you can access the summarised daily\nestimates via `$estimates$summarised`. We will convert this from the default\n`data.table` to a `tibble` for ease of use with **dplyr**.\n\n```{r epidemic_models_to_tibble, eval=F}\n## extract summary and convert to tibble\nestimates <- as_tibble(epinow_res$estimates$summarised)\nestimates\n```\n\n```{r epidemic_models_tibble_show,  echo = F}\n## show outputs\nestimates <- as_tibble(epinow_res$estimates$summarised)\nDT::datatable(\n  estimates,\n  rownames = FALSE,\n  filter = \"top\",\n  options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap'\n)\n```\n\nAs an example, let's make a plot of the doubling time and R<sub>t</sub>. We will\nonly look at the first few months of the outbreak when R<sub>t</sub> is well\nabove one, to avoid plotting extremely high doublings times.\n\nWe use the formula `log(2)/growth_rate` to calculate the doubling time from the\nestimated growth rate.\n\n```{r epidemic_models_plot_epinow_cusotom, out.width=c('100%', '100%'), fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}\n\n## make wide df for median plotting\ndf_wide <- estimates %>%\n  filter(\n    variable %in% c(\"growth_rate\", \"R\"),\n    date < as.Date(\"2014-09-01\")\n  ) %>%\n  ## convert growth rates to doubling times\n  mutate(\n    across(\n      c(median, lower_90:upper_90),\n      ~ case_when(\n        variable == \"growth_rate\" ~ log(2)/.x,\n        TRUE ~ .x\n      )\n    ),\n    ## rename variable to reflect transformation\n    variable = replace(variable, variable == \"growth_rate\", \"doubling_time\")\n  )\n\n## make long df for quantile plotting\ndf_long <- df_wide %>%\n  ## here we match matching quantiles (e.g. lower_90 to upper_90)\n  pivot_longer(\n    lower_90:upper_90,\n    names_to = c(\".value\", \"quantile\"),\n    names_pattern = \"(.+)_(.+)\"\n  )\n\n## make plot\nggplot() +\n  geom_ribbon(\n    data = df_long,\n    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = date, y = median)\n  ) +\n  ## use label_parsed to allow subscript label\n  facet_wrap(\n    ~ variable,\n    ncol = 1,\n    scales = \"free_y\",\n    labeller = as_labeller(c(R = \"R[t]\", doubling_time = \"Doubling~time\"), label_parsed),\n    strip.position = 'left'\n  ) +\n  ## manually define quantile transparency\n  scale_alpha_manual(\n    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = NULL,\n    alpha = \"Credibel\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    strip.background = element_blank(),\n    strip.placement = 'outside'\n  )\n\n```\n\n<!-- ======================================================= -->\n### EpiEstim {.unnumbered}\n\nTo run **EpiEstim**, we need to provide data on daily incidence and specify the\nserial interval (i.e. the distribution of delays between symptom onset of\nprimary and secondary cases). \n\nIncidence data can be provided to **EpiEstim** as a vector, a data frame, or an `incidence`\nobject from the original **incidence** package. You can even distinguish between imports\nand locally acquired infections; see the documentation at `?estimate_R` for\nfurther details.  \n\nWe will create the input using **incidence2**. See the page on [Epidemic curves] for more examples with the **incidence2** package. Since there have been updates to the **incidence2** package that don't completely align with `estimateR()`'s expected input, there are some minor additional steps needed. The incidence object consists of a tibble with dates and their respective case counts. We use `complete()` from **tidyr** to ensure all dates are included (even those with no cases), and then `rename()` the columns to align with what is expected by `estimate_R()` in a later step.  \n\n```{r epidemic_models_epiestim_incidence,}\n## get incidence from onset date\ncases <- incidence2::incidence(linelist, date_index = \"date_onset\") %>% # get case counts by day\n  tidyr::complete(date_index = seq.Date(                              # ensure all dates are represented\n    from = min(date_index, na.rm = T),\n    to = max(date_index, na.rm=T),\n    by = \"day\"),\n    fill = list(count = 0)) %>%                                       # convert NA counts to 0\n  rename(I = count,                                                   # rename to names expected by estimateR\n         dates = date_index)\n```\n\nThe package provides several options for specifying the serial interval, the\ndetails of which are provided in the documentation at `?estimate_R`. We will\ncover two of them here.\n\n#### Using serial interval estimates from the literature {.unnumbered}\n\nUsing the option `method = \"parametric_si\"`, we can manually specify the mean and\nstandard deviation of the serial interval in a `config` object created using the\nfunction `make_config`. We use a mean and standard deviation of 12.0 and 5.2, respectively, defined in\n[this paper](https://bmcmedicine.biomedcentral.com/articles/10.1186/s12916-014-0196-0):\n\n```{r epidemic_models_epiestim_config,}\n## make config\nconfig_lit <- make_config(\n  mean_si = 12.0,\n  std_si = 5.2\n)\n```\n\nWe can then estimate R<sub>t</sub> with the `estimate_R` function:\n\n```{r epidemic_models_epiestim_lit,  warning = FALSE}\n\ncases <- cases %>% \n     filter(!is.na(date))\n\n\n#create a dataframe for the function estimate_R()\ncases_incidence <- data.frame(dates = seq.Date(from = min(cases$dates),\n                               to = max(cases$dates), \n                               by = 1))\n\ncases_incidence <- left_join(cases_incidence, cases) %>% \n     select(dates, I) %>% \n     mutate(I = ifelse(is.na(I), 0, I))\n\nepiestim_res_lit <- estimate_R(\n  incid = cases_incidence,\n  method = \"parametric_si\",\n  config = config_lit\n)\n```\n\nand plot a summary of the outputs:\n\n```{r epidemic_models_epiestim_lit_plot,  warning = FALSE}\nplot(epiestim_res_lit)\n```\n\n#### Using serial interval estimates from the data {.unnumbered}\n\nAs we have data on dates of symptom onset _and_ transmission links, we can\nalso estimate the serial interval from the linelist by calculating the delay\nbetween onset dates of infector-infectee pairs. As we did in the **EpiNow2**\nsection, we will use the `get_pairwise` function from the **epicontacts**\npackage, which allows us to calculate pairwise differences of linelist\nproperties between transmission pairs. We first create an epicontacts object\n(see [Transmission chains] page for further details):\n\n```{r epidemic_models_epicontacts_epiestim, eval=F}\n## generate contacts\ncontacts <- linelist %>%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %>%\n  drop_na()\n\n## generate epicontacts object\nepic <- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n```\n\nWe then fit the difference in onset dates between transmission pairs, calculated\nusing `get_pairwise`, to a gamma distribution. We use the handy `fit_disc_gamma`\nfrom the **epitrix** package for this fitting procedure, as we require a\n_discretised_ distribution.\n\n```{r epidemic_models_incubation_estimate_epiestim,  warning = FALSE}\n## estimate gamma serial interval\nserial_interval <- fit_disc_gamma(get_pairwise(epic, \"date_onset\"))\n```\n\nWe then pass this information to the `config` object, run **EpiEstim**\nagain and plot the results:\n\n```{r epidemic_models_epiestim_emp,  warning = FALSE}\n## make config\nconfig_emp <- make_config(\n  mean_si = serial_interval$mu,\n  std_si = serial_interval$sd\n)\n\n## run epiestim\nepiestim_res_emp <- estimate_R(\n  incid = cases_incidence,\n  method = \"parametric_si\",\n  config = config_emp\n)\n\n## plot outputs\nplot(epiestim_res_emp)\n```\n\n#### Specifying estimation time windows {.unnumbered}\n\nThese default options will provide a weekly sliding estimate and might act as a\nwarning that you are estimating R<sub>t</sub> too early in the outbreak for a\nprecise estimate. You can change this by setting a later start date for the\nestimation as shown below. Unfortunately, **EpiEstim** only provides a very\nclunky way of specifying these estimations times, in that you have to provide a\nvector of __integers__ referring to the start and end dates for each time\nwindow.\n\n```{r epidemic_models_epiestim_config_late,}\n\n## define a vector of dates starting on June 1st\nstart_dates <- seq.Date(\n  as.Date(\"2014-06-01\"),\n  max(cases$dates) - 7,\n  by = 1\n) %>%\n  ## subtract the starting date to convert to numeric\n  `-`(min(cases$dates)) %>%\n  ## convert to integer\n  as.integer()\n\n## add six days for a one week sliding window\nend_dates <- start_dates + 6\n  \n## make config\nconfig_partial <- make_config(\n  mean_si = 12.0,\n  std_si = 5.2,\n  t_start = start_dates,\n  t_end = end_dates\n)\n```\nNow we re-run **EpiEstim** and can see that the estimates only start from June:\n\n```{r epidemic_models_epiestim_config_late_run,}\n\n## run epiestim\nepiestim_res_partial <- estimate_R(\n  incid = cases_incidence,\n  method = \"parametric_si\",\n  config = config_partial\n)\n\n## plot outputs\nplot(epiestim_res_partial)\n\n```\n\n#### Analysing outputs {.unnumbered}\n\nThe main outputs can be accessed via `$R`. As an example, we will create a plot of\nR<sub>t</sub> and a measure of \"transmission potential\" given by the product of\nR<sub>t</sub> and the number of cases reported on that day; this represents the\nexpected number of cases in the next generation of infection.\n\n```{r epidemic_models_epiestim_plot_full, out.width=c('100%', '100%'), fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}\n\n## make wide dataframe for median\ndf_wide <- epiestim_res_lit$R %>%\n  rename_all(clean_labels) %>%\n  rename(\n    lower_95_r = quantile_0_025_r,\n    lower_90_r = quantile_0_05_r,\n    lower_50_r = quantile_0_25_r,\n    upper_50_r = quantile_0_75_r,\n    upper_90_r = quantile_0_95_r,\n    upper_95_r = quantile_0_975_r,\n    ) %>%\n  mutate(\n    ## extract the median date from t_start and t_end\n    dates = epiestim_res_emp$dates[round(map2_dbl(t_start, t_end, median))],\n    var = \"R[t]\"\n  ) %>%\n  ## merge in daily incidence data\n  left_join(cases, \"dates\") %>%\n  ## calculate risk across all r estimates\n  mutate(\n    across(\n      lower_95_r:upper_95_r,\n      ~ .x*I,\n      .names = \"{str_replace(.col, '_r', '_risk')}\"\n    )\n  ) %>%\n  ## seperate r estimates and risk estimates\n  pivot_longer(\n    contains(\"median\"),\n    names_to = c(\".value\", \"variable\"),\n    names_pattern = \"(.+)_(.+)\"\n  ) %>%\n  ## assign factor levels\n  mutate(variable = factor(variable, c(\"risk\", \"r\")))\n\n## make long dataframe from quantiles\ndf_long <- df_wide %>%\n  select(-variable, -median) %>%\n  ## seperate r/risk estimates and quantile levels\n  pivot_longer(\n    contains(c(\"lower\", \"upper\")),\n    names_to = c(\".value\", \"quantile\", \"variable\"),\n    names_pattern = \"(.+)_(.+)_(.+)\"\n  ) %>%\n  mutate(variable = factor(variable, c(\"risk\", \"r\")))\n\n## make plot\nggplot() +\n  geom_ribbon(\n    data = df_long,\n    aes(x = dates, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = dates, y = median),\n    alpha = 0.2\n  ) +\n  ## use label_parsed to allow subscript label\n  facet_wrap(\n    ~ variable,\n    ncol = 1,\n    scales = \"free_y\",\n    labeller = as_labeller(c(r = \"R[t]\", risk = \"Transmission~potential\"), label_parsed),\n    strip.position = 'left'\n  ) +\n  ## manually define quantile transparency\n  scale_alpha_manual(\n    values = c(`50` = 0.7, `90` = 0.4, `95` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = NULL,\n    alpha = \"Credible\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    strip.background = element_blank(),\n    strip.placement = 'outside'\n  )\n  \n```\n\n<!-- ======================================================= -->\n## Projecting incidence {  }\n\n### EpiNow2 {.unnumbered}\n\nBesides estimating R<sub>t</sub>, **EpiNow2** also supports forecasting of\nR<sub>t</sub> and projections of case numbers by integration with the\n**EpiSoon** package under the hood. All you need to do is specify the `horizon`\nargument in your `epinow` function call, indicating how many days you want to\nproject into the future; see the **EpiNow2** section under the \"Estimating\nR<sub>t</sub>\" for details on how to get **EpiNow2** up and running. In this\nsection, we will just plot the outputs from that analysis, stored in the\n`epinow_res` object.\n\n```{r epidemic_models_episoon, out.width=c('100%', '100%'), fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}\n\n## define minimum date for plot\nmin_date <- as.Date(\"2015-03-01\")\n\n## extract summarised estimates\nestimates <-  as_tibble(epinow_res$estimates$summarised)\n\n## extract raw data on case incidence\nobservations <- as_tibble(epinow_res$estimates$observations) %>%\n  filter(date > min_date)\n\n## extract forecasted estimates of case numbers\ndf_wide <- estimates %>%\n  filter(\n    variable == \"reported_cases\",\n    type == \"forecast\",\n    date > min_date\n  )\n\n## convert to even longer format for quantile plotting\ndf_long <- df_wide %>%\n  ## here we match matching quantiles (e.g. lower_90 to upper_90)\n  pivot_longer(\n    lower_90:upper_90,\n    names_to = c(\".value\", \"quantile\"),\n    names_pattern = \"(.+)_(.+)\"\n  )\n\n## make plot\nggplot() +\n  geom_histogram(\n    data = observations,\n    aes(x = date, y = confirm),\n    stat = 'identity',\n    binwidth = 1\n  ) +\n  geom_ribbon(\n    data = df_long,\n    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = date, y = median)\n  ) +\n  geom_vline(xintercept = min(df_long$date), linetype = 2) +\n  ## manually define quantile transparency\n  scale_alpha_manual(\n    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = \"Daily reported cases\",\n    alpha = \"Credible\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14)\n\n```\n\n### projections {.unnumbered}\n\nThe **projections** package developed by RECON makes it very easy to make short\nterm incidence forecasts, requiring only knowledge of the effective reproduction\nnumber R<sub>t</sub> and the serial interval. Here we will cover how to use\nserial interval estimates from the literature and how to use our own estimates\nfrom the linelist.\n\n#### Using serial interval estimates from the literature {.unnumbered}\n\n**projections** requires a discretised serial interval distribution of the class\n`distcrete` from the package **distcrete**. We will use a gamma distribution\nwith a mean of 12.0 and and standard deviation of 5.2 defined in\n[this paper](https://bmcmedicine.biomedcentral.com/articles/10.1186/s12916-014-0196-0). To\nconvert these values into the shape and scale parameters required for a gamma\ndistribution, we will use the function `gamma_mucv2shapescale` from the\n**epitrix** package.\n\n```{r epidemic_models_projections_distcrete,}\n\n## get shape and scale parameters from the mean mu and the coefficient of\n## variation (e.g. the ratio of the standard deviation to the mean)\nshapescale <- epitrix::gamma_mucv2shapescale(mu = 12.0, cv = 5.2/12)\n\n## make distcrete object\nserial_interval_lit <- distcrete::distcrete(\n  name = \"gamma\",\n  interval = 1,\n  shape = shapescale$shape,\n  scale = shapescale$scale\n)\n\n```\n\nHere is a quick check to make sure the serial interval looks correct. We\naccess the density of the gamma distribution we have just defined by `$d`, which\nis equivalent to calling `dgamma`:\n\n```{r epidemic_models_projections_distcrete_plot,}\n\n## check to make sure the serial interval looks correct\nqplot(\n  x = 0:50, y = serial_interval_lit$d(0:50), geom = \"area\",\n  xlab = \"Serial interval\", ylab = \"Density\"\n)\n\n```\n\n#### Using serial interval estimates from the data {.unnumbered}\n\nAs we have data on dates of symptom onset _and_ transmission links, we can\nalso estimate the serial interval from the linelist by calculating the delay\nbetween onset dates of infector-infectee pairs. As we did in the **EpiNow2**\nsection, we will use the `get_pairwise` function from the **epicontacts**\npackage, which allows us to calculate pairwise differences of linelist\nproperties between transmission pairs. We first create an epicontacts object\n(see [Transmission chains] page for further details):\n\n```{r epidemic_models_epicontacts_projections, eval=F}\n## generate contacts\ncontacts <- linelist %>%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %>%\n  drop_na()\n\n## generate epicontacts object\nepic <- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n```\n\nWe then fit the difference in onset dates between transmission pairs, calculated\nusing `get_pairwise`, to a gamma distribution. We use the handy `fit_disc_gamma`\nfrom the **epitrix** package for this fitting procedure, as we require a\n_discretised_ distribution.\n\n```{r epidemic_models_incubation_estimate_projections,  warning = FALSE}\n## estimate gamma serial interval\nserial_interval <- fit_disc_gamma(get_pairwise(epic, \"date_onset\"))\n\n## inspect estimate\nserial_interval[c(\"mu\", \"sd\")]\n```\n\n#### Projecting incidence {.unnumbered}\n\nTo project future incidence, we still need to provide historical incidence in\nthe form of an `incidence` object, as well as a sample of plausible\nR<sub>t</sub> values. We will generate these values using the R<sub>t</sub>\nestimates generated by **EpiEstim** in the previous section (under \"Estimating\nR<sub>t</sub>\") and stored in the `epiestim_res_emp` object. In the code below,\nwe extract the mean and standard deviation estimates of R<sub>t</sub> for the\nlast time window of the outbreak (using the `tail` function to access the last\nelement in a vector), and simulate 1000 values from a gamma distribution using\n`rgamma`. You can also provide your own vector of R<sub>t</sub> values that you\nwant to use for forward projections.\n\n```{r epidemic_models_projection_setup,  warning = FALSE}\n\n## create incidence object from dates of onset\ninc <- incidence::incidence(linelist$date_onset)\n\n## extract plausible r values from most recent estimate\nmean_r <- tail(epiestim_res_emp$R$`Mean(R)`, 1)\nsd_r <- tail(epiestim_res_emp$R$`Std(R)`, 1)\nshapescale <- gamma_mucv2shapescale(mu = mean_r, cv = sd_r/mean_r)\nplausible_r <- rgamma(1000, shape = shapescale$shape, scale = shapescale$scale)\n\n## check distribution\nqplot(x = plausible_r, geom = \"histogram\", xlab = expression(R[t]), ylab = \"Counts\")\n\n```\n\nWe then use the `project()` function to make the actual forecast. We specify how\nmany days we want to project for via the `n_days` arguments, and specify the\nnumber of simulations using the `n_sim` argument.\n\n```{r epidemic_models_make_projection,}\n\n## make projection\nproj <- project(\n  x = inc,\n  R = plausible_r,\n  si = serial_interval$distribution,\n  n_days = 21,\n  n_sim = 1000\n)\n\n```\n\nWe can then handily plot the incidence and projections using the `plot()` and\n`add_projections()` functions. We can easily subset the `incidence` object to only\nshow the most recent cases by using the square bracket operator.\n\n```{r epidemic_models_plot_projection, out.width=c('100%', '100%'), fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}\n\n## plot incidence and projections\nplot(inc[inc$dates > as.Date(\"2015-03-01\")]) %>%\n  add_projections(proj)\n\n```\n\nYou can also easily extract the raw estimates of daily case numbers by\nconverting the output to a dataframe.\n\n```{r epidemic_models_projection_df, eval=F, warning = FALSE}\n## convert to data frame for raw data\nproj_df <- as.data.frame(proj)\nproj_df\n```\n\n```{r epidemic_models_projection_dt,  echo = F}\n\n## convert to data frame for raw data\nproj_df <- as.data.frame(proj)\n\n## data table output\nDT::datatable(\n  proj_df[1:11],\n  rownames = FALSE,\n  filter = \"top\",\n  options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap'\n)\n\n```\n\n\n<!-- ======================================================= -->\n## Resources {  }\n\n* [Here is the paper](https://www.sciencedirect.com/science/article/pii/S1755436519300350) describing\n  the methodology implemented in **EpiEstim**.\n* [Here is the paper](https://wellcomeopenresearch.org/articles/5-112/v1) describing\n  the methodology implemented in **EpiNow2**.\n* [Here is a paper](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1008409) describing\n  various methodological and practical considerations for estimating R<sub>t</sub>.\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"epidemic_models.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.340","lightbox":true,"theme":{"light":"cosmo","dark":["cosmo","theme-dark.scss"]}},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}