[
  {
    "objectID": "index.tr.html",
    "href": "index.tr.html",
    "title": "Epidemiyologun R Rehberi",
    "section": "",
    "text": "Hoş geldin",
    "crumbs": [
      "Hoş geldin"
    ]
  },
  {
    "objectID": "index.tr.html#uygulamalı-epidemiyoloji-ve-halk-sağlığı-için-r",
    "href": "index.tr.html#uygulamalı-epidemiyoloji-ve-halk-sağlığı-için-r",
    "title": "Epidemiyologun R Rehberi",
    "section": "Uygulamalı epidemiyoloji ve halk sağlığı için R",
    "text": "Uygulamalı epidemiyoloji ve halk sağlığı için R\nKullanımı: Bu çevrimiçi kitap, dünya çapında 300.000 kişi tarafından 1 milyondan fazla kez kullanılmıştır.\nHedef: Yaygın epidemiyolojik sorunlara çözümler üreten, pratik, hedef odaklı ve hızlı bir (çevrimiçi ve [çevrimdışı][El Kitabı ve verileri indirme]) referans kılavuz olarak rol oynamak.\nR’a yeni mi başlıyorsun? Ücretsiz interaktif eğitimlerimiz ya da senkronize, sanal kurslarımız Amerika CDC, Dünya Sağlık Örgütü dahil olmak üzere 75’ten fazla sağlık örgütü ve saha eğitim programlarında kullanıldı.\nDiller: İngilizce (English), Vietnamca (Tiếng Việt), Japonca (日本), İspanyolca (Español) Türkçe, Fransızca (Français), Portekizce (Português), Rusça (Русский)\n\n\n\n\n\n\n\n Epidemiyologlar tarafından epidemiyologlar için yazılmıştır\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\nApplied Epi dünyanın dört bir yanında faaliyetlerde bulunan, kar amacı gütmeyen bir kuruluştur. Böyle bir kaynağı sağlık çalışanlarına sunabilmek için kişisel vaktimizi bunu yazmaya ayırdık. Desteğinizi ve geri bildirimlerinizi memnuniyetle kabul ederiz:\n\nWebsitemizi ziyaret edip irtibat listemize katılabilirsiniz.\ncontact@appliedepi.org mail adresimiz, @appliedepi twitter veya LinkedIn hesabımızdan bize ulaşabilirsiniz.\n\nGithub sunucumuza sorunlarınızı bildirebilirsiniz.\n\nOnlarca yıllık epidemiyoloji deneyimine sahip eğitmenlerimizle canlı R eğitimi sunuyoruz - başvurmak için bize e-mail atabilirsiniz.",
    "crumbs": [
      "Hoş geldin"
    ]
  },
  {
    "objectID": "index.tr.html#kitabı-nasıl-kullanabilirim",
    "href": "index.tr.html#kitabı-nasıl-kullanabilirim",
    "title": "Epidemiyologun R Rehberi",
    "section": "Kitabı nasıl kullanabilirim?",
    "text": "Kitabı nasıl kullanabilirim?\n\nİçindekiler bölümündeki sayfalara göz atabilir veya arama kutusunu kullanabilirsiniz\nKodu kopyalamak için “kopyala” simgelerine tıklayabilirsiniz\n[örnek verileri][El Kitabı ve verileri indirme] kullanarak kendiniz de deneyebilirsiniz\n\nÇevrimdışı versiyonu\n[El Kitabı ve verileri indirme] sayfasında çevrimdışı versiyonuna nasıl ulaşacağınızı görebilirsiniz.",
    "crumbs": [
      "Hoş geldin"
    ]
  },
  {
    "objectID": "index.tr.html#teşekkür",
    "href": "index.tr.html#teşekkür",
    "title": "Epidemiyologun R Rehberi",
    "section": "Teşekkür",
    "text": "Teşekkür\nBu el kitabı, Dünya Sağlık Örgütü (WHO), Médecins Sans Frontières / Sınır Tanımayan Doktorlar (MSF), bölgesel ve ulusal sağlık örgütleri, akademik kurumlar ve hastaneler dahil olmak üzere pek çok kuruluşun deneyimlerinden faydalanılarak dünyanın dört bir yanından epidemiyologların işbirliğiyle hazırlanmıştır.\nBu el kitabı, belirli bir kuruluşun onaylanmış bir ürünü değildir. En doğru bilgiyi sizinle paylaşmak için çabalasak da, bu kitaptaki içerikle ilgili hiçbir garanti veremeyiz.\n\nKatkıda Bulunanlar\nEditör: Neale Batra\nYazarlar: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonathan Polonsky, Yurie Izawa, Chris Bailey, Daniel Molling, Isha Berry, Emma Buajitti, Mathilde Mousset, Sara Hollis, Wen Lin\nKatkıda bulunanlar: Pat Keating, Amrish Baidjoe, Annick Lenglet, Margot Charette, Danielly Xavier, Marie-Amélie Degail Chabrat, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Kate Kelsey, Berhe Etsay, John Rossow, Mackenzie Zendt, James Wright, Laura Haskins, Flavio Finger, Tim Taylor, Jae Hyoung Tim Lee, Brianna Bradley, Wayne Enanoria, Manual Albela Miranda, Molly Mantus, Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao Muianga\nİllüstrasyonlar: Calder Fong\nÇevirmenler: Çağrı Emin Şahin, Abdullah Ömer Şeker, Can Ilgin, Ömer Özer, Yasemin Denizli\n\n\n\n\n\n\nFonlama ve destek\nBu kitap binlerce saat süren gönüllü bir çabanın sonunda ortaya çıktı.\nEl kitabı, Saha Epidemiyolojisi küresel ağı olan TEPHINET’in COVID-19 acil durum kapasite geliştirme hibesinden destek fonu aldı.\nAyrıca El kitabı Annika Wendland’ın destekleriyle EPIET Mezunlar Ağı’ndan (EAN) idari destek aldı. EPIET, girişimsel epidemiyoloji eğitimi veren bir Avrupa programıdır.\nBu el kitabının geliştirilmesi sırasındaki destekleri için Médecins Sans Frontières (MSF) Amsterdam Operasyon Merkezi’ne (OCA) özellikle teşekkür ederiz.\nBu yayın, NU2GGH001873 numaralı İşbirliği Anlaşması ile Hastalık Kontrol ve Önleme Merkezi tarafından Küresel Sağlık Kurulu’nun bir programı olan TEPHINET aracılığıyla finanse edilmiştir. İçeriğin oluşturulması yalnızca yazarların sorumluluğundadır ve Hastalık Kontrol ve Önleme Merkezi, Sağlık ve İnsan Hizmetleri Departmanı, Küresel Sağlık Kurulu veya TEPHINET’in resmi görüşlerini temsil etmemektedir.\n\n\nİlham\nEl kitabı içeriğinin geliştirilmesi için, bilgi amaçlı, çok sayıda öğretici ve kısa hikaye, ilgili sayfalarında paylaşılmıştır.\nDaha genel olarak, aşağıdaki kaynaklar bu el kitabı için ilham kaynağı olmuştur: “R4Epis” projesi (MSF ve RECON işbirliği)\nR Salgın Konsorsiyumu (RECON)\nVeri Bilimi için R kitabı (R4DS)\nbookdown: R Markdown ile Kitap ve Teknik Belge Yazma\nNetlify (website sunucusu)",
    "crumbs": [
      "Hoş geldin"
    ]
  },
  {
    "objectID": "index.tr.html#kullanım-ve-katkı-koşulları",
    "href": "index.tr.html#kullanım-ve-katkı-koşulları",
    "title": "Epidemiyologun R Rehberi",
    "section": "Kullanım ve Katkı Koşulları",
    "text": "Kullanım ve Katkı Koşulları\n\nLisans\n Applied Epi Anonim Şirketi, 2021 Bu yayın, Applied Epi Anonim Şirketi tarafından “Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License”ı ile lisanslanmıştır..\nAkademik kurslarda ve epidemiyoloji eğitim programlarında bu el kitabı eğitim amaçlı kullanılıp çoğaltılabilir. Böyle bir durum söz konusu olduğunda bize e-posta ile haber vermenizi rica ediyoruz. Kullanım amacınızla ilgili sorularınız varsa contact@appliedepi.org adresine e-posta gönderebilirsiniz.\n\n\nAlıntı\nBatra, Neale, et al. The Epidemiologist R Handbook. 2021. \n\n\nKatkı\nİçerik katkısı yapmak istiyorsanız, lütfen önce Github veya e-posta yoluyla bizimle iletişime geçin. Güncellemeler için bir kapsamlı bir program uyguluyor ve bu amaçla destek rehberi hazırlıyoruz.\nLütfen destek vermeden önce epiRhandbook projesi Davranış Kuralları kılavuzunu inceleyin. Bu projeye katkıda bulunarak, kılavuzda belirlenen şartlara uymayı kabul etmiş olursunuz.",
    "crumbs": [
      "Hoş geldin"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.tr.html",
    "href": "new_pages/editorial_style.tr.html",
    "title": "1  Önyazı ve teknik notlar",
    "section": "",
    "text": "1.1 Yaklaşım ve stil\nBu kitabın potansiyel hedef kitlesinin geniş olmasını istedik. Hem R’a yeni olan kişiler tarafından hem de “R’ın iyi uygulamalarını” ve “R’ın ipuçlarını” öğrenmek isteyen deneyimli kullanıcıların bu kitaptan faydalanabilmesini istedik. Kitap hem kolayca erişilebilir hem de az ve öz olmalıydı. Bu nedenle yaklaşımımızı, R’de çok yeni olan birinin kodu uygulayabileceği ve kodun ne yaptığını takip edebileceği yeterli metin açıklamasını sağlamak olarak belirledik.\nBir kaç nokta daha:",
    "crumbs": [
      "Bu kitap hakkında",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Önyazı ve teknik notlar</span>"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.tr.html#yaklaşım-ve-stil",
    "href": "new_pages/editorial_style.tr.html#yaklaşım-ve-stil",
    "title": "1  Önyazı ve teknik notlar",
    "section": "",
    "text": "Nispeten kısa örneklerin eşlik ettiği bir kod referans kitabı olarak tasarlanmıştır - R , veri bilimi üzerine kapsamlı bir ders kitabı değildir.\nUygulamalı epidemiyolojide kullanmanız için R el kitabı olarak kapsamı sınırlandırılmıştır - uygulamalı epidemiyoloji yöntemleri veya bilimi hakkında bir kılavuz değil.\nBu el kitabının yaşayan bir belge olması amaçlanmıştır - belirli görevler için hazırlanan R paketleri sıklıkla güncellenir ve değişir. Bu kitapta hangilerine yer vermemiz gerektiğine dair öneri ve eleştirilerinizi memnuniyetle öğrenmek isteriz.\n\n\nR paketleri\nÇok fazla seçenek\nR öğrenmenin en zorlu yönlerinden biri de hangi R paketinin kullanılacağını bilmektir. Bir işi çözmeye çalışırken “Hey, bunların hepsini tek bir komut satırında yapan bir R paketi var!” demeniz nadir bir durum olmayacaktır.\nBu el kitabında, her görevi tamamlamanız için size en az iki yol sunmaya çalıştık: ilki denenmiş ve doğrulanmış bir yöntem (muhtemelen base R veya tidyverse içinde) ve ikincisi o iş için özel olarak tasarlanmış bir R paketi. Belirli bir pakette sorun yaşamanız halinde birden fazla seçeneğe sahip olmanızı istiyoruz.\nPaketleri belirlerken, R topluluğu tarafından test edilmiş ve onaylanmış paketlere ve yaklaşımlara öncelik verdik. Rutin bir çalışma oturumunda işinize yarayacak, stabil (çok sık değişmeyen) ve görevi basit ve temiz bir şekilde yerine getirebilecek minimal sayıda paket kullandık.\nBu el kitabı tidyverse’de bulunan R paket ve işlevlerine öncelik verir. Tidyverse, temel dilbilgisi ve veri yapılarını paylaşan veri bilimi için tasarlanmış bir R paketi koleksiyonudur. Tüm tidyverse paketleri, tidyverse paketi aracılığıyla kurulabilir veya yüklenebilir. Tidyverse’n web sitesinde daha fazlasını okuyabilirsiniz.\nUygun yerlerde, kurulum sırasında R ile birlikte yüklenen base paket ve fonksiyonlarıyla ilişkili kod seçeneklerini de ekledik. Bunu, bu kitabın okuyucularından bazılarının ekstra paketleri indirmek için güvenilir bir internete sahip ol(a)mama ihtimaline karşılık yaptık.\nFonksiyonları paketlerle ilişkilendirme\nR eğitim ve rehberlerinde bir fonksiyona ilişkin kodun anlatılıp, kullanılan paketin hiç değinilmemesine şahit olmuşsunuzdur. Bu durum sinir bozucudur! İşte biz bunu size yaşatmaktan kaçınmaya çalıştık.\nAçıklama metinlerinde paket adları kalın harflerle (örn. dplyr) ve fonksiyonları mutate() şeklinde yazılır. Bir fonksiyonun hangi paketten geldiğini, ya en yakındaki metinde referanslayarak ya da kodu dplyr::mutate() şeklinde yazarak size açıklamaya çalıştık. Başta gereksiz görünebilir ancak bunu yukarıda bahsettiğimiz amaç doğrultusunda, bilerek yapıyoruz.\nPaketler ve fonksiyonları hakkında daha fazla bilgi edinmek için R basics sayfasına bakabilirsiniz.\n\n\nKodlama stili\nEl kitabında sık sık “yeni satırlar” kullanıyoruz, bu da kodumuzun “uzun” görünmesine neden olabiliyor. Bunun birkaç sebebi var:\n\nKodun her küçük parçasına bitişik # ile açıklayıcı yorumlar yazabiliriz.\nGenellikle daha uzun (dikey) kodun okunması daha kolaydır.\nKodların dar bir ekranda okunması daha kolaydır (ekranı yana kaydırmanıza gerek kalmaz).\nGirintiler sayesinde hangi argümanların hangi fonksiyona ait olduğunu daha kolay anlayabilirsiniz.\n\nSonuç olarak, aşağıdaki gibi yazılabilecek kod:\n\nlinelist %&gt;% \n  group_by(hospital) %&gt;%  # satırları hastane (hospital) olarak gruplandır\n  slice_max(date, n = 1, with_ties = F) # eğer tarih (date) ile eşleşirse ilk satırı al\n\n…şu şekilde yazılır:\n\nlinelist %&gt;% \n  group_by(hospital) %&gt;% # satırları hastane (hospital) olarak gruplandır\n  slice_max(\n    date,                # maksimum tarih değerine grubu sırala\n    n = 1,               # gruptaki satırlardan sadece ilkini al \n    with_ties = F)       # eğer tarih (date) ile eşleşirse ilk satırı al\n\nR kodu genel olarak yeni satır veya girintilerden etkilenmez. Kodu yazarken, virgülden sonra yeni bir satır başlatırsanız, program yeni satıra otomatik girinti uygular.\nAyrıca, okunması daha kolay olduğu için kodu yazarken birçok boşluk kullandık (örneğin, ‘n=1’ yerine ‘n = 1’). Siz de kodunuzu yazarken onu okuyabilecek insanları düşünerek yazmalısınız!\n\n\nTerminoloji\nBu el kitabında, genellikle “değişkenler” ve “gözlemler” yerine “sütunlar” ve “satırlar”a atıfta bulunuyoruz. “Tidy verileri” ile ilgili bu makalede açıklandığı gibi, epidemiyolojik istatistiksel veri setlerinin çoğu yapısal olarak satır, sütun ve değerlerden oluşur.\nDeğişkenler aynı temel özelliği ölçen değerleri içerir (yaş grubu, çıktı veya başlangıç tarihi gibi). Gözlemler aynı birimde ölçülen tüm değerleri içerir (örneğin bir kişi, alan veya laboratuvar numunesi vb.). Dolayısıyla bu yönleri somut olarak tanımlamak daha zor olabilmektedir.\n“Tidy” veri kümelerinde her sütun bir değişken, her satır bir gözlem ve her hücre de tek bir değeri ifade etmektedir. Ancak karşılaştığınız bazı veri kümeleri bu kalıba sığmaz - “geniş” biçimli bir veri kümesinin birkaç sütuna bölünebilen değişkenleri olabilir (Pivoting data sayfasındaki bir örneğe bakın). Benzer şekilde, gözlemler de birkaç satıra bölünebilir.\nBu el kitabı çoğunlukla, verileri yönetmek ve işlemek üzerine odaklanmıştır. O nedenle satır ve sütunlarda somut verilere atıfta bulunmayı, daha soyut olan “gözlem” ve “değişkenler”e tercih ettik. Bu yaklaşımımızın istisnası, daha fazla değişken ve gözlem referansıyla karşılaşacağınız veri analizi sayfalarıdır.\n\n\nNotlar\nEl kitabında karşılaşabileceğiniz not türleri şunlardır:\nNOT: Bu bir nottur.\nİPUCU: Bu bir ipucudur.\nDİKKAT: Bu dikkatli yaklaşmanızı tavsiye eden bir nottur.\nTEHLİKE: Bu bir uyarıdır.",
    "crumbs": [
      "Bu kitap hakkında",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Önyazı ve teknik notlar</span>"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.tr.html#editöryal-kararlar",
    "href": "new_pages/editorial_style.tr.html#editöryal-kararlar",
    "title": "1  Önyazı ve teknik notlar",
    "section": "1.2 Editöryal Kararlar",
    "text": "1.2 Editöryal Kararlar\nAşağıda, paket ve işlev seçimiyle ilgili önemli editoryal kararları sizinle paylaşıyoruz. Bizimle aynı fikirde değilseniz veya değerlendirilmesi için yeni bir araç önermek isterseniz, lütfen Github sayfamıza katılın ve yeni bir sohbet başlatın.\nPaket, fonksiyon ve diğer editoryal kararlar tablosu\n\n\n\n\n\n\n\n\n\nKonu\nPaket\nÇıktı\nRasyoneli\n\n\n\n\nGenel kodlama yaklaşımı\ntidyverse, data.table, base\ntidyverse, data.table üzerinde bir sayfa ve interneti olmayan okuyucular için base alternatifleri\ntidyverse okunabilir, evrensel, en çok öğretilen pakettir.\n\n\nPaket yükleme\nlibrary(),install.packages(), require(), pacman\npacman\nÇoklu paket indirme/yükleme süreçlerini kısaltır ve basitleştirir.\n\n\nİçe ve dışa aktarma\nrio, ve diğer pek çok paketler\nrio\nbirçok dosya türü için kolaylık sağlar.\n\n\nİstatistik özetleri için gruplandırma\ndplyr group_by(), stats aggregate()\ndplyr group_by()\ntidyverse vurgusu ile tutarlıdır.\n\n\nPivotlama\ntidyr (pivot fonksiyonları), reshape2 (melt/cast), tidyr (spread/gather)\ntidyr (pivot fonksiyonları)\nreshape2 artık kullanımda değil, tidyr v1.0.0 itibariyle pivot fonksiyonlarını kullanmaktadır.\n\n\nSütun adlarını temizleme\nlinelist, janitor\njanitor\nPaketlerin birlikte kullanımı vurgulanmaktadır.\n\n\nEpiweeks\nlubridate, aweek, tsibble, zoo\ngenelde lubridate, özel durumlarda diğer paketler\nlubridate esnek, tutarlı ve diğer paketleri koruyan bir seçenektir.\n\n\nggplot etiketleri\nlabs(), ggtitle()/ylab()/xlab()\nlabs()\ntüm etiketler tek bir yerde, kullanımı basittir.\n\n\nFaktöre çevir\nfactor(), forcats\nforcats\nçeşitli fonksiyonları da aynı komutta faktöre dönüşür.\n\n\nEpidemi eğrileri\nincidence, ggplot2, EpiCurve\nincidence2 hızlıdır, ggplot2 ise detaylı ve güvenilirdir.\n\n\n\nBirleştirme\npaste(), paste0(), str_glue(), glue()\nstr_glue()\nstringr fonksiyonlarını içerir; yapıştır fonksiyonlarından daha basit bir sentaks (sözdizimi) vardır.",
    "crumbs": [
      "Bu kitap hakkında",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Önyazı ve teknik notlar</span>"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.tr.html#büyük-güncellemeler",
    "href": "new_pages/editorial_style.tr.html#büyük-güncellemeler",
    "title": "1  Önyazı ve teknik notlar",
    "section": "1.3 Büyük güncellemeler",
    "text": "1.3 Büyük güncellemeler\n\n\n\nTarih\nAçıklama\n\n\n\n\n10 May 2021\nVersiyon 1.0.0’ın yayınlanması",
    "crumbs": [
      "Bu kitap hakkında",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Önyazı ve teknik notlar</span>"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.tr.html#oturum-bilgisi-r-rstudio-packages",
    "href": "new_pages/editorial_style.tr.html#oturum-bilgisi-r-rstudio-packages",
    "title": "1  Önyazı ve teknik notlar",
    "section": "1.4 Oturum bilgisi (R, RStudio, packages)",
    "text": "1.4 Oturum bilgisi (R, RStudio, packages)\nAşağıda, bu el Kitabının hazırlanması sırasında kullanılan R, RStudio, R paketleri ve sürümlerine ilişkin bilgiler yer almaktadır.\n\nsessioninfo::session_info()\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31 ucrt)\n os       Windows 11 x64 (build 22621)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       Europe/Stockholm\n date     2024-05-10\n pandoc   3.1.11 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n cli           3.6.2   2023-12-11 [2] CRAN (R 4.3.2)\n digest        0.6.35  2024-03-11 [1] CRAN (R 4.3.3)\n evaluate      0.23    2023-11-01 [2] CRAN (R 4.3.2)\n fastmap       1.1.1   2023-02-24 [2] CRAN (R 4.3.2)\n htmltools     0.5.8   2024-03-25 [1] CRAN (R 4.3.3)\n htmlwidgets   1.6.4   2023-12-06 [2] CRAN (R 4.3.2)\n jsonlite      1.8.8   2023-12-04 [2] CRAN (R 4.3.2)\n knitr         1.45    2023-10-30 [2] CRAN (R 4.3.2)\n rlang         1.1.3   2024-01-10 [2] CRAN (R 4.3.2)\n rmarkdown     2.26    2024-03-05 [1] CRAN (R 4.3.3)\n rstudioapi    0.15.0  2023-07-07 [2] CRAN (R 4.3.2)\n sessioninfo   1.2.2   2021-12-06 [2] CRAN (R 4.3.2)\n xfun          0.43    2024-03-25 [1] CRAN (R 4.3.3)\n\n [1] C:/Users/ngulu864/AppData/Local/R/win-library/4.3\n [2] C:/Program Files/R/R-4.3.2/library\n\n──────────────────────────────────────────────────────────────────────────────",
    "crumbs": [
      "Bu kitap hakkında",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Önyazı ve teknik notlar</span>"
    ]
  },
  {
    "objectID": "new_pages/data_used.tr.html",
    "href": "new_pages/data_used.tr.html",
    "title": "2  El Kitabı ve verileri indirme",
    "section": "",
    "text": "2.1 Çevrimdışı el kitabı indirme\nİnternet erişiminiz olmasa bile bu el kitabını web tarayıcınızda görüntüleyebilirsiniz. Bunun için HTML dosyalarını indirmeniz gerekmektedir. Epi R El Kitabını çevrimdışı kullanmayı düşünüyorsanız, bilmeniz gereken gereken birkaç nokta mevcut:\nEl Kitabını iki farklı yoldan indirebilirsiniz:",
    "crumbs": [
      "Bu kitap hakkında",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>El Kitabı ve verileri indirme</span>"
    ]
  },
  {
    "objectID": "new_pages/data_used.tr.html#çevrimdışı-el-kitabı-indirme",
    "href": "new_pages/data_used.tr.html#çevrimdışı-el-kitabı-indirme",
    "title": "2  El Kitabı ve verileri indirme",
    "section": "",
    "text": "Dosyaları açtığınızda resimler ve İçindekiler’in yüklenmesi bir veya iki dakika sürebilir.\nÇevrimdışı kitabın düzeni biraz farklıdır - solda İçindekiler Tablosu olan uzun bir alan görecekseniz. Belirli terimleri aramak için Ctrl+F (Cmd-F) tuşlarını kullanabilirsiniz.\nİnternet bağlantınızı kesmeden önce uygun R paketlerini kurmanıza yardımcı olması için Önerilen paketler sayfasına bakın.\nTüm örnek verileri içeren R paketinizi epirhandbook kurun. (kurulum işlemi aşağıda açıklanmıştır)\n\n\n\nİndirme linkini kullanarak\nLinke hızlıca erişebilmek için, bu linki sağ fare tuşunuzla tıklayın link ve “Farklı Kaydet” seçeneğini seçin.\nMac kullanıyorsanız, Cmd’ye basılı tutarak farenizle tıklayın. Cep telefonu kullanıyorsanız, bağlantıyı basılı tutun ve “Bağlantıyı kaydet”i seçin. Kitap cihazınıza indirilecektir. Görseller olmadan HTML kodu içeren bir ekran görürseniz, yukarıdaki talimatları uyguladığınızdan emin olun veya ikinci seçeneği deneyin.\n\n\nR paketimizi kullanın\nSizin için epirhandbook adında bir R paketi tasarladık. El kitabını bilgisayarınıza indirebilmek için download_book() adlı bir fonksiyon oluşturduk. Bu fonksiyonu R programınızda kullanabilirsiniz.\nBu pakette ayrıca get_data() adlı bir fonksiyon da mevcuttur. Bu fonskiyonla tüm örnek verileri bilgisayarınıza indirebilirsiniz.\nGithub sayfamızdan appliedepi epirhandbook R paketini indirmek için aşağıda verdiğimiz kodu kullanabilirsiniz. İndireceğiniz bu paket CRAN’da olmadığı için (Github’da kayıtlı) p_install_gh() özel fonksiyonunu kullanmanız gerekecektir.\n\n# Epi R El Kitabı paketinin en son sürümünü indirin\npacman::p_install_gh(\"appliedepi/epirhandbook\")\n\nŞimdi, mevcut R oturumunuzda kullanmak üzere paketi yükleyin:\n\n# paketi kullanmak için yükleyin\npacman::p_load(epirhandbook)\n\nArdından, el kitabını bilgisayarınıza indirmek için paketin download_book() (boş parantez ile) fonksiyonunu çalıştırın. RStudio kullandığınızı varsayarsak, dosyaları kaydetmeden önce konumu seçmenize izin veren bir pencere açılacaktır.\n\n# çevrimdışı el kitabını bilgisayarınıza indirin\ndownload_book()",
    "crumbs": [
      "Bu kitap hakkında",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>El Kitabı ve verileri indirme</span>"
    ]
  },
  {
    "objectID": "new_pages/data_used.tr.html#örnek-bazlı-verileri-indirme",
    "href": "new_pages/data_used.tr.html#örnek-bazlı-verileri-indirme",
    "title": "2  El Kitabı ve verileri indirme",
    "section": "2.2 Örnek bazlı verileri indirme",
    "text": "2.2 Örnek bazlı verileri indirme\nEl kitabındaki örnekleri “takip etmek” için örnek veri ve çıktıları indirebilirsiniz.\n\nR paketimizi kullanma\nTüm verileri indirmenin en kolay yolu, R paketimiz olan epirhandbook kurmaktır. Bu paket tüm örnek verileri bilgisayarınızda seçtiğiniz bir klasöre kaydeden get_data() fonksiyonunu içerir.\nR paketini epirhandbooku kurmak için aşağıdaki kodu çalıştırın. Paketimiz CRAN’da bulunmamaktadır. Bu yüzden kurmak için p_install_gh() fonksiyonunu kullanın. Parantez içindeki referans, Github organizasyonumuza (“appliedepi”) ve epirhandbook proje adına atıfta bulunnmaktadır.\n\n# Epi R El Kitabı paketinin en son sürümünü indirin\npacman::p_install_gh(\"appliedepi/epirhandbook\")\n\nŞimdi, mevcut R oturumunuzda kullanmak üzere paketi yükleyin:\n\n# paketi kullanmak için yükleyin\npacman::p_load(epirhandbook)\n\nBu işlemlerin ardından, örnek verileri bilgisayarınıza indirmek için paketin get_data() fonksiyonunu kullanın. Örnek verilerin tamamını indirmek için get_data(\"all\") komutunu çalıştırın veya yalnızca bir dosyayı almak için tırnak işaretleri içinde ilgili dosya adı ve uzantısını yazın.\nVeriler paketle birlikte indirilmiş olacaktır. Burada yapmanız gereken tek şey bilgisayarınızda indireceğiniz klasörü belirlemektir. İndirme konumunu seçmenize izin veren bir açılır pencere karşınıza çıkacaktır. Örnek veri ve çıktılar dahil yaklaşık 30 dosya olduğundan indirme konumunda yeni bir “veri” klasörü oluşturmanızı öneririz.\n\n# tüm örnek verileri bilgisayarınızdaki bir klasöre indirin\nget_data(\"all\")\n\n# bilgisayarınızdaki bir klasöre yalnızca belli bir satırın verilerini indirin\nget_data(file = \"linelist_cleaned.rds\")\n\n\n# belirli bir dosyayı bilgisayarınızdaki bir klasöre indirin\nget_data(\"linelist_cleaned.rds\")\n\nİstediğiniz dosyayı bilgisayarınıza kaydetmek için get_data()yı kullandıktan sonra, yine de onu R’a aktarmanız gerekecektir. Ayrıntılar için İçe ve dışa aktar sayfasına bakabilirsiniz.\nDilerseniz bu el kitabında kullanılan tüm verileri Github sayfamızın “data” klasöründe inceleyebilirsiniz.\n\n\nTek tek indirme\nBu seçenek, dosyaya özel bir bağlantı veya R komutu aracılığıyla Github sayfamızdan dosyaları sırasıyla indirmeyi içermektedir. Bazı dosya türleri indirme düğmesine izin verirken, diğerleri bir R komutuyla indirilebilir.\n\nVaka satır listesi\nAşağıdaki linkler, outbreaks paketindeki ebola_sim uygulama veri kümesinde yer alan kitabın ekibi tarafından genişletilen kurgusal bir Ebola salgına aittir.\n\n“Ham” satır listesini indirmek için tıklayın (.xlsx). “Ham” vaka satır listesi, dağınık veriler içeren bir excel tablosudur. Verileri temizleme ve temel işlevler sayfasını takip etmek için bunu kullanabilirsiniz.\n“Temiz” satır listesini indirmek için tıklayın (.rds). Bu el kitabının satır listesini kullanan diğer tüm sayfaları için bu dosyayı kullanabilirsiniz. Rds dosyası, sütun sınıflarını koruyan R’a özgü bir dosya türüdür. Bu, verileri R’a aktardıktan sonra temizlik yapma ihtiyacını azaltır.\n\nDiğer dosyalar:\n\n“Temiz” satır listesini Excel dosyası olarak indirmek için tıklayın\nTemizleme sayfasının bir kısmı bir “temizleme sözlüğü” (.csv dosyası) kullanır. Aşağıdaki komutları çalıştırarak doğrudan R’a yükleyebilirsiniz:\n\n\npacman::p_load(rio) # rio paketini kurun/yükleyin\n\n# dosyayı doğrudan Github'dan içe aktarın\ncleaning_dict &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/cleaning_dict.csv\")\n\n\n\nSıtma sayısı verileri\nBu veriler, yaş grubu, tesis ve güne göre sıtma vakalarının kurgusal sayılarıdır. Rds dosyası, sütun sınıflarını koruyan R’a özgü bir dosya türüdür. Bu, verileri R’a aktardıktan sonra temizlik yapma ihtiyacını azaltır.\n Sıtma sayılarını (.rds dosyası) indirmek için tıklayın. \n\n\nLikert ölçekli veri\nBunlar, Demografik Piramitler ve Likert Ölçekleri sayfasında kullanılan likert tarzı bir anketten alınan kurgusal verilerdir. Aşağıdaki komutları çalıştırarak bu verileri doğrudan R’a yükleyebilirsiniz:\n\npacman::p_load(rio) # rio paketini kurun/yükleyin\n\n# dosyayı doğrudan Github'dan içe aktarın\nlikert_data &lt;- import(\"https://raw.githubusercontent.com/nsbatra/Epi_R_handbook/master/data/likert_data.csv\")\n\n\n\nEsnek pano\nAşağıda R Markdown ile Kontrol Panelleri’ndeki sayfayla ilişkili dosyaya bağlantılar verilmiştir:\n\nSalgın panosu ile ilgili R Markdown’ı indirmek için linke sağ fare tuşuyla tıklayın (Mac için Cmd + tıkla) ve “Farklı Kaydet” seçeneğini seçin.\n\nHTML kontrol panelini indirmek için linke sağ fare tuşuyla tıklayın (Mac için Cmd + tıkla) ve “Farklı Kaydet” seçeneğini seçin.\n\n\n\nTemaslı İzleme\nTemaslı İzleme sayfası, aşağıdaki örnek verileri kullanarak kişi izleme verilerinin analizini göstermektedir. Go.Data. Sayfada kullanılan veriler aşağıdaki linklere tıklanarak .rds dosyaları olarak indirilebilir:\n Vaka inceleme verilerini (.rds dosyası) indirmek için tıklayın. \n Temaslı kayıt verilerini (.rds dosyası) indirmek için tıklayın. \n Temaslı takip verilerini (.rds dosyası) indirmek için tıklayın. \nNOT: Diğer yazılımlarda (örn. KoBo, DHIS2 Tracker, CommCare) yapılandırılmış temaslı izleme verileri farklı görünebilir. Bu sayfa için alternatif örnek veri veya içeriğe katkıda bulunmak isterseniz lütfen bize ulaşın.\nİPUCU: Go.Data kullanmak istiyorsanız ve örneklerinizin API’sine bağlanmak istiyorsanız, İçe ve Dışa Aktarma sayfasına (API bölümü) ve Go.Data Uygulama Topluluğu’na bakabilirsiniz.\n\n\nGIS\nŞekil dosyaları, her biri farklı uzantıya sahip birçok alt bileşen dosyasına sahiptir. Bir dosya “.shp” uzantısına sahipken, bir diğeri “.dbf”, “.prj” vb. uzantıya sahip olabilir.\nGIS temel bilgileri sayfası, sıkıştırılmış şekil dosyalarını indirebileceğiniz Humanitarian Data Exchange web sitesine ait bağlantıları barındırmaktadır.\nÖrneğin sağlık tesisi puan verileri buradan indirilebilir. “hotosm_sierra_leone_health_facilities_points_shp.zip” dosyasını indirin. Bilgisayarınıza kaydettikten sonra, klasörü “açın”. Farklı uzantılara sahip birkaç dosya göreceksiniz (örneğin “.shp”, “.prj”, “.shx”) - bunların tümü bilgisayarınızda aynı klasöre kaydedilmelidir. Ardından, R’a aktarmak için “.shp” dosyasının dosya yolunu ve adını sf paketinden st_read() fonksiyonuna ekleyin (GIS temel bilgileri sayfasında açıklandığı gibi)\nTüm örnek verileri indirmek için Seçenek 1’i izlediyseniz (R paketimiz epirhandbook aracılığıyla), şekil dosyalarının tamamı içeride olacaktır.\nAlternatif olarak, şekil dosyalarını Github sayfamızdaki “data” klasöründen indirebilirsiniz (“gis” alt klasörüne bakın). Ancak, her bir alt dosyayı ayrı ayrı bilgisayarınıza indirmeniz gerekeceğini unutmayın. Github’da her bir dosyaya tek tek tıklayın ve “İndir” butonuna basarak indirin. Aşağıda örnek olarak, “sle_adm3” şekil dosyasının Github bölümünde kayıtlı birçok alt dosyadan oluştuğunu görebilirsiniz.\n\n\n\n\n\n\n\n\n\n\n\nFilogenetik ağaçlar\nFilogenetik ağaçlar sayfayasında, 299 Shigella sonnei örneğinin tüm genom dizilimi ve buna karşılık gelen vaka verilerinden (bir metin dosyası halinde) oluşturulan filogenetik ağacı Newick dosyası göreceksiniz. Belçika örneklerinden elde edilen veriler, ECDC EUPHEM asistanı tarafından yürütülen bir proje kapsamında üretilmiştir. Salmonella ve Shigella’dan elde edilen bu veriler Belçika NRC’si tarafından sağlanmaktadır.Bu veriler yayına dönüştürülme aşamasındadır. Kullanılan uluslararası veriler kamuya açık veri tabanlarına (ncbi) kayıtlı ve yayınlanmış verilerden elde edilmiştir.\n\n“Shigella_tree.txt” filogenetik ağaç dosyasını indirmek için linke sağ fare tuşuyla tıklayın (Mac için Cmd + tıkla) ve “Farklı Kaydet” seçeneğini seçin.\n\nHer örnekle ilgili ek bilgiler içeren “sample_data_Shigella_tree.csv” dosyasını indirmek için linke sağ fare tuşuyla tıklayın (Mac için Cmd + tıkla) ve “Farklı Kaydet” seçeneğini seçin.\n\nYeni oluşturulan altküme ağacını görmek için linke sağ fare tuşuyla tıklayın (Mac için Cmd + tıkla) ve “Farklı Kaydet” seçeneğini seçin.\n\nDaha sonra sayfada açıklandığı gibi ape paketinden read.tree() ile .txt dosyalarını içe aktarabilirsiniz.\n\nape::read.tree(\"Shigella_tree.txt\")\n\n\n\nStandardizasyon\nStandartlaştırılmış oranlar ile ilgili sayfaya bakın. Verileri doğrudan internetteki Github sayfamızdan aşağıdaki komutlarla R oturumunuza yükleyebilirsiniz:\n\n# rio paketini kurun/yükleyin\npacman::p_load(rio) \n\n##############\n# A Ülkesi\n##############\n# A ülkesi için demografi bilgilerini Github'dan içeri aktarın\nA_demo &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics.csv\")\n\n# A ülkesi için ölüm bilgilerini Github'dan içeri aktarın\nA_deaths &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryA.csv\")\n\n##############\n# B Ülkesi\n##############\n# B ülkesi için demografi bilgilerini Github'dan içeri aktarın\nB_demo &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics_2.csv\")\n\n# B ülkesi için ölüm bilgilerini Github'dan içeri aktarın\nB_deaths &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryB.csv\")\n\n\n###############\n# Referans\n###############\n# Referans demografik bilgileri Github'dan içeri aktarın\nstandard_pop_data &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/world_standard_population_by_sex.csv\")\n\n\n\nZaman serileri ve salgın tespiti\nZaman serisi ve salgın tespiti sayfasında Almanya 2002-2011’de rapor edilen Campylobacter vakalarını surveillance R paketinde olduğu gibi kullanıyoruz. (ek bilgi: bu veri seti orijinalinden uyarlanmıştır, 2011’in son 3 aylık verileri demo amacıyla silinmiştir)\n Almanya Campylobacter verilerini (.xlsx)  indirmek için tıklayın. \nKitapta ayrıca Almanya 2002-2011 iklim verilerini kullanıyoruz (santigrat derece cinsinden sıcaklık ve milimetre cinsinden yağış bilgileri mevcut). Bu veriler, ecmwfr paketi kullanılarak EU Copernicus uydu yeniden analiz veri setinden indirilmiştir. Bunların hepsini indirmeniz ve zaman serisi sayfasında açıklandığı gibi stars::read_stars() ile içe aktarmanız gerekecektir.\n Almanya Hava Durumu 2002 verilerini(.nc dosyası)  indirmek için tıklayın. \n Almanya Hava Durumu 2003 verilerini (.nc dosyası)  indirmek için tıklayın. \n Almanya Hava Durumu 2004 verilerini (.nc dosyası)  indirmek için tıklayın. \n Almanya Hava Durumu 2005 verilerini (.nc dosyası)  indirmek için tıklayın. \n Almanya Hava Durumu 2006 verilerini (.nc dosyası)  indirmek için tıklayın. \n Almanya Hava Durumu 2007 verilerini (.nc dosyası)  indirmek için tıklayın. \n Almanya Hava Durumu 2008 verilerini (.nc dosyası)  indirmek için tıklayın. \n Almanya Hava Durumu 2009 verilerini (.nc dosyası)  indirmek için tıklayın. \n Almanya Hava Durumu 2010 verilerini (.nc dosyası)  indirmek için tıklayın. \n Almanya Hava Durumu 2011 verilerini (.nc dosyası)  indirmek için tıklayın. \n\n\nAnket analizi\nAnket analizi sayfası için MSF OCA anket şablonlarına dayalı kurgusal ölüm anketi verilerini kullandık. Bu kurgusal veriler “R4Epis” projesi kapsamında oluşturulmuştur.\n Kurgusal anket verilerini (.xlsx)  indirmek için tıklayın. \n Kurgusal anket veri sözlüğünü (.xlsx)  indirmek için tıklayın. \n Kurgusal anket nüfus verilerini (.xlsx)  indirmek için tıklayın. \n\n\nShiny\nShiny Gösterge Tabloları ile ilgili sayfa, sıtma verilerini görüntülemek için uygulamanın yapısını göstermektedir.\nShiny uygulamasını oluşturan R dosyalarını indirmek için:\nShiny uygulaması için hem kullanıcı arayüzünü hem de sunucu kodunu içeren app.R dosyasını indirmek için burayı tıklayabilirsiniz.\nShiny uygulaması için sıtma verilerini içeren property_count_data.rds dosyasını indirmek için burayı tıklayabilirsiniz. here() fonksiyonunun doğru çalışması için onu bir “data” klasöründe saklamayı unutmayın.\nSayfada açıklandığı gibi, uygulama açılmadan önce çalışması gereken global.R dosyasını indirmek için burayı tıklayabilirsiniz. Sayfada açıklandığı gibi, uygulama açılmadan önce çalıştırmayı unutmayın.\nglobal.R tarafından sağlanan plot_epicurve.R dosyasını indirmek için burayı tıklayabilirsiniz. here() fonksiyonlarının doğru çalışması için onu bir “funcs” klasöründe saklamayı unutmayın.",
    "crumbs": [
      "Bu kitap hakkında",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>El Kitabı ve verileri indirme</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.tr.html",
    "href": "new_pages/basics.tr.html",
    "title": "3  R’ın Temelleri",
    "section": "",
    "text": "3.1 Neden R Kullanıyoruz?\nR proje web sitesinde belirtildiği gibi, R, istatistiksel hesaplama ve grafikler için bir programlama dili ve ortamıdır. Çok yönlü, genişletilebilir ve topluluk odaklıdır.\nMaliyet\nR’ın kullanımı ücretsizdir! Açık kaynak ve ücretsiz olması yönünde topluluğun ciddi bir etik duruşu vardır.\nYeniden üretilebilirlik\nVeri yönetiminizi ve analizinizi bir programlama dili aracılığıyla yürütmek (Excel’e veya başka bir öncelikli tıklama/manuel araçla karşılaştırıldığında), tekrarlanabilirliği artırır, hata algılamayı kolaylaştırır ve iş yükünüzü hafifletir.\nTopluluk\nR kullanıcı topluluğu kalabalık ve işbirlikçidir. Gerçek hayattaki sorunları ele almak için yeni paketler ve araçlar günlük olarak geliştirilir ve kullanıcı topluluğu tarafından incelenir. Örnek olarak, R-Ladies, amacı R topluluğunda cinsiyet çeşitliliğini teşvik etmek olan dünya çapında bir kuruluştur ve R kullanıcılarının en büyük kuruluşlarından biridir. Muhtemelen kullanmak üzere olduğunuz bir bölümleri vardır!",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R'ın Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.tr.html#anahtar-kelimeler",
    "href": "new_pages/basics.tr.html#anahtar-kelimeler",
    "title": "3  R’ın Temelleri",
    "section": "3.2 Anahtar Kelimeler",
    "text": "3.2 Anahtar Kelimeler\nRStudio - RStudio, R’ın daha kolay kullanımı için bir Grafik Kullanıcı Arayüzüdür (GUI). Daha fazlasını RStudio bölümünde okuyabilirsiniz.\nObjects - R’da sakladığınız her şey - veri kümeleri, değişkenler, köy adlarının bir listesi, toplam nüfus sayısı, hatta grafikler gibi çıktılar - bir isim atanan nesnelerdir ve sonraki komutlarda başvurulabilir. Daha fazlasını Nesneler bölümünde okuyabilirsiniz.\nFunctions - Fonksiyon, girdileri kabul eden ve çıktıya dönüştüren bir kod işlemidir. Daha fazlasını Fonksiyonlar bölümünde okuyabilirsiniz.\nPackages - R paketi, aslında paylaşılabilir fonksiyonlar paketidir. Daha fazlasını Paketler bölümünde okuyabilirsiniz.\nScripts - Komut dosyası, komutlarınızı tutan belge dosyasıdır. Daha fazlasını Komut Dosyaları bölümünde okuyabilirsiniz.",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R'ın Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.tr.html#learning",
    "href": "new_pages/basics.tr.html#learning",
    "title": "3  R’ın Temelleri",
    "section": "3.3 Öğrenme Kaynakları",
    "text": "3.3 Öğrenme Kaynakları\n\nRStudio İçindeki Kaynaklar\nYardım dosyaları\nR paketleri ve belirli fonksiyonlarla ilgili belgeler için RStudio “Yardım” sekmesini arayın. Bu, Dosyaları, Grafikleri ve Paketleri de içeren bölmenin içindedir (genellikle sağ alt bölmededir). Kısayol olarak, ilgili Yardım sayfasını açmak için bir soru işaretinden sonra R konsoluna bir paketin veya fonksiyonun adını da yazabilirsiniz. Kesme işareti eklemeyin.\nÖrneğin: ?filter veya ?diagrammeR.\nEtkileşimli öğreticiler\nRStudio içinde etkileşimli olarak R öğrenmenin birkaç yolu vardır.\nRStudio’nun kendisi, learnr R paketi tarafından desteklenen bir eğitim bölmesi sunar. Basitçe bu paketi kurabilir ve sağ üst RStudio bölmesindeki (Ortam ve Geçmiş sekmelerini de içeren) yeni “Tutorial” sekmesi aracılığıyla bir öğretici açabilirsiniz.\nR paketi swirl, R Konsolunda etkileşimli kurslar sunar. Bu paketi kurun ve yükleyin, ardından R konsolunda swirl() (boş parantezler) komutunu çalıştırın. Konsolda istemlerin göründüğünü göreceksiniz. Konsola yazarak yanıt verin. Seçtiğiniz bir kurs boyunca size rehberlik edecektir.\n\n\nKopya Kağıtları\nRStudio web sitesinde birçok PDF “kullanımı kolaylaştırıcı belge/ kopya kağıtları” bulunmaktadır, örneğin:\n\nforcats paketini içeren faktörler\n\nlubridate paketi ile tarihler ve saatler\n\nstringr paketi içeren dizeler\n\npurrr paketi ile tekrarlanan işlemler\n\niçeri_veri_aktar\n\ndplyr paketi ile veri dönüştürme hile sayfası\n\nR Markdown (PDF, Word, Powerpoint… gibi belgeler oluşturmak için)\n\nShiny (etkileşimli web uygulamaları oluşturmak için)\n\nggplot2 paketi ile veri görselleştirme\n\nHaritacılık (GIS)\n\nbroşür paketi (etkileşimli haritalar)\n\nR ile Python (reticulate paketi)\n\nBu, özellikle Excel kullanıcıları için çevrimiçi bir R kaynağıdır.\n\n\nTwitter\n\n\nBizi Takip Edin! @epiRhandbook\n\nR Function A Day @rfuntionaday muazzam bir kaynak\n\nR for Data Science @rstats4ds\n\nRStudio @RStudio\n\nRStudio Tips @rstudiotips\n\nR-Bloggers @Rbloggers\n\nR-ladies @RLadiesGlobal\n\nHadley Wickham @hadleywickham\n\nAynı zamanda:\n#epitwitter ve #rstats\n\n\nÜcretsiz Çevrimiçi Kaynaklar\nTanımlayıcı bir metin, Garrett Grolemund ve Hadley Wickham’ın Veri Bilimi için R kitabı.\nR4Epis Proje web sitesi “bir MSF acil müdahale ortamında yürütülecek yaygın salgın türlerini ve nüfusa dayalı anketleri kapsayacak şekilde standartlaştırılmış veri temizleme, analiz ve raporlama araçları geliştirmeyi” amaçlamaktadır. R temel eğitim materyallerini, salgınlar ve anketlerle ilgili RMarkdown raporları için şablonları ve bunları ayarlamanıza yardımcı olacak öğreticileri bulabilirsiniz.\n\n\nİngilizce dışındaki dillerde\nMateriales de RStudio en Español\nIntroduction à R et au tidyverse (Francais)",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R'ın Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.tr.html#kurulum",
    "href": "new_pages/basics.tr.html#kurulum",
    "title": "3  R’ın Temelleri",
    "section": "3.4 Kurulum",
    "text": "3.4 Kurulum\n\nR ve RStudio\nR Nasıl Kurulur?\nBu web sitesini https://www.r-project.org/ ziyaret edin ve bilgisayarınıza uygun en son R sürümünü indirin.\nRStudio nasıl kurulur?\nBu web sitesini https://rstudio.com/products/rstudio/download/ ziyaret edin ve bilgisayarınıza uygun RStudio’nun en son ücretsiz masaüstü sürümünü indirin.\nİzinler\n\nR ve RStudio’yu okuma ve yazma izinlerine sahip olduğunuz bir sürücüye kurmanız gerektiğini unutmayın. Aksi takdirde, R paketlerini kurma yeteneğiniz (sık rastlanan bir durum) etkilenecektir. Sorunlarla karşılaşırsanız, simgeye sağ tıklayıp “Yönetici olarak çalıştır”ı seçerek RStudio’yu açmayı deneyin. Diğer ipuçları Ağ sürücülerinde R sayfasında bulunabilir.\nR ve RStudio nasıl güncellenir?\nR sürümünüz, başlangıçta R Konsoluna yazdırılır. Ayrıca sessionInfo() komutunu da çalıştırabilirsiniz.\nR’ı güncellemek için yukarıda belirtilen web sitesine gidin ve R’ı yeniden yükleyin. Alternatif olarak, installr paketini (Windows’ta) installr::updateR() çalıştırarak kullanabilirsiniz. Bu, en son R sürümünü indirmenize ve paketlerinizi yeni R sürümüne güncellemenize yardımcı olacak iletişim kutularını açacaktır. Daha fazla ayrıntıyı installr belgelerde bulabilirsiniz.\nEski R sürümünün bilgisayarınızda hala var olacağını unutmayın. RStudio’da “Araçlar” -&gt; “Global Seçenekler”e tıklayarak ve bir R sürümü seçerek R’ın daha eski bir sürümünü (eski “kurulum”) geçici olarak çalıştırabilirsiniz. Bu, R’ın en yeni sürümü üzerinde çalışacak şekilde güncellenmemiş bir paket kullanmak istiyorsanız yararlı olabilir.\nRStudio’yu güncellemek için yukarıdaki web sitesine gidebilir ve RStudio’yu yeniden indirebilirsiniz. Başka bir seçenek de RStudio içinde “Yardım” -&gt; “Güncellemeleri Kontrol Et” seçeneğine tıklamaktır. Ancak bu en son güncellemeleri göstermeyebilir.\nBu El Kitabı hazırlanırken hangi R, RStudio veya paket sürümlerinin kullanıldığını görmek için Editoryal ve teknik notlar sayfasına bakın.\n\n\nKurulumuna ihtiyaç duyabileceğiniz diğer yazılımlar\n\nTinyTeX (bir RMarkdown belgesini PDF’ye derlemek için)\n\nPandoc (RMarkdown belgelerini derlemek için)\n\nRTools (R için paketler oluşturmak için)\n\nphantomjs (iletim zincirleri gibi hareketli ağların hareketsiz görüntülerini kaydetmek için)\n\n\nTinyTex\nTinyTex, özel bir LaTeX dağıtımıdır ve R’dan PDF’ler üretmeye çalışırken kullanışlıdır.\nDaha fazla bilgi için https://yihui.org/tinytex/ adresine bakın.\nTinyTex’i R’dan yüklemek için:\n\ninstall.packages('tinytex')\ntinytex::install_tinytex()\n# TinyTeX'i kaldırmak için, run tinytex::uninstall_tinytex()\n\n\n\nPandoc\nPandoc, R’dan ayrı bir yazılım olan belge dönüştürücüdür. RStudio ile birlikte gelir ve indirilmesi gerekmez. Rmarkdown belgelerini .pdf gibi biçimlere dönüştürme ve karmaşık fonksiyonlar ekleme sürecine yardımcı olur.\n\n\nRTools\nRTools, R için paketler oluşturmaya yönelik bir yazılım koleksiyonudur.\nBu internet sayfasından yükleyebilirsiniz: https://cran.r-project.org/bin/windows/Rtools/\n\n\nphantomjs\nBu genellikle web sayfalarının “ekran görüntülerini” almak için kullanılır. Örneğin epicontacts paketi ile bir iletim zinciri yaptığınızda interaktif ve dinamik bir HTML dosyası üretilir. Statik bir görüntü istiyorsanız, bu işlemi otomatikleştirmek için webshot paketini kullanmak faydalı olabilir. Bu, harici “phantomjs” programını gerektirecektir. phantomjs’yi webshot paketi aracılığıyla webshot::install_phantomjs() komutuyla kurabilirsiniz.",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R'ın Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.tr.html#rstudio",
    "href": "new_pages/basics.tr.html#rstudio",
    "title": "3  R’ın Temelleri",
    "section": "3.5 RStudio",
    "text": "3.5 RStudio\n\nRStudio Yönlendirmesi\nÖncelikle RStudio’yu açın. Simgeleri çok benzer görünebileceğinden, R’ı değil RStudio’yu açtığınızdan emin olun.\nRStudio’nun çalışması için bilgisayarda R’ın da kurulu olması gerekir (kurulum talimatları için yukarıya bakın).\nRStudio, R’ın daha kolay kullanımı için bir arayüzdür (GUI). R’ı kritik işi yapan aracın motoru ve RStudio’yu, ilerlemek için motoru gerçekten kullanmanıza yardımcı olan aracın gövdesi (koltuklar, aksesuarlar vb. ile) olarak düşünebilirsiniz! Tam RStudio kullanıcı arayüzünü kolaylaştırıcısını (PDF) buradan görebilirsiniz.\nVarsayılan olarak RStudio dört dikdörtgen bölme görüntüler.\n\n\n\n\n\n\n\n\n\nİPUCU: RStudio’nuz yalnızca bir sol bölme gösteriyorsa, bunun nedeni henüz açık komut dosyanız olmamasıdır.\nKaynak Bölmesi\n\nVarsayılan olarak sol üstteki bu bölme, komut dosyalarınızı düzenlemek, çalıştırmak ve kaydetmek için kullanılan bir alandır. Komut dosyaları, çalıştırmak istediğiniz komutları içerir. Bu bölme, görüntüleme için veri kümelerini/çerçevelerini (datasets/data frames) de görüntüleyebilir.\nStata kullanıcıları için bu bölme, Do-file ve Data Editor pencerelerinize benzer.\nR Konsol Bölmesi\nVarsayılan olarak R Studio’daki sol veya sol alt bölme olan R Konsolu, R “motorunun” evidir. Burası komutların fiilen çalıştırıldığı ve grafik olmayan çıktıların ve hata/uyarı mesajlarının göründüğü yerdir. Komutları doğrudan R Konsoluna girebilir ve çalıştırabilirsiniz. Ancak bu komutların bir komut dosyasından komut çalıştırırken olduğu gibi kaydedilmediğine dikkat ediniz.\nStata’ya aşina iseniz, R Konsolu komut penceresi “Sonuçlar” penceresi gibidir.\nOrtam Bölmesi\n\nVarsayılan olarak sağ üstte bulunan bu bölme, çoğunlukla mevcut oturumda R Ortamındaki nesnelerin kısa özetlerini görmek için kullanılır. Bu nesneler, içe aktarılan, değiştirilen veya oluşturulan veri kümelerini, tanımladığınız parametreleri (örneğin, analiz için belirli bir epi haftası) veya analiz sırasında tanımladığınız vektörleri veya listeleri (örneğin, bölgelerin adları) içerebilir. Değişkenlerini görmek için bir veri kümesi adının yanındaki oka tıklayabilirsiniz.\n\nStata’da, bu en çok Değişkenler Yöneticisi penceresine benzer.\nBu bölme ayrıca daha önceki komutları görebileceğiniz Geçmişi içerir. Ayrıca, learnr paketini yüklediyseniz etkileşimli R eğitimlerini tamamlayabileceğiniz bir “Öğretici” sekmesine de sahiptir. Ayrıca harici bağlantılar için bir “Bağlantılar” bölmesine sahiptir ve Github ile arabirim kurmayı seçerseniz bir “Git” bölmesine sahip olabilir.\nGrafikler, Görüntüleyici, Paketler ve Yardım Bölmesi\n\nSağ alt bölmede birkaç önemli sekme bulunur. Haritalar dahil tipik çizim grafikleri, Çizim bölmesinde görüntülenecektir. Etkileşimli veya HTML çıktıları, Görüntüleyici bölmesinde görüntülenecektir. Yardım bölmesi, belgeleri ve yardım dosyalarını görüntüleyebilir. Dosyalar bölmesi, dosyaları açmak veya silmek için kullanılabilen bir tarayıcıdır. Paketler bölmesi, R paketlerini görmenize, yüklemenize, güncellemenize, silmenize ve paketin hangi sürümüne sahip olduğunuzu görmenize olanak tanır. Paketler hakkında daha fazla bilgi edinmek için aşağıdaki paketler bölümüne bakın.\nBu bölme, Plots Manager ve Project Manager pencerelerinin Stata eşdeğerlerini içerir.\n\n\n3.5.1 RStudio ayarları\nTools açılır menüsünde Global Options’ı seçerek RStudio ayarlarını ve görünümünü değiştirin. Orada görünüm/arka plan rengi dahil varsayılan ayarları değiştirebilirsiniz.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTekrar başlat\nR’ınız donarsa, Oturum menüsüne gidip “R’ı Yeniden Başlat” ı tıklayarak R’ı yeniden başlatabilirsiniz. Bu, RStudio’yu kapatıp açma zahmetini ortadan kaldırır. Bunu yaptığınızda R ortamınızdaki her şey kaldırılacaktır.\n\n\nKlavye kısayolları\nBazı çok kullanışlı klavye kısayolları aşağıdadır. Bu RStudio’nun ikinci sayfasında Windows, Mac ve Linux için tüm klavye kısayollarına ulaşabilirsiniz kullanıcı arayüzü kolaylaştırıcısı. \n\n\n\n\n\n\n\n\n\n4 Windows/Linux\nEsc\n5 Mac\nEsc\nEylemi | ================================================================================================================================+ Geçerli komutu kesintiye uğratın (yanlışlıkla eksik bir komut çalıştırdıysanız ve R konsolunda “+” görmekten kurtulamıyorsanız kullanışlıdır)\n\n\n\n\nCtrl+s\nCmd+s\nKaydet (komut dosyası) |\n\n\nTab\nTab\nOtomatik tamamlama |\n\n\nCtrl + Enter\nCmd + Enter\nGeçerli satırları/kod seçimini çalıştır |\n\n\nCtrl + Shift + C\nCmd + Shift + c\nVurgulanan satırları yorumla/yorumu kaldır |\n\n\nAlt + -\nOption + -\nEklemek &lt;- |\n\n\nCtrl + Shift + m\nCmd + Shift + m\nEklemek %&gt;% |\n\n\nCtrl + l\nCmd + l\nR konsolunu temizle\n\n\n\nCtrl + Alt + b\nCmd + Option + b\nBaştan geçerli satıra çalıştır\n\n\n\nCtrl + Alt + t\nCmd + Option + t\nGeçerli kod bölümünü çalıştırın (R Markdown) |\n\n\nCtrl + Alt + i\nCmd + Shift + r\nKod öbeği ekle (R Markdown’a) |\n\n\nCtrl + Alt + c\nCmd + Option + c\nGeçerli kod parçasını çalıştır (R Markdown) |\n\n\nYukarı/aşağı ok tuşları\nAynı\nSon çalıştırılan komutlar arasında geçiş yap |\n\n\nShift + Yukarı/aşağı ok tuşları\nAynı\nBirden çok kod satırı seçin |\n\n\nCtrl + f\nCmd + f\nGeçerli komut dosyasında bul ve değiştir |\n\n\nCtrl + Shift + f\nCmd + Shift + f\nDosyalarda bulun (birçok komut dosyasında arama yapın/değiştirin) |\n\n\nAlt + l\nCmd + Option + l\nSeçilen kodu katla\n\n\n\nShift + Alt + l\nCmd + Shift + Option+l\nSeçili kodu aç |\n\n\n\nİPUCU: Yazarken RStudio’nun otomatik tamamlama fonksiyonunu etkinleştirmek için Sekme tuşunuzu kullanın. Bu, yazım hatalarını önleyebilir. Şu ana kadar yazdıklarınıza bağlı olarak olası fonksiyonlar ve nesnelerin bir açılır menüsünü oluşturmak için yazarken Sekme tuşuna basın.",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R'ın Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.tr.html#functions",
    "href": "new_pages/basics.tr.html#functions",
    "title": "3  R’ın Temelleri",
    "section": "5.1 Fonksiyonlar”",
    "text": "5.1 Fonksiyonlar”\nFonksiyonlar, R’ı kullanmanın merkezinde yer alır. Fonksiyonlar, görevleri ve işlemleri nasıl gerçekleştirdiğinizdir. Pek çok fonksiyon R ile kurulu olarak gelir, daha pek çoğu paketlerde indirilebilir (paketler bölümünde açıklanmıştır) ve hatta kendi özel Fonksiyonlarınızı bile yazabilirsiniz!\nFonksiyonlarla ilgili bu temel bilgiler bölümü şunları açıklar:\n\nFonksiyon nedir ve nasıl çalışır\n\nFonksiyonun Değişkenleri(arguments) nelerdir\n\nBir fonksiyonu anlamak için nasıl yardım alınır\n\nSözdizimi (syntax) hakkında kısa bir not: Bu el kitabında, fonksiyonlar açık ve kapalı parantezler içinde kod-metin içinde şöyle yazılmıştır: filter(). Paketler bölümünde açıklandığı gibi, Fonksiyonlar paketler içinde indirilir. Bu el kitabında, paket adları dplyr gibi kalın ile yazılmıştır. Bazen örnek kodda, fonksiyon adının, bunun gibi iki adet iki nokta üst üste (::) ile açıkça paketinin adıyla bağlantılı olduğunu görebilirsiniz: dplyr::filter(). Bu bağlantının amacı paketler bölümünde açıklanmıştır.\n\n\nBasit Fonksiyonlar\nBir fonksiyon, girdileri alan, bu girdilerle bazı işlemler yapan ve bir çıktı üreten makine gibidir. Çıktının ne olduğu fonksiyona bağlıdır.\nFonksiyonlar genellikle fonksiyonun parantezleri içine yerleştirilmiş bazı nesneler üzerinde çalışır. Örneğin, sqrt() fonksiyonu bir sayının karekökünü hesaplar:\n\nsqrt(49)\n\n[1] 7\n\n\nBir fonksiyona sağlanan nesne ayrıca veri kümesindeki bir sütun olabilir (tüm nesne türleri hakkında ayrıntılı bilgi için Nesneler bölümüne bakın). R, birden çok veri kümesini depolayabildiğinden, hem veri kümesini hem de sütunu belirtmeniz gerekecektir. Bunu yapmanın bir yolu, veri kümesinin adını ve sütunun adını (“veri kümesi\\(sütun\") bağlamak için \"\\)” gösterimini kullanmaktır. Aşağıdaki örnekte, “summary()” fonksiyonu, “linelist” veri kümesindeki “age” sayısal sütununa uygulanır ve çıktı, sütunun sayısal ve eksik değerlerinin bir özetidir.\n\n# 'linelist' veri kümesindeki 'age' sütununun özet istatistiklerini yazdır\nsummary(linelist$age)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00    6.00   13.00   16.07   23.00   84.00      86 \n\n\nNOT: Perde arkasında, bir fonksiyon, kullanıcı için tek bir kolay komuta sarılmış karmaşık ek kodu temsil eder.\n\n\n\nBirden çok bağımsız değişkene sahip fonksiyonlar\nFonksiyonlar genellikle,parantezleri içinde yer alan ve virgülle ayrılmış olan değişkenler adı verilen birkaç girdi ister.\n\nFonksiyonun doğru çalışması için bazı değişkenler gereklidir, bazıları isteğe bağlıdır\n\nİsteğe bağlı bağımsız değişkenlerin varsayılan ayarları vardır\n\nDeğişkenler karakter, sayısal, mantıksal (DOĞRU/YANLIŞ) ve diğer girdi değerlerini alabilir\n\nTipik bir fonksiyona örnek olarak, ‘oven_bake()’ adlı eğlenceli bir kurgusal fonksiyonu burada bulabilirsiniz. Bir girdi nesnesi (örneğin, bir veri kümesi veya bu örnekte “hamur”) alır ve üzerinde ek bağımsız değişkenler (‘dakikalar =’ ve ‘sıcaklık =’) tarafından belirtildiği gibi işlemler gerçekleştirir. Çıktı konsola yazdırılabilir veya “&lt;-” atama operatörü kullanılarak bir nesne olarak kaydedilebilir.\n\n\n\n\n\n\n\n\n\nDaha gerçekçi bir örnekte, aşağıdaki “age_pyramid()” komutu, tanımlanmış yaş gruplarına ve “cinsiyet” gibi ikili bir bölme sütununa dayalı bir yaş piramidi grafiği oluşturur. Fonksiyona, parantez içinde virgülle ayrılmış üç değişken verilir. Değişkenlere sağlanan değerler, kullanılacak veri çerçevesi olarak “satır listesi”ni, sayılacak sütun olarak “age_cat5”i ve piramidi renge göre bölmek için kullanılacak ikili sütun olarak “gender”i belirler.\n\n# Bir yaş piramidi oluştur\nage_pyramid(data = linelist, age_group = \"age_cat5\", split_by = \"gender\")\n\n\n\n\n\n\n\n\nYukarıdaki komut, her değişken için yeni bir satırla daha uzun bir tarzda aşağıdaki gibi eşdeğer olarak yazılabilir. Bu stilin okunması daha kolay olabilir ve her bölümü açıklamak için “#” ile “yorum” yazmak daha kolay olabilir (kapsamlı yorum yapmak iyi bir uygulamadır!). Bu daha uzun komutu çalıştırmak için tüm komutu vurgulayabilir ve “Çalıştır”a tıklayabilir veya imlecinizi ilk satıra getirip ardından Ctrl ve Enter tuşlarına aynı anda basabilirsiniz.\n\n# Bir yaş piramidi oluştur\nage_pyramid(\n  data = linelist,        # Satır listesini kullan\n  age_group = \"age_cat5\", # Yaş grubu sütununu kullan\n  split_by = \"gender\"     # Piramidin iki tarafı için cinsiyet sütununu kullan\n  )\n\n\n\n\n\n\n\n\nBir bağımsız değişken atamasının ilk yarısının (örneğin, “veri =”), bağımsız değişkenler belirli bir sırada (fonksiyonun belgelerinde belirtilen) yazılmışsa belirtilmesi gerekmez. Aşağıdaki kod, yukarıdakiyle tam olarak aynı piramidi üretir, çünkü fonksiyon değişken sırasını kabul eder: satır listesi, “yaş_grubu” değişkeni, “bölme_göre” değişkeni.\n\n# Bu komut yukarıdaki ile aynı grafiği üretecektir.\nage_pyramid(linelist, \"age_cat5\", \"gender\")\n\nDaha karmaşık bir “age_pyramid()” komutu, aşağıdakilere yönelik isteğe bağlı değişkenleri içerebilir:\n\nSayılar yerine oranları göster (varsayılan “YANLIŞ” olduğunda “orantılı = DOĞRU” olarak ayarlayın)\n\nKullanılacak iki rengi belirtin (pal =, “palet”in kısaltmasıdır ve iki renk adından oluşan bir vektörle sağlanır. ““c()” fonksiyonunun nasıl vektör oluşturduğunu öğrenmek için nesneler sayfasına bakın)\n\nNOT: İki taraflı belirtilecek değişkenler için (ör. orantılı = DOĞRU) değişkenlerin sıraları önemsizdir.\n\nage_pyramid(\n  linelist,                    # Satır listesini kullan\n  \"age_cat5\",                  # Yaş grubu sütununu kullan\n  \"gender\",                    # Cinsiyete göre ayır\n  proportional = TRUE,         # sayı yerine yüzdelik kullan\n  pal = c(\"orange\", \"purple\")  # renkleri turuncu ve mor\n  )\n\n\n\n\n\n\n\n\n\n\n\nFonksiyon Yazma\nR, fonksiyonlara yönelik bir dildir, bu nedenle kendi fonksiyonlarınızı yazmak için yetkilendirilmiş hissetmeniz gerekir. Fonskiyonlar oluşturmak çeşitli avantajlar sağlar:\n\nModüler programlamayı kolaylaştırmak için - kodun bağımsız ve yönetilebilir parçalara ayrılması\n\nHataya açık olabilen tekrarlayan kopyala ve yapıştır işlemlerinin değiştirilmesi\n\nKod parçalarına akılda kalıcı isimler verilmesi\n\nBir fonksiyonun nasıl yazılacağı Fonksiyon Yazma sayfasında derinlemesine ele alınmıştır.",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R'ın Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.tr.html#packages",
    "href": "new_pages/basics.tr.html#packages",
    "title": "3  R’ın Temelleri",
    "section": "5.2 Paketler",
    "text": "5.2 Paketler\nPaketler fonksiyonları içerir.\nBir R paketi, önceden tanımlanmış fonksiyonları içeren, paylaşılabilir bir kod ve belge paketidir. R topluluğundaki kullanıcılar, her zaman belirli sorunlara yönelik paketler geliştirir, muhtemelen size yardımcı olabilecek bir tanesi mevcuttur! R kullanımınızda yüzlerce paket kuracak ve kullanacaksınız.\nKurulum sırasında R, yaygın kullanılan görevleri gerçekleştiren “temel” paketleri ve fonksiyonları içerir. Ancak birçok R kullanıcısı, R topluluğu tarafından doğrulanan ve kendi kullanımınız için bir paket olarak indirebileceğiniz özel fonksiyonlar oluşturur. Bu el kitabında paket adları kalın ile yazılmıştır. R’ın daha zorlu yönlerinden biri, belirli bir görevi tamamlamak için seçilebilecek çok sayıda farklı fonksiyon veya paketin olmasıdır.\n\nKurulum ve Yükleme\nFonksiyonlar, internetten bilgisayarınıza indirebileceğiniz (“kurulu”) paketler içerisinde yer almaktadır. Bir paket indirildiğinde, “kütüphanenizde” saklanır. Ardından, paketi “yükleyerek” mevcut R oturumunuz sırasında içerdiği fonksiyonlara erişebilirsiniz.\nR’ı kişisel kitaplığınız olarak düşünün: Bir paket indirdiğinizde, kütüphaneniz yeni bir fonksiyon kitabı kazanır, ancak o kitaptaki bir fonksiyonu her kullanmak istediğinizde, kütüphanenizden o kitabı ödünç almanız (“yüklemeniz”) gerekir.\nÖzetle: bir R paketinde bulunan fonksiyonları kullanmak için 2 adım uygulanmalıdır:\n\nPaket (bir defaya mahsus) kurulmalı, ve\n\nPaket (her R oturumu sırasında) yüklenmeli\n\n\nSenin Kütüphanen\n“Senin kütüphanen” aslında bilgisayarınızda kurulu olan her paket için içerisinde farklı bir dosya oluşturulan bir klasördür. Bilgisayarınızda R’ın nerede kurulu olduğunu bulun ve “win-library” adlı bir klasör arayın. Örneğin: R\\win-library\\4.0 (4.0, R sürümüdür - indirdiğiniz her R sürümü için farklı bir kitaplığınız olacaktır).\n.libPaths() (boş parantezler) girerek kitaplığınızın dosya yolunu yazdırabilirsiniz. Ağ sürücülerinde R ile çalışırken bu özellikle önemlidir.\n\n\nCRAN ’dan Kurulum\nÇoğu zaman, R kullanıcıları paketleri CRAN’dan indirir. CRAN (Comprehensive R Archive Network - Kapsamlı R Arşiv Ağı), topluluk üyeleri tarafından yayınlanan R paketlerinin çevrimiçi genel deposudur.\nCRAN’dan bir paket indirirken virüsler ve güvenlik konusunda endişeleniyor musunuz? Konuyla ilgili bu makaleyi okuyabilirsiniz.\n\n\nNasıl kurulum yapar ve yüklerim?\nBu el kitabında, pacman paketini (“paket yöneticisi” kısaltması) kullanmanızı öneririz. Gerekirse bir paketi kuracak ve mevcut R oturumunda kullanmak üzere yükleyecek uygun bir p_load() fonksiyonu sunar.\nSözdizimi oldukça basit. Paketlerin adlarını ‘p_load()’ parantezleri içinde virgülle ayırarak listeleyin. Bu komut, henüz kurulmamışlarsa rio, tidyverse ve here paketlerini kuracak ve bunları kullanım için yükleyecektir. Bu, komut dosyalarını başkalarıyla paylaşırken p_load() yaklaşımını kullanışlı ve özlü hale getirir. Paket adlarının büyük/küçük harfe duyarlı olduğunu unutmayın.\n\n# Paketleri kurup yükleyebilirsiniz.(Gerekli görürseniz)\npacman::p_load(rio, tidyverse, here)\n\nPaket adını (pacman) fonksiyon adından (p_load()) önce açıkça yazan pacman::p_load() sözdizimini kullandığımızı ve iki adet iki nokta üst üste :: ile bağlandığını unutmayın. Bu sözdizimi, pacman paketini de yüklediği için kullanışlıdır (zaten kurulu olduğu varsayılarak).\nSıklıkla göreceğiniz alternatif temel R fonksiyonları vardır. Bir paketi kurmak için temel R fonksiyonu install.packages() fonksiyonudur. Kurulacak paketin adı parantez içinde tırnak içinde belirtilmelidir. Bir komutta birden çok paket kurmak istiyorsanız, bunlar bir c() karakter vektörü içinde listelenmelidir.\nNot: Bu komut bir paketi kurar, ancak geçerli oturumda kullanmak için yüklemez.\n\n# Temel R için bir paketin kurulumu\ninstall.packages(\"tidyverse\")\n\n# Temel R için çoklu paketlerin kurulumu\ninstall.packages(c(\"tidyverse\", \"rio\", \"here\"))\n\nKurulum ayrıca, RStudio “Paketler” bölmesine gidip istenen paket adını arayarak “Kur” seçeneğine tıklanarak da gerçekleştirilebilir.\nBir paketi kullanmak üzere (kurulduktan sonra) yüklemek için temel R fonksiyonu ’library()’dir. Bir seferde yalnızca bir paket yükleyebilir (p_load() kullanmanın başka bir nedeni). Paket adını tırnak işaretleri ile veya tırnak işaretleri olmadan sağlayabilirsiniz.\n\n# Temel R için paket yüklenmesi\nlibrary(tidyverse)\nlibrary(rio)\nlibrary(here)\n\nBir paketin kurulu ve/veya yüklenmiş olup olmadığını kontrol etmek için RStudio’da Paketler bölmesini görüntüleyebilirsiniz. Paket kurulu ise sürüm numarası ile orada gösterilir. Kutusu işaretliyse, geçerli oturum için yüklenir.\nGithub’dan Kurulum\nBazen, henüz CRAN’da bulunmayan bir paketi yüklemeniz gerekir. Veya belki de paket CRAN’da mevcuttur, ancak daha kararlı yayınlanan CRAN sürümünde henüz sunulmayan yeni özelliklere sahip geliştirme sürümünü istiyorsunuzdur. Bunlar genellikle github.com web sitesinde ücretsiz, halka açık bir kod “deposu” içinde barındırılır. [Git ve Github ile sürüm kontrolü ve işbirliği] El kitabı sayfasından Github hakkında daha fazla bilgi edinebilirsiniz.\nGithub’dan R paketlerini indirmek için, gerekirse paketi kuracak ve mevcut R oturumunuzda kullanmak üzere yükleyecek olan pacman’dan p_load_gh() fonksiyonunu kullanabilirsiniz. Kurulum alternatifleri arasında remotes veya devtools paketlerinin kullanılması yer alır. Paket belgelerinde tüm pacman fonksiyonları hakkında daha fazla bilgi edinin.\nGithub’dan yüklemek için daha fazla bilgi sağlamanız gerekir. Şunları sağlamalısın:\n\nDepo sahibinin Github kimliği\nPaketi içeren havuzun adı\n\n(isteğe bağlı) İndirmek istediğiniz “dalın” (özel geliştirme sürümü) adı\n\nAşağıdaki örneklerde, tırnak içindeki ilk kelime depo sahibinin Github ID’sidir, eğik çizgiden sonra deponun adı (paketin adı) olur.\n\n# Github deposundan epicontacts paketini kur ve yükle.\np_load_gh(\"reconhub/epicontacts\")\n\nAna dal dışında bir “daldan” (sürüm) kurulum yapmak istiyorsanız, dal adını depo adından sonra şu ifade ile birlikte “@” ekleyin.\n\n# Github'dan epicontacts paketinin \"zaman çizelgesi\" dalını kurun\np_load_gh(\"reconhub/epicontacts@timeline\")\n\nGithub sürümü ile bilgisayarınızdaki sürüm arasında herhangi bir fark yoksa herhangi bir işlem yapılmayacaktır. “update = TRUE” değişkeni yerine “p_load_current_gh()” komutu kullanarak yeniden yüklemeyi “zorlayabilirsiniz” (force). Bu [çevrimiçi gösterimde] http://trinker.github.io/pacman/vignettes/Introduction_to_pacman.html adresinde pacman hakkında daha fazla bilgi edinin)\nZIP veya TAR’dan yükleme\nPaketi bir URL’den yükleyebilirsiniz:\n\npackageurl &lt;- \"https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz\"\ninstall.packages(packageurl, repos=NULL, type=\"source\")\n\nVeya sıkıştırılmış bir dosyada bilgisayarınıza indirin:\nSeçenek 1: remotes paketinden install_local() kullanmak\n\nremotes::install_local(\"~/Downloads/dplyr-master.zip\")\n\nSeçenek 2: base R’dan install.packages() komutunu kullanarak, ZIP dosyasının dosya yolunu sağlayarak ve type = \"source ve repos = NULL ayarını yaparak.\n\ninstall.packages(\"~/Downloads/dplyr-master.zip\", repos=NULL, type=\"source\")\n\n\n\n\nKod sözdizimi\nBu el kitabındaki netlik için, fonksiyonlar önüne bazen aşağıdaki şekilde :: sembolü kullanılarak paketlerinin adı gelir: package_name::function_name()\nBir oturum için bir paket yüklendiğinde, belirgin stil gerekli değildir. Sadece function_name() kullanılabilir. Bununla birlikte, bir fonksiyon adı yaygın olduğunda ve birden çok pakette bulunabileceğinde paket adını yazmak yararlıdır (örneğin, plot()). Paket adının yazılması, henüz yüklenmemişse paketi de yükleyecektir.\n\n# Bu komut, bir veri kümesini içe aktarmak için \"rio\" paketini ve \"import()\" fonksiyonunu kullanır.\nlinelist &lt;- rio::import(\"linelist.xlsx\", which = \"Sheet1\")\n\n\n\nFonksiyon yardımı\nBir fonksiyon hakkında daha fazlasını okumak için, sağ alt RStudio’nun Yardım sekmesinde onu arayabilirsiniz. Ayrıca ?fonksiyonadı (fonksiyonun adını bir soru işaretinden sonra koyun) gibi bir komut çalıştırabilirsiniz ve Yardım bölmesinde Yardım sayfası görünecektir. Son olarak, kaynakları çevrimiçi olarak aramayı deneyin.\n\n\nPaketleri güncelleyin\nPaketleri yeniden yükleyerek güncelleyebilirsiniz. Hangi paketlerin kurulacak yeni sürümleri olduğunu görmek için RStudio Paketleri bölmenizdeki yeşil “Güncelle” düğmesini de tıklayabilirsiniz. Bir fonksiyonun nasıl çalıştığına dair büyük bir revizyon varsa, eski kodunuzun güncellenmesi gerekebileceğini unutmayın!\n\n\nPaketleri sil\npacman’den p_delete() veya base R’dan remove.packages() komutlarını kullanabilirsiniz. Alternatif olarak, kitaplığınızı içeren klasörü bulup manuel olarak silebilirsiniz.\n\n\nBağlılıklar\nPaketler genellikle çalışmak için diğer paketlere bağlıdır. Bunlara bağlılıklar (dependencies)denir. Bir bağlılık yüklenemezse, buna bağlı olan paket de yüklenemeyebilir.\np_depends() ile bir paketin bağlılıklarını görün ve p_depends_reverse() ile hangi paketlerin ona bağlı olduğunu görün\n\n\n5.2.1 Maskelenmiş fonksiyonlar\nİki veya daha fazla paketin aynı fonksiyon adını içermesi nadir değildir. Örneğin, dplyr paketinin bir “filter()” fonksiyonu vardır, ancak stats paketinin de fonksiyonu vardır. Varsayılan ‘filter()’ fonksiyonu, bu paketlerin R oturumunda ilk yüklendiği sıraya bağlıdır - sonraki, ‘filter()’ komutu için varsayılan olacaktır.\nSırayı R Studio’nun Ortam bölmesinde kontrol edebilirsiniz - “Global Ortam” açılır menüsünü tıklayın ve paketlerin sırasını görün. Bu açılır listedeki alt paketlerdeki fonksiyonlar, açılır listede daha yukarıda görünen paketlerdeki aynı ada sahip fonksiyonları maskeleyecektir. Bir paketi ilk yüklerken, maskeleme meydana gelirse R sizi konsolda uyarır, ancak bunu gözden kaçırmak kolay olabilir.\n\n\n\n\n\n\n\n\n\nMaskelemeyi düzeltmenin yolları şunlardır:\n\nKomutta paket adını belirtin. Örneğin, dplyr::filter() kodunu kullanın\nPaketlerin yüklenme sırasını yeniden düzenleyin (ör. p_load() içinde) ve yeni bir R oturumu başlatın\n\n\n\nAyır / kaldır\nBir paketi ayırmak (kaldırmak) için, bu komutu doğru paket adı ve yalnızca bir iki nokta üst üste ile kullanın. Bunun maskelemeyi çözmeyebileceğini unutmayın.\n\ndetach(package:PACKAGE_NAME_HERE, unload=TRUE)\n\n\n\nEski sürümü yükleyin\nBelirli bir paketin daha eski bir sürümünü yüklemek için bu kılavuza bakabilirsiniz.\n\n\nÖnerilen paketler\nGünlük epidemiyoloji için önerdiğimiz paketlerin listesi için Önerilen paketler sayfasına bakabilirsiniz.",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R'ın Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.tr.html#scripts",
    "href": "new_pages/basics.tr.html#scripts",
    "title": "3  R’ın Temelleri",
    "section": "5.3 Komut Dosyaları",
    "text": "5.3 Komut Dosyaları\nKomut dosyaları, programlamanın temel bir parçasıdır. Komutlarınızı tutan belgelerdir (örneğin, veri kümeleri oluşturma ve değiştirme fonksiyonları, baskı görselleştirmeleri vb.). Bir komut dosyasını kaydedebilir ve daha sonra yeniden çalıştırabilirsiniz. Komutlarınızı bir komut dosyasında saklamanın ve çalıştırmanın (komutları tek tek R konsolu “komut satırına” yazmaya kıyasla) birçok avantajı vardır:\n\nTaşınabilirlik - çalışmalarınızı komut dosyalarınızı göndererek başkalarıyla paylaşabilirsiniz\n\nTekrarlanabilirlik - böylece siz ve diğerleri tam olarak ne yaptığınızı bilir\n\nSürüm kontrolü - böylece kendiniz veya meslektaşlarınız tarafından yapılan değişiklikleri takip edebilirsiniz\n\nYorumlama/açıklama - meslektaşlarınıza ne yaptığınızı açıklamak için kullanabilirsiniz\n\n\nYorum yapma\nBir komut dosyasında, R kodunuzun etrafına açıklama da (“yorum”) yapabilirsiniz. Yorum yapmak, kendinize ve diğer okuyuculara ne yaptığınızı açıklamanıza yardımcı olur. Hashtag sembolünü (#) yazıp ardından yorumunuzu yazarak yorum ekleyebilirsiniz. Yorum yapılan metin, R kodundan farklı bir renkte görünecektir.\n#’dan sonra yazılan hiçbir kod çalıştırılmayacaktır. Bu nedenle, kodun önüne bir # koymak, silmek istemiyorsanız bir kod satırını geçici olarak engellemenin (“yorum yapma”) da yararlı bir yoludur. Ctrl+Shift+c (Mac’te Cmd+Shift+c) tuşlarına basarak aynı anda birden fazla satırda yorum yapabilir ve vurgular oluşturabilirsiniz.\n\n# Bir yorum tek başına bir satırda olabilir\n# verileri içe aktar\nlinelist &lt;- import(\"linelist_raw.xlsx\") %&gt;%   # Bir yorum aynı zamanda kodun ardından gelebilir\n# filtre(yaş &gt; 50)                # Bir kod satırını devre dışı bırakmak/kaldırmak için de kullanılabilir\n  count()\n\n\nNe yaptığınız hakkında ve neden yaptığınız hakkında yorum yapın.\n\nKodunuzu mantıksal bölümlere ayırın\n\nYaptığınız işin adım adım açıklamasını içeren bir metinle kodunuza eşlik edin (ör. numaralandırılmış adımlar)\n\n\n\n5.3.1 Stil\nÖzellikle bir ekip üzerinde çalışıyorsanız, kodlama stilinizin bilincinde olmak önemlidir. Biz tidyverse stil rehberini öneriyoruz. Bu stile uyum sağlamanıza yardımcı olan styler ve lintr gibi paketler de vardır.\nKodunuzu başkaları tarafından okunabilir kılmak için birkaç temel nokta:\n* Nesneleri adlandırırken yalnızca küçük harf, sayı ve alt çizgi “_” kullanın, ör. benim_verilerim\n* Sık boşluklar kullanın, ör. “n = 1” ve “age_new &lt;- age_old + 3”\n\n\nÖrnek Komut Dosyası\nAşağıda kısa bir R komut dosyası örneği verilmiştir. Unutmayın, kodunuzu yorumlarda ne kadar kısa ve öz bir şekilde açıklarsanız, iş arkadaşlarınız sizi o kadar çok sevecektir!\n\n\n\n\n\n\n\n\n\n\n\n\nR işaretleme (R Markdown)\nBir R işaretleme komut dosyası, betiğin kendisinin bir çıktı belgesi (PDF, Word, HTML, Powerpoint, vb.) olduğu türüdür. Bunlar, genellikle dinamik ve otomatik raporlar oluşturmak için kullanılan inanılmaz derecede kullanışlı ve çok yönlü araçlardır. Bu web sitesi ve el kitabı bile R işaretleme komut dosyaları ile üretilmiştir!\nYeni başlayan R kullanıcılarının da R Markdown’ı kullanabileceğini belirtmekte fayda var - gözünüz korkmasın! Daha fazla bilgi edinmek için, R Markdown ile Raporlar belgelerindeki el kitabı sayfasına bakabilirsiniz.\n\n\n\nR not defterleri\nRmarkdown ile R not defterine yazmak arasında hiçbir fark yoktur. Ancak belgenin işlenmesi biraz farklıdır. Daha fazla ayrıntı için bu siteye bakabilirsiniz.\n\n\n\nParlak\nParlak uygulamalar/web siteleri, “app.R” olarak adlandırılması gereken tek bir komut dosyası içinde bulunur. Bu dosyanın üç bileşeni vardır:\n\nBir kullanıcı arayüzü (user inteface(ui))\n\nBir sunucu fonksiyonu\n\n“shinyApp” fonksiyonuna bir çağrı\n\nShiny ile Panolar’daki el kitabı sayfasına veya bu çevrimiçi eğiticiye bakabilirsiniz: Parlak öğretici\nÖnceleri yukarıdaki dosya iki dosyaya bölünmüş olarak mevcuttu. (ui.R ve server.R)\n\n\nKod katlama\nKomut dosyanızın okunmasını kolaylaştırmak için kod bölümlerini daraltabilirsiniz.\nBunu yapmak için, # ile bir metin başlığı oluşturun, başlığınızı yazın ve ardından tire (-), kare (#) veya eşittir (=)’den birini en az 4 kez kullanın. Bunu yaptığınızda, soldaki “oluk”ta (satır numarasına göre) küçük bir ok belirecektir. Bu oku ve aşağıdaki kodu, bir sonraki başlık bitimine ve yerinde bir çift ok simgesi görünene kadar tıklayabilirsiniz.\nKodu genişletmek için, ya cilt payındaki oku ya da çift ok simgesini tıklayın. Bu sayfanın RStudio bölümünde açıklandığı gibi klavye kısayolları da mevcuttur.\n# ile başlıklar oluşturarak, komut dosyanızın altında (aşağıya bakın) komut dosyanızda gezinmek için kullanabileceğiniz İçindekiler Tablosunu da etkinleştirirsiniz. Daha fazla # sembolü ekleyerek alt başlıklar oluşturabilirsiniz, örneğin birincil için #, ikincil için ## ve üçüncül başlıklar için ###.\nAşağıda örnek bir komut dosyasının iki versiyonu bulunmaktadır. Solda, yorumlanmış başlıkları olan orijinaldir. Sağ tarafta, her başlıktan sonra daraltılabilir hale getiren dört çizgi yazılmıştır. Bunlardan ikisi daraltılmıştır ve alttaki İçindekiler’in artık her bölümü gösterdiğini görebilirsiniz.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOtomatik olarak katlama için uygun olan diğer kod alanları, fonksiyon tanımları veya koşullu bloklar (if else ifadeleri) gibi “{ }” köşeli parantezli “köşeli” bölgeleri içerir. RStudio sitesinde kod katlama hakkında daha fazla bilgi edinebilirsiniz.",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R'ın Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.tr.html#çalışma-dizini",
    "href": "new_pages/basics.tr.html#çalışma-dizini",
    "title": "3  R’ın Temelleri",
    "section": "5.4 Çalışma dizini",
    "text": "5.4 Çalışma dizini\nÇalışma dizini, R tarafından işiniz için kullanılan kök klasör konumudur - burada R, varsayılan olarak dosyaları arar ve kaydeder. Varsayılan olarak, yeni dosyaları ve çıktıları bu konuma kaydedecek ve içe aktarılacak dosyaları (örneğin veri kümeleri) burada da arayacaktır.\nÇalışma dizini, RStudio Konsol bölmesinin üst kısmında gri metin olarak görünür. Geçerli çalışma dizinini getwd() komutunu çalıştırarak da yazdırabilirsiniz (parantezleri boş bırakın).\n\nknitr::include_graphics(here::here(\"images\", \"working_directory_1.png\"))\n\n\n\n\n\n\n\n\nYakın zamana kadar, R öğrenen birçok kişiye komut dosyalarına setwd() komutuyla başlamaları öğretiliyordu. Bunun yerine lütfen R projesi odaklı bir iş akışı kullanmayı düşünün ve setwd() kullanmama nedenleriniz için okuyunuz. Kısacası, işiniz bilgisayarınıza özel hale gelir, dosyaları içe ve dışa aktarmak için kullanılan dosya yolları “kırılgan” hale gelir ve bu, işbirliğini ve kodunuzun başka herhangi bir bilgisayarda kullanılmasını ciddi şekilde engeller. Kolay alternatifler var!\nYukarıda belirtildiği gibi, çoğu durumda bu yaklaşımı önermesek de, setwd() komutunu alıntılarda istediğiniz klasör dosya yolu ile kullanabilirsiniz, örneğin:\n\nsetwd(\"C:/Documents/R Files/My analysis\")\n\nTEHLİKE: setwd() ile bir çalışma dizini ayarlamak dosya yolu bir bilgisayara özelse “kırılgan” olabilir. Bunun yerine, bir R Project kök dizinine göre dosya yollarını kullanın (burada paketiyle).\n\n\nManuel olarak ayarla\nÇalışma dizinini manuel olarak ayarlamak için (’setwd()’nin tıklamakla eşdeğeri), Oturum açılır menüsünü tıklayın ve “Çalışma Dizinini Ayarla”ya ve ardından “Dizin Seç”e gidin. Bu, o belirli R oturumu için çalışma dizinini ayarlayacaktır. Not: Bu yaklaşımı kullanıyorsanız, RStudio’yu her açtığınızda bunu manuel olarak yapmanız gerekecektir.\n\n\n\nBir R projesi içinde\nBir R projesi kullanıyorsanız, çalışma dizini varsayılan olarak “.rproj” dosyasını içeren R projesi kök klasörü olacaktır. Bu, RStudio’yu R Project’i (“.rproj” uzantılı dosya) tıklayarak açarsanız geçerli olacaktır.\n\n\n\nR markdown için çalışma dizini\nBir R markdown komut dosyasında, varsayılan çalışma dizini, Rmarkdown dosyasının (.Rmd) içinde kaydedildiği klasördür. Bir R projesi ve here paketi kullanılıyorsa, bu geçerli değildir ve çalışma dizini R projeleri sayfasında açıklandığı gibi ‘here()’ olacaktır.\nTek başına bir R markdown çalışma dizinini değiştirmek istiyorsanız (bir R projesinde değil), ‘setwd()’ kullanırsanız, bu yalnızca o belirli kod yığını için geçerli olacaktır. Bir R işaretlemesindeki tüm kod parçalarında değişiklik yapmak için, aşağıdaki gibi “root.dir =” parametresini eklemek için kurulum öbeğini düzenlemelisiniz:\n\nknitr::opts_knit$set(root.dir = 'desired/directorypath')\n\nBir R projesinde sadece R işaretlemesini kullanmak ve here paketini kullanmak çok daha kolaydır.\n\n\n\nDosya yolları sağlama\nYeni başlayanlar için (en azından bir Windows makinesinde) belki de en yaygın hayal kırıklığı kaynağı, verileri içe veya dışa aktarmak için bir dosya yoluna yazmaktır. [İçe ve dışa aktar] sayfasında dosya yollarının en iyi nasıl girileceğine dair kapsamlı bir açıklama vardır, ancak burada birkaç önemli nokta vardır:\nBozuk yollar\nAşağıda bir “mutlak” veya “tam adres” dosya yolu örneği verilmiştir. Bunlar başka bir bilgisayar tarafından kullanılırsa büyük olasılıkla kırılacaktır. Bir istisna, paylaşılan/ağ sürücüsü kullanmanızdır.\nC:/Kullanıcılar/Ad/Belge/Analitik Yazılım/R/Projeler/Analiz2019/data/March2019.csv\n** Eğik yön**\nBir dosya yolu yazıyorsanız, eğik çizgilerin yönüne dikkat edin. Bileşenleri ayırmak için eğik çizgi (/) kullanın (“data/provincial.csv”). Windows kullanıcıları için, dosya yollarının varsayılan görüntülenme şekli ters eğik çizgi (\\) iledir - bu nedenle her eğik çizginin yönünü değiştirmeniz gerekecektir. here paketini R projeleri sayfasında açıklandığı gibi kullanırsanız, eğik çizgi bir sorun olmaz.\nGöreceli dosya yolları\nBunun yerine genellikle “göreceli” dosya yolları sağlamanızı öneririz - yani, R Projenizin köküne göre olan yol. Bunu, R projeleri sayfasında açıklandığı gibi here paketini kullanarak yapabilirsiniz. Göreceli bir dosya yolu şöyle görünebilir:\n\n# Bir R projesinin veri/satır listesi/temiz/alt klasörlerinden csv satır listesini içe aktarın\nlinelist &lt;- import(here(\"data\", \"clean\", \"linelists\", \"marin_country.csv\"))\n\nBir R projesinde göreli dosya yolları kullanıyor olsanız bile, R projenizin dışında verileri içe/dışa aktarmak için mutlak yolları kullanabilirsiniz.",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R'ın Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.tr.html#objects",
    "href": "new_pages/basics.tr.html#objects",
    "title": "3  R’ın Temelleri",
    "section": "5.5 Nesneler",
    "text": "5.5 Nesneler\nR’daki her şey bir nesnedir ve R, “nesne yönelimli” bir dildir. Bu bölümler şunları açıklayacaktır:\n\nNesneler nasıl oluşturulur (&lt;-)\nNesne türleri (örn. veri çerçeveleri, vektörler..)\n\nNesnelerin alt bölümlerine nasıl erişilir (ör. bir veri kümesindeki değişkenler)\n\nNesne sınıfları (örn. sayısal, mantıksal, tamsayı, çift, karakter, faktör)\n\n\n\nHer şey bir nesnedir\nBu bölüm R4Epis projesinden uyarlanmıştır.\nR’da sakladığınız her şey - veri kümeleri, değişkenler, köy isimleri listesi, toplam nüfus sayısı, hatta grafikler gibi çıktılar - atanmış bir adla ve alıntılanabilen nesnelerdir.\nBir nesneye bir değer atadığınızda var olur (aşağıdaki atama bölümüne bakın). Bir değer atandığında, nesne Ortamda görünür (RStudio’nun sağ üst bölmesine bakın). Daha sonra çalıştırılabilir, manipüle edilebilir, değiştirilebilir ve yeniden tanımlanabilir.\n\n\n\nNesneleri tanımlama (&lt;-)\n&lt;- operatörüyle nesnelere bir değer atayarak nesneler oluşturun.\n“&lt;-” atama operatörü olarak tanımlanır. Atama komutları genellikle standart bir sıra izler:\nnesne_adı &lt;- değer (veya bir değer üreten süreç/hesaplama)\nÖrneğin, mevcut epidemiyolojik raporlama haftasını daha sonraki kodda referans için bir nesne olarak kaydetmek isteyebilirsiniz. Bu örnekte, “current_week” nesnesi “2018-W10”’ değeri atandığında oluşturulur (tırnak işaretleri bunu bir karakter değeri yapar). ‘current_week’ nesnesi daha sonra RStudio Ortam bölmesinde (sağ üst) görünecek ve sonraki komutlarda başvurulabilecektir.\nAşağıdaki kutularda R komutlarına ve çıktılarına bakabilirsiniz.\n\ncurrent_week &lt;- \"2018-W10\"   # bu komut, bir değer atayarak current_week nesnesini yaratır.\ncurrent_week                 # bu komut, geçerli_hafta nesnesinin geçerli değerini konsolda yazdırır\n\n[1] \"2018-W10\"\n\n\nNOT: R konsol çıktısındaki [1] sadece çıktının ilk öğesini görüntülediğinizi belirtir\nDİKKAT: Bir nesnenin değerinin üzerine yeniden tanımlamak için bir atama komutu herhangi bir zamanda yazılabilir Bu nedenle, çalışan komutların sırası çok önemlidir.\nAşağıdaki komut, “current_week” değerini yeniden tanımlayacaktır:\n\ncurrent_week &lt;- \"2018-W51\"   # current_week nesnesine YENİ bir değer atar\ncurrent_week                 # bu yeni değeri konsolda yazdırır\n\n[1] \"2018-W51\"\n\n\nEşittir işaretleri =\nAyrıca R kodunda eşittir işaretleri göreceksiniz:\n\nİki nesne veya değer arasındaki bir çift eşittir işareti == mantıksal bir soru sorar: “buna eşit mi?”.\n\nAyrıca, fonskiyonların değişkenlerinin değerlerini belirtmek için kullanılan eşittir işaretlerini de göreceksiniz (bunlar hakkında aşağıdaki bölümlerde okuyun), örneğin max(age, na.rm = TRUE).\n\nNesneleri oluşturmak ve tanımlamak için &lt;- yerine tek bir eşittir işareti = kullanabilirsiniz, ancak bu önerilmez. Bunun neden önerilmediğini buradan okuyabilirsiniz.\n\nVeri kümeleri (Datasets)\nVeri kümeleri de nesnelerdir (tipik olarak “veri çerçeveleri”) ve içe aktarıldıklarında adlarının atanması gerekir. Aşağıdaki kodda, ‘linelist’ nesnesi oluşturulur ve rio paketi ve ‘import()’ fonksiyonu ile içe aktarılan bir CSV dosyasının değeri atanır.\n\n# satır listesi oluşturulur ve içe aktarılan CSV dosyasının değeri atanır\nlinelist &lt;- import(\"my_linelist.csv\")\n\nİçe aktarma ve dışa aktarma bölümünden veri kümelerini içe ve dışa aktarma hakkında daha fazla bilgi edinebilirsiniz.\nDİKKAT: Nesnelerin adlandırılmasıyla ilgili kısa bir not:\n\nNesne adları boşluk içermemelidir, ancak boşluk yerine alt çizgi (_) veya nokta (.) kullanabilirsiniz.\n\nNesne adları büyük/küçük harfe duyarlıdır (yani Veri Kümesi_A, veri kümesi_A’dan farklıdır).\nNesne adları bir harfle başlamalıdır (1, 2 veya 3 gibi bir sayı ile başlayamaz).\n\nÇıktılar\nTablolar ve çizimler gibi çıktılar, çıktıların nesneler olarak nasıl kaydedilebileceğine veya kaydedilmeden nasıl yazdırılabileceğine dair bir örnek sağlar. Temel R fonksiyonu “table()” kullanılarak cinsiyet ve kazanç tablosu doğrudan R konsoluna yazdırılabilir (kaydedilmeden).\n\n# yalnızca R konsoluna yazdırılır\ntable(linelist$gender, linelist$outcome)\n\n   \n    Death Recover\n  f  1227     953\n  m  1228     950\n\n\nAncak aynı tablo adlandırılmış bir nesne olarak kaydedilebilir. Daha sonra isteğe bağlı olarak yazdırılabilir.\n\n# kayıt\ngen_out_table &lt;- table(linelist$gender, linelist$outcome)\n\n#  yazdırma\ngen_out_table\n\n   \n    Death Recover\n  f  1227     953\n  m  1228     950\n\n\nSütunlar\nBir veri kümesindeki sütunlar da nesnelerdir ve aşağıda Sütunlar bölümünde açıklandığı gibi tanımlanabilir, üzerine yazılabilir ve oluşturulabilirdir.\nYeni bir sütun oluşturmak için temel R’dan atama operatörünü kullanabilirsiniz. Aşağıda, yeni sütun “bmi” (Vücut Kitle İndeksi) oluşturulur ve her satır için yeni değer, satırın “wt_kg” ve “ht_cm” sütunlarındaki değeri üzerindeki matematiksel bir işlemin sonucudur.\n\n# temel R sözdizimini kullanarak yeni \"bmi\" sütunu oluşturun\nlinelist$bmi &lt;- linelist$wt_kg / (linelist$ht_cm/100)^2\n\nBununla birlikte, bu el kitabında, dplyr paketindeki mutate() fonksiyonunu ve tünel operatörüyle (%&gt;%) piping fonksiyonunu kullanan sütunları tanımlamaya yönelik farklı bir yaklaşımı vurguluyoruz. Sözdiziminin okunması daha kolaydır ve Temizleme verileri ve temel fonksiyonlar sayfasında açıklanan başka avantajları da vardır. tünelleme hakkında daha fazla bilgiyi aşağıdaki Tünelleme bölümünde okuyabilirsiniz.\n\n# dplyr sözdizimini kullanarak yeni \"bmi\" sütunu oluşturun\nlinelist &lt;- linelist %&gt;% \n  mutate(bmi = wt_kg / (ht_cm/100)^2)\n\n&lt;!PİPİNG OLAYINI HİÇ ANLAMADIM– ======================================================= –&gt;\n\n\nNesne yapısı\nNesneler tek bir veri parçası olabilir (ör. “my_number &lt;- 24”) veya yapılandırılmış verilerden oluşabilir.\nAşağıdaki grafik bu çevrimiçi R eğitiminden ödünç alınmıştır. Bazı yaygın veri yapılarını ve adlarını gösterir. GIS temelleri sayfasında tartışılan uzamsal veriler bu görüntüye dahil değildir.\n\n\n\n\n\n\n\n\n\nEpidemiyolojide (ve özellikle saha epidemiyolojisinde), en yaygın olarak veri çerçeveleri ve vektörlerle karşılaşacaksınız:\n\n\n\n\n\n\nYaygın Yapılar | Açıklama | Örnekler | ==================+==================================================================================================+=====================================================================================+ Vektörler | Hepsi aynı sınıftan (ör. sayısal, karakter) tekil nesneler dizisi için bir kapsayıcı. | Veri çerçevelerindeki “Değişkenler” (sütunlar) vektörlerdir (ör. “age_years” sütunu). |\n\n\nVeri Çerçeveleri | Hepsi aynı sayıda satıra sahip olan birbirine bağlı vektörler (örneğin sütunlar). | satır_listesi bir veri çerçevesidir.\n\n\n\n“Tek başına” (bir veri çerçevesinin parçası olmayan) bir vektör oluşturmak için “c()” fonksiyonunun farklı öğeleri birleştirmek için kullanıldığını unutmayın. Örneğin, bir renk vektörü oluşturuyorsanız, grafiğin renk skalası: vector_of_colors &lt;- c(\"blue\", \"red2\", \"orange\", \"grey\")\n\n\n\nNesne sınıfları\nR’da depolanan tüm nesnelerin, R’a nesneyi nasıl kullanacağını söyleyen bir sınıfı vardır. Birçok olası sınıf vardır, ancak ortak olanlar şunları içerir:\n\n\n\n6 Sınıf\nKarakter\nAçıklama | Örnekler | =========================================================================================================================================================================================+=======================================================================================================+ Bunlar “tırnak içinde” bulunan metin/kelimeler/cümlelerdir . Bu nesneler üzerinde matematik yapılamaz. | “Karakter nesneleri tırnak içindedir” |\n\n\n\n\n\n\n\n\n\n\nTam Sayı | Yalnızca tam olan sayılar (virgülden sonra ondalığı yok) | -5, 14, veya 2000 |\n\n\n\n\n\nSayısal(Nümerik) | Bunlar sayılardır ve ondalık sayılar içerebilir. Tırnak içindeyseler, karakter sınıfı olarak kabul edilirler. | 23.1 veya 14 |\n\n\n\n\n\nFaktör\nBunlar, belirtilmiş bir sıraya veya değerler hiyerarşisine sahip vektörlerdir. | Sıralı değerlere sahip bir ekonomik durum değişkeni |\n\n\n\n\nTarih |R’a belirli verilerin Tarih olduğu söylendiğinde, bu veriler özel yollarla manipüle edilebilir ve görüntülenebilir. Daha fazla bilgi için Tarihlerle çalışma sayfasına bakın.| 2018-04-12 veya 15/3/1954 veya Çrş 4 Ocak 1980 |\n\n\n\n\n\nMantıksal (Logical) | Değerler DOĞRU veya YANLIŞ iki özel değerden biri olmalıdır (bunların tırnak içinde değil “DOĞRU” ve “YANLIŞ” olduğuna dikkat edin) | DOĞRU veya YANLIŞ\n\n\n\n\n\nveri Çerçevesi (data frame) | Veri çerçevesi, R’ın tipik bir veri kümesini nasıl depoladığıdır. Hepsi aynı sayıda gözleme (satır) sahip olan birbirine bağlı veri vektörlerinden (sütunlarından) oluşur. | ‘linelist_raw’ adlı örnek AJS veri kümesi, her biri 300 gözlem (satır) içeren 68 değişken içerir. |\n\n\n\n\n\nTibble\ntibbles, veri çerçevesindeki bir varyasyondur, ana operasyonel fark, konsola daha güzel yazdırmalarıdır (ilk 10 satırı ve yalnızca ekrana uyan sütunları görüntüleyin) | Herhangi bir veri çerçevesi, liste veya matris, as_tibble() ile bir tibble'a dönüştürülebilir.\n\n\n\n\nListe | Liste vektör gibidir, ancak diğer nesneler farklı sınıflara ait olabilir. | Bir liste tek bir sayıyı, bir veri çerçevesini ve bir vektörü ve hatta içinde başka bir listeyi içerebilir! |\n\n\n\n\n\n\nBir nesnenin sınıfını, adını class() fonksiyonuna vererek test edebilirsiniz. Not: Veri kümesinin adını ve sütunun adını ayırmak için “$” gösterimini kullanarak bir veri kümesi içindeki belirli bir sütuna başvurabilirsiniz.\n\nclass(linelist) # sınıfı bir veri çerçevesi veya tibble olmalıdır\n\n[1] \"data.frame\"\n\nclass(linelist$age) # sınıfı sayısal olmalıdır\n\n[1] \"numeric\"\n\nclass(linelist$gender) # sınıfı karakter olmalı\n\n[1] \"character\"\n\n\nBazen bir sütun R tarafından otomatik olarak farklı bir sınıfa dönüştürülür. Buna dikkat edin! Örneğin, bir vektörünüz veya sayı sütununuz varsa, ancak bir karakter değeri eklenirse… sütunun tamamı sınıf karakterine dönüşür.\n\nnum_vector &lt;- c(1,2,3,4,5)       # vektörü tüm sayılar olarak tanımla\nclass(num_vector)                # vektör sayısal bir sınıftır\n\n[1] \"numeric\"\n\nnum_vector[3] &lt;- \"üç\"            # üçüncü elemanı bir karaktere çevir\nclass(num_vector)                # vektör artık karakter sınıfıdır\n\n[1] \"character\"\n\n\nBunun yaygın bir örneği, bir tablo yazdırmak için bir veri çerçevesini manipüle etmektir - toplam bir satır yaparsanız ve sayılarla aynı hücredeki yüzdeleri yapıştırmaya çalışırsanız (örneğin ‘23 (%40)’), yukarıdaki sayısal sütunun tamamı karaktere dönüştürülecek ve artık matematiksel hesaplamalar için kullanılamayacak.Bazen nesneleri veya sütunları başka bir sınıfa dönüştürmeniz gerekebilir.\n\n\n\nFonksiyon | Eylem | ==================+=======================================================================================+ as.character() | Karakter sınıfına çevirir |\n\n\n\nas.numeric()\nSayısal sınıfına çevirir |\n\n\nas.integer()\nTam Sayı sınıfına çevirir |\n\n\nas.Date()\nTarih sınıfına dönüştürür - Not: Ayrıntılar için dates bölümüne bakıns |\n\n\nfactor()\nFaktöre dönüştürür - Not: değer düzeylerinin sırasını yeniden tanımlamak için ekstra değişkenler gerekir\n\n\n\nBenzer şekilde, belirli bir sınıfa ait bir nesnenin IS olup olmadığını kontrol etmek için temel R fonksiyonları vardır. Örneğin “is.numeric()”, “is.character()”, “is.double()”, “is.factor(),is.integer()`\nR’daki sınıflar ve veri yapıları hakkında daha fazla çevrimiçi materyal.\n\n\n\nSütunlar/Değişkenler ($)\nVeri çerçevesindeki bir sütun teknik olarak bir “vektördür” (yukarıdaki tabloya bakın) - tümü aynı sınıfta olması gereken bir dizi değer (karakter, sayısal, mantıksal vb.).\nBir vektör, bir veri çerçevesinden bağımsız olarak var olabilir. Örneğin, bir modelde açıklayıcı değişkenler olarak dahil etmek istediğiniz sütun adlarından oluşan bir vektör. “Bağımsız” bir vektör oluşturmak için aşağıdaki gibi c() fonksiyonunu kullanın:\n\n# karakter değerlerinin bağımsız vektörünü tanımlayın\nexplanatory_vars &lt;- c(\"gender\", \"fever\", \"chills\", \"cough\", \"aches\", \"vomit\")\n\n# bu adlandırılmış vektördeki değerleri yazdır\nexplanatory_vars\n\n[1] \"gender\" \"fever\"  \"chills\" \"cough\"  \"aches\"  \"vomit\" \n\n\nBir veri çerçevesindeki sütunlar da vektörlerdir ve çağrılabilir, referans alınabilir, ayıklanabilir veya $ sembolü kullanılarak oluşturulabilir. $ sembolü, sütunun adını veri çerçevesinin adına bağlar. Bu el kitabında “değişken” yerine “sütun” kelimesini kullanmaya çalışıyoruz.\n\n# age_years vektörünün uzunluğunu alın\nlength(linelist$age) # (yaş, satır listesi veri çerçevesindeki bir sütundur)\n\nVeri çerçevesinin adının ardından `$’ yazarak, veri çerçevesindeki tüm sütunların bir açılır menüsünü de göreceksiniz. Ok tuşunuzu kullanarak aralarında gezinebilir, Enter tuşu ile birini seçebilir ve yazım hatalarından kaçınabilirsiniz!\n\n\n\n\n\n\n\n\n\nGELİŞMİŞ İPUCU: Bazı daha karmaşık nesnelerin (örneğin bir liste veya bir “epicontacts” nesnesi) birden çok dolar işaretiyle erişilebilen birden çok düzeyi olabilir. Örneğin, epicontacts$linelist$date_onset\n\n\n\nKöşeli ayraçlarla erişim/dizin ([ ])\nGenellikle “[ ]” köşeli parantezleri kullanılarak yapılan, “indeksleme” olarak da adlandırılan nesnelerin parçalarını görüntülemeniz gerekebilir. Bir sütuna erişmek için bir veri çerçevesinde $ kullanmak da bir indeksleme türüdür.\n\nmy_vector &lt;- c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\")  # Vektörün tanımlanması\nmy_vector[5]                                  # 5. ögenin yazdırılması\n\n[1] \"e\"\n\n\nKöşeli parantezler ayrıca, bir “summary()” fonksiyonunun çıktısı gibi, döndürülen çıktının belirli bölümlerini döndürmek için de çalışır:\n\n# Özetin tamamı\nsummary(linelist$age)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00    6.00   13.00   16.07   23.00   84.00      86 \n\n# Özetin yalnızca ikinci ögesi, adıyla (yalnızca tek parantez kullanarak)\nsummary(linelist$age)[2]\n\n1st Qu. \n      6 \n\n# Sadece ikinci öge, isimsiz (çift parantez kullanarak)\nsummary(linelist$age)[[2]]\n\n[1] 6\n\n# Bir öğeyi, adını göstermeden adıyla ayıklayın\nsummary(linelist$age)[[\"Median\"]]\n\n[1] 13\n\n\nParantezler ayrıca belirli satırları ve sütunları görüntülemek için veri çerçeveleri üzerinde de çalışır. Bunu, dataframe[rows, column] sözdizimini kullanarak yapabilirsiniz:\n\n# Tüm sütunlarla birlikte veri kümesinden belirli bir satırı (2) görüntüleyin (virgül unutmayın!)\nlinelist[2,]\n\n# Tüm satırları görüntüleyin, ancak yalnızca bir sütun\nlinelist[, \"date_onset\"]\n\n# 2. satırdaki ve 5 ile 10 arasındaki sütunlardaki değerleri görüntüleyin\nlinelist[2, 5:10] \n\n# 2. satırdaki ve 5. ila 10. ve 18. sütunlardaki değerleri görüntüleyin\nlinelist[2, c(5:10, 18)] \n\n# 2'den 20'ye kadar olan satırları ve belirli sütunları görüntüleyin\nlinelist[2:20, c(\"date_onset\", \"outcome\", \"age\")]\n\n# Ölçüte göre satırları ve sütunları görüntüleyin\n# *** Veri çerçevesinin kriterlerde hala adlandırılması gerektiğine dikkat edin!\nlinelist[linelist$age &gt; 25 , c(\"date_onset\", \"outcome\", \"age\")]\n\n# RStudio Viewer bölmesindeki çıktıları görmek için View()'i kullanın (okunması daha kolay)\n# *** View() fonksiyonunda büyük \"V\" harfini not edin\nView(linelist[2:20, \"date_onset\"])\n\n# Yeni bir nesne olarak kaydet\nnew_table &lt;- linelist[2:20, c(\"date_onset\")] \n\ndplyr sözdizimini (satırlar için ‘filter()’ ve sütunlar için ‘select()’ fonksiyonları) kullanarak veri çerçeveleri ve tibbles üzerinde yukarıdaki satır/sütun indekslemeyi de gerçekleştirebileceğinizi unutmayın. Temizleme verileri ve temel fonksiyonlar sayfasında bu temel fonksiyonlar hakkında daha fazla bilgi edinin.\n“Satır numarasına” göre filtrelemek için, mantıksal bir filtreleme ifadesinin parçası olarak açık parantezlerle dplyr row_number() fonksiyonunu kullanabilirsiniz. Aşağıda gösterildiği gibi, genellikle bu mantıksal ifadenin bir parçası olarak “%in%” operatörünü ve bir dizi sayıyı kullanacaksınız. ilk N satırı görmek için, özel dplyr fonksiyonu head() de kullanabilirsiniz.\n\n# İlk 100 satırı görüntüle\nlinelist %&gt;% head(100)\n\n# Sadece 5. satırı görüntüke\nlinelist %&gt;% filter(row_number() == 5)\n\n# 2'den 20'ye kadar olan satırları ve üç özel sütunu görüntüleyin (sütun adlarında tırnak işareti gerekmediğini unutmayın)\nlinelist %&gt;% filter(row_number() %in% 2:20) %&gt;% select(date_onset, outcome, age)\n\nlist sınıfının bir nesnesini indekslerken, yalnızca tek bir nesne döndürülse bile, tek parantezler her zaman sınıf listesiyle birlikte döner. Ancak çift parantezler, tek bir öğeye erişmek ve listeden farklı bir sınıf döndürmek için kullanılabilir.\nParantezler ayrıca aşağıda gösterildiği gibi birbiri ardına yazılabilir.\nBu liste indekslemenin tuzlukla görsel açıklaması komik ve faydalıdır.\n\n# demo listesini tanımla\nmy_list &lt;- list(\n  # Listedeki ilk öge karakter vektörü\n  hospitals = c(\"Central\", \"Empire\", \"Santa Anna\"),\n  \n  # Listedeki ikinci öge adreslerin veri çerçevesi\n  addresses   = data.frame(\n    street = c(\"145 Medical Way\", \"1048 Brown Ave\", \"999 El Camino\"),\n    city   = c(\"Andover\", \"Hamilton\", \"El Paso\")\n    )\n  )\n\nKonsola yazdırıldığında listenin nasıl göründüğü aşağıda açıklanmıştır. Nasıl adlandırılmış iki öğe olduğunu görün:\n\n“hospitals”, bir karakter vektörü\n\n“addresses”, adreslerin bir veri çerçevesi\n\n\nmy_list\n\n$hospitals\n[1] \"Central\"    \"Empire\"     \"Santa Anna\"\n\n$addresses\n           street     city\n1 145 Medical Way  Andover\n2  1048 Brown Ave Hamilton\n3   999 El Camino  El Paso\n\n\nŞimdi çeşitli yöntemler kullanarak ayıklıyoruz:\n\nmy_list[1] # bu, \"list\" sınıfındaki öğeyi döndürür - öğe adı hala görüntüleniyor\n\n$hospitals\n[1] \"Central\"    \"Empire\"     \"Santa Anna\"\n\nmy_list[[1]] # bu yalnızca (adsız) karakter vektörünü döndürür\n\n[1] \"Central\"    \"Empire\"     \"Santa Anna\"\n\nmy_list[[\"hospitals\"]] # ayrıca liste öğesinin adına göre dizin oluşturabilirsiniz\n\n[1] \"Central\"    \"Empire\"     \"Santa Anna\"\n\nmy_list[[1]][3] # \"hastaneler\" karakter vektörünün üçüncü öğesini döndürür\n\n[1] \"Santa Anna\"\n\nmy_list[[2]][1] # Bu, adres veri çerçevesinin ilk sütununu (\"sokak\") döndürür\n\n           street\n1 145 Medical Way\n2  1048 Brown Ave\n3   999 El Camino\n\n\n\n\n\nNesneleri kaldırma\n‘rm()’ fonksiyonu ile (tırnak işaretleri olmadan) R ortamınızdan tek tek nesneleri kaldırabilirsiniz:\n\nrm(object_name)\n\nAşağıdakileri çalıştırarak tüm nesneleri kaldırabilirsiniz (çalışma alanınızı temizleyin):\n\nrm(list = ls(all = TRUE))",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R'ın Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.tr.html#tünelleme",
    "href": "new_pages/basics.tr.html#tünelleme",
    "title": "3  R’ın Temelleri",
    "section": "6.1 Tünelleme (%>%)",
    "text": "6.1 Tünelleme (%&gt;%)\nNesnelerle çalışmaya yönelik iki genel yaklaşım şunlardır:\n\nTüneller/tidyverse - tüneller nesneyi bir fonksiyondan diğerine gönderir - vurgu nesne değil eylem üzerindedir\n\nAra nesneleri tanımlayın - bir nesne tekrar tekrar tanımlanır - vurgu nesne üzerindedir\n\n\n\nTüneller\nBasitçe açıklandığı gibi, tünel operatörü (%&gt;%) bir fonksiyondan diğerine bir ara çıktı iletir.\nBunu “sonrasında” demek gibi düşünebilirsiniz. Birçok fonksiyon %&gt;% ile birbirine bağlanabilir.\n\nTünelleme, eylemlerin gerçekleştirildiği nesneyi değil, bir dizi eylemi vurgular\n\nTüneller, bir nesne üzerinde bir dizi eylem gerçekleştirilmesi gerektiğinde en iyisidir\n\nTüneller, otomatik olarak dplyr ve tidyverse paketlerine dahil edilen magrittr paketinden gelir\nTüneller, kodu daha temiz ve okunması daha kolay, daha sezgisel hale getirebilir\n\nBu yaklaşımla ilgili daha fazla bilgiyi tidyverse stil kılavuzunda okuyabilirsiniz.\nİşte “kek pişirmek” için kurgusal fonksiyonları kullanan karşılaştırma için sahte bir örnek. İlk olarak, tünel yöntemi:\n\n# Tünel sözdizimi kullanarak kek pişirmenin sahte bir örneği\n\ncake &lt;- flour %&gt;%       # Kek pişirmek için önce undan başlanır, sonrasında...\n  add(eggs) %&gt;%   # yumurtaları ekle\n  add(oil) %&gt;%    # yağı ekle\n  add(water) %&gt;%  # suyu ekle\n  mix_together(         # birlikte karıştır\n    utensil = spoon,\n    minutes = 2) %&gt;%    \n  bake(degrees = 350,   # pişir\n       system = \"fahrenheit\",\n       minutes = 35) %&gt;%  \n  let_cool()            # soğumaya bırak\n\nİşte tünellerin kullanımını açıklayan başka bir bağlantı.\nTünelleme bir temel fonksiyon değildir. Tünelleri kullanmak için magrittr paketi kurulmalı ve yüklenmelidir (bu genellikle, onu içeren tidyverse veya dplyr paketi yüklenerek yapılır). magrittr belgelerinde tünelleme hakkında daha fazla bilgi edinebilirsiniz.\nDiğer R komutlarında olduğu gibi, tünellerin yalnızca sonucu görüntülemek veya “&lt;-” atama operatörünün dahil olup olmadığına bağlı olarak bir nesneyi kaydetmek/yeniden kaydetmek için kullanılabileceğini unutmayın. Her ikisine de bakın:\n\n# Yaş kategorisine göre toplam sayım olarak tanımlayarak nesne oluşturun veya üzerine yazın (yazdırılmaz)\nlinelist_summary &lt;- linelist %&gt;% \n  count(age_cat)\n\n\n# Konsoldaki sayım tablosunu yazdırın, ancak kaydetmeyin\nlinelist %&gt;% \n  count(age_cat)\n\n  age_cat    n\n1     0-4 1095\n2     5-9 1095\n3   10-14  941\n4   15-19  743\n5   20-29 1073\n6   30-49  754\n7   50-69   95\n8     70+    6\n9    &lt;NA&gt;   86\n\n\n%&lt;&gt;%\nBu, magrittr paketinden bir “atama tüneli”dir ve bu, bir nesneyi ileriye taşır ve aynı zamanda nesneyi yeniden tanımlar*. Zincirdeki ilk tünel operatörü olmalıdır. Kısa yol. Aşağıdaki iki komut eşdeğerdir:\n\nlinelist &lt;- linelist %&gt;%\n  filter(age &gt; 50)\n\nlinelist %&lt;&gt;% filter(age &gt; 50)\n\n\n\n\nAra nesneleri tanımlayın\nNesneleri/veri çerçevelerini değiştirmeye yönelik bu yaklaşım, aşağıdaki durumlarda daha iyi olabilir:\n\nBirden çok nesneyi manipüle etmeniz gerekirse\n\nAnlamlı olan ve ayrı nesne adlarını hak eden ara adımlar varsa\n\nRiskler:\n\nHer adım için yeni nesneler oluşturmak, çok sayıda nesne oluşturmak anlamına gelir. Eğer yanlış olanı kullanırsan, bunu fark etmeyebilirsin!\n\nTüm nesneleri adlandırmak kafa karıştırıcı olabilir\n\nHatalar kolayca tespit edilemeyebilir\n\nHer bir ara nesneyi adlandırın veya orijinalin üzerine yazın veya tüm fonksiyonları bir araya getirin. Hepsi kendi riskleriyle birlikte gelir.\nAşağıda, yukarıdakiyle aynı sahte “kek” örneği verilmiştir, ancak bu stili kullanarak:\n\n# bu yöntemi kullanarak kek pişirmenin sahte bir örneği (ara nesneleri tanımlama)\nbatter_1 &lt;- left_join(flour, eggs)\nbatter_2 &lt;- left_join(batter_1, oil)\nbatter_3 &lt;- left_join(batter_2, water)\n\nbatter_4 &lt;- mix_together(object = batter_3, utensil = spoon, minutes = 2)\n\ncake &lt;- bake(batter_4, degrees = 350, system = \"fahrenheit\", minutes = 35)\n\ncake &lt;- let_cool(cake)\n\nTüm fonksiyonları bir araya getirin - bunu okumak zordur:\n\n# birden çok fonksiyonu bir araya getirme/iç içe yerleştirme örneği - okunması zordur\ncake &lt;- let_cool(bake(mix_together(batter_3, utensil = spoon, minutes = 2), degrees = 350, system = \"fahrenheit\", minutes = 35))",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R'ın Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.tr.html#operators",
    "href": "new_pages/basics.tr.html#operators",
    "title": "3  R’ın Temelleri",
    "section": "6.2 Anahtar operatörler ve fonksiyonlar",
    "text": "6.2 Anahtar operatörler ve fonksiyonlar\nBu bölüm, R’daki operatörleri detaylandırır, örneğin:\n\nTanımsal operatörler\n\nİlişkisel operatörler (küçüktür, eşittir çok ..)\n\nMantıksal operatörler (ve, veya…)\n\nEksik değerlerin işlenmesi\n\nMatematiksel operatörler ve fonksiyonlar (+/-, &gt;, toplam(), medyan(), …)\n\n%in% operatörü\n\n\n\nAtama operatörleri\n&lt;-\nR’daki temel atama operatörü &lt;- şeklindedir. Öyle ki nesne_adı &lt;- değer.\nBu atama operatörü = şeklinde de yazılabilir. Genel R kullanımı için &lt;- kullanılmasını tavsiye ederiz.\nOkunabilirlik için bu tür operatörleri boşluklarla çevrelemenizi de öneririz.\n&lt;&lt;-\nYazma fonksiyonlarını veya R’ı kaynaklı komut dosyalarıyla etkileşimli bir şekilde kullanıyorsanız, bu atama operatörünü &lt;&lt;- (base R’dan) kullanmanız gerekebilir. Bu operatör, daha yüksek bir ‘ana’ R Ortamında bir nesneyi tanımlamak için kullanılır. Bu çevrimiçi referansa bakabilirsiniz.\n%&lt;&gt;%\nBu, bir nesneyi ileriye yönlendiren ve aynı zamanda nesneyi yeniden tanımlayan magrittr paketinden bir “atama tünelidir”. Zincirdeki ilk tünel operatörü olmalıdır. Aşağıda iki eşdeğer örnekte gösterildiği gibi kısa yoldur:\n\nlinelist &lt;- linelist %&gt;% \n  mutate(age_months = age_years * 12)\n\nYukarıdaki aşağıdakine eşdeğerdir.\n\nlinelist %&lt;&gt;% mutate(age_months = age_years * 12)\n\n%&lt;+%\nBu, ggtree paketi ile filogenetik ağaçlara veri eklemek için kullanılır. Filogenetik ağaçlar sayfasına veya bu çevrimiçi kaynak kitap sayfasına bakabilirsiniz.\n\n\n\nİlişkisel ve mantıksal operatörler\nİlişkisel operatörler değerleri karşılaştırır ve genellikle yeni değişkenleri ve veri kümelerinin alt kümelerini tanımlarken kullanılır. R’daki ortak ilişkisel operatörler şunlardır:\n\n\n\nAnlamı | Operatör | Örnek | Örnek Sonucu | ==========================+============+==============+========================================================================================================================================================+ Eşittir | == | \"A\" == \"a\" | FALSE (çünkü R büyük/küçük harf duyarlıdır) == (çift eşittir) öğesinin = (tekli eşittir) fonksiyonundan farklı olduğuna ve bu atama operatörünün &lt;- gibi davrandığına dikkat edin\n\n\n\n\n\n\nEşit değildir | != | 2 != 0 | TRUE |\n\n\n\n\n\n\nBüyüktür\n&gt;\n4 &gt; 2\nTRUE\n\n\n\nKüçüktür\n&lt;\n4 &lt; 2\nFALSE\n\n\n\nBüyük eşittir\n&gt;=\n6 &gt;= 4\nTRUE\n\n\n\nKüçük eşittir\n&lt;=\n6 &lt;= 4\nFALSE\n\n\n\nDeğer eksiktir\nis.na()\nis.na(7)\nFALSE Kayıp Veri sayfasına bakabilirsiniz)\n\n\n\nDeğer tamdır\n!is.na()\n!is.na(7)\nTRUE\n\n\n\n\nAND ve OR gibi mantıksal operatörler, genellikle ilişkisel operatörleri bağlamak ve daha karmaşık kriterler oluşturmak için kullanılır. Karmaşık ifadeler, gruplama ve uygulama sırası için parantez ( ) gerektirebilir.\n\n\n\n\n\n\n\n\n7 Anlamı\nVE\n8 Operator\n&\n\n\n\n\n\n\nVEYA | | (dikey çizgi) |\n\n\nParantezler\n( ) Kriterleri birlikte gruplandırmak ve işlem sırasını netleştirmek için kullanılır\n\n\n\nÖrneğin, aşağıda vaka tanımımızı oluşturmak için kullanmak istediğimiz iki değişkenli bir satır listemiz var, hep_e_rdt, bir test sonucu ve hanede başka vakalar olup olmadığını bize bildirecek other_cases_in_hh. Aşağıdaki komut, yeni “case_def” değişkenini yaratmak için “case_when()” fonksiyonunu kullanır:\n\nlinelist_cleaned &lt;- linelist %&gt;%\n  mutate(case_def = case_when(\n    is.na(rdt_result) & is.na(other_case_in_home)            ~ NA_character_,\n    rdt_result == \"Positive\"                                 ~ \"Confirmed\",\n    rdt_result != \"Positive\" & other_cases_in_home == \"Yes\"  ~ \"Probable\",\n    TRUE                                                     ~ \"Suspected\"\n  ))\n\n\n\n\n\n\n\n\nÜstteki örneğin kriteri | Yeni “case_def” değişkeninde elde edilen değer | ================================================================================================+============================================+ “rdt_result” ve “other_cases_in_home” değişkenlerinin değeri eksik ise | NA (eksik) |\n\n\n“rdt_result” içindeki değer “Pozitif” ise\n“Onaylanmış” |\n\n\n“rdt_result” içindeki değer “Pozitif” DEĞİLSE VE “other_cases_in_home” içindeki değer “Evet” ise | “Muhtemel”\n\n\nYukarıdaki kriterlerden biri karşılanmazsa | “Şüpheli” |\n\n\n\nR’ın büyük/küçük harf duyarlı olduğuna dikkat edin, bu nedenle “Pozitif”, “pozitif”ten farklıdır…\n\n\n\nEksik değerler\nR’da, eksik değerler “NA” (“ayrılmış” bir değer) özel değeriyle temsil edilir (büyük harfler N ve A - tırnak içinde değil). Eksik verileri başka bir şekilde kaydeden verileri içe aktarırsanız (ör. 99, “Eksik” veya .), bu değerleri “NA” olarak yeniden kodlamak isteyebilirsiniz. Bunun nasıl yapılacağı İçe ve dışa aktar sayfasında ele alınmaktadır.\nBir değerin “NA” olup olmadığını test etmek için “DOĞRU” veya “YANLIŞ” döndüren özel “is.na()” fonksiyonunu kullanın.\n\nrdt_result &lt;- c(\"Positive\", \"Suspected\", \"Positive\", NA)   # biri şüpheli, biri bilinmeyen iki pozitif vaka\nis.na(rdt_result)  # rdt_result değerinin NA olup olmadığını test eder\n\n[1] FALSE FALSE FALSE  TRUE\n\n\nEksik veri sayfasındaki eksik, sonsuz, “NULL” ve imkansız değerler hakkında daha fazla bilgi edinin. İçe ve dışa aktar sayfasındaki verileri içe aktarırken eksik değerleri nasıl dönüştüreceğinizi öğrenin.\n\n\n\nMatematik ve istatistik\nBu sayfadaki tüm operatörler ve fonksiyonlar, base R kullanılarak otomatik olarak kullanılabilir.\n\nMatematiksel operatörler\nBunlar genellikle toplama, bölme, yeni sütunlar vb. oluşturmak için kullanılır. Aşağıda R’daki yaygın matematiksel operatörler verilmiştir. Operatörlerin etrafına boşluk koyup koymamanız önemli değildir.\n\n\n\nAmaç\nR’da Örneği\n\n\n\n\nToplama\n2 + 3\n\n\nÇıkarma\n2 - 3\n\n\nÇarpma\n2 * 3\n\n\nBölme\n30 / 5\n\n\nÜstel\n2^3\n\n\nOperasyon sırası\n( )\n\n\n\n\n\nMatematiksel fonksiyonlar\n\n\n\nAmaç\nFonksiyon\n\n\n\n\nyuvarlama\nround(x, digits = n)\n\n\nyuvarlama\njanitor::round_half_up(x, digits = n)\n\n\ntavana yuvarlama\nceiling(x)\n\n\ntabana yuvarlama\nfloor(x)\n\n\nkesin değer\nabs(x)\n\n\nkarekök\nsqrt(x)\n\n\nüstel\nexponent(x)\n\n\ndoğal logaritma\nlog(x)\n\n\nlog 10 tabanlı\nlog10(x)\n\n\nlog 2 tabanlı\nlog2(x)\n\n\n\nNot: “round()” için “digits =”, yerleştirilen ondalık sayıyı belirtir. Bir dizi anlamlı rakama yuvarlamak için signif() kullanın.\n\n\nBilimsel gösterim\nBilimsel gösterimin kullanılma olasılığı, “scipen” seçeneğinin değerine bağlıdır.\n?options belgesinden: scipen, sayısal değerleri sabit veya üstel gösterimde yazdırmaya karar verirken uygulanacak bir cezadır. Pozitif değerler sabite ve negatif değerler bilimsel gösterime eğilimlidir: ‘scipen’ basamaklarından daha geniş olmadığı sürece sabit gösterim tercih edilecektir.\nDüşük bir sayıya (örneğin 0) ayarlanırsa, her zaman “açık” olacaktır. R oturumunuzda bilimsel gösterimi “kapatmak” için çok yüksek bir sayıya ayarlayın, örneğin:\n\n# bilimsel gösterimi kapat\noptions(scipen=999)\n\n\n\nYuvarlama\nTEHLİKE: ‘round()’, yalnızca üst sayı çift ise 0,5’ten yuvarlayan “banker yuvarlaması”nı kullanır. Yarımları tutarlı bir şekilde en yakın tam sayıya yuvarlamak için janitor ‘dan ’round_half_up()’ kullanın. Bu açıklamaya\n\n# işiniz için uygun yuvarlama fonksiyonunu kullanın\nround(c(2.5, 3.5))\n\n[1] 2 4\n\njanitor::round_half_up(c(2.5, 3.5))\n\n[1] 3 4\n\n\n\n\nİstatistiksel fonksiyonlar\nDİKKAT: Aşağıdaki fonksiyonlar varsayılan olarak hesaplamalarda eksik değerleri içerecektir. “na.rm = TRUE” bağımsız değişkeni belirtilmedikçe, eksik değerler “YOK” çıktısıyla sonuçlanır. Bu, kısaca na.rm = T şeklinde yazılabilir.\n\n\n\nAmaç\nFonksiyon\n\n\n\n\nOrtalama\nmean(x, na.rm=T)\n\n\nOrtanca\nmedian(x, na.rm=T)\n\n\nStandart Deviasyon\nsd(x, na.rm=T)\n\n\ndağılım*\nquantile(x, probs)\n\n\ntoplam\nsum(x, na.rm=T)\n\n\nminimum değer\nmin(x, na.rm=T)\n\n\nmaksimum değer\nmax(x, na.rm=T)\n\n\nNumerik veri aralığı\nrange(x, na.rm=T)\n\n\nözet**\nsummary(x)\n\n\n\nNotlar:\n\n“*quantile()“:”x” incelenecek sayısal vektördür ve “prob =” olasılıkları 0 ile 1.0 arasında olan sayısal bir vektördür, ör. “c(0.5, 0.8, 0.85)”\n**summary(): ortalama, medyan ve ortak yüzdelikler dahil olmak üzere sayısal bir vektörün özetini verir\n\nTEHLİKE: Yukarıdaki fonksiyonlardan birine bir sayı vektörü sağlıyorsanız, sayıları c() içine sardığınızdan emin olun.\n\n# Bir fonksiyona ham sayılar veriliyorsa, bunları c() içine sarın\nmean(1, 6, 12, 10, 5, 0)    # !!! YANLIŞ !!!  \n\n[1] 1\n\nmean(c(1, 6, 12, 10, 5, 0)) # DOĞRU\n\n[1] 5.666667\n\n\n\n\nDiğer kullanışlı fonksiyonlar\n\n\n\n\n\n\n\n\n\n9 Amaç\nBir seri oluştur\n10 Fonksiyon\nseq(from, to, by)\n11 Örnek\nseq(1, 10, 2)\n\n\n\n\n\n\nx, n kere tekrar et\nrep(x, ntimes)\nrep(1:3, 2) or rep(c(\"a\", \"b\", \"c\"), 3)\n\n\n\nsayısal bir vektörü alt bölümlere ayır | cut(x, n) | cut(linelist$age, 5)\n\n\nRastgele örnek al\nsample(x, size)\nsample(linelist$id, size = 5, replace = TRUE)\n\n\n\n\n\n\n\n\n%in%\nDeğerleri eşleştirmek ve bir değerin bir vektör veya veri çerçevesi içinde olup olmadığını hızlı bir şekilde değerlendirmek için çok kullanışlı bir operatör.\n\nmy_vector &lt;- c(\"a\", \"b\", \"c\", \"d\")\n\n\n\"a\" %in% my_vector\n\n[1] TRUE\n\n\"h\" %in% my_vector\n\n[1] FALSE\n\n\nBir vektörün %in%’inde olup olmadığını sormak için mantık ifadesinin önüne** bir ünlem işareti (!) koyun:\n\n# inkar etmek, önüne ünlem işareti koymak\n!\"a\" %in% my_vector\n\n[1] FALSE\n\n!\"h\" %in% my_vector\n\n[1] TRUE\n\n\n“%in%”, dplyr fonksiyonu “case_while()” kullanılırken çok kullanışlıdır. Bir vektörü önceden tanımlayabilir ve daha sonra ona başvurabilirsiniz. Örneğin:\n\naffirmative &lt;- c(\"1\", \"Yes\", \"YES\", \"yes\", \"y\", \"Y\", \"oui\", \"Oui\", \"Si\")\n\nlinelist &lt;- linelist %&gt;% \n  mutate(child_hospitaled = case_when(\n    hospitalized %in% affirmative & age &lt; 18 ~ \"Hospitalized Child\",\n    TRUE                                      ~ \"Not\"))\n\nNot: Belki stringr’den str_detect() kullanarak kısmi bir dize algılamak istiyorsanız, c(\"1\", \"Yes\", \"yes\", \"y\" gibi bir karakter vektörünü kabul etmeyecektir. \"). Bunun yerine, “1|Yes|yes|y” gibi VEYA çubukları olan bir yoğunlaştırılmış dize normal ifade verilmelidir. Örneğin, str_detect(hospitalized, \"1|Yes|yes|y\"). Daha fazla bilgi için Karakterler ve dizeler hakkındaki sayfaya bakın.\nBu komutla bir karakter vektörünü adlandırılmış bir normal ifadeye dönüştürebilirsiniz:\n\naffirmative &lt;- c(\"1\", \"Yes\", \"YES\", \"yes\", \"y\", \"Y\", \"oui\", \"Oui\", \"Si\")\naffirmative\n\n[1] \"1\"   \"Yes\" \"YES\" \"yes\" \"y\"   \"Y\"   \"oui\" \"Oui\" \"Si\" \n\n# condense to \naffirmative_str_search &lt;- paste0(affirmative, collapse = \"|\")  # Temel R ile yapılması seçeneği\naffirmative_str_search &lt;- str_c(affirmative, collapse = \"|\")   # stringr paketi seçeneği\n\naffirmative_str_search\n\n[1] \"1|Yes|YES|yes|y|Y|oui|Oui|Si\"",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R'ın Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.tr.html#hatalar-ve-uyarılar",
    "href": "new_pages/basics.tr.html#hatalar-ve-uyarılar",
    "title": "3  R’ın Temelleri",
    "section": "11.1 Hatalar ve uyarılar",
    "text": "11.1 Hatalar ve uyarılar\nBu bölüm şunları açıklar:\n\nHatalar ve uyarılar arasındaki fark\n\nR kodu yazmak için genel sözdizimi ipuçları\n\nKod yardımcıları\n\nGenel hatalar, uyarılar ve sorun giderme ipuçları Hatalar ve yardım sayfasında bulunabilir.\n\n\nHata VS. Uyarı\nBir komut çalıştırıldığında, R Konsolu size kırmızı metinle uyarı veya hata mesajları gösterebilir.\n\nBir uyarı, R’ın komutunuzu tamamladığı, ancak farkında olmanız gereken ek adımlar atması veya olağandışı çıktılar üretmesi gerektiği anlamına gelir.\nBir hata, R’ın komutunuzu tamamlayamadığı anlamına gelir.\n\nİpuçlarını ara:\n\nHata/uyarı mesajı genellikle sorun için bir satır numarası içerir.\nBir nesne “bilinmiyorsa” veya “bulunamadıysa”, yanlış yazmış olabilirsiniz, library() ile bir paketi çağırmayı unutmuş veya değişiklik yaptıktan sonra betiğinizi yeniden çalıştırmayı unutmuş olabilirsiniz.\n\nHer şey başarısız olursa, bazı anahtar terimlerle birlikte hata mesajını Google’a kopyalayın - büyük olasılıkla başka biri bunun üzerinde çalışmıştır!\n\n\n\nGenel sözdizimi ipuçları\nHataları ve uyarıları önlemek için R’da komut yazarken hatırlamanız gereken birkaç şey:\n\nParantezleri her zaman kapatın - ipucu: Her kod öbeği için “(” ve kapanış parantezleri “)” sayısını sayın\nSütun ve nesne adlarında boşluklardan kaçının. Bunun yerine alt çizgi ( _ ) veya nokta ( . ) kullanın\nBir fonksiyonun değişkenlerini virgülle ayırmayı unutmayın ve takip edin\nR büyük/küçük harf duyarlıdır, yani “Değişken_A”, “değişken_A”dan farklıdır\n\n\n\n\nKod yardımı\nHerhangi bir komut dosyası (RMarkdown veya başka türlü), bir hata yaptığınızda ipucu verecektir. Örneğin, gereken yere virgül yazmayı veya bir parantez kapatmayı unuttuysanız, RStudio sizi uyarmak için betiğin sağ tarafında o satırda bir bayrak kaldıracaktır.",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R'ın Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.tr.html",
    "href": "new_pages/transition_to_R.tr.html",
    "title": "4  R’a geçiş",
    "section": "",
    "text": "4.1 Excel’den geçiş\nExcel’den doğrudan R’a geçiş yapmak artık çok daha ulaşılabilir bir hedeftir. Göz korkutucu görünebilir, ancak yapabilirsiniz!\nGüçlü Excel becerilerine sahip birinin tek başına Excel’de çok gelişmiş analizler yapabileceği doğrudur. Hatta VBA gibi komut araçlarını kullanarak yapılabilecek faaliyetler daha da artabilecektir. Excel tüm dünyada kullanılmaktadır ve bir epidemiyolog için önemli bir araçtır. Bununla birlikte, onu R ile tamamlamak, iş akışlarınızı önemli ölçüde iyileştirip genişletebilir.",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>R'a geçiş</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.tr.html#excelden-geçiş",
    "href": "new_pages/transition_to_R.tr.html#excelden-geçiş",
    "title": "4  R’a geçiş",
    "section": "",
    "text": "Faydaları\nR’ın zamandan tasarruf, daha tutarlı ve doğru analiz, tekrarlanabilirlik, paylaşılabilirlik ve daha hızlı hata düzeltme açısından muazzam faydalar sunduğunu göreceksiniz. Her yeni yazılım gibi, ona aşina olmak için emek vermeniz gereken bir öğrenme “eğrisi” vardır. Birbirinden farklı kütüphaneleriyle R size yeni olasılıkların muazzam kapısını açacaktır.\nExcel, “seç ve tıkla” özelliği ile basit analizler ve görselleştirmeler oluşturmak için yeni başlayanlar tarafından kolayca kullanılabilen ve iyi bilinen bir yazılımdır. R’a baktığınızda, fonksiyonlarına ve arayüzüne aşina olabilmeniz birkaç hafta sürebilir. Bununla birlikte, R, son yıllarda yeni başlayanlar için çok daha kolay hale gelmek adına önemli adımlar atmıştır.\nBirçok Excel iş akışı hafıza ve tekrarlamaya dayanır. Bu nedenle hata olasılığı çoktur. Ayrıca, genellikle veri temizleme, analiz metodolojisi ve kullanılan denklemler görünümden gizlenir. Yeni bir iş arkadaşının bir Excel çalışma kitabının ne yaptığını ve olası hataların nasıl giderileceğini öğrenmesi için önemli ölçüde bir zamana ihtiyaç duyabilir. R ile tüm adımlar komut dosyasına açıkça yazılır ve kolayca görüntülenebilir, düzenlenebilir, düzeltilebilir ve diğer veri kümelerine uygulanabilir.\nExcel’den R’a geçişinize başlamak için zihniyetinizi birkaç önemli yaklaşımla düzenlemeniz gerekir:\n\n\nDüzenli veri\nDağınık “insan tarafından okunabilen” veriler yerine makine tarafından okunabilen “düzenli” verileri kullanın. R’deki “düzenli” veriler konusunda açıklandığı gibi, “düzenli” veriler için üç ana şart vardır:\n\nHer değişkenin kendi sütunu olmalıdır\nHer gözlemin kendi satırı olmalıdır\nHer değerin kendi hücresi olmalıdır\n\nExcel kullanıcıları bu şartları Excel “tablolarının” verileri standartlaştırma ve daha tahmin edilebilir bir formata uyarlamada oynadığı rol gibi değerlendirebilir.\n“Düzenli” verilere bir örnek, bu el kitabında kullanılan durum satır listesi olabilir. Her değişken bir sütunda yer alır, her gözlemin (bir vaka) kendine ait satırı vardır ve her değer yalnızca bir hücrededir. Aşağıda, linelistin ilk 50 satırını görüntüleyebilirsiniz:\n\n\n\n\n\n\nDüzenli olmayan verilerle karşılaşmamızın ana nedeni, birçok Excel tablosunun makineler/yazılımlar tarafından değil, insanlar tarafından kolay okumaya öncelik verecek şekilde tasarlanmış olmasıdır.\nFarkı görmenize yardımcı olmak için, aşağıda insan-okunabilirliğe öncelik veren düzensiz verilere ilişkin bazı kurgusal örnekler verilmiştir.:\n\n\n\n\n\n\n\n\n\nSorunlar: Yukarıdaki tabloda, R tarafından kolayca anlaşılamayacak olan birleştirilmiş hücreler mevcuttur. Hangi satırın “başlık” olarak kabul edilmesi gerektiği açık değildir. Renk tabanlı bir sözlük sağ taraftadır ve hücre değerleri renklerle temsil edilir - bu da R tarafından kolayca yorumlanamaz (ayrıca renk körlüğü olan insanlar tarafından da!). Ayrıca, farklı bilgi parçaları tek bir hücrede birleştirmiştir (bir alanda çalışan birden fazla ortak kuruluş gibi).\n\n\n\n\n\n\n\n\n\nSorunlar: Yukarıdaki tabloda, veri kümesi içinde çok sayıda fazladan boş satır ve sütun vardır - bu, R’de temizlik sorunlarına neden olur. Ayrıca, belirli bir tedavi merkezi için GPS koordinatları iki satıra yayılmaktadır. Bir yan not olarak - GPS koordinatları iki farklı biçimdedir!\n“Düzenli” veri kümeleri insan gözüyle rahatça okunabilir olmayabilir, fakat veri temizleme ve analiz süreçlerini çok daha kolay hale getirirler! Düzenli veriler çeşitli biçimlerde saklanabilir, örneğin “uzun” veya “geniş”“(bkz.Pivot verileri). Ancak yukarıdaki ilkeler hala gözetilmektedir.\n\n\nFonksiyonlar\nR terimi olan “fonksiyon” size yeni gelebilir, fakat bu kavram Excel’de formüller olarak mevcuttur. Excel’deki formüller ayrıca kesin sözdizimi gerektirir (örneğin, noktalı virgül ve parantez yerleştirilmesi). Tek yapmanız gereken birkaç yeni fonksiyonu ve bunların R’da nasıl birlikte çalıştıklarını öğrenmek.\n\n\nKodlar\nDüğmelere tıklayıp hücreleri sürüklemek yerine her adımı ve prosedürü bir “komut dosyasına” yazacaksınız. Excel kullanıcıları, aynı zamanda bir komut dosyası oluşturma yaklaşımı kullanan “VBA makrolarına” aşina olabilir.\nR komut dosyası adım adım talimatlardan oluşur. Bu, herhangi bir iş arkadaşınızın komut dosyasını okumasını ve attığınız adımları kolayca görmesini sağlar. Bu aynı zamanda hataların veya hatalı hesaplamaların giderilmesine de yardımcı olur. Örnekler için komut dosyalarıyla ilgili R temelleri bölümüne bakabilirsiniz.\nİşte bir R kodu örneği:\n\n\n\n\n\n\n\n\n\n\n\nExcel’den R’a geçiş kaynakları\nExcel’den R’ye geçiş yapmanıza yardımcı olacak rehberlere yönelik bazı bağlantılar:\n\nR vs. Excel\n\nExcel kullanıcıları için R’de RStudio kursu\n\n\n\nR-Excel etkileşimi\nR, Excel çalışma kitaplarını içe aktarmak, verilerle çalışmak, Excel dosyalarını dışa aktarmak/kaydetmek ve Excel sayfalarının nüanslarıyla çalışmak adına güçlü fonksiyonlara sahiptir.\nEstetik bazı Excel biçimlendirmelerinin çeviri sırasında kaybolabileceği doğrudur (örneğin, italik, yan metin, vb.). İş akışınız, orijinal Excel biçimlendirmesini korurken belgeleri R ve Excel arasında ileri geri aktarmayı gerektiriyorsa, openxlsx gibi paketleri deneyebilirsiniz.",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>R'a geçiş</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.tr.html#statadan-geçiş",
    "href": "new_pages/transition_to_R.tr.html#statadan-geçiş",
    "title": "4  R’a geçiş",
    "section": "4.2 Stata’dan geçiş",
    "text": "4.2 Stata’dan geçiş\n\nStata’dan R’a gelmek\nİlk olarak Stata’yı kullanmayı öğrenen birçok epidemiyolog için R’a geçmek göz korkutucu görünebilir. Ancak, iyi bir Stata kullanıcısıysanız, R’a geçiş kesinlikle düşündüğünüzden daha kolay süreç olacaktır. Stata ve R arasında verilerin nasıl oluşturulabileceği, değiştirilebileceği ve ayrıca analizlerin nasıl yapılacağı konusunda bazı temel farklılıklar olsa bile bu temel farklılıkları öğrendikten sonra Stata becerilerinizi burada da kullabilirsiniz.\nAşağıda, bu kılavuzu incelerken kullanışlı olabilecek, Stata ve R arasındaki bazı önemli akışları bulabilirsiniz.\nGenel notlar\n\n\n\nSTATA\nR\n\n\n\n\nBir seferde yalnızca bir veri kümesi görüntülenip değiştirebilir.\nAynı anda birden fazla veri kümesi görüntülenip değiştirebilir, bu nedenle sık sık kod içinde veri kümesinin belirtilmesi gerekmektedir.\n\n\nÇevrimiçi topluluklara https://www.statalist.org/ sitesinden ulaşabilir.\nÇevrimiçi topluluklara RStudio, StackOverFlow, ve R-bloggers sitelerinden ulaşabilir.\n\n\nSeçenek olarak seç ve tıkla işlevi mevcut.\nMinimal düzeyde seç ve tıkla işlevi mevcut.\n\n\nhelp [command] koduyla komutlar hakkında yardımcı bilgilere ulaşabilir.\n[function]? kodu veya Yardım sekmesi ile komutlar hakkında yardımcı bilgilere ulaşabilir.\n\n\n* veya /// veya /* METİN */ seçeneklerini kullanarak kod yoruma çevirebilir.\n# kullanarak kod yoruma çevirebilir.\n\n\nHemen hemen tüm komutlar Stata’da yerleşiktir. Yeni/kullanıcı tarafından yazılan işlevler, ssc install [paket] kullanılarak ado dosyaları olarak kurulabilir.\nR, base fonksiyonlarla kurulur, ancak tipik kullanım, CRAN’dan diğer paketlerin kurulmasını içerir (R temelleri’ndeki sayfasına bakınız.)\n\n\nAnalizler genellikle bir do dosyasına yazılır\nAnalizler RStudio’daki kaynak bölmesine R dili ile yazılır. R markdown dili de alternatif olarak kullanılmaktadır.\n\n\n\nÇalışma dizini\n\n\n\nSTATA\nR\n\n\n\n\nÇalışma dizinleri mutlak dosya yollarını içerir (örneğin, “C:/username/documents/projects/data/”).\nÇalışma dizinleri, here paketi kullanılarak proje ana klasörüne veya başka alanlara aktarılabilir (bkz. İçe aktarma ve dışa aktarma).\n\n\npwd ile mevcut çalışma dizini görülebilir.\nBoş parantezlerle “getwd()” veya “here()” (here paketi kullanılıyorsa) kullanılır.\n\n\nÇalışma dizinini cd “klasör konumu” ile ayarlanabilir.\nsetwd(“klasör konumu”) veya set_here(\"klasör konumu) (here paketi kullanılıyorsa) kullanabilir.\n\n\n\nVerinin içe aktarılması ve görüntülenmesi\n\n\n\nSTATA\nR\n\n\n\n\nDosya türüne göre belirli komutlar mevcuttur.\nHemen hemen tüm dosya türleri için rio paketinden import() fonksiyonu kullanabilir. Alternatif olarak belirli fonksiyonlar da mevcuttur (bkz. İçe aktarma ve dışa aktarma).\n\n\ncsv dosyalarını okuma, import delimitied “dosyaadı.csv” komutuyla sağlanır.\nimport(\"filename.csv\") kullanılır.\n\n\nxlsx dosyalarını okuma, import excel “dosyaadı.xlsx” komutuyla sağlanır.\nimport(\"filename.xlsx\") kullanılır.\n\n\nbrowse komutunu kullanarak veriler yeni bir pencerede incelenebilir.\nView(dataset) kullanarak RStudio kaynak bölmesinde veri seti görüntülenebilir. Aynı anda birden fazla veri seti tutulabileceğinden, R’daki fonksiyona veri seti adının belirtilmesi gerekir. Bu fonksiyondaki büyük “V” harfine dikkat edilmeli.\n\n\nDeğişken adlarını ve temel bilgileri veren summarize kullanılarak veri kümesine ilişkin genel bir bakış elde edilebilir.\nsummary(dataset) fonksiyonu kullanılarak veri kümesine ilişkin genel bir bakış elde edilebilir.\n\n\n\nBasit veri manipülasyonu\n\n\n\nSTATA\nR\n\n\n\n\nVeri kümesi sütunlarına genellikle “değişkenler” denir.\nDaha sıklıkla “sütunlar” veya bazen “vektörler” veya “değişkenler” olarak anılır.\n\n\nVeri kümesini özellikle belirtmenize gerek yoktur.\nAşağıdaki komutların her birinde veri kümesinin belirtilmesi gerekir. Örnekler için Verileri temizleme ve temel fonksiyonlar sayfasına bakınız.\n\n\ngenerate varname = komutu kullanılarak yeni değişkenler oluşturulabilir.\nmutate(varname = ) fonksiyonu kullanılarak yeni değişkenler oluşturabilir. Bütün dplyr fonksiyonlarıyla ilgili ayrıntılar için Verileri temizleme ve temel fonksiyonlar sayfasına bakınız.\n\n\nDeğişkenler rename eski_adı yeni_adı komutuyla yeniden adlandırılabilir.\nSütunlar, rename(new_name = old_name) fonksiyonu kullanılarak yeniden adlandırılabilir.\n\n\nDeğişkenler drop varname kullanılarak kaldırılabilir.\nSütunlar, bir eksi işaretinin ardından parantez içinde sütun adı ile select() işlevi kullanılarak kaldırılabilir.\n\n\nFaktör değişkenleri, label define gibi bir dizi komut kullanılarak etiketlenebilir.\nDeğerleri etiketleme, sütunu Faktör sınıfına dönüştürerek ve seviyeler belirleyerek yapılabilir.(Faktörler ile ilgili sayfaya bakınız.) Sütun adları genellikle Stata’da olduğu gibi etiketlenmez.\n\n\n\nTanımlayıcı analiz\n\n\n\nSTATA\nR\n\n\n\n\ntab varname kullanarak bir değişkenin sayılarını tablo haline getirilebilir.\ntable() fonksiyonu için table(dataset$colname) koduyla veri kümesi ve sütunun adının sağlanması gerekmektedir. Alternatif olarak, Verileri gruplama bölümünde açıklandığı gibi dplyr paketindeki count(varname) fonksiyonu kullanabilir.\n\n\n2x2’lik bir tabloda iki değişkenin çapraz tablosu tab varname1 varname2 kodlarıyla oluşturulur.\ntable(dataset$varname1, dataset$varname2) veya count(varname1, varname2) fonksiyonları kullanabilir.\n\n\n\nBu liste, Stata komutlarını R’a çevirmenin temelleri hakkında bir genel bakış sunmakla birlikte ayrıntılı değildir. R’a geçiş yapan Stata kullanıcıları için ilgi çekici olabilecek başka birçok harika kaynak mevcuttur:\n\nhttps://dss.princeton.edu/training/RStata.pdf\n\nhttps://clanfear.github.io/Stata_R_Equivalency/docs/r_stata_commands.html\n\nhttp://r4stats.com/books/r4stata/",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>R'a geçiş</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.tr.html#sasdan-geçiş",
    "href": "new_pages/transition_to_R.tr.html#sasdan-geçiş",
    "title": "4  R’a geçiş",
    "section": "4.3 SAS’dan geçiş",
    "text": "4.3 SAS’dan geçiş\n\nSAS’dan R’a gelmek\nSAS, halk sağlığı kurumlarında ve akademik araştırma alanlarında yaygın olarak kullanılmaktadır. Yeni bir dile geçiş nadiren basit bir süreç olsa da, SAS ve R arasındaki temel farkları anlamak, ana dilinizde edindiğiniz tecrübeleri yeni dile aktarmakta yardımcı olabilir.\nAşağıda, SAS ve R arasındaki veri yönetimi ve tanımlayıcı analizdeki temel farklılıklar özetlenmektedir.\nGenel notlar\n\n\n\nSAS\nR\n\n\n\n\nÇevrimiçi topluluklara SAS Müşteri Hizmetlerisitesinden ulaşabilir.\nRStudio, StackOverFlow ve R-blogları aracılığıyla çevrimiçi topluluklara ulaşabilir.\n\n\nhelp [command] koduyla komutlar hakkında yardımcı bilgilere ulaşabilir.\n[function]? kodu veya Yardım sekmesi ile komutlar hakkında yardımcı bilgilere ulaşabilir.\n\n\n* METİN; /* veya /* METİN */ seçeneklerini kullanarak kodu yoruma çevirebilir.\n# kullanarak kodu yoruma çevirebilir.\n\n\nHemen hemen tüm komutlar yerleşiktir. Yeni/kullanıcı tarafından yazılan işlevler, SAS macro, SAS/IML, SAS Component Language (SCL); Proc Fcmp ve Proc Proto prosedürleri kullanılarak kurulabilir.\nR, base fonksiyonlarla kurulur, ancak tipik kullanım, CRAN’dan diğer paketlerin kurulmasını içerir (R temelleri’ndeki sayfasına bakınız.).\n\n\nAnaliz genellikle Editör penceresinde bir SAS programı yazılarak yapılır.\nAnalizler RStudio’daki kaynak bölmesine R dili ile yazılır. R markdown dili de alternatif olarak kullanılmaktadır.\n\n\n\nÇalışma dizini\n\n\n\nSAS\nR\n\n\n\n\nÇalışma dizinleri mutlak dosya yollarını içerir. Bunun dışında %let rootdir=/root path; %include “&rootdir/subfoldername/filename” kodu kullanarak başka alanlara kaydedilebilir.\nÇalışma dizinleri, here paketi kullanılarak proje ana klasörüne veya başka alanlara aktarılabilir (bkz. İçe aktarma ve dışa aktarma).\n\n\n%put %sysfunc(getoption(work)); ile mevcut çalışma dizinini görebilir.\nBoş parantezlerle “getwd()” veya “here()” (here paketi kullanılıyorsa) kullanılır.\n\n\nÇalışma dizinini libname “folder location” “klasör konumu” ile ayarlanabilir.\nsetwd(“klasör konumu”) veya set_here(\"klasör konumu) (here paketi kullanılıyorsa) kullanabilir.\n\n\n\nVerinin içe aktarılması ve görüntülenmesi\n\n\n\nSAS\nR\n\n\n\n\nProc Import prosedürünü veya Data Step Infile ifadesini kullanılır.\nHemen hemen tüm dosya türleri için rio paketinden import() fonksiyonu kullanabilir. Alternatif olarak belirli fonksiyonlar da mevcuttur (bkz. İçe aktarma ve dışa aktarma).\n\n\ncsv dosyalarını okuma, Proc Import datafile=”filename.csv” out=work.filename dbms=CSV kullanılarak yapılır; run; VEYA Data Step Infile Açıklaması kullanılabilir.\nimport(\"filename.csv\") kullanılır.\n\n\nxlsx dosyalarını okuma, Proc Import datafile=”filename.xlsx” out=work.filename dbms=xlsx kullanılarak yapılır; run; VEYA Data Step Infile Açıklaması kullanılabilir.\nimport(\"filename.xlsx\") kullanılır.\n\n\nGezgin penceresi açılarak veriler yeni bir pencerede incelenebilir; istenilen kitaplık ve veri kümesi seçilebilir.\nView(dataset) kullanarak RStudio kaynak bölmesinde veri seti görüntülenebilir. Aynı anda birden fazla veri seti tutulabileceğinden, R’daki fonksiyona veri seti adının belirtilmesi gerekir. Bu fonksiyondaki büyük “V” harfine dikkat edilmeli.\n\n\n\nBasit veri manipülasyonu\n\n\n\nSAS\nR\n\n\n\n\nVeri kümesi sütunlarına genellikle “değişkenler” denir.\nDaha sıklıkla “sütunlar” veya bazen “vektörler” veya “değişkenler” olarak anılır.\n\n\nVeri kümesini özellikle belirtmenize gerek yoktur. Yeni değişkenler, yalnızca yeni değişken adı, ardından eşittir işareti ve ardından değer için bir ifade yazılarak oluşturulur.\nmutate() fonksiyonu kullanılarak yeni değişkenler oluşturabilir. Bütün dplyr fonksiyonlarıyla ilgili ayrıntılar için Verileri temizleme ve temel fonksiyonlar sayfasına bakınız.\n\n\nDeğişkenler rename *old_name=new_name* komutuyla yeniden adlandırılabilir.\nSütunlar, rename(new_name = old_name) fonksiyonu kullanılarak yeniden adlandırılabilir.\n\n\nDeğişkenler **keep**=varname kullanılarak kullanılabilir.\nSütunlar, parantez içinde sütun adı ile select() işlevi kullanılarak seçilebilir.\n\n\nDeğişkenler **drop**=varname kullanılarak kaldırılabilir.\nSütunlar, bir eksi işaretinin ardından parantez içinde sütun adı ile select() işlevi kullanılarak kaldırılabilir.\n\n\nFaktör değişkenleri, Label ifadesi kullanılarak Veri Adımında etiketlenebilir.\nDeğerleri etiketleme, sütunu Faktör sınıfına dönüştürerek ve seviyeler belirleyerek yapılabilir.(Faktörler ile ilgili sayfaya bakınız.) Sütun adları genellikle etiketlenmez.\n\n\nKayıtlar, Veri Adımında Where veya If ifadesi kullanılarak seçilir. Çoklu seçim koşulları “and” komutu kullanılarak ayrılır.\nKayıtlar, VE operatörü (&) veya virgülle ayrılmış çoklu seçim koşullarıyla filter() fonksiyonu kullanılarak seçilir.\n\n\nVeri kümeleri, Veri Adımında Merge ifadesi kullanılarak birleştirilir. Birleştirilecek veri kümelerinin önce Proc Sort prosedürü kullanılarak sıralanması gerekmektedir.\ndplyr paketi, veri kümelerini birleştirmek için birkaç işlev sunar. Ayrıntılar için Verileri birleştirme sayfasına bakınız.\n\n\n\nTanımlayıcı analiz\n\n\n\n\n\n\n\nSAS\nR\n\n\n\n\nDeğişken adları ve açıklayıcı istatistikler sağlayan “Proc Summary” prosedürü kullanılarak veri kümesi hakkında üst düzey bir genel bakış elde edilebilir.\nskimr paketinden “summary(dataset)” veya “skim(dataset)” kullanılarak veri kümesine ilişkin üst düzey bir genel bakış elde edilebilir.\n\n\nproc freq data=Dataset; Tables varname; Run; komutu kullanılarak değişken sayıları tablo halinde özetlenebilir.\n\n\n\n\nTanımlayıcı tablolar ile ilgili sayfaya bakınız. Seçenekler arasında base R’den ‘table()’ ve janitor paketinden ‘tabyl()’ bulunmaktadır. R birden fazla veri kümesi içerdiği için veri kümesi ve sütun adının belirtilmesi gerekmektedir. 2x2’lik bir tabloda iki değişkenin çapraz tablosu proc freq data=Dataset; Tables rowvar*colvar; Run; komutuyla oluşturulabilir. | table(), tabyl() veya Tanımlayıcı tablolar sayfasında açıklandığı gibi diğer seçenekler kullanabilir.\nBirkaç değerli kaynak:\nR for SAS and SPSS Users (2011)\nSAS and R, Second Edition (2014)",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>R'a geçiş</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.tr.html#veri-formatları",
    "href": "new_pages/transition_to_R.tr.html#veri-formatları",
    "title": "4  R’a geçiş",
    "section": "4.4 Veri formatları",
    "text": "4.4 Veri formatları\n\nR rio paketinin, STATA .dta dosyaları, SAS .xpt ve.sas7bdat dosyaları, SPSS .por ve.sav dosyaları gibi dosyaları gibi pek çok dosyanın nasıl içe ve dışa aktarabileceğiyle ilgili ayrıntılar için [İçe ve dışa aktar] sayfasına bakınız.",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>R'a geçiş</span>"
    ]
  },
  {
    "objectID": "new_pages/packages_suggested.tr.html",
    "href": "new_pages/packages_suggested.tr.html",
    "title": "5  Önerilen paketler",
    "section": "",
    "text": "5.1 Packages from CRAN\n##########################################\n# Önemli epidemiyoloji R paketlerinin listesi #\n##########################################\n\n# Bu komut dosyası, pacman R paketindeki p_load() işlevini kullanır, \n# paket yoksa indirilir ve zaten kuruluysa kullanım için yüklenir\n\n\n# \"pacman\" paketinin kurulu olduğundan emin olur\nif (!require(\"pacman\")) install.packages(\"pacman\")\n\n\n# Packages available from CRAN\n##############################\npacman::p_load(\n     \n     # R'ı öğrenmek\n     ############\n     learnr,   # RStudio Eğitimi bölmesinde etkileşimli rehberler\n     swirl,    # R konsolunda etkileşimli rehberler\n        \n     # proje ve dosya yönetimi\n     #############################\n     here,     # R proje ana klasörüne göre dosya yönetimi\n     rio,      # birçok veri türünün içe/dışa aktarımı\n     openxlsx, # çok sayfalı Excel çalışma kitaplarını içe/dışa aktarma\n     \n     # paket kurulumu ve yönetimi\n     ################################\n     pacman,   # paket indirme/yükleme\n     renv,     # ekiple çalışırken paket sürümlerini yönetme\n     remotes,  # Github'dan indirme\n     \n     # Genel veri yönetimi\n     #########################\n     tidyverse,    # düzenli veri analizi ve sunumu için birçok paket içerir\n          #dplyr,      # data yönetimi\n          #tidyr,      # data yönetimi\n          #ggplot2,    # data gösterimi\n          #stringr,    # dizeler ve karakterlerle çalışma\n          #forcats,    # faktörlerle çalışma\n          #lubridate,  # tarihlerle çalışma\n          #purrr       # yineleme ve listelerle çalışma\n     linelist,     # satır listesini temizleme\n     naniar,       # eksik verilerin değerlendirilmesi\n     \n     # İstatistik  \n     ############\n     janitor,      # tablolar ve veri temizleme\n     gtsummary,    # tanımlayıcı ve istatistiksel tablolar hazırlama\n     rstatix,      # istatistiksel testleri ve özetleri hızla çalıştırma\n     broom,        # regresyonlardan elde edilen sonuçları düzenleme\n     lmtest,       # likelihood-ratio testleri\n     easystats,\n          # parameters, # regresyonlardan elde edilen sonuçları alternatif düzenleme\n          # see,        # forest plot'ları alternatif görseleştirme \n     \n     # epidemic modelleme\n     ###################\n     epicontacts,  # Transmisyon networklarını analiz etme\n     EpiNow2,      # Rt tahmini\n     EpiEstim,     # Rt tahmini\n     projections,  # İnsidans projeksiyonları\n     incidence2,   # Epidemiyolojik eğrileri yapma ve insidans verilerini işleme\n     i2extras,     # İnsidans2 paketi için ekstra fonksiyonlar\n     epitrix,      # Faydalı epidemiyoloji fonksiyonları\n     distcrete,    # Ayrık dağılımlar\n     \n     \n     # plots - genel\n     #################\n     #ggplot2,         # tidyverse içinde bulunmaktadır\n     cowplot,          # plotları birleştirme  \n     # patchwork,      # plotları birleştirme   (alternatif)     \n     RColorBrewer,     # renk skalaları\n     ggnewscale,       # ek renk katmanları ekleme\n\n     \n     # plots - özel türler\n     ########################\n     DiagrammeR,       # DOT dilini kullanan diyagramlar\n     incidence2,       # epidemic eğriler\n     gghighlight,      # bir alt kümeyi vurgulama\n     ggrepel,          # akıllı etiketler\n     plotly,           # interaktif grafikler\n     gganimate,        # animasyonlu grafikler \n\n     \n     # gis\n     ######\n     sf,               # Basit Özellik formatı kullanarak uzamsal verileri yönetme\n     tmap,             # Basit haritalar üretme (Hem etkileşimli hem de statik haritalar oluşturulabilir)\n     OpenStreetMap,    # ggplot haritasına OSM temel haritası ekleme\n     spdep,            # geografik istatistikler\n     \n     # rutin raporlar\n     #################\n     rmarkdown,        # PDF, Word, Powerpoint ve HTML dosyaları üretme\n     reportfactory,    # R Markdown çıktılarının otomatik organizasyonu\n     officer,          # powerpoint\n     \n     # kontrol paneli\n     ############\n     flexdashboard,    # R Markdown komut dosyasını bir gösterge panosuna dönüştürme\n     shiny,            # etkileşimli web uygulamaları\n     \n     # sunum için tablolar\n     #########################\n     knitr,            # R Markdown raporu oluşturma ve html tabloları\n     flextable,        # HTML tablolar\n     #DT,              # HTML tablolar (alternatif)\n     #gt,              # HTML tablolar (alternatif)\n     #huxtable,        # HTML tablolar (alternatif) \n     \n     # filogenetik\n     ###############\n     ggtree,           # ağaçların görselleştirilmesi ve açıklanması\n     ape,              # filogenetik ve evrim analizi\n     treeio            # filogenetik dosyaları görselleştirme\n \n)",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Önerilen paketler</span>"
    ]
  },
  {
    "objectID": "new_pages/packages_suggested.tr.html#github-paketleri",
    "href": "new_pages/packages_suggested.tr.html#github-paketleri",
    "title": "5  Önerilen paketler",
    "section": "5.2 Github paketleri",
    "text": "5.2 Github paketleri\nAşağıda, iki paketi doğrudan Github sunucularından indirmek için gerekli komutlar verilmiştir.\n\nepicontacts’ın geliştirme sürümü, zamansal bir x ekseni ile transmisyon ağaçları oluşturma özelliğini içermektedir.\nepirhandbook paketi bu el kitabı için tüm örnek verileri içermektedir. Bunun dışında el kitabının çevrimdışı sürümünü indirmek için kullanılabilir.\n\n\n# Github'dan indirilecek paketler (CRAN'da mevcut değildir)\n##########################################################\n\n# Epicontacts geliştirme versiyonu (x ekseni zamanına sahip transmisyon zincirleri icin)\npacman::p_install_gh(\"reconhub/epicontacts@timeline\")\n\n# Tüm örnek verileri de içeren bu el kitabının paketi\npacman::p_install_gh(\"appliedepi/epirhandbook\")",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Önerilen paketler</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.tr.html",
    "href": "new_pages/r_projects.tr.html",
    "title": "6  R projeleri",
    "section": "",
    "text": "6.1 Önerilen kullanım\nR’ı kullanmanın yaygın, verimli ve sorunsuz bir yolu bu 3 unsuru birleştirmektir. Herbir proje, bir R klasörü içinde barındırılmaktadır. İlgili başlıklar aşağıdaki bölümlerde açıklanmıştır.",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>R projeleri</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.tr.html#önerilen-kullanım",
    "href": "new_pages/r_projects.tr.html#önerilen-kullanım",
    "title": "6  R projeleri",
    "section": "",
    "text": "Bir R projesi\n\nVeriler, komut dosyaları, çıktılar vb. için ilgili klasörlerden oluşan bağımsız bir çalışma ortamı.\n\nAlternatif dosya yolakları için here paketi\n\nDosya yolakları, R projesinin ana klasörüne göre yazılır - daha fazla bilgi için İçe ve dışa aktar bölümüne bakınız.\n\n\nİçe/dışa aktarma için rio paketi\n\nimport() ve export(), herhangi bir dosya türünü uzantısına göre işler (ör. .csv, .xlsx, .png)",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>R projeleri</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.tr.html#bir-r-projesi-yaratma",
    "href": "new_pages/r_projects.tr.html#bir-r-projesi-yaratma",
    "title": "6  R projeleri",
    "section": "6.2 Bir R projesi yaratma",
    "text": "6.2 Bir R projesi yaratma\nBir R projesi oluşturmak için Dosya menüsünden “Yeni Proje” seçeneğini seçiniz.\n\nProje için yeni bir klasör oluşturmak istiyorsanız, “Yeni dizin”i seçin ve projenizin nerede oluşturulmasını istediğinizi belirtiniz.\n\nProjeyi mevcut bir klasör içinde oluşturmak istiyorsanız, “Mevcut dizin” seçeneğine tıklayıp ve klasörü belirtiniz.\n\nBir Github deposunu klonlamak istiyorsanız, üçüncü seçenek olan “Versiyon Kontrolü”nü seçip ve ardından “Git”i seçiniz. Daha fazla ayrıntı için Versiyon kontrolü, Git ve Github ile işbirliği hakkındaki sayfaya bakınız.\n\n\n\n\n\n\n\n\n\n\nR projesi, .Rproj dosyası içeren bir klasör şeklinde oluşturulacaktır. Bu dosya bir kısayoldur ve projenizi açmanın birincil yoludur. Dosya menüsünden “Projeyi Aç”ı seçerek de bir projeyi açabilirsiniz. Alternatif olarak, RStudio’nun en sağ üst tarafında bir R projesi simgesi ve mevcut R projelerinin açılır menüsünü göreceksiniz.\nBir R projesinden çıkmak için ya yeni bir proje açın ya da açık olan projeyi kapatınız (Dosya - Projeyi Kapat).\n\nProjeler arasında geçiş yapma\nProjeler arasında geçiş yapmak için, RStudio’nun sağ üst köşesindeki R projesi simgesini ve açılır menüyü tıklayınız. “Projeyi Kapat”, “Projeyi Aç” seçeneklerini ve son projelerin bir listesini göreceksiniz.\n\n\n\n\n\n\n\n\n\n\n\nAyarlar\nGenellikle RStudio’yu her seferinde “temiz bir sayfa” ile başlatmanız önerilmektedir - yani, çalışma alanınız önceki oturumunuzdan korunmamış olarak. Bu, nesnelerinizin ve çıktılarınızın oturumdan oturuma devam etmeyeceği anlamına gelir (komut dosyalarınızı çalıştırarak bunları yeniden oluşturmanız gerekmektedir). Bu iyi bir durumdur, çünkü sizi daha iyi komutlar yazmaya ve uzun vadede hatalardan kaçınmaya zorlayacaktır.\nRStudio’yu her açılışta “temiz bir sayfaya” sahip olacak şekilde ayarlamak için:\n\nAraçlar menüsünden “Proje Seçenekleri”ni seçiniz.\n“Genel” sekmesinde, RStudio’yu başlangıçta .RData’yı çalışma alanına geri yüklemeyecek ve çıkışta çalışma alanını .RData’ya kaydetmeyecek şekilde ayarlayınız.\n\n\n\nOrganizasyon\nProjenizde alt klasörlerin olması yaygın bir durumdur. “Veri”, “komut dosyaları”, “şekiller”, “sunular” gibi klasörleri oluşturabilirsiniz. Bilgisayarınız için yeni bir klasör eklediğiniz gibi proje alt klasörlerini ekleyebilirsiniz. Alternatif olarak, R komutlarıyla yeni klasörlerin nasıl oluşturulacağını öğrenmek için Dizin etkileşimleri hakkındaki sayfaya bakınız.\n\n\nVersiyon kontrolü\nProjelerinizde her zaman bir versiyon kontrol sistemi düşünmelisiniz. Komut dosyalarının adlarında (örneğin, “transmission_analysis_2020-10-03.R”) ve bir “arşiv” klasöründe tarihlerin eklenmesi gibi basit bir yöntemi kullanabilirsiniz. Ayrıca açıklama, etiketler, yazarlar ve değişiklik günlüğü ile her komut dosyasının üst kısmında yorumlar da ekleyebilirsiniz.\nDaha karmaşık bir yöntem, sürüm kontrolü için Github veya benzer bir platform kullanmayı içermektedir. Versiyon kontrolü, Git ve Github ile işbirliği hakkındaki sayfaya bakınız.\nBir ipucu olarak, “Dosyalarda Bul” aracını (Düzenle menüsü) kullanarak tüm projede veya klasörde arama yapabilmenizdir. Birden çok dosyada istediğiniz kelime/dizeleri arayabilir ve hatta değiştirebilirsiniz.",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>R projeleri</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.tr.html#örnekler",
    "href": "new_pages/r_projects.tr.html#örnekler",
    "title": "6  R projeleri",
    "section": "6.3 Örnekler",
    "text": "6.3 Örnekler\nAşağıda, bir R projesi içinden here() fonksiyonunu kullanarak bazı içe/dışa aktarma/kaydetme örnekleri verilmiştir. İçe ve dışa aktar sayfasında here paketinin kullanımı hakkında daha fazla bilgi edinebilirsiniz.\nR projenizdeki “data” klasöründen linelist_raw.xlsx dosyasını içe aktarın\n\nlinelist &lt;- import(here(\"data\", \"linelist_raw.xlsx\"))\n\nR projenizdeki “data” klasörü içindeki “clean” klasörüne, R nesnesi ’linelist’i, “my_linelist.rds” olarak dışa aktarın.\n\nexport(linelist, here(\"data\",\"clean\", \"my_linelist.rds\"))\n\nEn son yazdırılan grafiği, R projenizdeki “outputs” klasöründeki “epicurves” klasörüne “epicurve_2021-02-15.png” olarak kaydedin.\n\nggsave(here(\"outputs\", \"epicurves\", \"epicurve_2021-02-15.png\"))",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>R projeleri</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.tr.html#kaynaklar",
    "href": "new_pages/r_projects.tr.html#kaynaklar",
    "title": "6  R projeleri",
    "section": "6.4 Kaynaklar",
    "text": "6.4 Kaynaklar\nRStudio web sayfası - R projelerini kullanma",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>R projeleri</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.tr.html",
    "href": "new_pages/importing.tr.html",
    "title": "7  İçe ve dışa aktar",
    "section": "",
    "text": "7.1 Genel Bakış\nBir “veri kümesini” R’ı içe aktardığınızda, genellikle R ortamınızda yeni bir veri çerçevesi nesnesi yaratır ve onu klasör dizinlerinizde bulunan içe aktarılmış bir dosya (örn. Excel, CSV, TSV, RDS) olarak belirli bir dosya yolu/adresini tanımlamış olursunuz.\nDiğer istatistiksel programlar (SAS, STATA, SPSS) tarafından oluşturulanlar da dahil olmak üzere birçok dosya türünü içe/dışa aktarabilirsiniz. Ayrıca ilişkisel veritabanlarına da bağlanabilirsiniz.\nR’ın kendi veri biçimleri bile vardır:",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>İçe ve dışa aktar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.tr.html#genel-bakış",
    "href": "new_pages/importing.tr.html#genel-bakış",
    "title": "7  İçe ve dışa aktar",
    "section": "",
    "text": "Bir RDS dosyası (.rds), veri çerçevesi gibi tek bir R nesnesini depolar. Bunlar, R sütun sınıflarını korudukları için temizlenmiş verileri depolamak için kullanışlıdır. Bu bölümde daha fazlasını okuyabilirsiniz.\nBir RData dosyası (.Rdata), birden çok nesneyi veya hatta eksiksiz bir R çalışma alanını depolamak için kullanılabilir. Bu bölümde daha fazlasını okuyabilirsiniz.",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>İçe ve dışa aktar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.tr.html#rio-paketi",
    "href": "new_pages/importing.tr.html#rio-paketi",
    "title": "7  İçe ve dışa aktar",
    "section": "7.2 rio paketi",
    "text": "7.2 rio paketi\nÖnerdiğimiz R paketi: rio. “Rio” adı, “R I/O” (girdi-input/çıktı-output) ifadesinin kısaltmasıdır.\nimport() ve export() fonksiyonları birçok farklı dosya türünü (örneğin .xlsx, .csv, .rds, .tsv) işleyebilir. Bu fonksiyonlardan herhangi birine (“.csv” gibi dosya uzantısı dahil) bir dosya yolu sağladığınızda, rio uzantıyı okuyacak ve dosyayı içe veya dışa aktarmak için doğru aracı kullanacaktır.\nrio kullanmanın alternatifi, her biri bir dosya türüne özgü olan diğer birçok paketin fonksiyonunu kullanmaktır. Örneğin, ‘read.csv()’ (base R), ‘read.xlsx()’ (openxlsx paketi) ve ‘write_csv()’ (readr paketi), vb. Bu alternatifleri hatırlamak zor olabilir, oysa rio’dan import() ve export() kullanmak kolaydır.\nrio’nun import() ve export() fonksiyonları, dosya uzantısına bağlı olarak belirli bir dosya için uygun paketi ve fonksiyonu kullanır. rio’nun arka planda kullandığı paketlerin/fonksiyonların tam bir tablosu için bu sayfanın sonuna bakabilirsiiniz. Düzinelerce başka dosya türü arasından STATA, SAS ve SPSS dosyalarını içe aktarmak için de kullanılabilir.\nŞekil dosyalarının içe/dışa aktarımı, GIS temelleri sayfasında ayrıntılı olarak açıklandığı gibi başka paketler gerektirir.",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>İçe ve dışa aktar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.tr.html#here",
    "href": "new_pages/importing.tr.html#here",
    "title": "7  İçe ve dışa aktar",
    "section": "7.3 here paketi",
    "text": "7.3 here paketi\nhere paketi ve ‘here()’ fonksiyonu, R’a dosyalarınızı nerede bulacağını ve kaydedeceğini söylemeyi kolaylaştırır - özünde, dosya yolları oluşturur.\nBir R projesiyle birlikte kullanıldığında here, R projenizdeki dosyaların konumunu R projesinin kök dizini (en üst düzey klasör) ile ilişkili olarak tanımlamanıza olanak tanır. Bu, R projesinin birden fazla kişi/bilgisayar tarafından paylaşılabildiği veya erişilebildiği durumlarda kullanışlıdır. Dosya yolunu tüm kullanıcılar için ortak bir yerde (R proje kökü) “başlatarak”, farklı bilgisayarlardaki benzersiz dosya yollarından (ör. “C:/Users/Laura/Documents…”) kaynaklanan komplikasyonları önler.\nBir R projesinde “here()” şu şekilde çalışır:\n\nhere paketi R projesine ilk yüklendiğinde, “.here” adlı küçük bir dosyayı R projenizin kök klasörüne “benchmark” veya “anchor” olarak yerleştirir.\nKomut dosyalarınızda, R projesinin alt klasörlerindeki bir dosyaya referans vermek için, dosya yolunu oluşturmak için ‘here()’ fonksiyonunu kullanırsınız bu bağlantıya göre\nDosya yolunu oluşturmak için, klasör adlarını kökün ötesinde, tırnak işaretleri içinde, virgülle ayırarak ve son olarak aşağıda gösterildiği gibi dosya adı ve dosya uzantısı ile bitecek şekilde yazın.\nhere() dosya yolları hem içe hem dışa aktarma için kullanılabilir\n\nÖrneğin, aşağıda, “import()” fonksiyonuna “here()” ile oluşturulmuş bir dosya yolu sağlanmaktadır.\n\nlinelist &lt;- import(here(\"data\", \"linelists\", \"ebola_linelist.xlsx\"))\n\nhere(\"data\", \"linelists\", \"ebola_linelist.xlsx\") komutu aslında kullanıcının bilgisayarına özgü olan tam dosya yolunu sağlar*:\n\"C:/Users/Laura/Documents/my_R_project/data/linelists/ebola_linelist.xlsx\"\nİşin güzel yanı, ‘here()’ kullanan R komutunun, R projesine erişen herhangi bir bilgisayarda başarılı bir şekilde çalıştırılabilmesidir.\nTIP: “.here” kökünün nereye ayarlandığından emin değilseniz, boş parantezlerle ‘here()’ fonksiyonunu çalıştırın.\nhere paketi hakkında bu bağlantıdan daha fazlasını okuyabilirsiniz.",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>İçe ve dışa aktar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.tr.html#dosya-yolları",
    "href": "new_pages/importing.tr.html#dosya-yolları",
    "title": "7  İçe ve dışa aktar",
    "section": "7.4 Dosya yolları",
    "text": "7.4 Dosya yolları\nVerileri içe veya dışa aktarırken bir dosya yolu sağlamanız gerekir. Bunu üç yoldan biriyle yapabilirsiniz:\n\nÖnerilen: here paketiyle “ilişkili” bir dosya yolu sağlayın\n“tam” / “mutlak” dosya yolunu sağlayın\nManuel dosya seçimi\n\n\n“İlişkili” dosya yolları\nR’da, “ilişkili” dosya yolları, bir R projesinin köküne ilişkili olan dosya yolundan oluşur. Farklı bilgisayarlarda çalışabilen daha basit dosya yollarına izin verirler (örneğin, R projesi paylaşılan bir sürücüdeyse veya e-postayla gönderiliyorsa). Yukarıda açıklandığı gibi, göreli dosya yolları here paketi kullanılarak kolaylaştırılır.\n‘here()’ ile oluşturulmuş ilişkili bir dosya yolu örneği aşağıdadır. Çalışmanın, bir “veri” alt klasörü içeren bir R projesinde olduğunu ve bunun içinde, .xlsx dosyasının bulunduğu bir “çizgi listeleri” alt klasöründe olduğunu varsayıyoruz.\n\nlinelist &lt;- import(here(\"data\", \"linelists\", \"ebola_linelist.xlsx\"))\n\n\n\n“Mutlak” dosya yolları\nimport() gibi fonksiyonlar için mutlak veya “tam” dosya yolları sağlanabilir, ancak bunlar kullanıcının özel bilgisayarına özgü olduğundan “kırılgandır” ve bu nedenle önerilmez.\nAşağıda, Laura’nın bilgisayarında bir “analiz” klasörü, bir “veri” alt klasörü ve bunun içinde, ilgilenilen .xlsx dosyasının bulunduğu bir alt klasör “satır listeleri” bulunan bir mutlak dosya yolu örneği verilmiştir. .\n\nlinelist &lt;- import(\"C:/Users/Laura/Documents/analysis/data/linelists/ebola_linelist.xlsx\")\n\nMutlak dosya yolları hakkında dikkat edilmesi gereken birkaç nokta:\n\nMutlak dosya yollarını kullanmaktan kaçının çünkü komut dosyası farklı bir bilgisayarda çalıştırılırsa bozulurlar\nYukarıdaki örnekte olduğu gibi ileri eğik çizgi (/) kullanın (not: bu, Windows dosya yolları için varsayılan DEĞİLDİR)\nÇift eğik çizgiyle başlayan dosya yolları (ör. “//…”) büyük olasılıkla R tarafından tanınmayacak ve bir hata üretecektir. Çalışmanızı bir harfle başlayan “adlandırılmış” veya “harfli” bir sürücüye taşımayı düşünün (ör. “J:” veya “C:”). Bu sorunla ilgili daha fazla ayrıntı için Dizin etkileşimleri hakkındaki sayfaya bakabilirsiniz.\n\nMutlak dosya yollarının uygun olabileceği bir senaryo, tüm kullanıcılar için aynı tam dosya yoluna sahip bir paylaşılan sürücüden bir dosyayı içe aktarmak istediğiniz zamandır.\nİPUCU: Tüm \\ işaretlerini / biçimine hızlı bir şekilde dönüştürmek için ilgili kodu vurgulayın, Ctrl+f (Windows’ta) kullanın, “In selection” seçenek kutusunu işaretleyin ve ardından bunları dönüştürmek için değiştirme fonksiyonunu kullanın.\n\n\n\nDosyayı manuel olarak seçin\nAşağıdaki yöntemlerden birini kullanarak verileri manuel olarak içe aktarabilirsiniz:\n\nOrtam RStudio Bölmesi, “Veri Kümesini İçe Aktar”a tıklayın ve veri türünü seçin\nDosya / Veri Kümesini İçe Aktar / (veri türünü seçin) öğesine tıklayın.\nManuel seçimi sabit kodlamak amacıyla, kullanıcının manuel olarak bilgisayarından dosya seçmesine izin veren bir açılır pencere görünümünü tetiklemek için temel R file.choose() komutunu (parantezleri boş bırakarak) kullanın. Örneğin:\n\n\n# Bir dosyanın manuel seçimi. Bu komut çalıştırıldığında bir POP-UP penceresi görünecektir.\n# Seçilen dosya yolu import() komutunu sağlayacaktır.\n\nmy_data &lt;- import(file.choose())\n\nİPUCU: Açılır pencere RStudio pencerenizin ARDINDA görünebilir.",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>İçe ve dışa aktar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.tr.html#verileri-içe-aktar",
    "href": "new_pages/importing.tr.html#verileri-içe-aktar",
    "title": "7  İçe ve dışa aktar",
    "section": "7.5 Verileri içe aktar",
    "text": "7.5 Verileri içe aktar\nBir veri kümesini içe aktarmak için import() kullanmak oldukça basittir. Dosyanın yolunu (dosya adı ve dosya uzantısı dahil) tırnak içinde belirtmeniz yeterlidir. Dosya yolunu oluşturmak için “here()” kullanılıyorsa, yukarıdaki talimatları izleyebilirsiniz. Aşağıda birkaç örnek verilmiştir:\n“Çalışma dizininizde” veya R projesi kök klasöründe bulunan bir csv dosyasını içe aktarma:\n\nlinelist &lt;- import(\"linelist_cleaned.csv\")\n\nR projesinin (here() kullanılarak oluşturulan dosya yolu) “veri” ve “çizgi listeleri” alt klasörlerinde bulunan bir Excel çalışma kitabının ilk sayfasını içe aktarma:\n\nlinelist &lt;- import(here(\"data\", \"linelists\", \"linelist_cleaned.xlsx\"))\n\nMutlak bir dosya yolu kullanarak bir veri çerçevesini (bir .rds dosyası) içe aktarma:\n\nlinelist &lt;- import(\"C:/Users/Laura/Documents/tuberculosis/data/linelists/linelist_cleaned.rds\")\n\n\nBelirli Excel sayfaları\nVarsayılan olarak, import() dosyasına bir Excel çalışma kitabı (.xlsx) sağlarsanız, çalışma kitabının ilk sayfası içe aktarılacaktır. Belirli bir sayfayı içe aktarmak istiyorsanız, sayfa adını which = değişkenine ekleyin. Örneğin:\n\nmy_data &lt;- import(\"my_excel_file.xlsx\", which = \"Sheetname\")\n\n“import()” ile ilişkili bir yol sağlamak için “here()” yöntemini kullanıyorsanız, “here()” fonksiyonunu kapanış parantezlerinden sonra “which =” değişkenine ekleyerek belirli bir sayfayı yine de belirtebilirsiniz.\n\n# Gösteri: 'here' paketiyle ilgili yolları kullanırken belirli bir Excel sayfasını içe aktarma\nlinelist_raw &lt;- import(here(\"data\", \"linelist.xlsx\"), which = \"Sheet1\")`  \n\nBir veri çerçevesini R’dan belirli bir Excel sayfasına dışa aktarmak ve Excel çalışma kitabının geri kalanının değişmeden kalmasını sağlamak için, bu amaca yönelik openxlsx gibi alternatif bir paketle içe aktarmanız, düzenlemeniz ve dışa aktarmanız gerekir. . Dizin etkileşimleri sayfasındaki veya bu github sayfasındaki daha fazla bilgiye bakabilirsiniz.\nExcel çalışma kitabınız .xlsb (ikili biçimli Excel çalışma kitabı) ise rio kullanarak içe aktaramayabilirsiniz. .xlsx olarak yeniden kaydetmeyi veya bu amaç için oluşturulmuş readxlsb gibi bir paket kullanmayı düşünebilirsiniz.\n\n\n\nEksik değerler\nVeri kümenizdeki hangi değer(ler)in eksik olarak kabul edilmesi gerektiğini belirlemek isteyebilirsiniz. Eksik veri sayfasında açıklandığı gibi, R’daki eksik veriler için değer `NA’dır, ancak belki de içe aktarmak istediğiniz veri kümesi bunun yerine 99, “Eksik” veya yalnızca boş karakter alanı “” kullanır.\n‘import()’ için ‘na =’ bağımsız değişkenini kullanın ve değer(ler)i tırnak işaretleri içinde sağlayın (sayı olsalar bile). Aşağıda gösterildiği gibi c() kullanarak bunları bir vektöre dahil ederek birden çok değer belirtebilirsiniz.\nBurada, içe aktarılan veri kümesindeki “99” değeri eksik olarak kabul edilir ve R’da “NA”ya dönüştürülür.\n\nlinelist &lt;- import(here(\"data\", \"my_linelist.xlsx\"), na = \"99\")\n\nBurada, içe aktarılan veri kümesindeki “Eksik”, “” (boş hücre) veya ” ” (tek boşluk) değerlerinden herhangi biri R’da “NA”ya dönüştürülür.\n\nlinelist &lt;- import(here(\"data\", \"my_linelist.csv\"), na = c(\"Missing\", \"\", \" \"))\n\n\n\n\nSatırları atla\nBazen bir veri satırını içe aktarmaktan kaçınmak isteyebilirsiniz. Bir .xlsx veya .csv dosyasında rio’dan import() kullanıyorsanız bunu skip = değişkeniyle yapabilirsiniz. Atlamak istediğiniz satır sayısını belirtin.\n\nlinelist_raw &lt;- import(\"linelist_raw.xlsx\", skip = 1)  # does not import header row\n\nNe yazık ki skip= yalnızca bir tamsayı değeri kabul eder, bir aralık kabul etmez (ör. “2:10” çalışmaz). Üstten ardışık olmayan belirli satırların içe aktarımını atlamak için, birden çok kez içe aktarmayı ve dplyr’den bind_rows() kullanmayı düşünün. Yalnızca 2. satırı atlamayla ilgili aşağıdaki örneğe bakın.\n\n\nİkinci bir başlık satırını yönetin\nBazen, aşağıda gösterildiği gibi bir “veri sözlüğü” satırıysa verileriniz bir saniye satırı olabilir. Bu durum sorunlu olabilir, çünkü tüm sütunların “karakter” sınıfı olarak içe aktarılmasına neden olabilir.\nAşağıda bu tür bir veri kümesi örneği verilmiştir (ilk satır veri sözlüğüdür).\n\n\n\n\n\n\n\nİkinci başlık satırını kaldırın\nİkinci başlık satırını bırakmak için büyük olasılıkla verileri iki kez içe aktarmanız gerekecektir.\n\nDoğru sütun adlarını saklamak için verileri içe aktarın\nİlk iki satırı (başlık ve ikinci satır) atlayarak verileri tekrar içe aktarın\nDoğru adları azaltılmış veri çerçevesine bağlayın\n\nDoğru sütun adlarını bağlamak için kullanılan tam bağımsız değişken, veri dosyasının türüne (.csv, .tsv, .xlsx, vb.) bağlıdır. Bunun nedeni, rio’nun farklı dosya türleri için farklı bir fonksiyon kullanmasıdır (yukarıdaki tabloya bakın).\nExcel dosyaları için: (col_names =)\n\n# ilk kez içe aktarma; sütun adlarını sakla\nlinelist_raw_names &lt;- import(\"linelist_raw.xlsx\") %&gt;% names()  # gerçek sütun adlarını kaydet\n\n# ikinci kez içe aktar; 2. satırı atlayın ve sütun adlarını col_names = değişkenine atayın\nlinelist_raw &lt;- import(\"linelist_raw.xlsx\",\n                       skip = 2,\n                       col_names = linelist_raw_names\n                       ) \n\nCSV dosyaları için: (col.names =)\n\n# ilk kez içe aktarma; sütun adlarını depola\nlinelist_raw_names &lt;- import(\"linelist_raw.csv\") %&gt;% names() # gerçek sütun adlarını kaydet\n\n# csv dosyaları için not değişkeni 'col.names =' şeklindedir\nlinelist_raw &lt;- import(\"linelist_raw.csv\",\n                       skip = 2,\n                       col.names = linelist_raw_names\n                       ) \n\nYedekleme seçeneği - sütun adlarını ayrı bir komut olarak değiştirme\n\n# temel 'colnames()' fonksiyonunu kullanarak başlıkları ata/üzerine yaz\ncolnames(linelist_raw) &lt;- linelist_raw_names\n\n\n\nVeri sözlüğü oluşturun\nBonus! Veri sözlüğü olan ikinci bir satırınız varsa, ondan kolayca uygun bir veri sözlüğü oluşturabilirsiniz. Bu ipucu bu post’dan uyarlanmıştır.\n\ndict &lt;- linelist_2headers %&gt;%             # başla: ilk satır olarak sözlük içeren satır listesi\n  head(1) %&gt;%                             # yalnızca sütun adlarını ve ilk sözlük satırını tut                \n  pivot_longer(cols = everything(),       # tüm sütunları uzun biçime döndür\n               names_to = \"Column\",       # yeni sütun adları atayın\n               values_to = \"Description\")\n\n\n\n\n\n\n\n\n\nİki başlık satırını birleştirin\nBazı durumlarda, ham veri kümenizde iki başlık satırı varsa (veya daha spesifik olarak, 2. veri satırı ikincil bir başlıktır), bunları “birleştirmek” veya ikinci başlık satırındaki değerleri ilk başlığa eklemek isteyebilirsiniz.\nAşağıdaki komut, veri çerçevesinin sütun adlarını, hemen altındaki (ilk satırdaki) değerle ilk (doğru) başlıkların birleşimi (birlikte yapıştırarak) olarak tanımlayacaktır.\n\nnames(my_data) &lt;- paste(names(my_data), my_data[1, ], sep = \"_\")\n\n\n\n\n\nGoogle sayfaları\ngooglesheet4 paketiyle ve e-tabloya erişiminizi doğrulayarak çevrimiçi bir Google e-tablosundan veri aktarabilirsiniz.\n\npacman::p_load(\"googlesheets4\")\n\nAşağıda, bir demo Google sayfası içe aktarılır ve kaydedilir. Bu komut, Google hesabınızın kimlik doğrulamasının onaylanmasını isteyebilir. Tidyverse API paketlerine Google Drive’da e-tablolarınızı düzenleme, oluşturma ve silme izinleri vermek için internet tarayıcınızdaki istemleri ve açılır pencereleri izleyin.\nAşağıdaki sayfa “bağlantıya sahip olan herkes tarafından görüntülenebilir” ve onu içe aktarmayı deneyebilirsiniz.\n\nGsheets_demo &lt;- read_sheet(\"https://docs.google.com/spreadsheets/d/1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY/edit#gid=0\")\n\nSayfa, yalnızca URL’nin daha kısa bir parçası olan sayfa kimliği kullanılarak da içe aktarılabilir:\n\nGsheets_demo &lt;- read_sheet(\"1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY\")\n\nBaşka bir paket olan googledrive, Google sayfalarını yazmak, düzenlemek ve silmek için kullanışlı fonksiyonlar sunar. Örneğin, bu pakette bulunan gs4_create() ve sheet_write() fonksiyonları kullanılabilir.\nİşte diğer bazı yararlı çevrimiçi eğitimler: temel Google sayfaları içe aktarma öğreticisi daha ayrıntılı eğitim googlesheets4 ve tidyverse arasındaki etkileşim",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>İçe ve dışa aktar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.tr.html#birden-çok-dosya---içe-aktarma-dışa-aktarma-bölme-birleştirme",
    "href": "new_pages/importing.tr.html#birden-çok-dosya---içe-aktarma-dışa-aktarma-bölme-birleştirme",
    "title": "7  İçe ve dışa aktar",
    "section": "7.6 Birden çok dosya - içe aktarma, dışa aktarma, bölme, birleştirme",
    "text": "7.6 Birden çok dosya - içe aktarma, dışa aktarma, bölme, birleştirme\nBirden çok dosyanın veya birden çok Excel çalışma kitabı dosyasının nasıl içe aktarılacağına ve birleştirileceğine ilişkin örnekler için Yineleme, döngüler ve listeler hakkındaki sayfaya bakın. Bu sayfada ayrıca bir veri çerçevesinin parçalara nasıl bölüneceği ve her birinin ayrı ayrı veya bir Excel çalışma kitabında adlandırılmış sayfalar olarak nasıl dışa aktarılacağına ilişkin örnekler de vardır.",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>İçe ve dışa aktar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.tr.html#import_github",
    "href": "new_pages/importing.tr.html#import_github",
    "title": "7  İçe ve dışa aktar",
    "section": "7.7 Github’dan içe aktar",
    "text": "7.7 Github’dan içe aktar\nVerileri doğrudan Github’dan R’a aktarmak çok kolay olabilir veya dosya türüne bağlı olarak birkaç adım gerektirebilir. Aşağıda bazı yaklaşımlar yer almaktadır:\n\nCSV dosyaları\nBir .csv dosyasını bir R komutuyla doğrudan Github’dan R’a aktarmak kolay olabilir.\n\nGithub deposuna gidin, ilgilendiğiniz dosyayı bulun ve üzerine tıklayın.\n“Raw” düğmesine tıklayın (daha sonra aşağıda gösterildiği gibi “ham” csv verilerini göreceksiniz)\nURL’yi kopyalayın (web adresi)\nURL’yi import() R komutu içinde tırnak içine alın\n\n\n\n\n\n\n\n\n\n\n\n\nXLSX dosyaları\nBazı dosyalar için “Ham” verileri görüntüleyemeyebilirsiniz (ör. .xlsx, .rds, .nwk, .shp)\n\nGithub deposuna gidin, ilgilendiğiniz dosyayı bulun ve üzerine tıklayın.\nAşağıda gösterildiği gibi “İndir” düğmesini tıklayın\nDosyayı bilgisayarınıza kaydedin ve R’a alın\n\n\n\n\n\n\n\n\n\n\n\n\nŞekil dosyaları (Shapefiles)\nŞekil dosyaları, her biri farklı bir dosya uzantısına sahip birçok alt bileşen dosyasına sahiptir. Bir dosya “.shp” uzantısına sahip olacaktır, ancak diğerleri “.dbf”, “.prj” vb. uzantılara sahip olabilir. Github’dan bir şekil dosyası indirmek için, alt bileşen dosyalarının her birini ayrı ayrı indirmeniz ve kaydetmeniz gerekir. bunları bilgisayarınızdaki aynı klasöre yerleştirin. Github’da her dosyaya tek tek tıklayın ve “İndir” butonuna tıklayarak indirin.\nBilgisayarınıza kaydettikten sonra, sf paketinden st_read() kullanarak şekil dosyasını GIS temel bilgileri sayfasında gösterildiği gibi içe aktarabilirsiniz. Diğer ilgili dosyalar bilgisayarınızda aynı klasörde olduğu sürece yalnızca “.shp” dosyasının dosya yolunu ve adını sağlamanız gerekir.\nAşağıda, “sle_adm3” şekil dosyasının her biri Github’dan indirilmesi gereken birçok dosyadan nasıl oluştuğunu görebilirsiniz.",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>İçe ve dışa aktar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.tr.html#manuel-veri-girişi",
    "href": "new_pages/importing.tr.html#manuel-veri-girişi",
    "title": "7  İçe ve dışa aktar",
    "section": "7.8 Manuel veri girişi",
    "text": "7.8 Manuel veri girişi\n\nSatırlara göre giriş\ntidyverse’deki tibble paketindeki ‘tribble’ fonksiyonunu kullanın (çevrimiçi tibble referansı).\nSütun başlıklarının nasıl tilde (~) ile başladığına dikkat edin. Ayrıca her sütunun yalnızca bir veri sınıfı (karakter, sayısal vb.) içermesi gerektiğini unutmayın. Veri girişini daha sezgisel ve okunabilir hale getirmek için sekmeleri, boşlukları ve yeni satırları kullanabilirsiniz. Değerler arasında boşluklar önemli değildir, ancak her satır yeni bir kod satırı ile temsil edilir. Örneğin:\n\n# veri kümesini satıra göre manuel olarak oluşturun\nmanual_entry_rows &lt;- tibble::tribble(\n  ~colA, ~colB,\n  \"a\",   1,\n  \"b\",   2,\n  \"c\",   3\n  )\n\nVe şimdi yeni veri setini görüntülüyoruz:\n\n\n\n\n\n\n\n\nSütunlara göre giriş\nBir veri çerçevesi vektörlerden (dikey sütunlardan) oluştuğu için, R’da manuel veri çerçevesi oluşturmaya yönelik temel yaklaşım, her sütunu tanımlamanızı ve ardından bunları birbirine bağlamanızı bekler. Bu, genellikle verilerimizi satırlar halinde düşündüğümüzden (yukarıdaki gibi) epidemiyolojide mantıksız olabilir.\n\n# her vektörü (dikey sütun) ayrı ayrı tanımlayın, her biri kendi adıyla\nPatientID &lt;- c(235, 452, 778, 111)\nTreatment &lt;- c(\"Yes\", \"No\", \"Yes\", \"Yes\")\nDeath     &lt;- c(1, 0, 1, 0)\n\nUYARI: Tüm vektörler aynı uzunlukta olmalıdır (aynı sayıda değer).\nVektörler daha sonra “data.frame()” fonksiyonu kullanılarak birbirine bağlanabilir:\n\n# vektör adlarına başvurarak sütunları bir veri çerçevesinde birleştirin\nmanual_entry_cols &lt;- data.frame(PatientID, Treatment, Death)\n\nVe şimdi yeni veri setini görüntülüyoruz.\n\n\n\n\n\n\n\n\nPanodan yapıştırma\nVerileri başka bir yerden kopyalar ve panonuzda bulundurursanız, aşağıdaki iki yoldan birini deneyebilirsiniz:\nclipr paketinden, veri çerçevesi olarak içe aktarmak için ‘read_clip_tbl()’ veya bir karakter vektörü olarak içe aktarmak için sadece ‘read_clip()’ kullanabilirsiniz. Her iki durumda da parantezleri boş bırakın.\n\nlinelist &lt;- clipr::read_clip_tbl()  # mevcut panoyu veri çerçevesi olarak içe aktarır\nlinelist &lt;- clipr::read_clip()      # karakter vektörü olarak içe aktar\n\nAyrıca clipr ile sisteminizin panosuna kolayca aktarabilirsiniz. Aşağıdaki dışa aktarma bölümüne bakın.\nAlternatif olarak, veri çerçevesi olarak içe aktarmak için base R’dan file = \"clipboard\") read.table() fonksiyonunu kullanabilirsiniz:\n\ndf_from_clipboard &lt;- read.table(\n  file = \"clipboard\",  # bunu \"pano\" olarak belirtin\n  sep = \"t\",           # ayırıcı sekme veya virgül vb. olabilir.\n  header=TRUE)         # bir başlık satırı varsa",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>İçe ve dışa aktar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.tr.html#en-son-dosyayı-içe-aktar",
    "href": "new_pages/importing.tr.html#en-son-dosyayı-içe-aktar",
    "title": "7  İçe ve dışa aktar",
    "section": "7.9 En son dosyayı içe aktar",
    "text": "7.9 En son dosyayı içe aktar\nGenellikle veri kümeleriniz için günlük güncellemeler alabilirsiniz. Bu durumda, en son dosyayı içe aktaran bir kod yazmak isteyeceksiniz. Aşağıda buna yaklaşmanın iki yolunu sunuyoruz:\n\nDosya adındaki tarihe göre dosya seçimi\nDosya meta verilerine göre dosya seçimi (son değişiklik)\n\n\nDosya adındaki tarihler\nBu yaklaşım üç öncüle bağlıdır:\n\nDosya adlarındaki tarihlere güveniyorsunuz\nTarihler sayısaldır ve genellikle aynı biçimde görünür (ör. yıl sonra ay sonra gün)\nDosya adında başka numara yok\n\nHer adımı açıklayacağız ve sonunda size bunların birleştirilmiş halini göstereceğiz.\nİlk olarak, ilgilenilen klasördeki her dosya için yalnızca dosya adlarını çıkarmak için base R’dan dir() kullanın. ‘dir()’ hakkında daha fazla ayrıntı için Dizin etkileşimleri sayfasına bakın. Bu örnekte, ilgilenilen klasör, R projesi içindeki “data” içindeki “example” klasörü içindeki “linelists” klasörüdür.\n\nlinelist_filenames &lt;- dir(here(\"data\", \"example\", \"linelists\")) # klasörden dosya isimlerini al\nlinelist_filenames                                              # yazdır\n\n[1] \"20201007linelist.csv\"          \"case_linelist_2020-10-02.csv\" \n[3] \"case_linelist_2020-10-03.csv\"  \"case_linelist_2020-10-04.csv\" \n[5] \"case_linelist_2020-10-05.csv\"  \"case_linelist_2020-10-08.xlsx\"\n[7] \"case_linelist20201006.csv\"    \n\n\nBu ad vektörüne sahip olduğunuzda, bu normal ifadeyi kullanarak stringr’den str_extract() uygulayarak tarihleri çıkarabilirsiniz. Dosya adındaki herhangi bir sayıyı çıkarır (ortadaki tire veya eğik çizgi gibi diğer karakterler dahil). Dizeler ve karakterler sayfasında stringr hakkında daha fazla bilgi edinebilirsiniz.\n\nlinelist_dates_raw &lt;- stringr::str_extract(linelist_filenames, \"[0-9].*[0-9]\") # sayıları ve aradaki karakterleri ayıklayın\nlinelist_dates_raw  # yazdır\n\n[1] \"20201007\"   \"2020-10-02\" \"2020-10-03\" \"2020-10-04\" \"2020-10-05\"\n[6] \"2020-10-08\" \"20201006\"  \n\n\nTarihlerin genellikle aynı tarih formatında yazıldığını (örneğin Yıl sonra Ay sonra Gün) ve yılların 4 basamaklı olduğunu varsayarsak, lubridate’nin esnek dönüştürme fonksiyonlarını (ymd(), dmy() kullanabilirsiniz. ) veya mdy()) tarihlere dönüştürmek için. Bu fonksiyonlar için tireler, boşluklar veya eğik çizgiler önemli değildir, yalnızca sayıların sırası önemlidir. Tarihlerle çalışma sayfasında daha fazlasını okuyun.\n\nlinelist_dates_clean &lt;- lubridate::ymd(linelist_dates_raw)\nlinelist_dates_clean\n\n[1] \"2020-10-07\" \"2020-10-02\" \"2020-10-03\" \"2020-10-04\" \"2020-10-05\"\n[6] \"2020-10-08\" \"2020-10-06\"\n\n\nbase R fonksiyonu which.max() daha sonra maksimum tarih değerinin dizin konumunu (ör. 1., 2., 3., …) döndürmek için kullanılabilir. En son dosya, 6. dosya olarak doğru bir şekilde tanımlandı - “case_linelist_2020-10-08.xlsx”.\n\nindex_latest_file &lt;- which.max(linelist_dates_clean)\nindex_latest_file\n\n[1] 6\n\n\nTüm bu komutları yoğunlaştırırsak, kodun tamamı aşağıdaki gibi görünebilir. Son satırdaki . öğesinin, tünel dizisindeki o noktada tünellenen nesne için bir yer tutucu olduğuna dikkat edin. Bu noktada değer basitçe 6 sayısıdır. Bu, ‘dir()’ tarafından üretilen dosya adları vektörünün 6. öğesini çıkarmak için çift parantez içine yerleştirilir.\n\n# paketleri yükle\npacman::p_load(\n  tidyverse,         # veri yönetimi\n  stringr,           # dizeler/karakterlerle çalışmak\n  lubridate,         # tarihlerle çalışmak\n  rio,               # içe aktar / dışa aktar\n  here,              # ilişkili dosya yolları\n  fs)                # dizin etkileşimleri\n\n# en son dosyanın dosya adını çıkar\nlatest_file &lt;- dir(here(\"data\", \"example\", \"linelists\")) %&gt;%  # \"linelists\" alt klasöründeki dosya adları         \n  str_extract(\"[0-9].*[0-9]\") %&gt;%                  # tarihleri çıkar (sayılar)\n  ymd() %&gt;%                                        # sayıları tarihlere dönüştür (yıl-ay-gün biçimini varsayarak)\n  which.max() %&gt;%                                  # maksimum tarihin dizinini al (en son dosya)\n  dir(here(\"data\", \"example\", \"linelists\"))[[.]]              # en son satır listesinin dosya adını döndür\n\nlatest_file  # en son dosyanın adını yazdır\n\n[1] \"case_linelist_2020-10-08.xlsx\"\n\n\nArtık bu adı, ilişkili dosya yolunu “here()” ile bitirmek için kullanabilirsiniz:\n\nhere(\"data\", \"example\", \"linelists\", latest_file) \n\nVe şimdi en son dosyayı içe aktarabilirsiniz:\n\n# import\nimport(here(\"data\", \"example\", \"linelists\", latest_file)) # içe aktar \n\n\n\nDosya bilgisini kullanın\nDosyalarınızın adlarında tarih yoksa (veya bu tarihlere güvenmiyorsanız), dosya meta verilerinden son değişiklik tarihini çıkarmayı deneyebilirsiniz. Her dosya için son değişiklik zamanını ve dosya yolunu içeren meta veri bilgilerini incelemek için fs paketindeki fonksiyonları kullanın.\nAşağıda, fs’nin dir_info() dosyasının ilgilendiği klasörü sunuyoruz. Bu durumda, ilgilenilen klasör “data” klasöründeki R projesinde, “example” alt klasöründe ve alt klasörü “linelists”tedir. Sonuç, dosya başına bir satır ve “modification_time”, “path” vb. için sütunlar içeren bir veri çerçevesidir. Bunun görsel bir örneğini Dizin etkileşimleri sayfasında görebilirsiniz.\nDosyaların bu veri çerçevesini ‘modification_time’ sütununa göre sıralayabiliriz ve ardından base R’ın ‘head()’ ile yalnızca en üstteki/en son satırı (dosyayı) tutabiliriz. Daha sonra bu en son dosyanın dosya yolunu sadece ‘path’ sütunundaki dplyr fonksiyonu ‘pull()’ ile ayıklayabiliriz. Sonunda bu dosya yolunu import()a geçirebiliriz. İçe aktarılan dosya “latest_file” olarak kaydedilir.\n\nlatest_file &lt;- dir_info(here(\"data\", \"example\", \"linelists\")) %&gt;%  # dizindeki tüm dosyalarda dosya bilgilerini topla\n  arrange(desc(modification_time)) %&gt;%      # değişiklik zamanına göre sırala\n  head(1) %&gt;%                               # sadece en üstteki (en son) dosyayı tut\n  pull(path) %&gt;%                            # yalnızca dosya yolunu çıkar\n  import()                                  # dosyayı içe aktar",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>İçe ve dışa aktar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.tr.html#import_api",
    "href": "new_pages/importing.tr.html#import_api",
    "title": "7  İçe ve dışa aktar",
    "section": "7.10 API’ler",
    "text": "7.10 API’ler\nBir web sitesinden doğrudan veri istemek için bir “Otomatik Programlama Arayüzü” (API) kullanılabilir. API’ler, bir yazılım uygulamasının diğeriyle etkileşime girmesine izin veren bir dizi kuraldır. İstemci (siz) bir “istek” gönderir ve içerik içeren bir “yanıt” alır. httr ve jsonlite R paketleri bu süreci kolaylaştırabilir.\nAPI’nin etkin olduğu her web sitesi, aşina olmak için kendi belgelerine ve özelliklerine sahip olacaktır. Bazı siteler herkese açıktır ve herkes tarafından erişilebilir. Kullanıcı kimliklerine ve kimlik bilgilerine sahip platformlar gibi diğerleri, verilerine erişmek için kimlik doğrulama gerektirir.\nAPI aracılığıyla verileri içe aktarmak için internet bağlantınızın olması gerektiğini söylemeye gerek yok. Verileri içe aktarmak için API’lerin kullanımına ilişkin örnekler vereceğiz ve sizi daha fazla kaynağa bağlayacağız.\nNot: Verilerin API içermeyen bir web sitesinde yayınlanabileceğini* ve bunun alınmasının daha kolay olabileceğini unutmayın. Örneğin, yayınlanan bir CSV dosyasına, Github’dan içe aktarma bölümünde açıklandığı gibi site URL’sini “import()”a sağlayarak kolayca erişilebilir.*\n\nHTTP isteği\nAPI değişimi en yaygın olarak bir HTTP isteği aracılığıyla yapılır. HTTP, Köprü Metni Aktarım Protokolüdür ve bir istemci ile bir sunucu arasındaki bir istek/yanıtın temel biçimidir. Tam girdi ve çıktı, API türüne bağlı olarak değişebilir, ancak süreç aynıdır - genellikle bir sorgu içeren, kullanıcıdan gelen bir “Talep” (genellikle HTTP İsteği), ardından durum bilgilerini içeren bir “Yanıt”.\nİşte bir HTTP isteğinin birkaç bileşeni:\n\nAPI uç noktasının URL’si\n“Yöntem” (veya “Fiil”)\nBaşlıklar\nVücut\n\nHTTP isteği “yöntemi”, gerçekleştirmek istediğiniz eylemdir. En yaygın iki HTTP yöntemi ‘GET’ ve ‘POST’tur, ancak diğerleri ’PUT’, ‘DELETE’, ‘PATCH’ vb. içerebilir. Verileri R’a aktarırken büyük olasılıkla ‘GET’ kullanacaksınız.\nİsteğinizden sonra bilgisayarınız, URL, HTTP durumu (İstediğiniz Durum 200’dür!), dosya türü, boyutu ve istenen içerik dahil olmak üzere gönderdiğinize benzer bir biçimde bir “yanıt” alacaktır. Daha sonra bu yanıtı ayrıştırmanız ve R ortamınızda uygulanabilir bir veri çerçevesine dönüştürmeniz gerekecektir.\n\n\nPaketler\nhttr paketi, R’da HTTP isteklerini işlemek için iyi çalışır. Web API’leri hakkında çok az ön bilgi gerektirir ve yazılım geliştirme terminolojisine daha az aşina olan kişiler tarafından kullanılabilir. Ayrıca, HTTP yanıtı .json ise yanıtı ayrıştırmak için jsonlite kullanabilirsiniz.\n\n# paketleri yüklemek\npacman::p_load(httr, jsonlite, tidyverse)\n\n\n\nHerkese açık veriler\nAşağıda, Trafford Data Lab bir eğiticiden ödünç alınan bir HTTP isteği örneği verilmiştir. Bu sitede öğrenilecek başka kaynaklar ve API alıştırmaları var.\nSenaryo: İngiltere’nin Trafford şehrinde bulunan fast food satış noktalarının bir listesini içe aktarmak istiyoruz. Verilere, Birleşik Krallık için gıda hijyeni derecelendirme verileri sağlayan Gıda Standartları Ajansı API’sinden erişilebilir.\nİşte talebimiz için parametreler:\n\nHTTP fiili: GET\nAPI uç noktası URL’si: http://api.ratings.food.gov.uk/Establishments\nSeçilen parametreler: ad, adres, boylam, enlem, businessTypeId, ratingKey, localAuthorityId\nBaşlıklar: “x-api-version”, 2\nVeri biçimleri: JSON, XML\nBelgeler: http://api.ratings.food.gov.uk/help\n\nR kodu aşağıdaki gibi olacaktır:\n\n# talebi hazırlamak\npath &lt;- \"http://api.ratings.food.gov.uk/Establishments\"\nrequest &lt;- GET(url = path,\n             query = list(\n               localAuthorityId = 188,\n               BusinessTypeId = 7844,\n               pageNumber = 1,\n               pageSize = 5000),\n             add_headers(\"x-api-version\" = \"2\"))\n\n# herhangi bir sunucu hatası olup olmadığını kontrol edin (\"200\" iyidir!)\nrequest$status_code\n\n# isteği gönderin, yanıtı ayrıştırın ve bir veri çerçevesine dönüştürün\nresponse &lt;- content(request, as = \"text\", encoding = \"UTF-8\") %&gt;%\n  fromJSON(flatten = TRUE) %&gt;%\n  pluck(\"establishments\") %&gt;%\n  as_tibble()\n\nArtık her fast food tesisi için bir satır içeren “yanıt” veri çerçevesini temizleyebilir ve kullanabilirsiniz.\n\n\nKimlik doğrulama gerekli\nBazı API’ler kimlik doğrulaması gerektirir - kim olduğunuzu kanıtlamanız halinde kısıtlı verilere erişebilirsiniz. Bu verileri içe aktarmak için önce bir kullanıcı adı, parola veya kod sağlamak üzere bir POST yöntemi kullanmanız gerekebilir. Bu, istenen verileri almak için sonraki GET yöntemi istekleri için kullanılabilecek bir erişim belirteci döndürür.\nAşağıda, bir salgın araştırma aracı olan Go.Data’dan veri sorgulama örneği verilmiştir. Go.Data, veri toplama için kullanılan web ön uç ve akıllı telefon uygulamaları arasındaki tüm etkileşimler için bir API kullanır. Go.Data tüm dünyada kullanılmaktadır. Salgın verileri hassas olduğundan ve yalnızca salgınınız için verilere erişebilmeniz gerektiğinden, kimlik doğrulama gereklidir.\nAşağıda, salgınınızdan kişi takibine ilişkin verileri içe aktarmak için Go.Data API’sine bağlanmak için httr ve jsonlite kullanan bazı örnek R kodları verilmiştir.\n\n# yetkilendirme için kimlik bilgilerini ayarla\nurl &lt;- \"https://godatasampleURL.int/\"           # geçerli Go.Data url örneği\nusername &lt;- \"username\"                          # geçerli Go.Data kullanıcı adı \npassword &lt;- \"password\"                          # geçerli Go.Data parolası \noutbreak_id &lt;- \"xxxxxx-xxxx-xxxx-xxxx-xxxxxxx\"  # geçerli Go.Data salgın kimliği\n\n# erişim izni almak\nurl_request &lt;- paste0(url,\"api/oauth/token?access_token=123\") # temel url isteğini tanımla\n\n# istek hazırlamak\nresponse &lt;- POST(\n  url = url_request,  \n  body = list(\n    username = username,    # yetkilendirmek için yukarıdan kaydedilmiş kullanıcı adını/şifreyi kullanın                           \n    password = password),                                       \n    encode = \"json\")\n\n# isteği yürüt ve yanıtı ayrıştır\ncontent &lt;-\n  content(response, as = \"text\") %&gt;%\n  fromJSON(flatten = TRUE) %&gt;%          # düzleştirilmiş iç içe JSON\n  glimpse()\n\n# Yanıttan erişim belirtecini kaydet\naccess_token &lt;- content$access_token    # aşağıdaki API çağrılarına izin vermek için erişim belirtecini kaydedin\n\n# Salgın temaslılarını içe aktar\n# Erişim belirtecini kullanın\nresponse_contacts &lt;- GET(\n  paste0(url,\"api/outbreaks/\",outbreak_id,\"/contacts\"),          # GET talebi\n  add_headers(\n    Authorization = paste(\"Bearer\", access_token, sep = \" \")))\n\njson_contacts &lt;- content(response_contacts, as = \"text\")         # Metni JSON'a dönüştür\n\ncontacts &lt;- as_tibble(fromJSON(json_contacts, flatten = TRUE))   # JSON'u tibble için düzleştirin \n\nUYARI: Kimlik doğrulama gerektiren bir API’den büyük miktarda veri içe aktarıyorsanız, zaman aşımına uğrayabilir. Bunu önlemek için, her API GET isteğinden önce access_token’i tekrar alın ve sorguda filtreleri veya sınırları kullanmayı deneyin. \nİPUCU: jsonlite paketindeki fromJSON() fonksiyonu, ilk çalıştırıldığında yuvayı tamamen açmaz, bu nedenle muhtemelen yine de sonuçta ortaya çıkan tibble’ınızda liste öğeleri vardır. .json dosyanızın ne kadar iç içe olduğuna bağlı olarak belirli değişkenler için daha fazla yuva açmanız gerekecektir. Bununla ilgili daha fazla bilgi görüntülemek için, flatten() fonksiyonu gibi jsonlite paketinin belgelerine bakabilirsiniz. \nDaha fazla ayrıntı için LoopBack Explorer, Kişi İzleme sayfası veya Go.Data Github deposundaki API ipuçları hakkındaki belgeleri görüntüleyin.\nhttr paketi hakkında daha fazla bilgiyi buradan okuyabilirsiniz.\nBu bölümde ayrıca bu ders ve bu ders metinlerinden de yararlanıldı.",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>İçe ve dışa aktar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.tr.html#dışa-aktarma",
    "href": "new_pages/importing.tr.html#dışa-aktarma",
    "title": "7  İçe ve dışa aktar",
    "section": "7.11 Dışa aktarma",
    "text": "7.11 Dışa aktarma\n\nrio paketiyle\nrio ile, ‘export()’ fonksiyonunu ‘import()’ fonksiyonuna çok benzer bir şekilde kullanabilirsiniz. Önce kaydetmek istediğiniz R nesnesinin adını verin (örn. Örneğin:\nBu, “linelist” veri çerçevesini bir Excel çalışma kitabı olarak çalışma dizini/R proje kök klasörüne kaydeder:\n\nexport(linelist, \"my_linelist.xlsx\") # çalışma dizinine kaydedecek\n\nUzantıyı değiştirerek aynı veri çerçevesini bir csv dosyası olarak kaydedebilirsiniz. Örneğin, onu “here()” ile oluşturulmuş bir dosya yoluna da kaydederiz:\n\nexport(linelist, here(\"data\",\"clean\", \"my_linelist.csv\")\n\n\n\nPanoya\nBir veri çerçevesini bilgisayarınızın “panosuna” aktarmak için (daha sonra Excel, Google E-Tablolar, vb. gibi başka bir yazılıma yapıştırmak için) clipr paketinden write_clip() kullanabilirsiniz.\n\n# satır listesi veri çerçevesini sisteminizin panosuna aktarın\nclipr::write_clip(linelist)",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>İçe ve dışa aktar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.tr.html#import_rds",
    "href": "new_pages/importing.tr.html#import_rds",
    "title": "7  İçe ve dışa aktar",
    "section": "7.12 RDS dosyaları",
    "text": "7.12 RDS dosyaları\n.csv, .xlsx vb. ile birlikte R veri çerçevelerini .rds dosyaları olarak dışa aktarabilir/kaydedebilirsiniz. Bu, R’a özgü bir dosya biçimidir ve dışa aktarılan verilerle tekrar R’da çalışacağınızı biliyorsanız çok kullanışlıdır.\nSütun sınıfları depolanır, bu nedenle içe aktarıldığında tekrar temizlemeniz gerekmez (bir Excel veya hatta bir CSV dosyası ile bu bir baş ağrısı olabilir!). Ayrıca, veri kümeniz büyükse dışa ve içe aktarma için kullanışlı olan daha küçük bir dosya üzerinden işlemi yapar.\nÖrneğin, bir Epidemiyoloji ekibinde çalışıyorsanız ve haritalama için bir CBS ekibine dosya göndermeniz gerekiyorsa ve onlar da R kullanıyorsa, onlara .rds dosyasını göndermeniz yeterlidir! Daha sonra tüm sütun sınıfları korunur ve yapacak daha az işleri olur.\n\nexport(linelist, here(\"data\",\"clean\", \"my_linelist.rds\")",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>İçe ve dışa aktar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.tr.html#import_rdata",
    "href": "new_pages/importing.tr.html#import_rdata",
    "title": "7  İçe ve dışa aktar",
    "section": "7.13 Rdata dosyaları ve listeleri",
    "text": "7.13 Rdata dosyaları ve listeleri\n‘.Rdata’ dosyaları birden çok R nesnesini depolayabilir - örneğin birden çok veri çerçevesi, model sonuçları, listeler, vb. Bu, belirli bir proje için çok sayıda verinizi birleştirmek veya paylaşmak için çok yararlı olabilir.\nAşağıdaki örnekte, dışa aktarılan “my_objects.Rdata” dosyasında birden çok R nesnesi depolanır:\n\nrio::export(my_list, my_dataframe, my_vector, \"my_objects.Rdata\")\n\nNot: Bir listeyi içe aktarmaya çalışıyorsanız, tam orijinal yapı ve içerikle içe aktarmak için rio’dan import_list() kullanın.\n\nrio::import_list(\"my_list.Rdata\")",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>İçe ve dışa aktar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.tr.html#grafikleri-kaydetme",
    "href": "new_pages/importing.tr.html#grafikleri-kaydetme",
    "title": "7  İçe ve dışa aktar",
    "section": "7.14 Grafikleri kaydetme",
    "text": "7.14 Grafikleri kaydetme\n“ggplot()” tarafından oluşturulanlar gibi grafiklerin nasıl kaydedileceğine ilişkin talimatlar ggplot temelleri sayfasında ayrıntılı olarak tartışılmaktadır.\nÖzetle, grafiğinizi yazdırdıktan sonra ggsave(\"my_plot_filepath_and_name.png\") komutunu çalıştırın. plot = değişkenine kaydedilmiş bir çizim nesnesi sağlayabilir veya en son görüntülenen grafiği kaydetmek için yalnızca hedef dosya yolunu (dosya uzantısıyla) belirtebilirsiniz. Ayrıca ‘width =’, ‘height =’, ‘units =’ ve ‘dpi =’ değerlerini de kontrol edebilirsiniz.\nİletim ağacı gibi bir ağ grafiğinin nasıl kaydedileceği İletim zincirleri sayfasında açıklanmıştır.",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>İçe ve dışa aktar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.tr.html#kaynaklar",
    "href": "new_pages/importing.tr.html#kaynaklar",
    "title": "7  İçe ve dışa aktar",
    "section": "7.15 Kaynaklar",
    "text": "7.15 Kaynaklar\nR Verilerini İçe/Dışa Aktarma Kılavuzu Veri içe aktarma hakkında R 4 Veri Bilimi bölümü ggsave() belgeleri\nAşağıda rio çevrimiçi vinyet’den alınmış bir tablo bulunmaktadır. Gösterilen her veri türü için: beklenen dosya uzantısı, rio paketinin verileri içe veya dışa aktarmak için kullandığı ve bu fonksiyonun rio’nun varsayılan yüklü sürümüne dahil edilip edilmediğini gösterir.\n\n\n\n\n\n\n\n\n\n\nBiçim\nTipik Uzantı\nİçe Aktarma Paketi\nDışa Aktarma Paketi\nVarsayılan Olarak Yüklenir Mi?\n\n\n\n\nComma-separated data\n.csv\ndata.table fread()\ndata.table\nEvet\n\n\nPipe-separated data\n.psv\ndata.table fread()\ndata.table\nEvet\n\n\nTab-separated data\n.tsv\ndata.table fread()\ndata.table\nEvet\n\n\nSAS\n.sas7bdat\nhaven\nhaven\nEvet\n\n\nSPSS\n.sav\nhaven\nhaven\nEvet\n\n\nStata\n.dta\nhaven\nhaven\nEvet\n\n\nSAS\nXPORT\n.xpt\nhaven\nhaven\n\n\nSPSS Portable\n.por\nhaven\n\nEvet\n\n\nExcel\n.xls\nreadxl\n\nEvet\n\n\nExcel\n.xlsx\nreadxl\nopenxlsx\nEvet\n\n\nR syntax\n.R\nbase\nbase\nEvet\n\n\nSaved R objects\n.RData, .rda\nbase\nbase\nEvet\n\n\nSerialized R objects\n.rds\nbase\nbase\nEvet\n\n\nEpiinfo\n.rec\nforeign\n\nEvet\n\n\nMinitab\n.mtp\nforeign\n\nEvet\n\n\nSystat\n.syd\nforeign\n\nEvet\n\n\n“XBASE”\ndatabase files\n.dbf\nforeign\nforeign\n\n\nWeka Attribute-Relation File Format\n.arff\nforeign\nforeign\nEvet\n\n\nData Interchange Format\n.dif\nutils\n\nEvet\n\n\nFortran data\nno recognized extension\nutils\n\nEvet\n\n\nFixed-width format data\n.fwf\nutils\nutils\nEvet\n\n\ngzip comma-separated data\n.csv.gz\nutils\nutils\nEvet\n\n\nCSVY (CSV + YAML metadata header)\n.csvy\ncsvy\ncsvy\nHayır\n\n\nEViews\n.wf1\nhexView\n\nHayır\n\n\nFeather R/Python interchange format\n.feather\nfeather\nfeather\nHayır\n\n\nFast Storage\n.fst\nfst\nfst\nHayır\n\n\nJSON\n.json\njsonlite\njsonlite\nHayır\n\n\nMatlab\n.mat\nrmatio\nrmatio\nHayır\n\n\nOpenDocument Spreadsheet\n.ods\nreadODS\nreadODS\nHayır\n\n\nHTML Tables\n.html\nxml2\nxml2\nHayır\n\n\nShallow XML documents\n.xml\nxml2\nxml2\nHayır\n\n\nYAML\n.yml\nyaml\nyaml\nHayır\n\n\nClipboard default is tsv\n\nclipr\nclipr\nHayır",
    "crumbs": [
      "Temel Bilgiler",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>İçe ve dışa aktar</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.tr.html",
    "href": "new_pages/cleaning.tr.html",
    "title": "8  Veri temizliği ve temel fonksiyonlar",
    "section": "",
    "text": "Temel fonksiyonlar\nBu el kitabı R paketlerinden tidyverse ailesi fonksiyonlarının kullanımını vurgulamaktadır. tidyverse Bu sayfada gösterilen temel R fonksiyonları aşağıda listelenmiştir.\nBu fonksiyonların çoğu dplyr R paketine aittir. Bu R paketi veri manipülasyonu problemlerini çözmek için gerekli “eylem” fonksiyonlarını içerir. ( dplyr ismi veri çerçevesi katlayıcı – data frame plier kelimelerine referans olarak verilmiştir). dplyr dplyr , tidyverse R paketi ailesinin bir parçasıdır. Bu aile ggplot2, tidyr, stringr, tibble, purrr, magrittr ve forcats gibi birçok önemli paketi kapsar.\nBu komutların Stata ya da SAS komutları ile karşılaştırılmasını görmek için R’a geçiş sayfasını inceleyin.\nAlternatif bir veri yönetim çerçevesi olarak data.table R paketi := gibi operatörler ve sıkça köşeli parantezler [ ] kullanır. Bu yaklaşım ve sintaksı kısaca Veri Tablosu sayfasında anlatılmıştır.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Veri temizliği ve temel fonksiyonlar</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.tr.html#tünel-hattını-temizlemek",
    "href": "new_pages/cleaning.tr.html#tünel-hattını-temizlemek",
    "title": "8  Veri temizliği ve temel fonksiyonlar",
    "section": "8.1 Tünel hattını temizlemek",
    "text": "8.1 Tünel hattını temizlemek\nBu sayfada tipik veri temizleme basamakları ve bu basamakların tünel hattına eklenmesi gözden geçirilecektir.\nEpidemiyolojik analiz ve veri işlemede, temizleme adımları genellikle birbiri ile bağlantılı olarak sırayla gerçekleştirilir. R’da, bu genellikle ham veri kümesinin bir temizleme adımından diğerine geçirildiği veya “tünellandığı” bir temizleme “tünel hattı” olarak kendini gösterir.\nBu tür zincirler, dplyr “eylem” fonksiyonları ve magrittr tünel operatörü %&gt;%’yi kullanır. Bu kanal, “ham” verilerle (“linelist_raw.xlsx”) başlar ve kullanılabilen, kaydedilebilen, dışa aktarılabilen vb. “temiz” bir R veri çerçevesi (linelist) ile biter.\nBir temizleme tünel hattında adımların sırası önemlidir. Temizleme adımları şunları içerebilir: • Verilerin içe aktarılması • Sütun adlarının temizlenmesi veya değiştirilmesi • Tekilleştirme (de-duplikasyon) • Sütun oluşturma ve dönüştürme (örn. değerleri yeniden kodlama veya standartlaştırma) • Filtrelenen veya eklenen satırlar",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Veri temizliği ve temel fonksiyonlar</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.tr.html#paketlerin-yüklenmesi",
    "href": "new_pages/cleaning.tr.html#paketlerin-yüklenmesi",
    "title": "8  Veri temizliği ve temel fonksiyonlar",
    "section": "8.2 Paketlerin yüklenmesi",
    "text": "8.2 Paketlerin yüklenmesi\nBu kod kümesi, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gereken durumlarda paket kuran ve kullanım için yükleyen pacman’ın p_load() fonksiyonu vurgulanmaktadır. Alternatif olarak, base (temel) R’den library() komutu ile kurulu paketler yüklenebilir. R paketleri hakkında daha fazla bilgi için R’ın temelleri sayfasına bakın.\n\npacman::p_load(\n  rio,        # verileri içe aktarma\n  here,       # göreli dosya yolları\n  janitor,    # veri temizleme ve tablolar\n  lubridate,  # tarihlerle çalışma\n  epikit,     # age_categories() fonksiyonu\n  tidyverse   # veri yönetimi ve görselleştirme\n)",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Veri temizliği ve temel fonksiyonlar</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.tr.html#verileri-içe-aktar",
    "href": "new_pages/cleaning.tr.html#verileri-içe-aktar",
    "title": "8  Veri temizliği ve temel fonksiyonlar",
    "section": "8.3 Verileri içe aktar",
    "text": "8.3 Verileri içe aktar\n\nİçe aktarma\nBurada, rio paketinden import() fonksiyonunu kullanarak “ham” vaka satır listesi formundaki Excel dosyasını içe aktarıyoruz. rio paketi birçok dosya türünü esnek bir şekilde işler (örn. .xlsx, .csv, .tsv, .rds. Satırları atlama, eksik değerleri ayarlama, Google sayfalarını içe aktarma gibi diğer durumlar hakkında daha fazla bilgi ve ipucu için İçe Aktarma ve Dışa Aktarma sayfasına bakın.\nEşlik etmek isterseniz, ham satır listesini indirmek için tıklayınız (.xlsx dosyası olarak).\nVeri tabanınız büyükse ve içe aktarılması uzun sürüyorsa, içe aktarma komutunun tünel zincirinden ayrı olması ve ham verinin ayrı bir dosya olarak kaydedilmesi yararlı olabilir. Bu aynı zamanda orijinal ve temizlenmiş sürümler arasında kolay karşılaştırma sağlar.\nAşağıda, ham Excel dosyasını içe aktarıyoruz ve onu linelist_raw veri çerçevesi olarak kaydediyoruz. Dosyanın çalışma dizininizde veya R proje kök dizininde bulunduğunu ve bu nedenle dosya yolunda hiçbir alt klasör belirtilmediğini varsayıyoruz.\n\nlinelist_raw &lt;- import(\"linelist_raw.xlsx\")\n\nAşağıda veri çerçevesinin ilk 50 satırını görüntüleyebilirsiniz. Not: temel R fonksiyonu head (n), R konsolundaki ilk n satırı görüntülemenize olanak tanır.\n\n\n\n\n\n\n\n\nGözden geçirme\nTüm veri çerçevesine genel bir bakış elde etmek için skimr paketindeki skim() fonksiyonunu kullanabilirsiniz (daha fazla bilgi için Tanımlayıcı tablolar sayfasına bakın). Sütunlar karakter, sayısal gibi sınıflara göre özetlenir. Not: “POSIXct” bir tür ham tarih sınıfıdır (bkz. Tarihlerle çalışma)\n\nskimr::skim(linelist_raw)\n\n\n\n\nData summary\n\n\nName\nlinelist_raw\n\n\nNumber of rows\n6611\n\n\nNumber of columns\n28\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n17\n\n\nnumeric\n8\n\n\nPOSIXct\n3\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\ncase_id\n137\n0.98\n6\n6\n0\n5888\n0\n\n\ndate onset\n293\n0.96\n10\n10\n0\n580\n0\n\n\noutcome\n1500\n0.77\n5\n7\n0\n2\n0\n\n\ngender\n324\n0.95\n1\n1\n0\n2\n0\n\n\nhospital\n1512\n0.77\n5\n36\n0\n13\n0\n\n\ninfector\n2323\n0.65\n6\n6\n0\n2697\n0\n\n\nsource\n2323\n0.65\n5\n7\n0\n2\n0\n\n\nage\n107\n0.98\n1\n2\n0\n75\n0\n\n\nage_unit\n7\n1.00\n5\n6\n0\n2\n0\n\n\nfever\n258\n0.96\n2\n3\n0\n2\n0\n\n\nchills\n258\n0.96\n2\n3\n0\n2\n0\n\n\ncough\n258\n0.96\n2\n3\n0\n2\n0\n\n\naches\n258\n0.96\n2\n3\n0\n2\n0\n\n\nvomit\n258\n0.96\n2\n3\n0\n2\n0\n\n\ntime_admission\n844\n0.87\n5\n5\n0\n1091\n0\n\n\nmerged_header\n0\n1.00\n1\n1\n0\n1\n0\n\n\n…28\n0\n1.00\n1\n1\n0\n1\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\n\n\n\n\ngeneration\n7\n1.00\n16.60\n5.71\n0.00\n13.00\n16.00\n20.00\n37.00\n\n\nlon\n7\n1.00\n-13.23\n0.02\n-13.27\n-13.25\n-13.23\n-13.22\n-13.21\n\n\nlat\n7\n1.00\n8.47\n0.01\n8.45\n8.46\n8.47\n8.48\n8.49\n\n\nrow_num\n0\n1.00\n3240.91\n1857.83\n1.00\n1647.50\n3241.00\n4836.50\n6481.00\n\n\nwt_kg\n7\n1.00\n52.69\n18.59\n-11.00\n41.00\n54.00\n66.00\n111.00\n\n\nht_cm\n7\n1.00\n125.25\n49.57\n4.00\n91.00\n130.00\n159.00\n295.00\n\n\nct_blood\n7\n1.00\n21.26\n1.67\n16.00\n20.00\n22.00\n22.00\n26.00\n\n\ntemp\n158\n0.98\n38.60\n0.95\n35.20\n38.30\n38.80\n39.20\n40.80\n\n\n\nVariable type: POSIXct\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nmedian\nn_unique\n\n\n\n\ninfection date\n2322\n0.65\n2012-04-09\n2015-04-27\n2014-10-04\n538\n\n\nhosp date\n7\n1.00\n2012-04-20\n2015-04-30\n2014-10-15\n570\n\n\ndate_of_outcome\n1068\n0.84\n2012-05-14\n2015-06-04\n2014-10-26\n575",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Veri temizliği ve temel fonksiyonlar</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.tr.html#sütun-isimleri",
    "href": "new_pages/cleaning.tr.html#sütun-isimleri",
    "title": "8  Veri temizliği ve temel fonksiyonlar",
    "section": "8.4 Sütun isimleri",
    "text": "8.4 Sütun isimleri\nR’de sütun adları, bir sütunun “başlık” veya “üst” değeridir. Koddaki sütunlara atıfta bulunmak için kullanılırlar ve şekillerde varsayılan bir etiket görevi görürler.\nSAS ve STATA gibi diğer istatistiksel yazılımlar, daha kısa sütun adlarının daha uzun basılı sürümleri olarak birlikte oldukları “etiketler” kullanır. R, verilere sütun etiketleri ekleme olanağı sunarken, uygulamada çoğu zaman bu vurgulanmamaktadır. Şekiller için sütun adlarını “yazıcı dostu” yapmak için, çıktı oluşturan çizim komutları içinde sütun adı gösterimleri uygun şekilde ayarlanabilir (Örneğin, bir grafiğin eksen veya gösterge (legend) başlıkları veya basılı bir tablodaki sütun başlıkları – ggplot için ipuçları ölçekler bölümü ve sunum sayfaları için tablolar sayfalarına bakabilirsiniz). Veride sütun etiketleri atamak istiyorsanız,[buradan] (https://cran.r-project.org/web/packages/expss/vignettes/labels-support.html) ve buradan çevrimiçi olarak daha fazlasını okuyabilirsiniz.\nR sütun adları çok sık kullanıldığından, “temiz” sintaksa sahip olmalıdır. Aşağıdakileri öneriyoruz:\n• Kısa isimler • Boşluk kullanmayın (bunun yerine alt çizgi _ kullanın ) • Beklenmedik karakter kullanmayın (&, #, &lt;, &gt;, …) • Benzer stilde adlandırmalar (örneğin tüm tarih sütunları tarih_başlangıç, tarih_rapor, tarih_ölüm… gibi aynı tarzda adlandırılmalı)\nlinelist_raw sütun adları, aşağıda temel R names() fonksiyonunu kullanılarak yazdırılır. Başlangıçta şunu görebiliriz: • Bazı isimler boşluk içerir (e.g. infection date) • Tarihler için farklı adlandırma kalıpları kullanılmıştır (date onset vs. infection date) • .xlsx dosyasındaki son iki sütunda birleştirilmiş bir başlık bulunmalıdır. Bunu biliyoruz, çünkü birleştirilmiş iki sütunun adı (“merged_header”) R tarafından ilk sütuna atanmıştır ve ikinci sütuna “…28” yer tutucu adı atanmıştır (boş olan 28. sütun).\n\nnames(linelist_raw)\n\n [1] \"case_id\"         \"generation\"      \"infection date\"  \"date onset\"     \n [5] \"hosp date\"       \"date_of_outcome\" \"outcome\"         \"gender\"         \n [9] \"hospital\"        \"lon\"             \"lat\"             \"infector\"       \n[13] \"source\"          \"age\"             \"age_unit\"        \"row_num\"        \n[17] \"wt_kg\"           \"ht_cm\"           \"ct_blood\"        \"fever\"          \n[21] \"chills\"          \"cough\"           \"aches\"           \"vomit\"          \n[25] \"temp\"            \"time_admission\"  \"merged_header\"   \"...28\"          \n\n\nNOT: Boşluk içeren bir sütun adı için, adı ters tik işaretleriyle çevreleyin, örneğin: linelist$\\x60infection date\\x60. . Klavyenizdeki geri tik işaretinin (`) tek tırnak işaretinden (’) farklı olduğunu unutmayın..\n\nEtiketler\nSAS gibi bazı diğer istatistiksel yazılımların değişken etiketleri vardır.\n\n\nOtomatik Temizleme\njanitor paketindeki clean_names() fonksiyonu, sütun adlarını standartlaştırır ve aşağıdakileri yaparak bunları benzersiz kılar: • Tüm adları yalnızca alt çizgi, sayı ve harflerden oluşacak şekilde dönüştürür • Vurgulu karakterler ASCII’ye dönüştürülür (örneğin, ö “o” olur, İspanyolca “enye” “n” olur) • Yeni sütun adları için büyük harf kullanımı tercihi case = argümanı kullanılarak belirtilebilir (“snake” varsayılandır, alternatifler arasında “sentence” (cümle) , “title” (başlık) , “small_camel”… bulunur) • İşte bir çevrimiçi gösterim\nAşağıda, temizleme tünel hattı, ham satır listesinde clean_names() kullanılarak başlar.\n\n# ham veri kümesini clean_names() fonksiyonu aracılığıyla aktarın, sonucu \"linelist\" olarak atayın\nlinelist &lt;- linelist_raw %&gt;% \n  janitor::clean_names()\n\n# yeni sütun adlarını görün\nnames(linelist)\n\n [1] \"case_id\"         \"generation\"      \"infection_date\"  \"date_onset\"     \n [5] \"hosp_date\"       \"date_of_outcome\" \"outcome\"         \"gender\"         \n [9] \"hospital\"        \"lon\"             \"lat\"             \"infector\"       \n[13] \"source\"          \"age\"             \"age_unit\"        \"row_num\"        \n[17] \"wt_kg\"           \"ht_cm\"           \"ct_blood\"        \"fever\"          \n[21] \"chills\"          \"cough\"           \"aches\"           \"vomit\"          \n[25] \"temp\"            \"time_admission\"  \"merged_header\"   \"x28\"            \n\n\nNOT: Son sütun adı “…28” “x28” olarak değiştirilmiştir.\n\n\nManuel isim temizliği\nSütunları manuel olarak yeniden adlandırmak, yukarıdaki standardizasyon adımından sonra bile genellikle gereklidir. Aşağıda, bir tünel zincirinin parçası olarak dplyr paketindeki rename() fonksiyonu kullanılarak yeniden adlandırma gerçekleştirilir. rename() YENİ = ESKİ stilini kullanır - yeni sütun adı eski sütun adından önce verilir.\nAşağıda, temizleme hattına bir yeniden adlandırma komutu eklenmiştir. Kodu daha kolay okumak için hizalama amacıyla boşluklar eklenmiştir.\n\n# TEMİZLİK 'TÜNEL' ZİNCİRİ (ham verilerle başlar ve temizleme adımları boyunca iletir)\n##################################################################################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # sütun adı sintaksını standartlaştırın\n    janitor::clean_names() %&gt;% \n    \n    # sütunları manuel olarak yeniden adlandır\n           # YENİ isim             # ESKİ isim\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome)\n\nArtık sütun adlarının değiştirildiğini görebilirsiniz:\n\n\n [1] \"case_id\"              \"generation\"           \"date_infection\"      \n [4] \"date_onset\"           \"date_hospitalisation\" \"date_outcome\"        \n [7] \"outcome\"              \"gender\"               \"hospital\"            \n[10] \"lon\"                  \"lat\"                  \"infector\"            \n[13] \"source\"               \"age\"                  \"age_unit\"            \n[16] \"row_num\"              \"wt_kg\"                \"ht_cm\"               \n[19] \"ct_blood\"             \"fever\"                \"chills\"              \n[22] \"cough\"                \"aches\"                \"vomit\"               \n[25] \"temp\"                 \"time_admission\"       \"merged_header\"       \n[28] \"x28\"                 \n\n\n\nSütun konumuna göre yeniden adlandırma\nSütun adı yerine sütun konumuna göre de yeniden adlandırabilirsiniz, örneğin:\n\nrename(newNameForFirstColumn  = 1,\n       newNameForSecondColumn = 2)\n\n\n\nselect() ve summarise() ile yeniden adlandırma\nKısa yol olarak, dplyr select() ve summarise() fonksiyonları ile sütunları yeniden adlandırabilirsiniz. select() yalnızca belirli sütunları tutmak için kullanılır (ve bu sayfanın ilerleyen kısımlarında ele alınacaktır). summarise(),Verilerin gruplanması ve Tanımlayıcı tablolar sayfalarında ele alınmıştır. Bu fonksiyonlar da yeni_adı = eski_adı biçimini kullanır. İşte bir örnek:\n\nlinelist_raw %&gt;% \n  select(# YENİ isim             # ESKİ isim\n         date_infection       = `infection date`,    # yeniden adlandır ve SADECE BU KOLONLARI TUT.\n         date_hospitalisation = `hosp date`)\n\n\n\n\nDiğer sorunlar\n\nBoş excel sütun isimleri\nR, sütun adları (başlıklar) olmayan veri kümesi sütunlarına izin vermez. Bu nedenle, veriler içeren ancak sütun başlıkları olmayan bir Excel veri kümesini içe aktarırsanız, başlıklar “…1” veya “…2” gibi adlarla doldurulacaktır. Sayı, sütun numarasını temsil eder (örneğin, veri kümesindeki 4. sütunun başlığı yoksa, R buna “…4” adını verir).\nBu adları, konum numaralarına (yukarıdaki örneğe bakın) veya atanmış adlarına (linelist_raw$…1) başvurarak manuel olarak temizleyebilirsiniz.\n\n\nBirleştirilmiş Excel sütun adları ve hücreleri\nBir Excel dosyasındaki birleştirilmiş hücreler, veri alırken sık karşılaşılan bir durumdur. R’a Geçiş bölümünde açıklandığı gibi, birleştirilmiş hücreler verinin insan tarafından okunması için iyi olabilir, ancak “düzenli-tidy veri” değildir ve verilerin makine tarafından okunması için birçok soruna neden olur. R, birleştirilmiş hücreleri barındıramaz.\nVeri girişi yapan kişilere, insan tarafından okunabilen verilerin makine tarafından okunabilen verilerle aynı olmadığını hatırlatın. Kullanıcıları düzenli veri tidy data ilkeleri konusunda eğitmeye çalışın. Mümkünse, verilerin birleştirilmiş hücreler olmadan düzenli bir biçimde aktarımı için prosedürleri değiştirmeye çalışın.\n• Her değişkenin kendi sütunu olmalıdır. • Her gözlemin kendi satırı olmalıdır. • Her değerin kendi hücresi olmalıdır.\nrio’nun import() fonksiyonunu kullanırken, birleştirilmiş hücredeki değer ilk hücreye atanacak ve sonraki hücreler boş kalacaktır.\nBirleştirilmiş hücrelerle başa çıkmak için bir çözüm, verileri openxlsx paketinden readWorkbook() fonksiyonuyla içe aktarmaktır. fillMergedCells = TRUE değişkeni ayarlanmalıdır. Bu, birleştirilmiş hücredeki değeri, birleştirme aralığındaki tüm hücrelere verir.\n\nlinelist_raw &lt;- openxlsx::readWorkbook(\"linelist_raw.xlsx\", fillMergedCells = TRUE)\n\nTEHLİKE: Sütun adları readWorkbook() ile birleştirilirse, el ile düzeltmeniz gereken yinelenen sütun adları elde edersiniz - R, tekrarlayan sütun adlarıyla iyi çalışmaz! Manuel sütun adı temizleme bölümünde açıklandığı gibi, sütunların konumlarına atıfta bulunarak (örneğin sütun 5) sütunları yeniden adlandırabilirsiniz.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Veri temizliği ve temel fonksiyonlar</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.tr.html#sütunların-seçimi-ve-yeniden-düzenlenmesi",
    "href": "new_pages/cleaning.tr.html#sütunların-seçimi-ve-yeniden-düzenlenmesi",
    "title": "8  Veri temizliği ve temel fonksiyonlar",
    "section": "8.5 Sütunların seçimi ve yeniden düzenlenmesi",
    "text": "8.5 Sütunların seçimi ve yeniden düzenlenmesi\nTutmak istediğiniz sütunları seçmek ve veri çerçevesindeki sıralarını belirtmek için dplyr’dan select()’i kullanın.\nUYARI: Aşağıdaki örneklerde, satır listesi veri çerçevesi select() ile değiştirilip görüntülenmektedir, ancak kaydedilmemektedir. Bu örnek gösterim amaçlıdır. Değiştirilen sütun adları, veri çerçevesinin names () fonksiyonuna bağlanmasıyla yazdırılır.\nTemizleme tünel hattının bu noktasında satır listesindeki TÜM sütun adları şunlardır:\n\nnames(linelist)\n\n [1] \"case_id\"              \"generation\"           \"date_infection\"      \n [4] \"date_onset\"           \"date_hospitalisation\" \"date_outcome\"        \n [7] \"outcome\"              \"gender\"               \"hospital\"            \n[10] \"lon\"                  \"lat\"                  \"infector\"            \n[13] \"source\"               \"age\"                  \"age_unit\"            \n[16] \"row_num\"              \"wt_kg\"                \"ht_cm\"               \n[19] \"ct_blood\"             \"fever\"                \"chills\"              \n[22] \"cough\"                \"aches\"                \"vomit\"               \n[25] \"temp\"                 \"time_admission\"       \"merged_header\"       \n[28] \"x28\"                 \n\n\n\nSütunları koru\nYalnızca kalmasını istediğiniz sütunları seçin\nSütun adlarını tırnak işareti olmadan select() komutuna koyun. Sütunlar veri çerçevesinde istediğiniz sırayla görünürler. Var olmayan bir sütun eklerseniz, R’nin hata vereceğini unutmayın (bu durumda herhangi bir hata istemiyorsanız, aşağıdaki any_of() kullanımına bakın).\n\n# linelist veri tabanı, select() komutu aracılığıyla iletilir ve name() yalnızca sütun adlarını yazdırır\nlinelist %&gt;% \n  select(case_id, date_onset, date_hospitalisation, fever) %&gt;% \n  names()  # sütun isimlerini göster\n\n[1] \"case_id\"              \"date_onset\"           \"date_hospitalisation\"\n[4] \"fever\"               \n\n\n\n\n“tidyselect” yardımcı fonksiyonları\nBu yardımcı fonksiyonlar, tutulacak, atılacak veya dönüştürülecek sütunları belirlemeyi kolaylaştırmak için oluşturulmuştur. Bu fonksiyonlar, tidyverse’de bulunan ve dplyr fonksiyonlarında sütunların nasıl seçildiğinin gösteren tidyselect paketindendir.\nÖrneğin, sütunları yeniden sıralamak istiyorsanız, everything() “henüz belirtilmeyen tüm sütunları” göstermek için kullanışlı bir fonksiyondur. Aşağıdaki komutlar, date_onset ve date_hospitalisation sütunlarını veritabanının başına (soluna) taşır, ancak diğer tüm sütunları tutar. everything()’in boş parantezlerle yazıldığını unutmayın:\n\n# date_onset ve date_hospitalisation'ı başlangıca taşıyın\nlinelist %&gt;% \n  select(date_onset, date_hospitalisation, everything()) %&gt;% \n  names()\n\n [1] \"date_onset\"           \"date_hospitalisation\" \"case_id\"             \n [4] \"generation\"           \"date_infection\"       \"date_outcome\"        \n [7] \"outcome\"              \"gender\"               \"hospital\"            \n[10] \"lon\"                  \"lat\"                  \"infector\"            \n[13] \"source\"               \"age\"                  \"age_unit\"            \n[16] \"row_num\"              \"wt_kg\"                \"ht_cm\"               \n[19] \"ct_blood\"             \"fever\"                \"chills\"              \n[22] \"cough\"                \"aches\"                \"vomit\"               \n[25] \"temp\"                 \"time_admission\"       \"merged_header\"       \n[28] \"x28\"                 \n\n\nBurada dplyr fonksiyonları içinde çalışan select(), across() ve summarise() gibi diğer “tidyselect” yardımcı fonksiyonları yer almaktadır:\n\neverything() - belirtilmemiş tüm diğer sütunlar\n\nlast_col() - son sütun\nwhere() - tüm sütunlara bir fonksiyon uygular ve DOĞRU (TRUE) olanları seçer\n\ncontains() - karakter dizisi (string) içeren sütunlar\n\nörnek: select(contains(\"time\"))\n\n\nstarts_with() - belirli bir ön-ekle eşleşme\n\nörnek: select(starts_with(\"date_\"))\n\n\nends_with() - - belirli bir son-ekle eşleşme\n\nörnek: select(ends_with(\"_post\"))\n\n\nmatches() - normal bir ifadenin (regex) uygulanması için\n\nörnek: select(matches(\"[pt]al\"))\n\n\nnum_range() - sayısal aralık x01, x02, x03 gibi\nany_of() - IF sütunuyla eşleşir ancak bulunamazsa hata vermez\n\nörnek: select(any_of(date_onset, date_death, cardiac_arrest))\n\n\nEk olarak, birkaç sütunun listelenmesi için c() gibi normal operatörler kullanılır, : ardışık sütunlar için, ! zıtlar için, & AND (VE) için , | OR (YA DA) için kullanılır.\nSütunlar için mantıksal kriterler belirtmek için where() kullanın. where() içinde bir fonksiyon kullanıyorsanız, fonksiyonun boş parantezlerini dahil etmeyin. Aşağıdaki komut, sayısal özellikteki sütunları seçer.\n\n# Sayısal sınıfı olan sütunları seçin\nlinelist %&gt;% \n  select(where(is.numeric)) %&gt;% \n  names()\n\n[1] \"generation\" \"lon\"        \"lat\"        \"row_num\"    \"wt_kg\"     \n[6] \"ht_cm\"      \"ct_blood\"   \"temp\"      \n\n\nYalnızca sütun adının belirtilen bir karakter dizesini (string) içeren sütunları seçmek için include() kullanın. end_with() ve start_with() daha fazla detay sağlar.\n\n# belirli karakterleri içeren sütunları seçin\nlinelist %&gt;% \n  select(contains(\"date\")) %&gt;% \n  names()\n\n[1] \"date_infection\"       \"date_onset\"           \"date_hospitalisation\"\n[4] \"date_outcome\"        \n\n\nMatch() fonksiyonu, include() fonksiyonuna benzer şekilde çalışır, ancak bu fonksiyon ile parantez içinde OR (VEYA) çubuklarıyla (|) ayrılmış birden çok dize (string) gibi bir normal ifadeler sağlanabilir. (Karakterler ve dizeler sayfasına bakın):\n\n# birden fazla karakter eşleşmesi arandı\nlinelist %&gt;% \n  select(matches(\"onset|hosp|fev\")) %&gt;%   # VEYA sembolüne dikkat edin \"|\"\n  names()\n\n[1] \"date_onset\"           \"date_hospitalisation\" \"hospital\"            \n[4] \"fever\"               \n\n\nUYARI: Verdiğiniz sütun adlarından biri verilerde yoksa, R hata verebilir ve kodunuzu durdurabilir. Özellikle negatif seçimlerde (kaldır), var olan (ya da olmayan) sütunları seçmek için any_of() kullanmak faydalıdır.\nBu sütunlardan yalnızca biri var, ancak herhangi bir hata üretilmiyor ve kod, temizleme zincirinizi durdurmadan devam ediyor.\n\nlinelist %&gt;% \n  select(any_of(c(\"date_onset\", \"village_origin\", \"village_detection\", \"village_residence\", \"village_travel\"))) %&gt;% \n  names()\n\n[1] \"date_onset\"\n\n\n\n\nSütunları kaldır\nSütun adının önüne bir eksi “-” sembolü (örn. select(-outcome)) veya sütun adları vektörü (aşağıdaki gibi) belirterek hangi sütunların kaldırılacağını belirtin. Diğer tüm sütunlar korunacaktır.\n\nlinelist %&gt;% \n  select(-c(date_onset, fever:vomit)) %&gt;% # date_onset ve tüm sütunları ateşten kusmaya kadar kaldırın\n  names()\n\n [1] \"case_id\"              \"generation\"           \"date_infection\"      \n [4] \"date_hospitalisation\" \"date_outcome\"         \"outcome\"             \n [7] \"gender\"               \"hospital\"             \"lon\"                 \n[10] \"lat\"                  \"infector\"             \"source\"              \n[13] \"age\"                  \"age_unit\"             \"row_num\"             \n[16] \"wt_kg\"                \"ht_cm\"                \"ct_blood\"            \n[19] \"temp\"                 \"time_admission\"       \"merged_header\"       \n[22] \"x28\"                 \n\n\nBir sütunu R tabanı sözdizimini kullanarak, onu ‘NULL’ olarak tanımlayarak da kaldırabilirsiniz. Örneğin:\n\nlinelist$date_onset &lt;- NULL   # R tabanı sözdizimine sahip sütunu siler\n\n\n\nBağımsız (Standalone)\nselect() tüneldan bağımsız bağımsız bir komut olarak da kullanılabilir. Bu durumda, ilk argüman, üzerinde çalışılacak orijinal veri çerçevesidir.\n\n# id ve yaşla ilgili sütunlarla yeni bir satır listesi oluşturun\nlinelist_age &lt;- select(linelist, case_id, contains(\"age\"))\n\n# Sütun adlarını göster\nnames(linelist_age)\n\n[1] \"case_id\"  \"age\"      \"age_unit\"\n\n\n\nTünel zincirine ekleme\nlinelist_raw’da ihtiyacımız olmayan birkaç sütun var: row_num, merged_header ve x28. Bunları temizleme tünel zincirinde bir select() komutuyla kaldırıyoruz:\n\n# TEMİZLİK 'BORU' ZİNCİRİ (ham verilerle başlar ve temizleme adımları boyunca iletir)\n##################################################################################\n\n# tünel zincirini temizlemeye başla\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # sütun adı sintaksını standartlaştır\n    janitor::clean_names() %&gt;% \n    \n    # sütunları manuel olarak yeniden adlandır\n           # YENİ isim           # ESKİ isim\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # YUKARIDAKİ TEMİZLİK ADIMLARI ZATEN TARTIŞILMIŞTIR\n    #####################################################\n\n    # satırı sil\n    select(-c(row_num, merged_header, x28))",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Veri temizliği ve temel fonksiyonlar</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.tr.html#tekilleştirme",
    "href": "new_pages/cleaning.tr.html#tekilleştirme",
    "title": "8  Veri temizliği ve temel fonksiyonlar",
    "section": "8.6 Tekilleştirme",
    "text": "8.6 Tekilleştirme\nVerilerin tekilleştirilmesinin nasıl yapılacağına ilişkin kapsamlı seçenekler için el kitabı Tekilleştirme sayfasına bakın. Burada yalnızca çok basit bir satır tekilleştirme örneği sunulmuştur.\ndplyr paketi, distinct() fonksiyonunu içerir. Bu fonksiyon, her satırı inceler ve veri çerçevesini yalnızca benzersiz satırlara indirger. Yani %100 tekrarlayan satırları kaldırır.\nYinelenen satırları değerlendirirken, bir dizi sütun dikkate alınır (varsayılan ayar olarak tüm sütunlar dikkate alınır). Tekilleştirme sayfasında gösterildiği gibi, sütun aralığı, yalnızca belirli sütunlara göre satır benzersizliği değerlendirilecek şekilde ayarlanabilir.\nBu basit örnekte, tünel zincirine sadece distinct () boş komutunu ekliyoruz. Bu, diğer satırların %100 kopyası olan hiçbir satır olmamasını sağlar (burada tüm sütunlarda değerlendirilir).\nLinelist’te nrow(linelist) satırları ile başlıyoruz.\n\nlinelist &lt;- linelist %&gt;% \n  distinct()\n\nTekilleştirmeden sonra nrow(linelist) satırları kalır. Kaldırılan herhangi bir satır, diğer satırların %100 kopyasıdır.\nAşağıda, temizleme tünel zincirine distinct() komutu eklenir:\n\n# TEMİZLİK 'BORU' ZİNCİRİ (ham verilerle başlar ve temizleme adımları boyunca iletir)\n##################################################################################\n\n# tünel zincirini temizlemeye başla\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # sütun adı sintaksını standartlaştır\n    janitor::clean_names() %&gt;% \n    \n    # sütunları manuel olarak yeniden adlandır\n           # YENİ isim           # ESKİ isim\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # sütunu sil\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # YUKARIDAKİ TEMİZLİK ADIMLARI ZATEN TARTIŞILMIŞTIR\n    #####################################################\n    \n    # tekilleştirme\n    distinct()",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Veri temizliği ve temel fonksiyonlar</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.tr.html#sütun-oluşturma-ve-dönüştürme",
    "href": "new_pages/cleaning.tr.html#sütun-oluşturma-ve-dönüştürme",
    "title": "8  Veri temizliği ve temel fonksiyonlar",
    "section": "8.7 Sütun oluşturma ve dönüştürme",
    "text": "8.7 Sütun oluşturma ve dönüştürme\nYeni bir sütun eklemek veya mevcut bir sütunu değiştirmek için dplyr mutate() fonksiyonunu kullanmanızı öneririz.\nAşağıda, mutate() ile yeni bir sütun oluşturmaya bir örnek verilmiştir. Sintaksı: mutate(new_column_name = value or transformation)\nBu Stata’da, generate komutuna benzer, ancak R’ın mutate() fonksiyonu de mevcut bir sütunu değiştirmek için kullanılabilir.\n\nYeni sütunlar\nYeni bir sütun oluşturmak için en temel mutate() komutu aşağıdaki gibdir görünebilir. Her satırdaki değerin 10 olduğu yeni bir new_col sütunu oluşturur.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(new_col = 10)\n\nHesaplamalar için diğer sütunlardaki değerlere de başvurabilirsiniz. Aşağıda, her vaka için Vücut Kitle İndeksi’ni (VKİ) hesaplamak için yeni bir BMI sütunu oluşturulmuştur - VKİ = kg/m^2 formülü kullanılarak, ht_cm sütunu ve wt_kg sütunu kullanılarak hesaplanmıştır.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(bmi = wt_kg / (ht_cm/100)^2)\n\nBirden çok yeni sütun oluşturuyorsanız, her birini bir virgül ve yeni bir satırla ayırın. Aşağıda, stringr paketinden str_glue() kullanılarak birleştirilen diğer sütunlardan gelen değerlerden oluşanlar da dahil olmak üzere yeni sütun örnekleri verilmiştir (Karakterler ve dizeler sayfasına bakın.)\n\nnew_col_demo &lt;- linelist %&gt;%                       \n  mutate(\n    new_var_dup    = case_id,             # yeni sütun = mevcut başka bir sütunu çoğalt/kopyala\n    new_var_static = 7,                   # yeni sütun = tüm değerler aynı\n    new_var_static = new_var_static + 5,  # bir sütunun üzerine yazabilirsiniz ve bu, diğer değişkenleri kullanan bir hesaplama olabilir\n    new_var_paste  = stringr::str_glue(\"{hospital} on ({date_hospitalisation})\") # yeni sütun = diğer sütunlardaki değerleri birbirine yapıştırma\n    ) %&gt;% \n  select(case_id, hospital, date_hospitalisation, contains(\"new\"))        # tanıtım amacıyla yalnızca yeni sütunları göster\n\nYeni sütunları inceleyin. Gösterim amacıyla, yalnızca yeni sütunlar ve bunları oluşturmak için kullanılan sütunlar sunulmuştur.\n\n\n\n\n\n\nİPUCU: : mutate() üzerindeki varyasyonlar için transmute() fonksiyonu kullanılır. Bu fonksiyon, mutate() gibi yeni bir sütun ekler, ancak parantez içinde bahsetmediğiniz diğer tüm sütunları da bırakır/kaldırır.\n\n# yukarıda oluşturulan yeni demo sütunlarını kaldırır\n# linelist &lt;- linelist %&gt;% \n#   select(-contains(\"new_var\"))\n\n\n\nSütun sınıfının dönüşümü\nTarihler, sayılar veya mantıksal değerler (DOĞRU/YANLIŞ) içeren sütunlar, yalnızca doğru şekilde sınıflandırıldıklarında beklendiği gibi davranacaktır. Sınıf tipi “2” ile sayısal 2 arasında fark vardır!\nİçe aktarma komutları sırasında sütun sınıfını ayarlamanın yolları vardır, ancak bu genellikle zahmetlidir. Nesnelerin ve sütunların sınıfını dönüştürme hakkında daha fazla bilgi edinmek için nesne sınıflarıyla ilgili R Temelleri bölümüne bakın.\nİlk olarak, önemli sütunların doğru sınıf olup olmadıklarını görmek için bazı kontroller yapalım. Bunu başlangıçta skim() komutunu çalıştırdığımızda da görmüştük.\nŞu anda, yaş sütununun sınıfı karakterdir. Nicel analizler yapmak için bu sayıların sayısal olarak tanınmasına ihtiyacımız var!\n\nclass(linelist$age)\n\n[1] \"character\"\n\n\ndate_onset sütununun sınıfı da karakterdir! Analiz yapabilmek için bu tarihlerin tarih olarak kabul edilmesi gerekir!\n\nclass(linelist$date_onset)\n\n[1] \"character\"\n\n\nBunu çözmek için, dönüştürülmüş bir sütunu yeniden tanımlamak için mutate() fonksiyonunu kullanın. Sütunu kendisi olarak tanımlıyoruz, ancak farklı bir sınıfa dönüştürüyoruz. age sütununun sayısal sınıfta olmasını sağlayan veya dönüştüren temel bir örnek:\n\nlinelist &lt;- linelist %&gt;% \n  mutate(age = as.numeric(age))\n\nBenzer şekilde, as.character() ve as.logical() kullanabilirsiniz. Faktör sınıfına dönüştürmek için, temel R’den factor() veya forcats’tan as_factor() kullanabilirsiniz. Faktörler sayfasında bu konuyla ilgili daha fazla bilgi edinebilirsiniz.\nTarih sınıfına geçerken dikkatli olmalısınız. Tarihlerle çalışma sayfasında çeşitli yöntemler açıklanmıştır. Tipik olarak, dönüştürmenin doğru çalışması için ham tarih değerlerinin tümü aynı biçimde olmalıdır (ör. “AA/GG/YYYY” veya “GG AA YYYY”). Tarih sınıfına dönüştürdükten sonra, her bir değerin doğru şekilde dönüştürüldüğünü doğrulamak için verilerinizi kontrol edin.\n\n\nGruplandırılmış veri\nVeri çerçeveniz zaten gruplanmışsa (verileri gruplama ile ilgili sayfaya bakın), mutate() veri çerçevesinin gruplanmamasındaki gruba göre farklı davranabilir. Ortalama(), medyan(), max(), vb. gibi herhangi bir özetleme fonksiyonu, tüm satırlara göre değil, gruba göre hesaplayacaktır.\n\n# TÜM satırların ortalamasına göre normalleştirilmiş yaş\nlinelist %&gt;% \n  mutate(age_norm = age / mean(age, na.rm=T))\n\n# hastane grubunun ortalamasına göre normalize edilmiş yaş\nlinelist %&gt;% \n  group_by(hospital) %&gt;% \n  mutate(age_norm = age / mean(age, na.rm=T))\n\nTidyverse mutate belgelerinden gruplanmış veri çerçevelerinde mutate () kullanma hakkında daha fazla bilgi edinebilirsiniz. tidyverse mutate dökümanları.\n\n\nBirden çok sütunu dönüştürün\nGenellikle kısa bir kod ile aynı dönüşümü birden çok sütuna aynı anda uygulamak amaçlanır. dplyr paketindeki (ayrıca tidyverse paketinde de bulunur) across() fonksiyonu kullanılarak aynı anda birden çok sütuna bir dönüşüm uygulanabilir. across() herhangi bir dplyr fonksiyonuyla kullanılabilir, ancak genellikle select(), mutate(), filter() veya summarise() içinde kullanılır. Tanımlayıcı tablolar sayfasındaki summarise() fonksiyonuna nasıl uygulandığını inceleyin.\n.cols = argümanına sütunlar ve .fns = argümanına uygulanacak fonksiyonlar atanır. .fns fonksiyonuna sağlanacak herhangi bir argüman, yine across() içinde olmak üzere virgülden sonra dahil edilebilir.\n\nacross() sütun seçimi\n.cols = argümanı ile sütunlarını seçin. Bunları tek tek adlandırabilir veya “tidyselect” yardımcı fonksiyonlarını kullanabilirsiniz. Fonksiyonu .fns = ile belirtin. Aşağıda gösterilen fonksiyon modunu kullanarak, fonksiyonun parantez ( ) olmadan yazıldığını unutmayın.\nBurada as.character() dönüşümü, across() içinde tanımlanmış belirli sütunlara uygulanır.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))\n\nSütunları belirlemede size yardımcı olmak için “tidyselect” yardımcı fonksiyonları mevcuttur. Yukarıda Sütunları seçme ve yeniden sıralama bölümünde ayrıntılı olarak açıklanmıştır ve şu komutları içerir: everything(), last_col(), where(), starts_with(), ends_with(), contains(), matches(), num_range() ve any_of().\nTüm sütunların karakter sınıfına nasıl değiştirileceğine dair bir örnek:\n\n#tüm sütunları karakter sınıfına değiştirmek için\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = everything(), .fns = as.character))\n\nAdın “tarih” dizesini içerdiği tüm sütunları karaktere dönüştürün (virgül ve parantezlerin yerleşimine dikkat edin\n\n#tüm sütunları karakter sınıfına değiştirmek için\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = contains(\"date\"), .fns = as.character))\n\nAşağıda, POSIXct sınıfı (zaman damgalarını gösteren ham bir tarihzaman sınıfı) olan sütunları değiştirmenin bir örneği. Başka bir deyişle, burada fonksiyon is.POSIXct() DOĞRU olarak değerlendirilir. Daha sonra, bu sütunları normal bir Date sınıfına dönüştürmek için bu sütunlara as.Date() fonksiyonu uygulanır.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = where(is.POSIXct), .fns = as.Date))\n\n• Across() içinde, is.POSIXct’in DOĞRU veya YANLIŞ olarak değerlendirdiği where() fonksiyonunu da kullandığımızı unutmayın. • is.POSIXct() komutunun lubridate paketinden olduğunu unutmayın. is.character(), is.numeric() ve is.logical() gibi diğer benzer “is” fonksiyonları R tabanı’ndadır.\n\n\nacross() fonksiyonları\nacross() fonksiyonlarına ilişkin ayrıntılar için ?across ile ilgili belgeleri okuyabilirsiniz. Birkaç özet nokta: Bir sütunda gerçekleştirilecek fonksiyonları belirtmenin birkaç yolu vardır ve hatta kendi fonksiyonlarınızı tanımlayabilirsiniz: • Yalnızca fonksiyon adını sağlayabilirsiniz (örneğin, mean veya as.character) • Fonksiyonu purr stilinde yazabilirsinizi (örneğin ~ mean(.x, na.rm = TRUE)) (bu sayfaya bakabilirsiniz)\n* • Bir liste ile çoklu fonksiyonlar belirlenebilir (örneğin list(mean = mean, n_miss = ~ sum(is.na(.x))). • Birden çok fonkisyon yazarsanız, giriş sütunu başına farklı adlarla col_fn biçiminde birden çok dönüştürülmüş sütun oluşturulur. Yeni sütunların .names = argümanıyla nasıl adlandırılacağını, {.col} ve {.fn}’nin giriş sütunu ve fonksiyonu için kısayol olduğu tutkal sintaksının Karakterler ve dizeler sayfasına bakınız) kullanarak ayarlayabilirsiniz.\nBurada across()kullanımı için online kaynaklar yer almakta: yaratıcı Hadley Wickham’ın düşünceleri\n\n\n\ncoalesce()\nBu dplyr fonksiyonu, her konumda eksik olmayan ilk değeri bulur. Eksik değerleri, belirttiğiniz sırayla ilk kullanılabilir değerle “doldurur”.\nİşte bir veri çerçevesi bağlamı dışında bir örnek: Diyelim ki, biri hastanın tespit edildiği köyü ve diğeri hastanın ikamet ettiği köyü içeren iki vektörünüz var. Her dizin için eksik olmayan ilk değeri seçmek için birleştirmeyi kullanabilirsiniz:\n\nvillage_detection &lt;- c(\"a\", \"b\", NA,  NA)\nvillage_residence &lt;- c(\"a\", \"c\", \"a\", \"d\")\n\nvillage &lt;- coalesce(village_detection, village_residence)\nvillage    # yazdır\n\n[1] \"a\" \"b\" \"a\" \"d\"\n\n\nBu fonksiyon, veri çerçevesi sütunlarıyla da aynı şekilde çalışır: her satır için fonksiyon, belirtilen sütunlarda (sırayla) ilk eksik olmayan değerle yeni sütun değerini atar.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(village = coalesce(village_detection, village_residence))\n\nBu, “satır bazında” bir işlem örneğidir. Daha karmaşık satır bazında hesaplamalar için aşağıdaki satır bazında hesaplamalar bölümüne bakın.\n\n\nKümülatif Matematik\nBir sütunun, bir veri çerçevesinin satırlarında o noktaya kadar değerlendirildiği kümülatif toplamı/ortalama/min/maks vb. yansıtmasını istiyorsanız, aşağıdaki fonksiyonları kullanın:\ncumsum() aşağıda gösterildiği gibi kümülatif toplamı verir:\n\nsum(c(2,4,15,10))     # sadece bir sayı verir\n\n[1] 31\n\ncumsum(c(2,4,15,10))  # her basamaktaki kümülatif toplamı verir\n\n[1]  2  6 21 31\n\n\nBu, veri çerçevesinde yeni bir sütun oluştururken de kullanılabilir. Örneğin, bir salgında günlük kümülatif vaka sayısını hesaplamak için şöyle bir kod düşünün:\n\ncumulative_case_counts &lt;- linelist %&gt;%  # linelist ile başlayan vakalar\n  count(date_onset) %&gt;%                 # 'n' sütunu olarak günlük satır sayısı   \n  mutate(cumulative_cases = cumsum(n))  # her satırdaki kümülatif toplamın yeni sütunu\n\nAşağıda ilk 10 satır görülmektedir:\n\nhead(cumulative_case_counts, 10)\n\n   date_onset n cumulative_cases\n1  2012-04-15 1                1\n2  2012-05-05 1                2\n3  2012-05-08 1                3\n4  2012-05-31 1                4\n5  2012-06-02 1                5\n6  2012-06-07 1                6\n7  2012-06-14 1                7\n8  2012-06-21 1                8\n9  2012-06-24 1                9\n10 2012-06-25 1               10\n\n\nEpikurve ile kümülatif insidansın nasıl çizileceğini öğrenmek için Epidemik eğriler sayfasına bakın.\nBunlara da bakın: cumsum(), cummean(), cummin(), cummax(), cumany(), cumall()\n\n\nR Tabanı kullanımı\nTemel R’I (R Tabanı) kullanarak yeni bir sütun tanımlamak (veya bir sütunu yeniden tanımlamak) için, $ ile bağlantılı veri çerçevesinin adını yeni sütuna (veya değiştirilecek sütuna) yazın. Yeni değer(ler)i tanımlamak için &lt;- atama operatörünü kullanın. Temel R’I kullanırken, her seferinde sütun adından önce veri çerçevesi adını belirtmeniz gerektiğini unutmayın (örn. dataframe$column). Aşağıda, temel R kullanarak bmi sütunu oluşturmaya bir örnek verilmiştir:\n\nlinelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)\n\n\n\nTünel zincirine ekleme yapma\nAşağıda, tünel zincirine yeni bir sütun eklenir ve bazı sınıflar dönüştürülür.\n\n# TEMİZLİK 'BORU' ZİNCİRİ (ham verilerle başlar ve temizleme adımları boyunca iletir)\n##################################################################################\n\n# tünel zincirini temizlemeye başlayın\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # sütun adı sintaksını standartlaştır\n    janitor::clean_names() %&gt;% \n    \n    # sütunları manuel olarak yeniden adlandır\n           # YENİ isim             # ESKİ isim\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # sütunu sil\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # tekilleştir\n    distinct() %&gt;% \n  \n    # YUKARIDAKİ TEMİZLİK ADIMLARI ZATEN TARTIŞILMIŞTIR\n    ###################################################\n    # yeni bir sütun ekle\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %&gt;% \n  \n    # sütun sınıfını değiştir\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age))",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Veri temizliği ve temel fonksiyonlar</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.tr.html#değerlerin-yeniden-kodlanması",
    "href": "new_pages/cleaning.tr.html#değerlerin-yeniden-kodlanması",
    "title": "8  Veri temizliği ve temel fonksiyonlar",
    "section": "8.8 Değerlerin yeniden kodlanması",
    "text": "8.8 Değerlerin yeniden kodlanması\nDeğerleri yeniden kodlamanız (değiştirmeniz) gereken birkaç senaryo:\n• Belirli bir değeri düzenlemek için (örneğin, yanlış bir yıl veya biçime sahip bir tarih) • Aynı şekilde yazılmayan değerleri uzlaştırmak için • Yeni bir kategorik değerler sütunu oluşturmak için • yeni bir sayısal kategori sütunu oluşturmak için (ör. Yaş kategorileri)\n\nSpesifik değerler\nDeğerleri manuel olarak değiştirmek için mutate() fonksiyonu içindeki recode() fonksiyonunu kullanabilirsiniz. Verilerde uygun olmayan bir tarih olduğunu düşünün (örneğin “2014-14-15”): tarihi ham kaynak verilerde manuel olarak düzeltebilir veya değişikliği mutate() ve recode( aracılığıyla temizleme hattına yazabilirsiniz. ).\nİkincisi daha şeffaftır ve analizinizi anlamak veya tekrarlamak isteyen herkes için tekrarlanabilir.\n\n# hatalı değerleri düzelt                   # eski değer       # yeni değer\nlinelist &lt;- linelist %&gt;% \n  mutate(date_onset = recode(date_onset, \"2014-14-15\" = \"2014-04-15\"))\n\nYukarıdaki mutate() satırı şu şekilde okunabilir: date_onset sütununu, yeniden kodlanan date_onset sütununa eşit olacak şekilde değiştirin, böylece ESKİ DEĞER YENİ DEĞER olarak değiştirilir”. recode() için bu kalıbın (ESKİ = YENİ) diğer R kalıplarının çoğunun (yeni = eski) tersi olduğuna dikkat edin. R geliştirme topluluğu bunu gözden geçirmek için çalışmaktadır.\nİşte bir sütun içinde birden çok değeri yeniden kodlayan başka bir örnek.\nLinelist’te “hospital” sütunundaki değerler temizlenmelidir. Birkaç farklı yazım ve birçok eksik değer var.\n\ntable(linelist$hospital, useNA = \"always\")  # eksik olanlar dahil tüm benzersiz değerlerin tablosunu yazdır\n\n\n                     Central Hopital                     Central Hospital \n                                  11                                  457 \n                          Hospital A                           Hospital B \n                                 290                                  289 \n                    Military Hopital                    Military Hospital \n                                  32                                  798 \n                    Mitylira Hopital                    Mitylira Hospital \n                                   1                                   79 \n                               Other                         Port Hopital \n                                 907                                   48 \n                       Port Hospital St. Mark's Maternity Hospital (SMMH) \n                                1756                                  417 \n  St. Marks Maternity Hopital (SMMH)                                 &lt;NA&gt; \n                                  11                                 1512 \n\n\nAşağıdaki recode() komutu, “hastane” sütununu belirtilen yeniden kodlama değişiklikleriyle geçerli “hastane” sütunu olarak yeniden tanımlar. Her birinden sonra virgül koymayı unutmayın!\n\nlinelist &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital,\n                     # kaynak için: ESKİ = YENİ\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      ))\n\nŞimdi hospital sütunundaki yazımların düzeltildiğini ve birleştiğini görüyoruz:\n\ntable(linelist$hospital, useNA = \"always\")\n\n\n                    Central Hospital                           Hospital A \n                                 468                                  290 \n                          Hospital B                    Military Hospital \n                                 289                                  910 \n                               Other                        Port Hospital \n                                 907                                 1804 \nSt. Mark's Maternity Hospital (SMMH)                                 &lt;NA&gt; \n                                 428                                 1512 \n\n\nİPUCU: Eşittir işaretinden önceki ve sonraki boşluk sayısı önemli değildir. Satırlar için = işaretini hizalayarak kodunuzun okunmasını kolaylaştırın. Ayrıca, gelecekteki okuyucular için hangi tarafın ESKİ ve hangi tarafın YENİ olduğunu netleştirmek için bir yorum satırı (#) eklemeyi düşünün. \nİPUCU: Bazen bir veri kümesinde boş bir karakter değeri bulunur (R tarafından eksik (NA) olarak tanınmaz). Bu değere, aralarında boşluk (““) olmadan iki tırnak işareti ile başvurabilirsiniz.\n\n\nMantık kullanımı\nAşağıda, mantık ve koşulların kullanımıyla bir sütundaki değerlerin nasıl yeniden kodlanacağını gösteriyoruz:\n• Basit mantık için replace(), ifelse() ve if_else() kullanımı • Daha karmaşık mantık için case_when() kullanımı\n\n\nBasit mantık\n\nreplace()\nBasit mantık kriterleriyle yeniden kodlamak için mutate() içinde replace() öğesini kullanabilirsiniz. replace(), temel R’daki bir fonksiyondur. Değiştirilecek satırları belirtmek için bir mantık koşulu kullanın. Genel sintaks şöyledir:\nmutate(col_to_change = replace(col_to_change, criteria for rows, new value)).\nreplace() fonksiyonunun en yaygın kullanımı; benzersiz bir satır tanımlayıcısı kullanarak bir satırdaki yalnızca bir değeri değiştirmektir. Aşağıda, case_id sütununun “2195” olduğu satırda cinsiyet “Kadın” olarak değiştirilmiştir.\n\n# Örnek: belirli bir gözlemin cinsiyetini \"Female\" olarak değiştirin\nlinelist &lt;- linelist %&gt;% \n  mutate(gender = replace(gender, case_id == \"2195\", \"Female\"))\n\nTemel R sintaksı ve dizinleme parantezlerini [ ] kullanan eşdeğer komut aşağıdadır. “Veri çerçevesi satır listesinin gender sütun değerini (satır listesinin case_id sütununda ‘2195’ değerine sahip olduğu satır için) ‘Kadın’ olarak değiştirin” olarak okunur.\n\nlinelist$gender[linelist$case_id == \"2195\"] &lt;- \"Female\"\n\n\n\nifelse() ve if_else()\nABasit mantık için başka bir araç ifelse() ve if_else()’dir. Bununla birlikte, çoğu durumda yeniden kodlama için case_when() kullanmak daha kolaydır (aşağıda ayrıntılı olarak açıklanmıştır). Bu “if else” komutları, if ve else programlama ifadelerinin basitleştirilmiş versiyonlarıdır. Genel sözdizimi şöyledir: ifelse(condition, value to return if condition evaluates to TRUE, value to return if condition evaluates to FALSE)\nAşağıda, source_known sütunu tanımlanmıştır. Sütun kaynağındaki satırın değeri eksik değilse, belirli bir satırdaki değeri “bilinen” olarak ayarlanır. Kaynaktaki değer eksikse, kaynak_bilinen içindeki değer “bilinmeyen” olarak ayarlanır.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(source_known = ifelse(!is.na(source), \"known\", \"unknown\"))\n\nif_else(), tarihleri işleyen dplyr’in özel bir sürümüdür. “doğru” değer bir tarihse, “yanlış” değerin de bir tarihi nitelemesi gerektiğini, dolayısıyla yalnızca NA yerine NA_real_ özel değerinin kullanması gerektiğini unutmayın.\n\n# Hasta ölmediyse NA olan bir ölüm tarihi sütunu oluşturun.\nlinelist &lt;- linelist %&gt;% \n  mutate(date_death = if_else(outcome == \"Death\", date_outcome, NA_real_))\n\nBirçok ifelse komutunu bir araya getirmekten kaçının… bunun yerine case_When() kullanın! case_When() çok daha kolay okunur ve daha az hata yaparsınız.\n\n\n\n\n\n\n\n\n\nBir veri çerçevesi bağlamı dışında, kodunuzda kullanılan bir nesnenin değerini değiştirmesini istiyorsanız, temel R’dan switch() kullanmayı düşünün.\n\n\n\nKarmaşık mantık\nBirçok yeni gruba yeniden kodlama yapıyorsanız veya değerleri yeniden kodlamak için karmaşık mantıksal ifadeler kullanmanız gerekiyorsa dplyr’in case_when() fonksiyonunu kullanın. Bu fonkisyon, veri çerçevesindeki her satırı değerlendirir, satırların belirtilen kriterleri karşılayıp karşılamadığını değerlendirir ve doğru yeni değeri atar.\ncase_When() komutları, “tilde” ~ ile ayrılmış Sağ Taraf (RHS) ve Sol Taraf (LHS) içeren ifadelerden oluşur. Mantık kriterleri her bir ifadenin sol tarafında ve ilgili değerler sağ tarafındadır. İfadeler virgülle ayrılır.\nÖrneğin, burada age_years sütunu oluşturmak için age ve age_unit sütunlarını kullanıyoruz:\n\nlinelist &lt;- linelist %&gt;% \n  mutate(age_years = case_when(\n            age_unit == \"years\"  ~ age,       # yaş yıl olarak verildiyse\n            age_unit == \"months\" ~ age/12,    # yaş ay olarak verildiyse\n            is.na(age_unit)      ~ age))      # yaş birimi eksikse, yıl varsayın\n                                              # Başka herhangi bir senaryo NA olarak atanır\n\nVerilerdeki her satır değerlendirilirken, kriterler case_when() ifadelerinin yazıldığı sırayla - yukarıdan aşağıya - uygulanır/değerlendirilir. Belirli bir satır için en üstteki ölçüt DOĞRU olarak değerlendirilirse, RHS değeri atanır ve kalan ölçütler o satır için test edilmez. Bu nedenle, en spesifik kriterleri önce ve en genel olanı en son yazmak en iyisidir.\nBu satırlar boyunca, son ifadenizde, önceki kriterlerden herhangi birini karşılamayan satırları yakalayacak şekilde, sol tarafa DOĞRU’yu yerleştirin. Bu ifadenin sağ tarafına “kontrol et!” gibi bir değer atanabilir. veya eksik olarak değerlendirilir.\nAşağıda, doğrulanmış ve şüpheli vakalar için bir vaka tanımına göre hasta sınıflandırmasıyla yeni bir sütun oluşturmak için kullanılan bir başka case_when() örneği yer almaktadır:\n\nlinelist &lt;- linelist %&gt;% \n     mutate(case_status = case_when(\n          \n          # if patient had lab test and it is positive,\n          # then they are marked as a confirmed case \n          ct_blood &lt; 20                   ~ \"Confirmed\",\n          \n          # given that a patient does not have a positive lab result,\n          # if patient has a \"source\" (epidemiological link) AND has fever, \n          # then they are marked as a suspect case\n          !is.na(source) & fever == \"yes\" ~ \"Suspect\",\n          \n          # any other patient not addressed above \n          # is marked for follow up\n          TRUE                            ~ \"To investigate\"))\n\nTEHLİKE: Sağ taraftaki değerlerin tümü aynı sınıfta olmalıdır - sayısal, karakter, tarih, mantıksal vb. Eksik (NA) ya senaryoyu ele almadan bırakın ya da NA_character_, NA_real_ (sayısal veya POSIX) ve as.Date(NA) gibi NA’nın özel varyasyonlarını kullanmanız gerekebilir. Tarihlerle çalışma bölümünden daha fazlasını okuyabilirsiniz.\n\n\nEksik değerler\nAşağıda, veri temizleme bağlamında eksik değerlerle çalışmak için özel fonksiyonlar bulunmaktadır.\nEksik değerleri belirleme ve işleme konusunda daha ayrıntılı bilgi için Eksik veriler sayfasına bakın. Örneğin, eksik olup olmadığını mantıksal olarak test eden is.na() fonksiyonu.\nreplace_na()\nEksik değerleri (NA), “Eksik” gibi belirli bir değerle değiştirmek için, mutate() içindeki dplyr replace_na() fonksiyonunu kullanın. Bunun yukarıdaki recode ile aynı şekilde kullanıldığını unutmayın - değişkenin adı replace_na() içinde tekrarlanmalıdır.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(hospital = replace_na(hospital, \"Missing\"))\n\nfct_explicit_na()\nBu, forcats paketinden bir fonksiyondur. forcats paketi, faktör sınıfının sütunlarını işler. Faktörler, R’nin c(“Birinci”, “İkinci”, “Üçüncü”) gibi sıralı değerleri işleme veya değerlerin (örn. hastaneler) tablolarda ve çizimlerde görünme sırasını belirleme yöntemidir. Faktörler sayfasını inceleyin.\nVerileriniz Faktör sınıfı ise ve replace_na() kullanarak NA’yı “Eksik”e dönüştürmeye çalışırsanız, şu hatayı alırsınız: geçersiz faktör düzeyi, NA oluşturuldu. Faktörün olası bir düzeyi olarak “Eksik” değerini bir değer olarak eklemeye çalıştığınızda reddedilirsiniz.\nBunu çözmenin en kolay yolu, bir sütunu sınıf faktörüne ve NA değerlerini “(Missing)” karakterine dönüştüren forcats fonksiyonunu fct_explicit_na() kullanmaktır.\n\nlinelist %&gt;% \n  mutate(hospital = fct_explicit_na(hospital))\n\nDaha yavaş bir alternatif, fct_expand() kullanarak faktör düzeyini eklemek ve ardından eksik değerleri dönüştürmek olabilir.\nna_if()\nBelirli bir değeri NA’ya dönüştürmek için dplyr’in na_if() fonksiyonunu kullanın. Aşağıdaki komut, replace_na() fonksiyonunun tersi işlemini gerçekleştirir. Aşağıdaki örnekte, hastane sütunundaki herhangi bir “Eksik” değeri NA’ya dönüştürülür.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(hospital = na_if(hospital, \"Missing\"))\n\nNot: na_if() mantık kriterleri için kullanılamaz (örneğin, “tüm değerler &gt; 99”) - bunun için replace() veya case_when() kullanın:\n\n# 40'ın üzerindeki sıcaklıkları NA'ya dönüştürün\nlinelist &lt;- linelist %&gt;% \n  mutate(temp = replace(temp, temp &gt; 40, NA))\n\n#  1 Ocak 2000'den önceki başlangıç tarihlerini eksik tarihlere dönüştürün\nlinelist &lt;- linelist %&gt;% \n  mutate(date_onset = replace(date_onset, date_onset &gt; as.Date(\"2000-01-01\"), NA))\n\n\n\nSözlüğün temizlenmesi\nBir veri çerçevesini bir temizleme sözlüğü ile temizlemek için R paketi satır matchmaker ve match_df() fonksiyonunu kullanın.\n\n3 sütunlu bir temizleme sözlüğü oluşturun: • Bir “-den” sütunu (yanlış değer) • Bir “-e” sütunu (doğru değer) • Değişikliklerin uygulanacağı sütunu belirten bir sütun (veya tüm sütunlara uygulanacak “.global”)\n\nNot: .global sözlük girişleri, sütuna özel sözlük girişleri tarafından geçersiz kılınacaktır.\n\n\n\n\n\n\n\n\n\n\nSözlük dosyasını R’a aktarın. Bu örnek, El kitabı ve veri indirme sayfasındaki talimatlar aracılığıyla indirilebilir.\n\n\ncleaning_dict &lt;- import(\"cleaning_dict.csv\")\n\n\nHam satır listesini, dictionary = temizleme sözlüğü veri çerçevesini belirterek match_df() öğesine iletin. from = argümanı “eski” değerleri içeren sözlük sütununun adı olmalıdır, by = argümanı karşılık gelen “yeni” değerleri içeren sözlük sütunu olmalıdır ve üçüncü sütun değişikliğin yapılacağı sütunu listeler. Bir değişikliği tüm sütunlara uygulamak için by = sütununda .global kullanın. Dördüncü bir sözlük sütunu olan order yeni değerlerin faktör sırasını belirtmek için kullanılabilir. Bu fonksiyonun çalışmasının uzun zaman alabileceğini unutmayın.\n\nDaha fazla ayrıntıyı ?match_df komutunu çalıştırarak paket dokümantasyonu adresinden okuyabilirsiniz.\n\nlinelist &lt;- linelist %&gt;%               # veri setinizi sağlayın veya borulayın\n     matchmaker::match_df(\n          dictionary = cleaning_dict,  # sözlüğünüzün adı\n          from = \"from\",               # değiştirilecek değerlerin bulunduğu sütun (varsayılan değer col 1'dir)\n          to = \"to\",                   # nihai değerleri içeren sütun (varsayılan değer 2. sütundur)\n          by = \"col\"                   # sütun adları ile sütun (varsayılan col 3'tür)\n  )\n\nŞimdi değerlerin nasıl değiştiğini görmek için sağa kaydırın - özellikle cinsiyet (küçük harften büyük harfe) ve tüm semptom sütunları evet/hayır’dan 1/0’a dönüştürülmüşür.\n\n\n\n\n\n\nTemizleme sözlüğündeki sütun adlarınızın, temizleme komut dosyanızın bu noktasındaki adlara karşılık gelmesi gerektiğini unutmayın.\n\nTünel zincirine ekleme\nAşağıda, tünel zincirine bazı yeni sütunlar ve sütun dönüşümleri eklenmiştir.\n\n# TEMİZLİK 'BORU' ZİNCİRİ (ham verilerle başlar ve temizleme adımları boyunca iletir\n##################################################################################\n\n# tünel zincirini temizlemeye başla\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # sütun adı sintaksını standartlaştır\n    janitor::clean_names() %&gt;% \n    \n    # sütunları manuel olarak yeniden adlandır\n           # YENİ isim             # ESKİ isim\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # sütunu sil\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # tekilleştir\n    distinct() %&gt;% \n  \n    # sütun ekle\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %&gt;%     \n\n    # sütun sınıfını değiştir\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %&gt;% \n    \n    # sütun ekleme: hastaneye yatışta gecikme\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %&gt;% \n    \n   # YUKARIDAKİ TEMİZLİK ADIMLARI ZATEN TARTIŞILMIŞTIR\n   ###################################################\n\n    # hastane sütununun temiz değerleri\n    mutate(hospital = recode(hospital,\n                      # ESKİ = YENİ\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %&gt;% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %&gt;% \n\n    # age_years sütunu oluştur (age ve age_unit sütunlarından)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age))",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Veri temizliği ve temel fonksiyonlar</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.tr.html#num_cats",
    "href": "new_pages/cleaning.tr.html#num_cats",
    "title": "8  Veri temizliği ve temel fonksiyonlar",
    "section": "8.9 Sayısal kategoriler",
    "text": "8.9 Sayısal kategoriler\nBurada sayısal sütunlardan kategoriler oluşturmaya yönelik bazı özel yaklaşımları açıklıyoruz. Yaygın örnekler arasında yaş kategorileri, laboratuvar değerleri grupları vb. bulunur. Burada şunları tartışacağız:\n• epikit paketinden age_categories() • temel R’dan cut() • case_when() • quantile() ve ntile() ile nicel sonlanmalar\n\nDağılımın gözden geçirilmesi\nBu örnek için age_years sütununu kullanarak bir age_cat sütunu oluşturacağız.\n\n#linelist değişken yaşının sınıfını kontrol edin\nclass(linelist$age_years)\n\n[1] \"numeric\"\n\n\nİlk olarak, uygun kesme noktaları yapmak için verilerinizin dağılımını inceleyin. ggplot temelleri ile ilgili sayfaya bakabilirsiniz.\n\n# dağılımın incelenmesi\nhist(linelist$age_years)\n\n\n\n\n\n\n\n\n\nsummary(linelist$age_years, na.rm=T)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00    6.00   13.00   16.04   23.00   84.00     107 \n\n\nUYARI: Bazen sayısal değişkenler “karakter” sınıfı olarak içe aktarılır. Bu durum, bazı değerlerde sayısal olmayan karakterler varsa, örneğin yaş için “2 ay” girişi veya (yerel ayarlarınıza bağlı olarak) ondalık basamakta virgül kullanılmışsa (örn. 5” dört buçuk yıl anlamına gelir) karşınıza çıkar.\n\n\n\nage_categories()\nEpikit paketiyle, sayısal sütunları kolayca kategorilere ayırmak ve etiketlemek için age_categories() fonksiyonunu kullanabilirsiniz (not: bu fonksiyon, yaş dışı sayısal değişkenlere de uygulanabilir). Bir bonus olarak, fonkisyonun oluşturduğu çıktı sütunu otomatik olarak sıralı bir faktör özelliğinde gelir.\nGerekli girdiler: • Sayısal bir vektör (sütun) • Kesiciler = argüman - yeni gruplar için sayısal bir kesim noktası vektörü sağlar\nİlk olarak, en basit örnek:\n\n# basit örnek\n################\npacman::p_load(epikit)                    # paket yükleme\n\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = age_categories(             # yeni sütun ekleme\n      age_years,                          # grupların oluşturulacağı ssayısal sütun \n      breakers = c(0, 5, 10, 15, 20,      # kesim noktaları \n\n                   30, 40, 50, 60, 70)))\n\n# tabloyu göster\ntable(linelist$age_cat, useNA = \"always\")\n\n\n  0-4   5-9 10-14 15-19 20-29 30-39 40-49 50-59 60-69   70+  &lt;NA&gt; \n 1227  1223  1048   827  1216   597   251    78    27     7   107 \n\n\nBelirttiğiniz kesme değerleri varsayılan olarak alt sınırlardır - yani “üst” gruba dahil edilirler / gruplar alt/sol tarafta “açıktır”. Aşağıda gösterildiği gibi, üstte/sağda açık olan gruplara ulaşmak için her bir ara değerine 1 ekleyebilirsiniz.\n\n# Aynı kategoriler için üst uçları dahil et\n############################################\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      breakers = c(0, 6, 11, 16, 21, 31, 41, 51, 61, 71)))\n\n# tabloyu göster\ntable(linelist$age_cat, useNA = \"always\")\n\n\n  0-5  6-10 11-15 16-20 21-30 31-40 41-50 51-60 61-70   71+  &lt;NA&gt; \n 1469  1195  1040   770  1149   547   231    70    24     6   107 \n\n\nAyırıcı = ile etiketlerin nasıl görüntüleneceğini ayarlayabilirsiniz. Varsayılan “-”\nCeiling = değişkeni ile en üstteki sayıların nasıl kullanılacağını ayarlayabilirsiniz. Daha yukarı seviyede eşik değeri ayarlamak için ceiling = DOĞRU. Bu kullanımda sağlanan en yüksek kesim değeri bir “tavan”dır ve “XX+” kategorisi oluşturulmaz. En yüksek kırılma değerinin üzerindeki (veya tanımlanmışsa upper =) değerler NA olarak kategorize edilir. Aşağıda ceiling = DOĞRU olan bir örnek verilmiştir, bu örnekte XX+ kategorisi yoktur ve 70’in üzerindeki değerler (en yüksek kesmi değeri) NA olarak atanır.\n\n# Tavan DOĞRU olarak ayarlandığında\n##########################\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70),\n      ceiling = TRUE)) # 70 tavandır, her şey NA olur\n\n# tabloyu göster\ntable(linelist$age_cat, useNA = \"always\")\n\n\n  0-4   5-9 10-14 15-19 20-29 30-39 40-49 50-59 60-70  &lt;NA&gt; \n 1227  1223  1048   827  1216   597   251    78    28   113 \n\n\nAlternatif olarak, ayırıcılar = yerine, tüm lower =, upper = ve by = değerlerini verebilirsiniz:\n• lower = Dikkate alınmasını istediğiniz en düşük sayı - varsayılan 0’dır • upper = dikkate alınmasını istediğiniz en yüksek sayı • by = Gruplar arasındaki yıl sayısı\n\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      lower = 0,\n      upper = 100,\n      by = 10))\n\n# tabloyu göster\ntable(linelist$age_cat, useNA = \"always\")\n\n\n  0-9 10-19 20-29 30-39 40-49 50-59 60-69 70-79 80-89 90-99  100+  &lt;NA&gt; \n 2450  1875  1216   597   251    78    27     6     1     0     0   107 \n\n\nDaha fazla ayrıntı için Yardım sayfasına bakın (R konsolunda ?age_categories).\n\n\n\ncut()\ncut(), age_categories()’e alternatif bir temel R fonksiyonudur, Bu işlemin basitleştirilmesi için age_categories()’in geliştirilmiştir. age_categories()’den bazı dikkate değer farklılıkları şunlardır:\n• Başka bir paket kurmanız/yüklemeniz gerekmez\n• Sağda/solda grupların açık/kapalı olup olmadığını belirleyebilirsiniz.\n• Doğru etiketleri kendiniz sağlamalısınız\n• En alt gruba 0’ın dahil edilmesini istiyorsanız, bunu belirtmelisiniz.\ncut() içindeki temel sintaksta, önce kesilecek sayısal sütun (age_years) ve ardından kesme noktalarının sayısal vektörü olan break argümanı yazılmalıdır. cut() kullanılarak elde edilen sütun sıralı bir faktördür.\nVarsayılan olarak, sınıflandırma sağ/üst taraf “açık” ve kapsayıcı (ve sol/alt taraf “kapalı” veya özel) olacak şekilde gerçekleşir. Bu, age_categories() fonksiyonunun tersi davranıştır. Varsayılan etiketler, “(A, B]” notasyonunu kullanır, bu, A’nın dahil edilmediği, ancak B’nin dahil olduğu anlamına gelir. right = DOĞRU argümanını sağlayarak bu davranışı tersine çevirin.\nBu nedenle, varsayılan olarak “0” değerleri en düşük gruptan çıkarılır ve NA olarak sınıflandırılır! “0” değerleri 0 yaş olarak kodlanmış bebekler olabilir, bu yüzden dikkatli olun! Bunu değiştirmek için, include.lowest = DOĞRU argümanını ekleyin, böylece herhangi bir “0” değeri en düşük gruba dahil edilecektir. En düşük kategori için otomatik olarak oluşturulan etiket “[A],B]” olacaktır. include.lowest = DOĞRU argümanını ve right = DOĞRU’yu eklerseniz, aşırı değerleri dahil etmenin artık en düşük değil, en yüksek kesme noktası değeri ve kategorisi için geçerli olacağını unutmayın.\nEtiketler = bağımsız değişkenini kullanarak bir özelleştirilmiş etiket vektörü sağlayabilirsiniz. Bunlar elle yazıldığından, doğru olduklarından emin olmak için çok dikkatli olun! Aşağıda açıklandığı gibi çapraz tablolama kullanarak çalışmanızı kontrol edin.\nYeni age_cat değişkenini yapmak için age_years’a uygulanan bir cut() örneği aşağıdadır:\n\n# Sayısal yaş değişkenini keserek yeni değişken oluşturun\n# alt kesim hariç tutulmuştur, ancak her kategoride üst kesim dahil edilmiştir\n\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = cut(\n      age_years,\n      breaks = c(0, 5, 10, 15, 20,\n                 30, 50, 70, 100),\n      include.lowest = TRUE         # 0'ı en düşük gruba dahil et\n      ))\n\n# grup başına gözlem sayısını tablo haline getirin\ntable(linelist$age_cat, useNA = \"always\")\n\n\n   [0,5]   (5,10]  (10,15]  (15,20]  (20,30]  (30,50]  (50,70] (70,100] \n    1469     1195     1040      770     1149      778       94        6 \n    &lt;NA&gt; \n     107 \n\n\nİşini kontrol et!!! Sayısal ve kategori sütunlarını çapraz tablolayarak her yaş değerinin doğru kategoriye atandığını doğrulayın. Sınır değerlerinin atanmasını inceleyin (örneğin komşu kategoriler 10-15 ve 16-20 ise 15).\n\n# Sayısal ve kategori sütunlarının çapraz tablosu.  \ntable(\"Numeric Values\" = linelist$age_years,   # netlik için tabloda belirtilen isimler.\n      \"Categories\"     = linelist$age_cat,\n      useNA = \"always\")                        # NA değerlerini incelemeyi unutmayın\n\n                    Categories\nNumeric Values       [0,5] (5,10] (10,15] (15,20] (20,30] (30,50] (50,70]\n  0                    136      0       0       0       0       0       0\n  0.0833333333333333     1      0       0       0       0       0       0\n  0.25                   2      0       0       0       0       0       0\n  0.333333333333333      6      0       0       0       0       0       0\n  0.416666666666667      1      0       0       0       0       0       0\n  0.5                    6      0       0       0       0       0       0\n  0.583333333333333      3      0       0       0       0       0       0\n  0.666666666666667      3      0       0       0       0       0       0\n  0.75                   3      0       0       0       0       0       0\n  0.833333333333333      1      0       0       0       0       0       0\n  0.916666666666667      1      0       0       0       0       0       0\n  1                    275      0       0       0       0       0       0\n  1.5                    2      0       0       0       0       0       0\n  2                    308      0       0       0       0       0       0\n  3                    246      0       0       0       0       0       0\n  4                    233      0       0       0       0       0       0\n  5                    242      0       0       0       0       0       0\n  6                      0    241       0       0       0       0       0\n  7                      0    256       0       0       0       0       0\n  8                      0    239       0       0       0       0       0\n  9                      0    245       0       0       0       0       0\n  10                     0    214       0       0       0       0       0\n  11                     0      0     220       0       0       0       0\n  12                     0      0     224       0       0       0       0\n  13                     0      0     191       0       0       0       0\n  14                     0      0     199       0       0       0       0\n  15                     0      0     206       0       0       0       0\n  16                     0      0       0     186       0       0       0\n  17                     0      0       0     164       0       0       0\n  18                     0      0       0     141       0       0       0\n  19                     0      0       0     130       0       0       0\n  20                     0      0       0     149       0       0       0\n  21                     0      0       0       0     158       0       0\n  22                     0      0       0       0     149       0       0\n  23                     0      0       0       0     125       0       0\n  24                     0      0       0       0     144       0       0\n  25                     0      0       0       0     107       0       0\n  26                     0      0       0       0     100       0       0\n  27                     0      0       0       0     117       0       0\n  28                     0      0       0       0      85       0       0\n  29                     0      0       0       0      82       0       0\n  30                     0      0       0       0      82       0       0\n  31                     0      0       0       0       0      68       0\n  32                     0      0       0       0       0      84       0\n  33                     0      0       0       0       0      78       0\n  34                     0      0       0       0       0      58       0\n  35                     0      0       0       0       0      58       0\n  36                     0      0       0       0       0      33       0\n  37                     0      0       0       0       0      46       0\n  38                     0      0       0       0       0      45       0\n  39                     0      0       0       0       0      45       0\n  40                     0      0       0       0       0      32       0\n  41                     0      0       0       0       0      34       0\n  42                     0      0       0       0       0      26       0\n  43                     0      0       0       0       0      31       0\n  44                     0      0       0       0       0      24       0\n  45                     0      0       0       0       0      27       0\n  46                     0      0       0       0       0      25       0\n  47                     0      0       0       0       0      16       0\n  48                     0      0       0       0       0      21       0\n  49                     0      0       0       0       0      15       0\n  50                     0      0       0       0       0      12       0\n  51                     0      0       0       0       0       0      13\n  52                     0      0       0       0       0       0       7\n  53                     0      0       0       0       0       0       4\n  54                     0      0       0       0       0       0       6\n  55                     0      0       0       0       0       0       9\n  56                     0      0       0       0       0       0       7\n  57                     0      0       0       0       0       0       9\n  58                     0      0       0       0       0       0       6\n  59                     0      0       0       0       0       0       5\n  60                     0      0       0       0       0       0       4\n  61                     0      0       0       0       0       0       2\n  62                     0      0       0       0       0       0       1\n  63                     0      0       0       0       0       0       5\n  64                     0      0       0       0       0       0       1\n  65                     0      0       0       0       0       0       5\n  66                     0      0       0       0       0       0       3\n  67                     0      0       0       0       0       0       2\n  68                     0      0       0       0       0       0       1\n  69                     0      0       0       0       0       0       3\n  70                     0      0       0       0       0       0       1\n  72                     0      0       0       0       0       0       0\n  73                     0      0       0       0       0       0       0\n  76                     0      0       0       0       0       0       0\n  84                     0      0       0       0       0       0       0\n  &lt;NA&gt;                   0      0       0       0       0       0       0\n                    Categories\nNumeric Values       (70,100] &lt;NA&gt;\n  0                         0    0\n  0.0833333333333333        0    0\n  0.25                      0    0\n  0.333333333333333         0    0\n  0.416666666666667         0    0\n  0.5                       0    0\n  0.583333333333333         0    0\n  0.666666666666667         0    0\n  0.75                      0    0\n  0.833333333333333         0    0\n  0.916666666666667         0    0\n  1                         0    0\n  1.5                       0    0\n  2                         0    0\n  3                         0    0\n  4                         0    0\n  5                         0    0\n  6                         0    0\n  7                         0    0\n  8                         0    0\n  9                         0    0\n  10                        0    0\n  11                        0    0\n  12                        0    0\n  13                        0    0\n  14                        0    0\n  15                        0    0\n  16                        0    0\n  17                        0    0\n  18                        0    0\n  19                        0    0\n  20                        0    0\n  21                        0    0\n  22                        0    0\n  23                        0    0\n  24                        0    0\n  25                        0    0\n  26                        0    0\n  27                        0    0\n  28                        0    0\n  29                        0    0\n  30                        0    0\n  31                        0    0\n  32                        0    0\n  33                        0    0\n  34                        0    0\n  35                        0    0\n  36                        0    0\n  37                        0    0\n  38                        0    0\n  39                        0    0\n  40                        0    0\n  41                        0    0\n  42                        0    0\n  43                        0    0\n  44                        0    0\n  45                        0    0\n  46                        0    0\n  47                        0    0\n  48                        0    0\n  49                        0    0\n  50                        0    0\n  51                        0    0\n  52                        0    0\n  53                        0    0\n  54                        0    0\n  55                        0    0\n  56                        0    0\n  57                        0    0\n  58                        0    0\n  59                        0    0\n  60                        0    0\n  61                        0    0\n  62                        0    0\n  63                        0    0\n  64                        0    0\n  65                        0    0\n  66                        0    0\n  67                        0    0\n  68                        0    0\n  69                        0    0\n  70                        0    0\n  72                        1    0\n  73                        3    0\n  76                        1    0\n  84                        1    0\n  &lt;NA&gt;                      0  107\n\n\nNA değerlerinin yeniden etiketlenmesi \nNA değerlerine “Eksik” gibi bir etiket atamak isteyebilirsiniz. Yeni sütun faktör sınıfından (kısıtlı değerler) olduğundan replace_na() ile değiştiremezsiniz. Bunun yerine, Faktörler sayfasında açıklandığı gibi forcat’lerden fct_explicit_na() kullanın.\n\nlinelist &lt;- linelist %&gt;% \n  \n  # cut()age_cat oluşturur, otomatik olarak faktör sınıfı özelliğindedir.     \n  mutate(age_cat = cut(\n    age_years,\n    breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          \n    right = FALSE,\n    include.lowest = TRUE,        \n    labels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\", \"20-29\", \"30-49\", \"50-69\", \"70-100\")),\n         \n    # eksik değerleri açık hale getirmek\n    age_cat = fct_explicit_na(\n      age_cat,\n      na_level = \"Missing age\")  # you can specify the label\n  )    \n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `age_cat = fct_explicit_na(age_cat, na_level = \"Missing age\")`.\nCaused by warning:\n! `fct_explicit_na()` was deprecated in forcats 1.0.0.\nℹ Please use `fct_na_value_to_level()` instead.\n\n# sayıları görüntülemek için tablo\ntable(linelist$age_cat, useNA = \"always\")\n\n\n        0-4         5-9       10-14       15-19       20-29       30-49 \n       1227        1223        1048         827        1216         848 \n      50-69      70-100 Missing age        &lt;NA&gt; \n        105           7         107           0 \n\n\nHızlı şekilde kesim noktaları ve etiket oluşturma \nKesim noktası oluşturma ve vektörleri etiketlemenin hızlı bir yolu için aşağıdaki yöntemi kullanın. seq() ve rep() ile ilgili referanslar için R temelleri sayfasına bakınız.\n\n# 0'dan 90'a 5'erli kesim noktaları yapın\nage_seq = seq(from = 0, to = 90, by = 5)\nage_seq\n\n# Varsayılan cut() ayarlarına göre yukarıdaki kategoriler için etiketler yapın\nage_labels = paste0(age_seq + 1, \"-\", age_seq + 5)\nage_labels\n\n# her iki vektörün de aynı uzunlukta olduğunu kontrol edin\nlength(age_seq) == length(age_labels)\n\nR konsoluna ?cut yazarak cut() hakkında daha fazla bilgi edinin.\n\n\nYüzdelik kesim noktaları\nGenel olarak, “yüzdelik dilimler”, değerlerin bir kısmının altına düştüğü bir değeri ifade eder. Örneğin, satır listesindeki yaşların 95. yüzdelik dilimi, yaşın %95’inin altına düştüğü yaş olacaktır.\nBununla birlikte, konuşmada, “çeyreklikler” ve “ondalıklar”, eşit olarak 4 veya 10 gruba bölünmüş veri gruplarını da ifade edebilir (grup sayısından bir fazla kesim noktası olacağını unutmayın).\nYüzdelik kırılma noktaları elde etmek için, temel R stats paketinden quantile() öğesini kullanabilirsiniz. Sayısal bir vektör (örneğin, bir veri kümesindeki bir sütun) ve 0 ile 1.0 arasında değişen sayısal değerleri içeren vektör yazılmalıdır. Kesmi noktaları sayısal bir vektör olarak oluşturulur. Konsola ?quantile komutunu girerek istatistiksel metodolojilerin ayrıntılarını keşfedin.\n• Girdiğiniz sayısal vektörde eksik değerler varsa, en iyisi na.rm = DOĞRU olarak ayarlamaktır.\n• Adsız bir sayısal vektör elde etmek için names = YANLIŞ\n\nquantile(linelist$age_years,               # üzerinde çalışılacak sayısal vektörü belirtin\n  probs = c(0, .25, .50, .75, .90, .95),   # istediğiniz yüzdelik dilimleri belirtin\n  na.rm = TRUE)                            # eksik değerleri yoksay \n\n 0% 25% 50% 75% 90% 95% \n  0   6  13  23  33  41 \n\n\nquantile() sonuçlarını age_categories() veya cut() içinde kesim noktaları olarak kullanabilirsiniz. Aşağıda cut() kullanarak yeni bir sütun oluşturuyoruz, burada kesim noktaları age_years üzerinde quantiles() kullanılarak tanımlanıyor. Aşağıda, yüzdeleri görebilmeniz için janitor’dan tabyl() fonksiyonu kullanarak sonuçları gösteriyoruz Tanımlayıcı tablolar sayfasına bakabilirsiniz. Her gruptaki, yüzdeliklerin tam olarak %10 olmadıklarına dikkat edin.\n\nlinelist %&gt;%                                # linelist ile başla \n  mutate(deciles = cut(age_years,           # age_years sütununda cut() olarak yeni sütun ondalık oluştur\n    breaks = quantile(                      # quantile() kullanarak kesim noktalarını tanımlayın\n      age_years,                               # age_years çalıştır\n      probs = seq(0, 1, by = 0.1),             # 0,0 ile 1,0 arasında 0,1’erlik aralıklar\n      na.rm = TRUE),                           # eksik değerleri yoksay\n    include.lowest = TRUE)) %&gt;%             # cut() için 0 yaşını içerir\n  janitor::tabyl(deciles)                   # görüntülemek için tabloya tünelle\n\n deciles   n    percent valid_percent\n   [0,2] 748 0.11319613    0.11505922\n   (2,5] 721 0.10911017    0.11090601\n   (5,7] 497 0.07521186    0.07644978\n  (7,10] 698 0.10562954    0.10736810\n (10,13] 635 0.09609564    0.09767728\n (13,17] 755 0.11425545    0.11613598\n (17,21] 578 0.08746973    0.08890940\n (21,26] 625 0.09458232    0.09613906\n (26,33] 596 0.09019370    0.09167820\n (33,84] 648 0.09806295    0.09967697\n    &lt;NA&gt; 107 0.01619249            NA\n\n\n\n\nEşit boyutlu gruplar\nSayısal gruplar oluşturmak için başka bir araç, verilerinizi eşit boyutlu gruplara ayırmaya çalışan ntile() dplyr fonksiyonudur - ancak quantile()’den farklı olarak aynı değerin birden fazla grupta görünebileceğini unutmayın. Sayısal vektörü ve ardından grup sayısını girin. Oluşturulan yeni sütundaki değerler, cut() kullanılırken olduğu gibi değer aralığının kendisi değil, yalnızca “sayılar” grubudur (örneğin 1 ila 10).\n\n# ntile() ile gruplar oluştur\nntile_data &lt;- linelist %&gt;% \n  mutate(even_groups = ntile(age_years, 10))\n\n# gruba göre sayım ve orantı tablosu yapın\nntile_table &lt;- ntile_data %&gt;% \n  janitor::tabyl(even_groups)\n  \n# aralıkları göstermek için min/maks değerleri ekleyin\nntile_ranges &lt;- ntile_data %&gt;% \n  group_by(even_groups) %&gt;% \n  summarise(\n    min = min(age_years, na.rm=T),\n    max = max(age_years, na.rm=T)\n  )\n\nWarning: There were 2 warnings in `summarise()`.\nThe first warning was:\nℹ In argument: `min = min(age_years, na.rm = T)`.\nℹ In group 11: `even_groups = NA`.\nCaused by warning in `min()`:\n! no non-missing arguments to min; returning Inf\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\n# birleştir ve yazdır - değerlerin birden fazla grupta bulunduğunu unutmayın\nleft_join(ntile_table, ntile_ranges, by = \"even_groups\")\n\n even_groups   n    percent valid_percent min  max\n           1 651 0.09851695    0.10013844   0    2\n           2 650 0.09836562    0.09998462   2    5\n           3 650 0.09836562    0.09998462   5    7\n           4 650 0.09836562    0.09998462   7   10\n           5 650 0.09836562    0.09998462  10   13\n           6 650 0.09836562    0.09998462  13   17\n           7 650 0.09836562    0.09998462  17   21\n           8 650 0.09836562    0.09998462  21   26\n           9 650 0.09836562    0.09998462  26   33\n          10 650 0.09836562    0.09998462  33   84\n          NA 107 0.01619249            NA Inf -Inf\n\n\n\n\n\ncase_when()\nSayısal bir sütundan kategoriler oluşturmak için case_when() dplyr fonksiyonunu kullanmak mümkündür, ancak epikit veya cut()’tan age_categories() kullanmak daha kolaydır çünkü bunlar otomatik olarak sıralı bir faktör oluşturacaktır.\ncase_when() kullanıyorsanız, lütfen bu sayfanın değerleri yeniden kodla bölümünde daha önce açıklandığı gibi doğru kullanıldığını kontrol edin. Ayrıca tüm sağ taraftaki değerlerin aynı sınıfta olması gerektiğini unutmayın. Bu nedenle, sağ tarafta NA istiyorsanız, “Eksik” yazmalı veya NA_character_ özel NA değerini kullanmalısınız.\n\n\nTünel zincirine ekleme\nAşağıda, temizleme tünel zincirine iki kategorik yaş sütunu oluşturma kodu eklenmiştir:\n\n# TEMİZLİK 'TÜNEL' ZİNCİRİ (ham verilerle başlar ve temizleme adımları boyunca iletir)\n##################################################################################\n\n# tünel zincirini temizlemeye başla\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # sütun adı sintaksını standartlaştır\n    janitor::clean_names() %&gt;% \n    \n    # sütunları manuel olarak yeniden adlandır\n           # YENİ isim             # ESKİ isim\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # sütunu sil\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # tekilleştir\n    distinct() %&gt;% \n\n    # sütun ekle\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %&gt;%     \n\n    # sütun sınıfını değiştir\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %&gt;% \n    \n    # sütun ekle: hastaneye yatışta gecikme\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %&gt;% \n    \n    # hastane sütununun temiz değerleri\n    mutate(hospital = recode(hospital,\n                      # ESKİ = YENİ\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %&gt;% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %&gt;% \n\n    # age_years sütunu oluştur (age ve age_unit'ten)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age)) %&gt;% \n  \n    # YUKARIDAKİ TEMİZLİK ADIMLARI ZATEN TARTIŞILMIŞTIR\n    ###################################################   \n    mutate(\n          # yaş kategorileri: özel\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # yaş kategorileri: 0-85 arası, 5’erli\n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Veri temizliği ve temel fonksiyonlar</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.tr.html#satır-ekleme",
    "href": "new_pages/cleaning.tr.html#satır-ekleme",
    "title": "8  Veri temizliği ve temel fonksiyonlar",
    "section": "8.10 Satır ekleme",
    "text": "8.10 Satır ekleme\n\nTeker teker\nSatırları tek tek manuel olarak eklemek sıkıcıdır ancak dplyr’den add_row() ile yapılabilir. Her sütunun yalnızca bir sınıfın (karakter, sayısal, mantık vb.) değerlerini içermesi gerektiğini unutmayın. Bu yüzden bir satır eklemek, bunu korumak için dikkat gerektirir.\n\nlinelist &lt;- linelist %&gt;% \n  add_row(row_num = 666,\n          case_id = \"abc\",\n          generation = 4,\n          `infection date` = as.Date(\"2020-10-10\"),\n          .before = 2)\n\n.before ve .after kullanın. Eklemek istediğiniz satırın yerleşimini belirtmek için .before = 3, yeni satırı mevcut 3. satırın önüne koyacaktır. Varsayılan davranış, satırı sonuna eklemektir. Belirtilmeyen sütunlar boş bırakılacaktır (NA).\nYeni satır numarası garip görünebilir (“…23”) ancak önceden var olan satırlardaki satır numaraları değişmiştir. Bu nedenle, komutu iki kez kullanıyorsanız, yerleştirmeyi dikkatlice inceleyin/test edin.\nSağladığınız bir sınıf kapalıysa, aşağıdaki gibi bir hata görürsünüz:\nError: Can't combine ..1$infection date &lt;date&gt; and ..2$infection date &lt;character&gt;.\n((tarih değerine sahip bir satır eklerken, tarihi as.Date() fonksiyonuyla as.Date(\"2021-12-31\") gibi eklemeyi unutmayın)).\n\n\nSatırların bağlanması\nBir veri çerçevesinin satırlarını başka bir veri çerçevesinin altına bağlayarak veri kümelerini birleştirmek için dplyr’den bind_rows() öğesini kullanabilirsiniz. Bu yöntem, Verileri birleştirme sayfasında daha ayrıntılı olarak açıklanmaktadır.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Veri temizliği ve temel fonksiyonlar</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.tr.html#satırların-filtrelenmesi",
    "href": "new_pages/cleaning.tr.html#satırların-filtrelenmesi",
    "title": "8  Veri temizliği ve temel fonksiyonlar",
    "section": "8.11 Satırların filtrelenmesi",
    "text": "8.11 Satırların filtrelenmesi\nSütunları temizledikten ve değerleri yeniden kodladıktan sonra tipik bir temizleme adımı, dplyr filter() komutunu kullanarak belirli satırlar için veri çerçevesini filtrelemektir.\nfilter() içinde, veri kümesindeki bir satırın tutulması için DOĞRU olması gereken mantık koşulunu belirtin. Aşağıda, basit ve karmaşık mantıksal koşullara dayalı olarak satırların nasıl filtreleneceğini gösteriyoruz.\n\n\nBasit Filtre\nBu basit örnek, mantıksal bir koşulu karşılayacak satırları filtreleyerek veri çerçevesi satır listesini yeniden tanımlar. Yalnızca parantez içindeki mantıksal ifadenin DOĞRU olarak değerlendirildiği satırlar veri çerçevesinde tutulur.\nBu örnekte, cinsiyet sütunundaki değerin “f”ye (büyük/küçük harf duyarlı) eşit olup olmadığını soran cinsiyet == “f” mantıksal ifadesi filtreleme için kullanılmıştır.\nFiltre uygulanmadan önce linelistteki satır sayısı nrow(linelist) ile gösterilir.\n\nlinelist &lt;- linelist %&gt;% \n  filter(gender == \"f\")   # yalnızca cinsiyetin \"f\"ye eşit olduğu satırları tut\n\nFiltre uygulandıktan sonra, linelistteki satır sayısı linelist %&gt;% filter(gender == “f”) %&gt;% nrow().\n\n\nEksik değerlerin filtrelenmesi\nEksik değerlere sahip satırları filtrelemek oldukça yaygındır. filter(!is.na(column) & !is.na(column)) yerine bu amaç için özel olarak oluşturulmuş tidyr fonksiyonunu kullanın: drop_na(). Boş parantezlerle çalıştırılırsa, eksik değerleri olan satırları kaldırır. Alternatif olarak, eksik olup olmadığı değerlendirilecek belirli sütunların adlarını sağlayabilir veya yukarıda açıklanan “tidyselect” yardımcı fonksiyonlarını kullanabilirsiniz.\n\nlinelist %&gt;% \n  drop_na(case_id, age_years)  # case_id veya age_years için eksik değerleri olan satırları bırak\n\nVerilerinizdeki eksiklikleri analiz etmeye ve yönetmeye yönelik birçok teknik için Eksik veriler sayfasına bakın.\n\n\nSatır numarasına göre filtreleme\nBir veri çerçevesinde veya tibble’da, her satır genellikle (R Viewer’da görüldüğünde) ilk sütunun solunda görünen bir “satır numarasına” sahip olacaktır. Bu satır numarası veri çerçevesinde gerçek bir sütun değildir, ancak filter() ifadesinde kullanılabilir.\n“Satır numarasına” göre filtrelemek için, mantıksal filtreleme ifadesinin bir parçası olarak açık parantezlerle dplyr row_number() fonksiyonunu kullanabilirsiniz. Aşağıda gösterildiği gibi, genellikle %in% operatörünü ve bir dizi sayıyı bu mantıksal ifadenin parçası olarak kullanacaksınız. İlk N satırı görmek için özel dplyr fonksiyonu head()’i de kullanabilirsiniz.\n\n# İlk 100 satırı gösterin\nlinelist %&gt;% head(100)     # veya son n satırı görmek için tail() kullanın\n\n# sadece 5 satırı göster\nlinelist %&gt;% filter(row_number() == 5)\n\n# satır 2'den 20'ye üç spesifik sütunu göster\nlinelist %&gt;% filter(row_number() %in% 2:20) %&gt;% select(date_onset, outcome, age)\n\nAyrıca veri çerçevenize tibble fonksiyonu rownames_to_column() (parantez içine hiçbir şey koymayın) kullanarak satır numaralarını gerçek bir sütuna dönüştürebilirsiniz.\n\n\n\nKarmaşık filtre\nParantezler ( ), OR |, negate !, %in% ve AND & operatörleri kullanılarak daha karmaşık mantıksal ifadeler oluşturulabilir. Bir örnek aşağıdadır:\nNot: Mantıksal bir kriteri reddetmek için ! operatörünü kullanabilirsiniz. Örneğin, !is.na(column), sütun değeri eksik değilse doğru olarak değerlendirilir. Aynı şekilde !column %in% c(“a”, “b”, “c”), sütun değeri vektörde değilse doğru olarak değerlendirilir.\n\nVerinin incelenmesi\nAşağıda, başlangıç tarihlerinin bir histogramını oluşturmak için basit bir tek satırlık komut verilmiştir. Bu ham veri kümesine 2012-2013 arasında ikinci bir daha küçük salgının da dahil edildiğini görün. Analizlerimiz için, bu önceki salgın girişlerini kaldırmak istiyoruz.\n\nhist(linelist$date_onset, breaks = 50)\n\n\n\n\n\n\n\n\n\n\nEksik sayısal ve tarih verilerinin filtrelenmesi\nHaziran 2013’ten sonraki satırlara date_onset’e göre filtre uygulayabilir miyiz? Dikkat! Kod filtresini uygulamak(date_onset &gt; as.Date(“2013-06-01”))) sonraki salgında başlangıç tarihi eksik olan tüm satırları kaldırır!\nUYARI: Bir tarih veya sayıdan büyük (&gt;) veya küçük (&lt;) olarak filtrelemek, eksik değerlere sahip satırları kaldırabilir (NA)! Bunun nedeni, NA’nın sonsuz büyük ve küçük olarak kabul edilmesidir.\n(Tarihlerle çalışma ve lubridate paketi hakkında daha fazla bilgi için Tarihlerle çalışma sayfasına bakın)\n\n\nFiltre Dizaynı\nYalnızca istediğimiz doğru satırları hariç tuttuğumuzdan emin olmak için bir çapraz tabloyu inceleyin:\n\ntable(Hospital  = linelist$hospital,                     # hastane ismi\n      YearOnset = lubridate::year(linelist$date_onset),  # date_onset yılı\n      useNA     = \"always\")                              # eksik verileri göster\n\n                                      YearOnset\nHospital                               2012 2013 2014 2015 &lt;NA&gt;\n  Central Hospital                        0    0  351   99   18\n  Hospital A                            229   46    0    0   15\n  Hospital B                            227   47    0    0   15\n  Military Hospital                       0    0  676  200   34\n  Missing                                 0    0 1117  318   77\n  Other                                   0    0  684  177   46\n  Port Hospital                           9    1 1372  347   75\n  St. Mark's Maternity Hospital (SMMH)    0    0  322   93   13\n  &lt;NA&gt;                                    0    0    0    0    0\n\n\nİlk salgını (2012 ve 2013’te) veri kümesinden çıkarmak için başka hangi kriterleri filtreleyebiliriz? Şunu görüyoruz:\n• 2012 ve 2013 yıllarında ilk salgın A Hastanesi ve B Hastanesi’nde meydana geldi ve ayrıca Liman Hastanesi’nde 10 vaka görüldü.\n• A ve B hastanelerinde ikinci salgında vaka görülmedi ama Liman Hastanesinde görüldü.\nDışlamak istediklerimiz:\n• nrow(linelist %&gt;% filter(hospital %in% c(“Hospital A”, “Hospital B”) | date_onset &lt; as.Date(“2013-06-01”))) • A, B hastanesi veya Liman’da 2012 ve 2013’te başlayan sıralar:\n• nrow(linelist %&gt;% filter(date_onset &lt; as.Date(“2013-06-01”))) 2012 ve 2013’te başlayan satırlar\n• Exclude nrow(linelist %&gt;% filter(hospital %in% c(‘Hospital A’, ‘Hospital B’) & is.na(date_onset))) A ve B Hastanelerinden başlangıç tarihleri eksik satırlar\n• Ancak nrow(linelist %&gt;% filter(!hospital %in% c(‘Hospital A’, ‘Hospital B’) & is.na(date_onset))) eksik tarihli diğer satırlar dışlanmayacak\nnrow(linelist)` satır listesiyle başlıyoruz. Filtre ifademiz:\n\nlinelist &lt;- linelist %&gt;% \n  # başlangıcın 1 Haziran 2013'ten sonra olduğu VEYA başlangıcın olmadığı ve Hastane A veya B'den DIŞINDA bir hastane olduğu satırları saklayın\n  filter(date_onset &gt; as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))\n\nnrow(linelist)\n\n[1] 6019\n\n\nÇapraz tabloyu yeniden yaptığımızda A ve B Hastanelerinin tamamen kaldırıldığını; 2012 ve 2013 yıllarındaki 10 Liman Hastanesi vakasının kaldırıldığını ve diğer tüm değerlerin aynı - istediğimiz gibi - olduğunu görüyoruz.\n\ntable(Hospital  = linelist$hospital,                     # hastane adı\n      YearOnset = lubridate::year(linelist$date_onset),  # date_onset yılı\n      useNA     = \"always\")                              # eksik değerleri göster\n\n                                      YearOnset\nHospital                               2014 2015 &lt;NA&gt;\n  Central Hospital                      351   99   18\n  Military Hospital                     676  200   34\n  Missing                              1117  318   77\n  Other                                 684  177   46\n  Port Hospital                        1372  347   75\n  St. Mark's Maternity Hospital (SMMH)  322   93   13\n  &lt;NA&gt;                                    0    0    0\n\n\nBir filtre komutuna (virgülle ayrılmış) birden çok ifade dahil edilebilir veya kolaylık için her zaman ayrı bir filter() komutuna yönlendirebilirsiniz.\nNot: Bazı okuyucular, hiçbir eksik değer olmadığında, yalnızca date_hospitalisation’a göre filtrelemenin daha kolay olacağını fark edebilir. Bu doğrudur. Ancak date_onset, karmaşık bir filtreyi göstermek amacıyla kullanılmıştır.\n\n\n\nBağımsız (Standalone)\nFiltreleme, bağımsız bir komut olarak da uygulanabilir (tünel zincirinin bir parçası değil). Diğer dplyr komutları gibi, bu durumda ilk argüman veri kümesinin kendisi olmalıdır.\n\n# dataframe &lt;- filter(dataframe, condition(s) for rows to keep)\n\nlinelist &lt;- filter(linelist, !is.na(case_id))\n\nKorumak istediğiniz [satırları, sütunları] yansıtan köşeli parantezler kullanarak alt küme için temel R ’ı da kullanabilirsiniz.\n\n# dataframe &lt;- dataframe[row conditions, column conditions] (blank means keep all)\n\nlinelist &lt;- linelist[!is.na(case_id), ]\n\n\n\nKayıtların hızla gözden geçirilmesi\nÇoğu zaman, yalnızca birkaç sütun için birkaç kaydı hızlı bir şekilde gözden geçirmek istersiniz. Temel R fonksiyonu View(), RStudio’da görüntülemek için bir veri çerçevesi yazdıracaktır.\nRStudio’daki satır listesini görüntüleyin:\n\nView(linelist)\n\nBelirli hücreleri (belirli satırlar ve belirli sütunlar) görüntülemeye ilişkin iki örnek:\ndplyr fonksiyonları filter() ve select():\nView() içinde, veri çerçevesinde belirli satırları tutmak için veri kümesini filter() öğesine ve ardından belirli sütunları tutmak için select() öğesine yönlendirin. Örneğin, 3 spesifik vakanın başlangıç ve hastaneye yatış tarihlerini gözden geçirmek için\n\nView(linelist %&gt;%\n       filter(case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\")) %&gt;%\n       select(date_onset, date_hospitalisation))\n\nAynı sonucu, görmek istediğiniz alt küme için köşeli parantez [ ] kullanarak, temel R sintaksı ile elde edebilirsiniz.\n\nView(linelist[linelist$case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\"), c(\"date_onset\", \"date_hospitalisation\")])\n\n\nTünel zincirine ekleme\n\n# TEMİZLİK 'TÜNEL' ZİNCİRİ (ham verilerle başlar ve temizleme adımları boyunca iletir)\n##################################################################################\n\n# tünel zincirini temizlemeye başla\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # sütun adı sintaksını standartlaştır\n    janitor::clean_names() %&gt;% \n    \n    # sütunları manuel olarak yeniden adlandır\n           # ESKİ isim             # YENİ isim\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # sütunu sil\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # tekilleştir\n    distinct() %&gt;% \n\n    # sütun ekle\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %&gt;%     \n\n    # sütun sınıfını değiştir\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %&gt;% \n    \n    # sütun ekleme: yatışta gecikme\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %&gt;% \n    \n    # hastane sütununun temiz değerleri\n    mutate(hospital = recode(hospital,\n                      # ESKİ = İSİM\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %&gt;% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %&gt;% \n\n    # age_years sütunu oluştur (age ve age_unit'ten)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age)) %&gt;% \n  \n    mutate(\n          # yaş kategorileri: özel\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # yaş kategorileri: 0-85 arası, 5’erli \n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5))) %&gt;% \n    \n    # YUKARIDAKİ TEMİZLİK ADIMLARI ZATEN TARTIŞILMIŞTIR\n    ###################################################\n    filter(\n          # sadece case_id'nin eksik olmadığı satırları tut\n          !is.na(case_id),  \n          \n          # ayrıca yalnızca ikinci salgını tutmak için filtreleyin\n          date_onset &gt; as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Veri temizliği ve temel fonksiyonlar</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.tr.html#satır-tabanlı-hesaplamalar",
    "href": "new_pages/cleaning.tr.html#satır-tabanlı-hesaplamalar",
    "title": "8  Veri temizliği ve temel fonksiyonlar",
    "section": "8.12 Satır tabanlı hesaplamalar",
    "text": "8.12 Satır tabanlı hesaplamalar\nBir satır içinde bir hesaplama yapmak istiyorsanız, dplyr’den rowwise() fonksiyonuni kullanabilirsiniz. Satır bazında hesaplamalar için bu çevrimiçi gösterime bakabilirsiniz. Örneğin, bu kod rowwise() komutunu uygular ve ardından satır listesindeki her satır için “evet” değerine sahip belirtilen semptom sütunlarının sayısını toplayan yeni bir sütun oluşturur. Sütunlar, bir c() vektörü içinde adlarıyla sum() içinde belirtilir. rowwise() aslında özel bir group_by() türüdür, bu nedenle işiniz bittiğinde ungroup() komutunu kullanmak en iyisidir verileri gruplandırma sayfasınd.\n\nlinelist %&gt;%\n  rowwise() %&gt;%\n  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == \"yes\")) %&gt;% \n  ungroup() %&gt;% \n  select(fever, chills, cough, aches, vomit, num_symptoms) # gösterim için\n\n# A tibble: 5,888 × 6\n   fever chills cough aches vomit num_symptoms\n   &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;        &lt;int&gt;\n 1 no    no     yes   no    yes              2\n 2 &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;            NA\n 3 &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;            NA\n 4 no    no     no    no    no               0\n 5 no    no     yes   no    yes              2\n 6 no    no     yes   no    yes              2\n 7 &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;            NA\n 8 no    no     yes   no    yes              2\n 9 no    no     yes   no    yes              2\n10 no    no     yes   no    no               1\n# ℹ 5,878 more rows\n\n\nDeğerlendirilecek sütunu belirlerken, bu sayfanın select() bölümünde açıklanan “tidyselect” yardımcı fonksiyonlarını kullanmak isteyebilirsiniz. Sadece bir ayarlama yapmanız gerekir (çünkü bunları select() veya summarise() gibi bir dplyr fonksiyonunda kullanmıyorsunuz).\nSütun belirtim ölçütlerini dplyr fonksiyonu c_across() içine koyun. Bunun nedeni, c_across’un (belgeler) özellikle rowwise() ile çalışmak üzere tasarlanmış olmasıdır. Örneğin, aşağıdaki kod:\n• rowwise() uygular, böylece her satırda aşağıdaki işlem (sum()) uygulanır (tüm sütunları toplamaz) • Yeni sütun num_NA_dates oluşturur, her satır için is.na() öğesinin DOĞRU olarak değerlendirildiği sütun sayısı tanımlanır. • sonraki adımlar için rowwise()’ın etkilerini kaldırmak için grubu çözmek gerekir ungroup()\n\nlinelist %&gt;%\n  rowwise() %&gt;%\n  mutate(num_NA_dates = sum(is.na(c_across(contains(\"date\"))))) %&gt;% \n  ungroup() %&gt;% \n  select(num_NA_dates, contains(\"date\")) # gösterim için\n\n# A tibble: 5,888 × 5\n   num_NA_dates date_infection date_onset date_hospitalisation date_outcome\n          &lt;int&gt; &lt;date&gt;         &lt;date&gt;     &lt;date&gt;               &lt;date&gt;      \n 1            1 2014-05-08     2014-05-13 2014-05-15           NA          \n 2            1 NA             2014-05-13 2014-05-14           2014-05-18  \n 3            1 NA             2014-05-16 2014-05-18           2014-05-30  \n 4            1 2014-05-04     2014-05-18 2014-05-20           NA          \n 5            0 2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n 6            0 2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n 7            0 2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n 8            0 2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n 9            1 NA             2014-06-05 2014-06-06           2014-06-18  \n10            1 NA             2014-06-05 2014-06-07           2014-06-09  \n# ℹ 5,878 more rows\n\n\nHer satır için en son veya en son tarihi almak için max() gibi başka fonksiyonlar da uygulayabilirsiniz:\n\nlinelist %&gt;%\n  rowwise() %&gt;%\n  mutate(latest_date = max(c_across(contains(\"date\")), na.rm=T)) %&gt;% \n  ungroup() %&gt;% \n  select(latest_date, contains(\"date\"))  # gösterim için\n\n# A tibble: 5,888 × 5\n   latest_date date_infection date_onset date_hospitalisation date_outcome\n   &lt;date&gt;      &lt;date&gt;         &lt;date&gt;     &lt;date&gt;               &lt;date&gt;      \n 1 2014-05-15  2014-05-08     2014-05-13 2014-05-15           NA          \n 2 2014-05-18  NA             2014-05-13 2014-05-14           2014-05-18  \n 3 2014-05-30  NA             2014-05-16 2014-05-18           2014-05-30  \n 4 2014-05-20  2014-05-04     2014-05-18 2014-05-20           NA          \n 5 2014-05-29  2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n 6 2014-05-24  2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n 7 2014-06-01  2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n 8 2014-06-07  2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n 9 2014-06-18  NA             2014-06-05 2014-06-06           2014-06-18  \n10 2014-06-09  NA             2014-06-05 2014-06-07           2014-06-09  \n# ℹ 5,878 more rows",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Veri temizliği ve temel fonksiyonlar</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.tr.html#düzenle-ve-sıraya-diz",
    "href": "new_pages/cleaning.tr.html#düzenle-ve-sıraya-diz",
    "title": "8  Veri temizliği ve temel fonksiyonlar",
    "section": "8.13 Düzenle ve sıraya diz",
    "text": "8.13 Düzenle ve sıraya diz\nSatırları sütun değerlerine göre sıralamak veya sıralamak için dplyr fonksiyonu arrange()’i kullanın.\nSütunları gereken sırayla basit bir şekilde listeleyin. Sıralamanın önce verilere uygulanan herhangi bir gruplandırma tarafından yapılmasını istiyorsanız .by_group = TRUE DOĞRU belirtin (bkz. Verileri gruplama sayfası).\nVarsayılan olarak, sütun “artan” düzende sıralanır (sayısal ve ayrıca karakter sütunları için geçerlidir). Bir değişkeni desc() fonksiyonu ile sararak “azalan” düzende sıralayabilirsiniz.\nVerileri arrange() ile sıralamak, sunum için tablolar hazırlarken, grup başına “üst” satırları almak için slice() kullanırken veya görünüm sırasına göre faktör düzeyi sırasını ayarlarken özellikle yararlıdır.\nÖrneğin, satır listesi satırlarımızı hastaneye göre, ardından azalan düzende date_onset’e göre sıralamak için şunu kullanırız:\n\nlinelist %&gt;% \n   arrange(hospital, desc(date_onset))",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Veri temizliği ve temel fonksiyonlar</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.tr.html",
    "href": "new_pages/dates.tr.html",
    "title": "9  Tarihlerle çalışma",
    "section": "",
    "text": "9.1 Hazırlık",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tarihlerle çalışma</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.tr.html#hazırlık",
    "href": "new_pages/dates.tr.html#hazırlık",
    "title": "9  Tarihlerle çalışma",
    "section": "",
    "text": "Paketleri yüklemek\nAşağıdaki kod parçası, bu sayfa için gerekli olan paketlerin yüklenmesini göstermektedir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() fonksiyonuna vurgulamaktayız. base R’dan library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R basics sayfasına bakınız.\n\n# Paketin kurulu olup olmadığını kontrol eder, gerekirse kurar ve mevcut oturum için paketi yükler\n\npacman::p_load(\n  lubridate,  # tarihlerin işlenmesi ve dönüştürülmesi için genel paket \n  parsedate,   # dağınık tarihleri \"tahmin etme\" işlevi sağlar\n  aweek,      # tarihleri haftalara ve haftaları tarihe dönüştürmek için alternatif bir seçenek\n  zoo,        # ek tarih/saat işlevleri\n  here,       # dosya yönetimi\n  tidyverse,  # veri yönetimi ve görselleştirme \n  rio)        # veri içe/dışa aktarma\n\n\n\nVerileri içe aktarma\nSimüle edilmiş bir Ebola salgını ile ilişkili vakaların veri setini içe aktarıyoruz. Adım adım izlenecek verileri indirmek istiyorsanız, El kitabını ve verileri indir sayfasındaki talimatlara bakınız. İlgili dosyaların çalışma dizininde olduğunu varsayıyoruz, bu nedenle bu dosya yolunda hiçbir alt klasör belirtilmemiştir.\n\nlinelist &lt;- import(\"linelist_cleaned.xlsx\")",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tarihlerle çalışma</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.tr.html#güncel-tarih",
    "href": "new_pages/dates.tr.html#güncel-tarih",
    "title": "9  Tarihlerle çalışma",
    "section": "9.2 Güncel tarih",
    "text": "9.2 Güncel tarih\nbase R ile aşağıdaki işlemleri tamamlayarak bilgisayarınızın güncel “sistem” tarihini veya sistem tarih saatini görebilirsiniz.\n\n# sistem tarihini al - bu bir DATE sınıfıdır\nSys.Date()\n\n[1] \"2024-05-10\"\n\n# sistem saatini al - bu bir DATETIME sınıfıdır\nSys.time()\n\n[1] \"2024-05-10 05:58:27 CEST\"\n\n\nlubridate paketi ile bu fonksiyonlar, sırasıyla ‘today()’ ve ‘now()’ ile de elde edilebilir. date(), haftanın günü ve ay adlarıyla birlikte geçerli tarih ve saati vermektedir.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tarihlerle çalışma</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.tr.html#tarihe-dönüştürme",
    "href": "new_pages/dates.tr.html#tarihe-dönüştürme",
    "title": "9  Tarihlerle çalışma",
    "section": "9.3 Tarihe Dönüştürme",
    "text": "9.3 Tarihe Dönüştürme\nBir veri kümesini R’a aktardıktan sonra, tarih sütunu değerleri “1989/12/30”, “05/06/2014” veya “13 Ocak 2020” gibi görünebilir. Bu durumlarda, R muhtemelen bu değerleri hala karakter değerleri olarak ele alıyordur. R’a bu değerlerin tarih olduğu söylenmelidir - tarih formatının ne olduğu (hangi kısım Gün, hangisi Ay, hangisi Yıl vb.).\nGerekli formatlar tanımlandığında, R bu değerleri Date sınıfına dönüştürür. Arka planda R, tarihleri sayı olarak saklayacaktır (“başlangıç” tarihi 1 Ocak 1970’den itibaren gün sayısı). Tarih numarasını büyük bir ihtimalle arayüzde ve hesaplamalarda kullanmayacaksınız, ancak bu, R’ın tarihleri sürekli değişkenler olarak ele almasına ve tarihler arasındaki mesafeyi hesaplama gibi özel işlemlerde kullanmasına izin verir.\nVarsayılan olarak, R’daki Date sınıfının değerleri YYYY-AA-GG olarak görüntülenmektedir. Bu bölümün ilerleyen kısımlarında, tarih değerlerinin görüntüsünün nasıl değiştirilebileceğini paylaşacağız\nAşağıda, bir sütunu karakter değerlerinden Date sınıfına dönüştürmek için iki yaklaşım sunmaktayız.\nİPUCU: Bir sütunun geçerli sınıfını base R fonksiyonu olan class() ile kontrol edebilirsiniz, örneğin class(linelist$date_onset).\n\nbase R\nas.Date(), bir nesneyi veya sütunu Date sınıfına dönüştürmek için standart, temel R fonksiyonudur. (“D” harfinin büyük harf kullanımına dikkat ediniz).\nas.Date() kullanımı aşağıdaki koşulları içermektedir:\n\nHam karakter tarihinin mevcut formatını veya tarihleri sayı olarak veriyorsanız başlangıç tarihini belirtirmelisiniz (Excel tarihleriyle ilgili bölüme bakınız)\n\nEğer bir karakter sütununda kullanılıyorsa, tüm tarih değerleri aynı formata sahip olmalıdır (eğer durum böyle değilse, parsedate paketinden parse_date() deneyebilirsiniz)\n\nİlk olarak, sütununuzun sınıfını base R’den class() fonksiyonu ile kontrol edin. Verilerinizin sınıfı hakkında emin değilseniz veya kafanız karıştıysa (örneğin, “POSIXct” vs. görüyorsanız) ilk adım olarak formatı sıfırlamak kolay bir strateji olabilir. Bunun için sütunu as.character() fonksiyonu ile Karakter sınıfına ve ardından onu Date sınıfına dönüştürebilirsiniz.\nİkinci olarak, ‘as.Date()’ fonksiyonu içinde, R’a karakter tarih bileşenlerinin geçerli biçimini - hangi karakterlerin ay, gün ve yılı ifade ettiğini ve bunların nasıl ayrıldığını belirtmek için ‘format =’ bağımsız değişkenini kullanabilirsiniz. Değerleriniz zaten R’ın standart tarih biçimlerinden (“YYYY-AA-GG” veya “YYYY/AA/GG”) biriyse, “format =” bağımsız değişkeni gerekli değildir.\nformat = için, aşağıdaki özel “strptime” kısaltmalarını kullanarak geçerli tarih biçimini temsil eden bir karakter dizisi (tırnak içinde) sağlamalısınız. Örneğin, karakter tarihleriniz şu anda “24/04/1968” gibi “GG/AA/YYYY” biçimindeyse, o zaman karakteri dönüştürmek için format = \"%d/%m/%Y\" kullanabilirsiniz. İlgili değerler tarihlere dönüştürülecektir. Formatı tırnak içine almanız gerekmektedir. Eğik çizgi veya kısa çizgileri de eklemeyi unutmayın!\n\n# Date sınıfına çevir\nlinelist &lt;- linelist %&gt;% \n  mutate(date_onset = as.Date(date_of_onset, format = \"%d/%m/%Y\"))\n\nstrptime kısaltmalarının çoğu aşağıda listelenmiştir. ?strptime komutunu çalıştırarak tam listeyi görebilirsiniz.\n%d = Aydaki gün (5, 17, 28, vb.)\n%j = Yıl-gün numarası (Julian günü 001-366)\n%a = Kısaltılmış gün (Pt, sa, Çar, vb.)\n%A = Tam gün (Pazartesi, Salı, vb.) %w = Gün sırası (0-6, Pazar 0’dır)\n%u = Gün sırası (1-7, Pazartesi 1’dir)\n%W = Hafta sırası (00-53, Pazartesi haftanın ilk günüdür)\n%U = Hafta sırası (01-53, Pazar haftanın ilk günüdür)\n%m = Ay sırası (örn. 01, 02, 03, 04)\n%b = Kısaltılmış ay (Oca, Şub, vb.)\n%B = Tam ay (Ocak, Şubat, vb.)\n%y = 2-basamak yıl (örn. 89)\n%Y = 4-basamak yıl (örn. 1989)\n%h = saat (24-saat)\n%m = dakika\n%s = saniye %z = GMT farkı %Z = Saat dilimi (karakter)\nİPUCU: ‘as.Date()’ fonksiyonun ‘format =’ argümanı, R’a tarihlerin olmasını istediğiniz biçimi söylemez, bunun yerine tarih bölümlerini siz komutu çalıştırmadan önce oldukları gibi nasıl tanımlayacağınızı söyler.\nİPUCU: “format =” bağımsız değişkeninde tarihlerinizde bulunan tarih-ayracı (ör. /, - veya boşluk) kullandığınızdan emin olun.\nDeğerler Date sınıfında olduğunda, R varsayılan olarak bunları YYYY-AA-GG olan standart biçimde görüntüler.\n\n\nlubridate\nlubridate paketi kullanılarak karakter nesnelerinin tarihlere dönüştürülmesi daha kolay hale getirilebilir. Bu, tarih ve saatlerle çalışmayı base R’dan daha basit ve tutarlı hale getirmek için tasarlanmış bir tidyverse paketidir. lubridate genellikle tarihler ve saatler için altın standart paket olarak kabul edilmektedir. Tarih hesaplamalarında bu paketle çalışmanızı tavsiye etmekteyiz.\nlubridate paketi, karakter nesnelerini ‘as.Date()’ biçiminde belirtmekten daha kolaydır. Paket tarihleri dönüştürmek için tasarlanmış birkaç farklı yardımcı fonksiyon sağlamaktadır. Bu fonksiyonlar çoğunlukla, kaba tarih biçimine özgüdür. Ancak tarihler için çeşitli ayırıcılara ve eş anlamlı tabirlerin kullanılmasına izin verir (ör. 01 - Oca - Ocak) - bunlar, tarih biçimlerinin kısaltmalarından sonra tanımlanır.\n\n# lubridate paketini indirip/yükler \npacman::p_load(lubridate)\n\n‘ymd()’ fonksiyonu, yıl, sonra ay, sonra gün olarak sağlanan tarih değerlerini esnek bir şekilde dönüştürür.\n\n# tarihi yıl-ay-gün biçiminde okur\nymd(\"2020-10-11\")\n\n[1] \"2020-10-11\"\n\nymd(\"20201011\")\n\n[1] \"2020-10-11\"\n\n\nmdy() fonksiyonu, ay, sonra gün, sonra yıl olarak sağlanan tarih değerlerini esnek bir şekilde dönüştürür.\n\n# tarihi ay-gün-yıl biçiminde okur\nmdy(\"10/11/2020\")\n\n[1] \"2020-10-11\"\n\nmdy(\"Oct 11 20\")\n\n[1] \"2020-10-11\"\n\n\ndmy() fonksiyonu, gün, sonra ay, sonra yıl olarak sağlanan tarih değerlerini esnek bir şekilde dönüştürür.\n\n# tarihi gün-ay-yıl biçiminde okur\ndmy(\"11 10 2020\")\n\n[1] \"2020-10-11\"\n\ndmy(\"11 October 2020\")\n\n[1] \"2020-10-11\"\n\n\n\n\n\n\nTünelleme kullanılıyorsa, bir karakter sütununun lubridate ile tarihlere dönüştürülmesi şöyle görünebilir:\n\nlinelist &lt;- linelist %&gt;%\n  mutate(date_onset = lubridate::dmy(date_onset))\n\nİşlemler tamamlandığında, sütunun sınıfını doğrulamak için class() komutunu çalıştırabilirsiniz.\n\n# Sütunun sınıfını kontrol edin\nclass(linelist$date_onset)  \n\nDeğerler Date sınıfında olduğunda, R varsayılan olarak bunları YYYY-AA-GG olan standart biçimde görüntüler.\nYukarıdaki fonksiyonların 4 basamaklı yıllarda en verimli şekilde çalıştığını unutmayın. lubridate yüzyılı tahmin etmeye çalıştığı için 2 basamaklı yıllar beklenmedik sonuçlar üretebilmektedir.\n2 basamaklı bir yılı 4 basamaklı bir yıla dönüştürmek için (tümü aynı yüzyılda) sınıf karakterine dönüştürebilir ve ardından stringr paketinden (bkz. Karakterler ve dizeler) str_glue() fonksiyonu kullanarak mevcut rakamları bir ön ek ile birleştirebilirsiniz. Ardından tarihe dönüştürebilirsiniz.\n\ntwo_digit_years &lt;- c(\"15\", \"15\", \"16\", \"17\")\nstr_glue(\"20{two_digit_years}\")\n\n2015\n2015\n2016\n2017\n\n\n\n\nSütunları birleştirme\nBirden çok sütunu tek bir tarih sütununda birleştirmek için make_date() ve make_datetime() lubridate fonksiyonlarını kullanabilirsiniz. Örneğin, “linelist” veri formatında onset_day, onset_month ve onset_year sütunlarınız mevcutsa:\n\nlinelist &lt;- linelist %&gt;% \n  mutate(onset_date = make_date(year = onset_year, month = onset_month, day = onset_day))",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tarihlerle çalışma</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.tr.html#excel-tarihleri",
    "href": "new_pages/dates.tr.html#excel-tarihleri",
    "title": "9  Tarihlerle çalışma",
    "section": "9.4 Excel tarihleri",
    "text": "9.4 Excel tarihleri\nArka planda, çoğu yazılım, tarihleri sayı olarak kaydeder. R 1 Ocak 1970 tarihini başlangıç tarihi olarak ele almaktadır. Bu nedenle, as.numeric(as.Date(\"1970-01-01)) komutunu çalıştırırsanız 0 sonucunu elde edersiniz.\nMicrosoft Excel, işletim sisteminize bağlı olarak 30 Aralık 1899 (Windows) veya 1 Ocak 1904 (Mac) tarihleri başlangıç tarihi olarak depolamaktadır. Detaylar için Microsoft rehberini inceleyebilirsiniz.\nExcel tarihleri genellikle R’a karakter yerine sayısal değerler olarak aktarılmaktadır. Excel’den içe aktardığınız veri kümesi, tarihleri sayı veya “41369” gibi karakterler olarak gösteriyorsa bunları istenilen formata dönüştürmek için as.Date() (veya lubridate’nin as_date() işlevini) kullanabilirsiniz. Ancak yukarıdaki gibi bir “formatı” tanımlamak yerine, origin = argümanıyla Excel başlangıç tarihini R’a bildirebilirsiniz.\nExcel tarihi bir Karakter türü olarak R’a aktarılmışsa bu fonksiyon işe yaramaz, bu nedenle sayının Numeric sınıfında olduğundan emin olun!\nNOT: Başlangıç tarihini R’ın varsayılan tarih biçiminde (“YYYY-AA-GG”) formatlamalısınız.\n\n# Exceldeki sayı formatındaki tarihleri dönüştürürken Excel 'başlangıç tarihi' sağlamaya ilişkin bir örnek\ndata_cleaned &lt;- data %&gt;% \n  mutate(date_onset = as.numeric(date_onset)) %&gt;%   # sınıfın numeric olduğundan emin olun\n  mutate(date_onset = as.Date(date_onset, origin = \"1899-12-30\")) # Excel orijinini kullanarak tarih formatına dönüştürme",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tarihlerle çalışma</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.tr.html#karışık-tarihler",
    "href": "new_pages/dates.tr.html#karışık-tarihler",
    "title": "9  Tarihlerle çalışma",
    "section": "9.5 Karışık tarihler",
    "text": "9.5 Karışık tarihler\nparsedate paketindeki parse_dates() fonksiyonu, birçok farklı biçimde tarihleri içeren “dağınık” bir tarih sütununu okumaya ve tarihleri standart bir biçime dönüştürmeye çalışır. parse_date() hakkında daha fazla bilgiyi için bakınız.\nÖrneğin, parse_dates(), “03 Oca 2018”, “07/03/1982” ve “08/20/85” karakter tarihlerinin bir vektörünü görür ve bunları Date sınıfına dönüştürür: ‘2018-01-03’, ‘1982-03-07’ ve ‘1985-08-20’.\n\nparsedate::parse_date(c(\"03 Janry 18\",\n                        \"07/03/1982\",\n                        \"8-20-1985\"))\n\n[1] \"2018-01-03 UTC\" \"1982-07-03 UTC\" \"1985-08-20 UTC\"\n\n\n\n# dater_onset sütununda parse_date() kullanan bir örnek\nlinelist &lt;- linelist %&gt;%      \n  mutate(date_onset = parse_date(date_onset))",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tarihlerle çalışma</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.tr.html#date-time-sınıfı-ile-çalışma",
    "href": "new_pages/dates.tr.html#date-time-sınıfı-ile-çalışma",
    "title": "9  Tarihlerle çalışma",
    "section": "9.6 Date-time sınıfı ile çalışma",
    "text": "9.6 Date-time sınıfı ile çalışma\nDaha önce belirtildiği gibi, R ek olarak datetime sınıfını desteklemektedir - tarih ve saat bilgilerini içeren bir sütun. “Date” sınıfında olduğu gibi, bu verilerin genellikle karakter nesnelerinden datetime nesnelerine dönüştürülmesi gerekmektedir.\n\nTarihleri saatlerle dönüştürme\nStandart bir “datetime” nesnesi önce tarihle, ardından bir saat bileşeniyle biçimlendirilir - örneğin 01 Ocak 2020, 16:30. Tarihlerde olduğu gibi, bun durumun biçimlendirilmesinin ve kesinlik düzeyinin (saat, dakika, saniye) tanımlanmasının bir çok yolu mevcuttur.\nNeyse ki, bu dizeleri ‘datetime’ nesnelerine dönüştürmeye yardımcı olmak için lubridate paketinin yardımcı fonksiyonları mevcuttur. Bu fonksiyonların, sonuna “_h” (saati tanımlar), “_hm” (saat ve dakikayı tanımlar) veya “_hms” (saat, dakika ve saniyeyi tanımlar) uzantıları eklenebilir (örn. dmy_hms()`). Aşağıda bu uzantıların kullanımı için örnekler verilmiştir.\nYalnızca saat bilgisi olan datetime verilerini datetime nesnesine dönüştürme:\n\nymd_h(\"2020-01-01 16hrs\")\n\n[1] \"2020-01-01 16:00:00 UTC\"\n\nymd_h(\"2020-01-01 4PM\")\n\n[1] \"2020-01-01 16:00:00 UTC\"\n\n\nSaat ve dakika bilgisi olan datetime verilerini datetime nesnesine dönüştürme:\n\ndmy_hm(\"01 January 2020 16:20\")\n\n[1] \"2020-01-01 16:20:00 UTC\"\n\n\nSaat, dakika ve saniye bilgisi olan datetime verilerini datetime nesnesine dönüştürme:\n\nmdy_hms(\"01 January 2020, 16:20:40\")\n\n[1] \"2020-01-20 16:20:40 UTC\"\n\n\nSaat dilimini formata ekleyebilirsiniz ancak bu bilgi yok sayılmaktadır. Daha detaylı bilgi için ilerleyen bölümlerdeki saat dilimleri bölümüne bakınız.\n\nmdy_hms(\"01 January 2020, 16:20:40 PST\")\n\n[1] \"2020-01-20 16:20:40 UTC\"\n\n\nBir veri çerçevesiyle çalışırken, stringr paketinden str_glue() fonksiyonu ve uygun bir lubridate fonksiyonu kullanılarak saat ve tarih sütunları birleştirilebilir. stringr ile ilgili ayrıntılar için Karakterler ve dizeler hakkındaki sayfaya bakınız.\nBu örnekte, “linelist” veri çerçevesi “saat:dakika” biçiminde bir sütuna sahiptir. Bunu bir datetime formatına dönüştürmek için aşağıdaki adımları izleyebiliriz:\n\nEksik verileri medyan sütunlarından elde edilen verilerle tamamlanmış, “temiz” bir hasta kabul sütunu oluşturun. Bunu yapıyoruz çünkü lubridate eksik değerler üzerinde çalışmayacaktır. Bunu “date_hospitalisation” sütunuyla birleştirin ve ardından istenilen formata dönüştürmek için “ymd_hm()” işlevini kullanın.\n\n\n# paketler\npacman::p_load(tidyverse, lubridate, stringr)\n\n# time_admission, saat:dakika cinsinden bir sütundur\nlinelist &lt;- linelist %&gt;%\n  \n  # uygun saat bulunamadığında, medyan kabul süresini atama\n  mutate(\n    time_admission_clean = ifelse(\n      is.na(time_admission),         # zaman eksikse\n      median(time_admission),        # medyan ata\n      time_admission                 # eksik değilse olduğu gibi tut\n  ) %&gt;%\n  \n    # bir karakter sütunu oluşturmak üzere tarih ve saat sütunlarını birleştirmek için str_glue() fonksiyonunu kullanın\n    # ve sonra onu tarih saatine dönüştürmek için ymd_hm() fonksiyonunu kullanın\n  mutate(\n    date_time_of_admission = str_glue(\"{date_hospitalisation} {time_admission_clean}\") %&gt;% \n      ymd_hm()\n  )\n\n\n\nSadece saatleri çevirme\nVerileriniz yalnızca bir karakter süresi (saat ve dakika) içeriyorsa, base R’dan strptime() kullanarak bunları zaman formatına dönüştürebilir ve değiştirebilirsiniz. Örneğin, bu iki süre arasındaki farkı elde etmek için:\n\n# ham karakter süreleri\ntime1 &lt;- \"13:45\" \ntime2 &lt;- \"15:20\"\n\n# Datetime sınıfına dönüştürülen zamanlar\ntime1_clean &lt;- strptime(time1, format = \"%H:%M\")\ntime2_clean &lt;- strptime(time2, format = \"%H:%M\")\n\n# Fark, varsayılan olarak \"difftime\" sınıfındadır, burada sayısal saatlere dönüştürülür\nas.numeric(time2_clean - time1_clean)   # saat farkı\n\n[1] 1.583333\n\n\nBununla birlikte, herhangi bir tarih değerine ulaşılamazsa, tarihin bugün olduğunu varsayıldığını unutmayın. Bir tarih harf dizisini ve bir zamanı harf dizisiyle birleştirmek için, hemen yukarıdaki bölümde stringr’nin nasıl kullanılacağına bakınız. strptime() hakkında daha fazla bilgiyi buradan okuyabilirsiniz.\nTek basamaklı sayıları çift basamaklı sayılara dönüştürmek için (ör. 2 basamak elde etmek için baştaki sıfırlarla birlikte saat veya dakika formatına), Karakterler ve dizeler sayfasının “Taban uzunluğu” bölümüne bakınız.\n\n\nSaati ayıklama\nBir zamanın alt öğelerini lubridate’paketinden ‘hour()’, ‘minute()’ veya ‘second()’ fonksiyonu ile seçebilirsiniz.\nSaatin ayıklanması ve ardından günün bölümlerine göre sınıflandırılmasına bir örnek verilmesi gerekirse: “SS:DD” biçimindeki Karakter sınıfı olan time_admission sütununu göz önüne alalım. İlk olarak, karakterleri datetime sınıfına dönüştürmek için yukarıda açıklandığı gibi strptime() fonksiyonu kullanılır. Daha sonra saat, 0-24 arasında bir sayı döndürerek hour() fonksiyonu ile çıkarılır. Son olarak, satırları giriş saatlerine göre Sabah/Öğleden sonra/Akşam/Gece olarak sınıflandırmak için case_while() mantığı kullanılarak bir ‘time_period’ sütunu oluşturulur.\n\nlinelist &lt;- linelist %&gt;%\n  mutate(hour_admit = hour(strptime(time_admission, format = \"%H:%M\"))) %&gt;%\n  mutate(time_period = case_when(\n    hour_admit &gt; 06 & hour_admit &lt; 12 ~ \"Morning\",\n    hour_admit &gt;= 12 & hour_admit &lt; 17 ~ \"Afternoon\",\n    hour_admit &gt;= 17 & hour_admit &lt; 21 ~ \"Evening\",\n    hour_admit &gt;=21 | hour_admit &lt;= 6 ~ \"Night\"))\n\ncase_while() hakkında daha fazla bilgi edinmek için Temizleme verileri ve temel işlevler hakkındaki sayfaya bakınız.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tarihlerle çalışma</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.tr.html#tarihlerle-çalışma",
    "href": "new_pages/dates.tr.html#tarihlerle-çalışma",
    "title": "9  Tarihlerle çalışma",
    "section": "9.7 Tarihlerle çalışma",
    "text": "9.7 Tarihlerle çalışma\nlubridate aynı zamanda date/datetime özelliklerini çıkarma, tarih aritmetiği gerçekleştirme veya tarih aralıklarını hesaplama gibi çeşitli başka işlevler için de kullanılabilir.\nBurada örnekler için kullanılacak bir tarih tanımlayacağız:\n\n# Date sınıfının nesnesini oluşturma\nexample_date &lt;- ymd(\"2020-03-01\")\n\n\nTarih bileşenlerini ayıklama\nAy, gün, hafta içi gibi ortak yönleri çıkarabilirsiniz:\n\nmonth(example_date)  # ay numarası\n\n[1] 3\n\nday(example_date)    # ayın günü (sayı)\n\n[1] 1\n\nwday(example_date)   # haftanın gün sayısı (1-7)\n\n[1] 1\n\n\nAyrıca bir datetime nesnesinden veya sütunundan saat bileşenlerini de çıkarabilirsiniz. Bu durum, özellikle başvuru saatlerinin dağılımını görmek istiyorsanız yararlı olabilir.\n\nexample_datetime &lt;- ymd_hm(\"2020-03-01 14:45\")\n\nhour(example_datetime)     # saati ayıklama\nminute(example_datetime)   # dakikayı ayıklama\nsecond(example_datetime)   # saniyeyi ayıklama\n\nHafta bilgilerini ayıklamak için birkaç seçenek vardır. Aşağıdaki Epidemiyolojik haftalar bölümüne bakın.\nBir tarihi belirli bir şekilde görüntülemek istiyorsanız (örneğin, “Ocak 2020” veya “20 Mart Perşembe” veya “20. Hafta, 1977”) bunu Tarihi görüntüleme bölümünde açıklandığı gibi daha esnek bir şekilde yapabilirsiniz.\n\n\nTarih matematiği\nlubridate’deki ilgili fonksiyonları kullanarak belirli sayıda gün veya hafta ekleyebilirsiniz.\n\n# bu tarihe 3 gün ekleyin\nexample_date + days(3)\n\n[1] \"2020-03-04\"\n\n# 7 hafta ekleyin ve bu tarihten iki gün çıkarın\nexample_date + weeks(7) - days(2)\n\n[1] \"2020-04-17\"\n\n\n\n\nTarih aralıkları\nTarihler arasındaki fark şu şekilde hesaplanabilir:\n\nHer iki tarihin de Date sınıfına ait olduğundan emin olun\nİki tarih arasındaki “zaman farkını (difftime)” elde etmek için çıkarma işlemini kullanın\n\nGerekirse, sonraki matematiksel hesaplamaları yapmak için sonucu sayısal sınıfa dönüştürün\n\nAşağıdaki kodda iki tarih arasındaki aralığın hesaplanması ve görüntülenmesi verilmiştir. Date sınıfındaki değerlerde çıkarma (eksi) işareti ile aralıkları bulabilirsiniz. Ancak, döndürülen değerin sınıfının aşağıda gösterildiği gibi “difftime” olduğunu ve sayısala dönüştürülmesi gerektiğini unutmayın.\n\n# bu tarih ile 20 Şubat 2020 arasındaki aralığı bulun\noutput &lt;- example_date - ymd(\"2020-02-20\")\noutput    # yazdır\n\nTime difference of 10 days\n\nclass(output)\n\n[1] \"difftime\"\n\n\nBir “difftime” üzerinde sonraki işlemleri yapmak için, onu as.numeric() ile sayısal değere dönüştürmelisiniz.\nBunların hepsi verilerle çalışmak için bir araya getirilebilir - örneğin:\n\npacman::p_load(lubridate, tidyverse)   # paketleri yükleme\n\nlinelist &lt;- linelist %&gt;%\n  \n  # dmy biçimini belirterek başlangıç tarihini, karakterden tarih nesnelerine dönüştürün\n  mutate(date_onset = dmy(date_onset),\n         date_hospitalisation = dmy(date_hospitalisation)) %&gt;%\n  \n  # Mart ayında başlamayan tüm vakaları filtreleyin\n  filter(month(date_onset) == 3) %&gt;%\n    \n  # başlangıç ve hastaneye yatış arasındaki gün farkını bulun\n  mutate(days_onset_to_hosp = date_hospitalisation - date_of_onset)\n\nBir veri çerçevesi bağlamında, yukarıdaki tarihlerden biri eksikse, o satır için işlem başarısız olur. Sonuç, sayısal bir değer yerine bir “NA” olarak verilecektir. Bu sütunu hesaplamalar için kullanırken, na.rm = bağımsız değişkenini TRUE (DOĞRU) olarak ayarladığınızdan emin olun. Örneğin:\n\n# verilerin mevcut olduğu tüm vakalar için; hastaneye yatışa kadar geçen medyan gün sayısını hesaplama\nmedian(linelist_delay$days_onset_to_hosp, na.rm = T)",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tarihlerle çalışma</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.tr.html#tarihi-gösterme",
    "href": "new_pages/dates.tr.html#tarihi-gösterme",
    "title": "9  Tarihlerle çalışma",
    "section": "9.8 Tarihi gösterme",
    "text": "9.8 Tarihi gösterme\nTarihler doğru sınıfta formatlandığında; farklı şekilde görüntülenmelerini isteyebilir (örneğin “2018-01-05” yerine “05 Ocak Pazartesi”), satırları tarih öğelerine göre gruplandırabilir (örneğin ay-yıla göre gruplandırma) gösterilme sırasını istediğiniz gibi düzenleyebilirsiniz.\n\nformat()\nTarih gösterimini base R fonksiyonu olan format() ile ayarlayabilirsiniz. Bu fonksiyon, “%” strptime kısaltmalarında istenen çıktı biçimini belirten bir karakter dizesini (tırnak içinde) argüman olarak kabul etmektedir.- (as.Date() içinde kullanılanla benzer sözdizimi). Aşağıda yaygın olarak kullanılan kısaltmaların çoğu verilmiştir.\nNot: format() fonksiyonunu kullanmak değerleri Karakter sınıfına dönüştürür, bu nedenle bu genellikle bir analizin sonuna doğru veya yalnızca görüntüleme amacıyla kullanılır! ?strptime komutunu çalıştırarak tam listeyi görebilirsiniz.\n%d = Aydaki gün (5, 17, 28, vb.)\n%j = Yıl-gün numarası (Julian günü 001-366)\n%a = Kısaltılmış gün (Pt, sa, Çar, vb.)\n%A = Tam gün (Pazartesi, Salı, vb.) %w = Gün sırası (0-6, Pazar 0’dır)\n%u = Gün sırası (1-7, Pazartesi 1’dir)\n%W = Hafta sırası (00-53, Pazartesi haftanın ilk günüdür)\n%U = Hafta sırası (01-53, Pazar haftanın ilk günüdür)\n%m = Ay sırası (örn. 01, 02, 03, 04)\n%b = Kısaltılmış ay (Oca, Şub, vb.)\n%B = Tam ay (Ocak, Şubat, vb.)\n%y = 2-basamak yıl (örn. 89)\n%Y = 4-basamak yıl (örn. 1989)\n%h = saat (24-saat)\n%m = dakika\n%s = saniye %z = GMT farkı %Z = Saat dilimi (karakter)\nBugünün tarihini biçimlendirmeye bir örnek olarak:\n\n# bugünün tarihi, biçimlendirme ile\nformat(Sys.Date(), format = \"%d %B %Y\")\n\n[1] \"10 May 2024\"\n\n# tam tarih ve saati almanın kolay yolu (varsayılan biçimlendirme)\ndate()\n\n[1] \"Fri May 10 05:58:28 2024\"\n\n# str_glue() fonksiyonunu kullanarak biçimlendirilmiş birleşik tarih, saat ve saat dilimi\nstr_glue(\"{format(Sys.Date(), format = '%A, %B %d %Y, %z  %Z, ')}{format(Sys.time(), format = '%H:%M:%S')}\")\n\nFriday, May 10 2024, +0000  UTC, 05:58:28\n\n# Haftaları görüntüleme formatını kullanma\nformat(Sys.Date(), \"%Y Week %W\")\n\n[1] \"2024 Week 19\"\n\n\nstr_glue() fonksiyonunu kullanıyorsanız, sözdizimi formatındaki çift tırnak içinde (“) yalnızca tek tırnak kullanmanız gerektiğini unutmayın (yukarıdaki örnekte verildiği gibi).\n\n\nAy-Yıl\nBir Date sütununu Ay-yıl biçimine dönüştürmek için, zoo paketindeki as.yearmon() işlevini kullanmanızı öneririz. Bu, tarihi “yearmon” sınıfına dönüştürür ve uygun sıralamayı korur. Buna karşılık, format(column, \"%Y %B\") fonksiyonunun kullanılması, değerleri Karakter sınıfına dönüştürecek ve değerleri alfabetik olarak (yanlış) sıralayacaktır.\nAşağıda, “as.yearmon()” fonksiyonu kullanılarak “date_onset” sütunundan yeni bir “yearmonth” sütunu oluşturulmuştur. Elde edilen değerlerin varsayılan (doğru) sıralaması tabloda gösterilmiştir.\n\n# yeni sütun oluştur\ntest_zoo &lt;- linelist %&gt;% \n     mutate(yearmonth = zoo::as.yearmon(date_onset))\n\n# tabloyu yazdır\ntable(test_zoo$yearmon)\n\n\nApr 2014 May 2014 Jun 2014 Jul 2014 Aug 2014 Sep 2014 Oct 2014 Nov 2014 \n       7       64      100      226      528     1070     1112      763 \nDec 2014 Jan 2015 Feb 2015 Mar 2015 Apr 2015 \n     562      431      306      277      186 \n\n\nBuna karşılık, aşağıdaki örnekte, format() fonksiyonu ile istenen görüntüleme biçimini verirken, ancak doğru sıralamayı nasıl sağlayamadığını görebilirsiniz.\n\n# yeni sütun oluştur\ntest_format &lt;- linelist %&gt;% \n     mutate(yearmonth = format(date_onset, \"%b %Y\"))\n\n# tabloyu yazdır\ntable(test_format$yearmon)\n\n\nApr 2014 Apr 2015 Aug 2014 Dec 2014 Feb 2015 Jan 2015 Jul 2014 Jun 2014 \n       7      186      528      562      306      431      226      100 \nMar 2015 May 2014 Nov 2014 Oct 2014 Sep 2014 \n     277       64      763     1112     1070 \n\n\nNot: Bir ggplot() içinde çalışıyor ve sadece tarihlerin nasıl görüntülendiğini düzenlemek istiyorsanız, scale_x_date() fonksiyonu içindeki date_labels = argümanına bir strptime formatı sağlamak yeterli olabilir. Bunun için \"%b %Y\" veya \"%Y %b\" formatını kullanabilirsiniz. Detaylı bilgi için [ggplot ipuçları] sayfasına bakınız.\nzoo ayrıca as.yearqtr() fonksiyonuna da sahiptir ve ggplot() kullanırken scale_x_yearmon() fonksiyonunu da bu amaçla kullanabilirsiniz.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tarihlerle çalışma</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.tr.html#dates_epi_wks",
    "href": "new_pages/dates.tr.html#dates_epi_wks",
    "title": "9  Tarihlerle çalışma",
    "section": "9.9 Epidemiyolojik haftalar",
    "text": "9.9 Epidemiyolojik haftalar\n\nlubridate\nVerileri tarihlerine göre gruplandırmaya ilişkin daha kapsamlı örnekler için Gruplama verileri hakkındaki sayfaya bakınız. Aşağıda, verileri haftalara göre gruplandırmayı kısaca açıklamaktayız.\nGenellikle, lubridate paketindeki floor_date() fonksiyonunu, unit = \"week\" bağımsız değişkeniyle kullanmanızı önermekteyiz. Bu, week_start = bağımsız değişkeniyle tanımlandığı gibi tarihi haftanın “başlangıcına” yuvarlar. Varsayılan hafta başlangıcı 1’dir (Pazartesiler için), ancak haftanın herhangi bir gününü başlangıç olarak belirtebilirsiniz (ör. Pazar günleri için 7). “floor_date()” çok yönlü bir fonksiyondur; unit = öğesini “saniye (second)”, “dakika (minute)”, “saat (hour)”, “gün (day)”, “ay (month)” veya “yıl (year)” olarak ayarlayarak diğer zaman birimlerine yuvarlamak için kullanılabilir.\nDöndürülen değer, Date sınıfında haftanın başlangıç tarihidir. Date sınıfı, ggplot() tarafından kolayca tanınacağı ve doğru şekilde sıralanacağı için verileri çizerken de gayet kolaylık sağlamaktadır.\nTarihleri bir grafikte yalnızca haftasına göre görüntülemek ile ilgileniyorsanız, bu sayfadaki Tarihi görüntüleme bölümüne bakınız. Örneğin, bir epicurve çizerken, istenen strptime “%” terminolojisini sağlayarak tarih görüntüsünü biçimlendirebilirsiniz. Örneğin, yıl ve hafta numarasını döndürmek için “%Y-%W” veya “%Y-%U” kullanabilirsiniz (sırasıyla Pazartesi veya Pazar haftanın ilk günü olarak kabul edilmektedir).\n\n\nHaftalık sayımlar\nVerileri count(), group_by() ve summarise() ile gruplandırmanın kapsamlı açıklamaları için Verileri Gruplama ile ilgili sayfaya bakınız. Aşğıda Kısa bir örnek verilmiştir.\n\nunit = \"week\" argümanıyla floor_date() ve mutate() fonksiyonlarıyla yeni bir “hafta” sütunu oluşturun\ncount() ile haftalık satır (vaka) sayısını alın; tarihi eksik olan vakaları filtreleyin\nVerilerde tüm haftaların görünmesini sağlamak için tidyr’paketinden complete() ile fonksiyonunu kullanın (satır/durum bilgisi içermeyenleri de eklemek adına). Varsayılan olarak, herhangi bir “yeni” satır için sayım değerleri NA’dır, ancak bunları adlandırılmış bir liste bekleyen fill = argümanıyla 0 yapabilirsiniz (aşağıdaki örnekte verilen n değeri yeni sütununun adıdır)\n\n\n# Haftalık vaka sayılarının yeni bir veri setinde gösterin\nweekly_counts &lt;- linelist %&gt;% \n  drop_na(date_onset) %&gt;%             # başlangıç tarihi eksik vakaları kaldırın\n  mutate(weekly_cases = floor_date(   # \"weekly_cases\" adında yeni bir sütun oluştur\n    date_onset,\n    unit = \"week\")) %&gt;%            \n  count(weekly_cases) %&gt;%           # verileri haftaya göre gruplandır ve grup başına satırları say ('n' sütununu oluşturur)\n  tidyr::complete(                  # vaka bildirilmemiş olan haftalar da dahil olmak üzere tüm haftaların mevcut olduğundan emin ol\n    weekly_cases = seq.Date(          # \"weekly_cases\" sütununu eksiksiz bir dizi olarak yeniden tanımla\n      from = min(weekly_cases),       # minimum tarihten itibaren\n      to = max(weekly_cases),         # maksimum tarihe kadar\n      by = \"week\"),                   # hafta olarak\n    fill = list(n = 0))             # n sütunundaki NA'ları 0 ile değiştir\n\nOrtaya çıkan veri çerçevesinin ilk satırları şunlardır:\n\n\n\n\n\n\n\n\nEpiweek alternatifleri\nlubridate’nin ayrıca her biri farklı başlangıç tarih ve nüanslarına sahip olan week(), epiweek() ve isoweek() fonksiyonlarına sahip olduğunu unutmayın. Genel olarak, floor_date() ihtiyacınız olan her şeyi kapsamaktadır. Konsola ?week girerek veya buradaki belgeleri okuyarak daha fazla bilgiye ulaşabilirsiniz.\nEpidemiyolojik haftaları ayarlamak için aweek paketini kullanmayı düşünebilirsiniz. Bununla ilgili daha fazla bilgiyi RECON web sitesinde okuyabilirsiniz. Haftanın başlangıç gününü week_start = \"Monday\" ile ayarlayabileceğiniz ‘date2week()’ ve ‘week2date()’ fonksiyonları mevcuttur. “Hafta” tarzı çıktılar istiyorsanız (örneğin “2020-W12”) bu paket en kolay yoldur. aweek’in bir başka avantajı da, tarih sütununa date2week() uygulandığında, döndürülen sütunun (hafta biçimi) otomatik olarak sınıf Faktörü olması ve zaman aralığındaki tüm haftalar için seviyeleri de içermesidir (bu, yukarıda anlatılan complete() komutunda ek adımını yok sayar). aweek, tarihleri ay, yıl vb. gibi diğer zaman birimlerine yuvarlama işlevine sahip değildir.\nBir “hafta” biçimini (“2020 W12”) göstermek için başka bir zaman serisi alternatifi de, [Zaman serisi ve salgın tespiti] sayfasında anlatılan tsibble paketindeki yearweek()tir. .",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tarihlerle çalışma</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.tr.html#tarihlerisaat-dilimlerini-dönüştürme",
    "href": "new_pages/dates.tr.html#tarihlerisaat-dilimlerini-dönüştürme",
    "title": "9  Tarihlerle çalışma",
    "section": "9.10 Tarihleri/saat dilimlerini dönüştürme",
    "text": "9.10 Tarihleri/saat dilimlerini dönüştürme\nVeriler farklı saat dilimlerinde olduğunda, bu verileri birleşik bir saat dilimine standart hale getirmek genellikle önemlidir. Çoğu durumda verilerin saat dilimi bileşeninin manuel olarak kodlanması gerektiğinden, bu daha fazla zorluğa neden olmaktadır.\nR’da her datetime nesnesinin bir saat dilimi bileşeni vardır. Varsayılan olarak, tüm datetime nesneleri kullanılan bilgisayarın yerel saat dilimini kullanmaktadır - bu genellikle, yaz saati uygulaması nedeniyle zaman dilimleri konumlarda sık sık değişeceğinden, adlandırılmış bir saat dilimi yerine konuma özgüdür. Bir tarih sütununun temsil ettiği olay belirli bir zamana atfedilemeyeceğinden ve bu nedenle saat cinsinden ölçülen zaman kaymaları makul bir şekilde açıklanamaz. Tarihin zaman bileşeni olmadan saat dilimlerini doğru bir şekilde yönetmek mümkün değildir.\nSaat dilimleriyle başa çıkabilmek için, lubridate’de bir datetime nesnesinin saat dilimini farklı bir saat dilimine değiştirmek için kullanılabilecek bir dizi yardımcı fonksiyon mevcuttur. Saat dilimleri, datetime nesnesine geçerli bir tz veritabanı saat dilimi atanarak hesaplanır. Bunların bir listesini aşağıdaki linkte bulabilirsiniz - verileri kullandığınız konum bu listede değilse, saat dilimine yakın büyük şehirleri kullanabilirsiniz, bu, aynı amaca hizmet edecektir.\nhttps://en.wikipedia.org/wiki/List_of_tz_database_time_zones\n\n# geçerli saati bir sütuna ata\ntime_now &lt;- Sys.time()\ntime_now\n\n[1] \"2024-05-10 05:58:29 CEST\"\n\n# saat zamanını DEĞİŞTİRİRKEN sütuna yeni bir saat dilimi atamak için with_tz() kullan\ntime_london_real &lt;- with_tz(time_now, \"Europe/London\")\n\n# sütuna yeni bir saat dilimi atamak için force_tz() kullanın, saat zamanını SABİTLEYİN\ntime_london_local &lt;- force_tz(time_now, \"Europe/London\")\n\n\n# Bu kodu çalıştırmak için kullanılan bilgisayar Londra saat diliminde olmadığını unutmayın,\n# zaman farkı olacaktır\n# (bilgisayar saat diliminden londra'ya kadar olan saat farkı)\ntime_london_real - time_london_local\n\nTime difference of -1 hours\n\n\nBu büyük ölçüde soyut görünebilir ve kullanıcı farklı zaman dilimlerinde çalışmıyorsa genellikle gerekli değildir.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tarihlerle çalışma</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.tr.html#gecikme-ve-önden-gelme-hesaplamaları",
    "href": "new_pages/dates.tr.html#gecikme-ve-önden-gelme-hesaplamaları",
    "title": "9  Tarihlerle çalışma",
    "section": "9.11 Gecikme ve önden gelme hesaplamaları",
    "text": "9.11 Gecikme ve önden gelme hesaplamaları\nlead() ve lag(), bir vektördeki önceki (geciken) veya sonraki (önden gelen) değerleri bulmaya yardımcı olan dplyr paketindeki fonksiyonlarıdır - tipik olarak bir sayısal veya tarih vektörüdür. Bu fonksiyonlar, zaman birimleri arasındaki değişim/fark hesaplamaları yaparken işe yarar.\nMevcut bir hafta ile önceki hafta arasındaki vaka farkını hesaplamak istediğinizi varsayalım. Veriler başlangıçta aşağıda gösterildiği gibi haftalık sayılarla elde edilir.\n\n\n\n\n\n\nlag() veya lead() komutlarını kullanırken veri çerçevesindeki satırların sırası çok önemlidir! - tarihlerinizin / numaralarınızın artan mı yoksa azalan mı olduğuna dikkat etmelisiniz.\nİlk olarak, önceki (geciken) haftanın değerini içeren yeni bir sütun oluşturun.\n\nGeri/ileri birim sayısını n = ile kontrol edin (negatif olmayan bir tam sayı olmalıdır)\n\nVar olmayan satırlara yerleştirilen değeri tanımlamak için default = argümanını kullanın (örneğin, gecikmeli değerin olmadığı ilk satır). Varsayılan olarak bu NAdır.\n\nSatırlarınız referans sütununuza göre sıralanmıyorsa order_by = TRUE argümanını kullanın\n\n\ncounts &lt;- counts %&gt;% \n  mutate(cases_prev_wk = lag(cases_wk, n = 1))\n\n\n\n\n\n\n\nArdından, iki vaka sütunu arasındaki farkı hesaplayan yeni bir sütun oluşturun:\n\ncounts &lt;- counts %&gt;% \n  mutate(cases_prev_wk = lag(cases_wk, n = 1),\n         case_diff = cases_wk - cases_prev_wk)\n\n\n\n\n\n\n\nlead() ve lag() hakkında daha fazla bilgiyi buradaki belgelerde veya `?lag`` kodunu konsola girerek elde edebilirsiniz.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tarihlerle çalışma</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.tr.html#kaynaklar",
    "href": "new_pages/dates.tr.html#kaynaklar",
    "title": "9  Tarihlerle çalışma",
    "section": "9.12 Kaynaklar",
    "text": "9.12 Kaynaklar\nlubridate tidyverse sayfası\nlubridate RStudio kopya kağıdı\nVeri Bilimi için R - tarih ve saatler sayfası\nÇevrimiçi rehber Tarih formatları",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tarihlerle çalışma</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.tr.html",
    "href": "new_pages/characters_strings.tr.html",
    "title": "10  Karakterler ve dizeler",
    "section": "",
    "text": "10.1 Hazırlık",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Karakterler ve dizeler</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.tr.html#hazırlık",
    "href": "new_pages/characters_strings.tr.html#hazırlık",
    "title": "10  Karakterler ve dizeler",
    "section": "",
    "text": "Paketleri yükleme\nstringr ve diğer tidyverse paketlerini kurun veya yükleyin.\n\n# paketleri indir/yükle\npacman::p_load(\n  stringr,    # dizeleri işlemek için birçok fonksiyon\n  tidyverse,  # ek veri işleme fonksiyonları\n  tools)      # başlıkları dönüştürmek için alternatif\n\n\n\nVerileri yükleme\nBu sayfada, simüle edilmiş bir Ebola salgını vakalarının temizlenmiş “satır listesine” ara sıra atıfta bulunulacaktır. Daha fazla bilgi için, “temiz satır listesi” dosyasını indirmek için tıklayın. (.rds dosyası olarak). rio paketinden import() işleviyle veriler içe aktarırılır (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için İçe ve dışa aktarma sayfasına bakın).\n\n# Satır listesini indir\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nThe first 50 rows of the linelist are displayed below.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Karakterler ve dizeler</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.tr.html#birleştir-böl-ve-düzenle",
    "href": "new_pages/characters_strings.tr.html#birleştir-böl-ve-düzenle",
    "title": "10  Karakterler ve dizeler",
    "section": "10.2 Birleştir, böl ve düzenle",
    "text": "10.2 Birleştir, böl ve düzenle\nBu bölüm aşağıdaki başlıkları içermektedir:\n\nstr_c(), str_glue(), ve unite() komutlarıyla dizeleri birleştirmek\n\nstr_order() komutuyla dizeleri sıralamak\nstr_split() ve separate() komutuyla dizeleri ayırmak\n\n\n\nDizeleri Birleştirme\nBirden çok dizeyi tek bir dizede birleştirmek için, stringr’dan str_c fonksiyonu kullanılır. Birleştirilecek farklı karakterler mevcutsa, bunları virgülle ayırarak benzersiz argümanlar olarak eklemeniz yeterlidir.\n\nstr_c(\"String1\", \"String2\", \"String3\")\n\n[1] \"String1String2String3\"\n\n\nsep = argümanı, eklediğiniz bağımsız değişkenlerin her birinin arasına bir karakter değeri ekler (ör. virgül, boşluk veya yeni satır \"\\n\" ekleme)\n\nstr_c(\"String1\", \"String2\", \"String3\", sep = \", \")\n\n[1] \"String1, String2, String3\"\n\n\ncollapse = argümanı, str_c() argümanıyla birden çok vektör kullanılıldığı durumlarda işe yarar. Çıktının öğelerini ayırmak için kullanılır.\nAşağıdaki örnek, iki vektörün tek bir vektörde (adlar ve soyadlar) birleşimini göstermektedir. Bir başka benzer örnek, yargı yetkileri ve dava sayıları olabilir. Bu örnekte:\n\nsep = değeri ad ve soyad arasını belirler\n\ncollapse = değeri her bir kişiyi bir diğerinden ayırır\n\n\nfirst_names &lt;- c(\"abdul\", \"fahruk\", \"janice\") \nlast_names  &lt;- c(\"hussein\", \"akinleye\", \"okeke\")\n\n# ilgili giriş dizeleri arasını sep belirler, her bir öğenin arasını ise collapse belirler\nstr_c(first_names, last_names, sep = \" \", collapse = \";  \")\n\n[1] \"abdul hussein;  fahruk akinleye;  janice okeke\"\n\n\nNot: İstenilen görüntüleme şekline göre, birleşik dize yazdırırken, yeni satırların düzgün yazdırılması için tüm ifadeyi cat() fonksiyonu içine sarmanız gerekebilir:\n\n# Yeni satırların doğru yazdırılması için ifadenin cat() içine sarılması gerekir\ncat(str_c(first_names, last_names, sep = \" \", collapse = \";\\n\"))\n\nabdul hussein;\nfahruk akinleye;\njanice okeke\n\n\n\n\n\nDinamik dizeler\nBir dizeye dinamik R kodu eklemek için str_glue() fonksiyonunu kullanın. Bu, aşağıda gösterildiği gibi dinamik grafik başlıkları oluşturmak için çok kullanışlı bir fonksiyondur\n\nTüm içerik çift tırnak işaretleri arasında girilir str_glue(\"\")\n\nHerhangi bir dinamik kod veya önceden tanımlanmış değerlere yapılan referanslar, çift tırnak işareti içerisinde {} küme parantezleri içine yerleştirilir. Aynı str_glue() komutunda birçok küme parantezleri olabilir.\n\n\" tırnak işaretini görüntülemek için, çevreleyen çift tırnak içinde tek tırnak kullanılabilir (ör. tarih formatı sağlarken - aşağıdaki örneğe bakın)\n\nİpucu: Satır atlamak için \\ni kullanabilirsiniz\nİpucu: Tarih gösterimini ayarlamak için format() ve geçerli tarihi görüntülemek için Sys.Date() fonksiyonlarını kullanabilirsiniz\n\nDinamik bir grafik başlığının basit bir örneği:\n\nstr_glue(\"Data include {nrow(linelist)} cases and are current to {format(Sys.Date(), '%d %b %Y')}.\")\n\nData include 5888 cases and are current to 10 May 2024.\n\n\nAlternatif bir format, parantez içinde yer tutucuları kullanmak ve kodu, aşağıdaki gibi str_glue() fonksiyonunun sonunda ayrı argümanlarda tanımlamaktır. Bu, metin uzunsa kodun okunabilirliğini artırabilir.\n\nstr_glue(\"Linelist as of {current_date}.\\nLast case hospitalized on {last_hospital}.\\n{n_missing_onset} cases are missing date of onset and not shown\",\n         current_date = format(Sys.Date(), '%d %b %Y'),\n         last_hospital = format(as.Date(max(linelist$date_hospitalisation, na.rm=T)), '%d %b %Y'),\n         n_missing_onset = nrow(linelist %&gt;% filter(is.na(date_onset)))\n         )\n\nLinelist as of 10 May 2024.\nLast case hospitalized on 30 Apr 2015.\n256 cases are missing date of onset and not shown\n\n\nBir veri çerçevesinden dizi alımı\nBazen, bir veri çerçevesinden veri çekmek ve peşpeşe eklemek istenebilir. Aşağıda örnek bir veri çerçevesi bulunmaktadır. Bu veri çerçevesi, yetki alanları; yeni ve toplam dava sayıları hakkında özet bir açıklama yapmak için kullanılabilir.\n\n# vaka veri çerçevesini hazırla\ncase_table &lt;- data.frame(\n  zone        = c(\"Zone 1\", \"Zone 2\", \"Zone 3\", \"Zone 4\", \"Zone 5\"),\n  new_cases   = c(3, 0, 7, 0, 15),\n  total_cases = c(40, 4, 25, 10, 103)\n  )\n\n\n\n\n\n\n\nVeri çerçevesi satırlarından veri almak için özel olarak yapılmış str_glue_data() kullanılır:\n\ncase_table %&gt;% \n  str_glue_data(\"{zone}: {new_cases} ({total_cases} total cases)\")\n\nZone 1: 3 (40 total cases)\nZone 2: 0 (4 total cases)\nZone 3: 7 (25 total cases)\nZone 4: 0 (10 total cases)\nZone 5: 15 (103 total cases)\n\n\nDizeleri satırlarda birleştirme\nBir veri çerçevesi sütunundaki değerleri “birleştirmeye” çalışıyorsanız; örneğin, birden çok satırdaki değerleri bir ayırıcıyla birbirine yapıştırarak tek bir satırda birleştirme, Tekilleştirme sayfasının “toplama” değerleri bölümüne bakabilirsiniz.\nVeri çerçevesini bir satıra çevirme\nstr_c() fonksiyonu (veri çerçevesini ve sütun adlarını da belirterek), sep = ve collapse = argümanlarını kullanarak verilerin tek satırda görünmesini sağlayabilirsiniz.\n\nstr_c(case_table$zone, case_table$new_cases, sep = \" = \", collapse = \";  \")\n\n[1] \"Zone 1 = 3;  Zone 2 = 0;  Zone 3 = 7;  Zone 4 = 0;  Zone 5 = 15\"\n\n\nVerileri ayrı bir str_c() komutu ile sarmalayarak ifadenin başına “New Cases:” ön metnini ekleyebilirsiniz (“New Cases:” orijinal str_c() içindeyse, birden çok kez görünecektir).\n\nstr_c(\"New Cases: \", str_c(case_table$zone, case_table$new_cases, sep = \" = \", collapse = \";  \"))\n\n[1] \"New Cases: Zone 1 = 3;  Zone 2 = 0;  Zone 3 = 7;  Zone 4 = 0;  Zone 5 = 15\"\n\n\n\n\nSütunları birleştirme\nBir veri çerçevesinde, birden çok sütundaki karakter değerlerini bir araya getirmek, tidyr’den unite() fonksiyonu ile gerçekleştirilebilir. Bu, separate()in tam tersidir.\nYeni birleşik sütunun adı girilir. Ardından, birleştirmek istenen sütunların adları girilir.\n\nVarsayılan olarak, birleşik sütunda kullanılan ayırıcı _ alt çizgidir, ancak bu, sep = argümanı ile değiştirilebilir.\nremove = veri çerçevesinden giriş sütunlarını kaldırır (varsayılan olarak TRUE)\nna.rm = birleştirirken eksik değerleri kaldırır (varsayılan olarak FALSE)\n\nAşağıda, göstermek için bir mini veri çerçevesi tanımlanmaktadır:\n\ndf &lt;- data.frame(\n  case_ID = c(1:6),\n  symptoms  = c(\"jaundice, fever, chills\",     # hasta 1\n                \"chills, aches, pains\",        # hasta 2 \n                \"fever\",                       # hasta 3\n                \"vomiting, diarrhoea\",         # hasta 4\n                \"bleeding from gums, fever\",   # hasta 5\n                \"rapid pulse, headache\"),      # hasta 6\n  outcome = c(\"Recover\", \"Death\", \"Death\", \"Recover\", \"Recover\", \"Recover\"))\n\n\ndf_split &lt;- separate(df, symptoms, into = c(\"sym_1\", \"sym_2\", \"sym_3\"), extra = \"merge\")\n\nWarning: Expected 3 pieces. Missing pieces filled with `NA` in 2 rows [3, 4].\n\n\nÖrnek bir veri çerçevesi:\n\n\n\n\n\n\nAşağıda, üç semptom sütununu birleştirilmiştir:\n\ndf_split %&gt;% \n  unite(\n    col = \"all_symptoms\",         # yeni birleşik sütunun adı\n    c(\"sym_1\", \"sym_2\", \"sym_3\"), # birleştirilecek için sütunlar\n    sep = \", \",                   # birleşik sütunda kullanılacak ayırıcı\n    remove = TRUE,                # TRUE ise, veri çerçevesinden girdi sütunlarını kaldırır\n    na.rm = TRUE                  # DOĞRU ise, birleştirmeden önce eksik değerler kaldırılır\n  )\n\n  case_ID                all_symptoms outcome\n1       1     jaundice, fever, chills Recover\n2       2        chills, aches, pains   Death\n3       3                       fever   Death\n4       4         vomiting, diarrhoea Recover\n5       5 bleeding, from, gums, fever Recover\n6       6      rapid, pulse, headache Recover\n\n\n\n\n\nAyırma\nBir dizgiyi belli bir paterne göre bölmek için str_split() kullanılabilir. Bu komut dize(ler)i uygun paternde böler ve yeni değerlerden oluşan karakter vektörleri list olarak döndürür.\nAşağıdaki basit örnek, verilen dizeyi değerlendirir ve onu üçe böler. Varsayılan olarak, her dizin her bir bölümü (bir karakter vektörü) list sınıfının bir nesnesine dönüştürülür. Eğer argüman simplify = TRUE ise, sonuç bir karakter matrisi olacaktır.\nBu örnekte, dize fonksiyon ile, listeye dönüştürülür - üç değer içeren bir karakter vektörü.\n\nstr_split(string = \"jaundice, fever, chills\",\n          pattern = \",\")\n\n[[1]]\n[1] \"jaundice\" \" fever\"   \" chills\" \n\n\nÇıktı kaydedilirse, parantez sözdizimi ile n’inci değerine erişebilirsiniz. Belirli bir değere erişmek için the_returned_object[[1]][2] argümanı kullanılır. Bu fonksiyonla listedeki (“fever”) ikinci değere erişir. Değerlere erişim hakkında daha fazla ayrıntı için [R temelleri] sayfasına bakabilirsiniz.\n\npt1_symptoms &lt;- str_split(\"jaundice, fever, chills\", \",\")\n\npt1_symptoms[[1]][2]  # listeden 2. değeri çıkarır\n\n[1] \" fever\"\n\n\nstr_split() fonksiyonuyla listede birden fazla karakter dizisi mevcutsa, döndürülen listede de birden fazla eleman olacaktır.\n\nsymptoms &lt;- c(\"jaundice, fever, chills\",     # hasta 1\n              \"chills, aches, pains\",        # hasta 2 \n              \"fever\",                       # hasta 3\n              \"vomiting, diarrhoea\",         # hasta 4\n              \"bleeding from gums, fever\",   # hasta 5\n              \"rapid pulse, headache\")       # hasta 6\n\nstr_split(symptoms, \",\")                     # her hastanın semptomlarını ayırır\n\n[[1]]\n[1] \"jaundice\" \" fever\"   \" chills\" \n\n[[2]]\n[1] \"chills\" \" aches\" \" pains\"\n\n[[3]]\n[1] \"fever\"\n\n[[4]]\n[1] \"vomiting\"   \" diarrhoea\"\n\n[[5]]\n[1] \"bleeding from gums\" \" fever\"            \n\n[[6]]\n[1] \"rapid pulse\" \" headache\"  \n\n\nVeri çerçevesi sütununa dönüştürebileceğiniz bir “karakter matrisi” çıktısını almak için, simplify = TRUE bağımsız değişkenini aşağıda gösterildiği gibi ayarlamalısınız:\n\nstr_split(symptoms, \",\", simplify = TRUE)\n\n     [,1]                 [,2]         [,3]     \n[1,] \"jaundice\"           \" fever\"     \" chills\"\n[2,] \"chills\"             \" aches\"     \" pains\" \n[3,] \"fever\"              \"\"           \"\"       \n[4,] \"vomiting\"           \" diarrhoea\" \"\"       \n[5,] \"bleeding from gums\" \" fever\"     \"\"       \n[6,] \"rapid pulse\"        \" headache\"  \"\"       \n\n\nAyrıca n = argümanıyla oluşturulacak bölmelerin sayısını da ayarlayabilirsiniz. Aşağıdaki örnekte bölme sayısı 2 ile sınırlandırılmıştır. Diğer virgül ve dizeler ikinci değer içinde kalır.\n\nstr_split(symptoms, \",\", simplify = TRUE, n = 2)\n\n     [,1]                 [,2]            \n[1,] \"jaundice\"           \" fever, chills\"\n[2,] \"chills\"             \" aches, pains\" \n[3,] \"fever\"              \"\"              \n[4,] \"vomiting\"           \" diarrhoea\"    \n[5,] \"bleeding from gums\" \" fever\"        \n[6,] \"rapid pulse\"        \" headache\"     \n\n\nNot - aynı çıktıları, “simplify” argümanını kullanmadığınız, bunun yerine sütun sayısını (n) belirtmeniz gereken str_split_fixed() fonksiyonu ile de elde edilebilirsiniz.\n\nstr_split_fixed(symptoms, \",\", n = 2)\n\n\n\nSütunları ayırma\nVeri çerçevesine ait bir sütunu bölmeye çalışıyorsanız, dplyr paketinden separate() fonksiyonu en iyi seçenektir. Bu fonksiyon var olan bir karakter sütununu diğer sütunlara bölmek için kullanılır.\nDiyelim ki bir case_ID sütunu, birçok semptom içeren bir karakter sütunu ve bir sonuç sütunu içeren basit bir “df” (Sütunları birleştirme bölümünde içinde tanımlanmış ve birleştirilmiş) veri çerçevemiz var. Bu örnekte amacımız, semptomlar sütununu her biri bir semptom içeren birçok sütuna ayırmaktır.\n\n\n\n\n\n\nVerileri separate() fonksiyonuna aktarıldığını varsayarsak, önce ayrılacak sütunu fonksiyona tanımlamalısınız. Ardından, aşağıda gösterildiği gibi yeni sütun adlarını içeren bir c( ) vektörünü olarak into = argümanına aktarabilirsiniz.\n\nsep = ayırıcı, bir karakter veya bir sayı olabilir (bölünecek karakter konumu olarak yorumlanır)\nremove = Varsayılan olarak FALSE, giriş sütununu kaldırır\n\nconvert = Varsayılan olarak FALSE, “NA” dizelerinin “NA” (eksik veri) formatına dönüştürür\nextra = bu, ayırılan yeni sütunlarda daha fazla değer varsa bunların ne olacağını kontrol eder.\n\nextra = \"warn\" sizi uyarır, ancak aşırı değerlerin kaybolacağı anlamına gelir (the default)\n\nextra = \"drop\" aşırı değerlerin uyarı yapılmadan kaybolacağı anlamına gelir\nextra = \"merge\" yalnızca “into” argümanında tanımlanan sütun sayısına bölünür - bu ayar tüm verilerinizi korur\n\n\nAşağıda extra = \"merge\" içeren bir örnek verilmiştir - burada hiçbir veri kaybolmaz. İki yeni sütun tanımlanır, ancak ikinci yeni sütunda üçüncü semptomlar kalmaya devam eder:\n\n# ikinci ve üçüncü semptomlar ikinci sütunda birleştirildi\ndf %&gt;% \n  separate(symptoms, into = c(\"sym_1\", \"sym_2\"), sep=\",\", extra = \"merge\")\n\nWarning: Expected 2 pieces. Missing pieces filled with `NA` in 1 rows [3].\n\n\n  case_ID              sym_1          sym_2 outcome\n1       1           jaundice  fever, chills Recover\n2       2             chills   aches, pains   Death\n3       3              fever           &lt;NA&gt;   Death\n4       4           vomiting      diarrhoea Recover\n5       5 bleeding from gums          fever Recover\n6       6        rapid pulse       headache Recover\n\n\nAşağıda varsayılan extra = \"drop\" kullanıldığında sistem bir uyarı verir ancak üçüncü semptomlar kaybolur:\n\n# üçüncü semptomlar kaybolur\ndf %&gt;% \n  separate(symptoms, into = c(\"sym_1\", \"sym_2\"), sep=\",\")\n\nWarning: Expected 2 pieces. Additional pieces discarded in 2 rows [1, 2].\n\n\nWarning: Expected 2 pieces. Missing pieces filled with `NA` in 1 rows [3].\n\n\n  case_ID              sym_1      sym_2 outcome\n1       1           jaundice      fever Recover\n2       2             chills      aches   Death\n3       3              fever       &lt;NA&gt;   Death\n4       4           vomiting  diarrhoea Recover\n5       5 bleeding from gums      fever Recover\n6       6        rapid pulse   headache Recover\n\n\nDİKKAT: Yeni sütunlar için yeterli into değeri sağlamazsanız verileriniz kaybolabilir.\n\n\n\nAlfabetik olarak düzenle\nBirkaç dize alfabetik sıraya göre sıralanabilir. str_order() dizelerin alfabetik olarak sırasını verirken, str_sort() dizeleri alfabetik olarak sıralar.\n\n# dizeler\nhealth_zones &lt;- c(\"Alba\", \"Takota\", \"Delta\")\n\n# alfabetik sırasını döndürür\nstr_order(health_zones)\n\n[1] 1 3 2\n\n# dizeleri alfabetik olarak sıralar\nstr_sort(health_zones)\n\n[1] \"Alba\"   \"Delta\"  \"Takota\"\n\n\nFarklı bir alfabe kullanmak için locale = argümanını ekleyebilirsiniz. R konsoluna stringi::stri_locale_list() girerek yerel ayarların tam listesine bakabınız.\n\n\n\nR tabanı fonksiyonları\nTüm parçaları karaktere dönüştürdükten sonra vektörleri birleştiren R tabanındaki paste() ve paste0() fonksiyonları yaygın bir şekilde kullanılmaktadır. Bunlar str_c() fonksiyonuna benzer şekilde hareket ederler, ancak sözdizimi daha karmaşıktır - parantez içinde her bölüm bir virgülle ayrılır. Parçalar ya karakter metnidir (tırnak içinde) ya da önceden tanımlanmış kod nesneleridir (tırnak işaretleri olmadan). Örnek olarak:\n\nn_beds &lt;- 10\nn_masks &lt;- 20\n\npaste0(\"Regional hospital needs \", n_beds, \" beds and \", n_masks, \" masks.\")\n\n[1] \"Regional hospital needs 10 beds and 20 masks.\"\n\n\nsep = ve collapse = argümanları özelleştirilebilir. paste0() basitçe paste() fonksiyonunun sep = \" \" (bir boşluk) argümanlı halidir.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Karakterler ve dizeler</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.tr.html#temizleme-ve-standartlaştırma",
    "href": "new_pages/characters_strings.tr.html#temizleme-ve-standartlaştırma",
    "title": "10  Karakterler ve dizeler",
    "section": "10.3 Temizleme ve standartlaştırma",
    "text": "10.3 Temizleme ve standartlaştırma\n\n\nKarakterleri değiştirme\nÇoğu zaman, bir dize değerinin büyük/küçük harf kullanımı değiştirilmelidir, örneğin şehir adları. Aşağıda stringr paketinden str_to_upper(), str_to_lower() ve str_to_title() fonksiyonlarına ait örnekler verilmiştir:\n\nstr_to_upper(\"California\")\n\n[1] \"CALIFORNIA\"\n\nstr_to_lower(\"California\")\n\n[1] \"california\"\n\n\nYukarıdaki örnekler R tabanındaki toupper(), tolower() fonksiyonlarıyla da yapılabilir.\nİlk karakter\nHer kelimenin ilk harfini büyütmek için str_to_title() fonksiyonu kullanılır:\n\nstr_to_title(\"go to the US state of california \")\n\n[1] \"Go To The Us State Of California \"\n\n\nDaha hassas bir büyük harf kullanımı elde etmek için tools paketinden toTitleCase() fonksiyonunu kullanabilirsiniz (“to”, “the” ve “of” gibi sözcükler büyük harfle yazılmaz).\n\ntools::toTitleCase(\"This is the US state of california\")\n\n[1] \"This is the US State of California\"\n\n\nAyrıca cümlenin yalnızca ilk harfini büyük harf yapan str_to_sentence() kullanabilirsiniz.\n\nstr_to_sentence(\"the patient must be transported\")\n\n[1] \"The patient must be transported\"\n\n\n\n\nKarakter uzunluğu\nBir dizeye minimum uzunlukta karakter eklemek için str_pad() fonksiyonunu kullanabilirsiniz. Varsayılan olarak boşluklar eklenir, ancak pad = argümanını kullanarak diğer karakterlerle de doldurabilirsiniz.\n\n# Farklı uzunluktaki ICD kodları\nICD_codes &lt;- c(\"R10.13\",\n               \"R10.819\",\n               \"R17\")\n\n# Sağ tarafta 7 karaktere kadar doldurulmuş ICD kodları\nstr_pad(ICD_codes, 7, \"right\")\n\n[1] \"R10.13 \" \"R10.819\" \"R17    \"\n\n# Boşluk yerine nokta içeren karakter alanı\nstr_pad(ICD_codes, 7, \"right\", pad = \".\")\n\n[1] \"R10.13.\" \"R10.819\" \"R17....\"\n\n\nÖrneğin, sayıların başını sıfırlarla doldurmak için (saat veya dakika gibi), sayıyı pad = \"0\" ile minimum 2 uzunluğa kadar doldurabilirsiniz.\n\n# İki basamağın başına sıfır ekle (ör. dakika/saat zamanları için)\nstr_pad(\"4\", 2, pad = \"0\") \n\n[1] \"04\"\n\n\n\n# \"saat\" adlı sayısal bir sütun kullanan örnek\nhours &lt;- str_pad(hours, 2, pad = \"0\")\n\n\n\nKesme\nstr_trunc() her dize için bir maksimum bir uzunluk belirler. Bir dize bu uzunluğu aşarsa, kısaltılır (kısaltılır) ve dizenin öncesinde daha uzun olduğunu belirtmek için bir üç nokta (…) eklenir. Üç noktanın uzunluk olarak sayıldığına dikkat etmelisiniz. Üç nokta karakterleri ellipsis = argümanı ile değiştirilebilir. İsteğe bağlı side = argümanı, üç noktanın kesilen dize (“sol”, “sağ” veya “merkez”) içinde nerede görüneceğini belirtir.\n\noriginal &lt;- \"Symptom onset on 4/3/2020 with vomiting\"\nstr_trunc(original, 10, \"center\")\n\n[1] \"Symp...ing\"\n\n\n\n\nStandart uzunluk\nStandart uzunluğu belirlemek için str_trunc() fonksiyonunu kullanabilirsiniz. Standart uzunluğa göre kısa olan dizeleri genişletmek için str_pad() fonksiyonu kullanılır. Aşağıdaki örnekte, maksimum uzunluk olarak 6 ayarlanmıştır. Burada daha uzun değerler kesilir ve kısa olan değerler genişler.\n\n# Farklı uzunluktaki ICD kodları\nICD_codes   &lt;- c(\"R10.13\",\n                 \"R10.819\",\n                 \"R17\")\n\n# en fazla 6 karakterle sınırla\nICD_codes_2 &lt;- str_trunc(ICD_codes, 6)\nICD_codes_2\n\n[1] \"R10.13\" \"R10...\" \"R17\"   \n\n# en az 6 karakter uzunluğunda tut\nICD_codes_3 &lt;- str_pad(ICD_codes_2, 6, \"right\")\nICD_codes_3\n\n[1] \"R10.13\" \"R10...\" \"R17   \"\n\n\n\n\nBaştaki/sondaki boşlukları kaldırma\nBir dize girişinin kenarlarındaki boşlukları, yeni satırları (\\n) veya sekmeleri (\\t) kaldırmak için str_trim() kullanın. Hangi tarafın kırpılacağını belirtmek için komuta \"sağ\" \"sol\" veya \"her ikisi\" ekleyin (ör. str_trim(x, \"sağ\")).\n\n# Sağda fazla boşluk bulunan kimlik numaraları\nIDs &lt;- c(\"provA_1852  \", # iki fazla boşluk\n         \"provA_2345\",   # fazla boşluk yok\n         \"provA_9460 \")  # bir fazla boşluk\n\n# Kimlik numaraların yalnızca sağ taraftaki fazla boşlukları kaldırılır\nstr_trim(IDs)\n\n[1] \"provA_1852\" \"provA_2345\" \"provA_9460\"\n\n\n\n\nTekrarlanan boşlukları kaldırma\nBir dizenin içindeki yinelenen boşlukları kaldırmak için str_squish() fonksiyonunu kullanabilirsiniz. Örneğin, çift boşlukları tek boşluklara dönüştürmek için. Ayrıca str_trim() fonksiyonu gibi dizenin dışındaki boşlukları, yeni satırları veya sekmeleri de kaldırır.\n\n# orijinal, dize içinde fazla boşluk içeriyor\nstr_squish(\"  Pt requires   IV saline\\n\") \n\n[1] \"Pt requires IV saline\"\n\n\nDaha fazla ayrıntı görmek için R konsolunuza ?str_trim, ?str_pad komutunu giriniz.\n\n\nParagrafa sığdırma\nUzun bir yapılandırılmamış metni sabit satır uzunluğuna sahip yapılandırılmış bir paragrafa sığdırmak için str_wrap() fonksiyonunu kullanabilirsiniz. Her satır için ideal karakter uzunluğunu tanımladığınızda, fonksiyon, aşağıdaki örnekte görüldüğü gibi paragraf içine yeni satırlar (\\n) eklemek için bir algoritma uygular.\n\npt_course &lt;- \"Symptom onset 1/4/2020 vomiting chills fever. Pt saw traditional healer in home village on 2/4/2020. On 5/4/2020 pt symptoms worsened and was admitted to Lumta clinic. Sample was taken and pt was transported to regional hospital on 6/4/2020. Pt died at regional hospital on 7/4/2020.\"\n\nstr_wrap(pt_course, 40)\n\n[1] \"Symptom onset 1/4/2020 vomiting chills\\nfever. Pt saw traditional healer in\\nhome village on 2/4/2020. On 5/4/2020\\npt symptoms worsened and was admitted\\nto Lumta clinic. Sample was taken and pt\\nwas transported to regional hospital on\\n6/4/2020. Pt died at regional hospital\\non 7/4/2020.\"\n\n\nR tabanındaki cat() fonksiyonu ile yapılandırılmış bu yeni paragrafın çıktısı alınabilir.\n\ncat(str_wrap(pt_course, 40))\n\nSymptom onset 1/4/2020 vomiting chills\nfever. Pt saw traditional healer in\nhome village on 2/4/2020. On 5/4/2020\npt symptoms worsened and was admitted\nto Lumta clinic. Sample was taken and pt\nwas transported to regional hospital on\n6/4/2020. Pt died at regional hospital\non 7/4/2020.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Karakterler ve dizeler</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.tr.html#pozisyona-göre-düzenleme",
    "href": "new_pages/characters_strings.tr.html#pozisyona-göre-düzenleme",
    "title": "10  Karakterler ve dizeler",
    "section": "10.4 Pozisyona göre düzenleme",
    "text": "10.4 Pozisyona göre düzenleme\n\nKarakter pozisyonuna göre çıkarma\nBir dizenin yalnızca bir kısmını döndürmek için str_sub() kullanın. Fonksiyon üç ana argüman alır:\n\nkarakter vektör(leri)\n\nbaşlangıç pozisyonu\nbitiş pozisyonu\n\nPozisyon değeri hakkında bir kaç:\n\nBir pozisyon değeri pozitifse, pozisyon dizenin sol ucundan başlayarak sayılır.\n\nBir pozisyon değeri negatifse, pozisyon dizenin sağ ucundan başlayarak sayılır.\nPozisyon numaraları dahildir.\n\nDizinin ötesine uzanan konumlar kesilir (kaldırılır).\n\nAşağıda “pneumonia” dizesine uygulanan bazı örnekler verilmiştir.:\n\n# soldan üçüncü başlar ve biter (soldan üçüncü harf)\nstr_sub(\"pneumonia\", 3, 3)\n\n[1] \"e\"\n\n# 0 mevcut değil\nstr_sub(\"pneumonia\", 0, 0)\n\n[1] \"\"\n\n# soldan 6., sağdan 1. arasındaki\nstr_sub(\"pneumonia\", 6, -1)\n\n[1] \"onia\"\n\n# Sağdan 5., sağdan 2. arasındaki\nstr_sub(\"pneumonia\", -5, -2)\n\n[1] \"moni\"\n\n# 4. soldan dizenin dışındaki bir pozisyona\nstr_sub(\"pneumonia\", 4, 15)\n\n[1] \"umonia\"\n\n\n\n\nKelime pozisyonuna göre çıkarma\nn’inci ’kelime’yi çıkarmak için, yine stringr paketinden word() fonksiyonunu kullanabilirsiniz. Fonksiyonu kullanabilmek için dizeyi, ardından ayıklanacak ilk sözcük konumunu ve ayıklanacak son sözcük konumunu tanımlamanız gerekmektedir.\nVarsayılan olarak, sep = ile aksi belirtilmedikçe ‘kelimeler’ arasındaki ayırıcının bir boşluk olduğu varsayılır (örneğin, kelimeler alt çizgilerle ayrıldığında sep = \"_\".\n\n# dizeleri değerlendirme\nchief_complaints &lt;- c(\"I just got out of the hospital 2 days ago, but still can barely breathe.\",\n                      \"My stomach hurts\",\n                      \"Severe ear pain\")\n\n# her dizenin 1. ila 3. kelimelerin arasını ayır\nword(chief_complaints, start = 1, end = 3, sep = \" \")\n\n[1] \"I just got\"       \"My stomach hurts\" \"Severe ear pain\" \n\n\n\n\nKarakteri pozisyonuna göre değiştirme\nAtama operatörüyle (&lt;-) eşleştirilen str_sub() fonksiyonu, bir dizenin bir bölümünü değiştirmek için kullanılabilir:\n\nword &lt;- \"pneumonia\"\n\n# üçüncü ve dördüncü karakterleri X'e dönüştür\nstr_sub(word, 3, 4) &lt;- \"XX\"\n\n# print\nword\n\n[1] \"pnXXmonia\"\n\n\nBirden çok dizeye uygulanan bir örnek (örneğin bir sütun). “HIV” uzunluğundaki genişlemeye dikkat edin.\n\nwords &lt;- c(\"pneumonia\", \"tubercolosis\", \"HIV\")\n\n# üçüncü ve dördüncü karakterleri X'e dönüştür\nstr_sub(words, 3, 4) &lt;- \"XX\"\n\nwords\n\n[1] \"pnXXmonia\"    \"tuXXrcolosis\" \"HIXX\"        \n\n\n\n\nUzunluğu değerlendirme\n\nstr_length(\"abc\")\n\n[1] 3\n\n\nAlternatif olarak, R tabanından nchar() fonksiyonu kullanabilirsiniz.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Karakterler ve dizeler</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.tr.html#paternler",
    "href": "new_pages/characters_strings.tr.html#paternler",
    "title": "10  Karakterler ve dizeler",
    "section": "10.5 Paternler",
    "text": "10.5 Paternler\nBirçok stringr fonksiyonu, belirli bir paterne göre algılamak, bulmak, ayıklamak, eşleştirmek, değiştirmek ve bölmek için kullanılabilir.\n\n\nPatern bulma\nBir dize içindeki bir kalıbın varlığını/yokluğunu algılamak için aşağıdaki gibi str_detect() fonksiyonunu kullanabilirsiniz. Önce aranacak dizeyi veya vektörü (string =) ve sonra aranacak modeli (pattern =) belirlemeniz gerekmektedir. Varsayılan olarak aramanın büyük/küçük harf duyarlı olduğunu unutmayın!\n\nstr_detect(string = \"primary school teacher\", pattern = \"teach\")\n\n[1] TRUE\n\n\nDesenin mevcut olup olmadığını bilmek istiyorsanız, negate = argümanı eklenebilir ve TRUE olarak ayarlanabilir.\n\nstr_detect(string = \"primary school teacher\", pattern = \"teach\", negate = TRUE)\n\n[1] FALSE\n\n\nBüyük/küçük harf kullanımını yok saymak için, kalıbı regex() içine sarın ve regex() komutu içinde, ignore_case = TRUE (veya T) argümanını ekleyin.\n\nstr_detect(string = \"Teacher\", pattern = regex(\"teach\", ignore_case = T))\n\n[1] TRUE\n\n\nBir karakter vektörüne veya bir veri çerçevesi sütununa str_detect() uygulandığında, değerlerin her biri için DOĞRU veya YANLIŞ sonucunu döndürür.\n\n# bir meslek vektörü/sütunu \noccupations &lt;- c(\"field laborer\",\n                 \"university professor\",\n                 \"primary school teacher & tutor\",\n                 \"tutor\",\n                 \"nurse at regional hospital\",\n                 \"lineworker at Amberdeen Fish Factory\",\n                 \"physican\",\n                 \"cardiologist\",\n                 \"office worker\",\n                 \"food service\")\n\n# Her dizede \"teach\" kalıbının varlığını tespit et - çıktı DOĞRU/YANLIŞ vektörüdür\nstr_detect(occupations, \"teach\")\n\n [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\n“DOĞRU”ları saymanız gerekiyorsa, çıktıyı sum() fonksiyonu içine almanız yeterlidir. Bu, “DOĞRU” çıktıların sayısını verir.\n\nsum(str_detect(occupations, \"teach\"))\n\n[1] 1\n\n\nBirden çok terimi aramak için, bunları aşağıda gösterildiği gibi ‘pattern =’ bağımsız değişkenine VEYA çubukları (|) ile ayırarak ekleyin:\n\nsum(str_detect(string = occupations, pattern = \"teach|professor|tutor\"))\n\n[1] 3\n\n\nUzun bir arama terimleri listesi oluşturmanız gerekiyorsa, bunları str_c() ve sep = | kullanarak birleştirebilir ardından bunun bir karakter nesnesi olarak tanımlayabilir ve daha sonrasında vektör formatında arayabilirsiniz. Aşağıdaki örnek, birinci basamak sağlık çalışanları için olası meslek arama terimlerini içermektedir.\n\n# search terms\noccupation_med_frontline &lt;- str_c(\"medical\", \"medicine\", \"hcw\", \"healthcare\", \"home care\", \"home health\",\n                                \"surgeon\", \"doctor\", \"doc\", \"physician\", \"surgery\", \"peds\", \"pediatrician\",\n                               \"intensivist\", \"cardiologist\", \"coroner\", \"nurse\", \"nursing\", \"rn\", \"lpn\",\n                               \"cna\", \"pa\", \"physician assistant\", \"mental health\",\n                               \"emergency department technician\", \"resp therapist\", \"respiratory\",\n                                \"phlebotomist\", \"pharmacy\", \"pharmacist\", \"hospital\", \"snf\", \"rehabilitation\",\n                               \"rehab\", \"activity\", \"elderly\", \"subacute\", \"sub acute\",\n                                \"clinic\", \"post acute\", \"therapist\", \"extended care\",\n                                \"dental\", \"dential\", \"dentist\", sep = \"|\")\n\noccupation_med_frontline\n\n[1] \"medical|medicine|hcw|healthcare|home care|home health|surgeon|doctor|doc|physician|surgery|peds|pediatrician|intensivist|cardiologist|coroner|nurse|nursing|rn|lpn|cna|pa|physician assistant|mental health|emergency department technician|resp therapist|respiratory|phlebotomist|pharmacy|pharmacist|hospital|snf|rehabilitation|rehab|activity|elderly|subacute|sub acute|clinic|post acute|therapist|extended care|dental|dential|dentist\"\n\n\nAşağıdaki komut, birinci basamak sağlık çalışanları (occupation_med_frontline) için arama terimlerinden herhangi birini içeren mesleklerin sayısını döndürür:\n\nsum(str_detect(string = occupations, pattern = occupation_med_frontline))\n\n[1] 2\n\n\nR tabanı dizin arama işlevleri\nR tabanı fonksiyonu olan grepl(), str_detect() fonksiyonuna benzer bir şekilde çalışır. Çünkü o da bir modelle eşleşmeleri arar ve mantıksal bir vektör döndürür. Temel sözdizimi grepl(pattern, strings_to_search, ignore.case = FALSE, ...) şeklindedir. Avantajlardan biri, ignore.case argümanını yazmanın daha kolay olmasıdır (regex() fonksiyonunu dahil etmeye gerek yoktur).\nBenzer şekilde, R tabanı fonksiyonları olan sub() ve gsub(), str_replace()a benzer şekilde hareket eder. Temel sözdizimleri şöyledir: gsub(pattern, replace, strings_to_search, ignore.case = FALSE). sub() kalıbın ilk örneğini değiştirirken, gsub() kalıbın tüm örneklerini değiştirir.\n\nVirgülleri noktalara dönüştürme\nBurada, bir sayı vektöründe virgülleri noktalara dönüştürmek için gsub() kullanımına örnek verilmiştir. Bu durum özellikle verileriniz Amerika Birleşik Devletleri veya İngiltere dışındaki ülkelerden geliyorsa faydalı olabilir.\nİlk olarak “lengths” üzerinde etkili olan komutun içindeki gsub() fonksiyonu, herhangi bir noktayı boşluksuz “” değerine dönüştürmektedir (silmektedir). Noktayı doğru tanımlamak için başına iki eğik çizgi “eklenmesi” gerekir çünkü normal “.” ifadesi “herhangi bir karakter” anlamına gelir. Ardından, sonuç (yalnızca virgülle), virgüllerin noktalarla değiştirildiği dış gsub() komutuna iletilir.\n\nlengths &lt;- c(\"2.454,56\", \"1,2\", \"6.096,5\")\n\nas.numeric(gsub(pattern = \",\",                # virgülleri bul     \n                replacement = \".\",            # nokta ile değiştir\n                x = gsub(\"\\\\.\", \"\", lengths)  # binlik değerlerdeki noktaları kaldır\n                )\n           )                                  # çıktıyı sayısal bir değer olarak tanımla\n\n\n\n\nTamamını değiştirme\n“Bul ve değiştir” aracı olarak str_replace_all() kullanabilirsiniz. İlk Önce, string = olarak değerlendirilecek dizeleri, sonra değiştirilecek kalıbı pattern = olarak ve ardından değiştirme değerini replacement = olarak tanımlamanız gerekmektedir. Aşağıdaki örnek, tüm “dead” örneklerini “deceased” ile değiştirmektedir. Bu komuttaki argümanların büyük/küçük harfe duyarlı olduğunu unutmayın.\n\noutcome &lt;- c(\"Karl: dead\",\n            \"Samantha: dead\",\n            \"Marco: not dead\")\n\nstr_replace_all(string = outcome, pattern = \"dead\", replacement = \"deceased\")\n\n[1] \"Karl: deceased\"      \"Samantha: deceased\"  \"Marco: not deceased\"\n\n\nNotlar:\n\nPaternleri NA olarak değiştirmek için str_replace_na() fonksiyonunu kullanın.\n\nstr_replace() fonksiyonu her bir dizedeki sadece ilk paterni değiştirir, diğerlerini değiştirmez.\n\n\n\n\nMantığa göre arama\ncase_when() fonksiyonuyla\nstr_detect() genellikle case_while() içinde kullanılır (dplyr paketinden). occupationsın satır listesindeki bir sütun olduğunu varsayalım. Aşağıda mutate(), case_while() fonksiyonları aracılığıyla koşullu mantığı kullanarak is_educator adında yeni bir sütun oluşturmaktayız. case_while() hakkında daha fazla bilgi edinmek için veri temizleme sayfasına bakabilirsiniz.\n\ndf &lt;- df %&gt;% \n  mutate(is_educator = case_when(\n    # meslek içinde terim arama, büyük/küçük harfe duyarlı değil\n    str_detect(occupations,\n               regex(\"teach|prof|tutor|university\",\n                     ignore_case = TRUE))              ~ \"Educator\",\n    # diğerleri\n    TRUE                                               ~ \"Not an educator\"))\n\nBir hatırlatma olarak, koşullu mantığa dışlama kriterlerini(negate = F) eklemeniz işinizi kolaylaştırabilir:\n\ndf &lt;- df %&gt;% \n  # is_educator yeni sütunundaki değer koşullu mantığa dayalıdır\n  mutate(is_educator = case_when(\n    \n    # Meslek sütununun \"Educator\" olarak atanabilmesi için 2 kriteri karşılaması gerekir:\n    # bir arama terimine sahip olmalı VE herhangi bir dışlama terimi olmamalı\n    \n    # Bir arama terimi içermeli\n    str_detect(occupations,\n               regex(\"teach|prof|tutor|university\", ignore_case = T)) &              \n    \n    # VE bir dışlama terimi İÇERMEMELİDİR\n    str_detect(occupations,\n               regex(\"admin\", ignore_case = T),\n               negate = TRUE                        ~ \"Educator\"\n    \n    # Yukarıdaki kriterlere uymayan tüm satırlar\n    TRUE                                            ~ \"Not an educator\"))\n\n\n\n\nPatern konumunu bulma\nBir paternin ilk konumunu bulmak için str_locate() kullanabilirsiniz. Fonksiyon çıktı olarak bir başlangıç ve bitiş konumu verir.\n\nstr_locate(\"I wish\", \"sh\")\n\n     start end\n[1,]     5   6\n\n\nDiğer str fonksiyonları gibi, her dizede paterni karşılayan bütün örneklerin konumlarını döndürecek bir “_all” versiyonu (str_locate_all()) mevcuttur. Bu fonksiyon bir liste çıktısı verir.\n\nphrases &lt;- c(\"I wish\", \"I hope\", \"he hopes\", \"He hopes\")\n\nstr_locate(phrases, \"h\" )     # paternin *ilk* örneğinin konumu\n\n     start end\n[1,]     6   6\n[2,]     3   3\n[3,]     1   1\n[4,]     4   4\n\nstr_locate_all(phrases, \"h\" ) # paternin *her* örneğinin konumu\n\n[[1]]\n     start end\n[1,]     6   6\n\n[[2]]\n     start end\n[1,]     3   3\n\n[[3]]\n     start end\n[1,]     1   1\n[2,]     4   4\n\n[[4]]\n     start end\n[1,]     4   4\n\n\n\n\n\nEşleşeni çıkarma\nstr_extract_all() eşleşen kalıpların kendisini döndürür; bu fonksiyon, “VEYA” koşulları aracılığıyla birkaç kalıp önerdiğinizde en kullanışlı seçenektir. Örnek olarak, “teach”, “prof” veya “tutor” paternleri için meslekler vektörünü (önceki sekmeye bakın) inceleyebilirsiniz.\nstr_extract_all(), değerlendirilen her dize için tüm eşleşmeleri içeren bir “liste” döndürür. Aşağıda, meslek vektörü içinde 3 paternin nasıl eşleştiğini görebilirsiniz.\n\nstr_extract_all(occupations, \"teach|prof|tutor\")\n\n[[1]]\ncharacter(0)\n\n[[2]]\n[1] \"prof\"\n\n[[3]]\n[1] \"teach\" \"tutor\"\n\n[[4]]\n[1] \"tutor\"\n\n[[5]]\ncharacter(0)\n\n[[6]]\ncharacter(0)\n\n[[7]]\ncharacter(0)\n\n[[8]]\ncharacter(0)\n\n[[9]]\ncharacter(0)\n\n[[10]]\ncharacter(0)\n\n\nstr_extract(), değerlendirilen her dizede yalnızca ilk eşleşmeyi ortaya çıkararak, değerlendirilen her dize için bir elemanlı bir karakter vektörü üretir. Eşleşmenin olmadığı yerde NA sonucunu döndürür. NAlar, döndürülen vektör na.exclude() fonksiyonu ile sarılarak kaldırılabilir. Çıkan sonuçta ikincisinin nasıl gösterilmediğine dikkat ediniz.\n\nstr_extract(occupations, \"teach|prof|tutor\")\n\n [1] NA      \"prof\"  \"teach\" \"tutor\" NA      NA      NA      NA      NA     \n[10] NA     \n\n\n\n\n\nAlt küme ve sayı\nBu başlıktaki fonksiyonlar arasında str_subset() ve str_count() bulunmaktadır.\nstr_subset() fonksiyonu paterni içeren gerçek değerleri döndürür:\n\nstr_subset(occupations, \"teach|prof|tutor\")\n\n[1] \"university professor\"           \"primary school teacher & tutor\"\n[3] \"tutor\"                         \n\n\nstr_count() bir sayı vektörü döndürür: Değerlendirilen her değerde bir arama teriminin göründüğü miktar.\n\nstr_count(occupations, regex(\"teach|prof|tutor\", ignore_case = TRUE))\n\n [1] 0 1 2 1 0 0 0 0 0 0\n\n\n\n\n\nRegex grupları\nHAZIRLANIYOR",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Karakterler ve dizeler</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.tr.html#özel-karakterler",
    "href": "new_pages/characters_strings.tr.html#özel-karakterler",
    "title": "10  Karakterler ve dizeler",
    "section": "10.6 Özel karakterler",
    "text": "10.6 Özel karakterler\nTers eğik çizgi \\\nTers eğik çizgi \\ sonrasındaki karakteri “yok saymak” için kullanılır. Bu şekilde, diğer tırnak işaretleri (\\\") içinde olan bir alıntı işaretini görüntülemek için bir ters eğik çizgi kullanılabilir - ortadaki alıntı işareti, çevreleyen alıntı işaretlerini “iptal etmez”.\nNot - bu nedenle, bir ters eğik çizgi görüntülemek istiyorsanız için iki ters eğik çizgi \\\\ yazmalısınız.\nÖzel Karakterler\n\n\n\n\n\n\n\nÖzel Karakter\nAnlamı\n\n\n\n\n\"\\\\\"\nters eğik çizgi\n\n\n\"\\n\"\nyeni satır\n\n\n\"\\\"\"\nçift tırnak içinde çift tırnak\n\n\n'\\''\ntek tırnak içinde tek tırnak\n\n\n\"\\“| şapka işareti”| satır başı“| sekme”| dikey sekme“`\ngeri alma\n\n\n\nBu özel karakterlerin tam listesini görüntülemek için R Konsolunda ?\"'\" komutunu çalıştırabilirsiniz (RStudio Yardım bölmesinde görünecektir).",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Karakterler ve dizeler</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.tr.html#düzenli-ifadeler-regex",
    "href": "new_pages/characters_strings.tr.html#düzenli-ifadeler-regex",
    "title": "10  Karakterler ve dizeler",
    "section": "10.7 Düzenli ifadeler (regex)",
    "text": "10.7 Düzenli ifadeler (regex)",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Karakterler ve dizeler</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.tr.html#regex-ve-özel-karakterler",
    "href": "new_pages/characters_strings.tr.html#regex-ve-özel-karakterler",
    "title": "10  Karakterler ve dizeler",
    "section": "10.8 Regex ve özel karakterler",
    "text": "10.8 Regex ve özel karakterler\nDüzenli ifadeler veya “regex”, dizelerdeki kalıpları açıklamak için kısa bir dildir. Eğer aşina değilseniz, düzenli ifadeler yabancı bir dil gibi görünebilir. Burada bu dili biraz gizeminden arındırmaya çalışacağız.\nBölümün çocuğu bu rehberden alınmıştır and this cheatsheet. Bu el kitabının internet erişimi olmayan kişiler tarafından da görüntülenebileceğini ön görülerek burada önemli olanları paylaşıyoruz.\n“Yapılandırılmamış” metinden belirli kalıplarını çıkarmak için genellikle düzenli bir ifade uygulanır - örneğin tıbbi notlar, hasta şikayetleri, geçmişi veya bir veri çerçevesindeki diğer serbest metin sütunları.\nTemel bir düzenli ifade oluşturmak için kullanılabilecek dört araç vardır:\n\nKarakter setleri\n\nMeta karakterler\n\nNiceleyiciler\n\nGrouplar\n\nKarakter setleri\nKarakter setleri, bir karakter eşleşmesi için köşeli parantez içinde listeleme seçeneklerini ifade etmenin bir yoludur. Bu nedenle, köşeli parantez içindeki karakterlerden herhangi biri dizede bulunursa eşleşme tetiklenir. Örneğin, sesli harfleri aramak için şu karakter seti kullanılabilir: “[aeiou]”. Diğer bazı yaygın karakter setleri şunlardır:\n\n\n\n\n\n\n\nKarakter Seti\nAnlamı\n\n\n\n\n\"[A-Z]\"\nherhangi bir tek büyük harf\n\n\n\"[a-z]\"\nherhangi bir tek küçük harf\n\n\n\"[0-9]\"\nherhangi bir rakam\n\n\n[:alnum:]\nherhangi bir alfanümerik karakter\n\n\n[:digit:]\nherhangi bir sayısal rakam\n\n\n[:alpha:]\nherhangi bir harf (büyük veya küçük harf)\n\n\n[:upper:]\nherhangi bir büyük harf\n\n\n[:lower:]\nherhangi bir küçük harf\n\n\n\nKarakter setleri, \"[A-Za-z]\" (herhangi bir büyük veya küçük harf) veya başka bir örnek \"[t-z0-5]\" gibi tek bir parantez içinde (boşluksuz!) birleştirilebilir ( t’den z’ye kadar küçük harf VEYA 0’dan 5’e kadar sayılar).\nMeta karakterler\nMeta karakterler, karakter setlerinin kısaltmasıdır. Önemli olanlardan bazıları aşağıda listelenmiştir:\n\n\n\n\n\n\n\nMeta karakter\nAnlamı\n\n\n\n\n\"\\\\s\"\ntek bir boşluk\n\n\n\"\\\\w\"\nherhangi bir tek alfanümerik karakter (A-Z, a-z, or 0-9)\n\n\n\"\\\\d\"\nherhangi bir tek sayısal rakam (0-9)\n\n\n\nNiceleyiciler\nGenellikle tek bir karakterde eşleşme aramak istemezsiniz. Niceleyiciler, eşleşmeye izin vermek için harflerin/sayıların uzunluğunu belirlemenize olanak tanır.\nNiceleyiciler, nicelleştirdikleri karakterin sonrasında olan { } küme parantezleri içinde yazılan sayılardır, örneğin,\n\n\"A{2}\" iki büyük A harfinin örneklerini döndürür.\n\n\"A{2,4}\" iki ile dört arasında büyük A harfi (boşluk koymayın!) örneklerini döndürür.\n\"A{2,}\" iki veya daha fazla büyük A harfinin örneklerini döndürür.\n\"A+\" bir veya daha fazla büyük A harfinin örneklerini döndürür (farklı bir karakterle karşılaşılıncaya kadar uzatılan grup).\n\nSıfır veya daha fazla eşleşme döndürmek için bir * yıldız işareti ile başlayın (paternin mevcut olduğundan emin değilseniz kullanışlıdır)\n\nNicelik belirteci olarak ‘+’ artı sembolü kullanıldığında, farklı bir karakterle karşılaşılıncaya kadar eşleşme gerçekleşir. Örneğin, bu ifade tüm kelimeleri (alfa karakterleri: \"[A-Za-z]+\") döndürür.\n\n# niceleyiciler için test dizisi\ntest &lt;- \"A-AA-AAA-AAAA\"\n\n{2} niceleyicisi kullanıldığında, yalnızca ardışık A çiftleri döndürülür. “AAAA” içinde iki çift tanımlanmıştır.\n\nstr_extract_all(test, \"A{2}\")\n\n[[1]]\n[1] \"AA\" \"AA\" \"AA\" \"AA\"\n\n\n{2,4} niceleyicisi kullanıldığında, uzunluğu iki ila dört olan ardışık A grupları döndürülebilir.\n\nstr_extract_all(test, \"A{2,4}\")\n\n[[1]]\n[1] \"AA\"   \"AAA\"  \"AAAA\"\n\n\n“+” niceleyicisiyle, bir veya daha fazla gruplar döndürülebilir:\n\nstr_extract_all(test, \"A+\")\n\n[[1]]\n[1] \"A\"    \"AA\"   \"AAA\"  \"AAAA\"\n\n\nRelatif pozisyon\nRelatif pozisyon, bir kalıptan önce gelen veya onu izleyen bir kalıba göre konumu ifade eder. Örneğin, cümleleri çıkarmak için “sonunda bir nokta bulunan iki sayı” (\"\"). (?&lt;=\\.)\\s(?=[A-Z])\n\nstr_extract_all(test, \"\")\n\n[[1]]\n [1] \"A\" \"-\" \"A\" \"A\" \"-\" \"A\" \"A\" \"A\" \"-\" \"A\" \"A\" \"A\" \"A\"\n\n\n\n\n\n\n\n\n\nPozisyon Tanımı\nAnlamı\n\n\n\n\n\"(?&lt;=b)a\"\nöncesinde bir “b” bulunan “a”\n\n\n\"(?&lt;!b)a\"\nÖncesinde  bir “b” olmayan “a”\n\n\n\"a(?=b)\"\nardından bir “b” gelen “a”\n\n\n\"a(?!b)\"\nardından bir “b” gelmeyen “a”\n\n\n\nGruplar\nDüzenli ifadelerinizde grupları yakalamak, çıkarma işlemi sonrasında daha organize bir çıktı elde etmenin bir yoludur.\nRegex örnekleri\nAşağıda örnekler için serbest bir metin bulunmaktadır. Bir düzenli ifade arama terimi kullanarak ondan faydalı bilgiler çıkarmaya çalışacağız.\n\npt_note &lt;- \"Patient arrived at Broward Hospital emergency ward at 18:00 on 6/12/2005. Patient presented with radiating abdominal pain from LR quadrant. Patient skin was pale, cool, and clammy. Patient temperature was 99.8 degrees farinheit. Patient pulse rate was 100 bpm and thready. Respiratory rate was 29 per minute.\"\n\nBu ifade tüm kelimelerle (boşluk gibi karakter olmayan bir karaktere ulaşana kadar herhangi bir karakter) eşleşir:\n\nstr_extract_all(pt_note, \"[A-Za-z]+\")\n\n[[1]]\n [1] \"Patient\"     \"arrived\"     \"at\"          \"Broward\"     \"Hospital\"   \n [6] \"emergency\"   \"ward\"        \"at\"          \"on\"          \"Patient\"    \n[11] \"presented\"   \"with\"        \"radiating\"   \"abdominal\"   \"pain\"       \n[16] \"from\"        \"LR\"          \"quadrant\"    \"Patient\"     \"skin\"       \n[21] \"was\"         \"pale\"        \"cool\"        \"and\"         \"clammy\"     \n[26] \"Patient\"     \"temperature\" \"was\"         \"degrees\"     \"farinheit\"  \n[31] \"Patient\"     \"pulse\"       \"rate\"        \"was\"         \"bpm\"        \n[36] \"and\"         \"thready\"     \"Respiratory\" \"rate\"        \"was\"        \n[41] \"per\"         \"minute\"     \n\n\n\"[0-9]{1,2}\" ifadesi, 1 veya 2 basamak uzunluğunda ardışık sayılarla eşleşir. Ayrıca \"\\\\d{1,2}\" veya \"[:digit:]{1,2}\" şeklinde de yazılabilir.\n\nstr_extract_all(pt_note, \"[0-9]{1,2}\")\n\n[[1]]\n [1] \"18\" \"00\" \"6\"  \"12\" \"20\" \"05\" \"99\" \"8\"  \"10\" \"0\"  \"29\"\n\n\n\n\n\n\nBu kopya kağıdının 2. sayfasında, normal ifadelerin ve ipuçlarının faydalı bir listesini görüntüleyebilirsiniz.\nAyrıca bu rehbere bakabilirsiniz.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Karakterler ve dizeler</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.tr.html#kaynaklar",
    "href": "new_pages/characters_strings.tr.html#kaynaklar",
    "title": "10  Karakterler ve dizeler",
    "section": "10.9 Kaynaklar",
    "text": "10.9 Kaynaklar\nstringr işlevleri için bir referans sayfası burada bulunabilir\nstringr ile ilgili bir gösterim burada bulunabilir",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Karakterler ve dizeler</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.tr.html",
    "href": "new_pages/factors.tr.html",
    "title": "11  Faktörler",
    "section": "",
    "text": "11.1 Hazırlık",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Faktörler</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.tr.html#hazırlık",
    "href": "new_pages/factors.tr.html#hazırlık",
    "title": "11  Faktörler",
    "section": "",
    "text": "Paketlerin yüklenmesi\nAşağıdaki kod parçası, analizler için gereken paketlerin yüklenmesini göstermektedir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() vurgulamaktayız. R tabanından library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R temelleri sayfasına bakın.\n\npacman::p_load(\n  rio,           # içe/dışa aktar\n  here,          # dosya yolu\n  lubridate,     # tarihlerle çalışma\n  forcats,       # faktörler\n  aweek,         # otomatik faktör seviyeleri ile epiweeks oluştur\n  janitor,       # tablolar\n  tidyverse      # data yönetim ve görselleştirmesi\n  )\n\n\n\nVeriyi içe aktarma\nSimüle edilmiş bir Ebola salgınına ait vakaların veri setini içe aktarıyoruz. Takip etmek isterseniz, “temiz satır listesi” dosyasını indirmek için tıklayın. (.rds dosyası olarak). Verilerinizi rio paketinden import() işleviyle içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için İçe ve dışa aktarma sayfasına bakın).\n\n# veri setini indir\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\n\n\nYeni kategorik değişken\nBu sayfada gösterim için ortak bir senaryo kullanacağız - yeni bir kategorik değişkenin oluşturulması.\nSayısal bir sütunu sınıf faktörüne dönüştürürseniz, bunun üzerinde sayısal istatistikleri hesaplayamayacağınızı unutmayın.\n\nSütun oluşturma\nBiz, mevcut days_onset_hosp sütununu (semptom başlangıcından hastaneye kabule kadar geçen gün) kullanarak her satırı birkaç kategoriden birine sınıflandırıp yeni bir delay_cat sütunu oluşturuyoruz. Bunu, her satıra sırayla mantıksal ölçütleri (sağ taraf) uygulayan ve yeni delay_cat sütununa karşılık gelen sol taraf değerini döndüren, dplyr paktenin fonksiyonu case_when() ile yapıyoruz. Temizleme verileri ve temel işlevler bölümünde case_when() hakkında daha fazla bilgi edinebilirsiniz.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(delay_cat = case_when(\n    # criteria                                   # eğer doğruysa yeni değer\n    days_onset_hosp &lt; 2                        ~ \"&lt;2 days\",\n    days_onset_hosp &gt;= 2 & days_onset_hosp &lt; 5 ~ \"2-5 days\",\n    days_onset_hosp &gt;= 5                       ~ \"&gt;5 days\",\n    is.na(days_onset_hosp)                     ~ NA_character_,\n    TRUE                                       ~ \"Check me\"))  \n\n\n\nVarsayılan değer sırası\ncase_when() ile oluşturulduğu gibi, yeni delay_cat sütunu, karakter sınıfının kategorik bir sütunudur - henüz bir faktör değildir. Bu nedenle, bir sıklık tablosunda, benzersiz değerlerin varsayılan bir alfa-numerik düzende sıralandığını görüyoruz - bu, sezgisel olarak pek mantıklı olmayan bir sıradır:\n\ntable(linelist$delay_cat, useNA = \"always\")\n\n\n &lt;2 days  &gt;5 days 2-5 days     &lt;NA&gt; \n    2990      602     2040      256 \n\n\nBenzer şekilde, bir çubuk grafiği yaparsak, değerler de x ekseninde bu sırayla görünür (R’deki en yaygın görselleştirme paketi olan ggplot2 hakkında daha fazla bilgi için [ggplot temelleri] sayfasına bakın).\n\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = delay_cat))",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Faktörler</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.tr.html#faktöre-dönüştürme",
    "href": "new_pages/factors.tr.html#faktöre-dönüştürme",
    "title": "11  Faktörler",
    "section": "11.2 Faktöre dönüştürme",
    "text": "11.2 Faktöre dönüştürme\nBir karakteri veya sayısal sütunu faktör sınıfına dönüştürmek için, forcats paketindeki herhangi bir fonksiyonu kullanabilirsiniz (birçoğu aşağıda ayrıntılı olarak verilmiştir). Bu fonksiyonlarla veriler sınıf faktörüne dönüşecek ve daha sonra seviyelerin belirli şekilde sıralanmasını gerçekleşecek veya buna izin verilecek - örneğin fct_relevel() kullanmak seviye sırasını manuel olarak belirlemenizi sağlar. as_factor() fonksiyonu, başka bir özellik eklemeden sınıfı basitçe dönüştürür.\nR tabanı fonksiyonu olan factor(), bir sütunu faktöre dönüştürür ve karakter vektöründeki levels = argümanına göre seviyelerin sırasını manuel olarak düzenlemenizi sağlar.\nAşağıda, delay_cat sütununu sınıf karakterinden sınıf faktörüne dönüştürmek için mutate() ve fct_relevel() kullanıyoruz. delay_cat sütunu, yukarıdaki Hazırlık bölümünde oluşturulmuştur.\n\nlinelist &lt;- linelist %&gt;%\n  mutate(delay_cat = fct_relevel(delay_cat))\n\nThe unique “values” in this column are now considered “levels” of the factor. The levels have an order, which can be printed with the base R function levels(), or alternatively viewed in a count table via table() from base R or tabyl() from janitor. By default, the order of the levels will be alpha-numeric, as before. Note that NA is not a factor level.\n\nlevels(linelist$delay_cat)\n\n[1] \"&lt;2 days\"  \"&gt;5 days\"  \"2-5 days\"\n\n\nfct_relevel() fonksiyonu, seviye sırasını manuel olarak belirlemenize izin veren ek bir özelliğe sahiptir. Düzey değerlerini, aşağıda gösterildiği gibi virgülle ayırarak sırayla, tırnak içinde yazmanız yeterlidir. Yazımın değerlerle tam olarak eşleşmesi gerektiğini unutmayın. Verilerde mevcut olmayan düzeyler oluşturmak istiyorsanız, bunun yerine fct_expand() kullanın).\n\nlinelist &lt;- linelist %&gt;%\n  mutate(delay_cat = fct_relevel(delay_cat, \"&lt;2 days\", \"2-5 days\", \"&gt;5 days\"))\n\nArtık seviyelerin bir önceki komutta belirtildiği gibi mantıklı bir sırayla sıralandığını görebiliriz.\n\nlevels(linelist$delay_cat)\n\n[1] \"&lt;2 days\"  \"2-5 days\" \"&gt;5 days\" \n\n\nŞimdi tablodaki sırası da daha sezgisel bir anlam ifade ediyor.\n\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = delay_cat))",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Faktörler</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.tr.html#seviye-ekleme-ve-çıkarma",
    "href": "new_pages/factors.tr.html#seviye-ekleme-ve-çıkarma",
    "title": "11  Faktörler",
    "section": "11.3 Seviye ekleme ve çıkarma",
    "text": "11.3 Seviye ekleme ve çıkarma\n\nEkleme\nBir faktöre seviye eklemeniz gerekiyorsa, bunu fct_expand() ile yapabilirsiniz. Sütun adını ve ardından yeni seviyeleri (virgülle ayırarak) yazmanız yeterlidir. Değerleri tablolaştırarak yeni seviyeleri ve sıfır sayılarını görebiliriz. R tabanından table()ı veya janitor’dan tabyl() kullanabilirsiniz:\n\nlinelist %&gt;% \n  mutate(delay_cat = fct_expand(delay_cat, \"Not admitted to hospital\", \"Transfer to other jurisdiction\")) %&gt;% \n  tabyl(delay_cat)   # print table\n\n                      delay_cat    n    percent valid_percent\n                        &lt;2 days 2990 0.50781250     0.5308949\n                       2-5 days 2040 0.34646739     0.3622159\n                        &gt;5 days  602 0.10224185     0.1068892\n       Not admitted to hospital    0 0.00000000     0.0000000\n Transfer to other jurisdiction    0 0.00000000     0.0000000\n                           &lt;NA&gt;  256 0.04347826            NA\n\n\nNot: Eksik değerleri (NA) seviyelere kolayca eklemek için özel bir forcats fonksiyonu mevcuttur. Aşağıdaki Eksik değerler ile ilgili bölüme bakın.\n\n\nÇıkarma\nfct_drop()ı kullanırsanız, sıfır sayımlı “kullanılmayan” seviyeler, seviyeler grubundan çıkarılacaktır. Yukarıda eklediğimiz seviyeler (“Hastaneye kabul edilmedi”) bir seviye olarak mevcuttur, ancak hiçbir satır aslında bu değere sahip değildir. Böylece, faktör sütunumuza fct_drop() uygulanarak çıkarılır:\n\nlinelist %&gt;% \n  mutate(delay_cat = fct_drop(delay_cat)) %&gt;% \n  tabyl(delay_cat)\n\n delay_cat    n    percent valid_percent\n   &lt;2 days 2990 0.50781250     0.5308949\n  2-5 days 2040 0.34646739     0.3622159\n   &gt;5 days  602 0.10224185     0.1068892\n      &lt;NA&gt;  256 0.04347826            NA",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Faktörler</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.tr.html#fct_adjust",
    "href": "new_pages/factors.tr.html#fct_adjust",
    "title": "11  Faktörler",
    "section": "11.4 Seviye sırasını düzenleme",
    "text": "11.4 Seviye sırasını düzenleme\nforcats paketi, faktör düzeylerinin sırasını kolayca ayarlamak için kullanışlı fonksiyonlar da sunar (bir sütun sınıf faktörü olarak tanımlandıktan sonra):\nBu fonksiyonlar, iki bağlamda faktör sütununa uygulanabilir:\n\nHer zamanki gibi veri çerçevesindeki sütuna uygulanır, böylece değişen veriler daha sonra da kullanılabilir\nBir grafik içine uygulanabilir, böylece değişiklik sadece grafik içinde kalır\n\n\nElle düzenleme\nBu fonksiyon, faktör seviyelerini manuel olarak sıralamak için kullanılır. Faktör olmayan bir sütunda kullanılırsa, sütun önce sınıf faktörüne dönüştürülür.\nParantez içinde önce faktör sütun adını girin, ardından aşağıdakilerden birini sağlayın:\n\nTüm seviyeleri istenen sırada (karakter vektörü c() olarak) veya\nBir seviye ve after = argümanı kullanılarak düzeltilmiş sıralama\n\nBurada, (zaten Faktör sınıfı olan) delay_cat sütununu yeniden tanımlamaya ve istenen tüm düzey sırasını belirtmeye bir örnek verilmiştir.\n\n# seviye sırasını yeniden düzenle\nlinelist &lt;- linelist %&gt;% \n  mutate(delay_cat = fct_relevel(delay_cat, c(\"&lt;2 days\", \"2-5 days\", \"&gt;5 days\")))\n\nSadece bir seviyeyi taşımak istiyorsanız, bunu tek başına fct_relevel() olarak belirtebilir ve after = argümanına hangi sırada olması gerektiğini belirtmek için sayı verebilirsiniz. Örneğin, aşağıdaki komut “&lt;2 gün” ifadesini ikinci konuma kaydırır:\n\n# seviye sırasını yeniden düzenle\nlinelist %&gt;% \n  mutate(delay_cat = fct_relevel(delay_cat, \"&lt;2 days\", after = 1)) %&gt;% \n  tabyl(delay_cat)\n\n\n\nGrafik içinde\nforcats komutları, veri çerçevesinde veya yalnızca bir grafik içinde seviye sırasını ayarlamak için kullanılabilir. Sütun adını grafik içinde ggplot()un “sarma” komutunu kullanarak, tersine çevirebilir veya yeniden seviyelendirebilirsiniz. Değişim yalnızca bu grafik için geçerli olacaktır.\nAşağıda, ggplot() ile iki grafik oluşturulmuştur ([ggplot temelleri] sayfasına bakın). İlkinde, delay_cat sütunu, “satır listesi” verisinde olduğu gibi varsayılan düzey sırası ile grafiğin x eksenine eşlenir. İkinci örnekte fct_relevel() içine sarılmış ve grafikteki sırası değiştirilmiştir.\n\n# Alfa-numerik varsayılan sıra - ggplot'ta düzenleme yapılmadı\nggplot(data = linelist)+\n    geom_bar(mapping = aes(x = delay_cat))\n\n# ggplot içinde faktör seviyesi düzenlendi\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = fct_relevel(delay_cat, c(\"&lt;2 days\", \"2-5 days\", \"&gt;5 days\"))))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVarsayılan x ekseni başlığının oldukça karmaşık olduğuna dikkat edin - bu başlığı ggplot2 labs() argümanı ile değiştirebilirsiniz.\n\n\nTersine döndürme\nSeviye sırasını tersine çevirmek işlemi oldukça yaygındır. Faktörü fct_rev() ile sarmanız yeterlidir.\nGerçek faktör seviyelerini değil de yalnızca bir grafiğin açıklamasını tersine çevirmek istiyorsanız, bunu guides() ile yapabileceğinizi unutmayın (bkz. [ggplot ipuçları]).\n\n\nSıklığa göre\nDeğerleri verilerde görünme sıklığına göre sıralamak için fct_infreq() kullanın. Eksik değerler (NA), açık bir düzeye dönüştürülmediği sürece otomatik olarak sona eklenir (bkz. bu bölüm). fct_rev() ile bir daha sarmalayarak sırayı tersine çevirebilirsiniz.\nBu fonksiyon, aşağıda gösterildiği gibi bir ggplot() içinde kullanılabilir.\n\n# sıklığa göre sırala\nggplot(data = linelist, aes(x = fct_infreq(delay_cat)))+\n  geom_bar()+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Ordered by frequency\")\n\n# sıralamayı tersine çevir\nggplot(data = linelist, aes(x = fct_rev(fct_infreq(delay_cat))))+\n  geom_bar()+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Reverse of order by frequency\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKarşılaşmaya göre\nSeviye sırasını, ilk satırdan başlayarak verilerdeki karşılaşma sırasına uyacak şekilde ayarlamak için fct_inorder() fonksiyonunu kullanın. Bu komut, veri çerçevesindeki verileri arrange() fonksiyonu ile düzenledikten sonra faktör sırasını tekrardan ayarlamak için faydalı olacaktır.\n\n\nBaşka bir sütunun özet istatistiğine göre\nBir sütunun seviyelerini başka bir sütunun özet istatistiğine göre sıralamak için fct_reorder()yı kullanabilirsiniz. Görsel olarak, bu, çubukların/noktaların grafik boyunca istikrarlı bir şekilde yükseldiği veya alçaldığı hoş grafiklerle sonuçlanabilir.\nAşağıdaki örneklerde, x ekseni delay_cat ve y ekseni ct_blood (döngü eşiği) sayısal sütunudur. Kutu grafikleri, delay_cat grubuna göre CT değeri dağılımını gösterir. Kutu grafiklerini grup medyan CT değerine göre artan sırada sıralamak istiyoruz.\nAşağıdaki ilk örnekte, varsayılan sıra olarak alfa-numerik sırası kullanılır. Kutu çizim yüksekliklerinin karışık olduğunu ve belirli bir sırada olmadığını görebilirsiniz. İkinci örnekte ise, delay_cat sütunu (x eksenine eşlenmiştir) fct_reorder() içine sarılmıştır, ct_blood sütunu ikinci ve medyan üçüncü argüman olarak verilmiştir. (maks, ortalama, min vb. de kullanabilirsiniz). Böylece, delay_cat seviyelerinin sırası artan medyan CT değerlerini yansıtacaktır. Bu, ikinci grafikte gösterilmektedir - kutu çizimleri yükselecek şekilde yeniden düzenlenmiştir. Açık bir düzeye dönüştürülmediği sürece, “NA”nın (eksik) sonunda nasıl görüldüğüne dikkat edin.\n\n# kutu grafiği orjinal faktör seviyelerine göre sıralanmıştır\nggplot(data = linelist)+\n  geom_boxplot(\n    aes(x = delay_cat,\n        y = ct_blood, \n        fill = delay_cat))+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Ordered by original alpha-numeric levels\")+\n  theme_classic()+\n  theme(legend.position = \"none\")\n\n\n# kutu grafiği medyan CT düzeylerine göre sıralanmıştır\nggplot(data = linelist)+\n  geom_boxplot(\n    aes(x = fct_reorder(delay_cat, ct_blood, \"median\"),\n        y = ct_blood,\n        fill = delay_cat))+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Ordered by median CT value in group\")+\n  theme_classic()+\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYukarıdaki örnekte, ggplot() komutundan önce gerekli hiçbir adım olmadığına dikkat edin - gruplama ve hesaplamaların tümü dahili olarak ggplot komutunda yapılır.\n\n\n“Son” değere göre\nGruplandırılmış çizgi grafiklerinde fct_reorder2(), düzeylerin (ve dolayısıyla başlığın) grafik “sonu” çizgilerin dikey sıralamasıyla hizalandırırr. Teknik olarak konuşursak, “en büyük x değerleriyle ilişkili y değerlerine göre sıralanır.”\nÖrneğin, zaman içinde hastaneye göre vaka sayılarını gösteren satırlarınız varsa, aes() içindeki color = argümanına fct_reorder2() komutunu uygulayabilirsiniz. Öyle ki açıklamada görünen hastanelerin dikey sırası grafik sonundaki satır sırasıyla hizalanır. Çevrimiçi belgelerde daha fazlasını okuyuabilirsiniz.\n\nepidemic_data &lt;- linelist %&gt;%         # satır listesiyle başla   \n    filter(date_onset &lt; as.Date(\"2014-09-21\")) %&gt;%    # görsel netlik için son tarih\n    count(                                            # haftalık ve hastaneye göre vaka sayılarını al\n      epiweek = lubridate::floor_date(date_onset, \"week\"),  \n      hospital                                            \n    ) \n  \nggplot(data = epidemic_data)+                       # grafiği başlat\n  geom_line(                                        # çizgileri hazırla\n    aes(\n      x = epiweek,                                  # x-axis epiweek\n      y = n,                                        # boyu haftalık vaka sayısıdır\n      color = fct_reorder2(hospital, epiweek, n)))+ # veriyi, grafik sonu yüksekliği ve hastaneye göre gruplandırılıp renklendir\n  labs(title = \"Factor levels (and legend display) by line height at end of plot\",\n       color = \"Hospital\")                          # başlığı değiştir",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Faktörler</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.tr.html#fct_missing",
    "href": "new_pages/factors.tr.html#fct_missing",
    "title": "11  Faktörler",
    "section": "11.5 Eksik değerler",
    "text": "11.5 Eksik değerler\nFaktör sütununuzda NA değerleri varsa, bunları fct_explicit_na() ile kolayca “Eksik” gibi adlandırılmış bir düzeye dönüştürebilirsiniz. NA değerleri, sıralamanın sonunda varsayılan olarak “(Eksik)” değerine dönüştürülür. Seviye adını na_level = argümanıyla ayarlayabilirsiniz.\nAşağıda, bu işlem delay_cat sütununda ’NA’ları “Missing delay”e dönüştürür. Bu, tabyl() ile bir tabloya yazdırılır.\n\nlinelist %&gt;% \n  mutate(delay_cat = fct_explicit_na(delay_cat, na_level = \"Missing delay\")) %&gt;% \n  tabyl(delay_cat)\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `delay_cat = fct_explicit_na(delay_cat, na_level = \"Missing\n  delay\")`.\nCaused by warning:\n! `fct_explicit_na()` was deprecated in forcats 1.0.0.\nℹ Please use `fct_na_value_to_level()` instead.\n\n\n     delay_cat    n    percent\n      2-5 days 2040 0.34646739\n       &lt;2 days 2990 0.50781250\n       &gt;5 days  602 0.10224185\n Missing delay  256 0.04347826",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Faktörler</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.tr.html#seviyeleri-birleştirme",
    "href": "new_pages/factors.tr.html#seviyeleri-birleştirme",
    "title": "11  Faktörler",
    "section": "11.6 Seviyeleri birleştirme",
    "text": "11.6 Seviyeleri birleştirme\n\nElle düzenleme\nSeviye göstergelerini fct_recode() ile manuel olarak ayarlayabilirsiniz. Bu, dplyr fonksiyonu recode() gibidir (bkz. [Temizleme verileri ve temel işlevler]), farklı olarak yeni faktör seviyelerinin oluşturulmasına izin verir. Bir faktörde basit recode()komutunu kullanırsanız, önceden izin verilen seviyeler ayarlanmadıkça yeni kodlanmış değerler reddedilecektir.\nBu araç, yeniden kodlanmış değeri birden çok seviyeye atayarak seviyeleri “birleştirmek” için de kullanılabilir. Sadece bilgileri kaybetmemeye dikkat edin! Bu birleştirme adımlarını yeni bir sütunda yapmayı düşünün (mevcut sütunun üzerine yazmayın).\nfct_recode(), recode()dan farklı bir sözdizimine sahiptir. recode(), ESKİ = YENİyi kullanırken, fct_recode(), YENİ = ESKİyi kullanır.\nGeçerli delay_cat seviyeleri şunlardır:\n\nlevels(linelist$delay_cat)\n\n[1] \"&lt;2 days\"  \"2-5 days\" \"&gt;5 days\" \n\n\nYeni düzeyler, fct_recode(column, \"new\" = \"old\", \"new\" = \"old\", \"new\" = \"old\") sözdizimi kullanılarak oluşturulur ve yazdırılır:\n\nlinelist %&gt;% \n  mutate(delay_cat = fct_recode(\n    delay_cat,\n    \"Less than 2 days\" = \"&lt;2 days\",\n    \"2 to 5 days\"      = \"2-5 days\",\n    \"More than 5 days\" = \"&gt;5 days\")) %&gt;% \n  tabyl(delay_cat)\n\n        delay_cat    n    percent valid_percent\n Less than 2 days 2990 0.50781250     0.5308949\n      2 to 5 days 2040 0.34646739     0.3622159\n More than 5 days  602 0.10224185     0.1068892\n             &lt;NA&gt;  256 0.04347826            NA\n\n\nBurada seviyeler fct_recode() ile manuel olarak birleştirilirler. “5 günden az” yeni bir düzeyin oluşturulmasında herhangi bir hata olmadığını unutmayın.\n\nlinelist %&gt;% \n  mutate(delay_cat = fct_recode(\n    delay_cat,\n    \"Less than 5 days\" = \"&lt;2 days\",\n    \"Less than 5 days\" = \"2-5 days\",\n    \"More than 5 days\" = \"&gt;5 days\")) %&gt;% \n  tabyl(delay_cat)\n\n        delay_cat    n    percent valid_percent\n Less than 5 days 5030 0.85427989     0.8931108\n More than 5 days  602 0.10224185     0.1068892\n             &lt;NA&gt;  256 0.04347826            NA\n\n\n\n\n“Diğerine” indirgeme\nFaktör seviyelerini bir “Diğer” seviyeye manuel olarak atamak için fct_other() komutunu kullanabilirsiniz. Aşağıda, “Port Hospital” ve “Central Hospital” dışındaki “hospital” sütunundaki tüm seviyeler “Other Hospital” olarak birleştirilmiştir. keep = veya drop = için bir vektör sağlayabilirsiniz. “Diğer” düzeyinin görünümünü other_level = ile değiştirebilirsiniz.\n\nlinelist %&gt;%    \n  mutate(hospital = fct_other(                      # adjust levels\n    hospital,\n    keep = c(\"Port Hospital\", \"Central Hospital\"),  # keep these separate\n    other_level = \"Other Hospital\")) %&gt;%            # All others as \"Other Hospital\"\n  tabyl(hospital)                                   # print table\n\n         hospital    n    percent\n Central Hospital  454 0.07710598\n    Port Hospital 1762 0.29925272\n   Other Hospital 3672 0.62364130\n\n\n\n\nFrekansa göre indirgeme\nfct_lump() kullanarak az görülen faktör düzeylerini otomatik olarak birleştirebilirsiniz.\nBirçok düşük frekans düzeyini bir “Diğer” grubuna “toplamak” için aşağıdakilerden birini yapın:\n\nTutmak istediğiniz grup sayısını n = olarak ayarlayın. En çok görülen n seviyeleri tutulacak ve diğerlerinin tamamı “Diğer” olarak birleştirilecektir.\n“prop =” değerini, üzerinde tutmak istediğiniz seviyeler için eşik frekans oranı olarak ayarlayın. Diğer tüm değerler “Diğer” olarak birleşecektir.\n\n“Diğer” düzeyinin görünümünü other_level = ile değiştirebilirsiniz. Aşağıda, en sık rastlanan iki hastane dışındaki tüm hastaneler “Other Hospital” olarak birleştirilmiştir.\n\nlinelist %&gt;%    \n  mutate(hospital = fct_lump(                      # seviyeleri düzenle\n    hospital,\n    n = 2,                                          # ilk 2 seviyeyi tut\n    other_level = \"Other Hospital\")) %&gt;%            # geri kalanını \"Other Hospital\" olarak tanımla\n  tabyl(hospital)                                   # tabloyu yazdır\n\n       hospital    n   percent\n        Missing 1469 0.2494905\n  Port Hospital 1762 0.2992527\n Other Hospital 2657 0.4512568",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Faktörler</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.tr.html#tüm-seviyeleri-gösterme",
    "href": "new_pages/factors.tr.html#tüm-seviyeleri-gösterme",
    "title": "11  Faktörler",
    "section": "11.7 Tüm seviyeleri gösterme",
    "text": "11.7 Tüm seviyeleri gösterme\nFaktörleri kullanmanın bir diğer faydası da, bir veri kümesinde gerçekte hangi değerlerin mevcut olduğuna bakılmaksızın, grafik açıklamalarının ve tabloların görünümünü standart hale getirmesidir.\nÇok sayıda analiz hazırlıyorsanız (örneğin, birden fazla analiz için), gösterge ve tabloların, değişen seviyelerde veri kompozisyonu ile bile aynı görünmesini isteyebilirsiniz.\n\nGrafiklerde\nBir ggplot() grafiğinde, ilgili scale_xxxx() fonksiyonuna “drop = FALSE” argümanını eklemeniz yeterlidir. Verilerde bulunup bulunmadıklarına bakılmaksızın tüm faktör seviyeleri görüntülenecektir. Faktör sütun seviyeleriniz fill = kullanılarak görüntüleniyorsa, o zaman scale_fill_discrete() içine aşağıda gösterildiği gibi drop = FALSE değerini eklersiniz. Seviyeleriniz x = (x eksenine göre) color = veya size = ile görüntüleniyorsa, bunu scale_color_discrete() veya scale_size_discrete() argümanlarıyla sağlayabilirsiniz.\nAşağıdaki örnek, hastaneye göre yaş kategorisine ait çubuk grafiğidir. scale_fill_discrete(drop = FALSE) eklenmesi, verilerde mevcut olmasa bile tüm yaş gruplarının açıklamada görünmesini sağlar.\n\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = hospital, fill = age_cat)) +\n  scale_fill_discrete(drop = FALSE)+                        # boş olsa bile tüm verileri açıklamada göster\n  labs(\n    title = \"All age groups will appear in legend, even if not present in data\")\n\n\n\n\n\n\n\n\n\n\nTablolarda\nHem R tabanında table() hem de janitor’dan tabyl() tüm faktör seviyelerini (kullanılmayan seviyeler bile) gösterecektir.\nBir tablo oluşturmak için dplyr’den count() veya summarise() kullanırsanız, kullanılmamış olanlar da dahil tüm faktör düzeylerini dahil etmek için ‘.drop = FALSE’ bağımsız değişkenini ekleyin.\n[Açıklayıcı tablolar] sayfasında, scale_discrete belgelerinde veya count() belgelerinde. [Bulaşıcı takibi] sayfasında başka bir örnek görebilirsiniz.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Faktörler</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.tr.html#epiweeks",
    "href": "new_pages/factors.tr.html#epiweeks",
    "title": "11  Faktörler",
    "section": "11.8 Epiweeks",
    "text": "11.8 Epiweeks\nLütfen [Gruplama verileri] sayfasında epidemiyolojik haftaların nasıl oluşturulacağına ilişkin kapsamlı tartışmaya bakın.\nEpidemiyolojik haftaların nasıl oluşturulacağı ve biçimlendirileceğiyle ilgili ipuçları için lütfen [Tarihlerle çalışma] sayfasına da bakın.\n\nGrafiklerde epiweeks\nAmacınız bir grafikte görüntülenecek epiweeks oluşturmaksa, bunu [Gruplama verileri] sayfasında açıklandığı gibi lubridate’nin floor_date() ile yapabilirsiniz. Döndürülen değerler YYYY-AA-GG biçiminde Date sınıfında olacaktır. Bu sütunu bir grafik içinde kullanırsanız, tarihler doğal olarak sıralanır; seviyeler veya sınıf Faktörüne dönüştürme konusunda endişelenmenize gerek yoktur. Aşağıdaki başlangıç tarihlerine ait ggplot() histogramına bakın.\nBu yaklaşımda, scale_x_date() ile bir eksen üzerindeki tarihlerin görüntülenmesini ayarlayabilirsiniz. Daha fazla bilgi için [Salgın eğrileri] ile ilgili sayfaya bakın. scale_x_date() öğesinin ‘date_labels =’ bağımsız değişkenine bir “strptime” görüntüleme biçimi belirleyebilirsiniz. Bu biçimler “%” yer tutucularını kullanır. Yer tutucular [Tarihlerle çalışma] sayfasında ele alınmıştır. 4 basamaklı bir yılı temsil etmek için “%Y” ve hafta numarasını temsil etmek için “%W” veya “%U” kullanın (sırasıyla Pazartesi veya Pazar haftaları).\n\nlinelist %&gt;% \n  mutate(epiweek_date = floor_date(date_onset, \"week\")) %&gt;%  # hafta sütununu oluştur\n  ggplot()+                                                  # ggplotu başlat\n  geom_histogram(mapping = aes(x = epiweek_date))+           # başlangıç tarihinin histogramı\n  scale_x_date(date_labels = \"%Y-W%W\")                       # tarihlerin gösterimini YYYY-WWw olacak şekilde ayarla\n\n\n\n\n\n\n\n\n\n\nVerilerde epiweeks\nVerileri faktöre çevirmedeki amacınız grafik yapmak değilse, bunu iki yoldan yapabilirsiniz:\n\nGörüntüleme üzerindeki hassas kontrol için, lubridate epiweek sütununu (YYYY-AA-GG) istenen formatına (YYYY-WWw) ve ardından bunu sınıf Faktörüne dönüştürün .\n\nİlk olarak, tarih gösterimini YYYY-AA-GG’den YYYY-Www gösterimine dönüştürmek için R tabanından format() komutunu kullanın (bkz. [Tarihlerle çalışma] sayfası). Bu süreçte veriler sınıftan karaktere dönüşmüş olacaktır. Ardından, factor() ile karakterden tekrar sınıf Factor’a dönüştürün.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(epiweek_date = floor_date(date_onset, \"week\"),       # epiweeks oluştur (YYYY-AA-GG)\n         epiweek_formatted = format(epiweek_date, \"%Y-W%W\"),  # (YYYY-HHh) formatına dönüştür\n         epiweek_formatted = factor(epiweek_formatted))       # faktöre dönüştür\n\n# seviyeleri göster\nlevels(linelist$epiweek_formatted)\n\n [1] \"2014-W13\" \"2014-W14\" \"2014-W15\" \"2014-W16\" \"2014-W17\" \"2014-W18\"\n [7] \"2014-W19\" \"2014-W20\" \"2014-W21\" \"2014-W22\" \"2014-W23\" \"2014-W24\"\n[13] \"2014-W25\" \"2014-W26\" \"2014-W27\" \"2014-W28\" \"2014-W29\" \"2014-W30\"\n[19] \"2014-W31\" \"2014-W32\" \"2014-W33\" \"2014-W34\" \"2014-W35\" \"2014-W36\"\n[25] \"2014-W37\" \"2014-W38\" \"2014-W39\" \"2014-W40\" \"2014-W41\" \"2014-W42\"\n[31] \"2014-W43\" \"2014-W44\" \"2014-W45\" \"2014-W46\" \"2014-W47\" \"2014-W48\"\n[37] \"2014-W49\" \"2014-W50\" \"2014-W51\" \"2015-W00\" \"2015-W01\" \"2015-W02\"\n[43] \"2015-W03\" \"2015-W04\" \"2015-W05\" \"2015-W06\" \"2015-W07\" \"2015-W08\"\n[49] \"2015-W09\" \"2015-W10\" \"2015-W11\" \"2015-W12\" \"2015-W13\" \"2015-W14\"\n[55] \"2015-W15\" \"2015-W16\"\n\n\nTEHLİKE: Haftaları yılların önüne koyarsanız (“Www-YYYY”) (“%W-%Y”), varsayılan alfa-numerik sıralaması yanlış olacaktır (ör. 01-2015, 35-2014’ten önce olacaktır). Uzun ve sancılı bir süreçle, sırayı manuel olarak ayarlamanız gerekebilir.\n\nHızlı varsayılan görüntüleme için aweek paketini ve date2week() fonksiyonunu kullanın. week_start = ile haftanın ilk gününü ayarlayabilirsiniz. factor = TRUE olarak ayarlarsanız, çıktı sütunu sıralı bir faktör olacaktır. Ek olarak, faktör, o hafta hiç vaka olmasa bile, aralıktaki tüm haftalar için seviyeleri içermektedir.\n\n\ndf &lt;- linelist %&gt;% \n  mutate(epiweek = date2week(date_onset, week_start = \"Monday\", factor = TRUE))\n\nlevels(df$epiweek)\n\naweek hakkında daha fazla bilgi için [Tarihlerle çalışma] sayfasına bakın. Ayrıca week2date() ters fonksiyonu da bu paket içinde mevcuttur.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Faktörler</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.tr.html#kaynaklar",
    "href": "new_pages/factors.tr.html#kaynaklar",
    "title": "11  Faktörler",
    "section": "11.9 Kaynaklar",
    "text": "11.9 Kaynaklar\nfaktörler ile ilgili Veri Bilimi sayfası için R\naweek paketi skeci",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Faktörler</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.tr.html",
    "href": "new_pages/pivoting.tr.html",
    "title": "12  Verilerin pivotlanması",
    "section": "",
    "text": "12.1 Hazırlık",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Verilerin pivotlanması</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.tr.html#hazırlık",
    "href": "new_pages/pivoting.tr.html#hazırlık",
    "title": "12  Verilerin pivotlanması",
    "section": "",
    "text": "Paketlerin yüklenmesi\nBu kod bloğu, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gereken durumlarda paketi kuran ve kullanım için yükleyen pacman’ın p_load() fonksiyonunun kullanımı vurgulanmıştır. Ayrıca, R tabanından library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R temelleri sayfasına bakın.\n\npacman::p_load(\n  rio,          # Dosyanın içe aktarımı\n  here,         # Dosyanın konumu\n  kableExtra,   # Build and manipulate complex tables\n  tidyverse)    # veri yönetimi + ggplot2 grafik paketi\n\n\n\nVerinin içeri aktarımı\n\n\nSıtma hastalığı için sayım verisi\nBu sayfada, kuruluş ve yaş grubuna göre günlük sıtma vakalarını içeren kurgusal bir veri setini inceleyeceğiz. Adımları takip etmek isterseniz, veri setini indirmek için buraya tıklayın (.rds dosyası formatında). Verileri rio paketinden import() fonksiyonuyla içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için İçe Aktarma ve Dışa Aktarma sayfasına bakın).\n\n# Verinin içeri aktarımı\ncount_data &lt;- import(\"malaria_facility_count_data.rds\")\n\nİlk 50 satır aşağıda gösterilmiştir.\n\n\n\n\n\n\n\n\nSatır listesi verisi\nBu sayfanın sonraki bölümünde, simüle edilmiş bir Ebola salgını vakalarını içeren veri setini de kullanacağız. Devam etmek istiyorsanız, “temiz” satır listesini (.rds dosyası olarak) indirmek için tıklayın. Verilerinizi rio paketinden import() işleviyle içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için İçe Aktarma ve Dışa Aktarma sayfasına bakın).\n\n# Verinin içeri aktarımı\nlinelist &lt;- import(\"linelist_cleaned.xlsx\")",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Verilerin pivotlanması</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.tr.html#genişten-uzuna",
    "href": "new_pages/pivoting.tr.html#genişten-uzuna",
    "title": "12  Verilerin pivotlanması",
    "section": "12.2 Genişten uzuna",
    "text": "12.2 Genişten uzuna\n\n\n\n\n\n\n\n\n\n\n\n“Geniş” format\nVeriler genellikle “geniş” bir biçimde girilir ve saklanır - burada bir gözlemin (kişinin) özellikleri veya yanıtları tek bir satırda depolanır. Bu sunum için faydalı olsa da, bazı analiz türleri için ideal değildir.\nÖrnek olarak yukarıdaki Hazırlık bölümünde içe aktarılan count_data veri setini ele alalım. Her satırın bir “tesis-gününü” temsil ettiğini görebilirsiniz. Gerçek vaka sayıları (en sağdaki sütunlar), belirli bir tesis günündeki farklı yaş grubuna ait bilgilerin ayrı sütunlar halinde ancak tek bir satırda saklanacağı şekilde “geniş” bir formatta bulunur.\n\n\n\n\n\n\nBu veri tabanındaki ScriptEach gözlemi, belirli bir tarihteki 65 tesisten birindeki sıtma sayımlarını gösterir; bu sayı, count_data$data_date %&gt;% min() ile count_data$data_date %&gt;% max() arasında değişir. Bu tesisler bir Province (il) (North) ve dört District (ilçe)de (Spring, Bolo, Dingo ve Barnard) bulunmaktadır. Veri seti, genel sıtma sayılarının yanı sıra üç yaş grubunun her birinde - &lt;4 yaş, 5-14 yaş ve 15 yaş ve üzeri - yaşa özel sayıları da içermektedir.\nBunun gibi “geniş” veriler “düzenli veri” standartlarına uymaz, çünkü sütun başlıkları aslında “değişkenleri” temsil etmez - bunlar hipotetik bir “yaş grubu” değişkenini temsil eder.\nBu format, bilgileri bir tabloda sunmak veya vaka raporu formlarına veri girmek (örn. Excel’de) için faydalı olabilir. Ancak, analiz aşamasında, bu veriler tipik olarak “düzenli veri” standartlarıyla daha uyumlu “daha uzun” bir formata dönüştürülmelidir. Özellikle R paketi ggplot2, veriler “uzun” formatta olduğunda en iyi sonuçları verir.\nToplam sıtma sayılarının zamana göre görselleştirilmesinde, mevcut formattaki verilerle herhangi bir zorluk yaşanmaz:\n\nggplot(count_data) +\n  geom_col(aes(x = data_date, y = malaria_tot), width = 1)\n\n\n\n\n\n\n\n\nAncak, her yaş grubunun bu toplam sayıya göreli katkılarını göstermek istersek ne olur? Bu durumda, ilgilenilen değişkenin (yaş grubu), veri kümesinde {ggplot2}’nin “haritalama estetiği” aes() argümanına aktarılabilecek tek bir sütunda bulunması gerekir.\n\n\n\npivot_longer()\ntidyr fonksiyonu pivot_longer(), verileri “daha uzun” formata getirir. tidyr, R paketlerinin tidyverse kümesinin bir parçasıdır.\nBu fonksiyon, dönüştürülecek bir dizi sütunu kabul eder (cols = argümanı ile belirtilir). Bu nedenle, bir veri tabanının yalnızca bir kısmıyla çalışabilir. Bu fonksiyonla yalnızca vaka sayısı sütunlarını döndürmek istediğimizden, kullandığımız veritabanı için yararlıdı\nBu süreçte, biri kategorileri (eski sütun adları) ve diğeri de karşılık gelen değerleri (ör. vaka sayıları) içeren iki “yeni” sütun elde edeceksiniz. Bu yeni sütunlar için varsayılan adları kabul edebilir veya kendi adlarınızı sırasıyla names_to = ve values_to = argümanlarıyla belirtebilirsiniz.\nPivot_longer()’ı çalışırken görelim…\n\n\nStandard pivoting\n“Geniş” verileri “uzun” bir biçime dönüştürmek için tidyr’in pivot_longer() fonksiyonunu kullanmak istiyoruz. Spesifik olarak, sıtma sayılarına ilişkin verileri içeren dört sayısal sütunu iki yeni sütuna dönüştürmek istiyoruz. İki yeni sütundan biri yaş gruplarını ve diğeri yaş gruplarına karşılık gelen değerleri içerecektir.\n\ndf_long &lt;- count_data %&gt;% \n  pivot_longer(\n    cols = c(`malaria_rdt_0-4`, `malaria_rdt_5-14`, `malaria_rdt_15`, `malaria_tot`)\n  )\n\ndf_long\n\nYeni oluşturulan veri çerçevesinin (df_long) daha fazla satırı olduğuna dikkat edin (12.152’ye karşı 3.038); böylece veri çerçevesi daha uzun bir şekle sahip olur. Aslında, eski versiyonuna göre tam olarak dört kat daha uzundur, çünkü orijinal veri kümesindeki her satır şimdi df_long’da dört satırı temsil etmektedir (her bir sıtma sayımı gözlemi yaş grubu için bir tane (&lt;4y, 5-14y, 15y+ ve toplam)).\nDaha önce dört sütunda (malaria_ ön ekiyle başlayanlar) depolanan veriler şimdi iki sütunda depolandığından, daha uzun olmanın yanı sıra, yeni veri kümesi daha az sütuna (8’e karşı 10) sahiptir.\nBu dört sütunun adlarının tümü malaria_ önekiyle başladığından, aynı sonucu elde etmek için kullanışlı “tidyselect” start_with() işlevini kullanabilirdik (bu yardımcı işlevlerin daha fazlası için [Verileri temizleme ve temel işlevler] sayfasına bakın).\n\n# tidyselect yardımcı işleviyle sütun sağlayın\ncount_data %&gt;% \n  pivot_longer(\n    cols = starts_with(\"malaria_\")\n  )\n\n# A tibble: 12,152 × 8\n   location_name data_date  submitted_date Province District newid name    value\n   &lt;chr&gt;         &lt;date&gt;     &lt;date&gt;         &lt;chr&gt;    &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;   &lt;int&gt;\n 1 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malari…    11\n 2 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malari…    12\n 3 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malari…    23\n 4 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malari…    46\n 5 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malari…    11\n 6 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malari…    10\n 7 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malari…     5\n 8 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malari…    26\n 9 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malari…     8\n10 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malari…     5\n# ℹ 12,142 more rows\n\n\nya da pozisyona göre:\n\n# pozisyona göre sütun sağlamak\ncount_data %&gt;% \n  pivot_longer(\n    cols = 6:9\n  )\n\nveya adlandırılmış aralığa göre:\n\n# ardışık sütun aralıkları sağlama\ncount_data %&gt;% \n  pivot_longer(\n    cols = `malaria_rdt_0-4`:malaria_tot\n  )\n\nBu iki yeni sütuna varsayılan ad ve değerler verilir, ancak istediğimiz adları verebilmek için bu varsayılan adları geçersiz kılabiliriz; names_to ve values_to argümanlarını kullanarak yeni sütunlarda hangi bilgilerin depolandığını hatırlayabiliriz. Age_group adlarını ve sayılarını kullanalım:\n\ndf_long &lt;- \n  count_data %&gt;% \n  pivot_longer(\n    cols = starts_with(\"malaria_\"),\n    names_to = \"age_group\",\n    values_to = \"counts\"\n  )\n\ndf_long\n\n# A tibble: 12,152 × 8\n   location_name data_date  submitted_date Province District newid age_group    \n   &lt;chr&gt;         &lt;date&gt;     &lt;date&gt;         &lt;chr&gt;    &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;        \n 1 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_…\n 2 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_…\n 3 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_…\n 4 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_tot  \n 5 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_…\n 6 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_…\n 7 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_…\n 8 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_tot  \n 9 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malaria_rdt_…\n10 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malaria_rdt_…\n# ℹ 12,142 more rows\n# ℹ 1 more variable: counts &lt;int&gt;\n\n\nŞimdi bu yeni veri kümesini {ggplot2}’ye aktarabiliriz ve yeni sütunlardaki count y eksenine ve yeni age_group sütununu fill = argümanına (sütun iç kısmının rengi) atayabiliriz. Bu komut, çubuk grafikte yaş grubuna göre sıtma sayılarını gösterir:\n\nggplot(data = df_long) +\n  geom_col(\n    mapping = aes(x = data_date, y = counts, fill = age_group),\n    width = 1\n  )\n\n\n\n\n\n\n\n\nBu yeni grafiği inceleyin ve daha önce oluşturduğumuz grafikle karşılaştırın – Sizce yanlış giden ne?\nSürveyans verilerini incelerken yaygın bir sorunla karşılaştık: Grafikteki her çubuğun boyu olması gerekenin iki katıdır, çünkü grafiğe malaria_tot sütunundaki toplam sayıları da dahil ettik.\nBu sorunu birkaç şekilde halledebiliriz. ggplot()’a aktarmadan önce bu toplamları veri kümesinden filtreleyebiliriz:\n\ndf_long %&gt;% \n  filter(age_group != \"malaria_tot\") %&gt;% \n  ggplot() +\n  geom_col(\n    aes(x = data_date, y = counts, fill = age_group),\n    width = 1\n  )\n\n\n\n\n\n\n\n\nAlternatif olarak, pivot_longer()’ı çalıştırdığımızda bu değişkeni hariç tutabilirdik, böylece sorun oluşturan bu değişkeni ayrı bir değişken olarak veri kümesinde tutabilirdik. Değerlerin yeni satırları doldurmak için nasıl “genişlediğini” inceleyin.\n\ncount_data %&gt;% \n  pivot_longer(\n    cols = `malaria_rdt_0-4`:malaria_rdt_15,   # does not include the totals column\n    names_to = \"age_group\",\n    values_to = \"counts\"\n  )\n\n# A tibble: 9,114 × 9\n   location_name data_date  submitted_date Province District malaria_tot newid\n   &lt;chr&gt;         &lt;date&gt;     &lt;date&gt;         &lt;chr&gt;    &lt;chr&gt;          &lt;int&gt; &lt;int&gt;\n 1 Facility 1    2020-08-11 2020-08-12     North    Spring            46     1\n 2 Facility 1    2020-08-11 2020-08-12     North    Spring            46     1\n 3 Facility 1    2020-08-11 2020-08-12     North    Spring            46     1\n 4 Facility 2    2020-08-11 2020-08-12     North    Bolo              26     2\n 5 Facility 2    2020-08-11 2020-08-12     North    Bolo              26     2\n 6 Facility 2    2020-08-11 2020-08-12     North    Bolo              26     2\n 7 Facility 3    2020-08-11 2020-08-12     North    Dingo             18     3\n 8 Facility 3    2020-08-11 2020-08-12     North    Dingo             18     3\n 9 Facility 3    2020-08-11 2020-08-12     North    Dingo             18     3\n10 Facility 4    2020-08-11 2020-08-12     North    Bolo              49     4\n# ℹ 9,104 more rows\n# ℹ 2 more variables: age_group &lt;chr&gt;, counts &lt;int&gt;\n\n\n\n\nBirden çok sınıfa ait verinin pivotlanması\nYukarıdaki örnek, daha uzun şekilde pivotlamak istediğiniz tüm sütunların aynı sınıfta olduğu durumlarda (karakter, sayısal, mantıksal…) iyi çalışır.\nBununla birlikte, bir saha epidemiyoloğu olarak, bu konuda uzman olmayanlar tarafından hazırlanan ve standart dışı verilerle çalışacağınız birçok durum olacaktır - Hadley Wickham’ın Düzenli Veri ilkeleri üzerine ufuk açıcı makalesinde Tolstoy’a atıfta bulunarak belirttiği gibi “Düzenli veri kümelerinin hepsi birbirine benzer, ancak her dağınık veri kümesi kendi tarzında dağınıktır, aynı aileler gibi.”\nKarşılaşacağınız özellikle yaygın bir sorun, farklı veri sınıfları içeren sütunları döndürme ihtiyacı olacaktır. Bu pivot işlemi, farklı veri türlerinin tek bir sütunda depolanmasına neden olur ve bu durum istenmeyen bir sonuçtur. Bunun yarattığı karışıklığı ortadan kaldırmak için çeşitli yaklaşımlar vardır. Ancak bu duruma düşmemek için pivot_longer() kullanımında uygulanabilecek önemli bir adım vardır.\nA, B ve C öğelerinin her biri için farklı zamanlarda bir dizi gözlemin olduğu bir durumu ele alın. Bu öğeler örneğin farklı bireyler (örneğin 21 gün boyunca her gün bir Ebola vakasının temaslıları) veya hala çalışır durumda olduklarından emin olmak için yılda bir kez izlenen sağlık ocakları olabilir. Temaslı kişilerini izlemini ele alalım. Verilerin aşağıdaki gibi kaydedildiğini düşünelim:\n\n\n\n\n\n\nVerinin durumu başlangıçta karmaşıktır. Her satır, bir öğe hakkında veri içerir, ancak zaman serilerinde zamandaki ilerleme ile sütunlarda sağa doğru ilerleme izlenmektedir. Ayrıca, sütun sınıfları sırayla tarih ve karakter değerleri almaktadır.\nBu araştırmacının karşılaştığı kötü bir örnek, 4 yıl boyunca her gün 8 yeni gözlem sütununun eklendiği kolera sürveyans verilerini içeriyordu. Bu verilerin depolandığı Excel dosyasını açmak, dizüstü bilgisayarda 10 dakikan fazla zaman almıştır.\nBu verilerle çalışmak için, veri çerçevesini uzun biçime dönüştürmemiz, ancak her öğeye ait tüm gözlemler için date ve character (durum) sütunu arasındaki ayrımı korumamız gerekir. Bunu yapmazsak, tek bir sütunda değişken türleri karışık şekilde bulunur (Veri yönetimi ve düzenli veriler söz konusu olduğunda gerçekten istenmeyen bir durumdur):\n\ndf %&gt;% \n  pivot_longer(\n    cols = -id,\n    names_to = c(\"observation\")\n  )\n\n# A tibble: 18 × 3\n   id    observation value     \n   &lt;chr&gt; &lt;chr&gt;       &lt;chr&gt;     \n 1 A     obs1_date   2021-04-23\n 2 A     obs1_status Healthy   \n 3 A     obs2_date   2021-04-24\n 4 A     obs2_status Healthy   \n 5 A     obs3_date   2021-04-25\n 6 A     obs3_status Unwell    \n 7 B     obs1_date   2021-04-23\n 8 B     obs1_status Healthy   \n 9 B     obs2_date   2021-04-24\n10 B     obs2_status Healthy   \n11 B     obs3_date   2021-04-25\n12 B     obs3_status Healthy   \n13 C     obs1_date   2021-04-23\n14 C     obs1_status Missing   \n15 C     obs2_date   2021-04-24\n16 C     obs2_status Healthy   \n17 C     obs3_date   2021-04-25\n18 C     obs3_status Healthy   \n\n\nYukarıda, pivot komutu, tarihleri ve karakterleri tek bir değer sütununda birleştirdi. Bu durumda R, tüm sütunu sınıf karakterine dönüştür ve tarih özellikleri kaybolur.\nBu durumu önlemek için orijinal sütun adlarının sintaks yapısından yararlanabiliriz. Gözlem numarası, alt çizgi ve ardından “durum” veya “tarih” bilgisi içeren ortak bir adlandırma şeklini kullanmak faydalıdır. Pivot sonrası bu iki veri türünü ayrı sütunlarda tutmak için bu sintakstan yararlanabiliriz.\nBunu şu şekilde yapıyoruz:\n\nİkinci öğe (\".value\") olmak üzere, names_to = argümanına bir karakter vektörü yazmalısınız. Bu özel terim, pivot sütunlarının adlarındaki bir karaktere göre nasıl bölüneceğini belirtir.\nAyrıca, name_sep = argümanına “splitting-ayırma” karakterini de yazmalısınız. Bu durumda, ayırma karakteri alt çizgidir ( “_”)\n\nBu nedenle, yeni sütunların adlandırılması ve bölünmesi, mevcut değişken adlarındaki alt çizgiye göre gerçekleşir.\n\ndf_long &lt;- \n  df %&gt;% \n  pivot_longer(\n    cols = -id,\n    names_to = c(\"observation\", \".value\"),\n    names_sep = \"_\"\n  )\n\ndf_long\n\n# A tibble: 9 × 4\n  id    observation date       status \n  &lt;chr&gt; &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;  \n1 A     obs1        2021-04-23 Healthy\n2 A     obs2        2021-04-24 Healthy\n3 A     obs3        2021-04-25 Unwell \n4 B     obs1        2021-04-23 Healthy\n5 B     obs2        2021-04-24 Healthy\n6 B     obs3        2021-04-25 Healthy\n7 C     obs1        2021-04-23 Missing\n8 C     obs2        2021-04-24 Healthy\n9 C     obs3        2021-04-25 Healthy\n\n\nSon dokunuşlar:\nTarih sütununun şu anda character sınıfında olduğuna dikkat edin. [Tarihlerle çalışma] sayfasında açıklanan mutate() ve as_date() fonksiyonlarını kullanarak sınıfı kolayca uygun tarih sınıfına dönüştürebiliriz.\nAyrıca, “obs” ön ekini silerek observation sütununu sayısal bir biçime dönüştürmek isteyebiliriz. Bunu stringr paketinden str_remove_all() ile yapabiliriz ([Karakterler ve dizeler] sayfasına bakın).\n\ndf_long &lt;- \n  df_long %&gt;% \n  mutate(\n    date = date %&gt;% lubridate::as_date(),\n    observation = \n      observation %&gt;% \n      str_remove_all(\"obs\") %&gt;% \n      as.numeric()\n  )\n\ndf_long\n\n# A tibble: 9 × 4\n  id    observation date       status \n  &lt;chr&gt;       &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;  \n1 A               1 2021-04-23 Healthy\n2 A               2 2021-04-24 Healthy\n3 A               3 2021-04-25 Unwell \n4 B               1 2021-04-23 Healthy\n5 B               2 2021-04-24 Healthy\n6 B               3 2021-04-25 Healthy\n7 C               1 2021-04-23 Missing\n8 C               2 2021-04-24 Healthy\n9 C               3 2021-04-25 Healthy\n\n\nVe şimdi bu formattaki verilerle çalışmaya başlayabiliriz, örn. açıklayıcı bir ısı döşemesi çizerek:\n\nggplot(data = df_long, mapping = aes(x = date, y = id, fill = status)) +\n  geom_tile(colour = \"black\") +\n  scale_fill_manual(\n    values = \n      c(\"Healthy\" = \"lightgreen\", \n        \"Unwell\" = \"red\", \n        \"Missing\" = \"orange\")\n  )",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Verilerin pivotlanması</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.tr.html#uzundan-genişe",
    "href": "new_pages/pivoting.tr.html#uzundan-genişe",
    "title": "12  Verilerin pivotlanması",
    "section": "12.3 Uzundan genişe",
    "text": "12.3 Uzundan genişe\n\n\n\n\n\n\n\n\n\nBazı durumlarda, bir veri tabanını daha geniş bir formata dönüştürmek isteyebiliriz. Bunun için pivot_wider() fonksiyonunu kullanabiliriz.\nAnaliz sonuçlarını okuyucu için daha anlaşılır bir formata dönüştürmek istediğimiz zamandır (örneğin, [Sunum için bir tablo][Tables for presentation]), bu fonksiyonu. Genellikle bu işlem, bir gözlem için değerlerin birden çok satıra yayıldığı bir veri kümesinin, bu değerlerin tek bir satırda depolandığı bir formata dönüştürülmesini içerir.\n\nVeri\nSayfanın bu bölümü için, vaka başına bir satır içeren satır listesini kullanacağız (Hazırlık bölümüne bakın).\nİlk 50 satır:\n\n\n\n\n\n\nFarklı yaş gruplarındaki bireylerin sayısını cinsiyete göre bilmek istediğimizi varsayalım:\n\ndf_wide &lt;- \n  linelist %&gt;% \n  count(age_cat, gender)\n\ndf_wide\n\n   age_cat gender   n\n1      0-4      f 640\n2      0-4      m 416\n3      0-4   &lt;NA&gt;  39\n4      5-9      f 641\n5      5-9      m 412\n6      5-9   &lt;NA&gt;  42\n7    10-14      f 518\n8    10-14      m 383\n9    10-14   &lt;NA&gt;  40\n10   15-19      f 359\n11   15-19      m 364\n12   15-19   &lt;NA&gt;  20\n13   20-29      f 468\n14   20-29      m 575\n15   20-29   &lt;NA&gt;  30\n16   30-49      f 179\n17   30-49      m 557\n18   30-49   &lt;NA&gt;  18\n19   50-69      f   2\n20   50-69      m  91\n21   50-69   &lt;NA&gt;   2\n22     70+      m   5\n23     70+   &lt;NA&gt;   1\n24    &lt;NA&gt;   &lt;NA&gt;  86\n\n\nBu bize, ggplot2’de görselleştirme için harika, ancak tabloda sunum için ideal olmayan uzun bir veri tabanı sağlar:\n\nggplot(df_wide) +\n  geom_col(aes(x = age_cat, y = n, fill = gender))\n\n\n\n\n\n\n\n\n\n\nDaha geniş olarak pivotlama\nBu nedenle, verileri raporlara tablo olarak dahil etmek amaçlı olarak daha uygun biçime dönüştürmek için pivot_wider()’ı kullanabiliriz.\nname_from argümanı, yeni sütun adlarının oluşturulacağı names sütunu belirtirken; values_from argümanı, hücreleri doldurmak için gereken değerlerin alınacağı sütunu belirtir. id_cols = argümanı isteğe bağlıdır, ancak döndürülmemesi gereken satırları içeren sütun adları vektörünü içerir ..\n\ntable_wide &lt;- \n  df_wide %&gt;% \n  pivot_wider(\n    id_cols = age_cat,\n    names_from = gender,\n    values_from = n\n  )\n\ntable_wide\n\n# A tibble: 9 × 4\n  age_cat     f     m  `NA`\n  &lt;fct&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n1 0-4       640   416    39\n2 5-9       641   412    42\n3 10-14     518   383    40\n4 15-19     359   364    20\n5 20-29     468   575    30\n6 30-49     179   557    18\n7 50-69       2    91     2\n8 70+        NA     5     1\n9 &lt;NA&gt;       NA    NA    86\n\n\nBu tablo daha okuyucu dostudur ve bu nedenle raporlarımıza dahil edilmesi daha uygundur. Flextable ve knitr dahil olmak üzere çeşitli paketlerle güzel bir tablolar oluşturulabilir. Bu süreç [Sunum için tablolar] sayfasında daha detaylı olarak anlatılmıştır.\n\ntable_wide %&gt;% \n  janitor::adorn_totals(c(\"row\", \"col\")) %&gt;% # adds row and column totals\n  knitr::kable() %&gt;% \n  kableExtra::row_spec(row = 10, bold = TRUE) %&gt;% \n  kableExtra::column_spec(column = 5, bold = TRUE) \n\n\n\n\n\nage_cat\nf\nm\nNA\nTotal\n\n\n\n\n0-4\n640\n416\n39\n1095\n\n\n5-9\n641\n412\n42\n1095\n\n\n10-14\n518\n383\n40\n941\n\n\n15-19\n359\n364\n20\n743\n\n\n20-29\n468\n575\n30\n1073\n\n\n30-49\n179\n557\n18\n754\n\n\n50-69\n2\n91\n2\n95\n\n\n70+\nNA\n5\n1\n6\n\n\nNA\nNA\nNA\n86\n86\n\n\nTotal\n2807\n2803\n278\n5888",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Verilerin pivotlanması</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.tr.html#doldurma",
    "href": "new_pages/pivoting.tr.html#doldurma",
    "title": "12  Verilerin pivotlanması",
    "section": "12.4 Doldurma",
    "text": "12.4 Doldurma\nBazı durumlarda pivot işlemi sonrası ve daha yaygın olarak bir birleştirme sonrası, bazı hücrelerde doldurmak istediğimiz boşluklar kalır.\n\n\nVeri\nÖrneğin, ölçüm numarası, tesisin adı ve o andaki vaka sayısı için gözlemleri olan iki veri tabanını inceleyelim. Ancak, ikinci veri kümesinde ek olarak Year değişkeni vardır.\n\ndf1 &lt;- \n  tibble::tribble(\n       ~Measurement, ~Facility, ~Cases,\n                  1,  \"Hosp 1\",     66,\n                  2,  \"Hosp 1\",     26,\n                  3,  \"Hosp 1\",      8,\n                  1,  \"Hosp 2\",     71,\n                  2,  \"Hosp 2\",     62,\n                  3,  \"Hosp 2\",     70,\n                  1,  \"Hosp 3\",     47,\n                  2,  \"Hosp 3\",     70,\n                  3,  \"Hosp 3\",     38,\n       )\n\ndf1 \n\n# A tibble: 9 × 3\n  Measurement Facility Cases\n        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;\n1           1 Hosp 1      66\n2           2 Hosp 1      26\n3           3 Hosp 1       8\n4           1 Hosp 2      71\n5           2 Hosp 2      62\n6           3 Hosp 2      70\n7           1 Hosp 3      47\n8           2 Hosp 3      70\n9           3 Hosp 3      38\n\ndf2 &lt;- \n  tibble::tribble(\n    ~Year, ~Measurement, ~Facility, ~Cases,\n     2000,            1,  \"Hosp 4\",     82,\n     2001,            2,  \"Hosp 4\",     87,\n     2002,            3,  \"Hosp 4\",     46\n  )\n\ndf2\n\n# A tibble: 3 × 4\n   Year Measurement Facility Cases\n  &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;\n1  2000           1 Hosp 4      82\n2  2001           2 Hosp 4      87\n3  2002           3 Hosp 4      46\n\n\nİki veri kümesini birleştirmek için bir bind_rows() işlemi gerçekleştirdiğimizde, Year değişkeni, ön bilgi bulunmayan satırlar için (yani ilk veri kümesinde) NA ile doldurulur:\n\ndf_combined &lt;- \n  bind_rows(df1, df2) %&gt;% \n  arrange(Measurement, Facility)\n\ndf_combined\n\n# A tibble: 12 × 4\n   Measurement Facility Cases  Year\n         &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1           1 Hosp 1      66    NA\n 2           1 Hosp 2      71    NA\n 3           1 Hosp 3      47    NA\n 4           1 Hosp 4      82  2000\n 5           2 Hosp 1      26    NA\n 6           2 Hosp 2      62    NA\n 7           2 Hosp 3      70    NA\n 8           2 Hosp 4      87  2001\n 9           3 Hosp 1       8    NA\n10           3 Hosp 2      70    NA\n11           3 Hosp 3      38    NA\n12           3 Hosp 4      46  2002\n\n\n\n\n\nfill()\nBu durumda, özellikle zaman içindeki eğilimleri keşfetmek istiyorsak, yıl dahil etmek için yararlı bir değişkendir. Bu nedenle, doldurulacak sütunu ve doldurma yönünü (bu durumda yukarı) belirterek boş hücreleri doldurmak için fill() komutunu kullanırız:\n\ndf_combined %&gt;% \n  fill(Year, .direction = \"up\")\n\n# A tibble: 12 × 4\n   Measurement Facility Cases  Year\n         &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1           1 Hosp 1      66  2000\n 2           1 Hosp 2      71  2000\n 3           1 Hosp 3      47  2000\n 4           1 Hosp 4      82  2000\n 5           2 Hosp 1      26  2001\n 6           2 Hosp 2      62  2001\n 7           2 Hosp 3      70  2001\n 8           2 Hosp 4      87  2001\n 9           3 Hosp 1       8  2002\n10           3 Hosp 2      70  2002\n11           3 Hosp 3      38  2002\n12           3 Hosp 4      46  2002\n\n\nAlternatif olarak, verileri aşağı yönde dolduracak şekilde yeniden düzenleyebiliriz:\n\ndf_combined &lt;- \n  df_combined %&gt;% \n  arrange(Measurement, desc(Facility))\n\ndf_combined\n\n# A tibble: 12 × 4\n   Measurement Facility Cases  Year\n         &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1           1 Hosp 4      82  2000\n 2           1 Hosp 3      47    NA\n 3           1 Hosp 2      71    NA\n 4           1 Hosp 1      66    NA\n 5           2 Hosp 4      87  2001\n 6           2 Hosp 3      70    NA\n 7           2 Hosp 2      62    NA\n 8           2 Hosp 1      26    NA\n 9           3 Hosp 4      46  2002\n10           3 Hosp 3      38    NA\n11           3 Hosp 2      70    NA\n12           3 Hosp 1       8    NA\n\ndf_combined &lt;- \n  df_combined %&gt;% \n  fill(Year, .direction = \"down\")\n\ndf_combined\n\n# A tibble: 12 × 4\n   Measurement Facility Cases  Year\n         &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1           1 Hosp 4      82  2000\n 2           1 Hosp 3      47  2000\n 3           1 Hosp 2      71  2000\n 4           1 Hosp 1      66  2000\n 5           2 Hosp 4      87  2001\n 6           2 Hosp 3      70  2001\n 7           2 Hosp 2      62  2001\n 8           2 Hosp 1      26  2001\n 9           3 Hosp 4      46  2002\n10           3 Hosp 3      38  2002\n11           3 Hosp 2      70  2002\n12           3 Hosp 1       8  2002\n\n\nArtık görselleştirmek için kullanışlı bir veri setimiz var:\n\nggplot(df_combined) +\n  aes(Year, Cases, fill = Facility) +\n  geom_col()\n\n\n\n\n\n\n\n\nAncak bu form tablo halinde sunmak için daha az kullanışlıdır, bu yüzden uzun, düzensiz veri çerçevesini daha geniş, düzenli bir veri çerçevesine dönüştürme alıştırması yapalım:\n\ndf_combined %&gt;% \n  pivot_wider(\n    id_cols = c(Measurement, Facility),\n    names_from = \"Year\",\n    values_from = \"Cases\"\n  ) %&gt;% \n  arrange(Facility) %&gt;% \n  janitor::adorn_totals(c(\"row\", \"col\")) %&gt;% \n  knitr::kable() %&gt;% \n  kableExtra::row_spec(row = 5, bold = TRUE) %&gt;% \n  kableExtra::column_spec(column = 5, bold = TRUE) \n\n\n\n\n\nMeasurement\nFacility\n2000\n2001\n2002\nTotal\n\n\n\n\n1\nHosp 1\n66\nNA\nNA\n66\n\n\n2\nHosp 1\nNA\n26\nNA\n26\n\n\n3\nHosp 1\nNA\nNA\n8\n8\n\n\n1\nHosp 2\n71\nNA\nNA\n71\n\n\n2\nHosp 2\nNA\n62\nNA\n62\n\n\n3\nHosp 2\nNA\nNA\n70\n70\n\n\n1\nHosp 3\n47\nNA\nNA\n47\n\n\n2\nHosp 3\nNA\n70\nNA\n70\n\n\n3\nHosp 3\nNA\nNA\n38\n38\n\n\n1\nHosp 4\n82\nNA\nNA\n82\n\n\n2\nHosp 4\nNA\n87\nNA\n87\n\n\n3\nHosp 4\nNA\nNA\n46\n46\n\n\nTotal\n-\n266\n245\n162\n673\n\n\n\n\n\n\n\n\nNot: Bu durumda, ek değişken olan “ölçüm” tablonun oluşturulmasına engel olacağından, yalnızca Facility, Year ve Cases değişkenleri dahil edilmelidir:\n\ndf_combined %&gt;% \n  pivot_wider(\n    names_from = \"Year\",\n    values_from = \"Cases\"\n  ) %&gt;% \n  knitr::kable()\n\n\n\n\nMeasurement\nFacility\n2000\n2001\n2002\n\n\n\n\n1\nHosp 4\n82\nNA\nNA\n\n\n1\nHosp 3\n47\nNA\nNA\n\n\n1\nHosp 2\n71\nNA\nNA\n\n\n1\nHosp 1\n66\nNA\nNA\n\n\n2\nHosp 4\nNA\n87\nNA\n\n\n2\nHosp 3\nNA\n70\nNA\n\n\n2\nHosp 2\nNA\n62\nNA\n\n\n2\nHosp 1\nNA\n26\nNA\n\n\n3\nHosp 4\nNA\nNA\n46\n\n\n3\nHosp 3\nNA\nNA\n38\n\n\n3\nHosp 2\nNA\nNA\n70\n\n\n3\nHosp 1\nNA\nNA\n8",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Verilerin pivotlanması</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.tr.html#kaynaklar",
    "href": "new_pages/pivoting.tr.html#kaynaklar",
    "title": "12  Verilerin pivotlanması",
    "section": "12.5 Kaynaklar",
    "text": "12.5 Kaynaklar\nYararlı bir eğitim",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Verilerin pivotlanması</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.tr.html",
    "href": "new_pages/grouping.tr.html",
    "title": "13  Verileri Gruplama",
    "section": "",
    "text": "13.1 Hazırlık",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Verileri Gruplama</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.tr.html#hazırlık",
    "href": "new_pages/grouping.tr.html#hazırlık",
    "title": "13  Verileri Gruplama",
    "section": "",
    "text": "Paketleri yükleyin\nBu kod parçası, analizler için gereken paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() vurgusunu yapıyoruz. R tabanından library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R basics sayfasına bakabilirsiniz.\n\npacman::p_load(\n  rio,       # verileri içe aktarma\n  here,      # dosyaları konumlama\n  tidyverse, # veriyi temizleme, işleme ve grafikleştirme (dplyr dahil)\n  janitor)   # toplam satır ve süruna ekleme yapma\n\n\n\nVerileri içe aktar\nSimüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Takip etmek isterseniz, “clean” dosyasını indirmek için tıklayın (.rds dosyası olarak). Veri kümesi, rio paketinden import() fonksiyonu kullanılarak içe aktarılır. Verileri içe aktarmanın çeşitli yolları için İçe ve dışa aktar hakkındaki sayfaya bakın.\n\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\n“linelist”in ilk 50 satırı:",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Verileri Gruplama</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.tr.html#gruplandırma",
    "href": "new_pages/grouping.tr.html#gruplandırma",
    "title": "13  Verileri Gruplama",
    "section": "13.2 Gruplandırma",
    "text": "13.2 Gruplandırma\ndplyr’den group_by() fonsiyonu, satırları kendisine belirtilen sütundaki benzersiz değerlere göre gruplandırır. Birden çok sütun belirtilirse, satırlar sütunlar boyunca benzersiz değer kombinasyonlarına göre gruplanır. Her benzersiz değer (veya değer kombinasyonu) bir grup oluşturur. Veri kümesinde veya hesaplamalarda sonraki değişiklikler daha sonra her grup bağlamında gerçekleştirilebilir.\nÖrneğin, aşağıdaki komut “linelist”i alır ve satırları “outcome” sütunundaki benzersiz değerlere göre gruplayarak çıktıyı yeni bir “ll_by_outcome” veri çerçevesi olarak kaydeder. Gruplandırma sütunu/sütunları, ‘group_by()’ fonksiyonunun parantezlerin içine yerleştirilir.\n\nll_by_outcome &lt;- linelist %&gt;% \n  group_by(outcome)\n\nVeri kümesinde algılanabilir bir değişiklik olmadığını unutmayın group_by() çalıştırıldıktan sonra, mutate(), summarise() veya arrange() gibi başka bir dplyr fiili “gruplandırılmış” veri çerçevesine kadar uygulanır.\nBununla birlikte, veri çerçevesini yazdırarak gruplamaları “görebilirsiniz”. Gruplandırılmış bir veri çerçevesi yazdırdığınızda, bunun yazdırıldığında hangi gruplamaların uygulandığını ve kaç tane olduğunu gösteren bir tibble sınıf nesnesine dönüştürüldüğünü göreceksiniz - başlık satırının hemen üstüne yazılır.\n\n# hangi grupların aktif olduğunu görmek için yazdır\nll_by_outcome\n\n# A tibble: 5,888 × 30\n# Groups:   outcome [3]\n   case_id generation date_infection date_onset date_hospitalisation\n   &lt;chr&gt;        &lt;dbl&gt; &lt;date&gt;         &lt;date&gt;     &lt;date&gt;              \n 1 5fe599           4 2014-05-08     2014-05-13 2014-05-15          \n 2 8689b7           4 NA             2014-05-13 2014-05-14          \n 3 11f8ea           2 NA             2014-05-16 2014-05-18          \n 4 b8812a           3 2014-05-04     2014-05-18 2014-05-20          \n 5 893f25           3 2014-05-18     2014-05-21 2014-05-22          \n 6 be99c8           3 2014-05-03     2014-05-22 2014-05-23          \n 7 07e3e8           4 2014-05-22     2014-05-27 2014-05-29          \n 8 369449           4 2014-05-28     2014-06-02 2014-06-03          \n 9 f393b4           4 NA             2014-06-05 2014-06-06          \n10 1389ca           4 NA             2014-06-05 2014-06-07          \n# ℹ 5,878 more rows\n# ℹ 25 more variables: date_outcome &lt;date&gt;, outcome &lt;chr&gt;, gender &lt;chr&gt;,\n#   age &lt;dbl&gt;, age_unit &lt;chr&gt;, age_years &lt;dbl&gt;, age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;,\n#   hospital &lt;chr&gt;, lon &lt;dbl&gt;, lat &lt;dbl&gt;, infector &lt;chr&gt;, source &lt;chr&gt;,\n#   wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;, ct_blood &lt;dbl&gt;, fever &lt;chr&gt;, chills &lt;chr&gt;,\n#   cough &lt;chr&gt;, aches &lt;chr&gt;, vomit &lt;chr&gt;, temp &lt;dbl&gt;, time_admission &lt;chr&gt;,\n#   bmi &lt;dbl&gt;, days_onset_hosp &lt;dbl&gt;\n\n\n\nBenzersiz gruplar\nOluşturulan gruplar, gruplandırma sütunlarında her benzersiz değer kombinasyonunu yansıtır.\nGrupları ve her gruptaki satır sayısını görmek için gruplanmış verileri ‘tally()’ öğesine iletin. Sadece benzersiz, sayısız grupları görmek için group_keys() öğesine geçebilirsiniz.\nAşağıda, “sonuç” gruplandırma sütununda üç benzersiz değer olduğunu görün: “Ölüm”, “İyileşme” ve “NA”. nrow(linelist %&gt;% filter(outcome == \"Death\")) ölümler, nrow(linelist %&gt;% filter(outcome == \"Recover\")) ve nrow(linelist %) olduğunu görün &gt;% filter(is.na(outcome)))` hiçbir sonuç kaydedilmedi.\n\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  tally()\n\n# A tibble: 3 × 2\n  outcome     n\n  &lt;chr&gt;   &lt;int&gt;\n1 Death    2582\n2 Recover  1983\n3 &lt;NA&gt;     1323\n\n\nBirden fazla sütuna göre gruplandırabilirsiniz. Aşağıda, veri çerçevesi “sonuç” ve “cinsiyet”e göre gruplandırılır ve ardından hesaplanır. “Sonuç” ve “cinsiyet”in her benzersiz kombinasyonunun kendi grubu olarak nasıl kaydedildiğine dikkat edin - her iki sütun için de eksik değerler dahil edilmektedir.\n\nlinelist %&gt;% \n  group_by(outcome, gender) %&gt;% \n  tally()\n\n# A tibble: 9 × 3\n# Groups:   outcome [3]\n  outcome gender     n\n  &lt;chr&gt;   &lt;chr&gt;  &lt;int&gt;\n1 Death   f       1227\n2 Death   m       1228\n3 Death   &lt;NA&gt;     127\n4 Recover f        953\n5 Recover m        950\n6 Recover &lt;NA&gt;      80\n7 &lt;NA&gt;    f        627\n8 &lt;NA&gt;    m        625\n9 &lt;NA&gt;    &lt;NA&gt;      71\n\n\n\n\nYeni sütunlar\nAyrıca, “group_by()” ifadesinin içinde yeni bir gruplandırma sütunu da oluşturabilirsiniz. Bu, ‘group_by()’dan önce ’mutate()’ çağrısına eşdeğerdir. Hızlı bir tablolama için bu stil kullanışlı olabilir, ancak kodunuzda daha fazla netlik için bu sütunu kendi mutate() adımında oluşturmayı ve ardından group_by() ile bağlantı kurmayı düşünün.\n\n# group_by() komut satırı listesi %&gt;% *içinde* oluşturulan bir ikili sütuna dayalı grup verileri\nlinelist %&gt;% \n     group_by(\n          age_class = ifelse(age &gt;= 18, \"adult\", \"child\")) %&gt;% \n     tally(sort = T)\n\n# A tibble: 3 × 2\n  age_class     n\n  &lt;chr&gt;     &lt;int&gt;\n1 child      3618\n2 adult      2184\n3 &lt;NA&gt;         86\n\n\n\n\nGruplandırma sütunlarını ekle/bırak\nVarsayılan olarak, zaten gruplanmış veriler üzerinde group_by() çalıştırırsanız, eski gruplar kaldırılacak ve yenileri uygulanacaktır. Mevcut gruplara yeni gruplar eklemek istiyorsanız, .add = TRUE değişkenini ekleyin.\n\n# Çıktıya göre gruplama\nby_outcome &lt;- linelist %&gt;% \n  group_by(outcome)\n\n# İlave olarak cinsiyet olarak gruplama eklemesi\nby_outcome_gender &lt;- by_outcome %&gt;% \n  group_by(gender, .add = TRUE)\n\n** Tüm grupları tut**\nBir sınıf faktörü sütununda gruplandırırsanız, şu anda verilerde mevcut olmayan faktör seviyeleri olabilir. Bu sütunda gruplandırırsanız, varsayılan olarak mevcut olmayan seviyeler bırakılır ve grup olarak dahil edilmez. Bunu, tüm seviyelerin gruplar halinde görüneceği şekilde değiştirmek için (verilerde mevcut olmasa bile), group_by() komutunuzda .drop = FALSE değerini ayarlayın.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Verileri Gruplama</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.tr.html#grubu-kaldır",
    "href": "new_pages/grouping.tr.html#grubu-kaldır",
    "title": "13  Verileri Gruplama",
    "section": "13.3 Grubu kaldır",
    "text": "13.3 Grubu kaldır\nGruplandırılmış veriler, ‘ungroup()’ aracılığıyla özellikle işlenene kadar gruplanmış olarak kalacaktır. Grubu çözmeyi unutursanız, yanlış hesaplamalara yol açabilir! Aşağıda tüm gruplamaların kaldırılmasına ilişkin bir örnek verilmiştir:\n\nlinelist %&gt;% \n  group_by(outcome, gender) %&gt;% \n  tally() %&gt;% \n  ungroup()\n\nAyrıca, sütun adını “ungroup()” içine yerleştirerek yalnızca belirli sütunlar için gruplamayı kaldırabilirsiniz.\n\nlinelist %&gt;% \n  group_by(outcome, gender) %&gt;% \n  tally() %&gt;% \n  ungroup(gender) # cinsiyete göre gruplamayı kaldır, sonuca göre gruplamayı bırak\n\nNOT: count() fiili saydıktan sonra verilerin grubunu otomatik olarak çözer.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Verileri Gruplama</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.tr.html#group_summarise",
    "href": "new_pages/grouping.tr.html#group_summarise",
    "title": "13  Verileri Gruplama",
    "section": "13.4 Özetleme",
    "text": "13.4 Özetleme\nÖzet tablolarının “summarise()” ile nasıl oluşturulacağına ilişkin ayrıntılı bir açıklama için [Tanımlayıcı tablolar] sayfasının dplyr bölümüne bakın. Burada, gruplandırılmış verilere uygulandığında davranışının nasıl değiştiğini kısaca ele alıyoruz.\ndplyr fonksiyonusummarise() (veya summarize()) bir veri çerçevesi alır ve onu tanımladığınız özet istatistikleri içeren sütunlarla birlikte yeni bir özet veri çerçevesine dönüştürür. Gruplandırılmamış bir veri çerçevesinde, tüm satırlardan özet istatistikler hesaplanacaktır. Gruplandırılmış verilere ‘summarise()’ uygulamak, her grup için bu özet istatistikleri üretir.\nsummarise() sözdizimi, yeni özet sütun(lar)ının adlarını, bir eşittir işaretini ve ardından aşağıda gösterildiği gibi verilere uygulanacak istatistiksel bir fonksiyon sağlayacak şekildedir. Örneğin, “min()”, “max()”, “median()” veya “sd()”. İstatistiksel fonksiyon içinde, üzerinde çalışılacak sütunu ve ilgili herhangi bir değişkeni listeleyebilir (ör. “na.rm = TRUE”). Mantıksal bir ölçütü karşılayan satırların sayısını saymak için sum() kullanabilirsiniz (çift eşittir == ile).\nAşağıda, gruplandırılmış veriler olmadan uygulanan bir summarise() örneği verilmiştir. Döndürülen istatistikler, tüm veri kümesinden üretilir.\n\n# gruplandırılmamış satır listesindeki özet istatistikler\nlinelist %&gt;% \n  summarise(\n    n_cases  = n(),\n    mean_age = mean(age_years, na.rm=T),\n    max_age  = max(age_years, na.rm=T),\n    min_age  = min(age_years, na.rm=T),\n    n_males  = sum(gender == \"m\", na.rm=T))\n\n  n_cases mean_age max_age min_age n_males\n1    5888 16.01831      84       0    2803\n\n\nBuna karşılık, aşağıda gruplanmış verilere uygulanan aynı “summarise()” ifadesi yer almaktadır. İstatistikler, her bir “sonuç” grubu için hesaplanır. Gruplandırma sütunlarının yeni veri çerçevesine nasıl taşınacağına dikkat edin.\n\n# gruplandırılmış satır listesindeki özet istatistikler\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  summarise(\n    n_cases  = n(),\n    mean_age = mean(age_years, na.rm=T),\n    max_age  = max(age_years, na.rm=T),\n    min_age  = min(age_years, na.rm=T),\n    n_males    = sum(gender == \"m\", na.rm=T))\n\n# A tibble: 3 × 6\n  outcome n_cases mean_age max_age min_age n_males\n  &lt;chr&gt;     &lt;int&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;int&gt;\n1 Death      2582     15.9      76       0    1228\n2 Recover    1983     16.1      84       0     950\n3 &lt;NA&gt;       1323     16.2      69       0     625\n\n\nİPUCU: TÖzetleme işlevi hem Birleşik Krallık hem de ABD yazımıyla çalışır - summarise() ve summarize() aynı fonksiyonu çağırır.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Verileri Gruplama</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.tr.html#sayımlar-ve-seriler",
    "href": "new_pages/grouping.tr.html#sayımlar-ve-seriler",
    "title": "13  Verileri Gruplama",
    "section": "13.5 Sayımlar ve seriler",
    "text": "13.5 Sayımlar ve seriler\ncount() ve tally() benzer işlevsellik sağlar ancak farklıdır. “tally()” ve “count()” arasındaki fark hakkında daha fazla bilgiyi buradan okuyabilirsiniz.\n\ntally()\n“tally()”, “summarise(n = n())” ifadesinin kısaltmasıdır ve verileri gruplandırmaz. Bu nedenle, gruplandırılmış çetelelere ulaşmak için bir ‘group_by()’ komutunu izlemesi gerekir. Önce en büyük grupları görmek için sort = TRUE ekleyebilirsiniz.\n\nlinelist %&gt;% \n  tally()\n\n     n\n1 5888\n\n\n\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  tally(sort = TRUE)\n\n# A tibble: 3 × 2\n  outcome     n\n  &lt;chr&gt;   &lt;int&gt;\n1 Death    2582\n2 Recover  1983\n3 &lt;NA&gt;     1323\n\n\n\n\ncount()\nBuna karşılık, “count()” şunları yapar:\n\nbelirtilen sütun(lar)a group_by() uygular\n“summarise()” uygular ve grup başına satır sayısıyla “n” sütununu döndürür\nungroup() uygular\n\n\nlinelist %&gt;% \n  count(outcome)\n\n  outcome    n\n1   Death 2582\n2 Recover 1983\n3    &lt;NA&gt; 1323\n\n\nTıpkı ‘group_by()’ ile olduğu gibi, ‘count()’ komutu için de yeni bir sütun oluşturabilirsiniz:\n\nlinelist %&gt;% \n  count(age_class = ifelse(age &gt;= 18, \"adult\", \"child\"), sort = T)\n\n  age_class    n\n1     child 3618\n2     adult 2184\n3      &lt;NA&gt;   86\n\n\ncount(), “yuvarlama”nın kullanışlılığı ile birden çok kez çağrılabilir. Örneğin, her bir cinsiyet için mevcut hastanelerin sayısını özetlemek için aşağıdakileri çalıştırın. Son sütunun adının, netlik için varsayılan “n” yerine değiştirildiğini unutmayın (name = ile).\n\nlinelist %&gt;% \n  # benzersiz sonuç-cinsiyet gruplarına göre sayımlar üretmek\n  count(gender, hospital) %&gt;% \n  #cinsiyete göre satırları toplayın (3) ve cinsiyete göre hastane sayısını sayın (6)\n  count(gender, name = \"hospitals per gender\" ) \n\n  gender hospitals per gender\n1      f                    6\n2      m                    6\n3   &lt;NA&gt;                    6\n\n\n\n\nSayıları ekle\n‘count()’ ve ‘summarise()’in aksine, diğer tüm veri çerçevesi sütunlarını korurken grup başına satır sayısıyla yeni bir ’n’ sütunu eklemek için ‘add_count()’ kullanabilirsiniz.\nBu, yeni n sütunundaki bir grubun sayım numarasının grubun her satırına yazdırılacağı anlamına gelir. Gösteri amacıyla, bu sütunu ekliyoruz ve daha sonra daha kolay görüntüleme için sütunları yeniden düzenliyoruz. Başka bir örnek için aşağıdaki grup boyutuna göre filtrele bölümüne bakabilirsiniz.\n\nlinelist %&gt;% \n  as_tibble() %&gt;%                   # daha güzel baskı için tibble'a dönüştürün\n  add_count(hospital) %&gt;%           # hastaneye göre sayılarla n sütunu ekle\n  select(hospital, n, everything()) # demo amaçlı yeniden düzenlemek\n\n# A tibble: 5,888 × 31\n   hospital                       n case_id generation date_infection date_onset\n   &lt;chr&gt;                      &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt; &lt;date&gt;         &lt;date&gt;    \n 1 Other                        885 5fe599           4 2014-05-08     2014-05-13\n 2 Missing                     1469 8689b7           4 NA             2014-05-13\n 3 St. Mark's Maternity Hosp…   422 11f8ea           2 NA             2014-05-16\n 4 Port Hospital               1762 b8812a           3 2014-05-04     2014-05-18\n 5 Military Hospital            896 893f25           3 2014-05-18     2014-05-21\n 6 Port Hospital               1762 be99c8           3 2014-05-03     2014-05-22\n 7 Missing                     1469 07e3e8           4 2014-05-22     2014-05-27\n 8 Missing                     1469 369449           4 2014-05-28     2014-06-02\n 9 Missing                     1469 f393b4           4 NA             2014-06-05\n10 Missing                     1469 1389ca           4 NA             2014-06-05\n# ℹ 5,878 more rows\n# ℹ 25 more variables: date_hospitalisation &lt;date&gt;, date_outcome &lt;date&gt;,\n#   outcome &lt;chr&gt;, gender &lt;chr&gt;, age &lt;dbl&gt;, age_unit &lt;chr&gt;, age_years &lt;dbl&gt;,\n#   age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;, lon &lt;dbl&gt;, lat &lt;dbl&gt;, infector &lt;chr&gt;,\n#   source &lt;chr&gt;, wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;, ct_blood &lt;dbl&gt;, fever &lt;chr&gt;,\n#   chills &lt;chr&gt;, cough &lt;chr&gt;, aches &lt;chr&gt;, vomit &lt;chr&gt;, temp &lt;dbl&gt;,\n#   time_admission &lt;chr&gt;, bmi &lt;dbl&gt;, days_onset_hosp &lt;dbl&gt;\n\n\n\n\nToplamları ekle\n“tally()” veya “count()” kullandıktan sonra toplam sum satırlarını veya sütunlarını kolayca eklemek için Tanımlayıcı tablolar sayfasının janitor bölümüne bakın. Bu paket, toplamları eklemek ve yüzdeleri göstermek için dönüştürmek için ‘adorn_totals()’ ve ‘adorn_percentages()’ gibi fonksiyonlar sunar. Aşağıda kısa bir örnek verilmiştir:\n\nlinelist %&gt;%                                  # vaka satır listesi \n  tabyl(age_cat, gender) %&gt;%                  # iki sütunun çapraz tablo sayımları\n  adorn_totals(where = \"row\") %&gt;%             # toplam satır ekle\n  adorn_percentages(denominator = \"col\") %&gt;%  # sütun paydası ile oranlara dönüştürme\n  adorn_pct_formatting() %&gt;%                  # oranları yüzdelere çevir\n  adorn_ns(position = \"front\") %&gt;%            # \"count (percent)\" olarak göster\n  adorn_title(                                # başlıkları ayarla\n    row_name = \"Age Category\",\n    col_name = \"Gender\")\n\n                      Gender                            \n Age Category              f              m          NA_\n          0-4   640  (22.8%)   416  (14.8%)  39  (14.0%)\n          5-9   641  (22.8%)   412  (14.7%)  42  (15.1%)\n        10-14   518  (18.5%)   383  (13.7%)  40  (14.4%)\n        15-19   359  (12.8%)   364  (13.0%)  20   (7.2%)\n        20-29   468  (16.7%)   575  (20.5%)  30  (10.8%)\n        30-49   179   (6.4%)   557  (19.9%)  18   (6.5%)\n        50-69     2   (0.1%)    91   (3.2%)   2   (0.7%)\n          70+     0   (0.0%)     5   (0.2%)   1   (0.4%)\n         &lt;NA&gt;     0   (0.0%)     0   (0.0%)  86  (30.9%)\n        Total 2,807 (100.0%) 2,803 (100.0%) 278 (100.0%)\n\n\nToplamlar dışında özet istatistikleri içeren daha karmaşık ‘sums’ satırları eklemek için Tanımlayıcı Tablolar sayfasının bu bölümüne bakabilirsiniz.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Verileri Gruplama</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.tr.html#tarihe-göre-gruplama",
    "href": "new_pages/grouping.tr.html#tarihe-göre-gruplama",
    "title": "13  Verileri Gruplama",
    "section": "13.6 Tarihe göre gruplama",
    "text": "13.6 Tarihe göre gruplama\nVerileri tarihe göre gruplarken, ilgilenilen tarih birimi için bir sütuna sahip olmalısınız (veya oluşturmalısınız) (örneğin “gün”, “epiweek”, “ay”, vb.) lubridate’den ‘floor_date()’ kullanarak bu sütunu oluşturabilirsiniz. [Tarihlerle çalışma] sayfasının Epidemiyolojik haftalar bölümünde açıklandığı gibi. Bu sütuna sahip olduğunuzda, satırları bu benzersiz tarih değerlerine göre gruplandırmak ve toplam sayıları elde etmek için dplyr’den count() kullanabilirsiniz.\nTarih durumları için ortak bir ek adım, dizide verilerde mevcut olmayan tüm tarihleri ​​“doldurmaktır”. tidyr’den ‘complete()’ kullanın, böylece aralık içindeki tüm olası tarih birimleri dahil olmak üzere toplu tarih serisi tamamlanır. Bu adım olmadan, hiçbir vakanın bildirilmediği bir hafta verilerinizde görünmeyebilir!\n‘complete()’ içinde, tarih sütununuzu minimumdan maksimuma ‘seq.Date()’ tarihlerinin bir dizisi olarak yeniden tanımlarsınız. Böylece tarihler genişletilir. Varsayılan olarak, herhangi bir yeni “genişletilmiş” satırdaki büyük/küçük harf sayısı değerleri “NA” olacaktır. Adlandırılmış bir liste bekleyen ‘complete()’ öğesinin ‘fill =’ değişkenini kullanarak bunları 0’a ayarlayabilirsiniz (sayımlar sütununuz ‘n’ olarak adlandırılmışsa, ‘fill = list(n = 0)’ sağlayın. Ayrıntılar için ?complete’ komutuna ve örnek için Tarihlerle çalışma sayfasına bakabilirsiniz.\n\nGünlere göre satır listesi vakaları\nBurada, “complete()” kullanılmadan ​günlere göre gruplandırma örneği verilmiştir. İlk satırların hiçbir durum olmadan tarihleri atladığını unutmayın.\n\ndaily_counts &lt;- linelist %&gt;% \n  drop_na(date_onset) %&gt;%        # date_onset eksik olanları kaldırın\n  count(date_onset)              # benzersiz tarih başına satır sayısını say\n\n\n\n\n\n\n\nAşağıda, aralıktaki her günün temsil edilmesini sağlamak için complete() komutunu ekliyoruz.\n\ndaily_counts &lt;- linelist %&gt;% \n  drop_na(date_onset) %&gt;%                 # date_onset eksik vakayı kaldır\n  count(date_onset) %&gt;%                   # benzersiz tarih başına satır sayısını say\n  complete(                               # hiçbir vaka olmasa bile tüm günlerin görünmesini sağlayın\n    date_onset = seq.Date(                # tarih sütununu günlük tarih dizisi olarak yeniden tanımlayın\n      from = min(date_onset, na.rm=T), \n      to = max(date_onset, na.rm=T),\n      by = \"day\"),\n    fill = list(n = 0))                   # yeni doldurulmuş satırları n sütununda 0 gösterecek şekilde ayarla (varsayılan olarak NA değil) \n\n\n\n\n\n\n\n\n\nHaftalara bölünmüş satır listesi vakaları\nAynı prensip haftalarca uygulanabilir. İlk önce, unit = \"hafta\" ile floor_date() kullanarak vakanın haftası olan yeni bir sütun oluşturun. Ardından, haftalık vaka sayılarına ulaşmak için yukarıdaki gibi count() kullanın. Hiçbir vaka içermeseler bile tüm haftaların temsil edildiğinden emin olmak için “complete()” ile bitirin.\n\n# Haftalık vaka sayımlarının veri setini yapın\nweekly_counts &lt;- linelist %&gt;% \n  drop_na(date_onset) %&gt;%                 # date_onset eksik vakaları kaldırın\n  mutate(week = lubridate::floor_date(date_onset, unit = \"week\")) %&gt;%  # başlangıç haftasının yeni sütunu\n  count(week) %&gt;%                         # verileri haftaya göre gruplandır ve grup başına satırları say\n  complete(                               # hiçbir vaka olmasa bile tüm günlerin görünmesini sağlayın\n    week = seq.Date(                      # tarih sütununu günlük tarih dizisi olarak yeniden tanımlayın\n      from = min(week, na.rm=T), \n      to = max(week, na.rm=T),\n      by = \"week\"),\n    fill = list(n = 0))                   # yeni doldurulmuş satırları n sütununda 0 gösterecek şekilde ayarla (varsayılan olarak NA değil)\n\nOrtaya çıkan veri çerçevesinin ilk 50 satırı:\n\n\n\n\n\n\n\n\nAylara ayrılmış satır listesi vakaları\nVakaları aylara toplamak için, yine lubridate paketinden ‘floor_date()’ kullanın, ancak ‘unit= “months”’ bağımsız değişkeni ile. Bu, her tarihi ayın 1’ine yuvarlar. Çıktı, Date sınıfı olacaktır. complete() adımında by = \"aylar\" ifadesini de kullandığımızı unutmayın.\n\n# Aylık vaka sayımlarının veri setini yapın\nmonthly_counts &lt;- linelist %&gt;% \n  drop_na(date_onset) %&gt;% \n  mutate(month = lubridate::floor_date(date_onset, unit = \"months\")) %&gt;%  # yeni sütun, başlangıcın 1. ayı\n  count(month) %&gt;%                          # vakaları aya göre saymak\n  complete(\n    month = seq.Date(\n      min(month, na.rm=T),     # hiçbir vakanın bildirilmediği tüm ayları dahil et\n      max(month, na.rm=T),\n      by=\"month\"),\n    fill = list(n = 0))\n\n\n\n\n\n\n\n\n\nHaftalara göre günlük sayım\nGünlük sayıları haftalık sayımlarda toplamak için yukarıdaki gibi floor_date() kullanın. Ancak, “count()” yerine “group_by()” ve “summarize()” kullanın, çünkü yalnızca haftalık satır sayısını saymak yerine günlük vaka sayılarını “sum()” yapmanız gerekir.\n\nAylara göre günlük sayımlar\nGünlük sayıları ay sayılarına toplamak için, yukarıdaki gibi “unit =”month”” ile “floor_date()” kullanın. Ancak, ‘count()’ yerine ‘group_by()’ ve ‘summarize()’ kullanın çünkü sadece aylık satır sayısını saymak yerine günlük vaka sayılarını ‘sum()’ yapmanız gerekir.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Verileri Gruplama</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.tr.html#gruplandırılmış-verileri-düzenleme",
    "href": "new_pages/grouping.tr.html#gruplandırılmış-verileri-düzenleme",
    "title": "13  Verileri Gruplama",
    "section": "13.7 Gruplandırılmış verileri düzenleme",
    "text": "13.7 Gruplandırılmış verileri düzenleme\nBir veri çerçevesindeki satırları sıralamak için dplyr fiilinin “arrange()” kullanılması, “.by_group =TRUE” bağımsız değişkenini ayarlamadığınız sürece, veriler gruplandığında aynı şekilde davranır. Bu durumda, satırlar önce gruplandırma sütunlarına ve ardından ‘arrange()’ için belirttiğiniz diğer sütunlara göre sıralanır.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Verileri Gruplama</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.tr.html#gruplandırılmış-verilere-filtre-uygula",
    "href": "new_pages/grouping.tr.html#gruplandırılmış-verilere-filtre-uygula",
    "title": "13  Verileri Gruplama",
    "section": "13.8 Gruplandırılmış verilere filtre uygula",
    "text": "13.8 Gruplandırılmış verilere filtre uygula\n\nfiltre()\nVeri çerçevesini değerlendiren işlevlerle birlikte uygulandığında (‘max()’, ‘min()’, ‘mean()’ gibi), bu fonksiyonlar artık gruplara uygulanacaktır. Örneğin, hastaların medyan yaşın üzerinde olduğu satırları filtrelemek ve tutmak istiyorsanız, bu artık her grup için geçerli olacaktır - satırları grubun medyan yaşının üzerinde tutmak için filtreleyin.\n\n\nGrup başına satırları dilimleyin\nVerilerdeki satırları konumlarına göre filtreleyen dplyr slice() fonksiyonu da grup başına uygulanabilir. İstenilen “dilimi” elde etmek için her grup içindeki verileri sıralamayı unutmayın.\nÖrneğin, her hastaneden yalnızca en son 5 başvuruyu almak için:\n\nSatır listesini “hastane” sütununa göre gruplandırın\nKayıtları en geçten en erken ’hastaneye yatış tarihi’ne her hastane grubu içinde düzenleyin\nHer hastaneden ilk 5 sırayı almak için dilimleyin\n\n\nlinelist %&gt;%\n  group_by(hospital) %&gt;%\n  arrange(hospital, date_hospitalisation) %&gt;%\n  slice_head(n = 5) %&gt;% \n  arrange(hospital) %&gt;%                            \n  select(case_id, hospital, date_hospitalisation)  # görüntülemek için\n\n# A tibble: 30 × 3\n# Groups:   hospital [6]\n   case_id hospital          date_hospitalisation\n   &lt;chr&gt;   &lt;chr&gt;             &lt;date&gt;              \n 1 20b688  Central Hospital  2014-05-06          \n 2 d58402  Central Hospital  2014-05-10          \n 3 b8f2fd  Central Hospital  2014-05-13          \n 4 acf422  Central Hospital  2014-05-28          \n 5 275cc7  Central Hospital  2014-05-28          \n 6 d1fafd  Military Hospital 2014-04-17          \n 7 974bc1  Military Hospital 2014-05-13          \n 8 6a9004  Military Hospital 2014-05-13          \n 9 09e386  Military Hospital 2014-05-14          \n10 865581  Military Hospital 2014-05-15          \n# ℹ 20 more rows\n\n\nslice_head() - üstten n satır seçer slice_tail() - sondan n satır seçer slice_sample() - n satırı rastgele seçer slice_min() - order_by = sütununda en yüksek değerlere sahip n satırı seçer, bağları korumak için with_ties = TRUE kullanın ‘slice_max()’ - ‘order_by =’ sütununda en düşük değerlere sahip n satırı seçer, bağları korumak için ’with_ties = TRUE’yu kullanın\nslice() hakkında daha fazla örnek ve ayrıntı için [Tekilleştirme] sayfasına bakabilirsiniz.\n\n\nGrup boyutuna göre filtreleyin\n‘add_count()’ fonksiyonu, o satırın grubundaki satır sayısını veren orijinal verilere bir ‘n’ sütunu ekler.\nAşağıda gösterildiği gibi, “hastane” sütununa “add_count()” uygulanır, bu nedenle yeni “n” sütunundaki değerler, o satırın hastane grubundaki satır sayısını yansıtır. ‘n’ sütunundaki değerlerin nasıl tekrarlandığına dikkat edin. Aşağıdaki örnekte, ‘n’ sütun adı ‘add_count()’ içindeki ‘name =’ kullanılarak değiştirilebilir. Gösteri amacıyla sütunları select() ile yeniden düzenliyoruz.\n\nlinelist %&gt;% \n  as_tibble() %&gt;% \n  add_count(hospital) %&gt;%          # \"bu sıra ile aynı hastaneye kabul edilen sıra sayısı\" ekle\n  select(hospital, n, everything())\n\n# A tibble: 5,888 × 31\n   hospital                       n case_id generation date_infection date_onset\n   &lt;chr&gt;                      &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt; &lt;date&gt;         &lt;date&gt;    \n 1 Other                        885 5fe599           4 2014-05-08     2014-05-13\n 2 Missing                     1469 8689b7           4 NA             2014-05-13\n 3 St. Mark's Maternity Hosp…   422 11f8ea           2 NA             2014-05-16\n 4 Port Hospital               1762 b8812a           3 2014-05-04     2014-05-18\n 5 Military Hospital            896 893f25           3 2014-05-18     2014-05-21\n 6 Port Hospital               1762 be99c8           3 2014-05-03     2014-05-22\n 7 Missing                     1469 07e3e8           4 2014-05-22     2014-05-27\n 8 Missing                     1469 369449           4 2014-05-28     2014-06-02\n 9 Missing                     1469 f393b4           4 NA             2014-06-05\n10 Missing                     1469 1389ca           4 NA             2014-06-05\n# ℹ 5,878 more rows\n# ℹ 25 more variables: date_hospitalisation &lt;date&gt;, date_outcome &lt;date&gt;,\n#   outcome &lt;chr&gt;, gender &lt;chr&gt;, age &lt;dbl&gt;, age_unit &lt;chr&gt;, age_years &lt;dbl&gt;,\n#   age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;, lon &lt;dbl&gt;, lat &lt;dbl&gt;, infector &lt;chr&gt;,\n#   source &lt;chr&gt;, wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;, ct_blood &lt;dbl&gt;, fever &lt;chr&gt;,\n#   chills &lt;chr&gt;, cough &lt;chr&gt;, aches &lt;chr&gt;, vomit &lt;chr&gt;, temp &lt;dbl&gt;,\n#   time_admission &lt;chr&gt;, bmi &lt;dbl&gt;, days_onset_hosp &lt;dbl&gt;\n\n\nArdından “küçük” bir hastanede, örneğin 500’den az hastayı kabul eden bir hastanede yatan vaka sıralarını filtrelemek kolaylaşıyor:\n\nlinelist %&gt;% \n  add_count(hospital) %&gt;% \n  filter(n &lt; 500)",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Verileri Gruplama</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.tr.html#gruplandırılmış-verileri-dönüştürün",
    "href": "new_pages/grouping.tr.html#gruplandırılmış-verileri-dönüştürün",
    "title": "13  Verileri Gruplama",
    "section": "13.9 Gruplandırılmış verileri dönüştürün",
    "text": "13.9 Gruplandırılmış verileri dönüştürün\nTüm sütunları ve satırları (özetleme değil) korumak ve grup istatistiklerini içeren yeni bir sütun eklemek için, ‘özet()’ yerine ‘group_by()’dan sonra ’mutate()’ kullanın.\nBu, orijinal veri kümesinde diğer tüm sütunların mevcut olduğu grup istatistiklerini istiyorsanız yararlıdır - ör. bir satırı kendi grubuyla karşılaştıran hesaplamalar için.\nÖrneğin, aşağıdaki kod, bir satırın kabul gecikmesi ile hastaneleri için medyan gecikme arasındaki farkı hesaplar. Adımlar:\n\nVerileri hastaneye göre gruplandırın\no satırın hastanede ortalama gecikmesini içeren yeni bir sütun oluşturmak için “days_onset_hosp” (hastaneye yatış gecikmesi) sütununu kullanın\nİki sütun arasındaki farkı hesaplayın\n\nGösteri amacıyla yalnızca belirli sütunları “select()” olarak seçiyoruz.\n\nlinelist %&gt;% \n  # hastaneye göre grup verileri (henüz satır listesinde değişiklik yok)\n  group_by(hospital) %&gt;% \n  \n  # Yeni sütunlar\n  mutate(\n    # hastaneye kabule kadar geçen ortalama gün sayısı (1 ondalık sayıya yuvarlanır)\n    group_delay_admit = round(mean(days_onset_hosp, na.rm=T), 1),\n    \n    # sıra gecikmesi ile hastanelerindeki ortalama gecikme arasındaki fark (1 ondalık basamağa yuvarlanır)\n    diff_to_group     = round(days_onset_hosp - group_delay_admit, 1)) %&gt;%\n  \n  # yalnızca belirli satırları seçin - gösterim/görüntüleme amaçlı\n  select(case_id, hospital, days_onset_hosp, group_delay_admit, diff_to_group)\n\n# A tibble: 5,888 × 5\n# Groups:   hospital [6]\n   case_id hospital              days_onset_hosp group_delay_admit diff_to_group\n   &lt;chr&gt;   &lt;chr&gt;                           &lt;dbl&gt;             &lt;dbl&gt;         &lt;dbl&gt;\n 1 5fe599  Other                               2               2             0  \n 2 8689b7  Missing                             1               2.1          -1.1\n 3 11f8ea  St. Mark's Maternity…               2               2.1          -0.1\n 4 b8812a  Port Hospital                       2               2.1          -0.1\n 5 893f25  Military Hospital                   1               2.1          -1.1\n 6 be99c8  Port Hospital                       1               2.1          -1.1\n 7 07e3e8  Missing                             2               2.1          -0.1\n 8 369449  Missing                             1               2.1          -1.1\n 9 f393b4  Missing                             1               2.1          -1.1\n10 1389ca  Missing                             2               2.1          -0.1\n# ℹ 5,878 more rows",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Verileri Gruplama</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.tr.html#gruplandırılmış-verileri-seçin",
    "href": "new_pages/grouping.tr.html#gruplandırılmış-verileri-seçin",
    "title": "13  Verileri Gruplama",
    "section": "13.10 Gruplandırılmış verileri seçin",
    "text": "13.10 Gruplandırılmış verileri seçin\n‘select()’ fiili gruplandırılmış veriler üzerinde çalışır, ancak gruplandırma sütunları her zaman dahil edilir (‘select()’ içinde belirtilmemiş olsa bile). Bu gruplama sütunlarını istemiyorsanız, önce ungroup() kullanın.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Verileri Gruplama</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.tr.html#kaynaklar",
    "href": "new_pages/grouping.tr.html#kaynaklar",
    "title": "13  Verileri Gruplama",
    "section": "13.11 Kaynaklar",
    "text": "13.11 Kaynaklar\nDaha fazla bilgi için bazı yararlı kaynaklar şunlardır:\nGruplandırılmış veriler üzerinde herhangi bir özet fonksiyonu gerçekleştirebilirsiniz; RStudio veri dönüştürme bilgi sayfasına bakabilirsiniz.\ndplyr adresindeki Veri Marangozluğu sayfası group_by() ve grouping üzerindeki tidyverse referans sayfaları.\nBu sayfa Veri manipülasyonu\ndplyr’deki koşullarla özetleyin",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Verileri Gruplama</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.tr.html",
    "href": "new_pages/joining_matching.tr.html",
    "title": "14  Veri Birleştirme",
    "section": "",
    "text": "14.1 Hazırlık",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Veri Birleştirme</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.tr.html#hazırlık",
    "href": "new_pages/joining_matching.tr.html#hazırlık",
    "title": "14  Veri Birleştirme",
    "section": "",
    "text": "Paketleri yükleme\nBu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan ‘p_load()’ vurgusunu yapıyoruz. base R’dan library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R basics sayfasına bakın.\n\npacman::p_load(\n  rio,            # içe aktar ve dışa aktar\n  here,           # dosyaların yerini belirle\n  tidyverse,      # veri yönetimi ve görselleştirme\n  RecordLinkage,  # olasılıksal eşleşme\n  fastLink        # olasılıksal eşleşme\n)\n\n\n\nVerileri içe aktarma\nBaşlamak için, simüle edilmiş bir Ebola salgınından temizlenmiş vaka listesini içe aktarıyoruz. Takip etmek isterseniz click to download the “clean” linelist (.rds dosyası olarak). rio paketinden import() fonksiyonuyla verileri içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için İçe aktarma ve dışa aktarma sayfasına bakın).\n\n# vaka satır listesini içe aktarma \nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nSatır listesinin ilk 50 satırı aşağıda gösterilmiştir.\n\n\n\n\n\n\n\n\n\nÖrnek veri kümeleri\nAşağıdaki birleştirme bölümünde, aşağıdaki veri kümelerini kullanacağız:\n\nYalnızca “case_id”, “date_onset” ve “hospital” sütunlarını ve yalnızca ilk 10 satırı içeren “vaka satır listesinin” “minyatür” versiyonu\nHer hastane hakkında daha fazla ayrıntı içeren “hosp_info” adlı ayrı bir veri çerçevesi\n\nOlasılıksal eşleştirme bölümünde iki farklı küçük veri seti kullanacağız. Bu veri kümelerini oluşturacak kod o bölümde verilmiştir.\n\n“Minyatür” vaka satır listesi\nAşağıda, yalnızca 10 satır ve yalnızca “case_id”, “date_onset” ve “hospital” sütunlarını içeren minyatür vaka satır listesi bulunmaktadır.\n\nlinelist_mini &lt;- linelist %&gt;%                 # orijinal satır listesiyle başla\n  select(case_id, date_onset, hospital) %&gt;%   # sütunları seç\n  head(10)                                    # sadece ilk 10 satırı al\n\n\n\n\n\n\n\n\n\nHastane bilgi veri çerçevesi\nAşağıda, yedi hastane hakkında ek bilgi içeren ayrı bir veri çerçevesi oluşturma kodu verilmiştir (çalışma alanı nüfusu ve mevcut bakım düzeyi). “Askeri Hastane” adının iki farklı hastaneye ait olduğunu unutmayın - biri 10000 kişiye hizmet veren birinci basamak ve diğeri 50280 kişiye hizmet veren ikinci basamak.\n\n#Hastane bilgi veri çerçevesini yapın\nhosp_info = data.frame(\n  hosp_name     = c(\"central hospital\", \"military\", \"military\", \"port\", \"St. Mark's\", \"ignace\", \"sisters\"),\n  catchment_pop = c(1950280, 40500, 10000, 50280, 12000, 5000, 4200),\n  level         = c(\"Tertiary\", \"Secondary\", \"Primary\", \"Secondary\", \"Secondary\", \"Primary\", \"Primary\")\n)\n\nİşte bu veri çerçevesi:\n\n\n\n\n\n\n\n\n\n\nÖn temizleme\nGeleneksel birleştirmeler (olasılıksız) büyük/küçük harfe duyarlıdır ve iki veri çerçevesindeki değerler arasında tam karakter eşleşmeleri gerektirir. Bir birleştirmeyi başlatmadan önce yapmanız gerekebilecek bazı temizleme adımlarını göstermek için, şimdi ‘linelist_mini’ ve ‘hosp_info’ veri kümelerini temizleyip hizalayacağız.\nFarklılıkları tanımlayın\n‘linelist_mini’ veri çerçevesindeki ‘hospital’ sütununun değerleriyle eşleşmesi için ‘hosp_info’ veri çerçevesindeki ‘hosp_name’ sütununun değerlerine ihtiyacımız var.\nbase R fonksiyonu ‘unique()’ ile yazdırılan ‘linelist_mini’ veri çerçevesindeki değerler şunlardır:\n\nunique(linelist_mini$hospital)\n\n[1] \"Other\"                               \n[2] \"Missing\"                             \n[3] \"St. Mark's Maternity Hospital (SMMH)\"\n[4] \"Port Hospital\"                       \n[5] \"Military Hospital\"                   \n\n\nve burada “hosp_info” veri çerçevesindeki değerler:\n\nunique(hosp_info$hosp_name)\n\n[1] \"central hospital\" \"military\"         \"port\"             \"St. Mark's\"      \n[5] \"ignace\"           \"sisters\"         \n\n\nHer iki veri çerçevesinde de bazı hastaneler varken, yazımda birçok farklılık olduğunu görebilirsiniz.\nDeğerleri hizala\nhosp_info veri çerçevesindeki değerleri temizleyerek başlıyoruz. Temizleme verileri ve temel fonksiyonlar sayfasında açıklandığı gibi, dplyr’in case_while() fonksiyonunu kullanarak değerleri mantıksal kriterlerle yeniden kodlayabiliriz. Her iki veri çerçevesinde de bulunan dört hastane için değerleri, ‘linelist_mini’ içindeki değerlerle uyumlu olacak şekilde değiştiriyoruz. Diğer hastanelerde değerleri olduğu gibi bırakıyoruz (TRUE ~ hosp_name).\nUYARI: Genellikle temizlik yapılırken yeni bir sütun oluşturulmalıdır (ör. hosp_name_clean), ancak gösterim kolaylığı için eski sütunun modifikasyonunu gösteriyoruz\n\nhosp_info &lt;- hosp_info %&gt;% \n  mutate(\n    hosp_name = case_when(\n      # criteria                         # yeni değer\n      hosp_name == \"military\"          ~ \"Military Hospital\",\n      hosp_name == \"port\"              ~ \"Port Hospital\",\n      hosp_name == \"St. Mark's\"        ~ \"St. Mark's Maternity Hospital (SMMH)\",\n      hosp_name == \"central hospital\"  ~ \"Central Hospital\",\n      TRUE                             ~ hosp_name\n      )\n    )\n\nHer iki veri çerçevesinde de görünen hastane adları hizalanmıştır. “Hosp_info”da “linelist_mini”de bulunmayan iki hastane vardır - bunları daha sonra, birleştirmede ele alacağız.\n\nunique(hosp_info$hosp_name)\n\n[1] \"Central Hospital\"                    \n[2] \"Military Hospital\"                   \n[3] \"Port Hospital\"                       \n[4] \"St. Mark's Maternity Hospital (SMMH)\"\n[5] \"ignace\"                              \n[6] \"sisters\"                             \n\n\nBirleştirmeden önce, bir sütunu tamamen küçük harfe veya tamamı büyük harfe dönüştürmek genellikle en kolayıdır. Bir sütundaki tüm değerleri BÜYÜK veya küçük harfe dönüştürmeniz gerekiyorsa, ‘mutate()’ kullanın ve sütunustringr’ fonksiyonlarından biriyle sarın. [Karakterler ve dizeler] sayfasında gösterildiği gibi\nstr_to_upper()\nstr_to_upper()\nstr_to_title()",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Veri Birleştirme</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.tr.html#dplyr-birleştirmeleri",
    "href": "new_pages/joining_matching.tr.html#dplyr-birleştirmeleri",
    "title": "14  Veri Birleştirme",
    "section": "14.2 dplyr birleştirmeleri",
    "text": "14.2 dplyr birleştirmeleri\ndplyr paketi birkaç farklı birleştirme fonksiyonu sunar. dplyr, tidyverse paketine dahildir. Bu birleştirme fonksiyonları, basit kullanım durumları ile aşağıda açıklanmıştır.\nBilgilendirici gifler için https://github.com/gadenbuie’e çok teşekkürler!\n\n\nGenel sözdizimi\nBirleştirme komutları, iki veri çerçevesini yeni bir nesnede birleştirmek için bağımsız komutlar olarak çalıştırılabilir veya bir veri çerçevesini temizlenirken veya başka bir şekilde değiştirilirken bir veri çerçevesini diğerine birleştirmek için bir tünel zincirinde (“%&gt;%”) kullanılabilir. .\nAşağıdaki örnekte, “left_join()” fonksiyonu, yeni bir “joined_data” veri çerçevesi oluşturmak için bağımsız bir komut olarak kullanılır. Girişler, veri çerçeveleri 1 ve 2’dir (df1 ve df2). Listelenen ilk veri çerçevesi temel veri çerçevesidir ve listelenen ikincisi buna birleştirilir.\nÜçüncü argüman “by =”, iki veri çerçevesindeki satırları hizalamak için kullanılacak her veri çerçevesindeki sütunları belirttiğiniz yerdir. Bu sütunların adları farklıysa, bunları aşağıda gösterildiği gibi bir “c()” vektörü içinde sağlayın; burada satırlar “df1”deki “ID” sütunu ile “df2”deki “tanımlayıcı” sütunu arasındaki ortak değerler temelinde eşleştirilir.\n\n# \"ID\" sütunu (ilk veri çerçevesi) ve \"tanımlayıcı\" sütunu (ikinci veri çerçevesi) arasındaki ortak değerlere göre birleştirme\njoined_data &lt;- left_join(df1, df2, by = c(\"ID\" = \"identifier\"))\n\nHer iki veri çerçevesindeki “by” sütunları tam olarak aynı ada sahipse, bu tek adı tırnak içinde verebilirsiniz.\n\n# Her iki veri çerçevesindeki \"ID\" sütunundaki ortak değerlere dayalı birleştirme\njoined_data &lt;- left_join(df1, df2, by = \"ID\")\n\nBirden çok alandaki ortak değerlere dayalı veri çerçevelerini birleştiriyorsanız, bu alanları “c()” vektörü içinde listeleyin. Bu örnek, her veri kümesindeki üç sütundaki değerler tam olarak aynı hizadaysa satırları birleştirir.\n\n# aynı isim-soyisim ve yaşa sahip olanları birleştirme\njoined_data &lt;- left_join(df1, df2, by = c(\"name\" = \"firstname\", \"surname\" = \"lastname\", \"Age\" = \"age\"))\n\nBirleştirme komutları bir tünel zinciri içinde de çalıştırılabilir. Bu, aktarılan veri çerçevesini değiştirecektir.\nAşağıdaki örnekte ‘df1’ tünellerden geçirilmekte, ‘df2’ ile birleştirilmekte ve böylece ‘df’ değiştirilip yeniden tanımlanmaktadır.\n\ndf1 &lt;- df1 %&gt;%\n  filter(date_onset &lt; as.Date(\"2020-03-05\")) %&gt;% # öok yönlü temizlik\n  left_join(df2, by = c(\"ID\" = \"identifier\"))    # df2 yi df1 e birleştirmek\n\nUYARI: Birleştirmeler büyük/küçük harfe özeldir! Bu nedenle, birleştirmeden önce tüm değerleri küçük harfe veya büyük harfe dönüştürmek yararlıdır. Karakterler/dizeler ile ilgili sayfaya bakınız.\n\n\n\nSol ve sağ birleşimler\nBir veri çerçevesine bilgi eklemek için yaygın olarak sol veya sağ birleşim kullanılır - yeni bilgiler yalnızca temel veri çerçevesinde zaten var olan satırlara eklenir. Bunlar, bir veri kümesinden diğerine bilgi eklemek için kullanıldıkları için epidemiyolojik çalışmalarda yaygın olarak kullanılan birleştirmelerdir.\nBu birleştirmeleri kullanırken, komuttaki veri çerçevelerinin yazılı sırası önemlidir*.\n\nBir sol birleştirmede, yazılan ilk veri çerçevesi temel satırdır\nBir sağ birleştirmede, yazılan ikinci veri çerçevesi temel satırdır\n\nTemel veri çerçevesinin tüm satırları tutulur. Diğer (ikincil) veri çerçevesindeki bilgiler, temel veri çerçevesine yalnızca tanımlayıcı sütun(lar)ı aracılığıyla bir eşleşme varsa birleştirilir. Ek olarak:\n\nİkincil veri çerçevesindeki eşleşmeyen satırlar atlanır.\nİkincil veri çerçevesindeki bir satırla eşleşen çok sayıda temel satır varsa (çoktan bire), ikincil bilgiler eşleşen her bir temel satıra eklenir.\nBir temel satır, ikincil veri çerçevesindeki birden çok satırla eşleşirse (bire çok), tüm kombinasyonlar verilir, yani döndürülen veri çerçevenize yeni satırlar eklenebilir!\n\nSol ve sağ birleştirmelerin animasyonlu örnekleri (image source)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nÖrnek\nAşağıda, “hosp_info”nun (ikincil veri çerçevesi, buradan görüntüleyebilirsiniz) “linelist_mini”ye (temel veri çerçevesi, buradan görüntüleyebilirsiniz) bir “left_join()” çıktısı verilmiştir. Orijinal “linelist_mini”, “nrow(linelist_mini)” satırlarına sahiptir. Değiştirilen “linelist_mini” görüntülenir. Aşağıdakilere dikkat ediniz:\n\n“linelist_mini”nin sol tarafına iki yeni sütun, “catchment_pop” ve “level” eklendi\n‘linelist_mini’ temel veri çerçevesinin tüm orijinal satırları tutulur\n“Askeri Hastane” için herhangi bir orijinal “linelist_mini” satırı, ikincil veri çerçevesindeki iki satırla eşleştiği için çoğaltılır, bu nedenle her iki kombinasyon da döndürülür\nİkincil veri kümesinin (hosp_name) birleştirme tanımlayıcı sütunu, birincil veri kümesindeki (“hastane”) tanımlayıcı sütunuyla gereksiz olduğundan kayboldu\nTemel satır herhangi bir ikincil satırla eşleşmediğinde (örneğin, “hastane” “Diğer” veya “Eksik” olduğunda), “NA” (boşluk) ikincil veri çerçevesindeki sütunları doldurur\nİkincil veri çerçevesindeki temel veri çerçevesiyle eşleşmeyen satırlar (“kızkardeşler” ve “ignace” hastaneleri) çıkarıldı.\n\n\nlinelist_mini %&gt;% \n  left_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))\n\n\n\nWarning in left_join(., hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 5 of `x` matches multiple rows in `y`.\nℹ Row 4 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\n\n“Sağ birleştirme mi yoksa sol birleştirme mi kullanmalıyım?”\nYukarıdaki soruyu yanıtlamak için kendinize “hangi veri çerçevesinin tüm satırlarını tutması gerektiğini” sorun. - bunu temel satır olarak kullanın. sol birleştirme komutta yazılan ilk veri çerçevesindeki tüm satırları tutarken, sağ birleştirme tüm satırları ikinci veri çerçevesinde tutar.\nAşağıdaki iki komut aynı çıktıyı elde eder - 10 satır “hosp_info” bir “linelist_mini” temel satırına katılmıştır, ancak farklı birleşimler kullanırlar. Sonuç olarak, sütun sırası, “hosp_info”nun sağdan mı (sol birleştirmede) yoksa soldan mı (sağ birleştirmede) geldiğine bağlı olarak farklılık gösterecektir. Sıraların sırası da buna göre değişebilir. Ancak bu sonuçların her ikisi de daha sonra, sütunları yeniden sıralamak için “select()” veya satırları sıralamak için “arrange()” kullanılarak ele alınabilir.\n\n# Aşağıdaki iki komut aynı verileri elde eder, ancak farklı sıralı satırlar ve sütunlarla\nleft_join(linelist_mini, hosp_info, by = c(\"hospital\" = \"hosp_name\"))\nright_join(hosp_info, linelist_mini, by = c(\"hosp_name\" = \"hospital\"))\n\nSol birleşim yoluyla ‘hosp_info’nun ’linelist_mini’ içindeki sonucu (sağdan gelen yeni sütunlar)\n\n\nWarning in left_join(linelist_mini, hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 5 of `x` matches multiple rows in `y`.\nℹ Row 4 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\nİşte sağ birleştirme yoluyla ‘hosp_info’nun ’linelist_mini’ içindeki sonucu (soldan gelen yeni sütunlar)\n\n\nWarning in right_join(hosp_info, linelist_mini, by = c(hosp_name = \"hospital\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 4 of `x` matches multiple rows in `y`.\nℹ Row 5 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\nAyrıca kullanım durumunuzun bir tünel zinciri (%&gt;%) içinde olup olmadığını da göz önünde bulundurun. Borulardaki veri kümesi temel satır ise, buna veri eklemek için büyük olasılıkla bir sol birleştirme kullanacaksınız.\n\n\n\n\nTam birleşme\n**Tam birleşim, birleşimlerin en *kapsayıcısıdır** - her iki veri çerçevesinden tüm satırları döndürür.\nBirinde mevcut olan ve diğerinde olmayan satırlar varsa (eşleşmenin bulunmadığı durumlarda), veri çerçevesi bunları içerecek ve daha uzun olacaktır. “NA” eksik değerleri, oluşturulan boşlukları doldurmak için kullanılır. Birleştirirken, büyük/küçük harf duyarlılığı ve tam karakter eşleşmeleriyle ilgili sorunları gidermek için sütun ve satır sayısını dikkatle izleyin.\n“Temel satır” veri çerçevesi, komutta ilk yazılan çerçevedir. Bunun ayarlanması, birleştirme tarafından hangi kayıtların döndürüleceğini etkilemez, ancak sonuçta elde edilen sütun sırasını, satır sırasını ve hangi tanımlayıcı sütunların tutulacağını etkileyebilir.\n\n\n\n\n\n\n\n\n\nTam birleştirmenin animasyonlu örneği (görüntü kaynağı)\nÖrnek\nlinelist_mininin(başlangıçtanrow(linelist_mini), buradan görüntüleyebilirsiniz içine hosp_info’nun full_join()’i (başlangıçta nrow(hosp_info)`, buradan görüntüleyebilirsiniz) çıktısı aşağıda yer almaktadır. Aşağıdakilere dikkat ediniz:\n\nTüm temel satırlar tutulur (linelist_mini)\nİkincil satırda temel satırla eşleşmeyen satırlar tutulur (“ignace” ve “sisters”), karşılık gelen “case_id” ve “onset” sütunlarındaki değerler eksik değerlerle doldurulur\nBenzer şekilde, temel veri çerçevesindeki ikincil ile eşleşmeyen satırlar (“Diğer” ve “Eksik”) tutulur, ikincil sütunlar “catchment_pop” ve “level” eksik değerlerle doldurulur\nBire çoğa veya çoğa bire eşleşmelerde (ör. “Askeri Hastane” satırları), tüm olası kombinasyonlar döndürülür (son veri çerçevesini uzatarak)\nYalnızca temel satırdan tanımlayıcı sütun tutulur (“hastane”)\n\n\nlinelist_mini %&gt;% \n  full_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))\n\n\n\nWarning in full_join(., hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 5 of `x` matches multiple rows in `y`.\nℹ Row 4 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\n\n\n\nİç birleştirme\n**İç birleştirme, birleştirmelerin en *kısıtlayıcısıdır** - yalnızca her iki veri çerçevesinde eşleşen satırları döndürür. Bu, temel veri çerçevesindeki satır sayısının gerçekten azalabileceği anlamına gelir. Hangi veri çerçevesinin “temel satır” (işlevde ilk olarak yazılır) olduğunun ayarlanması, hangi satırların döndürüleceğini etkilemez, ancak sütun sırasını, satır sırasını ve hangi tanımlayıcı sütunların tutulacağını etkiler.\n\n\n\n\n\n\n\n\n\nİç birleştirmenin animasyonlu örneği (görüntü kaynağı)\nÖrnek\nAşağıda, “hosp_info” (ikincil) ile “linelist_mini”nin (temel satır) bir “inner_join()” çıktısı bulunmaktadır. Aşağıdakilere dikkat ediniz:\n\nİkincil verilerle eşleşmeyen temel satırlar kaldırılır (“hastane”nin “Eksik” veya “Diğer” olduğu satırlar)\nBenzer şekilde, temel satırla eşleşmeyen ikincil veri çerçevesindeki satırlar kaldırılır (“hosp_name”nin “kız kardeşler” veya “ignace” olduğu satırlar)\nYalnızca temel satırdan tanımlayıcı sütun tutulur (“hastane”)\n\n\nlinelist_mini %&gt;% \n  inner_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))\n\n\n\nWarning in inner_join(., hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 5 of `x` matches multiple rows in `y`.\nℹ Row 4 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\n\n\n\nYarım birleştirme\nYarım birleştirme, başka bir veri kümesini satır veya sütun eklemek için değil, filtreleme gerçekleştirmek için kullanan bir “filtreleme birleştirme”dir.\nBir yarım birleştirme, ikincil veri çerçevesinde bir eşleşmeye sahip olan temel veri çerçevesindeki tüm gözlemleri tutar (ancak yeni sütunlar eklemez veya birden çok eşleşme için herhangi bir satırı çoğaltmaz). Bu “filtreleme” birleşimleri hakkında daha fazla bilgiyi buradan okuyabilirsiniz buradan.\n\n\n\n\n\n\n\n\n\nYarım birleştirmenin animasyonlu örneği (görüntü kaynağı)\nÖrnek olarak, aşağıdaki kod, hastane adına göre “linelist_mini” içinde eşleşmeleri olan “hosp_info” veri çerçevesinden satırları döndürür.\n\nhosp_info %&gt;% \n  semi_join(linelist_mini, by = c(\"hosp_name\" = \"hospital\"))\n\n                             hosp_name catchment_pop     level\n1                    Military Hospital         40500 Secondary\n2                    Military Hospital         10000   Primary\n3                        Port Hospital         50280 Secondary\n4 St. Mark's Maternity Hospital (SMMH)         12000 Secondary\n\n\n\n\n\nKarşıt birleştirme\nKarşıt birleştirme ‘anti_join()’, temel veri çerçevesindeki ikincil veri çerçevesinde eşleşmeyen* satırları döndüren başka bir “filtreleme birleştirme”dir.\nBirleştirmeleri filtreleme hakkında daha fazla bilgiyi buradan okuyabilirsiniz buradan.\nBir karşıt birleştirme için yaygın senaryolar arasında başka bir veri çerçevesinde mevcut olmayan kayıtların belirlenmesi, bir birleştirmedeki yazım hatalarının giderilmesi (eşleşmesi gereken kayıtların gözden geçirilmesi) ve başka bir birleştirmeden sonra hariç tutulan kayıtların incelenmesi yer alır.\n‘right_join()’ ve ‘left_join()’ ile olduğu gibi, temel veri çerçevesi (ilk olarak listelenmiştir) önemlidir. Döndürülen satırlar yalnızca temel veri çerçevesindendir. Alttaki gifte, ikincil veri çerçevesindeki o satırın (mor satır 4), taban çizgisiyle eşleşmemesine rağmen döndürülmediğine dikkat edin.\n\n\n\n\n\n\n\n\n\nKarşıt birleştirmenin animasyonlu örneği (görüntü kaynağı)\n\nBasit anti_join() örneği\nBasit bir örnek için, ‘linelist_mini’ içinde herhangi bir vaka bulunmayan ‘hosp_info’ hastanelerini bulalım. Temel veri çerçevesi olarak önce ‘hosp_info’yu listeleriz. ’linelist_mini’ içinde bulunmayan hastaneler iade edilir.\n\nhosp_info %&gt;% \n  anti_join(linelist_mini, by = c(\"hosp_name\" = \"hospital\"))\n\n\n\n\n\n\n\n\n\nKarmaşık anti_join() örneği\nBaşka bir örnek için, “linelist_mini” ve “hosp_info” arasında bir “inner_join()” çalıştırdığımızı varsayalım. Bazıları “hosp_info” içinde bulunmadığından, bu, orijinal “linelist_mini” kayıtlarının yalnızca bir alt kümesini döndürür.\n\nlinelist_mini %&gt;% \n  inner_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))\n\n\n\nWarning in inner_join(., hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 5 of `x` matches multiple rows in `y`.\nℹ Row 4 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\nİç birleştirme sırasında hariç tutulan ‘linelist_mini’ kayıtlarını gözden geçirmek için aynı ayarlarla (temel satır olarak ‘linelist_mini’) bir ayrıştırma (anti-join) çalıştırabiliriz.\n\nlinelist_mini %&gt;% \n  anti_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))\n\n\n\n\n\n\n\nİç birleşimde hariç tutulan ‘hosp_info’ kayıtlarını görmek için, temel veri çerçevesi olarak ‘hosp_info’ ile bir ayrıştırma çalıştırabiliriz.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Veri Birleştirme</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.tr.html#olasılıksal-eşleştirme",
    "href": "new_pages/joining_matching.tr.html#olasılıksal-eşleştirme",
    "title": "14  Veri Birleştirme",
    "section": "14.3 Olasılıksal eşleştirme",
    "text": "14.3 Olasılıksal eşleştirme\nKatılmak için veri kümeleri arasında ortak benzersiz bir tanımlayıcınız yoksa, olasılıklı bir eşleştirme algoritması kullanmayı düşünün. Bu, benzerliğe dayalı olarak kayıtlar arasındaki eşleşmeleri bulur (örneğin, Jaro–Winkler dizi mesafesi veya sayısal mesafe). Aşağıda fastLink paketini kullanan basit bir örnek verilmiştir.\nPaketleri yükle\n\npacman::p_load(\n  tidyverse,      # veri işleme ve görselleştirme\n  fastLink        # kayıt eşleştirme\n  )\n\nOlasılıksal eşleşmeyi göstermek için kullanacağımız iki küçük örnek veri kümesi (“durumlar” ve “test_sonuçları”):\nVeri kümelerini oluşturmak için kullanılan kod:\n\n# veri kümeleri yapmak\n\ncases &lt;- tribble(\n  ~gender, ~first,      ~middle,     ~last,        ~yr,   ~mon, ~day, ~district,\n  \"M\",     \"Amir\",      NA,          \"Khan\",       1989,  11,   22,   \"River\",\n  \"M\",     \"Anthony\",   \"B.\",        \"Smith\",      1970, 09, 19,      \"River\", \n  \"F\",     \"Marialisa\", \"Contreras\", \"Rodrigues\",  1972, 04, 15,      \"River\",\n  \"F\",     \"Elizabeth\", \"Casteel\",   \"Chase\",      1954, 03, 03,      \"City\",\n  \"M\",     \"Jose\",      \"Sanchez\",   \"Lopez\",      1996, 01, 06,      \"City\",\n  \"F\",     \"Cassidy\",   \"Jones\",      \"Davis\",     1980, 07, 20,      \"City\",\n  \"M\",     \"Michael\",   \"Murphy\",     \"O'Calaghan\",1969, 04, 12,      \"Rural\", \n  \"M\",     \"Oliver\",    \"Laurent\",    \"De Bordow\" , 1971, 02, 04,     \"River\",\n  \"F\",      \"Blessing\",  NA,          \"Adebayo\",   1955,  02, 14,     \"Rural\"\n)\n\nresults &lt;- tribble(\n  ~gender,  ~first,     ~middle,     ~last,          ~yr, ~mon, ~day, ~district, ~result,\n  \"M\",      \"Amir\",     NA,          \"Khan\",         1989, 11,   22,  \"River\", \"positive\",\n  \"M\",      \"Tony\",   \"B\",         \"Smith\",          1970, 09,   19,  \"River\", \"positive\",\n  \"F\",      \"Maria\",    \"Contreras\", \"Rodriguez\",    1972, 04,   15,  \"Cty\",   \"negative\",\n  \"F\",      \"Betty\",    \"Castel\",   \"Chase\",        1954,  03,   30,  \"City\",  \"positive\",\n  \"F\",      \"Andrea\",   NA,          \"Kumaraswamy\",  2001, 01,   05,  \"Rural\", \"positive\",      \n  \"F\",      \"Caroline\", NA,          \"Wang\",         1988, 12,   11,  \"Rural\", \"negative\",\n  \"F\",      \"Trang\",    NA,          \"Nguyen\",       1981, 06,   10,  \"Rural\", \"positive\",\n  \"M\",      \"Olivier\" , \"Laurent\",   \"De Bordeaux\",  NA,   NA,   NA,  \"River\", \"positive\",\n  \"M\",      \"Mike\",     \"Murphy\",    \"O'Callaghan\",  1969, 04,   12,  \"Rural\", \"negative\",\n  \"F\",      \"Cassidy\",  \"Jones\",     \"Davis\",        1980, 07,   02,  \"City\",  \"positive\",\n  \"M\",      \"Mohammad\", NA,          \"Ali\",          1942, 01,   17,  \"City\",  \"negative\",\n  NA,       \"Jose\",     \"Sanchez\",   \"Lopez\",        1995, 01,   06,  \"City\",  \"negative\",\n  \"M\",      \"Abubakar\", NA,          \"Abullahi\",     1960, 01,   01,  \"River\", \"positive\",\n  \"F\",      \"Maria\",    \"Salinas\",   \"Contreras\",    1955, 03,   03,  \"River\", \"positive\"\n  )\n\n“vakalar” veri kümesinde, test sonuçlarını bekleyen hastaların 9 kaydı vardır.\n\n\n\n\n\n\ntest_results veri kümesi 14 kayıt içerir ve kayıtların olasılıksal eşleşmesine dayalı olarak vakalardaki kayıtlara eklemek istediğimiz sonuç sütununu içerir.\n\n\n\n\n\n\n\nOlasılıksal eşleşme\nfastLink paketindeki fastLink() fonksiyonu, bir eşleştirme algoritması uygulamak için kullanılabilir. İşte temel bilgiler. Konsolunuza ?fastLink girerek daha fazla ayrıntı okuyabilirsiniz.\n\ndfA = ve dfB = değişkenleriyle karşılaştırmak için iki veri çerçevesini tanımlayın.\nvarnames = içinde eşleştirme için kullanılacak tüm sütun adlarını verin. Hepsi hem “dfA” hem de “dfB” içinde bulunmalıdır.\nstringdist.match = içinde, “distance” dizesinde değerlendirilmek üzere varnames içindekilerden sütunlar verin.\n‘numeric.match =’ içinde, ‘varnames’ içindekilerden sayısal mesafeye göre değerlendirilecek sütunlar verin.\nEksik değerler dikkate alınmaz\nVarsayılan olarak, herhangi bir veri çerçevesindeki her satır, diğer veri çerçevesindeki en fazla bir satırla eşleştirilir. Değerlendirilen tüm eşleşmeleri görmek istiyorsanız, “dedupe.matches = FALSE” olarak ayarlayın. Tekilleştirme, Winkler’in doğrusal atama çözümü kullanılarak yapılır.\n\nİpucu: lubridate paketinden ‘day()’, ‘ay()’ ve ‘year()’ kullanarak bir tarih sütununu üç ayrı sayısal sütuna ayırın\nEşleşmeler için varsayılan eşik 0,94’tür (threshold.match =), ancak bunu daha yüksek veya daha düşük olarak ayarlayabilirsiniz. Eşiği tanımlarsanız, daha yüksek eşiklerin daha fazla yanlış-negatif (aslında eşleşmesi gereken eşleşmeyen satırlar) verebileceğini ve aynı şekilde daha düşük bir eşiğin daha fazla yanlış-pozitif eşleşmeler sağlayabileceğini düşünün.\nAşağıda, veriler, ad ve bölge sütunları boyunca harf dizisi mesafesine ve yıl, ay ve doğum günü için sayısal mesafeye göre eşleştirilir. %95 olasılıkla bir eşleşme eşiği belirlenir.\n\nfl_output &lt;- fastLink::fastLink(\n  dfA = cases,\n  dfB = results,\n  varnames = c(\"gender\", \"first\", \"middle\", \"last\", \"yr\", \"mon\", \"day\", \"district\"),\n  stringdist.match = c(\"first\", \"middle\", \"last\", \"district\"),\n  numeric.match = c(\"yr\", \"mon\", \"day\"),\n  threshold.match = 0.95)\n\n\n==================== \nfastLink(): Fast Probabilistic Record Linkage\n==================== \n\nIf you set return.all to FALSE, you will not be able to calculate a confusion table as a summary statistic.\nCalculating matches for each variable.\nGetting counts for parameter estimation.\n    Parallelizing calculation using OpenMP. 1 threads out of 8 are used.\nRunning the EM algorithm.\nGetting the indices of estimated matches.\n    Parallelizing calculation using OpenMP. 1 threads out of 8 are used.\nDeduping the estimated matches.\nGetting the match patterns for each estimated match.\n\n\nEşleşmelerin incelenmesi\nfastLink()den dönen nesneyi fl_output olarak tanımladık. ‘list’ sınıfında yer alır ve aslında içinde eşleşmenin sonuçlarını detaylandıran birkaç veri çerçevesi içerir. Bu veri çerçevelerinden biri, “durumlar” ve “sonuçlar” arasındaki en olası eşleşmeleri içeren “eşleşmeler”dir. Bu “eşleşmelere” veri çerçevesine fl_output$matches ile erişebilirsiniz. Aşağıda, daha sonra erişim kolaylığı için ‘my_matches’ olarak kaydedilmiştir.\n“my_matches” yazdırıldığında, iki sütun vektörü görürsünüz: “cases” (“inds.a”) ve “results” (“inds.b”) içindeki satır numaraları/indeks (“satır adları” olarak da adlandırılır) çiftleri en iyi eşleşmeleri temsil eder. Bir veri çerçevesinden bir satır numarası eksikse, belirtilen eşleşme eşiğinde diğer veri çerçevesinde hiçbir eşleşme bulunamaz.\n\n# eşleşmeleri yazdır\nmy_matches &lt;- fl_output$matches\nmy_matches\n\n  inds.a inds.b\n1      1      1\n2      2      2\n3      3      3\n4      4      4\n5      8      8\n6      7      9\n7      6     10\n8      5     12\n\n\nDikkat edilmesi gerekenler:\n\nİsim yazımında ve doğum tarihlerinde küçük farklılıklar olmasına rağmen eşleşmeler gerçekleşti:\n\n“Tony B. Smith”, “Anthony B Smith” ile eşleşti\n“Maria Rodriguez”, “Marialisa Rodrigues” ile eşleşti\n“Betty Chase”, “Elizabeth Chase” ile eşleşti\n“Olivier Laurent De Bordeaux”, “Oliver Laurent De Bordow” ile eşleştirildi (eksik doğum tarihi dikkate alınmadı)\n\n“Cases” bir satır (“Blessing Adebayo” için, 9. satır) “results”da iyi bir eşleşmeye sahip değildi, bu nedenle “eşleşmelerim”de yer verilmedi.\n\nOlasılıklı eşleşmelere göre birleştirme\nBu eşleşmeleri “results” “cases” birleştirmek için strateji şudur:\n\n“my_matches”ı “cases” ile birleştirmek için “left_join()”i kullanın (“cases”deki satır adlarını “my_matches” içindeki “inds.a” ile eşleştirme)\nArdından, “results”ı “cases” ile birleştirmek için başka bir “left_join()” kullanın (“vakalar”daki yeni edinilen “inds.b”yi “results”daki satır adlarıyla eşleştirin)\n\nBirleştirmelerden önce üç veri çerçevesini temizlemeliyiz:\n\nHem “dfA” hem de “dfB” satır numaraları (“satır adı”) uygun bir sütuna dönüştürülmelidir.\nmy_matches içindeki her iki sütun da sınıf karakterine dönüştürülür, böylece karakter satır adlarına birleştirilebilirler.\n\n\n# Eşleştirmeden önce verileri temizleyin\n#############################\n\n# vaka satır adlarını bir sütuna dönüştür \ncases_clean &lt;- cases %&gt;% rownames_to_column()\n\n# test_results satır adlarını bir sütuna dönüştür\nresults_clean &lt;- results %&gt;% rownames_to_column()  \n\n# eşleşen veri kümesindeki tüm sütunları karaktere dönüştürün, böylece satır adlarına birleştirilebilirler\nmatches_clean &lt;- my_matches %&gt;%\n  mutate(across(everything(), as.character))\n\n\n\n# Eşleşmeleri dfA ile birleştirin, ardından dfB ekleyin\n##################################\n# \"inds.b\" sütunu dfA'ya eklendi\ncomplete &lt;- left_join(cases_clean, matches_clean, by = c(\"rowname\" = \"inds.a\"))\n\n#dfB'den sütun(lar) eklendi\ncomplete &lt;- left_join(complete, results_clean, by = c(\"inds.b\" = \"rowname\"))\n\nYukarıdaki kod kullanılarak gerçekleştirildiği gibi, elde edilen “tamamlandı” veri çerçevesi hem “durumlardan” hem de “sonuçlardan” tüm sütunları içerecektir. Sütun adları aksi takdirde yineleneceğinden, birçoğuna “.x” ve “.y” son ekleri eklenecektir.\n\n\n\n\n\n\nAlternatif olarak, “results”dan yeni sütun(lar)la “cases” yalnızca “orijinal” 9 kaydı elde etmek için, birleştirmeden önce “results”da “select()”i kullanın, böylece yalnızca satır adlarını ve “cases” (örneğin “result” sütunu) eklemek istediğiniz sütunları içerir.\n\ncases_clean &lt;- cases %&gt;% rownames_to_column()\n\nresults_clean &lt;- results %&gt;%\n  rownames_to_column() %&gt;% \n  select(rowname, result)    # sadece belirli sütunları seç\n\nmatches_clean &lt;- my_matches %&gt;%\n  mutate(across(everything(), as.character))\n\n# birleştirme\ncomplete &lt;- left_join(cases_clean, matches_clean, by = c(\"rowname\" = \"inds.a\"))\ncomplete &lt;- left_join(complete, results_clean, by = c(\"inds.b\" = \"rowname\"))\n\n\n\n\n\n\n\nHer iki veri kümesini de yalnızca eşleşen satırlara alt kümelemek isterseniz aşağıdaki kodları kullanabilirsiniz:\n\ncases_matched &lt;- cases[my_matches$inds.a,]  # Sonuçlarda bir satırla eşleşen vakalarda satırlar\nresults_matched &lt;- results[my_matches$inds.b,]  # Vakalardaki bir satırla eşleşen sonuçlardaki satırlar\n\nVeya yalnızca eşleşmeyen satırları görmek için:\n\ncases_not_matched &lt;- cases[!rownames(cases) %in% my_matches$inds.a,]  # Sonuçlarda bir satırla eşleşmeyen vakalardaki satırlar\nresults_not_matched &lt;- results[!rownames(results) %in% my_matches$inds.b,]  # Bir satırla eşleşmeyen sonuçlardaki satırlars\n\n\n\nOlasılıksal veri tekilleştirme\nOlasılıksal eşleştirme, bir veri kümesini tekilleştirmek için de kullanılabilir. Diğer veri tekilleştirme yöntemleri için veri tekilleştirme sayfasına bakabilirsiniz.\nBurada “cases” veri kümesiyle başladık, ancak önceki satırların kopyası olabilecek 2 ek satırı olduğundan şimdi buna “cases_dup” adını veriyoruz: “Anthony” ile “Tony” ve “Maria Rodriguez” ile “Marialisa Rodrigues” i inceleyiniz.\n\n\n\n\n\n\nDaha önce olduğu gibi “fastLink()”i çalıştırın, ancak “cases_dup” veri çerçevesini kendisiyle karşılaştırın. Sağlanan iki veri çerçevesi aynı olduğunda, fonksiyon, çoğaltmayı kaldırmak istediğinizi varsayar. Daha önce yaptığımız gibi stringdist.match = veya numeric.match = belirtmediğimizi unutmayın.\n\n## Aynı veri kümesinde fastLink'i çalıştırın\ndedupe_output &lt;- fastLink(\n  dfA = cases_dup,\n  dfB = cases_dup,\n  varnames = c(\"gender\", \"first\", \"middle\", \"last\", \"yr\", \"mon\", \"day\", \"district\")\n)\n\n\n==================== \nfastLink(): Fast Probabilistic Record Linkage\n==================== \n\nIf you set return.all to FALSE, you will not be able to calculate a confusion table as a summary statistic.\ndfA and dfB are identical, assuming deduplication of a single data set.\nSetting return.all to FALSE.\n\nCalculating matches for each variable.\nGetting counts for parameter estimation.\n    Parallelizing calculation using OpenMP. 1 threads out of 8 are used.\nRunning the EM algorithm.\nGetting the indices of estimated matches.\n    Parallelizing calculation using OpenMP. 1 threads out of 8 are used.\nCalculating the posterior for each pair of matched observations.\nGetting the match patterns for each estimated match.\n\n\nŞimdi, getMatches() ile olası kopyaları inceleyebilirsiniz. Veri çerçevesini hem ‘dfA =’ hem de ‘dfB =’ olarak sağlayın ve ‘fastLink()’ fonksiyonunun çıktısını ‘fl.out =’ olarak sağlayın. “fl.out”, “fastLink.dedupe” sınıfında veya başka bir deyişle “fastLink()”in sonucu olmalıdır.\n\n## getMatches() çalıştır\ncases_dedupe &lt;- getMatches(\n  dfA = cases_dup,\n  dfB = cases_dup,\n  fl.out = dedupe_output)\n\nYinelenen kimlikleri gösteren en sağdaki sütuna bakın - son iki satır, 2. ve 3. satırların olası kopyaları olarak tanımlanır.\n\n\n\n\n\n\nBüyük olasılıkla yinelenen satırların satır numaralarını döndürmek için, “dedupe.ids” sütunundaki benzersiz değer başına satır sayısını sayabilir ve ardından yalnızca birden fazla satıra sahip olanları tutmak için filtre uygulayabilirsiniz. Bu durumda 2. ve 3. satırları bırakır.\n\ncases_dedupe %&gt;% \n  count(dedupe.ids) %&gt;% \n  filter(n &gt; 1)\n\n  dedupe.ids n\n1          2 2\n2          3 2\n\n\nMuhtemel kopyaların tüm satırlarını incelemek için satır numarasını bu komuta girin:\n\n# 2. satırı ve tüm olası kopyalarını görüntüler\ncases_dedupe[cases_dedupe$dedupe.ids == 2,]   \n\n   gender   first middle  last   yr mon day district dedupe.ids\n2       M Anthony     B. Smith 1970   9  19    River          2\n10      M    Tony     B. Smith 1970   9  19    River          2",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Veri Birleştirme</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.tr.html#bağlama-ve-hizalama",
    "href": "new_pages/joining_matching.tr.html#bağlama-ve-hizalama",
    "title": "14  Veri Birleştirme",
    "section": "14.4 Bağlama ve hizalama",
    "text": "14.4 Bağlama ve hizalama\nİki veri çerçevesini birleştirmenin başka bir yöntemi, onları birbirine “bağlamaktır”. Bunu satır veya sütunları “eklemek” olarak da düşünebilirsiniz.\nBu bölümde ayrıca bir veri çerçevesinin satır sırasının başka bir veri çerçevesindeki sıraya nasıl “hizalanacağı” tartışılacaktır. Bu konu aşağıda Sütunları bağlama bölümünde tartışılmaktadır.\n\nSatırları bağlama\nBir veri çerçevesinin satırlarını başka bir veri çerçevesinin altına bağlamak için, dplyr’den bind_rows() kullanın. Çok kapsayıcıdır, bu nedenle her iki veri çerçevesinde bulunan herhangi bir sütun çıktıya dahil edilecektir. Birkaç not:\n\nbase R sürümü ‘row.bind()’den farklı olarak, dplyr’nin ’bind_rows()’ fonksiyonu, sütunların sırasının her iki veri çerçevesinde de aynı olmasını gerektirmez. Sütun adları aynı şekilde yazıldığı sürece, bunları doğru şekilde hizalayacaktır.\nİsteğe bağlı olarak .id = argümanını belirtebilirsiniz. Bir karakter sütun adı sağlayın. Bu, her satırın orijinal olarak hangi veri çerçevesinden geldiğini belirlemeye yarayan yeni bir sütun üretecektir.\nBenzer şekilde yapılandırılmış veri çerçevelerinin bir ‘listesinde’ onları tek bir veri çerçevesinde birleştirmek için ‘bind_rows()’ kullanabilirsiniz. purrr ile birden çok satır listesinin içe aktarılmasını içeren [Yineleme, döngüler ve listeler] sayfasındaki bir örneğe bakın.\n\nSatır bağlamanın yaygın bir örneği, “toplam” bir satırı dplyr’nin summarise() fonksiyonuyla yapılmış açıklayıcı bir tabloya bağlamaktır. Aşağıda, toplam satır ile hastaneye göre vaka sayıları ve medyan CT değerleri tablosu oluşturulmuştur.\n“Summarise()” fonksiyonu, hastaneye göre bir özet veri çerçevesi döndürmek için hastaneye göre gruplandırılmış verilerde kullanılır. Ancak summarise() fonksiyonu otomatik olarak bir “toplamlar” satırı oluşturmaz, bu nedenle verileri tekrar özetleyerek, ancak hastane tarafından gruplandırılmamış verilerle oluştururuz. Bu, yalnızca bir satırdan oluşan ikinci bir veri çerçevesi üretir. Daha sonra nihai tabloya ulaşmak için bu veri çerçevelerini birbirine bağlayabiliriz.\n[Açıklayıcı tablolar] ve [Sunum için tablolar] sayfalarında bunun gibi diğer çalışılmış örnekleri inceleyibilirsiniz.\n\n# Çekirdek tablo oluştur\n###################\nhosp_summary &lt;- linelist %&gt;% \n  group_by(hospital) %&gt;%                        # Verileri hastaneye göre gruplandır\n  summarise(                                    # İlgilenilen göstergelerin yeni özet sütunları oluşturun\n    cases = n(),                                  # Hastane-çıktı grubu başına satır sayısı     \n    ct_value_med = median(ct_blood, na.rm=T))     # grup başına medyan CT değeri\n\nİşte “hosp_summary” veri çerçevesi:\n\n\n\n\n\n\n“Toplam” istatistiklerle (hastaneye göre gruplandırılmamış) bir veri çerçevesi oluşturun. Bu sadece bir satır döndürür.\n\n# Toplamları oluştur\n###############\ntotals &lt;- linelist %&gt;% \n  summarise(\n    cases = n(),                               # Tüm veri kümesi için satır sayısı    \n    ct_value_med = median(ct_blood, na.rm=T))  # Tüm veri seti için medyan CT\n\nVe aşağıda bu “totals” veri çerçevesi var. Sadece iki sütunun nasıl olduğuna dikkat edin. Bu sütunlar da “hosp_summary” içindedir, ancak “hosp_summary”de “totals” (“hastane”) içinde olmayan bir sütun vardır.\n\n\n\n\n\n\nArtık satırları bind_rows() ile birbirine bağlayabiliriz.\n\n# Veri çerçevelerini birbirine bağla\ncombined &lt;- bind_rows(hosp_summary, totals)\n\nArtık sonucu görebiliriz. Son satırda, “hosp_summary”de olmayan “hospital” sütunu için boş bir “NA” değerinin nasıl doldurulduğunu görün. [Sunum için tablolar] sayfasında açıklandığı gibi, replace_na() kullanarak bu hücreyi “Total” ile “doldurabilirsiniz”.\n\n\n\n\n\n\n\n\nSütunları bağla\nİki veri çerçevesini yanlara birleştirmek için kullanabileceğiniz benzer bir dplyr fonksiyonu bind_cols() vardır. Satırların birbiriyle konuma göre eşleştirildiğini unutmayınız (yukarıdaki birleştirme gibi değil). Örneğin her veri çerçevesindeki 12. satır hizalanacaktır.\nÖrneğin, birkaç özet tabloyu birbirine bağlarız. Bunu yapmak için, aynı zamanda, bir veri çerçevesindeki satırların sırasının, ‘match()’ ile başka bir veri çerçevesindeki sıra ile eşleşecek şekilde nasıl yeniden düzenleneceğini de gösteriyoruz.\nBurada ’vaka_bilgisi’ni, hastaneye göre, vaka sayısı ve ölüm sayısı ile birlikte sıralı vakaların özet veri çerçevesi olarak tanımlıyoruz.\n\n# Vaka bilgisi\ncase_info &lt;- linelist %&gt;% \n  group_by(hospital) %&gt;% \n  summarise(\n    cases = n(),\n    deaths = sum(outcome == \"Death\", na.rm=T)\n  )\n\n\n\n\n\n\n\nVe diyelim ki burada yine hastane tarafından araştırılan ve “takip edilen” maruz kalan temasların yüzdesi hakkında bilgi içeren farklı bir “contact_fu” veri çerçevesi var.\n\ncontact_fu &lt;- data.frame(\n  hospital = c(\"St. Mark's Maternity Hospital (SMMH)\", \"Military Hospital\", \"Missing\", \"Central Hospital\", \"Port Hospital\", \"Other\"),\n  investigated = c(\"80%\", \"82%\", NA, \"78%\", \"64%\", \"55%\"),\n  per_fu = c(\"60%\", \"25%\", NA, \"20%\", \"75%\", \"80%\")\n)\n\n\n\n\n\n\n\nHastanelerin aynı olduğunu, ancak her veri çerçevesinde farklı sıralarda olduğunu unutmayın. En kolay çözüm, ‘hastane’ sütununda bir ‘left_join()’ kullanmak olacaktır, ancak fazladan bir adımla ‘bind_cols()’ da kullanabilirsiniz.\n\nSırasını hizalamak için match() kullanımı\nSatır sıraları farklı olduğundan, basit bir “bind_cols()” komutu, verilerin yanlış eşleşmesine neden olur. Bunu düzeltmek için, bir veri çerçevesinin satırlarını diğeriyle aynı sırada hizalamak için base R’dan ‘match()’ kullanabiliriz. Bu yaklaşım için her iki veri çerçevesinde de yinelenen değer olmadığını varsayıyoruz.\n‘match()’ kullandığımızda, sözdizimi ‘match(HEDEF SIRA VEKTÖR, DEĞİŞTİRİLECEK VERİ ÇERÇEVESİ SÜTUNU)’ şeklindedir, burada ilk değişken istenen sıradır (ya bağımsız bir vektör, ya da bu durumda bir veri çerçevesi) ve ikinci değişken, yeniden sıralanacak veri çerçevesindeki veri çerçevesi sütunudur. “match()” çıktısı, doğru konum sıralamasını temsil eden bir sayı vektörüdür. Daha fazlasını ?match ile okuyabilirsiniz.\n\nmatch(case_info$hospital, contact_fu$hospital)\n\n[1] 4 2 3 6 5 1\n\n\nVeri çerçevesini yeniden sıralamak için bu sayısal vektörü kullanabilirsiniz - onu ‘[ ]’ alt küme parantezleri içine virgülden önce yerleştirin. [R temelleri] sayfasında temel R köşeli ayraç alt kümesi sözdizimi hakkında daha fazla bilgi edinin. Aşağıdaki komut, satırların yukarıdaki sayısal vektörde sıralandığı eskisi olarak tanımlanan yeni bir veri çerçevesi oluşturur.\n\ncontact_fu_aligned &lt;- contact_fu[match(case_info$hospital, contact_fu$hospital),]\n\n\n\n\n\n\n\nArtık veri çerçevesi sütunlarını doğru satır sırası ile birbirine bağlayabiliriz. Bazı sütunların çoğaltıldığını ve ‘rename()’ ile temizlenmesi gerekeceğini unutmayın. bind_rows() hakkında daha fazla bilgi edinmek için tıklayınız. buradan.\n\nbind_cols(case_info, contact_fu)\n\nNew names:\n• `hospital` -&gt; `hospital...1`\n• `hospital` -&gt; `hospital...4`\n\n\n# A tibble: 6 × 6\n  hospital...1                     cases deaths hospital...4 investigated per_fu\n  &lt;chr&gt;                            &lt;int&gt;  &lt;int&gt; &lt;chr&gt;        &lt;chr&gt;        &lt;chr&gt; \n1 Central Hospital                   454    193 St. Mark's … 80%          60%   \n2 Military Hospital                  896    399 Military Ho… 82%          25%   \n3 Missing                           1469    611 Missing      &lt;NA&gt;         &lt;NA&gt;  \n4 Other                              885    395 Central Hos… 78%          20%   \n5 Port Hospital                     1762    785 Port Hospit… 64%          75%   \n6 St. Mark's Maternity Hospital (…   422    199 Other        55%          80%   \n\n\n“bind_cols”e bir base R alternatifi, aynı işlemi gerçekleştiren “cbind()”dir.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Veri Birleştirme</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.tr.html#kaynaklar",
    "href": "new_pages/joining_matching.tr.html#kaynaklar",
    "title": "14  Veri Birleştirme",
    "section": "14.5 Kaynaklar",
    "text": "14.5 Kaynaklar\nBirleşimlerdeki tidyverse sayfası\nİlişkisel verilerle ilgili Veri Bilimi için R sayfası\ndplyr’deki tidyverse sayfası ciltleme hakkında\nPaketin Github sayfasındaki betimlemesi fastLink\nMetodolojisini açıklayan yayınfastLink\n[RecordLinkage paketini] açıklayan yayın (https://journal.r-project.org/archive/2010/RJ-2010-017/RJ-2010-017.pdf)",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Veri Birleştirme</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.tr.html",
    "href": "new_pages/deduplication.tr.html",
    "title": "15  Tekilleştirme",
    "section": "",
    "text": "15.1 Hazırlık",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Tekilleştirme</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.tr.html#hazırlık",
    "href": "new_pages/deduplication.tr.html#hazırlık",
    "title": "15  Tekilleştirme",
    "section": "",
    "text": "Paketleri yükleme\nBu kod parçası, analizler için gereken paketlerin yüklenmesini göstermektedir. Bu el kitabında, paketi kuran ve eğer gerekirse kullanım için yükleyen pacman’ın p_load() işlevlerini vurgulamaktayız. Ayrıca, base R’den library() fonksiyonu ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R’ın Temelleri sayfasına bakabilirsiniz.\n\npacman::p_load(\n  tidyverse,   # tekilleştirme, gruplama ve dilimleme işlevleri\n  janitor,     # kopyaları gözden geçirme işlevi\n  stringr)      # dizi aramaları için \"toplama\" değerleri de kullanılabilir\n\n\n\nVerileri içeri aktarma\nAşağıda, R kodu ile oluşturulmuş örnek bir veri seti kullanacağız.\nVeriler, temaslı kişiler ve vakalar dahil olmak üzere COVID-19 telefon görüşmelerinin kayıtlarıdır. Sütunlar, kayıt kimliği - recordID (bilgisayar tarafından oluşturulan), kişi kimliği - personID, ad - name, karşılaşma tarihi - date, karşılaşma zamanı - time, karşılaşmanın amacını - purpose (vaka veya temaslı olarak görüşme için) ve semptomları symptoms_ever (kayıt zamanında kişinin hiç semptom bildirip bildirmediğini) içerir.\nobs veri kümesini oluşturmak için gereken kod:\n\nobs &lt;- data.frame(\n  recordID  = c(1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18),\n  personID  = c(1,1,2,2,3,2,4,5,6,7,2,1,3,3,4,5,5,7,8),\n  name      = c(\"adam\", \"adam\", \"amrish\", \"amrish\", \"mariah\", \"amrish\", \"nikhil\", \"brian\", \"smita\", \"raquel\", \"amrish\",\n                \"adam\", \"mariah\", \"mariah\", \"nikhil\", \"brian\", \"brian\", \"raquel\", \"natalie\"),\n  date      = c(\"1/1/2020\", \"1/1/2020\", \"2/1/2020\", \"2/1/2020\", \"5/1/2020\", \"5/1/2020\", \"5/1/2020\", \"5/1/2020\", \"5/1/2020\",\"5/1/2020\", \"2/1/2020\",\n                \"5/1/2020\", \"6/1/2020\", \"6/1/2020\", \"6/1/2020\", \"6/1/2020\", \"7/1/2020\", \"7/1/2020\", \"7/1/2020\"),\n  time      = c(\"09:00\", \"09:00\", \"14:20\", \"14:20\", \"12:00\", \"16:10\", \"13:01\", \"15:20\", \"14:20\", \"12:30\", \"10:24\",\n                \"09:40\", \"07:25\", \"08:32\", \"15:36\", \"15:31\", \"07:59\", \"11:13\", \"17:12\"),\n  encounter = c(1,1,1,1,1,3,1,1,1,1,2,\n                2,2,3,2,2,3,2,1),\n  purpose   = c(\"contact\", \"contact\", \"contact\", \"contact\", \"case\", \"case\", \"contact\", \"contact\", \"contact\", \"contact\", \"contact\",\n                \"case\", \"contact\", \"contact\", \"contact\", \"contact\", \"case\", \"contact\", \"case\"),\n  symptoms_ever = c(NA, NA, \"No\", \"No\", \"No\", \"Yes\", \"Yes\", \"No\", \"Yes\", NA, \"Yes\",\n                    \"No\", \"No\", \"No\", \"Yes\", \"Yes\", \"No\",\"No\", \"No\")) %&gt;% \n  mutate(date = as.Date(date, format = \"%d/%m/%Y\"))\n\n\nVeri Çerçevesi\nHer bir kişi için karşılaşmaları gözden geçirmek için üst kısımdaki filtre kutularını kullanabilirsiniz.\n\n\n\n\n\n\nVerileri gözden geçirirken dikkat etmeniz gereken birkaç nokta:\n\nİlk iki kayıt, yineleyen kayıt kimliği - recordID de dahil olmak üzere %100 birbirinin tam kopyalarıdır (bir bilgisayar arızası olmalı!)\nİkinci iki satır, kayıt kimliği - recordID dışındaki tüm sütunlarda birbirinin kopyalarıdır.\nBirkaç kişi, çeşitli tarih ve saatlerde ve temaslılar ve/veya vakalar olarak birden fazla telefon görüşmesi yaptı.\nHer vizitte, kişiye daha öncesinde semptomları olup olmadığı soruldu ve bu bilgilerin bir kısmı eksik.\n\nVe işte janitor paketinden tabyl() fonksiyonu kullanılarak insanların ve karşılaşmalarının amaçlarının kısa bir özeti:\n\nobs %&gt;% \n  tabyl(name, purpose)\n\n    name case contact\n    adam    1       2\n  amrish    1       3\n   brian    1       2\n  mariah    1       2\n natalie    1       0\n  nikhil    0       2\n  raquel    0       2\n   smita    0       1",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Tekilleştirme</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.tr.html#tekilleştirme",
    "href": "new_pages/deduplication.tr.html#tekilleştirme",
    "title": "15  Tekilleştirme",
    "section": "15.2 Tekilleştirme",
    "text": "15.2 Tekilleştirme\nBu bölüm, bir veri çerçevesindeki yinelenen satırların nasıl gözden geçirileceğini ve kaldırılacağını açıklamakta ve bir vektörde yinelenen öğelerin nasıl ele alınacağını göstermektedir.\n\n\nYinelenen satırları inceleme\nYinelenen satırları hızlı bir şekilde gözden geçirmek için janitor paketinden get_dupes() öğesini kullanabilirsiniz. Varsayılan olarak, yinelemeler değerlendirilirken tüm sütunlar dikkate alınır - fonksiyon tarafından döndürülen satırlar, bütün sütunlardaki değerler dikkate alındığında %100 yinelemedir.\nobs veri çerçevesinde, ilk iki satır %100 kopyadır - her sütunda aynı değere sahiptirler (benzersiz olması gereken kayıt kimliği - recordID sütunu dahil - bir bilgisayar arızası olmalı). Döndürülen veri çerçevesi, sağ tarafta otomatik olarak yeni bir dupe_count sütunu içerir ve bu yinelenen değerler kombinasyonuna sahip satır sayısını gösterir.\n\n# Tüm sütunlarda %100 kopyalar\nobs %&gt;% \n  janitor::get_dupes()\n\n\n\n\n\n\n\nOrijinal veriyi incelemek için linke tıklayınız.\nAncak kayıt kimliğini- recordID yok saymayı seçersek 3. ve 4. satırlar da birbirinin kopyasıdır. Yani, recordID dışındaki tüm sütunlarda aynı değerlere sahiptirler. Bir - eksi sembolü kullanarak fonksiyonda yok sayılacak belirli sütunları belirtebilirsiniz.\n\n# Sütun kayıt kimliği/recordID dikkate alınmadığında yinelenir\nobs %&gt;% \n  janitor::get_dupes(-recordID)         # if multiple columns, wrap them in c()\n\n\n\n\n\n\n\nAyrıca dikkate alınacak sütunları pozitif olarak belirleyebilirsiniz. Aşağıda, yalnızca ad- name ve amaç - name sütunlarında aynı değerlere sahip satırlar döndürülür. “amrish”in, üç “temas” karşılaşmasını yansıtmak için nasıl dupe_count’un 3’e eşit olduğuna dikkat edin.\nDaha fazla satır görmek için sola kaydırın.\n\n# YALNIZCA ad ve amaç sütunlarına dayalı olarak kopyalar\nobs %&gt;% \n  janitor::get_dupes(name, purpose)\n\n\n\n\n\n\n\nOrijinal veriyi incelemek için linke tıklayınız.\nDaha fazla ayrıntı için ?get_dupes fonksiyonunu kullanabilir veya bu çevrimiçi referansa bakabilirsiniz.\n\n\n\nYalnızca benzersiz satırları tutma\nBir veri çerçevesinin yalnızca benzersiz satırlarını tutmak için dplyr paketinden distinct() fonksiyonunu kullanabilirsiniz (Veri ve temel işlevleri temizleme sayfasında gösterildiği gibi). Yinelenen satırlar, bu tür satırlardan yalnızca ilki tutulacak şekilde kaldırılır. Varsayılan olarak, “ilk” en yüksek satır sayısı - rownumber anlamına gelir (yukarıdan aşağıya sırasında). Yalnızca benzersiz satırlar kalır.\nAşağıdaki örnekte, kayıt kimliği - recordID sütununun dikkate alınmaması için distinct() fonksiyonunu çalıştırıyoruz - bu nedenle iki yinelenen satır kaldırılmaktadır. İlk satır (“adam” için) %100 kopyalandı ve kaldırıldı. Ayrıca 3. satır (“amrish” için) recordID (değerlendirilmemiştir) dışındaki her sütunda bir kopyaydı ve bu nedenle de kaldırıldı. obs veri kümesinin n’i nrow(obs)-2dir, nrow(obs) satırı değil.\nTüm veri çerçevesini görmek için sola kaydırın.\n\n# veri zincirine eklendi (ör. veri temizleme)\nobs %&gt;% \n  distinct(across(-recordID), # veri çerçevesini yalnızca benzersiz satırlara indirger (herhangi bir kopyadan ilkini tutar)\n           .keep_all = TRUE) \n\n# eğer veri zincirinin dışındaysa, verileri ilk argüman olarak dahil et \n# distinct(obs)\n\n\n\n\n\n\n\nUYARI: Gruplandırılmış verilerde distinct() kullanılıyorsa, fonksiyon her gruba uygulanacaktır.\nBelirli sütunlara dayalı olarak tekilleştirme\nAyrıca tekilleştirme için temel olacak sütunları da belirtebilirsiniz. Bu şekilde, tekilleştirme yalnızca belirtilen sütunlar içinde yinelenen satırlar için geçerlidir. .keep_all = TRUE, olarak ayarlamadığınız sürece, belirtilmeyen tüm sütunlar kaldırılacaktır.\nAşağıdaki örnekte, tekilleştirme yalnızca ad - name ve amaç - purpose sütunları için aynı değerlere sahip satırlar için geçerlidir. Böylece, “brian”ın 3 yerine sadece 2 satırı vardır - ilk “temas” karşılaşması ve tek “vaka” karşılaşması. Brian’ın her bir amaç için en son karşılaşmasını koruyacak şekilde ayarlamak için, Gruplar içinde Dilimleme sekmesine bakın.\nTüm veri çerçevesini görmek için sola kaydırın.\n\n# veri zincirine eklendi (ör. veri temizleme)\nobs %&gt;% \n  distinct(name, purpose, .keep_all = TRUE) %&gt;%  # satırları ada ve amaca göre benzersiz tut ve tüm sütunları koru\n  arrange(name)                                  # daha kolay görüntüleme için düzenle\n\n\n\n\n\n\n\nOrijinal veriyi incelemek için linke tıklayınız.\n\n\n\nBir vektörde yinelenen öğeler\nbase R’dan duplicated() fonksiyonu, bir vektörü (sütun) değerlendirecek ve aynı uzunlukta (DOĞRU/YANLIŞ) bir mantıksal vektöre döndürecektir. Bir değer ilk göründüğünde, YANLIŞ’a (yinelenen değil) döndürür ve bu değerin sonraki görüntülerinde DOĞRU’ya döndürür. NA’nın diğer herhangi bir değerle nasıl aynı şekilde ele alındığına dikkat edin.\n\nx &lt;- c(1, 1, 2, NA, NA, 4, 5, 4, 4, 1, 2)\nduplicated(x)\n\n [1] FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n\n\nYalnızca yinelenen öğeleri döndürmek için, orijinal vektörün alt kümesini oluşturmak için köşeli parantezleri kullanabilirsiniz:\n\nx[duplicated(x)]\n\n[1]  1 NA  4  4  1  2\n\n\nYalnızca benzersiz öğeleri döndürmek için, base R’dan unique() kullanın. NA’ları sonuçtan çıkarmak için na.omit() öğesini unique() içine yerleştirin.\n\nunique(x)           # alternatif olarak, x[!duplicated(x)]kullanın\n\n[1]  1  2 NA  4  5\n\nunique(na.omit(x))  # NA’ları kaldırın\n\n[1] 1 2 4 5\n\n\n\n\n\nbase R’ı kullanma\nYinelenen satırları döndürmek için\nbase R’da, duplicated(df) komutuyla df veri çerçevesinde hangi satırların %100 kopya olduğunu da görebilirsiniz (satırların mantıksal vektörünü döndürür).\nBu nedenle, df[duplicated(df),] ile yineleyen satırları görmek için veri çerçevesindeki [ ] temel alt kümesini de kullanabilirsiniz (virgülü unutmayın, bu tüm sütunları görmek istediğiniz anlamına gelir!).\nBenzersiz satırları döndürmek için\nYukarıdaki notlara bakın. Benzersiz satırları görmek için duplicated() işlevinin önünde mantıksal olumsuzlayıcıyı/logical negator !v eklersiniz:df[!duplicated(df),]`\nYalnızca belirli sütunların kopyası olan satırları döndürmek için\nduplicated() parantez içindeki df’yi alt kümeye alın, böylece bu işlev df’nin yalnızca belirli sütunlarında çalışacaktır.\nSütunları belirtmek için, virgülden sonra sütun numaralarını veya adlarını girin (tüm bunların duplicated() fonksiyonu içinde olduğunu unutmayın).\nduplicated() fonksiyonundan sonra da virgülü dışarıda tuttuğunuzdan emin olun!\nÖrneğin, kopyalar için yalnızca 2 ila 5 arasındaki sütunları değerlendirmek için: df[!duplicated(df[, 2:5]),]\nKopyalar için yalnızca name ve purpose sütununu değerlendirmek için: df[!duplicated(df[, c(\"name\", \"purpose)]),]",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Tekilleştirme</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.tr.html#dilimleme",
    "href": "new_pages/deduplication.tr.html#dilimleme",
    "title": "15  Tekilleştirme",
    "section": "15.3 Dilimleme",
    "text": "15.3 Dilimleme\nSatır numarasına/konumuna göre satırlara filtre uygulamak için bir veri çerçevesini “dilimlemek”. Bu, özellikle işlevsel grup başına (örneğin, “kişi” başına) birden çok satırınız varsa ve bunlardan yalnızca birini veya birkaçını tutmak istiyorsanız yararlı olur.\nTemel slice() işlevi sayıları kabul eder ve bu konumlardaki satırları döndürür. Sağlanan sayılar pozitifse, yalnızca döndürülür. Negatifse, bu satırlar döndürülmez. Sayıların tümü pozitif veya tümü negatif olmalıdır.\n\nobs %&gt;% slice(4)  # 4. satırı döndür\n\n  recordID personID   name       date  time encounter purpose symptoms_ever\n1        3        2 amrish 2020-01-02 14:20         1 contact            No\n\n\n\nobs %&gt;% slice(c(2,4))  # 2. ve 4. satırları döndür\n\n  recordID personID   name       date  time encounter purpose symptoms_ever\n1        1        1   adam 2020-01-01 09:00         1 contact          &lt;NA&gt;\n2        3        2 amrish 2020-01-02 14:20         1 contact            No\n\n#obs %&gt;% slice(c(2:4))  # 2'den 4'e kadar olan satırları döndür\n\nOrijinal veriyi incelemek için linke tıklayınız.\nBirkaç varyasyon mevcuttur: Bunlara bir sütun ve döndürülecek birkaç satır verilmelidir ( n =’ye).\n\nslice_min() ve slice_max() yalnızca belirtilen sütunun minimum veya maksimum değer(ler)ine sahip satır(lar)ı tutar. Bu aynı zamanda sıralı faktörlerin “min” ve “maks” değerlerini döndürmek için de işe yarar.\nslice_head() ve slice_tail() - sadece ilk veya son satır(lar)ı tutar.\nslice_sample() - satırların yalnızca rastgele bir örneğini tutar.\n\n\nobs %&gt;% slice_max(encounter, n = 1)  # en büyük karşılaşma numarasına sahip satırları döndür\n\n  recordID personID   name       date  time encounter purpose symptoms_ever\n1        5        2 amrish 2020-01-05 16:10         3    case           Yes\n2       13        3 mariah 2020-01-06 08:32         3 contact            No\n3       16        5  brian 2020-01-07 07:59         3    case            No\n\n\nSaklanacak satırların sayısını veya oranını belirtmek için n = veya prop = argümanlarını kullanın. İşlev bir boru zincirinde kullanılmıyorsa, önce veri bağımsız değişkenini sağlayın (ör. slice(data, n = 2)). Daha fazla bilgi için ?slice bölümüne bakın.\nDiğer argümanlar:\n.order_by = slice_min() ve slice_max() içinde kullanılır ve bu, dilimlemeden önce sıralanması gereken bir sütundur. with_ties = Varsayılan olarak DOĞRU, yani bağlar korunur. .preserve = Varsayılan olarak YANLIŞ. DOĞRU ise, dilimlemeden sonra gruplama yapısı yeniden hesaplanır.\nweight_by = Ağırlıklandırmaya göre isteğe bağlı, sayısal sütun (daha büyük sayının örneklenmesi daha olasıdır). Ayrıca replace = Örneklemenin değiştirilerek/değiştirilmeden yapılıp yapılmadığı için.\nİPUCU: slice_max() ve slice_min() kullanırken, n =’yi belirttiğinizden/yazdığınızdan emin olun (ör. n = 2, sadece 2 değil). Aksi takdirde bir hata alabilirsiniz. Error: … is not empty.\nNOT: slice işlevlerinin yerini alan top_n() fonksiyonuyla karşılaşabilirsiniz.\n\n\nGruplarla dilimleme\nslice_*() fonksiyonları, gruplanmış bir veri çerçevesine uygulandığında çok yararlı olabilir, çünkü dilim işlemi her grup üzerinde ayrı ayrı gerçekleştirilir. Her gruptan bir dilim almak üzere verileri gruplamak için group_by() fonksiyonunu slice() ile birlikte kullanın.\nBu, kişi başına birden fazla satırınız varsa ancak bunlardan yalnızca birini tutmak istiyorsanız, tekilleştirme için yararlıdır. Önce group_by() fonksiyonunu kişi başına aynı olan anahtar sütunlarla kullanırsınız ve ardından gruplanmış satırlar arasında farklılık gösterecek bir sütun üzerinde bir slice fonksiyonunu kullanırsınız.\nAşağıdaki örnekte, kişi başına yalnızca en son karşılaşmayı tutmak için satırları ada - name göre grupladık ve ardından tarih - date sütununda n = 1 ile slice_max()’ı kullandık. Haberin olsun! Tarihlere slice_max() gibi bir işlevi uygulamak için tarih sütunu Date sınıfı olmalıdır.\nVarsayılan olarak, “bağlar” (ör. bu senaryoda aynı tarih) korunur ve yine de bazı insanlar için (ör. adam) birden çok satır alırız. Bunu önlemek için with_ties = FALSE olarak ayarladık.\nUYARI: Eğer arrange() fonksiyonu kullanılıyorsa, verilerin her bir grup içinde düzenlenmesi için .by_group = TRUE olarak belirtin.\nTEHLİKE: Eğer with_ties = FALSE ise, bir bağın ilk satırı tutulur. Bu aldatıcı olabilir. Mariah’nın son randevusunda (6 Ocak) iki karşılaşması var ve ilki (en erken) tutuluyor. Muhtemelen, o gün daha sonraki karşılaşmasını sürdürmek istiyoruz. Bir sonraki örnekte bu bağların nasıl “kırılacağını” görebilirsiniz.\n\nobs %&gt;% \n  group_by(name) %&gt;%       # satırları 'ad'a göre gruplandır\n  slice_max(date,          # maksimum tarih değerine sahip grup başına satır tut \n            n = 1,         # sadece tek en yüksek satırı tut\n            with_ties = F) # (tarihin) bir bağı varsa, ilk sırayı alın\n\n\n\n\n\n\n\nYukarıda, örneğin sadece Amrish’in 5 Ocak’taki satırının tutulduğunu ve sadece Brian’ın 7 Ocak’taki satırının tutulduğunu görebiliriz. Orijinal veriyi incelemek için linke tıklayınız.\n“Bağları” kırmak\n“Bağları kırmak” için birden çok dilim ifadesi çalıştırılabilir. Bu durumda, bir kişinin en son tarihinde birden fazla karşılaşması varsa, en son zamanlı olan karşılaşma tutulur (karakter zamanlarını sıralanabilir bir zaman sınıfına dönüştürmek için lubridate::hm() kullanılır). Şimdi, 6 Ocak’ta “Mariah” için tutulan bir satırın, 07:25’teki 2. karşılaşma değil, 08:32’deki 3. karşılaşma olduğuna dikkat edin.\n\n# \"Bağları kırmak\" için çoklu dilim ifadesi örneği\nobs %&gt;%\n  group_by(name) %&gt;%\n  \n  # İLK - en son tarihe göre dilimleyin\n  slice_max(date, n = 1, with_ties = TRUE) %&gt;% \n  \n  # İKİNCİ - bir bağ varsa, en son zamana sahip satırı seçin; bağlar yasak\n  slice_max(lubridate::hm(time), n = 1, with_ties = FALSE)\n\n\n\n\n\n\n\nScriptIn yukarıdaki örnekte karşılaşma - encounter sayısına göre dilimleme yapmak da mümkün olabilirdi ama biz örnek amaçlı olarak tarih - date ve saat - time üzerinde dilimi gösterdik.\nİPUCU: Bir “karakter” sütununda slice_max() veya slice_min() kullanmak için, onu sıralı bir faktör sınıfına dönüştürün!\nOrijinal veriyi incelemek için linke tıklayınız.\n\n\n\nHepsini sakla ama işaretle\nTüm kayıtları tutmak, ancak yalnızca bazılarını analiz için işaretlemek istiyorsanız, benzersiz bir recordID/encounter number:\n\nOrijinal veri çerçevesini analiz için yalnızca satırlara küçültün/dilimleyin. Bu azaltılmış veri çerçevesini kaydedin/saklayın.\nOrijinal veri çerçevesinde, satırları, kayıtlı benzersiz tanımlayıcısının (bu örnekte recordID) indirgenmiş veri çerçevesinde bulunup bulunmadığına bağlı olarak case_when() ile uygun şekilde işaretleyin.\n\n\n# 1. Analiz için saklanacak satırların veri çerçevesini tanımlayın\nobs_keep &lt;- obs %&gt;%\n  group_by(name) %&gt;%\n  slice_max(encounter, n = 1, with_ties = FALSE) # her kişi başına yalnızca en son karşılaşmayı tutun\n\n\n# 2. Orijinal veri çerçevesini işaretleyin\nobs_marked &lt;- obs %&gt;%\n\n  # yeni dup_record sütunu oluşturun\n  mutate(dup_record = case_when(\n    \n    # kayıt obs_keep veri çerçevesindeyse\n    recordID %in% obs_keep$recordID ~ \"For analysis\", \n    \n    # analiz amacıyla \"Yoksay\" olarak işaretlenen diğer her şey\n    TRUE                            ~ \"Ignore\"))\n\n# yazdır\nobs_marked\n\n   recordID personID    name       date  time encounter purpose symptoms_ever\n1         1        1    adam 2020-01-01 09:00         1 contact          &lt;NA&gt;\n2         1        1    adam 2020-01-01 09:00         1 contact          &lt;NA&gt;\n3         2        2  amrish 2020-01-02 14:20         1 contact            No\n4         3        2  amrish 2020-01-02 14:20         1 contact            No\n5         4        3  mariah 2020-01-05 12:00         1    case            No\n6         5        2  amrish 2020-01-05 16:10         3    case           Yes\n7         6        4  nikhil 2020-01-05 13:01         1 contact           Yes\n8         7        5   brian 2020-01-05 15:20         1 contact            No\n9         8        6   smita 2020-01-05 14:20         1 contact           Yes\n10        9        7  raquel 2020-01-05 12:30         1 contact          &lt;NA&gt;\n11       10        2  amrish 2020-01-02 10:24         2 contact           Yes\n12       11        1    adam 2020-01-05 09:40         2    case            No\n13       12        3  mariah 2020-01-06 07:25         2 contact            No\n14       13        3  mariah 2020-01-06 08:32         3 contact            No\n15       14        4  nikhil 2020-01-06 15:36         2 contact           Yes\n16       15        5   brian 2020-01-06 15:31         2 contact           Yes\n17       16        5   brian 2020-01-07 07:59         3    case            No\n18       17        7  raquel 2020-01-07 11:13         2 contact            No\n19       18        8 natalie 2020-01-07 17:12         1    case            No\n     dup_record\n1        Ignore\n2        Ignore\n3        Ignore\n4        Ignore\n5        Ignore\n6  For analysis\n7        Ignore\n8        Ignore\n9  For analysis\n10       Ignore\n11       Ignore\n12 For analysis\n13       Ignore\n14 For analysis\n15 For analysis\n16       Ignore\n17 For analysis\n18 For analysis\n19 For analysis\n\n\n\n\n\n\n\n\nOrijinal veriyi incelemek için linke tıklayınız.\n\n\n\nSatır tamlığını hesapla\nSatırın tamlığı (eksik olmaması) için bir metrik içeren bir sütun oluşturun. Bu, tekilleştirme/dilimleme sırasında hangi satırların diğerlerine göre önceliklendirileceğine karar verirken yardımcı olabilir.\nBu örnekte, tamlığını ölçmek istediğiniz “anahtar” sütunlar, bir sütun adları vektörüne kaydedilir.\nDaha sonra mutate() ile yeni key_completeness sütunu oluşturulur. Her satırdaki yeni değer, hesaplanmış bir kesir olarak tanımlanır: o satırda anahtar sütunlar arasında eksik olmayan değerlerin sayısı, anahtar sütunların sayısına bölünür.\nBu işlem, base R’daki rowSums() fonksiyonunu içermektedir. Ayrıca, tünellemede, veri çerçevesindeki bir noktaya atıfta bulunan . kullanılır (bu durumda, köşeli parantez [] ile alt kümelenmektedir).\n*Daha fazla satır görmek için sağa kaydırın**\n\n# bir \"değişken tamlığı\" sütunu oluşturun\n# bu, eksik olmayan değerlere sahip \"key_cols\" olarak belirlenmiş sütunların *oranıdır*\n\nkey_cols = c(\"personID\", \"name\", \"symptoms_ever\")\n\nobs %&gt;% \n  mutate(key_completeness = rowSums(!is.na(.[,key_cols]))/length(key_cols)) \n\n\n\n\n\n\n\nOrijinal veriyi incelemek için linke tıklayınız.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Tekilleştirme</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.tr.html#str_rollup",
    "href": "new_pages/deduplication.tr.html#str_rollup",
    "title": "15  Tekilleştirme",
    "section": "15.4 Toplama değerleri",
    "text": "15.4 Toplama değerleri\nBu bölüm şunları açıklar:\n\nBazı varyasyonlarla birden çok satırdaki değerleri tek bir satıra “toplama”\n“Toplanmış” değerlere sahip olduğunuzda, her hücredeki değerlerin üzerine nasıl yazılır/öncelik verilir\n\nBu sekme, Hazırlık sekmesindeki örnek veri kümesini kullanır.\n\n\nDeğerleri bir satıra topla\nAşağıdaki kod örneği, satırları kişiye göre gruplandırmak için group_by() ve summarise() öğelerini kullanır ve ardından gruplanmış satırlardaki tüm benzersiz değerleri birbirine yapıştırır. Böylece kişi başına bir özet satırı elde edersiniz.\n\nTüm yeni sütunlara bir son ek eklenir (bu örnekte “_roll”).\nHücre başına yalnızca benzersiz değerleri göstermek istiyorsanız, na.omit() öğesini unique() ile sarın.\nna.omit() NA değerlerini kaldırır, ancak bu istenmiyorsa paste0(.x)… kaldırılabilir.\n\n\n# \"Toplama\" değerlerini grup başına bir satırda toplar (\"personID\" başına) \ncases_rolled &lt;- obs %&gt;% \n  \n  # Ada göre grup oluşturur\n  group_by(personID) %&gt;% \n  \n  # Her gruptaki satırları sıralar (ör. tarihe göre)\n  arrange(date, .by_group = TRUE) %&gt;% \n  \n  # Her sütun için, gruplandırılmış satırlardaki tüm değerleri \";\" ile ayırarak birbirine yapıştır\n  summarise(\n    across(everything(),                           # Tüm sütunlara uygula\n           ~paste0(na.omit(.x), collapse = \"; \"))) # NA olmayan benzersiz değerleri birleştiren işlev tanımlanır\n\nFonksiyonun çıktısı, girişlerin tarihe göre düzenlendiği ve birbirine yapıştırıldığı, grup başına bir satırdır (“ID”). Daha fazla satır görmek için sola kaydırın.\n\n\n\n\n\n\nOrijinal veriyi incelemek için linke tıklayınız.\nBu varyasyon yalnızca benzersiz değerleri gösterir:\n\n# Varyasyon - yalnızca benzersiz değerleri göster\ncases_rolled &lt;- obs %&gt;% \n  group_by(personID) %&gt;% \n  arrange(date, .by_group = TRUE) %&gt;% \n  summarise(\n    across(everything(),                                   # Tüm sütunlara uygular\n           ~paste0(unique(na.omit(.x)), collapse = \"; \"))) # NA olmayan benzersiz değerleri birleştiren işlev tanımlanır\n\n\n\n\n\n\n\nBu varyasyon, her sütuna bir son ek ekler.\nBu durumda, yuvarlandığını belirtmek için “_roll”:\n\n# Varyasyon - sütun adlarına eklenen sonek \ncases_rolled &lt;- obs %&gt;% \n  group_by(personID) %&gt;% \n  arrange(date, .by_group = TRUE) %&gt;% \n  summarise(\n    across(everything(),                \n           list(roll = ~paste0(na.omit(.x), collapse = \"; \")))) # _roll sütun adlarına eklenir\n\n\n\n\n\n\n\n\n\n\nDeğerlerin/hiyerarşinin üzerine yaz\nDaha sonra tüm yuvarlanan değerleri değerlendirmek ve yalnızca belirli bir değeri (örneğin, “en iyi” veya “maksimum” değer) tutmak istiyorsanız, dize kalıplarını sırayla aramak ve hücre içeriğinin üzerine yazmak için stringr paketinden str_detect() kullanan case_when() öğesini uygulamak için istenen sütunlarda mutate() öğesini kullanabilirsiniz.\n\n# TEMİZ VAKALAR\n#############\ncases_clean &lt;- cases_rolled %&gt;% \n    \n    # Temiz Evet-Hayır-Bilinmeyen değişkenler: metni dizede bulunan \"en yüksek\" değerle değiştir\n    mutate(across(c(contains(\"symptoms_ever\")),                     # belirtilen sütunlarda çalışır (E/H/B)\n             list(mod = ~case_when(                                 # yeni sütunlara \"_mod\" son ekini ekler; case_when() öğesini uygular\n               \n               str_detect(.x, \"Yes\")       ~ \"Yes\",                 # \"Evet\" algılanırsa, hücre değeri evet'e dönüşür\n               str_detect(.x, \"No\")        ~ \"No\",                  # daha sonra, \"Hayır\" algılanırsa, hücre değeri hayır'a dönüşür\n               str_detect(.x, \"Unknown\")   ~ \"Unknown\",             # daha sonra, \"Bilinmeyen\" algılanırsa, hücre değeri bilinmeyen'e dönüşür\n               TRUE                        ~ as.character(.x)))),   # sonra, başka bir şey varsa olduğu gibi tutulursa\n      .keep = \"unused\")                                             # eski sütunlar kaldırıldı, yalnızca _mod sütunları kaldı\n\nŞimdi, symptoms_ever sütununda görebilirsiniz, eğer kişi HEP semptomlara “Evet” dediyse, o zaman sadece “Evet” görüntülenir.\n\n\n\n\n\n\nOrijinal veriyi incelemek için linke tıklayınız.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Tekilleştirme</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.tr.html#probabilistic-de-duplication",
    "href": "new_pages/deduplication.tr.html#probabilistic-de-duplication",
    "title": "15  Tekilleştirme",
    "section": "15.5 Probabilistic de-duplication",
    "text": "15.5 Probabilistic de-duplication\nBazen, ad, yaş, cinsiyet, doğum tarihi vb. gibi çeşitli sütunlarda benzerliğe (ör. dize “mesafe”) dayalı olarak “olası” yinelemeleri belirlemek isteyebilirsiniz. Olası yinelemeleri belirlemek için olasılıklı bir eşleştirme algoritması uygulayabilirsiniz.\nBu yöntemle ilgili bir açıklama için [Verileri birleştirme] sayfasına bakın. Olasılıksal Eşleştirme bölümü, bir veri çerçevesini kendisiyle karşılaştırmak için bu algoritmaları uygulamanın bir örneğini içerir, böylece olasılıksal tekilleştirme gerçekleştirir.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Tekilleştirme</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.tr.html#kaynaklar",
    "href": "new_pages/deduplication.tr.html#kaynaklar",
    "title": "15  Tekilleştirme",
    "section": "15.6 Kaynaklar",
    "text": "15.6 Kaynaklar\nBu sayfadaki bilgilerin çoğu şu kaynaklardan ve çevrimiçi vinyetlerden uyarlanmıştır:\ndatanovia\ndplyr tidyverse reference\ncran janitor vignette",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Tekilleştirme</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.tr.html",
    "href": "new_pages/iteration.tr.html",
    "title": "16  Yineleme, döngüler ve listeler",
    "section": "",
    "text": "16.1 Hazırlık",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Yineleme, döngüler ve listeler</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.tr.html#hazırlık",
    "href": "new_pages/iteration.tr.html#hazırlık",
    "title": "16  Yineleme, döngüler ve listeler",
    "section": "",
    "text": "Paketleri yükleme\nBu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekli olursa paketi kuran ve kullanım için yükleyen pacman’ın p_load() fonksiyonunu vurguluyoruz. Ayrıca, R tabanından library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakın.\n\npacman::p_load(\n     rio,         # içe/dışa aktarma\n     here,        # dosya bulucu\n     purrr,       # yineleme\n     grates,      # scales in ggplot\n     tidyverse    # veri yönetimi ve görselleştirme\n)\n\n\n\nVerileri içe aktarma\nSimüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Devam etmek isterseniz, “temiz” satır listesini indirmek için tıklayın (.rds dosyası olarak). Verileri rio paketinden import() fonksiyonuyla içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe ve Dışa Aktarma] sayfasına bakın).\n\n# satır listesini içe aktar\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nÇizgi listesinin ilk 50 satırı aşağıda görüntülenir.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Yineleme, döngüler ve listeler</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.tr.html#for-döngüleri",
    "href": "new_pages/iteration.tr.html#for-döngüleri",
    "title": "16  Yineleme, döngüler ve listeler",
    "section": "16.2 for döngüleri",
    "text": "16.2 for döngüleri\n\nR’daki for döngüleri*\nfor döngüleri R’de vurgulanmaz, ancak diğer programlama dillerinde yaygındır. Yeni başlayan olarak, “keşfetmek”te , “hata ayıklamak”ta daha kolay oldukları için öğrenmek ve pratik yapmak için yardımcı olabilirler ve aksi takdirde, özellikle kendi işlevlerinizi yazarken henüz rahat değilseniz, her yinelemenin tam olarak ne olduğunu anlamalısınız.\npurrr ile eşlenmiş işlevlerle yinelemek için for döngüleri sayesinde hızla ilerleyebilirsiniz (aşağıdaki bölüme bakın).\n\n\nTemel bileşenler\nBir for döngüsünün üç temel parçası vardır:\n\nYinelenecek öğelerin sırası\n\nSıradaki her öğe başına yapılacak işlemler\nSonuçlar için kapsayıcı (isteğe bağlı)\n\nTemel sözdizimi şudur: for (sıradaki öğe) {öğeyi kullanarak işlemler yapın}. Parantezlere ve küme parantezlerine dikkat edin. Sonuçlar konsola yazdırılabilir veya bir kapsayıcı R nesnesinde saklanabilir.\nBasit bir for döngüsü örneği aşağıdadır.\n\nfor (num in c(1,2,3,4,5)) {  # SIRA tanımlanır (1'den 5'e kadar sayılar) ve \"{\" ile döngü açılır\n  print(num + 2)             # İŞLEMLER (her sıra numarasına iki tane ekleyin ve yazdırın)\n}                            # Döngü \"}\" ile kapatılır                          \n\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n\n                             # Bu örnekte \"kapsayıcı\" yok\n\n\n\nSıralama\nBu, for döngüsünün “for” kısmıdır - işlemler dizideki her öğe için “for” çalışır. Sıra, bir dizi değer (ör. yetki alanlarının adları, hastalıklar, sütun adları, liste öğeleri, vb.) olabilir veya bir dizi ardışık sayı (ör. 1,2,3,4,5) olabilir. Her yaklaşımın aşağıda açıklanan kendi araçları vardır.\nBir dizi ifadesinin temel yapısı vektördeki öğedir.\n\n“Öğe” yerine herhangi bir karakter veya kelime yazabilirsiniz (örn. “i”, “num”, “hosp”, “bölge” vb.). Bu “öğenin” değeri, vektördeki her değerden geçerek döngünün her yinelemesinde değişir.\nVektör, karakter değerleri, sütun adları veya belki bir dizi sayı olabilir - bunlar her yinelemede değişecek olan değerlerdir. Bunları “item” terimini kullanarak for döngüsü işlemleri içinde kullanabilirsiniz.\n\nÖrnek: karakter değerleri dizisi\nBu örnekte, hastane adlarının önceden tanımlanmış bir karakter vektöründeki her bir değer için bir döngü gerçekleştirilir.\n\n# hastane isimlerinin vektörünü yap\nhospital_names &lt;- unique(linelist$hospital)\nhospital_names # yazdır\n\n[1] \"Other\"                               \n[2] \"Missing\"                             \n[3] \"St. Mark's Maternity Hospital (SMMH)\"\n[4] \"Port Hospital\"                       \n[5] \"Military Hospital\"                   \n[6] \"Central Hospital\"                    \n\n\nHastane_adı - hospital_names vektöründen değerleri temsil etmek için hosp terimini seçtik. Döngünün ilk yinelemesi için, hosp değeri hastane_adı - hospital_names[[1]] olacaktır. İkinci döngü için hastane_adı - hospital_names[[2]] olacaktır. Ve bunun gibi…\n\n# karakter sıralı bir 'for döngüsü'\n\nfor (hosp in hospital_names){       # sıra\n  \n       # İŞLEMLER BURAYA YAZILIR\n  }\n\nÖrnek: sütun adları dizisi\nBu, mevcut bir R nesnesinin adlarının çıkarıldığı ve vektör haline geldiği, yukarıdaki karakter dizisinin bir varyasyonudur. Örneğin, bir veri çerçevesinin sütun adları. Uygun bir şekilde, for döngüsünün işlem kodunda, sütun adları orijinal veri çerçevelerini indekslemek (alt kümeler) için kullanılabilir.\nAşağıda sıra, satır listesi veri çerçevesinin adları - names() (sütun adları) şeklindedir. “Öğe” adımız, döngüler ilerledikçe her sütun adını temsil edecek olan col’dur.\nÖrnek olarak, dizideki her değer için çalıştırılan for döngüsünün içine işlem kodunu ekledik. Bu kodda, sıra değerleri (sütun adları), her seferinde bir satır listesini indekslemek (alt küme) için kullanılır. R temelleri sayfasında öğretildiği gibi, alt küme için çift köşeli ayraçlar [[ ]] kullanılır. Elde edilen sütun is.na() öğesine, ardından sütunda eksik olan değerlerin sayısını üretmek için sum() öğesine iletilir. Sonuç konsola yazdırılır - her sütun için bir sayı.\nSütun adlarıyla indeksleme hakkında bir not - sütunun kendisine atıfta bulunurken sadece “col” yazmayın! col sadece karakter sütun adını temsil eder! Tüm sütuna başvurmak için, sütun adını linelist[[col]] aracılığıyla satır listesinde bir dizin olarak kullanmalısınız.\n\nfor (col in names(linelist)){        # satır listesindeki her sütun için döngü çalışır; \"col\" ile temsil edilen sütun adı\n  \n  # Örnek işlem kodu - sütundaki eksik değerlerin sayısını yazdır\n  print(sum(is.na(linelist[[col]])))  # sıra listesi, \"col\" öğesinin geçerli değeriyle indekslenir\n     \n}\n\n[1] 0\n[1] 0\n[1] 2087\n[1] 256\n[1] 0\n[1] 936\n[1] 1323\n[1] 278\n[1] 86\n[1] 0\n[1] 86\n[1] 86\n[1] 86\n[1] 0\n[1] 0\n[1] 0\n[1] 2088\n[1] 2088\n[1] 0\n[1] 0\n[1] 0\n[1] 249\n[1] 249\n[1] 249\n[1] 249\n[1] 249\n[1] 149\n[1] 765\n[1] 0\n[1] 256\n\n\nSayıların dizisi\nBu yaklaşımda, dizi ardışık sayılar dizisidir. Bu nedenle, “öğe”nin değeri bir karakter değeri değil (ör. “Merkez Hastane” veya “tarih_başlangıç”) bir sayıdır. Bu, veri çerçevesini satır numarasına göre indekslemek için for döngüsü içindeki “öğe” numarasını kullanabileceğiniz için veri çerçeveleri arasında döngü yapmak için kullanışlıdır.\nÖrneğin, veri çerçevenizdeki her satırda döngü yapmak ve belirli bilgileri çıkarmak istediğinizi varsayalım. “Öğeleriniz” sayısal satır numaraları olacaktır. Çoğu zaman, bu durumda “öğeler” i olarak yazılır.\nFor döngüsü işlemi, “veri çerçevemdeki 1’den toplam satır sayısına kadar bir sayı dizisindeki her öğe için X yap” şeklinde açıklanabilir. Döngünün ilk yinelemesi için “item” i değeri 1 olur. İkinci yineleme için i 2 olur, vb.\nSıra kodda şöyle görünür: for (i in 1:nrow(linelist)) {OPERATIONS CODE} burada i “öğeyi” temsil eder ve 1:nrow(linelist) 1’den satır listesindeki satır sayısına kadar ardışık sayılar dizisi üretir.\n\nfor (i in 1:nrow(linelist)) {  # bir veri çerçevesinde kullan\n  # İŞLEMLER BURAYA YAZILIR\n}  \n\nDizinin sayı olmasını istiyorsanız, ancak bir vektörden başlıyorsanız (bir veri çerçevesi değil), vektördeki her bir öğeki bir sayı dizisini döndürmek için seq_along() kısayolunu kullanın. Örneğin, for (i in seq_along(hospital_names) {OPERATIONS CODE}.\nAşağıdaki kod aslında kendi döngülerinde i’nin değeri olacak olan sayıları döndürür.\n\nseq_along(hospital_names)  # adlandırılmış bir vektör üzerinde kullan\n\n[1] 1 2 3 4 5 6\n\n\nDizide sayıları kullanmanın bir avantajı, döngü çıktılarını depolayan bir kapsayıcıyı indekslemek için i numarasını kullanmanın da kolay olmasıdır. Aşağıdaki İşlemler bölümünde bunun bir örneği var.\n\n\nOperasyonlar\nBu, for döngüsünün küme parantezleri { } içindeki koddur. Bu kodun sıradaki her “öğe” için çalışmasını istiyorsunuz. Bu nedenle, kodunuzun “öğe” ile değişen her parçasının gerçekten değişeceği şekilde doğru kodlanmış olmasına dikkat edin! Örneğin, indeksleme için [[ ]] kullanmayı unutmayın.\nAşağıdaki örnekte, satır listesindeki her bir satırı yineliyoruz. Her satırın cinsiyet - gender ve yaş - age değerleri birbirine yapıştırılır ve cases_demographics kapsayıcı karakter vektöründe saklanır. Döngü çıktısını “kapsayıcı” vektöründe doğru konuma kaydetmek için indekslemeyi [[i]] nasıl kullandığımıza dikkat edin.\n\n# sonuçları depolamak için kapsayıcı oluştur - bir karakter vektörü\ncases_demographics &lt;- vector(mode = \"character\", length = nrow(linelist))\n\n# for döngüsü\nfor (i in 1:nrow(linelist)){\n  \n  # OPERASYONLAR\n  # indeksleme için parantez kullanarak satır i için satır listesinden değerleri ayıkla\n  row_gender  &lt;- linelist$gender[[i]]\n  row_age     &lt;- linelist$age_years[[i]]    # indekslemeyi unutmayın!\n     \n  # cinsiyet-yaşı birleştirin ve indekslenmiş konumda kapsayıcı vektöründe sakla\n  cases_demographics[[i]] &lt;- str_c(row_gender, row_age, sep = \",\") \n\n}  # döngü sonu\n\n\n# kapsayıcının ilk 10 satırını göster\nhead(cases_demographics, 10)\n\n [1] \"m,2\"  \"f,3\"  \"m,56\" \"f,18\" \"m,3\"  \"f,16\" \"f,16\" \"f,0\"  \"m,61\" \"f,27\"\n\n\n\n\nKapsayıcı\nBazen for döngüsünün sonuçları konsola veya RStudio Plots bölmesine yazdırılır. Diğer zamanlarda, çıktıları daha sonra kullanmak üzere bir “kapsayıcı”da saklamak isteyeceksiniz. Böyle bir kapsayıcı, bir vektör, bir veri çerçevesi ve hatta bir liste olabilir.\nFor döngüsüne başlamadan önce bile sonuçlar için kapsayıcı oluşturmak en verimli yöntemdir. Pratikte bu, boş bir vektör, veri çerçevesi veya liste oluşturmak anlamına gelir. Bunlar, vektörler veya listeler için vector() işlevleriyle veya bir veri çerçevesi için matrix() ve data.frame() işlevleriyle oluşturulabilir.\nBoş vektör\nvector()’u kullanın ve ekleyeceğiniz nesnelerin beklenen sınıfına göre mode = belirtin - “çift” (sayıları tutmak için), “karakter” veya “mantıksal”. Ayrıca length = önceden ayarlamalısınız. Bu, for döngüsü dizinizin uzunluğu olmalıdır.\nHer hastane için medyan kabul gecikmesini saklamak istediğinizi varsayalım. “Çift” kullanır ve uzunluğu beklenen çıktıların sayısı (veri setindeki benzersiz hastanelerin sayısı) olarak ayarlarsınız.\n\ndelays &lt;- vector(\n  mode = \"double\",                            # numaraları kaydetmeyi bekliyoruz\n  length = length(unique(linelist$hospital))) # veri setindeki benzersiz hastanelerin sayısı\n\nBoş veri çerçevesi\nBunun gibi satır ve sütun sayısını belirterek boş bir veri çerçevesi oluşturabilirsiniz:\n\ndelays &lt;- data.frame(matrix(ncol = 2, nrow = 3))\n\nBoş liste\nBir for döngüsü tarafından oluşturulan bazı grafikleri bir listede saklamak isteyebilirsiniz. Liste vektör gibidir, ancak içinde farklı sınıflardan olabilen diğer R nesnelerini içerir. Listedeki öğeler tek bir sayı, bir veri çerçevesi, bir vektör ve hatta başka bir liste olabilir.\nAslında yukarıdakiyle aynı vector() komutunu kullanarak, ancak mode = \"list\" ile boş bir liste başlatıyorsunuz. Uzunluğu istediğiniz gibi belirtin.\n\nplots &lt;- vector(mode = \"list\", length = 16)\n\n\n\nYazdırma\nBir for döngüsü içinden yazdırmak için büyük olasılıkla print() işleviyle açıkça sarmanız gerekeceğini unutmayın.\nAşağıdaki bu örnekte dizi, hastane tarafından satır listesinin alt kümesi için kullanılan açık bir karakter vektörüdür. Sonuçlar bir kapsayıcıda saklanmaz, bunun yerine print() işleviyle konsola yazdırılır.\n\nfor (hosp in hospital_names){ \n     hospital_cases &lt;- linelist %&gt;% filter(hospital == hosp)\n     print(nrow(hospital_cases))\n}\n\n[1] 885\n[1] 1469\n[1] 422\n[1] 1762\n[1] 896\n[1] 454\n\n\n\n\nFor döngüsünü test etme\nDöngünüzü test etmek için, i &lt;- 10 veya hosp &lt;- \"Central Hospital\" gibi “öğe”nin geçici bir atamasını yapmak için bir komut çalıştırabilirsiniz. Bunu döngünün dışında yapın ve ardından beklenen sonuçların üretilip üretilmediğini görmek için yalnızca işlem kodunuzu (kıvrımlı parantez içindeki kod) çalıştırın.\n\n\nDöngü grafikleri\nÜç bileşeni (kapsayıcı, sıralama ve operasyonlar) bir araya getirmek için her hastane için bir epi eğrisi çizmeye çalışalım ([Salgın eğrileri] sayfasına bakın).\nAşağıdaki gibi incidence2 paketini kullanarak tüm vakaların cinsiyete göre güzel bir epik eğrisini yapabiliriz:\n\n# 'insidans' nesnesi oluşturun\noutbreak &lt;- incidence2::incidence(   \n     x = linelist,                   # dataframe - tam satır listesi\n     date_index = \"date_onset\",      # tarih sütunu\n     interval = \"week\",              # haftalık toplu sayımlar\n     groups = \"gender\")              # cinsiyete göre grup değerleri\n     #na_as_group = TRUE)            # eksik cinsiyet ayrı bir gruptur\n\n# plot epi eğrisi\nggplot(outbreak, # nom de l'objet d'incidence\n        aes(x = date_index, #aesthetiques et axes\n            y = count, \n            fill = gender), # Fill colour of bars by gender\n       color = \"black\"      # Contour colour of bars\n       ) +  \n     geom_col() + \n     facet_wrap(~gender) +\n     theme_bw() + \n     labs(title = \"Outbreak of all cases\", #titre\n          x = \"Counts\", \n          y = \"Date\", \n          fill = \"Gender\", \n          color = \"Gender\")\n\n\n\n\n\n\n\n\nHer hastanenin vakası için ayrı bir grafik oluşturmak için bu epi eğri kodunu bir for döngüsüne koyabiliriz.\nİlk olarak, benzersiz hastane adlarının adlandırılmış bir vektörünü, hospital_names olarak kaydederiz. for döngüsü şu adların her biri için bir kez çalışacaktır: for (hosp in hospital_names). for döngüsünün her yinelemesinde, vektörden gelen mevcut hastane adı, döngü içinde kullanım için hosp olarak temsil edilecektir.\nDöngü işlemleri içinde, normal olarak R kodunu yazabilirsiniz, ancak değerinin değişeceğini bilerek “öğe”yi (bu durumda hosp) kullanın. Bu döngü içinde:\n\nSatır listesine bir filter() uygulanır, öyle ki hastane - hospital sütunu, hosp’un mevcut değerine eşit olmalıdır.\nİnsidans nesnesi, filtrelenmiş satır listesinde oluşturulur.\nMevcut hastane için grafik, hosp kullanan otomatik ayarlı bir başlıkla oluşturulur.\nMevcut hastane için grafik geçici olarak kaydedilir ve ardından yazdırılır.\nDöngü, daha sonra, hospital_names içindeki bir sonraki hastane ile tekrar etmek için ilerler\n\n\n# hastane isimlerinin vektörünü yapın\nhospital_names &lt;- unique(linelist$hospital)\n\n# hospital_names deki her ad (\"hosp\") için epi eğrisini oluşturun ve yazdırın\nfor (hosp in hospital_names) {\n     \n     # mevcut hastaneye özgü olay nesnesi oluşturun\n     outbreak_hosp &lt;- incidence2::incidence(\n          x = linelist %&gt;% filter(hospital == hosp),   # satır listesi mevcut hastaneye göre filtrelenir\n          date_index = \"date_onset\",\n          interval = \"week\", \n          groups = \"gender\"#,\n          #na_as_group = TRUE\n     )\n     \n     # Grafik oluşturun ve kaydedin. Başlık otomatik olarak mevcut hastaneye göre ayarlanır\n      plot_hosp &lt;- ggplot(outbreak_hosp, # incidence object name\n                         aes(x = date_index, #axes\n                             y = count, \n                             fill = gender), # fill colour by gender\n                         color = \"black\"      # colour of bar contour\n                         ) +  \n          geom_col() + \n          facet_wrap(~gender) +\n          theme_bw() + \n          labs(title = stringr::str_glue(\"Epidemic of cases admitted to {hosp}\"), #title\n               x = \"Counts\", \n               y = \"Date\", \n               fill = \"Gender\", \n               color = \"Gender\")\n     \n     # With older versions of R, remove the # before na_as_group and use this plot command instead.\n    # plot_hosp &lt;- plot(\n#       outbreak_hosp,\n#       fill = \"gender\",\n#       color = \"black\",\n#       title = stringr::str_glue(\"Epidemic of cases admitted to {hosp}\")\n#     )\n     \n     # mevcut hastane için grafik yazdırın\n     print(plot_hosp)\n     \n} # hospital_names içindeki her hastane için çalıştırıldığında for döngüsünü sonlandırın \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBir döngünün ilerlemesini izleme\nBirçok yinelemeli bir döngü, dakikalarca hatta saatlerce çalışabilir. Bu nedenle, ilerlemeyi R konsoluna yazdırmak yararlı olabilir. Aşağıdaki if ifadesi, her 100. sayıyı yazdırmak için döngü fonksiyonlarının içine yerleştirilebilir. Döngünüzdeki “öğe” i olacak şekilde ayarlayın.\n\n# her 100 yinelemede ilerlemeyi yazdırmak için kodlu döngü\nfor (i in seq_len(nrow(linelist))){\n\n  # yazdırma ilerlemesi\n  if(i %% 100==0){    # %% operatörü kalandır\n    print(i)\n\n}",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Yineleme, döngüler ve listeler</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.tr.html#iter_purrr",
    "href": "new_pages/iteration.tr.html#iter_purrr",
    "title": "16  Yineleme, döngüler ve listeler",
    "section": "16.3 purrr ve listeler",
    "text": "16.3 purrr ve listeler\nYinelemeli işlemlere başka bir yaklaşım da purrr paketidir - yineleme için tidyverse yaklaşımdır.\nAynı görevi birkaç kez yapmakla karşı karşıya kalırsanız, muhtemelen birçok girdide kullanabileceğiniz genelleştirilmiş bir çözüm oluşturmaya değer. Örneğin, birden fazla yetki alanları için grafikler oluşturmak veya birçok dosyayı içe aktarmak ve birleştirmek.\nAyrıca purrr’ın birkaç avantajı daha vardır - %&gt;% tünelleriyle kullanabilirsiniz, for döngülerine kıyasla normalden daha iyi hataları ele alır ve sözdizimi oldukça temiz ve basittir! Bir for döngüsü kullanıyorsanız, muhtemelen purrr ile daha net ve özlü bir şekilde yapabilirsiniz!\npurrr’ın fonksiyonel programlama aracı olduğunu unutmayın. Yani, yinelemeli olarak uygulanacak işlemler fonksiyonlara sarılır. Kendi işlevlerinizi nasıl yazacağınızı öğrenmek için [Yazma işlevleri] sayfasına bakın.\npurrr ayrıca neredeyse tamamen listeler ve vektörler üzerine kuruludur - bu yüzden bunu o listenin/vektörün her bir öğesine bir işlev uygulamak olarak düşünün!\n\nPaketleri yükleme\npurrr tidyverse’in bir parçasıdır, bu nedenle ayrı bir paket kurmaya/yüklemeye gerek yoktur.\n\npacman::p_load(\n     rio,            # içe/dışa aktar\n     here,           # ilgili dosya yolları\n     tidyverse,      # mgt ve viz verisi\n     writexl,        # Excel dosyasını birden çok sayfayla yaz\n     readxl          # Excel'i birden çok sayfayla içe aktar\n)\n\n\n\nmap()\npurrr’un temel bir işlevi, sağladığınız bir listenin/vektörün her giriş öğesine bir işlevi “eşleyen” (uygulayan) map() işlevidir.\nTemel sözdizimi map(.x = SEQUENCE, .f = FUNCTION, OTHER ARGUMENTS). Biraz daha ayrıntılı olarak:\n\n.x =, .f işlevinin yinelemeli olarak uygulanacağı girdilerdir - ör. yetki alanları adları vektörü, veri çerçevesindeki sütunlar veya veri çerçeveleri listesi.\n.f =, .x girişinin her bir öğesine uygulanacak fonksiyondur - zaten var olan print() gibi bir işlev veya tanımladığınız özel bir işlev olabilir. İşlev genellikle yaklaşık işaretinden sonra yazılır ~ (ayrıntılar aşağıdadır).\n\nSözdizimi hakkında birkaç not daha:\n\nFonksiyonun daha fazla argümana ihtiyacı yoksa, parantez ve yaklaşık işareti olmadan yazılabilir (ör. .f = mean). Her yineleme için aynı değerde olacak bağımsız değişkenler sağlamak için, bunları map() içinde ancak .f = bağımsız değişkeninin dışında sağlayın, örneğin na.rm = T içine map(.x = my_list, .f = mean, na.rm=T).\nBu yinelemenin .x değeri için yer tutucu olarak .f = fonksiyonu içinde .x (veya basitçe .) kullanabilirsiniz.\nFonksiyon üzerinde daha fazla kontrole sahip olmak için yaklaşık sözdizimini (~) kullanın - fonksiyonu parantez içinde normal olarak yazın, örneğin: map(.x = my_list, .f = ~mean(., na.rm = T)). Bu söz dizimini özellikle bir bağımsız değişkenin değeri her yinelemeyi değiştirecekse veya .x değerinin kendisiyse kullanın (aşağıdaki örneklere bakın)\n\nmap() kullanımının çıktısı bir listedir - liste, vektör gibi bir nesne sınıfıdır, ancak öğeleri farklı sınıflardan olabilir. Bu nedenle, map() tarafından üretilen bir liste birçok veri çerçevesi veya birçok vektör, birçok tek değer ve hatta birçok liste içerebilir! Aşağıda açıklanan ve diğer çıktı türlerini üreten alternatif map() sürümleri vardır (örneğin, bir veri çerçevesi oluşturmak için .map_dfr(), karakter vektörleri üretmek için map_chr() ve sayısal vektörler üretmek için map_dbl()).\n\nÖrnek - Excel sayfalarını içe aktarın ve birleştirin\nYaygın bir epidemiyolog göreviyle gösterelim: - aka verileri içeren bir Excel çalışma kitabını içe aktarmak istiyorsunuz, ancak veriler çalışma kitabındaki farklı adlandırılmış sayfalara bölünüyor. Sayfaları tek bir veri çerçevesinde nasıl verimli bir şekilde içe aktarır ve birleştirirsiniz?\nDiyelim ki aşağıdaki Excel çalışma kitabı bize gönderildi. Her sayfa belirli bir hastaneden vakaları içerir.\n\n\n\n\n\n\n\n\n\nİşte map() kullanan bir yaklaşım:\n\nmap() import() işlevi, böylece her Excel sayfası için çalışır\nbind_rows() kullanarak içe aktarılan veri çerçevelerini bir araya getirin\nYol boyunca, her satır için orijinal sayfa adını koruyarak bu bilgiyi son veri çerçevesinde yeni bir sütunda saklayın\n\nİlk olarak, sayfa adlarını çıkarmamız ve kaydetmemiz gerekiyor. Excel çalışma kitabının dosya yolunu, sayfa adlarını ayıklayan readxl paketinden excel_sheets() işlevine sağlıyoruz. Bunları sheet_names adlı bir karakter vektöründe saklarız.\n\nsheet_names &lt;- readxl::excel_sheets(\"hospital_linelists.xlsx\")\n\nİşte isimler:\n\nsheet_names\n\n[1] \"Central Hospital\"              \"Military Hospital\"            \n[3] \"Missing\"                       \"Other\"                        \n[5] \"Port Hospital\"                 \"St. Mark's Maternity Hospital\"\n\n\nArtık bu ad vektörüne sahip olduğumuza göre, map() bunları import()işlevine birer birer sağlayabilir. Bu örnekte sheet_names, .x ve import() .f işlevidir.\nİçe aktarma ve dışa aktarma sayfasından, Excel çalışma kitaplarında kullanıldığında import() öğesinin içe aktarılacak sayfayı belirten which = bağımsız değişkeni kabul edebileceğini hatırlayın..f fonksiyonu import() içinde, sheet_names vektörü aracılığıyla değeri her yinelemede değişecek olan which = .x’i sağlarız - önce “Merkez Hastane”, ardından “Askeri Hastane” vb.\nNot - map() kullandığımız için, her Excel sayfasındaki veriler bir liste içinde ayrı bir veri çerçevesi olarak kaydedilecektir. Bu liste öğelerinin (veri çerçevelerinin) her birinin bir ada sahip olmasını istiyoruz, bu nedenle sheet_names map()’e aktarmadan önce onu set_names() aracılığıyla purrr’dan geçiririz, bu da her liste öğesinin uygun adı almasını sağlar.\nÇıktı listesini combined olarak kaydediyoruz.\n\ncombined &lt;- sheet_names %&gt;% \n  purrr::set_names() %&gt;% \n  map(.f = ~import(\"hospital_linelists.xlsx\", which = .x))\n\nÇıktıyı incelediğimizde, her bir Excel sayfasındaki verilerin bir adla listeye kaydedildiğini görüyoruz. Bu iyi, ama tam olarak bitirmedik.\n\n\n\n\n\n\n\n\n\nSon olarak, benzer şekilde yapılandırılmış veri çerçevelerinin listesini kabul eden ve bunları tek bir veri çerçevesinde birleştiren bind_rows() (dplyr’den) işlevini kullanıyoruz. Liste öğesi adlarından yeni bir sütun oluşturmak için, .id = bağımsız değişkenini kullanırız ve ona yeni sütun için istenen adı veririz.\nTüm komut dizisi aşağıdadır:\n\nsheet_names &lt;- readxl::excel_sheets(\"hospital_linelists.xlsx\")  # extract sheet names\n \ncombined &lt;- sheet_names %&gt;%                                     # begin with sheet names\n  purrr::set_names() %&gt;%                                        # set their names\n  map(.f = ~import(\"hospital_linelists.xlsx\", which = .x)) %&gt;%  # iterate, import, save in list\n  bind_rows(.id = \"origin_sheet\") # combine list of data frames, preserving origin in new column  \n\nVe şimdi, orijin sayfasını içeren bir sütuna sahip bir veri çerçevemiz var!\n\n\n\n\n\n\n\n\n\nBilmeniz gereken map() varyasyonları vardır. Örneğin, map_dfr() bir liste değil, bir veri çerçevesi döndürür. Böylece yukarıdaki görev için kullanabilirdik ve satırları bağlamak zorunda kalmazdık. Ama o zaman her vakanın hangi sayfadan (hastaneden) geldiğini yakalayamazdık.\nDiğer varyasyonlar arasında map_chr(), map_dbl() bulunur. Bunlar iki nedenden dolayı çok faydalı işlevlerdir. İlk önce. yinelemeli bir işlevin çıktısını otomatik olarak bir vektöre (listeye değil) dönüştürürler. İkincisi, verilerin geri geldiği sınıfı açıkça kontrol edebilirler - verilerinizin map_chr() ile bir karakter vektörü veya map_dbl() ile sayısal vektör olarak geri gelmesini sağlarsınız. Bölümde daha sonra bunlara dönelim!\nmap_at() ve map_if() işlevleri yineleme için de çok kullanışlıdır - bir listenin hangi öğelerini yinelemeniz gerektiğini belirlemenize izin verirler! Bunlar basitçe bir dizin/ad vektörü (map_at() durumunda) veya mantıksal bir test (map_if() durumunda) uygulayarak çalışır.\nHastane verilerinin ilk sayfasını okumak istemediğimiz bir örnek kullanalım. map() yerine map_at() kullanırız ve .at = bağımsız değişkeni c(-1) olarak belirtiriz, bu da .x’in ilk öğesini kullanılmaması anlamına gelir. Alternatif olarak, hangi öğelerin kullanılacağını belirtmek için, .at = için, bir pozitif sayı veya ad vektörü sağlayabilirsiniz.\n\nsheet_names &lt;- readxl::excel_sheets(\"hospital_linelists.xlsx\")\n\ncombined &lt;- sheet_names %&gt;% \n     purrr::set_names() %&gt;% \n     # ilk sayfayı hariç tut\n     map_at(.f = ~import( \"hospital_linelists.xlsx\", which = .x),\n            .at = c(-1))\n\nİlk sayfa adının yine de çıktı listesinin bir öğesi olarak görüneceğini unutmayın - ancak bu yalnızca tek bir karakter adıdır (veri çerçevesi değil). Satırları bağlamadan önce bu öğeyi kaldırmanız gerekir. Liste öğelerinin nasıl kaldırılacağını ve değiştirileceğini daha sonraki bir bölümde ele alacağız.\n\n\n\nVeri kümesini bölme ve dışa aktarma\nAşağıda, bir veri kümesinin parçalara nasıl bölüneceğine ve ardından her bir parçayı ayrı bir Excel sayfası veya ayrı bir CSV dosyası olarak dışa aktarmak için map() yinelemesinin nasıl kullanılacağına ilişkin bir örnek veriyoruz.\n\nBölünmüş veri seti\nVeri çerçevesi olarak tam vaka satır listesine sahip olduğumuzu ve şimdi her hastane için ayrı bir satır listesi oluşturmak ve her birini ayrı bir CSV dosyası olarak dışa aktarmak istediğimizi varsayalım. Aşağıda, izleyen adımları yapıyoruz:\nhospital sütunundaki benzersiz değerlere göre satır listesi veri çerçevesini bölmek için group_split() (dplyr’den) kullanın. Çıktı, her hastane alt kümesi başına bir veri çerçevesi içeren bir listedir.\n\nlinelist_split &lt;- linelist %&gt;% \n     group_split(hospital)\n\nView(linelist_split) çalıştırabilir ve bu listenin her birinin bir hastaneden vakaları temsil eden 6 veri çerçevesi (“tibbles”) içerdiğini görebiliriz.\n\n\n\n\n\n\n\n\n\nAncak, listedeki veri çerçevelerinin varsayılan olarak adları olmadığını unutmayın! Her birinin bir adı olmasını ve ardından CSV dosyasını kaydederken bu adı kullanmasını istiyoruz.\nAdları çıkarmaya yönelik bir yaklaşım, listedeki her veri çerçevesinden hospital sütununu çıkarmak için pull() (dplyr’den) kullanmaktır. Ardından, güvende olmak için değerleri karaktere dönüştürürüz ve ardından o belirli veri çerçevesinin adını almak için unique() işlevini kullanırız. Bu adımların tümü, her veri çerçevesine map() aracılığıyla uygulanır.\n\nnames(linelist_split) &lt;- linelist_split %&gt;%   # Assign to names of listed data frames \n     # Extract the names by doing the following to each data frame: \n     map(.f = ~pull(.x, hospital)) %&gt;%        # Pull out hospital column\n     map(.f = ~as.character(.x)) %&gt;%          # Convert to character, just in case\n     map(.f = ~unique(.x))                    # Take the unique hospital name\n\nArtık liste öğelerinin her birinin bir adı olduğunu görebiliriz. Bu isimlere names(linelist_split) üzerinden erişilebilir.\n\n\n\n\n\n\n\n\n\n\nnames(linelist_split)\n\n[1] \"Central Hospital\"                    \n[2] \"Military Hospital\"                   \n[3] \"Missing\"                             \n[4] \"Other\"                               \n[5] \"Port Hospital\"                       \n[6] \"St. Mark's Maternity Hospital (SMMH)\"\n\n\n\nBirden fazla group_split() sütunu\nHastane VE cinsiyetin kesişimine göre alt küme satır listesi üretmek gibi, satır listesini birden fazla gruplama sütununa bölmek istiyorsanız, liste öğelerini adlandırmak için farklı bir yaklaşıma ihtiyacınız olacaktır. Bu, dplyr’den group_keys() kullanarak benzersiz “grup anahtarları”nın toplanmasını içerir - bunlar bir veri çerçevesine döndürülür. Ardından, aşağıda gösterildiği gibi unite() ile grup anahtarlarını değerler halinde birleştirebilir ve bu grup adlarını linelist_split’e atayabilirsiniz.\n\n# benzersiz hastane-cinsiyet kombinasyonlarına göre bölünmüş satır listesi\nlinelist_split &lt;- linelist %&gt;% \n     group_split(hospital, gender)\n\n# group_keys() öğesini bir veri çerçevesi olarak çıkar\ngroupings &lt;- linelist %&gt;% \n     group_by(hospital, gender) %&gt;%       \n     group_keys()\n\ngroupings      # benzersiz gruplamaları göster \n\n# A tibble: 18 × 2\n   hospital                             gender\n   &lt;chr&gt;                                &lt;chr&gt; \n 1 Central Hospital                     f     \n 2 Central Hospital                     m     \n 3 Central Hospital                     &lt;NA&gt;  \n 4 Military Hospital                    f     \n 5 Military Hospital                    m     \n 6 Military Hospital                    &lt;NA&gt;  \n 7 Missing                              f     \n 8 Missing                              m     \n 9 Missing                              &lt;NA&gt;  \n10 Other                                f     \n11 Other                                m     \n12 Other                                &lt;NA&gt;  \n13 Port Hospital                        f     \n14 Port Hospital                        m     \n15 Port Hospital                        &lt;NA&gt;  \n16 St. Mark's Maternity Hospital (SMMH) f     \n17 St. Mark's Maternity Hospital (SMMH) m     \n18 St. Mark's Maternity Hospital (SMMH) &lt;NA&gt;  \n\n\nŞimdi, tire ile ayrılmış gruplamaları bir araya getiriyoruz ve bunları linelist_split’te liste elemanlarının adları olarak atadık. NA’yı “Eksik” ile değiştirdiğimiz için bu, bazı ekstra satırlar alır, sütun değerlerini birleştirmek için dplyr’den unite() kullanın (tire ile ayrılmış), ve sonra linelist_split adları olarak kullanılabilmesi için adsız bir vektöre dönüştürün.\n\n# Tek bir ad değerinde birleştir\nnames(linelist_split) &lt;- groupings %&gt;% \n     mutate(across(everything(), replace_na, \"Missing\")) %&gt;%  # tüm sütunlarda NA'yı \"Eksik\" ile değiştir\n     unite(\"combined\", sep = \"-\") %&gt;%                         # Tüm sütun değerlerini tek bir sütunda birleştir\n     setNames(NULL) %&gt;% \n     as_vector() %&gt;% \n     as.list()\n\n\n\n\nExcel sayfaları olarak dışa aktar\nHastane satır listelerini, sayfa başına bir satır listesi ile bir Excel çalışma kitabı olacak şekilde dışa aktarmak için, writexl paketinden write_xlsx() işlevine yalnızca linelist_split adlı listeyi sağlayabiliriz. Bu, birden çok sayfa içeren bir Excel çalışma kitabını kaydetme özelliğine sahiptir. Liste öğesi adları, sayfa adları olarak otomatik olarak uygulanır.\n\nlinelist_split %&gt;% \n     writexl::write_xlsx(path = here(\"data\", \"hospital_linelists.xlsx\"))\n\nArtık Excel dosyasını açıp her hastanenin kendi sayfası olduğunu görebilirsiniz.\n\n\n\n\n\n\n\n\n\n\n\nExport as CSV files\nBu biraz daha karmaşık bir komuttur, ancak hastaneye özel her bir satır listesini hastaneye özel bir dosya adıyla ayrı bir CSV dosyası olarak da dışa aktarabilirsiniz.\nYine map() kullanıyoruz: liste öğesi adlarının (yukarıda gösterilen) vektörünü alıyoruz ve bunlar arasında yineleme yapmak için map() kullanıyoruz, bu adı taşıyan linelist_split listesindeki veri çerçevesine export() (rio paketinden, [İçe ve dışa aktarma] sayfasına bakın) uyguluyoruz. Adı benzersiz bir dosya adı oluşturmak için de kullanırız. İşte nasıl çalıştığı:\n\nmap()’e .x olarak iletilen karakter adlarının vektörüyle başlıyoruz.\n.f fonksiyonu, bir veri çerçevesi ve yazmak için bir dosya yolu gerektiren export() işlevidir.\n.x girişi (hastane adı), linelist_split listesinin o belirli öğesini çıkarmak/indekslemek için .f içinde kullanılır. Bu, export() işlevine aynı anda yalnızca bir veri çerçevesinin sağlanmasıyla sonuçlanır.\nÖrneğin, map() “Askeri Hastane” için yinelendiğinde, linelist_split[[.x]] aslında linelist_split[[\"Military Hospital\"]] olur, bu nedenle linelist_split öğesinin ikinci öğesini döndürür - ki bu, Askeri Hastanedeki tüm vakalardır.\nexport() için sağlanan dosya yolu, str_glue() kullanımı yoluyla dinamiktir (bkz. Karakterler ve dizeler sayfası):\n\nhere() dosya yolunun temelini almak ve “data” klasörünü belirtmek için kullanılır (str_glue() çift tırnak işaretini kesmemek için tek tırnak işaretlerini not edin)\n\nArdından bir eğik çizgi / ve ardından tekrar dosyanın tanımlanabilmesi için mevcut hastane adını yazdıran.x\nSon olarak, export() öğesinin bir CSV dosyası oluşturmak için kullandığı “.csv” uzantısı\n\n\nnames(linelist_split) %&gt;%\n     map(.f = ~export(linelist_split[[.x]], file = str_glue(\"{here('data')}/{.x}.csv\")))\n\nArtık her dosyanın R Project “Epi_R_handbook” un “data” klasörüne kaydedildiğini görebilirsiniz!\n\n\n\n\n\n\n\n\n\n\n\n\nÖzel işlevler\nmap() sağlamak için kendi işlevinizi oluşturmak isteyebilirsiniz.\nHer hastanenin vakası için salgın eğrileri oluşturmak istediğimizi varsayalım. Bunu purrr kullanarak yapmak için, .f işlevimiz her zamanki gibi ggplot() ve + ile uzantılar olabilir. map() çıktısı her zaman bir liste olduğundan, grafikler bir listede saklanır. Grafikler oldukları için, ggpubr paketinden ggarrange() fonksiyonuyla çıkarılabilir ve grafiklendirilebilir. (dokümantasyon)\n\n# listeden öğeleri grafiklendirebilmek için paketi yükle\npacman::p_load(\"ggpubr\")\n\n# 6 hastane \"adlar\"ının vektörü boyunca haritala (daha önce oluşturulmuş)\n# belirtilen ggplot işlevini kullanın\n# çıktı, 6 ggplot içeren bir listedir\nhospital_names &lt;- unique(linelist$hospital)\n\nmy_plots &lt;- map(\n  .x = hospital_names,\n  .f = ~ggplot(data = linelist %&gt;% filter(hospital == .x)) +\n                geom_histogram(aes(x = date_onset)) +\n                labs(title = .x)\n)\n\n# ggplot'ları yazdırın (bir listede saklanırlar)\nggarrange(plotlist = my_plots, ncol = 2, nrow = 3)\n\n\n\n\n\n\n\n\nBu map() kodu çok dağınık görünüyorsa, ilgili ggplot() komutunuzu özel bir kullanıcı tanımlı fonksiyon olarak kaydederek aynı sonucu elde edebilirsiniz, örneğin ona make_epicurve() adını verebiliriz. Bu işlev daha sonra map() içinde kullanılır. .x yinelemeli olarak hastane adıyla değiştirilecek ve make_epicurve() fonksiyonunda hosp_name olarak kullanılacaktır. Detaylar için [Yazma fonksiyonları] sayfasına bakın.\n\n# Fonksiyon oluştur\nmake_epicurve &lt;- function(hosp_name){\n  \n  ggplot(data = linelist %&gt;% filter(hospital == hosp_name)) +\n    geom_histogram(aes(x = date_onset)) +\n    theme_classic()+\n    labs(title = hosp_name)\n  \n}\n\n\n# haritalama\nmy_plots &lt;- map(hospital_names, ~make_epicurve(hosp_name = .x))\n\n# ggplot'ları yazdırın (bir listede saklanırlar)\nggarrange(plotlist = my_plots, ncol = 2, nrow = 3)\n\n\n\nSütunlar arasında bir fonksiyonu eşleme\nDiğer bir yaygın kullanım durumu, bir işlevi birçok sütun arasında eşlemektir. Aşağıda, t.test() fonksiyonunu, sayısal değerleri cinsiyete göre karşılaştırarak, veri çerçevesi satır listesindeki sayısal sütunlar arasında eşliyoruz / map().\n[Basit istatistiksel testler] sayfasından t.test()’in t.test(numeric column ~ binary column) gibi bir formül biçiminde girdiler alabileceğini hatırlayın. Bu örnekte aşağıdakileri yapıyoruz:\n\nİlgilenilen sayısal sütunlar satır listesinden seçilir - bunlar map() için .x girdileri olur\nt.test() metodu, her sayısal sütuna uygulanan .f fonksiyonu olarak sağlanır\nt.test() parantezleri içinde:\n\nilk ~ , map()’in .x üzerinde yineleneceği .f’den önce gelir\n.x, t.test() işlevine sağlanan geçerli sütunu temsil eder\nikinci ~ yukarıda açıklanan t testi denkleminin bir parçasıdır\nt.test() işlevi, denklemin sağ tarafında bir ikili sütun bekler. linelist$gender vektörünü bağımsız ve statik olarak sağlıyoruz (select()’e dahil edilmediğine dikkat edin).\n\n\nmap() bir liste döndürür, bu nedenle çıktı t-test sonuçlarının bir listesidir - analiz edilen her sayısal sütun için bir liste öğesi.\n\n# Sonuçlar bir liste olarak kaydedilir\nt.test_results &lt;- linelist %&gt;% \n  select(age, wt_kg, ht_cm, ct_blood, temp) %&gt;%  # eşlemek için yalnızca bazı sayısal sütunları saklayın\n  map(.f = ~t.test(.x ~ linelist$gender))        # t.test fonksiyonu, SAYISAL ~ KATEGORİSEL denklemi ile\n\nRStudio’da açıldığında (Görüntülendiğinde) t.test_results listesi şöyle görünür. Bu sayfadaki örnekler için önemli olan kısımları vurguladık.\n\nEn üstte tüm listenin t.test_results olarak adlandırıldığını ve beş öğeye sahip olduğunu görebilirsiniz. Bu beş öğe, linelist’den cinsiyet - gender ile bir t-testinde kullanılan her değişkenden sonra age, wt_km, ht_cm, ct_blood, temp olarak adlandırılır.\nBu beş öğenin her biri, içinde p.value ve conf.int gibi öğeler bulunan listelerdir. p.value gibi bu öğelerden bazıları tek sayılardır, oysa tahmin - estimate gibi bazıları iki veya daha fazla öğeden oluşur (f grubunda ortalama ve m grubunda ortalama).\n\n\n\n\n\n\n\n\n\n\nNot: Bir veri çerçevesindeki yalnızca belirli sütunlara bir işlev uygulamak istiyorsanız, [Verileri temizleme ve temel işlevler] sayfasında açıklandığı gibi mutate() ve across()’u da kullanabileceğinizi unutmayın. Aşağıda, yalnızca “yaş” sütunlarına as.character() uygulamasının bir örneği verilmiştir. Parantez ve virgüllerin yerleşimine dikkat edin.\n\n# \"yaş\" içeren sütun adına sahip sütunları karakter sınıfına dönüştürün\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = contains(\"age\"), .fns = as.character))  \n\n\n\nListeden çıkarma\nmap() List sınıfının bir çıktısını ürettiği için, eşlik eden purrr fonksiyonlarını kullanarak listelerden nasıl veri çıkarılacağını tartışmak için biraz zaman harcayacağız. Bunu göstermek için önceki bölümdeki t.test_results listesini kullanacağız. Bu 5 listeden oluşan bir listedir - 5 listenin her biri, linelist veri çerçevesinden bir sütun ile ikili sütun cinsiyeti - gender arasındaki bir t-testinin sonuçlarını içerir. Liste yapısının görseli için yukarıdaki bölümdeki resme bakın.\n\nElementlerin isimleri\nÖğelerin adlarını çıkarmak için, yalnızca R tabanından names() fonksiyonunu kullanın. Bu durumda, t-testleri gerçekleştirilen 5 değişkenin adları olan her bir alt listenin adını döndürmek için t.test_results üzerinde names() kullanırız.\n\nnames(t.test_results)\n\n[1] \"age\"      \"wt_kg\"    \"ht_cm\"    \"ct_blood\" \"temp\"    \n\n\n\n\nAda veya konuma göre öğeler\nListe öğelerini ada veya konuma göre çıkarmak için, R temelleri sayfasında açıklandığı gibi köşeli ayraçları [[ ]] kullanabilirsiniz. Aşağıda, t.tests_results listesini indekslemek için çift parantez kullanıyoruz ve t-testinin yaşa - age göre sonuçları olan ilk öğeyi gösteriyoruz.\n\nt.test_results[[1]] # pozisyona göre ilk eleman\n\n\n    Welch Two Sample t-test\n\ndata:  .x by linelist$gender\nt = -21.3, df = 4902.9, p-value &lt; 2.2e-16\nalternative hypothesis: true difference in means between group f and group m is not equal to 0\n95 percent confidence interval:\n -7.544409 -6.272675\nsample estimates:\nmean in group f mean in group m \n       12.66085        19.56939 \n\nt.test_results[[1]][\"p.value\"] # ilk öğeden \"p.value\" adlı öğeyi döndür \n\n$p.value\n[1] 2.350374e-96\n\n\nBununla birlikte, aşağıda aynı sonuçları elde etmek için basit ve esnek purrr fonksiyonları map() ve pluck() kullanımını göstereceğiz.\n\n\npluck()\npluck(), elemanları ada veya konuma göre çeker. Örneğin - yaş için t testi sonuçlarını çıkarmak için pluck() işlevini şu şekilde kullanabilirsiniz:\n\nt.test_results %&gt;% \n  pluck(\"age\")        # alternatif olarak, pluck(1) kullanın\n\n\n    Welch Two Sample t-test\n\ndata:  .x by linelist$gender\nt = -21.3, df = 4902.9, p-value &lt; 2.2e-16\nalternative hypothesis: true difference in means between group f and group m is not equal to 0\n95 percent confidence interval:\n -7.544409 -6.272675\nsample estimates:\nmean in group f mean in group m \n       12.66085        19.56939 \n\n\nDiğer seviyeleri virgülle belirterek daha derin seviyeleri indeksleyin. Aşağıdaki, t.test_results listesindeki liste yaşından age “p.value” adlı öğeyi çıkarır. Karakter adları yerine sayıları da kullanabilirsiniz.\n\nt.test_results %&gt;% \n  pluck(\"age\", \"p.value\")\n\n[1] 2.350374e-96\n\n\npluck() işlevini her bir birinci düzey öğede çalıştırmak için map() kullanarak tüm birinci düzey öğelerden bu tür iç öğeleri ayıklayabilirsiniz. Örneğin, aşağıdaki kod, t.test_results içindeki tüm listelerden “p.value” öğelerini çıkarır. t testi sonuçlarının listesi, yinelenen .x’dir, pluck() yinelenen .f fonksiyonudur ve fonksiyona “p-değeri” sağlar.\n\nt.test_results %&gt;%\n  map(pluck, \"p.value\")   # her p değerini döndür\n\n$age\n[1] 2.350374e-96\n\n$wt_kg\n[1] 2.664367e-182\n\n$ht_cm\n[1] 3.515713e-144\n\n$ct_blood\n[1] 0.4473498\n\n$temp\n[1] 0.5735923\n\n\nBaşka bir alternatif olarak, map(), eleman adını tırnak içinde yazabileceğiniz bir kestirme yol sunar ve onu çıkarır. map() kullanırsanız çıktı bir liste olur, map_chr() kullanırsanız bu adlandırılmış bir karakter vektörü olur ve map_dbl() kullanırsanız bu adlandırılmış bir sayısal vektör olur.\n\nt.test_results %&gt;% \n  map_dbl(\"p.value\")   # p-değerlerini adlandırılmış bir sayısal vektör olarak döndür\n\n          age         wt_kg         ht_cm      ct_blood          temp \n 2.350374e-96 2.664367e-182 3.515713e-144  4.473498e-01  5.735923e-01 \n\n\npurrr belgelerinde pluck() hakkında daha fazla bilgi edinebilirsiniz. Bir öğe yoksa NULL yerine bir hata döndüren chuck() kardeş işlevine sahiptir.\n\n\n\nListeyi veri çerçevesine dönüştür\nBu karmaşık bir konudur - daha eksiksiz öğreticiler için Kaynaklar bölümüne bakın. Yine de, t-testi sonuçlarının listesini bir veri çerçevesine dönüştürmeyi göstereceğiz. Değişken, p değeri ve iki gruptan (erkek ve kadın) ortalamalar için sütunlar içeren bir veri çerçevesi oluşturacağız.\nKullanılacak bazı yeni yaklaşımlar ve işlevler şunlardır:\n\ntibble() fonksiyonu, bir tibble (veri çerçevesi gibi) oluşturmak için kullanılacaktır\n\nTüm t.test_results’un ilk tibble sütunu olarak depolanmasını önlemek için tibble() fonksiyonunu küme parantezleri { } ile çevreliyoruz\n\ntibble() içinde her sütun, mutate() sözdizimine benzer şekilde açıkça oluşturulur:\n\n., t.test_results’u temsil eder\nt-test değişken adlarıyla (her liste öğesinin adı) bir sütun oluşturmak için yukarıda açıklandığı gibi names()i kullanırız\np değerleriyle bir sütun oluşturmak için, p.value öğelerini çekmek ve bunları sayısal bir vektöre dönüştürmek için yukarıda açıklandığı gibi map_dbl() kullanırız\n\n\n\nt.test_results %&gt;% {\n  tibble(\n    variables = names(.),\n    p         = map_dbl(., \"p.value\"))\n  }\n\n# A tibble: 5 × 2\n  variables         p\n  &lt;chr&gt;         &lt;dbl&gt;\n1 age       2.35e- 96\n2 wt_kg     2.66e-182\n3 ht_cm     3.52e-144\n4 ct_blood  4.47e-  1\n5 temp      5.74e-  1\n\n\nAma şimdi her grup için (erkekler ve kadınlar) ortalamaları içeren sütunlar ekleyelim.\nÖğe tahminini/estimate çıkarmamız gerekir, ancak bu aslında içinde iki öğe içerir (f grubunda ortalama ve m grubunda ortalama). Bu nedenle, map_chr() veya map_dbl() ile bir vektöre basitleştirilemez. Bunun yerine, tibble() içinde kullanılan map() fonksiyonunu kullanıyoruz, bu tibble içinde bir sınıf listesi sütunu yaratacaktır! Evet, bu mümkün!\n\nt.test_results %&gt;% \n  {tibble(\n    variables = names(.),\n    p = map_dbl(., \"p.value\"),\n    means = map(., \"estimate\"))}\n\n# A tibble: 5 × 3\n  variables         p means       \n  &lt;chr&gt;         &lt;dbl&gt; &lt;named list&gt;\n1 age       2.35e- 96 &lt;dbl [2]&gt;   \n2 wt_kg     2.66e-182 &lt;dbl [2]&gt;   \n3 ht_cm     3.52e-144 &lt;dbl [2]&gt;   \n4 ct_blood  4.47e-  1 &lt;dbl [2]&gt;   \n5 temp      5.74e-  1 &lt;dbl [2]&gt;   \n\n\nBu liste sütununa sahip olduğunuzda, bu “iç içe liste” sütunlarını “dikdörtgenleştirmenize” veya “iç içeden çıkarmanıza” yardımcı olan birkaç tidyr fonksiyonu (tidyverse’nin bir parçası) vardır. Onlar hakkında daha fazla bilgiyi buradan veya vignette(\"rectangle\") çalıştırarak okuyun. Kısaca:\n\nunnest_wider() - bir liste sütununun her elemanına kendi sütununu verir\nunnest_longer() - bir liste sütununun her elemanına kendi satırını verir\nhoist() - unnest_wider() gibi davranır, ancak hangi öğelerin yuvalanacağını siz belirlersiniz\n\nAşağıda, tibble’ın ortalama - means sütununu (iç içe bir liste olan) belirterek tibble’ı unnest_wider() öğesine iletiyoruz. Sonuç, ortalamaların her biri daha önce her bir means hücresinde bulunan iki öğeyi yansıtan iki yeni sütunla değiştirilmesidir.\n\nt.test_results %&gt;% \n  {tibble(\n    variables = names(.),\n    p = map_dbl(., \"p.value\"),\n    means = map(., \"estimate\")\n    )} %&gt;% \n  unnest_wider(means)\n\n# A tibble: 5 × 4\n  variables         p `mean in group f` `mean in group m`\n  &lt;chr&gt;         &lt;dbl&gt;             &lt;dbl&gt;             &lt;dbl&gt;\n1 age       2.35e- 96              12.7              19.6\n2 wt_kg     2.66e-182              45.8              59.6\n3 ht_cm     3.52e-144             109.              142. \n4 ct_blood  4.47e-  1              21.2              21.2\n5 temp      5.74e-  1              38.6              38.6\n\n\n\n\nListeleri atma, saklama ve sıkıştırma\npurrr ile çalışmak genellikle listeler içerdiğinden, listeleri değiştirmek için bazı purrr fonksiyonlarını kısaca inceleyeceğiz. purrr fonksiyonlarıyla ilgili daha eksiksiz eğitimler için Kaynaklar bölümüne bakın.\n\nlist_modify() birçok kullanıma sahiptir, bunlardan biri bir liste öğesini kaldırmak olabilir\nkeep(), .p = için belirtilen öğeleri veya .p = için sağlanan bir işlevin DOĞRU olarak değerlendirildiği yerde tutar\ndiscard(), .p için belirtilen öğeleri veya .p = için sağlanan bir işlevin DOĞRU olarak değerlendirildiği yerde kaldırır\ncompact() tüm boş öğeleri kaldırır\n\nBirden çok dosyayı içe aktarmak ve birleştirmek için map() kullanımıyla ilgili yukarıdaki bölümde oluşturulan birleşik listeyi kullanan bazı örnekler (6 vaka sıra listesi veri çerçevesi içerir):\nÖğeler, list_modify() ile adlarına göre ve adı NULL’a eşitlenerek kaldırılabilir.\n\ncombined %&gt;% \n  list_modify(\"Central Hospital\" = NULL)   # liste öğesini isme göre kaldır\n\nAyrıca, .p = (DOĞRU veya YANLIŞ olarak değerlendirilen bir denklem) için bir “yüklem” denklemi sağlayarak, ölçütlere göre öğeleri kaldırabilirsiniz. Fonksiyonun önüne bir tilde ~ yerleştirin ve liste öğesini temsil etmek için .x kullanın. keep() kullanılarak DOĞRU olarak değerlendirilen liste öğeleri tutulacaktır. Tersine, eğer discard() kullanılıyorsa, DOĞRU olarak değerlendirilen liste elemanları kaldırılacaktır.\n\n# yalnızca 500'den fazla satır içeren liste öğelerini tut\ncombined %&gt;% \n  keep(.p = ~nrow(.x) &gt; 500)  \n\nAşağıdaki örnekte, sınıfları veri çerçeveleri değilse liste öğeleri atılır.\n\n# Veri çerçevesi olmayan liste öğelerini at\ncombined %&gt;% \n  discard(.p = ~class(.x) != \"data.frame\")\n\nYüklem işleviniz ayrıca her liste öğesindeki öğelere/sütunlara başvurabilir. Örneğin, aşağıda, ct_blood sütununun ortalamasının 25’in üzerinde olduğu liste öğeleri atılır.\n\n# yalnızca ct_blood sütun ortalamasının 25'in üzerinde olduğu liste öğelerini tut\ncombined %&gt;% \n  discard(.p = ~mean(.x$ct_blood) &gt; 25)  \n\nBu komut, tüm boş liste öğelerini kaldırır:\n\n# Tüm boş liste öğelerini kaldırın\ncombined %&gt;% \n  compact()\n\n\n\npmap()\nBU BÖLÜM YAPIM AŞAMASINDADIR.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Yineleme, döngüler ve listeler</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.tr.html#fonksiyonları-uygulama",
    "href": "new_pages/iteration.tr.html#fonksiyonları-uygulama",
    "title": "16  Yineleme, döngüler ve listeler",
    "section": "16.4 Fonksiyonları uygulama",
    "text": "16.4 Fonksiyonları uygulama\n“Uygula” fonksiyon ailesi, yinelemeli işlemler için purrr’a R tabanı alternatifidir. Onlar hakkında daha fazlasını buradan okuyabilirsiniz.",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Yineleme, döngüler ve listeler</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.tr.html#kaynaklar",
    "href": "new_pages/iteration.tr.html#kaynaklar",
    "title": "16  Yineleme, döngüler ve listeler",
    "section": "16.5 Kaynaklar",
    "text": "16.5 Kaynaklar\nData Carpentry ile for döngüleri\nYinelemede Veri Bilimi için R sayfası\nExcel dosyaları yazma/okuma üzerine skeç\njennybc tarafından bir purrr dersi by jennybc\nRebecca Barter’dan bir başka purrr dersi by Rebecca Barter\nmap, pmap ve imap hakkında bir purrr eğitimi on map, pmap, and imap\npurrr hile sayfası\npurrr ipuçları ve püf noktaları\nsakla ve at",
    "crumbs": [
      "Veri Yönetimi",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Yineleme, döngüler ve listeler</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.tr.html",
    "href": "new_pages/tables_descriptive.tr.html",
    "title": "17  Tanımlayıcı tablolar",
    "section": "",
    "text": "17.1 Hazırlık",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Tanımlayıcı tablolar</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.tr.html#hazırlık",
    "href": "new_pages/tables_descriptive.tr.html#hazırlık",
    "title": "17  Tanımlayıcı tablolar",
    "section": "",
    "text": "Paketleri yükleme\nBu kod bloğu, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’ın p_load() fonksiyonu vurgulanmaktadır. Ayrıca, temel R’dan library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R’ın temelleri sayfasına bakabilirsiniz.\n\npacman::p_load(\n  rio,          # Dosya içeri aktarımı\n  here,         # Dosyaların tespit edilmesi \n  skimr,        # Verinin gözden geçirilmesi \n  tidyverse,    # Veri yönetimi + ggplot2 grafikleri  \n  gtsummary,    # Özet istatistikler ve testler\n  rstatix,      # Özet istatistikler ve istatistik testler\n  janitor,      # Toplamların ve yüzdelerin eklenmesi \n  scales,       # Yüzdelerin oranlara kolayca çevrilmesi \n  flextable     # Tabloların “güzel” resimlere dönüştürülmesi \n  )\n\n\n\nVerinin içeri aktarımı\nSimüle edilmiş bir Ebola salgını veri setini içe aktarıyoruz. Devam etmek istiyorsanız, “temiz” satır listesini (.rds dosyası olarak) indirmek için tıklayın click to download the “clean” linelist . Verilerinizi rio paketinden import() fonksiyonuyla içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için İçe Aktarma ve Dışa Aktarma sayfasına bakın).\n\n# satır listesini içe aktar\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nThe first 50 rows of the linelist are displayed below.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Tanımlayıcı tablolar</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.tr.html#verileri-gözden-geçirme",
    "href": "new_pages/tables_descriptive.tr.html#verileri-gözden-geçirme",
    "title": "17  Tanımlayıcı tablolar",
    "section": "17.2 Verileri gözden geçirme",
    "text": "17.2 Verileri gözden geçirme\n\nskimr paketi\nskimr paketini kullanarak, veri tabaınızdaki değişkenlerin her biri için ayrıntılı ve estetik bir genel bakış elde edebilirsiniz. github sayfasında github. skimr hakkında daha fazla bilgi edinin.\nAşağıda, ’skim()’fonksiyonu tüm satır listesi veri çerçevesine uygulanır. Veri çerçevesine genel bir bakış ve her sütunun (sınıfa göre) bir özeti çıkarılır.\n\n## veritabanındaki her değişken için bilgiyi edin \nskim(linelist)\n\n\n\n\nData summary\n\n\nName\nlinelist\n\n\nNumber of rows\n5888\n\n\nNumber of columns\n30\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n13\n\n\nDate\n4\n\n\nfactor\n2\n\n\nnumeric\n11\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\ncase_id\n0\n1.00\n6\n6\n0\n5888\n0\n\n\noutcome\n1323\n0.78\n5\n7\n0\n2\n0\n\n\ngender\n278\n0.95\n1\n1\n0\n2\n0\n\n\nage_unit\n0\n1.00\n5\n6\n0\n2\n0\n\n\nhospital\n0\n1.00\n5\n36\n0\n6\n0\n\n\ninfector\n2088\n0.65\n6\n6\n0\n2697\n0\n\n\nsource\n2088\n0.65\n5\n7\n0\n2\n0\n\n\nfever\n249\n0.96\n2\n3\n0\n2\n0\n\n\nchills\n249\n0.96\n2\n3\n0\n2\n0\n\n\ncough\n249\n0.96\n2\n3\n0\n2\n0\n\n\naches\n249\n0.96\n2\n3\n0\n2\n0\n\n\nvomit\n249\n0.96\n2\n3\n0\n2\n0\n\n\ntime_admission\n765\n0.87\n5\n5\n0\n1072\n0\n\n\n\nVariable type: Date\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nmedian\nn_unique\n\n\n\n\ndate_infection\n2087\n0.65\n2014-03-19\n2015-04-27\n2014-10-11\n359\n\n\ndate_onset\n256\n0.96\n2014-04-07\n2015-04-30\n2014-10-23\n367\n\n\ndate_hospitalisation\n0\n1.00\n2014-04-17\n2015-04-30\n2014-10-23\n363\n\n\ndate_outcome\n936\n0.84\n2014-04-19\n2015-06-04\n2014-11-01\n371\n\n\n\nVariable type: factor\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nordered\nn_unique\ntop_counts\n\n\n\n\nage_cat\n86\n0.99\nFALSE\n8\n0-4: 1095, 5-9: 1095, 20-: 1073, 10-: 941\n\n\nage_cat5\n86\n0.99\nFALSE\n17\n0-4: 1095, 5-9: 1095, 10-: 941, 15-: 743\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\n\n\n\n\ngeneration\n0\n1.00\n16.56\n5.79\n0.00\n13.00\n16.00\n20.00\n37.00\n\n\nage\n86\n0.99\n16.07\n12.62\n0.00\n6.00\n13.00\n23.00\n84.00\n\n\nage_years\n86\n0.99\n16.02\n12.64\n0.00\n6.00\n13.00\n23.00\n84.00\n\n\nlon\n0\n1.00\n-13.23\n0.02\n-13.27\n-13.25\n-13.23\n-13.22\n-13.21\n\n\nlat\n0\n1.00\n8.47\n0.01\n8.45\n8.46\n8.47\n8.48\n8.49\n\n\nwt_kg\n0\n1.00\n52.64\n18.58\n-11.00\n41.00\n54.00\n66.00\n111.00\n\n\nht_cm\n0\n1.00\n124.96\n49.52\n4.00\n91.00\n129.00\n159.00\n295.00\n\n\nct_blood\n0\n1.00\n21.21\n1.69\n16.00\n20.00\n22.00\n22.00\n26.00\n\n\ntemp\n149\n0.97\n38.56\n0.98\n35.20\n38.20\n38.80\n39.20\n40.80\n\n\nbmi\n0\n1.00\n46.89\n55.39\n-1200.00\n24.56\n32.12\n50.01\n1250.00\n\n\ndays_onset_hosp\n256\n0.96\n2.06\n2.26\n0.00\n1.00\n1.00\n3.00\n22.00\n\n\n\n\n\nTüm bir veri tabanı hakkında bilgi almak için temel R’dan summary() fonksiyonunu da kullanabilirsiniz, ancak bu çıktıyı okumak skimr çıktısından daha zor olabilir. Bu nedenle, sayfa sayısından tasarruf etmek için çıktı aşağıda gösterilmemiştir.\n\n## veritabanındaki her sütun için bilgiyi edin  \nsummary(linelist)\n\n\n\nÖzet İstatistikleri\nSayısal bir sütunda özet istatistikleri göstermek için temel R işlevlerini kullanabilirsiniz. Bir sayısal sütun için yararlı özet istatistiklerin çoğunu aşağıdaki gibi summary() kullanarak elde edebilirsiniz. Veri çerçevesi adının da aşağıda gösterildiği gibi belirtilmesi gerektiğini unutmayın.\n\nsummary(linelist$age_years)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00    6.00   13.00   16.02   23.00   84.00      86 \n\n\nDizin parantezleri [ ] ile veri çerçevesinin belirli bir bölümüne erişebilir ve kaydedebilirsiniz:\n\nsummary(linelist$age_years)[[2]]            # yalnızca ikinci ögeyi göster\n\n[1] 6\n\n# eşdeğeri, eleman adı için yukarıdakine alternatif olarak \n# summary(linelist$age_years)[[\"1st Qu.\"]]  \n\nmax(), min(), median(), ortalama(), quantile(), sd() ve range() gibi temel R işlevleriyle istatistikleri tek tek elde edebilirsiniz. Tam bir liste için R’ın temelleri sayfasına bakabilirsiniz.\nUYARI: Verileriniz eksik değerler içeriyorsa, R bunu belirtmenizi ister. Bu nedenle, na.rm = TRUE argümanı aracılığıyla R’nin eksik değerleri yok saymasını belirtmediğiniz sürece komut NA değerini verir.na.rm = TRUE.\nÖzet istatistikleri bir veri çerçevesi biçiminde döndürmek için rstatix’teki get_summary_stats() fonkisyonunu kullanabilirsiniz. Bu fonksiyon, sonraki işlemleri gerçekleştirmek veya istatistiklerle çizim yapmak için yardımcı olabilir. rstatix paketi ve işlevleri hakkında daha fazla ayrıntı için Temel istatistiksel testler sayfasına bakın.\n\nlinelist %&gt;% \n  get_summary_stats(\n    age, wt_kg, ht_cm, ct_blood, temp,  # hesaplanacak sütunlar\n    type = \"common\")                    # döndürülecek özet istatistikler\n\n# A tibble: 5 × 10\n  variable     n   min   max median   iqr  mean     sd    se    ci\n  &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 age       5802   0    84     13      17  16.1 12.6   0.166 0.325\n2 wt_kg     5888 -11   111     54      25  52.6 18.6   0.242 0.475\n3 ht_cm     5888   4   295    129      68 125.  49.5   0.645 1.26 \n4 ct_blood  5888  16    26     22       2  21.2  1.69  0.022 0.043\n5 temp      5739  35.2  40.8   38.8     1  38.6  0.977 0.013 0.025",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Tanımlayıcı tablolar</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.tr.html#tbl_janitor",
    "href": "new_pages/tables_descriptive.tr.html#tbl_janitor",
    "title": "17  Tanımlayıcı tablolar",
    "section": "17.3 janitor paketi",
    "text": "17.3 janitor paketi\njanitor paketleri, yüzdeleri, oranları, sayıları vb. görüntülemek için yardımcı işlevlerin uygulandığı tablolar ve çapraz tablolar oluşturmak için tabyl() fonksiyonunu sunar.\nAşağıda, sıra listesi veri çerçevesini janitor fonksiyonlarına aktarıyoruz ve sonucu yazdırıyoruz. İstenirse, sonuç tablolarını &lt;- atama operatörü ile de kaydedebilirsiniz.\n\nBasit tabyl\n‘tabyl()’ öğesinin belirli bir sütunda varsayılan kullanımı, değerler, sayılar ve sütun bazında “yüzdeler” (oranlar) oluşturur. Oranlar çok basamaklı olabilir. Aşağıda açıklandığı gibi ‘adorn_rounding()’ ile ondalık basamak sayısını ayarlayabilirsiniz.\n\nlinelist %&gt;% tabyl(age_cat)\n\n age_cat    n     percent valid_percent\n     0-4 1095 0.185971467   0.188728025\n     5-9 1095 0.185971467   0.188728025\n   10-14  941 0.159816576   0.162185453\n   15-19  743 0.126188859   0.128059290\n   20-29 1073 0.182235054   0.184936229\n   30-49  754 0.128057065   0.129955188\n   50-69   95 0.016134511   0.016373664\n     70+    6 0.001019022   0.001034126\n    &lt;NA&gt;   86 0.014605978            NA\n\n\nYukarıda gördüğünüz gibi, eksik değerler varsa,  etiketli bir satırda görüntülenirler. Bunların gösterimini show_na = FALSE ile kapatabilirsiniz. Eksik değer yoksa bu satır görünmez. Eksik değerler varsa, tüm oranlar hem ham olarak (paydadaki NA sayıları dahil) hem de “geçerli” (paydadaki NA sayıları hariç) formda verilir.\nSütun sınıfı faktörse ve verilerinizde yalnızca belirli düzeyler varsa, tüm düzeyler tabloda görünmeye devam eder. show_missing_levels = FALSE belirterek bu özelliği kapatabilirsiniz. Faktörler sayfasında daha fazla bilgiye ulaşabilirsiniz.\n\n\nÇapraz tablolar\nÇapraz tablolar, tabyl() içinde bir veya daha fazla ek sütun eklenerek elde edilir. Çıktıda yalnızca sayıların elde edildiğini unutmayın - oranlar ve yüzdeler, aşağıda gösterilen ek adımlarla eklenebilir.\n\nlinelist %&gt;% tabyl(age_cat, gender)\n\n age_cat   f   m NA_\n     0-4 640 416  39\n     5-9 641 412  42\n   10-14 518 383  40\n   15-19 359 364  20\n   20-29 468 575  30\n   30-49 179 557  18\n   50-69   2  91   2\n     70+   0   5   1\n    &lt;NA&gt;   0   0  86\n\n\n\n\ntabyl’in “süslenmesi”\nToplamları eklemek veya oranlara, yüzdelere dönüştürme işlemi veya ekranı başka bir şekilde ayarlamak için janitor “adorn” fonkisyonlarını kullanın. Tabloyu bu fonksiyonlardan birkaçından geçirebilirsiniz.\n\n\n\n\n\n\n\nFonksiyon\nÇıktı\n\n\n\n\nadorn_totals()\nToplamların eklenmesi (where = “row”, “col”, veya “both”). name = “Total” için.\n\n\nadorn_percentages()\nSayımların orana dönüştürülmesi denominator = “row”, “col”, veya “all”\n\n\nadorn_pct_formatting()\nOranların yüzdelere çevrimi. digits = belirtilmelidir. “%” sembolü bu argüman ile uzaklaştırılır. affix_sign = FALSE.\n\n\nadorn_rounding()\nOranların digits = sayıda basamağa yuvarlanması. Yüzdelerin yuvarlanması için adorn_pct_formatting().\n\n\nadorn_ns()\nOranlar veya yüzdeler tablosuna sayıları ekleyin. Sayıları parantez içinde göstermek için position = “rear” veya yüzdeleri parantez içinde koymak için “front” belirtin.\n\n\nadorn_title()\nDEğişkenler aracılığıyla dize (string)eklenmesi row_name = and/or col_name =\n\n\n\nYukarıdaki işlevleri uyguladığınız sıra önemlidir. Aşağıda bazı örnekler verilmiştir.\nVarsayılan oranlar yerine yüzdeleri olan basit, tek yönlü bir tablo örneği:\n\nlinelist %&gt;%               # vaka satır listesi \n  tabyl(age_cat) %&gt;%       # sayıları-oranları yaşa göre tablo haline getirin\n  adorn_pct_formatting()   # oranları yüzdelere çevir\n\n age_cat    n percent valid_percent\n     0-4 1095   18.6%         18.9%\n     5-9 1095   18.6%         18.9%\n   10-14  941   16.0%         16.2%\n   15-19  743   12.6%         12.8%\n   20-29 1073   18.2%         18.5%\n   30-49  754   12.8%         13.0%\n   50-69   95    1.6%          1.6%\n     70+    6    0.1%          0.1%\n    &lt;NA&gt;   86    1.5%             -\n\n\nToplam satır ve satır yüzdelerini içeren bir çapraz tablo.\n\nlinelist %&gt;%                                  \n  tabyl(age_cat, gender) %&gt;%                  # yaş ve cinsiyete göre sayılar\n  adorn_totals(where = \"row\") %&gt;%             # toplam satırı ekle\n  adorn_percentages(denominator = \"row\") %&gt;%  # sayıları oranlara dönüştür\n  adorn_pct_formatting(digits = 1)            # oranları yüzdelere çevir\n\n age_cat     f     m    NA_\n     0-4 58.4% 38.0%   3.6%\n     5-9 58.5% 37.6%   3.8%\n   10-14 55.0% 40.7%   4.3%\n   15-19 48.3% 49.0%   2.7%\n   20-29 43.6% 53.6%   2.8%\n   30-49 23.7% 73.9%   2.4%\n   50-69  2.1% 95.8%   2.1%\n     70+  0.0% 83.3%  16.7%\n    &lt;NA&gt;  0.0%  0.0% 100.0%\n   Total 47.7% 47.6%   4.7%\n\n\nHem sayıların hem de yüzdelerin görüntülenmesi için ayarlanmış bir çapraz tablo.\n\nlinelist %&gt;%                                  # vaka listesi\n  tabyl(age_cat, gender) %&gt;%                  # çapraz tablo sayıları\n  adorn_totals(where = \"row\") %&gt;%             # toplam satırı ekle\n  adorn_percentages(denominator = \"col\") %&gt;%  # oranlara dönüştürmek\n  adorn_pct_formatting() %&gt;%                  # yüzdeye dönüştür\n  adorn_ns(position = \"front\") %&gt;%            # \"sayı (yüzde)\" olarak görüntüleme\n  adorn_title(                                # başlıkların ayarlanması \n    row_name = \"Age Category\",\n    col_name = \"Gender\")\n\n                      Gender                            \n Age Category              f              m          NA_\n          0-4   640  (22.8%)   416  (14.8%)  39  (14.0%)\n          5-9   641  (22.8%)   412  (14.7%)  42  (15.1%)\n        10-14   518  (18.5%)   383  (13.7%)  40  (14.4%)\n        15-19   359  (12.8%)   364  (13.0%)  20   (7.2%)\n        20-29   468  (16.7%)   575  (20.5%)  30  (10.8%)\n        30-49   179   (6.4%)   557  (19.9%)  18   (6.5%)\n        50-69     2   (0.1%)    91   (3.2%)   2   (0.7%)\n          70+     0   (0.0%)     5   (0.2%)   1   (0.4%)\n         &lt;NA&gt;     0   (0.0%)     0   (0.0%)  86  (30.9%)\n        Total 2,807 (100.0%) 2,803 (100.0%) 278 (100.0%)\n\n\n\n\ntabyl çıktısının alınması\nVarsayılan olarak tabyl, R konsolunuza ham formda yazdıracaktır.\nAlternatif olarak, RStudio Viewer’da .png, .jpeg, .html, vb. olarak dışa aktarılabilen bir resim olarak yazdırmak için tabyl’i flextable veya benzeri bir pakete geçirebilirsiniz. Bu işlem, Sunum için tablolar sayfasında tartışılmaktadır. Bu şekilde yazdırıyorsanız ve adorn_titles() kullanıyorsanız, place = argümanını “combined” belirtmeniz gerektiğini unutmayın.\n\nlinelist %&gt;%\n  tabyl(age_cat, gender) %&gt;% \n  adorn_totals(where = \"col\") %&gt;% \n  adorn_percentages(denominator = \"col\") %&gt;% \n  adorn_pct_formatting() %&gt;% \n  adorn_ns(position = \"front\") %&gt;% \n  adorn_title(\n    row_name = \"Age Category\",\n    col_name = \"Gender\",\n    placement = \"combined\") %&gt;% # resim olarak yazdırmak için bu gereklidir\n  flextable::flextable() %&gt;%    # güzel görüntüye dönüştür\n  flextable::autofit()          # satır başına bir satıra biçimlendir\n\nAge Category/GenderfmNA_Total0-4640 (22.8%)416 (14.8%)39 (14.0%)1,095 (18.6%)5-9641 (22.8%)412 (14.7%)42 (15.1%)1,095 (18.6%)10-14518 (18.5%)383 (13.7%)40 (14.4%)941 (16.0%)15-19359 (12.8%)364 (13.0%)20  (7.2%)743 (12.6%)20-29468 (16.7%)575 (20.5%)30 (10.8%)1,073 (18.2%)30-49179  (6.4%)557 (19.9%)18  (6.5%)754 (12.8%)50-692  (0.1%)91  (3.2%)2  (0.7%)95  (1.6%)70+0  (0.0%)5  (0.2%)1  (0.4%)6  (0.1%)0  (0.0%)0  (0.0%)86 (30.9%)86  (1.5%)\n\n\n\n\nDiğer tablolarda kullanımı\njanitor adorn_*() işlevlerini, dplyr’den summarise() ve count() veya temel R’dan table() tarafından oluşturulanlar diğer tabloları da kullanabilirsiniz. Tabloyu istenen janitor fonksiyonuna yönlendirmeniz yeterlidir. Örneğin:\n\nlinelist %&gt;% \n  count(hospital) %&gt;%   # dplyr fonksiyonu\n  adorn_totals()        # janitor fonksiyonu\n\n                             hospital    n\n                     Central Hospital  454\n                    Military Hospital  896\n                              Missing 1469\n                                Other  885\n                        Port Hospital 1762\n St. Mark's Maternity Hospital (SMMH)  422\n                                Total 5888\n\n\n\n\ntabyl kaydedilmesi\nTabloyu flextable gibi bir paketle “güzel” bir resme dönüştürürseniz, o paketteki fonksiyonlarla kaydedebilirsiniz (flextable’da save_as_html(), save_as_word(), save_as_ppt() ve save_as_image() gibi fonksiyonlar bulunmaktadır. Sunum için tablolar sayfasında kapsamlı bir şekilde tartışılmıştır. Aşağıdaki tablo, elle düzenlenebilen bir Word belgesi olarak kaydedilmiştir:\n\nlinelist %&gt;%\n  tabyl(age_cat, gender) %&gt;% \n  adorn_totals(where = \"col\") %&gt;% \n  adorn_percentages(denominator = \"col\") %&gt;% \n  adorn_pct_formatting() %&gt;% \n  adorn_ns(position = \"front\") %&gt;% \n  adorn_title(\n    row_name = \"Age Category\",\n    col_name = \"Gender\",\n    placement = \"combined\") %&gt;% \n flextable::flextable() %&gt;%                     # resme dönüştür\n  flextable::autofit() %&gt;%                       # satır başına yalnızca bir satır\n  flextable::save_as_docx(path = \"tabyl.docx\")   # dosya yoluna Word belgesi kaydet\n\n\n\n\n\n\n\n\n\n\n\n\nİstatistikler\nAşağıda gösterildiği gibi, stats paketinden chisq.test() veya fisher.test() gibi fonksiyonlarla tablolar üzerinde istatistiksel testler uygulayabilirsiniz. Bu işlem, eksik değerlere izin verilmez, bu nedenle show_na = FALSE ile tablodan hariç tutulurlar.\n\nage_by_outcome &lt;- linelist %&gt;% \n  tabyl(age_cat, outcome, show_na = FALSE) \n\nchisq.test(age_by_outcome)\n\n\n    Pearson's Chi-squared test\n\ndata:  age_by_outcome\nX-squared = 6.4931, df = 7, p-value = 0.4835\n\n\nDaha fazla kod ve istatistiklerle ilgili ipuçları için Temel istatistik testleri sayfasına bakın.\n\n\nDiğer ipuçları\n• Yukarıdaki hesaplamalardan herhangi birinden eksik değerleri hariç tutmak için na.rm = TRUE değişkenini kullanın.\n• tabyl() tarafından oluşturulmamış tablolara herhangi bir adorn_*() yardımcı fonksiyonu uyguluyorsanız, bunları adorn_percentage(,,,c(cases,deaths)) sintaksıyla belirli sütunlara uygulayabilirsiniz. (Sütunlar 4. değişken olarak belirtilmedir.). Sintaksı basit değil, bu nedenle bu işlem yerine summarise() kullanmayı düşünün.\n• Daha fazla ayrıntıyı janitor sayfasından ve tabyl gösteriminden okuyabilirsiniz. janitor sayfası ve tabyl göstergesi.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Tanımlayıcı tablolar</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.tr.html#dplyr-paketi",
    "href": "new_pages/tables_descriptive.tr.html#dplyr-paketi",
    "title": "17  Tanımlayıcı tablolar",
    "section": "17.4 dplyr paketi",
    "text": "17.4 dplyr paketi\ndplyr, tidyverse paketlerinin bir parçasıdır ve çok yaygın bir veri yönetimi aracıdır.\ndplyr’ın summarise() ve count() fonksiyonları tablolar oluşturmak, istatistikleri hesaplamak, gruba göre özetlemek veya tabloları ggplot()’a geçirmek için kullanışlı bir yaklaşımdır.\nsummarise(), yeni bir özet veri çerçevesi oluşturur. Veriler gruplandırılmamışsa, tüm veri çerçevesinin belirtilen özet istatistiklerini içeren tek satırlık bir veri çerçevesi oluşturur. Veriler gruplandırılmışsa, yeni veri çerçevesinde grup başına bir satır oluşturacaktır (bkz. Verilerin gruplandırması sayfası).\n\nsummarise() fonksiyonunun parantezleri içinde, her yeni özet sütununun adını ve ardından bir eşittir işareti ve uygulanacak istatistiksel işlevi argüman olarak belirtmelisiniz.\n\n\n\n\nİPUCU: Özetleme işlevi hem İngiliz hem de Amerikan İngilizcesi ile yazılabilir. (summarise() and summarize()).\n\nGözlem sayılarını elde etme\nsummarise() içinde uygulanacak en basit fonksiyon n()’dir. Satır sayısını elde etmek için parantezleri boş bırakın.\n\nlinelist %&gt;%                 # satır listesiyle başla\n  summarise(n_rows = n())    # n_rows sütunu ile özet veri çerçevesi elde edilir\n\n  n_rows\n1   5888\n\n\nVerileri önceden gruplandırıldığında bu daha ilginç sonuçlar elde edilir.\n\nlinelist %&gt;% \n  group_by(age_cat) %&gt;%     # verileri age_cat sütunundaki değerlere göre gruplandır\n  summarise(n_rows = n())   # *grup başına* satır sayısı elde edilir\n\n# A tibble: 9 × 2\n  age_cat n_rows\n  &lt;fct&gt;    &lt;int&gt;\n1 0-4       1095\n2 5-9       1095\n3 10-14      941\n4 15-19      743\n5 20-29     1073\n6 30-49      754\n7 50-69       95\n8 70+          6\n9 &lt;NA&gt;        86\n\n\nYukarıdaki komut, count() işlevi kullanılarak kısaltılabilir. count() şunları yapar:\n\nVerileri belirlenen sütunlara göre gruplandırır\nVerileri n() ile özetler (n sütunu oluşturur)\nVerileri gruplarını çözer\n\n\nlinelist %&gt;% \n  count(age_cat)\n\n  age_cat    n\n1     0-4 1095\n2     5-9 1095\n3   10-14  941\n4   15-19  743\n5   20-29 1073\n6   30-49  754\n7   50-69   95\n8     70+    6\n9    &lt;NA&gt;   86\n\n\nSayılar sütununun adını varsayılan n’den name = değişkeniyle değiştirebilirsiniz.\nİki veya daha fazla gruplandırma sütunundaki sayılar “uzun” biçimde tablo halinde döndürülür. n sütununda gözlem sayıları bulunmaktadır. “Uzun” ve “geniş” veri biçimleri hakkında bilgi edinmek için verileri pivotlama sayfasına bakın.\n\nlinelist %&gt;% \n  count(age_cat, outcome)\n\n   age_cat outcome   n\n1      0-4   Death 471\n2      0-4 Recover 364\n3      0-4    &lt;NA&gt; 260\n4      5-9   Death 476\n5      5-9 Recover 391\n6      5-9    &lt;NA&gt; 228\n7    10-14   Death 438\n8    10-14 Recover 303\n9    10-14    &lt;NA&gt; 200\n10   15-19   Death 323\n11   15-19 Recover 251\n12   15-19    &lt;NA&gt; 169\n13   20-29   Death 477\n14   20-29 Recover 367\n15   20-29    &lt;NA&gt; 229\n16   30-49   Death 329\n17   30-49 Recover 238\n18   30-49    &lt;NA&gt; 187\n19   50-69   Death  33\n20   50-69 Recover  38\n21   50-69    &lt;NA&gt;  24\n22     70+   Death   3\n23     70+ Recover   3\n24    &lt;NA&gt;   Death  32\n25    &lt;NA&gt; Recover  28\n26    &lt;NA&gt;    &lt;NA&gt;  26\n\n\n\n\nTüm seviyelerin gösterimi\nBir sınıf faktörü sütunu oluştururken, summarise() veya count() komutuna .drop = FALSE argümanını ekleyerek (yalnızca verilerde değerleri olan seviyeleri değil) tüm seviyelerin gösterebilirsiniz.\nBu teknik, tablolarınızı/grafiklerinizi standart hale getirmek için kullanışlıdır. Özellikle, birden fazla alt grup için grafik oluştururken ya da rutin raporlar için tekrarlayan grafiklerr oluştururken faydalıdır. Bu koşulların her birinde, verilerdeki değerler değişse de sabit kalan seviyeler tanımlayabilirsiniz.\nDaha fazla bilgi için [Faktörler] sayfasına bakın.\n\n\nOranlar\nOranlar, yeni bir sütun oluşturmak için tablonun mutate() fonksiyonuna yönlendirmesi ile elde edilebilir. Yeni sütun, sayım sütununun (varsayılan olarak n) sayım sütununun toplamının elde edildiği sum()’a bölünmesiyle oluşturulur (bu işlem bir oran verir).\nBu durumda, mutate() komutundaki sum() öğesinin, oranın paydası olarak kullanılmak üzere tüm n sütununun toplamını vereceğini unutmayın. Verileri gruplandırılması sayfasında açıklandığı gibi, gruplandırılmış verilerde sum() fonksiyonu kullanılıyorsa (örneğin, mutate() fonksiyonu group_by() komutunu takip ediyorsa), gruba göre toplamlar elde edilir. Yukarıda belirtildiği gibi, count() fonksiyonu grupları çözerek görevini tamamlar. Böylece, bu senaryoda tam sütun oranlarını elde ederiz.\nYüzdeleri kolayca görüntülemek için, scales paketinden percent() fonksiyonunu kullanabilirsiniz (bu fonksiyonda verinin sınıf karakterine dönüştürüldüğünü unutmayın).\n\nage_summary &lt;- linelist %&gt;% \n  count(age_cat) %&gt;%                     # cinsiyete göre grupla ve say (\"n\" sütunu oluşur)\n  mutate(                                # sütunun yüzdesini oluştur – paydaya dikkat edin \n    percent = scales::percent(n / sum(n))) \n\n# çıktı al \nage_summary\n\n  age_cat    n percent\n1     0-4 1095  18.60%\n2     5-9 1095  18.60%\n3   10-14  941  15.98%\n4   15-19  743  12.62%\n5   20-29 1073  18.22%\n6   30-49  754  12.81%\n7   50-69   95   1.61%\n8     70+    6   0.10%\n9    &lt;NA&gt;   86   1.46%\n\n\nAşağıda gruplar içindeki oranları hesaplamak için bir yöntem gösterilmiştir. Seçici olarak uygulanan farklı veri gruplama düzeylerine dayanan bir yöntemdir. İlk olarak, veriler group_by() aracılığıyla sonuca göre gruplandırılır. Ardından, count() uygulanır. Bu fonksiyon, verileri age_cat’e göre gruplandırır ve her sonuç-age_cat kombinasyonu için gözlem sayılarını verir. Daha önemlisi, count() aynı zamanda age_cat gruplandırmasını da çözer, bu nedenle geriye kalan tek veri gruplaması sonuca göre orijinal gruplandırmadır. Bu nedenle, oranları hesaplamada son adımı (payda sum(n)) hala sonuca göre gruplandırılmıştır.\n\nage_by_outcome &lt;- linelist %&gt;%                  # satır listesiyle başla\n  group_by(outcome) %&gt;%                         # sonuca göre gruplandır\n  count(age_cat) %&gt;%                            # age_cat ile gruplandır ve say ve ardından age_cat gruplamasını kaldır \n  mutate(percent = scales::percent(n / sum(n))) # yüzdeyi hesapla - paydanın sonuç grubuna göre olduğuna dikkat edin\n\n\n\n\n\n\n\n\n\nGrafikleştirme\nYukarıdaki gibi “uzun” bir tablo ggplot() ile rahatça görüntülenebilir. Veriler ggplot() tarafından doğal olarak kabul edilen “uzun” formattadır. ggplot temelleri ve ggplot ipuçları sayfalarındaki diğer örneklere bakın.\n\nlinelist %&gt;%                      # satır listesiyle başlama\n  count(age_cat, outcome) %&gt;%     # sayıları iki sütuna göre gruplandırın ve tablolaştırın\n  ggplot()+                       # yeni veri çerçevesini ggplot'a geçir\n    geom_col(                     # sütun grafiği oluştur\n      mapping = aes(   \n        x = outcome,              # sonucu x eksenine eşle\n        fill = age_cat,           # age_cat'i dolguya eşle\n        y = n))                   # sayım sütununu `n` yüksekliğe eşle\n\n\n\n\n\n\n\n\n\n\nÖzet istatistiği\ndplyr ve summarise()’in önemli bir avantajı, median(), mean(), max(), min(), sd() (standart sapma) ve yüzdelikler gibi daha ileri istatistik özetleri oluşturma yeteneğidir. Belirli mantık kriterlerini karşılayan satır sayılarını elde etmek için sum() fonksiyonuna da kullanabilirsiniz. Yukarıdaki gibi, bu çıktılar tüm veri çerçevesi için veya belli grup gruplar için oluşturulabilir.\nSintaks aynıdır - summarise() parantezleri içinde yeni özet sütunlarının adları, ardından bir eşittir işareti ve uygulanacak istatistiksel fonksiyonlar yazılmalıdır. İstatistiksel fonksiyon içinde, üzerinde çalışılacak sütunları ve ilgili argümanlar yazılmalıdır (örneğin, çoğu matematiksel fonksiyon için na.rm = DOĞRU).\nMantıksal bir ölçütü karşılayan satır sayısını elde etmek için sum()’u da kullanabilirsiniz. İçindeki ifade TRUE olarak değerlendirilirse sayıma girer. Örneğin:\n\nsum(age_years &lt; 18, na.rm=T)\n\nsum(gender == \"male\", na.rm=T)\n\nsum(response %in% c(\"Likely\", \"Very Likely\"))\n\nAşağıda, satır listesi verilerinde, semptom başlangıcından hastaneye kabule kadar geçen gün gecikmesi değişkeni (sütun days_onset_hosp) özetlenmiştir.\n\nsummary_table &lt;- linelist %&gt;%                                        # linelist ile başlayın, yeni nesne olarak kaydedin\n  group_by(hospital) %&gt;%                                             # tüm hesaplamaları hastaneye göre gruplandır\n  summarise(                                                         # yalnızca aşağıdaki özet sütunları elde edilecek\n    cases       = n(),                                                # grup başına satır sayısı\n    delay_max   = max(days_onset_hosp, na.rm = T),                    # maksimum gecikme\n    delay_mean  = round(mean(days_onset_hosp, na.rm=T), digits = 1),  # ortalama gecikme, yuvarlanmış\n    delay_sd    = round(sd(days_onset_hosp, na.rm = T), digits = 1),  # gecikmelerin standart sapması, yuvarlanmış\n    delay_3     = sum(days_onset_hosp &gt;= 3, na.rm = T),               # 3 veya daha fazla gün gecikmeli satır sayısı\n    pct_delay_3 = scales::percent(delay_3 / cases)                    # önceden tanımlanmış gecikme sütununu yüzdeye dönüştür\n  )\n\nsummary_table  # yazdır\n\n# A tibble: 6 × 7\n  hospital               cases delay_max delay_mean delay_sd delay_3 pct_delay_3\n  &lt;chr&gt;                  &lt;int&gt;     &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;   &lt;int&gt; &lt;chr&gt;      \n1 Central Hospital         454        12        1.9      1.9     108 24%        \n2 Military Hospital        896        15        2.1      2.4     253 28%        \n3 Missing                 1469        22        2.1      2.3     399 27%        \n4 Other                    885        18        2        2.2     234 26%        \n5 Port Hospital           1762        16        2.1      2.2     470 27%        \n6 St. Mark's Maternity …   422        18        2.1      2.3     116 27%        \n\n\nBazı ipuçları\n• Belirli ölçütleri karşılayan (==) satırları “saymak” için bir mantıksal ifadeyle sum() kullanın • sum() gibi matematiksel fonksiyonlarda na.rm = TRUE kullanımına dikkat edin, aksi takdirde eksik değerler varsa NA elde edilir. • Yüzdelere kolayca dönüştürmek için scales paketindeki percent() işlevini kullanın • Sırasıyla 1 veya 2 ondalık basamak sağlamak için accuracy = argümanını 0,1 veya 0,01 olarak ayarlayın • Ondalık sayıları belirtmek için temel R’dan round() fonksiyonunu kullanın • Bu istatistikleri tüm veri kümesinde hesaplamak için, group_by() olmadan summarise() kullanın. • Daha sonraki hesaplamalar için (örneğin payda oluşturmak için) veri çerçevenizden select() ile seçebileceğiniz sütunlar oluşturabilirsiniz.\n\n\nKoşullu istatistikler\nKoşullu istatistikleri elde etmek isteyebilirsiniz - ör. belirli ölçütleri karşılayan maksimum satır sayısı elde edilebilir. Bu işlem, sütun parantez [ ] ile alt kümelere ayrılarak gerçekleştirilebilir. Aşağıdaki örnek, ateşi olan veya olmayan hastalar için maksimum vücut sıcaklığını verir. Ancak unutmayın - group_by()ve pivot_wider() komutlarıyla (aşağıda gösterildiği gibi) başka bir sütun eklemek daha uygun olabilir. (#tbls_pivot_wider)).\n\nlinelist %&gt;% \n  group_by(hospital) %&gt;% \n  summarise(\n    max_temp_fvr = max(temp[fever == \"yes\"], na.rm = T),\n    max_temp_no = max(temp[fever == \"no\"], na.rm = T)\n  )\n\n# A tibble: 6 × 3\n  hospital                             max_temp_fvr max_temp_no\n  &lt;chr&gt;                                       &lt;dbl&gt;       &lt;dbl&gt;\n1 Central Hospital                             40.4        38  \n2 Military Hospital                            40.5        38  \n3 Missing                                      40.6        38  \n4 Other                                        40.8        37.9\n5 Port Hospital                                40.6        38  \n6 St. Mark's Maternity Hospital (SMMH)         40.6        37.9\n\n\n\n\nHepsini birleştirmek\nstringr’den str_glue() fonksiyonu, birkaç sütundaki değerleri yeni bir sütunda birleştirmek için kullanışlıdır. Genellikle bu fonksiyon summarise() komutundan sonra kullanılır.\nKarakterler ve dizeler sayfasında, unite() ve paste0() dahil olmak üzere sütunları birleştirmek için çeşitli seçenekler tartışılmaktadır. Bu kullanım örneğinde, unite()’den daha esnek olduğu ve paste0()’dan daha basit sözdizimine sahip olduğu için str_glue() vurgulanmıştır.\nAşağıdaki örnekte, summary_table veri çerçevesinde, delay_mean ve delay_sd sütunları birleştirilecek, yeni sütuna parantez biçimlendirmesi eklenecek ve ilgili eski sütunlar kaldırılacaktır.\nArdından, tabloyu daha anlaşılır hale getirmek için, janitor’dan adorn_totals() ile toplam bir satır eklenir (bu fonksiyon sayısal olmayan sütunları yok sayar). Son olarak, hem yeniden sıralamak hem de sütunları yeniden adlandırmak için dplyr’den select() kullanıyoruz.\nArtık flextable’a geçebilir ve tablonun çıktısını Word, .png, .jpeg, .html, Powerpoint, RMarkdown, vb.’ye alabilirsiniz! (Sunum için tablolar sayfasına bakınız).\n\nsummary_table %&gt;% \n  mutate(delay = str_glue(\"{delay_mean} ({delay_sd})\")) %&gt;%  # diğer değerleri birleştir ve biçimlendir\n  select(-c(delay_mean, delay_sd)) %&gt;%                       # iki eski sütunu sil  \n  adorn_totals(where = \"row\") %&gt;%                            # toplam satırı ekle\n  select(                                                    # sütunları sırala ve yeniden adlandır\n    \"Hospital Name\"   = hospital,\n    \"Cases\"           = cases,\n    \"Max delay\"       = delay_max,\n    \"Mean (sd)\"       = delay,\n    \"Delay 3+ days\"   = delay_3,\n    \"% delay 3+ days\" = pct_delay_3\n    )\n\n                        Hospital Name Cases Max delay Mean (sd) Delay 3+ days\n                     Central Hospital   454        12 1.9 (1.9)           108\n                    Military Hospital   896        15 2.1 (2.4)           253\n                              Missing  1469        22 2.1 (2.3)           399\n                                Other   885        18   2 (2.2)           234\n                        Port Hospital  1762        16 2.1 (2.2)           470\n St. Mark's Maternity Hospital (SMMH)   422        18 2.1 (2.3)           116\n                                Total  5888       101         -          1580\n % delay 3+ days\n             24%\n             28%\n             27%\n             26%\n             27%\n             27%\n               -\n\n\n\nYüzdelikler\nBurada dplyr’deki yüzdelikler ve çeyrekliklere özel olarak değinilecektir. Yüzdelikleri döndürmek için, ‘quantile()’ fonksiyonunu varsayılanlarla kullanın veya istediğiniz değeri/değerleri ‘probs =’ değişkeni ile belirtin.\n\n# yaşın varsayılan yüzdelik değerlerini alın (%0, %25, %50, %75, %100)\nlinelist %&gt;% \n  summarise(age_percentiles = quantile(age_years, na.rm = TRUE))\n\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\nℹ Please use `reframe()` instead.\nℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n\n\n  age_percentiles\n1               0\n2               6\n3              13\n4              23\n5              84\n\n# manuel olarak belirtilen yaş yüzdelik değerlerini alın (%5, %50, %75, %98)\nlinelist %&gt;% \n  summarise(\n    age_percentiles = quantile(\n      age_years,\n      probs = c(.05, 0.5, 0.75, 0.98), \n      na.rm=TRUE)\n    )\n\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\nℹ Please use `reframe()` instead.\nℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n\n\n  age_percentiles\n1               1\n2              13\n3              23\n4              48\n\n\nYüzdelikleri gruplara göre elde etmek istiyorsanız, group_by() öğesine basitçe başka bir sütun eklerseniz, uzun ve kullanışsız çıktılarla karşılaşabilirsiniz. Bu nedenle, bunun yerine istenen her yüzdelik düzeyi için bir sütun oluşturma yöntemini kullanın.\n\n#   manuel olarak belirtilen yaş yüzdelik değerlerini alın (%5, %50, %75, %98)\nlinelist %&gt;% \n  group_by(hospital) %&gt;% \n  summarise(\n    p05 = quantile(age_years, probs = 0.05, na.rm=T),\n    p50 = quantile(age_years, probs = 0.5, na.rm=T),\n    p75 = quantile(age_years, probs = 0.75, na.rm=T),\n    p98 = quantile(age_years, probs = 0.98, na.rm=T)\n    )\n\n# A tibble: 6 × 5\n  hospital                               p05   p50   p75   p98\n  &lt;chr&gt;                                &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Central Hospital                         1    12    21  48  \n2 Military Hospital                        1    13    24  45  \n3 Missing                                  1    13    23  48.2\n4 Other                                    1    13    23  50  \n5 Port Hospital                            1    14    24  49  \n6 St. Mark's Maternity Hospital (SMMH)     2    12    22  50.2\n\n\ndplyr summarise() fonksiyonu kesinlikle daha iyi kontrol sağlarken, ihtiyacınız olan tüm özet istatistiklerin rstatix paketinden get_summary_stat() ile elde edebilirsiniz. Gruplandırılmış veriler üzerinde çalışıyorsanız, %0, %25, %50, %75 ve %100 değerlerini elde edebilirsiniz. Gruplandırılmamış verilere uygularsanız, yüzdelikleri probs = c(.05, .5, .75, .98) değişkeni ile belirtebilirsiniz.\n\nlinelist %&gt;% \n  group_by(hospital) %&gt;% \n  rstatix::get_summary_stats(age, type = \"quantile\")\n\n# A tibble: 6 × 8\n  hospital                         variable     n  `0%` `25%` `50%` `75%` `100%`\n  &lt;chr&gt;                            &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1 Central Hospital                 age        445     0     6    12    21     58\n2 Military Hospital                age        884     0     6    14    24     72\n3 Missing                          age       1441     0     6    13    23     76\n4 Other                            age        873     0     6    13    23     69\n5 Port Hospital                    age       1739     0     6    14    24     68\n6 St. Mark's Maternity Hospital (… age        420     0     7    12    22     84\n\n\n\nlinelist %&gt;% \n  rstatix::get_summary_stats(age, type = \"quantile\")\n\n# A tibble: 1 × 7\n  variable     n  `0%` `25%` `50%` `75%` `100%`\n  &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1 age       5802     0     6    13    23     84\n\n\n\n\n\nBirleştirilmiş verileri özetleyin\nBirleştirilmiş verilerle başlarsanız, n() fonksiyonunu kullandığınızda, toplanan sayıların toplamını değil, satır sayısını elde edersiniz. Toplamları almak için verilerin sayımlar sütununda sum() öğesini kullanın. Örneğin, linelist_agg adında sayım veri çerçevesiyle başladığınızı varsayalım- vaka sayıları sonuca ve cinsiyete göre “uzun” biçimde gösterilir. Aşağıda, sonuca ve cinsiyete göre satır listesi vaka sayılarının örnek veri çerçevesini oluşturuyoruz (Anlaşılması için eksik değerler kaldırıldı).\n\nlinelist_agg &lt;- linelist %&gt;% \n  drop_na(gender, outcome) %&gt;% \n  count(outcome, gender)\n\nlinelist_agg\n\n  outcome gender    n\n1   Death      f 1227\n2   Death      m 1228\n3 Recover      f  953\n4 Recover      m  950\n\n\nSayıları (n sütunundaki) gruba göre toplamak için summarise()’i kullanabilirsiniz, ancak yeni sütunu sum(n, na.rm=T) değerine eşitlemeniz gerekmektedir. Toplam işlemine koşullu öğe eklemek için, sayımlar sütunundaki alt küme ayracını [ ] kullanabilirsiniz.\n\nlinelist_agg %&gt;% \n  group_by(outcome) %&gt;% \n  summarise(\n    total_cases  = sum(n, na.rm=T),\n    male_cases   = sum(n[gender == \"m\"], na.rm=T),\n    female_cases = sum(n[gender == \"f\"], na.rm=T))\n\n# A tibble: 2 × 4\n  outcome total_cases male_cases female_cases\n  &lt;chr&gt;         &lt;int&gt;      &lt;int&gt;        &lt;int&gt;\n1 Death          2455       1228         1227\n2 Recover        1903        950          953\n\n\n\n\nacross() birden çok sütun arasından\nsummarise() fonksiyonunu across() kullanarak birden çok sütuna uygulayabilirsiniz. Bu şekilde birçok sütun için aynı istatistikleri hesaplayabilirsiniz . summarise() fonksiyonu içine across() fonksiyonunu yerleştirin ve aşağıdakileri belirtin:\n\n.cols = sütun adlarının bir vektörü olarak .cols = c() veya “tidyselect” yardımcı işlevleri (aşağıda açıklanmıştır)\n.fns =gerçekleştirilecek fonksiyon (parantez yok) - bir liste içinde birden çok fonksiyon belirtebilirsiniz.\n\nAşağıda, mean() birkaç sayısal sütuna uygulanmıştır. Bir sütun vektörü .cols = argümanı olarak belirtilir ve .fns = olarak tek bir fonksiyon- bu durumda (parantez olmadan) ortalama belirtilir. İşlev için ek argümanlar (ör. na.rm=TRUE), .fns = argümanından sonra virgülle ayrılmış olarak yazılır.\nAcross() kullanılırken parantez ve virgüllerin sırasını doğru yapmak zor olabilir. Across() içinde, sütunları, fonksiyonları ve fonkisyonlar için gereken fazladan argümanları dahil etmeniz gerektiğini unutmayın.\n\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm),  # sütunlar\n                   .fns = mean,                               # fonksiyon\n                   na.rm=T))                                  # ekstra değişkenler\n\nWarning: There was 1 warning in `summarise()`.\nℹ In argument: `across(...)`.\nℹ In group 1: `outcome = \"Death\"`.\nCaused by warning:\n! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\nSupply arguments directly to `.fns` through an anonymous function instead.\n\n  # Previously\n  across(a:b, mean, na.rm = TRUE)\n\n  # Now\n  across(a:b, \\(x) mean(x, na.rm = TRUE))\n\n\n# A tibble: 3 × 5\n  outcome age_years  temp wt_kg ht_cm\n  &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Death        15.9  38.6  52.6  125.\n2 Recover      16.1  38.6  52.5  125.\n3 &lt;NA&gt;         16.2  38.6  53.0  125.\n\n\nAynı anda birden fazla fonksiyon çalıştırılabilir. Aşağıda, bir liste list() içinde .fns = için mean ve sd fonkisyonları sağlanır. Yeni sütunları istediğimiz gibbi adlandırabiliriz (örneğin, “ortalama” ve “sd”).\n\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm), # sütunlar\n                   .fns = list(\"mean\" = mean, \"sd\" = sd),    # çoklu fonksiyon \n                   na.rm=T))                                 # ekstra değişkenler\n\n# A tibble: 3 × 9\n  outcome age_years_mean age_years_sd temp_mean temp_sd wt_kg_mean wt_kg_sd\n  &lt;chr&gt;            &lt;dbl&gt;        &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;\n1 Death             15.9         12.3      38.6   0.962       52.6     18.4\n2 Recover           16.1         13.0      38.6   0.997       52.5     18.6\n3 &lt;NA&gt;              16.2         12.8      38.6   0.976       53.0     18.9\n# ℹ 2 more variables: ht_cm_mean &lt;dbl&gt;, ht_cm_sd &lt;dbl&gt;\n\n\nSütunları seçmek için .cols = argümanı için sağlayabileceğiniz “tidyselect” yardımcı işlevleri şunlardır:\n• everything() - belirtilmeyen diğer tüm sütunlar • last_col() – son sütun • where() - tüm sütunlara bir fonksiyonu uygular ve DOĞRU olanları seçer • starts_with() - belirli bir ön-ekle eşleşir. Örnek: starts_with(“date”) • ends_with() - belirli bir son-ekle eşleşir. Örnek:ends_with(“_end”) • contains() - bir karakter dizisi içeren sütunlar. Örnek:contains(“time”) • matches() - regüler bir ifade (regex) uygulamak için. Örnek:contains(“[pt]al”) • num_range() - • any_of() – sütun adlandırılmışsa eşleşir. Ad mevcut değilse kullanışlıdır. Örnek: • any_of(date_onset, date_death, cardiac_arrest)\nÖrneğin, her sayısal sütunun ortalamasını elde etmek için where() fonksiyonunu kullanın ve içinde is.numeric’i parentez olmadan kullanın. Bütün bunlar across() komutu içinde kalır.\n\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  summarise(across(\n    .cols = where(is.numeric),  # veri çerçevesindeki tüm sayısal sütunlar\n    .fns = mean,\n    na.rm=T))\n\n# A tibble: 3 × 12\n  outcome generation   age age_years   lon   lat wt_kg ht_cm ct_blood  temp\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;\n1 Death         16.7  15.9      15.9 -13.2  8.47  52.6  125.     21.3  38.6\n2 Recover       16.4  16.2      16.1 -13.2  8.47  52.5  125.     21.1  38.6\n3 &lt;NA&gt;          16.5  16.3      16.2 -13.2  8.47  53.0  125.     21.2  38.6\n# ℹ 2 more variables: bmi &lt;dbl&gt;, days_onset_hosp &lt;dbl&gt;\n\n\n\n\nPivot genişletme\nTablonuzu “geniş” biçimde oluşturmayı tercih ederseniz, tidyr pivot_wider() fonksiyonunu kullanarak dönüştürebilirsiniz. Sütunları rename() ile yeniden adlandırmanız gerekebilir. Daha fazla bilgi için Verilerin pivotlanması sayfasına bakın.\nAşağıdaki örnek, oranlar bölümündeki “uzun” tablodur ve age_by_outcome ile başlamaktadır.\n\nage_by_outcome &lt;- linelist %&gt;%                  # satır listesiyle başla\n  group_by(outcome) %&gt;%                         # sonuca göre gruplandır\n  count(age_cat) %&gt;%                            # age_cat ile gruplandırın ve sayın ve ardından age_cat gruplamasını kaldırın\n  mutate(percent = scales::percent(n / sum(n))) # yüzdeyi hesapla - paydanın sonuç grubuna göre olduğuna dikkat edin\n\n\n\n\n\n\n\nDaha geniş bir tablo halinde özetlemek için ScriptTo ile, mevcut age_cat sütunundaki değerlerden name_from = age_cat ayarını yaparak yeni sütunlar yaratırız. Yeni tablo değerleri mevcut n sütunundan, value_from = n ile elde edilecektir. Pivotlama komutumuzda (çıktı) belirtilmeyen sütunlar, en sol tarafta değişmeden kalacaktır.\n\nage_by_outcome %&gt;% \n  select(-percent) %&gt;%   # basit gösterim için sadece sayımlar \n  pivot_wider(names_from = age_cat, values_from = n)  \n\n# A tibble: 3 × 10\n# Groups:   outcome [3]\n  outcome `0-4` `5-9` `10-14` `15-19` `20-29` `30-49` `50-69` `70+`  `NA`\n  &lt;chr&gt;   &lt;int&gt; &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n1 Death     471   476     438     323     477     329      33     3    32\n2 Recover   364   391     303     251     367     238      38     3    28\n3 &lt;NA&gt;      260   228     200     169     229     187      24    NA    26\n\n\n\n\nToplam satırlar\nsummarise () işlevi, gruplanmış veriler üzerinde çalıştığında, otomatik olarak “toplam” istatistikler üretmez. Aşağıda, toplam satır eklemeye yönelik iki yaklaşım sunulmaktadır:\n\njanitor’ün adorn_totals() fonskiyonu\nTablonuz yalnızca toplamda elde edilebilecek sayılardan veya orantılardan/yüzdelerden oluşuyorsa, yukarıdaki bölümde açıklandığı gibi janitor adorn_totals() fonksiyonunu kullanarak toplamları ekleyebilirsiniz. Bu fonkisyonun yalnızca sayısal sütunları toplayabileceğine dikkat edin - diğer toplam özet istatistiklerini hesaplamak istiyorsanız dplyr ile sonraki yaklaşıma bakın.\nAşağıda, satır listesi cinsiyete göre gruplandırılmıştır ve sonucu bilinen, ölen ve iyileşen vakaların sayısını açıklayan bir tabloda özetlenmiştir. Tabloyu adorn_totals()’a yönlendirmek, tablonun altına her sütunun toplamını yansıtan bir toplam satır ekler. Diğer adorn_*() işlevleri, kodda belirtildiği gibi ekranı ayarlar.\n\nlinelist %&gt;% \n  group_by(gender) %&gt;%\n  summarise(\n    known_outcome = sum(!is.na(outcome)),           # Sonucun eksik olmadığı gruptaki satır sayısı\n    n_death  = sum(outcome == \"Death\", na.rm=T),    # Sonucun ölüm olduğu gruptaki satır sayısı\n    n_recover = sum(outcome == \"Recover\", na.rm=T), # Sonucun hayatta kalma olduğu gruptaki satır sayısı\n  ) %&gt;% \n  adorn_totals() %&gt;%                                # Toplam satırı (her sayısal sütunun toplamı)\n  adorn_percentages(\"col\") %&gt;%                      # Sütun oranlarını al\n  adorn_pct_formatting() %&gt;%                        # Oranları yüzdelere dönüştür\n  adorn_ns(position = \"front\")                      # % ve sayıları göster (sayılar önde)\n\n gender  known_outcome        n_death      n_recover\n      f 2,180  (47.8%) 1,227  (47.5%)   953  (48.1%)\n      m 2,178  (47.7%) 1,228  (47.6%)   950  (47.9%)\n   &lt;NA&gt;   207   (4.5%)   127   (4.9%)    80   (4.0%)\n  Total 4,565 (100.0%) 2,582 (100.0%) 1,983 (100.0%)\n\n\n\n\nToplam veride summarise() sonrasında bind_rows() fonksiyonu\nTablonuz median(), mean() vb. özet istatistiklerden oluşuyorsa, yukarıda gösterilen adorn_totals() yaklaşımı yeterli olmayacaktır. Bunun yerine, tüm veri kümesi için özet istatistikleri elde etmek için ayrı bir summarise() komutu kullanarak hesaplamanız ve ardından sonuçları orijinal gruplandırılmış özet tablosuna eklemeniz gerekir. Birleştirmeyi yapmak için, Verilerin birleştirilmesi sayfasında açıklanan dplyr’dan bind_rows() fonksiyonunu kullanabilirsiniz. Aşağıda bir örnek verilmiştir:\ngroup_by() ve summarise() ile hastane bazında sonuçların özetini şu şekilde çıkarabilirsiniz:\n\nby_hospital &lt;- linelist %&gt;% \n  filter(!is.na(outcome) & hospital != \"Missing\") %&gt;%  # Eksik sonuç veya hastane verisi olan vakaları sil\n  group_by(hospital, outcome) %&gt;%                      # Veriyi grupla \n  summarise(                                           # İlgilenilen göstergelerin yeni özet sütunları oluşturun\n    N = n(),                                            # Hastane-sonuç grubu başına satır sayısı\n    ct_value = median(ct_blood, na.rm=T))               # by_hospital grubu başına medyan CT değeri\n\nby_hospital # tabloyu yazdır  \n\n# A tibble: 10 × 4\n# Groups:   hospital [5]\n   hospital                             outcome     N ct_value\n   &lt;chr&gt;                                &lt;chr&gt;   &lt;int&gt;    &lt;dbl&gt;\n 1 Central Hospital                     Death     193       22\n 2 Central Hospital                     Recover   165       22\n 3 Military Hospital                    Death     399       21\n 4 Military Hospital                    Recover   309       22\n 5 Other                                Death     395       22\n 6 Other                                Recover   290       21\n 7 Port Hospital                        Death     785       22\n 8 Port Hospital                        Recover   579       21\n 9 St. Mark's Maternity Hospital (SMMH) Death     199       22\n10 St. Mark's Maternity Hospital (SMMH) Recover   126       22\n\n\nToplamları almak için summarise() komutunu çalıştırın, ancak verileri yalnızca sonuca göre (hastaneye göre değil) şu şekilde gruplandırın:\n\ntotals &lt;- linelist %&gt;% \n      filter(!is.na(outcome) & hospital != \"Missing\") %&gt;%\n      group_by(outcome) %&gt;%                            # Hastaneye göre değil, yalnızca sonuca göre gruplandırılmış  \n      summarise(\n        N = n(),                                       # Bu istatistikler artık sadece sonuca göre     \n        ct_value = median(ct_blood, na.rm=T))\n\ntotals # tabloyu yazdır\n\n# A tibble: 2 × 3\n  outcome     N ct_value\n  &lt;chr&gt;   &lt;int&gt;    &lt;dbl&gt;\n1 Death    1971       22\n2 Recover  1469       22\n\n\nBu iki veri çerçevesini birbirine bağlayabiliriz. by_hospital’in 4 sütunu, toplamların ise 3 sütunu olduğunu unutmayın. bind_rows() kullanılarak, sütunlar ada göre birleştirilir ve fazladan boşluklar NA ifadesi ile doldurulur (örneğin, iki yeni toplam satırı için sütun hastane değerleri). Satırları bağladıktan sonra, bu boş alanları replace_na() kullanarak “toplam”a dönüştürürüz (bkz. Veri temizliği ve çekirdek fonksiyonlar sayfaları).\n\ntable_long &lt;- bind_rows(by_hospital, totals) %&gt;% \n  mutate(hospital = replace_na(hospital, \"Total\"))\n\nAltta “Toplam” satırları olan yeni tablo yer almaktadır.\n\n\n\n\n\n\nBu tablo, istediğiniz gibi “uzun” biçimdedir. İsteğe bağlı olarak, tabloyu daha okunabilir hale getirmek için bu tabloyu daha geniş forma pivotlayabilirsiniz. Yukarıdaki daha geniş pivotlama ile ilgili bölüme ve Verilerin pivotlanması sayfasına bakın. Ayrıca daha fazla sütun ekleyebilir ve düzenleyebilirsiniz. İlgili kod aşağıdadır.\n\ntable_long %&gt;% \n  \n  # Daha geniş pivotlama ve formatlama \n\n    mutate(hospital = replace_na(hospital, \"Total\")) %&gt;% \n  pivot_wider(                                         # Uzundan genişe pivotlama\n    values_from = c(ct_value, N),                       # yeni değerler ct ve count sütunlarından alınmıştır\n    names_from = outcome) %&gt;%                           # sonuçlardan yeni sütun adları \n  mutate(                                              # Yeni sütunlar ekle\n    N_Known = N_Death + N_Recover,                               # sonucu bilinen sayı\n    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # ölen vakaların yüzdesi (1 ondalık basamağa kadar)\n    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %&gt;% # iyileşenlerin yüzdesi (1 ondalık basamağa kadar)\n  select(                                              # Sütunları yeniden sırala\n    hospital, N_Known,                                   # Giriş sütunları\n    N_Recover, Pct_Recover, ct_value_Recover,            # İyileşenlerin sütunları\n    N_Death, Pct_Death, ct_value_Death)  %&gt;%             # Ölen vakaların sütunları\n  arrange(N_Known)                                  # Satırları en düşükten en yükseğe doğru düzenleyin (Toplam satır en altta)\n\n# A tibble: 6 × 8\n# Groups:   hospital [6]\n  hospital      N_Known N_Recover Pct_Recover ct_value_Recover N_Death Pct_Death\n  &lt;chr&gt;           &lt;int&gt;     &lt;int&gt; &lt;chr&gt;                  &lt;dbl&gt;   &lt;int&gt; &lt;chr&gt;    \n1 St. Mark's M…     325       126 38.8%                     22     199 61.2%    \n2 Central Hosp…     358       165 46.1%                     22     193 53.9%    \n3 Other             685       290 42.3%                     21     395 57.7%    \n4 Military Hos…     708       309 43.6%                     22     399 56.4%    \n5 Port Hospital    1364       579 42.4%                     21     785 57.6%    \n6 Total            3440      1469 42.7%                     22    1971 57.3%    \n# ℹ 1 more variable: ct_value_Death &lt;dbl&gt;\n\n\nDaha sonra bu tablo daha “güzel” bir şekilde yazdırabilir. Aşağıda flextable ile elde edilen çıktı yer almaktadır. Bu “güzel” tablonun nasıl elde edileceği hakkında daha ayrıntılı bilgiyi Sunum için Tablolar sayfasından okuyabilirsiniz.\n\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Tanımlayıcı tablolar</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.tr.html#tbl_gt",
    "href": "new_pages/tables_descriptive.tr.html#tbl_gt",
    "title": "17  Tanımlayıcı tablolar",
    "section": "17.5 gtsummary paketi",
    "text": "17.5 gtsummary paketi\nÖzet istatistiklerinizi yayına hazır bir grafikte yazdırmak istiyorsanız, gtsummary paketini ve onun tbl_summary() fonksiyonunu kullanabilirsiniz. Kod ilk başta karmaşık görünebilir, ancak çıktıları güzel görünür ve RStudio Viewer panelinize HTML görüntüsü olarak yazdırılır. gösterimi burada.\nAyrıca istatistiksel testlerin sonuçlarını gtsummary tablolarına ekleyebilirsiniz. Bu işlem, Basit istatistik testleri sayfasının gtsummary bölümünde açıklanmıştır.Basit istatistiksel testler sayfası.\ntbl_summary()’yi tanıtmak için öncelikle büyük ve güzel tablolar oluşturan en temel işlevlerini göstereceğiz. Daha sonra düzenlemelerin ve özel tablolar yapımını detaylı olarak inceleyeceğiz.\n\nÖzet tablosu\ntbl_summary()’nin varsayılan fonksiyonuyla belirtilen sütunları alır ve tek komutta bir özet tablo oluşturur. İşlev, sütun sınıfına uygun istatistikleri yazdırır: sayısal sütunlar için medyan ve çeyrekler arası aralık (IQR) ve kategorik sütunlar için gözlem sayısı (%) istatistiklerini verir. Eksik değerler “Bilinmeyen” ifadesnie dönüştürülür. İstatistikleri açıklamak için en alta dipnotlar eklenirken, toplam N üstte gösterilir.\n\nlinelist %&gt;% \n  select(age_years, gender, outcome, fever, temp, hospital) %&gt;%  # sadece ilgilenilen sütunları tut\n  tbl_summary()                                                  # varsayılan\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nN = 5,8881\n\n\n\n\nage_years\n13 (6, 23)\n\n\n    Unknown\n86\n\n\ngender\n\n\n\n\n    f\n2,807 (50%)\n\n\n    m\n2,803 (50%)\n\n\n    Unknown\n278\n\n\noutcome\n\n\n\n\n    Death\n2,582 (57%)\n\n\n    Recover\n1,983 (43%)\n\n\n    Unknown\n1,323\n\n\nfever\n4,549 (81%)\n\n\n    Unknown\n249\n\n\ntemp\n38.80 (38.20, 39.20)\n\n\n    Unknown\n149\n\n\nhospital\n\n\n\n\n    Central Hospital\n454 (7.7%)\n\n\n    Military Hospital\n896 (15%)\n\n\n    Missing\n1,469 (25%)\n\n\n    Other\n885 (15%)\n\n\n    Port Hospital\n1,762 (30%)\n\n\n    St. Mark's Maternity Hospital (SMMH)\n422 (7.2%)\n\n\n\n1 Median (IQR); n (%)\n\n\n\n\n\n\n\n\n\n\n\nAyarlar\nŞimdi fonksiyonun nasıl çalıştığını ve ayarlamaların nasıl yapıldığını anlatacağız. Temel değişkenler aşağıda detaylandırılmıştır:\nby =\n2 yönlü bir tablo oluşturarak tablonuzu bir sütuna göre (örn. sonuca göre) tabakalandırabilirsiniz.\nstatistic =\nHangi istatistiklerin gösterileceğini ve nasıl görüntüleneceğini belirtmek için denklem kullanın. Denklemin bir tilde ~ işareti ile ayrılmış iki tarafı vardır. Sağ tarafta istenen istatistiksel hesap, sol tarafta ise bu hesabın uygulanacağı sütunlar yer almaktadır.\n• Denklemin sağ tarafındaki stringr’den str_glue() sintaksına (bkz. “n” (sayılar için), “N” (payda için), “mean”, “median”, “sd”, “max”, “min”, yüzdelikleri ( “p##” olarak; örneğin p25, toplamın yüzdeliği p) dahil edebilirsiniz. Ayrıntılar için ?tbl_summary komutunu uygulayın.\n• Denklemin sol tarafı için sütunları ada göre (örn. yaş veya c(yaş, cinsiyet)) veya all_continuous(), all_categorical(), include(), start_with(), vb. gibi yardımcıları kullanarak belirtebilirsiniz.\nBasit bir statistics = denklemi örneği, yalnızca age_years sütununun ortalamasını yazdırmak için aşağıdaki gibi görünebilir:\n\nlinelist %&gt;% \n  select(age_years) %&gt;%         # yalnızca ilgilenilen sütunları tut\n  tbl_summary(                  # özet tablo oluştur\n    statistic = age_years ~ \"{mean}\") # yaş ortalamasını yazdır\n\n\n\n\n\n\n\n\nCharacteristic\nN = 5,8881\n\n\n\n\nage_years\n16\n\n\n    Unknown\n86\n\n\n\n1 Mean\n\n\n\n\n\n\n\n\n\nBiraz daha karmaşık gibi görünebilen denklem “({min}, {maks})”, maksimum ve minimum değerleri parantez içine alır ve virgülle ayırır:\n\nlinelist %&gt;% \n  select(age_years) %&gt;%                       # yalnızca ilgilenilen sütunları tut \n  tbl_summary(                                # özet tablo oluştur\n    statistic = age_years ~ \"({min}, {max})\") # yaşın en küçük ve en büyük değerlerini yazdır\n\n\n\n\n\n\n\n\nCharacteristic\nN = 5,8881\n\n\n\n\nage_years\n(0, 84)\n\n\n    Unknown\n86\n\n\n\n1 (Range)\n\n\n\n\n\n\n\n\n\nAyrı sütunlar veya sütun türleri için sintaksı de farklılaştırabilirsiniz. Aşağıdaki daha karmaşık örnekte, statistic = argümanına sağlanan değer, tablonun tüm sürekli sayısal sütunlar için parantez içinde standart sapma ile ortalamayı, tüm kategorik sütunlar için ise n, payda ve yüzdeyi yazdırması gerektiğini belirten bir listedir.\ndigits = Rakamları ve yuvarlamayı ayarlayın. İsteğe bağlı olarak, bu yalnızca sürekli sütunlar için belirtilebilir (aşağıdaki gibi).\nlabel= Sütun adının nasıl görüntüleneceğini ayarlayın. Bir tilde ~ ile ayrılmış sütun adını ve istenen etiketi sağlayın. Varsayılan, sütun adıdır.\nMissing_text= Eksik değerlerin nasıl görüntüleneceğini ayarlayın. Varsayılan ifade “Bilinmeyen”dir.\ntype = Bu argüman, istatistiklerin hangi düzeyinin gösterileceğini ayarlamak için kullanılır. Sintaksı, statistic = değişkeni ile benzerdir, çünkü solda sütunlar ve sağda değer içeren bir denklem oluşturursunuz. İki yaygın senaryo şunları içerir:\n• type = all_categorical() ~ “categorical” İkili sütunları (örn. ateş evet/hayır) yalnızca “evet” satırı yerine tüm seviyeleri göstermeye zorlar\n• type = all_continuous() ~ “continuous2” Daha sonraki bir bölümde gösterildiği gibi, değişken başına çok satırlı istatistiklere izin verir\nAşağıdaki örnekte, bu bağımsız değişkenlerin her biri orijinal özet tablosunu değiştirmek için kullanılır:\n\nlinelist %&gt;% \n  select(age_years, gender, outcome, fever, temp, hospital) %&gt;% # yalnızca ilgilenilen sütunları tut\n  tbl_summary(     \n    by = outcome,                                               # tüm tabloyu sonuca göre katmanlandır\n    statistic = list(all_continuous() ~ \"{mean} ({sd})\",        # sürekli sütunlar için istatistikler ve biçim\n                     all_categorical() ~ \"{n} / {N} ({p}%)\"),   # kategorik sütunlar için istatistikler ve biçim\n    digits = all_continuous() ~ 1,                              # sürekli sütunlar için yuvarlama\n    type   = all_categorical() ~ \"categorical\",                 # tüm kategorik seviyeleri görüntülemeye zorla\n    label  = list(                                              # sütun adları için etiketleri göster\n      outcome   ~ \"Outcome\",                           \n      age_years ~ \"Age (years)\",\n      gender    ~ \"Gender\",\n      temp      ~ \"Temperature\",\n      hospital  ~ \"Hospital\"),\n    missing_text = \"Missing\"                                    # eksik değerler nasıl gösterilmelidir\n  )\n\n1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nDeath, N = 2,5821\nRecover, N = 1,9831\n\n\n\n\nAge (years)\n15.9 (12.3)\n16.1 (13.0)\n\n\n    Missing\n32\n28\n\n\nGender\n\n\n\n\n\n\n    f\n1,227 / 2,455 (50%)\n953 / 1,903 (50%)\n\n\n    m\n1,228 / 2,455 (50%)\n950 / 1,903 (50%)\n\n\n    Missing\n127\n80\n\n\nfever\n\n\n\n\n\n\n    no\n458 / 2,460 (19%)\n361 / 1,904 (19%)\n\n\n    yes\n2,002 / 2,460 (81%)\n1,543 / 1,904 (81%)\n\n\n    Missing\n122\n79\n\n\nTemperature\n38.6 (1.0)\n38.6 (1.0)\n\n\n    Missing\n60\n55\n\n\nHospital\n\n\n\n\n\n\n    Central Hospital\n193 / 2,582 (7.5%)\n165 / 1,983 (8.3%)\n\n\n    Military Hospital\n399 / 2,582 (15%)\n309 / 1,983 (16%)\n\n\n    Missing\n611 / 2,582 (24%)\n514 / 1,983 (26%)\n\n\n    Other\n395 / 2,582 (15%)\n290 / 1,983 (15%)\n\n\n    Port Hospital\n785 / 2,582 (30%)\n579 / 1,983 (29%)\n\n\n    St. Mark's Maternity Hospital (SMMH)\n199 / 2,582 (7.7%)\n126 / 1,983 (6.4%)\n\n\n\n1 Mean (SD); n / N (%)\n\n\n\n\n\n\n\n\n\n\n\nSürekli değişkenler için çok satırlı istatistikler\nSürekli değişkenler için birden çok istatistik satırı yazdırmak istiyorsanız, bunu type = değişkenini “continuous2” olarak ayarlayarak belirtebilirsiniz. Hangi istatistikleri göstermek istediğinizi seçerek, daha önce gösterilen tüm öğeleri tek bir tabloda birleştirebilirsiniz. Bunun için type argümanına “continuous2” girerek tabloyu geri almak istediğinizi fonksiyona belirtmeniz gerekir. Eksik değerlerin sayısı “Bilinmeyen” olarak gösterilir.\n\nlinelist %&gt;% \n  select(age_years, temp) %&gt;%                      # yalnızca ilgilenilen sütunları tut\n  tbl_summary(                                     # özet tablo oluştur\n    type = all_continuous() ~ \"continuous2\",       # birden fazla istatistik yazdırmak istediğinizi belirtin\n    statistic = all_continuous() ~ c(\n      \"{mean} ({sd})\",                             # 1. satır: ortalama ve SD\n      \"{median} ({p25}, {p75})\",                   # 2. satır: medyan ve IQR\n      \"{min}, {max}\")                              # satır 3: min ve maks\n    )\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nN = 5,888\n\n\n\n\nage_years\n\n\n\n\n    Mean (SD)\n16 (13)\n\n\n    Median (IQR)\n13 (6, 23)\n\n\n    Range\n0, 84\n\n\n    Unknown\n86\n\n\ntemp\n\n\n\n\n    Mean (SD)\n38.56 (0.98)\n\n\n    Median (IQR)\n38.80 (38.20, 39.20)\n\n\n    Range\n35.20, 40.80\n\n\n    Unknown\n149\n\n\n\n\n\n\n\n\nBu tabloları p değerleri eklenerek, renk ve başlıkları ayarlayarak vb. gibi birçok başka şekilde değiştirilebilir. Bu işlemler çoğu belgelerde açıklanmıştır (Konsol’a ?tbl_summary komutunu girin) ve diğer işlemler ise istatistiksel testler bölümünde açıklanmıştır.istatistiksel testler.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Tanımlayıcı tablolar</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.tr.html#r-tabanı",
    "href": "new_pages/tables_descriptive.tr.html#r-tabanı",
    "title": "17  Tanımlayıcı tablolar",
    "section": "17.6 R tabanı",
    "text": "17.6 R tabanı\nSütunları tablolamak ve çapraz tablo oluşturmak için table() fonkisyonunu kullanabilirsiniz. Yukarıdaki seçeneklerden farklı olarak, aşağıda gösterildiği gibi bir sütun adına her başvurduğunuzda veri çerçevesini belirtmelisiniz.\nUyarı: NA (eksik) değerler, useNA = “always” (aynı zamanda “hayır” veya “eğer” olarak da ayarlanabilir) değişkenini eklemediğiniz sürece tablo haline getirilmeyecektir.\nİPUCU: Baz fonksiyonlarda tekrarlanan veri çerçevesi belirtme ihtiyacını ortadan kaldırmak için magrittr’den %$% operatörünü kullanabilirsiniz. Örneğin aşağıdaki satır listesi tablosunu inceleyin (çıktı, useNA = “always”)\n\ntable(linelist$outcome, useNA = \"always\")\n\n\n  Death Recover    &lt;NA&gt; \n   2582    1983    1323 \n\n\nBirden çok sütun, virgülle ayrılmış şekilde ardışık olarak listelenerek çapraz tablo haline getirilebilir. İsteğe bağlı olarak, her sütuna Outcome = linelist$outcome değişkeni gösterildiği gibi bir ad atayabilirsiniz.\n\nage_by_outcome &lt;- table(linelist$age_cat, linelist$outcome, useNA = \"always\") # tabloyu nesne olarak kaydet\nage_by_outcome   # tabloyu yazdır\n\n       \n        Death Recover &lt;NA&gt;\n  0-4     471     364  260\n  5-9     476     391  228\n  10-14   438     303  200\n  15-19   323     251  169\n  20-29   477     367  229\n  30-49   329     238  187\n  50-69    33      38   24\n  70+       3       3    0\n  &lt;NA&gt;     32      28   26\n\n\n\nOranlar\nOranları elde etmek için yukarıdaki tabloyu prop.table() aktarın geçirin. Oranların (1) satırlardan mı, (2) sütunlardan mı yoksa tüm tablodan mı (3) olmasını istediğinizi belirtmek için margins = argümanını kullanın. Kolay anlaşılmasını sağlamak için, 2 basamak belirterek tabloyu temel R’daki round() fonksiyonuna yönlendiririz.\n\n# yukarıda tanımlanan tablo oranlarını, satırlara göre, yuvarlanmış olarak alın\nprop.table(age_by_outcome, 1) %&gt;% round(2)\n\n       \n        Death Recover &lt;NA&gt;\n  0-4    0.43    0.33 0.24\n  5-9    0.43    0.36 0.21\n  10-14  0.47    0.32 0.21\n  15-19  0.43    0.34 0.23\n  20-29  0.44    0.34 0.21\n  30-49  0.44    0.32 0.25\n  50-69  0.35    0.40 0.25\n  70+    0.50    0.50 0.00\n  &lt;NA&gt;   0.37    0.33 0.30\n\n\n\n\nToplamlar\nSatır ve sütun toplamlarını eklemek için tabloyu addmargins() fonksiyonuna iletin. Bu fonksiyon hem sayılar hem de oranlar için geçerlidir. ”\n\naddmargins(age_by_outcome)\n\n       \n        Death Recover &lt;NA&gt;  Sum\n  0-4     471     364  260 1095\n  5-9     476     391  228 1095\n  10-14   438     303  200  941\n  15-19   323     251  169  743\n  20-29   477     367  229 1073\n  30-49   329     238  187  754\n  50-69    33      38   24   95\n  70+       3       3    0    6\n  &lt;NA&gt;     32      28   26   86\n  Sum    2582    1983 1323 5888\n\n\n\n\nVeri çerçevesine dönüştürmek\nBir tablo() nesnesini doğrudan bir veri çerçevesine dönüştürmek kolay değildir. Bir yaklaşım aşağıda gösterilmiştir:\n\ntabloyu useNA = “always” değişkenini kullanmadan oluşturun. Bunun yerine forcats’tan fct_explicit_na() fonksiyonu ile NA değerlerini “(Missing)”e dönüştürün.\nToplamları (isteğe bağlı) addmargins() fonkisyonuna yönlendirerek ekleyin\nTemel R fonksiyonuna tünelleme için as.data.frame.matrix() fonksiyonunu kullanın\nİlk sütunun adını belirterek tabloyu rownames_to_column() tibble fonksiyonuna aktarın\nTabloyu istediğiniz gibi yazdırın, görüntüleyin veya dışa aktarın. Bu örnekte, Sunum için tablolar sayfasında açıklandığı gibi flextable paketinden flextable() fonksiyonu kullanılmıştır. Bu şekilde tablo RStudio görüntüleyici bölmesine HTML görüntüsü olarak yazdırılacaktır.\n\n\ntable(fct_explicit_na(linelist$age_cat), fct_explicit_na(linelist$outcome)) %&gt;% \n  addmargins() %&gt;% \n  as.data.frame.matrix() %&gt;% \n  tibble::rownames_to_column(var = \"Age Category\") %&gt;% \n  flextable::flextable()\n\nAge CategoryDeathRecover(Missing)Sum0-44713642601,0955-94763912281,09510-1443830320094115-1932325116974320-294773672291,07330-4932923818775450-693338249570+3306(Missing)32282686Sum2,5821,9831,3235,888",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Tanımlayıcı tablolar</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.tr.html#kaynaklar",
    "href": "new_pages/tables_descriptive.tr.html#kaynaklar",
    "title": "17  Tanımlayıcı tablolar",
    "section": "17.7 Kaynaklar",
    "text": "17.7 Kaynaklar\nBu sayfadaki bilgilerin çoğu şu kaynaklardan ve çevrimiçi görüntülerden uyarlanmıştır:\ngtsummary\ndplyr",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Tanımlayıcı tablolar</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.tr.html",
    "href": "new_pages/stat_tests.tr.html",
    "title": "18  Basit istatistiksel testler",
    "section": "",
    "text": "18.1 Hazırlık",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Basit istatistiksel testler</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.tr.html#hazırlık",
    "href": "new_pages/stat_tests.tr.html#hazırlık",
    "title": "18  Basit istatistiksel testler",
    "section": "",
    "text": "Paketleri yükleyin\nBu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() vurgusunu yapıyoruz. base R’dan library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakın.\n\npacman::p_load(\n  rio,          # Dosyayı içe aktarma\n  here,         # Dosyayı konumlama\n  skimr,        # Veriye göz atma\n  tidyverse,    # veri yönetimi + ggplot2 grafikleri, \n  gtsummary,    # özet istatistikler ve testler\n  rstatix,      # istatistikler\n  corrr,        # Sayısal değişkenler için Korelasyon analizi \n  janitor,      # Tablolara toplamı ve yüzdeleri ekleme\n  flextable     # Tabloları HTML formatına dönüştürme\n  )\n\n\n\nVerileri içe aktar\nSimüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Takip etmek isterseniz, “temiz” vaka listesini indirmek için tıklayınız(.rds dosyası olarak). Verilerinizi rio paketinden import() fonksiyonuyla içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakın).\n\n# Vaka listesini içe aktarma\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nVaka listesinin ilk 50 satırı aşağıda görüntülenmektedir.\n\n\n\n\n\n\nbase (temel) R {}\nİstatistiksel testler yapmak için base R fonksiyonlarını kullanabilirsiniz. Komutlar nispeten basittir ve sonuçlar basit görüntüleme için R Konsoluna yazdırılacaktır. Bununla birlikte, çıktılar genellikle listelerdir ve bu nedenle sonuçları sonraki işlemlerde kullanmak istiyorsanız manipüle edilmesi daha zordur.\n\n\nT testleri\n“Student’s t-Test” olarak da adlandırılan bir t-testi, genellikle iki grup arasındaki bazı sayısal değişkenlerin ortalamaları arasında önemli bir fark olup olmadığını belirlemek için kullanılır. Burada, sütunların aynı veri çerçevesinde olup olmadığına bağlı olarak bu testi yapmak için sözdizimini göstereceğiz.\nSözdizimi 1: Bu, sayısal ve kategorik sütunlarınız aynı veri çerçevesinde olduğundaki sözdizimidir. Denklemin sol tarafında sayısal sütunu ve sağ tarafında kategorik sütunu sağlayın. Veri kümesini data = olarak belirtin. İsteğe bağlı olarak, paired = TRUE, ve conf.level = (0.95 default), vealternative =(“iki taraflı”, “daha az” veya “daha büyük”) olarak ayarlayın. Daha fazla ayrıntı için ?t.test girin.\n\n## T-testi ile grupların yaş ortalamalarını karşılaştırma\nt.test(age_years ~ gender, data = linelist)\n\n\n    Welch Two Sample t-test\n\ndata:  age_years by gender\nt = -21.344, df = 4902.3, p-value &lt; 2.2e-16\nalternative hypothesis: true difference in means between group f and group m is not equal to 0\n95 percent confidence interval:\n -7.571920 -6.297975\nsample estimates:\nmean in group f mean in group m \n       12.60207        19.53701 \n\n\nSözdizimi 2: Bu alternatif sözdizimini kullanarak iki ayrı sayısal vektörü karşılaştırabilirsiniz. Örneğin, iki sütun farklı veri kümelerindeyse.\n\nt.test(df1$age_years, df2$age_years)\n\nÖrneklerin ortalamasının belirli bir değerden önemli ölçüde farklı olup olmadığını belirlemek için bir t testi de kullanabilirsiniz. Burada, mu = olarak bilinen/varsayımsal popülasyon ortalaması ile tek örnekli bir t-testi yapıyoruz:\n\nt.test(linelist$age_years, mu = 45)\n\n\n\nShapiro-Wilk testi\nShapiro-Wilk testi bir örneğin normal dağılıma sahip bir popülasyondan gelip gelmediğini belirlemek için kullanılabilir (diğer birçok testin varsayımı ve analizinde olduğu gibi, örneğin t-testi). Ancak, bu yalnızca 3 ila 5000 gözlem arasındaki bir örnek üzerinde kullanılabilir. Daha büyük numuneler için bir quantile-quantile (Q-Q) grafiği yardımcı olabilir.\n\nshapiro.test(linelist$age_years)\n\n\n\nWilcoxon sıralama toplamı testi\nMann–Whitney U testi olarak da adlandırılan Wilcoxon sıralama toplamı testi, genellikle iki sayısal örneğin popülasyonları normal dağılmadığında veya eşit olmayan varyansa sahip olduğunda kullanılır.\n\n## Wilcox testi ile grupların yaş dağılımını karşılaştırma\nwilcox.test(age_years ~ outcome, data = linelist)\n\n\n    Wilcoxon rank sum test with continuity correction\n\ndata:  age_years by outcome\nW = 2501868, p-value = 0.8308\nalternative hypothesis: true location shift is not equal to 0\n\n\n\n\nKruskal-Wallis testi\nKruskal-Wallis testi, ikiden fazla örneklemin dağılımdaki farklılıklarını test etmek için kullanılabilecek Wilcoxon testinin bir uzantısıdır. Yalnızca iki örnek kullanıldığında, Wilcoxon testiyle aynı sonuçları verir.\n\n## Kruskal-Wallis testi ile grupların yaş dağılımını karşılaştırma\nkruskal.test(age_years ~ outcome, linelist)\n\n\n    Kruskal-Wallis rank sum test\n\ndata:  age_years by outcome\nKruskal-Wallis chi-squared = 0.045675, df = 1, p-value = 0.8308\n\n\n\n\nKi-kare testi\nPearson Ki-kare testi kategorik gruplar arasındaki önemli farklılıkları test etmek için kullanılır.\n\n## Ki-kare testi ile her grubun oranlarını karşılaşırma\nchisq.test(linelist$gender, linelist$outcome)\n\n\n    Pearson's Chi-squared test with Yates' continuity correction\n\ndata:  linelist$gender and linelist$outcome\nX-squared = 0.0011841, df = 1, p-value = 0.9725",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Basit istatistiksel testler</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.tr.html#rstatix-paketi",
    "href": "new_pages/stat_tests.tr.html#rstatix-paketi",
    "title": "18  Basit istatistiksel testler",
    "section": "18.2 rstatix paketi",
    "text": "18.2 rstatix paketi\nrstatix paketi, istatistiksel testlerin çalıştırılmasını ve sonuçlarını “tünel dostu” bir çerçevede alma olanağı sunar. Sonuçlar üzerinde işlemleri gerçekleştirebilmeniz için sonuçlar, otomatik olarak bir veri çerçevesindedir. İstatistiklerin her grup için çalıştırılması ve fonksiyonlara geçirilen verileri gruplamak kolaydır.\n\nÖzet istatistikler\nget_summary_stats() fonksiyonu, özet istatistikleri döndürmenin hızlı bir yoludur. Veri kümenizi bu fonksiyona aktarmanız ve analiz edilecek sütunları sağlamanız yeterlidir. Hiçbir sütun belirtilmemişse, istatistikler tüm sütunlar için hesaplanır.\nVarsayılan olarak, tam bir özet istatistik aralığı döndürülür: n, maks, min, medyan, %25 ile, %75 ile, IQR, medyan mutlak sapma (mad), ortalama, standart sapma, standart hata ve güven aralığı.\n\nlinelist %&gt;%\n  rstatix::get_summary_stats(age, temp)\n\n# A tibble: 2 × 13\n  variable     n   min   max median    q1    q3   iqr    mad  mean     sd    se\n  &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 age       5802   0    84     13     6    23      17 11.9    16.1 12.6   0.166\n2 temp      5739  35.2  40.8   38.8  38.2  39.2     1  0.741  38.6  0.977 0.013\n# ℹ 1 more variable: ci &lt;dbl&gt;\n\n\ntype = için şu değerlerden birini sağlayarak döndürülecek özet istatistiklerin bir alt kümesini belirtebilirsiniz: “full”, “common”, “robust”, “five_number”, “mean_sd”, “mean_se”, “mean_ci” , “median_iqr”, “median_mad”, “quantile”, “mean”, “median”, “min”, “max”.\nHer gruplama değişkeni için bir satır döndürülecek şekilde gruplandırılmış verilerle de kullanılabilir:\n\nlinelist %&gt;%\n  group_by(hospital) %&gt;%\n  rstatix::get_summary_stats(age, temp, type = \"common\")\n\n# A tibble: 12 × 11\n   hospital     variable     n   min   max median   iqr  mean     sd    se    ci\n   &lt;chr&gt;        &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 Central Hos… age        445   0    58     12    15    15.7 12.5   0.591 1.16 \n 2 Central Hos… temp       450  35.2  40.4   38.8   1    38.5  0.964 0.045 0.089\n 3 Military Ho… age        884   0    72     14    18    16.1 12.4   0.417 0.818\n 4 Military Ho… temp       873  35.3  40.5   38.8   1    38.6  0.952 0.032 0.063\n 5 Missing      age       1441   0    76     13    17    16.0 12.9   0.339 0.665\n 6 Missing      temp      1431  35.8  40.6   38.9   1    38.6  0.97  0.026 0.05 \n 7 Other        age        873   0    69     13    17    16.0 12.5   0.422 0.828\n 8 Other        temp       862  35.7  40.8   38.8   1.1  38.5  1.01  0.034 0.067\n 9 Port Hospit… age       1739   0    68     14    18    16.3 12.7   0.305 0.598\n10 Port Hospit… temp      1713  35.5  40.6   38.8   1.1  38.6  0.981 0.024 0.046\n11 St. Mark's … age        420   0    84     12    15    15.7 12.4   0.606 1.19 \n12 St. Mark's … temp       410  35.9  40.6   38.8   1.1  38.5  0.983 0.049 0.095\n\n\nİstatistiksel testler yapmak için rstatix’i de kullanabilirsiniz:\n\n\nT-testi\nSayısal ve kategorik sütunları belirtmek için bir formül sözdizimi kullanın:\n\nlinelist %&gt;% \n  t_test(age_years ~ gender)\n\n# A tibble: 1 × 10\n  .y.   group1 group2    n1    n2 statistic    df        p    p.adj p.adj.signif\n* &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;int&gt; &lt;int&gt;     &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;       \n1 age_… f      m       2807  2803     -21.3 4902. 9.89e-97 9.89e-97 ****        \n\n\nVeya ~ 1 kullanın ve tek örnekli bir T-testi için mu = belirtin. Bu grup tarafından da yapılabilir.\n\nlinelist %&gt;% \n  t_test(age_years ~ 1, mu = 30)\n\n# A tibble: 1 × 7\n  .y.       group1 group2         n statistic    df     p\n* &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;      &lt;int&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 age_years 1      null model  5802     -84.2  5801     0\n\n\nUygulanabilirse, istatistiksel testler aşağıda gösterildiği gibi grup bazında yapılabilir:\n\nlinelist %&gt;% \n  group_by(gender) %&gt;% \n  t_test(age_years ~ 1, mu = 18)\n\n# A tibble: 3 × 8\n  gender .y.       group1 group2         n statistic    df         p\n* &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;      &lt;int&gt;     &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;\n1 f      age_years 1      null model  2807    -29.8   2806 7.52e-170\n2 m      age_years 1      null model  2803      5.70  2802 1.34e-  8\n3 &lt;NA&gt;   age_years 1      null model   192     -3.80   191 1.96e-  4\n\n\n\n\nShapiro-Wilk testi\nYukarıda belirtildiği gibi, örneklem büyüklüğü 3 ile 5000 arasında olmalıdır.\n\nlinelist %&gt;% \n  head(500) %&gt;%            # Vaka listesinin ilk 500 satırı, sadece örnek için\n  shapiro_test(age_years)\n\n# A tibble: 1 × 3\n  variable  statistic        p\n  &lt;chr&gt;         &lt;dbl&gt;    &lt;dbl&gt;\n1 age_years     0.917 6.67e-16\n\n\n\n\nWilcoxon sıralama toplamı testi\n\nlinelist %&gt;% \n  wilcox_test(age_years ~ gender)\n\n# A tibble: 1 × 9\n  .y.       group1 group2    n1    n2 statistic        p    p.adj p.adj.signif\n* &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;  &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;       \n1 age_years f      m       2807  2803   2829274 3.47e-74 3.47e-74 ****        \n\n\n\n\nKruskal-Wallis testi\nMann-Whitney U testi olarak da bilinir.\n\nlinelist %&gt;% \n  kruskal_test(age_years ~ outcome)\n\n# A tibble: 1 × 6\n  .y.           n statistic    df     p method        \n* &lt;chr&gt;     &lt;int&gt;     &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;         \n1 age_years  5888    0.0457     1 0.831 Kruskal-Wallis\n\n\n\n\nKi-kare testi\nKi-kare test fonksiyonu bir tablo kabul eder, bu nedenle önce bir çapraz tablo oluştururuz. Çapraz tablo oluşturmanın birçok yolu vardır (bkz. [Tanımlayıcı tablolar]) ancak burada janitor ‘den ’tabyl()’ kullanıyoruz ve ’chisq_test()’e geçmeden önce en soldaki değer etiketleri sütununu kaldırıyoruz.\n\nlinelist %&gt;% \n  tabyl(gender, outcome) %&gt;% \n  select(-1) %&gt;% \n  chisq_test()\n\n# A tibble: 1 × 6\n      n statistic     p    df method          p.signif\n* &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt;           &lt;chr&gt;   \n1  5888      3.53 0.473     4 Chi-square test ns      \n\n\nrstatix fonksiyonları ile daha birçok fonksiyon ve istatistiksel test çalıştırılabilir. rstatix belgelerine buradan çevrimiçi veya ?rstatix girerek inceleyebilirsiniz.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Basit istatistiksel testler</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.tr.html#stats_gt",
    "href": "new_pages/stat_tests.tr.html#stats_gt",
    "title": "18  Basit istatistiksel testler",
    "section": "18.3 gtsummary paketi",
    "text": "18.3 gtsummary paketi\nBu paketle oluşturulmuş güzel bir tabloya istatistiksel bir testin sonuçlarını eklemek istiyorsanız gtsummary kullanın (Açıklayıcı tablolar sayfasının gtsummary bölümünde açıklandığı gibi) ).\n‘tbl_summary’ ile karşılaştırmanın istatistiksel testlerinin yapılması, Bir tabloya add_p fonskiyonu ve hangi testin kullanılacağını belirtir. kullanarak çoklu test için p değerlerinin düzeltilmesi mümkündür. ‘add_q’ işlevi. Ayrıntılar için ?tbl_summary çalıştırın.\n\nKi-kare testi\nKategorik bir değişkenin oranlarını iki grupta karşılaştırın. Kategorik bir değişkene uygulandığında ‘add_p()’ için varsayılan istatistiksel test, süreklilik düzeltmeli ki-kare bağımsızlık testi yapmaktır, ancak herhangi bir beklenen değer sayısı 5’in altındaysa, o zaman Fisher’ın kesin testi kullanılır.\n\nlinelist %&gt;% \n  select(gender, outcome) %&gt;%    # ilgilenilen değişkenleri tutma\n  tbl_summary(by = outcome) %&gt;%  # özet tablo oluştur ve gruplama değişkenini belirle\n  add_p()                        # hangi testin gerçekleştirileceğini belirtin\n\n1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nDeath, N = 2,5821\nRecover, N = 1,9831\np-value2\n\n\n\n\ngender\n\n\n\n\n&gt;0.9\n\n\n    f\n1,227 (50%)\n953 (50%)\n\n\n\n\n    m\n1,228 (50%)\n950 (50%)\n\n\n\n\n    Unknown\n127\n80\n\n\n\n\n\n1 n (%)\n\n\n2 Pearson’s Chi-squared test\n\n\n\n\n\n\n\n\n\n\n\nT testleri\nİki grupta sürekli bir değişken için ortalamalardaki farkı karşılaştırın. Örneğin, ortalama yaşı hasta sonucuna göre karşılaştırın.\n\nlinelist %&gt;% \n  select(age_years, outcome) %&gt;%             # ilgilenilen değişkenleri tutma\n  tbl_summary(                               # özet tablo üretme\n    statistic = age_years ~ \"{mean} ({sd})\", # hangi istatistiklerin gösterileceğini belirtin\n    by = outcome) %&gt;%                        # gruplama değişkenini belirtin\n  add_p(age_years ~ \"t.test\")                # hangi testlerin gerçekleştirileceğini belirtin\n\n1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nDeath, N = 2,5821\nRecover, N = 1,9831\np-value2\n\n\n\n\nage_years\n16 (12)\n16 (13)\n0.6\n\n\n    Unknown\n32\n28\n\n\n\n\n\n1 Mean (SD)\n\n\n2 Welch Two Sample t-test\n\n\n\n\n\n\n\n\n\n\n\nWilcoxon sıralama toplamı testi\nSürekli bir değişkenin dağılımını iki grupta karşılaştırın. Varsayılan ayar, iki grubu karşılaştırırken Wilcoxon sıra toplamı testi ve medyanı (IQR) kullanmaktır. Ancak normal dağılmayan veriler veya çoklu grupların karşılaştırılması için Kruskal-wallis testi daha uygundur.\n\nlinelist %&gt;% \n  select(age_years, outcome) %&gt;%                       # ilgilenilen değişkenleri tutma\n  tbl_summary(                                         # özet tablo üretme\n    statistic = age_years ~ \"{median} ({p25}, {p75})\", # hangi istatistiğin gösterileceğini belirtin (bu varsayılandır, bu nedenle kaldırılabilir)\n    by = outcome) %&gt;%                                  # gruplama değişkenini belirtin\n  add_p(age_years ~ \"wilcox.test\")                     # hangi testin gerçekleştirileceğini belirtin (bu varsayılandır, bu nedenle parantezler boş bırakılabilir)\n\n1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nDeath, N = 2,5821\nRecover, N = 1,9831\np-value2\n\n\n\n\nage_years\n13 (6, 23)\n13 (6, 23)\n0.8\n\n\n    Unknown\n32\n28\n\n\n\n\n\n1 Median (IQR)\n\n\n2 Wilcoxon rank sum test\n\n\n\n\n\n\n\n\n\n\n\n18.3.1 Kruskal-wallis testi\nVerilerin normal dağılıp dağılmadığına bakılmaksızın, sürekli bir değişkenin iki veya daha fazla gruptaki dağılımını karşılaştırın.\n\nlinelist %&gt;% \n  select(age_years, outcome) %&gt;%                       # ilgilenilen değişkenleri tutma\n  tbl_summary(                                         # özet tablo üretme\n    statistic = age_years ~ \"{median} ({p25}, {p75})\", # hangi istatistiğin gösterileceğini belirtin (bu varsayılandır, bu nedenle kaldırılabilir)\n    by = outcome) %&gt;%                                  # gruplama değişkenini belirtin\n  add_p(age_years ~ \"kruskal.test\")                    # hangi testin gerçekleştirileceğini belirtin\n\n1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nDeath, N = 2,5821\nRecover, N = 1,9831\np-value2\n\n\n\n\nage_years\n13 (6, 23)\n13 (6, 23)\n0.8\n\n\n    Unknown\n32\n28\n\n\n\n\n\n1 Median (IQR)\n\n\n2 Kruskal-Wallis rank sum test",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Basit istatistiksel testler</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.tr.html#korelasyonlar",
    "href": "new_pages/stat_tests.tr.html#korelasyonlar",
    "title": "18  Basit istatistiksel testler",
    "section": "18.4 Korelasyonlar",
    "text": "18.4 Korelasyonlar\nSayısal değişkenler arasındaki korelasyon tidyverse kullanılarak araştırılabilir. corrr paketi, Pearson Kendall kullanarak korelasyonları hesaplamanıza izin verir. tau veya Spearman rho, Paket bir tablo oluşturur ve ayrıca değerleri otomatik olarak çizer.\n\ncorrelation_tab &lt;- linelist %&gt;% \n  select(generation, age, ct_blood, days_onset_hosp, wt_kg, ht_cm) %&gt;%   # ilgilenilen sayısal değişkenleri tutma\n  correlate()      # korelasyon tablosu oluşturma (varsayılan pearson kullanılarak)\n\ncorrelation_tab    # yazdır\n\n# A tibble: 6 × 7\n  term            generation      age ct_blood days_onset_hosp    wt_kg    ht_cm\n  &lt;chr&gt;                &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;           &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n1 generation        NA       -2.22e-2  0.179         -0.288    -0.0302  -0.00942\n2 age               -0.0222  NA        0.00849       -0.000635  0.833    0.877  \n3 ct_blood           0.179    8.49e-3 NA             -0.600    -0.00636  0.0181 \n4 days_onset_hosp   -0.288   -6.35e-4 -0.600         NA         0.0153  -0.00953\n5 wt_kg             -0.0302   8.33e-1 -0.00636        0.0153   NA        0.884  \n6 ht_cm             -0.00942  8.77e-1  0.0181        -0.00953   0.884   NA      \n\n## Duplike girdileri kaldırma (üstteki tablo yansıtılır) \ncorrelation_tab &lt;- correlation_tab %&gt;% \n  shave()\n\n## Korelasyon tablosunu gösterme \ncorrelation_tab\n\n# A tibble: 6 × 7\n  term            generation       age ct_blood days_onset_hosp  wt_kg ht_cm\n  &lt;chr&gt;                &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;           &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 generation        NA       NA        NA              NA       NA        NA\n2 age               -0.0222  NA        NA              NA       NA        NA\n3 ct_blood           0.179    0.00849  NA              NA       NA        NA\n4 days_onset_hosp   -0.288   -0.000635 -0.600          NA       NA        NA\n5 wt_kg             -0.0302   0.833    -0.00636         0.0153  NA        NA\n6 ht_cm             -0.00942  0.877     0.0181         -0.00953  0.884    NA\n\n## korelasyon grafikleri \nrplot(correlation_tab)",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Basit istatistiksel testler</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.tr.html#kaynaklar",
    "href": "new_pages/stat_tests.tr.html#kaynaklar",
    "title": "18  Basit istatistiksel testler",
    "section": "18.5 Kaynaklar",
    "text": "18.5 Kaynaklar\nBu sayfadaki bilgilerin çoğu şu kaynaklardan ve çevrimiçi gösterimlerden uyarlanmıştır:\ngtsummary dplyr corrr sthda correlation",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Basit istatistiksel testler</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.tr.html",
    "href": "new_pages/regression.tr.html",
    "title": "19  Tek değişkenli ve çok değişkenli regresyon",
    "section": "",
    "text": "19.1 Hazırlık",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Tek değişkenli ve çok değişkenli regresyon</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.tr.html#hazırlık",
    "href": "new_pages/regression.tr.html#hazırlık",
    "title": "19  Tek değişkenli ve çok değişkenli regresyon",
    "section": "",
    "text": "Paketleri yükleyin\nBu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() vurgusunu yapıyoruz. base R’dan library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakın.\n\npacman::p_load(\n  rio,          # Dosyayı içe aktarma\n  here,         # Dosyayı konumlama\n  tidyverse,    # veri yönetimi + ggplo2 grafikleri \n  stringr,      # metin dizelerini düzenle \n  purrr,        # düzenli bir şekilde nesneler üzerinde döngü sağlama\n  gtsummary,    # özet istatistikler ve testler\n  broom,        # regresyonlardan elde edilen sonuçları toparlama\n  lmtest,       # olasılık oranı testleri\n  parameters,   # regresyonlardan elde edilen sonuçları toparlamaya alternatif\n  see          # Forest grafiklerini görselleştirmeye alternatif\n  )\n\n\n\nVerileri içe aktar\nSimüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Takip etmek isterseniz, “clean” linelist indirmek için tıklayın (.rds dosyası olarak). Verilerinizi rio paketinden import() fonksiyonuyla içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakınız).\n\n# Vaka listesini içe aktarma\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nVaka listesinin ilk 50 satırı aşağıda görüntülenir.\n\n\n\n\n\n\n\n\nTemiz veri\n\nAçıklayıcı değişkenleri saklayın\nAçıklayıcı sütunların adlarını bir karakter vektörü olarak saklıyoruz. Buna daha sonra atıfta bulunulacaktır.\n\n## ilgilenilen değişkenleri tanımlama \nexplanatory_vars &lt;- c(\"gender\", \"fever\", \"chills\", \"cough\", \"aches\", \"vomit\")\n\n\n\n1’lere ve 0’lara dönüştür\nAşağıda, lojistik regresyon modellerinin beklentileriyle işbirliği yapmak için “evet”/“hayır”, “e”/“k” ve “ölü”/“canlı” olan açıklayıcı sütunları 1/0’a çeviriyoruz. Bunu verimli bir şekilde yapmak için, aynı anda birden çok sütunu dönüştürmek için dplyr’den ‘across()’ kullanıldı. Her sütuna uyguladığımız fonksiyon, belirtilen değerleri 1’lere ve 0’lara dönüştürmek için mantık uygulayan ‘case_while()’ (ayrıca dplyr) fonksiyonudur. Temizleme verileri ve temel işlevler sayfasındaki ‘across()’ ve ‘case_while()’ ile ilgili bölümlere bakınız\nNot: “.” aşağıdaki, ‘cross()’ tarafından işlenmekte olan sütunu temsil eder.\n\n## ikili değişkenleri 0/1'e dönüştür\nlinelist &lt;- linelist %&gt;%  \n  mutate(across(                                      \n    .cols = all_of(c(explanatory_vars, \"outcome\")),  ## listelenen her sütun ve \"sonuç\" için\n    .fns = ~case_when(                              \n      . %in% c(\"m\", \"yes\", \"Death\")   ~ 1,           ## erkek, evet ve ölü'yü 1 olarak yeniden kodla\n      . %in% c(\"f\", \"no\",  \"Recover\") ~ 0,           ## kadın, hayır ve iyileşme'yi sıfır olarak kodla\n      TRUE                            ~ NA_real_)    ## geri kalanını kayıp veri olarak kaydet\n    )\n  )\n\n\n\nEksik değerlere sahip satırları bırakın\nEksik değerleri olan satırları bırakmak için, tidyr drop_na() fonksiyonunu kullanabilirsiniz. Ancak, bunu yalnızca ilgilenilen sütunlarda değerleri eksik olan satırlar için yapmak istiyoruz.\nYapmamız gereken ilk şey, “explanatory_vars” vektörümüzün “age” sütununu içerdiğinden emin olmaktır (“age”, yalnızca ikili değişkenler için olan önceki “case_while()” işleminde bir hata üretebilirdi). Ardından, “outcome” sütununda veya “explanatory_vars” sütunlarından herhangi birinde eksik değerleri olan satırları kaldırmak için “linelist”i “drop_na()”ya yönlendiririz.\nKodu çalıştırmadan önce, ‘linelist’teki satır sayısı ’nrow(linelist)’ şeklindedir.\n\n## açıklayıcı değişkenlere age_category ekleyin \nexplanatory_vars &lt;- c(explanatory_vars, \"age_cat\")\n\n## ilgilenilen değişkenler için eksik bilgi içeren satırları bırak \nlinelist &lt;- linelist %&gt;% \n  drop_na(any_of(c(\"outcome\", explanatory_vars)))\n\n‘linelist’te’ kalan satır sayısı ‘nrow(linelist)’ şeklindedir.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Tek değişkenli ve çok değişkenli regresyon</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.tr.html#tek-değişkenli",
    "href": "new_pages/regression.tr.html#tek-değişkenli",
    "title": "19  Tek değişkenli ve çok değişkenli regresyon",
    "section": "19.2 Tek değişkenli",
    "text": "19.2 Tek değişkenli\nTıpkı Açıklayıcı tablolar sayfasında olduğu gibi, kullandığınız senaryo hangi R paketini kullanacağınızı belirleyecektir. Tek değişkenli analiz yapmak için iki seçenek sunuyoruz:\n\nSonuçları konsola hızlı bir şekilde yazdırmak için base R’da bulunan fonksiyonları kullanın. Çıktıları düzenlemek için broom paketini kullanın.\nYayına hazır çıktıları modellemek ve almak için gtsummary paketini kullanın\n\n\n\nbase R\n\nDoğrusal (Lineer) regresyon\nbase R fonskiyonu ‘lm()’, sayısal yanıt ile doğrusal bir ilişkiye sahip olduğu varsayılan açıklayıcı değişkenler arasındaki ilişkiyi değerlendirerek doğrusal regresyon gerçekleştirir.\nDenklemi, yanıt ve açıklayıcı sütun adları yaklaşık bir “~” ile ayrılmış şekilde bir formül olarak sağlayın. Ayrıca, veri kümesini data = olarak belirtin. Model sonuçlarını daha sonra kullanmak üzere bir R nesnesi olarak tanımlayın.\n\nlm_results &lt;- lm(ht_cm ~ age, data = linelist)\n\nDaha sonra katsayıları (Tahminler), P-değerini, artıkları ve diğer ölçüleri görmek için model sonuçlarında “summary()” komutunu çalıştırabilirsiniz.\n\nsummary(lm_results)\n\n\nCall:\nlm(formula = ht_cm ~ age, data = linelist)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-128.579  -15.854    1.177   15.887  175.483 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  69.9051     0.5979   116.9   &lt;2e-16 ***\nage           3.4354     0.0293   117.2   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 23.75 on 4165 degrees of freedom\nMultiple R-squared:  0.7675,    Adjusted R-squared:  0.7674 \nF-statistic: 1.375e+04 on 1 and 4165 DF,  p-value: &lt; 2.2e-16\n\n\nAlternatif olarak, broom paketindeki tidy() fonksiyonunu kullanabilirsiniz. Sonuçlar bir tabloya dönüştürülür. Sonuçlarda her yıl yaş arttıkça boy da 3.5 cm artıyor ve bu istatistiksel olarak anlamlıdır.\n\ntidy(lm_results)\n\n# A tibble: 2 × 5\n  term        estimate std.error statistic p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;\n1 (Intercept)    69.9     0.598       117.       0\n2 age             3.44    0.0293      117.       0\n\n\nDaha sonra bu regresyonu bir ggplot’a eklemek için de kullanabilirsiniz, bunu yapmak için önce broomdan ‘augment()’ fonksiyonunu kullanarak gözlemlenen veri ve uygun çizgi için noktaları tek bir veri çerçevesine çekeriz.\n\n## regresyon noktalarını ve gözlemlenen verileri tek bir veri kümesine çekin\npoints &lt;- augment(lm_results)\n\n## x ekseni olarak yaşı kullanarak verileri grafikleştirin\nggplot(points, aes(x = age)) + \n  ## boy için noktalar koyun \n  geom_point(aes(y = ht_cm)) + \n  ## regresyon çizginizi çizin \n  geom_line(aes(y = .fitted), colour = \"red\")\n\n\n\n\n\n\n\n\nAyrıca, “geom_smooth()” fonksiyonunu kullanarak ggplot’a doğrudan basit bir doğrusal regresyon eklemek de mümkündür.\n\n## verinizi bir grafiğe ekleyin \n ggplot(linelist, aes(x = age, y = ht_cm)) + \n  ## noktaları gösterin\n  geom_point() + \n  ## lineer regresyon ekleyin \n  geom_smooth(method = \"lm\", se = FALSE)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nDaha ayrıntılı öğreticiler için bu bölümün sonundaki Kaynak bölümüne bakabilirsiniz.\n\n\nLojistik regresyon\nstats paketindeki (base R’ın bir parçası) ‘glm()’ fonksiyonu, Genelleştirilmiş Doğrusal Modellere (GLM) uymak için kullanılır.\nglm(), tek değişkenli ve çok değişkenli lojistik regresyon için kullanılabilir (örneğin, Odds Ratio’ları elde etmek için). İşte temel parçalar:\n\n# glm() için değişkenler\nglm(formula, family, data, weights, subset, ...)\n\n\nformül = Model glm() için bir denklem olarak sağlanır, tilde ~ nin sağında çıktısı, solunda açıklayıcı değişkenler bulunur.\nfamily = Bu, çalıştırılacak modelin türünü belirler. Lojistik regresyon için family= \"binom\" kullanın, poisson için family = \"poisson\" kullanın. Diğer örnekler aşağıdaki tablodadır.\ndata = Veri çerçevenizi belirtin\n\nGerekirse, bağlantı işlevini family = familytype(link = \"linkfunction\")) sözdizimi aracılığıyla da belirtebilirsiniz. Diğer aileler ve ‘ağırlıklar =’ ve ‘alt küme =’ (‘?glm’) gibi isteğe bağlı bağımsız değişkenler hakkındaki belgelerde daha fazlasını okuyabilirsiniz.\n\n\n\nFamily\nVarsayılan bağlantı fonksiyonu\n\n\n\n\n\"binomial\"\n(link = \"logit\")\n\n\n\"gaussian\"\n(link = \"identity\")\n\n\n\"Gamma\"\n(link = \"inverse\")\n\n\n\"inverse.gaussian\"\n(link = \"1/mu^2\")\n\n\n\"poisson\"\n(link = \"log\")\n\n\n\"quasi\"\n(link = \"identity\", variance = \"constant\")\n\n\n\"quasibinomial\"\n(link = \"logit\")\n\n\n\"quasipoisson\"\n(link = \"log\")\n\n\n\nglm() çalıştırıldığında, sonuçların adlandırılmış bir R nesnesi olarak kaydedilmesi en yaygın yöntemdir. Ardından, aşağıda gösterildiği gibi summary() kullanarak sonuçları konsolunuza yazdırabilir veya sonuçlar üzerinde diğer işlemleri gerçekleştirebilirsiniz ( örneğin; üstünü almak gibi).\nNegatif bir binom regresyonu çalıştırmanız gerekiyorsa MASS paketini kullanabilirsiniz; “glm.nb()”, “glm()” ile aynı sözdizimini kullanır. Farklı regresyonların gözden geçirilmesi için UCLA istatistik sayfasına bakabilirsiniz.\n\n\nTek değişkenli glm()\nBu örnekte, farklı yaş kategorileri ile ölümün sonucu arasındaki ilişkiyi değerlendiriyoruz (Hazırlık bölümünde 1 olarak kodlanmıştır). Aşağıda, “age_cat” tarafından “sonucun” tek değişkenli bir modeli verilmiştir. Model çıktısını model olarak kaydedip ardından summary() ile konsola yazdırıyoruz. Sağlanan tahminlerin log oranları olduğunu ve temel seviyenin “age_cat” (“0-4”) birinci faktör seviyesi olduğunu unutmayınız.\n\nmodel &lt;- glm(outcome ~ age_cat, family = \"binomial\", data = linelist)\nsummary(model)\n\n\nCall:\nglm(formula = outcome ~ age_cat, family = \"binomial\", data = linelist)\n\nCoefficients:\n              Estimate Std. Error z value Pr(&gt;|z|)   \n(Intercept)   0.233738   0.072805   3.210  0.00133 **\nage_cat5-9   -0.062898   0.101733  -0.618  0.53640   \nage_cat10-14  0.138204   0.107186   1.289  0.19726   \nage_cat15-19 -0.005565   0.113343  -0.049  0.96084   \nage_cat20-29  0.027511   0.102133   0.269  0.78765   \nage_cat30-49  0.063764   0.113771   0.560  0.57517   \nage_cat50-69 -0.387889   0.259240  -1.496  0.13459   \nage_cat70+   -0.639203   0.915770  -0.698  0.48518   \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 5712.4  on 4166  degrees of freedom\nResidual deviance: 5705.1  on 4159  degrees of freedom\nAIC: 5721.1\n\nNumber of Fisher Scoring iterations: 4\n\n\nBelirli bir değişkenin temel seviyesini değiştirmek için, sütunun Faktör sınıfı olduğundan emin olun ve istenen seviyeyi fct_relevel() ile ilk konuma taşıyın ([Faktörler] sayfasındaki sayfaya bakabilirsiniz). Örneğin, aşağıda ‘age_cat’ sütununu alıyoruz ve değiştirilmiş veri çerçevesini ‘glm()’ içine aktarmadan önce temel olarak “20-29” ayarlıyoruz.\n\nlinelist %&gt;% \n  mutate(age_cat = fct_relevel(age_cat, \"20-29\", after = 0)) %&gt;% \n  glm(formula = outcome ~ age_cat, family = \"binomial\") %&gt;% \n  summary()\n\n\nCall:\nglm(formula = outcome ~ age_cat, family = \"binomial\", data = .)\n\nCoefficients:\n             Estimate Std. Error z value Pr(&gt;|z|)    \n(Intercept)   0.26125    0.07163   3.647 0.000265 ***\nage_cat0-4   -0.02751    0.10213  -0.269 0.787652    \nage_cat5-9   -0.09041    0.10090  -0.896 0.370220    \nage_cat10-14  0.11069    0.10639   1.040 0.298133    \nage_cat15-19 -0.03308    0.11259  -0.294 0.768934    \nage_cat30-49  0.03625    0.11302   0.321 0.748390    \nage_cat50-69 -0.41540    0.25891  -1.604 0.108625    \nage_cat70+   -0.66671    0.91568  -0.728 0.466546    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 5712.4  on 4166  degrees of freedom\nResidual deviance: 5705.1  on 4159  degrees of freedom\nAIC: 5721.1\n\nNumber of Fisher Scoring iterations: 4\n\n\n\n\nSonuçları yazdırmak\nÇoğu kullanım için, yukarıdaki çıktılarda birkaç değişiklik yapılmalıdır. broom paketindeki ‘tidy()’ fonksiyonu, model sonuçlarını sunulabilir kılmak için uygundur.\nBurada model çıktılarının bir sayım tablosuyla nasıl birleştirileceğini gösteriyoruz.\n\nModeli “tidy()” öğesine geçirerek ve “üssel = TRUE” ve “conf.int = TRUE” ayarını yaparak üslü günlük odds oranı tahminlerini ve güven aralıklarını(GA) alın.\n\n\nmodel &lt;- glm(outcome ~ age_cat, family = \"binomial\", data = linelist) %&gt;% \n  tidy(exponentiate = TRUE, conf.int = TRUE) %&gt;%        # GA'larını üret ve üstelleştir\n  mutate(across(where(is.numeric), round, digits = 2))  # tüm sayısal sütunları yuvarla\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `across(where(is.numeric), round, digits = 2)`.\nCaused by warning:\n! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\nSupply arguments directly to `.fns` through an anonymous function instead.\n\n  # Previously\n  across(a:b, mean, na.rm = TRUE)\n\n  # Now\n  across(a:b, \\(x) mean(x, na.rm = TRUE))\n\n\nÇıktı alınan tibble ‘model’ aşağıdadır:\n\n\n\n\n\n\n\nBu model sonuçlarını bir sayım tablosuyla birleştirin. Aşağıda, [Açıklayıcı tablolar] sayfasında anlatıldığı gibi, janitor’dan ‘tabyl()’ fonksiyonuyla bir sayımlar çapraz tablosunu oluşturuyoruz.\n\n\ncounts_table &lt;- linelist %&gt;% \n  janitor::tabyl(age_cat, outcome)\n\n\n\n\n\n\n\n\n\n\n\nBu “counts_table” veri çerçevesi şöyle görünür:\n\n\n\n\n\n\nŞimdi ‘counts_table’ ve ‘model’ sonuçlarını ‘bind_cols()’ (dplyr) ile yatay olarak birbirine bağlayabiliriz. bind_cols() ile iki veri çerçevesindeki satırların mükemmel şekilde hizalanması gerektiğini unutmayın. Bu kodda, bir tünel zinciri içinde bağlı olduğumuz için, tünelli nesneyi “counts_table” olarak temsil etmek için “.” kullanırız ve onu “model”e bağlarız. İşlemi bitirmek için, istenen sütunları ve sıralarını seçmek için ‘select()’ kullanırız ve son olarak 2 ondalık basamak belirtmek için tüm sayısal sütunlara base R ‘round()’ fonksiyonunu uygularız.\n\ncombined &lt;- counts_table %&gt;%           # sayım tablosuyla başla\n  bind_cols(., model) %&gt;%              # regresyonun çıktıları ile birleştir \n  select(term, 2:3, estimate,          # sütunları seç ve yeniden düzenle\n         conf.low, conf.high, p.value) %&gt;% \n  mutate(across(where(is.numeric), round, digits = 2)) ## 2 basamak şeklinde yuvarla\n\nBirleştirilmiş veri çerçevesinin nasıl göründüğü, flextable fonksiyonuyla güzel bir görüntü olarak yazdırılmıştır. [Tablolar sunum], bu tür tabloların flextable ile nasıl özelleştirileceğini veya knitr veya GT gibi çok sayıda başka paketin nasıl kullanılacağını açıklar.\n\ncombined &lt;- combined %&gt;% \n  flextable::qflextable()\n\n\n\nBirden çok tek değişkenli modeli döngüye alma\nAşağıda daha basit bir yaklaşım için glm() ve tidy() kullanan bir yöntem sunuyoruz, gtsummary bölümüne bakın.\nTek değişkenli olasılık oranları (yani birbirini kontrol etmeyen) üretmek için modelleri çeşitli maruziyet değişkenleri üzerinde çalıştırmak için aşağıdaki yaklaşımı kullanabilirsiniz. Tek değişkenli formüller oluşturmak için stringr’den str_c()’ kullanır (bkz. )ve son olarak **tidyr**'denbind_rows()ile birlikte tüm model çıktılarını daraltır. Bu yaklaşım, yineleme için **purrr** paketindenmap()` kullanır - bu araç hakkında daha fazla bilgi için [Yineleme, döngüler ve listeler] sayfasına bakın.\n\nAçıklayıcı değişkenlerin sütun adlarından oluşan bir vektör oluşturun. Bunu zaten bu sayfanın Hazırlık bölümünden ‘açıklayıcı_değişkenler’ olarak aldık.\nSolda “sonuç” ve sağda “açıklayıcı_değişkenler”den bir sütun adı ile birden çok dize formülü oluşturmak için “str_c()” kullanın. “.” noktası, “açıklayıcı_değişkenler”deki sütun adının yerini alır.\n\n\nexplanatory_vars %&gt;% str_c(\"outcome ~ \", .)\n\n[1] \"outcome ~ gender\"  \"outcome ~ fever\"   \"outcome ~ chills\" \n[4] \"outcome ~ cough\"   \"outcome ~ aches\"   \"outcome ~ vomit\"  \n[7] \"outcome ~ age_cat\"\n\n\n\nBu dizi formüllerini ‘map()’ öğesine iletin ve her girişe uygulanacak fonksiyon olarak ‘~glm()’ öğesini ayarlayın. “glm()” içinde, regresyon formülünü “as.formula(.x)” olarak ayarlayın, burada “.x”, yukarıdaki adımda tanımlanan dizi formülüyle değiştirilecektir. map(), her biri için gerilemeler çalıştırarak, dizi formüllerinin her biri üzerinde döngü yapacaktır.\nBu ilk ‘map()’ çıktıları, regresyon çıktılarına ‘tidy()’ uygulayan ikinci bir ‘map()’ komutuna iletilir.\nSon olarak, ikinci ‘map()’ çıktısı (düzenlenmiş veri çerçevelerinin bir listesi) ‘bind_rows()’ ile yoğunlaştırılır, bu da tüm tek değişkenli sonuçları içeren bir veri çerçevesiyle sonuçlanır.\n\n\nmodels &lt;- explanatory_vars %&gt;%       # ilgilenilen değişkenlerle başla\n  str_c(\"outcome ~ \", .) %&gt;%         # her değişkeni formüle birleştir (\"outcome ~ variable of interest\")\n  \n  # her tek değişkenli formülü yineleyin\n  map(                               \n    .f = ~glm(                       # formülleri birer birer glm() öğesine iletin\n      formula = as.formula(.x),      # glm() içinde, dizİ formülü .x'tir\n      family = \"binomial\",           # glm (logistic) tipini belirle\n      data = linelist)) %&gt;%          # veri kümesi\n  \n  # glm regresyon çıktılarının her birini düzenleyin\n  map(\n    .f = ~tidy(\n      .x, \n      exponentiate = TRUE,           # üstelleştirme \n      conf.int = TRUE)) %&gt;%          # güven aralığına dönme\n  \n  # regresyon çıktılarının listesini bir veri çerçevesine daralt\n  bind_rows() %&gt;% \n  \n  # tüm sayısal sütunları yuvarla\n  mutate(across(where(is.numeric), round, digits = 2))\n\nBu sefer, son nesne ‘modelleri’ daha uzundur çünkü artık birkaç tek değişkenli regresyonun birleşik sonuçlarını temsil etmektedir. Tüm “model” satırlarını görmek için tıklayın.\n\n\n\n\n\n\nDaha önce olduğu gibi, her açıklayıcı değişken için ‘vaka listesi’nden bir sayım tablosu oluşturabilir, onu ’modellere’ bağlayabilir ve güzel bir tablo yapabiliriz. Değişkenlerle başlıyoruz ve onları map() ile yineliyoruz. dplyr fonksiyonlarıyla bir sayım tablosu oluşturmayı içeren kullanıcı tanımlı bir fonksiyonu yineliyoruz. Daha sonra sonuçlar birleştirilir ve ‘modeller’ model sonuçlarıyla birleştirilir.\n\n## Her açıklayıcı değişken için\nuniv_tab_base &lt;- explanatory_vars %&gt;% \n  map(.f = \n    ~{linelist %&gt;%                ## vaka listesiyle başla\n        group_by(outcome) %&gt;%     ## veri setini çıktıya göre gruplandırma\n        count(.data[[.x]]) %&gt;%    ## ilgilenilen değişken için sayılar üret\n        pivot_wider(              ## geniş formata yayılma (çapraz tablodaki gibi)\n          names_from = outcome,\n          values_from = n) %&gt;% \n        drop_na(.data[[.x]]) %&gt;%         ## eksik olan satırları bırak\n        rename(\"variable\" = .x) %&gt;%      ## ilgili sütununun değişkenini \"değişken\" olarak değiştir\n        mutate(variable = as.character(variable))} ## karaktere dönüştürün, aksi takdirde ikili olmayan (kategorik) değişkenler faktör olarak ortaya çıkar ve birleştirilemez\n      ) %&gt;% \n  \n  ## sayım çıktılarının listesini bir veri çerçevesine daralt\n  bind_rows() %&gt;% \n  \n  ## regresyon çıktıları ile birleştirme \n  bind_cols(., models) %&gt;% \n  \n  ## yalnızca ilgilenilen sütunları tutma \n  select(term, 2:3, estimate, conf.low, conf.high, p.value) %&gt;% \n  \n  ## ondalık basamakları yuvarla\n  mutate(across(where(is.numeric), round, digits = 2))\n\nAşağıda veri çerçevesinin neye benzediği görülmektedir. Bu tablonun güzel HTML çıktısına nasıl dönüştürüleceği hakkında fikirler için [Tablolar] hakkındaki sayfaya bakın (ör. flextable ile).\n\n\n\n\n\n\n\n\n\n\ngtsummary paketi\nAşağıda gtsummary paketinden tbl_uvregression() kullanımını sunuyoruz. Tıpkı Tanımlayıcı tablolar sayfasındaki gibi, gtsummary fonksiyonları istatistikleri çalıştırmada ve profesyonel görünümlü çıktılar üretmede iyi bir iş çıkarır. Bu fonksiyon, tek değişkenli regresyon sonuçlarının bir tablosunu üretir.\n‘Vaka listesi’nden (açıklayıcı değişkenler ve sonuç değişkeni) yalnızca gerekli sütunları seçiyoruz ve bunları ’tbl_uvregression()’ içine aktarıyoruz. Veri Hazırlama bölümünde ‘açıklayıcı_değişkenler’ olarak tanımladığımız sütunların her biri üzerinde (cinsiyet, ateş, titreme, öksürük, ağrı, kusmuk ve yaş_kedi) tek değişkenli regresyon uygulayacağız.\nFonksiyonun kendi içinde, method = as glm (tırnak işaretleri olmadan), y = sonuç sütununu (outcome) sağlarız, family= binomial yoluyla, lojistik regresyonu çalıştırmak istediğimizi method.args = ile belirtiriz. Ve ona sonuçları üslü hale getirmesini söylüyoruz.\nÇıktı HTML’dir ve sayıları içermektedir.\n\nuniv_tab &lt;- linelist %&gt;% \n  dplyr::select(explanatory_vars, outcome) %&gt;% ## ilgilenilen değişkenleri seç\n\n  tbl_uvregression(                         ## tek değişkenli tablo üret\n    method = glm,                           ## çalıştırmak istediğiniz regresyonu tanımlayın (genelleştirilmiş doğrusal model)\n    y = outcome,                            ## sonuç değişkenini tanımlayın\n    method.args = list(family = binomial),  ## ne tür bir glm çalıştırmak istediğini tanımla (lojistik)\n    exponentiate = TRUE                     ## odds oranlarını üretmek için üstelleştir (logaritmik oranlar yerine)\n  )\n\n## tek değişkenli sonuç tablosunu göster \nuniv_tab\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nN\nOR1\n95% CI1\np-value\n\n\n\n\ngender\n4,167\n1.00\n0.88, 1.13\n&gt;0.9\n\n\nfever\n4,167\n1.00\n0.85, 1.17\n&gt;0.9\n\n\nchills\n4,167\n1.03\n0.89, 1.21\n0.7\n\n\ncough\n4,167\n1.15\n0.97, 1.37\n0.11\n\n\naches\n4,167\n0.93\n0.76, 1.14\n0.5\n\n\nvomit\n4,167\n1.09\n0.96, 1.23\n0.2\n\n\nage_cat\n4,167\n\n\n\n\n\n\n\n\n    0-4\n\n\n—\n—\n\n\n\n\n    5-9\n\n\n0.94\n0.77, 1.15\n0.5\n\n\n    10-14\n\n\n1.15\n0.93, 1.42\n0.2\n\n\n    15-19\n\n\n0.99\n0.80, 1.24\n&gt;0.9\n\n\n    20-29\n\n\n1.03\n0.84, 1.26\n0.8\n\n\n    30-49\n\n\n1.07\n0.85, 1.33\n0.6\n\n\n    50-69\n\n\n0.68\n0.41, 1.13\n0.13\n\n\n    70+\n\n\n0.53\n0.07, 3.20\n0.5\n\n\n\n1 OR = Odds Ratio, CI = Confidence Interval\n\n\n\n\n\n\n\n\n\nBu tablo çıktısında, metin etiketlerini ayarlamak, satırları p değerlerine göre kalınlaştırmak vb. gibi birçok değişiklik yapabilirsiniz. Öğreticilere buradan ve başka çevrimiçi yerlerden bakabilirsiniz.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Tek değişkenli ve çok değişkenli regresyon</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.tr.html#tabakalı",
    "href": "new_pages/regression.tr.html#tabakalı",
    "title": "19  Tek değişkenli ve çok değişkenli regresyon",
    "section": "19.3 Tabakalı",
    "text": "19.3 Tabakalı\nTabakalı analiz şu anda gtsummary üzerinde çalışıyor, bu sayfa zamanı gelince güncellenecektir.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Tek değişkenli ve çok değişkenli regresyon</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.tr.html#çok-değişkenli",
    "href": "new_pages/regression.tr.html#çok-değişkenli",
    "title": "19  Tek değişkenli ve çok değişkenli regresyon",
    "section": "19.4 Çok Değişkenli",
    "text": "19.4 Çok Değişkenli\nÇok değişkenli analiz için yine iki yaklaşım sunuyoruz:\n\nglm() ve tidy()\ngtsummary paketi\n\nİş akışı her biri için benzerdir ve yalnızca son tabloyu bir araya getirmenin son adımı farklıdır.\n\nÇok değişkenli yürütme\nBurada glm() kullanıyoruz ama denklemin sağ tarafına artı sembolleriyle (+) ayırarak daha fazla değişken ekliyoruz.\nModeli tüm açıklayıcı değişkenlerimizle çalıştırmak için şunu çalıştırırız:\n\nmv_reg &lt;- glm(outcome ~ gender + fever + chills + cough + aches + vomit + age_cat, family = \"binomial\", data = linelist)\n\nsummary(mv_reg)\n\n\nCall:\nglm(formula = outcome ~ gender + fever + chills + cough + aches + \n    vomit + age_cat, family = \"binomial\", data = linelist)\n\nCoefficients:\n              Estimate Std. Error z value Pr(&gt;|z|)\n(Intercept)   0.069054   0.131726   0.524    0.600\ngender        0.002448   0.065133   0.038    0.970\nfever         0.004309   0.080522   0.054    0.957\nchills        0.034112   0.078924   0.432    0.666\ncough         0.138584   0.089909   1.541    0.123\naches        -0.070705   0.104078  -0.679    0.497\nvomit         0.086098   0.062618   1.375    0.169\nage_cat5-9   -0.063562   0.101851  -0.624    0.533\nage_cat10-14  0.136372   0.107275   1.271    0.204\nage_cat15-19 -0.011074   0.113640  -0.097    0.922\nage_cat20-29  0.026552   0.102780   0.258    0.796\nage_cat30-49  0.059569   0.116402   0.512    0.609\nage_cat50-69 -0.388964   0.262384  -1.482    0.138\nage_cat70+   -0.647443   0.917375  -0.706    0.480\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 5712.4  on 4166  degrees of freedom\nResidual deviance: 5700.2  on 4153  degrees of freedom\nAIC: 5728.2\n\nNumber of Fisher Scoring iterations: 4\n\n\nİki değişken ve aralarında bir etkileşim eklemek istiyorsanız, bunları “+” yerine yıldız işareti “*” ile ayırabilirsiniz. Yalnızca etkileşimi belirtiyorsanız, bunları iki nokta üst üste : ile ayırın. Örneğin:\n\nglm(outcome ~ gender + age_cat * fever, family = \"binomial\", data = linelist)\n\nİsteğe bağlı olarak, bu kodu, önceden tanımlanmış sütun adları vektöründen yararlanmak ve str_c() kullanarak yukarıdaki komutu yeniden oluşturmak için kullanabilirsiniz. Bu, açıklayıcı değişken adlarınız değişiyorsa veya hepsini yeniden yazmak istemiyorsanız yararlı olabilir.\n\n##  ilgilenilen tüm değişkenlerle bir regresyon çalıştırın \nmv_reg &lt;- explanatory_vars %&gt;%  ## açıklayıcı sütun adlarının vektörüyle başlayın\n  str_c(collapse = \"+\") %&gt;%     ## bir artı ile ayrılmış ilgilenilen değişkenlerin tüm adlarını birleştirin\n  str_c(\"outcome ~ \", .) %&gt;%    ## formül stilinde sonuç ile ilgilenilen değişkenlerin adlarını birleştirin\n  glm(family = \"binomial\",      ## glm tipini lojistik olarak tanımlayın\n      data = linelist)          ## veri setinizi tanımlayın\n\n\nModeli oluşturma\nBelirli açıklayıcı değişkenleri içeren çeşitli modelleri kaydederek modelinizi adım adım oluşturabilirsiniz. Bu modelleri, aşağıdaki gibi lmtest paketinden lrtest() kullanarak olasılık-oran testleri ile karşılaştırabilirsiniz:\nNOT: base anova(model1, model2, test = \"Chisq) kullanılması aynı sonuçları verir \n\nmodel1 &lt;- glm(outcome ~ age_cat, family = \"binomial\", data = linelist)\nmodel2 &lt;- glm(outcome ~ age_cat + gender, family = \"binomial\", data = linelist)\n\nlmtest::lrtest(model1, model2)\n\nLikelihood ratio test\n\nModel 1: outcome ~ age_cat\nModel 2: outcome ~ age_cat + gender\n  #Df  LogLik Df Chisq Pr(&gt;Chisq)\n1   8 -2852.6                    \n2   9 -2852.6  1 2e-04     0.9883\n\n\nDiğer bir seçenek ise model nesnesini alıp stats paketinden step() fonksiyonunu uygulamaktır. Modeli oluştururken hangi değişken seçim yönünü kullanmak istediğinizi belirtin.\n\n## AIC'ye (Akaike information criterion) dayalı ileri seçimi kullanarak bir model seçin\n## yönü ayarlayarak \"geri\" veya \"her ikisini\" de yapabilirsiniz.\nfinal_mv_reg &lt;- mv_reg %&gt;%\n  step(direction = \"forward\", trace = FALSE)\n\nNetlik için R oturumunuzda bilimsel gösterimi de kapatabilirsiniz:\n\noptions(scipen=999)\n\nTek değişkenli analiz bölümünde açıklandığı gibi, log oranlarını ve GA’nı üslendirmek için model çıktısını ‘tidy()’ öğesine iletin. Son olarak, tüm sayısal sütunları iki ondalık basamağa yuvarlarız. Tüm satırları görmek için kaydırın.\n\nmv_tab_base &lt;- final_mv_reg %&gt;% \n  broom::tidy(exponentiate = TRUE, conf.int = TRUE) %&gt;%  ## düzenli veri çerçevesinin tahminlerini elde edin \n  mutate(across(where(is.numeric), round, digits = 2))          ## yuvarlama \n\nOrtaya çıkan veri çerçevesi şöyle görünür:\n\n\n\n\n\n\n\n\n\n\nTek değişkenli ve çok değişkenli birleştirme\n\ngtsummary ile birleştirme\ngtsummary paketi, tbl_regression() fonksiyonunu sağlar. Bu paket regresyondan çıktıları alan (bu durumda glm()) ve güzel bir sonuç üreten özet tablodur.\n\n## son regresyonun sonuç tablosunu göster\nmv_tab &lt;- tbl_regression(final_mv_reg, exponentiate = TRUE)\n\nTabloyu görelim:\n\nmv_tab\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nOR1\n95% CI1\np-value\n\n\n\n\ngender\n1.00\n0.88, 1.14\n&gt;0.9\n\n\nfever\n1.00\n0.86, 1.18\n&gt;0.9\n\n\nchills\n1.03\n0.89, 1.21\n0.7\n\n\ncough\n1.15\n0.96, 1.37\n0.12\n\n\naches\n0.93\n0.76, 1.14\n0.5\n\n\nvomit\n1.09\n0.96, 1.23\n0.2\n\n\nage_cat\n\n\n\n\n\n\n\n\n    0-4\n—\n—\n\n\n\n\n    5-9\n0.94\n0.77, 1.15\n0.5\n\n\n    10-14\n1.15\n0.93, 1.41\n0.2\n\n\n    15-19\n0.99\n0.79, 1.24\n&gt;0.9\n\n\n    20-29\n1.03\n0.84, 1.26\n0.8\n\n\n    30-49\n1.06\n0.85, 1.33\n0.6\n\n\n    50-69\n0.68\n0.40, 1.13\n0.14\n\n\n    70+\n0.52\n0.07, 3.19\n0.5\n\n\n\n1 OR = Odds Ratio, CI = Confidence Interval\n\n\n\n\n\n\n\n\n\ngtsummary tarafından üretilen birkaç farklı çıktı tablosunu tbl_merge() fonksiyonuyla da birleştirebilirsiniz. Şimdi çok değişkenli sonuçları, oluşturduğumuz gtsummary tek değişkenli sonuçlarla birleştiriyoruz yukarıda:\n\n## tek değişkenli sonuçlarla birleştir\ntbl_merge(\n  tbls = list(univ_tab, mv_tab),                          # birleştir\n  tab_spanner = c(\"**Univariate**\", \"**Multivariable**\")) # başlık adlarını ayarla\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nUnivariate\nMultivariable\n\n\nN\nOR1\n95% CI1\np-value\nOR1\n95% CI1\np-value\n\n\n\n\ngender\n4,167\n1.00\n0.88, 1.13\n&gt;0.9\n1.00\n0.88, 1.14\n&gt;0.9\n\n\nfever\n4,167\n1.00\n0.85, 1.17\n&gt;0.9\n1.00\n0.86, 1.18\n&gt;0.9\n\n\nchills\n4,167\n1.03\n0.89, 1.21\n0.7\n1.03\n0.89, 1.21\n0.7\n\n\ncough\n4,167\n1.15\n0.97, 1.37\n0.11\n1.15\n0.96, 1.37\n0.12\n\n\naches\n4,167\n0.93\n0.76, 1.14\n0.5\n0.93\n0.76, 1.14\n0.5\n\n\nvomit\n4,167\n1.09\n0.96, 1.23\n0.2\n1.09\n0.96, 1.23\n0.2\n\n\nage_cat\n4,167\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    0-4\n\n\n—\n—\n\n\n—\n—\n\n\n\n\n    5-9\n\n\n0.94\n0.77, 1.15\n0.5\n0.94\n0.77, 1.15\n0.5\n\n\n    10-14\n\n\n1.15\n0.93, 1.42\n0.2\n1.15\n0.93, 1.41\n0.2\n\n\n    15-19\n\n\n0.99\n0.80, 1.24\n&gt;0.9\n0.99\n0.79, 1.24\n&gt;0.9\n\n\n    20-29\n\n\n1.03\n0.84, 1.26\n0.8\n1.03\n0.84, 1.26\n0.8\n\n\n    30-49\n\n\n1.07\n0.85, 1.33\n0.6\n1.06\n0.85, 1.33\n0.6\n\n\n    50-69\n\n\n0.68\n0.41, 1.13\n0.13\n0.68\n0.40, 1.13\n0.14\n\n\n    70+\n\n\n0.53\n0.07, 3.20\n0.5\n0.52\n0.07, 3.19\n0.5\n\n\n\n1 OR = Odds Ratio, CI = Confidence Interval\n\n\n\n\n\n\n\n\n\n\n\ndplyr ile birleştirme\nglm()/tidy() tek değişkenli ve çok değişkenli çıktıları birleştirmenin alternatif bir yolu, dplyr birleştirme fonksiyonlarıdır.\n\nDaha önceki tek değişkenli sonuçları (sayıları içeren ‘univ_tab_base’) derlenmiş çok değişkenli sonuçlar ‘mv_tab_base’ ile birleştirebilirsiniz\nYalnızca istediğimiz sütunları tutmak, sıralarını belirlemek ve yeniden adlandırmak için select() kullanabilirsiniz\nDouble sınıfı olan tüm sütunlarda iki ondalık basamakla round() kullanabilirsiniz\n\n\n## tek ve çok değişkenli tabloları birleştir\nleft_join(univ_tab_base, mv_tab_base, by = \"term\") %&gt;% \n  ## sütunları seç ve yeniden isimlendir\n  select( # yeni isim =  eski isim\n    \"characteristic\" = term, \n    \"recovered\"      = \"0\", \n    \"dead\"           = \"1\", \n    \"univ_or\"        = estimate.x, \n    \"univ_ci_low\"    = conf.low.x, \n    \"univ_ci_high\"   = conf.high.x,\n    \"univ_pval\"      = p.value.x, \n    \"mv_or\"          = estimate.y, \n    \"mvv_ci_low\"     = conf.low.y, \n    \"mv_ci_high\"     = conf.high.y,\n    \"mv_pval\"        = p.value.y \n  ) %&gt;% \n  mutate(across(where(is.double), round, 2))   \n\n# A tibble: 20 × 11\n   characteristic recovered  dead univ_or univ_ci_low univ_ci_high univ_pval\n   &lt;chr&gt;              &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;     &lt;dbl&gt;\n 1 (Intercept)          909  1168    1.28        1.18         1.4       0   \n 2 gender               916  1174    1           0.88         1.13      0.97\n 3 (Intercept)          340   436    1.28        1.11         1.48      0   \n 4 fever               1485  1906    1           0.85         1.17      0.99\n 5 (Intercept)         1472  1877    1.28        1.19         1.37      0   \n 6 chills               353   465    1.03        0.89         1.21      0.68\n 7 (Intercept)          272   309    1.14        0.97         1.34      0.13\n 8 cough               1553  2033    1.15        0.97         1.37      0.11\n 9 (Intercept)         1636  2114    1.29        1.21         1.38      0   \n10 aches                189   228    0.93        0.76         1.14      0.51\n11 (Intercept)          931  1144    1.23        1.13         1.34      0   \n12 vomit                894  1198    1.09        0.96         1.23      0.17\n13 (Intercept)          338   427    1.26        1.1          1.46      0   \n14 age_cat5-9           365   433    0.94        0.77         1.15      0.54\n15 age_cat10-14         273   396    1.15        0.93         1.42      0.2 \n16 age_cat15-19         238   299    0.99        0.8          1.24      0.96\n17 age_cat20-29         345   448    1.03        0.84         1.26      0.79\n18 age_cat30-49         228   307    1.07        0.85         1.33      0.58\n19 age_cat50-69          35    30    0.68        0.41         1.13      0.13\n20 age_cat70+             3     2    0.53        0.07         3.2       0.49\n# ℹ 4 more variables: mv_or &lt;dbl&gt;, mvv_ci_low &lt;dbl&gt;, mv_ci_high &lt;dbl&gt;,\n#   mv_pval &lt;dbl&gt;",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Tek değişkenli ve çok değişkenli regresyon</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.tr.html#forest-grafiği",
    "href": "new_pages/regression.tr.html#forest-grafiği",
    "title": "19  Tek değişkenli ve çok değişkenli regresyon",
    "section": "19.5 Forest Grafiği",
    "text": "19.5 Forest Grafiği\nBu bölüm, regresyonunuzun çıktılarıyla bir grafiğin nasıl üretileceğini gösterir. İki seçenek vardır, ggplot2 kullanarak kendiniz bir grafik oluşturabilir veya easystats (birçok paket içeren bir paket) adlı bir meta paket kullanabilirsiniz.\nggplot2 çizim paketine aşina değilseniz [ggplot temelleri] sayfasına bakın.\n\n\nggplot2 paketi\nÇok değişkenli regresyon sonuçlarının öğelerini çizerek ggplot() ile bir Forest grafiği oluşturabilirsiniz. Bu “geomları” kullanarak grafiklerin katmanlarını ekleyin:\n\ngeom_point() ile tahminler\ngeom_errorbar() ile güven aralıkları\nOR(Odds Ratio)= 1’de geom_vline() ile dikey bir çizgi\n\nÇizmeden önce, y eksenindeki değişkenlerin/seviyelerin sırasını ayarlamak için forcats paketinden fct_relevel() kullanmak isteyebilirsiniz. “ggplot()”, bu yaş kategorisi değerleri için iyi çalışmayan (“30”, “5”ten önce görünür) alfa-sayısal sırada görüntüleyebilir. Daha fazla ayrıntı için [Faktörler] sayfasına bakın.\n\n## kesme değerini çok değişkenli sonuçlarınızdan kaldırın\nmv_tab_base %&gt;% \n  \n  #y ekseni boyunca görünecek seviyelerin sırasını ayarlayın\n  mutate(term = fct_relevel(\n    term,\n    \"vomit\", \"gender\", \"fever\", \"cough\", \"chills\", \"aches\",\n    \"age_cat5-9\", \"age_cat10-14\", \"age_cat15-19\", \"age_cat20-29\",\n    \"age_cat30-49\", \"age_cat50-69\", \"age_cat70+\")) %&gt;%\n  \n  # grafikten \"kesme değeri\" satırını kaldır\n  filter(term != \"(Intercept)\") %&gt;% \n  \n  ## değişkeni y eksenine göre grafikleştir, x eksenini tahmin et(OR)\n  ggplot(aes(x = estimate, y = term)) +\n  \n  ## tahminini nokta olarak göster\n  geom_point() + \n  \n  ## güven aralıkları için bir hata çubuğu ekleyin\n  geom_errorbar(aes(xmin = conf.low, xmax = conf.high)) + \n  \n  ## OR = 1'in referans için nerede olduğunu kesikli çizgi olarak göster\n  geom_vline(xintercept = 1, linetype = \"dashed\")\n\n\n\n\n\n\n\n\n\n\n\neasystats paketleri\nggplot2’nin sağladığı iyi düzeyde kontrolü istemiyorsanız, alternatif olarak easystats paketlerinin bir kombinasyonunu kullanabilirsiniz.\nparameters paketindeki ‘model_parameters()’ fonksiyonu, broom paket işlevi ‘tidy()’ ile eşdeğerdir. see paketi daha sonra bu çıktıları kabul eder ve bir “ggplot()” nesnesi olarak varsayılan bir Forest grafiği oluşturur.\n\npacman::p_load(easystats)\n \n## kesme değerini çok değişkenli sonuçlarınızdan kaldırın \nfinal_mv_reg %&gt;% \n  model_parameters(exponentiate = TRUE) %&gt;% \n  plot()",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Tek değişkenli ve çok değişkenli regresyon</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.tr.html#kaynaklar",
    "href": "new_pages/regression.tr.html#kaynaklar",
    "title": "19  Tek değişkenli ve çok değişkenli regresyon",
    "section": "19.6 Kaynaklar",
    "text": "19.6 Kaynaklar\nBu sayfanın içeriği şu kaynaklar ve çevrimiçi gösterimlerden yararlanılarak hazırlanmıştır.\nR’da Linear regression\ngtsummary\nUCLA stats sayfası\nsthda stepwise regression",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Tek değişkenli ve çok değişkenli regresyon</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.tr.html",
    "href": "new_pages/missing_data.tr.html",
    "title": "20  Eksik Veri",
    "section": "",
    "text": "20.1 Hazırlık",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Eksik Veri</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.tr.html#hazırlık",
    "href": "new_pages/missing_data.tr.html#hazırlık",
    "title": "20  Eksik Veri",
    "section": "",
    "text": "Paketleri yükleyin\nBu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() vurgusunu yapıyoruz. base R’dan library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakabilirsiniz.\n\npacman::p_load(\n  rio,           # İçe aktar/Dışa aktar\n  tidyverse,     # Veri yönetimi ve görselleştirme\n  naniar,        # Eksikliği değerlendir ve görselleştir\n  mice           # Eksik veri yerine aktarma\n)\n\n\n\nVerileri içe aktar\nSimüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Takip etmek isterseniz, “clean” satır listesi dosyasını indirmek için tıklayın  (.rds dosyası olarak). Verilerinizi rio paketinden import() fonksiyonuyla içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakabilirsiniz).\n\n# Satır listesini içe aktar\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nSatır listesinin ilk 50 satırı aşağıda görüntülenmektedir.\n\n\n\n\n\n\n\n\nİçe aktarma işleminde eksikliği dönüştürme\nVerilerinizi içe aktarırken, eksik olarak sınıflandırılması gereken değerlerin farkında olun. Örneğin, 99, 999, “Eksik”, boş hücreler (““) veya boşluklu hücreler (” “). Veri içe aktarma komutu sırasında bunları ’NA’ya (R’ın eksik veri sürümü) dönüştürebilirsiniz. Tam sözdizimi dosya türüne göre değiştiğinden, ayrıntılar için Eksik veriler ile ilgili sayfanın içe aktarılmasıyla ilgili sayfaya bakın.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Eksik Veri</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.tr.html#rda-eksik-değerler",
    "href": "new_pages/missing_data.tr.html#rda-eksik-değerler",
    "title": "20  Eksik Veri",
    "section": "20.2 R’da eksik değerler",
    "text": "20.2 R’da eksik değerler\nAşağıda, bazı bitişik değerler ve fonksiyonlarla birlikte, R’da eksikliğin sunulma ve değerlendirilme yollarını araştırıyoruz.\n\n“NA”\nR’da, eksik değerler ‘NA’ ile temsil edilir. Bunun * tırnak işaretleri olmadan * yazıldığını unutmayın. “NA” farklıdır ve sadece normal bir karakter değeridir (aynı zamanda Beatles’ın Hey Jude şarkısından bir söz).\nVerilerinizin “99” veya “Eksik” veya “Bilinmeyen” gibi eksikleri temsil etmenin başka yolları olabilir - “boş” görünen boş karakter değerini “” veya tek bir boşluk ” ” bile olabilir. Bunların farkında olun ve içe aktarma sırasında bunları ’NA’ya dönüştürün veya ‘na_if()’ ile veri temizleme sırasında yapabilirsiniz.\nVeri temizleme işleminizde, tüm ‘NA’ları “Eksik” veya ’replace_na()’ya benzer şekilde veya faktörler için ’fct_explicit_na()’ ile de değiştirmek isteyebilirsiniz.\n\n\n“NA” sürümleri\nÇoğu zaman, “NA” eksik bir değeri temsil eder ve her şey yolunda gider. Ancak, bazı durumlarda, bir nesne sınıfına (karakter, sayısal, vb.) özgü “NA”nın varyasyonları gereksinimiyle karşılaşabilirsiniz. Bu nadiren olacak, ancak bilmenizde fayda vardır. Bunun için tipik senaryo, dplyr fonksiyonu “case_while()” ile yeni bir sütun oluştururken gerçekleşmektedir. Verileri ve temel fonksiyonları temizleme sayfasında açıklandığı gibi, bu fonksiyon veri çerçevesindeki her satırı değerlendirir, satırların belirtilen mantıksal ölçütlerini (kodun sağ tarafı) karşılayıp karşılamadığını değerlendirir ve doğru yeni değerini atar ( kodun sol tarafı). Önemli olan: sağ taraftaki tüm değerler aynı sınıf olmalıdır.\n\nlinelist &lt;- linelist %&gt;% \n  \n  # \"Yaş\" sütunundan yeni \"yaş_yıl\" sütununu oluştur\n  mutate(age_years = case_when(\n    age_unit == \"years\"  ~ age,       # eğer yaş yıl şeklinde verildiyse, orijinal değeri atayın\n    age_unit == \"months\" ~ age/12,    # eğer yaş ay şeklinde verildiyse, 12'ye bölün\n    is.na(age_unit)      ~ age,       # eğer yaş birimi eksikse, yılmış gibi kabul edin\n    TRUE                 ~ NA_real_)) # diğer durumlarda kayıp veri olarak atayın\n\nSağ tarafta ‘NA’ istiyorsanız, aşağıda listelenen özel ‘NA’ seçeneklerinden birini belirtmeniz gerekebilir. Diğer sağ taraftaki değerler karakter ise, bunun yerine “Missing” kullanmayı düşünün veya aksi takdirde “NA_character_” kullanın. Hepsi sayısal ise, ‘NA_real_’ kullanın. Hepsi tarih veya mantıklıysa, ‘NA’ kullanabilirsiniz.\n\nNA - tarihler veya mantıksal DOĞRU/YANLIŞ için kullanın\nNA_character_ - karakterler için kullanın\nNA_real_ - sayısal değerler için kullanın\n\nYine, yeni bir sütun oluşturmak için case_while() kullanmıyorsanız bu varyasyonlarla karşılaşmanız pek olası değildir. Daha fazla bilgi için NA ile ilgili R belgelerine bakabilirsiniz.\n\n\n‘NULL’\n‘NULL’, R’dan ayrılmış başka bir değerdir. Bu, ne doğru ne de yanlış olan bir ifadenin mantıksal temsilidir. Değerleri tanımsız olan ifadeler veya fonksiyonlar tarafından döndürülür. Belirli senaryolarda “NULL” döndürmek için fonksiyon yazmadıkça veya belki de [shiny uygulaması][Shiny Panoları] yazmadıkça NULL değerini genellikle bir değer olarak atamayın.\nBoşluk is.null() kullanılarak değerlendirilebilir ve as.null() ile dönüşüm yapılabilir.\n“NULL” ve “NA” arasındaki farkla ilgili bu blog gönderisine bakabilirsiniz.\n\n\nNaN\nİmkansız değerler “NaN” özel değeri ile temsil edilir. Bunun bir örneği, R’ı 0’ı 0’a bölmeye zorlamanızdır. Bunu is.nan() ile değerlendirebilirsiniz. “is.infinite()” ve “is.finite()” gibi tamamlayıcı fonksiyonlarla da karşılaşabilirsiniz.\n\n\n“Inf”\n“Inf”, örneğin bir sayıyı 0’a böldüğünüzde olduğu gibi sonsuz bir değeri temsil eder.\nBunun işinizi nasıl etkileyebileceğine dair bir örnek olarak: Diyelim ki şu değerleri içeren bir “z” vektörünüz/sütununuz var: “z &lt;- c(1, 22, NA, Inf, NaN, 5)”\nEn yüksek değeri bulmak için sütunda ‘max()’ kullanmak istiyorsanız, ‘NA’yı hesaplamadan çıkarmak için ’na.rm = TRUE’yu kullanabilirsiniz, ancak ’Inf’ ve ‘NaN’ arta kalacak ve Inf döndürülecektir. Bunu çözmek için, hesaplamada yalnızca sonlu değerlerin kullanılacağı şekilde alt kümeler için “[ ]” ve “is.finite()” köşeli parantezlerini kullanabilirsiniz: “max(z[is.finite(z)])”.\n\nz &lt;- c(1, 22, NA, Inf, NaN, 5)\nmax(z)                           # NA'ya döner\nmax(z, na.rm=T)                  # Inf'ye döner\nmax(z[is.finite(z)])             # 22'ye döner\n\n\n\nÖrnekler\n\n\n\n\n\n\n\nR Komutları\nÇıktısı\n\n\n\n\n5 / 0\nInf\n\n\n0 / 0\nNaN\n\n\n5 / NA\nNA\n\n\n5 / Inf |0NA - 5|NAInf / 5|Infclass(NA)| \"logical\"class(NaN)| \"numeric\"class(Inf)| \"numeric\"class(NULL)`\n“NULL”\n\n\n\n“Zorlamanın getirdiği NA’lar” yaygın bir uyarı mesajıdır. Bu, aksi takdirde sayısal olan bir vektöre karakter değeri eklemek gibi geçersiz bir dönüştürme yapmaya çalışırsanız olabilir.\n\nas.numeric(c(\"10\", \"20\", \"thirty\", \"40\"))\n\nWarning: NAs introduced by coercion\n\n\n[1] 10 20 NA 40\n\n\nBir vektörde “NULL” yok sayılır.\n\nmy_vector &lt;- c(25, NA, 10, NULL)  # tanımla\nmy_vector                         # yazdır\n\n[1] 25 NA 10\n\n\nBir sayının varyansı “NA” ile sonuçlanır.\n\nvar(22)\n\n[1] NA",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Eksik Veri</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.tr.html#faydalı-fonksiyonları",
    "href": "new_pages/missing_data.tr.html#faydalı-fonksiyonları",
    "title": "20  Eksik Veri",
    "section": "20.3 Faydalı fonksiyonları",
    "text": "20.3 Faydalı fonksiyonları\nAşağıdakiler, eksik değerleri değerlendirirken veya işlerken yararlı base R fonksiyonlarıdır:\n\nis.na() ve !is.na()\nEksik değerleri belirlemek için is.na() kullanın veya eksik olmayan değerleri belirlemek için tersini (önde ! ile) kullanın. Bunların her ikisi de mantıksal bir değer (“DOĞRU” veya “YANLIŞ”) döndürür. ‘DOĞRU’ sayısını saymak için elde edilen vektörü ‘sum()’ ile toplayabileceğinizi unutmayın, ör. sum(is.na(linelist$date_outcome)).\n\nmy_vector &lt;- c(1, 4, 56, NA, 5, NA, 22)\nis.na(my_vector)\n\n[1] FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE\n\n!is.na(my_vector)\n\n[1]  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\n\nsum(is.na(my_vector))\n\n[1] 2\n\n\n\n\nna.omit()\nBu fonksiyon, bir veri çerçevesine uygulanırsa, herhangi bir eksik değere sahip satırları kaldıracaktır. Aynı zamanda base R’dandır. Bir vektöre uygulanırsa, uygulandığı vektörden ‘NA’ değerlerini kaldıracaktır. Örneğin:\n\nna.omit(my_vector)\n\n[1]  1  4 56  5 22\nattr(,\"na.action\")\n[1] 4 6\nattr(,\"class\")\n[1] \"omit\"\n\n\n\n\ndrop_na()\nBu, [veri temizleme ardışık düzeninde][Verileri ve temel fonksiyonları temizleme] yararlı olan bir tidyr fonksiyonudur. Parantezler boş olarak çalıştırılırsa, herhangi bir eksik değeri olan satırları kaldırır. Sütun adları parantez içinde belirtilirse, bu sütunlarda eksik değerlere sahip satırlar atlanır. Sütunları belirtmek için “tidyselect” sözdizimini de kullanabilirsiniz.\n\nlinelist %&gt;% \n  drop_na(case_id, date_onset, age) # bu sütunlardan herhangi biri için satır eksik değerleri bırakır\n\n\n\nna.rm = DOĞRU\n‘max()’, ‘min()’, ‘sum()’ veya ‘mean()’ gibi bir matematiksel işlevi çalıştırdığınızda, herhangi bir ‘NA’ değeri mevcutsa, döndürülen değer ‘NA’ olacaktır. Bu varsayılan davranış kasıtlıdır, böylece verilerinizden herhangi biri eksikse uyarılırsınız.\nHesaplamadan eksik değerleri kaldırarak bunu önleyebilirsiniz. Bunu yapmak için “na.rm = TRUE” bağımsız değişkenini ekleyin (“na.rm”, “NA”yı kaldır” anlamına gelir).\n\nmy_vector &lt;- c(1, 4, 56, NA, 5, NA, 22)\n\nmean(my_vector)     \n\n[1] NA\n\nmean(my_vector, na.rm = TRUE)\n\n[1] 17.6",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Eksik Veri</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.tr.html#bir-veri-çerçevesindeki-eksikliği-değerlendir",
    "href": "new_pages/missing_data.tr.html#bir-veri-çerçevesindeki-eksikliği-değerlendir",
    "title": "20  Eksik Veri",
    "section": "20.4 Bir veri çerçevesindeki eksikliği değerlendir",
    "text": "20.4 Bir veri çerçevesindeki eksikliği değerlendir\nnaniar paketini, “linelist” veri çerçevesindeki eksiklikleri değerlendirmek ve görselleştirmek için kullanabilirsiniz.\n\n# paketi kurun ve/veya yükleyin\npacman::p_load(naniar)\n\n\nEksikliği ölçme\nEksik olan tüm değerlerin yüzdesini bulmak için pct_miss() kullanın. Eksik değerlerin sayısını almak için n_miss() kullanın.\n\n# eksik TÜM veri çerçevesi değerlerinin yüzdesi\npct_miss(linelist)\n\n[1] 6.688745\n\n\nAşağıdaki iki fonksiyon, sırasıyla herhangi bir eksik değere sahip veya tamamen tamamlanmış satırların yüzdesini döndürür. “NA”nın eksik anlamına geldiğini ve `\"\" veya \" \" eksik olarak sayılamayacağını unutmayın.\n\n# Herhangi bir değeri eksik olan satırların yüzdesi\npct_miss_case(linelist)   # sayımlar için n_complete() kullanın\n\n[1] 69.12364\n\n\n\n# Tamamlanan satırların yüzdesi (eksik değer yok)  \npct_complete_case(linelist) # sayımlar için n_complete() kullanın\n\n[1] 30.87636\n\n\n\n\nEksikliği görselleştirme\ngg_miss_var() fonksiyonu size her sütundaki eksik değerlerin sayısını (veya %) gösterecektir. Birkaç nüans:\n\nGruplara göre grafiği görmek için facet = değişkenlerine bir sütun adı (tırnak içinde değil) ekleyebilirsiniz.\nVarsayılan olarak, yüzdeler yerine sayılar gösterilir, bunu show_pct = TRUE ile değiştirin\n+ labs(...) ile normal bir ggplot() için olduğu gibi eksen ve başlık etiketleri ekleyebilirsiniz.\n\n\ngg_miss_var(linelist, show_pct = TRUE)\n\n\n\n\n\n\n\n\nBurada veriler fonksiyona %&gt;% yoluyla tünellenerek iletilir. facet = değişkeni ayrıca verileri bölmek için kullanılır.\n\nlinelist %&gt;% \n  gg_miss_var(show_pct = TRUE, facet = outcome)\n\n\n\n\n\n\n\n\nVeri çerçevesini her bir değerin eksik olup olmadığını gösteren bir ısı haritası olarak görselleştirmek için vis_miss()‘i kullanabilirsiniz. Ayrıca veri çerçevesinden belirli sütunları ’select()’ ile seçerek, yalnızca bu sütunların gösterilmesini sağlayabilirsiniz.\n\n# Tüm veri çerçevesindeki eksikliğin ısı grafiği  \nvis_miss(linelist)\n\n\n\n\n\n\n\n\n\n\nEksiklik ilişkilerini keşfedin ve görselleştirin\nOlmayan bir şeyi nasıl görselleştirirsiniz??? Varsayılan olarak, “ggplot()” grafiklerden eksik değerlere sahip noktaları kaldırır.\nnaniar, geom_miss_point() aracılığıyla bir çözüm sunar. İki sütunlu bir dağılım grafiği oluştururken, değerlerden biri eksik, diğeri mevcut olan kayıtlar, eksik değerler sütundaki en düşük değerden %10 daha düşük olarak ayarlanarak ve belirgin bir şekilde renklendirilerek gösterilir.\nAşağıdaki dağılım grafiğinde kırmızı noktalar, bir sütunun değerinin mevcut olduğu ancak diğer sütunun değerinin eksik olduğu kayıtlardır. Bu, eksik değerlerin eksik olmayan değerlere göre dağılımını görmenizi sağlar.\n\nggplot(\n  data = linelist,\n  mapping = aes(x = age_years, y = temp)) +     \n  geom_miss_point()\n\n\n\n\n\n\n\n\nVeri çerçevesindeki başka bir sütun tarafından katmanlandırılmış eksiklikleri değerlendirmek için, veri çerçevesindeki bir yüzdelik ısı haritasını bir faktör/kategorik (veya tarih) sütun ile döndüren ‘gg_miss_fct()’ fonksiyonu ile sağlayın:\n\ngg_miss_fct(linelist, age_cat5)\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `age_cat5 = (function (x) ...`.\nCaused by warning:\n! `fct_explicit_na()` was deprecated in forcats 1.0.0.\nℹ Please use `fct_na_value_to_level()` instead.\nℹ The deprecated feature was likely used in the naniar package.\n  Please report the issue at &lt;https://github.com/njtierney/naniar/issues&gt;.\n\n\n\n\n\n\n\n\n\nBu fonksiyon, eksiklerin zaman içinde nasıl değiştiğini görmek için bir tarih sütunu ile de kullanılabilir:\n\ngg_miss_fct(linelist, date_onset)\n\nWarning: Removed 29 rows containing missing values or values outside the scale range\n(`geom_tile()`).\n\n\n\n\n\n\n\n\n\n\n\n“Gölge” sütunları\nBir sütundaki eksikliği ikinci bir sütundaki değerlere göre görselleştirmenin başka bir yolu da naniar’ın oluşturabileceği “gölgeyi” kullanmaktır. bind_shadow() mevcut her sütun için bir ikili NA/`NA değil` sütunu oluşturur ve tüm bu yeni sütunları “_NA” ekiyle orijinal veri kümesine bağlar. Bu, sütun sayısını iki katına çıkarır - aşağıda göreceğiniz üzere:\n\nshadowed_linelist &lt;- linelist %&gt;% \n  bind_shadow()\n\nnames(shadowed_linelist)\n\n [1] \"case_id\"                 \"generation\"             \n [3] \"date_infection\"          \"date_onset\"             \n [5] \"date_hospitalisation\"    \"date_outcome\"           \n [7] \"outcome\"                 \"gender\"                 \n [9] \"age\"                     \"age_unit\"               \n[11] \"age_years\"               \"age_cat\"                \n[13] \"age_cat5\"                \"hospital\"               \n[15] \"lon\"                     \"lat\"                    \n[17] \"infector\"                \"source\"                 \n[19] \"wt_kg\"                   \"ht_cm\"                  \n[21] \"ct_blood\"                \"fever\"                  \n[23] \"chills\"                  \"cough\"                  \n[25] \"aches\"                   \"vomit\"                  \n[27] \"temp\"                    \"time_admission\"         \n[29] \"bmi\"                     \"days_onset_hosp\"        \n[31] \"case_id_NA\"              \"generation_NA\"          \n[33] \"date_infection_NA\"       \"date_onset_NA\"          \n[35] \"date_hospitalisation_NA\" \"date_outcome_NA\"        \n[37] \"outcome_NA\"              \"gender_NA\"              \n[39] \"age_NA\"                  \"age_unit_NA\"            \n[41] \"age_years_NA\"            \"age_cat_NA\"             \n[43] \"age_cat5_NA\"             \"hospital_NA\"            \n[45] \"lon_NA\"                  \"lat_NA\"                 \n[47] \"infector_NA\"             \"source_NA\"              \n[49] \"wt_kg_NA\"                \"ht_cm_NA\"               \n[51] \"ct_blood_NA\"             \"fever_NA\"               \n[53] \"chills_NA\"               \"cough_NA\"               \n[55] \"aches_NA\"                \"vomit_NA\"               \n[57] \"temp_NA\"                 \"time_admission_NA\"      \n[59] \"bmi_NA\"                  \"days_onset_hosp_NA\"     \n\n\nBu “gölge” sütunlar, eksik değerlerin oranını başka bir sütuna göre çizmek için kullanılabilir.\nÖrneğin, aşağıdaki grafik, “days_onset_hosp” (semptom başlangıcından hastaneye yatışa kadar geçen gün sayısı) eksik kayıtların oranını, bu kaydın “tarih_hastaneye yatış” değerine göre gösterir. Esasen, x ekseni sütununun yoğunluğunu çiziyorsunuz, ancak sonuçları (‘renk =’) ilgilenilen bir gölge sütunu ile katmanlıyorsunuz. Bu analiz, x ekseni bir sayısal veya tarih sütunuysa en iyi sonucu verir.\n\nggplot(data = shadowed_linelist,          # gölge sütunlu veri çerçevesi\n  mapping = aes(x = date_hospitalisation, # sayısal veya tarih sütunu\n                colour = age_years_NA)) + # ilgi alanı gölge sütunu\n  geom_density()                          # yoğunluk eğrilerini çizme\n\n\n\n\n\n\n\n\nBu “gölge” sütunları, aşağıda gösterildiği gibi istatistiksel bir özet oluşturmak için de kullanabilirsiniz:\n\nlinelist %&gt;%\n  bind_shadow() %&gt;%                # gösteri sütunlarını oluştur\n  group_by(date_outcome_NA) %&gt;%    # katmanlama için gölge sütunları\n  summarise(across(\n    .cols = age_years,             # hesaplamalar için ilgilenilen değişken\n    .fns = list(\"mean\" = mean,     # hesaplanacak istatistikler\n                \"sd\" = sd,\n                \"var\" = var,\n                \"min\" = min,\n                \"max\" = max),  \n    na.rm = TRUE))                 # stat hesaplamaları için diğer değişkenler\n\nWarning: There was 1 warning in `summarise()`.\nℹ In argument: `across(...)`.\nℹ In group 1: `date_outcome_NA = !NA`.\nCaused by warning:\n! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\nSupply arguments directly to `.fns` through an anonymous function instead.\n\n  # Previously\n  across(a:b, mean, na.rm = TRUE)\n\n  # Now\n  across(a:b, \\(x) mean(x, na.rm = TRUE))\n\n\n# A tibble: 2 × 6\n  date_outcome_NA age_years_mean age_years_sd age_years_var age_years_min\n  &lt;fct&gt;                    &lt;dbl&gt;        &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n1 !NA                       16.0         12.6          158.             0\n2 NA                        16.2         12.9          167.             0\n# ℹ 1 more variable: age_years_max &lt;dbl&gt;\n\n\nBir sütunun zaman içinde eksik olan değerlerinin oranını çizmenin alternatif bir yolu aşağıda gösterilmiştir. naniar içermez. Bu örnek, eksik olan haftalık gözlemlerin yüzdesini gösterir.\n\nVerileri, gözlemlerin oranını “NA” (ve diğer ilgili değerler) ile özetleyerek yararlı bir zaman biriminde (günler, haftalar vb.) toplayın.\nEksik oranı ggplot() kullanarak bir çizgi olarak çizin.\n\nAşağıda, satır listesini alıyoruz, hafta için yeni bir sütun ekliyoruz, verileri haftaya göre gruplandırıyoruz ve ardından değerin eksik olduğu o haftanın kayıtlarının yüzdesini hesaplıyoruz. (not: 7 günün yüzdesini istiyorsanız, hesaplama biraz farklı olacaktır).\n\noutcome_missing &lt;- linelist %&gt;%\n  mutate(week = lubridate::floor_date(date_onset, \"week\")) %&gt;%   # yeni hafta sütunu oluşturun\n  group_by(week) %&gt;%                                             # satırları haftaya göre gruplayın\n  summarise(                                                     # her haftayı özetleyin\n    n_obs = n(),                                                  # kayıtların sayısı\n    \n    outcome_missing = sum(is.na(outcome) | outcome == \"\"),        # değeri eksik olan kayıt sayısı\n    outcome_p_miss  = outcome_missing / n_obs,                    # değeri eksik kayıtların oranı\n  \n    outcome_dead    = sum(outcome == \"Death\", na.rm=T),           # ölü olarak kayıt sayısı\n    outcome_p_dead  = outcome_dead / n_obs) %&gt;%                   # ölü olarak kayıtların oranı\n  \n  tidyr::pivot_longer(-week, names_to = \"statistic\") %&gt;%         # hafta dışındaki tüm sütunları ggplot için uzun biçime döndür\n  filter(stringr::str_detect(statistic, \"_p_\"))                  # sadece orantı değerlerini tut\n\nSonra eksik oranı haftaya göre bir çizgi olarak çizeriz. ggplot2 çizim paketine aşina değilseniz [ggplot temelleri] sayfasına bakabilirsiniz.\n\nggplot(data = outcome_missing)+\n    geom_line(\n      mapping = aes(x = week, y = value, group = statistic, color = statistic),\n      size = 2,\n      stat = \"identity\")+\n    labs(title = \"Weekly outcomes\",\n         x = \"Week\",\n         y = \"Proportion of weekly records\") + \n     scale_color_discrete(\n       name = \"\",\n       labels = c(\"Died\", \"Missing outcome\"))+\n    scale_y_continuous(breaks = c(seq(0,1,0.1)))+\n  theme_minimal()+\n  theme(legend.position = \"bottom\")",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Eksik Veri</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.tr.html#eksik-değerlere-sahip-verileri-kullanma",
    "href": "new_pages/missing_data.tr.html#eksik-değerlere-sahip-verileri-kullanma",
    "title": "20  Eksik Veri",
    "section": "20.5 Eksik değerlere sahip verileri kullanma",
    "text": "20.5 Eksik değerlere sahip verileri kullanma\n\nEksik değerlere sahip satırları filtreleyin\nEksik değerlere sahip satırları hızla kaldırmak için dplyr drop_na() fonksiyonunu kullanın.\nOrijinal ‘linelist’, ‘nrow(linelist)’ satırlarına sahiptir. Ayarlanan satır sayısı aşağıda gösterilmiştir:\n\nlinelist %&gt;% \n  drop_na() %&gt;%     # HERHANGİ eksik değerleri olan satırları kaldırın\n  nrow()\n\n[1] 1818\n\n\nBelirli sütunlarda eksik olan satırların bırakılmasını belirtebilirsiniz:\n\nlinelist %&gt;% \n  drop_na(date_onset) %&gt;% # date_onset eksik satırları kaldırın\n  nrow()\n\n[1] 5632\n\n\nSütunları arka arkaya listeleyebilir veya “tidyselect” yardımcı işlevlerini kullanabilirsiniz:\n\nlinelist %&gt;% \n  drop_na(contains(\"date\")) %&gt;% # herhangi bir \"tarih\" sütununda satır eksik değerleri kaldırın \n  nrow()\n\n[1] 3029\n\n\n\n\n\nggplot() içindeki NAyı işleme\nBir başlıktaki bir çizimden hariç tutulan değerlerin sayısını bildirmek genellikle akıllıca olur. Aşağıda bir örnek verilmiştir:\n‘ggplot()’ içinde, ‘labs()’ ve içine bir ‘caption =’ ekleyebilirsiniz. Altyazıda, değerleri bir cümleye dinamik olarak yapıştırmak için stringr paketinden str_glue() kullanabilirsiniz, böylece verilere uyum sağlarlar. Bir örnek aşağıdadır:\n\nYeni bir satır için \\n kullanımına dikkat edin.\nBirden fazla sütun, çizilmeyen değerlere katkıda bulunacaksa (örneğin, çizimde yaş veya cinsiyet yansıtılıyorsa), gösterilmeyen sayıyı doğru bir şekilde hesaplamak için bu sütunları da filtrelemeniz gerektiğini unutmayın.\n\n\nlabs(\n  title = \"\",\n  y = \"\",\n  x = \"\",\n  caption  = stringr::str_glue(\n  \"n = {nrow(central_data)} from Central Hospital;\n  {nrow(central_data %&gt;% filter(is.na(date_onset)))} cases missing date of onset and not shown.\"))  \n\nBazen, “ggplot()” komutundan önceki komutlarda dizeyi bir nesne olarak kaydetmek ve “str_glue()” içindeki adlandırılmış dize nesnesine başvurmak daha kolay olabilir.\n\n\n\nFaktörlerde “NA”\nİlgilendiğiniz sütun bir faktörse, “NA” değerlerini bir karakter değerine dönüştürmek için forcats paketinden “fct_explicit_na()” kullanın. [Faktörler] sayfasında daha fazla ayrıntıya bakabilirsiniz. Varsayılan olarak, yeni değer “(Eksik)” şeklindedir ancak bu, na_level = değişkeni ile ayarlanabilir.\n\npacman::p_load(forcats)   # paketi yükle\n\nlinelist &lt;- linelist %&gt;% \n  mutate(gender = fct_explicit_na(gender, na_level = \"Missing\"))\n\nlevels(linelist$gender)\n\n[1] \"f\"       \"m\"       \"Missing\"",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Eksik Veri</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.tr.html#atama",
    "href": "new_pages/missing_data.tr.html#atama",
    "title": "20  Eksik Veri",
    "section": "20.6 Atama",
    "text": "20.6 Atama\nBazen, verilerinizi analiz ederken, “boşlukları doldurmak” ve eksik verileri eklemek önemli olabilir. Tüm eksik değerleri çıkardıktan sonra bir veri kümesini her zaman basitçe analiz edebilirsiniz. Ancak bu, birçok yönden sorunlara neden olabilir. İşte iki örnek:\n\nEksik değerlere sahip tüm gözlemleri veya büyük miktarda eksik veriye sahip değişkenleri kaldırarak, bazı analiz türlerini yapma gücünüzü veya yeteneğinizi azaltabilirsiniz. Örneğin, daha önce keşfettiğimiz gibi, linelist veri kümemizdeki gözlemlerin yalnızca küçük bir kısmında tüm değişkenlerimizde eksik veri yoktur. Veri setimizin çoğunu kaldırırsak, çok fazla bilgi kaybederiz! Ve değişkenlerimizin çoğunda bir miktar eksik veri var - çoğu analiz için çok fazla verisi olan her değişkeni bırakmak da muhtemelen makul değildir.\nVerilerinizin neden eksik olduğuna bağlı olarak, yalnızca eksik olmayan verilerin analizi yanlı veya yanıltıcı sonuçlara yol açabilir. Örneğin, daha önce öğrendiğimiz gibi, bazı hastaların ateş veya öksürük gibi bazı önemli semptomları olup olmadığına ilişkin verileri kaçırıyor olabiliriz. Ancak, bir olasılık olarak, belki de bu bilgi çok hasta olmayan insanlar için kaydedilmemiştir. Bu durumda, bu gözlemleri kaldırmış olsaydık, veri kümemizdeki en sağlıklı insanlardan bazılarını hariç tutmuş olurduk ve bu gerçekten herhangi bir sonucu saptırabilirdi.\n\nNe kadarının eksik olduğunu görmenin yanı sıra verilerinizin neden eksik olabileceğini düşünmek de önemlidir. Bunu yapmak, eksik verileri yüklemenin ne kadar önemli olabileceğine ve ayrıca sizin durumunuzda hangi eksik verileri yükleme yönteminin en iyi olabileceğine karar vermenize yardımcı olabilir.\n\nEksik veri türleri\nİşte üç genel eksik veri türü:\n\nRastgele Tamamen Eksik (MCAR). Bu, verilerin eksik olma olasılığı ile verilerinizdeki diğer değişkenlerden herhangi biri arasında bir ilişki olmadığı anlamına gelir. Eksik olma olasılığı tüm durumlarda aynıdır. Bu nadir görülen bir durumdur. Ancak, verilerinizin MCAR olduğuna inanmak için güçlü bir nedeniniz varsa, yalnızca eksik olmayan verileri empoze etmeden analiz ediyorsa, sonuçlarınızı etkilemeyecektir (ancak biraz güç kaybedebilirsiniz). [TODO: MCAR için istatistiksel testleri tartışmayı düşünün]\nRastgele Eksik (MAR). Bu isim aslında biraz yanıltıcıdır, çünkü MAR, sahip olduğunuz diğer bilgilere dayanarak verilerinizin sistematik, öngörülebilir bir şekilde eksik olduğu anlamına gelir. Örneğin, belki de veri setimizde eksik bir ateş değeri olan her gözlem aslında kaydedilmemiştir çünkü üşüyen ve ağrıyan her hastanın sadece ateşi olduğu varsayıldığından ateşleri hiç ölçülmemiştir. Eğer doğruysa, titreme ve ağrılı her eksik gözlemin de bir ateşi olduğunu kolayca tahmin edebilir ve bu bilgiyi eksik verilerimizi değerlendirmek için kullanabiliriz. Uygulamada, bu daha çok bir spektrumdur. Belki bir hastada hem üşüme hem de ağrı varsa, ateşi ölçülmediyse de ateşi olma olasılığı daha yüksekti, ama her zaman değil. Mükemmel bir şekilde öngörülebilir olmasa bile yine de öngörülebilir. Yaygın bir eksik veri türüdür.\nRastgele Eksik Değil (MNAR veya NMAR). Bu, bir değerin eksik olma olasılığının sistematik OLMADIĞINI veya sahip olduğumuz diğer bilgiler kullanılarak öngörülebilir olmadığını, ancak rastgele olarak da eksik olmadığını varsayar. Bu durumda, bilinmeyen veya hakkında bilgi sahibi olmadığınız nedenlerden dolayı veriler eksiktir. Örneğin, veri setimizde yaşla ilgili bilgiler eksik olabilir, çünkü bazı çok yaşlı hastalar kaç yaşında olduklarını ya bilmiyorlar ya da söylemeyi reddediyorlardır. Bu durumda, yaşa ilişkin eksik veriler, değerin kendisiyle ilgilidir (ve dolayısıyla rastgele değildir) ve sahip olduğumuz diğer bilgilere dayanarak tahmin edilebilir değildir. MNAR karmaşıktır ve çoğu zaman bununla başa çıkmanın en iyi yolu, verilerin neden eksik olduğu hakkında daha fazla veri veya bilgi toplamaya çalışmaktır.\n\nGenel olarak, MCAR verilerini empoze etmek genellikle oldukça basittir, MNAR ise imkansız değilse de çok zordur. Yaygın veri atama yöntemlerinin çoğu MAR’ı varsayar.\n\n\nFaydalı paketler\nEksik verileri yüklemek için bazı yararlı paketler Mmisc, missForest (eksik verileri yüklemek için rastgele forestları kullanır) ve MICE’dir (Multivariate Imputation by Chained Equations- Zincirli Denklemlerle Çok Değişkenli Tahminleme). Bu bölüm için sadece çeşitli teknikleri uygulayan MICE paketini kullanacağız. MICE paketi üreticisi, burada daha fazla ayrıntıya giren eksik verilerin empoze edilmesi hakkında bir çevrimiçi kitap yayınlamıştır (https://stefvanbuuren.name/fimd/).\nFare paketini yüklemek için kod:\n\npacman::p_load(mice)\n\n\n\nOrtalama Atama\nBazen basit bir analiz yapıyorsanız veya MCAR’ı varsayabileceğinizi düşünmek için güçlü bir nedeniniz varsa, eksik sayısal değerleri o değişkenin ortalamasına kolayca ayarlayabilirsiniz. Belki de veri setimizde eksik olan sıcaklık ölçümlerinin ya MCAR olduğunu ya da sadece normal değerler olduğunu varsayabiliriz. Veri kümemizdeki eksik sıcaklık değerlerini ortalama sıcaklık değeriyle değiştiren yeni bir değişken oluşturma kodu burada. Bununla birlikte, birçok durumda verileri ortalamayla değiştirmek yanlılığa neden olabilir, bu nedenle kullanırken dikkatli olun.\n\nlinelist &lt;- linelist %&gt;%\n  mutate(temp_replace_na_with_mean = replace_na(temp, mean(temp, na.rm = T)))\n\nKategorik verileri belirli bir değerle değiştirmek için de benzer bir işlem yapabilirsiniz. Tüm gözlemlerin çıktılarının eksik verili olmasına karşın (“Ölüm” veya “İyileşme” olabilir) ölümlerden oluştuğunu bildiğinizi farz edin (not: bu aslında bu veri kümesi için doğru değildir):\n\nlinelist &lt;- linelist %&gt;%\n  mutate(outcome_replace_na_with_death = replace_na(outcome, \"Death\"))\n\n\n\nRegresyon ataması\nBiraz daha gelişmiş bir yöntem, eksik bir değerin ne olabileceğini tahmin etmek için bir tür istatistiksel model kullanmak ve bunu tahmin edilen değerle değiştirmektir. Burada, sıcaklığın eksik olduğu, ancak yaş ve ateşin olmadığı tüm gözlemler için, tahmin edici olarak ateş durumu ve yaş kullanılarak basit doğrusal regresyon kullanılarak tahmin değerleri oluşturmaya bir örnek verilmiştir. Pratikte bu tür basit yaklaşımlardan daha iyi bir model kullanmak istersiniz.\n\nsimple_temperature_model_fit &lt;- lm(temp ~ fever + age_years, data = linelist)\n\n#sadece sıcaklığın eksik olduğu gözlemler için değerleri tahmin etmek için basit sıcaklık modelimizi kullanma\npredictions_for_missing_temps &lt;- predict(simple_temperature_model_fit,\n                                        newdata = linelist %&gt;% filter(is.na(temp))) \n\nVeya, eksik sıcaklık gözlemleri için emsal değerler oluşturmak üzere MICE paketi aracılığıyla aynı modelleme yaklaşımını kullanarak:\n\nmodel_dataset &lt;- linelist %&gt;%\n  select(temp, fever, age_years)  \n\ntemp_imputed &lt;- mice(model_dataset,\n                            method = \"norm.predict\",\n                            seed = 1,\n                            m = 1,\n                            print = F)\n\nWarning: Number of logged events: 1\n\ntemp_imputed_values &lt;- temp_imputed$imp$temp\n\nBu, eksik verileri tahmin edilen değerlerle değiştirmek için missForest paketini kullanmak gibi bazı daha gelişmiş yöntemlerle aynı türde bir yaklaşımdır. Bu durumda, tahmin modeli doğrusal bir regresyon yerine random forest’tir. Bunu yapmak için diğer model türlerini de kullanabilirsiniz. Bununla birlikte, bu yaklaşım MCAR altında iyi çalışsa da, MAR veya MNAR’ın durumunuzu daha doğru tanımladığına inanıyorsanız biraz dikkatli olmalısınız. Tahmininizin kalitesi, tahmin modelinizin ne kadar iyi olduğuna bağlı olacaktır ve çok iyi bir modelde bile, empoze edilen verilerinizin değişkenliği iyi tahmin edilemeyebilir.\n\n\nLOCF ve BOCF\nİleriye taşınan son gözlem (Last observation carried forward- LOCF) ve ileriye taşınan temel gözlem (Baseline observation carried forward-BOCF), zaman serisi/boylamsal veriler için değerlendirme yöntemleridir. Buradaki fikir, eksik verilerin yerine önceki gözlenen değeri almaktır. Art arda birden fazla değer eksik olduğunda, yöntem en son gözlenen değeri arar.\ntidyr paketindeki fill() fonksiyonu hem LOCF hem de BOCF ataması için kullanılabilir (ancak, HMISC, zoo ve data.table gibi diğer paketler ayrıca bunu yapmak için yöntemler içerir). fill() sözdizimini göstermek için 2000 ve 2001 yıllarının her çeyreği için bir hastalık vakalarının sayısını içeren basit bir zaman serisi veri seti oluşturacağız. Ancak, Q1’den sonraki çeyrekler için yıl değeri eksik olduğundan onları saymamız gerekecek. ‘fill()’ bağlantısı [Pivoting data] sayfasında da gösterilmektedir.\n\n# basit veri setimizi oluşturmak\ndisease &lt;- tibble::tribble(\n  ~quarter, ~year, ~cases,\n  \"Q1\",    2000,    66013,\n  \"Q2\",      NA,    69182,\n  \"Q3\",      NA,    53175,\n  \"Q4\",      NA,    21001,\n  \"Q1\",    2001,    46036,\n  \"Q2\",      NA,    58842,\n  \"Q3\",      NA,    44568,\n  \"Q4\",      NA,    50197)\n\n# eksik yıl değerlerinin ataması:\ndisease %&gt;% fill(year)\n\n# A tibble: 8 × 3\n  quarter  year cases\n  &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;\n1 Q1       2000 66013\n2 Q2       2000 69182\n3 Q3       2000 53175\n4 Q4       2000 21001\n5 Q1       2001 46036\n6 Q2       2001 58842\n7 Q3       2001 44568\n8 Q4       2001 50197\n\n\nNot: fill() fonskiyonunu kullanmadan önce verilerinizin doğru şekilde sıralandığından emin olun. fill() varsayılan olarak “aşağı” doldurma şeklindedir, ancak .direction parametresini değiştirerek değerleri farklı yönlere de uygulayabilirsiniz. Yıl değerinin yalnızca yılın sonunda kaydedildiği ve önceki çeyrekler için eksik olduğu benzer bir veri seti yapabiliriz:\n\n# biraz farklı veri kümemizi oluşturmak\ndisease &lt;- tibble::tribble(\n  ~quarter, ~year, ~cases,\n  \"Q1\",      NA,    66013,\n  \"Q2\",      NA,    69182,\n  \"Q3\",      NA,    53175,\n  \"Q4\",    2000,    21001,\n  \"Q1\",      NA,    46036,\n  \"Q2\",      NA,    58842,\n  \"Q3\",      NA,    44568,\n  \"Q4\",    2001,    50197)\n\n# eksik yıl değerlerini \"yukarı\" yönde atamak:\ndisease %&gt;% fill(year, .direction = \"up\")\n\n# A tibble: 8 × 3\n  quarter  year cases\n  &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;\n1 Q1       2000 66013\n2 Q2       2000 69182\n3 Q3       2000 53175\n4 Q4       2000 21001\n5 Q1       2001 46036\n6 Q2       2001 58842\n7 Q3       2001 44568\n8 Q4       2001 50197\n\n\nBu örnekte, LOCF ve BOCF açıkça yapılması gereken doğru şeylerdir, ancak daha karmaşık durumlarda bu yöntemlerin uygun olup olmadığına karar vermek daha zor olabilir. Örneğin hastanede yatan bir hasta için ilk günden sonra eksik laboratuvar değerleriniz olabilir. Bazen bu, laboratuvar değerlerinin değişmediği anlamına gelebilir… ama aynı zamanda hastanın iyileştiği ve değerlerinin ilk günden sonra çok farklı olacağı anlamına da gelebilir! Bu yöntemleri dikkatli kullanın.\n\n\nÇoklu Atama\nMICE paketinin yazarı tarafından daha önce bahsettiğimiz çevrimiçi kitap (https://stefvanbuuren.name/fimd/), birden fazla değerlemenin ayrıntılı bir açıklamasını ve neden kullanmak isteyeceğinizi içermektedir. Ancak, işte yöntemin temel bir açıklaması:\nBirden çok atama yaptığınızda, eksik değerlerin makul veri değerlerine atfedildiği birden çok veri kümesi oluşturursunuz (araştırma verilerinize bağlı olarak, bu atfedilen veri kümelerinden daha fazlasını veya daha azını oluşturmak isteyebilirsiniz, ancak MICE paketi varsayılan sayıyı 5’e ayarlar). Aradaki fark, her bir empoze edilen değerin tek, belirli bir değerden ziyade tahmini bir dağılımdan çekilmesidir (bu nedenle bir miktar rastgelelik içerir). Sonuç olarak, bu veri kümelerinin her biri biraz farklı emsal değerlere sahip olacaktır (ancak, eksik olmayan veriler bu empoze edilen veri kümelerinin her birinde aynı olacaktır). Bu yeni veri kümelerinin her birinde atama yapmak için hala bir tür tahmine dayalı model kullanıyorsunuz (MICE Tahmini Ortalama Eşleştirme, lojistik regresyon ve random forest dahil olmak üzere birçok tahmin yöntemi seçeneği vardır) ancak MICE paketinin modelleme detaylarına dikkat etmelisiniz.\nArdından, bu yeni atfedilen veri kümelerini oluşturduktan sonra, bu yeni empoze edilmiş veri kümelerinin her biri için yapmayı planladığınız istatistiksel modeli veya analizi uygulayabilir ve modellerin sonuçlarını bir araya toplayabilirsiniz. Bu, hem MCAR hem de birçok MAR ayarındaki yanlılığı azaltmak için çok iyi çalışır ve genellikle daha doğru standart hata tahminleriyle sonuçlanır.\nBurada, bir yaş ve ateş durumu (yukarıdaki basitleştirilmiş model_veri kümemiz) kullanarak satır listesi veri kümemizdeki sıcaklığı tahmin etmek için Çoklu Atama işleminin uygulanmasına bir örnek verilmiştir:\n\n# model_dataset'imizdeki tüm değişkenler için eksik değerler atamak ve 10 yeni atanmış veri kümesi oluşturmak\nmultiple_imputation = mice(\n  model_dataset,\n  seed = 1,\n  m = 10,\n  print = FALSE) \n\nWarning: Number of logged events: 1\n\nmodel_fit &lt;- with(multiple_imputation, lm(temp ~ age_years + fever))\n\nbase::summary(mice::pool(model_fit))\n\n         term     estimate    std.error    statistic        df       p.value\n1 (Intercept) 3.703143e+01 0.0270863456 1.367162e+03  26.83673  1.583113e-66\n2   age_years 3.867829e-05 0.0006090202 6.350905e-02 171.44363  9.494351e-01\n3    feveryes 1.978044e+00 0.0193587115 1.021785e+02 176.51325 5.666771e-159\n\n\nBurada MICE’nin standart yöntemi Tahmini Ortalama Eşleştirme yöntemini kullandık. Daha sonra, bu veri kümelerinin her birinde basit doğrusal regresyonlardan elde edilen sonuçları ayrı ayrı tahmin etmek ve havuzlamak için bu emsal veri kümelerini kullandık. Üzerinde durduğumuz birçok ayrıntı ve MICE paketini kullanırken Çoklu Atama işlemi sırasında ayarlayabileceğiniz birçok ayar vardır. Örneğin, her zaman sayısal verileriniz olmaz ve başka atama yöntemlerini kullanmanız gerekebilir (diğer birçok veri ve yöntem türü için MICE paketini kullanmaya devam edebilirsiniz). Ancak, eksik veriler önemli bir sorun olduğunda daha sağlam bir analiz için, Çoklu Atama iyi bir çözümdür ancak, her zaman tam bir vaka analizi yapmaktan daha fazla işe yaramaz.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Eksik Veri</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.tr.html#kaynaklar",
    "href": "new_pages/missing_data.tr.html#kaynaklar",
    "title": "20  Eksik Veri",
    "section": "20.7 Kaynaklar",
    "text": "20.7 Kaynaklar\nKılavuz naniar package\nGaleri missing value visualizations\nÇevrimiçi kitap R’da birden fazla değer atama hakkında MICE paketi yaratıcısının kitabı",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Eksik Veri</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.tr.html",
    "href": "new_pages/standardization.tr.html",
    "title": "21  Standardize edilmiş hızlar",
    "section": "",
    "text": "21.1 Genel bakış\nStandardizasyonun iki ana yöntemi vardır: Direkt ve indirekt standardizasyon. A ve B ülkeleri için ölüm hızlarını yaşa ve cinsiyete göre standardize etmek ve bu ülkeler arasındaki standardize edilmiş oranları karşılaştırmak istediğimizi varsayalım.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Standardize edilmiş hızlar</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.tr.html#genel-bakış",
    "href": "new_pages/standardization.tr.html#genel-bakış",
    "title": "21  Standardize edilmiş hızlar",
    "section": "",
    "text": "Direk standardizasyon için, A ülkesi ve B ülkesi için her yaş ve cinsiyet tabakası için risk altındaki popülasyon büyüklüğüve ölümlerin sayısını bilmeniz gerekecektir. Örneğimizdeki bir katman 15-44 yaş arası kadınlar olabilir.\nİndirekt standardizasyon için, her ülkenin toplam ölüm sayısı, yaş ve cinsiyet yapısını bilmeniz gerekir. Dolayısıyla bu seçenek, yaşa ve cinsiyete özgü ölüm hızları veya nüfus sayıları mevcut değilse uygulanabilir. Direkt standardizasyondaki tahminler örneklem varyasyonundan etkileneceğinden; tabaka başına küçük sayıların olması durumunda indirekt standardizasyon tercih edilir.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Standardize edilmiş hızlar</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.tr.html#hazırlık",
    "href": "new_pages/standardization.tr.html#hazırlık",
    "title": "21  Standardize edilmiş hızlar",
    "section": "21.2 Hazırlık",
    "text": "21.2 Hazırlık\nStandardizasyonun nasıl yapıldığını göstermek için, A ve B ülkelerinin yaşa (5 yıllık tabakalar halinde) ve cinsiyete (kadın, erkek) göre kurgusal nüfus büyüklükleri ve ölüm sayımlarını kullanacağız. Veri setlerini kullanıma hazır hale getirmek için aşağıdaki hazırlık adımlarını gerçekleştireceğiz:\n\nPaketlerin yüklenmesi\n\nVeri tabanlarının yüklenmesi\nİki ülkenin nüfus ve ölüm verilerini birleştirilmesi\nYaş-cinsiyet katmanı başına bir satır olacak şekilde daha uzun şekilde pivotlama\nReferans popülasyonunu (dünya standart nüfusu) temizleme ve ülke verilerine ekleme\n\nSenaryonuzda, verileriniz farklı bir biçimde gelebilir. Belki verileriniz il, şehir veya başka bir hizmet alanına göre düzenlenmiştir. Her ölüm için bir satır ve bu ölümlerin her biri (veya önemli bir kısmı) için yaş ve cinsiyet bilgileri olabilir. Bu durumda, yaş-cinsiyet katmanlarına göre olay ve nüfus sayıları içeren bir veri tabanı oluşturmak için [Verileri gruplandırma], [Verileri pivotlama] ve [Tanımlayıcı tablolar] sayfalarına bakın.\nAyrıca bir referans popülasyona, standart popülasyona ihtiyacımız vardır. Bu alıştırma için world_standard_population_by_sex’i kullanacağız. Dünya standart nüfusu, 46 ülkenin nüfusuna dayanmaktadır ve 1960 yılında geliştirilmiştir. Birçok “standart” popülasyon vardır - bir örnek olarak, NHS İskoçya’nın web sitesi Avrupa Standart Nüfusu, Dünya Standart Nüfusu ve İskoçya Standardı hakkında detaylı bilgi içermektedir. (European Standard Population, World Standard Population and Scotland Standard Population).\n\n\nPaketlerin yüklenmesi\nBu kod kümesi, analizler için gereken paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’ın p_load() fonksiyonunu vurguluyoruz. Ayrıca, R tabanından library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R’ın temelleri] sayfasına bakın.\n\npacman::p_load(\n     rio,                 # verileri içe/dışa aktar\n     here,                # dosyaları bul\n     stringr,             # karakterleri ve dizeleri (string) temizleme\n     frailtypack,         # frailty modelleri için dsr için gerekli\n     dsr,                 # hızları standardize et\n     PHEindicatormethods, # hızların  standardizasyonu için alternatif\n     tidyverse)           # veri yönetimi ve görselleştirme\n\n**DİKKAT:_** Daha yeni bir R sürümüne sahipseniz, dsr paketi doğrudan CRAN’den indirilemez. Ancak, yine de bu paket CRAN arşivinden temin edilebilir. Bu şekilde paketi yükleyebilir ve kullanabilirsiniz. \nMac kullanıcısı olmayanlar için:\n\npackageurl &lt;- \"https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz\"\ninstall.packages(packageurl, repos=NULL, type=\"source\")\n\n\n# Diğer çözüm\nrequire(devtools)\ndevtools::install_version(\"dsr\", version=\"0.2.2\", repos=\"http:/cran.us.r.project.org\")\n\nMac kullanıcıları için:\n\nrequire(devtools)\ndevtools::install_version(\"dsr\", version=\"0.2.2\", repos=\"https://mac.R-project.org\")\n\n\n\nPopülasyon verisinin yüklenmesi\nEl kitabındaki tüm örnek verilerin nasıl indirileceğine ilişkin talimatlar için [Verilerin ve el kitabının indirilmesi] sayfasına bakın. Aşağıdaki import() komutlarını çalıştırarak Standardizasyon sayfası verilerini Github depomuzdan doğrudan R’a aktarabilirsiniz:\n\n# A ülkesi için demografik veriyi doğrudan Github'dan içe aktarın\nA_demo &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics.csv\")\n\n# A ülkesi için ölümleri doğrudan Github'dan içe aktarın\nA_deaths &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryA.csv\")\n\n# B ülkesi için demografik veriyi doğrudan Github'dan içe aktarın\nB_demo &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics_2.csv\")\n\n# B ülkesi için ölümleri doğrudan Github'dan içe aktarın\nB_deaths &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryB.csv\")\n\n# B ülkesi için demografik veriyi doğrudan Github'dan içe aktarın\nstandard_pop_data &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/world_standard_population_by_sex.csv\")\n\nİlk önce karşılaştıracağımız iki ülke olan “Ülke A” ve “Ülke B” için demografik verileri (5 yıllık yaş kategorisine göre kadın ve erkek sayıları) yüklüyoruz.\n\n# A ülkesi\nA_demo &lt;- import(\"country_demographics.csv\")\n\n\n\n\n\n\n\n\n# B ülkesi\nB_demo &lt;- import(\"country_demographics_2.csv\")\n\n\n\n\n\n\n\n\n\nÖlüm sayılarının yüklenmesi\nElimizde uygun bir şekilde, ilgilenilen zaman dilimindeki yaş ve cinsiyete göre ölüm sayıları da bulunmaktadır. Her ülkenin ölüm sayıları aşağıda gösterilen ayrı bir dosyadadır.\nA Ülkesindeki Ölümler\n\n\n\n\n\n\nB Ülkesindeki Ölümler\n\n\n\n\n\n\n\n\nNüfus ve ölüm verilerinin temizliği\nBu verileri aşağıdaki şekillerde birleştirmemiz ve dönüştürmemiz gerekiyor:\n\nÜlke popülasyonlarını tek bir veri tabanında birleştirin ve her bir yaş-cinsiyet katmanının bir satır olması için “uzun” şekilde pivotlayın\nÜlke ölüm sayılarını tek bir veri tabanında birleştirin ve her bir yaş-cinsiyet katmanının bir satır olması için “uzun” şekilde pivotlayın\nÖlümleri nüfusla birleştirin\n\nİlk olarak, ülke popülasyonları veri tabanlarını birleştirip, daha sonra uzun biçimde pivotlar ve temizlik yaparız. Daha fazla ayrıntı için [Verilerin pivotlanması] sayfasına bakın.\n\npop_countries &lt;- A_demo %&gt;%  # A ülkesi veritabanı ile başla\n     bind_rows(B_demo) %&gt;%        # Satırları B veri tabanıyla bağla, çünkü sütunlar aynı şekilde adlandırılır\n     pivot_longer(                       # uzun şekilde pivotlama\n          cols = c(m, f),                   # birleştirilecek sütunlar\n          names_to = \"Sex\",                 # kategoriyi (\"m\" veya \"f\") içeren yeni sütunun adı \n          values_to = \"Population\") %&gt;%     # özetlenen sayısal değerleri içeren yeni sütunun adı\n     mutate(Sex = recode(Sex,            # anlaşılması için değerleri yeniden kodla\n          \"m\" = \"Male\",\n          \"f\" = \"Female\"))\n\nBirleşik nüfus verileri şimdi şöyle görünür (A ve B ülkelerini görmek için tıklayın):\n\n\n\n\n\n\nŞimdi de iki ölüm veri setinde benzer işlemler yapıyoruz.\n\ndeaths_countries &lt;- A_deaths %&gt;%    # A ülkesi ölüm veritabanı ile başlayın\n     bind_rows(B_deaths) %&gt;%        # Satırları B veri tabanıyla bağla, çünkü sütunlar aynı şekilde adlandırılır\n     pivot_longer(                  # uzun şekilde pivotlama\n          cols = c(Male, Female),        # birleştirilecek sütunlar\n          names_to = \"Sex\",              # kategoriyi (\"m\" veya \"f\") içeren yeni sütunun adı\n          values_to = \"Deaths\") %&gt;%      # özetlenen sayısal değerleri içeren yeni sütunun adı\n     rename(age_cat5 = AgeCat)      # anlaşılması için değerleri yeniden kodla\n\nÖlüm verileri şimdi böyle görünüyor ve her iki ülkeden de veriler içermekte:\n\n\n\n\n\n\nŞimdi Country, age_cat5 ve Sex ortak sütunlarına dayalı ölüm ve nüfus verilerini birleştiriyoruz. Bu işlem, Deaths sütununu ekler.\n\ncountry_data &lt;- pop_countries %&gt;% \n     left_join(deaths_countries, by = c(\"Country\", \"age_cat5\", \"Sex\"))\n\nArtık Sex, age_cat5 ve Country’yi faktör olarak sınıflandırabilir ve [Faktörler] sayfasında açıklandığı gibi forcats paketinden fct_relevel() fonksiyonunu kullanarak seviye sırasını ayarlayabiliriz. Unutulmamalıdır ki, faktör seviyelerinin sınıflandırılması verileri gözle görülür şekilde değiştirmez, ancak arrange() komutu verileri ülkeye, yaş kategorisine ve cinsiyete göre sıralar.\n\ncountry_data &lt;- country_data %&gt;% \n  mutate(\n    Country = fct_relevel(Country, \"A\", \"B\"),\n      \n    Sex = fct_relevel(Sex, \"Male\", \"Female\"),\n        \n    age_cat5 = fct_relevel(\n      age_cat5,\n      \"0-4\", \"5-9\", \"10-14\", \"15-19\",\n      \"20-24\", \"25-29\",  \"30-34\", \"35-39\",\n      \"40-44\", \"45-49\", \"50-54\", \"55-59\",\n      \"60-64\", \"65-69\", \"70-74\",\n      \"75-79\", \"80-84\", \"85\")) %&gt;% \n          \n  arrange(Country, age_cat5, Sex)\n\n\n\n\n\n\n\nDİKKAT: Her tabakada az sayıda ölüm varsa, yaşa göre 5 yıllık kategoriler yerine 10 veya 15 yıllık kategorileri kullanmayı düşünün.\n\n\nReferans popülasyonun yüklenmesi\nSon olarak, direkt standardizasyon için referans popülasyonu (cinsiyete göre dünya “standart nüfusu”) içe aktarıyoruz.\n\n# Referans popülasyon\nstandard_pop_data &lt;- import(\"world_standard_population_by_sex.csv\")\n\n\n\n\n\n\n\n\n\n\nReferans popülasyon verisinin temizliği\ncountry_data ve standard_pop_data veri çerçevelerindeki yaş kategorisi değerlerinin hizalanması gerekir.\nŞu anda, standart_pop_data veri çerçevesinden age_cat5 sütununun değerleri “yıllar” ve “artı” kelimelerini içerirken country_data veri çerçevesindeki sütun bu kelimeleri içermemektedir. Yaş kategorisi değerlerini eşleştirmemiz gerekecek. Bu kalıpları boşluksuz olarak \"\" biçiminde değiştirmek için [Karakterler ve dizeler] sayfasında açıklandığı gibi stringr paketinden str_replace_all() komutunu kullanıyoruz.\nAyrıca, dsr paketi standart popülasyonda sayıları içeren sütunun \"pop\" olarak adlandırılmasını bekler. Bu yüzden bu sütunu bu şekilde yeniden adlandırıyoruz.\n\n# Sütun değerlerinden belirli dizeyi kaldır\nstandard_pop_clean &lt;- standard_pop_data %&gt;%\n     mutate(\n          age_cat5 = str_replace_all(age_cat5, \"years\", \"\"),   # \"year\"'ı kaldır\n          age_cat5 = str_replace_all(age_cat5, \"plus\", \"\"),    # \"plus\"'ı kaldır\n          age_cat5 = str_replace_all(age_cat5, \" \", \"\")) %&gt;%   # \" \" boşluğu kaldır\n     \n     rename(pop = WorldStandardPopulation)   # dsr paketi tarafından tanınması için sütun adını \"pop\" olarak değiştir\n\nDİKKAT: Bir artı sembolünü kaldırmak için str_replace_all() kullanmayı denerseniz, özel bir sembol olduğu için çalışmayacaktır. str_replace_call(column, \"\\\\+\", \"\") örneğinde olduğu gibi önüne iki ters eğik çizgi koyarak özel özelliklerden kaçınabilirsiniz.\n\n\nStandart popülasyon ile veri tabanının oluşturulması\nSon olarak, aşağıda ayrıntıları verilen PHEindicatormethods paketi, ülke için gerçekleşen olay (ölüm), nüfus sayıları ve standart popülasyon verilerini istemektedir. Bu amaçla bir all_data veri tabanı oluşturacağız.\n\nall_data &lt;- left_join(country_data, standard_pop_clean, by=c(\"age_cat5\", \"Sex\"))\n\nTam veri tabanı bu şekilde görülmektedir:",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Standardize edilmiş hızlar</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.tr.html#dsr-paketi",
    "href": "new_pages/standardization.tr.html#dsr-paketi",
    "title": "21  Standardize edilmiş hızlar",
    "section": "21.3 dsr paketi",
    "text": "21.3 dsr paketi\nAşağıda, dsr paketini kullanarak direkt standardize edilmiş hızları hesaplamayı ve karşılaştırmayı gösteriyoruz. dsr paketi, direkt standardize edilmiş hızları hesaplamanıza ve karşılaştırmanıza olanak tanır (indirekt standardize edilmiş oranlar yok!).\nVeri Hazırlama bölümünde ülkeler ve standart nüfus için ayrı ayrı veri tabanları oluşturduk:\n\nÜlke için tabaka başına nüfus ve ölüm sayısını içeren bir nüfus tablosu olan country_data nesnesi\nReferans popülasyonumuz olan World Standard Population için tabaka başına popülasyonu gösteren içeren standard_pop_clean nesnesi\n\nBu ayrı veri tabanlarını dsr yaklaşımı için kullanacağız.\n\n\nStandardize edilmiş hızlar\nAşağıda, yaş ve cinsiyet için direkt standardize edilmiş oranları ülkeler için hesaplıyoruz. Bu işlem için dsr() fonksiyonunu kullanıyoruz.\nNot: dsr(), ülke popülasyonları ve olay sayıları (ölümler) için bir veri tabanı ve referans popülasyonu için ayrı bir veri tabanı bekler. Ayrıca bu referans popülasyon veri tabanında birim-zaman sütun adının “pop” olmasını bekler (bunu veri Hazırlama bölümünde sağladık)\nAşağıdaki kodda görüldüğü gibi bu fonksiyon için birçok argüman vardır. Dikkat çekici bir şekilde, event = ölümler sütununa ve fu = (“follow up”- “takip”), Population sütununa ayarlanmıştır. Karşılaştırma alt gruplarını Country sütunu olarak belirledik ve age_cat5 ve Sex’e göre standardize ettik. Bu son iki sütuna belirli bir argüman atanmaz. Ayrıntılar için ?dsr komutuna bakınız.\n\n# Yaş ve cinsiyet için direkt standardize edilmiş hızları ülke başına hesapla\nmortality_rate &lt;- dsr::dsr(\n     data = country_data,  # tabaka başına ölüm sayısını içeren nesneyi belirt\n     event = Deaths,       # tabaka başına ölüm sayısını içeren sütun\n     fu = Population,      # tabaka başına nüfus sayısını içeren sütun\n     subgroup = Country,   # karşılaştırmak istediğimiz birimler\n     age_cat5,             # standardize etmek istediğimiz özellikler\n     Sex,\n     refdata = standard_pop_clean, # pop olarak adlandırılan sütundaki sayılarla referans popülasyonu\n     method = \"gamma\",      # 95% güven aralığını hesaplayan yöntem\n     sig = 0.95,            # anlamlılık düzeyi\n     mp = 100000,           # 100.000 kişilik nüfus başına hız istiyoruz\n     decimals = 2)          # ondalık basamak sayısı\n\n\n# Çıktıyı iyi görünen bir HTML tablosu olarak yazdır\nknitr::kable(mortality_rate) # direkt standardizasyondan önce ve sonra ölüm oranını göster\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSubgroup\nNumerator\nDenominator\nCrude Rate (per 1e+05)\n95% LCL (Crude)\n95% UCL (Crude)\nStd Rate (per 1e+05)\n95% LCL (Std)\n95% UCL (Std)\n\n\n\n\nA\n11344\n86790567\n13.07\n12.83\n13.31\n23.57\n23.08\n24.06\n\n\nB\n9955\n52898281\n18.82\n18.45\n19.19\n19.33\n18.46\n20.22\n\n\n\n\n\nYukarıda, A ülkesinin B ülkesinden daha düşük bir kaba ölüm hızına sahip olduğunu, ancak yaş ve cinsiyet için direkt standardizasyon sonrası, A ülkesinin daha yüksek bir standardize edilmiş hıza sahip olduğunu görüyoruz.\n\n\n\nStandardize hız oranları\n\n# Calculate RR\nmortality_rr &lt;- dsr::dsrr(\n     data = country_data, # tabaka başına ölüm sayısını içeren nesneyi belirt\n     event = Deaths,      # tabaka başına ölüm sayısını içeren sütun\n     fu = Population,     # tabaka başına nüfus sayısını içeren sütun\n     subgroup = Country,  # karşılaştırmak istediğimiz birimler\n     age_cat5,\n     Sex,                 # standardize istediğimiz özellikler\n     refdata = standard_pop_clean, # pop olarak adlandırılan sütundaki sayılarla referans popülasyonu\n     refgroup = \"B\",      # karşılaştırma için referans\n     estimate = \"ratio\",  # tahmin tipi\n     sig = 0.95,          # anlamlılık seviyesi\n     mp = 100000,         # 100.000 kişilik nüfus başına hız istiyoruz\n     decimals = 2)        # ondalık basamak sayısı\n\n# Tabloyu yazdır\nknitr::kable(mortality_rr) \n\n\n\n\n\n\n\n\n\n\n\n\nComparator\nReference\nStd Rate (per 1e+05)\nRate Ratio (RR)\n95% LCL (RR)\n95% UCL (RR)\n\n\n\n\nA\nB\n23.57\n1.22\n1.17\n1.27\n\n\nB\nB\n19.33\n1.00\n0.94\n1.06\n\n\n\n\n\nStandardize ölüm oranı, A ülkesinde B ülkesine kıyasla 1,22 kat daha yüksektir (%95 GA 1,17-1,27).\n\n\n\nStandardize hız farkı\n\n# Calculate RD\nmortality_rd &lt;- dsr::dsrr(\n     data = country_data,       # tabaka başına ölüm sayısını içeren nesneyi belirt\n     event = Deaths,            # tabaka başına ölüm sayısını içeren sütun \n     fu = Population,           # tabaka başına nüfus sayısını içeren sütun\n     subgroup = Country,        # karşılaştırmak istediğimiz birimler\n     age_cat5,                  # standardize istediğimiz özellikler\n     Sex,                        \n     refdata = standard_pop_clean, # pop olarak adlandırılan sütundaki sayılarla referans popülasyonu\n     refgroup = \"B\",            # karşılaştırma için referans\n     estimate = \"difference\",   # tahmin tipi\n     sig = 0.95,                # anlamlılık seviyesi\n     mp = 100000,               # 100.000 kişilik nüfus başına hız istiyoruz\n     decimals = 2)              # ondalık basamak sayısı\n\n# Tabloyu yazdır\nknitr::kable(mortality_rd) \n\n\n\n\n\n\n\n\n\n\n\n\nComparator\nReference\nStd Rate (per 1e+05)\nRate Difference (RD)\n95% LCL (RD)\n95% UCL (RD)\n\n\n\n\nA\nB\n23.57\n4.24\n3.24\n5.24\n\n\nB\nB\n19.33\n0.00\n-1.24\n1.24\n\n\n\n\n\nA Ülkesi, B ülkesine kıyasla 100.000 nüfus başına 4.24 ek ölüme (%95 GA 3.24-5.24) sahiptir.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Standardize edilmiş hızlar</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.tr.html#standard_phe",
    "href": "new_pages/standardization.tr.html#standard_phe",
    "title": "21  Standardize edilmiş hızlar",
    "section": "21.4 PHEindicatormethods paketi",
    "text": "21.4 PHEindicatormethods paketi\nStandardize hızları hesaplamanın başka bir yolu da PHEindicatormethods paketidir. Bu paket, direkt ve indirekt olarak standardize edilmiş hızları hesaplamanıza olanak tanır. İkisini de göstereceğiz.\nBu bölüm, Hazırlık bölümünün sonunda oluşturulan all_data veri tabanını kullanacaktır. Bu veri tabanı, ülke popülasyonlarını, ölüm olaylarını ve dünya için standart referans popülasyonu içerir. Burada görüntüleyebilirsiniz.\n\n\nDirekt standardize edilmiş hızlar\nAşağıda, önce verileri ülkeye göre gruplandırıyoruz ve ardından ülke başına direkt standardize edilmiş hızları elde etmek için phe_dsr() fonksiyonuna aktarıyoruz.\nNot: Referans (standart) popülasyon, ülkeye özgü veri tabanında bir sütun olarak veya ayrı bir vektör olarak verilebilir. Ülkeye özel veri tabanı oluşturulduysa, stdpoptype= \"field\" olarak ayarlanmalıdır. Vektör olarak sağlanmışsa, stdpoptype = \"vector\" olarak ayarlanmalıdır. İkinci durumda, kayıtlar pozisyona göre eşleştirileceğinden, satırların tabaklara göre sıralamasının hem ülkeye özgü veri tabanında hem de referans popülasyonda benzer olduğundan emin olmalısınız. Aşağıdaki örneğimizde, ülkeye özgü veri tabanında bir sütun olarak referans popülasyon verilmiştir.\nDaha fazla bilgi için ?phr_dsr ile ilgili yardıma veya Referanslar bölümündeki bağlantılara bakabilirsiniz\n\n# yaş ve cinsiyet için direkt standardize edilmiş hızları ülke başına hesapla\nmortality_ds_rate_phe &lt;- all_data %&gt;%\n     group_by(Country) %&gt;%\n     PHEindicatormethods::phe_dsr(\n          x = Deaths,                 # gözlemlenen olay sayısını içeren sütun\n          n = Population,             # her tabaka için standart olmayan nüfusu içeren sütunlar\n          stdpop = pop,               # her tabaka için standart popülasyonlar\n          stdpoptype = \"field\")       # bağımsız bir vektör için \"vector-vektör\" veya verilerde standart popülasyonların olduğu durumlarda \"field-alan\"\n\n# Tabloyu yazdır\nknitr::kable(mortality_ds_rate_phe)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCountry\ntotal_count\ntotal_pop\nvalue\nlowercl\nuppercl\nconfidence\nstatistic\nmethod\n\n\n\n\nA\n11344\n86790567\n23.56686\n23.08107\n24.05944\n95%\ndsr per 100000\nDobson\n\n\nB\n9955\n52898281\n19.32549\n18.45516\n20.20882\n95%\ndsr per 100000\nDobson\n\n\n\n\n\n\n\n\nİndirekt standardize edilmiş hızlar\nİnidirekt standardizasyon için, tabaka başına ölüm sayısı, nüfus ve bir referans popülasyona ihtiyacınız vardır. Bu örnekte, standart_pop_clean referans popülasyonu tabaka başına ölüm sayısını içermediğinden, B ülkesini referans popülasyon olarak kullanarak A ülkesi için hızları hesaplayacağız.\nAşağıda, önce B ülkesinden referans popülasyonu oluşturuyoruz. Ardından, A ülkesi için ölüm ve nüfus verilerini çıkarıyoruz, bu verileri referans popülasyonla birleştiriyoruz ve indirekt standardize edilmiş hızları elde etmek için calculate_ISRate() fonksiyonuna aktarıyoruz. Tabii ki, bunun tersini de yapabilirsiniz.\nNot: Aşağıdaki örneğimizde, referans popülasyonu ayrı bir veri tabanı olarak verilmiştir. Bu durumda, kayıtlar pozisyona göre eşleştirileceğinden, x =, n =, x_ref = ve n_ref = vektörlerinin tümünün, ülkemize özgü veri tabanıyla aynı standardizasyon kategorisi (tabaka) değerlerine göre sıralandığından emin oluruz.\nDaha fazla bilgi için ?phr_isr komutu ile ilgili yardıma veya Referanslar bölümündeki bağlantılara bakın.\n\n# Referans popülasyonu oluştur\nrefpopCountryB &lt;- country_data %&gt;% \n  filter(Country == \"B\") \n\n# A ülkesi için yaş ve cinsiyete göre indirekt standardize edilmiş hızları hesapla\nmortality_is_rate_phe_A &lt;- country_data %&gt;%\n     filter(Country == \"A\") %&gt;%\n     PHEindicatormethods::calculate_ISRate(\n          x = Deaths,                 # gözlemlenen olay sayısını içeren sütun\n          n = Population,             # her tabaka için standardize edilmemiş popülasyonu içeren sütunlar\n          x_ref = refpopCountryB$Deaths,  # her tabaka için referans ölüm sayısı\n          n_ref = refpopCountryB$Population)  # her tabaka için referans popülasyon\n\n# Tabloyu yazdır\nknitr::kable(mortality_is_rate_phe_A)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nobserved\nexpected\nref_rate\nvalue\nlowercl\nuppercl\nconfidence\nstatistic\nmethod\n\n\n\n\n11344\n15847.42\n18.81914\n13.47123\n13.22446\n13.72145\n95%\nindirectly standardised rate per 100000\nByars",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Standardize edilmiş hızlar</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.tr.html#kaynaklar",
    "href": "new_pages/standardization.tr.html#kaynaklar",
    "title": "21  Standardize edilmiş hızlar",
    "section": "21.5 Kaynaklar",
    "text": "21.5 Kaynaklar\ndsr paketini kullanarak başka bir tekrarlanabilir örnek görmek isterseniz, lütfen bu skece bakın.\nPHEindicatormethods paketini kullanan başka bir örnek için lütfen bu web sitesine gidin.\nPHEindicatormethods referans pdf dosyasına bakın.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Standardize edilmiş hızlar</span>"
    ]
  },
  {
    "objectID": "new_pages/moving_average.tr.html",
    "href": "new_pages/moving_average.tr.html",
    "title": "22  Hareketli ortalamalar",
    "section": "",
    "text": "22.1 Hazırlık",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Hareketli ortalamalar</span>"
    ]
  },
  {
    "objectID": "new_pages/moving_average.tr.html#hazırlık",
    "href": "new_pages/moving_average.tr.html#hazırlık",
    "title": "22  Hareketli ortalamalar",
    "section": "",
    "text": "Paketleri yükleme\nBu kod parçası, analizler için gerekli olan paketlerin yüklenmesini göstermektedir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’ın p_load() fonksiyonunu öneriyoruz. Ayrıca, R tabanından library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakın.\n\npacman::p_load(\n  tidyverse,      # verinin yönetimi ve görselleştirilmesi için\n  slider,         # hareketli ortalamaları hesaplamak için\n  tidyquant       # ggplot içinde hareketli ortalamaları hesaplamak için\n)\n\n\n\nVerinin içe aktarımı\nSimüle edilmiş Ebola salgını vakalarını içeren veri setini içe aktarıyoruz. Takip etmek istiyorsanız, “temiz” satır listesini (.rds dosyası olarak) indirmek için tıklayın. rio paketinden import() fonksiyonu ile verileri içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için İçe Aktarma ve Dışa Aktarma sayfasına bakın).\n\n# satır listesini içe aktar\nlinelist &lt;- import(\"linelist_cleaned.xlsx\")\n\nSatır listesinin ilk 50 satırı aşağıda görüntülenir.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Hareketli ortalamalar</span>"
    ]
  },
  {
    "objectID": "new_pages/moving_average.tr.html#slider-ile-hesaplama",
    "href": "new_pages/moving_average.tr.html#slider-ile-hesaplama",
    "title": "22  Hareketli ortalamalar",
    "section": "22.2 slider ile hesaplama",
    "text": "22.2 slider ile hesaplama\nGrafik haline getirmeden önce bir veri çerçevesinde hareketli ir ortalama hesaplamak için bu yaklaşımı kullanın.\nslider paketi, yuvarlanan ortalamaları, kümülatif toplamları, yuvarlanan regresyonları vb. hesaplamak için “kayan pencere” fonksiyonu içerir. Bir veri çerçevesini bir satır vektörü olarak ele alır ve bir veri çerçevesi üzerinde satır bazında yinelemelere izin verir.\nOrtak fonksiyonlardan bazıları:\n\nslide_dbl() - kayan pencere kullanarak işlem gerçekleştiren sayısal bir sütunu yineler (dolayısıyla “_dbl”)\n\nslide_sum() - slide_dbl() için yuvarlanan toplam kısayol fonksiyonu\n\nslide_mean() - slide_dbl() için yuvarlanan ortalama kısayol fonksiyonu\n\nslide_index_dbl() - pencere ilerlemesini indekslemek için ayrı bir sütun kullanarak; yuvarlanan pencereyi sayısal bir sütuna uygular (bazı tarihler eksikken tarihe göre yuvarlanıyorsa kullanışlıdır)\n\nslide_index_sum() - indeksleme ile birlikte yuvarlanan toplam kısayol fonksiyonu\n\nslide_index_mean() - indekslemeli yuvarlanan ortalama kısayol fonksiyonu\n\n\nslider paketi, bu sayfada Kaynaklar bölümünde ele alınan birçok başka fonkisyona da sahiptir. En yaygın olanlara kısaca değineceğiz.\nTemel argümanlar\n\nVarsayılan ilk argüman olan .x, yinelenecek ve fonksiyonu uygulayacak vektördür.\n.i = slider fonksiyonların “indeks” versiyonları için - geçişi “indekslemek” için bir sütun oluşturur aşağıdaki bölüme bakın)\n.f =, varsayılan ikinci argüman;\n\nOrtalama gibi parantezsiz yazılmış bir fonksiyon veya\nBir fonksiyona dönüştürülecek bir formül. Örneğin ~ .x - ortalama(.x), mevcut değerden pencerenin değerinin ortalamasını hesaplar ve elde edilen sonucu sunar.\n\nDaha fazla ayrıntı için bu kaynak materyaline bakın\n\nPencere büyüklüğü\n.before, .after veya her iki argümanı kullanarak pencerenin boyutunu belirtin:\n\n.before = - Bir tamsayı verin\n\n.after = - Bir tamsayı verin\n\n.complete = - Yalnızca eksiksiz pencerelerde hesaplama yapılmasını istiyorsanız bunu DOĞRU olarak ayarlayın\n\nÖrneğin, mevcut değeri ve önceki altı değeri içeren 7 günlük bir pencere elde etmek için .before = 6 argümanını kullanın. “Ortalanmış” bir pencere elde etmek için hem .before = hem de .after = için aynı sayıyı sağlayın.\nVarsayılan olarak, .complete = FALSE olarak kodlanmıştır, bu nedenle tam satır penceresi mevcut değilse, fonksiyonlar hesaplamayı gerçekleştirmek için mevcut satırları kullanacaktır. Bu argümanı DOĞRU olarak ayarlamak, hesaplamaların yalnızca eksiksiz pencerelerde gerçekleştirilmesini sağlar.\nPencerenin genişletilmesi\nKümülatif işlemleri gerçekleştirmek için, .before = argümanını Inf olarak ayarlayın. Bu argüman, işlemi mevcut değerde ve daha önceki değerlerde yürütecektir.\n\nTarihe göre yuvarlama\nUygulamalı epidemiyolojide yuvarlanan hesaplamanın en olası kullanım durumu, zaman içinde değişim gösteren bir ölçümün incelenmesidir (Örnek: Günlük vaka sayılarına dayalı olarak vaka insidansının yuvarlanan bir ölçümü)\nHer tarih için değer içeren temiz bir zaman serisi veriniz varsa, burada Zaman Serisi ve Salgın Tespiti sayfasında gösterildiği gibi slide_dbl() fonksiyonunu kullanabilirsiniz.\nBununla birlikte, birçok epidemiyoloji uygulamasında, kaydedilen hiçbir olayın gerçekleşmediği, verilerinizde eksik tarihler olabilir. Bu durumlarda, slider fonksiyonların “indeks” sürümlerini kullanmak doğrudur.\n\n\nİndekslenmiş veri\nAşağıda, vaka satır listesinde slide_index_dbl() fonksiyonunu kullanan bir örnek gösterilmiştir. Diyelim ki hedefimiz 7 günlük bir insidansı hesaplamak (7 günlük bir pencere kullanarak vakaların toplamını göstermek). Yuvarlanan ortalama örneği için, gruplandırılmış yuvarlanma ile ilgili aşağıdaki bölüme bakın.\nBaşlamak için, dplyr’den count() fonksiyonu ile hesaplandığı gibi, satır listesinde günlük vaka sayılarını göstermek için daily_counts veri kümesi oluşturulur.\n\n# günlük sayımların veri kümesini oluştur\ndaily_counts &lt;- linelist %&gt;% \n  count(date_hospitalisation, name = \"new_cases\")\n\ndaily_counts veri çerçevesinden nrow(daily_counts) satır elde edilebilir. Günlük vaka sayısında her gün bir satırla temsil edilmektedir, ancak özellikle salgının başlarında bazı günler mevcut değil (o günlerde vaka tespit edilmemiştir).\n\n\n\n\n\n\nStandart bir yuvarlanma işlevinin (slide_dbl() gibi) 7 günlük değil 7 satırlık bir pencere kullanacağını bilmek önemlidir. Dolayısıyla, eksik tarihler varsa, bazı pencereler aslında 7 takvim gününden daha fazla uzatılacaktır!\nslide_index_dbl() ile “akıllı” bir yuvarlanma penceresi elde edilebilir. “İndeks”, işlevin yuvarlanan pencere için “indeks” olarak alacağı ayrı bir sütun kullandığı anlamına gelir. Pencere sadece veri çerçevesinin satırlarına bağlı değildir.\nİndeks sütunu bir tarihse, pencere içeriğini lubridate days() veya month() fonksiyonları ile .before = ve/veya .after = olarak belirtebilirsiniz. Bu durumda fonksiyon, pencerede olmayan günleri sanki oradaymış gibi (NA değerleri olarak) kabul edecektir.\nBir karşılaştırma gösterilirse. Aşağıda, düzenli ve indekslenmiş pencerelerle 7 günlük vaka insidansını hesaplıyoruz.\n\nrolling &lt;- daily_counts %&gt;% \n  mutate(                                # yeni sütunlar oluştur\n    # Using slide_dbl()\n    ###################\n    reg_7day = slide_dbl(\n      new_cases,                         # new_cases üzerinde hesapla\n      .f = ~sum(.x, na.rm = T),          # fonksiyon, eksik değerler kaldırılmış sum() işlemidir\n      .before = 6),                      # pencere mevcut SATIR ve 6 önceki SATIR\n    \n    # slide_index_dbl() kullanımı\n    #########################\n    indexed_7day = slide_index_dbl(\n        new_cases,                       # new_cases üzerinde hesapla\n        .i = date_hospitalisation,       # date_onset ile indekse eklenme \n        .f = ~sum(.x, na.rm = TRUE),     # fonksiyon, eksik değerlerin olmadığı sum() işlevidir\n        .before = days(6))               # pencere mevcut GÜN ve 6 önceki GÜN\n    )\n\nİlk 7 satır için normal sütunda, satırlar birbirine için 7 günlük aralık içinde olmamasına rağmen istikrarlı artışı gözlemleyin! Komşu “indekslenmiş” sütun, eksik takvim günlerini de hesaba katar, bu nedenle 7 günlük toplamları, vakaların birbirlerinden daha uzak zamanlarda görüldüğü salgın döneminde çok daha düşüktür.\n\n\n\n\n\n\nBu veri, ggplot() fonksiyonu kullanılarak grafik haline getirilebilir.\n\nggplot(data = rolling)+\n  geom_line(mapping = aes(x = date_hospitalisation, y = indexed_7day), size = 1)\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGruba göre yuvarlanma\nslider fonksiyonlarını kullanmadan önce verilerinizi gruplandırırsanız, kayan pencereler grup olarak uygulanacaktır. Satırlarınızı grup bazında istediğiniz sıraya göre düzenlemeye özen gösteriniz.\nHer yeni grup başladığında, kayan pencere yeniden başlayacaktır. Bu nedenle, bilinmesi gereken bir ayrıntı vardır. Verileriniz gruplandırılmışsa ve .complete = TRUE olarak ayarladıysanız, gruplar arasındaki her geçişte boş değerler elde edersiniz. Fonksiyon satırlar arasında aşağı doğru hareket ettikçe, gruplandırma sütunundaki her geçiş, hesaplamaya izin vermek için minimum pencere boyutunun oluşturulma sürecini yeniden başlatacaktır.\nVerileri gruplandırmayla ilgili ayrıntılar için [Verilerin Gruplandırılması] ile ilgili el kitabı sayfasına bakın.\nAşağıda, listedeki vakaları tarihe ve hastaneye göre sayıyoruz. Daha sonra sıraları artan şekilde, önce hastaneye göre sonra da tarihe göre sıralamaktayız. Sonrasında group_by() fonksiyonunu ayarlıyoruz. Ardından yeni yuvarlanan ortalamamızı oluşturabiliriz.\n\ngrouped_roll &lt;- linelist %&gt;%\n\n  count(hospital, date_hospitalisation, name = \"new_cases\") %&gt;% \n\n  arrange(hospital, date_hospitalisation) %&gt;%   # satırları hastaneye ve ardından tarihe göre düzenle\n  \n  group_by(hospital) %&gt;%              # hastaneye göre grupla\n    \n  mutate(                             # yuvarlanan ortalama  \n    mean_7day_hosp = slide_index_dbl(\n      .x = new_cases,                 # hastane-gün başına vaka sayısı\n      .i = date_hospitalisation,      # giriş tarihi indeksi\n      .f = mean,                      # mean() kullanımı                  \n      .before = days(6)               # mevcut günü ve önceki 6 günü kullan\n      )\n  )\n\nİşte yeni veri seti:\n\n\n\n\n\n\nArtık ggplot() içinde ~ hastaneyi - hospital facet_wrap() içinde belirterek verileri grup bazında görüntüleyerek hareketli ortalamaları çizebiliriz. Burada iki şekil oluşturuyoruz - günlük vaka sayılarını gösteren bir geom_col() ve 7 günlük hareketli ortalamayı gösteren bir geom_line().\n\nggplot(data = grouped_roll)+\n  geom_col(                       # günlük vaka sayılarını gri çubuklar olarak çiz\n    mapping = aes(\n      x = date_hospitalisation,\n      y = new_cases),\n    fill = \"grey\",\n    width = 1)+\n  geom_line(                      # hastaneye göre renklendirilen çizgi olarak yuvarlanan ortalama grafiği\n    mapping = aes(\n      x = date_hospitalisation,\n      y = mean_7day_hosp,\n      color = hospital),\n    size = 1)+\n  facet_wrap(~hospital, ncol = 2)+ # hastane başına mini grafikler oluştur\n  theme_classic()+                 # arka planı basitleştir  \n  theme(legend.position = \"none\")+ # çizelgeyi (legend) kaldır\n  labs(                            # grafik etiketlerini ekle\n    title = \"7-day rolling average of daily case incidence\",\n    x = \"Date of admission\",\n    y = \"Case incidence\")\n\n\n\n\n\n\n\n\n**TEHLİKE:_** “slide() tsibble 0.9.0’da kullanımdan kaldırılmıştır ve artık geçersizdir” şeklinde bir hata alırsanız, lütfen bunun yerine slider::slide() kullanın. Bu, tsibble paketindeki slide() fonksiyonunun, slider paketindeki slide() fonksiyonunu maskelediği anlamına gelir. Slider::slide_dbl() şekklinde komutunuzda paketi belirterek bu hatayı düzeltin.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Hareketli ortalamalar</span>"
    ]
  },
  {
    "objectID": "new_pages/moving_average.tr.html#ggplot-içinde-tidyquant-hesabı",
    "href": "new_pages/moving_average.tr.html#ggplot-içinde-tidyquant-hesabı",
    "title": "22  Hareketli ortalamalar",
    "section": "22.3 ggplot() içinde tidyquant hesabı",
    "text": "22.3 ggplot() içinde tidyquant hesabı\ntidyquant paketi, bir ggplot() komutunun içinde hareketli ortalamaları hesaplamak için başka bir yaklaşım sunar.\nSatır listesinin altındaki veriler, başlangıç tarihine göre sayılır ve soluk bir çizgi (alpha &lt; 1) olarak çizilir. Üstte, tidyquant paketinden geom_ma() ile oluşturulan, belirtilen renk ve kalınlıkta 7 günlük (n = 7) pencereli bir satır yer alır.\nVarsayılan olarak geom_ma() basit hareketli ortalama kullanır (ma_fun = \"SMA\"), ancak başka türler de belirtilebilir, örneğin:\n\n“EMA” - üstel hareketli ortalama (son gözlemlere daha fazla ağırlık verilir)\n\n“WMA” - ağırlıklı hareketli ortalama (ağırlık, hareketli ortalamadaki gözlemleri ağırlıklandırmak için kullanılır)\n\nDiğerleri fonksiyon belgelerinde bulunabilir\n\n\nlinelist %&gt;% \n  count(date_onset) %&gt;%                 # gün başına vaka sayımı\n  drop_na(date_onset) %&gt;%               # başlangıç tarihi eksik vakaları kaldır\n  ggplot(aes(x = date_onset, y = n))+   # ggplot’u başlat\n    geom_line(                          # ham değerleri çiz\n      size = 1,\n      alpha = 0.2                       # yarı şeffaf çizgi\n      )+             \n    tidyquant::geom_ma(                 # hareketli ortalama grafiği çiz\n      n = 7,           \n      size = 1,\n      color = \"blue\")+ \n  theme_minimal()                       # sade arka plan\n\nWarning: Using the `size` aesthetic in this geom was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` in the `default_aes` field and elsewhere instead.\n\n\n\n\n\n\n\n\n\ntidyquant’ta bulunan seçenekler hakkında daha fazla ayrıntı için bu skece bakın.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Hareketli ortalamalar</span>"
    ]
  },
  {
    "objectID": "new_pages/moving_average.tr.html#kaynaklar",
    "href": "new_pages/moving_average.tr.html#kaynaklar",
    "title": "22  Hareketli ortalamalar",
    "section": "22.4 Kaynaklar",
    "text": "22.4 Kaynaklar\nslider paketi için yararlı çevrimiçi skeç\nslider github sayfası\nslider skeci\ntidyquant skeci\nHafta sonlarını ve tatilleri “atlamanızı” gerekiyorsa, almanac paketini kullabilirsiniz.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Hareketli ortalamalar</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.tr.html",
    "href": "new_pages/time_series.tr.html",
    "title": "23  Zaman serileri ve salgınların tespit edilmesi",
    "section": "",
    "text": "23.1 Genel bakış\nBu sekme, zaman serisi analizi için gereken birkaç paketin kullanımını göstermektedir. Bu tip analizler öncelikle tidyvers tidyverts ailesinden gelen paketlerle yapılır, ancak bulaşıcı hastalık epidemiyolojisi için daha uygun olan RECON trend paketini trending de kullanır.\nAşağıdaki örnekte, Almanya’da hazırlanmış Campylobacter bir veri setini kullandığımıza dikkat edin (ayrıntılar için el kitabının veri bölümüne bakabilirsiniz). Ancak, aynı kodu birden fazla ülke veya başka tabakalar içeren bir veritabanlarında çalıştırmak istiyorsanız, r4epis github deposunda örnek bir kod şablonu bulunmaktadır.r4epis github repo.\nKapsanan konular:",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Zaman serileri ve salgınların tespit edilmesi</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.tr.html#genel-bakış",
    "href": "new_pages/time_series.tr.html#genel-bakış",
    "title": "23  Zaman serileri ve salgınların tespit edilmesi",
    "section": "",
    "text": "Zaman serisi verileri\nTanımlayıcı analiz\nUyum (fitting) regresyonları\nİki zaman serisinin ilişkisi\nSalgın tespiti\nKesintili zaman serisi",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Zaman serileri ve salgınların tespit edilmesi</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.tr.html#hazırlık",
    "href": "new_pages/time_series.tr.html#hazırlık",
    "title": "23  Zaman serileri ve salgınların tespit edilmesi",
    "section": "23.2 Hazırlık",
    "text": "23.2 Hazırlık\n\nPaketler\nBu kod kümesi, analizler için gereken paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’ın p_load() fonksiyonunu vurguluyoruz. Ayrıca temel R’dan library() ile paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R temelleri sayfasına bakın. R temelleri\n\npacman::p_load(rio,          # Dosyanın içe aktarılması\n               here,         # Dosyanın yerinin bulunması\n               tidyverse,    # veri yönetimi + ggplot2 grafikleri\n               tsibble,      # zaman serisi veri tabanlarını işlemek\n               slider,       # hareketli ortalamaları hesaplamak için\n               imputeTS,     # eksik değerleri doldurmak için\n               feasts,       # zaman serilerinde ayrıştırma ve otokorelasyon için\n               forecast,     # sin ve cosin terimlerini verilere uydurun (not: feasts sonrası yüklenmelidir)\n               trending,     # model oluştur ve değerlendir\n               tmaptools,    # yer adlarına göre coğrafi koordinatları (boylam/enlem) almak için\n               ecmwfr,       # copernicus uydu CDS API ile etkileşim için\n               stars,        # .nc (iklim verileri) dosyalarını okumak için\n               units,        # for defining units of measurement (climate data)\n               yardstick,    # model doğruluğuna bakmak için\n               surveillance  # sapma tespiti için\n               )\n\n\n\nVeri yükleme\nBu el kitabında kullanılan tüm verileri, [el kitabının ve verilerin indirilmesi] sayfasındaki talimatlar aracılığıyla indirebilirsiniz.\nBu bölümde kullanılan örnek veri seti, 2001 ve 2011 yılları arasında Almanya’da rapor edilen haftalık kampilobakter vaka sayılarıdır. Bu veri dosyasını (.xlsx) indirmek için buraya tıklayabilirsiniz.(.xlsx) olarak görülecektir.\nBu veri seti, surveillance paketinde bulunan veri setinin küçültülmüş bir versiyonudur. (detaylar için surveillance paketini yükleyin ve bkz. ?campyDE) surveillance\nBu verileri rio paketinden import() fonksiyonu ile içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe Aktarma ve Dışa Aktarma] sayfasına bakın).\n\n# sayımları R'ye aktar\ncounts &lt;- rio::import(\"campylobacter_germany.xlsx\")\n\nSayımların ilk 10 satırı aşağıda gösterilmiştir\n\n\n\n\n\n\n\n\nTemiz veri\nAşağıdaki kod, tarih sütununun uygun biçimde olmasını sağlar. Bu sekme için tsibble paketini kullanacağız ve bu nedenle bir takvim haftası değişkeni oluşturmak için yearweek fonksiyonu kullanılacaktır. Bunu yapmanın başka yolları da vardır (ayrıntılar için Tarihlerle çalışma sayfasına bakın), ancak zaman serileri için en iyisi tarihleri tek bir çerçeve (tsibble) içinde tutmaktır.\n\n## tarih sütununun uygun biçimde olduğundan emin olun\ncounts$date &lt;- as.Date(counts$date)\n\n## bir takvim haftası değişkeni oluşturun\n## Pazartesi gününden başlayarak haftaların ISO tanımlarına uyumlu hale getirilmesi\ncounts &lt;- counts %&gt;% \n     mutate(epiweek = yearweek(date, week_start = 1))\n\n\n\nİklim verisinin indirilmesi\nBu sayfanın iki zaman serisi bölümünde, kampilobakter vaka sayılarını iklim verileriyle karşılaştıracağız. Dünyanın herhangi bir yerindeki iklim verileri AB’nin Copernicus Uydusundan indirilebilir.\nBunlar kesin ölçümler değildir, ancak bir modele dayalıdır (interpolasyona benzer), tahminlerin yanı sıra küresel saatlik bilgi kapsamı elde edilebilir.\nBu iklim veri dosyalarının her birini [el kitabının ve verilerin indirilmesi] sayfasından indirebilirsiniz.\nBurada gösterim amacıyla, verileri Copernicus iklim veri deposundan çekmek için ecmwfr paketini kullanmak için gereken R kodunu tanıtacağız. Bunun çalışması için ücretsiz bir hesap oluşturmanız gerekecektir. Paketin web sitesinde bunun nasıl yapılacağına dair yararlı bir yol gösterilmiştirwalkthrough.\nAşağıda, uygun API anahtarlarına sahip olduğunuzda, bunun nasıl yapılacağına ilişkin örnek kod verilmiştir. Aşağıdaki X’leri hesap kimliklerinizle değiştirmeniz gerekir. Her seferinde bir yıllık veri indirmeniz gerekir, aksi takdirde sunucu zaman aşımına uğrayacaktır.\nVerilerini indirmek istediğiniz konumun koordinatlarından emin değilseniz, açık sokak haritalarından koordinatları almak için tmaptools paketini kullanabilirsiniz. Alternatif bir seçenek photon paketidir,photon ancak bu henüz CRAN’da yayınlanmamıştır; photon’un güzel yanı, aramanız için birkaç eşleşme olduğunda daha fazla bağlamsal veri sağlamasıdır.\n\n## konum koordinatlarını al\ncoords &lt;- geocode_OSM(\"Germany\", geometry = \"point\")\n\n## ERA-5 sorgulaması için boylamları/enlemleri bir araya getirin (sınırlayıcı kutu)\n## (tek bir noktanın koordinatlarının tekrar edebileceği gibi)\nrequest_coords &lt;- str_glue_data(coords$coords, \"{y}/{x}/{y}/{x}\")\n\n\n## Kopernik uydusundan modellenen verileri çekme (ERA-5 yeniden analizi)\n## https://cds.climate.copernicus.eu/cdsapp#!/software/app-era5-explorer?tab=app\n## https://github.com/bluegreen-labs/ecmwfr\n\n## hava durumu verileri için anahtar ayarla\nwf_set_key(user = \"XXXXX\",\n           key = \"XXXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXX\",\n           service = \"cds\") \n\n## ilgilenilen her yıl için çalıştırın (aksi takdirde sunucu zaman aşımına uğrar)\nfor (i in 2002:2011) {\n  \n  ## sorguyu bir araya getir\n  ## nasıl yapılacağı için buraya bakın: https://bluegreen-labs.github.io/ecmwfr/articles/cds_vignette.html#the-request-syntax\n  ## yukarıdaki eklenti düğmesini kullanarak isteği bir listeye dönüştürün (listeye python)\n  ## Hedef, çıktı dosyasının adıdır!\n\n  request &lt;- request &lt;- list(\n    product_type = \"reanalysis\",\n    format = \"netcdf\",\n    variable = c(\"2m_temperature\", \"total_precipitation\"),\n    year = c(i),\n    month = c(\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\"),\n    day = c(\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\",\n            \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\",\n            \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\"),\n    time = c(\"00:00\", \"01:00\", \"02:00\", \"03:00\", \"04:00\", \"05:00\", \"06:00\", \"07:00\",\n             \"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\", \"13:00\", \"14:00\", \"15:00\",\n             \"16:00\", \"17:00\", \"18:00\", \"19:00\", \"20:00\", \"21:00\", \"22:00\", \"23:00\"),\n    area = request_coords,\n    dataset_short_name = \"reanalysis-era5-single-levels\",\n    target = paste0(\"germany_weather\", i, \".nc\")\n  )\n  \n # dosyayı indirin ve mevcut çalışma dizininde saklayın\n  file &lt;- wf_request(user     = \"XXXXX\",  # kullanıcı ID (kimlik doğrulama için)\n                     request  = request,  # istek\n                     transfer = TRUE,     # dosyayı indir \n                     path     = here::here(\"data\", \"Weather\")) ## dosyayı kaydetmek için yolak\n  }\n\n\n\nİklim verisinin yüklenmesi\nİster iklim verilerini el kitabımız üzerinden indirmiş olun, ister yukarıdaki kodu kullanmış olun, artık bilgisayarınızda aynı klasörde saklanan 10 yıllık “.nc” iklim veri dosyalarına sahip olmalısınız.\nBu dosyaları stars paketiyle R’a aktarmak için aşağıdaki kodu kullanın.\n\n## hava durumu klasörüne giden yolu tanımlayın \nfile_paths &lt;- list.files(\n  here::here(\"data\", \"time_series\", \"weather\"), # replace with your own file path \n  full.names = TRUE)\n\n## sadece şu anki ilgi alanına sahip olanları saklayın\nfile_paths &lt;- file_paths[str_detect(file_paths, \"germany\")]\n\n## tüm dosyaları stars nesnesi olarak oku\ndata &lt;- stars::read_stars(file_paths)\n\nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \n\n\nBu dosyalar nesne verisi olarak içe aktarıldıktan sonra onları bir veri çerçevesine dönüştüreceğiz.\n\n## veri çerçevesine değiştir\ntemp_data &lt;- as_tibble(data) %&gt;% \n  ## değişkenler ekleyin ve birimleri düzeltin\n  mutate(\n    ## takvim haftası değişkeni oluşturun\n    epiweek = tsibble::yearweek(time), \n    ## tarih değişkeni oluşturun (takvim haftasının başlangıcı)\n    date = as.Date(epiweek),\n    ## sıcaklığı kelvin'den santigrat dereceye değiştir\n    t2m = set_units(t2m, celsius), \n    ## yağışı metreden milimetreye değiştir\n    tp  = set_units(tp, mm)) %&gt;% \n  ## haftaya göre gruplandır (tarihi de sakla)\n  group_by(epiweek, date) %&gt;% \n  ## haftalık ortalamanın özetlenmesi\n  summarise(t2m = as.numeric(mean(t2m)), \n            tp = as.numeric(mean(tp)))\n\n`summarise()` has grouped output by 'epiweek'. You can override using the\n`.groups` argument.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Zaman serileri ve salgınların tespit edilmesi</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.tr.html#zaman-serisi-verisi",
    "href": "new_pages/time_series.tr.html#zaman-serisi-verisi",
    "title": "23  Zaman serileri ve salgınların tespit edilmesi",
    "section": "23.3 Zaman serisi verisi",
    "text": "23.3 Zaman serisi verisi\nZaman serisi verilerini yapılandırmak ve işlemek için bir dizi farklı paket vardır. Bahsedildiği gibi, tidyverts paket ailesine odaklanacağız ve bu nedenle zaman serisi nesnemizi tanımlamak için tsibble paketini kullanacağız. Zaman serisi nesnesi olarak tanımlanan bir veri setine sahip olmak, analizimizi yapılandırmanın çok daha kolay olduğu anlamına gelir.\nBunu yapmak için tsibble() fonksiyonunu kullanırız ve “indeks”i, yani ilgilenilen zaman birimini belirten değişkeni belirtiriz. Bizim durumumuzda bu, epiweek değişkenidir.\nÖrneğin, il bazında haftalık sayıları olan bir veri setimiz olsaydı, key = değişkenini kullanarak gruplama değişkenini de belirleyebilirdik. Bu, her grup için analiz yapmamızı sağlar.\n\n## zaman serisi nesnesini tanımla\ncounts &lt;- tsibble(counts, index = epiweek)\n\nclass(counts)’a baktığınızda, düzenli bir veri çerçevesi (“tbl_df”, “tbl”, “data.frame”) olmanın yanı sıra, bir zaman serisi veri çerçevesinin (“tbl_ts”) ek özelliklerine sahip olduğunu gösterir.\nggplot2 kullanarak verilerinize hızlıca göz atabilirsiniz. Olay örgüsünde net bir mevsimsel motif olduğunu ve eksik veri olmadığını görüyoruz. Ancak, her yılın başında raporlama ile ilgili bir sorun var gibi görünüyor; vakalar yılın son haftasında düşmekte ve sonraki yılın ilk haftasında artmaktadır.\n\n## haftaya göre vakaların bir çizgi grafiğini çizin\nggplot(counts, aes(x = epiweek, y = case)) + \n     geom_line()\n\n\n\n\n\n\n\n\nTEHLİKE: Çoğu veri kümesi bu örnek kadar temiz değildir. Aşağıdaki gibi duplikasyonları ve eksikleri kontrol etmeniz gerekecektir. \n\n\nDuplikasyonlar\ntsibble yinelenen gözlemlere izin vermez. Bu nedenle, her satırın benzersiz veya (anahtar değişkene göre) grup içinde benzersiz olması gerekir. Paket, kopyaları tanımlamaya yardımcı olan birkaç işleve sahiptir. Bunlar, satırın bir kopya olup olmadığına dair bir DOĞRU/YANLIŞ vektörü veren are_duplicated() ve size duplike satırların veri çerçevesini veren duplicates() fonksiyonlarını içerir.\nİstediğiniz satırları nasıl seçeceğinizle ilgili daha fazla ayrıntı için Tekilleştirme (De-duplikasyon) sayfasına bakabilirsiniz. Tekilleştirme\n\n## satırların kopya olup olmadığını DOĞRU/YANLIŞ vektörü olarak çıkarın\nare_duplicated(counts, index = epiweek) \n\n## yinelenen satırların veri çerçevesini çıkarın\nduplicates(counts, index = epiweek) \n\n\n\n\nEksikler\nYukarıdaki kısa incelememizde hiçbir eksik olmadığını gördük, ancak yeni yıl civarında raporlama gecikmesinde bir sorun olduğunu da gördük. Bu sorunu çözmenin bir yolu, bu değerleri eksik olarak ayarlamak ve ardından değerleri atfetmek olabilir. Zaman serisi atamasının en basit şekli, en son kayıp olmayan ve bir sonraki kayıp olmayan değer arasına düz bir çizgi çizmektir. Bunu yapmak için imputeTS paketinden na_interpolation() fonksiyonunu kullanacağız.\nTahmin için değerler atamada diğer seçenekler için Eksik veri sayfasına bakabilirsiniz.\nDiğer bir alternatif, hareketli ortalama hesaplamak, belirgin raporlama sorunlarını denemek ve düzeltmek olabilir (bir sonraki bölüme ve Hareketli ortalamalar sayfasına bakın)Hareketli ortalamalar).\n\n## raporlama sorunları olan haftalar yerine eksikleri olan bir değişken oluşturun\ncounts &lt;- counts %&gt;% \n     mutate(case_miss = if_else(\n          ## epiweek 52, 53, 1 veya 2 içeriyorsa\n          str_detect(epiweek, \"W51|W52|W53|W01|W02\"), \n          ## sonrasında eksik olarak ayarlayın\n          NA_real_, \n          ## aksi takdirde değeri saklayın\n          case\n     ))\n\n## alternatif olarak eksikleri doğrusal trendle interpolasyon yapın\n## en yakın iki bitişik nokta arasında\ncounts &lt;- counts %&gt;% \n  mutate(case_int = imputeTS::na_interpolation(case_miss)\n         )\n\n## orijinaline kıyasla hangi değerlerin atfedildiğini (impute) kontrol etmek için\nggplot_na_imputations(counts$case_miss, counts$case_int) + \n  ## geleneksel bir grafik oluşturun (siyah eksenli ve beyaz arka planlı)\n  theme_classic()",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Zaman serileri ve salgınların tespit edilmesi</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.tr.html#tanımlayıcı-analizler",
    "href": "new_pages/time_series.tr.html#tanımlayıcı-analizler",
    "title": "23  Zaman serileri ve salgınların tespit edilmesi",
    "section": "23.4 Tanımlayıcı analizler",
    "text": "23.4 Tanımlayıcı analizler\n\n\nHareketli ortalamalar\nVeriler çok gürültülüyse (yukarı ve aşağı atlamalar sayılır), hareketli bir ortalama hesaplamak yardımcı olabilir. Aşağıdaki örnekte, her hafta için önceki dört haftadaki ortalama vaka sayısını hesaplıyoruz. Bu hesap ile, verilerin daha yorumlanabilir hale gelmesi için düzeltme yapılır. Örneğimiz için bu düzeltmenin faydası kısıtlıdır, bu yüzden daha fazla analiz için interpolasyonlu verilere bağlı kalınacaktuır. Daha fazla ayrıntı için Hareketli ortalamalar sayfasına bakın. Hareketli ortalamalar.\n\n## hareketli bir ortalama değişkeni oluşturun (eksiklerle ilgilenilecektir)\ncounts &lt;- counts %&gt;% \n     ## ma_4w değişkenini oluştur\n     ## case değişkeninin her satırının üzerine kaydırın\n     mutate(ma_4wk = slider::slide_dbl(case, \n                               ## her satır için ad hesapla\n                               ~ mean(.x, na.rm = TRUE),\n                               ## önceki dört haftayı kullan\n                               .before = 4))\n\n## farkını hızla görselleştirin \nggplot(counts, aes(x = epiweek)) + \n     geom_line(aes(y = case)) + \n     geom_line(aes(y = ma_4wk), colour = \"red\")\n\n\n\n\n\n\n\n\n\n\n\nPeriyodisite\nAşağıda bir periodogram oluşturmak için özel bir fonksiyon tanımlıyoruz. R’de fonksiyonların nasıl yazılacağı hakkında bilgi için Fonksiyon yazma sayfasına bakın.\nİlk olarak fonksiyon tanımlanır. Fonksiyonun argümanları, sütun sayıları olan bir veri tabanını, veri tabanının ilk haftası olan başlangıç_haftası =, yılda kaç periyot olduğunu gösteren bir sayıyı (örneğin 52, 12) ve son olarak çıktı stilini içerir (aşağıdaki koddaki ayrıntılara bakın).\n\n## Fonksiyonun argümanları\n#####################\n## x veritabanıdır\n## x içindeki oranlar ya da sayımlar değişkendir\n## start_week is the first week in your dataset\n## periyot bir yıldaki birim sayısıdır \n## çıktı, dönüş spektral periodogramı ya da peak görülen haftalardır.\n  ## \"periodogram\" veya \"weeks\"\n\n# Fonksiyonu tanımlamak\nperiodogram &lt;- function(x, \n                        counts, \n                        start_week = c(2002, 1), \n                        period = 52, \n                        output = \"weeks\") {\n  \n\n    ## bir tsibble olmadığından emin olun, projeye filtre uygulayın ve yalnızca ilgilenilen sütunları tutun\n    prepare_data &lt;- dplyr::as_tibble(x)\n    \n    # veriyi hazırla &lt;- prepare_data[prepare_data[[strata]] == j, ]\n    prepare_data &lt;- dplyr::select(prepare_data, {{counts}})\n    \n    ## spec.pgram ile kullanılabilecek bir ara zaman serisi (“zoo”) oluşturun\n    zoo_cases &lt;- zoo::zooreg(prepare_data, \n                             start = start_week, frequency = period)\n    \n    ## hızlı fourier dönüşümü kullanmayan bir spektral periodogram elde edin\n    periodo &lt;- spec.pgram(zoo_cases, fast = FALSE, plot = FALSE)\n    \n    ## pieak haftaları elde edin \n    periodo_weeks &lt;- 1 / periodo$freq[order(-periodo$spec)] * period\n    \n    if (output == \"weeks\") {\n      periodo_weeks\n    } else {\n      periodo\n    }\n    \n}\n\n## en yüksek frekanslara sahip haftaları çıkarmak için spektral periodogram alın\n## (mevsimsellik kontrolü)\nperiodo &lt;- periodogram(counts, \n                       case_int, \n                       start_week = c(2002, 1),\n                       output = \"periodogram\")\n\n## görselleştirme için bir veri çerçevesine tam spektrum ve frekans yerleştirilir\nperiodo &lt;- data.frame(periodo$freq, periodo$spec)\n\n## en sık meydana gelen periyodikliği gösteren bir periodogram çizin\nggplot(data = periodo, \n                aes(x = 1/(periodo.freq/52),  y = log(periodo.spec))) + \n  geom_line() + \n  labs(x = \"Period (Weeks)\", y = \"Log(density)\")\n\n\n\n\n\n\n\n## haftaları içeren vektörü artan sırayla elde edin \npeak_weeks &lt;- periodogram(counts, \n                          case_int, \n                          start_week = c(2002, 1), \n                          output = \"weeks\")\n\nNOT: Yukarıdaki haftaları sinüs ve kosinüs terimlerine eklemek mümkündür, ancak bu terimleri oluşturmak için bir fonksiyon kullanacağız (aşağıdaki regresyon bölümüne bakınız) \n\n\n\nAyrıştırma\nKlasik ayrıştırma, bir zaman serisini parçalara ayırmak için kullanılır ve bu parçalar birlikte gördüğünüz modeli oluşturur. Bu farklı parçalar şunlardır:\n• Trend döngüsü (verinin uzun vadeli seyri) • Mevsimsellik (tekrarlanan modeller) • Rastgele (trend ve sezon çıkarıldıktan sonra kalan)\n\n## sayımlar veri tabanını ayrıştır \ncounts %&gt;% \n  # additif klasik ayrıştırma modeli uygula \n  model(classical_decomposition(case_int, type = \"additive\")) %&gt;% \n  ## önemli bilgileri modelden çıkarın\n  components() %&gt;% \n  ## grafik oluştur \n  autoplot()\n\n\n\n\n\n\n\n\n\n\n\nOtokorelasyon\nOtokorelasyon size her haftadaki sayımlar ile önceki haftalardaki sayımlar (gecikme olarak adlandırılır) arasındaki ilişkiyi anlatır.\nACF() fonksiyonunu kullanarak, farklı gecikmelerdeki ilişkiyi bize bir dizi çizgi gösteren bir grafik oluşturabiliriz. Gecikmenin 0 (x = 0) olduğu yerde, çizgi gözlem ile kendisi arasındaki ilişkiyi gösterdiğinden (burada gösterilmemiştir) her zaman 1 olacaktır. Burada gösterilen ilk satır (x = 1), her gözlem ile bir önceki gözlem arasındaki ilişkiyi gösterir (1 gecikme), ikincisi gözlem ile iki önceki gözlem arasındaki ilişkiyi gösterir (2 gecikme) ve gecikme sayıları bu şekilde artarak devam eder (Her bir gözlem ile 1 yıllık (52 hafta öncesi) gözlem arasındaki ilişkiyi gösteren 52’ye kadar)\nPACF() fonksiyonunun kullanılması (kısmi otokorelasyon için) aynı ilişkiyi gösterir, ancak aradaki diğer tüm haftalar için ayarlanmış bir ölçüttür. Kısmi otokorelasyon, periyodikliği belirlemek için daha az yararlıdır.\n\n## sayım veri tabanını kullanma\ncounts %&gt;% \n  ## yıl içindeki gecikmeleri kullanarak otokorelasyonu hesaplayın\n  ACF(case_int, lag_max = 52) %&gt;% \n  ## grafik oluşturun\n  autoplot()\n\n\n\n\n\n\n\n## sayım veri tabanını kullanma \ncounts %&gt;% \n  ## yıl içindeki gecikmeleri kullanarak kısmi otokorelasyonu hesaplayın\n  PACF(case_int, lag_max = 52) %&gt;% \n  ## grafik oluşturun\n  autoplot()\n\n\n\n\n\n\n\n\nLjung-Box testini (stats paketinde) kullanarak zaman serisinde null hipotezini (yani otokorelasyonlu olup olmadığı) test edebilirsiniz. Anlamlı bir p değeri, verilerde otokorelasyon olduğunu gösterir.\n\n## bağımsızlık testi \nBox.test(counts$case_int, type = \"Ljung-Box\")\n\n\n    Box-Ljung test\n\ndata:  counts$case_int\nX-squared = 462.65, df = 1, p-value &lt; 2.2e-16",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Zaman serileri ve salgınların tespit edilmesi</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.tr.html#uyum-regresyonları",
    "href": "new_pages/time_series.tr.html#uyum-regresyonları",
    "title": "23  Zaman serileri ve salgınların tespit edilmesi",
    "section": "23.5 Uyum regresyonları",
    "text": "23.5 Uyum regresyonları\nBir zaman serisine çok sayıda farklı regresyon sığdırmak mümkündür, ancak burada negatif iki terimli regresyonun nasıl sığdırılacağını göstereceğiz - çünkü bu genellikle bulaşıcı hastalıklardaki sayım verileri için en uygun olanıdır.\n\n\nFourier terimleri\nFourier terimleri, sinüs ve kosinüs eğrilerinin eş epi hafta ve case_int değişkenlerini kullanarak fourier terimleri ekleyindeğeridir. Aradaki fark, bu terimlerin verilerinizi açıklamak için en uygun eğri kombinasyonunu bulmaya dayalı bulunmasıdır.\nYalnızca bir fourier terimine kullanacak olsaydınız, periodogramınızda görülen en sık meydana gelen gecikmeniz için (bizim durumumuzda 52 hafta) bir sinüs ve bir kosinüs kullanmaya eşdeğer olacaktır. Forecast paketindeki fourier() fonksiyonunu kullanıyoruz.\nAşağıdaki kodda $ operatörünü kullanarak atadık, çünkü fourier() iki sütun oluşturur (biri sinüs, diğeri kosinüs için) ve bu nedenle bunlar veri tabanına “fourier” adı verilen bir liste olarak eklenir - ancak bu liste daha sonra regresyonda normal bir değişken olarak kullanılabilir:\n\n## epi hafta ve case_int değişkenlerini kullanarak fourier terimleri ekleyin\ncounts$fourier &lt;- select(counts, epiweek, case_int) %&gt;% \n  fourier(K = 1)\n\n\n\n\nNegatif binomial\nTemel istatistik (base stats) veya MASS fonksiyonlarını (örn. lm(), glm() ve glm.nb()) kullanarak uyumlu regresyonlar oluşturmak mümkündür. Bununla birlikte, uygun güven ve tahmin aralıklarının (aksi takdirde mevcut olmayan) hesaplanmasına izin verdiği için, trending paketindeki fonksiyonları kullanacağız. Bu fonksiyonların sintaksı aynıdır ve bir çıktı değişkeni, ardından bir tilde (~) belirtir ve ardından artı (+) ile ayırarak ilgilendiğiniz çeşitli maruz kalma değişkenlerinizi eklersiniz.\nDiğer fark, önce modeli tanımlamamız ve ardından onu verilere fit() ile uydurmamızdır. Bu, aynı sintaksa sahip birden çok farklı modeli karşılaştırmaya izin verdiği için yararlıdır.\nİPUCU: Sayılar yerine oranları kullanmak istiyorsanız, offset(log(population) terimini ekleyerek popülasyon değişkenini logaritmik bir offset terimi olarak dahil edebilirsiniz. Bu durumda bir oran oluşturmak için predict() fonksiyonunu kullanmadan önce popülasyonu 1 olarak ayarlamanız gerekir. \nİPUCU: ARIMA veya prophet gibi daha karmaşık modelleri uygulamak için fable paketine bakAbilirsiniz. fable.\n\n## uydurmak istediğiniz modeli tanımlayın (negatif binom)\nmodel &lt;- glm_nb_model(\n  ## ilgilenilen sonuç olarak vaka sayısını belirlemek\n  case_int ~\n    ## trendi hesaba katmak için epiweek'i kullanın\n    epiweek +\n    ## mevsimselliği hesaba katmak için fourier terimlerini kullanın\n    fourier)\n\n## sayım veri tabanını kullanarak modelinize uydurun\nfitted_model &lt;- trending::fit(model, data.frame(counts))\n\n## güven ve tahmin aralıklarını hesaplayın\nobserved &lt;- predict(fitted_model, simulate_pi = FALSE)\n\nestimate_res &lt;- data.frame(observed$result)\n\n## regresyonunuzu görselleştirin \nggplot(data = estimate_res, aes(x = epiweek)) + \n  ## model tahmini için bir satır ekleyin\n  geom_line(aes(y = estimate),\n            col = \"Red\") + \n  ## tahmin aralıkları için bir bant ekleyin\n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## gözlemlenen vaka sayılarınız için bir satır ekleyin\n  geom_line(aes(y = case_int), \n            col = \"black\") + \n  ## geleneksel bir grafik oluşturun (siyah eksenli ve beyaz arka planlı)\n  theme_classic()\n\n\n\n\n\n\n\n\n\n\n\nArtıklar (Residuals)\nModelimizin gözlemlenen verilere ne kadar uyum gösterdiğini görmek için artıklara bakmamız gerekir. Artıklar, gözlemlenen değerler ile modelden tahmin edilen değerler arasındaki farktır. Bunu basitçe case_int - tahmin formülünü kullanarak hesaplayabiliriz, ancak residuals() fonksiyonu bunu bizim için doğrudan regresyondan çıkarır.\nAşağıdan gördüğümüz gibi modelle tüm varyansı açıklamamaktayız. Daha fazla fourier terimi kullanmamız ve genliği ele almamız gerekebilir. Ancak bu örnek için olduğu gibi bırakacağız. Grafikler, modelimizin tepe ve diplerde (sayılar en yüksek ve en düşük olduğunda) daha kötü olduğunu ve gözlemlenen sayıları olduğundan daha az tahmin etme olasılığının (underestimate) yüksek olabileceğini gösteriyor.\n\n## artıkların hesabı \nestimate_res &lt;- estimate_res %&gt;% \n  mutate(resid = fitted_model$result[[1]]$residuals)\n\n## artıklar zaman içinde oldukça sabit mi (değilse: salgın? uygulamada değişiklik?)\nestimate_res %&gt;%\n  ggplot(aes(x = epiweek, y = resid)) +\n  geom_line() +\n  geom_point() + \n  labs(x = \"epiweek\", y = \"Residuals\")\n\n\n\n\n\n\n\n## artıklarda otokorelasyon var mı (hatanın bir motifi var mı?)\nestimate_res %&gt;% \n  as_tsibble(index = epiweek) %&gt;% \n  ACF(resid, lag_max = 52) %&gt;% \n  autoplot()\n\n\n\n\n\n\n\n## artıklar normal olarak dağılmış mı (tahminin altında mı yoksa üzerinde mi?)\nestimate_res %&gt;%\n  ggplot(aes(x = resid)) +\n  geom_histogram(binwidth = 100) +\n  geom_rug() +\n  labs(y = \"count\") \n\n\n\n\n\n\n\n## gözlemlenen sayıları artıklarıyla karşılaştırın\n  ## ayrıca motif görülmemeli\nestimate_res %&gt;%\n  ggplot(aes(x = estimate, y = resid)) +\n  geom_point() +\n  labs(x = \"Fitted\", y = \"Residuals\")\n\n\n\n\n\n\n\n## artıkların otokorelasyonunu test edin\n## H0, artıkların beyaz gürültü (yani rastgele) olmasıdır\n## bağımsızlık testi\n## p değeri anlamlıysa rastgele değil\nBox.test(estimate_res$resid, type = \"Ljung-Box\")\n\n\n    Box-Ljung test\n\ndata:  estimate_res$resid\nX-squared = 336.25, df = 1, p-value &lt; 2.2e-16\n\n## \n##  Box-Ljung test\n## \n## data:  observed$resid\n## X-squared = 346.64, df = 1, p-value &lt; 2.2e-16",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Zaman serileri ve salgınların tespit edilmesi</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.tr.html#iki-zaman-serisinin-ilişkisi",
    "href": "new_pages/time_series.tr.html#iki-zaman-serisinin-ilişkisi",
    "title": "23  Zaman serileri ve salgınların tespit edilmesi",
    "section": "23.6 İki zaman serisinin ilişkisi",
    "text": "23.6 İki zaman serisinin ilişkisi\nBurada, campylobacter vaka sayılarını açıklamak için hava durumu verilerini (özellikle sıcaklık) kullanmayı inceliyoruz.\n\n\nVeritabanlarının birleştirilmesi\nHafta değişkenini kullanarak veri tabanlarımızı birleştirebiliriz. Birleştirme hakkında daha fazla bilgi için birleştirme ilgili el kitabı bölümüne bakın. joining.\n\n## sol birleştirme, böylece yalnızca sayılarda mevcut olan satırlarımız olur \n## temp_data'dan tarih değişkenini çıkarın (aksi takdirde yinelenir)\n\ncounts &lt;- left_join(counts, \n                    select(temp_data, -date),\n                    by = \"epiweek\")\n\n\n\n\nTanımlayıcı analizler\nGörünür bir ilişki olup olmadığını görmek için önce verilerinizi çizin. Aşağıdaki grafik, iki değişkenin mevsimselliği yönünden görünür bir ilişki olduğunu ve sıcaklığın vaka sayısından birkaç hafta önce zirveye ulaştığını göstermektedir. Verilerin pivotlanması hakkında daha fazla bilgi için, verilerin pivotlanmasıyla ilgili el kitabı bölümüne bakın. pivoting data.\n\ncounts %&gt;% \n  ## sadece ilgilendiğimiz değişkenler veritabanında kalır  \n  select(epiweek, case_int, t2m) %&gt;% \n  ## verilerinizi uzun formatta değiştirin\n  pivot_longer(\n    ## anahtar olarak epiweek'i kullanın\n    !epiweek,\n    ## sütun adlarını yeni \"ölçü\" sütununa taşıyın\n    names_to = \"measure\", \n    ## hücre değerlerini yeni \"değerler\" sütununa taşı\n    values_to = \"value\") %&gt;% \n  ## yukarıdaki veritabanından bir grafik oluşturun \n  ## epiweek'i x ekseninde ve değerler (sayılar/santigrat) y ekseninde grafik çizin\n  ggplot(aes(x = epiweek, y = value)) + \n    ## sıcaklık ve vaka sayıları için ayrı bir grafik oluşturun\n    ## kendi y eksenlerini ayarlamalarına izin verin\n    facet_grid(measure ~ ., scales = \"free_y\") +\n    ## ikisini de bir çizgi grafiği olarak çizin \n    geom_line()\n\n\n\n\n\n\n\n\n\n\n\nGecikmeler ve çapraz korelasyonlar\nVakalar ve sıcaklık arasında hangi haftaların en çok ilişkili olduğunu test etmek çapraz korelasyon uygulanır. feasts paketinden çapraz korelasyon fonksiyonunu (CCF()) kullanabiliriz. Ayrıca autoplot() fonksiyonunu kullanarak (arrange kullanmak yerine) grafik oluşturabilirsiniz.\n\ncounts %&gt;% \n  ## interpolasyonlu sayımlar ve sıcaklık arasındaki çapraz korelasyonu hesaplayın\n  CCF(case_int, t2m,\n      ## maksimum gecikmeyi 52 hafta olarak ayarlayın\n      lag_max = 52, \n      ## korelasyon katsayısını hesaplayın\n      type = \"correlation\") %&gt;% \n  ## korelasyon katsayısını azalan biçimde dizin\n  ## en yüksek ilişkili gecikmeleri göster\n  arrange(-ccf) %&gt;% \n  ## sadece ilk 10'u gösterin \n  slice_head(n = 10)\n\n# A tsibble: 10 x 2 [1W]\n        lag   ccf\n   &lt;cf_lag&gt; &lt;dbl&gt;\n 1      -4W 0.749\n 2      -5W 0.745\n 3      -3W 0.735\n 4      -6W 0.729\n 5      -2W 0.727\n 6      -7W 0.704\n 7      -1W 0.695\n 8      -8W 0.671\n 9       0W 0.649\n10      47W 0.638\n\n\nBurada 4 haftalık bir gecikmenin en yüksek oranda ilişkili olduğunu görüyoruz, bu nedenle regresyonumuza dahil etmek için gecikmeli bir sıcaklık değişkeni oluşturuyoruz.\nTEHLİKE: Gecikmeli sıcaklık değişkenindeki verilerin ilk dört haftasının eksik olduğunu (NA) unutmayın - çünkü veri almak için önceki dört hafta mevcut değildi. Bu veri tabanını trending predict() fonksiyonuyla kullanmak için, daha aşağıda predict() fonksiyonu içinde simulate_pi = FALSE argümanını kullanmamız gerekir. Simulate (simüle et) seçeneğini kullanmak istediysek, aşağıdaki kod parçasına drop_na(t2m_lag4) terimini ekleyerek eksikleri çıkararak yeni bir veri tabanı olarak kaydetmeliyiz.\n\ncounts &lt;- counts %&gt;% \n  ## sıcaklık için dört hafta gecikmeli yeni bir değişken oluşturun\n  mutate(t2m_lag4 = lag(t2m, n = 4))\n\n\n\n\nİki değişkenli negatif binomial\nDaha önce gösterildiği gibi negatif bir binom regresyon modeli geliştiriyoruz. Bu sefer modelimize dört hafta gecikmeli sıcaklık değişkenini ekliyoruz.\nUYARI: predict() değişkeninde simulate_pi = FALSE kullanımına dikkat edin. Bunun nedeni, trending’in varsayılan davranışının bir tahmin aralığı oluşturmak için ciTools paketini kullanmasıdır. NA (eksik) sayılar varsa bu paket çalışmaz ve daha granüler aralıklar üretir. Ayrıntılar için ?trending::predict.trending_model_fit’e bakın. \n\n## uydurmak istediğiniz modeli tanımlayın (negatif binom)\nmodel &lt;- glm_nb_model(\n  ## ilgilenilen çıktı olarak vaka sayısını belirleyin \n  case_int ~\n    ## trendi hesaba katmak için epiweek'i kullanın\n    epiweek +\n    ## mevsimselliği hesaba katmak için fourier terimlerini kullanın\n    fourier + \n    ## dört hafta gecikmeli sıcaklık değişkenini kullanın\n    t2m_lag4\n    )\n\n## sayım veri tabanını kullanarak uyumlu modelinizi oluşturun\nfitted_model &lt;- trending::fit(model, data.frame(counts))\n\n## güven aralıklarını ve tahmin aralıklarını hesaplayın\nobserved &lt;- predict(fitted_model, simulate_pi = FALSE)\n\nTek tek terimleri araştırmak için, get_model() fonksiyonunu kullanarak orijinal negatif binom regresyonunu trend formatından çıkarabilir sonrasında üstel tahminleri ve ilişkili güven aralıklarını elde etmek için broom paketi tidy() işlevine iletebiliriz. Bu bize, trend ve mevsimsellik için kontrol edildikten sonra gecikmeli sıcaklığın vaka sayılarına benzer olduğunu ve vaka sayılarıyla anlamlı olarak ilişkili (tahmini ~ 1) olduğunu gösterir. Bu sonuç , gecikmeli sıcaklık değişkeninin gelecekteki vaka sayılarını tahmin etmek için iyi bir değişken olabileceğini düşündürmektedir (iklim tahminleri zaten hazır olduğu için).\n\nfitted_model %&gt;% \n  ## orijinal negatif binom regresyonunu elde edin \n  get_fitted_model() #%&gt;% \n\n[[1]]\n\nCall:  glm.nb(formula = case_int ~ epiweek + fourier + t2m_lag4, data = data.frame(counts), \n    init.theta = 32.80689607, link = log)\n\nCoefficients:\n (Intercept)       epiweek  fourierS1-52  fourierC1-52      t2m_lag4  \n   5.825e+00     8.464e-05    -2.850e-01    -1.954e-01     6.672e-03  \n\nDegrees of Freedom: 504 Total (i.e. Null);  500 Residual\n  (4 observations deleted due to missingness)\nNull Deviance:      2015 \nResidual Deviance: 508.2    AIC: 6784\n\n  ## sonuçların tidy veri çerçevesini elde edin\n  # tidy(exponentiate = TRUE, \n  #      conf.int = TRUE)\n\nModelin hızlı görsel incelemesi, modelin gözlemlenen vaka sayılarını tahmin etmede daha iyi bir iş çıkarabileceğini gösterir.\n\nestimate_res &lt;- data.frame(observed$result)\n\n## regresyonunuzu çiz\nggplot(data = estimate_res, aes(x = epiweek)) + \n  ## model tahmini için bir satır ekleyin\n  geom_line(aes(y = estimate),\n            col = \"Red\") + \n  ## tahmin aralıkları için bir bant ekleyin\n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## gözlemlenen vaka sayılarınız için bir satır ekleyin\n  geom_line(aes(y = case_int), \n            col = \"black\") + \n  ## geleneksel bir grafik oluşturun (siyah eksenli ve beyaz arka planlı)\n  theme_classic()\n\n\n\n\n\n\n\n\n\nRezidüeller (Artıklar)\nModelimizin gözlemlenen verilerle ne kadar uyumlu olduğunu görmek için artıkları tekrar araştırırız. Buradaki sonuçlar ve yorum önceki regresyona benzer, bu nedenle sıcaklık değişkenini içermeyen daha basit bir modele bağlı kalmak daha uygun olabilir.\n\n## artıkları hesapla\nestimate_res &lt;- estimate_res %&gt;% \n  mutate(resid = case_int - estimate)\n\n## artıklar zaman içinde oldukça sabit mi (değilse: salgın? uygulamada değişiklik?)\nestimate_res %&gt;%\n  ggplot(aes(x = epiweek, y = resid)) +\n  geom_line() +\n  geom_point() + \n  labs(x = \"epiweek\", y = \"Residuals\")\n\n\n\n\n\n\n\n## Uyarı: Eksik değerler içeren 4 satır kaldırıldı (geom_path).\n\n \n## artıklarda otokorelasyon var mı (hatanın bir motifi var mı?)\nestimate_res %&gt;% \n  as_tsibble(index = epiweek) %&gt;% \n  ACF(resid, lag_max = 52) %&gt;% \n  autoplot()\n\n\n\n\n\n\n\n## artıklar normal dağılım gösteriyor mu (tahminin altında mı yoksa üzerinde mi?)\nestimate_res %&gt;%\n  ggplot(aes(x = resid)) +\n  geom_histogram(binwidth = 100) +\n  geom_rug() +\n  labs(y = \"count\") \n\n\n\n\n\n\n\n## Uyarı: Sonlu olmayan değerler içeren 4 satır kaldırıldı (stat_bin).\n\n \n## gözlemlenen sayıları artıklarıyla karşılaştırın\n  ## ayrıca tekrarlama olmamalı\nestimate_res %&gt;%\n  ggplot(aes(x = estimate, y = resid)) +\n  geom_point() +\n  labs(x = \"Fitted\", y = \"Residuals\")\n\n\n\n\n\n\n\n## Uyarı: Eksik değerler içeren 4 satır kaldırıldı (geom_point).\n\n \n## artıkların otokorelasyonunu test edin\n## H0, artıkların beyaz gürültü (yani rastgele) olmasıdır\n## bağımsızlık testi\n## p değeri anlamlıysa rastgele değildir\nBox.test(estimate_res$resid, type = \"Ljung-Box\")\n\n\n    Box-Ljung test\n\ndata:  estimate_res$resid\nX-squared = 339.52, df = 1, p-value &lt; 2.2e-16",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Zaman serileri ve salgınların tespit edilmesi</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.tr.html#salgınların-tespit-edilmesi",
    "href": "new_pages/time_series.tr.html#salgınların-tespit-edilmesi",
    "title": "23  Zaman serileri ve salgınların tespit edilmesi",
    "section": "23.7 Salgınların tespit edilmesi",
    "text": "23.7 Salgınların tespit edilmesi\nBurada salgınları tespit etmek için iki (benzer) yöntem göstereceğiz. İlki, yukarıdaki bölümler üzerine kuruludur. Regresyonları önceki yıllara uydurmak için trending paketini kullanıyoruz ve ardından gelecek yıl görmeyi umduğumuzu değerleri tahmin ediyoruz. Gözlenen sayımlar beklediğimizin üzerindeyse, bir salgın olduğunu gösterebilir. İkinci yöntem benzer ilkelere dayanmaktadır ancak aşırı değerlerin (aberration) tespiti için bir dizi farklı algoritmaya sahip surveillance paketini kullanır.\nUYARI: Normalde, mevcut yılla ilgilenirsiniz (yalnızca mevcut haftaya kadar olan sayıları bildiğiniz için). Bu örnekte 2011’in 39. haftasındaymış gibi analiz yapıyoruz.\n\n\ntrending paketi\nBu yöntem için bir temel tanımlarız, genellikle yaklaşık 5 yıllık veri olmalıdır). Temel veriler için bir regresyon modeli oluştururuz ve ardından bunu gelecek yıl için tahmin elde etmek için kullanırız.\n\n\nKesim (eşik) tarihi\nTarihlerinizi tek bir yerde tanımlamak ve ardından bunları kodunuzun geri kalanında kullanmak daha kolaydır.\nBurada bir başlangıç tarihi (gözlemlerimizin başladığı tarih) ve bir bitiş tarihi (temel dönemimizin sonu olan- ve tahmine ne zaman başlayacağımızın tarihi) tanımlarız. ~Ayrıca ilgilendiğimiz yılda (tahmin edeceğimiz yılda) kaç hafta olduğunu da tanımlarız ~. Ayrıca, temel kesim tarihimiz ile tahmin etmek istediğimiz bitiş tarihi arasında kaç hafta olduğunu da tanımlarız.\nNOT: Bu örnekte, şu anda Eylül 2011’in sonundaymış gibi davranıyoruz (“2011 W39”).\n\n## başlangıç tarihini tanımlayın (gözlemlerin başladığı zaman)\nstart_date &lt;- min(counts$epiweek)\n\n## bir bitiş haftası tanımlayın (temel verinin sonu, tahmin döneminin başlangıcı)\ncut_off &lt;- yearweek(\"2010-12-31\")\n\n## ilgilenilen son tarihi tanımlayın (yani tahminin sonu)\nend_date &lt;- yearweek(\"2011-12-31\")\n\n## ilgilenilen dönemde (yıl) kaç hafta bulun\nnum_weeks &lt;- as.numeric(end_date - cut_off)\n\n\n\n\nSatır eklemek\nTidyverse formatında tahmin yapabilmek için, veri setimizde doğru sayıda satıra, yani yukarıda tanımlanan end_date tarihine kadar her hafta için bir satıra ihtiyacımız var. Aşağıdaki kod, bu satırları bir gruplama değişkenine göre eklemenize izin verir - örneğin, bir veri tabanında birden fazla ülkemiz varsa, ülkeye göre gruplayabilir ve ardından her biri için uygun satırlar ekleyebiliriz. tsibble’ın group_by_key() fonksiyonu , bu gruplandırmayı yapmamıza ve ardından gruplanmış verileri dplyr fonkisyonlarına, group_modify() ve add_row()’a geçirmemize izin verir. Ardından, verilerde mevcut olan maksimum hafta değerinden bir sonraki hafta ile bitiş haftası arasındaki hafta sırasını belirleriz.\n\n## yılın sonuna kadar eksik haftaları ekleyin\ncounts &lt;- counts %&gt;%\n  ## bölgeye göre grup\n  group_by_key() %&gt;%\n  ## her grup için en yüksek epiweek’ten yıl sonuna kadar satır ekleyin\n  group_modify(~add_row(.,\n                        epiweek = seq(max(.$epiweek) + 1, \n                                      end_date,\n                                      by = 1)))\n\n\n\n\nFourier terimleri\nFourier terimlerimizi yeniden tanımlamamız gerekiyor - çünkü bu terimleri temel tarihe uydurmak ve gelecek yıl için ekstrapole etmek istiyoruz. Bunu yapmak için fourier() fonkisyonundan iki çıktı listesini bir araya getirmemiz gerekiyor; ilki temel veriler içindir ve ikincisi ilgilenilen yılı (h argümanını tanımlayarak) tahmin eder.\nNot: Satırları bağlamak için rbind() (tidyverse’teki bind_rows yerine) kullanmalıyız, çünkü fourier sütunları bir liste biçimindedir (yani ayrı ayrı adlandırılmaz).\n\n## fourier terimlerini tanımlayın (sincos)\ncounts &lt;- counts %&gt;% \n  mutate(\n    ## 2010 kesim tarihinden önceki ve sonraki haftalar için fourier terimlerini birleştirin\n    ## (yani 2011 fourier terimleri tahmin edilmektedir)\n    fourier = rbind(\n      ## önceki yıllar için fourier terimlerini getirin \n      fourier(\n        ## sadece 2011'den önceki satırları tutun\n        filter(counts, \n               epiweek &lt;= cut_off), \n        ## bir dizi sin cos terimini dahil et\n        K = 1\n        ), \n      ## 2011 için fourier terimlerini tahmin edin (temel verileri kullanarak)\n      fourier(\n        ## sadece 2011'den önceki satırları tutun\n        filter(counts, \n               epiweek &lt;= cut_off),\n        ## bir dizi sin cos terimini dahil et\n        K = 1, \n        ## 52 hafta sonrasını tahmin et\n        h = num_weeks\n        )\n      )\n    )\n\n\n\n\nVerinin bölünmesi ve uyumlu regresyon\nŞimdi veri setimizi temel periyoda (tahminin başladığı zamana kadarki veri) ve tahmin periyoduna bölmemiz gerekiyor. Bu, group_by()’den sonra dplyr group_split() fonkisyonu kullanılarak yapılır ve biri kesme işleminden önce diğeri sonra olmak üzere iki veri çerçevesi içeren bir liste oluşturur.\nDaha sonra veri kümelerini listeden çıkarmak için purrr paketi pluck() fonksiyonunu kullanırız (bu fonksiyon köşeli parantez kullanmaya eşdeğer, örneğin dat[[1]] gibi ) ve daha sonra modelimizi temel verilere uydurabilir ve ardından kesintiden sonra ilgilendiğimiz veri için predict() fonksiyonunu kullanabiliriz.\nPurrr hakkında daha fazla bilgi edinmek için Yineleme (iterasyon), döngüler ve listeler sayfasına bakın.\nUYARI: predict() fonksiyonunda simulate_pi = FALSE argümanının kullanımına dikkat edin. Bunun nedeni, trend oluşturmanın varsayılan davranışının bir tahmin aralığını oluşturmak için ciTools paketinin kullanılmasıdır. NA (eksik) değerler varsa bu fonksiyon çalışmaz ve ayrıca daha granüler aralıklar üretir. Ayrıntılar için ?trending::predict.trending_model_fit’e bakın. \n\n# uyum ve tahmin için bölünmüş veriler\ndat &lt;- counts %&gt;% \n  group_by(epiweek &lt;= cut_off) %&gt;%\n  group_split()\n\n## uydurmak istediğiniz modeli tanımlayın (negatif binom)\nmodel &lt;- glm_nb_model(\n  ## set number of cases as outcome of interest\n  case_int ~\n    ## use epiweek to account for the trend\n    epiweek +\n    ## use the furier terms to account for seasonality\n    fourier\n)\n\n# Uyum ve tahmin için hangi verilerin kullanılacağını tanımlayın\nfitting_data &lt;- pluck(dat, 2)\npred_data &lt;- pluck(dat, 1) %&gt;% \n  select(case_int, epiweek, fourier)\n\n# modeli uydurun\nfitted_model &lt;- trending::fit(model, data.frame(fitting_data))\n\n# Uydurulan veriler için sınır ve tahmin değerleri elde edin\nobserved &lt;- fitted_model %&gt;% \n  predict(simulate_pi = FALSE)\n\n# tahmin için kullanılacak veri ile tahmin \nforecasts &lt;- fitted_model %&gt;% \n  predict(data.frame(pred_data), simulate_pi = FALSE)\n\n## temel ve tahmin edilmiş veri tabanlarını birleştirin \nobserved &lt;- bind_rows(observed$result, forecasts$result)\n\nDaha önce olduğu gibi modelimizi ggplot ile görselleştirebiliriz. %95 tahmin aralığının üzerindeki gözlemlenen değerleri dikkat çekmek amacıyla kırmızı noktalarla vurgularız. Bu sefer tahminin başladığı tarihi etiketlemek için dikey bir çizgi de ekliyoruz.\n\n## regresyonunuzu görselleştirin \nggplot(data = observed, aes(x = epiweek)) + \n  ## model tahmini için bir satır ekleyin\n  geom_line(aes(y = estimate),\n            col = \"grey\") + \n  ## tahmin aralıkları için bir bant ekleyin\n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## gözlemlenen vaka sayılarınız için bir çizgi grafiği ekleyin\n  geom_line(aes(y = case_int), \n            col = \"black\") + \n  ## beklenenin üzerinde gözlenen sayımlar için saçılım grafiği\n  geom_point(\n    data = filter(observed, case_int &gt; upper_pi), \n    aes(y = case_int), \n    colour = \"red\", \n    size = 2) + \n  ## tahminin nerede başladığını göstermek için dikey çizgi ve etiket ekleyin\n  geom_vline(\n           xintercept = as.Date(cut_off), \n           linetype = \"dashed\") + \n  annotate(geom = \"text\", \n           label = \"Forecast\", \n           x = cut_off, \n           y = max(observed$upper_pi) - 250, \n           angle = 90, \n           vjust = 1\n           ) + \n  ## geleneksel bir grafik oluşturun (siyah eksenli ve beyaz arka planlı)\n  theme_classic()\n\nWarning: Removed 13 rows containing missing values or values outside the scale range\n(`geom_line()`).\n\n\n\n\n\n\n\n\n## Uyarı: Eksik değerler içeren 13 satır kaldırıldı(geom_path).\n\n\n\n\nÖngörünün doğrulanması (validasyonu)\nArtıkları incelemenin ötesinde, modelinizin gelecekteki durumları tahmin etmede ne kadar iyi olduğunu araştırmak önemlidir. Bu size eşik uyarılarınızın ne kadar güvenilir olduğu konusunda fikir verir.\nDoğrulamanın geleneksel yolu, önceki yılı ne kadar iyi tahmin edebileceğinizi görmektir (çünkü “şimdiki yıl” için sayıları henüz bilmiyorsunuz). Örneğin, veri setimizde 2010’u tahmin etmek için 2002’den 2009’a kadar olan verileri kullanıp sonra bu tahminlerin ne kadar doğru olduğunu ölçerdik. Ardından modeli 2010 verilerini içerecek şekilde uygulayıp 2011 sayılarını tahmin etmek için kullanın.\nAşağıdaki şekilde Hyndman ve arkadaşlarının “Tahmin ilkeleri ve uygulaması” bölümünde görülebileceği gibi. Hyndman et al “Forecasting principles and practice”.\n Görsel yazarlardan alınan izinle yeniden oluşturulmuştur\nBu yöntemin dezavantajı, elinizdeki tüm verileri kullanmamanız ve modelin tahmin için kullandığınız son model olmamasıdır.\nBir alternatif, çapraz doğrulama adı verilen bir yöntem kullanmaktır. Bu senaryoda, bir yıl sonrasını tahmin etmek için birden fazla modele uydurabilmek için mevcut tüm verileri kaydırırsınız. Aynı makaleden [Hyndman ve arkadaşlarına ait metninden]((https://otexts.com/fpp3/) alınan aşağıdaki şekilde görüldüğü gibi, her modelde giderek daha fazla veri kullanıyorsunuz.\nÖrneğin, ilk model 2003’ü tahmin etmek için 2002’yi kullanıyor , ikincisi 2004’ü tahmin etmek için 2002 ve 2003’ü kullanır, vb.  Görsel yazarlardan alınan izinle yeniden oluşturulmuştur\nAşağıda, veri kümeleri üzerinde döngü işlemini uygulamak için purrr paketinden map() fonksiyonunu kullanıyoruz. Daha sonra, doğruluk ölçülerini hesaplama amacıyla yardstick paketini kullanmak için elde ettiğimiz tahminleri bir veri tabanına aktarır ve orijinal vaka sayılarıyla birleştiririz. Aşağıda belirtilen dört ölçüyü hesaplıyoruz: Kök Ortalama Kare Hatası (RMSE), Ortalama mutlak hata (MAE), Ortalama mutlak ölçekli hata (MASE), Ortalama mutlak yüzde hatası (MAPE).\nUYARI: predict() fonksiyonunda simulate_pi = FALSE argümanının kullanımına dikkat edin. Bunun nedeni, trend oluşturmanın varsayılan davranışının bir tahmin aralığını oluşturmak için ciTools paketinin kullanılmasıdır. NA (eksik) değerler varsa bu fonksiyon çalışmaz ve ayrıca daha granüler aralıklar üretir. Ayrıntılar için ?trending::predict.trending_model_fit’e bakın. \n\n## Çapraz doğrulama: Kayan pencereye dayalı olarak önümüzdeki haftaları tahmin etme\n\n## 52 haftalık pencerelerde kaydırarak verilerinizi genişletin (öncesi + sonrası)\n## 52 hafta sonrasını tahmin etmek\n## (daha uzun gözlem zincirleri oluşturur- eski verileri tutar)\n\n## kaydırmak istediğiniz pencereyi tanımlayın\nroll_window &lt;- 52\n\n## tahmin etmek istediğiniz haftaları tanımlayın  \nweeks_ahead &lt;- 52\n\n## yinelenen, giderek daha uzun verilerden oluşan bir veri seti oluşturun\n## her veri setini benzersiz bir kimlikle etiketleyin\n## yalnızca ilgilenilen yıldan önceki vakaları kullanın (yani 2011)\ncase_roll &lt;- counts %&gt;% \n  filter(epiweek &lt; cut_off) %&gt;% \n  ## sadece hafta ve vaka sayısı değişkenlerini veri tabanında tut \n  select(epiweek, case_int) %&gt;% \n    ## en son x sayıda gözlemi uzaklaştırın \n    ## önümüzdeki kaç haftayı tahmin etmek istediğinize bağlı olarak \n    ## (aksi takdirde \"bilinmeyen\" için tahmin yapılacaktır)\n    slice(1:(n() - weeks_ahead)) %&gt;%\n    as_tsibble(index = epiweek) %&gt;% \n    ## gruplandırma kimliği oluşturmak amacıyla x’teki her hafta için kaydırın\n    ## kaydırma pencerisinin özgüllüğüne bağlı \n    stretch_tsibble(.init = roll_window, .step = 1) %&gt;% \n  ## önceki vakası yokmuş gibi ilk çifti uzaklaştırın drop the first couple \n  filter(.id &gt; roll_window)\n\n## benzersiz veri setlerinin her biri için aşağıdaki kodu çalıştırın\nforecasts &lt;- purrr::map(unique(case_roll$.id), \n                        function(i) {\n  \n  ## yalnızca mevcut katlantının uygun olmasını sağlayın\n  mini_data &lt;- filter(case_roll, .id == i) %&gt;% \n    as_tibble()\n  \n  ## tahmin için boş bir veri seti oluşturun\n  forecast_data &lt;- tibble(\n    epiweek = seq(max(mini_data$epiweek) + 1,\n                  max(mini_data$epiweek) + weeks_ahead,\n                  by = 1),\n    case_int = rep.int(NA, weeks_ahead),\n    .id = rep.int(i, weeks_ahead)\n  )\n  \n  ## tahmin verilerini orijinale ekleyin\n  mini_data &lt;- bind_rows(mini_data, forecast_data)\n  \n  ## en son eksik olmayan sayım verilerine dayalı olarak kesim tarhini tanımlayın\n  cv_cut_off &lt;- mini_data %&gt;% \n    ## sadece eksik olmayan satırları tutun \n    drop_na(case_int) %&gt;% \n    ## en son haftayı elde edin \n    summarise(max(epiweek)) %&gt;% \n    ## bir veri çerçevesinde olmayacak şekilde dışa aktar \n    pull()\n  \n  ## mini_data’yı tsibble haline getirin\n  mini_data &lt;- tsibble(mini_data, index = epiweek)\n  \n  ## fourier terimlerini tanımlayın (sincos) \n  mini_data &lt;- mini_data %&gt;% \n    mutate(\n    ## fourier terimlerini kesim tarihinden önceki ve sonraki haftaları kombine etmek için kullanın \n    fourier = rbind(\n      ## önceki yıllardan fourier terimelerini getirin \n      forecast::fourier(\n        ## sadece kesim öncesi satırları tutun \n        filter(mini_data, \n               epiweek &lt;= cv_cut_off), \n        ## bir sin cos terim setini dahil edin \n        K = 1\n        ), \n      ## takiben eden yıl için fourier terimlerini tahmin edin (temel veriyi kullanarak)\n      fourier(\n        ## sadece kesim öncesi satırları tutun\n        filter(mini_data, \n               epiweek &lt;= cv_cut_off),\n        ## bir sin cos terim setini dahil edin\n        K = 1, \n        ## 52 hafta sonrasını tahmin edin \n        h = weeks_ahead\n        )\n      )\n    )\n\n  \n  \n    # uyum ve tahmin için bölünmüş veriler\n  dat &lt;- mini_data %&gt;% \n    group_by(epiweek &lt;= cv_cut_off) %&gt;%\n    group_split()\n\n  ## uydurmak istediğiniz modeli tanımlayın (negatif binom)\n  model &lt;- glm_nb_model(\n    ## ilgilenilen çıktı olarak vaka sayısını ayarlayın \n    case_int ~\n      ## trendi hesaba katmak için epiweek'i kullanın\n      epiweek +\n      ## mevsimselliği hesaba katmak için fourier terimlerini kullanın\n      fourier\n  )\n\n  # Uyum ve tahmin için hangi verilerin kullanılacağını tanımlayın\n  fitting_data &lt;- pluck(dat, 2)\n  pred_data &lt;- pluck(dat, 1)\n  \n  # modeli uydurun \n  fitted_model &lt;- trending::fit(model, fitting_data)\n  \n  # istenilen verilerle tahmin \n  forecasts &lt;- fitted_model %&gt;% \n    predict(data.frame(pred_data), simulate_pi = FALSE) \n  forecasts &lt;- data.frame(forecasts$result[[1]]) %&gt;%\n    ## sadece hafta ve tahmin değerini tutun \n    select(epiweek, estimate)\n    \n  }\n  )\n\n## listeyi tüm tahminlerle birlikte bir veri çerçevesine dönüştürün\nforecasts &lt;- bind_rows(forecasts)\n\n## tahmin ile gözlenen verileri birleştirin \nforecasts &lt;- left_join(forecasts, \n                       select(counts, epiweek, case_int),\n                       by = \"epiweek\")\n\n## {yardstick} ile ölçümlerin hesabı\n  ## RMSE: Kök Ortalama Kare Hatası\n  ## MAE:  Ortalama mutlak hata \n  ## MASE: Ortalama mutlak ölçekli hata\n  ## MAPE: Ortalama mutlak yüzde hatası\n\nmodel_metrics &lt;- bind_rows(\n  ## tahmin edilen veri setinizde gözlemlenen ile tahmin edileni karşılaştırın\n  rmse(forecasts, case_int, estimate), \n  mae( forecasts, case_int, estimate),\n  mase(forecasts, case_int, estimate),\n  mape(forecasts, case_int, estimate),\n  ) %&gt;% \n  ## yalnızca metrik türünü ve çıktısını tutun\n  select(Metric  = .metric, \n         Measure = .estimate) %&gt;% \n  ## geniş formatta yapın, böylece satırları bağlayın\n  pivot_wider(names_from = Metric, values_from = Measure)\n\n## metrik modeli getirin \nmodel_metrics\n\n# A tibble: 1 × 4\n   rmse   mae  mase  mape\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1  252.  199.  1.96  17.3\n\n\n\n\n\n\nsurveillance paketi\nBu bölümde, salgın tespit algoritmalarına dayalı uyarı eşikleri oluşturmak için surveillance paketini kullanıyoruz. Pakette birkaç farklı yöntem mevcuttur, ancak burada iki seçeneğe odaklanacağız. Ayrıntılar için, kullanılan algoritmaların uygulaması ve teorisi hakkındaki bu makalelere bakın. application ve theory.\nİlk seçenek, iyileştirilmiş Farrington yöntemini kullanır. Bu yöntem, negatif bir binom glm’ye (trend dahil) uyum gösterir ve eşik değeri oluşturmak için geçmiş salgınları (aykırı değerler) düşük değer olarak kullanır.\nİkinci seçenek glrnb yöntemini kullanır. Bu aynı zamanda negatif bir binom glm’ye (genelleştirilmiş doğrusal modele) de uyar, ancak trend ve fourier terimlerini içerir (burada tercih edilir). Regresyon, “kontrol ortalamasını” (~uyumlu değerleri) hesaplamak için kullanılır - daha sonra her hafta için ortalamada kayma olup olmadığını değerlendirmek için hesaplanmış bir genelleştirilmiş olabilirlik oranı (likelihood ratio) istatistiği kullanır. Her hafta için eşiğin önceki haftaları hesaba kattığını unutmayın, bu nedenle sürekli bir kayma varsa bir alarm tetiklenecektir. (Ayrıca her alarmdan sonra algoritmanın sıfırlandığını unutmayın)\nsurveillance paketiyle çalışmak için öncelikle çerçeveye sığacak bir “gözetim zaman serisi” nesnesi (sts() fonksiyonunu kullanarak) tanımlamamız gerekir.\n\n## gözetim zaman serisi nesnesini tanımla\n## not. popülasyon nesnesine bir payda ekleyebilirsiniz (bkz. ?sts)\ncounts_sts &lt;- sts(observed = counts$case_int[!is.na(counts$case_int)],\n                 start = c(\n              ## yalnızca start_date tarihinden itibaren yılı tutmak için alt küme\n              as.numeric(str_sub(start_date, 1, 4)), \n              ## yalnızca start_date tarihinden itibaren haftayı tutmak için alt küme\n              as.numeric(str_sub(start_date, 7, 8))), \n              ## veri türünü tanımlayın (bu durumda haftalık)\n              freq = 52)\n\n## dahil etmek istediğiniz hafta aralığını tanımlayın (ör. tahmin dönemi)\n## not. sts nesnesi yalnızca kendilerine tanımlanmış hafta ya da yılları atamadan gözlemleri sayar \n## bu nedenle uygun olanı tanımlamak için verilerimizi kullanırız\nweekrange &lt;- cut_off - start_date\n\n\nDaha sonra Farrington yöntemi için parametrelerimizi bir liste halinde tanımlarız. Ardından farringtonFlexible() fonksiyonunu kullanarak algoritmayı çalıştırırız ve ardından bunu veri setimize dahil etmek için farringtonmethod@upperbound kullanarak bir uyarı eşiğini çıkarabiliriz. Farringtonmethod@alarm kullanarak her hafta için uyarı tetiklendiyse (eşiğin üzerindeyse) DOĞRU/YANLIŞ değerlerini çıkarmak da mümkündür.\n\n## kontrolü tanımlayın \nctrl &lt;- list(\n  ## eşik için zaman periyodunu tanımlayın (yani 2011)\n  range = which(counts_sts@epoch &gt; weekrange),\n  b = 9, ## temelden kaç yıl geriye \n  w = 2, ## haftalar halinde kaydırma penceresi \n  weightsThreshold = 2.58, ## geçmiş salgınların yeniden ağırlıklandırılması (geliştirilmiş noufaily yöntemi - orijinal öneriler 1)\n  ## pastWeeksNotIncluded = 3, ## mevcut tüm haftaları kullanın (noufaily önerisi 26’yı çıkarın)\n  trend = TRUE,\n  pThresholdTrend = 1, ## 0.05 normally, however 1 is advised in the improved method (i.e. always keep)\n  thresholdMethod = \"nbPlugin\",\n  populationOffset = TRUE\n  )\n\n## farrington’ın esnek yöntemini uygulayın \nfarringtonmethod &lt;- farringtonFlexible(counts_sts, ctrl)\n\n## orijinal veri setinde eşik adı verilen yeni bir değişken oluşturun\n## farrington'dan gelen üst sınırı içerir\n## not: bu yalnızca 2011'deki haftalar içindir (bu nedenle satırları alt kümelere ayırmanız gerekir)\ncounts[which(counts$epiweek &gt;= cut_off & \n               !is.na(counts$case_int)),\n              \"threshold\"] &lt;- farringtonmethod@upperbound\n\nDaha sonra sonuçları daha önce olduğu gibi ggplot’ta görselleştirebiliriz.\n\nggplot(counts, aes(x = epiweek)) + \n  ## gözlemlenen vaka sayılarını bir çizgi olarak ekleyin\n  geom_line(aes(y = case_int, colour = \"Observed\")) + \n  ## sapma algoritmasının üst sınırını ekleyin \n  geom_line(aes(y = threshold, colour = \"Alert threshold\"), \n            linetype = \"dashed\", \n            size = 1.5) +\n  ## renkleri belirleyin \n  scale_colour_manual(values = c(\"Observed\" = \"black\", \n                                 \"Alert threshold\" = \"red\")) + \n  ## geleneksel bir grafik oluşturun (siyah eksenli ve beyaz arka planlı)\n  theme_classic() + \n  ## lejantın (işaret tablosunun) başlığını kaldırın  \n  theme(legend.title = element_blank())\n\n\n\n\n\n\n\n\n\n\nGLRNB yöntemi\nBenzer şekilde GLRNB yöntemi için her bir parametremizi bir liste halinde tanımlıyoruz, ardından algoritmayı uygun hale getiriyoruz ve üst sınırları çıkarıyoruz.\nUYARI: Bu yöntem, eşikleri hesaplamak için “kaba kuvvet” (önyüklemeye [bootstrapping’e] benzer) kullanır, bu nedenle uzun zaman alabilir!\nAyrıntılar için GLRNB gösterimi bakabilirsiniz.\n\n## kontrol ayarlarını belirleyin \nctrl &lt;- list(\n  ## hangi zaman dilimi için eşik değer isteneceğini tanımlayın (yani 2011)\n  range = which(counts_sts@epoch &gt; weekrange),\n  mu0 = list(S = 1,    ## dahil edilecek fourier terimlerinin (harmonik) sayısı\n  trend = TRUE,   ## trendin dahil edilip edilmeyeceği\n  refit = FALSE), ## her alarmdan sonra modelin yeniden uydurulup uydurulmayacağı \n  ## cARL = GLR istatistiği için eşik (keyfi)\n     ## 3 ~ yanlış pozitifleri en aza indirmek için orta yol\n     ## 1, glm.nb'nin %99 tahmin aralığına uyar - zirvelerden sonraki değişikliklerle (uyarı için eşik düşürüldü)\n   c.ARL = 2,\n   # theta = log(1.5), ## salgın vakalarında %50 artışa eşittir\n   ret = \"cases\"     ## vaka sayısı olarak üst sınıra dönüş eşiği\n  )\n\n## glrnb yöntemini uygula\nglrnbmethod &lt;- glrnb(counts_sts, control = ctrl, verbose = FALSE)\n\n## orijinal veri setinde eşik adı verilen yeni bir değişken oluşturun\n## glrnb'den üst sınırı içeren\n## not. bu yalnızca 2011'deki haftalar içindir (bu nedenle satırları alt kümelere ayırmanız gerekir)\ncounts[which(counts$epiweek &gt;= cut_off & \n               !is.na(counts$case_int)),\n              \"threshold_glrnb\"] &lt;- glrnbmethod@upperbound\n\nÇıktıları daha önce olduğu gibi görselleştirin.\n\nggplot(counts, aes(x = epiweek)) + \n  ## gözlemlenen vaka sayılarını bir çizgi olarak ekleyin\n  geom_line(aes(y = case_int, colour = \"Observed\")) + \n  ## sapma algoritmasının üst sınırına ekleyin\n  geom_line(aes(y = threshold_glrnb, colour = \"Alert threshold\"), \n            linetype = \"dashed\", \n            size = 1.5) +\n  ## renkleri belirleyin \n  scale_colour_manual(values = c(\"Observed\" = \"black\", \n                                 \"Alert threshold\" = \"red\")) + \n  ## geleneksel bir grafik oluşturun (siyah eksenli ve beyaz arka planlı)\n  theme_classic() + \n  ## lejantın (işaret tablosunun) başlığını kaldırın  \n  theme(legend.title = element_blank())",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Zaman serileri ve salgınların tespit edilmesi</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.tr.html#kesintili-zaman-serileri",
    "href": "new_pages/time_series.tr.html#kesintili-zaman-serileri",
    "title": "23  Zaman serileri ve salgınların tespit edilmesi",
    "section": "23.8 Kesintili zaman serileri",
    "text": "23.8 Kesintili zaman serileri\nKesintili zaman serileri (ayrıca bölümlere ayrılmış regresyon veya müdahale analizi olarak da adlandırılır), genellikle aşıların hastalık insidansı üzerindeki etkisini değerlendirmede kullanılır. Ancak çok çeşitli müdahalelerin etkisini değerlendirmek için kullanılabilir. Örneğin, hastane prosedürlerinde değişiklikler veya bir popülasyona yeni bir hastalık türünün görülmesi. Bu örnekte, 2008’in sonunda Almanya’ya yeni bir Campylobacter türünün geldiğini farz edeceğiz ve bunun vaka sayısını etkileyip etkilemediğini göreceğiz. Negatif binom regresyonunu tekrar kullanacağız. Bu seferki regresyon, müdahaleden önce (veya burada yeni suşun gelişi) ve diğeri (ön/pre- ve son/post dönemler) olmak üzere iki kısma ayrılacaktır. Bu, iki zaman periyodunu karşılaştıran bir insidans oranı hesaplamamızı sağlar. Denklemi açıklamak anlatımı daha net hale getirebilir (eğer değilse, görmezden gelin!).\nNegatif binom regresyon aşağıdaki gibi tanımlanabilir:\n\\[\\log(Y_t)= β_0 + β_1 \\times t+ β_2 \\times δ(t-t_0) + β_3\\times(t-t_0 )^+ + log(pop_t) + e_t\\]\nNeresi: \\(Y_t\\), \\(t\\) anında gözlemlenen vaka sayısıdır \\(pop_t\\), \\(t\\) anındaki 100.000’lerdeki nüfus büyüklüğüdür (burada kullanılmaz) \\(t_0\\) ön dönemin son yılıdır (varsa geçiş süresi dahil) \\(δ(x\\) gösterge işlevidir (x≤0 ise 0 ve x&gt;0 ise 1’dir) \\((x)^+\\) kesme operatörüdür (x&gt;0 ise x, aksi takdirde 0’dır) \\(e_t\\) kalıntıyı belirtir Gerektiğinde ek terimler trend ve sezon eklenebilir.\n\\(β_2 \\times δ(t-t_0) + β_3\\times(t-t_0 )^+\\) genelleştirilmiş doğrusaldır sonrası dönemin bir parçasıdır ve ön dönemde sıfırdır. Bu, \\(β_2\\) ve \\(β_3\\) tahminlerinin müdahalenin etkileri olduğu anlamına gelir.\nElimizdeki tüm verileri (yani geriye dönük olarak) kullanacağımızdan, burada tahmin yapmadan fourier terimlerini yeniden hesaplamamız gerekiyor. Ek olarak, regresyon için gereken ekstra terimleri hesaplamamız gerekiyor.\n\n## epi hafta ve case_int değişkenlerini kullanarak fourier terimleri ekleyin\ncounts$fourier &lt;- select(counts, epiweek, case_int) %&gt;% \n  as_tsibble(index = epiweek) %&gt;% \n  fourier(K = 1)\n\n## müdahale haftasını tanımla\nintervention_week &lt;- yearweek(\"2008-12-31\")\n\n## regresyon için değişkenleri tanımlayın\ncounts &lt;- counts %&gt;% \n  mutate(\n    ## formüldeki t'ye karşılık gelir\n      ## hafta sayısı (muhtemelen düz epiweeks değişkenini de kullanabilir)\n    # linear = row_number(epiweek), \n    ## formüldeki delta(t-t0)'a karşılık gelir\n      ## müdahale öncesi veya sonrası dönem\n    intervention = as.numeric(epiweek &gt;= intervention_week), \n    ## formüldeki (t-t0)^+'a karşılık gelir\n      ## müdahale sonrası hafta sayısı\n      ## (0 ile hesaplanan değer arasındaki sayılardan daha büyük sayıyı seçin)\n    time_post = pmax(0, epiweek - intervention_week + 1))\n\nDaha sonra bu terimleri negatif bir binom regresyonuna uydurmak için kullanırız ve çıktısı yüzde değişimi olan bir tablo elde ederiz. Bu örnekte, önemli bir değişiklik görülmemiştir.\nDİKKAT: Npredict() değişkeninde simulate_pi = FALSE kullanımına dikkat edin. Bunun nedeni, trending’in varsayılan davranışının bir tahmin aralığı oluşturmak için ciTools paketini kullanmasıdır. NA (eksik) sayılar varsa bu paket çalışmaz ve daha granüler aralıklar üretir. Ayrıntılar için ?trending::predict.trending_model_fit’e bakın. \n\n## uydurmak istediğiniz modeli tanımlayın (negatif binom)\nmodel &lt;- glm_nb_model(\n  ## ilgilenilen çıktı olarak vaka sayısını belirleyeni \n  case_int ~\n    ## trendi hesaba katmak için epiweek'i kullanın\n    epiweek +\n    ## mevsimselliği hesaba katmak için fourier terimlerini kullanın\n    fourier + \n    ## öncesi (pre-) veya sonrası (post-) dönemde ekleyin\n    intervention + \n    ## müdahale sonrası zamanı ekleyin\n    time_post\n    )\n\n## sayım veri setini kullanarak modelinizi uydurun \nfitted_model &lt;- trending::fit(model, counts)\n\n## güven ve tahmin aralıklarını hesaplayın\nobserved &lt;- predict(fitted_model, simulate_pi = FALSE)\n\n\n## tabloda tahminleri ve yüzde değişimini gösterin \nfitted_model %&gt;% \n  ## orijinal negatif binom regresyonunu çıkarın\n  get_model() %&gt;% \n  ## sonuçların düzenli (tidy) veri çerçevesini elde edin \n  tidy(exponentiate = TRUE, \n       conf.int = TRUE) %&gt;% \n  ## sadece müdahale değerini koruyun\n  filter(term == \"intervention\") %&gt;% \n  ## tahmin ve güven aralıkları için IRR'yi yüzde değişikliğine değiştirin\n  mutate(\n    ## ilgilenilen sütunların her biri için - yeni bir sütun oluşturun\n    across(\n      all_of(c(\"estimate\", \"conf.low\", \"conf.high\")), \n      ## yüzde değişimini hesaplamak için formülü uygulayın\n            .f = function(i) 100 * (i - 1), \n      ## yeni sütun adlarına bir sonek \"_perc\"  ekleyin\n      .names = \"{.col}_perc\")\n    ) %&gt;% \n  ## yalnızca belirli sütunları tutun (ve yeniden adlandırın)\n  select(\"IRR\" = estimate, \n         \"95%CI low\" = conf.low, \n         \"95%CI high\" = conf.high,\n         \"Percentage change\" = estimate_perc, \n         \"95%CI low (perc)\" = conf.low_perc, \n         \"95%CI high (perc)\" = conf.high_perc,\n         \"p-value\" = p.value)\n\nDaha önce olduğu gibi, regresyonun çıktılarını görselleştirebiliriz.\n\nestimate_res &lt;- data.frame(observed$result)\n\nggplot(estimate_res, aes(x = epiweek)) + \n  ## gözlemlenen vaka sayılarını bir çizgi olarak ekle\n  geom_line(aes(y = case_int, colour = \"Observed\")) + \n  ## model tahmini için bir satır ekleyin\n  geom_line(aes(y = estimate, col = \"Estimate\")) + \n  ## tahmin aralıkları için bir bant ekleyin\n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## tahminin nerede başladığını göstermek için dikey çizgi ve etiket ekleyin\n  geom_vline(\n           xintercept = as.Date(intervention_week), \n           linetype = \"dashed\") + \n  annotate(geom = \"text\", \n           label = \"Intervention\", \n           x = intervention_week, \n           y = max(observed$upper_pi), \n           angle = 90, \n           vjust = 1\n           ) + \n  ## renkleri tanımlayın\n  scale_colour_manual(values = c(\"Observed\" = \"black\", \n                                 \"Estimate\" = \"red\")) + \n  ## geleneksel bir grafik oluşturun (siyah eksenli ve beyaz arka planlı)\n  theme_classic()\n\nWarning: Unknown or uninitialised column: `upper_pi`.\n\n\nWarning in max(observed$upper_pi): no non-missing arguments to max; returning\n-Inf\n\n\n\n\n\n\n\n\n## Uyarı: Eksik değerler içeren 13 satır kaldırıldı (geom_path).",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Zaman serileri ve salgınların tespit edilmesi</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.tr.html#kaynaklar",
    "href": "new_pages/time_series.tr.html#kaynaklar",
    "title": "23  Zaman serileri ve salgınların tespit edilmesi",
    "section": "23.9 Kaynaklar",
    "text": "23.9 Kaynaklar\nTahminleme: İlkeler ve uygulama ders kitabı\nEPIET zaman serisi analizi vaka çalışmaları\nPenn State kursu Surveillance paketi metni",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Zaman serileri ve salgınların tespit edilmesi</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.tr.html",
    "href": "new_pages/epidemic_models.tr.html",
    "title": "24  Salgın Modelleme",
    "section": "",
    "text": "24.1 Genel Bakış\nSalgın modelleme için, oldukça karmaşık analizleri minimum çabayla yapmamızı sağlayan, büyüyen bir araç grubu vardır. Bu bölüm, bu araçların aşağıdaki amaçlarla nasıl kullanılacağına ilişkin bir genel bakış sağlayacaktır:\nBu bölüm araçların altında yatan metodolojilere ve istatistiksel yöntemlere genel bir bakış değildir, bu nedenle bu konuyu kapsayan bazı makalelere bağlantılar için lütfen Kaynaklar sekmesine bakınız. Bu araçları kullanmadan önce yöntemleri anladığınızdan emin olun; bu, sonuçlarını doğru bir şekilde yorumlayabilmenizi sağlayacaktır.\nAşağıda, bu bölümde üreteceğimiz çıktılardan birine bir örnek verilmiştir.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Salgın Modelleme</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.tr.html#genel-bakış",
    "href": "new_pages/epidemic_models.tr.html#genel-bakış",
    "title": "24  Salgın Modelleme",
    "section": "",
    "text": "etkin üreme sayısı Rt ve iki katına çıkma süresi gibi ilgili istatistikleri tahmin etme\ngelecekteki insidansın kısa vadeli projeksiyonlarını üretme",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Salgın Modelleme</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.tr.html#hazırlık",
    "href": "new_pages/epidemic_models.tr.html#hazırlık",
    "title": "24  Salgın Modelleme",
    "section": "24.2 Hazırlık",
    "text": "24.2 Hazırlık\nRt tahmini için EpiNow ve EpiEstim olmak üzere iki farklı yöntem ve paketin yanı sıra vaka insidansını tahmin etmek için projections paketini kullanacağız.\nBu kod parçası, analizler için gereken paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() vurgusunu yapıyoruz. base R’dan library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakın.\n\npacman::p_load(\n   rio,          # dosya içe aktarma\n   here,         # dosya konumlama\n   tidyverse,    # Veri yönetimi + ggplot2 grafikleri\n   epicontacts,  # bulaş ağlarının analizi\n   EpiNow2,      # Rt tahminleme\n   EpiEstim,     # Rt tahminleme\n   projections,  # İnsidans öngörme\n   incidence2,   # İnsidans verilerini işleme\n   epitrix,      # Faydalı epi fonksiyonları\n   distcrete     # Ayrık gecikme dağılımları\n)\n\n\nBu bölümdeki tüm analizler için temizlenmiş vaka satır listesini kullanacağız. Takip etmek isterseniz, “clean” dosyasını indirmek için tıklayın. ”  (.rds dosyası olarak). Bu el kitabında kullanılan tüm örnek verileri indirmek için [El kitabı ve verileri indir] sayfasına bakınız.\n\n# temizlenmiş satır listesini içe aktarma\nlinelist &lt;- import(\"linelist_cleaned.rds\")",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Salgın Modelleme</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.tr.html#rt-tahmini",
    "href": "new_pages/epidemic_models.tr.html#rt-tahmini",
    "title": "24  Salgın Modelleme",
    "section": "24.3 Rt Tahmini",
    "text": "24.3 Rt Tahmini\n\nEpiNow2 vs. EpiEstim\nÜreme sayısı R, bir hastalığın bulaşıcılığının bir ölçüsüdür ve enfekte vaka başına beklenen ikincil vaka sayısı olarak tanımlanır. Tamamen duyarlı bir popülasyonda bu değer, R0 (Rnought) temel üreme sayısını temsil eder. Bununla birlikte, bir salgın veya pandemi sırasında bir popülasyondaki duyarlı bireylerin sayısı değiştikçe ve çeşitli müdahale önlemleri uygulandıkça, en yaygın olarak kullanılan ölçüm aktarılabilirlik, etkili üreme sayısıdır Rt; bu, belirli bir t zamanında virüslü vaka başına beklenen ikincil vaka sayısı olarak tanımlanır.\nEpiNow2 paketi, Rt tahmini için en gelişmiş çerçeveyi sağlar. Diğer yaygın olarak kullanılan paket olan EpiEstim’e göre iki önemli avantajı vardır:\n\nRaporlamadaki gecikmeleri hesaba katar ve bu nedenle son veriler eksik olsa bile Rt tahminini yapabilir.\nRt’yi raporlamanın başlangıç ​​tarihlerinden ziyade enfeksiyon tarihlerinde tahmin eder; bu, bir müdahalenin etkisinin Rt’deki bir değişikliğe gecikme ile değil hemen yansıtılacağı anlamına gelir.\n\nBununla birlikte, aynı zamanda iki önemli dezavantajı vardır:\n\nBulaş süresi dağılımı (yani birincil ve ikincil vakaların enfeksiyonu arasındaki gecikmelerin dağılımı), kuluçka dönemi dağılımı (yani enfeksiyon ve semptom başlangıcı arasındaki gecikmelerin dağılımı) ve verilerinizle ilgili herhangi bir başka gecikme dağılımı (ör. raporlama tarihleriniz varsa, semptomların başlangıcından raporlamaya kadar olan gecikmelerin dağılımına ihtiyaç duyarsınız). Bu, Rt’nin daha doğru bir şekilde tahmin edilmesini sağlayacak olsa da, EpiEstim yalnızca seri aralık dağılımını (yani, birincil ve ikincil vakanın semptom başlangıcı arasındaki gecikmelerin dağılımına) ihtiyaç duyar. Elinizdeki tek veri bu olduğunda çok kıymetlidir.\n\nEpiNow2, EpiEstim’den önemli ölçüde daha yavaştır, anekdot olarak yaklaşık 100-1000 kat! Örneğin, bu bölümde ele alınan örnek salgın için Rt tahmini yaklaşık dört saat sürer (bu, yüksek doğruluk sağlamak için çok sayıda yineleme için çalıştırılmasındandır. Gerekirse muhtemelen azaltılabilir, ancak ifade edilmek istenen algoritmanın genel olarak yavaş çalıştığıdır). Rt tahminlerinizi düzenli olarak güncelliyorsanız, kullanışlı olmayabilir.\nBu nedenle hangi paketi kullanmayı seçeceğiniz, size sunulan verilere, zamana ve hesaplama kaynaklarına bağlı olacaktır.\n\n\nEpiNow2\n\nTahmini gecikme dağılımları\nEpiNow2’yi çalıştırmak için gereken gecikme dağılımları, sahip olduğunuz verilere bağlıdır. Esasen, Rt tahmininde kullanmak istediğiniz bulaşma tarihinden olay tarihine kadar olan gecikmeyi tanımlayabilmeniz gerekir. Başlangıç ​​tarihlerini kullanıyorsanız, bu sadece kuluçka dönemi dağılımı olacaktır. Raporlama tarihlerini kullanıyorsanız, enfeksiyondan raporlamaya kadar olan gecikmeye ihtiyacınız vardır. Bu dağıtımın doğrudan bilinmesi pek mümkün olmadığından, EpiNow2 birden çok gecikme dağıtımını birlikte zincirlemenize olanak tanır. Bu durumda, enfeksiyondan semptom başlangıcına (örneğin, muhtemelen bilinen kuluçka dönemi) ve semptom başlangıcından raporlamaya (genellikle verilerden tahmin edebileceğiniz) gecikmeyi bilmelisiniz.\nÖrnek satır listesindeki tüm vakalarımız için başlangıç ​​tarihlerine sahip olduğumuzdan, verilerimizi (örn. semptom başlangıç ​​tarihleri) enfeksiyon tarihine bağlamak için yalnızca kuluçka dönemi dağılımına ihtiyaç duyacağız. Bu dağılımı verilerden tahmin edebilir veya literatürdeki değerleri kullanabiliriz.\nEbola’nın kuluçka dönemine ilişkin bir literatür tahmini (bu makaleden alınmıştır) ortalama 9.1, standart sapma 7.3 ve maksimum değer 30 aşağıdaki gibi belirtilecektir:\n\nincubation_period_lit &lt;- list(\n  mean = log(9.1),\n  mean_sd = log(0.1),\n  sd = log(7.3),\n  sd_sd = log(0.1),\n  max = 30\n)\n\nEpiNow2 bu gecikme dağılımlarının bir log ölçeğinde sağlanmasını gerektirdiğini unutmayın, bu nedenle “log” her değerin etrafında çağrılır (kafa karıştırıcı bir şekilde doğal bir değerde sağlanması gereken “max” parametresi hariç). “mean_sd” ve “sd_sd”, ortalamanın standart sapması ve standart sapmasının tahminlerini tanımlamaktadır. Bu durumda bunlar bilinmediğinden, oldukça gelişigüzel 0,1 değerini seçiyoruz.\nBu analizde, kuluçka dönemi dağılımını tahmin etmemiz gibi değil, satır listesinde enfeksiyon ve başlangıç ​​arasında gözlemlenen gecikmelere uyacak bir lognormal dağılımı ‘bootstrapped_dist_fit’ fonksiyonu ile tahminliyoruz.\n\n## inkübasyon süresini tahminleme\nincubation_period &lt;- bootstrapped_dist_fit(\n  linelist$date_onset - linelist$date_infection,\n  dist = \"lognormal\",\n  max_value = 100,\n  bootstraps = 1\n)\n\nİhtiyacımız olan diğer dağılım ise üreme süresidir. Bulaşma zamanları ve iletim bağlantılarına ilişkin verilerimiz olduğundan, bu dağılımı, bulaşan-bulaşan çiftlerinin bulaşma süreleri arasındaki gecikmeyi hesaplayarak satır listesinden tahmin edebiliriz. Bunu yapmak için, epicontacts paketindeki kullanışlı get_pairwise fonksiyonunu kullanıyoruz. Bu, iletim çiftleri arasındaki satır listesi özelliklerinin ikili farklılıklarını hesaplamamıza izin veriyor. Önce bir epicontacts nesnesi oluşturuyoruz (daha fazla ayrıntı için [İletim zincirleri] sayfasına bakabilirsiniz):\n\n## kişileri oluştur\ncontacts &lt;- linelist %&gt;%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %&gt;%\n  drop_na()\n\n## temaslı kişileri oluştur\nepic &lt;- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n\nDaha sonra, “get_pairwise” kullanılarak hesaplanan iletim çiftleri arasındaki enfeksiyon sürelerindeki farkı bir gama dağılımına uydururuz:\n\n## gama oluşturma süresini tahmin et\ngeneration_time &lt;- bootstrapped_dist_fit(\n  get_pairwise(epic, \"date_infection\"),\n  dist = \"gamma\",\n  max_value = 20,\n  bootstraps = 1\n)\n\n\n\nEpiNow2 Çalıştırmak\nŞimdi sadece dplyr group_by() ve n() fonskiyonlarıyla kolayca yapabileceğimiz satır listesinden günlük insidansı hesaplamamız gerekiyor. EpiNow2 sütun adlarının “date” ve “confirm” olmasını gerektirdiğini unutmayın.\n\n## başlangıç tarihlerinden insidans almak\ncases &lt;- linelist %&gt;%\n  group_by(date = date_onset) %&gt;%\n  summarise(confirm = n())\n\nDaha sonra ‘epinow’ fonksiyonunu kullanarak Rt değerini tahmin edebiliriz. Girişlerle ilgili bazı notlar:\n\n‘delays’ değişkenine herhangi bir sayıda ‘zincirleme’ gecikme dağılımı sağlayabiliriz; onları sadece ‘delay_opts’ işlevi içindeki incubation_period’ nesnesinin yanına ekleyebiliriz.\n“return_output”, çıktının yalnızca bir dosyaya kaydedilmesini değil, R içinde döndürülmesini sağlar.\n“verbose” ilerlemenin bir okumasını istediğimizi belirtir.\n“horizon”, gelecekteki insidansı kaç gün için tahmin etmek istediğimizi gösterir.\nÇıkarımı ne kadar süreyle çalıştırmak istediğimizi belirtmek için ‘stan’ değişkenine ek seçenekler iletiyoruz. Artan “örnekler” ve “zincirler”, belirsizliği daha iyi karakterize eden daha doğru bir tahmin verecektir, ancak çalışması daha uzun sürecektir..\n\n\n## epinow çalıştır\nepinow_res &lt;- epinow(\n  reported_cases = cases,\n  generation_time = generation_time,\n  delays = delay_opts(incubation_period),\n  return_output = TRUE,\n  verbose = TRUE,\n  horizon = 21,\n  stan = stan_opts(samples = 750, chains = 4)\n)\n\n\n\nÇıktıları analiz etme\nKodun çalışması bittiğinde, aşağıdaki gibi çok kolay bir şekilde bir özet çizebiliriz. Resmin tamamını görmek için kaydırınız.\n\n## özet grafiği çiz\nplot(epinow_res)\n\n\n\n\n\n\n\n\nAyrıca çeşitli özet istatistiklere de bakabiliriz:\n\n## özet tablo\nepinow_res$summary\n\n                                 measure                  estimate\n                                  &lt;char&gt;                    &lt;char&gt;\n1: New confirmed cases by infection date                4 (2 -- 6)\n2:        Expected change in daily cases                    Unsure\n3:            Effective reproduction no.        0.88 (0.73 -- 1.1)\n4:                        Rate of growth -0.012 (-0.028 -- 0.0052)\n5:          Doubling/halving time (days)          -60 (130 -- -25)\n    numeric_estimate\n              &lt;list&gt;\n1: &lt;data.table[1x9]&gt;\n2:              0.56\n3: &lt;data.table[1x9]&gt;\n4: &lt;data.table[1x9]&gt;\n5: &lt;data.table[1x9]&gt;\n\n\nDaha fazla analiz ve özel çizim için, $estimates$summarised üzerinden özetlenen günlük tahminlere erişebilirsiniz. dplyr ile kullanım kolaylığı için bunu varsayılan ’veri.tablosu’ndan ’tibble’a çevireceğiz.\n\n## özeti çıkar ve tibble'a dönüştür\nestimates &lt;- as_tibble(epinow_res$estimates$summarised)\nestimates\n\n\n\n\n\n\n\nÖrnek olarak, ikiye katlama süresinin ve Rt’nin bir grafiğini yapalım. Aşırı yüksek katlama zamanlarını planlamaktan kaçınmak için, Rt birin çok üzerinde olduğunda, salgının yalnızca ilk birkaç ayına bakacağız.\nTahmini büyüme oranından iki katına çıkma süresini hesaplamak için “log(2)/growth_rate” formülünü kullanırız.\n\n## medyan çizim için geniş df yapın\ndf_wide &lt;- estimates %&gt;%\n  filter(\n    variable %in% c(\"growth_rate\", \"R\"),\n    date &lt; as.Date(\"2014-09-01\")\n  ) %&gt;%\n  ## büyüme oranlarını ikiye katlama sürelerine dönüştürme\n  mutate(\n    across(\n      c(median, lower_90:upper_90),\n      ~ case_when(\n        variable == \"growth_rate\" ~ log(2)/.x,\n        TRUE ~ .x\n      )\n    ),\n    ## dönüşümü yansıtmak için değişkeni yeniden adlandırın\n    variable = replace(variable, variable == \"growth_rate\", \"doubling_time\")\n  )\n\n## nicel çizim için uzun df yapın\ndf_long &lt;- df_wide %&gt;%\n  ## burada eşleşen nicelikleri eşleştiriyoruz (örneğin, alt_90 ila üst_90)\n  pivot_longer(\n    lower_90:upper_90,\n    names_to = c(\".value\", \"quantile\"),\n    names_pattern = \"(.+)_(.+)\"\n  )\n\n## grafik yapın\nggplot() +\n  geom_ribbon(\n    data = df_long,\n    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = date, y = median)\n  ) +\n  ## alt simge etiketine izin vermek için label_parsed kullanın\n  facet_wrap(\n    ~ variable,\n    ncol = 1,\n    scales = \"free_y\",\n    labeller = as_labeller(c(R = \"R[t]\", doubling_time = \"Doubling~time\"), label_parsed),\n    strip.position = 'left'\n  ) +\n  ## nicel şeffaflığı manuel olarak tanımla\n  scale_alpha_manual(\n    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = NULL,\n    alpha = \"Credibel\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    strip.background = element_blank(),\n    strip.placement = 'outside'\n  )\n\n\n\n\n\n\n\n\n\n\n\n\nEpiEstim\nEpiEstim’i çalıştırmak için günlük insidans hakkında veri sağlamamız ve seri aralığı (yani semptomların başlangıcı arasındaki gecikmelerin dağılımını (birincil ve ikincil vakalar) belirtmemiz gerekir).\nİnsidans verileri EpiEstim’e bir vektör, veri çerçevesi veya orijinal insidans paketinden bir “insidans” nesnesi olarak sağlanabilir. İçe aktamalar ve yerel olarak edinilen enfeksiyonlar arasında bile ayrım yapabilirsiniz. Daha fazla detay için ?estimate_R adresindeki belgelere bakabilirsiniz.\nGirdiyi incidence2 kullanarak oluşturacağız. incidence2 paketiyle ilgili daha fazla örnek için [Salgın eğrileri] ile ilgili sayfaya bakabilirsiniz. incidence2 paketinde, “estimateR()”nin beklenen girdisiyle tam olarak uyuşmayan güncellemeler olduğundan, gerekli bazı küçük ek adımlar vardır. İnsidans nesnesi, tarihlerin ve ilgili vaka sayılarının bulunduğu bir tibble’dan oluşur. Tüm tarihlerin dahil edildiğinden emin olmak için tidyr’den ‘complete()’ kullanırız. Daha sonra sonraki bir adımda ‘estimate_R()’ tarafından beklenenle hizalanacak şekilde sütunları ‘yeniden adlandırın()’.\n\n## başlangıç tarihinden itibaren insidansı almak\ncases &lt;- incidence2::incidence(linelist, date_index = \"date_onset\") %&gt;% # günlere göre vaka sayılarını al\n  tidyr::complete(date_index = seq.Date(                              # tüm tarihlerin temsil edildiğinden emin olun\n    from = min(date_index, na.rm = T),\n    to = max(date_index, na.rm=T),\n    by = \"day\"),\n    fill = list(count = 0)) %&gt;%                                       # NA sayılarını 0'a çevir\n  rename(I = count,                                                   # EstimateR'a göre beklenen adlarla yeniden adlandırın\n         \n         dates = date_index)\n\nPaket, ayrıntıları “?estimate_R” adresindeki belgelerde sağlanan seri aralığı belirtmek için çeşitli seçenekler sunar. Biz burada bunlardan ikisini ele alacağız.\n\nLiteratürden seri aralık tahminlerini kullanma\nmethod = \"parametric_si\" seçeneğini kullanarak, make_configfonksiyonu kullanılarak oluşturulan birconfig` nesnesindeki seri aralığın ortalamasını ve standart sapmasını manuel olarak belirtebiliriz. [Bu belgede] https://bmcmedicine.biomedcentral.com/articles/10.1186/s12916-014-0196-0’da tanımlanan sırasıyla 12,0 ve 5,2’lik bir ortalama ve standart sapma kullanıyoruz:\n\n## make config\nconfig_lit &lt;- make_config(\n  mean_si = 12.0,\n  std_si = 5.2\n)\n\nDaha sonra estimate_R fonksiyonuyla Rt değerini tahmin edebiliriz:\n\ncases &lt;- cases %&gt;% \n     filter(!is.na(date))\n#create a dataframe for the function estimate_R()\ncases_incidence &lt;- data.frame(dates = seq.Date(from = min(cases$dates),\n                               to = max(cases$dates), \n                               by = 1))\ncases_incidence &lt;- left_join(cases_incidence, cases) %&gt;% \n     select(dates, I) %&gt;% \n     mutate(I = ifelse(is.na(I), 0, I))\n\nJoining with `by = join_by(dates)`\n\nepiestim_res_lit &lt;- estimate_R(\n  incid = cases_incidence,\n  method = \"parametric_si\",\n  config = config_lit\n)\n\nDefault config will estimate R on weekly sliding windows.\n    To change this change the t_start and t_end arguments. \n\n\nve çıktıların bir özetini çizin:\n\nplot(epiestim_res_lit)\n\n\n\n\n\n\n\n\n\n\nVerilerden seri aralık tahminlerini kullanma\nSemptom başlangıç tarihlerine ve iletim bağlantılarına ilişkin verilere sahip olduğumuz için, bulaştırıcı-enfekte çiftlerinin başlangıç tarihleri arasındaki gecikmeyi hesaplayarak satır listesinden seri aralığı da tahmin edebiliriz. EpiNow2 bölümünde yaptığımız gibi, epicontacts paketindeki get_pairwise fonksiyonunu kullanacağız, bu da iletim çiftleri arasındaki satır listesi özelliklerinin ikili farklarını hesaplamamızı sağlar. Önce bir epicontacts nesnesi oluşturuyoruz (daha fazla ayrıntı için [İletim zincirleri] sayfasına bakın):\n\n## kişileri oluştur\ncontacts &lt;- linelist %&gt;%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %&gt;%\n  drop_na()\n\n## temaslıları oluştur\nepic &lt;- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n\nDaha sonra, “get_pairwise” kullanılarak hesaplanan iletim çiftleri arasındaki başlangıç tarihlerindeki farkı bir gama dağılımına uydururuz. Bu yerleştirme prosedürü için epitrix paketindeki kullanışlı ’fit_disc_gamma’yı kullanıyoruz, çünkü bir ayrıştırılmış dağıtıma ihtiyacımız var.\n\n## gama seri aralığını tahmin et\nserial_interval &lt;- fit_disc_gamma(get_pairwise(epic, \"date_onset\"))\n\nDaha sonra bu bilgiyi config nesnesine iletiyoruz, EpiEstim’i tekrar çalıştırıyoruz ve sonuçları çiziyoruz:\n\n## yapılandırma yap\nconfig_emp &lt;- make_config(\n  mean_si = serial_interval$mu,\n  std_si = serial_interval$sd\n)\n\n## epiestim çalıştır\nepiestim_res_emp &lt;- estimate_R(\n  incid = cases_incidence,\n  method = \"parametric_si\",\n  config = config_emp\n)\n\nDefault config will estimate R on weekly sliding windows.\n    To change this change the t_start and t_end arguments. \n\n## grafik çıktısı al\nplot(epiestim_res_emp)\n\n\n\n\n\n\n\n\n\n\nTahmin zaman pencerelerini belirtme\nBu varsayılan seçenekler, haftalık kayan bir tahmin sağlar ve kesin bir tahmin için Rt’ı salgında çok erken tahmin ettiğinize dair bir uyarı görevi görebilir. Aşağıda gösterildiği gibi tahmin için daha ileri bir başlangıç tarihi ayarlayarak bunu değiştirebilirsiniz. Ne yazık ki, EpiEstim, her zaman penceresi için başlangıç ve bitiş tarihlerine atıfta bulunan bir tam sayı vektörü sağlamanız gerektiğinden, bu tahmin sürelerini belirtmek için yalnızca çok hantal bir yol sağlar.\n\n## 1 Haziran'da başlayan bir tarih vektörü tanımlayın\nstart_dates &lt;- seq.Date(\n  as.Date(\"2014-06-01\"),\n  max(cases$dates) - 7,\n  by = 1\n) %&gt;%\n  ## sayısala dönüştürmek için başlangıç tarihini çıkarın\n  `-`(min(cases$dates)) %&gt;%\n  ## tam sayıya çevirin\n  as.integer()\n\n## bir haftalık sürgülü pencere protokolüne altı gün ekleyin\nend_dates &lt;- start_dates + 6\n  \n## yapılandırma yap\nconfig_partial &lt;- make_config(\n  mean_si = 12.0,\n  std_si = 5.2,\n  t_start = start_dates,\n  t_end = end_dates\n)\n\nŞimdi EpiEstim’i yeniden çalıştırıyoruz ve tahminlerin yalnızca Haziran’dan itibaren başladığını görebiliyoruz:\n\n## epiestim'i çalıştır\nepiestim_res_partial &lt;- estimate_R(\n  incid = cases_incidence,\n  method = \"parametric_si\",\n  config = config_partial\n)\n\n## çıktıları grafikleştir\nplot(epiestim_res_partial)\n\n\n\n\n\n\n\n\n\n\nÇıktıları analiz etme\nAna çıkışlara $R üzerinden erişilebilir. Örnek olarak, bir Rt grafiği ve Rt çarpımı ve o gün rapor edilen vaka sayısı tarafından verilen bir “iletim potansiyeli” ölçüsü oluşturacağız. Bu, yeni nesil enfeksiyonda beklenen vaka sayısını temsil eder.\n\n## medyan için geniş veri çerçevesi yapın\ndf_wide &lt;- epiestim_res_lit$R %&gt;%\n  rename_all(clean_labels) %&gt;%\n  rename(\n    lower_95_r = quantile_0_025_r,\n    lower_90_r = quantile_0_05_r,\n    lower_50_r = quantile_0_25_r,\n    upper_50_r = quantile_0_75_r,\n    upper_90_r = quantile_0_95_r,\n    upper_95_r = quantile_0_975_r,\n    ) %&gt;%\n  mutate(\n    ## medyan tarihini t_start ve t_end'den çıkarın\n    dates = epiestim_res_emp$dates[round(map2_dbl(t_start, t_end, median))],\n    var = \"R[t]\"\n  ) %&gt;%\n  ## günlük insidans verilerinde birleştirme  \n  left_join(cases, \"dates\") %&gt;%\n  ## tüm r tahminlerinde riski hesapla\n  mutate(\n    across(\n      lower_95_r:upper_95_r,\n      ~ .x*I,\n      .names = \"{str_replace(.col, '_r', '_risk')}\"\n    )\n  ) %&gt;%\n  ## ayrı r tahminleri ve risk tahminleri\n  pivot_longer(\n    contains(\"median\"),\n    names_to = c(\".value\", \"variable\"),\n    names_pattern = \"(.+)_(.+)\"\n  ) %&gt;%\n  ## faktör seviyeleri atamak\n  mutate(variable = factor(variable, c(\"risk\", \"r\")))\n\n## niceliklerden uzun veri çerçevesi yapmak\ndf_long &lt;- df_wide %&gt;%\n  select(-variable, -median) %&gt;%\n  ## seperate r/risk estimates and quantile levels\n  pivot_longer(\n    contains(c(\"lower\", \"upper\")),\n    names_to = c(\".value\", \"quantile\", \"variable\"),\n    names_pattern = \"(.+)_(.+)_(.+)\"\n  ) %&gt;%\n  mutate(variable = factor(variable, c(\"risk\", \"r\")))\n\n## grafik yapmak\nggplot() +\n  geom_ribbon(\n    data = df_long,\n    aes(x = dates, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = dates, y = median),\n    alpha = 0.2\n  ) +\n  ## alt simge etiketine izin vermek için label_parsed kullanın\n  facet_wrap(\n    ~ variable,\n    ncol = 1,\n    scales = \"free_y\",\n    labeller = as_labeller(c(r = \"R[t]\", risk = \"Transmission~potential\"), label_parsed),\n    strip.position = 'left'\n  ) +\n  ## nicel şeffaflığı manuel olarak tanımla\n  scale_alpha_manual(\n    values = c(`50` = 0.7, `90` = 0.4, `95` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = NULL,\n    alpha = \"Credible\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    strip.background = element_blank(),\n    strip.placement = 'outside'\n  )",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Salgın Modelleme</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.tr.html#tahmini-insidans",
    "href": "new_pages/epidemic_models.tr.html#tahmini-insidans",
    "title": "24  Salgın Modelleme",
    "section": "24.4 Tahmini insidans",
    "text": "24.4 Tahmini insidans\n\nEpiNow2\nEpiNow2, Rt tahmininin yanı sıra, başlık altındaki EpiSoon paketi ile entegrasyon yoluyla Rt tahminini ve vaka sayılarının projeksiyonlarını da destekler. Tek yapmanız gereken, ‘epinow’ fonksiyon çağrınızda, geleceğe kaç gün yansıtmak istediğinizi belirten ‘horizon’ değişkenini belirtmek; EpiNow2’nin nasıl kurulup çalıştırılacağına ilişkin ayrıntılar için “Rt Tahmini” altındaki EpiNow2 bölümüne bakabilirsiniz. Bu bölümde, “epinow_res” nesnesinde saklanan bu analizin çıktılarını çizeceğiz.\n\n## grafik için minimum tarihi belirleyin\nmin_date &lt;- as.Date(\"2015-03-01\")\n\n## özetlenmiş tahminleri çıkar\nestimates &lt;-  as_tibble(epinow_res$estimates$summarised)\n\n## vaka insidansı hakkında ham verileri ayıklayın\nobservations &lt;- as_tibble(epinow_res$estimates$observations) %&gt;%\n  filter(date &gt; min_date)\n\n## vaka sayılarının öngörülen tahminlerini çıkarın\ndf_wide &lt;- estimates %&gt;%\n  filter(\n    variable == \"reported_cases\",\n    type == \"forecast\",\n    date &gt; min_date\n  )\n\n## nicel çizim için daha da uzun formata dönüştürün\ndf_long &lt;- df_wide %&gt;%\n  ## burada eşleşen nicelikleri eşleştiriyoruz (örneğin, alt_90 ila üst_90)\n  pivot_longer(\n    lower_90:upper_90,\n    names_to = c(\".value\", \"quantile\"),\n    names_pattern = \"(.+)_(.+)\"\n  )\n\n## çizimi yapın\nggplot() +\n  geom_histogram(\n    data = observations,\n    aes(x = date, y = confirm),\n    stat = 'identity',\n    binwidth = 1\n  ) +\n  geom_ribbon(\n    data = df_long,\n    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = date, y = median)\n  ) +\n  geom_vline(xintercept = min(df_long$date), linetype = 2) +\n  ## nicel şeffaflığı manuel olarak tanımla\n  scale_alpha_manual(\n    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = \"Daily reported cases\",\n    alpha = \"Credible\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14)\n\n\n\n\n\n\n\n\n\n\nProjeksiyonlar\nRECON tarafından geliştirilen projeksiyonlar paketi, etkin üreme sayısı Rt ve seri aralığı hakkında bilgi gerektiren kısa vadeli insidans tahminleri yapmayı çok kolaylaştırır. Burada literatürden seri aralık tahminlerinin nasıl kullanılacağını ve satır listesinden kendi tahminlerimizin nasıl kullanılacağını ele alacağız.\n\nLiteratürden seri aralık tahminlerini kullanma\nprojeksiyonlar, discrete paketinden ‘discrete’ sınıfının ayrık bir seri aralık dağılımını gerektirir. Bu yazıda tanımlanan ortalama 12.0 ve standart sapması 5.2 olan bir gama dağılımı kullanacağız. Bu değerleri bir gama dağılımı için gereken şekil ve ölçek parametrelerine dönüştürmek için, epitrix paketindeki ‘gamma_mucv2shapescale’ fonkdiyonunu kullanacağız.\n\n## ortalama mu ve katsayısından şekil ve ölçek parametreleri alın\n## varyasyon (ör. standart sapmanın ortalamaya oranı)\nshapescale &lt;- epitrix::gamma_mucv2shapescale(mu = 12.0, cv = 5.2/12)\n\n## ayrık nesne yapmak\nserial_interval_lit &lt;- distcrete::distcrete(\n  name = \"gamma\",\n  interval = 1,\n  shape = shapescale$shape,\n  scale = shapescale$scale\n)\n\nİşte seri aralığın doğru göründüğünden emin olmak için hızlı bir kontrol. Az önce tanımladığımız gama dağılımının yoğunluğuna, ‘dgamma’ çağırmaya eşdeğer olan ‘$d’ ile erişiriz:\n\n## seri aralığın doğru göründüğünden emin olmak için kontrol edin\nqplot(\n  x = 0:50, y = serial_interval_lit$d(0:50), geom = \"area\",\n  xlab = \"Serial interval\", ylab = \"Density\"\n)\n\nWarning: `qplot()` was deprecated in ggplot2 3.4.0.\n\n\n\n\n\n\n\n\n\n\n\nVerilerinden seri aralık tahminlerini kullanma\nSemptom başlangıç tarihlerine ve iletim bağlantılarına ilişkin verilere sahip olduğumuz için, bulaştırıcı-enfekte çiftlerinin başlangıç tarihleri arasındaki gecikmeyi hesaplayarak satır listesinden seri aralığı da tahmin edebiliriz. EpiNow2 bölümünde yaptığımız gibi, epicontacts paketindeki get_pairwise fonksiyonunu kullanacağız. Bu da iletim çiftleri arasındaki satır listesi özelliklerinin ikili farklarını hesaplamamıza izin verir. Önce bir epicontacts nesnesi oluşturuyoruz (daha fazla ayrıntı için [İletim zincirleri] sayfasına bakabilirsiniz:\n\n## kişileri üretin \ncontacts &lt;- linelist %&gt;%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %&gt;%\n  drop_na()\n\n## temaslı kişileri üretin\nepic &lt;- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n\nDaha sonra iletim çiftleri arasındaki başlangıç tarihlerindeki farkı bir gama dağılımına uydururuz, “get_pairwise” kullanarak hesaplarız. Ayrık bir dağıtım gerektirdiğinden, bu yerleştirme prosedürü için epitrix paketindeki kullanışlı ’fit_disc_gamma’yı kullanıyoruz.\n\n## gama seri aralığını tahmin et\nserial_interval &lt;- fit_disc_gamma(get_pairwise(epic, \"date_onset\"))\n\n## tahmini inceleme\nserial_interval[c(\"mu\", \"sd\")]\n\n$mu\n[1] 11.51047\n\n$sd\n[1] 7.696056\n\n\n\n\nTahmini insidans\nGelecekteki vakaları tahmin etmek için, yine de bir “insidans” nesnesi şeklinde tarihsel vakayı ve ayrıca makul Rt değerleri örneğini sağlamamız gerekiyor. Bu değerleri, önceki bölümde (“Tahmini Rt” başlığı altında) EpiEstim tarafından oluşturulan ve ‘epiestim_res_emp’ nesnesi içinde depolanan Rt tahminlerini kullanarak üreteceğiz. Aşağıdaki kodda, Rt için ortalama ve standart sapma tahminlerini çıkarıyoruz. Salgının son zaman penceresi (bir vektördeki son öğeye erişmek için “tail” fonksiyonunu kullanarak) ve “rgamma” kullanarak bir gama dağılımından 1000 değeri simüle edin. İleriye dönük projeksiyonlar için kullanmak istediğiniz kendi Rt değerleri vektörünüzü de sağlayabilirsiniz.\n\n## başlangıç tarihlerinden insidans nesnesi oluşturun\ninc &lt;- incidence::incidence(linelist$date_onset)\n\n256 missing observations were removed.\n\n## en son tahminden makul r değerleri çıkar\nmean_r &lt;- tail(epiestim_res_emp$R$`Mean(R)`, 1)\nsd_r &lt;- tail(epiestim_res_emp$R$`Std(R)`, 1)\nshapescale &lt;- gamma_mucv2shapescale(mu = mean_r, cv = sd_r/mean_r)\nplausible_r &lt;- rgamma(1000, shape = shapescale$shape, scale = shapescale$scale)\n\n## dağıtımı kontrol et\nqplot(x = plausible_r, geom = \"histogram\", xlab = expression(R[t]), ylab = \"Counts\")\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nDaha sonra gerçek tahmini yapmak için project() fonksiyonunu kullanırız. ‘n_days’ değişkenleri ile kaç gün için projeksiyon yapmak istediğimizi ve ‘n_sim’ değişkeni kullanarak simülasyonların sayısını belirliyoruz.\n\n## projeksiyon yapma\nproj &lt;- project(\n  x = inc,\n  R = plausible_r,\n  si = serial_interval$distribution,\n  n_days = 21,\n  n_sim = 1000\n)\n\nDaha sonra ‘plot()’ ve ‘add_projections()’ fonksiyonlarını kullanarak insidansı ve projeksiyonları kolayca çizebiliriz. Köşeli parantez operatörünü kullanarak yalnızca en son durumları göstermek için ‘insidans’ nesnesini kolayca alt kümeye koyabiliriz.\n\n## insidans ve projeksiyon çizimi\nplot(inc[inc$dates &gt; as.Date(\"2015-03-01\")]) %&gt;%\n  add_projections(proj)\n\n\n\n\n\n\n\n\nÇıktıyı bir veri çerçevesine dönüştürerek günlük vaka sayılarının ham tahminlerini de kolayca çıkarabilirsiniz.\n\n## ham veriler için veri çerçevesine dönüştür\nproj_df &lt;- as.data.frame(proj)\nproj_df",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Salgın Modelleme</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.tr.html#kaynaklar",
    "href": "new_pages/epidemic_models.tr.html#kaynaklar",
    "title": "24  Salgın Modelleme",
    "section": "24.5 Kaynaklar",
    "text": "24.5 Kaynaklar\n\nEpiEstim’de uygulanan metodolojiyi açıklayan makale.\nEpiNow2’de uygulanan metodolojiyi açıklayan makale.\nRt tahminine yönelik çeşitli metodolojik ve pratik hususları açıklayan makale.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Salgın Modelleme</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.tr.html",
    "href": "new_pages/contact_tracing.tr.html",
    "title": "25  Temaslı izlemi",
    "section": "",
    "text": "25.1 Hazırlık",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Temaslı izlemi</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.tr.html#hazırlık",
    "href": "new_pages/contact_tracing.tr.html#hazırlık",
    "title": "25  Temaslı izlemi",
    "section": "",
    "text": "Paketleri yükleyin\nBu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() vurgusunu yapıyoruz. base R’dan library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakın.\n\npacman::p_load(\n  rio,          # veriyi içe aktar  \n  here,         # göreli dosya yolları  \n  janitor,      # veri temizleme ve tablolar\n  lubridate,    # tarihlerle çalışmak\n  epikit,       # age_categories() fonksiyonu\n  apyramid,     # yal piramitleri\n  tidyverse,    # veri işleme ve görselleştirme\n  RColorBrewer, # renk paletleri\n  formattable,  # süslü tablolar\n  kableExtra    # tablo biçimlendirme\n)\n\n\n\nVerileri içe aktarma\nKişilerin ve “takiplerinin” örnek veri kümelerini içe aktaracağız. Bu veriler Go.Data API’sinden alınmış, yuvalanmamış ve “.rds” dosyaları olarak depolanmıştır.\nBu el kitabı için tüm örnek verileri [El kitabını ve verileri indir] sayfasından indirebilirsiniz.\nBu sayfaya özel örnek temaslı izleme verilerini indirmek istiyorsanız, aşağıdaki üç indirme bağlantısını kullanın:\n İndire tıklayınız vaka inceleme verileri (.rds file) \n İndire tıklayınız iletişim kayıt verileri (.rds file) \n İndire tıklayınız temaslı izlem verileri (.rds file) \n\n\n\nİndirilebilir dosyalardaki orijinal formlarında, veriler Go.Data API’si tarafından sağlanan verileri yansıtır (API’ler hakkında bilgi edinin). Örneğin, buradaki amaçlar için, bu sayfada okumayı kolaylaştıracak verileri temizleyeceğiz. Bir Go.Data örneği kullanıyorsanız, verilerinizi nasıl alacağınıza ilişkin talimatların tamamını buradan görüntüleyebilirsiniz.\nAşağıda, veri kümeleri rio paketinden import() fonksiyonu kullanılarak içe aktarılır. Verileri içe aktarmanın çeşitli yolları için [İçe ve dışa aktar] hakkındaki sayfaya bakın. Dosya yolunu belirtmek için burada() kullanıyoruz - bilgisayarınıza özel dosya yolunu sağlamalısınız. Daha sonra gösterim amacıyla basitleştirmek için verilerin yalnızca belirli sütunlarını seçmek için select() kullanırız.\n\nVaka verileri\nBu veriler, vakaların bir tablosu ve bunlarla ilgili bilgilerdir.\n\ncases &lt;- import(here(\"data\", \"godata\", \"cases_clean.rds\")) %&gt;% \n  select(case_id, firstName, lastName, gender, age, age_class,\n         occupation, classification, was_contact, hospitalization_typeid)\n\nnrow(cases) vakaları :\n\n\n\n\n\n\n\n\nKişi verileri\nBu veriler, tüm kişilerin ve bunlarla ilgili bilgilerin bir tablosudur. Yine, kendi dosya yolunuzu sağlayın. İçe aktardıktan sonra, aşağıdakileri içeren birkaç ön veri temizleme adımı gerçekleştiririz:\n\nAge_class’ı bir faktör olarak ayarlayın ve seviye sırasını tersine çevirin, böylece daha genç yaşlar ilk sırada yer alır.\nBirini yeniden adlandırırken yalnızca belirli sütunu seçin\nBazı örnek görselleştirmelerin netliğini artırmak için, yönetici düzeyi 2 eksik olan satırları “Djembe”ye yapay olarak atayın\n\n\ncontacts &lt;- import(here(\"data\", \"godata\", \"contacts_clean.rds\")) %&gt;% \n  mutate(age_class = forcats::fct_rev(age_class)) %&gt;% \n  select(contact_id, contact_status, firstName, lastName, gender, age,\n         age_class, occupation, date_of_reporting, date_of_data_entry,\n         date_of_last_exposure = date_of_last_contact,\n         date_of_followup_start, date_of_followup_end, risk_level, was_case, admin_2_name) %&gt;% \n  mutate(admin_2_name = replace_na(admin_2_name, \"Djembe\"))\n\nnrow(contacts), contacts verisetinin satırları:\n\n\n\n\n\n\n\n\nTakip verileri\nBu veriler, ilgili kişilerle “takip” etkileşimlerinin kayıtlarıdır. Her temasın, maruz kaldıktan sonra 14 gün boyunca her gün bir karşılaşma yapması gerekiyor.\nBirkaç temizleme adımını içe aktarıp gerçekleştiriyoruz. Belirli sütunları seçiyoruz ve ayrıca bir karakter sütununu tüm küçük harf değerlerine dönüştürüyoruz.\n\nfollowups &lt;- rio::import(here::here(\"data\", \"godata\", \"followups_clean.rds\")) %&gt;% \n  select(contact_id, followup_status, followup_number,\n         date_of_followup, admin_2_name, admin_1_name) %&gt;% \n  mutate(followup_status = str_to_lower(followup_status))\n\n” nrow(followups)“-row”followups” veri kümesinin ilk 50 satırı (her satır bir takip etkileşimidir ve sonuç durumu “followup_status” sütunundadır):\n\n\n\n\n\n\n\n\nİlişki verileri\nBurada vakalar ve kişiler arasındaki ilişkiyi gösteren verileri içe aktarıyoruz. Gösterilecek belirli bir sütunu seçiyoruz.\n\nrelationships &lt;- rio::import(here::here(\"data\", \"godata\", \"relationships_clean.rds\")) %&gt;% \n  select(source_visualid, source_gender, source_age, date_of_last_contact,\n         date_of_data_entry, target_visualid, target_gender,\n         target_age, exposure_type)\n\nAşağıda, vakalar ve ilgili kişiler arasındaki tüm ilişkileri kaydeden “ilişkiler” veri kümesinin ilk 50 satırı verilmiştir.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Temaslı izlemi</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.tr.html#tanımlayıcı-analizler",
    "href": "new_pages/contact_tracing.tr.html#tanımlayıcı-analizler",
    "title": "25  Temaslı izlemi",
    "section": "25.2 Tanımlayıcı analizler",
    "text": "25.2 Tanımlayıcı analizler\nVakalarınız, temaslılarınız ve ilişkileri hakkında tanımlayıcı analizler yapmak için bu el kitabının diğer sayfalarında kapsanan teknikleri kullanabilirsiniz. Aşağıda bazı örnekler verilmiştir.\n\nDemografi\n[Demografik piramitler][Demografik piramitler ve Likert ölçekleri] ile ilgili sayfada gösterildiği gibi, yaş ve cinsiyet dağılımını görselleştirebilirsiniz (burada apyramid paketini kullanıyoruz).\n\nTemaslıların yaşı ve cinsiyeti\nAşağıdaki piramit, temaslıların yaş dağılımını cinsiyete göre karşılaştırmaktadır. Yaşı eksik olan kişilerin en üstteki bilinmeyen çubuklarına dahil edildiğini unutmayın. Bu varsayılan davranışı değiştirebilirsiniz, ancak daha sonra bir başlıkta eksik olan numarayı listelemeyi düşünebilirsiniz.\n\napyramid::age_pyramid(\n  data = contacts,                                   # temaslı verisetini kullanma\n  age_group = \"age_class\",                           # kategorik yaş sütunu\n  split_by = \"gender\") +                             # piramidin yarısının cinsiyeti\n  labs(\n    fill = \"Gender\",                                 # göstergenin başlığı\n    title = \"Age/Sex Pyramid of COVID-19 contacts\")+ # grafiğin başlığı\n  theme_minimal()                                    # basit arkaplan\n\n\n\n\n\n\n\n\nGo.Data veri yapısıyla, ‘ilişkiler’ veri kümesi hem vakaların hem de ilgili kişilerin yaşlarını içerir, böylece bu veri kümesini kullanabilir ve bu iki insan grubu arasındaki farkları gösteren bir yaş piramidi oluşturabilirsiniz. “İlişkiler” veri çerçevesi, sayısal yaş sütunlarını kategorilere dönüştürmek için değiştirilecektir (bkz. [Temizleme verileri ve temel işlevler] sayfası). Ayrıca, ggplot2 ile çizimi kolaylaştırmak için veri çerçevesini daha uzun süre döndürürüz (bkz. [Özetleme verileri]).\n\nrelation_age &lt;- relationships %&gt;% \n  select(source_age, target_age) %&gt;% \n  transmute(                              # transmute, mutate() gibidir ancak bahsedilmeyen tüm diğer sütunları kaldırır\n    source_age_class = epikit::age_categories(source_age, breakers = seq(0, 80, 5)),\n    target_age_class = epikit::age_categories(target_age, breakers = seq(0, 80, 5)),\n    ) %&gt;% \n  pivot_longer(cols = contains(\"class\"), names_to = \"category\", values_to = \"age_class\")  \n\n\nrelation_age\n\n# A tibble: 200 × 2\n   category         age_class\n   &lt;chr&gt;            &lt;fct&gt;    \n 1 source_age_class 80+      \n 2 target_age_class 15-19    \n 3 source_age_class &lt;NA&gt;     \n 4 target_age_class 50-54    \n 5 source_age_class &lt;NA&gt;     \n 6 target_age_class 20-24    \n 7 source_age_class 30-34    \n 8 target_age_class 45-49    \n 9 source_age_class 40-44    \n10 target_age_class 30-34    \n# ℹ 190 more rows\n\n\nŞimdi bu dönüştürülmüş veri setini daha önce olduğu gibi ‘age_pyramid()’ ile çizebiliriz, ancak ‘gender’ yerine ‘category’ (temaslı veya vaka) koyabiliriz.\n\napyramid::age_pyramid(\n  data = relation_age,                               # değiştirilmiş ilişki veri kümesini kullan\n  age_group = \"age_class\",                           # kategorik yaş sütunu\n  split_by = \"category\") +                           # vakalar ve temaslılar tarafından\n  scale_fill_manual(\n    values = c(\"orange\", \"purple\"),                  # renkleri VE etiketleri belirtmek için\n    labels = c(\"Case\", \"Contact\"))+\n  labs(\n    fill = \"Legend\",                                           # göstergenin başlığı\n    title = \"Age/Sex Pyramid of COVID-19 contacts and cases\")+ # grafiğin başlığı\n  theme_minimal()                                              # basit arkaplan\n\n\n\n\n\n\n\n\nMesleki dağılım gibi diğer özellikleri de görebiliriz (örneğin pasta grafiği şeklinde).\n\n# Veri kümesini temizleyin ve mesleğe göre sayıları alın\nocc_plot_data &lt;- cases %&gt;% \n  mutate(occupation = forcats::fct_explicit_na(occupation),  # NA eksik değerleri bir kategori yapın\n         occupation = forcats::fct_infreq(occupation)) %&gt;%   # sıklık sırasına göre sıra faktörü seviyeleri\n  count(occupation)                                          # mesleğe göre sayıları alın\n  \n# pasta grafiği yapın\nggplot(data = occ_plot_data, mapping = aes(x = \"\", y = n, fill = occupation))+\n  geom_bar(width = 1, stat = \"identity\") +\n  coord_polar(\"y\", start = 0) +\n  labs(\n    fill = \"Occupation\",\n    title = \"Known occupations of COVID-19 cases\")+\n  theme_minimal() +                    \n  theme(axis.line = element_blank(),\n        axis.title = element_blank(),\n        axis.text = element_blank())\n\n\n\n\n\n\n\n\n\n\n\nVaka başına kişi sayısı\nVaka başına temaslı sayısı, temaslı numaralandırmanın kalitesini ve nüfusun halk sağlığı müdahalesine uygunluğunu değerlendirmek için önemli bir ölçü olabilir.\nVeri yapınıza bağlı olarak bu, tüm vakaları ve ilgili kişileri içeren bir veri seti ile değerlendirilebilir. Go.Data veri kümelerinde, vakalar (“kaynaklar”) ve kişiler (“hedefler”) arasındaki bağlantılar “ilişkiler” veri kümesinde depolanır.\nBu veri kümesinde her satır bir ilgili kişidir ve kaynak vaka satırda listelenir. Birden fazla vakayla ilişkisi olan hiç kimse yok, ancak bu varsa, planlamadan önce olanları hesaba katmanız gerekebilir (ve onları da keşfedin!).\nKaynak vaka başına satır (kişi) sayısını sayarak başlarız. Bu bir veri çerçevesi olarak kaydedilir.\n\ncontacts_per_case &lt;- relationships %&gt;% \n  count(source_visualid)\n\ncontacts_per_case\n\n   source_visualid  n\n1   CASE-2020-0001 13\n2   CASE-2020-0002  5\n3   CASE-2020-0003  2\n4   CASE-2020-0004  4\n5   CASE-2020-0005  5\n6   CASE-2020-0006  3\n7   CASE-2020-0008  3\n8   CASE-2020-0009  3\n9   CASE-2020-0010  3\n10  CASE-2020-0012  3\n11  CASE-2020-0013  5\n12  CASE-2020-0014  3\n13  CASE-2020-0016  3\n14  CASE-2020-0018  4\n15  CASE-2020-0022  3\n16  CASE-2020-0023  4\n17  CASE-2020-0030  3\n18  CASE-2020-0031  3\n19  CASE-2020-0034  4\n20  CASE-2020-0036  1\n21  CASE-2020-0037  3\n22  CASE-2020-0045  3\n23            &lt;NA&gt; 17\n\n\nBu verileri bir histogram olarak çizmek için geom_histogram() kullanıyoruz.\n\nggplot(data = contacts_per_case)+        # yukarıda oluşturulan sayım veri çerçevesiyle başlayın\n  geom_histogram(mapping = aes(x = n))+  # vaka başına kişi sayısının histogramını yazdırın\n  scale_y_continuous(expand = c(0,0))+   # y ekseninde 0'ın altındaki fazla boşluğu kaldırın\n  theme_light()+                         # arka planı basitleştirin\n  labs(\n    title = \"Number of contacts per case\",\n    y = \"Cases\",\n    x = \"Contacts per case\"\n  )",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Temaslı izlemi</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.tr.html#temaslı-takibi",
    "href": "new_pages/contact_tracing.tr.html#temaslı-takibi",
    "title": "25  Temaslı izlemi",
    "section": "25.3 Temaslı Takibi",
    "text": "25.3 Temaslı Takibi\nTemaslı izleme verileri genellikle karantinadaki kişilerin günlük semptom kontrollerinin sonuçlarını kaydeden “takip” verilerini içerir. Bu verilerin analizi, yanıt stratejisini bilgilendirebilir, takip kaybı riski altındaki veya hastalık geliştirme riski altındaki temaslıları belirleyebilir.\n\nVeri temizleme\nBu veriler çeşitli biçimlerde bulunabilir. Kişi başına bir satır ve takip eden “gün” başına bir sütun içeren “geniş” formatlı bir Excel sayfası olarak bulunabilirler. “Uzun” ve “geniş” verilerin açıklamaları ve verilerin nasıl daha geniş veya daha uzun döndürüleceği için [Pivoting data] bölümüne bakabilirsiniz.\nGo.Data örneğimizde, bu veriler, takip etkileşimi başına bir satır ile “uzun” bir formatta olan “takipler” veri çerçevesinde depolanır. İlk 50 satır şöyle görünür:\n\n\n\n\n\n\nUYARI: Takip verileriyle uğraşırken mükerrerlere dikkat edin; çünkü belirli bir temaslı için aynı gün içinde birkaç hatalı takip olabilir. Belki bir hata gibi görünüyor ama gerçeği yansıtıyor olabilir - ör. bir iletişim izleyicisi, ilgili kişiye ulaşamadıkları günün erken saatlerinde bir takip formu gönderebilir ve kendilerine daha sonra ulaşıldığında ikinci bir form gönderebilir. Yinelenenleri nasıl ele almak istediğinize ilişkin operasyonel bağlama göre değişecektir. - yalnızca yaklaşımınızı net bir şekilde belgelediğinizden emin olun. \nKaç tane “mükerrer” satır örneğimiz olduğunu görelim:\n\nfollowups %&gt;% \n  count(contact_id, date_of_followup) %&gt;%   # benzersiz contact_days alın\n  filter(n &gt; 1)                             # sayının 1'den fazla olduğu kayıtları görüntüleyin  \n\n  contact_id date_of_followup n\n1       &lt;NA&gt;       2020-09-03 2\n2       &lt;NA&gt;       2020-09-04 2\n3       &lt;NA&gt;       2020-09-05 2\n\n\nÖrnek verilerimizde, bunun geçerli olduğu tek kayıt, kimliği eksik olanlardır! Bunları kaldırabiliriz. Ancak, öğretmek amacıyla, tekilleştirme adımlarını göstereceğiz. Böylece kişi başına günde yalnızca bir izlemi yapılan ile muhatap olunur. Daha fazla ayrıntı için [Tekilleştirme] ile ilgili sayfaya bakabilirsiniz. En son karşılaşma kaydının doğru olduğunu varsayacağız. Ayrıca ‘followup_number’ sütununu (1 - 14 aralığında olması gereken takip “günü”) temizleme fırsatını da kullanıyoruz.\n\nfollowups_clean &lt;- followups %&gt;%\n  \n  # yinelenenleri kaldırın\n  group_by(contact_id, date_of_followup) %&gt;%        # temaslı günü başına grup satırları\n  arrange(contact_id, desc(date_of_followup)) %&gt;%   # takip tarihine göre her temas günü için satırlar düzenleyin (en son en üstte)\n  slice_head() %&gt;%                                  # benzersiz kişi kimliği başına yalnızca ilk satırı tutun  \n  ungroup() %&gt;% \n  \n  # diğer temizlemeler\n  mutate(followup_number = replace(followup_number, followup_number &gt; 14, NA)) %&gt;% # hatalı verileri temizle\n  drop_na(contact_id)                               # eksik contact_id olan satırları kaldırın\n\nHer takip eden karşılaşma için, bir takip durumumuz var (örneğin, karşılaşmanın olup olmadığı ve olduysa, temasta belirti olup olmadığı gibi). Tüm değerleri görmek için ‘followup_status’ ile hızlı bir ‘tabyl()’ (janitor’dan) veya ‘table()’ (R tabanından) (bkz. [Tanımlayıcı tablolar]) sonuçların her birinin sıklığını görebilmek için çalıştırabiliriz.\nBu veri setinde “seen_not_ok”, “semptomlarla görülen” ve “seen_ok”, “semptomsuz görülen” anlamına gelir.\n\nfollowups_clean %&gt;% \n  tabyl(followup_status)\n\n followup_status   n    percent\n          missed  10 0.02325581\n   not_attempted   5 0.01162791\n   not_performed 319 0.74186047\n     seen_not_ok   6 0.01395349\n         seen_ok  90 0.20930233\n\n\n\n\nZaman içinde grafik\nTarih verileri sürekli olduğundan, x eksenine atanan ‘date_of_followup’ ile bunları çizmek için bir histogram kullanacağız. ‘followup_status’ sütununa atadığımız ‘aes()’ içinde bir ‘fill = ’değişkenleri belirleyerek “yığınlanmış” bir histogram elde edebiliriz. Sonuç olarak, ’labs()’ öğesinin ‘fill =’ değişkenini kullanarak gösterge başlığını ayarlayabilirsiniz.\nTemaslıların dalgalar halinde tanımlandığını (muhtemelen salgın vaka dalgalarına karşılık gelen) ve takip tamamlamanın salgın boyunca görünüşte iyileşmediğini görebiliriz.\n\nggplot(data = followups_clean)+\n  geom_histogram(mapping = aes(x = date_of_followup, fill = followup_status)) +\n  scale_fill_discrete(drop = FALSE)+   # göstergedeki tüm faktör seviyelerini (followup_status), kullanılmayanları bile gösterin\n  theme_classic() +\n  labs(\n    x = \"\",\n    y = \"Number of contacts\",\n    title = \"Daily Contact Followup Status\",\n    fill = \"Followup Status\",\n    subtitle = str_glue(\"Data as of {max(followups$date_of_followup, na.rm=T)}\"))   # dinamik altyazı\n\n\n\n\n\n\n\n\nUYARI: Çok sayıda çizim hazırlıyorsanız (örneğin, birden fazla konu için), göstergelerin değişen seviyelerde veri tamamlama veya veri birleştirme ile bile aynı görünmesini isteyeceksiniz. Verilerde tüm takip durumlarının bulunmadığı grafikler olabilir, ancak yine de bu kategorilerin göstergelerde standart olarak görünmesini istiyorsunuz. Ggplot’larda (yukarıdaki gibi), ‘scale_fill_discrete()’ için ‘drop = FALSE’ değişkenini belirtebilirsiniz. Tablolarda, tüm faktör düzeyleri için sayıları gösteren ‘tabyl()’ kullanın veya dplyr’den ‘count()’ kullanıyorsanız, tüm faktör düzeyleri için sayıları dahil etmek için ‘.drop = FALSE’ bağımsız değişkenini ekleyin.\n\n\nGünlük bireysel izleme\nSalgınınız yeterince küçükse, her bir kişiye ayrı ayrı bakmak ve takipleri boyunca durumlarını görmek isteyebilirsiniz. Neyse ki, bu “izlemeler” veri kümesi halihazırda takip “sayısı” (1-14) sütununu içeriyor. Verilerinizde bu yoksa, karşılaşma tarihi ile ilgili kişi için takibin başlaması amaçlanan tarih arasındaki farkı hesaplayarak oluşturabilirsiniz.\nUygun bir görselleştirme mekanizması (eğer vaka sayısı çok büyük değilse), geom_tile() ile yapılmış bir ısı grafiği olabilir. [Isı grafiği] sayfasında daha fazla ayrıntıya bakın.\n\nggplot(data = followups_clean)+\n  geom_tile(mapping = aes(x = followup_number, y = contact_id, fill = followup_status),\n            color = \"grey\")+       # gri kılavuz çizgileri\n  scale_fill_manual( values = c(\"yellow\", \"grey\", \"orange\", \"darkred\", \"darkgreen\"))+\n  theme_minimal()+\n  scale_x_continuous(breaks = seq(from = 1, to = 14, by = 1))\n\n\n\n\n\n\n\n\n\n\nGrubuna göre analiz et\nBelki de bu takip verileri, operasyonel karar verme için günlük veya haftalık olarak görüntülenmektedir. Coğrafi alana veya kişi izleme ekibine göre daha anlamlı ayrıştırmalar isteyebilirsiniz. Bunu group_by() için sağlanan sütunları ayarlayarak yapabiliriz.\n\nplot_by_region &lt;- followups_clean %&gt;%                                        # takip veri seti ile başlayın\n  count(admin_1_name, admin_2_name, followup_status) %&gt;%   # benzersiz bölge durumuna göre sayıları al (sayılarla 'n' sütununu oluşturur)\n  \n  \n  ggplot(                                         # ggplot() başlatın\n    mapping = aes(x = reorder(admin_2_name, n),     # 'n' sütunundaki sayısal değerlere göre yönetici faktör düzeylerini yeniden sıralayın\n                  y = n,                            # 'n' sütunundan çubuğun yükseklikleri\n                  fill = followup_status,           # durumlarına göre renk yığılmış çubuklar\n                  label = n))+                      # geom_label()'e geçmek için              \n  geom_col()+                                     # yığılmış çubuklar, yukarıdan devredilen haritalama\n  geom_text(                                      # metin ekleme, yukarıdan devredilen haritalama\n    size = 3,                                         \n    position = position_stack(vjust = 0.5), \n    color = \"white\",           \n    check_overlap = TRUE,\n    fontface = \"bold\")+\n  coord_flip()+\n  labs(\n    x = \"\",\n    y = \"Number of contacts\",\n    title = \"Contact Followup Status, by Region\",\n    fill = \"Followup Status\",\n    subtitle = str_glue(\"Data as of {max(followups_clean$date_of_followup, na.rm=T)}\")) +\n  theme_classic()+                                                                      # Arka planı basitleştirin\n  facet_wrap(~admin_1_name, strip.position = \"right\", scales = \"free_y\", ncol = 1)      # yönleri tanıtın\n\nplot_by_region",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Temaslı izlemi</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.tr.html#kpi-tabloları",
    "href": "new_pages/contact_tracing.tr.html#kpi-tabloları",
    "title": "25  Temaslı izlemi",
    "section": "25.4 KPI Tabloları",
    "text": "25.4 KPI Tabloları\nKişi takibi performansını izlemek için farklı ayrıştırma seviyelerinde ve farklı zaman dilimlerinde hesaplanabilen ve izlenebilen bir dizi farklı Temel Performans Göstergesi (KPI) vardır. Hesaplamaları yapıp ve temel tablo formatına sahip olduğunuzda; farklı KPI’ları değiştirmek oldukça kolaydır.\nResolveToSaveLives.org kaynağındaki bu gibi çok sayıda kişi izleme KPI’sı kaynağı vardır. Çalışmanın çoğu, veri yapınızı gözden geçirecek ve tüm dahil etme/hariç tutma kriterlerini düşünecektir. Aşağıda birkaç örnek gösteriyoruz; Go.Data meta veri yapısını kullanarak:\n\n\n\n\n\n\n\n\n\nKategori\nGösterge\nGo.Data Numeratör\nGo.Data paydası\n\n\n\n\nSüreç Göstergesi - Temaslı İzleme Hızı\nVaka raporundan sonraki 24 saat içinde görüşülen ve izole edilen vakaların yüzdesi\n(`date_of_reporting - date_of_data_entry) &lt; 1 gün VE (isolation_startdate - date_of_data_entry) &lt; 1 gün OLDUĞU YERDE “case_id” SAYIMI\n“case_id” SAYIMI\n\n\nİşlem Göstergesi - Kişi İzleme Hızı\nAlındıktan sonraki 24 saat içinde bildirilen ve karantinaya alınan kişilerin yüzdesi\n‘followup_status’ == “SEEN_NOT_OK” VEYA “SEEN_OK” VE ‘date_of_followup’ - ‘date_of_reporting’ &lt; 1 gün OLDUĞU YERDE ‘contact_id’ SAYIMI\n“contact_id” SAYIMI\n\n\nSüreç Göstergesi - Testin Tamlığı\nSemptomların başlamasından sonraki 3 gün içinde test edilen ve görüşülen yeni semptomatik vakaların yüzdesi\n(date_of_reporting - date_of_onset) &lt; =3 gün OLDUĞU YERDE “vaka_kimliği” SAYIMI\n“vaka_kimliği” SAYIMI\n\n\nSonuç Göstergesi - Genel\nmevcut kişi listesindeki yeni vakaların yüzdesi\nwas_contact OLDUĞU YERDE case_id SAYIMI== “TRUE”\ncase_id SAYIMI\n\n\n\nAşağıda, yönetici alanlarındaki iletişim takibini göstermek için güzel bir tablo görseli oluşturmaya yönelik örnek bir alıştırmayı inceleyeceğiz. Sonunda, formattable paketi ile sunuma uygun hale getireceğiz (ancak flextable gibi başka paketleri de kullanabilirsiniz - bkz. [Sunum için tablolar]).\nBunun gibi bir tabloyu nasıl oluşturacağınız, temaslı izleme verilerinizin yapısına bağlı olacaktır. dplyr fonksiyonlarını kullanarak verileri nasıl özetleyeceğinizi öğrenmek için [Açıklayıcı tablolar] sayfasını kullanın.\nDinamik olacak ve veriler değiştikçe değişecek bir tablo oluşturacağız. Sonuçları ilginç hale getirmek için, tabloyu belirli bir günde çalıştırmayı simüle etmemize izin verecek bir “rapor_tarihi” ayarlayacağız (10 Haziran 2020’yi seçiyoruz). Veriler o tarihe kadar filtrelenir.\n\n# Raporun bu tarihten itibaren verilerle çalıştırılmasını simüle etmek için \"Rapor tarihi\"ni ayarlayın\nreport_date &lt;- as.Date(\"2020-06-10\")\n\n# Rapor tarihini yansıtacak takip verileri oluşturun.\ntable_data &lt;- followups_clean %&gt;% \n  filter(date_of_followup &lt;= report_date)\n\nŞimdi, veri yapımıza dayanarak aşağıdakileri yapacağız:\n\n“Takip” verileriyle başlayın ve her benzersiz kişi için içerecek şekilde özetleyin:\n\nEn son kayıt tarihi (karşılaşmanın durumu ne olursa olsun)\nTemaslının “görüldüğü” en son karşılaşma tarihi\nNihai “görülen” karşılaşmadaki karşılaşma durumu (örneğin semptomlu, semptomlar olmadan)\n\nBu verileri genel iletişim durumu, bir temaslıya son maruz kalma tarihi vb. gibi diğer bilgileri içeren temaslı verileriyle birleştirin. Ayrıca, son temastan bu yana geçen gün sayısı gibi her bir ilgili temaslı için ilgilenilen metrikleri hesaplayacağız.\nGelişmiş iletişim verilerini coğrafi bölgeye (admin_2_name) göre gruplandırıyoruz ve bölge başına özet istatistikleri hesaplıyoruz\nSon olarak, sunum için tabloyu güzelce biçimlendiriyoruz.\n\nİlk olarak, ilgilenilen bilgileri almak için takip verilerini özetliyoruz:\n\nfollowup_info &lt;- table_data %&gt;% \n  group_by(contact_id) %&gt;% \n  summarise(\n    date_last_record   = max(date_of_followup, na.rm=T),\n    date_last_seen     = max(date_of_followup[followup_status %in% c(\"seen_ok\", \"seen_not_ok\")], na.rm=T),\n    status_last_record = followup_status[which(date_of_followup == date_last_record)]) %&gt;% \n  ungroup()\n\nİşte veriler böyle görünüyor:\n\n\n\n\n\n\nŞimdi bu bilgiyi “kişiler” veri kümesine ekleyeceğiz ve bazı ek sütunları hesaplayacağız.\n\ncontacts_info &lt;- followup_info %&gt;% \n  right_join(contacts, by = \"contact_id\") %&gt;% \n  mutate(\n    database_date       = max(date_last_record, na.rm=T),\n    days_since_seen     = database_date - date_last_seen,\n    days_since_exposure = database_date - date_of_last_exposure\n    )\n\nİşte veriler böyle görünüyor. Sağdaki “kişiler” sütununu ve en sağdaki yeni hesaplanmış sütunu not edin.\n\n\n\n\n\n\nArdından, özet istatistik sütunlarından oluşan kısa bir veri çerçevesi elde etmek için kişi verilerini bölgeye göre özetleyeceğiz.\n\ncontacts_table &lt;- contacts_info %&gt;% \n  \n  group_by(`Admin 2` = admin_2_name) %&gt;%\n  \n  summarise(\n    `Registered contacts` = n(),\n    `Active contacts`     = sum(contact_status == \"UNDER_FOLLOW_UP\", na.rm=T),\n    `In first week`       = sum(days_since_exposure &lt; 8, na.rm=T),\n    `In second week`      = sum(days_since_exposure &gt;= 8 & days_since_exposure &lt; 15, na.rm=T),\n    `Became case`         = sum(contact_status == \"BECAME_CASE\", na.rm=T),\n    `Lost to follow up`   = sum(days_since_seen &gt;= 3, na.rm=T),\n    `Never seen`          = sum(is.na(date_last_seen)),\n    `Followed up - signs` = sum(status_last_record == \"Seen_not_ok\" & date_last_record == database_date, na.rm=T),\n    `Followed up - no signs` = sum(status_last_record == \"Seen_ok\" & date_last_record == database_date, na.rm=T),\n    `Not Followed up`     = sum(\n      (status_last_record == \"NOT_ATTEMPTED\" | status_last_record == \"NOT_PERFORMED\") &\n        date_last_record == database_date, na.rm=T)) %&gt;% \n    \n  arrange(desc(`Registered contacts`))\n\n\n\n\n\n\n\nVe şimdi, “başlangıç” tarihini gösteren bir dipnot da dahil olmak üzere biçimlendirilebilir ve knitr paketlerinden stil uyguluyoruz.\n\ncontacts_table %&gt;%\n  mutate(\n    `Admin 2` = formatter(\"span\", style = ~ formattable::style(\n      color = ifelse(`Admin 2` == NA, \"red\", \"grey\"),\n      font.weight = \"bold\",font.style = \"italic\"))(`Admin 2`),\n    `Followed up - signs`= color_tile(\"white\", \"orange\")(`Followed up - signs`),\n    `Followed up - no signs`= color_tile(\"white\", \"#A0E2BD\")(`Followed up - no signs`),\n    `Became case`= color_tile(\"white\", \"grey\")(`Became case`),\n    `Lost to follow up`= color_tile(\"white\", \"grey\")(`Lost to follow up`), \n    `Never seen`= color_tile(\"white\", \"red\")(`Never seen`),\n    `Active contacts` = color_tile(\"white\", \"#81A4CE\")(`Active contacts`)\n  ) %&gt;%\n  kable(\"html\", escape = F, align =c(\"l\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\")) %&gt;%\n  kable_styling(\"hover\", full_width = FALSE) %&gt;%\n  add_header_above(c(\" \" = 3, \n                     \"Of contacts currently under follow up\" = 5,\n                     \"Status of last visit\" = 3)) %&gt;% \n  kableExtra::footnote(general = str_glue(\"Data are current to {format(report_date, '%b %d %Y')}\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOf contacts currently under follow up\n\n\nStatus of last visit\n\n\n\nAdmin 2\nRegistered contacts\nActive contacts\nIn first week\nIn second week\nBecame case\nLost to follow up\nNever seen\nFollowed up - signs\nFollowed up - no signs\nNot Followed up\n\n\n\n\nDjembe \n59\n30\n44\n0\n2\n15\n22\n0\n0\n0\n\n\nTrumpet\n3\n1\n3\n0\n0\n0\n0\n0\n0\n0\n\n\nVenu \n2\n0\n0\n0\n2\n0\n2\n0\n0\n0\n\n\nCongas \n1\n0\n0\n0\n1\n0\n1\n0\n0\n0\n\n\nCornet \n1\n0\n1\n0\n1\n0\n1\n0\n0\n0\n\n\n\nNote: \n\n\n\n\n\n\n\n\n\n\n\n\n Data are current to Jun 10 2020",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Temaslı izlemi</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.tr.html#bulaş-matrisleri",
    "href": "new_pages/contact_tracing.tr.html#bulaş-matrisleri",
    "title": "25  Temaslı izlemi",
    "section": "25.5 Bulaş Matrisleri",
    "text": "25.5 Bulaş Matrisleri\n[Isı grafikleri] sayfasında tartışıldığı gibi, “geom_tile()” kullanarak “kimin kime bulaştırdığını” gösteren bir matris oluşturabilirsiniz.\nYeni kişiler oluşturulduğunda, Go.Data bu ilişki bilgilerini “ilişkiler” API uç noktasında saklar ve bu veri setinin ilk 50 satırını aşağıda görebiliriz. Bu, her bir temasın kendi kaynak durumuna zaten katılmış olduğu göz önüne alındığında, nispeten az adımla bir ısı grafiği oluşturabileceğimiz anlamına gelir.\n\n\n\n\n\n\nYukarıda vakaları ve ilgili kişileri karşılaştıran yaş piramidi için yapıldığı gibi, ihtiyacımız olan birkaç değişkeni seçebilir ve hem kaynaklar (vakalar) hem de hedefler (temaslılar) için kategorik yaş gruplamaları içeren sütunlar oluşturabiliriz.\n\nheatmap_ages &lt;- relationships %&gt;% \n  select(source_age, target_age) %&gt;% \n  mutate(                              # transmute fonksiyonu, mutate() gibidir ancak diğer tüm sütunları kaldırır\n    source_age_class = epikit::age_categories(source_age, breakers = seq(0, 80, 5)),\n    target_age_class = epikit::age_categories(target_age, breakers = seq(0, 80, 5))) \n\nDaha önce açıklandığı gibi, çapraz tablo oluşturuyoruz;\n\ncross_tab &lt;- table(\n  source_cases = heatmap_ages$source_age_class,\n  target_cases = heatmap_ages$target_age_class)\n\ncross_tab\n\n            target_cases\nsource_cases 0-4 5-9 10-14 15-19 20-24 25-29 30-34 35-39 40-44 45-49 50-54\n       0-4     0   0     0     0     0     0     0     0     0     1     0\n       5-9     0   0     1     0     0     0     0     1     0     0     0\n       10-14   0   0     0     0     0     0     0     0     0     0     0\n       15-19   0   0     0     0     0     0     0     0     0     0     0\n       20-24   1   1     0     1     2     0     2     1     0     0     0\n       25-29   1   2     0     0     0     0     0     0     0     0     0\n       30-34   0   0     0     0     0     0     0     0     1     1     0\n       35-39   0   2     0     0     0     0     0     0     0     1     0\n       40-44   0   0     0     0     1     0     2     1     0     3     1\n       45-49   1   2     2     0     0     0     3     0     1     0     3\n       50-54   1   2     1     2     0     0     1     0     0     3     4\n       55-59   0   1     0     0     1     1     2     0     0     0     0\n       60-64   0   0     0     0     0     0     0     0     0     0     0\n       65-69   0   0     0     0     0     0     0     0     0     0     0\n       70-74   0   0     0     0     0     0     0     0     0     0     0\n       75-79   0   0     0     0     0     0     0     0     0     0     0\n       80+     1   0     0     2     1     0     0     0     1     0     0\n            target_cases\nsource_cases 55-59 60-64 65-69 70-74 75-79 80+\n       0-4       1     0     0     0     0   0\n       5-9       1     0     0     0     0   0\n       10-14     0     0     0     0     0   0\n       15-19     0     0     0     0     0   0\n       20-24     1     0     0     0     0   1\n       25-29     0     0     0     0     0   0\n       30-34     1     0     0     0     0   0\n       35-39     0     0     0     0     0   0\n       40-44     1     0     0     0     1   1\n       45-49     2     1     0     0     0   1\n       50-54     1     0     1     0     0   1\n       55-59     0     0     0     0     0   0\n       60-64     0     0     0     0     0   0\n       65-69     0     0     0     0     0   0\n       70-74     0     0     0     0     0   0\n       75-79     0     0     0     0     0   0\n       80+       0     0     0     0     0   0\n\n\norantılarla uzun biçime dönüştürün;\n\nlong_prop &lt;- data.frame(prop.table(cross_tab))\n\nve yaşa göre bir ısı haritası oluşturun.\n\nggplot(data = long_prop)+       # oranlarda sıklık olarak uzun veriler kullanın\n  geom_tile(                    # görselleştirin\n    aes(\n      x = target_cases,         # vaka yaşı x ekseninde\n      y = source_cases,         # kaynak yaşı y ekseninde\n      fill = Freq))+            # arkaplan rengi verilerdeki Sıklık sütunudur\n  scale_fill_gradient(          # dolgu rengini ayarlayın\n    low = \"blue\",\n    high = \"orange\")+\n  theme(axis.text.x = element_text(angle = 90))+\n  labs(                         # etiketler\n    x = \"Target case age\",\n    y = \"Source case age\",\n    title = \"Who infected whom\",\n    subtitle = \"Frequency matrix of transmission events\",\n    fill = \"Proportion of all\\ntranmsission events\"     # göstergenin başlığı\n  )",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Temaslı izlemi</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.tr.html#kaynaklar",
    "href": "new_pages/contact_tracing.tr.html#kaynaklar",
    "title": "25  Temaslı izlemi",
    "section": "25.6 Kaynaklar",
    "text": "25.6 Kaynaklar\nhttps://github.com/WorldHealthOrganization/godata/tree/master/analytics/r-reporting\nhttps://worldhealthorganization.github.io/godata/\nhttps://community-godata.who.int/",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Temaslı izlemi</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.tr.html",
    "href": "new_pages/survey_analysis.tr.html",
    "title": "26  Anket analizi",
    "section": "",
    "text": "26.1 Genel bakış\nBu sayfa, anket analizi için çeşitli paketlerin kullanımını göstermektedir.\nÇoğu anket R paketleri, ağırlıklı analiz yapmak için survey paketine güvenir. survey paketinin yanı sıra srvyr (tidyverse-stili kodlamaya izin veren bir survey sarmalayıcısı) ve gtsummary (yayına hazır tablolara izin veren bir survey sarmalayıcısı) kullanacağız. Orijinal survey paketi tidyverse-stili kodlamaya izin vermese de, anket ağırlıklı genelleştirilmiş doğrusal modellere izin verme avantajına sahiptir (bu sayfaya daha sonraki bir tarihte eklenecektir). Örnekleme ağırlıkları oluşturmak için sitrep paketinden bir fonksiyonu kullanmayı da göstereceğiz (n.b , bu paket şu anda CRAN’da değil, ancak github’dan kurulabilir).\nBu sayfanın çoğu “R4Epis” projesi için yapılan çalışmalara dayanmaktadır; ayrıntılı kod ve R-markdown şablonları için “R4Epis” github sayasına bakabilirsiniz. survey paketine ait kodlardan bazıları, EPIET vaka çalışmalarının ilk sürümlerini temel almaktadır.\nŞu anda bu sayfa, örneklem büyüklüğü hesaplamalarını veya örneklemeyi ele almamaktadır. Örnek boyutu hesaplayıcıyı kullanmak için basit bir kullanım için OpenEpi’ye bakabilirsiniz. El kitabının GIS temelleri sayfasında eninde sonunda uzamsal rastgele örnekleme üzerine bir bölüm mevcuttur ve bu sayfa sonunda örnekleme çerçeveleri ve örnek boyutu hesaplamaları hakkında bir bölüme sahip olacaktır.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Anket analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.tr.html#genel-bakış",
    "href": "new_pages/survey_analysis.tr.html#genel-bakış",
    "title": "26  Anket analizi",
    "section": "",
    "text": "Anket verisi\nGözlem süresi\nAğırlıklandırma\nAnket tasarım nesneleri\nTanımlayıcı analiz\nAğırlıklı orantılar\nAğırlıklı hızlar",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Anket analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.tr.html#hazırlık",
    "href": "new_pages/survey_analysis.tr.html#hazırlık",
    "title": "26  Anket analizi",
    "section": "26.2 Hazırlık",
    "text": "26.2 Hazırlık\n\nPaketler\nBu kod parçası, analizler için gereken paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman paketinden p_load() fonksiyonunu kullanacağız. Ayrıca R tabanı’dan library() ile paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakabilirsiniz.\nBurada ayrıca, github’dan henüz CRAN’da yayınlanmayan bir paketi yüklemek için pacman paketinden p_load_gh() fonksiyonunu kullanmayı gösteriyoruz.\n\n## paketleri CRAN'dan yükle\npacman::p_load(rio,          # Dosya içe aktarma\n               here,         # Dosya bulucu\n               tidyverse,    # veri yönetimi + ggplot2 grafikleri\n               tsibble,      # zaman serisi veri kümelerini işleme\n               survey,       # anket işlevleri için\n               srvyr,        # anket paketi için dplyr sarmalayıcı\n               gtsummary,    # tablolar üretmek için anket paketi için sarıcı\n               apyramid,     # yaş piramitleri oluşturmaya adanmış bir paket\n               patchwork,    # ggplot'ları birleştirmek için\n               ggforce       # alüvyon/sankey grafikleri için\n               ) \n\n## paketleri github'dan yükle\npacman::p_load_gh(\n     \"R4EPI/sitrep\"          # gözlem süresi / ağırlıklandırma fonksiyonları için\n)\n\n\n\nVeri yükleme\nBu bölümde kullanılan örnek veri kümeleri aşağıda listelenmiştir:\n\nkurgusal ölüm anketi verileri.\naraştırma alanı için kurgusal nüfus sayımları.\nkurgusal ölüm anketi verileri için veri sözlüğü.\n\nBu, MSF OCA etik inceleme kurulu tarafından önceden onaylanmış ankete dayanmaktadır. Kurgusal veri seti “R4Epis” projesi kapsamında üretilmiştir. Bunların tümü, Open Data Kit’e dayalı bir veri toplama yazılımı olan KoboToolbox kullanılarak toplanan verilere dayanmaktadır.\nKobo, hem toplanan verileri hem de bu veri kümesi için veri sözlüğünü dışa aktarmanıza olanak tanır. Veri temizlemeyi basitleştirdiği ve değişkenleri/soruları aramak için kullanışlı olduğu için bunu yapmanızı şiddetle tavsiye etmekteyiz.\nİPUCU: Kobo veri sözlüğünün anket sayfasının “name” sütununda değişken adları vardır. Her değişken için olası değerler, seçenekler sayfasında belirtilmiştir. Seçenekler sekmesinde “name” kısaltılmış değere sahiptir ve “label::english” ve “label::french” sütunları gerekli uzun versiyonlara da sahiptir. Bir Kobo sözlük excel dosyasını içe aktarmak için epidict paketi msf_dict_survey() fonksiyonunu kullanarak bu adları otomatik olarak yeniden biçimlendirebilirsiniz. Bu sayede kodlarınızı tekrardan kullanma şansınız olur.\nDİKKAT: Bu örnek veri kümesi dışa aktarılan formatı ile aynı değildir (Kobo’da farklı anket düzeylerini ayrı ayrı dışa aktardığınız gibi) - farklı düzeyleri birleştirmek için aşağıdaki anket verileri bölümüne bakmalısınız.\nVeri kümesi, rio paketinden import() fonksiyonu kullanılarak içe aktarılır. Verileri içe aktarmanın çeşitli yolları için İçe ve dışa aktarma sayfasına bakın.\n\n# anket verilerini içe aktar\nsurvey_data &lt;- rio::import(\"survey_data.xlsx\")\n\n# sözlüğü R’ın içine aktar\nsurvey_dict &lt;- rio::import(\"survey_dict.xlsx\") \n\nAnketin ilk 10 satırı aşağıda gösterilmiştir.\n\n\n\n\n\n\nUygun ağırlıklar üretebilmemiz için örneklem popülasyonundaki verileri de içe aktarmak istiyoruz. Bu veriler farklı formatlarda olabilir, ancak aşağıda görüldüğü gibi olmasını öneririz (bu sadece bir excel’e yazılabilir).\n\n# nüfus verilerini içe aktar\npopulation &lt;- rio::import(\"population.xlsx\")\n\nAnketin ilk 10 satırı aşağıda gösterilmiştir.\n\n\n\n\n\n\nKüme anketleri için küme düzeyinde anket ağırlıkları eklemek isteyebilirsiniz. Bu verileri yukarıdaki gibi okuyabilirsiniz. Alternatif olarak, yalnızca birkaç sayı varsa, bunlar bir tibble’a aşağıdaki gibi girilebilir. Her durumda, anket verilerinizle eşleşen bir küme tanımlayıcısına sahip bir sütuna ve her bir kümedeki hane sayısını içeren başka bir sütuna ihtiyacınız olacaktır.\n\n## her kümedeki hane sayısını tanımla\ncluster_counts &lt;- tibble(cluster = c(\"village_1\", \"village_2\", \"village_3\", \"village_4\", \n                                     \"village_5\", \"village_6\", \"village_7\", \"village_8\",\n                                     \"village_9\", \"village_10\"), \n                         households = c(700, 400, 600, 500, 300, \n                                        800, 700, 400, 500, 500))\n\n\n\nVeri temizleme\nAşağıdaki kodlar, tarih sütununun uygun biçimde olmasını sağlar. Bunu yapmanın başka yolları da vardır (ayrıntılar için Tarihlerle çalışma sayfasına bakın), ancak tarihleri tanımlamak için sözlüğü kullanmak hızlı ve kolaydır.\nAyrıca **epikit* paketindeki age_categories() fonksiyonunu kullanarak bir yaş grubu değişkeni oluşturuyoruz - ayrıntılar için el kitabındaki Verileri temizleme bölümüne bakabilirsiniz. Ek olarak, çeşitli kümelerin hangi bölgede olduğunu tanımlayan bir karakter değişkeni oluşturuyoruz.\nSon olarak, tüm evet/hayır değişkenlerini DOĞRU/YANLIŞ değişkenlere yeniden kodlarız - aksi takdirde bunlar survey orantı fonksiyonları tarafından kullanılamaz.\n\n## sözlükten tarih değişkeni adlarını seç \nDATEVARS &lt;- survey_dict %&gt;% \n  filter(type == \"date\") %&gt;% \n  filter(name %in% names(survey_data)) %&gt;% \n  ## filter to match the column names of your data\n  pull(name) # select date vars\n  \n## tarihleri değiştir\nsurvey_data &lt;- survey_data %&gt;%\n  mutate(across(all_of(DATEVARS), as.Date))\n\n\n## yıl değişkenine yalnızca ay cinsinden yaşı olanları ekle (on ikiye böl)\nsurvey_data &lt;- survey_data %&gt;% \n  mutate(age_years = if_else(is.na(age_years), \n                             age_months / 12, \n                             age_years))\n\n## yaş grubu değişkenini tanımla\nsurvey_data &lt;- survey_data %&gt;% \n     mutate(age_group = age_categories(age_years, \n                                    breakers = c(0, 3, 15, 30, 45)\n                                    ))\n\n\n## farklı bir değişkenin gruplarına dayalı bir karakter değişkeni oluştur\nsurvey_data &lt;- survey_data %&gt;% \n  mutate(health_district = case_when(\n    cluster_number %in% c(1:5) ~ \"district_a\", \n    TRUE ~ \"district_b\"\n  ))\n\n\n## sözlükten evet/hayır değişken isimlerini seç\nYNVARS &lt;- survey_dict %&gt;% \n  filter(type == \"yn\") %&gt;% \n  filter(name %in% names(survey_data)) %&gt;% \n  ## filter to match the column names of your data\n  pull(name) # select yn vars\n  \n## tarihleri değiştir \nsurvey_data &lt;- survey_data %&gt;%\n  mutate(across(all_of(YNVARS), \n                str_detect, \n                pattern = \"yes\"))\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `across(all_of(YNVARS), str_detect, pattern = \"yes\")`.\nCaused by warning:\n! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\nSupply arguments directly to `.fns` through an anonymous function instead.\n\n  # Previously\n  across(a:b, mean, na.rm = TRUE)\n\n  # Now\n  across(a:b, \\(x) mean(x, na.rm = TRUE))",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Anket analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.tr.html#anket-verisi",
    "href": "new_pages/survey_analysis.tr.html#anket-verisi",
    "title": "26  Anket analizi",
    "section": "26.3 Anket verisi",
    "text": "26.3 Anket verisi\nAnketler için kullanılabilecek çok sayıda farklı örnekleme tasarımı vardır. Burada şu kodları göstereceğiz: - Tabakalı - Küme - Tabakalı ve küme\nYukarıda açıklandığı gibi (anketinizi nasıl tasarladığınıza bağlı olarak) her seviye için veriler Kobo’dan ayrı bir veri seti olarak dışa aktarılacaktır. Örneğimizde, haneler için bir düzey ve bu hanelerdeki bireyler için bir düzey vardır.\nBu iki seviye benzersiz bir tanımlayıcı ile birbirine bağlanır. Bir Kobo veri kümesi için bu değişken, bireysel düzeyde “_parent_index” ile eşleşen hane düzeyinde “_index” dir. Bu, eşleşen her bireyle hane için yeni satırlar oluşturacaktır, ayrıntılar için Verileri ekleme ilgili el kitabı bölümüne bakabilirsiniz.\n\n## eksiksiz bir veri seti oluşturmak için bireysel ve hane verilerini birleştir\nsurvey_data &lt;- left_join(survey_data_hh, \n                         survey_data_indiv,\n                         by = c(\"_index\" = \"_parent_index\"))\n\n\n## iki düzeyin endekslerini birleştirerek benzersiz bir tanımlayıcı oluştur\nsurvey_data &lt;- survey_data %&gt;% \n     mutate(uid = str_glue(\"{index}_{index_y}\"))",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Anket analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.tr.html#gözlem-süresi",
    "href": "new_pages/survey_analysis.tr.html#gözlem-süresi",
    "title": "26  Anket analizi",
    "section": "26.4 Gözlem süresi",
    "text": "26.4 Gözlem süresi\nMortalite araştırmaları için, ilgilendiğimiz döneme ait uygun bir ölüm oranını hesaplayabilmek için her bireyin bölgede ne kadar süredir bulunduğunu bilmek istiyoruz. Bu, tüm anketlerde geçerli değildir, ancak özellikle ölüm anketleri için bu önemlidir, çünkü bunlar sık sık hareketli veya göç etmiş nüfuslarda kullanılabilir.\nBunu yapmak için önce, geri çağırma dönemi olarak da bilinen ilgilendiğimiz süreyi tanımlarız (yani, katılımcılardan soruları cevaplarken rapor vermelerinin istendiği süre). Daha sonra bu süreyi, uygun olmayan tarihleri kayıp olarak ayarlamak için kullanabiliriz, örneğin ölümler ilgili dönemin dışından bildirilirse.\n\n## geri çağırma süresinin başlangıcını/sonunu ayarla\n## veri setinden tarih değişkenleri olarak değiştirilebilir\n## (örn. başlangıç tarihi & anket tarihi)\nsurvey_data &lt;- survey_data %&gt;% \n  mutate(recall_start = as.Date(\"2018-01-01\"), \n         recall_end   = as.Date(\"2018-05-01\")\n  )\n\n\n# kurallara göre uygunsuz tarihleri NA olarak ayarla\n## örneğin, başlangıçtan önce varışlar, bitişten sonra ayrılışlar\nsurvey_data &lt;- survey_data %&gt;%\n      mutate(\n           arrived_date = if_else(arrived_date &lt; recall_start, \n                                 as.Date(NA),\n                                  arrived_date),\n           birthday_date = if_else(birthday_date &lt; recall_start,\n                                  as.Date(NA),\n                                  birthday_date),\n           left_date = if_else(left_date &gt; recall_end,\n                              as.Date(NA),\n                               left_date),\n           death_date = if_else(death_date &gt; recall_end,\n                               as.Date(NA),\n                               death_date)\n           )\n\nDaha sonra her birey için başlangıç ve bitiş tarihlerini tanımlamak için tarih değişkenlerimizi kullanabiliriz. Tarihlerin nedenlerini belirlemek için sitrep paketinden find_start_date() fonksiyonunu kullanabilir ve ardından bunu günler arasındaki farkı (kişi-zaman) hesaplamak için kullanabiliriz.\nbaşlangıç tarihi: Geri çağırma döneminiz içindeki en erken uygun varış olayı Geri çağırma sürenizin başlangıcı (önceden tanımladığınız) veya varsa, geri çağırma başlangıcından sonraki bir tarih (örneğin varışlar veya doğumlar)\nbitiş tarihi: Geri çağırma süreniz içindeki en erken uygun ayrılma olayı Geri çağırma sürenizin sonu ya da varsa, geri çağırma süresinin bitiminden önceki bir tarih (örn. ayrılışlar, ölümler)\n\n## başlangıç ve bitiş tarihleri/nedenleri için yeni değişkenler oluştur\nsurvey_data &lt;- survey_data %&gt;% \n     ## ankete girilen en erken tarihi seç\n     ## doğumlardan, hane girişlerinden ve kamp varışlarından\n     find_start_date(\"birthday_date\",\n                  \"arrived_date\",\n                  period_start = \"recall_start\",\n                  period_end   = \"recall_end\",\n                  datecol      = \"startdate\",\n                  datereason   = \"startcause\" \n                 ) %&gt;%\n     ## ankete girilen en erken tarihi seç\n     ## kamptan ayrılma, ölüm ve çalışmanın bitiminden\n     find_end_date(\"left_date\",\n                \"death_date\",\n                period_start = \"recall_start\",\n                period_end   = \"recall_end\",\n                datecol      = \"enddate\",\n                datereason   = \"endcause\" \n               )\n\n\n## başlangıçta/sonda olanları etiketle (doğumlar/ölümler hariç)\nsurvey_data &lt;- survey_data %&gt;% \n     mutate(\n       ##geri çağırma süresinin başlangıcı olarak başlangıç tarihini gir (boş olanlar için)\n       startdate = if_else(is.na(startdate), recall_start, startdate), \n       ## geri çağırma periyoduna eşitse, başlangıç nedenini başlangıçta gösterecek şekilde ayarla\n       ## doğum tarihine eşit değilse\n       startcause = if_else(startdate == recall_start & startcause != \"birthday_date\",\n                              \"Present at start\", startcause), \n       ## geri çağırma süresinin bitimi için bitiş tarihini gir (boş olanlar için)\n       enddate = if_else(is.na(enddate), recall_end, enddate), \n       ## son nedeni, geri çağırma sonuna eşitse, sonunda sunacak şekilde ayarla\n       ## ölüm tarihine eşit olmadıkça\n       endcause = if_else(enddate == recall_end & endcause != \"death_date\", \n                            \"Present at end\", endcause))\n\n\n## Gözlem süresini gün olarak tanımla\nsurvey_data &lt;- survey_data %&gt;% \n  mutate(obstime = as.numeric(enddate - startdate))",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Anket analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.tr.html#ağırlıklandırma",
    "href": "new_pages/survey_analysis.tr.html#ağırlıklandırma",
    "title": "26  Anket analizi",
    "section": "26.5 Ağırlıklandırma",
    "text": "26.5 Ağırlıklandırma\nAnket ağırlıkları eklemeden önce hatalı gözlemleri bırakmanız önemlidir. Örneğin, negatif gözlem süresine sahip gözlemleriniz varsa, bunları kontrol etmeniz gerekecektir (bunu sitrep paketinden assert_positive_timespan() fonksiyonuyla yapabilirsiniz. Başka bir şey de boş satırlar bırakmak istiyorsanız (örneğin drop_na(uid) ile) veya kopyaları kaldırabilirsiniz (ayrıntılar için El Kitabının [Tekilleştirme] bölümüne bakın). İzinsiz olanların da çıkarılması gerekir.\nBu örnekte, bırakmak ve ayrı bir veri çerçevesinde saklamak istediğimiz durumları filtreliyoruz - bu şekilde anketten hariç tutulanları tanımlayabiliriz. Ardından, bu bırakılan durumları anket verilerimizden çıkarmak için dplyr paketinden anti_join() fonksiyonunu kullanırız.\nTEHLİKE: Ağırlık değişkeninizde veya anket tasarımınızla ilgili herhangi bir değişkende (örneğin yaş, cinsiyet, tabaka veya küme değişkenleri) eksik değerler olamaz.\n\n## düşürdüğünüz vakaları tanımlayabilmek için sakla (ör.rıza dışı\n## veya yanlış köy/küme)\ndropped &lt;- survey_data %&gt;% \n  filter(!consent | is.na(startdate) | is.na(enddate) | village_name == \"other\")\n\n## kullanılmayan satırları anket veri setinden çıkarmak için bırakılan vakaları kullan \nsurvey_data &lt;- anti_join(survey_data, dropped, by = names(dropped))\n\nYukarıda bahsedildiği gibi, üç farklı çalışma tasarımı (katmanlı, küme ve tabakalı küme) için ağırlıkların nasıl ekleneceğini gösteriyoruz. Bunlar, kaynak popülasyon ve/veya incelenen kümeler hakkında bilgi gerektirir. Bu örnek için tabakalı küme kodunu kullanacağız, ancak çalışma tasarımınız için en uygun olanı kullanın.\n\n# tabakalı ------------------------------------------------------------------\n# \"surv_weight_strata\" adında bir değişken oluştur\n# her birey için ağırlıklar içerir - yaş grubuna, cinsiyete ve sağlık bölgesine göre\nsurvey_data &lt;- add_weights_strata(x = survey_data,\n                                         p = population,\n                                         surv_weight = \"surv_weight_strata\",\n                                         surv_weight_ID = \"surv_weight_ID_strata\",\n                                         age_group, sex, health_district)\n\n## küme ---------------------------------------------------------------------\n\n# hane başına görüşülen bireylerin kişi sayısını al\n# hane (ebeveyn) indeks değişkeni sayılarına sahip bir değişken ekler\nsurvey_data &lt;- survey_data %&gt;%\n  add_count(index, name = \"interviewed\")\n\n\n## küme ağırlıkları oluştur\nsurvey_data &lt;- add_weights_cluster(x = survey_data,\n                                          cl = cluster_counts,\n                                          eligible = member_number,\n                                          interviewed = interviewed,\n                                          cluster_x = village_name,\n                                          cluster_cl = cluster,\n                                          household_x = index,\n                                          household_cl = households,\n                                          surv_weight = \"surv_weight_cluster\",\n                                          surv_weight_ID = \"surv_weight_ID_cluster\",\n                                          ignore_cluster = FALSE,\n                                          ignore_household = FALSE)\n\n\n# tabakalı ve küme ---------------------------------------------------------\n# küme ve tabalalar için bir anket ağırlığı oluştur\nsurvey_data &lt;- survey_data %&gt;%\n  mutate(surv_weight_cluster_strata = surv_weight_strata * surv_weight_cluster)",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Anket analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.tr.html#anket-tasarım-nesneleri",
    "href": "new_pages/survey_analysis.tr.html#anket-tasarım-nesneleri",
    "title": "26  Anket analizi",
    "section": "26.6 Anket tasarım nesneleri",
    "text": "26.6 Anket tasarım nesneleri\nÇalışma tasarımınıza göre anket nesnesi oluşturun. Ağırlık orantılarını vb. hesaplamak için veri çerçeveleri ile aynı şekilde kullanılır. Bundan önce gerekli tüm değişkenlerin oluşturulduğundan emin olun.\nDört seçenek vardır, kullanmadıklarınızı yorumlayarak kodun dışında bırakın:\n\nBasit rastgele\nTabakalı\nKüme\nTabakalı küme\n\nBu şablon için - anketleri iki ayrı katmanda (sağlık bölgeleri A ve B) gruplandırdığımızı farz edeceğiz. Bu nedenle, genel tahminler elde etmek için küme ve tabaka ağırlıklarının birleştirilmesine ihtiyacımız var.\nDaha önce de belirtildiği gibi, bunu yapmak için iki paket mevcuttur. Klasik olan survey paketidir; ve daha sonra düzenli tidyverse dostu nesneler ve işlevler yapan srvyr adında bir sarmalayıcı paket vardır. Burada her ikisini de göstereceğiz, ancak bu bölümdeki kodun çoğunun srvyr tabanlı nesneleri kullanacağını unutmayın. Tek istisna, gtsummary paketinin yalnızca anket nesnelerini kabul etmesidir.\n\n26.6.1 Survey paketi\nsurvey paketi, R tabanı kodlamasını etkin bir şekilde kullanır ve bu nedenle tüneller (%&gt;%) veya diğer dplyr sözdizimini kullanmak mümkün değildir. survey paketiyle, uygun kümeler, ağırlıklar ve tabakalarla bir anket nesnesi tanımlamak için svydesign() fonksiyonunu kullanırız.\nNOT: Değişkenlerin önünde yaklaşık işareti (~) kullanmamız gerekir, bunun nedeni paketin formüllere dayalı değişkenler atamak için R tabanı sözdizimini kullanmasıdır.\n\n# basit rastgele ---------------------------------------------------------------\nbase_survey_design_simple &lt;- svydesign(ids = ~1, # küme kimliği yok demek için 1\n                   weights = NULL,               # Ağırlık eklenmedi\n                   strata = NULL,                # örnekleme basitti (tabaka yok)\n                   data = survey_data            # veri kümesini belirtmek zorunda\n                  )\n\n## tabakalı --------------------------------------------------------------------\nbase_survey_design_strata &lt;- svydesign(ids = ~1,  # küme kimliği yok demek için 1\n                   weights = ~surv_weight_strata, # yukarıda oluşturulan ağırlık değişkeni\n                   strata = ~health_district,     # örnekleme bölgelere göre tabakalandırılmıştır\n                   data = survey_data             # veri kümesini belirtmek zorunda\n                  )\n\n# küme -------------------------------------------------------------------------\nbase_survey_design_cluster &lt;- svydesign(ids = ~village_name, # küme kimlikleri\n                   weights = ~surv_weight_cluster, # yukarıda oluşturulan ağırlık değişkeni\n                   strata = NULL,                 # örnekleme basitti (tabaka yok)\n                   data = survey_data              # veri kümesini belirtmek zorunda\n                  )\n\n# tabakalı küme ----------------------------------------------------------------\nbase_survey_design &lt;- svydesign(ids = ~village_name,      # küme kimlikleri\n                   weights = ~surv_weight_cluster_strata, # yukarıda oluşturulan ağırlık değişkeni\n                   strata = ~health_district,             # örnekleme bölgelere göre tabakalandırılmıştır\n                   data = survey_data                     # veri kümesini belirtmek zorunda\n                  )\n\n\n\n26.6.2 Srvyr paketi\nsrvyr paketiyle, yukarıdakiyle aynı argümanlara sahip olan ancak tünellere (%&gt;%) izin veren as_survey_design() fonksiyonunu kullanabiliriz ve bu nedenle tilde (~) kullanmamız gerekmez.\n\n## basit rastgele --------------------------------------------------------------\nsurvey_design_simple &lt;- survey_data %&gt;% \n  as_survey_design(ids = 1, # küme kimliği yok demek için 1\n                   weights = NULL, # Ağırlık eklenmedi\n                   strata = NULL # örnekleme basitti (tabaka yok)\n                  )\n## tabakalı --------------------------------------------------------------------\nsurvey_design_strata &lt;- survey_data %&gt;%\n  as_survey_design(ids = 1, # küme kimliği yok demek için 1\n                   weights = surv_weight_strata, # yukarıda oluşturulan ağırlık değişkeni\n                   strata = health_district # örnekleme bölgelere göre tabakalandırılmıştır\n                  )\n## küme ------------------------------------------------------------------------\nsurvey_design_cluster &lt;- survey_data %&gt;%\n  as_survey_design(ids = village_name, # küme kimlikleri\n                   weights = surv_weight_cluster, # yukarıda oluşturulan ağırlık değişkeni\n                   strata = NULL # örnekleme basitti (tabaka yok)\n                  )\n\n## tabakalı küme ---------------------------------------------------------------\nsurvey_design &lt;- survey_data %&gt;%\n  as_survey_design(ids = village_name, # küme kimlikleri\n                   weights = surv_weight_cluster_strata, # yukarıda oluşturulan ağırlık değişkeni\n                   strata = health_district # örnekleme bölgelere göre tabakalandırılmıştır\n                  )",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Anket analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.tr.html#tanımlayıcı-analiz",
    "href": "new_pages/survey_analysis.tr.html#tanımlayıcı-analiz",
    "title": "26  Anket analizi",
    "section": "26.7 Tanımlayıcı analiz",
    "text": "26.7 Tanımlayıcı analiz\nTemel tanımlayıcı analiz ve görselleştirme, el kitabının diğer bölümlerinde kapsamlı bir şekilde ele alınmıştır, bu nedenle burada üzerinde durmayacağız. Ayrıntılar için tanımlayıcı tablolar, istatistiksel testler, sunum tabloları, ggplot temelleri ve R markdown raporları ile ilgili bölümlere bakabilirsiniz.\nBu bölümde, örnekleminizdeki yanlılığı nasıl araştırıp bunu görselleştireceğimize odaklanacağız. Ayrıca alüvyon/sankey diyagramlarını kullanarak bir anket ortamında nüfus akışını görselleştirmeye bakacağız.\nGenel olarak, aşağıdaki tanımlayıcı analizleri dahil etmeyi düşünmelisiniz:\n\nDahil edilen kümelerin, hanelerin ve bireylerin nihai sayısı\nDışlanan kişi sayısı ve dışlanma nedenleri\nKüme başına medyan (aralık) hane ve hane başına birey sayısı\n\n\n26.7.1 Örnekleme yanlılığı\nÖrnekleminiz ve kaynak popülasyon arasındaki her yaş grubundaki orantıları karşılaştırın. Bu, potansiyel örnekleme yanlılığını vurgulayabilmek için önemlidir. Benzer şekilde, cinsiyete göre dağılımlara bakarak da bunu tekrarlayabilirsiniz.\nBu p değerlerinin yalnızca gösterge niteliğinde olduğunu ve kaynak popülasyona kıyasla çalışma örneğinizdeki dağılımların açıklayıcı bir tartışmasının (veya aşağıdaki yaş piramitleriyle görselleştirmenin) binom testinin kendisinden daha önemli olduğunu unutmayın. Bunun nedeni, örnek boyutunun artmasının, verilerinizi ağırlıklandırdıktan sonra alakasız olabilecek farklılıklara yol açmamasıdır.\n\n## çalışma popülasyonunun sayıları ve orantıları\nag &lt;- survey_data %&gt;% \n  group_by(age_group) %&gt;% \n  drop_na(age_group) %&gt;% \n  tally() %&gt;% \n  mutate(proportion = n / sum(n), \n         n_total = sum(n))\n\n## kaynak popülasyonun sayıları ve orantıları\npropcount &lt;- population %&gt;% \n  group_by(age_group) %&gt;%\n    tally(population) %&gt;%\n    mutate(proportion = n / sum(n))\n\n## iki tablonun sütunlarını birbirine bağla, yaşa göre grupla ve bir\n## n/toplamın popülasyondan önemli ölçüde farklı olup olmadığını görmek için binom testi orantısı.\n  ## buradaki son ek, iki veri kümesinin her birindeki sütunların sonuna metne ekler\nleft_join(ag, propcount, by = \"age_group\", suffix = c(\"\", \"_pop\")) %&gt;%\n  group_by(age_group) %&gt;%\n  ## broom::tidy(binom.test()) binom testinden bir veri çerçevesi yapar ve\n  ## p.value, parametre, conf.low, conf.high, method ve değişkenlerini ekleyecektir.\n  ## Burada sadece p.value kullanacağız. diğerlerini dahil edebilirsiniz\n  ## güven aralıklarını bildirmek istiyorsanız sütunlar\n  mutate(binom = list(broom::tidy(binom.test(n, n_total, proportion_pop)))) %&gt;%\n  unnest(cols = c(binom)) %&gt;% # important for expanding the binom.test data frame\n  mutate(proportion_pop = proportion_pop * 100) %&gt;%\n  ## Yanlış pozitifleri düzeltmek için p-değerlerini ayarla\n  ## (çünkü birden fazla yaş grubunu test ediyor). Bu sadece yapacak\n  ## birçok yaş kategoriniz varsa bir fark verir\n  mutate(p.value = p.adjust(p.value, method = \"holm\")) %&gt;%\n                      \n  ## Yalnızca 0,001'in üzerindeki p değerlerini göster (&lt;0,001 olarak rapor edilenler)\n  mutate(p.value = ifelse(p.value &lt; 0.001, \n                          \"&lt;0.001\", \n                          as.character(round(p.value, 3)))) %&gt;% \n  \n  ## sütunları uygun şekilde yeniden adlandır\n  select(\n    \"Age group\" = age_group,\n    \"Study population (n)\" = n,\n    \"Study population (%)\" = proportion,\n    \"Source population (n)\" = n_pop,\n    \"Source population (%)\" = proportion_pop,\n    \"P-value\" = p.value\n  )\n\n# A tibble: 5 × 6\n# Groups:   Age group [5]\n  `Age group` `Study population (n)` `Study population (%)`\n  &lt;chr&gt;                        &lt;int&gt;                  &lt;dbl&gt;\n1 0-2                             12                 0.0256\n2 3-14                            42                 0.0896\n3 15-29                           64                 0.136 \n4 30-44                           52                 0.111 \n5 45+                            299                 0.638 \n# ℹ 3 more variables: `Source population (n)` &lt;dbl&gt;,\n#   `Source population (%)` &lt;dbl&gt;, `P-value` &lt;chr&gt;\n\n\n\n\n26.7.2 Demografik piramitler\nDemografik (veya yaş-cinsiyet) piramitler, anket popülasyonunuzdaki dağılımı görselleştirmenin kolay bir yoludur. Anket tabaklarına göre yaş ve cinsiyet için tanımlayıcı tabloları oluşturmayı da düşünmeye değer. Yukarıda oluşturulan anket tasarım nesnemizi kullanarak ağırlıklı orantılara izin verdiği için apyramid paketini kullanmayı göstereceğiz. Demografik piramitler oluşturmaya yönelik diğer seçenekler, el kitabının bu bölümünde kapsamlı bir şekilde ele alınmıştır. Ayrıca, orantıları olan bir grafik üretmek için birkaç satır kodlama kaydeden, age_pyramid() adlı sitrep paketinden bir sarmalayıcı işlevi kullanacağız.\nYukarıda örnekleme yanlılığı bölümünde görülen resmi binom farklılık testinde olduğu gibi, burada örneklenen popülasyonumuzun kaynak popülasyondan önemli ölçüde farklı olup olmadığını ve ağırlıklandırmanın bu farkı düzeltip düzeltmediğini görselleştirmekle ilgileniyoruz. Bunu yapmak için ggplot görselleştirmelerimizi yan yana göstermek için patchwork paketini kullanacağız; ayrıntılar için el kitabının ggplot ipuçları bölümündeki grafikleri birleştirme bölümüne bakın. Kaynak popülasyonumuzu, ağırlıksız anket popülasyonumuzu ve ağırlıklı anket popülasyonumuzu görselleştireceğiz. Anketinizin her katmanına göre görselleştirmeyi de düşünebilirsiniz - buradaki örneğimizde bu, stack_by = \"health_district\" argümanını kullanmak olacaktır (ayrıntılar için ?age_pyramid komutuna bknz.).\nNOT: x ve y eksenleri piramitlerde çevrilir.\n\n## x ekseni sınırlarını ve etiketlerini tanımlayın -----------------------------\n## (bu sayıları grafiğinizin değerleri olacak şekilde güncelle)\nmax_prop &lt;- 35      # göstermek istediğiniz en yüksek orantıyı seç\nstep &lt;- 5           # etiketler arasında istediğiniz boşluğu seç\n\n## bu kısım, vektörü yukarıdaki sayıları kullanarak eksen sonları ile tanımlar.\nbreaks &lt;- c(\n    seq(max_prop/100 * -1, 0 - step/100, step/100), \n    0, \n    seq(0 + step / 100, max_prop/100, step/100)\n    )\n\n## bu kısım vektörü yukarıdaki sayıları kullanarak eksen limitleri ile tanımlar.\nlimits &lt;- c(max_prop/100 * -1, max_prop/100)\n\n## bu kısım, vektörü, eksen etiketleriyle birlikte yukarıdaki sayıları kullanarak tanımlar.\nlabels &lt;-  c(\n      seq(max_prop, step, -step), \n      0, \n      seq(step, max_prop, step)\n    )\n\n\n## ayrı ayrı grafikler oluştur  ------------------------------------------------\n\n## kaynak popülasyonu grafiklendir \n## not: bunun genel nüfus için daraltılması gerekiyor (yani sağlık bölgelerinin kaldırılması)\nsource_population &lt;- population %&gt;%\n  ## yaş ve cinsiyetin faktörler olduğundan emin ol\n  mutate(age_group = factor(age_group, \n                            levels = c(\"0-2\", \n                                       \"3-14\", \n                                       \"15-29\",\n                                       \"30-44\", \n                                       \"45+\")), \n         sex = factor(sex)) %&gt;% \n  group_by(age_group, sex) %&gt;% \n  ## birlikte her sağlık bölgesi için sayıları ekle\n  summarise(population = sum(population)) %&gt;% \n  ## genel orantıyı hesaplayabilmek için gruplandırmayı kaldır\n  ungroup() %&gt;% \n  mutate(proportion = population / sum(population)) %&gt;% \n  ## piramid grafiği\n  age_pyramid(\n            age_group = age_group, \n            split_by = sex, \n            count = proportion, \n            proportional = TRUE) +\n  ## sadece y ekseni etiketini göster (aksi takdirde her üç çizimde de tekrarlanır)\n  labs(title = \"Source population\", \n       y = \"\", \n       x = \"Age group (years)\") + \n  ## x eksenini tüm grafikler için aynı yap\n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n  \n  \n## ağırlıksız örnek popülasyonunu grafiklendir\nsample_population &lt;- age_pyramid(survey_data, \n                 age_group = \"age_group\", \n                 split_by = \"sex\",\n                 proportion = TRUE) + \n  ## sadece x ekseni etiketini göster (aksi takdirde her üç grafikte de tekrarlanır)\n  labs(title = \"Unweighted sample population\", \n       y = \"Proportion (%)\", \n       x = \"\") + \n  ## x eksenini tüm grafikler için aynı yap\n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n\n\n## ağırlıklı örnek popülasyonunu grafiklendir \nweighted_population &lt;- survey_design %&gt;% \n  ## değişkenlerin faktör olduğundan emin ol\n  mutate(age_group = factor(age_group), \n         sex = factor(sex)) %&gt;%\n  age_pyramid(\n    age_group = \"age_group\",\n    split_by = \"sex\", \n    proportion = TRUE) +\n  ## sadece x ekseni etiketini göster (aksi takdirde her üç grafikte de tekrarlanır)\n  labs(title = \"Weighted sample population\", \n       y = \"\", \n       x = \"\")  + \n  ## x eksenini tüm grafikler için aynı yap\n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n\n## üç grafiğin tümünü birleştir ------------------------------------------------\n## + kullanarak üç grafiği yan yana birleştir\nsource_population + sample_population + weighted_population + \n  ## sadece bir legand göster ve temayı tanımla \n  ## temayı plot_layout() ile birleştirmek için & kullanımına dikkat et\n  plot_layout(guides = \"collect\") & \n  theme(legend.position = \"bottom\",                    # açıklamayı aşağıya taşı\n        legend.title = element_blank(),                # başlığı kaldır\n        text = element_text(size = 18),                # metin boyutunu değiştir\n        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1) # x ekseni metnini çevir\n       )\n\n\n\n\n\n\n\n\n\n\n26.7.3 Alluvial/sankey diagramı\nBireyler için başlangıç noktalarını ve sonuçları görselleştirmek, genel bir bakış elde etmek için çok yardımcı olabilir. Mobil popülasyonlar için oldukça açık bir uygulama var, ancak kohortlar veya bireyler için durumlarda geçişlerin olduğu diğer durumlar gibi çok sayıda başka uygulama var. Bu diyagramların alüvyon, sankey ve paralel kümeler dahil olmak üzere birkaç farklı adı vardır - ayrıntılar el kitabının Diyagramlar ve çizelgeler bölümündedir.\n\n## verileri özetle\nflow_table &lt;- survey_data %&gt;%\n  count(startcause, endcause, sex) %&gt;%  # sayımları al \n  gather_set_data(x = c(\"startcause\", \"endcause\"))     # grafiklendirme için formatı değiştir\n\n\n## veri kümesini çiz \n  ## x ekseninde başlangıç ve bitiş nedenleri\n  ## gather_set_data, her olası kombinasyon için bir kimlik oluşturur\n  ## y ile bölme, olası başlangıç/bitiş kombinasyonlarını verir\n  ## n'nin sayı olarak verdiği değer (orantı olarak da değiştirilebilir)\nggplot(flow_table, aes(x, id = id, split = y, value = n)) +\n  ## cinsiyete göre renk çizgileri\n  geom_parallel_sets(aes(fill = sex), alpha = 0.5, axis.width = 0.2) +\n  ## etiket kutularını gri doldur\n  geom_parallel_sets_axes(axis.width = 0.15, fill = \"grey80\", color = \"grey80\") +\n  ## metin rengini ve açısını değiştir (ayarlanması gerekiyor)\n  geom_parallel_sets_labels(color = \"black\", angle = 0, size = 5) +\n  ## ayarlanmış y ve x eksenleri (muhtemelen daha fazla dikey alana ihtiyaç duyar)\n  scale_x_discrete(name = NULL, expand = c(0, 0.2)) + \n  ## eksen etiketlerini kaldır\n  theme(\n    title = element_text(size = 26),\n    text = element_text(size = 26),\n    axis.line = element_blank(),\n    axis.ticks = element_blank(),\n    axis.text.y = element_blank(),\n    panel.background = element_blank(),\n    legend.position = \"bottom\",                    # açıklamayı aşağıya taşı\n    legend.title = element_blank(),                # başlığı kaldır\n  )",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Anket analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.tr.html#ağırlıklı-orantılar",
    "href": "new_pages/survey_analysis.tr.html#ağırlıklı-orantılar",
    "title": "26  Anket analizi",
    "section": "26.8 Ağırlıklı orantılar",
    "text": "26.8 Ağırlıklı orantılar\nBu bölüm, ilişkili güven aralıkları ve tasarım etkisi ile birlikte ağırlıklı sayımlar ve oranlar için tabloların nasıl üretileceğini detaylandıracaktır. Aşağıdaki paketlerdeki işlevleri kullanan dört farklı seçenek vardır: survey, srvyr, sitrep ve gtsummary. Standart bir epidemiyoloji stili tablosu oluşturmak üzere minimum kodlama için, srvyr kodunun sarmalayıcısı olan sitrep fonksiyonunu öneriyoruz; Ancak bunun henüz CRAN’da olmadığını ve gelecekte değişebileceğini unutmayın. Aksi takdirde, survey kodu muhtemelen en istikrarlı ve uzun vadeli paket olacaktır, oysa srvyr paketi en iyi şekilde derli toplu iş akışlarına uymaktadır. gtsummary fonksiyonları çok fazla potansiyele sahip olsa da, bu kitap yazıldığı sırada deneysel ve eksiktirler.\n\n26.8.1 Survey paketi\nAğırlıklı orantılar ve beraberindeki %95 güven aralıklarını elde etmek için survey paketinden svyciprop() fonksiyonunu kullanabiliriz. Uygun bir tasarım efekti, svyprop() fonksiyonu yerine svymean() kullanılarak da çıkarılabilir. svyprop() fonksiyonunun yalnızca 0 ile 1 (veya DOĞRU/YANLIŞ) arasındaki değişkenleri kabul ediyor gibi göründüğünü, dolayısıyla kategorik değişkenlerin çalışmayacağını belirtmekte fayda var.\nNOT: survey paketinden gelen foksiyonlar ayrıca srvyr tasarım nesnelerini de kabul etmektedir, ancak burada anket survey nesnesini yalnızca tutarlılık için kullandık. \n\n## ağırlıklı sayılar üretme\nsvytable(~died, base_survey_design)\n\ndied\n     FALSE       TRUE \n1406244.43   76213.01 \n\n## ağırlıklı orantılar üretme\nsvyciprop(~died, base_survey_design, na.rm = T)\n\n              2.5% 97.5%\ndied 0.0514 0.0208  0.12\n\n## tasarım efektini al\nsvymean(~died, base_survey_design, na.rm = T, deff = T) %&gt;% \n  deff()\n\ndiedFALSE  diedTRUE \n 3.755508  3.755508 \n\n\nYukarıda gösterilen survey fonksiyonları, aşağıda kendimizi tanımladığımız, svy_prop adlı bir fonksiyonda birleştirebiliriz; ve daha sonra bu fonksiyonu purrr paketindeki map() ile birlikte birkaç değişken üzerinde yineleme yapmak ve bir tablo oluşturmak için kullanabiliriz. purrr hakkında ayrıntılar için el kitabı yineleme bölümüne bakabilirsiniz.\n\n# Ağırlıklı sayıları, oranlatıları, CI ve tasarım etkisini hesaplamak için fonksiyonu tanımla\n# x tırnak içindeki değişkendir \n# tasarım, sizin anket tasarım nesnenizdir\n\nsvy_prop &lt;- function(design, x) {\n  \n  ## ilgilenilen değişkeni bir formüle koy\n  form &lt;- as.formula(paste0( \"~\" , x))\n  ## svytable'dan yalnızca DOĞRU sayım sütununu sakla\n  weighted_counts &lt;- svytable(form, design)[[2]]\n  ## orantıları hesapla (yüzdeleri almak için 100 ile çarpın)\n  weighted_props &lt;- svyciprop(form, design, na.rm = TRUE) * 100\n  ## güven aralıklarını çıkarın ve yüzdeleri elde etmek için çarp\n  weighted_confint &lt;- confint(weighted_props) * 100\n  ## tasarım etkisini hesaplamak için svymean kullanın ve yalnızca DOĞRU sütununu koru\n  design_eff &lt;- deff(svymean(form, design, na.rm = TRUE, deff = TRUE))[[TRUE]]\n  \n  ## tek bir veri çerçevesinde birleştir\n  full_table &lt;- cbind(\n    \"Variable\"        = x,\n    \"Count\"           = weighted_counts,\n    \"Proportion\"      = weighted_props,\n    weighted_confint, \n    \"Design effect\"   = design_eff\n    )\n  \n  ## tabloyu veri çerçevesi olarak döndür\n  full_table &lt;- data.frame(full_table, \n             ## remove the variable names from rows (is a separate column now)\n             row.names = NULL)\n  \n  ## sayısalları tekrar sayısal olarak değiştir\n  full_table[ , 2:6] &lt;- as.numeric(full_table[, 2:6])\n  \n  ## veri çerçevesini döndür\n  full_table\n}\n\n## bir tablo oluşturmak için birkaç değişken üzerinde yineleme yap\npurrr::map(\n  ## ilgilenilen değişkenleri tanımla\n  c(\"left\", \"died\", \"arrived\"), \n  ## durum fonksiyonu kullanımı ve bu fonksiyon için argümanlar (tasarım)\n  svy_prop, design = base_survey_design) %&gt;% \n  ## listeyi tek bir veri çerçevesine daralt\n  bind_rows() %&gt;% \n  ## yuvarla\n  mutate(across(where(is.numeric), round, digits = 1))\n\n  Variable    Count Proportion X2.5. X97.5. Design.effect\n1     left 701199.1       47.3  39.2   55.5           2.4\n2     died  76213.0        5.1   2.1   12.1           3.8\n3  arrived 761799.0       51.4  40.9   61.7           3.9\n\n\n\n\n26.8.2 Srvyr paketi\nsrvyr ile bir tablo oluşturmak için dplyr sözdizimini kullanabiliriz. survey_mean() fonksiyonunun kullanıldığını ve orantı argümanının belirtildiğini ve ayrıca tasarım etkisini hesaplamak için aynı fonksiyonu kullanıldığını unutmayın. Bunun nedeni, srvyr paketinin yukarıdaki bölümde kullanılan svyciprop() ve svymean() survey paketi fonksiyonun her ikisinin de etrafını sarmasıdır.\nNOT: Kategorik değişkenlerden orantıları srvyr paketini kullanarak da almak pek mümkün görünmüyor, buna ihtiyacınız varsa sitrep paketini kullanmanız gerekir. Detaylar için aşağıdaki bölüme göz atın.\n\n## srvyr tasarım nesnesini kullan\nsurvey_design %&gt;% \n  summarise(\n    ## ağırlıklı sayıları üret\n    counts = survey_total(died), \n    ## ağırlıklı orantıları ve güven aralıkları üret\n    ## yüzde almak için 100 ile çarp\n    props = survey_mean(died, \n                        proportion = TRUE, \n                        vartype = \"ci\") * 100, \n    ## tasarım efekti üret\n    deff = survey_mean(died, deff = TRUE)) %&gt;% \n  ## sadece ilgi alanlarını tut\n  ## (standart hataları bırakın ve orantı hesaplamasını tekrarla)\n  select(counts, props, props_low, props_upp, deff_deff)\n\n# A tibble: 1 × 5\n  counts props props_low props_upp deff_deff\n   &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1 76213.  5.14      2.08      12.1      3.76\n\n\nBurada da purrr paketini kullanarak birden çok değişken üzerinde yineleme yapacak bir fonksiyon yazabiliriz. purrr hakkında ayrıntılar için el kitabı yineleme bölümüne bakabilirsiniz.\n\n# Ağırlıklı sayıları, orantıları, CI ve tasarım etkisini hesaplamak için işlevi tanımla\n# tasarım, sizin anket tasarım nesnenizdir\n# x tırnak içindeki değişkendir\n\n\nsrvyr_prop &lt;- function(design, x) {\n  \n  summarise(\n    ## anket tasarım nesnesini kullan\n    design, \n    ## ağırlıklı sayıları üret\n    counts = survey_total(.data[[x]]), \n    ## ağırlıklı orantıları ve güven aralıkları üret\n    ## yüzde almak için 100 ile çarp\n    props = survey_mean(.data[[x]], \n                        proportion = TRUE, \n                        vartype = \"ci\") * 100, \n    ## tasarım efekti üret\n    deff = survey_mean(.data[[x]], deff = TRUE)) %&gt;% \n  ## değişken adını ekle\n  mutate(variable = x) %&gt;% \n  ## sadece ilgi alanlarını tut\n  ## (standart hataları bırak ve orantı hesaplamasını tekrarla)\n  select(variable, counts, props, props_low, props_upp, deff_deff)\n  \n}\n  \n\n## bir tablo oluşturmak için birkaç değişken üzerinde yineleme yap\npurrr::map(\n  ## ilgilenilen değişkenleri tanımla\n  c(\"left\", \"died\", \"arrived\"), \n  ## durum fonksiyonu kullanımı ve bu fonksiyon için argümanlar (tasarım)\n  ~srvyr_prop(.x, design = survey_design)) %&gt;% \n  ## listeyi tek bir veri çerçevesine daralt\n  bind_rows()\n\n# A tibble: 3 × 6\n  variable  counts props props_low props_upp deff_deff\n  &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1 left     701199. 47.3      39.2       55.5      2.38\n2 died      76213.  5.14      2.08      12.1      3.76\n3 arrived  761799. 51.4      40.9       61.7      3.93\n\n\n\n\n26.8.3 Sitrep paketi\nsitrep paketinin tab_survey() fonksiyonu, minimum kodlama ile ağırlıklı tablolar oluşturmanıza olanak tanıyan srvyr paketi için bir sarmalayıcıdır. Ayrıca kategorik değişkenler için ağırlıklı orantıları hesaplamanıza olanak tanır.\n\n## anket tasarım nesnesini kullan\nsurvey_design %&gt;% \n  ## ilgilenilen değişkenlerin isimlerini alıntı yapılmadan ilet\n  tab_survey(arrived, left, died, education_level,\n             deff = TRUE,   # tasarım etkisini hesapla\n             pretty = TRUE  # oranı ve %95 CI'yi birleştir\n             )\n\nWarning: removing 257 missing value(s) from `education_level`\n\n\n# A tibble: 9 × 5\n  variable        value            n  deff ci               \n  &lt;chr&gt;           &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;            \n1 arrived         TRUE       761799.  3.93 51.4% (40.9-61.7)\n2 arrived         FALSE      720658.  3.93 48.6% (38.3-59.1)\n3 left            TRUE       701199.  2.38 47.3% (39.2-55.5)\n4 left            FALSE      781258.  2.38 52.7% (44.5-60.8)\n5 died            TRUE        76213.  3.76 5.1% (2.1-12.1)  \n6 died            FALSE     1406244.  3.76 94.9% (87.9-97.9)\n7 education_level higher     171644.  4.70 42.4% (26.9-59.7)\n8 education_level primary    102609.  2.37 25.4% (16.2-37.3)\n9 education_level secondary  130201.  6.68 32.2% (16.5-53.3)\n\n\n\n\n26.8.4 Gtsummary paketi\ngtsummary paketinde henüz güven aralıklarını veya tasarım efektini eklemek için yerleşik fonksiyonlar yok gibi görünüyor. Burada, güven aralıkları eklemek için bir fonksiyonun nasıl tanımlanacağını ve ardından tbl_svysummary() fonksiyonunu kullanılarak oluşturulan bir gtsummary tablosuna güven aralıklarının nasıl ekleneceğini gösteriyoruz.\n\nconfidence_intervals &lt;- function(data, variable, by, ...) {\n  \n  ## güven aralıklarını çıkarın ve yüzdeleri elde etmek için çarp\n  props &lt;- svyciprop(as.formula(paste0( \"~\" , variable)),\n              data, na.rm = TRUE)\n  \n  ## güven aralıklarını çıkar\n  as.numeric(confint(props) * 100) %&gt;% ## sayısal yap ve yüzde için çarp\n    round(., digits = 1) %&gt;%           ## bir haneye yuvarla\n    c(.) %&gt;%                           ## sayıları matristen çıkar\n    paste0(., collapse = \"-\")          ## tek karakterle birleştir\n}\n\n## anket paketi tasarım nesnesini kullan\ntbl_svysummary(base_survey_design, \n               include = c(arrived, left, died),   ## dahil etmek istediğiniz değişkenleri tanımla\n               statistic = list(everything() ~ c(\"{n} ({p}%)\"))) %&gt;% ## ilgi istatistiklerini tanımla\n  add_n() %&gt;%  ## add the weighted total \n  add_stat(fns = everything() ~ confidence_intervals) %&gt;% ## güven aralığını ekle\n  ## sütun başlıklarını değiştir\n  modify_header(\n    list(\n      n ~ \"**Weighted total (N)**\",\n      stat_0 ~ \"**Weighted Count**\",\n      add_stat_1 ~ \"**95%CI**\"\n    )\n    )\n\n\n\n\n\n\n\n\nCharacteristic\nWeighted total (N)\nWeighted Count1\n95%CI\n\n\n\n\narrived\n1,482,457\n761,799 (51%)\n40.9-61.7\n\n\nleft\n1,482,457\n701,199 (47%)\n39.2-55.5\n\n\ndied\n1,482,457\n76,213 (5.1%)\n2.1-12.1\n\n\n\n1 n (%)",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Anket analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.tr.html#ağırlıklı-hızlar",
    "href": "new_pages/survey_analysis.tr.html#ağırlıklı-hızlar",
    "title": "26  Anket analizi",
    "section": "26.9 Ağırlıklı hızlar",
    "text": "26.9 Ağırlıklı hızlar\nBenzer şekilde ağırlıklı hızlar için (ölüm hızları gibi) survey veya srvyr paketini kullanabilirsiniz. Birkaç değişken üzerinde yineleme yapmak için benzer şekilde (yukarıdakilere benzer) fonksiyonlar yazabilirsiniz. Ayrıca gtsummary için yukarıdaki gibi bir fonksiyon oluşturabilirsiniz, ancak şu anda dahili bir fonksiyonelliği bulunmamaktadır.\n\n26.9.1 Survey paketi\n\nratio &lt;- svyratio(~died, \n         denominator = ~obstime, \n         design = base_survey_design)\n\nci &lt;- confint(ratio)\n\ncbind(\n  ratio$ratio * 10000, \n  ci * 10000\n)\n\n      obstime    2.5 %   97.5 %\ndied 5.981922 1.194294 10.76955\n\n\n\n\n26.9.2 Srvyr paketi\n\nsurvey_design %&gt;% \n  ## gözlem süresini hesaba katmak için kullanılan anket hızı\n  summarise(\n    mortality = survey_ratio(\n      as.numeric(died) * 10000, \n      obstime, \n      vartype = \"ci\")\n    )\n\n# A tibble: 1 × 3\n  mortality mortality_low mortality_upp\n      &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n1      5.98         0.349          11.6",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Anket analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.tr.html#kaynaklar",
    "href": "new_pages/survey_analysis.tr.html#kaynaklar",
    "title": "26  Anket analizi",
    "section": "26.10 Kaynaklar",
    "text": "26.10 Kaynaklar\nUCLA istatistik sayfası\nAnket verilerini ücretsiz analiz edin\nsrvyr paketi\ngtsummary paketi\nEPIET anket vaka çalışmaları",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Anket analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.tr.html",
    "href": "new_pages/survival_analysis.tr.html",
    "title": "27  Sağkalım Analizi",
    "section": "",
    "text": "27.1 Genel Bakış\nSağkalım analizi, belirli bir birey veya birey grubu için, başarısızlık (bir hastalığın ortaya çıkması, bir hastalıktan iyileşme, ölüm, tedaviye yanıttan sonra nüks…) olarak adlandırılan bir olay noktasını tanımlamaya odaklanır. Bu, bireylerin gözlemlendiği başarısızlık süresi (veya kohort/nüfus temelli çalışmalarda izleme süresi) olarak adlandırılan bir süreden sonra ortaya çıkar. Başarısızlık süresini belirlemek için, daha sonra bir başlangıç zamanı tanımlamak gerekir (bu, dahil etme tarihi, teşhis tarihi olabilir…).\nSağkalım analizinin nihayi çıktısı, başlangıç noktası ile olay arasındaki zamandır. Mevcut tıbbi araştırmalarda, örneğin klinik çalışmalarda bir tedavinin etkisini veya çeşitli kanser sağkalım ölçümlerini değerlendirmek için kanser epidemiyolojisinde yaygın olarak kullanılmaktadır.\nGenellikle sağkalım ihtimali ile ifade edilir;ki bu, ilgilenilen olayın t süresi boyunca gerçekleşmemiş olma olasılığıdır.\nSansürleme: Sansür; izlem sonunda, bazı kişilerin ilgilendikleri olay olmadığında ve bu nedenle gerçek zamanlarının bilinmediği durumlarda meydana gelir. Burada çoğunlukla doğru sansürlemeye odaklanacağız, ancak genel olarak sansürleme ve sağkalım analizi hakkında daha fazla ayrıntı için referansları görebilirsiniz.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Sağkalım Analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.tr.html#hazırlık",
    "href": "new_pages/survival_analysis.tr.html#hazırlık",
    "title": "27  Sağkalım Analizi",
    "section": "27.2 Hazırlık",
    "text": "27.2 Hazırlık\n\nPaketleri yükleyin\nR’da sağkalım analizlerini çalıştırmak için en yaygın kullanılan paketlerden biri survival paketidir. Önce o kurulur ve ardından bu bölümde kullanılacak diğer paketlerin yanı sıra o da yüklenir:\nBu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() vurgusu yapılmaktadır. R tabanı’ndan library() ile kurulu paketler de yüklenebilir. R paketleri hakkında daha fazla bilgi için [R’ın temelleri] sayfasına bakabilirsiniz.\nBu sayfa, önceki sayfaların çoğunda kullanılan ve uygun bir sağkalım verisine sahip olmak için bazı değişiklikler uyguladığımız satır listesini kullanarak sağkalım analizlerini araştırmaktadır.\n\n\nVeri kümesini içe aktar\nSimüle edilmiş bir Ebola salgınından vakaların veri seti içe aktarılmaktadır. Takip etmek için; “temiz satır listesi” dosyasını indirmek için tıklayın. (.rds dosyası olarak). rio paketinden import() işleviyle veriler içe aktarılabilir (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe ve dışa aktarma] sayfasına bakılabilir).\n\n# import linelist\nlinelist_case_data &lt;- rio::import(\"linelist_cleaned.rds\")\n\n\n\nVeri yönetimi ve dönüştürme\nKısacası, sağkalım verileri aşağıdaki üç özelliğe sahip olarak tanımlanabilir:\n\nBağımlı değişken veya sonuç, iyi tanımlanmış bir olayın meydana gelmesine kadar geçen bekleme süresidir.\nGözlemler, bazı birimler için verilerin analiz edildiği sırada ilgili olayın meydana gelmediği anlamında sansürlenir.\nBekleme süresi üzerindeki etkisini değerlendirmek veya kontrol etmek istediğimiz öngörüler veya açıklayıcı değişkenler vardır.\n\nBöylece, bu yapıya uymak ve sağkalım analizini yürütmek için gereken farklı değişkenler ortaya çıkarılmaktadır.\n\nBu analiz için yeni bir veri çerçevesini linelist_surv olarak;\nİlgilendiğimiz olayı “ölüm” olarak; (dolayısıyla sağkalım olasılığımız, başlangıç zamanından belirli bir süre sonra sağkalım olasılığı olacaktır),\nBaşlangıç zamanı ile sonuç zamanı arasındaki izlem süresini (futime) gün olarak;\nSansürlenmiş hastalar iyileşen veya nihai sonucu bilinmeyen, yani “ölüm” olayının gözlemlenmediği hastalar olarak (event=0); tanımlanmaktadır.\n\nDİKKAT: Gerçek bir kohort çalışmasında, bireyler gözlendiğinde, başlangıç zamanı ve izlem sonu hakkındaki bilgiler bilindiği için, başlangıç tarihi veya sonuç tarihi bilinmiyorsa gözlemler kaldırılacaktır. Ayrıca başlangıç tarihinin sonuç tarihinden sonra olduğu durumlar da yanlış kabul edildiğinden kaldırılacaktır.\nİPUCU: Bir tarihe göre büyük (&gt;) veya küçük (&lt;) olarak filtrelemenin eksik değerlere sahip satırları kaldırabileceği göz önüne alındığında, filtreyi yanlış tarihlere uygulamak eksik tarihlere sahip satırları da kaldıracaktır.\nArdından, içinde yalnızca 3 yaş kategorisi bulunan bir age_cat_small sütunu oluşturmak için case_while() kullanılmaktadır.\n\n#create a new data called linelist_surv from the linelist_case_data\n\nlinelist_surv &lt;-  linelist_case_data %&gt;% \n     \n  dplyr::filter(\n       # remove observations with wrong or missing dates of onset or date of outcome\n       date_outcome &gt; date_onset) %&gt;% \n  \n  dplyr::mutate(\n       # create the event var which is 1 if the patient died and 0 if he was right censored\n       event = ifelse(is.na(outcome) | outcome == \"Recover\", 0, 1), \n    \n       # create the var on the follow-up time in days\n       futime = as.double(date_outcome - date_onset), \n    \n       # create a new age category variable with only 3 strata levels\n       age_cat_small = dplyr::case_when( \n            age_years &lt; 5  ~ \"0-4\",\n            age_years &gt;= 5 & age_years &lt; 20 ~ \"5-19\",\n            age_years &gt;= 20   ~ \"20+\"),\n       \n       # previous step created age_cat_small var as character.\n       # now convert it to factor and specify the levels.\n       # Note that the NA values remain NA's and are not put in a level \"unknown\" for example,\n       # since in the next analyses they have to be removed.\n       age_cat_small = fct_relevel(age_cat_small, \"0-4\", \"5-19\", \"20+\")\n       )\n\nİPUCU: Oluşturulan yeni sütunlar, futime hakkında bir özet ve oluşturulduğu event ve outcome arasında bir çapraz tablo yapılarak doğrulanabilir. Bu doğrulamanın yanı sıra, sağkalım analizi sonuçlarını yorumlarken medyan takip süresini iletmek iyi bir alışkanlıktır.\n\nsummary(linelist_surv$futime)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00    6.00   10.00   11.98   16.00   64.00 \n\n# cross tabulate the new event var and the outcome var from which it was created\n# to make sure the code did what it was intended to\nlinelist_surv %&gt;% \n  tabyl(outcome, event)\n\n outcome    0    1\n   Death    0 1952\n Recover 1547    0\n    &lt;NA&gt; 1040    0\n\n\nDoğru atamaları sağlamak için yeni age_cat_small var ve eski age_cat sütunu çapraz tablo haline getirilmektedir.\n\nlinelist_surv %&gt;% \n  tabyl(age_cat_small, age_cat)\n\n age_cat_small 0-4 5-9 10-14 15-19 20-29 30-49 50-69 70+ NA_\n           0-4 834   0     0     0     0     0     0   0   0\n          5-19   0 852   717   575     0     0     0   0   0\n           20+   0   0     0     0   862   554    69   5   0\n          &lt;NA&gt;   0   0     0     0     0     0     0   0  71\n\n\nŞimdi, belirli değişkenlere (yeni oluşturulanlar dahil) bakarak linelist_surv verilerinin ilk 10 gözlemi gözden geçirilmektedir.\n\nlinelist_surv %&gt;% \n  select(case_id, age_cat_small, date_onset, date_outcome, outcome, event, futime) %&gt;% \n  head(10)\n\n   case_id age_cat_small date_onset date_outcome outcome event futime\n1   8689b7           0-4 2014-05-13   2014-05-18 Recover     0      5\n2   11f8ea           20+ 2014-05-16   2014-05-30 Recover     0     14\n3   893f25           0-4 2014-05-21   2014-05-29 Recover     0      8\n4   be99c8          5-19 2014-05-22   2014-05-24 Recover     0      2\n5   07e3e8          5-19 2014-05-27   2014-06-01 Recover     0      5\n6   369449           0-4 2014-06-02   2014-06-07   Death     1      5\n7   f393b4           20+ 2014-06-05   2014-06-18 Recover     0     13\n8   1389ca           20+ 2014-06-05   2014-06-09   Death     1      4\n9   2978ac          5-19 2014-06-06   2014-06-15   Death     1      9\n10  fc15ef          5-19 2014-06-16   2014-07-09 Recover     0     23\n\n\nBu yeni sütunun cinsiyete göre dağılımı hakkında daha fazla ayrıntıya sahip olmak için age_cat_small ve gender sütunları da çapraz tablo haline getirilebilir. [Açıklayıcı tablolar] sayfasında açıklandığı gibi janitor’dan tabyl() ve adorn fonksiyonları kullanılmaktadır.\n\n\nlinelist_surv %&gt;% \n  tabyl(gender, age_cat_small, show_na = F) %&gt;% \n  adorn_totals(where = \"both\") %&gt;% \n  adorn_percentages() %&gt;% \n  adorn_pct_formatting() %&gt;% \n  adorn_ns(position = \"front\")\n\n gender         0-4          5-19           20+          Total\n      f 482 (22.4%) 1,184 (54.9%)   490 (22.7%) 2,156 (100.0%)\n      m 325 (15.0%)   880 (40.6%)   960 (44.3%) 2,165 (100.0%)\n  Total 807 (18.7%) 2,064 (47.8%) 1,450 (33.6%) 4,321 (100.0%)",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Sağkalım Analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.tr.html#sağkalım-analizinin-temelleri",
    "href": "new_pages/survival_analysis.tr.html#sağkalım-analizinin-temelleri",
    "title": "27  Sağkalım Analizi",
    "section": "27.3 Sağkalım analizinin temelleri",
    "text": "27.3 Sağkalım analizinin temelleri\n\nSağkalım analiz materyali oluşturma\nİzlem süresi ve olay sütunlarından bir hayatta kalma nesnesi oluşturmak için ilk olarak survival’den Surv() kısmını kullanılır.\nBöyle bir adımın sonucu, zaman bilgisini ve ilgilenilen olayın (ölüm) gözlemlenip gözlemlenmediğini özetleştiren surv türünde bir nesne üretmektir. Bu nesne nihai olarak sonraki model formüllerinin sağ tarafında kullanılacaktır (bkz. belgeler).\n\n# Use Suv() syntax for right-censored data\nsurvobj &lt;- Surv(time = linelist_surv$futime,\n                event = linelist_surv$event)\n\n\n\n\n\n\nİncelemek için, burada yalnızca bazı önemli sütunları görüntüleyen linelist_surv verilerinin ilk 10 satırı verilmiştir.\n\nlinelist_surv %&gt;% \n  select(case_id, date_onset, date_outcome, futime, outcome, event) %&gt;% \n  head(10)\n\n   case_id date_onset date_outcome futime outcome event\n1   8689b7 2014-05-13   2014-05-18      5 Recover     0\n2   11f8ea 2014-05-16   2014-05-30     14 Recover     0\n3   893f25 2014-05-21   2014-05-29      8 Recover     0\n4   be99c8 2014-05-22   2014-05-24      2 Recover     0\n5   07e3e8 2014-05-27   2014-06-01      5 Recover     0\n6   369449 2014-06-02   2014-06-07      5   Death     1\n7   f393b4 2014-06-05   2014-06-18     13 Recover     0\n8   1389ca 2014-06-05   2014-06-09      4   Death     1\n9   2978ac 2014-06-06   2014-06-15      9   Death     1\n10  fc15ef 2014-06-16   2014-07-09     23 Recover     0\n\n\nBurada survobjun ilk 10 unsuru izlenmektedir. Esasen bir gözlemin doğru sansürlenip sansürlenmediğini göstermek için, “+” ile birlikte izlem süresi vektörü olarak yazdırılır. Rakamların yukarıda ve aşağıda nasıl hizalandığını görülmektedir.\n\n#print the 50 first elements of the vector to see how it presents\nhead(survobj, 10)\n\n [1]  5+ 14+  8+  2+  5+  5  13+  4   9  23+\n\n\n\n\nİlk analizleri çalıştırma\nGözlemlenen olay zamanlarında atlamalı bir adım fonksiyonu olan genel (marjinal) hayatta kalma eğrisinin Kaplan Meier (KM) tahminleri için varsayılan hesaplamalara uyan bir survfit nesnesi üretmek için survfit() işlevini kullanarak analize başlanır. Sonuçta survfit nesnesi bir veya daha fazla sağkalım eğrisi içerir ve model formülünde bir yanıt değişkeni olarak Surv nesnesi kullanılarak oluşturulur.\nNOT: Kaplan-Meier tahmini, sağkalım fonksiyonunun parametrik olmayan maksimum olabilirlik tahminidir (MLE). . (daha fazla bilgi için kaynaklara bakın).\nBu survfit nesnesinin özeti, yaşam tablosu’nu verecektir. Gerçekleşen (artan şekilde) bir olayın takip edilen her bir zaman adımı için (time):\n\nOlayı geliştirme riski altında olan kişi sayısı (henüz olaya sahip olmayan veya sansürlenmemiş kişiler: n.risk),\nOlayı geliştirenler: (n.event),\nYukarıdakilerin devamı olarak: Olayın gelişmeme olasılığı (ölmeme veya belirli bir zamandan sonra sağkalım olasılığı) bulunur;\nSon olarak, bu olasılık için standart hata ve güven aralığı türetilir ve görüntülenir.\n\nKM tahminleri, daha önce Surv nesnesi “survobj” un yanıt değişkeni olduğu formül kullanılarak oturtulur. Genel sağkalım için modeli çalıştırılan kesinlik “~ 1” ’dir.\n\n# fit the KM estimates using a formula where the Surv object \"survobj\" is the response variable.\n# \"~ 1\" signifies that we run the model for the overall survival  \nlinelistsurv_fit &lt;-  survival::survfit(survobj ~ 1)\n\n#print its summary for more details\nsummary(linelistsurv_fit)\n\nCall: survfit(formula = survobj ~ 1)\n\n time n.risk n.event survival std.err lower 95% CI upper 95% CI\n    1   4539      30    0.993 0.00120        0.991        0.996\n    2   4500      69    0.978 0.00217        0.974        0.982\n    3   4394     149    0.945 0.00340        0.938        0.952\n    4   4176     194    0.901 0.00447        0.892        0.910\n    5   3899     214    0.852 0.00535        0.841        0.862\n    6   3592     210    0.802 0.00604        0.790        0.814\n    7   3223     179    0.757 0.00656        0.745        0.770\n    8   2899     167    0.714 0.00700        0.700        0.728\n    9   2593     145    0.674 0.00735        0.660        0.688\n   10   2311     109    0.642 0.00761        0.627        0.657\n   11   2081     119    0.605 0.00788        0.590        0.621\n   12   1843      89    0.576 0.00809        0.560        0.592\n   13   1608      55    0.556 0.00823        0.540        0.573\n   14   1448      43    0.540 0.00837        0.524        0.556\n   15   1296      31    0.527 0.00848        0.511        0.544\n   16   1152      48    0.505 0.00870        0.488        0.522\n   17   1002      29    0.490 0.00886        0.473        0.508\n   18    898      21    0.479 0.00900        0.462        0.497\n   19    798       7    0.475 0.00906        0.457        0.493\n   20    705       4    0.472 0.00911        0.454        0.490\n   21    626      13    0.462 0.00932        0.444        0.481\n   22    546       8    0.455 0.00948        0.437        0.474\n   23    481       5    0.451 0.00962        0.432        0.470\n   24    436       4    0.447 0.00975        0.428        0.466\n   25    378       4    0.442 0.00993        0.423        0.462\n   26    336       3    0.438 0.01010        0.419        0.458\n   27    297       1    0.436 0.01017        0.417        0.457\n   29    235       1    0.435 0.01030        0.415        0.455\n   38     73       1    0.429 0.01175        0.406        0.452\n\n\nsummary() kullanılırken times seçeneği eklenebilir ve sağkalım bilgisinin görülmek istendiği zamanlar belirtilebilir.\n\n#print its summary at specific times\nsummary(linelistsurv_fit, times = c(5,10,20,30,60))\n\nCall: survfit(formula = survobj ~ 1)\n\n time n.risk n.event survival std.err lower 95% CI upper 95% CI\n    5   3899     656    0.852 0.00535        0.841        0.862\n   10   2311     810    0.642 0.00761        0.627        0.657\n   20    705     446    0.472 0.00911        0.454        0.490\n   30    210      39    0.435 0.01030        0.415        0.455\n   60      2       1    0.429 0.01175        0.406        0.452\n\n\nprint() fonksiyonu da kullanılabilir. print.rmean = TRUE argümanı, ortalama sağkalım süresini ve standart hatayı (se) elde etmek için kullanılır.\nNOT: Kısıtlı ortalama sağkalım süresi (RMST), kanser sağkalım analizinde giderek daha fazla kullanılan ve kısıtlı T süresine kadar hastaları gözlemlediğimiz, göz önüne alındığında genellikle hayatta kalma eğrisinin altındaki alan olarak tanımlanan spesifik bir hayatta kalma ölçüsüdür. (Daha fazla ayrıntı için kaynaklar bölümüne bakın).\n\n# print linelistsurv_fit object with mean survival time and its se. \nprint(linelistsurv_fit, print.rmean = TRUE)\n\nCall: survfit(formula = survobj ~ 1)\n\n        n events rmean* se(rmean) median 0.95LCL 0.95UCL\n[1,] 4539   1952   33.1     0.539     17      16      18\n    * restricted mean with upper limit =  64 \n\n\nİPUCU: surv nesnesi doğrudan survfit() işlevinde oluşturulabilir ve bir kod satırı kaydedilebilir. Bu daha sonra şöyle görünecektir: linelistsurv_quick &lt;-  survfit(Surv(futime, event) ~ 1, data=linelist_surv).\n\n\nKümülatif risk\nsummary() işlevinin yanı sıra, survfit() nesnesinin yapısı hakkında daha fazla ayrıntı veren str() işlevi de kullanılabilir. Liste 16 unsurdan meydana gelir.\nBu unsurlardan önemli bir tanesi de sayısal bir vektör olan cumhaz ’dır. Bu, kümülatif risk in gösterilmesine izin verecek şekilde belirlenebilir, risk olayın anlık meydana gelme oranı dır (kaynaklara bakınız).\n\nstr(linelistsurv_fit)\n\nList of 16\n $ n        : int 4539\n $ time     : num [1:59] 1 2 3 4 5 6 7 8 9 10 ...\n $ n.risk   : num [1:59] 4539 4500 4394 4176 3899 ...\n $ n.event  : num [1:59] 30 69 149 194 214 210 179 167 145 109 ...\n $ n.censor : num [1:59] 9 37 69 83 93 159 145 139 137 121 ...\n $ surv     : num [1:59] 0.993 0.978 0.945 0.901 0.852 ...\n $ std.err  : num [1:59] 0.00121 0.00222 0.00359 0.00496 0.00628 ...\n $ cumhaz   : num [1:59] 0.00661 0.02194 0.05585 0.10231 0.15719 ...\n $ std.chaz : num [1:59] 0.00121 0.00221 0.00355 0.00487 0.00615 ...\n $ type     : chr \"right\"\n $ logse    : logi TRUE\n $ conf.int : num 0.95\n $ conf.type: chr \"log\"\n $ lower    : num [1:59] 0.991 0.974 0.938 0.892 0.841 ...\n $ upper    : num [1:59] 0.996 0.982 0.952 0.91 0.862 ...\n $ call     : language survfit(formula = survobj ~ 1)\n - attr(*, \"class\")= chr \"survfit\"\n\n\n\n\n\nKaplan-Meier eğrilerinin çizilmesi\nKM tahminleri yerleştirildikten sonra, “Kaplan-Meier eğrisi” ni çizen temel plot() işlevi kullanılarak belirli bir süre boyunca sağkalım olasılığı görselleştirilebilir. Başka bir deyişle, aşağıdaki eğri, tüm hasta grubunda sağkalım deneyiminin geleneksel bir gösterimidir.\nEğrideki min ve max takip süresi hızlı bir şekilde doğrulanabilir.\nYorumlamanın kolay bir yolu, başlangıçta tüm katılımcıların hala hayatta olduğunu ve sağkalım olasılığının %100 olduğunu söylemektir. Hastalar öldükçe bu olasılık zamanla azalır. 60 günlük izlemden sağ kalanların oranı %40 civarındadır.\n\nplot(linelistsurv_fit, \n     xlab = \"Days of follow-up\",    # x-axis label\n     ylab=\"Survival Probability\",   # y-axis label\n     main= \"Overall survival curve\" # figure title\n     )\n\n\n\n\n\n\n\n\nKM sağkalım tahminlerinin güven aralığı da varsayılan olarak çizilir ve plot() komutuna conf.int = FALSE seçeneği eklenerek reddedilebilir.\nİlgilenilen olay “ölüm” olduğu için, sağkalım oranlarının tamamlayıcılarını tanımlayan bir eğri çizmek, kümülatif ölüm oranlarının çizilmesini sağlayacaktır. Bu, mevcut bir çizime bilgi ekleyen lines() ile yapılabilir.\n\n# original plot\nplot(\n  linelistsurv_fit,\n  xlab = \"Days of follow-up\",       \n  ylab = \"Survival Probability\",       \n  mark.time = TRUE,              # mark events on the curve: a \"+\" is printed at every event\n  conf.int = FALSE,              # do not plot the confidence interval\n  main = \"Overall survival curve and cumulative mortality\"\n  )\n\n# draw an additional curve to the previous plot\nlines(\n  linelistsurv_fit,\n  lty = 3,             # use different line type for clarity\n  fun = \"event\",       # draw the cumulative events instead of the survival \n  mark.time = FALSE,\n  conf.int = FALSE\n  )\n\n# add a legend to the plot\nlegend(\n  \"topright\",                               # position of legend\n  legend = c(\"Survival\", \"Cum. Mortality\"), # legend text \n  lty = c(1, 3),                            # line types to use in the legend\n  cex = .85,                                # parametes that defines size of legend text\n  bty = \"n\"                                 # no box type to be drawn for the legend\n  )",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Sağkalım Analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.tr.html#sağkalım-eğrilerinin-karşılaştırılması",
    "href": "new_pages/survival_analysis.tr.html#sağkalım-eğrilerinin-karşılaştırılması",
    "title": "27  Sağkalım Analizi",
    "section": "27.4 Sağkalım eğrilerinin karşılaştırılması",
    "text": "27.4 Sağkalım eğrilerinin karşılaştırılması\nGözlemlenen katılımcılarımızın veya hastalarımızın farklı gruplar içindeki sağkalımını karşılaştırmak için, önce ilgili sağkalım eğrilerine bakmamız ve ardından bağımsız gruplar arasındaki farkı değerlendirmek için testler yapmamız gerekebilir. Bu karşılaştırma cinsiyet, yaş, tedavi, komorbidite bazında gruplarla ilgili olabilir…\n\nLog rank testi\nLog rank testi, iki veya daha fazla bağımsız grup arasındaki tüm sağkalım deneyimini karşılaştıran popüler bir testtir ve sağkalım eğrilerinin aynı (örtüşen) olup olmadığını gösteren bir test olarak düşünülebilir (gruplar arasında sağkalımda hiçbir farkın olmadığı sıfır hipotezi). Hayatta kalma paketi nin survdiff() işlevi, rho = 0 (varsayılan) belirttiğimizde log rank testinin çalıştırılmasına izin verir. Log rank istatistiği yaklaşık olarak bir ki-kare test istatistiği şeklinde dağıtıldığından, test sonuçları bir p-değeri ile birlikte bir ki-kare değeri verir.\nİlk önce sağkalım eğrileri cinsiyet grubuna göre karşılaştırılır. Bunun için eğriler önce görselleştirilmeye çalışılır (iki hayatta kalma eğrisinin örtüşüp örtüşmediğini kontrol edilir). Biraz farklı bir formülle yeni bir survfit nesnesi oluşturulup; ardından survdiff nesnesi oluşturulur.\nFormülün sağ tarafına ~ gender yerleştirilerek, genel sağkalıma göre değil, cinsiyete göre planlama yapılır.\n\n# create the new survfit object based on gender\nlinelistsurv_fit_sex &lt;-  survfit(Surv(futime, event) ~ gender, data = linelist_surv)\n\nŞimdi sağkalım eğrileri cinsiyete göre çizilebilir. Renkler ve açıklamalar tanımlanmadan önce cinsiyet sütunundaki katman düzeylerinin sıra sına bakılır.\n\n# set colors\ncol_sex &lt;- c(\"lightgreen\", \"darkgreen\")\n\n# create plot\nplot(\n  linelistsurv_fit_sex,\n  col = col_sex,\n  xlab = \"Days of follow-up\",\n  ylab = \"Survival Probability\")\n\n# add legend\nlegend(\n  \"topright\",\n  legend = c(\"Female\",\"Male\"),\n  col = col_sex,\n  lty = 1,\n  cex = .9,\n  bty = \"n\")\n\n\n\n\n\n\n\n\nŞimdi survdiff() kullanılarak sağkalım eğrileri arasındaki fark testi hesaplanabilir.\n\n#compute the test of the difference between the survival curves\nsurvival::survdiff(\n  Surv(futime, event) ~ gender, \n  data = linelist_surv\n  )\n\nCall:\nsurvival::survdiff(formula = Surv(futime, event) ~ gender, data = linelist_surv)\n\nn=4321, 218 observations deleted due to missingness.\n\n            N Observed Expected (O-E)^2/E (O-E)^2/V\ngender=f 2156      924      909     0.255     0.524\ngender=m 2165      929      944     0.245     0.524\n\n Chisq= 0.5  on 1 degrees of freedom, p= 0.5 \n\n\nKadınlar ve erkekler için sağkalım eğrilerinin örtüştüğü ve log-rank testinin kadınlar ve erkekler arasında bir sağkalım farkı olduğuna dair kanıt vermediği görülmektedir.\nDiğer bazı R paketleri, farklı gruplar için sağkalım eğrilerinin gösterilmesine ve bir defada farkın test edilmesine izin verir. survminer paketindeki ggsurvplot() işlevi kullanılarak, eğriye her grup için yazdırılmış risk tabloları ve log-rank testinden elde edilen p değeri de eklenebilir.\nDİKKAT: survminer işlevleri, sağkalım nesnesini * ve* sağkalım nesnesine sığdırmak için kullanılan verilerin yeniden belirtilmesini gerektirir. Spesifik olmayan hata mesajlarından kaçınmak için bu işlemin yapılması ihmal edilmemelidir. \n\nsurvminer::ggsurvplot(\n    linelistsurv_fit_sex, \n    data = linelist_surv,          # again specify the data used to fit linelistsurv_fit_sex \n    conf.int = FALSE,              # do not show confidence interval of KM estimates\n    surv.scale = \"percent\",        # present probabilities in the y axis in %\n    break.time.by = 10,            # present the time axis with an increment of 10 days\n    xlab = \"Follow-up days\",\n    ylab = \"Survival Probability\",\n    pval = T,                      # print p-value of Log-rank test \n    pval.coord = c(40,.91),        # print p-value at these plot coordinates\n    risk.table = T,                # print the risk table at bottom \n    legend.title = \"Gender\",       # legend characteristics\n    legend.labs = c(\"Female\",\"Male\"),\n    font.legend = 10, \n    palette = \"Dark2\",             # specify color palette \n    surv.median.line = \"hv\",       # draw horizontal and vertical lines to the median survivals\n    ggtheme = theme_light()        # simplify plot background\n)\n\n\n\n\n\n\n\n\nAyrıca enfeksiyon kaynağına (kontaminasyon kaynağı) göre sağkalım farklılıkları test edilmek istenebilir.\nBu durumda, Log rank testi, alfa= 0,005 değerinde sağkalım olasılıkları arasında bir fark olduğuna dair yeterli kanıt sağlar. Cenazelerde enfekte olan hastaların sağkalım olasılıkları, başka yerlerde enfekte olan hastaların sağkalım olasılıklarından daha yüksektir; bu da sağkalım avantajı olduğunu düşündürür.\n\nlinelistsurv_fit_source &lt;-  survfit(\n  Surv(futime, event) ~ source,\n  data = linelist_surv\n  )\n\n# plot\nggsurvplot( \n  linelistsurv_fit_source,\n  data = linelist_surv,\n  size = 1, linetype = \"strata\",   # line types\n  conf.int = T,\n  surv.scale = \"percent\",  \n  break.time.by = 10, \n  xlab = \"Follow-up days\",\n  ylab= \"Survival Probability\",\n  pval = T,\n  pval.coord = c(40,.91),\n  risk.table = T,\n  legend.title = \"Source of \\ninfection\",\n  legend.labs = c(\"Funeral\", \"Other\"),\n  font.legend = 10,\n  palette = c(\"#E7B800\",\"#3E606F\"),\n  surv.median.line = \"hv\", \n  ggtheme = theme_light()\n)\n\nWarning in geom_segment(aes(x = 0, y = max(y2), xend = max(x1), yend = max(y2)), : All aesthetics have length 1, but the data has 2 rows.\nℹ Did you mean to use `annotate()`?\nAll aesthetics have length 1, but the data has 2 rows.\nℹ Did you mean to use `annotate()`?\nAll aesthetics have length 1, but the data has 2 rows.\nℹ Did you mean to use `annotate()`?\nAll aesthetics have length 1, but the data has 2 rows.\nℹ Did you mean to use `annotate()`?",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Sağkalım Analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.tr.html#cox-regresyon-analizi",
    "href": "new_pages/survival_analysis.tr.html#cox-regresyon-analizi",
    "title": "27  Sağkalım Analizi",
    "section": "27.5 Cox regresyon analizi",
    "text": "27.5 Cox regresyon analizi\nCox orantılı hazards regresyonu, sağkalım analizi için en popüler regresyon tekniklerinden biridir. Cox modeli, orantılı hazards varsayımı gibi uygun bir kullanım için doğrulanması gereken önemli varsayımlar gerektirdiğinden başka modeller de kullanılabilir (kaynaklara bakın).\nCox orantılı hazards regresyon modelinde, etkinin ölçüsü, katılımcının belirli bir süreye kadar yaşadığı göz önüne alındığında, başarısızlık riski (veya örneğimizde ölüm riski) olan hazard rate (HR)’dir. Genellikle, bağımsız grupları risklerine göre karşılaştırmakla ilgileniriz ve çoklu lojistik regresyon analizi ortamındaki bir olasılık oranına benzer bir tehlike oranı (HR) kullanırız. survival paketindeki cox.ph() işlevi modele uyması için kullanılır. survival paketindeki cox.zph() işlevi ise bir Cox regresyon modeli uyumu için orantılı hazards varsayımını test etmek için kullanılabilir.\nNOT: Bir olasılık 0 ile 1 aralığında olmalıdır. Ancak hazard (tehlike/risk), bir zaman birimi başına beklenen olay sayısını temsil eder.\n\nBir prediktör için tehlike oranı 1’e yakınsa, o prediktör sağkalımı etkilemez,\nHR 1’den küçükse, prediktör koruyucudur (yani, iyileştirilmiş sağkalım ile ilişkilidir),\nve HR 1’den büyükse, prediktör risk artışı (veya azalmış sağkalım) ile ilişkilidir.\n\n\nCox modelini uyarlama\nİlk olarak yaş ve cinsiyetin sağkalım üzerindeki etkilerini değerlendirmek için bir model uyarlanabilir. Sadece modeli yazdırarak elde edilen bilgiler:\n\nprediktörler ile sonuç arasındaki ilişkiyi ölçen tahmini regresyon katsayıları coef,\nhazard oranı nı üreten üstelleri (yorumlanabilirlik için exp(coef)),\nonların standart hatası se(coef),\nz-skoru: 0’dan uzakta tahmin edilen katsayının standart hata miktarı,\nve p değeri: Tahmini katsayının 0 olma olasılığı.\n\nCox model nesnesine uygulanan summary() işlevi, tahmini HR’nin güven aralığı ve farklı test puanları gibi daha fazla bilgi verir.\nİlk ortak değişken gender in etkisi ilk satırda sunulmaktadır. genderm (erkek) yazdırılır, bu da ilk katman seviyesinin (“f”), yani kadın grubunun cinsiyet için referans grubu olduğunu gösterir. Bu nedenle, test parametresinin yorumu, kadınlara kıyasla erkeklerinkiyle aynıdır. p değeri, cinsiyetin beklenen tehlike üzerindeki etkisine veya cinsiyet ile tüm nedenlere bağlı ölüm arasındaki ilişkiye dair yeterli kanıt olmadığını gösterir.\nAynı kanıt eksikliği, yaş grubuyla ilgili olarak da belirtilmiştir.\n\n#fitting the cox model\nlinelistsurv_cox_sexage &lt;-  survival::coxph(\n              Surv(futime, event) ~ gender + age_cat_small, \n              data = linelist_surv\n              )\n\n\n#printing the model fitted\nlinelistsurv_cox_sexage\n\nCall:\nsurvival::coxph(formula = Surv(futime, event) ~ gender + age_cat_small, \n    data = linelist_surv)\n\n                      coef exp(coef) se(coef)      z     p\ngenderm           -0.03149   0.96900  0.04767 -0.661 0.509\nage_cat_small5-19  0.09400   1.09856  0.06454  1.456 0.145\nage_cat_small20+   0.05032   1.05161  0.06953  0.724 0.469\n\nLikelihood ratio test=2.8  on 3 df, p=0.4243\nn= 4321, number of events= 1853 \n   (218 observations deleted due to missingness)\n\n#summary of the model\nsummary(linelistsurv_cox_sexage)\n\nCall:\nsurvival::coxph(formula = Surv(futime, event) ~ gender + age_cat_small, \n    data = linelist_surv)\n\n  n= 4321, number of events= 1853 \n   (218 observations deleted due to missingness)\n\n                      coef exp(coef) se(coef)      z Pr(&gt;|z|)\ngenderm           -0.03149   0.96900  0.04767 -0.661    0.509\nage_cat_small5-19  0.09400   1.09856  0.06454  1.456    0.145\nage_cat_small20+   0.05032   1.05161  0.06953  0.724    0.469\n\n                  exp(coef) exp(-coef) lower .95 upper .95\ngenderm               0.969     1.0320    0.8826     1.064\nage_cat_small5-19     1.099     0.9103    0.9680     1.247\nage_cat_small20+      1.052     0.9509    0.9176     1.205\n\nConcordance= 0.514  (se = 0.007 )\nLikelihood ratio test= 2.8  on 3 df,   p=0.4\nWald test            = 2.78  on 3 df,   p=0.4\nScore (logrank) test = 2.78  on 3 df,   p=0.4\n\n\nModeli çalıştırmak ve sonuçlara bakmak ilginç olsa da, orantılı hazards varsayımlarına uyulup uyulmadığını doğrulamak için göz atmak zamandan tasarruf etmenize yardımcı olabilir..\n\ntest_ph_sexage &lt;- survival::cox.zph(linelistsurv_cox_sexage)\ntest_ph_sexage\n\n              chisq df    p\ngender        0.454  1 0.50\nage_cat_small 0.838  2 0.66\nGLOBAL        1.399  3 0.71\n\n\nNOT: Cox modeli hesaplanırken, bağların nasıl ele alınacağını belirleyen yöntem adlı ikinci bir argüman belirtilebilir. varsayılan “efron” dur ve diğer seçenekler “breslow” ve “exact” dır.\nBaşka bir modelde, enfeksiyonun kaynağı ve başlangıç tarihi ile kabul arasındaki gün sayısı gibi daha fazla risk faktörü eklenir. Bu sefer, ilerlemeden önce orantılı hazards varsayımını doğrularız.\nBu modele sürekli bir prediktör (days_onset_hosp) eklendi. Bu durumda, parametre tahminlerini, diğer prediktörleri sabit tutarak, prediktördeki her bir birimlik artış için nispi tehlikenin beklenen logundaki artış olarak yorumlanır. İlk önce orantılı hazards varsayımı doğrulanır.\n\n#fit the model\nlinelistsurv_cox &lt;-  coxph(\n                        Surv(futime, event) ~ gender + age_years+ source + days_onset_hosp,\n                        data = linelist_surv\n                        )\n\n\n#test the proportional hazard model\nlinelistsurv_ph_test &lt;- cox.zph(linelistsurv_cox)\nlinelistsurv_ph_test\n\n                   chisq df       p\ngender           0.45062  1    0.50\nage_years        0.00199  1    0.96\nsource           1.79622  1    0.18\ndays_onset_hosp 31.66167  1 1.8e-08\nGLOBAL          34.08502  4 7.2e-07\n\n\nBu varsayımın grafiksel doğrulaması, survminer paketindeki ggcoxzph() fonksiyonu ile gerçekleştirilebilir.\n\nsurvminer::ggcoxzph(linelistsurv_ph_test)\n\n\n\n\n\n\n\n\nModel sonuçları, başlangıçtan hastaneye başvurana kadar olan süre ile tüm nedenlere bağlı mortalite arasında negatif bir ilişki olduğunu göstermektedir. Cinsiyet sabit tutulduğunda, bir gün sonra hastaneye başvuran bir kişide beklenen risk, diğerinden 0,9 kat daha düşüktür. Ya da daha açık bir anlatımla, hastaneye başvuruya başlama süresindeki bir birimlik artış, ölüm riskinde %10,7’lik (coef *100) bir azalma ile ilişkilidir.\nAyrıca sonuçlar enfeksiyon kaynağı ile tüm nedenlere bağlı ölümler arasında pozitif bir ilişki olduğunu göstermektedir. Yani cenaze dışında bir enfeksiyon kaynağı olan hastalarda ölüm riski (1.21x) artmaktadır.\n\n#print the summary of the model\nsummary(linelistsurv_cox)\n\nCall:\ncoxph(formula = Surv(futime, event) ~ gender + age_years + source + \n    days_onset_hosp, data = linelist_surv)\n\n  n= 2772, number of events= 1180 \n   (1767 observations deleted due to missingness)\n\n                     coef exp(coef)  se(coef)      z Pr(&gt;|z|)    \ngenderm          0.004710  1.004721  0.060827  0.077   0.9383    \nage_years       -0.002249  0.997753  0.002421 -0.929   0.3528    \nsourceother      0.178393  1.195295  0.084291  2.116   0.0343 *  \ndays_onset_hosp -0.104063  0.901169  0.014245 -7.305 2.77e-13 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n                exp(coef) exp(-coef) lower .95 upper .95\ngenderm            1.0047     0.9953    0.8918    1.1319\nage_years          0.9978     1.0023    0.9930    1.0025\nsourceother        1.1953     0.8366    1.0133    1.4100\ndays_onset_hosp    0.9012     1.1097    0.8764    0.9267\n\nConcordance= 0.566  (se = 0.009 )\nLikelihood ratio test= 71.31  on 4 df,   p=1e-14\nWald test            = 59.22  on 4 df,   p=4e-12\nScore (logrank) test = 59.54  on 4 df,   p=4e-12\n\n\nBu ilişki bir tablo ile doğrulanabilir:\n\nlinelist_case_data %&gt;% \n  tabyl(days_onset_hosp, outcome) %&gt;% \n  adorn_percentages() %&gt;%  \n  adorn_pct_formatting()\n\n days_onset_hosp Death Recover   NA_\n               0 44.3%   31.4% 24.3%\n               1 46.6%   32.2% 21.2%\n               2 43.0%   32.8% 24.2%\n               3 45.0%   32.3% 22.7%\n               4 41.5%   38.3% 20.2%\n               5 40.0%   36.2% 23.8%\n               6 32.2%   48.7% 19.1%\n               7 31.8%   38.6% 29.5%\n               8 29.8%   38.6% 31.6%\n               9 30.3%   51.5% 18.2%\n              10 16.7%   58.3% 25.0%\n              11 36.4%   45.5% 18.2%\n              12 18.8%   62.5% 18.8%\n              13 10.0%   60.0% 30.0%\n              14 10.0%   50.0% 40.0%\n              15 28.6%   42.9% 28.6%\n              16 20.0%   80.0%  0.0%\n              17  0.0%  100.0%  0.0%\n              18  0.0%  100.0%  0.0%\n              22  0.0%  100.0%  0.0%\n              NA 52.7%   31.2% 16.0%\n\n\nBu ilişkinin verilerde neden var olduğunun düşünülmesi ve araştırılması gerekir. Olası bir açıklama, daha sonra kabul edilecek kadar uzun yaşayan hastaların başlangıçta daha az şiddetli hastalığa sahip olmaları olabilir. Belki de daha olası bir başka açıklama, simüle edilmiş sahte bir veri seti kullanıldığı için bu modelin gerçeği yansıtmamasıdır!\n\n\n\nForest grafikleri\nDaha sonra, survminer paketi nin ggforest() işleviyle pratik forest grafikleri kullanılarak cox modelinin sonuçları görselleştirilebilir..\n\nggforest(linelistsurv_cox, data = linelist_surv)",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Sağkalım Analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.tr.html#sağkalım-modellerinde-zamana-bağlı-değişkenler",
    "href": "new_pages/survival_analysis.tr.html#sağkalım-modellerinde-zamana-bağlı-değişkenler",
    "title": "27  Sağkalım Analizi",
    "section": "27.6 Sağkalım modellerinde zamana bağlı değişkenler",
    "text": "27.6 Sağkalım modellerinde zamana bağlı değişkenler\nAşağıdaki bölümlerden bazıları, faydalı bir kaynaktan izin alınarak uyarlanmıştır introduction to survival analysis in R by Dr. Emily Zabor\nSon bölümde, ilgilenilen ortak değişkenler ve sağkalım sonuçları arasındaki ilişkileri incelemek için Cox regresyonunu kullanma ele alındı. Ancak bu analizler, başlangıçta, yani olayın takip süresi başlamadan önce ölçülen ortak değişkene dayanır.\nTakip süresi başladıktan sonra ölçülen bir ortak değişkenle ilgileniyorsanız ne olur? Ya da zamanla değişebilen bir ortak değişkeniniz varsa?\nÖrneğin, zaman içinde değişebilen hastane laboratuvar değerleri ölçümlerini tekrarladığınız klinik verilerle çalışıyor olabilirsiniz. Bu, bir Zaman Bağımlı Ortak Değişken örneğidir. Bunu ele almak için özel bir kuruluma ihtiyacınız var, ancak neyse ki cox modeli çok esnektir ve bu tür veriler sağkalım paketindeki araçlarla da modellenebilir.\n\nZaman bağımlı ortak değişken kurulumu\nR’daki zaman bağımlı ortak değişkenlerin analizi, özel bir veri setinin kurulmasını gerektirir. İlgileniyorsanız, sağkalım paketi yazarının bu konu hakkındaki daha ayrıntılı makalesine bakılabilir Cox Modelinde Zamana Bağlı Ortak Değişkenleri ve Zamana Bağlı Katsayıları Kullanma.\nBunun için, 137 kemik iliği nakli hastasının verilerini içeren BMT adlı SemiCompRisks paketinden yeni bir veri seti kullanılabilir. Odaklanılacak değişkenler şunlardır:\n\nT1 - ölüme veya son takibe kadar geçen süre (gün olarak)\ndelta1 - ölüm göstergesi; 1-Ölü, 0-Canlı\nTA - akut graft-versus-host hastalığına kadar geçen süre (gün olarak)\ndeltaA - akut graft-versus-host hastalığı göstergesi;\n\n1 - Gelişmiş akut graft-versus-host hastalığı\n0 - Hiçbir zaman akut graft-versus-host hastalığı geliştirmedi.\n\n\nBu veri seti sağkalım paketinden temel R komutu data() kullanarak yüklenir; bu, zaten yüklü olan bir R paketine dahil olan verileri yüklemek için kullanılabilir. BMT veri çerçevesi R ortamında görünecektir.\n\ndata(BMT, package = \"SemiCompRisks\")\n\n\nÖzgün hasta tanımlayıcısı ekleme\nBMT verilerinde, istenilen veri seti çeşidini oluşturmak için gerekli olan özgün bir ID sütunu yoktur. Bu nedenle, tidyverse paketinden tibble rowid_to_column() işlevini my_id adlı yeni bir ID sütunu oluşturmak için kullanılır (1’den başlayarak sıralı satır kimlikleriyle veri çerçevesinin başına sütun ekler) . Veri çerçevesi bmt olarak adlandırılır.\n\nbmt &lt;- rowid_to_column(BMT, \"my_id\")\n\nVeri seti şimdi şöyle görünür:\n\n\n\n\n\n\n\n\nHasta dizilerini genişletme\nDaha sonra, yeniden yapılandırılmış veri setini oluşturmak için event() ve tdc() yardımcı işlevleriyle tmerge() işlevi kullanılır. Amaç; her hasta için, farklı bir deltaA değerine sahip oldukları her zaman aralığı için ayrı bir satır oluşturmak üzere veri setini yeniden yapılandırmaktır. Bu durumda, veri toplama döneminde akut graft-versus-host hastalığı geliştirip geliştirmediğine bağlı olarak her hasta en fazla iki sıraya sahip olabilir. Akut graft-versus-host hastalığı gelişimi için yeni göstergeye agvhd adı verilir.\n\ntmerge(), her hasta için tanımlanan farklı ortak değişken değerler için birden fazla zaman aralığı içeren uzun bir veri seti oluşturur\nevent(), yeni oluşturulan zaman aralıklarıyla uyumlu olacak yeni olay göstergesini yaratır\ntdc() , yeni oluşturulan zaman aralıklarına uygun olarak zamana bağlı ortak değişken sütunu agvhd yi oluşturur\n\n\ntd_dat &lt;- \n  tmerge(\n    data1 = bmt %&gt;% select(my_id, T1, delta1), \n    data2 = bmt %&gt;% select(my_id, T1, delta1, TA, deltaA), \n    id = my_id, \n    death = event(T1, delta1),\n    agvhd = tdc(TA)\n    )\n\nBunun ne işe yaradığını görmek için ilk 5 özgün hastaya ait verilere bakıldığında orijinal verilerdeki ilgili değişkenler bu şekilde görünür:\n\nbmt %&gt;% \n  select(my_id, T1, delta1, TA, deltaA) %&gt;% \n  filter(my_id %in% seq(1, 5))\n\n  my_id   T1 delta1   TA deltaA\n1     1 2081      0   67      1\n2     2 1602      0 1602      0\n3     3 1496      0 1496      0\n4     4 1462      0   70      1\n5     5 1433      0 1433      0\n\n\nAynı hastalar için yeni veri seti şuna benzer:\n\ntd_dat %&gt;% \n  filter(my_id %in% seq(1, 5))\n\n  my_id   T1 delta1 tstart tstop death agvhd\n1     1 2081      0      0    67     0     0\n2     1 2081      0     67  2081     0     1\n3     2 1602      0      0  1602     0     0\n4     3 1496      0      0  1496     0     0\n5     4 1462      0      0    70     0     0\n6     4 1462      0     70  1462     0     1\n7     5 1433      0      0  1433     0     0\n\n\nŞimdi bazı hastalarımızın veri setinde yeni değişkenimiz agvhd için farklı bir değere sahip oldukları aralıklara karşılık gelen iki satırı var. Örneğin, Hasta 1 artık 0 zamanından 67. zamana kadar sıfır agvhd değerine ve 67’den 2081’e kadar 1 değerine sahip iki satıra sahiptir.\n\n\n\nZamana bağlı ortak değişkenlerle cox regresyonu\nVeriler yeniden şekillendirildiğine ve yeni zamana bağlı aghvd değişkeni eklediğine göre, şimdi basit tek değişkenli bir cox regresyon modeli uygulanabilir. Daha önce olduğu gibi aynı coxph() işlevi kullanılabilir; time1 = ve time2 = bağımsız değişkenlerini kullanarak her bir aralık için hem başlangıç hem de bitiş zamanını belirtmek için Surv() işlevini değiştirmek yeterlidir.\n\nbmt_td_model = coxph(\n  Surv(time = tstart, time2 = tstop, event = death) ~ agvhd, \n  data = td_dat\n  )\n\nsummary(bmt_td_model)\n\nCall:\ncoxph(formula = Surv(time = tstart, time2 = tstop, event = death) ~ \n    agvhd, data = td_dat)\n\n  n= 163, number of events= 80 \n\n        coef exp(coef) se(coef)    z Pr(&gt;|z|)\nagvhd 0.3351    1.3980   0.2815 1.19    0.234\n\n      exp(coef) exp(-coef) lower .95 upper .95\nagvhd     1.398     0.7153    0.8052     2.427\n\nConcordance= 0.535  (se = 0.024 )\nLikelihood ratio test= 1.33  on 1 df,   p=0.2\nWald test            = 1.42  on 1 df,   p=0.2\nScore (logrank) test = 1.43  on 1 df,   p=0.2\n\n\nYine, survminer paketi ’nden ggforest() işlevi kullanılarak cox model sonuçları görselleştirilebilir.:\n\nggforest(bmt_td_model, data = td_dat)\n\n\n\n\n\n\n\n\nForest grafiğinden, güven aralığından ve p-değerinden görülebildiği üzere, basit modelimiz bağlamında ölüm ile akut graft-versus-host hastalığı arasında güçlü bir ilişki yok gibi görünmektedir.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Sağkalım Analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.tr.html#kaynaklar",
    "href": "new_pages/survival_analysis.tr.html#kaynaklar",
    "title": "27  Sağkalım Analizi",
    "section": "27.7 Kaynaklar",
    "text": "27.7 Kaynaklar\nSağkalım Analizi Bölüm I: Temel kavramlar ve ilk analizler\nR’da Sağkalım Analizi\nBulaşıcı hastalık araştırmalarında sağkalım analizi: Olayları zaman içinde tanımlama\nGelişmiş sağkalım modelleri Princeton ile ilgili bölüm\nCox Modelinde Zamana Bağlı Ortak Değişkenleri ve Zamana Bağlı Katsayıları Kullanma\nR kopya kağıdında sağkalım analizi\nSurvminer kopya kağıdı\nEk materyal olarak sağlanan R Kodu ile kanser kayıt verileri için farklı sağkalım ölçüleri hakkında bir sayfa",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Sağkalım Analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.tr.html",
    "href": "new_pages/gis.tr.html",
    "title": "28  Coğrafi Bilgi Sistemleri (CBS) Temelleri",
    "section": "",
    "text": "28.1 Genel Bakış\nVerilerinizin uzamsal yönleri, salgının durumuna ilişkin pek çok içgörü sağlayabilir ve aşağıdaki gibi soruları yanıtlayabilir:\nBu CBS sayfasının mevcut odak noktası, salgın yanıtında uygulamalı epidemiyologların ihtiyaçlarını ele almaktır. tmap ve ggplot2 paketlerini kullanarak temel mekansal veri görselleştirme yöntemlerini keşfedeceğiz. Ayrıca sf paketi ile bazı temel uzamsal veri yönetimi ve sorgulama yöntemlerini de inceleyeceğiz. Son olarak, spdep paketini kullanarak uzamsal ilişkiler, uzamsal otokorelasyon ve uzamsal regresyon gibi mekansal istatistik kavramlarına kısaca değineceğiz.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Coğrafi Bilgi Sistemleri (CBS) Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.tr.html#genel-bakış",
    "href": "new_pages/gis.tr.html#genel-bakış",
    "title": "28  Coğrafi Bilgi Sistemleri (CBS) Temelleri",
    "section": "",
    "text": "Mevcut hastalık noktaları nerede?\nKümelenme noktaları zaman içinde nasıl değişti?\nSağlık tesislerine ulaşım nasıl? Herhangi bir iyileştirme gerekli mi?",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Coğrafi Bilgi Sistemleri (CBS) Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.tr.html#anahtar-terimler",
    "href": "new_pages/gis.tr.html#anahtar-terimler",
    "title": "28  Coğrafi Bilgi Sistemleri (CBS) Temelleri",
    "section": "28.2 Anahtar terimler",
    "text": "28.2 Anahtar terimler\nAşağıda bazı temel terminolojiyi tanıtıyoruz. CBS ve mekansal analize kapsamlı bir giriş için, Referanslar bölümünde listelenen daha uzun öğreticilerden veya kurslardan birini incelemenizi öneririz.\nCoğrafi Bilgi Sistemi (CBS) - CBS, mekansal verileri toplamak, yönetmek, analiz etmek ve görselleştirmek için bir çerçeve veya ortamdır.\n\nCBS yazılımı\nBazı popüler CBS yazılımları, harita geliştirme ve mekansal analiz için işaretle ve tıkla etkileşimine izin verir. Bu araçlar, kod öğrenmeye gerek olmaması ve simgeleri ve özellikleri bir haritaya manuel olarak seçme ve yerleştirme kolaylığı gibi avantajlarla birlikte gelir. İşte iki popüler olan:\nArcGIS - ESRI şirketi tarafından geliştirilen, çok popüler ancak oldukça pahalı olan ticari bir CBS yazılımı\nQGIS - ArcGIS’in yapabileceği hemen hemen her şeyi yapabilen ücretsiz bir açık kaynaklı CBS yazılımı. QGIS’i buradan indirebilirsiniz\nR’ı bir CBS olarak kullanmak, “işaretle ve tıkla” yerine bir “komut satırı arayüzüne” sahip olduğundan (istenen sonucu elde etmek için kodlamanız gerekir) ilk başta daha korkutucu görünebilir. Ancak, tekrar tekrar haritalar üretmeniz veya tekrarlanabilir bir analiz oluşturmanız gerekiyorsa bu büyük bir avantajdır.\n\n\nMekansal veri\nCBS’de kullanılan iki temel konumsal veri biçimi vektör ve hücresel(raster) veridir:\nVektör Verileri - CBS’de kullanılan en yaygın konumsal veri biçimi olan vektör verileri, köşelerin ve yolların geometrik özelliklerinden oluşur. Vektör uzamsal verileri ayrıca yaygın olarak kullanılan üç türe ayrılabilir:\n\nNoktalar - Bir nokta, bir koordinat sistemindeki belirli bir konumu temsil eden bir koordinat çiftinden (x,y) oluşur. Noktalar, uzamsal verilerin en temel biçimidir ve bir durumu (yani hasta evi) veya bir konumu (yani hastaneyi) bir harita üzerinde belirtmek için kullanılabilir.\nÇizgiler - Çizgi, birbirine bağlı iki noktadan oluşur. Çizgilerin bir uzunluğu vardır ve yollar veya nehirler gibi şeyleri belirtmek için kullanılabilir.\nÇokgenler - Çokgen, noktalarla birbirine bağlanan en az üç doğru parçasından oluşur. Çokgen özellikleri bir uzunluğa (yani alanın çevresi) ve ayrıca bir alan ölçümüne sahiptir. Çokgenler bir alanı (yani bir köyü) veya bir yapıyı (yani bir hastanenin gerçek alanını) belirtmek için kullanılabilir.\n\nHücresel Veri - Uzamsal veriler için alternatif bir format olan hücresel veriler, her hücrenin yükseklik, sıcaklık, eğim, orman örtüsü vb. gibi bilgileri içeren bir hücre matrisidir (örneğin pikseller). Bunlar genellikle hava fotoğrafları, uydu görüntüler, vb. Rasterler (yani hücresel haritalar), vektör verilerinin altında “temel haritalar” olarak da kullanılabilir.\n\n\nUzamsal verileri görselleştirme\nBir harita üzerinde uzamsal verileri görsel olarak temsil etmek için, CBS yazılımı, farklı özelliklerin birbiriyle ilişkili olarak nerede olması gerektiği hakkında yeterli bilgi sağlamanızı gerektirir. Çoğu kullanım durumu için geçerli olan vektör verilerini kullanıyorsanız, bu bilgiler genellikle bir şekil dosyasında depolanır:\nShapefiles - Shapefile, çizgilerden, noktalardan veya çokgenlerden oluşan “vektör” uzamsal verileri depolamak için yaygın bir veri biçimidir. Tek bir şekil dosyası aslında en az üç dosyadan oluşan bir koleksiyondur - .shp, .shx ve .dbf. Şekil dosyasının okunabilmesi için tüm bu alt bileşen dosyalarının belirli bir dizinde (klasörde) bulunması gerekir. Bu ilişkili dosyalar, e-posta yoluyla gönderilmek veya bir web sitesinden indirilmek üzere bir ZIP klasörüne sıkıştırılabilir.\nŞekil dosyası, özelliklerin kendileri ve bunların Dünya yüzeyinde nereye yerleştirileceği hakkında bilgi içerecektir. Bu önemlidir, çünkü Dünya bir küre iken, haritalar tipik olarak iki boyutludur; uzamsal verilerin nasıl “düzleştirileceğine” ilişkin seçimler, ortaya çıkan haritanın görünümü ve yorumlanması üzerinde büyük bir etkiye sahip olabilir.\nKoordinat Referans Sistemleri (CRS) - CRS, Dünya yüzeyindeki coğrafi özellikleri konumlandırmak için kullanılan koordinat tabanlı bir sistemdir. Birkaç temel bileşeni vardır:\n\nKoordinat Sistemi - Birçok farklı koordinat sistemi vardır, bu nedenle koordinatlarınızın hangi sistemden olduğunu bildiğinizden emin olun. Enlem/boylam dereceleri yaygındır, ancak UTM koordinatlarını da görebilirsiniz.\nBirimler - Koordinat sisteminiz için birimlerin ne olduğunu öğrenin (ör. ondalık dereceler, metreler)\nDatum - Dünya’nın belirli bir modellenmiş versiyonu. Bunlar yıllar içinde revize edilmiştir, bu nedenle harita katmanlarınızın aynı veriyi kullandığından emin olun. Özellikle herhangi bir konum verisi elde edilirken yatay ve düşey konumunu tanımlamak için başlangıç alınan bir referans yüzeyi gereklidir. Yer’in şeklini ve boyutunu tanımlayan bu yüzeye Datum adı verilmektedir.\nProjeksiyon - Gerçekten yuvarlak olan dünyayı düz bir yüzeye (harita) yansıtmak için kullanılan matematiksel denklem.\n\nAşağıda gösterilen haritalama araçlarını kullanmadan uzamsal verileri özetleyebileceğinizi unutmayın. Bazen coğrafyaya göre (ör. ilçe, ülke vb.) basit bir tablo yeterlidir!",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Coğrafi Bilgi Sistemleri (CBS) Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.tr.html#cbsyi-kullanmaya-başlama",
    "href": "new_pages/gis.tr.html#cbsyi-kullanmaya-başlama",
    "title": "28  Coğrafi Bilgi Sistemleri (CBS) Temelleri",
    "section": "28.3 CBS’yi kullanmaya başlama",
    "text": "28.3 CBS’yi kullanmaya başlama\nBir harita yapmak için sahip olmanız ve düşünmeniz gereken birkaç önemli öğe var. Bunlar şunları içerir:\n\nBir veri kümesi – bu, uzamsal bir veri biçiminde olabilir (yukarıda belirtildiği gibi şekil dosyaları gibi) veya uzamsal bir biçimde olmayabilir (örneğin sadece bir csv olarak).\nVeri kümeniz uzamsal biçimde değilse ayrıca bir referans veri kümesine ihtiyacınız olacaktır. Referans verileri, verilerin uzamsal temsilinden ve belirli özelliklerin konum ve adres bilgilerini içeren materyali içeren ilgili niteliklerden oluşur.\n\nÖnceden tanımlanmış coğrafi sınırlarla (örneğin, idari bölgeler) çalışıyorsanız, referans şekil dosyaları genellikle bir devlet kurumundan veya veri paylaşım kuruluşundan ücretsiz olarak indirilebilir. Şüpheye düştüğünüzde, Google “[bölgeler] şekil dosyası” başlamak için iyi bir yerdir.\nAdres bilginiz varsa ancak enlem ve boylam yoksa, kayıtlarınız için uzamsal referans verilerini almak için bir coğrafi kodlama motoru kullanmanız gerekebilir.\n\nVeri kümelerinizdeki bilgileri hedef kitlenize nasıl sunmak istediğiniz hakkında fikriniz olmalı. Birçok farklı harita türü vardır ve ihtiyaçlarınıza en uygun harita türünü düşünmek önemlidir.\n\n\nVerilerinizi görselleştirmek için harita türleri\nChoropleth haritası - coğrafi bölgeleri bir öznitelik değerine göre temsil etmek için renklerin, gölgelerin veya desenlerin kullanıldığı bir tür tematik haritadır. Örneğin, daha büyük bir değer, daha küçük bir değerden daha koyu bir renkle gösterilebilir. Bu harita türü, bir değişkeni ve onun tanımlanmış bölgeler veya jeopolitik alanlar arasında nasıl değiştiğini görselleştirirken özellikle kullanışlıdır.\n\n\n\n\n\n\n\n\n\nVaka yoğunluğu ısı haritası - renklerin bir değerin yoğunluğunu temsil etmek için kullanıldığı, ancak verileri gruplamak için tanımlanmış bölgeleri veya jeopolitik sınırları kullanmadığı bir tür tematik haritadır. Bu harita türü tipik olarak “sıcak noktaları” veya yüksek yoğunluklu veya nokta yoğunluğuna sahip alanları göstermek için kullanılır.\n\n\n\n\n\n\n\n\n\nNokta yoğunluğu haritası - verilerinizdeki öznitelik değerlerini temsil etmek için noktaları kullanan tematik bir harita türüdür. Bu tür harita en iyi, verilerinizin dağılımını görselleştirmek ve kümeleri görsel olarak taramak için kullanılır.\nOransal semboller haritası (dereceli semboller haritası) - bir choropleth haritasına benzer bir tematik harita, ancak bir özelliğin değerini belirtmek için renk kullanmak yerine, değere göre bir sembol (genellikle bir daire) kullanır. Örneğin, daha büyük bir değer, daha küçük bir değerden daha büyük bir sembolle gösterilebilir. Bu harita türü en iyi, coğrafi bölgelerdeki verilerinizin boyutunu veya miktarını görselleştirmek istediğinizde kullanılır.\nKarmaşık coğrafi kalıpları göstermek için birkaç farklı görselleştirme türünü de birleştirebilirsiniz. Örneğin aşağıdaki haritadaki vakalar (noktalar) en yakın sağlık kuruluşuna göre renklendirilmiştir (bkz. lejand). Büyük kırmızı daireler, belirli bir yarıçaptaki sağlık tesisi hizmet alanlarını ve herhangi bir hizmet alanı dışında kalan parlak kırmızı vaka noktalarını gösterir:\n\n\n\n\n\n\n\n\n\nNot: Bu CBS sayfasının birincil odak noktası, saha salgın yanıtı bağlamına dayanmaktadır. Bu nedenle sayfanın içeriği, temel uzamsal veri manipülasyonlarını, görselleştirmeleri ve analizleri kapsayacaktır.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Coğrafi Bilgi Sistemleri (CBS) Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.tr.html#hazırlık",
    "href": "new_pages/gis.tr.html#hazırlık",
    "title": "28  Coğrafi Bilgi Sistemleri (CBS) Temelleri",
    "section": "28.4 Hazırlık",
    "text": "28.4 Hazırlık\n\nPaketleri yükleyin\nBu kod parçası, analizler için gereken paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() vurgusunu yapıyoruz. R tabanından library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakabilirsiniz.\n\npacman::p_load(\n  rio,           # verileri içe aktarmak için\n  here,          # dosyaları bulmak için\n  tidyverse,     # verileri temizlemek, işlemek ve çizmek için (ggplot2 paketini içerir)\n  sf,            # Basit Özellik formatı kullanarak uzamsal verileri yönetmek için\n  tmap,          # basit haritalar üretmek için hem etkileşimli hem de statik haritalar için çalışır\n  janitor,       # sütun adlarını temizlemek için\n  OpenStreetMap, # ggplot haritasına OSM altlık haritası eklemek için\n  spdep          # mekansal istatistik\n  ) \n\nCRAN “Uzamsal Görev Görünümü”nde uzamsal verilerle ilgilenen tüm R paketlerinin bir özetini görebilirsiniz.\n\n\nÖrnek vaka verileri\nGösteri amacıyla, simüle edilmiş Ebola salgını “satır listesi” veri çerçevesinden rastgele 1000 vakalık bir örneklemle çalışacağız (hesaplamalı olarak, daha az vakayla çalışmak bu el kitabında daha kolaydır). Takip etmek isterseniz, “clean” dosyasını indirmek için tıklayın. (.rds dosyası olarak).\nVakaların rastgele bir örneğini aldığımız için, kodları kendi başınıza çalıştırdığınızda sonuçlarınız burada gösterilenden biraz farklı görünebilir.\nrio paketinden import() fonksiyonuyla verileri içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakın).\n\n# temizlenmiş vaka satır listesini içe aktarmak\nlinelist &lt;- import(\"linelist_cleaned.rds\")  \n\nDaha sonra R tabanından sample() kullanarak 1000 satırlık rastgele bir örnek seçiyoruz.\n\n# satır listesindeki satır sayısından 1000 rastgele satır numarası üretmek\nsample_rows &lt;- sample(nrow(linelist), 1000)\n\n# yalnızca örnek satırları ve tüm sütunları tutmak için alt küme satır listesi üretmek\nlinelist &lt;- linelist[sample_rows,]\n\nŞimdi sınıf veri çerçevesi olan bu ’linelist’i “sf” (uzaysal özellikler) sınıfının bir nesnesine dönüştürmek istiyoruz. Satır listesinin, her vakanın ikametgahının enlem ve boylamını temsil eden iki sütun “boy” ve “en” olduğu göz önüne alındığında, bu kolay olacaktır.\nsf (uzaysal özellikler) paketini ve onun ‘st_as_sf()’ fonksiyonunu ‘linelist_sf’ dediğimiz yeni nesneyi yaratmak için kullanırız. Bu yeni nesne, esasen satır listesiyle aynı görünüyor, ancak “boy” ve “enlem” sütunları koordinat sütunları olarak belirlenmiş ve noktalar görüntülendiğinde bir koordinat referans sistemi (CRS) atanmıştır. 4326, koordinatlarımızı, GPS koordinatları için standart olan World Geodetic System 1984 (WGS84) temelinde tanımlar.\n\n# sf nesnesi oluşturmk\nlinelist_sf &lt;- linelist %&gt;%\n     sf::st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326)\n\nOrijinal “satır listesi” veri çerçevesi bu şekilde görünür. Bu gösterimde, yalnızca “date_onset” ve “geometry” (yukarıdaki boylam ve enlem alanlarından oluşturulan ve veri çerçevesindeki son sütun olan) sütununu kullanacağız.\n\nDT::datatable(head(linelist_sf, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )\n\n\n\n\n\n\n\nYönetici sınır şekil dosyaları\nSierra Leone: Yönetici sınır şekil dosyaları\nSierra Leone için tüm idari sınırları önceden İnsani Veri Değişimi’nden (HDX) web sitesi burada indirdik. ). Alternatif olarak, bu el kitabı için bunları ve diğer tüm örnek verileri [El kitabını ve verileri indir] sayfasında açıklandığı gibi R paketimiz aracılığıyla indirebilirsiniz.\nŞimdi Admin Level 3 şekil dosyasını R’a kaydetmek için aşağıdakileri yapacağız:\n\nŞekil dosyasını içe aktarın\nSütun adlarını temizleyin\nYalnızca ilgi alanlarını korumak için satırları filtreleyin\n\nBir şekil dosyasını içe aktarmak için sf’den read_sf() fonksiyonunu kullanırız. Dosya yolu here() ile sağlanır. - bizim durumumuzda dosya, “data”, “gis” ve “shp” alt klasörlerinde “sle_adm3.shp” dosya adıyla R projemizin içindedir (daha fazla bilgi için [İçe aktarma ve dışa aktarma] ve [R projeleri] sayfalarına bakabilirsiniz). Kendi dosya yolunuzu sağlamanız gerekecek.\nDaha sonra, şekil dosyasının sütun adlarını standartlaştırmak için janitor paketinden clean_names() kullanıyoruz. Ayrıca sadece “Western Area Urban” veya “Western Area Rural” admin2name ile satırları tutmak için filter() kullanırız.\n\n# ADM3 seviyesi temizlik \nsle_adm3 &lt;- sle_adm3_raw %&gt;%\n  janitor::clean_names() %&gt;% # sütun isimlerini standardize etmek\n  filter(admin2name %in% c(\"Western Area Urban\", \"Western Area Rural\")) # belirli alanları tutmak için filtrelemek\n\nAşağıda, içe aktarma ve temizleme işleminden sonra şekil dosyasının nasıl göründüğünü görebilirsiniz. sağa doğru kaydırın yönetici düzeyi 0 (ülke), yönetici düzeyi 1, yönetici düzeyi 2 ve son olarak yönetici düzeyi 3 olan sütunların nasıl olduğunu görmek için her düzeyin bir karakter adı ve benzersiz bir “pcode” tanımlayıcısı vardır. Pcode, artan her yönetici düzeyiyle birlikte genişler; SL (Sierra Leone) -&gt; SL04 (Batı) -&gt; SL0410 (Batı Bölgesi Kırsal) -&gt; SL040101 (Koya Kırsal).\n\n\n\n\n\n\n\n\nNüfus verileri\nSierra Leone: ADM3’e göre nüfus\nBu veriler tekrar HDX’ten (bağlantı buradan) veya [bu sayfada] açıklandığı gibi epirhandbook R paketimizden indirilebilir. [El kitabını ve verileri indirin]. .csv dosyasını yüklemek için import() kullanıyoruz. Ayrıca, sütun adı sözdizimini standartlaştırmak için içe aktarılan dosyayı clean_names() öğesine iletiyoruz.\n\n# ADM3'e göre nüfus\nsle_adm3_pop &lt;- import(here(\"data\", \"gis\", \"population\", \"sle_admpop_adm3_2020.csv\")) %&gt;%\n  clean_names()\n\nPopülasyon dosyası böyle görünüyor. Her yetki alanında “erkek” nüfus, “kadın” nüfus, “toplam” nüfus ve yaş grubuna göre nüfus dökümü sütunlarının nasıl olduğunu görmek için sağa kaydırın.\n\n\n\n\n\n\n\n\nSağlık Tesisleri\nSierra Leone: OpenStreetMap’ten alınan sağlık tesisi verileri\nYine sağlık tesislerinin konumlarını HDX buradan veya [el kitabını ve verileri indir] sayfasındaki talimatlar aracılığıyla indirdik.\nTesis noktaları şekil dosyasını read_sf() ile içe aktarıyoruz, sütun adlarını tekrar temizliyoruz ve ardından yalnızca “hastane”, “klinik” veya “doktorlar” olarak etiketlenmiş noktaları tutmak için filtreliyoruz.\n\n# OSM sağlık tesisi şekil dosyası\nsle_hf &lt;- sf::read_sf(here(\"data\", \"gis\", \"shp\", \"sle_hf.shp\")) %&gt;% \n  clean_names() %&gt;%\n  filter(amenity %in% c(\"hospital\", \"clinic\", \"doctors\"))\n\nİşte ortaya çıkan veri çerçevesi - tesis adını ve “geometri” koordinatlarını görmek için sağa kaydırın.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Coğrafi Bilgi Sistemleri (CBS) Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.tr.html#koordinatları-grafikleştirme",
    "href": "new_pages/gis.tr.html#koordinatları-grafikleştirme",
    "title": "28  Coğrafi Bilgi Sistemleri (CBS) Temelleri",
    "section": "28.5 Koordinatları grafikleştirme",
    "text": "28.5 Koordinatları grafikleştirme\nBu durumda X-Y koordinatlarını (boylam/enlem, noktalar) çizmenin en kolay yolu, bunları doğrudan hazırlık bölümünde oluşturduğumuz linelist_sf nesnesinden nokta olarak çizmektir.\ntmap paketi, hem statik (“çizim” modu) hem de etkileşimli (“görünüm” modu) için yalnızca birkaç satır kodla basit eşleme yetenekleri sunar. tmap sözdizimi ggplot2’ninkine benzerdir, öyle ki komutlar `+’ ile birbirine eklenir. Bu gösterimde daha fazla ayrıntı okuyabilirsiniz.\n\ntmap modunu ayarlayın. Bu durumda statik çıktılar üreten “plot” modunu kullanacağız.\n\n\ntmap_mode(\"plot\") # \"görünüm\" veya \"grafik\"i seçin\n\nAşağıda, noktalar tek başına çizilir.tm_shape()``,linelist_sfnesneleri ile sağlanır. Daha sonra boyut ve rengi belirterektm_dots()` aracılığıyla noktalar ekliyoruz. “linelist_sf” bir sf nesnesi olduğundan, enlem/boylam koordinatlarını ve koordinat referans sistemini (CRS) içeren iki sütunu zaten belirledik:\n\n# noktalar sadece vakalar\ntm_shape(linelist_sf) + tm_dots(size=0.08, col='blue')\n\n\n\n\n\n\n\n\nYalnız, puanlar bize fazla bir şey söylemez. Dolayısıyla idari sınırları da haritalandırmalıyız:\nYine tm_shape() kullanıyoruz (bkz. [dokümantasyon] https://www.rdocumentation.org/packages/tmap/versions/3.3/topics/tm_shape)) ancak vaka noktaları şekil dosyası sağlamak yerine, idari sınır şekil dosyası (çokgenler) sağlıyoruz.\nbbox = değişkeniyle (bbox “sınırlayıcı kutu” anlamına gelir) koordinat sınırlarını belirleyebiliriz. Önce harita gösterimini bbox olmadan ve sonra onunla birlikte gösteriyoruz.\n\n# Çokgenler sadece idari sınırlar\ntm_shape(sle_adm3) +               # yönetici sınırları şekil dosyası\n  tm_polygons(col = \"#F7F7F7\")+    # çokgenleri açık gri olarak göster\n  tm_borders(col = \"#000000\",      # renk ve çizgi ağırlığı ile sınırları göster\n             lwd = 2) +\n  tm_text(\"admin3name\")            # her çokgen için görüntülenecek sütun metni\n\n\n# Yukarıdakiyle aynı, ancak sınırlayıcı kutudan yakınlaştırma ile\ntm_shape(sle_adm3,\n         bbox = c(-13.3, 8.43,    # corner\n                  -13.2, 8.5)) +  # corner\n  tm_polygons(col = \"#F7F7F7\") +\n  tm_borders(col = \"#000000\", lwd = 2) +\n  tm_text(\"admin3name\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVe şimdi hem noktalar hem de çokgenler birlikte:\n\n# Hepsi birlikte\ntm_shape(sle_adm3, bbox = c(-13.3, 8.43, -13.2, 8.5)) +     \n  tm_polygons(col = \"#F7F7F7\") +\n  tm_borders(col = \"#000000\", lwd = 2) +\n  tm_text(\"admin3name\")+\ntm_shape(linelist_sf) +\n  tm_dots(size=0.08, col='blue', alpha = 0.5) +\n  tm_layout(title = \"Distribution of Ebola cases\")   # haritaya isim vermek\n\n\n\n\n\n\n\n\nR’daki eşleme seçeneklerinin iyi bir karşılaştırmasını okumak için bu blog gönderisine bakabilirsiniz.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Coğrafi Bilgi Sistemleri (CBS) Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.tr.html#mekansal-birleşimler",
    "href": "new_pages/gis.tr.html#mekansal-birleşimler",
    "title": "28  Coğrafi Bilgi Sistemleri (CBS) Temelleri",
    "section": "28.6 Mekansal birleşimler",
    "text": "28.6 Mekansal birleşimler\nVerileri bir veri kümesinden diğerine birleştirmeye aşina olabilirsiniz. Bu el kitabının [Birleştirme verileri] sayfasında çeşitli yöntemler tartışılmaktadır. Bir uzamsal birleşim benzer bir amaca hizmet eder, ancak uzamsal ilişkilerden yararlanır. Gözlemleri doğru bir şekilde eşleştirmek için sütunlardaki ortak değerlere güvenmek yerine, bir özelliğin bir diğerinin içinde olması veya bir diğerine en yakın komşu olması veya belirli bir yarıçapın tampon içinde olması gibi uzamsal ilişkilerini kullanabilirsiniz.\nsf paketi, uzamsal birleşimler için çeşitli yöntemler sunar. Bu başvuruda st_join yöntemi ve uzamsal birleştirme türleri hakkında daha fazla belgeye bakabilirsiniz.\n\nÇokgendeki noktalar\nMekansal olarak vakalara idari birimler atama\nİşte ilginç bir muamma: vakaların satır listesi, vakaların idari birimleri hakkında herhangi bir bilgi içermiyor. İlk veri toplama aşamasında bu tür bilgileri toplamak ideal olsa da, uzamsal ilişkilerine dayalı olarak bireysel vakalara idari birimler de atayabiliriz (yani nokta bir çokgenle kesişir).\nAşağıda, durum konumlarımızı (noktaları) ADM3 sınırları (poligonlar) ile uzamsal olarak keseceğiz:\n\nSatır listesi(puan) ile başlayın\nSınırlara uzamsal birleştirme, birleştirme türünü “st_intersects” olarak ayarlayın\nYeni yönetim sınırı sütunlarından yalnızca belirli bir kısmını tutmak için select() kullanın\n\n\nlinelist_adm &lt;- linelist_sf %&gt;%\n  \n  # idari sınır dosyasını uzamsal kesişime dayalı olarak satır listesine ekleyin\n  sf::st_join(sle_adm3, join = st_intersects)\n\n’sle_adms’deki tüm sütunlar satır listesine eklendi! Artık her vaka, içinde bulunduğu idari seviyeleri detaylandıran sütunlara sahiptir. Bu örnekte, yeni sütunlardan yalnızca ikisini (yönetici düzeyi 3) tutmak istiyoruz, bu nedenle eski sütun adlarını ve yalnızca iki ek ilgiyi “select()” yapıyoruz:\n\nlinelist_adm &lt;- linelist_sf %&gt;%\n  \n  # idari sınır dosyasını uzamsal kesişime dayalı olarak satır listesine ekleyin\n  sf::st_join(sle_adm3, join = st_intersects) %&gt;% \n  \n  # Eski sütun adlarını ve ilgilendiğiniz iki yeni yönetici adlarını saklayın\n  select(names(linelist_sf), admin3name, admin3pcod)\n\nAşağıda, yalnızca görüntüleme amacıyla, noktanın çokgen şekilleriyle uzamsal olarak kesiştiği yere bağlı olarak ilk on vakayı ve bunların admin seviyesi 3 (ADM3) yargı yetkilerini görebilirsiniz.\n\n# Şimdi her bir vakaya eklenmiş ADM3 adlarını göreceksiniz.\nlinelist_adm %&gt;% select(case_id, admin3name, admin3pcod)\n\nSimple feature collection with 1000 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -13.27117 ymin: 8.448387 xmax: -13.20576 ymax: 8.490227\nGeodetic CRS:  WGS 84\nFirst 10 features:\n     case_id     admin3name admin3pcod                   geometry\n4611  0445d8       West III   SL040208 POINT (-13.26113 8.463351)\n1142  a38384 Mountain Rural   SL040102 POINT (-13.22012 8.476247)\n1896  af2f4a        West II   SL040207  POINT (-13.2462 8.474212)\n1755  0e7ec8         East I   SL040203  POINT (-13.21763 8.48524)\n3875  b5fdeb       West III   SL040208 POINT (-13.26307 8.463263)\n5709  4ec8b9         East I   SL040203 POINT (-13.21595 8.488859)\n4099  91fb42 Mountain Rural   SL040102 POINT (-13.21628 8.462982)\n5396  72f036        East II   SL040204 POINT (-13.21312 8.483335)\n5820  4b5e3e        West II   SL040207 POINT (-13.25715 8.482293)\n764   b3deb4       West III   SL040208 POINT (-13.26103 8.464523)\n\n\nŞimdi durumlarımızı idari birime göre tanımlayabiliriz - uzaysal birleşmeden önce yapamadığımız bir şey!\n\n# İdari birime göre vaka sayılarını içeren yeni veri çerçevesi yapın\ncase_adm3 &lt;- linelist_adm %&gt;%          # yeni yönetici sütunlarına sahip satır listesiyle başlayın\n  as_tibble() %&gt;%                      # daha iyi görüntü için tibble'a dönüştürün\n  group_by(admin3pcod, admin3name) %&gt;% # admin birimine göre gruplandır, hem ada hem de pkoda göre\n  summarise(cases = n()) %&gt;%           # satırları özetle ve say\n  arrange(desc(cases))                     # azalan sırada düzenle\n\ncase_adm3\n\n# A tibble: 10 × 3\n# Groups:   admin3pcod [10]\n   admin3pcod admin3name     cases\n   &lt;chr&gt;      &lt;chr&gt;          &lt;int&gt;\n 1 SL040102   Mountain Rural   276\n 2 SL040208   West III         220\n 3 SL040207   West II          195\n 4 SL040204   East II          107\n 5 SL040201   Central I         59\n 6 SL040203   East I            58\n 7 SL040206   West I            37\n 8 SL040202   Central II        27\n 9 SL040205   East III          19\n10 &lt;NA&gt;       &lt;NA&gt;               2\n\n\nAyrıca idari birime göre vaka sayımlarının bir çubuk grafiğini de oluşturabiliriz.\nBu örnekte, ggplot()‘a ’linelist_adm’ ile başlıyoruz, böylece çubukları frekansa göre sıralayan ‘fct_infreq()’ gibi faktör fonksiyonlarını uygulayabiliriz (ipuçları için [Faktörler] sayfasına bakınız).\n\nggplot(\n    data = linelist_adm,                       # yönetici birimi bilgilerini içeren satır listesiyle başlayın\n    mapping = aes(\n      x = fct_rev(fct_infreq(admin3name))))+ # x ekseni, frekansa göre sıralanmış (tersine çevrilmiş) yönetici birimleridir\n   geom_bar()+                      # çubuk oluştur, yükseklik satır sayısıdır\n   coord_flip()+ # adm birimlerinin daha kolay okunması için X ve Y eksenlerini çevirin\n   theme_classic()+ # arka planı basitleştirir\n   labs( # başlık ve etiket\n    x = \"Admin level 3\",\n    y = \"Number of cases\",\n    title = \"Number of cases, by adminstative unit\",\n    caption = \"As determined by a spatial join, from 1000 randomly sampled cases from linelist\"\n  )\n\n\n\n\n\n\n\n\n\n\n\nEn yakın komşu\nEn yakın sağlık kuruluşunu / toplanma alanını bulma\nHastalık sıcak noktaları ile ilgili olarak sağlık tesislerinin nerede olduğunu bilmek faydalı olabilir.\nBireysel vakalara en yakın sağlık tesisini görselleştirmek için st_join() fonksiyonundan (sf paketi) st_nearest_feature birleştirme yöntemini kullanabiliriz.\n\nSatır listesinin şekil dosyası linelist_sf ile başlıyoruz\nSağlık tesislerinin ve kliniklerin konumları olan sle_hf ile mekansal olarak birleştiriyoruz (puan)\n\n\n# Her vakaya en yakın sağlık kuruluşu\nlinelist_sf_hf &lt;- linelist_sf %&gt;%                  # satır listesini şekil dosyası ile başla\n  st_join(sle_hf, join = st_nearest_feature) %&gt;%   # vaka verilerine en yakın klinikten alınan veriler\n  select(case_id, osm_id, name, amenity) %&gt;%       # sağlık tesisinin adı, türü ve geometrisi dahil olmak üzere ilgili sütunları tutmak\n  rename(\"nearest_clinic\" = \"name\")                # netlik için yeniden adlandırın\n\nAşağıda (ilk 50 satır) her vakanın artık en yakın klinik/hastaneye ait verileri olduğunu görebiliriz.\n\n\n\n\n\n\nVakaların yaklaşık %30’u için en yakın sağlık kuruluşunun “Den Clinic” olduğunu görebiliyoruz.\n\n# Sağlık kuruluşuna göre vaka sayıları\nhf_catchment &lt;- linelist_sf_hf %&gt;%   # en yakın klinik verilerini içeren satır listesiyle başlayın\n  as.data.frame() %&gt;%                # şekil dosyasından veri çerçevesine dönüştür\n  count(nearest_clinic,              # satırları \"ad\" ile sayın (kliniğin)\n        name = \"case_n\") %&gt;%         # yeni sayım sütununu \"case_n\" olarak ata\n  arrange(desc(case_n))              # azalan sırada düzenlemek\n\nhf_catchment                         # konsola yazdırmak\n\n                         nearest_clinic case_n\n1                            Den Clinic    358\n2       Shriners Hospitals for Children    342\n3         GINER HALL COMMUNITY HOSPITAL    166\n4                             panasonic     43\n5 Princess Christian Maternity Hospital     36\n6                  MABELL HEALTH CENTER     22\n7                                  &lt;NA&gt;     17\n8                     ARAB EGYPT CLINIC     16\n\n\nSonuçları görselleştirmek için tmap kullanabiliriz - bu sefer daha kolay görüntüleme için etkileşimli mod\n\ntmap_mode(\"view\")   # tmap modunu etkileşimli olarak ayarla\n\n# vakaları ve klinik noktaları çizin \ntm_shape(linelist_sf_hf) +            # vaka grafikleri\n  tm_dots(size=0.08,                  # en yakın klinik tarafından renklendirilen vakalar\n          col='nearest_clinic') +    \ntm_shape(sle_hf) +                    # klinik tesisleri büyük siyah noktalarla çizin\n  tm_dots(size=0.3, col='black', alpha = 0.4) +      \n  tm_text(\"name\") +                   # tesis adı ile üzerine bindirme\ntm_view(set.view = c(-13.2284, 8.4699, 13), # yakınlaştırmayı ayarla (merkez kodları, yakınlaştırma)\n        set.zoom.limits = c(13,14))+\ntm_layout(title = \"Cases, colored by nearest clinic\")\n\n\n\n\n\n\n\nTamponlar\nAyrıca en yakın sağlık kuruluşuna 2,5 km (~30 dakika) yürüme mesafesinde kaç vaka bulunduğunu da keşfedebiliriz.\nNot: Daha doğru mesafe hesaplamaları için, sf nesnenizi UTM (düzlemsel bir yüzeye yansıtılan Dünya) gibi ilgili yerel harita projeksiyon sistemine yeniden yansıtmak daha iyidir. Bu örnekte, basit olması için Dünya Jeodezi Sistemi (WGS84) Coğrafi koordinat sistemine bağlı kalacağız (Dünya küresel / yuvarlak bir yüzeyde temsil edilir, bu nedenle birimler ondalık derece cinsindendir). Genel bir dönüşüm kullanacağız: 1 ondalık derece = ~111km.\nBu esri makalesinde harita projeksiyonları ve koordinat sistemleri hakkında daha fazla bilgi bulabilirsiniz. Bu blog harita projeksiyonu ve ilgi alanına ve haritanızın / analizinizin içeriğine bağlı olarak uygun bir projeksiyonun nasıl seçilebileceği gibi farklı türlerden bahsetmektedir.\nİlkin, her sağlık tesisinin çevresinde ~2,5 km yarıçaplı dairesel bir tampon oluşturun. Bu, tmap’teki st_buffer() fonksiyonuyla yapılır. Haritanın birimi enlem/boylam ondalık derece cinsinden olduğundan, “0,02” bu şekilde yorumlanır. Harita koordinat sisteminiz metre cinsinden ise sayının metre cinsinden verilmesi gerekir.\n\nsle_hf_2k &lt;- sle_hf %&gt;%\n  st_buffer(dist=0.02)       # ondalık derece, yaklaşık 2,5 km'ye eşittir \n\nAşağıda, tampon bölgeleri şu şekilde çiziyoruz:\n\ntmap_mode(\"plot\")\n# Create circular buffers\ntm_shape(sle_hf_2k) +\n  tm_borders(col = \"black\", lwd = 2)+\ntm_shape(sle_hf) +                    # klinik tesislerini büyük kırmızı noktalarla çizin\n  tm_dots(size=0.3, col='black')      \n\n\n\n\n\n\n\n\n**İkinci olarak, bu arabellekleri ‘st_join()’ ve st_intersects* birleştirme türünü kullanarak durumlar (noktalar) ile kesiştiririz. Yani tamponlardan gelen veriler kesiştikleri noktalara birleştirilir.\n\n# Vakaları arabelleklerle kesiştirin\nlinelist_sf_hf_2k &lt;- linelist_sf_hf %&gt;%\n  st_join(sle_hf_2k, join = st_intersects, left = TRUE) %&gt;%\n  filter(osm_id.x==osm_id.y | is.na(osm_id.y)) %&gt;%\n  select(case_id, osm_id.x, nearest_clinic, amenity.x, osm_id.y)\n\nŞimdi sonuçları sayabiliriz: nrow(linelist_sf_hf_2k[is.na(linelist_sf_hf_2k$osm_id.y),]) 1000 vakadan herhangi biri arabellekle kesişmedi (bu değer eksik) ve bu yüzden en yakın sağlık kuruluşundan 30 dakikadan fazla yürüyün.\n\n# Sağlık tesisi tamponlarından herhangi biriyle kesişmeyen vakalar\nlinelist_sf_hf_2k %&gt;% \n  filter(is.na(osm_id.y)) %&gt;%\n  nrow()\n\n[1] 1000\n\n\nSonuçları, herhangi bir arabellekle kesişmeyen vakaların kırmızı görüneceği şekilde görselleştirebiliriz.\n\ntmap_mode(\"view\")\n\n# İlk önce vakaları puan olarak görüntüleyin\ntm_shape(linelist_sf_hf) +\n  tm_dots(size=0.08, col='nearest_clinic') +\n\n# klinik tesisleri büyük siyah noktalarla çizin\ntm_shape(sle_hf) +                    \n  tm_dots(size=0.3, col='black')+   \n\n# Ardından sağlık tesisi arabelleklerini çoklu çizgilerle kaplayın\ntm_shape(sle_hf_2k) +\n  tm_borders(col = \"black\", lwd = 2) +\n\n# Herhangi bir sağlık tesisi tamponunun parçası olmayan vakaları vurgulayın\n# kırmızı noktalarda\ntm_shape(linelist_sf_hf_2k %&gt;%  filter(is.na(osm_id.y))) +\n  tm_dots(size=0.1, col='red') +\ntm_view(set.view = c(-13.2284,8.4699, 13), set.zoom.limits = c(13,14))+\n\n# Başlık ekleyin\ntm_layout(title = \"Cases by clinic catchment area\")\n\n\n\n\n\n\n\nDiğer uzamsal birleşimler\n“Birleştirme” bağımsız değişkeni için alternatif değerler şunları içerir (belgelerden) * st_contains_properly\n* st_contains\n* st_covered_by\n* st_covers\n* st_crosses\n* st_disjoint\n* st_equals_exact\n* st_equals\n* st_is_within_distance\n* st_nearest_feature\n* st_overlaps\n* st_touches\n* st_within",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Coğrafi Bilgi Sistemleri (CBS) Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.tr.html#choropleth-haritaları",
    "href": "new_pages/gis.tr.html#choropleth-haritaları",
    "title": "28  Coğrafi Bilgi Sistemleri (CBS) Temelleri",
    "section": "28.7 Choropleth haritaları",
    "text": "28.7 Choropleth haritaları\nChoropleth haritaları, verilerinizi önceden tanımlanmış alan, genellikle idari birim veya sağlık alanı ile görselleştirmek için faydalı olabilir. Salgın müdahalesinde bu, örneğin yüksek insidans oranlarına sahip belirli alanlar için kaynak tahsisinin hedeflenmesine yardımcı olabilir.\nArtık tüm vakalara atanan idari birim adlarına sahip olduğumuza göre (yukarıdaki uzamsal birleştirmeler bölümüne bakın), vaka sayılarını alana göre eşleştirmeye başlayabiliriz (choropleth haritaları).\nADM3’e göre popülasyon verisi de elimizde olduğundan, bu bilgiyi daha önce oluşturulan case_adm3 tablosuna ekleyebiliriz.\nHer bir idari birimin ve vaka sayısının bir özet tablosu olan önceki ‘case_adm3’ adımında oluşturulan veri çerçevesi ile başlıyoruz.\n\n“sle_adm3_pop” popülasyon verileri, “case_adm3” veri çerçevesindeki “admin3pcod” sütunundaki ve “sle_adm3_pop içindeki”adm_pcode” sütunundaki ortak değerler temelinde dplyr’den bir “left_join()” kullanılarak birleştirilir `. [Birleştirme verileri] ile ilgili sayfaya bakın).\nYalnızca yararlı sütunları tutmak için yeni veri çerçevesine “select()” uygulanır - “toplam” toplam nüfustur\n10.000 nüfus başına vaka sayısı, mutate() ile yeni bir sütun olarak hesaplanır.\n\n\n# Nüfus verilerini ekleyin ve 10.000 nüfus başına vakaları hesaplayın\ncase_adm3 &lt;- case_adm3 %&gt;% \n     left_join(sle_adm3_pop,                             # pop veri kümesinden sütunlar ekle\n               by = c(\"admin3pcod\" = \"adm3_pcode\")) %&gt;%  # bu iki sütundaki ortak değerlere dayalı olarak birleştir\n     select(names(case_adm3), total) %&gt;%                 # toplam nüfus da dahil olmak üzere yalnızca önemli sütunları tut\n     mutate(case_10kpop = round(cases/total * 10000, 3)) # 3 ondalık basamağa yuvarlanmış 10.000 başına büyük/küçük harf oranıyla yeni sütun oluştur\n\ncase_adm3                                                # izlemek için konsola yazdır\n\n# A tibble: 10 × 5\n# Groups:   admin3pcod [10]\n   admin3pcod admin3name     cases  total case_10kpop\n   &lt;chr&gt;      &lt;chr&gt;          &lt;int&gt;  &lt;int&gt;       &lt;dbl&gt;\n 1 SL040102   Mountain Rural   276  33993       81.2 \n 2 SL040208   West III         220 210252       10.5 \n 3 SL040207   West II          195 145109       13.4 \n 4 SL040204   East II          107  99821       10.7 \n 5 SL040201   Central I         59  69683        8.47\n 6 SL040203   East I            58  68284        8.49\n 7 SL040206   West I            37  60186        6.15\n 8 SL040202   Central II        27  23874       11.3 \n 9 SL040205   East III          19 500134        0.38\n10 &lt;NA&gt;       &lt;NA&gt;               2     NA       NA   \n\n\nEşleme için bu tabloya ADM3 çokgen şekil dosyasıyla katılın\n\ncase_adm3_sf &lt;- case_adm3 %&gt;%                 #vakalarla başlayın ve yönetici birimine göre puan verin\n  left_join(sle_adm3, by=\"admin3pcod\") %&gt;%    # ortak sütunla şekil dosyası verilerine katıl\n  select(objectid, admin3pcod,                # yalnızca belirli ilgi sütunlarını tut\n         admin3name = admin3name.x,           # bir sütunun adını temizle\n         admin2name, admin1name,\n         cases, total, case_10kpop,\n         geometry) %&gt;%                        # geometriyi koru, böylece çokgenler çizilebilir\n  drop_na(objectid) %&gt;%                       # drop empty rows\n  st_as_sf()                                  # şekil dosyasına çevir\n\nSonuçların haritalanması\n\n# tmap modu\ntmap_mode(\"plot\")               # statik haritayı görüntüle\n\n# poligonları çiz\ntm_shape(case_adm3_sf) + \n        tm_polygons(\"cases\") +  # vaka sayısına göre renk sütunu\n        tm_text(\"admin3name\")   # ismi göster\n\n\n\n\n\n\n\n\nİnsidans oranlarını da haritalayabiliriz\n\n# 10.000 nüfus başına vakalar\ntmap_mode(\"plot\")             # statik görüntüleme modu\n\n# çizim\ntm_shape(case_adm3_sf) +                # polygonlqrı çiz\n  tm_polygons(\"case_10kpop\",            # vaka oranını içeren sütuna göre renklendir\n              breaks=c(0, 10, 50, 100), # renkler için kırılma noktaları tanımlayın\n              palette = \"Purples\"       # mor renk paleti kullanın\n              ) +\n  tm_text(\"admin3name\")                 # metni göster",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Coğrafi Bilgi Sistemleri (CBS) Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.tr.html#ggplot2-ile-haritalandırma",
    "href": "new_pages/gis.tr.html#ggplot2-ile-haritalandırma",
    "title": "28  Coğrafi Bilgi Sistemleri (CBS) Temelleri",
    "section": "28.8 ggplot2 ile haritalandırma",
    "text": "28.8 ggplot2 ile haritalandırma\nggplot2 kullanımına zaten aşina iseniz, verilerinizin statik haritalarını oluşturmak için bu paketi kullanabilirsiniz. ‘geom_sf()’ fonksiyonu, verilerinizdeki hangi özelliklerin (noktalar, çizgiler veya çokgenler) olduğuna bağlı olarak farklı nesneler çizecektir. Örneğin, bir choropleth haritası oluşturmak için çokgen geometrili “sf” verilerini kullanarak bir “ggplot()” içinde “geom_sf()” kullanabilirsiniz.\nBunun nasıl çalıştığını göstermek için daha önce kullandığımız ADM3 çokgen şekil dosyasıyla başlayabiliriz. Bunların Sierra Leone’deki Yönetici Düzey 3 bölgeleri olduğunu hatırlayın:\n\nsle_adm3\n\nSimple feature collection with 12 features and 19 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -13.29894 ymin: 8.094272 xmax: -12.91333 ymax: 8.499809\nGeodetic CRS:  WGS 84\n# A tibble: 12 × 20\n   objectid admin3name   admin3pcod admin3ref_n admin2name admin2pcod admin1name\n *    &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;     \n 1      155 Koya Rural   SL040101   Koya Rural  Western A… SL0401     Western   \n 2      156 Mountain Ru… SL040102   Mountain R… Western A… SL0401     Western   \n 3      157 Waterloo Ru… SL040103   Waterloo R… Western A… SL0401     Western   \n 4      158 York Rural   SL040104   York Rural  Western A… SL0401     Western   \n 5      159 Central I    SL040201   Central I   Western A… SL0402     Western   \n 6      160 East I       SL040203   East I      Western A… SL0402     Western   \n 7      161 East II      SL040204   East II     Western A… SL0402     Western   \n 8      162 Central II   SL040202   Central II  Western A… SL0402     Western   \n 9      163 West III     SL040208   West III    Western A… SL0402     Western   \n10      164 West I       SL040206   West I      Western A… SL0402     Western   \n11      165 West II      SL040207   West II     Western A… SL0402     Western   \n12      167 East III     SL040205   East III    Western A… SL0402     Western   \n# ℹ 13 more variables: admin1pcod &lt;chr&gt;, admin0name &lt;chr&gt;, admin0pcod &lt;chr&gt;,\n#   date &lt;date&gt;, valid_on &lt;date&gt;, valid_to &lt;date&gt;, shape_leng &lt;dbl&gt;,\n#   shape_area &lt;dbl&gt;, rowcacode0 &lt;chr&gt;, rowcacode1 &lt;chr&gt;, rowcacode2 &lt;chr&gt;,\n#   rowcacode3 &lt;chr&gt;, geometry &lt;MULTIPOLYGON [°]&gt;\n\n\nEşlemek istediğimiz verileri şekil dosyası nesnesine eklemek için dplyr’deki left_join() fonksiyonunu kullanabiliriz. Bu durumda, daha önce oluşturduğumuz ‘case_adm3’ veri çerçevesini, idari bölgelere göre vaka sayılarını özetlemek için kullanacağız; ancak, bir veri çerçevesinde depolanan herhangi bir veriyi eşlemek için aynı yaklaşımı kullanabiliriz.\n\nsle_adm3_dat &lt;- sle_adm3 %&gt;% \n  inner_join(case_adm3, by = \"admin3pcod\") # iç birleştirme = yalnızca her iki veri nesnesinde de tutuluyorsa\n\nselect(sle_adm3_dat, admin3name.x, cases) # seçili değişkenleri konsola yazdır\n\nSimple feature collection with 9 features and 2 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -13.29894 ymin: 8.384533 xmax: -13.12612 ymax: 8.499809\nGeodetic CRS:  WGS 84\n# A tibble: 9 × 3\n  admin3name.x   cases                                                  geometry\n  &lt;chr&gt;          &lt;int&gt;                                        &lt;MULTIPOLYGON [°]&gt;\n1 Mountain Rural   276 (((-13.21496 8.474341, -13.21479 8.474289, -13.21465 8.4…\n2 Central I         59 (((-13.22646 8.489716, -13.22648 8.48955, -13.22644 8.48…\n3 East I            58 (((-13.2129 8.494033, -13.21076 8.494026, -13.21013 8.49…\n4 East II          107 (((-13.22653 8.491883, -13.22647 8.491853, -13.22642 8.4…\n5 Central II        27 (((-13.23154 8.491768, -13.23141 8.491566, -13.23144 8.4…\n6 West III         220 (((-13.28529 8.497354, -13.28456 8.496497, -13.28403 8.4…\n7 West I            37 (((-13.24677 8.493453, -13.24669 8.493285, -13.2464 8.49…\n8 West II          195 (((-13.25698 8.485518, -13.25685 8.485501, -13.25668 8.4…\n9 East III          19 (((-13.20465 8.485758, -13.20461 8.485698, -13.20449 8.4…\n\n\nBölgeye göre vaka sayımlarının sütun grafiğini yapmak için, ggplot2 kullanarak, geom_col()u şu şekilde çağırabiliriz:\n\nggplot(data=sle_adm3_dat) +\n  geom_col(aes(x=fct_reorder(admin3name.x, cases, .desc=T),   # 'vakaları' azaltarak x eksenini yeniden sıralayın\n               y=cases)) +                                  # y ekseni bölgeye göre vaka sayısıdır\n  theme_bw() +\n  labs(                                                     # şekil metnini ayarla\n    title=\"Number of cases, by administrative unit\",\n    x=\"Admin level 3\",\n    y=\"Number of cases\"\n  ) + \n  guides(x=guide_axis(angle=45))                            # açı x ekseni etiketleri daha iyi sığdırmak için 45 derecedir\n\n\n\n\n\n\n\n\nBunun yerine vaka sayımlarının bir choropleth haritası yapmak için ggplot2 kullanmak istiyorsak, geom_sf() fonksiyonunu çağırmak için benzer sözdizimini kullanabiliriz:\n\nggplot(data=sle_adm3_dat) + \n  geom_sf(aes(fill=cases))    # dolguyu vaka sayısı değişkenine göre değiştirecek şekilde ayarla\n\n\n\n\n\n\n\n\nArdından, ggplot2 genelinde tutarlı olan dilbilgisini kullanarak haritamızın görünümünü özelleştirebiliriz, örneğin:\n\nggplot(data=sle_adm3_dat) +                           \n  geom_sf(aes(fill=cases)) +                        \n  scale_fill_continuous(high=\"#54278f\", low=\"#f2f0f7\") +    # renk derecesini değiştir\n  theme_bw() +\n  labs(title = \"Number of cases, by administrative unit\",   # şekil metnini ayarla\n       subtitle = \"Admin level 3\"\n  )\n\n\n\n\n\n\n\n\nggplot2 ile rahat çalışan R kullanıcıları için, geom_sf(), temel harita görselleştirmeleri için uygun olan basit ve doğrudan bir uygulama sunar. Daha fazla bilgi edinmek için geom_sf() gösterimi veya ggplot2 kitabını okuyabilirsiniz.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Coğrafi Bilgi Sistemleri (CBS) Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.tr.html#altlık-haritalar",
    "href": "new_pages/gis.tr.html#altlık-haritalar",
    "title": "28  Coğrafi Bilgi Sistemleri (CBS) Temelleri",
    "section": "28.9 Altlık Haritalar",
    "text": "28.9 Altlık Haritalar\n\nOpenStreetMap\nAşağıda, OpenStreetMap özelliklerini kullanarak ggplot2 haritası için bir altlık haritanın nasıl elde edileceğini açıklıyoruz. Alternatif yöntemler arasında, Google’a ücretsiz kayıt gerektiren ggmap kullanımı yer almaktadır (detaylar) .\nOpenStreetMap, ücretsiz düzenlenebilir bir dünya haritası oluşturmaya yönelik ortak bir projedir. Temel coğrafi konum verileri (örneğin şehirlerin konumları, yollar, doğal özellikler, havaalanları, okullar, hastaneler, yollar vb.), projenin birincil çıktısı olarak kabul edilir.\nÖncelikle altlık haritamızı alacağımız OpenStreetMap paketini yüklüyoruz.\nArdından, OpenStreetMap paketinden (dosyalar ‘openmap()’ fonksiyonunu kullanarak tanımladığımız ‘harita’ nesnesini oluşturuyoruz). Aşağıdakileri sağlıyoruz:\n\n‘upperLeft’ ve ‘lowRight’ altlık harita döşemesinin sınırlarını belirten iki koordinat çifti\n\nBu durumda, satır listesinin satırlarından max ve min’i koyuyoruz, böylece harita verilere dinamik olarak yanıt verecek\n\nzoom = (null ise otomatik olarak belirlenir)\ntype = hangi tür altlık harita - burada birkaç olasılık listeledik ve kod şu anda ilkini ([1]) “osm” kullanıyor\nmergeTiles = DOĞRU seçtik, böylece temel döşemeler tek bir yerde birleştirildi.\n\n\n# paketi yükle\npacman::p_load(OpenStreetMap)\n\n# Enlem/boylam koordinat aralığına göre altlık haritayı sığdır. Döşeme türünü seç.\nmap &lt;- openmap(\n  upperLeft = c(max(linelist$lat, na.rm=T), max(linelist$lon, na.rm=T)),   # altlık harita döşemelerinin sınırı\n  lowerRight = c(min(linelist$lat, na.rm=T), min(linelist$lon, na.rm=T)),\n  zoom = NULL,\n  type = c(\"osm\", \"stamen-toner\", \"stamen-terrain\", \"stamen-watercolor\", \"esri\",\"esri-topo\")[1])\n\nBu altlık haritasını OpenStreetMap paketinden autoplot.OpenStreetMap() kullanarak şimdi çizersek, eksenlerdeki birimlerin enlem/boylam koordinatları olmadığını görürsünüz. Farklı bir koordinat sistemi kullanıyor. Vaka konutlarını (enlem/boylamda depolanan) doğru bir şekilde görüntülemek için bunun değiştirilmesi gerekir.\n\nautoplot.OpenStreetMap(map)\n\n\n\n\n\n\n\n\nBu nedenle OpenStreetMap paketindeki openproj() fonksiyonu ile haritayı enlem/boylam şekline dönüştürmek istiyoruz. Altlık harita olarak ’map’i ve ayrıca istediğimiz Koordinat Referans Sistemini (CRS) sağlıyoruz. Bunu, WGS 1984 projeksiyonu için “proj.4” karakter dizisini sağlayarak yapıyoruz, ancak CRS’yi başka şekillerde de sağlayabilirsiniz. (bir proj.4 dizesinin ne olduğunu anlamak için bkz. bu sayfa\n\n# WGS84 projeksiyonu\nmap_latlon &lt;- openproj(map, projection = \"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs\")\n\nŞimdi grafiği oluşturduğumuzda eksenler boyunca enlem ve boylam koordinatları olduğunu görüyoruz. Koordinat sistemi dönüştürüldü. Artık vakalarımız üst üste bindirilirse doğru şekilde çizilecek!\n\n# Grafik haritası. ggplot ile çalışmak için \"autoplot\" kullanılmalıdır\nautoplot.OpenStreetMap(map_latlon)\n\n\n\n\n\n\n\n\nDaha fazla bilgi için Eğitimlere buradan ve buradan bakın Konular/autoplot.OpenStreetMap) ulaşabilirsiniz.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Coğrafi Bilgi Sistemleri (CBS) Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.tr.html#konturlu-yoğunluk-ısı-haritaları",
    "href": "new_pages/gis.tr.html#konturlu-yoğunluk-ısı-haritaları",
    "title": "28  Coğrafi Bilgi Sistemleri (CBS) Temelleri",
    "section": "28.10 Konturlu yoğunluk ısı haritaları",
    "text": "28.10 Konturlu yoğunluk ısı haritaları\nAşağıda, bir satır listesiyle (vaka başına bir satır) başlayarak, bir altlık harita üzerinde vakaların konturlu bir yoğunluk ısı haritasının nasıl elde edileceğini açıklıyoruz.\n\nYukarıda açıklandığı gibi OpenStreetMap’ten altlık harita döşemesi oluşturun\nEnlem ve boylam sütunlarını kullanarak durumları ’linelist’ten çizin\nNoktaları ggplot2’den stat_density_2d() ile bir yoğunluk ısı haritasına dönüştürün,\n\nEnlem/boylam koordinatlarına sahip bir altlık haritamız olduğunda, yerleşim yerlerinin enlem/boylam koordinatlarını kullanarak durumlarımızı en üste çizebiliriz.\nAltlık haritayı oluşturmak için “autoplot.OpenStreetMap()” fonksiyonunu temel alan ggplot2 fonksiyonları, aşağıda “geom_point()” ile gösterildiği gibi, kolayca en üste eklenecektir:\n\n# Grafik haritası. ggplot ile çalışmak için \"autoplot\" kullanılmalıdır\nautoplot.OpenStreetMap(map_latlon)+                 # altlık haritası ile başla\n  geom_point(                                       # satır listesinin enlem ve boylam sütunlarından xy noktaları ekleyin \n    data = linelist,                                \n    aes(x = lon, y = lat),\n    size = 1, \n    alpha = 0.5,\n    show.legend = FALSE) +                          # göstergeleri tamamen bırak\n  labs(x = \"Longitude\",                             # başlıklar ve etiketler\n       y = \"Latitude\",\n       title = \"Cumulative cases\")\n\n\n\n\n\n\n\n\nYukarıdaki haritanın yorumlanması zor olabilir, özellikle de noktalar çakışıyorsa. Bunun yerine ggplot2 stat_density_2d() fonksiyonunu kullanarak 2 boyutlu bir yoğunluk haritası çizebilirsiniz. Hala satır listesi enlem/boylam koordinatlarını kullanıyorsunuz, ancak 2B çekirdek yoğunluğu tahmini yapılıyor ve sonuçlar kontur çizgileriyle - bir topografik harita gibi - gösteriliyor. Belgelerin tamamını buradan okuyabilirsiniz\n\n# altlık haritası ile başla\nautoplot.OpenStreetMap(map_latlon)+\n  \n  # yoğunluk grafiğine ekle\n  ggplot2::stat_density_2d(\n        data = linelist,\n        aes(\n          x = lon,\n          y = lat,\n          fill = ..level..,\n          alpha = ..level..),\n        bins = 10,\n        geom = \"polygon\",\n        contour_var = \"count\",\n        show.legend = F) +                          \n  \n  # renk dağılımını belirle\n  scale_fill_gradient(low = \"black\", high = \"red\")+\n  \n  # etiketler \n  labs(x = \"Longitude\",\n       y = \"Latitude\",\n       title = \"Distribution of cumulative cases\")\n\n\n\n\n\n\n\n\n\n\nZaman serisi ısı haritası\nYukarıdaki yoğunluk ısı haritası kümülatif durumları gösterir. Satır listesinden türetilen semptom başlangıç ayına dayalı olarak ısı haritasını şekillendirerek salgını zaman ve mekan içinde inceleyebiliriz.\nBaşlangıç Yılı ve Ayı ile yeni bir sütun oluşturarak “satır listesi” ile başlıyoruz. R tabanındaki ‘format()’ fonksiyonu, bir tarihin görüntülenme şeklini değiştirir. Bu durumda “YYYY-AA” istiyoruz.\n\n# başlangıç ayını dışa aktar\nlinelist &lt;- linelist %&gt;% \n  mutate(date_onset_ym = format(date_onset, \"%Y-%m\"))\n\n# Değerleri inceleyin\ntable(linelist$date_onset_ym, useNA = \"always\")\n\n\n2014-05 2014-06 2014-07 2014-08 2014-09 2014-10 2014-11 2014-12 2015-01 2015-02 \n      9      15      48      90     175     207     113      99      70      44 \n2015-03 2015-04    &lt;NA&gt; \n     52      34      44 \n\n\nŞimdi, yoğunluk ısı haritasına ggplot2 aracılığıyla yüzey oluşturmayı tanıtıyoruz. Yeni sütun satır olarak kullanılarak facet_wrap() uygulanır. Anlaşılır olması için yüzey sütunlarının sayısını 3 olarak ayarladık.\n\n# paketler\npacman::p_load(OpenStreetMap, tidyverse)\n\n# altlık haritası ile başlayın\nautoplot.OpenStreetMap(map_latlon)+\n  \n  # yoğunluk grafiği ekleyin\n  ggplot2::stat_density_2d(\n        data = linelist,\n        aes(\n          x = lon,\n          y = lat,\n          fill = ..level..,\n          alpha = ..level..),\n        bins = 10,\n        geom = \"polygon\",\n        contour_var = \"count\",\n        show.legend = F) +                          \n  \n  # renk dağılımını belirle\n  scale_fill_gradient(low = \"black\", high = \"red\")+\n  \n  # etiketler \n  labs(x = \"Longitude\",\n       y = \"Latitude\",\n       title = \"Distribution of cumulative cases over time\")+\n  \n  # grafiği başlangıç ayı-yılına göre şekillendirin\n  facet_wrap(~ date_onset_ym, ncol = 4)",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Coğrafi Bilgi Sistemleri (CBS) Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.tr.html#mekansal-istatistikler",
    "href": "new_pages/gis.tr.html#mekansal-istatistikler",
    "title": "28  Coğrafi Bilgi Sistemleri (CBS) Temelleri",
    "section": "28.11 Mekansal istatistikler",
    "text": "28.11 Mekansal istatistikler\nŞimdiye kadarki tartışmalarımızın çoğu, mekansal verilerin görselleştirilmesine odaklandı. Bazı durumlarda, verilerinizdeki özniteliklerin uzamsal ilişkilerini ölçmek için mekansal istatistikler kullanmak da ilginizi çekebilir. Bu bölüm uzamsal istatistikteki bazı temel kavramlara çok kısa bir genel bakış sunacak ve daha kapsamlı uzamsal analizler yapmak istiyorsanız keşfetmenize yardımcı olacak bazı kaynaklar önerecektir.\n\nMekansal ilişkiler\nHerhangi bir uzamsal istatistiği hesaplamadan önce, verilerimizdeki özellikler arasındaki ilişkileri belirlememiz gerekir. Mekansal ilişkileri kavramsallaştırmanın birçok yolu vardır, ancak kullanımı basit ve yaygın olarak uygulanabilir bir model bitişiklik modelidir. Bu modelde, bir sınırı veya “komşuluğu” paylaşan alanlar arasında coğrafi bir ilişki beklemekteyiz.\nspdep paketi ile kullandığımız sle_adm3 datasında yönetim bölgesi poligonları arasındaki komşuluk ilişkilerini ölçebiliyoruz. vezir bitişikliğini belirleyeceğiz, bu, bölgelerin sınırları boyunca en az bir noktayı paylaştıkları takdirde komşu olacağı anlamına gelmektedir. Alternatif olarak, bölgelerin bir kenarı paylaşmasını gerektiren kale bitişikliği olacaktır - bizim durumumuzda, düzensiz çokgenlerle, ayrım önemsizdir, ancak bazı durumlarda vezir ve kale arasındaki seçim etkili olabilir.\n\nsle_nb &lt;- spdep::poly2nb(sle_adm3_dat, queen=T) # komşuluklar yaratın \nsle_adjmat &lt;- spdep::nb2mat(sle_nb)    # komşu ilişkilerini özetleyen matris oluşturun\nsle_listw &lt;- spdep::nb2listw(sle_nb)   # listw (ağırlık listesi) nesnesi oluştur -- buna daha sonra ihtiyacımız olacak\n\nsle_nb\n\nNeighbour list object:\nNumber of regions: 9 \nNumber of nonzero links: 30 \nPercentage nonzero weights: 37.03704 \nAverage number of links: 3.333333 \n\nround(sle_adjmat, digits = 2)\n\n  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n1 0.00 0.20 0.00 0.20 0.00  0.2 0.00 0.20 0.20\n2 0.25 0.00 0.00 0.25 0.25  0.0 0.00 0.25 0.00\n3 0.00 0.00 0.00 0.50 0.00  0.0 0.00 0.00 0.50\n4 0.25 0.25 0.25 0.00 0.00  0.0 0.00 0.00 0.25\n5 0.00 0.33 0.00 0.00 0.00  0.0 0.33 0.33 0.00\n6 0.50 0.00 0.00 0.00 0.00  0.0 0.00 0.50 0.00\n7 0.00 0.00 0.00 0.00 0.50  0.0 0.00 0.50 0.00\n8 0.20 0.20 0.00 0.00 0.20  0.2 0.20 0.00 0.00\n9 0.33 0.00 0.33 0.33 0.00  0.0 0.00 0.00 0.00\nattr(,\"call\")\nspdep::nb2mat(neighbours = sle_nb)\n\n\nYukarıda yazdırılan matris, ‘sle_adm3’ verilerimizdeki 9 bölge arasındaki ilişkileri göstermektedir. 0 puan, iki bölgenin komşu olmadığını gösterirken, 0 dışında herhangi bir değer, bir komşu ilişkisini gösterir. Matristeki değerler, her bölgenin toplam satır ağırlığı 1 olacak şekilde ölçeklendirilir.\nBu komşu ilişkileri görselleştirmenin daha iyi bir yolu, onları çizmektir:\n\nplot(sle_adm3_dat$geometry) +                                           # alan sınırlarını grafikleştir\n  spdep::plot.nb(sle_nb,as(sle_adm3_dat, 'Spatial'), col='grey', add=T) # komşuluk ilişkileri ekle\n\n\n\n\n\n\n\n\nKomşu çokgenleri tanımlamak için bir bitişiklik yaklaşımı kullandık; tanımladığımız komşulara bazen bitişiklik tabanlı komşular da denir. Ancak bu, coğrafi bir ilişkiye sahip olması beklenen bölgeleri seçmenin sadece bir yoludur. Coğrafi ilişkileri belirlemeye yönelik en yaygın alternatif yaklaşımı mesafeye dayalı komşular oluşturur; kısaca bunlar:\n\nK-en yakın komşular - Merkezler (her çokgen bölgesinin coğrafi ağırlıklı merkezi) arasındaki mesafeye bağlı olarak, komşu olarak n en yakın bölgeleri seçin. Bir maksimum mesafe yakınlık eşiği de belirtilebilir. spdep’te “knearneigh()” kullanabilirsiniz (bkz. belgeler).\nMesafe eşiği komşuları - Bir mesafe eşiği içindeki tüm komşuları seçin. spdep’te, bu komşu ilişkiler “dnearneigh()” kullanılarak tanımlanabilir (bkz. belgeler) .\n\n\n\nMekansal otokorelasyon\nTobler’in sık sık alıntılanan birinci coğrafya yasası, “her şey diğer her şeyle ilişkilidir, ancak yakın şeyler uzaktaki şeylerden daha fazla ilişkilidir” der. Epidemiyolojide bu genellikle, belirli bir bölgedeki belirli bir sağlık sonucu riskinin, uzaktaki bölgelere kıyasla komşu bölgelere daha benzer olduğu anlamına gelir. Bu kavram, uzaysal otokorelasyon olarak resmileştirilmiştir. Benzer değerlere sahip coğrafi özelliklerin uzayda bir araya toplandığı istatistiksel özellik olarak tanımlanır. Uzamsal otokorelasyonun istatistiksel ölçüleri, verilerinizdeki mekansal kümelemenin kapsamını ölçmek, kümelemenin nerede gerçekleştiğini belirlemek ve verilerinizdeki farklı değişkenler arasındaki paylaşılan uzamsal otokorelasyon modellerini belirlemek için kullanılabilir. Bu bölüm, bazı yaygın uzamsal otokorelasyon ölçülerine ve bunların R’da nasıl hesaplanacağına genel bir bakış sunar.\nMoran’ın İ İstatistiği - Bu, bir bölgedeki bir değişkenin değeri ile komşu bölgelerdeki aynı değişkenin değerleri arasındaki korelasyonun genel bir özet istatistiğidir. Moran’ın I istatistiği tipik olarak -1 ile 1 arasındadır. 0 değeri uzamsal korelasyon modeli olmadığını gösterirken 1 veya -1’e yakın değerler sırasıyla daha güçlü uzamsal otokorelasyonu (benzer değerler birbirine yakındır) veya uzamsal dağılımı (benzersiz değerler birbirine yakındır) gösterir.\nÖrnek olarak, daha önce haritalandırdığımız Ebola vakalarındaki uzamsal otokorelasyonu ölçmek için Moran’ın İ istatistiğini hesaplayacağız (unutmayın, bu simüle edilmiş salgın “satır listesi” veri çerçevesinden vakaların bir alt kümesidir). spdep paketinde bu hesaplamayı bizim için yapabilen “moran.test” fonskiyonu vardır:\n\nmoran_i &lt;-spdep::moran.test(sle_adm3_dat$cases,    # ilgilenilen değişken içim sayısal vektör\n                            listw=sle_listw)       # komşu ilişkilerini özetleyen listw nesnesi\n\nmoran_i                                            # yazdırma sonuçları\n\n\n    Moran I test under randomisation\n\ndata:  sle_adm3_dat$cases  \nweights: sle_listw    \n\nMoran I statistic standard deviate = 1.5337, p-value = 0.06255\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n       0.19941217       -0.12500000        0.04474276 \n\n\n‘moran.test()’ fonksiyonunun çıktısı bize ‘round(moran_i$estimate[1],2)’ Moran I istatistiğini gösterir. Bu, verilerimizde uzamsal otokorelasyonun varlığını gösterir - özellikle, benzer sayıda Ebola vakası olan bölgelerin birbirine yakın olması muhtemeldir. “moran.test()” tarafından sağlanan p değeri, uzaysal otokorelasyonun olmadığı sıfır hipotezi altındaki beklentiyle karşılaştırılarak oluşturulur ve resmi bir hipotez testinin sonuçlarını bildirmeniz gerekiyorsa kullanılabilir.\nYerel Moran I - yerelleştirilmiş uzamsal otokorelasyonu tanımlamak için yukarıda hesaplanan (küresel) Moran I istatistiğini ayrıştırabiliriz; bu durum verilerimizdeki belirli kümeleri tanımlamamızı sağlar. Bazen Yerel Mekansal İlişki Göstergesi (LISA) istatistiği olarak adlandırılan bu istatistik, her bir bölge etrafındaki mekansal otokorelasyonun kapsamını özetler. Haritada “sıcak” ve “soğuk” noktaları bulmak için faydalı olabilir.\nBir örnek göstermek için, yukarıda kullanılan Ebola vaka sayıları için Yerel Moran’ın I istatistiğini spdep’ten local_moran() fonksiyonuyla hesaplayabilir ve eşleyebiliriz:\n\n# yereli hesapla\nlocal_moran &lt;- spdep::localmoran(                  \n  sle_adm3_dat$cases,                              # ilgi değişkeni\n  listw=sle_listw                                  # komşu ağırlıkları ile listw nesnesi\n)\n\n# sf verilerine sonuçları birleştirme\nsle_adm3_dat&lt;- cbind(sle_adm3_dat, local_moran)    \n\n# harita grafiği\nggplot(data=sle_adm3_dat) +\n  geom_sf(aes(fill=Ii)) +\n  theme_bw() +\n  scale_fill_gradient2(low=\"#2c7bb6\", mid=\"#ffffbf\", high=\"#d7191c\",\n                       name=\"Local Moran's I\") +\n  labs(title=\"Local Moran's I statistic for Ebola cases\",\n       subtitle=\"Admin level 3 regions, Sierra Leone\")\n\n\n\n\n\n\n\n\n**Getis-Ord Gi** - Bu, etkin nokta analizi için yaygın olarak kullanılan başka bir istatistiktir. Bu istatistiğin popülaritesi büyük ölçüde ArcGIS’teki Sıcak Nokta Analizi aracındaki kullanımıyla ilgilidir. Tipik olarak, komşu bölgeler arasındaki bir değişkenin değerindeki farkın normal bir dağılım izlemesi gerektiği varsayımına dayanır. Komşularına kıyasla, belirli bir değişkenin önemli ölçüde daha yüksek (sıcak nokta) veya önemli ölçüde daha düşük (soğuk nokta) değerlerine sahip bölgeleri belirlemek için bir z-skoru yaklaşımı kullanır.\nspdep’teki localG() fonksiyonunu kullanarak Gi istatistiğini hesaplayabilir ve eşleyebiliriz:\n\n# Yerel G analizi gerçekleştir\ngetis_ord &lt;- spdep::localG(\n  sle_adm3_dat$cases,\n  sle_listw\n)\n\n# sf verisine sonuçları ekleme\nsle_adm3_dat$getis_ord &lt;- as.numeric(getis_ord)\n\n# harita grafiği\nggplot(data=sle_adm3_dat) +\n  geom_sf(aes(fill=getis_ord)) +\n  theme_bw() +\n  scale_fill_gradient2(low=\"#2c7bb6\", mid=\"#ffffbf\", high=\"#d7191c\",\n                       name=\"Gi*\") +\n  labs(title=\"Getis-Ord Gi* statistic for Ebola cases\",\n       subtitle=\"Admin level 3 regions, Sierra Leone\")\n\n\n\n\n\n\n\n\nGördüğünüz gibi Getis-Ord Gi haritası daha önce hazırladığımız Yerel Moran’ın İ haritasından biraz farklı görünüyor. Bu, iki istatistiği hesaplamak için kullanılan yöntemin biraz farklı olduğunu yansıtır; hangisini kullanmanız gerektiği, özel kullanım durumunuza ve ilgilendiğiniz araştırma sorusuna bağlıdır.\nLee’s L testi - İki değişkenli uzamsal korelasyon için istatistiksel bir testtir. Belirli bir x değişkeni için uzamsal kalıbın, uzamsal olarak x ile ilişkili olduğu varsayılan başka bir değişken olan y’nin uzamsal kalıbına benzer olup olmadığını test etmenizi sağlar.\nBir örnek vermek gerekirse, simüle edilmiş salgındaki Ebola vakalarının mekansal düzeninin, nüfusun mekansal düzeniyle ilişkili olup olmadığını test edelim. Başlamak için, ‘sle_adm3’ verilerimizde bir ‘population’ değişkenine ihtiyacımız var. Daha önce yüklediğimiz ‘sle_adm3_pop’ veri çerçevesinden ‘total’ değişkenini kullanabiliriz.\n\nsle_adm3_dat &lt;- sle_adm3_dat %&gt;% \n  rename(population = total)                          # toplamı nüfus olarak yeniden adlandır\n\nBenzer görünüp görünmediklerini görmek için iki değişkenin uzamsal modellerini yan yana hızlı bir şekilde görselleştirebiliriz:\n\ntmap_mode(\"plot\")\n\ncases_map &lt;- tm_shape(sle_adm3_dat) + tm_polygons(\"cases\") + tm_layout(main.title=\"Cases\")\npop_map &lt;- tm_shape(sle_adm3_dat) + tm_polygons(\"population\") + tm_layout(main.title=\"Population\")\n\ntmap_arrange(cases_map, pop_map, ncol=2)   # 2x1 yönlerine göre düzenleyin\n\n\n\n\n\n\n\n\nGörsel olarak, desenler farklı görünüyor. İki değişkendeki uzamsal otokorelasyon modelinin ilişkili olup olmadığını istatistiksel olarak test etmek için spdep içindeki lee.test() fonksiyonunu kullanabiliriz. Modeller arasında korelasyon yoksa L istatistiği 0’a yakın, güçlü bir pozitif korelasyon varsa 1’e yakın (yani modeller benzer) ve güçlü bir negatif korelasyon varsa -1’e yakındır (örn. desenler terstir).\n\nlee_test &lt;- spdep::lee.test(\n  x=sle_adm3_dat$cases,          # karşılaştırılacak değişken 1\n  y=sle_adm3_dat$population,     # karşılaştırılacak değişken 2\n  listw=sle_listw                # komşu ağırlıkları ile listw nesnesi\n)\n\nlee_test\n\n\n    Lee's L statistic randomisation\n\ndata:  sle_adm3_dat$cases ,  sle_adm3_dat$population \nweights: sle_listw  \n\nLee's L statistic standard deviate = -1.0393, p-value = 0.8507\nalternative hypothesis: greater\nsample estimates:\nLee's L statistic       Expectation          Variance \n      -0.15930426       -0.04384940        0.01234084 \n\n\nYukarıdaki çıktı, iki değişkenimiz için Lee’nin L istatistiğinin, zayıf negatif korelasyonu gösteren `round(lee_test$estimate[1],2)’ olduğunu göstermektedir. Vaka ve nüfus düzeninin birbiriyle ilişkili olmadığına dair görsel değerlendirmemizi doğrular ve vakaların mekânsal düzeninin kesinlikle yüksek riskli bölgelerdeki nüfus yoğunluğunun bir sonucu olmadığına dair kanıt sağlar.\nLee L istatistiği, uzamsal olarak dağılmış değişkenler arasındaki ilişki hakkında bu tür çıkarımlar yapmak için faydalı olabilir; ancak, iki değişken arasındaki ilişkinin doğasını daha ayrıntılı olarak tanımlamak veya kafa karıştırıcı duruma göre ayarlamak için uzaysal regresyon tekniklerine ihtiyaç duyulacaktır. Bunlar aşağıdaki bölümde kısaca açıklanmıştır.\n\n\nMekansal regresyon\nUzamsal verilerinizdeki değişkenler arasındaki ilişkiler hakkında istatistiksel çıkarımlar yapmak isteyebilirsiniz. Bu durumlarda, uzaysal regresyon tekniklerini, yani verilerinizdeki birimlerin uzamsal organizasyonunu açıkça dikkate alan regresyon yaklaşımlarını anlamak yararlıdır. Genel Lineer Modeller (GLM) gibi standart regresyon modelleri yerine uzamsal regresyon modellerini dikkate almanız gerekebilecek bazı nedenler şunlardır:\n\nStandart regresyon modelleri, artıkların birbirinden bağımsız olduğunu varsayar. Güçlü bir uzaysal otokorelasyon varlığında, standart bir regresyon modelinin artıklarının da uzaysal olarak otokorelasyona sahip olması muhtemeldir, dolayısıyla bu varsayımı ihlal eder. Bu, model sonuçlarının yorumlanmasında sorunlara yol açabilir, bu durumda uzamsal bir model tercih edilir.\nRegresyon modelleri ayrıca tipik olarak x değişkeninin etkisinin tüm gözlemlerde sabit olduğunu varsayar. Mekansal heterojenlik durumunda, tahmin etmek istediğimiz etkiler uzaya göre değişebilir ve bu farklılıkları ölçmekle ilgilenebiliriz. Bu durumda, uzamsal regresyon modelleri, etkileri tahmin etmek ve yorumlamak için daha fazla esneklik sunar.\n\nMekansal regresyon yaklaşımlarının ayrıntıları bu el kitabının kapsamı dışındadır. Bu bölüm bunun yerine en yaygın uzamsal regresyon modellerine ve kullanımlarına genel bir bakış sunacak ve bu alanı daha fazla araştırmak isterseniz kullanılabilecek referanslara yönlendirecektir.\nUzamsal hata modelleri - Bu modeller, uzamsal birimler arasındaki hata terimlerinin ilişkili olduğunu varsayar; bu durumda veriler, standart bir “Ordinary Least Squares (OLS)” modelinin varsayımlarını ihlal eder. Uzamsal hata modellerine bazen eşzamanlı otoregresif (SAR) modeller de denir. spatialreg paketindeki ‘errorsarlm()’ fonksiyonu kullanılarak sığdırılabilirler (eskiden spdep’in bir parçası olan uzamsal regresyon fonksiyonları).\nUzamsal gecikme modelleri - Bu modeller, i bölgesi için bağımlı değişkenin yalnızca i içindeki bağımsız değişkenlerin değerinden değil, aynı zamanda i’ye komşu bölgelerdeki bu değişkenlerin değerlerinden de etkilendiğini varsayar. Uzamsal hata modelleri gibi, uzaysal gecikme modelleri de bazen eşzamanlı otoregresif (SAR) modeller olarak tanımlanır. spatialreg paketindeki lagsarlm() fonskiyonu kullanılarak sığdırılabilirler.\nspdep paketi, standart OLS, uzamsal gecikme ve uzamsal hata modelleri arasında karar vermek için birkaç faydalı tanı testi içerir. Lagrange Çarpanı teşhisleri olarak adlandırılan bu testler, verilerinizdeki uzamsal bağımlılığın türünü belirlemek ve hangi modelin en uygun olduğunu seçmek için kullanılabilir. lm.LMtests() fonksiyonu, tüm Lagrange Çarpan testlerini hesaplamak için kullanılabilir. Anselin (1988) ayrıca Lagrange Çarpan testlerinin sonuçlarına dayanarak hangi uzaysal regresyon modelinin kullanılacağına karar vermek için kullanışlı bir akış şeması aracı sağlar:\n\n\n\n\n\n\n\n\n\nBayesin hiyerarşik modelleri - Bayes yaklaşımları, uzaysal analizdeki bazı uygulamalar için yaygın olarak kullanılır, en yaygın olarak hastalık haritalama. Vaka verilerinin seyrek olarak dağıtıldığı (örneğin, nadir bir sonuç durumunda) veya istatistiksel olarak “gürültülü” olduğu durumlarda tercih edilirler, çünkü altta yatan gizli mekansal verileri hesaba katarak hastalık riskinin “düzeltilmiş” tahminlerini oluşturmak için kullanılabilirler. Bu, tahminlerin kalitesini artırabilir. Bunlar ayrıca, hem bağımsız hem de bağımlı değişkenlerde uzamsal olarak bağımlı ve bağımsız varyasyonu açıklayabilen, verilerde bulunabilen karmaşık uzamsal korelasyon modellerinin araştırmacı tarafından önceden belirlenmesine (önceki seçim yoluyla) izin verir. R’da, Bayesin hiyerarşik modelleri CARbayes paketi kullanılarak sığdırılabilir (bkz. gösterim) veya R -INLA (bkz. web sitesi ve ders kitabı). R ayrıca JAGS veya WinBUGS gibi Bayes tahmini yapan harici yazılımları çağırmak için de kullanılabilir.",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Coğrafi Bilgi Sistemleri (CBS) Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.tr.html#kaynaklar",
    "href": "new_pages/gis.tr.html#kaynaklar",
    "title": "28  Coğrafi Bilgi Sistemleri (CBS) Temelleri",
    "section": "28.12 Kaynaklar",
    "text": "28.12 Kaynaklar\n\nR’ın Basit Özellikleri ve sf paketi gösterim\nR tmap paketi gösterim\nggmap: ggplot2 ile Mekansal Görselleştirme\nR ile harita oluşturmaya giriş, farklı paketlere genel bakış\nR’da Mekansal Veriler (EarthLab kursu)\nR’da Uygulamalı Uzamsal Veri Analizi ders kitabı\nSpatialEpiApp - R paketi olarak indirilebilen bir Shiny uygulaması, kendi verilerinizi sağlamanıza ve haritalama, küme analizi ve mekansal istatistikleri sağlar.\nR’da Mekansal Ekonometriye Giriş atölye",
    "crumbs": [
      "Analiz",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Coğrafi Bilgi Sistemleri (CBS) Temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.tr.html",
    "href": "new_pages/tables_presentation.tr.html",
    "title": "29  Sunum için tablolar",
    "section": "",
    "text": "29.1 Hazırlık",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Sunum için tablolar</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.tr.html#hazırlık",
    "href": "new_pages/tables_presentation.tr.html#hazırlık",
    "title": "29  Sunum için tablolar",
    "section": "",
    "text": "Paketleri yükleme\nflextable’ı kurun ve yükleyin. Bu el kitabında, paketi kuran ve kullanım için yükleyen pacman’dan p_load() kullanacağız. R tabanından library() içeren paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakabilirsiniz.\n\npacman::p_load(\n  rio,            # içe/dışa aktar\n  here,           # dosya yolağı\n  flextable,      # HTML tablosu oluştur \n  officer,        # tablolar için yardımcı fonksiyonlar\n  tidyverse)      # veri yönetimi, özetlemesi ve görselleştirilmesi\n\n\n\nVerileri içe aktarma\nBaşlamak için, simüle edilmiş bir Ebola salgınından temizlenmiş vaka listesini içe aktarıyoruz. Takip etmek isterseniz, “temiz satır listesi” dosyasını indirmek için tıklayın. (.rds dosyası olarak). rio paketinden import() fonksiyonuyla verileri içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakın).\n\n# satır listesini içe aktar\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nÇizgi listesinin ilk 50 satırı aşağıda görüntülenmektedir:\n\n\n\n\n\n\n\n\nTabloyu hazırlama\nflextable kullanmaya başlamadan önce tablonuzu veri çerçevesine dönüştürmeniz gerekecektir. janitor ve dplyr gibi paketleri kullanarak bir veri çerçevesinin nasıl oluşturulacağını öğrenmek için [Tanımlayıcı tablolar] ve [Veri pivotlama] sayfalarına bakabilirsiniz. İçeriği, görüntülenmesini istediğiniz gibi satırlar ve sütunlar halinde düzenlemelisiniz. Ardından, veri çerçevesinin rengi, başlığı, yazı tipleri vb. ile görüntülemek için flextable’e geçirilecektir.\nAşağıda, [Tanımlayıcı tablolar] sayfasından, vaka satır listesi örnek olarak kullanılmıştır. Hazırlanan tabloda toplamlar satırı ile hastaneye göre hasta sonuçları ve CT değerlerini özetlenmiştir.\n\ntable &lt;- linelist %&gt;% \n  \n  # Hastane sonuç grubu başına özet değerleri al\n  ###############################################\n  group_by(hospital, outcome) %&gt;%                      # Grup verisi\n  summarise(                                           # İlgilenilen göstergelerin yeni özet sütunları oluştur\n    N = n(),                                            # Hastane-sonuç grubu başına satır sayısı   \n    ct_value = median(ct_blood, na.rm=T)) %&gt;%           # Grup başına medyan CT değeri\n  \n  # Toplamları ekle\n  ############\n  bind_rows(                                           # Önceki tabloyu mini toplamlar tablosuyla birleştir\n    linelist %&gt;% \n      filter(!is.na(outcome) & hospital != \"Missing\") %&gt;%\n      group_by(outcome) %&gt;%                            # Hastaneye göre değil, yalnızca sonuca göre gruplandır  \n      summarise(\n        N = n(),                                       # Tüm veri kümesi için satır sayısı    \n        ct_value = median(ct_blood, na.rm=T))) %&gt;%     # Tüm veri seti için medyan CT değeri\n  \n  # Geniş pivotlama ve format\n  ########################\n  mutate(hospital = replace_na(hospital, \"Total\")) %&gt;% \n  pivot_wider(                                         # uzundan genişe pivotla\n    values_from = c(ct_value, N),                       # yeni değerler ct ve count sütunlarından alınır\n    names_from = outcome) %&gt;%                           # yeni sütun adları sonuçlardan alınır\n  mutate(                                              # yeni sütun ekle\n    N_Known = N_Death + N_Recover,                               # sonucu bilinen sayı\n    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # ölen vakaların yüzdesi (1 ondalık basamağa kadar)\n    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %&gt;% # iyileşen vakaların yüzdesi (1 ondalık basamağa kadar)\n  select(                                              # Sütunları yeniden sırala\n    hospital, N_Known,                                   # Giriş sütunları\n    N_Recover, Pct_Recover, ct_value_Recover,            # İyileşen vaka sütunları\n    N_Death, Pct_Death, ct_value_Death)  %&gt;%             # Ölen vaka sütunları\n  arrange(N_Known)                                     # Satırları en düşükten en yükseğe doğru düzenle (Toplam satırı en altta)\n\ntable  # yazdır\n\n# A tibble: 7 × 8\n# Groups:   hospital [7]\n  hospital      N_Known N_Recover Pct_Recover ct_value_Recover N_Death Pct_Death\n  &lt;chr&gt;           &lt;int&gt;     &lt;int&gt; &lt;chr&gt;                  &lt;dbl&gt;   &lt;int&gt; &lt;chr&gt;    \n1 St. Mark's M…     325       126 38.8%                     22     199 61.2%    \n2 Central Hosp…     358       165 46.1%                     22     193 53.9%    \n3 Other             685       290 42.3%                     21     395 57.7%    \n4 Military Hos…     708       309 43.6%                     22     399 56.4%    \n5 Missing          1125       514 45.7%                     21     611 54.3%    \n6 Port Hospital    1364       579 42.4%                     21     785 57.6%    \n7 Total            3440      1469 42.7%                     22    1971 57.3%    \n# ℹ 1 more variable: ct_value_Death &lt;dbl&gt;",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Sunum için tablolar</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.tr.html#temel-flextable",
    "href": "new_pages/tables_presentation.tr.html#temel-flextable",
    "title": "29  Sunum için tablolar",
    "section": "29.2 Temel flextable",
    "text": "29.2 Temel flextable\n\nFlextable oluşturma\nflextable nesnelerini oluşturmak ve yönetmek için, önce veri çerçevesini flextable() fonksiyonundan geçirilir. Sonuç my_table olarak kaydedilir.\n\nmy_table &lt;- flextable(table) \nmy_table\n\nhospitalN_KnownN_RecoverPct_Recoverct_value_RecoverN_DeathPct_Deathct_value_DeathSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\nBu yapıldıktan sonra, daha fazla flextable biçimlendirme fonksiyonları aracılığıyla my_table nesnesi aşamalı olarak yönlendirilebilir.\nBu sayfada, anlaşılır olması için ara adımlarda tablo my_table olarak kaydedilecek ve flextable fonksiyonları bit-bit eklenecektir. Kodun başından sonuna kadar tümünü tek bir yığın halinde yazılmış olarak görmek isterseniz, aşağıdaki Bütün kodlar bölümünü ziyaret edebilirsiniz.\nflextable koduna ait her bir satırının genel sözdizimi aşağıdaki gibidir:\n\nfunction(table, i = X, j = X, part = \"X\"), burada:\n\nfunction, sütun genişliklerini belirlemek için width(), arka plan renklerini ayarlamak için bg(), metnin merkeze/sağa/sola hizalı olup olmadığını ayarlamak için align() gibi birçok farklı fonksiyondan biri olabilir.\ntable = veri çerçevesinin adıdır, ancak veri çerçevesi fonksiyona aktarılıyorsa belirtilmesine gerek yoktur.\npart = fonksiyonun tablonun hangi bölümüne uygulandığını belirtir. Örneğin. “başlık”, “gövde” veya “tümü”.\ni = fonksiyonun uygulanacağı satırı belirtir, burada X satır numarasıdır. Birden fazla satır varsa, ör. birinci ila üçüncü satırlar arasında şu şekilde yazılabilir: i = c(1:3). ‘Gövde’ seçiliyse, ilk satırın başlık bölümünün altından başladığını unutmayın.\nj = fonksiyonun uygulanacağı sütununu belirtir, burada X sütun numarası veya adıdır. Birden çok sütun varsa, ör. beşinci ve altıncı, şu şekilde yazılabilir: j = c(5,6).\n\n\nflextable biçimlendirme fonksiyonlarına ait tam listeyi burada bulabilir veya ?flextable komutunu girerek belgeleri inceleyebilirsiniz.\n\n\nSütun genişliği\nHer hücrede yalnızca bir metin satırı olacak şekilde tabloyu güzelce genişleten autofit() fonksiyonunu kullanabiliriz. qflextable() fonksiyonu, flextable() ve autofit() için uygun bir kısayoldur.\n\nmy_table %&gt;% autofit()\n\nhospitalN_KnownN_RecoverPct_Recoverct_value_RecoverN_DeathPct_Deathct_value_DeathSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\nAncak, özellikle hücreler içinde çok uzun değerler varsa, bu fonksiyon her zaman uygun olmayabilir, tablo sayfaya sığmayabilir.\nBunun yerine genişlikleri width() fonksiyonu ile belirtebilir. Hangi genişlik değerini koyacağınızı bilmek biraz zaman alabilir. Aşağıdaki örnekte, sütun 1, 2, 4 ve 8 için farklı genişlikler belirlenmiştir.\n\nmy_table &lt;- my_table %&gt;% \n  width(j=1, width = 2.7) %&gt;% \n  width(j=2, width = 1.5) %&gt;% \n  width(j=c(4,5,7,8), width = 1)\n\nmy_table\n\nhospitalN_KnownN_RecoverPct_Recoverct_value_RecoverN_DeathPct_Deathct_value_DeathSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\n\n\nSütun başlıkları\nTablo içeriklerinin daha kolay yorumlanması için daha net başlıklar istenir.\nBu tablo için, aynı alt grupları kapsayan sütunların birlikte gruplanabilmesi için ikinci bir başlık katmanı eklemek istiyoruz. Bu top = TRUE argümanı ve add_header_row() fonksiyonu ile yapılmaktadır. Daha sonra birleştirilecek sütunlar için \"\" boş değer bırakılarak, her sütunun yeni adı values = argümanıyla verilmektedir.\nİkinci başlıktaki başlık adları ayrı bir set_header_labels() komutuyla yeniden adlandırılır.\nSon olarak, üst başlıktaki belirli sütun başlıklarını “birleştirmek” için, merge_at() fonksiyonu kullanılır.\n\nmy_table &lt;- my_table %&gt;% \n  \n  add_header_row(\n    top = TRUE,                # Yeni başlık, mevcut başlık satırının üstüne eklenir\n    values = c(\"Hospital\",     # Aşağıdaki her sütun için başlık değerleri\n               \"Total cases with known outcome\", \n               \"Recovered\",    # Bu, bunun ve sonraki iki sütunun en üst düzey başlığı olacak\n               \"\",\n               \"\",\n               \"Died\",         # Bu, bunun ve sonraki iki sütunun en üst düzey başlığı olacak\n               \"\",             # \"Öldü\" ile birleştirileceği için boş bırak\n               \"\")) %&gt;% \n    \n  set_header_labels(         # Orijinal başlık satırındaki sütunları yeniden adlandır\n      hospital = \"\", \n      N_Known = \"\",                  \n      N_Recover = \"Total\",\n      Pct_Recover = \"% of cases\",\n      ct_value_Recover = \"Median CT values\",\n      N_Death = \"Total\",\n      Pct_Death = \"% of cases\",\n      ct_value_Death = \"Median CT values\")  %&gt;% \n  \n  merge_at(i = 1, j = 3:5, part = \"header\") %&gt;% # Yeni başlık satırında 3 ile 5 arasındaki sütunları yatay olarak birleştir\n  merge_at(i = 1, j = 6:8, part = \"header\")     # HYeni başlık satırında 6 ile 8 arasındaki sütunları yatay olarak birleştir\n\nmy_table  # print\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\n\n\nKenarlıklar ve arka plan\nÇeşitli flextable fonksiyonlarıyla kenarlıkları, iç çizgileri vb. ayarlayabilirsiniz. border_remove() ile mevcut tüm sınırları kaldırarak başlamak genellikle daha kolaydır.\nArdından, tabloyu theme_box(), theme_booktabs() veya theme_alafoli() öğelerine geçirerek varsayılan kenarlık temalarını uygulayabilirsiniz.\nÇeşitli fonksiyonlara dikey ve yatay çizgiler ekleyebilirsiniz. hline() ve vline() sırasıyla belirli bir satıra veya sütuna satır ekler. Her birinin içinde “part =” öğesini “tümü”, “gövde” veya “başlık” olarak belirtmelisiniz. Dikey çizgiler için sütunu j = ve yatay çizgiler için satırı i = olarak belirtmelisiniz. vline_right(), vline_left(), hline_top() ve hline_bottom() gibi diğer işlevler yalnızca dış taraflara satır ekler.\nTüm bu fonksiyonlarda, çizgi stili border = olarak belirtilmelidir ayrıca officer paketinden fp_border() fonksiyonunu kullanan ayrı bir komutun çıktısı şeklinde olmalıdır. Bu fonksiyon, çizginin genişliğini ve rengini tanımlamanıza yardımcı olur. Bunu aşağıda gösterildiği gibi tablo komutlarının üzerinde tanımlayabilirsiniz.\n\n# sınır çizgisi için stil tanımla\nborder_style = officer::fp_border(color=\"black\", width=1)\n\n# tabloya sınır çizgileri ekle\nmy_table &lt;- my_table %&gt;% \n\n  # Mevcut tüm sınırları kaldır\n  border_remove() %&gt;%  \n  \n  # önceden belirlenmiş bir tema ayarıyla yatay çizgiler ekle\n  theme_booktabs() %&gt;% \n  \n  # İyileşen ve Ölen bölümleri ayırmak için dikey çizgiler ekleyin\n  vline(part = \"all\", j = 2, border = border_style) %&gt;%   # sütun 2'de \n  vline(part = \"all\", j = 5, border = border_style)       # sütun 5'de\n\nmy_table\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\n\n\nYazı tipi ve hizalama\nflextable’daki align() fonksiyonunu kullanarak en soldaki sütun dışındaki tüm sütunlar hastane adlarıyla ortalayarak hizalanabilir.\n\nmy_table &lt;- my_table %&gt;% \n   flextable::align(align = \"center\", j = c(2:8), part = \"all\") \nmy_table\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\nEk olarak, başlık yazı tipi boyutunu artırabilir ve ardından kalın olarak değiştirebilir. Toplam satırı da kalın olarak değiştirebilir.\n\nmy_table &lt;-  my_table %&gt;%  \n  fontsize(i = 1, size = 12, part = \"header\") %&gt;%   # başlığın font büyüklüğünü değiştir\n  bold(i = 1, bold = TRUE, part = \"header\") %&gt;%     # başlığın kalınlığını ayarla\n  bold(i = 7, bold = TRUE, part = \"body\")           # toplam satırın kalınlığını ayarla (gövdenin 7. satırı)\n\nmy_table\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\ncolformat_num() fonksiyonunu kullanarak orantı sütunlarının yalnızca bir ondalık basamak göstermesi sağlanabilir. Bunun, round() fonksiyonuyla veri yönetimi aşamasında da yapılabileceğini unutmayın.\n\nmy_table &lt;- colformat_num(my_table, j = c(4,7), digits = 1)\nmy_table\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\n\n\nHücreleri birleştirme\nBaşlık satırındaki hücreler yatay olarak birleştirilebileciği gibi, merge_at() kullanılarak ve satırları (i) ve sütunu (j) belirtilerek hücreler dikey olarak da birleştirebilir. Burada daha fazla yer açmak için “Hastane” ve “Sonucu bilinen toplam vaka” değerleri dikey olarak birleştirilmektedir.\n\nmy_table &lt;- my_table %&gt;% \n  merge_at(i = 1:2, j = 1, part = \"header\") %&gt;% \n  merge_at(i = 1:2, j = 2, part = \"header\")\n\nmy_table\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\n\n\nArka plan rengi\nTablonun içeriğini başlıklardan ayırt etmek için ek biçimlendirme eklemek istenebilir. Örneğin, arka plan rengini değiştirme. Bu örnekte tablo gövdesini gri olarak değiştirmekteyiz.\n\nmy_table &lt;- my_table %&gt;% \n    bg(part = \"body\", bg = \"gray95\")  \n\nmy_table \n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Sunum için tablolar</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.tr.html#koşullu-biçimlendirme",
    "href": "new_pages/tables_presentation.tr.html#koşullu-biçimlendirme",
    "title": "29  Sunum için tablolar",
    "section": "29.3 Koşullu biçimlendirme",
    "text": "29.3 Koşullu biçimlendirme\nBelirli bir kuralı karşılayan bir sütundaki tüm değerler vurgulanabilir. Örneğin, vakaların %55’inden fazlasının öldüğü yer. Ölçütleri i = veya j = argümanına, önünde bir tilde ~ gelecek şekilde koyulması yeterlidir. Değerler görüntülenen başlığa değil, veri çerçevesindeki sütununa refere edilmelidir.\n\nmy_table %&gt;% \n  bg(j = 7, i = ~ Pct_Death &gt;= 55, part = \"body\", bg = \"red\") \n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\nVeya, ilgilenilen bir hastane gibi belirli bir kriteri karşılayan tüm satır vurgulanabilir. Ölçütlerin tüm sütunlara uygulanabilmesi için sütun (j) argümanının kaldırılması yeterlidir.\n\nmy_table %&gt;% \n  bg(., i= ~ hospital == \"Military Hospital\", part = \"body\", bg = \"#91c293\") \n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Sunum için tablolar</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.tr.html#tbl_pres_all",
    "href": "new_pages/tables_presentation.tr.html#tbl_pres_all",
    "title": "29  Sunum için tablolar",
    "section": "29.4 Bütün kodlar",
    "text": "29.4 Bütün kodlar\nAşağıda, yukarıdaki bölümlerdeki bahsi geçen bütün kodlar paylaşılmaktadır.\n\nborder_style = officer::fp_border(color=\"black\", width=1)\n\npacman::p_load(\n  rio,            # içe/dışa aktar\n  here,           # dosya yolağı\n  flextable,      # HTML tablosu oluştur \n  officer,        # tablolar için yardımcı fonksiyonlar\n  tidyverse)      # veri yönetimi, özetlemesi ve görselleştirilmesi\n\ntable &lt;- linelist %&gt;% \n\n  # Hastane sonuç grubu başına özet değerleri al\n  ###############################################\n  group_by(hospital, outcome) %&gt;%                      # Grup verisi\n  summarise(                                           # İlgilenilen göstergelerin yeni özet sütunları oluştur\n    N = n(),                                            # Hastane-sonuç grubu başına satır sayısı   \n    ct_value = median(ct_blood, na.rm=T)) %&gt;%           # Grup başına medyan CT değeri\n  \n  # Toplamları ekle\n  ############\n  bind_rows(                                           # Önceki tabloyu mini toplamlar tablosuyla birleştir\n    linelist %&gt;% \n      filter(!is.na(outcome) & hospital != \"Missing\") %&gt;%\n      group_by(outcome) %&gt;%                            # Hastaneye göre değil, yalnızca sonuca göre gruplandır  \n      summarise(\n        N = n(),                                       # Tüm veri kümesi için satır sayısı    \n        ct_value = median(ct_blood, na.rm=T))) %&gt;%     # Tüm veri seti için medyan CT değeri\n  \n  # Geniş pivotlama ve format\n  ########################\n  mutate(hospital = replace_na(hospital, \"Total\")) %&gt;% \n  pivot_wider(                                         # uzundan genişe pivotla\n    values_from = c(ct_value, N),                       # yeni değerler ct ve count sütunlarından alınır\n    names_from = outcome) %&gt;%                           # yeni sütun adları sonuçlardan alınır\n  mutate(                                              # yeni sütun ekle\n    N_Known = N_Death + N_Recover,                               # sonucu bilinen satırların sayısı\n    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # ölen vakaların yüzdesi (1 ondalık basamağa kadar)\n    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %&gt;% # iyileşen vakaların yüzdesi (1 ondalık basamağa kadar)\n  select(                                              # Sütunları yeniden sırala\n    hospital, N_Known,                                   # Giriş sütunları\n    N_Recover, Pct_Recover, ct_value_Recover,            # İyileşen vaka sütunları\n    N_Death, Pct_Death, ct_value_Death)  %&gt;%             # Ölen vaka sütunları\n  arrange(N_Known) %&gt;%                                 # Satırları en düşükten en yükseğe doğru düzenle (Toplam satırı en altta)\n\n  # formatlama\n  ############\n  flextable() %&gt;%              # tablo yukarıdan aktarılır\n  add_header_row(\n    top = TRUE,                # Yeni başlık, mevcut başlık satırının üstüne eklenir\n    values = c(\"Hospital\",     # Aşağıdaki her sütun için başlık değerleri\n               \"Total cases with known outcome\", \n               \"Recovered\",    # Bu, bunun ve sonraki iki sütunun en üst düzey başlığı olacak\n               \"\",\n               \"\",\n               \"Died\",         # Bu, bunun ve sonraki iki sütunun en üst düzey başlığı olacak\n               \"\",             # \"Öldü\" ile birleştirileceği için boş bırak\n               \"\")) %&gt;% \n    set_header_labels(         # Orijinal başlık satırındaki sütunları yeniden adlandır\n      hospital = \"\", \n      N_Known = \"\",                  \n      N_Recover = \"Total\",\n      Pct_Recover = \"% of cases\",\n      ct_value_Recover = \"Median CT values\",\n      N_Death = \"Total\",\n      Pct_Death = \"% of cases\",\n      ct_value_Death = \"Median CT values\")  %&gt;% \n  merge_at(i = 1, j = 3:5, part = \"header\") %&gt;% # Yeni başlık satırında 3 ile 5 arasındaki sütunları yatay olarak birleştir\n  merge_at(i = 1, j = 6:8, part = \"header\") %&gt;%  \n  border_remove() %&gt;%  \n  theme_booktabs() %&gt;% \n  vline(part = \"all\", j = 2, border = border_style) %&gt;%   # at column 2 \n  vline(part = \"all\", j = 5, border = border_style) %&gt;%   # at column 5\n  merge_at(i = 1:2, j = 1, part = \"header\") %&gt;% \n  merge_at(i = 1:2, j = 2, part = \"header\") %&gt;% \n  width(j=1, width = 2.7) %&gt;% \n  width(j=2, width = 1.5) %&gt;% \n  width(j=c(4,5,7,8), width = 1) %&gt;% \n  flextable::align(., align = \"center\", j = c(2:8), part = \"all\") %&gt;% \n  bg(., part = \"body\", bg = \"gray95\")  %&gt;% \n  bg(., j=c(1:8), i= ~ hospital == \"Military Hospital\", part = \"body\", bg = \"#91c293\") %&gt;% \n  colformat_num(., j = c(4,7), digits = 1) %&gt;%\n  bold(i = 1, bold = TRUE, part = \"header\") %&gt;% \n  bold(i = 7, bold = TRUE, part = \"body\")\n\n`summarise()` has grouped output by 'hospital'. You can override using the\n`.groups` argument.\n\ntable\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Sunum için tablolar</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.tr.html#tablonun-kaydedilmesi",
    "href": "new_pages/tables_presentation.tr.html#tablonun-kaydedilmesi",
    "title": "29  Sunum için tablolar",
    "section": "29.5 Tablonun kaydedilmesi",
    "text": "29.5 Tablonun kaydedilmesi\nTablonun nihai çıktınıza entegre edilmesinin farklı yolları vardır.\n\nTek bir tablonun kaydedilmesi\nTabloları Word, PowerPoint, HTML veya görüntü (PNG) dosyaları olarak dışa aktarabilirsiniz. Bunu yapmak için aşağıdaki fonksiyonlardan uygun olanı kullanın:\n\nsave_as_docx()\n\nsave_as_pptx()\n\nsave_as_image()\n\nsave_as_html()\n\nÖrnek olarak aşağıda tablo word belgesi olarak kaydedilmektedir. İlk argümanın sözdizimine dikkat edilirse - sadece **flextable* nesnesinin adı verilebilir, ör. my_table veya aşağıda gösterildiği gibi bir “ad” da verilebilir (“my table”). Ad, Word’deki tablonun başlığı olarak görünecektir. Aşağıda ayrıca PNG olarak kaydetme kodu da paylaşılmıştır.\n\n# Tablo başlığını 'my table' olarak düzenle  \nsave_as_docx(\"my table\" = my_table, path = \"file.docx\")\n\nsave_as_image(my_table, path = \"file.png\")\n\nBir flextable tablosunu resim olarak kaydetmek için webshot veya webshot2 paketlerinin gerekli olduğunu unutmayın. Görüntüler şeffaf arka planla çıkartılabilir.\nflextable çıktının ‘canlı’ bir sürümü belge biçiminde görüntülemek istenirse, print() fonksiyonu kullanılabilir. preview = argümanı için aşağıdakilerden birini belirtmek gerekmektedir. Belge, bilgisayarınızda tanımlanan yazılım programında “açılır” ancak kaydedilmez. Bu durum, tablonun bir sayfaya / slayda sığıp sığmadığını kontrol etmek için yararlı olabilir böylece onu başka bir belgeye hızlı bir şekilde kopyalayabilirsiniz. Bağımsız değişken önizlemesini “pptx” veya “docx” olarak ayarlayabilirsiniz.\n\nprint(my_table, preview = \"docx\") # Word örneği\nprint(my_table, preview = \"pptx\") # Powerpoint örneği \n\n\n\nTabloyu R markdown’da yazdırma\nTablo nesnesi otomatik olarak bir belgenize veya R markdown çıktısına entegre edilebilir. Bu, değişen verilerle tablonun güncellenebileceği ve böylece sayıların yenilenebileceği anlamına gelmektedir.\nBu el kitabının [R Markdown ile Raporlar] sayfasındaki ayrıntılara bakın.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Sunum için tablolar</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.tr.html#kaynaklar",
    "href": "new_pages/tables_presentation.tr.html#kaynaklar",
    "title": "29  Sunum için tablolar",
    "section": "29.6 Kaynaklar",
    "text": "29.6 Kaynaklar\nTam flextable kitabı İlgili Github sayfası\nTüm flextable fonksiyonlarının bir kılavuzu burada bulunabilir Örnek flextable tablolardan oluşan bir galeriye buradan erişilebilir",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Sunum için tablolar</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.tr.html",
    "href": "new_pages/ggplot_basics.tr.html",
    "title": "30  ggplot temelleri",
    "section": "",
    "text": "30.1 Hazırlık",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.tr.html#hazırlık",
    "href": "new_pages/ggplot_basics.tr.html#hazırlık",
    "title": "30  ggplot temelleri",
    "section": "",
    "text": "Paketlerin yüklenmesi\nAşağıdaki bu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() fonksiyonunu kullanacağız. R tabanından library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakabilirsiniz.\n\npacman::p_load(\n  tidyverse,      # ggplot2 ve diğer veri yönetim paketlerini içerir\n  janitor,        # veri temizleme\n  ggforce,        # ggplot2'ye ekstra grafik öğeleri ekler\n  rio,            # içe / dışa aktarma\n  here,           # dosya lokasyonu bulma\n  stringr         # metinle çalışmak için   \n)\n\n\n\nVerileri içe aktarma\nÖrnek için Ebola salgınını simüle vakaların veri setini içe aktaracağız. Örneği takip etmek isterseniz, “temiz satır listesi” dosyasını indirmek için tıklayın. (.rds dosyası olarak). Verilerinizi rio paketinden import() işleviyle içe aktarabilirsiniz (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakabilirsiniz).\n\nlinelist &lt;- rio::import(\"linelist_cleaned.rds\")\n\nSatır listesinin ilk 50 satırı aşağıda gösterilmiştir. “age” (yaş), “wt_kg” (kilo cinsinden ağırlık), “ct_blood” (CT değerleri) ve “days_onset_hosp” (başlangıç tarihi ile hastaneye yatış arasındaki fark) sürekli değişkenlerine odaklanacağız.\n\n\n\n\n\n\n\n\nGenel temizleme\nÇizilecek verileri hazırlarken, verilerin mümkün olduğunca “tidy” veri standartlarına uygun düzenlemek gerekir. Bunun nasıl yapılacağı, bu el kitabının [Verileri temizleme ve temel işlevler] gibi veri yönetimi sayfalarında ayrıntılı olarak açıklanmıştır.\nVerileri çizim için daha iyi hale getirmek için kullanılan bazı basit yollar, verilerin içeriğini görüntüleme için daha iyi hale getirmeyi içerebilir. Bu yolların, veri işlemeyi her zaman daha da kolaylaştıracağı anlamına gelmez. Örneğin:\n\nBir karakter sütunundaki NA değerlerini “Bilinmeyen” karakter dizesiyle değiştirme\n\nSütunu faktör sınıfına çevirerek, değerleri sıralı düzeylere dönüştürme\nBazı sütunları, alt çizgi vb. içeren “veri dostu” değerlerinin normal metin veya büyük/küçük harfe dönüştürülmesi (bkz. [Karakterler ve dizeler])\n\nİşte bu yolların bazı örnekleri:\n\n# sütunların görüntü sürümünü daha kolay adlara değiştirme\nlinelist &lt;- linelist %&gt;%\n  mutate(\n    gender_disp = case_when(gender == \"m\" ~ \"Male\",        # m'den Male'e çevirme \n                            gender == \"f\" ~ \"Female\",      # f'den Female'e çevirme\n                            is.na(gender) ~ \"Unknown\"),    # NA'dan Unknown'a çevirme\n    \n    outcome_disp = replace_na(outcome, \"Unknown\")          # replace NA outcome with \"unknown\"\n  )\n\n\n\nUzun formata döndürme\nVeri yapısıyla ilgili olarak, ggplot2 için genellikle verilerimizi daha uzun biçimlere döndürmek isteyebiliriz. Bununla ilgili daha fazla bilgiyi [Verilerin Pivotlanması] sayfasında bulabilirsiniz.\n\n\n\n\n\n\n\n\n\nÖrneğin, satır listesindeki her bir vaka ve ilişkili verilerini “geniş” bir biçimde çizmek istediğimizi varsayalım. Aşağıda, yalnızca case_id ve semptomların sütunlarını içeren symptoms_data adlı bir mini satır listesi oluşturuyoruz.\n\nsymptoms_data &lt;- linelist %&gt;% \n  select(c(case_id, fever, chills, cough, aches, vomit))\n\nBu mini-satır listesinin ilk 50 satırı aşağıdaki şekilde görünür - her bir semptomun sütunda nasıl “geniş” olarak biçimlendirildiklerini görebilirsiniz:\n\n\n\n\n\n\nSpesifik semptomları olan vakaların sayısını çizmek istersek, her semptomun belirli bir sütunda olması gerçeğiyle sınırlıyız. Ancak, semptom sütunlarını aşağıdaki gibi daha uzun bir biçime pivotlayabiliriz:\n\nsymptoms_data_long &lt;- symptoms_data %&gt;%    # symptoms_data adlı \"mini\" satır listesiyle başla\n  \n  pivot_longer(\n    cols = -case_id,                       # case_id dışındaki tüm sütunları döndür (tüm belirti sütunları)\n    names_to = \"symptom_name\",             # semptomları içeren yeni sütun için ad ata\n    values_to = \"symptom_is_present\") %&gt;%  # değerleri tutan yeni sütun için ad ata (evet/hayır)\n  \n  mutate(symptom_is_present = replace_na(symptom_is_present, \"unknown\")) # NA'yı \"unknown\"a dönüştür\n\nİşte ilk 50 satır. Burada vakaların 5 satırı olduğunu unutmayın - her olası semptom için bir tane. Yeni symptom_name ve symptom_is_present sütunları, pivotlamanın sonucudur. Bu formatın diğer işlemler için çok yararlı olmayabileceğini, ancak çizim için faydalı olduğunu unutmayın.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.tr.html#ggplot-temelleri",
    "href": "new_pages/ggplot_basics.tr.html#ggplot-temelleri",
    "title": "30  ggplot temelleri",
    "section": "30.2 ggplot temelleri",
    "text": "30.2 ggplot temelleri\n“Grafiklerin grameri” - ggplot2\nggplot2 ile çizim, çizim katmanları ve tasarım öğelerinin birbirinin üzerine “eklenmesi” prensibine dayanır. Her komut bir öncekine bir artı sembolü (+) ile eklenir. Sonuç, kaydedilebilen, değiştirilebilen, yazdırılabilen, dışa aktarılabilen vb. çok katmanlı bir çizim nesnesidir.\nggplot nesneleri oldukça karmaşık olabilir, ancak katmanların temel sırası genellikle şöyle görünür:\n\nBaşta temel ggplot() komutuyla başlayın - bu, ggplot fonksiyonunu “açar” ve sonraki işlevlerin “+” ile eklenmesine izin verir. Tipik olarak veri kümesi de bu komutta belirtilir.\n“Geom” katmanlarını ekleyin - bu işlevler verileri geometriler (şekiller) olarak görselleştirir, ör. çubuk grafik, çizgi grafiği, dağılım grafiği, histogram (veya bir kombinasyon!) olarak. Bu işlevlerin tümü, önek olarak “geom_” ile başlar.\nEksen etiketleri, başlık, yazı tipleri, boyutlar, renk şemaları, göstergeler veya eksen dönüşü gibi tasarım öğelerini çizime ekleyin\n\nBasit bir kod dizilim örneği aşağıdaki gibidir. Her bir bileşeni aşağıdaki bölümlerde açıklayacağız.\n\n# my_data sütunlarındaki verileri kırmızı noktalar olarak çiz\nggplot(data = my_data)+                   # \"my_data\" veri kümesini kullan\n  geom_point(                             # bir nokta katmanı ekle (noktalar)\n    mapping = aes(x = col1, y = col2),    # veri sütununu eksene \"haritala\"\n    color = \"red\")+                       # geom için diğer özellikler\n  labs()+                                 # buraya başlıklar, eksen etiketleri vb. eklenir\n  theme()                                 # burada veri olmayan çizim öğelerinin (eksenler, başlık vb.) rengi, yazı tipi, boyutu vb. ayarlanır",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.tr.html#ggplot",
    "href": "new_pages/ggplot_basics.tr.html#ggplot",
    "title": "30  ggplot temelleri",
    "section": "30.3 ggplot()",
    "text": "30.3 ggplot()\nHerhangi bir ggplot2 grafiğinin açılış komutu ggplot() şeklindedir. Bu komut, üzerine katmanların ekleneceği boş bir arka plan oluşturur. Bir + sembolü ile ek katmanların eklenmesinin yolunu “açar”.\nTipik olarak, ggplot() komutu, çizim için gerekli olan data = argümanını içerir. Bu, grafiğin sonraki katmanları için kullanılacak varsayılan veri kümesini ayarlar.\nBu komut, kapanış parantezlerinden sonra bir + ile bitecektir. Bu, komutu “açık” bırakır. ggplot yalnızca, tam komut sonunda bir + olmadan son bir katman içerdiğinde yürütülür/görünür.\n\n# Bu komut, boş bir arka planı olan bir grafik yaratacaktır.\nggplot(data = linelist)",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.tr.html#geomlar",
    "href": "new_pages/ggplot_basics.tr.html#geomlar",
    "title": "30  ggplot temelleri",
    "section": "30.4 Geomlar",
    "text": "30.4 Geomlar\nBoş bir arka plan kesinlikle yeterli değildir - verilerden (örneğin çubuk grafikler, histogramlar, dağılım grafikleri, kutu grafikleri) geometriler (şekiller) oluşturmanız gerekir.\nGrafikler, ilk ggplot() komutuna geom katmanları eklenerek yapılır. Geom oluşturabilen birçok ggplot2 fonksiyonu mevcuttur. Bu fonksiyonların her biri geom_ ile başlar, bu nedenle onlardan genel olarak geom_XXXX() olarak bahsedeceğiz. ggplot2’de gönüllüler tarafından oluşturulmuş 40’tan fazla geoms bulunmaktadır. Bunları ggplot2 galerisinden görüntüleyebilirsiniz. Bazı yaygın geomlar aşağıda listelenmiştir:\n\nHistogramlar - geom_histogram()\n\nÇubuk grafikler - geom_bar() yada geom_col() (“Çubuk grafikleri” bölümüne bakabilirsiniz)\n\nKutu grafiği - geom_boxplot()\n\nNoktalar (örn. dağılım grafikleri) - geom_point()\n\nÇizgi grafikler - geom_line() yada geom_path()\n\nTrend eğrileri - geom_smooth()\n\nBir çizimde bir veya birden fazla geom görüntüleyebilirsiniz. Her biri önceki ggplot2 komutlarına bir `+’ ile eklenir ve sonraki coğrafi konumlar öncekilerin üzerine yerleştirilecek şekilde sırayla çizilir.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.tr.html#ggplot_basics_mapping",
    "href": "new_pages/ggplot_basics.tr.html#ggplot_basics_mapping",
    "title": "30  ggplot temelleri",
    "section": "30.5 Verileri grafiğe eşleme",
    "text": "30.5 Verileri grafiğe eşleme\nÇoğu geom fonksiyonunda şekilleri oluştururken ne için kullanacakları söylenmelidir - bu nedenle fonksiyonda verilerinizdeki sütunları ilgili grafikle eşleştirerek eksenini, şeklini, rengini, boyutunu vb. tanımlamalısınız. vb. Çoğu grafik konum verileri için, eşlenmesi gereken temel bileşenler x ekseni ve (gerekirse) y eksenidir.\nBu “eşleme”, mapping = argümanıyla gerçekleşir. mapping için sağladığınız eşlemeler aes() fonksiyonunda sarılmalıdır, bu nedenle aşağıda gösterildiği gibi mapping = aes(x = col1, y = col2) şeklinde yazabilirsiniz.\nAşağıda, ggplot() komutunda veriler linelist durumu olarak ayarlanır. mapping = aes() argümanında age sütunu x eksenine, wt_kg sütunu ise y eksenine eşlenir.\n+ işaretinden sonra çizim komutları devam eder. geom fonksiyonu olan geom_point() ile bir şekil oluşturulur. Bu geom, yukarıdaki ggplot() komutundan eşlemeleri devralır - eksen-sütun atamalarını bilir ve bu ilişkileri alan üzerinde noktalar olarak görselleştirmeye devam eder.\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+\n  geom_point()\n\n\n\n\n\n\n\n\nBaşka bir örnek olarak, aşağıdaki komutlar aynı verileri, biraz farklı bir eşlemeyi ve farklı bir geom’u kullanır. geom_histogram() fonksiyonu, sayımlar y ekseni otomatik olarak oluşturulduğundan, yalnızca x eksenine eşlenmiş bir sütun gerektirir.\n\nggplot(data = linelist, mapping = aes(x = age))+\n  geom_histogram()\n\n\n\n\n\n\n\n\n\nGrafik estetiği\nggplot terminolojisinde “estetik” konusunun belirli bir anlamı vardır. Burada estetik, çizilmiş verinin görsel bir özelliğini ifade eder. Buradaki “estetik” ifadesinin geomlarda/şekillerde çizilen verileri de kapsadığını unutmayın - başlıklar, eksen etiketleri, arka plan rengi gibi genel İngilizcede “estetik” kelimesiyle ilişkilendirebileceğiniz çevredeki görüntü değil. ggplot’ta bu ayrıntılara “temalar” denir ve bir theme() komutuyla ayarlanır (bkz. bu bölüm).\nBu nedenle, çizim nesnesinin estetiği, çizilen verilerin renkleri, boyutları, asetatları, yerleşimi vb. olabilir. Tüm geomlar aynı estetik seçeneklere sahip değildir, ancak çoğu geom tarafından kullanılabilir. İşte bazı örnekler:\n\nshape = Bir noktayı nokta, yıldız, üçgen veya kare olarak geom_point() ile gösterme…\nfill = İç renk (örneğin bir çubuk veya kutu grafiği)\ncolor = Bir çubuğun, kutu grafiğinin vb. dış çizgisi veya geom_point() kullanılıyorsa noktanın rengi\nsize = Boyut (ör. çizgi kalınlığı, nokta boyutu)\nalpha = Şeffaflık (1 = opak, 0 = görünmez)\n\nbinwidth = Histogram bölmelerinin genişliği\nwidth = “Çubuk grafiği” sütunlarının genişliği\nlinetype = Çizgi türü (ör. düz, kesikli, noktalı)\n\nBu çizim nesnesi estetiğine değerler iki şekilde atanabilir:\n\nTüm çizilen gözlemlere uygulanacak statik bir değer (ör. `color = \"blue\") atanması\n\nHer bir gözlemin görüntülenmesi o sütundaki değerine bağlı olacak şekilde bir veri sütununa (ör. color = hospital) atanması\n\n\n\n\nStatik bir değer ayarlama\nÇizim nesnesine ait estetik değerlerin statik olmasını istiyorsanız, yani - verilerdeki her gözlem için aynı olmasını istiyorsanız, atamasını geom içine, ancak herhangi bir mapping = aes() ifadesinin dışına yazmalısınız. Bu atamalar size = 1 veya color = \"blue\" gibi görünebilir. İşte iki örnek:\n\nİlk örnekte, mapping = aes(), ggplot() komutunun içindedir ve eksenler, verilerdeki yaş ve ağırlık sütunlarına eşlenir. Çizim estetiğindeki color =, size = ve alpha =(saydamlık) parametrelerine statik değerler atanır. Anlaşılır olması için, bu, daha sonra çizim estetiği için farklı değerler alacak başka geom’lar ekleyebileceğiniz için ‘geom_point()’ işlevinde yapılmıştır.\nİkinci örnekte, histogram yalnızca bir sütuna eşlenen x eksenini gerektirmektedir. binwidth =, color =, fill = (iç renk) ve alpha = parametreleri geom içinde tekrar statik değerlere ayarlanır.\n\n\n# dağılım grafiği\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  # veri ve eksen eşlemesini ayarla\n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)         # statik nokta estetiğini ayarla\n\n# histogram\nggplot(data = linelist, mapping = aes(x = age))+       # veri ve eksenleri ayarla\n  geom_histogram(                # histogramı göster\n    binwidth = 7,                # kutuların genişliği\n    color = \"red\",               # sınır çizgi rengi\n    fill = \"blue\",               # kutu iç rengi\n    alpha = 0.1)                 # kutu şeffaflığı\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSütun değerlerine ölçekleme\nAlternatif olarak, çizim nesnesi estetiğini bir sütundaki değerlerle ölçekleyebiliriz. Bu yaklaşımda, estetiğin görüntüsü, o veri sütunundaki gözlemin değerine bağlı olacaktır. Sütun değerleri sürekli ise, o estetik için görüntü ölçeği de (açıklama) sürekli olacaktır. Sütun değerleri ayrıysa, gösterge her bir değeri görüntüleyecek ve çizilen veriler belirgin bir şekilde “gruplanmış” olarak görünecektirr (bu sayfanın gruplandırma bölümünde daha fazlasını okuyabilirsiniz).\nBunu başarmak için, estetiği bir sütun adına eşlemeniz gerekmektedir (tırnak içinde değil). Bu eşleme, mapping  = aes() fonksiyonu içinde yapılmalıdır (not: aşağıda tartışıldığı gibi kodda bu eşleme atamalarını yapabileceğiniz birkaç yer vardır).\nİki örnek aşağıda verilmiştir.\n\nİlk örnekte, color = parametresi (her noktanın) age sütununa eşlenir - açıklamada bir ölçek belirir! Şimdilik ölçeğin var olduğuna dikkat etmeniz yeterlidir- sonraki bölümlerde nasıl değiştirileceğini paylaşcağız.\nİkinci örnekte, iki yeni çizim estetiği de sütunlarla eşlenir (color = ve size =), shape = ve alpha = parametreleri herhangi bir mapping = aes() fonksiyonu dışındaki statik değerlere eşlenir.\n\n\n# dağılım grafiği\nggplot(data = linelist,   # veri ayarla\n       mapping = aes(     # estetiği sütun değerlerine eşle\n         x = age,           # x eksenini yaşa eşle          \n         y = wt_kg,         # y eksenini ağırlıkla eşle\n         color = age)\n       )+     # yaşa göre rengi eşle\n  geom_point()         # verileri nokta olarak göster\n\n# dağılım grafiği\nggplot(data = linelist,   # veri ayarla\n       mapping = aes(     # estetiği sütun değerlerine eşle\n         x = age,           # x eksenini yaşa eşle           \n         y = wt_kg,         # y eksenini ağırlıkla eşle\n         color = age,       # yaşa göre rengi eşle\n         size = age))+      # yaşa göre boyutu eşle\n  geom_point(             # verileri nokta olarak göster\n    shape = \"diamond\",      # noktalar elmas olarak görüntülenir\n    alpha = 0.3)            # nokta şeffaflığı 30%\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNot: Eksen atamaları her zaman verilerdeki sütunlara atanır (statik değerlere değil) ve bu her zaman mapping = aes() içinde yapılır.\nDaha karmaşık grafikler oluştururken çizim katmanlarınızı ve estetiğinizi takip etmek daha da önemli hale gelir - örneğin birden fazla geom içeren grafikler. Aşağıdaki örnekte, size = parametresi iki kez atanır - bir kez geom_point() için ve bir kez de geom_smooth() için - her ikisi de statik bir değer olarak.\n\nggplot(data = linelist,\n       mapping = aes(           # estetiği sütunlara eşle\n         x = age,\n         y = wt_kg,\n         color = age_years)\n       ) + \n  geom_point(                   # her veri satırı için puan ekle\n    size = 1,\n    alpha = 0.5) +  \n  geom_smooth(                  # trend eğrisi ekle\n    method = \"lm\",              # linear metodla\n    size = 2)                   # çizgi boyutunu (çizgi genişliği) 2 yap\n\n\n\n\n\n\n\n\n\n\nHarita atamaları nerede yapılır\nmapping = aes() içindeki estetik haritalama, çizim komutlarınızda birden fazla kez yazılabilir. Bu argüman, en üstteki ggplot() komutuna ve/veya altındaki her bir geoma yazılabilir. Nüanslar şunları içerir:\n\nEn üstteki ggplot() komutunda yapılan eşleme atamaları (x = ve y = öğelerinin nasıl devralındığı gibi atamalar) aşağıdaki herhangi bir geomda varsayılan olarak devralınır.\nBir geom içinde yapılan eşleme atamaları yalnızca o geom için geçerlidir\n\nBenzer şekilde, en üstteki ggplot() içinde belirtilen data = aşağıdaki herhangi bir geomda varsayılan olarak geçerli olacaktır, ancak her bir geom için farklı veri de belirtebilirsiniz (ancak bu daha zordur).\nBöylece, aşağıdaki komutların her biri aynı grafiği oluşturacaktır:\n\n# Bu komutlar tam olarak aynı grafiği üretecek\nggplot(data = linelist, mapping = aes(x = age))+\n  geom_histogram()\n\nggplot(data = linelist)+\n  geom_histogram(mapping = aes(x = age))\n\nggplot()+\n  geom_histogram(data = linelist, mapping = aes(x = age))\n\n\n\nGrouplar\nVerileri kolayca gruplayabilir ve “gruba göre çizebilirsiniz”. Aslında, bunu zaten yaptınız!\nBir mapping = aes() argümanı içinde “grouping” sütununu uygun çizim estetiğine atayın. Yukarıda, age sütununa size = argümanını atadığımızda sürekli değerler kullanarak bunu gösterdik. Ancak bu, ayrık/kategorik sütunlar için aynı şekilde çalışır.\nÖrneğin, puanların cinsiyete göre görüntülenmesini istiyorsanız, mapping = aes(color = gender) değerini ayarlamanız gerekmektedir. Otomatik olarak bir açıklama belirir. Bu atama, en üstteki ggplot() komutundaki mapping = aes() argümanı içinde yapılabilir (ve geom tarafından miras alınabilir) veya geom içinde ayrı bir mapping = aes() içinde ayarlanabilir. Aşağıdaki her iki yaklaşım da aşağıda gösterilmiştir:\n\nggplot(data = linelist,\n       mapping = aes(x = age, y = wt_kg, color = gender))+\n  geom_point(alpha = 0.5)\n\n\n\n\n\n\n\n\n\n# Bu alternatif kod aynı grafiği üretir\nggplot(data = linelist,\n       mapping = aes(x = age, y = wt_kg))+\n  geom_point(\n    mapping = aes(color = gender),\n    alpha = 0.5)\n\nGeom değerlerine bağlı olarak, verileri gruplamak için farklı argümanlar kullanmanız gerekeceğini unutmayın. geom_point() için büyük olasılıkla color =, shape = veya size = kullanacaksınız. Oysa geom_bar() için fill = argümanını kullanmanız daha olasıdır. Bu sadece geoma ve gruplamaları yansıtmak istediğiniz grafik estetiğine bağlıdır.\nBilginize - verileri gruplandırmanın en temel yolu, yalnızca mapping = aes() içindeki group = argümanını kullanmaktır. Ancak, bu tek başına renkleri, dolguyu veya şekilleri değiştirmeyecektir. Ayrıca yeni bir açıklama oluşturacaktır. Yine de veriler gruplandırılmıştır, bu nedenle istatistiksel görüntüler etkilenebilir.\nBir grafikteki grupların sırasını ayarlamak için [ggplot ipuçları] sayfasına veya [Faktörler] sayfasına bakabilirsiniz. Aşağıdaki bölümlerde, sürekli ve kategorik verilerin çizilmesine ilişkin birçok gruplanmış grafik örneği bulunmaktadır.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.tr.html#ggplot_basics_facet",
    "href": "new_pages/ggplot_basics.tr.html#ggplot_basics_facet",
    "title": "30  ggplot temelleri",
    "section": "30.6 Yüzeyler / Küçük katlar",
    "text": "30.6 Yüzeyler / Küçük katlar\nYüzeyler veya “küçük katlar”, bir grafiği, veri grubu başına bir panel (“yüzey”) olacak şekilde çok panelli bir şekle bölmek için kullanılır. Aynı tip çizim, her biri aynı veri setinin bir alt grubunu kullanarak, birden çok kez oluşturulabilir.\nYüzey ekleme, ggplot2 ile birlikte gelen bir fonksiyondur, bu nedenle model “panellerinin” açıklamaları ve eksenleri otomatik olarak hizalanır. [ggplot ipuçları] sayfasında tartışılan ve tamamen farklı çizimleri (cowplot ve patchwork) tek bir şekilde birleştirmek için kullanılan başka paketler de vardır.\nYüzey ekleme, aşağıdaki ggplot2 işlevlerinden biriyle yapılır:\n\nfacet_wrap() tek değişkenin her düzeyine ait farklı bir panel oluşturmak için kullanılır. Örnek olarak, bir bölgedeki her hastane için farklı bir salgın eğrisi gösteriyor olabilir. Değişken, tanımlanmış başka bir sıralamaya sahip bir faktör olmadığı sürece, yönler alfabetik olarak sıralanır.\n\n\nYüzeylerin düzenini belirlemek için belirli seçenekleri çağırabilirsiniz, örn. Yönlü grafiklerin düzenlendiği satır veya sütun sayısını kontrol etmek için nrow = 1 veya ncol = 1.\n\n\nfacet_grid() yüzey düzenlemesine ikinci bir değişken getirmek istediğinizde kullanılır. Burada her bir alan, iki sütundaki değerler arasındaki kesişimi gösterir. Örneğin, her bir hastane-yaş grubu için salgın eğrileri, hastaneler üstte (sütunlar) ve yaş grupları yanda (sıralar) bulunur.\n\n\nalt gruplar bir dizilimde gösterildiğinden nrow ve ncol ile alakalı değildir\n\nBu fonksiyonların her biri, yüzey eklemek için sütunları belirten bir söz dizimini kabul eder. Her ikisi de bir tilde ~ işaretinin her iki tarafında birer tane olmak üzere en fazla iki sütunu kabul eder.\n\nfacet_wrap() için genellikle, facet_wrap(~hospital) gibi önüne bir tilde (~) gelen sütunun adını yazarsınız. Ancak iki sütunu facet_wrap(outcome ~ hospital) şeklinde yazabilirsiniz - her benzersiz kombinasyon ayrı bir panelde görüntülenecektir. Ancak bir dizilim halinde düzenlenmeyecektir. Başlıklar birleşik terimleri gösterecek ve bunlar sütunlara karşılık satırları özel olarak göstermeyecektir. Yalnızca bir yönlü değişken sağlıyorsanız, formülün diğer tarafında yer tutucu olarak nokta . kullanabilirsiniz - aşağıdaki kod örneklerine bakın.\nfacet_grid() için formülde bir veya iki sütun da belirtebilirsiniz (dizilim ‘satırlar ~ sütunlar’ şeklindedir). Yalnızca birini belirtmek istiyorsanız, tildenin diğer tarafına facet_grid(. ~ hospital) veya facet_grid(hospital ~ .) gibi bir nokta . koyabilirsiniz.\n\nYüzeyler, hızlı bir şekilde karmaşıklaşabilir - yüzey eklemeyi seçtiğiniz her bir değişkenin çok fazla düzeye sahip olmadığından emin olmalısınız. Tesislerin yaş grubuna göre günlük sıtma vaka sayılarından oluşan sıtma veri seti ile ilgili bazı örnekler için [El kitabı ve verileri indirme] sayfasına bakabilirsiniz.\nAşağıda, basit örnek için bazı değişiklikleri içe aktarıp düzenliyoruz:\n\n# Bu veriler, tesis-gününe göre günlük sıtma vakası sayılarıdır.\nmalaria_data &lt;- import(here(\"data\", \"malaria_facility_count_data.rds\")) %&gt;%  # içe aktar\n  select(-submitted_date, -Province, -newid)                                 # gereksiz sütunları kaldır\n\nSıtma verilerinin ilk 50 satırı aşağıdadır. malaria_tot sütununun yanı sıra yaş grubuna göre sayımları içeren sütunlar olduğunu unutmayın (bunlar ikinci, facet_grid() örneğinde kullanılacaktır).\n\n\n\n\n\n\n\nfacet_wrap()\nmalaria_tot ve District sütunlarına odaklanalım. Şimdilik yaşa özel sayım sütunlarını yok sayabilirsiniz. malaria_tot sütununda verilen belirtilen y ekseni yüksekliğinde her gün için bir sütun üreten geom_col() ile salgın eğrileri çizeceğiz (veriler zaten günlük sayılardır, bu nedenle geom_col() kullanıyoruz - bkz. aşağıdaki “Çubuk grafiği” bölümü).\nfacet_wrap() komutunu eklediğimizde, bir tilde ve sonra yüzey üzerinde sütunu tanımlarız (bu durumda District). Yaklaşık işaretinin sol tarafına başka bir sütun yerleştirebilirsiniz, - bu her kombinasyon için bir yüzey oluşturacaktır - ancak bunu bunun yerine facet_grid() ile yapmanızı öneririz. Bu kullanım örneğinde, “Bölge”nin her benzersiz değeri için bir yüzey oluşturulur.\n\n# Bölgelere göre yüzeyleri olan bir grafik\nggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1, fill = \"darkred\") +       # sayım verilerini sütun olarak çiz\n  theme_minimal()+                              # arka plan panellerini basitleştir\n  labs(                                         # grafik etiketleri, başlık vb. ekle\n    x = \"Date of report\",\n    y = \"Malaria cases\",\n    title = \"Malaria cases by district\") +\n  facet_wrap(~District)                       # yüzeyler oluşturuldu\n\n\n\n\n\n\n\n\n\n\nfacet_grid()\nİki değişkeni çaprazlamak için facet_grid() yaklaşımını kullanabiliriz. Diyelim ki District verilerini yaşa göre gruplandırmak istiyoruz. Bu verileri ggplot tarafından tercih edilen “long” formatına sokmak için yaş sütunlarında bazı verileri dönüştürmemiz gerekiyor. Yaş gruplarının hepsinin kendine ait sütunları mevcut - biz onları age_group a ve num_cases adlı sütunlarda toplamak istiyoruz. Bu işlem hakkında daha fazla bilgi için [Pivoting data] sayfasına bakabilirsiniz.\n\nmalaria_age &lt;- malaria_data %&gt;%\n  select(-malaria_tot) %&gt;% \n  pivot_longer(\n    cols = c(starts_with(\"malaria_rdt_\")),  # sütunları long formatına çevir\n    names_to = \"age_group\",      # sütun adları yaş grubu olacak\n    values_to = \"num_cases\"      # tek bir sütuna sayılar aktarılacak (num_cases)\n  ) %&gt;%\n  mutate(\n    age_group = str_replace(age_group, \"malaria_rdt_\", \"\"),\n    age_group = forcats::fct_relevel(age_group, \"5-14\", after = 1))\n\nİlk 50 veri satırı aşağıdaki gibi görünmektedir:\n\n\n\n\n\n\nİki değişkeni facet_grid() öğesine ilettiğinizde, en kolay yöntem, x’in satır ve y’nin sütun olduğu formül gösterimini (örneğin x ~ y) kullanmak olacaktır. Burada, age_group ve District sütunlarının her bir kombinasyonunun çizimlerinde facet_grid() kullanılımı gösterilmiştir.\n\nggplot(malaria_age, aes(x = data_date, y = num_cases)) +\n  geom_col(fill = \"darkred\", width = 1) +\n  theme_minimal()+\n  labs(\n    x = \"Date of report\",\n    y = \"Malaria cases\",\n    title = \"Malaria cases by district and age group\"\n  ) +\n  facet_grid(District ~ age_group)\n\n\n\n\n\n\n\n\n\n\nSerbest veya sabit eksenler\nYüzey düzenlemesi sırasında görüntülenen eksen ölçekleri, varsayılan olarak tüm yüzeylerde aynıdır (sabit). Bu, çapraz karşılaştırma için yararlıyken her zaman uygun format olmayabilir.\nfacet_wrap() veya facet_grid() kullanırken, “serbest” eksenleri belirlemek için scales = \"free_y\" argümanını kullanabilir veya panellerin y eksenlerini veri alt kümelerine uygun bir şekilde ölçeklendirmesi için serbest bırakabiliriz. Bu, özellikle alt kategorilerden biri için gerçek sayıların küçük olması ve eğilimlerin görülmesinin zorlaşması durumunda işe yarayabilir. “free_y” yerine, x eksenini serbest kılmak için (örneğin tarihlerde) “free_x” veya her iki eksen için “serbest” yazabiliriz. facet_grid fonksiyonunda, aynı satırdaki yüzeyler için y ölçeğinin ve aynı sütundaki yüzeyler için x ölçeğinin aynı olacağına dikkat etmelisiniz.\nYalnızca facet_grid kullanıldığı durumlarda, space = \"free_y\" veya space = \"free_x\" argümanlarını ekleyebiliriz. Böylece yüzeyin gerçek yüksekliği veya genişliği, içindeki şeklin değerlerine göre ağırlıklandırılır. Bu, yalnızca scales = \"free\" (y veya x) argümanı mevcutsa çalışır.\n\n# Serbest y ekseni\nggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1, fill = \"darkred\") +       # sayım verilerini sütun olarak çiz\n  theme_minimal()+                              # arka plan panellerini basitleştir\n  labs(                                         # grafik etiketleri, başlık vb. ekle\n    x = \"Date of report\",\n    y = \"Malaria cases\",\n    title = \"Malaria cases by district - 'free' x and y axes\") +\n  facet_wrap(~District, scales = \"free\")        # yüzeyler oluşturuldu\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYüzeylerde faktör düzeyi sırası\nFaktör seviyelerinin yüzeyler içinde nasıl yeniden sıralanacağını öğrenmek için bu blog yazısına bakabilirsiniz.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.tr.html#grafikleri-depolama",
    "href": "new_pages/ggplot_basics.tr.html#grafikleri-depolama",
    "title": "30  ggplot temelleri",
    "section": "30.7 Grafikleri depolama",
    "text": "30.7 Grafikleri depolama\n\nGrafikleri kaydetme\nVarsayılan olarak bir ggplot() komutunu çalıştırdığınızda, grafik Plots RStudio bölmesinde görüntülenecektir. Ancak, &lt;- atama operatörünü kullanarak ve ona bir isim vererek grafiği bir nesne olarak da kaydedebilirsiniz. Bundan sonra, nesne adının kendisi çalıştırılmadıkça grafik yazdırılmayacaktır. Ek olarak, nesne adını print() ile sararak da yazdırabilirsiniz, ancak bu bir kerede birden çok grafiği yazdırmak için kullanılan bir for döngüsü gibi belirli durumlarda gereklidir (bkz. [Yineleme, döngüler ve listeler] sayfası).\n\n# grafiği tanımla\nage_by_wt &lt;- ggplot(data = linelist, mapping = aes(x = age_years, y = wt_kg, color = age_years))+\n  geom_point(alpha = 0.1)\n\n# yazdır\nage_by_wt    \n\n\n\n\n\n\n\n\n\n\nKayıtlı grafikleri değiştirme\nggplot2 ile ilgili güzel bir şey de, bir grafiği (yukarıdaki gibi) tanımlayabilmeniz ve ardından buna adından başlayarak yeni katmanlar ekleyebilmenizdir. Orijinal grafiği oluşturan tüm komutları tekrarlamanız gerekmez!\nÖrneğin, yukarıda tanımlanan age_by_wt grafiğini 50 yaş sütununda dikey bir çizgi içerecek şekilde değiştirmek için, sadece bir ‘+’ ile ek katmanlar eklemeye başlarız.\n\nage_by_wt+\n  geom_vline(xintercept = 50)\n\n\n\n\n\n\n\n\n\n\nGrafikleri dışa aktarma\nggplot2’den ggsave() fonksiyonuyla grafikleri dışa kolayca aktarabiliriz. Bunu iki şekilde de yapabiliriz:\n\nGrafik nesnesinin adını, ardından dosya yolunu ve uzantılı adı belirterek\n\nÖrnek: ggsave(my_plot, here(\"plots\", \"my_plot.png\"))\n\n\nYazdırılan son grafiği kaydetmek için komutu bir dosya yolu ile çalıştırarak\n\nÖrnek: ggsave(here(\"plots\", \"my_plot.png\"))\n\n\nDosya yolunda dosya uzantısını tanımlayarak; png, pdf, jpeg, tiff, bmp, svg gibi pek çok formatta dışarı aktarabilirsiniz.\nAyrıca width =, height = ve units = (“in”, “cm” veya “mm”) bağımsız değişkenlerini de tanımlayabilirsiniz. Çizim çözünürlüğü için bir sayı ile dpi = argümanını ekleyebilirsiniz (ör. 300). “?ggsave” komutunu girerek veya çevrimiçi belgeleri okuyarak fonksiyonu daha ayrıntılı inceleyebilirsiniz.\nİstediğiniz dosya yolunu sağlamak için burada() sözdizimini kullanabileceğinizi unutmayın. Daha fazla bilgi için [İçe ve dışa aktar] sayfasına bakabilirsiniz.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.tr.html#etiketler",
    "href": "new_pages/ggplot_basics.tr.html#etiketler",
    "title": "30  ggplot temelleri",
    "section": "30.8 Etiketler",
    "text": "30.8 Etiketler\nElbette grafik etiketlerini eklemek veya ayarlamak isteyeceksiniz. Bunlar en kolay şekilde, tıpkı geom’larda olduğu gibi + ile grafiğe eklenen ‘labs()’ fonksiyonu ile düzenlenir.\nlabs() fonksiyonu içinde aşağıdaki argümanları kullanabilirsiniz:\n\nx = ve y = x ve y ekseni başlığı (etiketler)\ntitle = Ana grafik başlığı\nsubtitle = Grafiğin alt başlığı, başlığın altında daha küçük metinle\ncaption = Grafik başlığı, varsayılan olarak sağ altta\n\nİşte daha önce yaptığımız, ancak daha güzel etiketlerle bir grafik:\n\nage_by_wt &lt;- ggplot(\n  data = linelist,   # veriyi belirle\n  mapping = aes(     # estetiği sütun değerlerine eşle\n         x = age,           # x eksenini yaşa eşle           \n         y = wt_kg,         # y eksenini ağırlıkla eşle\n         color = age))+     # rengi yaşla eşle\n  geom_point()+           # verileri nokta olarak göster\n  labs(\n    title = \"Age and weight distribution\",\n    subtitle = \"Fictional Ebola outbreak, 2014\",\n    x = \"Age in years\",\n    y = \"Weight in kilos\",\n    color = \"Age\",\n    caption = stringr::str_glue(\"Data as of {max(linelist$date_hospitalisation, na.rm=T)}\"))\n\nage_by_wt\n\n\n\n\n\n\n\n\nDize metnine dinamik R kodunu yerleştirmek için altyazı atamasında stringr paketinden str_glue() fonksiyonunu nasıl kullandığımıza dikkat edin. Başlık, ilgili tarihteki maksimum hastane yatış süresini yansıtan “verileri” gösterecektir. Daha fazla bilgiyi [Karakterler ve dizeler] sayfasından okuyabilirsiniz.\nAçıklama başlığının belirlenmesine ilişkin bir not: Açıklamalarda birden fazla skalanız olabileceğinden, tek bir “açıklama başlığı” argümanı yoktur. labs() içinde, açıklamayı oluşturmak için kullanılan çizim estetiğinde gerekli argümanı kullanarak başlığı tanımlayabilirsiniz. Örneğin, açıklama oluşturmak için yukarıda color = age argümanını kullandık. Bu nedenle, labs() fonksiyonuna color = argümanını ekler ve istediğimiz açıklama başlığını yazarız (büyük Y ile “Yaş”). Açıklamayı aes(fill = COLUMN) ile oluşturursanız, labs() içinde bu açıklamanın başlığını ayarlamak için fill = yazmak zorundasınız. [ggplot ipuçları] sayfasındaki renk ölçekleriyle ilgili bölüm, açıklamaları düzenleme hakkında daha fazla ayrıntı ve scales_() fonksiyonuyla alternatif yaklaşımları içermektedir.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.tr.html#ggplot_basics_themes",
    "href": "new_pages/ggplot_basics.tr.html#ggplot_basics_themes",
    "title": "30  ggplot temelleri",
    "section": "30.9 Temalar",
    "text": "30.9 Temalar\nggplot2’nin en iyi yanlarından biri, grafik üzerinde sahip olduğunuz kontrol düzeyidir - her şeyi tanımlayabilirsiniz! Yukarıda bahsedilen, veri şekilleri/geometrileri ile ilgili olmayan tasarım özellikleri theme() fonksiyonu içerisinde düzenlenir. Örneğin, arka plan rengi, kılavuz çizgilerinin varlığı/yokluğu ve metnin yazı tipi/boyutu/renk/hizalaması (başlıklar, alt yazılar, açıklamalar, eksen başlıkları…). Bu düzenlemeler iki yolla yapılabilir:\n\nKapsamlı ayarlamalar yapmak için bir tam tema “theme_()” fonksiyonu kullanma - örn. theme_classic(), theme_minimal(), theme_dark(), theme_light() theme_grey(), theme_bw()\ntheme() içinde grafiğin her yönünü ayrı ayrı düzenleme\n\n\nTam temalar\nOldukça basit oldukları için, aşağıda tüm tema işlevlerini göstereceğiz ve burada daha fazla açıklamayacağız. theme() ile yapılan tüm mikro ayarlamaların, tam bir tema kullanıldıktan sonra yapılması gerektiğini unutmamalısınız.\nBunları boş parantez ile yazınız.\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme classic\")+\n  theme_classic()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme bw\")+\n  theme_bw()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme minimal\")+\n  theme_minimal()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme gray\")+\n  theme_gray()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTemayı düzenleme\ntheme() fonksiyonu, her biri grafiğin çok özel bir yönünü düzenleyen pek çok sayıda argüman alabilir. Tüm argümanları ele almamız mümkün değil, ancak onların tamamı geçerli olan genel kalıbı tanımlayacağız. İhtiyacınız olan argüman adını nasıl bulacağınızı göstereceğiz. Bu fonksiyonun temel sözdizimi aşağıdaki gibidir:\n\ntheme() fonksiyonu içinde, düzenlemek istediğiniz grafiğin argüman adını plot.title = olarak yazın.\nArgümana bir element_() fonksiyonu ekleyin\n\n\nÇoğu zaman element_text() fonksiyonu kullanılır, ancak sık kullanılan diğerleri de arka plan renkleri için element_rect() veya grafik öğelerini kaldırmak için element_blank()\n\n\nelement_() fonksiyonu içinde, istediğiniz ince ayarları yapmak için argümanlar kullanın.\n\nBiliyoruz, bu açıklama oldukça soyuttu. Daha iyi açıklamak adına bir kaç örnek paylaşacağız.\nAşağıdaki grafiğin oldukça saçma bir örnek olduğunun farkındayız, ancak size grafikleri nasıl ayarlayabileceğinizi göstermekte bize yardımcı olacak.\n\nİlk olarak tanımlanan age_by_wt grafiğiyle başlayıp theme_classic() fonksiyonunu ekliyoruz\nDaha ince ayarlamalar için theme() fonksiyonu ve ayarlanacak her grafik öğesi için bir argüman ekleriz.\n\nArgümanları mantıksal bir şekilde düzenlemek güzel olabilir. Aşağıda bir kaçını tanımladık:\n\nlegend.position = “alt”, “üst”, “sol” ve “sağ” gibi basit değerleri kabul etmesi bakımından benzersizdir. Ancak genellikle metinle ilgili argümanlar, ayrıntıları element_text() içine yerleştirmenizi gerektirir.\nelement_text(size = 30) ile başlık boyutu\n\nelement_text(hjust = 0) ile yazıyı yatay olarak hizalama (sağdan sola)\nAltyazı, element_text(face = \"italic\") ile italik yazılır\n\n\nage_by_wt + \n  theme_classic()+                                 # önceden tanımlanmış tema ayarlamaları\n  theme(\n    legend.position = \"bottom\",                    # açıklamayı aşağıya taşı\n    \n    plot.title = element_text(size = 30),          # başlığın boyutu 30\n    plot.caption = element_text(hjust = 0),        # sola hizalı başlık\n    plot.subtitle = element_text(face = \"italic\"), # italik alt başlık\n    \n    axis.text.x = element_text(color = \"red\", size = 15, angle = 90), # yalnızca x ekseni metnini ayarlar\n    axis.text.y = element_text(size = 15),         # yalnızca y ekseni metnini ayarlar\n    \n    axis.title = element_text(size = 20)           # her iki eksen başlığını da ayarlar\n    )     \n\n\n\n\n\n\n\n\nBurada özellikle yaygın olan bazı tema() argümanları verilmiştir. Değişikliği yalnızca bir eksene uygulamak için “.x” veya “.y” ekini ekleyebilirsiniz.\n\n\n\n\n\n\n\ntheme() argümanı\nEtkilediği yer\n\n\n\n\nplot.title = element_text()\nAna başlık\n\n\nplot.subtitle = element_text()\nAlt başlık\n\n\nplot.caption = element_text()\nBaşlık (family, face, color, size, angle, vjust, hjust…)\n\n\naxis.title = element_text()\nEksen başlığı (x ve y) (size, face, angle, color…)\n\n\naxis.title.x = element_text()\nX ekseni başlığı (y ekseni için .y ekini kullanın)\n\n\naxis.text = element_text()\nEksen metni (x ve y)\n\n\naxis.text.x = element_text()\nX ekseni metni (y ekseni için .y ekini kullanın)\n\n\naxis.ticks = element_blank()\nEksen işaretlerini kaldır\n\n\naxis.line = element_line()\nEksen çizgisi (colour, size, linetype: solid dashed dotted etc)\n\n\nstrip.text = element_text()\nYön şerit metni (colour, face, size, angle…)\n\n\nstrip.background = element_rect()\nYön şeridi (fill, colour, size…)\n\n\n\nDaha pek çok tema argümanı mevcuttur! Hepsini nasıl hatırlayabilirim diye endişelenmenize gerek yok - hepsini hatırlamanız imkansız. Neyse ki size yardımcı olacak birkaç araç var:\nTam bir liste içeren tema değiştirme hakkındaki tidyverse belgeleri.\nİPUCU: Konsola 90’dan fazla theme() argümanının listesini yazdırmak için ggplot2 paketinden theme_get() fonksiyonunu çalıştırın.\nİPUCU: Grafiğin bir öğesini kaldırmak isterseniz, bunu theme() aracılığıyla da yapabilirsiniz. Tamamen kaybolması için bir argümana element_blank()ı eklemeniz yeterlidir. Açıklamalar için de legend.position = \"none\" argümanını kullanabilirsiniz.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.tr.html#renkler",
    "href": "new_pages/ggplot_basics.tr.html#renkler",
    "title": "30  ggplot temelleri",
    "section": "30.10 Renkler",
    "text": "30.10 Renkler\nLütfen ggplot ipuçları sayfasının renk skalalarıyla ilgili bölüme bakın.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.tr.html#ggplot2-içine-tünelleme",
    "href": "new_pages/ggplot_basics.tr.html#ggplot2-içine-tünelleme",
    "title": "30  ggplot temelleri",
    "section": "30.11 ggplot2 içine tünelleme",
    "text": "30.11 ggplot2 içine tünelleme\nVerilerinizi temizlemek ve dönüştürmek için tünelleme metodunu kullandıysanız, dönüştürülmüş bu verileri ggplot()a kolayca geçirebilirsiniz.\nVeri kümesini fonksiyondan fonksiyona taşıma işlemi, ggplot() kullanımında “+” eklenmiş gibi davranacaktır. Bu durumda, otomatik olarak iletilen veri kümesi olarak tanımlandığından, data = argümanını kullanmaya gerek olmadığını unutmayın.\nKodun söz dizimi aşağıdaki gibi görülebilir:\n\nlinelist %&gt;%                                                     # satır listesiyle başla\n  select(c(case_id, fever, chills, cough, aches, vomit)) %&gt;%     # sütunları seç\n  pivot_longer(                                                  # long formatına dönüştür\n    cols = -case_id,                                  \n    names_to = \"symptom_name\",\n    values_to = \"symptom_is_present\") %&gt;%\n  mutate(                                                        # eksik verileri düzenle\n    symptom_is_present = replace_na(symptom_is_present, \"unknown\")) %&gt;% \n  \n  ggplot(                                                        # ggplot'u başlat\n    mapping = aes(x = symptom_name, fill = symptom_is_present))+\n  geom_bar(position = \"fill\", col = \"black\") +                    \n  theme_classic() +\n  labs(\n    x = \"Symptom\",\n    y = \"Symptom status (proportion)\"\n  )",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.tr.html#sürekli-verilere-ait-grafikler",
    "href": "new_pages/ggplot_basics.tr.html#sürekli-verilere-ait-grafikler",
    "title": "30  ggplot temelleri",
    "section": "30.12 Sürekli verilere ait grafikler",
    "text": "30.12 Sürekli verilere ait grafikler\nBu sayfa boyunca, sürekli veri grafiklerine ait birçok örneği zaten gördünüz. Burada bunları kısaca tekrarlayıp birkaç varyasyonu paylaşacağız.\nBurada kapsanan görselleştirmeler aşağıda listelenmiştir:\n\nBir sürekli değişken için grafikler:\n\nHistogram, sürekli bir değişkenin dağılımını sunar\nKutu grafiği 25., 50. ve 75. yüzdelikleri, dağılımın uçlarını ve aykırı değerleri gösterir (önemli kısıtlamaları öğrenmek için linke tıklaın).\n\nJitter grafiği, tüm değerleri ‘titreyen’ noktalar olarak gösterir, böylece ikisi aynı değere sahip olsa bile (çoğunlukla) bütün noktalar görülebilir.\nViolin grafiği, ‘kemanın’ simetrik genişliğine dayalı sürekli bir değişkenin dağılımını gösterir\nSina grafiği, tek tek noktaları ve dağılımı simetrik şekilde (ggforce paketi aracılığıyla) gösterir. Jitter ve Violin grafiklerinin bir kombinasyonudur.\n\n\nİki sürekli değişken için Dağılım grafiği.\nÜç sürekli değişken için Isı grafikleri ([Isı grafikleri] sayfasına bağlantılı)\n\n\nHistogramlar\nHistogramlar çubuk grafikler gibi görünebilir, ancak farklıdır çünkü sürekli bir değişkenin dağılımını ölçerler. “Çubuklar” arasında boşluk yoktur ve geom_histogram() fonksiyonu için yalnızca bir sütun sağlanır.\nAşağıda, sürekli verileri aralık halinde gruplayan ve değişen yükseklikteki bitişik çubuklarda görüntüleyen histogram kodları paylaşılmıştır. Grafik çizimi, geom_histogram() kullanılarak yapılır. geom_histogram(), geom_bar() ve geom_col() arasındaki farkı anlamak için ggplot temelleri sayfasının “Çubuk grafiği” bölümüne bakabilirsiniz.\nAşağıdaki örnekte vakaların yaş dağılımını göstereceğiz. mapping = aes() argümanı içinde, dağılımını görmek istediğiniz sütunu tanımlamanız gerekmektedir. Bu sütunu x veya y eksenine atayabilirsiniz.\nSatırlar, sayısal yaşlarına göre “bin”lere atanacak ve bunlar, çubuklarla temsil edilecektir. bins = argümanıyla çubuk sayısını belirtirseniz, kırılma noktaları, histogramın minimum ve maksimum değerleri arasında eşit aralıklarla yerleştirilir. bins = argümanı belirtilmemişse, uygun sayıdaki bin değeri tahmin edilir ve çizimden sonra bu aşağıdaki mesaj görüntülenir:\n\n## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\nbins = için bir sayı belirtmek istemiyorsanız, alternatif olarak ilgili eksenin birimlerini binwidth = argümanıyla tanımlayabilirsiniz. Aşağıda farklı “bin” sayısı ve genişliklerini gösteren birkaç örnek veriyoruz:\n\n# A) Normal histogram\nggplot(data = linelist, aes(x = age))+  # x parametresi tanımla\n  geom_histogram()+\n  labs(title = \"A) Default histogram (30 bins)\")\n\n# B) Daha çok bin\nggplot(data = linelist, aes(x = age))+  # x parametresi tanımla\n  geom_histogram(bins = 50)+\n  labs(title = \"B) Set to 50 bins\")\n\n# C) Daha az \"bin\"\nggplot(data = linelist, aes(x = age))+  # x parametresi tanımla\n  geom_histogram(bins = 5)+\n  labs(title = \"C) Set to 5 bins\")\n\n# D) Çok bin\nggplot(data = linelist, aes(x = age))+  # x parametresi tanımla\n  geom_histogram(binwidth = 1)+\n  labs(title = \"D) binwidth of 1\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDüzleştirilmiş oranlar elde etmek için geom_density() fonksiyonunu kullanabilirsiniz:\n\n# Oran eksenli frekans, düzleştirilmiş\nggplot(data = linelist, mapping = aes(x = age)) +\n  geom_density(size = 2, alpha = 0.2)+\n  labs(title = \"Proportional density\")\n\n# Oran ekseni ile yığılmış frekans, düzleştirilmiş\nggplot(data = linelist, mapping = aes(x = age, fill = gender)) +\n  geom_density(size = 2, alpha = 0.2, position = \"stack\")+\n  labs(title = \"'Stacked' proportional densities\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n“Yığılmış” bir histogram (sürekli bir veri sütunundan) oluşturmak için aşağıdakilerden birini yapabilirsiniz:\n\n‘aes()’ fonksiyonu içindeki ‘fill =’ argümanına atanmış bir gruplandırma sütununu ‘geom_histogram()’ fonksiyonuyla birlikte kullanma,\nMuhtemelen okunması daha kolay olan geom_freqpoly() fonksiyonunu kullanma (binwidth = argümanını kullanmaya devam edebilirsiniz),\nTüm değerlerin oranlarını görmek için y = after_stat(yoğunluk) değerini ayarlama (bu sözdizimini tam olarak kullanın - verileriniz değişmedi). Not: grup başına oranları gösterecektir.\n\nHer bir seçenek aşağıda gösterilmiştir (*kodlardaki color = vs fill = kullanımına dikkat edin):\n\n# \"Yığılmış\" histogram\nggplot(data = linelist, mapping = aes(x = age, fill = gender)) +\n  geom_histogram(binwidth = 2)+\n  labs(title = \"'Stacked' histogram\")\n\n# Sıklık \nggplot(data = linelist, mapping = aes(x = age, color = gender)) +\n  geom_freqpoly(binwidth = 2, size = 2)+\n  labs(title = \"Freqpoly\")\n\n# Oran eksenli frekans\nggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), color = gender)) +\n  geom_freqpoly(binwidth = 5, size = 2)+\n  labs(title = \"Proportional freqpoly\")\n\n# Oran eksenli frekans, düzleştirilmiş\nggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), fill = gender)) +\n  geom_density(size = 2, alpha = 0.2)+\n  labs(title = \"Proportional, smoothed with geom_density()\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBiraz eğlenmek istiyorsanız, ggridges paketinden “geom_density_ridges”i deneyebilirsiniz .\ntidyverse geom_histogram() sayfasındaki histogramlar hakkında daha fazla bilgi edinebilirsiniz.\n\n\nÇubuk grafikleri\nÇubuk grafikleri yaygındır, ancak önemli kısıtlamalara sahiptir. İlk olarak gerçek dağılımı gizleyebilirler - ör. iki modlu bir dağıtım. Detaylı bilgi için R grafiği galerisine ve bu data-to-viz makalesine bakabilirsiniz. Bununla birlikte, çeyrekler arasındaki mesafeyi ve aykırı değerleri güzel bir şekilde gösterirler - böylece dağılımı daha ayrıntılı gösteren diğer grafik türlerinin üzerine eklenebilirler.\nAşağıda size bir kutu grafiğinin çeşitli bileşenlerini hatırlatıyoruz:\n\n\n\n\n\n\n\n\n\nBir çubuk grafiği oluşturmak için geom_boxplot() fonksiyonunu kullanırken, genellikle aes() içinde yalnızca bir ekseni (x veya y) eşlersiniz. Tanımlanan eksen, grafiklerin yatay mı yoksa dikey mi olduğunu belirler.\nÇoğu geomlarda, color = veya fill = gibi bir estetiği aes() içindeki bir sütuna eşleyerek grup başına bir çizim oluşturursunuz. Bununla birlikte, çubuk grafiğinde sütunu boş bir eksene (x veya y) atayarak elde edebilirsiniz. Aşağıda, kod örneklerinin ilkinde tüm yaş değerlerinin çubuk grafiği kodlanmıştır. İkincisinde ise veri kümesindeki her (eksik olmayan) cinsiyet için bir çubuk grafiği kodlanmıştır. Kaldırılmadığı sürece NA (eksik) değerlerin ayrı bir kutu grafiği olarak görüneceğini unutmayın. Bu örnekte, her grafiğin farklı bir renk olması için outcome sütununa farklı bir fill argümanı tanımladık - ancak rutinde bu gerekli değildir.\n\n# A) Genel yaş grafiği\nggplot(data = linelist)+  \n  geom_boxplot(mapping = aes(y = age))+   # only y axis mapped (not x)\n  labs(title = \"A) Overall boxplot\")\n\n# B) Cinsiyete göre çubuk grafiği\nggplot(data = linelist, mapping = aes(y = age, x = gender, fill = gender)) + \n  geom_boxplot()+                     \n  theme(legend.position = \"none\")+   # remove legend (redundant)\n  labs(title = \"B) Boxplot by gender\")      \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBir dağılım grafiğinin (“marjinal” grafikler) kenarına kutu grafiği eklemenin nasıl yapıldığını görmek için [ggplot ipuçları] sayfasına bakabilirsiniz.\n\n\nViolin, jitter ve sina grafikleri\nAşağıda, dağılımları göstermek için violin (geom_violin) ve jitter grafiklerinin (geom_jitter) nasıl kodlandığı gösterilmiştir. Bu seçenekleri aes() içine ekleyerek dolgu veya rengin de veriler tarafından belirlenmesini sağlayabilirsiniz.\n\n# A) Jitter grafiği\nggplot(data = linelist %&gt;% drop_na(outcome),      # Eksik değerleri kaldır\n       mapping = aes(y = age,                     # Sürekli değişken\n           x = outcome,                           # Gruplama değişkeni\n           color = outcome))+                     # Renk değişkeni\n  geom_jitter()+                                  # Jitter grafiği oluştur\n  labs(title = \"A) jitter plot by gender\")     \n\n\n\n# B) Violin grafiği\nggplot(data = linelist %&gt;% drop_na(outcome),       # Eksik değerleri kaldır\n       mapping = aes(y = age,                      # Sürekli değişken\n           x = outcome,                            # Gruplama değişkeni\n           fill = outcome))+                       # Dolgu değişkeni (renk)\n  geom_violin()+                                   # Violin grafiği oluştur\n  labs(title = \"B) violin plot by gender\")    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggforce paketindeki geom_sina() fonksiyonunu kullanarak iki grafiği birleştirebilirsiniz. Sina, jitter noktalarını violin grafiği şeklinde çizer. Violin grafiği üzerine eklendiğinde (şeffaflığı düzenlenerek), oluşan yeni grafiğin görsel olarak yorumlanması daha kolay olabilir.\n\n# A) Sina grafiği\nggplot(\n  data = linelist %&gt;% drop_na(outcome), \n  aes(y = age,           # numerik değişken\n      x = outcome)) +    # grup değişkeni\n  geom_violin(\n    aes(fill = outcome), # dolgu (violin grafiğinin arka planının rengi)\n    color = \"white\",     # beyaz anahat\n    alpha = 0.2)+        # şefaflık\n  geom_sina(\n    size=1,                # jitter noktalarının boyutunu değiştir\n    aes(color = outcome))+ # renk (noktaların rengi)\n  scale_fill_manual(       # Death/recovery violin grafiği arka planı için dolguyu tanımla\n    values = c(\"Death\" = \"#bf5300\", \n              \"Recover\" = \"#11118c\")) + \n  scale_color_manual(      # death/recover noktaları için renkleri tanımla\n    values = c(\"Death\" = \"#bf5300\", \n              \"Recover\" = \"#11118c\")) + \n  theme_minimal() +                                # Gri arka planı kaldır\n  theme(legend.position = \"none\") +                # Gereksiz açıklamayı kaldır\n  labs(title = \"B) violin and sina plot by gender, with extra formatting\")      \n\n\n\n\n\n\n\n\n\n\nİki sürekli değişken\nBenzer sözdizimini takip ederek, geom_point(), bir dağılım grafiğinde iki sürekli değişkeni birbirine karşı çizmenize izin verir. Bu, dağılımlarından ziyade gerçek değerleri göstermek için kullanışlıdır. Yaş ve kilonun temel bir dağılım grafiği (A)’da gösterilmektedir. (B)’de, satır listesindeki iki sürekli değişken arasındaki ilişkiyi göstermek için yine facet_grid() fonksiyonunu kullanıyoruz.\n\n# Ağırlık ve yaşın temel dağılım grafiği\nggplot(data = linelist, \n       mapping = aes(y = wt_kg, x = age))+\n  geom_point() +\n  labs(title = \"A) Scatter plot of weight and age\")\n\n# Cinsiyete ve Ebola sonucuna göre ağırlık ve yaş dağılım grafiği\nggplot(data = linelist %&gt;% drop_na(gender, outcome), # filtre eksik olmayan cinsiyeti/sonucu korur\n       mapping = aes(y = wt_kg, x = age))+\n  geom_point() +\n  labs(title = \"B) Scatter plot of weight and age faceted by gender and outcome\")+\n  facet_grid(gender ~ outcome) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nÜç sürekli değişken\nBir ısı grafiği oluşturmak için fill = argümanını kullanarak üç sürekli değişkeni görüntüleyebilirsiniz. Her “hücrenin” rengi, üçüncü sürekli veri sütununun değerini yansıtacaktır. Daha fazla ayrıntı ve birkaç örnek için [ggplot ipuçları] ve [Isı grafikleri] hakkındaki sayfaya bakabilirsiniz.\nR’da 3D grafikler oluşturmanın yolları vardır, ancak uygulamalı epidemiyoloji için bunların yorumlanması genellikle zordur ve bu nedenle karar verme süreçlerinde daha az kullanılırlar.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.tr.html#kategorik-verilere-ait-grafikler",
    "href": "new_pages/ggplot_basics.tr.html#kategorik-verilere-ait-grafikler",
    "title": "30  ggplot temelleri",
    "section": "30.13 Kategorik verilere ait grafikler",
    "text": "30.13 Kategorik verilere ait grafikler\nKategorik veriler karakter değerleri, mantıksal (DOĞRU/YANLIŞ) veya faktör olabilir ([Faktörler] sayfasına bakınız).\n\nHazırlık\n\nVeri yapısı\nKategorik verileriniz hakkında anlamanız gereken ilk şey, verilerin bir satır listesi gibi ham gözlemler olarak mı yoksa sayıları veya oranları tutan bir özet veya toplu veri çerçevesi olarak mı var olduğudur. Verilerinizin durumu, kullandığınız çizim fonksiyonunu etkiler:\n\nVerileriniz gözlem başına bir satır içeren ham gözlemlerse, büyük olasılıkla geom_bar() fonksiyonunu kullanacaksınız.\nVerileriniz zaten sayılar veya oranlar halinde toplanmışsa, büyük olasılıkla ‘geom_col()’ fonksiyonunu kullanacaksınız.\n\n\n\nSütun sınıfı ve değer sıralaması\nBu aşamadan sonra, çizmek istediğiniz sütunların sınıfını incelemelisiniz. Önce R tabanından class() ve janitor paketinden tabyl() fonksiyonuyla hospital sütununa bakıyoruz.\n\n# Hastane sütununun sınıfını görüntüleyin - bunun bir karakter olduğunu görebiliriz\nclass(linelist$hospital)\n\n[1] \"character\"\n\n# Hastane sütunundaki değerlere ve oranlara bakın\nlinelist %&gt;% \n  tabyl(hospital)\n\n                             hospital    n    percent\n                     Central Hospital  454 0.07710598\n                    Military Hospital  896 0.15217391\n                              Missing 1469 0.24949049\n                                Other  885 0.15030571\n                        Port Hospital 1762 0.29925272\n St. Mark's Maternity Hospital (SMMH)  422 0.07167120\n\n\nHastane adları olduğu ve varsayılan olarak alfabetik olarak sıralandığı için içindeki değerlerin karakter olduğunu görebiliriz. Kırılımları sunarken en son sırada olmasını tercih edeceğimiz ‘Other’ ve ‘Missing’ değerleri de mevcuttur. Bu yüzden bu sütunu bir faktöre değiştirip yeniden sıralıyoruz. Konu, [Faktörler] sayfasında daha ayrıntılı olarak ele alınmaktadır.\n\n# Faktöre dönüştürün ve seviye sırasını \"Other\" ve \"Missing\" en son olacak şekilde tanımlayın\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    hospital = fct_relevel(hospital, \n      \"St. Mark's Maternity Hospital (SMMH)\",\n      \"Port Hospital\", \n      \"Central Hospital\",\n      \"Military Hospital\",\n      \"Other\",\n      \"Missing\"))\n\n\nlevels(linelist$hospital)\n\n[1] \"St. Mark's Maternity Hospital (SMMH)\"\n[2] \"Port Hospital\"                       \n[3] \"Central Hospital\"                    \n[4] \"Military Hospital\"                   \n[5] \"Other\"                               \n[6] \"Missing\"                             \n\n\n\n\n\ngeom_bar()\nÇubuk yüksekliğinin (veya yığılmış çubuk bileşenlerinin yüksekliğinin) verilerdeki ilgili satırların sayısını yansıtmasını istiyorsanız, geom_bar() fonksiyonunu kullanmalısınız. width = çizim estetiği ayarlanmadığı sürece, bu çubukların aralarında boşluklar olacaktır.\n\nYalnızca bir eksene sütun atayın (tipik olarak x ekseni). x ve y eksenlerinin her ikisine de sütun tanımlarsanız, Error: stat_count() can only have an x or y aesthetic. hatasını alırsınız.\nmapping = aes() içinde bir fill = argümanına sütun ekleyerek yığılmış çubuk grafiği oluşturabilirsiniz.\nKarşı eksen, satır sayısını temsil ettiği için varsayılan olarak “count” olarak adlandırılacaktır.\n\nAşağıda, sonucu y eksenine atadık, ancak bu aynı kolaylıkla x ekseni de olabilirdi. Daha uzun karakter değerleriniz varsa, bazen çubukları yana çevirip açıklamayı en alta koymak iyi bir seçenek olabilir. Bu, faktör seviyelerinizin nasıl sıralandığını etkileyebilir - bu durumda, “missing” ve “other” değerlerini en alta koymak için sıralamayı fct_rev() ile tersine çeviriyoruz.\n\n# A) Tüm vakaların çıktıları\nggplot(linelist %&gt;% drop_na(outcome)) + \n  geom_bar(aes(y = fct_rev(hospital)), width = 0.7) +\n  theme_minimal()+\n  labs(title = \"A) Number of cases by hospital\",\n       y = \"Hospital\")\n\n\n# B) Tüm vakaların hastaneye göre çıktıları\nggplot(linelist %&gt;% drop_na(outcome)) + \n  geom_bar(aes(y = fct_rev(hospital), fill = outcome), width = 0.7) +\n  theme_minimal()+\n  theme(legend.position = \"bottom\") +\n  labs(title = \"B) Number of recovered and dead Ebola cases, by hospital\",\n       y = \"Hospital\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngeom_col()\nÇubuk yüksekliğinin (veya yığılmış çubuk bileşenlerinin yüksekliğinin) verilerde bulunan önceden hesaplanmış değerleri yansıtmasını istiyorsanız, geom_col() fonksiyonunu kullanmalısınız. Bunlar genellikle özet, “toplanmış” sayılar veya oranlardır.\ngeom_col() fonksiyonunda her iki eksen için de sütun atamalısınız. Tipik olarak x ekseni sütununuz ayrık verilerden oluşurken y ekseni sütununuz sayısaldır.\nDiyelim ki outcomes veri setimiz var:\n\n\n# A tibble: 2 × 3\n  outcome     n proportion\n  &lt;chr&gt;   &lt;int&gt;      &lt;dbl&gt;\n1 Death    1022       56.2\n2 Recover   796       43.8\n\n\nAşağıda, Ebola hasta sonuçlarının dağılımını gösteren basit bir çubuk grafiği oluşturmak için geom_col fonksiyonu kullanılmıştır. geom_col fonksiyonunda hem x hem de y tanımlanmalıdır. Burada x kategorik değişkendir ve y “oran”dır.\n\n# Tüm vakaların çıktıları\nggplot(outcomes) + \n  geom_col(aes(x=outcome, y = proportion)) +\n  labs(subtitle = \"Number of recovered and dead Ebola cases\")\n\n\n\n\n\n\n\n\nHastanelere göre dağılımları göstermek için tablomuzun daha fazla bilgi içermesi ve “long” formatında olması gerekir. Bu tabloyu outcome ve hospital birleşik kategorilerinin frekanslarıyla oluşturuyoruz (gruplandırma ipuçları için [Gruplama verileri] sayfasına bakabilirsiniz).\n\noutcomes2 &lt;- linelist %&gt;% \n  drop_na(outcome) %&gt;% \n  count(hospital, outcome) %&gt;%  # hastaneye ve sonuca göre sayımları al\n  group_by(hospital) %&gt;%        # Oranlar hastane toplamı dışında olacak şekilde gruplandır\n  mutate(proportion = n/sum(n)*100) # hastane toplamının oranlarını hesapla\n\nhead(outcomes2) # verili göster\n\n# A tibble: 6 × 4\n# Groups:   hospital [3]\n  hospital                             outcome     n proportion\n  &lt;fct&gt;                                &lt;chr&gt;   &lt;int&gt;      &lt;dbl&gt;\n1 St. Mark's Maternity Hospital (SMMH) Death     199       61.2\n2 St. Mark's Maternity Hospital (SMMH) Recover   126       38.8\n3 Port Hospital                        Death     785       57.6\n4 Port Hospital                        Recover   579       42.4\n5 Central Hospital                     Death     193       53.9\n6 Central Hospital                     Recover   165       46.1\n\n\nDaha sonra bazı ek biçimlendirmelerle ggplot’u oluştururuz:\n\nAxis flip: Hastane isimlerini okuyabilmemiz için ekseni coord_flip() fonksiyonu ile değiştirdik.\nColumns side-by-side: Ölüm ve iyileşme çubuklarının yığılması yerine yan yana sunulması için bir position = \"dodge\" argümanı eklendi. Not yığılmış çubuklar varsayılandır.\nColumn width: ‘Genişlik’ tanımlanır, bu nedenle sütunlar mümkün olan tam genişliğin yarısı kadar incelir.\nColumn order: ‘Other’ ve ‘Missing’ altta olacak şekilde, scale_x_discrete(limits=rev) ile kategorilerin sırasını y ekseninde tersine çevrildi. scale_y_discrete yerine x kullandığımıza dikkat edin, çünkü hastane aes()’in x argümanında tanımlanmıştır. (görsel olarak y ekseninde olsa bile). Bunu yapıyoruz çünkü Ggplot, biz tersini söylemedikçe kategorileri geriye doğru sıralamaktadır.\nOther details: Sırasıyla labs ve scale_fill_color argümanları içine eklenen etiket/başlık ve renkler.\n\n\n# Tüm vakaların hastaneye göre çıktıları\nggplot(outcomes2) +  \n  geom_col(\n    mapping = aes(\n      x = proportion,                 # önceden hesaplanmış orantı değerlerini göster\n      y = fct_rev(hospital),          # missing/other altta kalması için ters çevir\n      fill = outcome),                # sonuca göre yığılmış\n    width = 0.5)+                    # daha ince çubuklar (max: 1)\n  theme_minimal() +                  # Minimal tema \n  theme(legend.position = \"bottom\")+\n  labs(subtitle = \"Number of recovered and dead Ebola cases, by hospital\",\n       fill = \"Outcome\",             # açıklama başlığı\n       y = \"Count\",                  # y ekseni başlığı\n       x = \"Hospital of admission\")+ # x ekseni başlığı\n  scale_fill_manual(                 # renkleri manuel ekle\n    values = c(\"Death\"= \"#3B1c8C\",\n               \"Recover\" = \"#21908D\" )) \n\n\n\n\n\n\n\n\nOranların ikili olduğuna dikkat edin, bu nedenle ‘recover’ verilerini bırakıp sadece ölen oranını göstermeyi tercih edebiliriz. Bu sadece örnekleme amaçlıdır.\nTarih verilerinde geom_col() fonksiyonunu kullanıyorsanız (örneğin, toplu verilerden bir dış eğri) - çubuklar arasındaki “boşluğu” kaldırmak için width = argümanını ayarlamalısınız. Günlük veri seti kullanılıyorsa width = 1. Haftalık ise, width = 7. Ayların düzgün bir şekilde gösterilmesi mümkün değildir çünkü her ayın gün sayısı bir diğerinden farklıdır.\n\n\ngeom_histogram()\nHistogramlar çubuk grafikler gibi görünebilir, ancak farklıdır çünkü sürekli bir değişkenin dağılımını ölçerler. “Çubuklar” arasında boşluk yoktur ve geom_histogram() fonksiyonu için yalnızca bir sütun gerekir. Verilerin nasıl gruplanacağını belirtmek için bin_width = ve breaks = gibi histograma özgü argümanlar vardır. Yukarıdaki sürekli verilerle ilgili bölüm ve [Salgın eğrileri] sayfasaında daha detaylı bilgi bulabilirsiniz.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.tr.html#kaynaklar",
    "href": "new_pages/ggplot_basics.tr.html#kaynaklar",
    "title": "30  ggplot temelleri",
    "section": "30.14 Kaynaklar",
    "text": "30.14 Kaynaklar\nÖzellikle ggplot ile ilgili çevrimiçi olarak çok miktarda kaynak mevcuttur. Bunlardan bazıları:\n\nggplot2 kopya kağıdı\nbaşka bir kopya kağıdı\ntidyverse ggplot temelleri sayfası\n\nsürekli değişkenleri çizmek\n\nVeri Bilimi için R’da veri görselleştirme bölümü\niletişim için grafikler",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot temelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.tr.html",
    "href": "new_pages/ggplot_tips.tr.html",
    "title": "31  ggplot ipuçları",
    "section": "",
    "text": "31.1 Hazırlık",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>ggplot ipuçları</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.tr.html#hazırlık",
    "href": "new_pages/ggplot_tips.tr.html#hazırlık",
    "title": "31  ggplot ipuçları",
    "section": "",
    "text": "Paketleri yükleme\nBu kod parçası, analizler için gereken paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan ‘p_load()’ vurgusunu yapıyoruz. R tabanından library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakabilirsiniz.\n\npacman::p_load(\n  tidyverse,      # ggplot2 ve diğerlerini içerir\n  rio,            # içe / dışa aktar\n  here,           # dosyayı bul\n  stringr,        # karakterlerle çalışmak   \n  scales,         # sayıları çevirmek\n  ggrepel,        # akıllıca yerleştirilmiş etiketler\n  gghighlight,    # arsanın bir bölümünü vurgula\n  RColorBrewer    # renk skalaları\n)\n\n\n\nVerileri içe aktarma\nBu sayfa için, simüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Takip etmek isterseniz, “clean” dosyasını indirmek için tıklayın. (.rds dosyası olarak). rio paketinden import() fonksiyonuyla verileri içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakabilirsiniz).\n\nlinelist &lt;- rio::import(\"linelist_cleaned.rds\")\n\nSatır listesinin ilk 50 satırı aşağıda görüntülenir.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>ggplot ipuçları</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.tr.html#ggplot_tips_colors",
    "href": "new_pages/ggplot_tips.tr.html#ggplot_tips_colors",
    "title": "31  ggplot ipuçları",
    "section": "31.2 Renk, dolgu, eksen vb. için ölçekler",
    "text": "31.2 Renk, dolgu, eksen vb. için ölçekler\nggplot2’de, çizilen verilerin estetiği (ör. boyut, renk, şekil, dolgu, çizim ekseni) verilerdeki sütunlarla eşlendiğinde, tam görüntü ilgili “ölçek” komutuyla ayarlanabilir. Bu bölümde bazı yaygın ölçek ayarlamalarını açıklıyoruz.\n\n31.2.1 Renk şemaları\nggplot2 ile başlangıçta anlaşılması zor olabilecek bir şey, renk şemalarının kontrolüdür. Bu bölümün noktalar, çubuklar, çizgiler, döşemeler vb. çizim nesnelerinin (geomlar/şekiller) rengini tartıştığını unutmayın. Aksesuar metninin, başlıkların veya arka plan renginin rengini ayarlamak için [ggplot temelleri] sayfasının bölümü olan Temalar bölümüne bakınız.\nArsa nesnelerinin “rengini” kontrol etmek için, ya renk = estetiğini (dış renk) ya da dolgu = estetiğini (iç renk) ayarlayacaksınız. Bu modelin bir istisnası, gerçekten yalnızca noktanın rengini (iç ve dış) kontrol eden ‘color =’ öğesini kontrol edebileceğiniz ‘geom_point()’ fonksiyonudur.\nRenk veya dolguyu ayarlarken “kırmızı” gibi R tarafından tanınan renk adlarını kullanabilir (bkz. tam liste veya ?colors) veya “#ff0505”` gibi belirli bir onaltılık renkler kullanılabilir.\n\n# histogram - \nggplot(data = linelist, mapping = aes(x = age))+       # veri ve eksenleri ayarla\n  geom_histogram(                # histogram göster\n    binwidth = 7,                # kutu genişliği\n    color = \"red\",               # kutu çizgi rengi\n    fill = \"lightblue\")          # kutu iç rengi (dolgu) \n\n\n\n\n\n\n\n\n[Gggplot temelleri] bölümünde verileri çizime eşleme ile ilgili olarak açıklandığı gibi, ‘fill =’ ve ‘color =’ gibi estetikler bir ‘mapping = aes()’ ifadesinin dışında veya birinin içinde tanımlanabilir. “aes()” * dışında* ise, atanan değer statik olmalıdır (ör. ‘color= “mavi”’) ve geom tarafından çizilen tüm veriler için geçerli olacaktır. içeride ise, estetik, ‘renk = hastane”’ gibi bir sütuna eşlenmelidir ve ifade, verilerdeki o satırın değerine göre değişecektir. Birkaç örnek:\n\n# Noktalar ve çizgi için statik renk\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     \n  geom_point(color = \"purple\")+\n  geom_vline(xintercept = 50, color = \"orange\")+\n  labs(title = \"Static color for points and line\")\n\n# Sürekli sütuna eşlenen renk\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     \n  geom_point(mapping = aes(color = temp))+         \n  labs(title = \"Color mapped to continuous column\")\n\n# Ayrık sütuna eşlenen renk\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     \n  geom_point(mapping = aes(color = gender))+         \n  labs(title = \"Color mapped to discrete column\")\n\n# çubuk grafiği, ayrı sütuna doldur, statik değere renk\nggplot(data = linelist, mapping = aes(x = hospital))+     \n  geom_bar(mapping = aes(fill = gender), color = \"yellow\")+         \n  labs(title = \"Fill mapped to discrete column, static color\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nÖlçekler\nBir sütunu bir çizim estetiğine eşlediğinizde (örneğin, x =, y =, fill =, color =…), grafiğiniz bir ölçek/lejand kazanacaktır. Yukarıda, atanan sütunun sınıfına bağlı olarak ölçeğin sürekli, ayrık, tarih vb. değerlerinin nasıl olabileceğini görün. Sütunlara eşlenmiş birden fazla estetiğiniz varsa, arsanızın birden çok ölçeği olacaktır.\nUygun scales_() fonksiyonu ile terazileri kontrol edebilirsiniz. ggplot()’un ölçek fonksiyonlarının şu şekilde yazılmış 3 bölümü vardır: scale_AESTHETIC_METHOD().\n\nİlk kısım olan scale_() düzeltildi.\nİkinci kısım olan ESTETİK, ölçeği ayarlamak istediğiniz estetik olmalıdır (_fill_, _shape_, _color_, _size_, _alpha_…) - buradaki seçenekler de ‘x’ ve ‘y’ içerir.\nÜçüncü kısım olan YÖNTEM, sütunun sınıfına ve nasıl kontrol etmek istediğine bağlı olarak _discrete(), continuous(), _date(), _gradient() veya _manual() olacaktır. Başkaları da var, ancak bunlar en sık kullanılanlardır.\n\nTartı için doğru işlevi kullandığınızdan emin olun! Aksi takdirde, ölçek komutunuz hiçbir şeyi değiştirmiş gibi görünmeyecektir. Birden fazla teraziniz varsa, bunları ayarlamak için birden fazla terazi işlevi kullanabilirsiniz! Örneğin:\n\n\nÖlçek değişkenleri\nBazı örtüşmeler olsa da, her tür ölçeğin kendi değişkenleri vardır. Fonksiyon değişkeni belgelerini görmek için R konsolunda ?scale_color_discrete gibi fonksiyonu sorgulayabilirsiniz.\nSürekli ölçekler için, ‘seq()’ ile bir değerler dizisi sağlamak için ‘breaks =’ kullanın (aşağıdaki örnekte gösterildiği gibi ‘to =’, ‘from =’ ve ‘by =’ alın. Eksenlerin etrafındaki dolgu alanını ortadan kaldırmak için “expand= c(0,0)” değerini ayarlayın (bu herhangi bir “x” veya “y” ölçeğinde kullanılabilir.\nAyrık ölçekler için, seviye görünümünün sırasını breaks = ile ve değerlerin nasıl görüntüleneceğini labels = değişkeniyle ayarlayabilirsiniz. Bunların her birine bir karakter vektörü sağlayın (aşağıdaki örneğe bakın). Ayrıca, “na.translate = FALSE” ayarını yaparak “NA”yı kolayca bırakabilirsiniz.\nTarih ölçeklerinin nüansları, [Salgın eğrileri] sayfasında daha kapsamlı bir şekilde ele alınmaktadır.\n\n\nManuel ayarlamalar\nEn kullanışlı püf noktalardan biri, renkleri açıkça istediğiniz gibi atamak için “manuel” ölçekleme fonksiyonlarını kullanmaktır. Bunlar, “scale_xxx_manual()” sözdizimine sahiptir(ör. “scale_colour_manual()” veya “scale_fill_manual()”). Aşağıdaki bağımsız değişkenlerin her biri aşağıdaki kod örneğinde gösterilmiştir.\n\nvalues = değişkeniyle veri değerlerine renkler atayın\n‘NA’ için ‘na.value =’ ile bir renk belirtin\nGöstergede değerlerin nasıl yazılacağını labels = değişkeni ile değiştirin\nGösterge başlığını name = ile değiştirin\n\nAşağıda, bir çubuk grafiği oluşturuyoruz ve varsayılan olarak nasıl göründüğünü gösteriyoruz ve ardından üç ölçek ayarlıyoruz - sürekli y ekseni ölçeği, ayrık x ekseni ölçeği ve dolgunun manuel olarak ayarlanması (iç çubuk rengi).\n\n# TEMEL - ölçek ayarı yok\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = outcome, fill = gender))+\n  labs(title = \"Baseline - no scale adjustments\")\n\n\n\n\n\n\n\n# AYARLANAN ÖLÇEKLER\nggplot(data = linelist)+\n  \n  geom_bar(mapping = aes(x = outcome, fill = gender), color = \"black\")+\n  \n  theme_minimal()+                   # arka planı basitleştir\n  \n  scale_y_continuous(                # y ekseni için sürekli ölçek (sayılar)\n    expand = c(0,0),                 # dolgu yok\n    breaks = seq(from = 0,\n                 to = 3000,\n                 by = 500))+\n  \n  scale_x_discrete(                   # x ekseni için ayrık ölçek (cinsiyet)\n    expand = c(0,0),                  # dolgu yok\n    drop = FALSE,                     # tüm faktör seviyelerini göster (verilerde olmasa bile)\n    na.translate = FALSE,             # Boş sonuçlarını grafikten kaldır\n    labels = c(\"Died\", \"Recovered\"))+ # Değerlerin gösterimini değiştir\n    \n  \n  scale_fill_manual(                  # Dolguyu manuel olarak belirtin (çubuk iç rengi)\n    values = c(\"m\" = \"violetred\",     # renk atamak için verilerdeki referans değerleri\n               \"f\" = \"aquamarine\"),\n    labels = c(\"m\" = \"Male\",          # lejandı yeniden etiketleyin (hataları önlemek için \"=\" atamasını kullanın)\n              \"f\" = \"Female\",\n              \"Missing\"),\n    name = \"Gender\",                  # lejand başlığı\n    na.value = \"grey\"                 # eksik değerler için bir renk atama\n  )+\n  labs(title = \"Adjustment of scales\") # Doldurma açıklamasının başlığını ayarlayın\n\n\n\n\n\n\n\n\n\n\nSürekli eksen ölçekleri\nVeriler çizim eksenlerine eşlendiğinde, bunlar da ölçek komutlarıyla ayarlanabilir. Yaygın bir örnek, sürekli veriler içeren bir sütuna eşlenen bir eksenin (ör. y ekseni) görüntüsünü ayarlamaktır.\nscale_y_continuous() kullanarak ggplot’taki değerlerin kesintilerini veya gösterimini ayarlamak isteyebiliriz. Yukarıda belirtildiği gibi, ölçek boyunca “kesmeler” olarak hizmet edecek bir değerler dizisi sağlamak için “kesmeler =” bağımsız değişkenini kullanın. Bunlar sayıların görüntüleneceği değerlerdir. Bu bağımsız değişkene, istenen kesme değerlerini içeren bir “c()” vektörü sağlayabilir veya R tabanı fonksiyonu “seq()” kullanarak düzenli bir sayı dizisi sağlayabilirsiniz. Bu ‘seq()’ fonksiyonu ‘to =’, ‘from =’ ve ‘by =’ kabul eder.\n\n# TEMEL - ölçek ayarı yok\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = outcome, fill = gender))+\n  labs(title = \"Baseline - no scale adjustments\")\n\n\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = outcome, fill = gender))+\n  scale_y_continuous(\n    breaks = seq(\n      from = 0,\n      to = 3000,\n      by = 100)\n  )+\n  labs(title = \"Adjusted y-axis breaks\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYüzdeleri göster\nOrijinal veri değerleriniz oranlarsa, aşağıda gösterildiği gibi ölçekler komutunuzda labels = scales::percent sağlayarak bunları kolayca “%” ile yüzdeler olarak görüntüleyebilirsiniz.\nBir alternatif, değerleri karaktere dönüştürmek ve sona “%” karakteri eklemek olsa da, verileriniz artık sürekli sayısal değerler olmayacağından bu yaklaşım sorunlara yol açacaktır.\n\n# Orjinal y ekseni oranları\n#############################\nlinelist %&gt;%                                   # satır listesi ile başlama\n  group_by(hospital) %&gt;%                       # veriyi hastaneye göre gruplandırma\n  summarise(                                   # özet kolonlar oluşturma\n    n = n(),                                     # gruptaki toplam satır sayısı\n    deaths = sum(outcome == \"Death\", na.rm=T),   # gruptaki ölüm sayısı\n    prop_death = deaths/n) %&gt;%                   # gruptaki ölüm oranı\n  ggplot(                                      # çizime başlama\n    mapping = aes(\n      x = hospital,\n      y = prop_death))+ \n  geom_col()+\n  theme_minimal()+\n  labs(title = \"Display y-axis original proportions\")\n\n\n\n# Y ekseni oranlarını yüzdelik olarak gösterme\n########################################\nlinelist %&gt;%         \n  group_by(hospital) %&gt;% \n  summarise(\n    n = n(),\n    deaths = sum(outcome == \"Death\", na.rm=T),\n    prop_death = deaths/n) %&gt;% \n  ggplot(\n    mapping = aes(\n      x = hospital,\n      y = prop_death))+\n  geom_col()+\n  theme_minimal()+\n  labs(title = \"Display y-axis as percents (%)\")+\n  scale_y_continuous(\n    labels = scales::percent                   \n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLogaritmik ölçeği\nSürekli bir ekseni logaritmik ölçeğine dönüştürmek için, ölçek komutuna trans = \"log2\" ekleyin. Örnek olarak, ilgili ‘preparedness_index’ ve kümülatif vaka değerleri ile bölgelerin bir veri çerçevesini oluşturuyoruz.\n\nplot_data &lt;- data.frame(\n  region = c(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\"),\n  preparedness_index = c(8.8, 7.5, 3.4, 3.6, 2.1, 7.9, 7.0, 5.6, 1.0),\n  cases_cumulative = c(15, 45, 80, 20, 21, 7, 51, 30, 1442)\n)\n\nplot_data\n\n  region preparedness_index cases_cumulative\n1      A                8.8               15\n2      B                7.5               45\n3      C                3.4               80\n4      D                3.6               20\n5      E                2.1               21\n6      F                7.9                7\n7      G                7.0               51\n8      H                5.6               30\n9      I                1.0             1442\n\n\n“I” bölgesi için kümülatif vakalar, diğer tüm bölgelerden çarpıcı biçimde daha fazladır. Bunun gibi durumlarda, okuyucunun daha az kümülatif vaka ile bölgeler arasındaki farklılıkları görebilmesi için bir logaritmik ölçeği kullanarak y eksenini görüntülemeyi seçebilirsiniz.\n\n# Orijinal y ekseni\npreparedness_plot &lt;- ggplot(data = plot_data,  \n       mapping = aes(\n         x = preparedness_index,\n         y = cases_cumulative))+\n  geom_point(size = 2)+            # her bölgeye nokta \n  geom_text(\n    mapping = aes(label = region),\n    vjust = 1.5)+                  # yazı etiketleri ekleme\n  theme_minimal()\n\npreparedness_plot                  # orijinal grafiği yazdıe\n\n\n# dönüştürülmüş y ekseni ile yazdır\npreparedness_plot+                   # yukarıda kaydedilen grafik ile başlayın\n  scale_y_continuous(trans = \"log2\") # y ekseni için dönüşüm ekle\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGradyan ölçekleri\nDolgu gradyan ölçekleri ek nüanslar içerebilir. Varsayılanlar genellikle oldukça hoştur, ancak değerleri, kesmeleri vb. ayarlamak isteyebilirsiniz.\nSürekli bir renk skalasının nasıl ayarlanacağını göstermek için, vakaların yaşlarını ve kaynak vakalarını içeren [Temaslı izlemi] sayfasından bir veri seti kullanacağız.\n\ncase_source_relationships &lt;- rio::import(here::here(\"data\", \"godata\", \"relationships_clean.rds\")) %&gt;% \n  select(source_age, target_age) \n\nAşağıda, bir “hücresel” ısı karosu yoğunluk grafiği üretiyoruz. Nasıl olduğunu detaylandırmayacağız (yukarıdaki paragraftaki bağlantıya bakabilirsiniz) ancak renk skalasını nasıl ayarlayabileceğimize odaklanacağız. stat_density2d() ggplot2 fonksiyonu hakkında buradan daha fazla bilgi edinebilirsiniz. fill ölçeğinin nasıl sürekli olduğuna dikkat edin.\n\ntrans_matrix &lt;- ggplot(\n    data = case_source_relationships,\n    mapping = aes(x = source_age, y = target_age))+\n  stat_density2d(\n    geom = \"raster\",\n    mapping = aes(fill = after_stat(density)),\n    contour = FALSE)+\n  theme_minimal()\n\nŞimdi doldurma ölçeğinde bazı varyasyonlar gösteriyoruz:\n\ntrans_matrix\ntrans_matrix + scale_fill_viridis_c(option = \"plasma\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nŞimdi ölçeğin kırılma noktalarını ayarlamanın bazı örneklerini gösteriyoruz:\n\nscale_fill_gradient() iki rengi kabul eder (yüksek/düşük)\nscale_fill_gradientn() herhangi bir uzunluktaki bir renk vektörünü “değerler =” olarak kabul eder (ara değerler eklemlenmiş olacaktır)\nscales::rescale() renklerin gradyan boyunca nasıl konumlandırılacağını ayarlamak için kullanılır. Konum vektörünüzü 0 ile 1 arasında olacak şekilde yeniden ölçeklendirir.\n\n\ntrans_matrix + \n  scale_fill_gradient(     # Çift taraflı gradyan ölçeği\n    low = \"aquamarine\",    # düşük değer\n    high = \"purple\",       # yüksek değer\n    na.value = \"grey\",     # Boş için değer\n    name = \"Density\")+     # Lejand Başlığı\n  labs(title = \"Manually specify high/low colors\")\n\n# Ölçeklendirmek 3+ renk\ntrans_matrix + \n  scale_fill_gradientn(    # 3 renkli ölçek (low/mid/high)\n    colors = c(\"blue\", \"yellow\",\"red\") # y dönüş için yeterli\n  )+\n  labs(title = \"3-color scale\")\n\n# Ölçek boyunca renklerin yerleşimini ayarlamak için rescale() kullanımı\ntrans_matrix + \n  scale_fill_gradientn(    # herhangi bir sayıda rengi sağlamak\n    colors = c(\"blue\", \"yellow\",\"red\", \"black\"),\n    values = scales::rescale(c(0, 0.05, 0.07, 0.10, 0.15, 0.20, 0.3, 0.5)) # renkler için konumlar 0 ile 1 arasında yeniden ölçeklenir\n    )+\n  labs(title = \"Colors not evenly positioned\")\n\n# dolgu rengini alan kesme değerleri için sınırların kullanılması\ntrans_matrix + \n  scale_fill_gradientn(    \n    colors = c(\"blue\", \"yellow\",\"red\"),\n    limits = c(0, 0.0002))+\n  labs(title = \"Restrict value limits, resulting in grey space\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPaletler\n\nColorbrewer ve Viridis\nDaha genel olarak, önceden tanımlanmış paletler istiyorsanız, “scale_xxx_brewer” veya “scale_xxx_viridis_y” fonksiyonlarını kullanabilirsiniz.\n‘brewer’ fonksiyonları colorbrewer.org paletlerinden çizim yapabilir.\n‘viridis’ fonksiyonları, viridis (renk körü dostu!) paletlerinden alınmıştır, bunlar “hem renkli hem de siyah-beyaz olarak algısal olarak tek biçimli renk haritaları sağlar. Ayrıca, yaygın renk körlüğü biçimlerine sahip izleyiciler tarafından algılanmak üzere tasarlanmıştır. (daha fazlasını buradan ve buradan okuyabilirsiniz). Fonksiyonun sonunda bunu belirterek paletin ayrık, sürekli veya ikili olup olmadığını tanımlayın (örneğin ayrık ‘scale_xxx_viridis_d’ dir).\nGrafiğinizi bu renk körlüğü simülatöründe test etmeniz önerilir. Kırmızı/yeşil renk düzeniniz varsa, bunun yerine soğuk (kırmızı-mavi) bir şema deneyin burada\nİşte çeşitli renk şemaları kullanan [ggplot basics] sayfasından bir örnek.\n\nsymp_plot &lt;- linelist %&gt;%                                         # satırlistesi ile başla\n  select(c(case_id, fever, chills, cough, aches, vomit)) %&gt;%     # sütunları seç\n  pivot_longer(                                                  # daha uzun döndür\n    cols = -case_id,                                  \n    names_to = \"symptom_name\",\n    values_to = \"symptom_is_present\") %&gt;%\n  mutate(                                                        # eksik verileri tamamla\n    symptom_is_present = replace_na(symptom_is_present, \"unknown\")) %&gt;% \n  ggplot(                                                        # ggplot'a başla\n    mapping = aes(x = symptom_name, fill = symptom_is_present))+\n  geom_bar(position = \"fill\", col = \"black\") +                    \n  theme_classic() +\n  theme(legend.position = \"bottom\")+\n  labs(\n    x = \"Symptom\",\n    y = \"Symptom status (proportion)\"\n  )\n\nsymp_plot  # kendinden olan renkleri yazdır\n\n#################################\n# el ile özelleştirdiğin renkleri yazdır\nsymp_plot +\n  scale_fill_manual(\n    values = c(\"yes\" = \"black\",         # renkleri açıkça tanımla\n               \"no\" = \"white\",\n               \"unknown\" = \"grey\"),\n    breaks = c(\"yes\", \"no\", \"unknown\"), # faktörleri doğru sırala\n    name = \"\"                           # lejandı başlıksız olarak ayarla\n\n  ) \n\n#################################\n# viridis ile ayrık renklerle yazdırın\nsymp_plot +\n  scale_fill_viridis_d(\n    breaks = c(\"yes\", \"no\", \"unknown\"),\n    name = \"\"\n  )",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>ggplot ipuçları</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.tr.html#ayrık-değişkenlerin-sırasını-değiştirmek",
    "href": "new_pages/ggplot_tips.tr.html#ayrık-değişkenlerin-sırasını-değiştirmek",
    "title": "31  ggplot ipuçları",
    "section": "31.3 Ayrık değişkenlerin sırasını değiştirmek",
    "text": "31.3 Ayrık değişkenlerin sırasını değiştirmek\nKesikli değişkenlerin göründüğü sırayı değiştirmek, genellikle “ggplot2” grafiklerinde yeni olan kişiler için anlaşılması zordur. Bunu nasıl yapacağınızı anlamak kolaydır, ancak ’ggplot2’nin başlık altında ayrık değişkenleri nasıl ele aldığını anladıktan sonra. Genel olarak konuşursak, ayrı bir değişken kullanılıyorsa, otomatik olarak bir “faktör” türüne dönüştürülür - bu, faktörleri varsayılan olarak alfabetik sıraya göre sıralar. Bunu halletmek için, grafikte görünmesini istediğiniz sırayı yansıtacak şekilde faktör düzeylerini yeniden sıralamanız yeterlidir. “Faktör” nesnelerinin nasıl yeniden sıralanacağı hakkında daha ayrıntılı bilgi için kılavuzun faktör bölümüne bakabilirsiniz.\nYaş gruplarını kullanarak yaygın bir örneğe bakabiliriz - varsayılan olarak 5-9 yaş grubu yaş gruplarının ortasına yerleştirilir (alfanumerik sıra verilir), ancak faktörleri yeniden seviyelendirerek onu 0-4 yaş grubunun arkasına taşıyabiliriz.\n\nggplot(\n  data = linelist %&gt;% drop_na(age_cat5),                         # age_cat5'in eksik olduğu satırları kaldırın\n  mapping = aes(x = fct_relevel(age_cat5, \"5-9\", after = 1))) +  # faktörü yeniden seviyelendirin\n\n  geom_bar() +\n  \n  labs(x = \"Age group\", y = \"Number of hospitalisations\",\n       title = \"Total hospitalisations by age group\") +\n  \n  theme_minimal()\n\n\n\n\n\n\n\n\n\n31.3.0.1 ggthemr\nAyrıca ggthemr paketini kullanmayı düşünün. Bu paketi buradaki talimatları kullanarak Github’dan indirebilirsiniz. Estetik açıdan çok hoş paletler sunar, ancak bunların tipik olarak 7 veya 8’den fazla renk istiyorsanız sınırlayıcı olabilecek maksimum sayıda değere sahip olduğunu unutmayın.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>ggplot ipuçları</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.tr.html#kontur-çizgileri",
    "href": "new_pages/ggplot_tips.tr.html#kontur-çizgileri",
    "title": "31  ggplot ipuçları",
    "section": "31.4 Kontur çizgileri",
    "text": "31.4 Kontur çizgileri\nKontur grafikleri, birbirini kapsayabilecek birçok noktanız olduğunda (“üst çizim”) yardımcı olur. Yukarıda kullanılan durum-kaynak verileri tekrar çizilir, ancak daha basit bir şekilde ‘stat_density2d()’ ve ‘stat_density2d_filled()’ kullanılarak - bir topografik harita gibi - ayrı kontur seviyeleri elde edilir. İstatistikler hakkında daha fazla bilgiyi buradan okuyabilirsiniz.\n\ncase_source_relationships %&gt;% \n  ggplot(aes(x = source_age, y = target_age))+\n  stat_density2d()+\n  geom_point()+\n  theme_minimal()+\n  labs(title = \"stat_density2d() + geom_point()\")\n\n\ncase_source_relationships %&gt;% \n  ggplot(aes(x = source_age, y = target_age))+\n  stat_density2d_filled()+\n  theme_minimal()+\n  labs(title = \"stat_density2d_filled()\")",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>ggplot ipuçları</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.tr.html#marjinal-dağılımlar",
    "href": "new_pages/ggplot_tips.tr.html#marjinal-dağılımlar",
    "title": "31  ggplot ipuçları",
    "section": "31.5 Marjinal dağılımlar",
    "text": "31.5 Marjinal dağılımlar\nBir “geom_point()” dağılım grafiğinin kenarlarındaki dağılımları göstermek için, ggExtra paketini ve onun “ggMarginal()” fonksiyonunu kullanabilirsiniz. Orijinal ggplot’unuzu bir nesne olarak kaydedin, ardından aşağıda gösterildiği gibi ggMarginal() öğesine iletin. İşte temel değikenler:\n\ntype = değerini “histogram”, “density” “boxplot”, “violin” veya “densigram” olarak belirtmelisiniz.\nVarsayılan olarak, her iki eksen için de marjinal grafikler görünecektir. Yalnızca bir tane istiyorsanız, margins = öğesini “x” veya “y” olarak ayarlayabilirsiniz.\nDiğer isteğe bağlı argümanlar arasında fill = (çubuk rengi), color = (çizgi rengi), size = (sınır boyutuna göre grafik boyutu, dolayısıyla daha büyük sayı marjinal grafiği küçültür).\nxparams = ve yparams = için eksene özel başka değişkenler sağlayabilirsiniz. Örneğin, aşağıda gösterildiği gibi farklı histogram kutusu boyutlarına sahip olunablir.\n\nMarjinal grafiklerin grupları yansıtmasını sağlayabilirsiniz (“ggplot()” eşleme estetiğinizde “color =” a atanan sütunlar). Bu durumda, “ggMarginal()” bağımsız değişkeni “groupColour =” veya “groupFill =” aşağıda gösterildiği gibi “TRUE” olarak ayarlayın.\nDetaylı bilgiye R fonksiyonu ?ggMarginal veya Bu gösterim, R Graph Gallery yoluyla erişebilirsiniz.\n\n# ggExtra'yı kurun/yükleyin\npacman::p_load(ggExtra)\n\n# Ağırlık ve yaşın temel saçılım grafiği\nscatter_plot &lt;- ggplot(data = linelist)+\n  geom_point(mapping = aes(y = wt_kg, x = age)) +\n  labs(title = \"Scatter plot of weight and age\")\n\nMarjinal histogramlar eklemek için type = \"histogram\" kullanın. Sıralanmış histogramları almak için isteğe bağlı olarak “groupFill = TRUE” ayarını yapabilirsiniz.\n\n# histogramlar ile\nggMarginal(\n  scatter_plot,                     # marjinal histogramlar ekle\n  type = \"histogram\",               # histogramları belirtmek\n  fill = \"lightblue\",               # çubuk doldurma\n  xparams = list(binwidth = 10),    # x ekseni marjinali için diğer parametreler\n  yparams = list(binwidth = 5))     # y ekseni marjinal için diğer parametreler\n\n\n\n\n\n\n\n\nGruplandırılmış/renkli değerlerle marjinal yoğunluk grafiği:\n\n# Sonuca göre renklendirilmiş dağılım grafiği\n# Sonuç sütunu ggplot'ta renk olarak atanır. (groupFill in ggMarginal TRUE olarak ayarlandı)\nscatter_plot_color &lt;- ggplot(data = linelist %&gt;% drop_na(gender))+\n  geom_point(mapping = aes(y = wt_kg, x = age, color = gender)) +\n  labs(title = \"Scatter plot of weight and age\")+\n  theme(legend.position = \"bottom\")\n\nggMarginal(scatter_plot_color, type = \"density\", groupFill = TRUE)\n\n\n\n\n\n\n\n\nMarjinal grafiğin göreli boyutunu ayarlamak için size = değişkenini ayarlayın. Daha küçük sayı, daha büyük bir marjinal grafik yapar. Ayrıca color= ve aşağıda, yalnızca bir eksende görünmesi için “margins =” değişkeni gösterimi ile bir marjinal kutu grafiği verilmiştir:\n\n# kutu grafiği ile \nggMarginal(\n  scatter_plot,\n  margins = \"x\",      # sadece x ekseni marjinal grafiğini göster\n  type = \"boxplot\")",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>ggplot ipuçları</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.tr.html#akıllı-etiketleme",
    "href": "new_pages/ggplot_tips.tr.html#akıllı-etiketleme",
    "title": "31  ggplot ipuçları",
    "section": "31.6 Akıllı Etiketleme",
    "text": "31.6 Akıllı Etiketleme\nggplot2’de çizimlere metin eklemek de mümkündür. Bununla birlikte, metin etiketlerinin genellikle bir grafikteki veri noktalarıyla çatıştığı, dağınık veya okunması zor görünmelerine neden olan dikkate değer bir sınırlama mevcuttur. Temel pakette bununla başa çıkmanın ideal bir yolu yoktur, ancak bununla uğraşmayı çok basit hale getiren ggrepel olarak bilinen bir ggplot2 eklentisi vardır.\nggrepel paketi, “geom_label()” ve “geom_text()” fonksiyonlarının yerine geçen “geom_label_repel()” ve “geom_text_repel()” adlı iki yeni fonksiyon sağlar. Düzgün etiketler üretmek için bunları kullanabilirsiniz. Fonksiyon içinde, “aes()” estetiğini her zaman olduğu gibi eşleştirin, ancak görüntülemek istediğiniz değerleri (örneğin hasta kimliği veya adı vb.) içeren bir sütun adı sağladığınız “label =” bağımsız değişkenini eklemiş olun. Aşağıda gösterildiği gibi str_glue() içindeki sütunları ve yeni satırları (\\n) birleştirerek daha karmaşık etiketler oluşturabilirsiniz.\nBirkaç ipucu:\n\nHer zaman çizgi parçaları çizmek için “min.segment.length = 0” veya onları asla çizmemek için “min.segment.length = Inf” kullanın\nMetin boyutunu ayarlamak için aes() dışında size = kullanın\nEtiketler ve ilgili noktaları arasındaki itme derecesini değiştirmek için force = kullanın (varsayılan 1’dir)\nEtiketin değere göre renklendirilmesi için ‘aes()’ içine ‘fill =’ ekleyin\n\nLejandda bir “a” harfi görünebilir - onu kaldırmak için guides(fill = guide_legend(override.aes ​​= aes(color = NA)))+ ekleyin\n\n\nDaha fazlası için ayrıntılı şu eğitime başvurabilirsiniz. eğitim.\n\npacman::p_load(ggrepel)\n\nlinelist %&gt;%                                               # vaka listesi ile başla\n  group_by(hospital) %&gt;%                                   # hastaneye göre gruplandır\n  summarise(                                               # hastane başına özet değerlerle yeni veri seti oluşturun\n    n_cases = n(),                                           # hastane başına vaka sayısı\n    delay_mean = round(mean(days_onset_hosp, na.rm=T),1),    # hastane başına ortalama gecikme\n  ) %&gt;% \n  ggplot(mapping = aes(x = n_cases, y = delay_mean))+      # veri çerçevesini ggplot'a gönder\n  geom_point(size = 2)+                                    # puan ekle\n  geom_label_repel(                                        # nokta etiketleri ekle\n    mapping = aes(\n      label = stringr::str_glue(\n        \"{hospital}\\n{n_cases} cases, {delay_mean} days\")  # etiket nasıl görüntülenir\n      ), \n    size = 3,                                              # etiketlerdeki metin boyutu\n    min.segment.length = 0)+                               # tüm çizgi parçalarını göster              \n  labs(                                                    # eksen etiketleri ekle\n    title = \"Mean delay to admission, by hospital\",\n    x = \"Number of cases\",\n    y = \"Mean delay (days)\")\n\n\n\n\n\n\n\n\nGrafiğin her bir “geom” katmanı için farklı “data =” sağlamak üzere standart “ggplot()” sözdizimini kullanarak, veri noktalarının yalnızca bir alt kümesini etiketleyebilirsiniz. Aşağıda, tüm durumlar çizilmiştir, ancak yalnızca birkaçı etiketlenmiştir.\n\nggplot()+\n  # Tüm noktalar gri\n  geom_point(\n    data = linelist,                                   # bu katmana sağlanan tüm veriler\n    mapping = aes(x = ht_cm, y = wt_kg),\n    color = \"grey\",\n    alpha = 0.5)+                                              # gri ve yarı şeffaf\n  \n  # Birkaç nokta siyah\n  geom_point(\n    data = linelist %&gt;% filter(days_onset_hosp &gt; 15),  # bu katmana sağlanan filtrelenmiş veriler\n    mapping = aes(x = ht_cm, y = wt_kg),\n    alpha = 1)+                                                # varsayılan siyah, şeffaf değil\n  \n  # birkaç nokta için nokta etiketleri\n  geom_label_repel(\n    data = linelist %&gt;% filter(days_onset_hosp &gt; 15),  # etiketler için verileri filtreleyin\n    mapping = aes(\n      x = ht_cm,\n      y = wt_kg,\n      fill = outcome,                                          # sonuca göre etiket rengi\n      label = stringr::str_glue(\"Delay: {days_onset_hosp}d\")), # str_glue() ile oluşturulan etiket\n    min.segment.length = 0) +                                  # hepsi için çizgi parçalarını göster\n  \n  # \"a\" harfini gösterge kutularından çıkarın\n  guides(fill = guide_legend(override.aes = aes(color = NA)))+\n  \n  # eksen etiketleri\n  labs(\n    title = \"Cases with long delay to admission\",\n    y = \"weight (kg)\",\n    x = \"height(cm)\")",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>ggplot ipuçları</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.tr.html#zaman-eksenleri",
    "href": "new_pages/ggplot_tips.tr.html#zaman-eksenleri",
    "title": "31  ggplot ipuçları",
    "section": "31.7 Zaman eksenleri",
    "text": "31.7 Zaman eksenleri\nggplot’ta zaman eksenleriyle çalışmak göz korkutucu görünebilir, ancak birkaç temel fonksiyonla çok kolay hale getirilmiştir. Saat veya tarihle çalışırken, doğru değişkenlerin tarih veya tarih-saat sınıfı olarak biçimlendirildiğinden emin olmanız gerektiğini unutmayın - bu konuda daha fazla bilgi için [Tarihlerle çalışma] sayfasına veya örnekler için [Salgın eğrileri] sayfasına (ggplot bölümü) bakabilirsiniz.\n“ggplot2”de tarihlerle çalışmak için en kullanışlı fonksiyon kümesi, ölçeklerdir (‘scale_x_date()’, ‘scale_x_datetime()’) ve bunların aynı kökteki y ekseni fonksiyonları). Eksen etiketlerine ne sıklıkla sahip olduğunuzu ve eksen etiketlerinin nasıl biçimlendirileceğini tanımlamanıza olanak tanır. Tarihlerin nasıl biçimlendirileceğini öğrenmek için tarihlerle çalışma bölümüne tekrar bakın! Tarihlerin nasıl görüneceğini belirtmek için “date_breaks” ve “date_labels” bağımsız değişkenlerini kullanabilirsiniz:\n\n“date_breaks”, eksen kırılmalarının ne sıklıkta gerçekleşeceğini belirlemenize olanak tanır - buraya bir dize iletebilirsiniz (örneğin ““3 ay”” veya “2 gün”’)\n“date_labels”, tarihlerin gösterildiği biçimi tanımlamanıza olanak tanır. Bu bağımsız değişkenlere bir tarih biçimi dizesi iletebilirsiniz (örneğin ““%b-%d-%Y”`):\n\n\n# mevcut olduğunda başlangıç tarihine göre salgın eğrisi yapın\nggplot(linelist, aes(x = date_onset)) +\n  geom_histogram(binwidth = 7) +\n  scale_x_date(\n    # 1 ayda 1 mola\n    date_breaks = \"1 months\",\n    # etiketler aydan sonra tarihi göstermelidir\n    date_labels = \"%b %d\"\n  ) +\n  theme_classic()",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>ggplot ipuçları</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.tr.html#vurgulama",
    "href": "new_pages/ggplot_tips.tr.html#vurgulama",
    "title": "31  ggplot ipuçları",
    "section": "31.8 Vurgulama",
    "text": "31.8 Vurgulama\nBir grafikteki belirli öğelerin vurgulanması, bir değişkenin belirli bir örneğine dikkat çekmenin ve aynı zamanda tüm veri kümesinin dağılımı hakkında bilgi sağlamanın yararlı bir yoludur. Bu, ggplot2 tabanında kolayca yapılmasa da, bunu yapmanıza yardımcı olabilecek gghighlight olarak bilinen harici bir paket vardır. Bunun ggplot sözdizimi içinde kullanımı kolaydır.\ngghighlight paketi, bu efekti elde etmek için ‘gghighlight()’ fonksiyonunu kullanır. Kullanmak için, fonksiyona mantıklı bir ifade sağlayın - bunun oldukça esnek sonuçları olabilir, ancak burada satır listemizdeki vakaların yaş dağılımının bir örneğini sonuca göre vurgulayarak göstereceğiz.\n\n# gghighlight yükle\nlibrary(gghighlight)\n\n# sonuç değişkeninde NA değerlerini bilinmeyenle değiştirin\nlinelist &lt;- linelist %&gt;%\n  mutate(outcome = replace_na(outcome, \"Unknown\"))\n\n# yaşa göre tüm vakaların bir histogramını üretmek\nggplot(\n  data = linelist,\n  mapping = aes(x = age_years, fill = outcome)) +\n  geom_histogram() + \n  gghighlight::gghighlight(outcome == \"Death\")     # Hastanın öldüğü durumları vurgulayın.\n\n\n\n\n\n\n\n\nBu aynı zamanda faset fonksiyonları ile de iyi çalışır - kullanıcının, faset için geçerli olmayan vurgulanmış arka plan verileriyle faset grafikleri oluşturmasını sağlar! Aşağıda vakaları haftaya göre sayıyor ve hastaneye göre salgın eğrilerini çiziyoruz (“color =” ve “facet_wrap()”, “hastane” sütununa ayarlı).\n\n# yaşa göre tüm vakaların bir histogramını üretmek\nlinelist %&gt;% \n  count(week = lubridate::floor_date(date_hospitalisation, \"week\"),\n        hospital) %&gt;% \n  ggplot()+\n  geom_line(aes(x = week, y = n, color = hospital))+\n  theme_minimal()+\n  gghighlight::gghighlight() +                      # Hastanın öldüğü örnekleri vurgulayın\n  facet_wrap(~hospital)                              # sonuca göre yönler yapmak",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>ggplot ipuçları</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.tr.html#birden-çok-veri-kümesini-çizme",
    "href": "new_pages/ggplot_tips.tr.html#birden-çok-veri-kümesini-çizme",
    "title": "31  ggplot ipuçları",
    "section": "31.9 Birden çok veri kümesini çizme",
    "text": "31.9 Birden çok veri kümesini çizme\nAynı çizimdeki birden çok veri kümesinden çizim yapmak için eksenleri düzgün şekilde hizalamanın zor olabileceğini unutmayın. Aşağıdaki stratejilerden birini düşünün:\n\nÇizimden önce verileri birleştirin ve veri kümesini yansıtan bir sütunla “uzun” biçime dönüştürün\nİki grafiği birleştirmek için cowplot veya benzer bir paket kullanın (aşağıya bakın)",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>ggplot ipuçları</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.tr.html#grafikleri-birleştirmek",
    "href": "new_pages/ggplot_tips.tr.html#grafikleri-birleştirmek",
    "title": "31  ggplot ipuçları",
    "section": "31.10 Grafikleri birleştirmek",
    "text": "31.10 Grafikleri birleştirmek\nGrafikleri birleştirmek için çok yararlı olan iki paket cowplot ve patchwork’tür. Bu sayfada, ara sıra patchwork kullanımıyla çoğunlukla cowplot’a odaklanacağız.\nİşte çevrimiçi cowplot’a giriş. Her fonksiyon için daha kapsamlı belgeleri çevrimiçi olarak buradan okuyabilirsiniz. Aşağıda en yaygın kullanım durumlarından ve fonksiyonlarından birkaçını ele alacağız.\ncowplot paketi ggplot2 ile birlikte çalışır - temel olarak, onu ggplot’ları ve açıklamalarını bileşik rakamlarda düzenlemek ve birleştirmek için kullanırsınız. Ayrıca R tabanı grafiklerini de kabul edebilir.\n\npacman::p_load(\n  tidyverse,      # veri işleme ve görselleştirme\n  cowplot,        # grafikleri birleştir\n  patchwork       # grafikleri birleştir\n)\n\nYönlendirme ([ggplot temelleri] sayfasında açıklanmıştır) çizim için uygun bir yaklaşım olsa da, bazen nispeten kısıtlayıcı yaklaşımından istediğiniz sonuçları elde etmek mümkün değildir. Burada, grafikleri daha büyük bir alana yapıştırarak birleştirmeyi seçebilirsiniz. Bunun için çok iyi bilinen üç paket vardır - cowplot, gridExtra ve patchwork. Ancak, bu paketler büyük ölçüde aynı şeyleri yapar, bu nedenle bu bölüm için cowplot üzerine odaklanacağız.\n\nplot_grid()\ncowplot paketi oldukça geniş bir fonksiyon yelpazesine sahiptir, ancak bunun en kolay kullanımı plot_grid() kullanılarak elde edilebilir. Bu, bir ızgara oluşumunda önceden tanımlanmış grafikleri düzenlemenin etkili bir yoludur. Sıtma veri seti ile başka bir örnek üzerinde çalışabiliriz - burada toplam vakaları bölgeye göre çizebilir ve ayrıca zaman içindeki salgın eğrisini gösterebiliriz.\n\nmalaria_data &lt;- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\")) \n\n# ilçeye göre toplam vakaların çubuk grafiği\np1 &lt;- ggplot(malaria_data, aes(x = District, y = malaria_tot)) +\n  geom_bar(stat = \"identity\") +\n  labs(\n    x = \"District\",\n    y = \"Total number of cases\",\n    title = \"Total malaria cases by district\"\n  ) +\n  theme_minimal()\n\n# zamanla salgın eğrisi\np2 &lt;- ggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1) +\n  labs(\n    x = \"Date of data submission\",\n    y =  \"number of cases\"\n  ) +\n  theme_minimal()\n\ncowplot::plot_grid(p1, p2,\n                  # 1 sütun ve iki satır - üst üste yığılmış\n                   ncol = 1,\n                   nrow = 2,\n                   # üst arsa, saniyenin 2/3'ü kadar uzun\n                   rel_heights = c(2, 3))\n\n\n\n\n\n\n\n\n\n\nGöstergeleri birleştir\nGrafikleriniz aynı göstergelere sahipse, bunları birleştirmek nispeten basittir. Grafikleri birleştirmek için yukarıdaki cowplot yaklaşımını kullanın, ancak göstergeyi bunlardan birinden kaldırın (tekrarlanacaktır).\nGrafikleriniz farklı göstergelere sahipse, alternatif bir yaklaşım kullanmalısınız:\n\ntheme(legend.position = \"none\") kullanarak grafiklerinizi göstergeler olmadan oluşturun ve kaydedin\nAşağıda gösterildiği gibi get_legend() kullanarak her bir grafikten göstergeleri ayıklayın - ancak lejantı gerçekten göstermek için değiştirilmiş grafiklerden lejantları çıkarın\nGöstergeleri bir gösterge panelinde birleştirin\nGrafikler ve göstergeler panelini birleştirin\n\nÖrnek için iki grafiği ayrı ayrı gösteriyoruz ve sonra kendi açıklamaları (çirkin ve verimsiz alan kullanımı) gösteren bir ızgarada düzenliyoruz:\n\np1 &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %&gt;% \n  count(hospital, outcome) %&gt;% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+\n  scale_fill_brewer(type = \"qual\", palette = 4, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  labs(title = \"Cases by outcome\")\n\n\np2 &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %&gt;% \n  count(hospital, age_cat) %&gt;% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+\n  scale_fill_brewer(type = \"qual\", palette = 1, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  theme(axis.text.y = element_blank())+\n  labs(title = \"Cases by age\")\n\nİki grafik, lejantlarını/göstergelerini birleştirmeden “plot_grid()” kullanılarak birleştirildiğinde şöyle görünür:\n\ncowplot::plot_grid(p1, p2, rel_widths = c(0.3))\n\n\n\n\n\n\n\n\nVe şimdi göstergeleri nasıl birleştireceğimizi gösteriyoruz. Esasen yaptığımız şey, her bir grafiği açıklaması olmadan tanımlamaktır (theme(legend.position = \"none\") ve sonra get_legend() fonksiyonunu kullanarak her bir grafiğin göstergesini ayrı ayrı cowplot dan tanımlarız. Kaydedilen çizimden lejandı çıkardığımızda, lejandı tekrar `+’ eklememiz gerekiyor, buna yerleşimi belirtmek (“sağ”) ve lejandların ve başlıklarının hizalanması için daha küçük ayarlamalar da dahildir. Lejandları dikey olarak bir araya getirin ve ardından iki grafiği yeniden birleştirin.\n\n# Açıklama olmadan grafik 1'i tanımlayın\np1 &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %&gt;% \n  count(hospital, outcome) %&gt;% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+\n  scale_fill_brewer(type = \"qual\", palette = 4, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  theme(legend.position = \"none\")+\n  labs(title = \"Cases by outcome\")\n\n\n# Açıklama olmadan grafik 2'yi tanımlayın\np2 &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %&gt;% \n  count(hospital, age_cat) %&gt;% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+\n  scale_fill_brewer(type = \"qual\", palette = 1, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  theme(\n    legend.position = \"none\",\n    axis.text.y = element_blank(),\n    axis.title.y = element_blank()\n  )+\n  labs(title = \"Cases by age\")\n\n\n# p1'den lejandı çıkar (p1'den + lejand)\nleg_p1 &lt;- cowplot::get_legend(p1 +\n                                theme(legend.position = \"right\",        # dikey lejandı çıkar\n                                      legend.justification = c(0,0.5))+ # böylece lejandlar hizalanır\n                                labs(fill = \"Outcome\"))                 # lejand başlığı\n# p2'den lejandı çıkar (p2'den + lejand)\nleg_p2 &lt;- cowplot::get_legend(p2 + \n                                theme(legend.position = \"right\",            \n                                      legend.justification = c(0,0.5))+  \n                                labs(fill = \"Age Category\"))             \n\n# lejand hizalaması için boş bir grafik oluşturun\n#blank_p &lt;- patchwork::plot_spacer() + theme_void()\n\n# lejand paneli oluşturun, üst üste olabilir (veya yukarıda yorumlanan aralayıcıyı kullanın)\nlegends &lt;- cowplot::plot_grid(leg_p1, leg_p2, nrow = 2, rel_heights = c(.3, .7))\n\n# iki grafiği ve birleştirilmiş lejand panelini birleştirin\ncombined &lt;- cowplot::plot_grid(p1, p2, legends, ncol = 3, rel_widths = c(.4, .4, .2))\n\ncombined  # yazdır\n\n\n\n\n\n\n\n\nBu çözüm, bu gönderiden öğrenildi ve lejandları bu gönderiden hizalamak için küçük bir düzeltme yapıldı.\nİPUCU: Eğlenceli not - cowplot’taki “inek-COW”, yaratıcının adından gelir - Claus O. Wilke.\n\n\nEk grafikler\ncowplot kullanarak bir grafiği diğerine yerleştirebilirsiniz. İşte dikkat edilmesi gerekenler:\n\nAna grafiği cowplot’tan theme_half_open() ile tanımlayın; lejandın üstte veya altta olması en iyisi olabilir\nİç metin grafiğini tanımlayın. En iyisi, bir lejanda ihtiyacınız olmayan bir grafiğe sahip olmaktır. Aşağıda gösterildiği gibi element_blank() ile çizim teması öğelerini kaldırabilirsiniz.\nBunları ana çizime ggdraw()’ uygulayarak birleştirin, ardından içteki çizime ‘draw_plot()’ ekleyerek ve koordinatları (sol alt köşenin x ve y), tüm ana grafiğin oranı olarak yüksekliği ve genişliği belirterek birleştirin .\n\n\n# Ana grafiği tanımla\nmain_plot &lt;- ggplot(data = linelist)+\n  geom_histogram(aes(x = date_onset, fill = hospital))+\n  scale_fill_brewer(type = \"qual\", palette = 1, na.value = \"grey\")+ \n  theme_half_open()+\n  theme(legend.position = \"bottom\")+\n  labs(title = \"Epidemic curve and outcomes by hospital\")\n\n\n# İç metin grafiğini tanımlayın\ninset_plot &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %&gt;% \n  count(hospital, outcome) %&gt;% \n  ggplot()+\n    geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+\n    scale_fill_brewer(type = \"qual\", palette = 4, na.value = \"grey\")+\n    coord_flip()+\n    theme_minimal()+\n    theme(legend.position = \"none\",\n          axis.title.y = element_blank())+\n    labs(title = \"Cases by outcome\") \n\n\n# Ana öğeyi iç metinle birleştirin\ncowplot::ggdraw(main_plot)+\n     draw_plot(inset_plot,\n               x = .6, y = .55,    #x = .07, y = .65,\n               width = .4, height = .4)\n\n\n\n\n\n\n\n\nBu teknik, bu iki gösterim içinde daha fazla açıklanmıştır:\nWilke laboratuvarı draw_plot() belgeleri",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>ggplot ipuçları</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.tr.html#çift-eksen",
    "href": "new_pages/ggplot_tips.tr.html#çift-eksen",
    "title": "31  ggplot ipuçları",
    "section": "31.11 Çift eksen",
    "text": "31.11 Çift eksen\nİkincil bir y ekseni genellikle bir “ggplot2” grafiğine istenen bir ektir. Veri görselleştirme topluluğunda bu tür grafiklerin geçerliliği hakkında güçlü bir tartışma olsa da ve bunlar genellikle önerilmese de, yöneticiniz yine de bunları isteyebilir. Aşağıda, bunları elde etmek için bir yöntem sunuyoruz: iki ayrı grafiği birleştirmek için cowplot paketini kullanmak.\nBu yaklaşım, biri solda y ekseni ve diğeri sağda y ekseni olan iki ayrı grafik oluşturmayı içerir. Her ikisi de belirli bir “theme_cowplot()” kullanır ve aynı x eksenine sahip olmalıdır. Daha sonra üçüncü bir komutta iki grafik hizalanır ve üst üste bindirilir. Bu cowplot’un özelliği sitede ayrıntılı olarak açıklanmaktadır.\nBu tekniği göstermek için, salgın eğrisini, ölen hastaların haftalık yüzdesinin bir çizgisiyle kaplayacağız. Bu örneği, x eksenindeki tarihlerin hizalanmasını, bir çubuk grafiği başka bir grafikle hizalamaktan daha karmaşık olduğu için kullanıyoruz. Dikkat edilmesi gereken bazı şeyler:\n\nSalgın eğrisi ve çizgi, çizimden önceki haftalarda toplanır ve “tarih_araları” ve “tarih_etiketleri” aynıdır - bunu, üst üste bindirildiklerinde iki grafiğin x-eksenlerinin aynı olması için yaparız.\ny ekseni, ‘scale_y_continuous()’ un ‘position =’ değişkeni ile 2. grafik için sağ tarafa taşınır.\nHer iki grafik de theme_cowplot() fonksiyonunu kullanır\n\n[Salgın eğrileri] sayfasında bu tekniğin başka bir örneğine dikkat çekilmiştir - kümülatif insidansı eğri üzerine bindirerek.\n** 1. Grafiği Üretmek** Bu aslında salgın eğrisidir. Sadece kullanımını göstermek için geom_area() kullanıyoruz (varsayılan olarak bir çizginin altındaki alan)\n\npacman::p_load(cowplot)            # Cowplot'u yükle/kur\n\np1 &lt;- linelist %&gt;%                 # grafiği nesne olarak kaydet\n     count(\n       epiweek = lubridate::floor_date(date_onset, \"week\")) %&gt;% \n     ggplot()+\n          geom_area(aes(x = epiweek, y = n), fill = \"grey\")+\n          scale_x_date(\n               date_breaks = \"month\",\n               date_labels = \"%b\")+\n     theme_cowplot()+\n     labs(\n       y = \"Weekly cases\"\n     )\n\np1                                      # grafiği göster\n\n\n\n\n\n\n\n\n2. Grafiği Üretmek Ölen vakaların haftalık yüzdesinin bir satırını gösteren ikinci grafiği oluşturun.\n\np2 &lt;- linelist %&gt;%         # grafiği nesne olarak kaydet\n     group_by(\n       epiweek = lubridate::floor_date(date_onset, \"week\")) %&gt;% \n     summarise(\n       n = n(),\n       pct_death = 100*sum(outcome == \"Death\", na.rm=T) / n) %&gt;% \n     ggplot(aes(x = epiweek, y = pct_death))+\n          geom_line()+\n          scale_x_date(\n               date_breaks = \"month\",\n               date_labels = \"%b\")+\n          scale_y_continuous(\n               position = \"right\")+\n          theme_cowplot()+\n          labs(\n            x = \"Epiweek of symptom onset\",\n            y = \"Weekly percent of deaths\",\n            title = \"Weekly case incidence and percent deaths\"\n          )\n\np2     # grafiği göster\n\n\n\n\n\n\n\n\nŞimdi yatay ve dikey hizalamayı (“hv”, “h”, “v”, “none” da olabilir) belirterek, align_plots() fonksiyonunu kullanarak grafiği hizalıyoruz. “tblr” ile tüm eksenlerin (üst, alt, sol ve sağ) hizalamasını da belirtiyoruz. Çıktı sınıf listesidir (2 eleman).\nArdından, ggdraw()‘ı (cowplot’tan) kullanarak ve ’aligned_plots’ nesnesinin iki parçasına atıfta bulunarak iki grafiği birlikte çiziyoruz.\n\naligned_plots &lt;- cowplot::align_plots(p1, p2, align=\"hv\", axis=\"tblr\")         # iki grafiği hizalayın ve liste olarak kaydedin\naligned_plotted &lt;- ggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])  # üst üste bindirin ve görsel grafiği kaydedin\naligned_plotted                                                                # bindirilmiş grafikleri yazdır",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>ggplot ipuçları</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.tr.html#size-yardımcı-olacak-paketler",
    "href": "new_pages/ggplot_tips.tr.html#size-yardımcı-olacak-paketler",
    "title": "31  ggplot ipuçları",
    "section": "31.12 Size yardımcı olacak paketler",
    "text": "31.12 Size yardımcı olacak paketler\nggplot2’de gezinmenize yardımcı olmak için özel olarak tasarlanmış gerçekten anlaşılır bazı R paketleri vardır:\n\nİşaretle ve tıkla ggplot2 ile equisse\n“Bu eklenti, verilerinizi ggplot2 paketi ile görselleştirerek etkileşimli olarak keşfetmenizi sağlar. Çubuk grafikler, eğriler, dağılım grafikleri, histogramlar, kutu grafiği ve sf nesneleri çizmenize, ardından grafiği dışa aktarmanıza veya grafiği yeniden oluşturmak için kodu almanıza olanak tanır.”\nEklentiyi RStudio menüsü veya esquisse::esquisser() ile kurun ve başlatın.\nGithub sayfasına bakabilirsiniz.\nBelgeler",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>ggplot ipuçları</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.tr.html#çeşitli",
    "href": "new_pages/ggplot_tips.tr.html#çeşitli",
    "title": "31  ggplot ipuçları",
    "section": "31.13 Çeşitli",
    "text": "31.13 Çeşitli\n\nSayısal ekran\nÇizimden önce bu komutu çalıştırarak bilimsel gösterimi devre dışı bırakabilirsiniz.\n\noptions(scipen=999)\n\nVeya scales paketinden number_format() öğesini aşağıda gösterildiği gibi belirli bir değere veya sütuna uygulayın.\nSayıların nasıl görüntüleneceğini kolayca ayarlamak için scales paketindeki fonksiyonları kullanın. Bunlar, veri çerçevenizdeki sütunlara uygulanabilir, ancak örnek olarak tek tek sayılarda gösterilir.\n\nscales::number(6.2e5)\n\n[1] \"620 000\"\n\nscales::number(1506800.62,  accuracy = 0.1,)\n\n[1] \"1 506 800.6\"\n\nscales::comma(1506800.62, accuracy = 0.01)\n\n[1] \"1,506,800.62\"\n\nscales::comma(1506800.62, accuracy = 0.01,  big.mark = \".\" , decimal.mark = \",\")\n\n[1] \"1.506.800,62\"\n\nscales::percent(0.1)\n\n[1] \"10%\"\n\nscales::dollar(56)\n\n[1] \"$56\"\n\nscales::scientific(100000)\n\n[1] \"1e+05\"",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>ggplot ipuçları</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.tr.html#kaynaklar",
    "href": "new_pages/ggplot_tips.tr.html#kaynaklar",
    "title": "31  ggplot ipuçları",
    "section": "31.14 Kaynaklar",
    "text": "31.14 Kaynaklar\nEsinlenme ggplot grafik galerisi\nVerilerin sunumu Avrupa Hastalık Önleme ve Kontrol Merkezi Sürveyans verilerinin sunumuna ilişkin kılavuzlar\nYönler ve etiketleyiciler Yüz şeritleri için etiketleyici kullanma Etiketçiler\nFaktörlerle sıralamayı ayarlama fct_reorder fct_inorder Bir kutu grafiği nasıl yeniden sıralanır ggplot2’de bir değişkeni yeniden sıralayın Veri Bilimi için R - Faktörler\nGöstergeler Lejand sırasını ayarlayın\nAltyazılar Altyazı hizalaması\nEtiketler ggrepel\nYardımcı sayfaları ggplot2 ile güzel çizim",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>ggplot ipuçları</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.tr.html",
    "href": "new_pages/epicurves.tr.html",
    "title": "32  Salgın eğrileri",
    "section": "",
    "text": "32.1 Hazırlık",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Salgın eğrileri</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.tr.html#hazırlık",
    "href": "new_pages/epicurves.tr.html#hazırlık",
    "title": "32  Salgın eğrileri",
    "section": "",
    "text": "Paketler\nBu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’ın p_load()işlevini vurguluyoruz. Ayrıca, R tabanı’ndan library()ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] ile ilgili sayfaya bakın.\n\npacman::p_load(\n  rio,          # file import/export\n  here,         # relative filepaths \n  lubridate,    # working with dates/epiweeks\n  aweek,        # alternative package for working with dates/epiweeks\n  incidence2,   # epicurves of linelist data\n  i2extras,     # supplement to incidence2\n  stringr,      # search and manipulate character strings\n  forcats,      # working with factors\n  RColorBrewer, # Color palettes from colorbrewer2.org\n  tidyverse     # data management + ggplot2 graphics\n) \n\n\n\nVerileri içe aktarma\nBu bölümde iki örnek veri seti kullanılmıştır:\n\nSimüle edilmiş bir salgından bireysel vakaların sıra listesi\nAynı simüle edilmiş salgından hastaneye göre toplu sayımlar\n\nVeri setleri, rio paketinden import()fonksiyonu kullanılarak içe aktarılır. Verileri içe aktarmanın çeşitli yolları için [İçe ve dışa aktarma] sayfasına bakın.\nVaka satır listesi\nSimüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Adım adım izlenecek verileri indirmek istiyorsanız, [El kitabını ve verileri indir] sayfasındaki talimata bakın. Dosyanın çalışma dizininde olduğunu varsayıyoruz, bu nedenle bu dosya yolunda hiçbir alt klasör belirtilmemiştir.\n\nlinelist &lt;- import(\"linelist_cleaned.xlsx\")\n\nİlk 50 satır aşağıda gösterilmiştir.\n\n\n\n\n\n\nHastane tarafından toplanan vaka sayıları\nEl kitabının amaçları doğrultusunda, hastane tarafından haftalık toplu sayımların veri seti, aşağıdaki kodla linelist ’den oluşturulur.\n\n# import the counts data into R\ncount_data &lt;- linelist %&gt;% \n  group_by(hospital, date_hospitalisation) %&gt;% \n  summarize(n_cases = dplyr::n()) %&gt;% \n  filter(date_hospitalisation &gt; as.Date(\"2013-06-01\")) %&gt;% \n  ungroup()\n\nİlk 50 satır aşağıda görüntülenir:\n\n\n\n\n\n\n\n\nParametreleri ayarlamak\nBir raporun hazırlanması için, verilerin güncel olduğu tarih (“veri tarihi”) gibi düzenlenebilir parametreleri ayarlamak isteyebilirsiniz. Ardından, filtre uygularken veya dinamik altyazılarda kodunuzdaki data_date nesnesine başvurabilirsiniz.\n\n## set the report date for the report\n## note: can be set to Sys.Date() for the current date\ndata_date &lt;- as.Date(\"2015-05-15\")\n\n\n\nTarihleri doğrulama\nHer ilgili tarih sütununun Date sınıfı olduğunu ve uygun bir değer aralığına sahip olduğunu doğrulayın. Bunu, histogramlar için hist()’i veya na.rm=TRUE ile range()’i veya aşağıdaki gibi ggplot()’u kullanarak yapabilirsiniz.\n\n# check range of onset dates\nggplot(data = linelist)+\n  geom_histogram(aes(x = date_onset))",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Salgın eğrileri</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.tr.html#ggplot2-ile-salgın-eğrileri",
    "href": "new_pages/epicurves.tr.html#ggplot2-ile-salgın-eğrileri",
    "title": "32  Salgın eğrileri",
    "section": "32.2 ggplot2 ile salgın eğrileri",
    "text": "32.2 ggplot2 ile salgın eğrileri\nSalgın eğrinizi oluşturmak için ggplot()’u kullanmak daha fazla esneklik ve özelleştirme sağlar, ancak ggplot()’un nasıl çalıştığına dair daha fazla çaba ve anlayış gerektirir.\nincidence2 paketini kullanmaktan farklı olarak, vakaların zamana (haftalara, aylara vb.) göre toplanmasını ve tarih eksenindeki etiketlerin sonlanmalarını manuel olarak kontrol etmelisiniz. Bu dikkatle yönetilmelidir.\nBu örnekler, linelist veri kümesinin bir alt kümesini kullanır - yalnızca Central Hospital’daki vakalar.\n\ncentral_data &lt;- linelist %&gt;% \n  filter(hospital == \"Central Hospital\")\n\nggplot() ile bir salgın eğrisi oluşturmak için üç ana unsur vardır:\n\nBelirli “sonlanlanma” noktalarıyla ayırt edilen “bölmelere” toplanmış satır listesi vakaları içeren bir histogram,\n\nEksenler ve etiketleri için ölçekler,\n\nBaşlıklar, etiketler, altyazılar vb. dahil olmak üzere grafik görünümü için temalar.\n\n\nVaka bölmelerini belirtin\nBurada, vakaların histogram bölmelerinde (“çubuklar”) nasıl toplanacağını belirteceğiz. Vakaların histogram bölmelerinde toplanmasının, x ekseninde görünecek tarihlerle mutlaka aynı sonlanmalar olmadığını bilmek önemlidir.\nAşağıda, günlük ve haftalık salgın eğrileri üretmek için belki de en basit kod verilmiştir.\nAşırı kemerli ggplot() komutunda, veri kümesi data = olarak sağlanır. Bu temel üzerine, bir histogramın geometrisi + ile eklenir. geom_histogram() içinde, date_onset sütunu x eksenine eşlenecek şekilde estetiği eşleriz. Ayrıca geom_histogram() içinde ama aes() içinde değil, histogram bölmelerinin binwidth = değerini gün olarak ayarladık. Bu ggplot2 sözdizimi kafa karıştırıcıysa, [ggplot temelleri] hakkındaki sayfayı inceleyin.\nDİKKAT: binwidth = 7 kullanarak haftalık vakaları grafiklendirmek, ilk durumda ilk 7 günlük bölmeyi başlatır, bu haftanın herhangi bir günü olabilir! Belirli haftalar oluşturmak için aşağıdaki bölüme bakın. \n\n# daily \nggplot(data = central_data) +          # set data\n  geom_histogram(                      # add histogram\n    mapping = aes(x = date_onset),     # map date column to x-axis\n    binwidth = 1)+                     # cases binned by 1 day \n  labs(title = \"Central Hospital - Daily\")                # title\n\n# weekly\nggplot(data = central_data) +          # set data \n  geom_histogram(                      # add histogram\n      mapping = aes(x = date_onset),   # map date column to x-axis\n      binwidth = 7)+                   # cases binned every 7 days, starting from first case (!) \n  labs(title = \"Central Hospital - 7-day bins, starting at first case\") # title\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBu Central Hopital veri setindeki ilk vakanın aşağıdakilerde semptom başlangıcı olduğunu not edelim:\n\nformat(min(central_data$date_onset, na.rm=T), \"%A %d %b, %Y\")\n\n[1] \"Thursday 01 May, 2014\"\n\n\nHistogram bölme kesmelerini manuel olarak belirtmek için bölme binwidth = argümanını kullanmayın ve bunun yerine breaks = için bir tarih vektörü sağlayın.\nR tabanı işlevi seq.Date()ile tarihlerin vektörünü oluşturun. Bu fonksiyon to =, from = ve by = argümanlarını bekler. Örneğin, aşağıdaki komut, 15 Ocak’ta başlayan ve 28 Haziran’a kadar biten aylık tarihleri döndürür.\n\nmonthly_breaks &lt;- seq.Date(from = as.Date(\"2014-02-01\"),\n                           to = as.Date(\"2015-07-15\"),\n                           by = \"months\")\n\nmonthly_breaks   # print\n\n [1] \"2014-02-01\" \"2014-03-01\" \"2014-04-01\" \"2014-05-01\" \"2014-06-01\"\n [6] \"2014-07-01\" \"2014-08-01\" \"2014-09-01\" \"2014-10-01\" \"2014-11-01\"\n[11] \"2014-12-01\" \"2015-01-01\" \"2015-02-01\" \"2015-03-01\" \"2015-04-01\"\n[16] \"2015-05-01\" \"2015-06-01\" \"2015-07-01\"\n\n\nBu vektör geom_histogram()’a breaks = olarak sağlanabilir:\n\n# monthly \nggplot(data = central_data) +  \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    breaks = monthly_breaks)+         # provide the pre-defined vector of breaks                    \n  labs(title = \"Monthly case bins\")   # title\n\n\n\n\n\n\n\n\nBasit bir haftalık tarih dizisi, by = \"week\" ile ayarlanarak döndürülebilir. Örneğin:\n\nweekly_breaks &lt;- seq.Date(from = as.Date(\"2014-02-01\"),\n                          to = as.Date(\"2015-07-15\"),\n                          by = \"week\")\n\nBelirli başlangıç ve bitiş tarihlerini sağlamaya bir alternatif, haftalık bölmelerin ilk durumdan önceki Pazartesi günü başlaması için dinamik kod yazmaktır. Aşağıdaki örneklerde bu tarih vektörlerini kullanacağız.\n\n# Sequence of weekly Monday dates for CENTRAL HOSPITAL\nweekly_breaks_central &lt;- seq.Date(\n  from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 1), # monday before first case\n  to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # monday after last case\n  by   = \"week\")\n\nYukarıdaki oldukça göz korkutucu kodu açalım:\n\n“from” değeri (dizinin en erken tarihi) şu şekilde oluşturulur: date_onset sütunundaki minimum tarih değeri (min() ile na.rm=TRUE) lubridate paketinden floor_date() öğesine beslenir. floor_date() “hafta” olarak ayarlandığında, her haftanın başlangıç gününün Pazartesi olması koşuluyla (week_start = 1) bu vakaların “hafta”sının başlangıç tarihini döndürür.\n\nBenzer şekilde, “to” değeri (dizinin bitiş tarihi), son vakadan sonraki Pazartesi gününü döndürmek için ceiling_date() ters işlevi kullanılarak oluşturulur.\n\nseq.Date() öğesinin “by” argümanı herhangi bir sayıda gün, hafta veya aya ayarlanabilir.\n\nPazar haftaları için week_start = 7 kullanın.\n\nBu sayfa boyunca bu veri vektörlerini kullanacağımız için, tüm salgın için bir tane de tanımladık (yukarıdakiler sadece Central Hospital içindir).\n\n# Sequence for the entire outbreak\nweekly_breaks_all &lt;- seq.Date(\n  from = floor_date(min(linelist$date_onset, na.rm=T),   \"week\", week_start = 1), # monday before first case\n  to   = ceiling_date(max(linelist$date_onset, na.rm=T), \"week\", week_start = 1), # monday after last case\n  by   = \"week\")\n\nBu seq.Date()çıktıları, histogram bölme sonlanmalarını oluşturmak için kullanılabilir, ancak aynı zamanda bölmelerden bağımsız olabilen tarih etiketleri için sonlanmalar da kullanılabilir. Sonraki bölümlerde tarih etiketleri hakkında daha fazla bilgi edinin.\nİPUCU: Daha basit bir ggplot() komutu için, bölme sonlanmalarını ve etiket sonlanmalarını önceden adlandırılmış vektörler olarak kaydedin ve yalnızca adlarını breaks = olarak değiştirin.\n\n\nHaftalık salgın eğrisi örneği\nAşağıda, hizalanmış çubuklar, tarih etiketleri ve dikey kılavuz çizgileri ile Pazartesi haftaları için haftalık salıgın eğrileri oluşturmak için ayrıntılı örnek kod verilmiştir. Bu bölüm, hızlı bir şekilde koda ihtiyaç duyan kullanıcı içindir. Her yönü (temalar, tarih etiketleri vb.) derinlemesine anlamak için sonraki bölümlere geçin. Önemli:\n\nHistogram bölme araları, en erken vakadan önceki Pazartesi günü başlayacak ve son vakadan sonraki Pazartesi günü sona erecek şekilde yukarıda açıklandığı gibi seq.Date()ile tanımlanır.\n\nTarih etiketlerinin aralığı, scale_x_date() içinde date_breaks = ile belirtilir.\n\nTarih etiketleri arasındaki küçük dikey kılavuz çizgilerinin aralığı, date_minor_breaks = olarak belirtilir.\nx ve y ölçeklerinde expand = c(0,0)eksenlerin her iki yanındaki fazla boşluğu kaldırır, bu da tarih etiketlerinin ilk çubuktan başlamasını sağlar.\n\n\n# TOTAL MONDAY WEEK ALIGNMENT\n#############################\n# Define sequence of weekly breaks\nweekly_breaks_central &lt;- seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 1), # Monday before first case\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # Monday after last case\n      by   = \"week\")    # bins are 7-days \n\n\nggplot(data = central_data) + \n  \n  # make histogram: specify bin break points: starts the Monday before first case, end Monday after last case\n  geom_histogram(\n    \n    # mapping aesthetics\n    mapping = aes(x = date_onset),  # date column mapped to x-axis\n    \n    # histogram bin breaks\n    breaks = weekly_breaks_central, # histogram bin breaks defined previously\n    \n    # bars\n    color = \"darkblue\",     # color of lines around bars\n    fill = \"lightblue\"      # color of fill within bars\n  )+ \n    \n  # x-axis labels\n  scale_x_date(\n    expand            = c(0,0),           # remove excess x-axis space before and after case bars\n    date_breaks       = \"4 weeks\",        # date labels and major vertical gridlines appear every 3 Monday weeks\n    date_minor_breaks = \"week\",           # minor vertical lines appear every Monday week\n    date_labels       = \"%a\\n%d %b\\n%Y\")+ # date labels format\n  \n  # y-axis\n  scale_y_continuous(\n    expand = c(0,0))+             # remove excess y-axis space below 0 (align histogram flush with x-axis)\n  \n  # aesthetic themes\n  theme_minimal()+                # simplify plot background\n  \n  theme(\n    plot.caption = element_text(hjust = 0,        # caption on left side\n                                face = \"italic\"), # caption in italics\n    axis.title = element_text(face = \"bold\"))+    # axis titles in bold\n  \n  # labels including dynamic caption\n  labs(\n    title    = \"Weekly incidence of cases (Monday weeks)\",\n    subtitle = \"Note alignment of bars, vertical gridlines, and axis labels on Monday weeks\",\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly incident cases reported\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %&gt;% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))\n\n\n\n\n\n\n\n\n\nPazar haftaları\nPazar haftaları için yukarıdaki grafiği elde etmek için birkaç değişiklik gereklidir, çünkü date_breaks = \"weeks\" sadece Pazartesi haftaları için çalışır.\n\nHistogram bölmelerinin sonlanma noktaları Pazar günleri olarak ayarlanmalıdır (week_start = 7).\nscale_x_date() içinde, tarih etiketlerinin ve dikey kılavuz çizgilerinin Pazar günleri hizalanmasını sağlamak için breaks = ve minor_breaks = için benzer tarih sonlanmaları sağlanmalıdır.\n\nÖrneğin, Pazar haftaları için scale_x_date() komutu şöyle görünebilir:\n\nscale_x_date(\n    expand = c(0,0),\n    \n    # specify interval of date labels and major vertical gridlines\n    breaks = seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7), # Sunday before first case\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # Sunday after last case\n      by   = \"4 weeks\"),\n    \n    # specify interval of minor vertical gridline \n    minor_breaks = seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7), # Sunday before first case\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # Sunday after last case\n      by   = \"week\"),\n   \n    # date label format\n    #date_labels = \"%a\\n%d %b\\n%Y\")+         # day, above month abbrev., above 2-digit year\n    label = scales::label_date_short())\n\n\n\n\nDeğere göre grup/renk\nHistogram çubukları, grup ve “yığılmış” olarak renklendirilebilir. Gruplandırma sütununu atamak için aşağıdaki değişiklikleri yapın. Ayrıntılar için [ggplot temelleri] sayfasına bakın.\n\nHistogram estetik haritalama aes()içinde, sütun adını group = ve fill = bağımsız değişkenini eşleştirin.\naes() dışındaki herhangi bir fill = argümanını kaldırın, çünkü içindekini geçersiz kılar.\n\naes() içindeki argümanlar gruba göre uygulanırken, dışındaki herhangi bir argüman tüm çubuklara uygulanacaktır (örneğin, yine de color = dışarıda isteyebilirsiniz, böylece her çubuk aynı kenarlığa sahip olur).\n\nÇubukları cinsiyete göre gruplamak ve renklendirmek için aes()komutu şöyle görünür:\n\naes(x = date_onset, group = gender, fill = gender)\n\nBurada uygulanır:\n\nggplot(data = linelist) +     # begin with linelist (many hospitals)\n  \n  # make histogram: specify bin break points: starts the Monday before first case, end Monday after last case\n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = hospital,       # set data to be grouped by hospital\n      fill = hospital),       # bar fill (inside color) by hospital\n    \n    # bin breaks are Monday weeks\n    breaks = weekly_breaks_all,   # sequence of weekly Monday bin breaks for whole outbreak, defined in previous code       \n    \n    # Color around bars\n    color = \"black\")\n\n\n\n\n\n\n\n\n\n\nRenkleri ayarlamak\n\nHer grup için dolguyu manuel olarak ayarlamak için scale_fill_manual() öğesini kullanın (not: scale_color_manual() farklıdır!).\n\nBir renk vektörü uygulamak için values = argümanını kullanın.\n\nNA değerleri için bir renk belirtmek için na.value = kullanın.\n\nGösterge öğelerinin metnini değiştirmek için labels = argümanını kullanın. Güvende olmak için, c(\"old\" = \"new\", \"old\" = \"new\") gibi adlandırılmış bir vektör sağlayın veya verilerin kendisindeki değerleri ayarlayın.\n\nAçıklamaya uygun bir başlık koymak için name = kullanın.\n\nRenk ölçekleri ve paletler hakkında daha fazla ipucu için [ggplot temelleri] sayfasına bakın.\n\n\nggplot(data = linelist)+           # begin with linelist (many hospitals)\n  \n  # make histogram\n  geom_histogram(\n    mapping = aes(x = date_onset,\n        group = hospital,          # cases grouped by hospital\n        fill = hospital),          # bar fill by hospital\n    \n    # bin breaks\n    breaks = weekly_breaks_all,        # sequence of weekly Monday bin breaks, defined in previous code\n    \n    # Color around bars\n    color = \"black\")+              # border color of each bar\n  \n  # manual specification of colors\n  scale_fill_manual(\n    values = c(\"black\", \"orange\", \"grey\", \"beige\", \"blue\", \"brown\"),\n    labels = c(\"St. Mark's Maternity Hospital (SMMH)\" = \"St. Mark's\"),\n    name = \"Hospital\") # specify fill colors (\"values\") - attention to order!\n\n\n\n\n\n\n\n\n\n\nSeviye sırasını ayarlamak\nGruplandırılmış çubukların istiflendiği sıra, en iyi şekilde gruplandırma sütununu sınıf Faktörü olarak sınıflandırarak ayarlanır. Daha sonra faktör düzeyi sırasını (ve bunların görüntü etiketlerini) belirleyebilirsiniz. Ayrıntılar için [Faktörler] veya [ggplot ipuçları] sayfasına bakın.\nGrafiği yapmadan önce, gruplandırma sütununu sınıf faktörüne dönüştürmek için forcats paketindeki fct_relevel() işlevini kullanın ve [Faktörler] sayfasında ayrıntılı olarak açıklandığı gibi seviye sırasını manuel olarak ayarlayın.\n\n# load forcats package for working with factors\npacman::p_load(forcats)\n\n# Define new dataset with hospital as factor\nplot_data &lt;- linelist %&gt;% \n  mutate(hospital = fct_relevel(hospital, c(\"Missing\", \"Other\"))) # Convert to factor and set \"Missing\" and \"Other\" as top levels to appear on epicurve top\n\nlevels(plot_data$hospital) # print levels in order\n\n[1] \"Missing\"                             \n[2] \"Other\"                               \n[3] \"Central Hospital\"                    \n[4] \"Military Hospital\"                   \n[5] \"Port Hospital\"                       \n[6] \"St. Mark's Maternity Hospital (SMMH)\"\n\n\nAşağıdaki çizimde, öncekinden tek fark, hospital sütununu yukarıdaki gibi konsolide edilmiş olmasıdır ve gösterge sırasını tersine çevirmek için guides()kullanıyoruz, böylece “Eksik” göstergenin alt kısmındadır.\n\nggplot(plot_data) +                     # Use NEW dataset with hospital as re-ordered factor\n  \n  # make histogram\n  geom_histogram(\n    mapping = aes(x = date_onset,\n        group = hospital,               # cases grouped by hospital\n        fill = hospital),               # bar fill (color) by hospital\n    \n    breaks = weekly_breaks_all,         # sequence of weekly Monday bin breaks for whole outbreak, defined at top of ggplot section\n    \n    color = \"black\")+                   # border color around each bar\n    \n  # x-axis labels\n  scale_x_date(\n    expand            = c(0,0),         # remove excess x-axis space before and after case bars\n    date_breaks       = \"3 weeks\",      # labels appear every 3 Monday weeks\n    date_minor_breaks = \"week\",         # vertical lines appear every Monday week\n    label = scales::label_date_short()) + # efficient label formatting\n  \n  # y-axis\n  scale_y_continuous(\n    expand = c(0,0))+                   # remove excess y-axis space below 0\n  \n  # manual specification of colors, ! attention to order\n  scale_fill_manual(\n    values = c(\"grey\", \"beige\", \"black\", \"orange\", \"blue\", \"brown\"),\n    labels = c(\"St. Mark's Maternity Hospital (SMMH)\" = \"St. Mark's\"),\n    name = \"Hospital\")+ \n  \n  # aesthetic themes\n  theme_minimal()+                      # simplify plot background\n  \n  theme(\n    plot.caption = element_text(face = \"italic\", # caption on left side in italics\n                                hjust = 0), \n    axis.title = element_text(face = \"bold\"))+   # axis titles in bold\n  \n  # labels\n  labs(\n    title    = \"Weekly incidence of cases by hospital\",\n    subtitle = \"Hospital as re-ordered factor\",\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly cases\")\n\n\n\n\n\n\n\n\nİPUCU: Yalnızca göstergenin sırasını tersine çevirmek için bu ggplot2 komutunu ekleyin: guides(fill = guide_legend(reverse = TRUE)).\n\n\nGöstergeyi ayarlamak\n[ggplot ipuçları] sayfasında göstergeler ve ölçekler hakkında daha fazla bilgi edinin. İşte birkaç önemli nokta:\n\nGösterge başlığını ölçek işlevinde veya labs(fill = \"Legend title\") ile düzenleyin (color = estetik kullanıyorsanız, labs(color = \"\") kullanın)\n\nGösterge başlığının olmaması için theme(legend.title = element_blank()) kulanın.\n\ntheme(legend.position = \"top\") (göstergeyi kaldırmak için “alt”, “sol”, “sağ” veya “yok”) kullanın.\nYatay gösterge için theme(legend.direction = \"horizontal\") kullanın.\nGöstergenin sırasını tersine çevirmek için guides(fill = guide_legend(reverse = TRUE)) kullanın.\n\n\n\nYan yana çubuklar\nGrup çubuklarının yan yana gösterimi (yığılmışın aksine) geom_histogram()içinde, position = \"dodge\" aes() dışına yerleştirilerek belirtilir.\nİkiden fazla değer grubu varsa, bunların okunması zorlaşabilir. Bunun yerine fasetli bir grafik (küçük katlar) kullanmayı düşünün. Bu örnekte okunabilirliği artırmak için eksik cinsiyet değerleri kaldırılmıştır.\n\nggplot(central_data %&gt;% drop_na(gender))+   # begin with Central Hospital cases dropping missing gender\n    geom_histogram(\n        mapping = aes(\n          x = date_onset,\n          group = gender,         # cases grouped by gender\n          fill = gender),         # bars filled by gender\n        \n        # histogram bin breaks\n        breaks = weekly_breaks_central,   # sequence of weekly dates for Central outbreak - defined at top of ggplot section\n        \n        color = \"black\",          # bar edge color\n        \n        position = \"dodge\")+      # SIDE-BY-SIDE bars\n                      \n  \n  # The labels on the x-axis\n  scale_x_date(expand            = c(0,0),         # remove excess x-axis space below and after case bars\n               date_breaks       = \"3 weeks\",      # labels appear every 3 Monday weeks\n               date_minor_breaks = \"week\",         # vertical lines appear every Monday week\n               label = scales::label_date_short())+ # efficient date labels\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+             # removes excess y-axis space between bottom of bars and the labels\n  \n  #scale of colors and legend labels\n  scale_fill_manual(values = c(\"brown\", \"orange\"),  # specify fill colors (\"values\") - attention to order!\n                    na.value = \"grey\" )+     \n\n  # aesthetic themes\n  theme_minimal()+                                               # a set of themes to simplify plot\n  theme(plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n        axis.title = element_text(face = \"bold\"))+               # axis titles in bold\n  \n  # labels\n  labs(title    = \"Weekly incidence of cases, by gender\",\n       subtitle = \"Subtitle\",\n       fill     = \"Gender\",                                      # provide new title for legend\n       x        = \"Week of symptom onset\",\n       y        = \"Weekly incident cases reported\")\n\n\n\n\n\n\n\n\n\n\nEksen sınırları\nEksen değerlerinin kapsamını sınırlamanın iki yolu vardır:\nGenellikle tercih edilen yol, xlim = c(min, max) ve ylim = c(min, max) (min ve max değerlerini sağladığınız) kabul eden coord_cartesian()komutunu kullanmaktır. Bu, istatistikler ve özet ölçümler için önemli olan herhangi bir veriyi fiilen kaldırmadan bir “yakınlaştırma” görevi görür.\nAlternatif olarak, scale_x_date()içinde limits = c() kullanarak maksimum ve minimum tarih değerlerini ayarlayabilirsiniz. Örneğin:\n\nscale_x_date(limits = c(as.Date(\"2014-04-01\"), NA)) # sets a minimum date but leaves the maximum open.  \n\nBenzer şekilde, x ekseninin belirli bir tarihe (örn. geçerli tarih) uzanmasını istiyorsanız, yeni vaka bildirilmemiş olsa bile şunları kullanabilirsiniz:\n\nscale_x_date(limits = c(NA, Sys.Date()) # ensures date axis will extend until current date  \n\nTEHLİKE: y ekseni ölçek sonları veya sınırlarını ayarlarken dikkatli olun (örn. 0 ila 30 by 5: seq(0, 30, 5)). Bu tür statik sayılar, veriler sınırı aşacak şekilde değişirse grafiğinizi çok kısa kesebilir!.\n\n\nTarih ekseni etiketleri/kılavuz çizgileri\nİPUCU: Tarih ekseni etiketlerinin verilerin çubuklar halinde toplanmasından bağımsız olduğunu, ancak görsel olarak bölmeleri, tarih etiketlerini ve dikey kılavuz çizgilerini hizalamanın önemli olabileceğini unutmayın.\nTarih etiketlerini ve kılavuz çizgilerini değiştirmek için, şu yollardan biriyle scale_x_date() kullanın:\n\nHistogram bölmeleriniz günler, Pazartesi haftaları, aylar veya yıllar ise:\n\nEtiketlerin ve ana kılavuz çizgilerinin aralığını belirtmek için date_breaks = kullanın (ör. “gün”, “hafta”, “3 hafta”, “ay” veya “yıl”).\nKüçük dikey kılavuz çizgilerinin aralığını belirtmek için date_minor_breaks = kullanın (tarih etiketleri arasında).\n\nEtiketlere ilk çubuktan başlamak için expand = c(0,0) ekleyin.\nTarih etiketlerinin biçimini belirtmek için date_labels = kullanın - ipuçları için tarihler sayfasına bakın (yeni bir satır için \\n kullanın).\n\n\nHistogram bölmeleriniz Pazar haftalarıysa:\n\nHer biri için bir tarih sonları dizisi sağlayarak breaks = ve minor_breaks = kullanın.\nYukarıda açıklandığı gibi biçimlendirme için hala ddate_labels = ve expand = kullanabilirsiniz.\n\n\nBazı notlar:\n\nseq.Date() kullanarak bir tarih dizisinin nasıl oluşturulacağına ilişkin talimatlar için açılış ggplot bölümüne bakın.\n\nTarih etiketleri oluşturmaya ilişkin ipuçları için bu sayfaya veya [Tarihlerle çalışma sayfasına] bakın.\n\n\nSunumlar\nAşağıda, bölmeler ve grafik etiketlerinin/kılavuz çizgilerinin hizalandığı ve hizalanmadığı grafiklerin bir gösterimi bulunmaktadır:\n\n# 7-day bins + Monday labels\n#############################\nggplot(central_data) +\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    binwidth = 7,                 # 7-day bins with start at first case\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n  \n  scale_x_date(\n    expand = c(0,0),               # remove excess x-axis space below and after case bars\n    date_breaks = \"3 weeks\",       # Monday every 3 weeks\n    date_minor_breaks = \"week\",    # Monday weeks\n    label = scales::label_date_short())+ # automatic label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+              # remove excess space under x-axis, make flush\n  \n  labs(\n    title = \"MISALIGNED\",\n    subtitle = \"! CAUTION: 7-day bars start Thursdays at first case\\nDate labels and gridlines on Mondays\\nNote how ticks don't align with bars\")\n\n\n\n# 7-day bins + Months\n#####################\nggplot(central_data) +\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    binwidth = 7,\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n  \n  scale_x_date(\n    expand = c(0,0),                  # remove excess x-axis space below and after case bars\n    date_breaks = \"months\",           # 1st of month\n    date_minor_breaks = \"week\",       # Monday weeks\n    label = scales::label_date_short())+ # label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remove excess space under x-axis, make flush \n  \n  labs(\n    title = \"MISALIGNED\",\n    subtitle = \"! CAUTION: 7-day bars start Thursdays with first case\\nMajor gridlines and date labels at 1st of each month\\nMinor gridlines weekly on Mondays\\nNote uneven spacing of some gridlines and ticks unaligned with bars\")\n\n\n# TOTAL MONDAY ALIGNMENT: specify manual bin breaks to be mondays\n#################################################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # histogram breaks set to 7 days beginning Monday before first case\n    breaks = weekly_breaks_central,    # defined earlier in this page\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),                   # remove excess x-axis space below and after case bars\n    date_breaks = \"4 weeks\",           # Monday every 4 weeks\n    date_minor_breaks = \"week\",        # Monday weeks \n    label = scales::label_date_short())+ # label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remove excess space under x-axis, make flush \n  \n  labs(\n    title = \"ALIGNED Mondays\",\n    subtitle = \"7-day bins manually set to begin Monday before first case (28 Apr)\\nDate labels and gridlines on Mondays as well\")\n\n\n# TOTAL MONDAY ALIGNMENT WITH MONTHS LABELS:\n############################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # histogram breaks set to 7 days beginning Monday before first case\n    breaks = weekly_breaks_central,            # defined earlier in this page\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),                   # remove excess x-axis space below and after case bars\n    date_breaks = \"months\",            # Monday every 4 weeks\n    date_minor_breaks = \"week\",        # Monday weeks \n    label = scales::label_date_short())+ # label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remove excess space under x-axis, make flush \n  \n  theme(panel.grid.major = element_blank())+  # Remove major gridlines (fall on 1st of month)\n          \n  labs(\n    title = \"ALIGNED Mondays with MONTHLY labels\",\n    subtitle = \"7-day bins manually set to begin Monday before first case (28 Apr)\\nDate labels on 1st of Month\\nMonthly major gridlines removed\")\n\n\n# TOTAL SUNDAY ALIGNMENT: specify manual bin breaks AND labels to be Sundays\n############################################################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # histogram breaks set to 7 days beginning Sunday before first case\n    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                      by   = \"7 days\"),\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),\n    # date label breaks and major gridlines set to every 3 weeks beginning Sunday before first case\n    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                      by   = \"3 weeks\"),\n    \n    # minor gridlines set to weekly beginning Sunday before first case\n    minor_breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                            to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                            by   = \"7 days\"),\n    \n    label = scales::label_date_short())+ # automatic label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remove excess space under x-axis, make flush \n  \n  labs(title = \"ALIGNED Sundays\",\n       subtitle = \"7-day bins manually set to begin Sunday before first case (27 Apr)\\nDate labels and gridlines manually set to Sundays as well\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nToplu veri\nGenellikle bir satır listesi yerine tesislerden, bölgelerden vb. toplu sayımlarla başlarsınız. ggplot() ile bir salgın eğrisi oluşturabilirsiniz ancak kod biraz farklı olacaktır. Bu bölüm, veri hazırlama bölümünde daha önce içe aktarılan count_data veri setini kullanacaktır. Bu veri seti, günlük hastane sayımlarına göre toplanan linelist’dir. İlk 50 satır aşağıda gösterilmiştir.\n\n\n\n\n\n\n\nKomut Dosyası Çizimi günlük sayımlar\nBu günlük sayımlardan günlük bir salgın eğrisi çizebiliriz. İşte koddaki farklar:\n\nEstetik haritalama aes() içinde, sayımlar sütunu olarak y = belirtin (bu durumda, sütun adı n_cases ’dir).\nstat = \"identity\" argümanını geom_histogram()içine ekleyin; bu, çubuk yüksekliğinin varsayılan olarak satır sayısı değil, y = değeri olması gerektiğini belirtir.\n\nÇubuklar arasında dikey beyaz çizgileri önlemek için width = argümanını ekleyin. 1’e ayarlanmış günlük veriler için 7’ye ayarlanmış haftalık sayım verileri için Aylık sayım verileri için beyaz çizgiler bir sorundur (her ayın farklı gün sayısı vardır) - x ekseninizi kategorik sıralı bir faktöre (aylar) dönüştürmeyi ve geom_col()kullanmayı düşünün.\n\n\nggplot(data = count_data)+\n  geom_histogram(\n   mapping = aes(x = date_hospitalisation, y = n_cases),\n   stat = \"identity\",\n   width = 1)+                # for daily counts, set width = 1 to avoid white space between bars\n  labs(\n    x = \"Date of report\", \n    y = \"Number of cases\",\n    title = \"Daily case incidence, from daily count data\")\n\n\n\n\n\n\n\n\n\n\nHaftalık sayıların çizilmesi\nVerileriniz zaten haftaya göre vaka sayılarıysa, bu veri kümesine benzeyebilirler (count_data_weekly olarak adlandırılır):\ncount_data_weekly ’nin ilk 50 satırı aşağıda gösterilmiştir. Sayıların haftalar halinde toplandığını görebilirsiniz. Her hafta, haftanın ilk gününe göre görüntülenir (varsayılan olarak Pazartesi).\n\n\n\n\n\n\nŞimdi x = salgın haftası sütunu olacak şekilde çizin. Estetik haritalamaya y = sayı sütununu eklemeyi ve yukarıda açıklandığı gibi stat = \"identity\" eklemeyi unutmayın.\n\nggplot(data = count_data_weekly)+\n  \n  geom_histogram(\n    mapping = aes(\n      x = epiweek,           # x-axis is epiweek (as class Date)\n      y = n_cases_weekly,    # y-axis height in the weekly case counts\n      group = hospital,      # we are grouping the bars and coloring by hospital\n      fill = hospital),\n    stat = \"identity\")+      # this is also required when plotting count data\n     \n  # labels for x-axis\n  scale_x_date(\n    date_breaks = \"2 months\",      # labels every 2 months \n    date_minor_breaks = \"1 month\", # gridlines every month\n    label = scales::label_date_short())+ # automatic label formatting\n     \n  # Choose color palette (uses RColorBrewer package)\n  scale_fill_brewer(palette = \"Pastel2\")+ \n  \n  theme_minimal()+\n  \n  labs(\n    x = \"Week of onset\", \n    y = \"Weekly case incidence\",\n    fill = \"Hospital\",\n    title = \"Weekly case incidence, from aggregated count data by hospital\")\n\n\n\n\n\n\n\n\n\n\n\nHareketli ortalamalar\nAyrıntılı bir açıklama ve çeşitli seçenekler için Hareketli ortalamalar sayfasına bakın. Aşağıda, slider paketi ile hareketli ortalamaları hesaplamak için bir seçenek bulunmaktadır. Bu yaklaşımda, hareketli ortalama, çizimden önce veri setinde hesaplanır:\n\nVerileri gerektiği gibi sayımlar halinde toplayın (günlük, haftalık vb.) (bkz. [Verileri gruplandırma] sayfası).\n\nslider paketinden slide_index() ile oluşturulan hareketli ortalamayı tutmak için yeni bir sütun oluşturun.\n\nHareketli ortalamayı, salgın eğrisi histogramının üstüne (sonra) bir geom_line()olarak çizin.\n\nYararlı çevrimiçi slider paketi için belirtece bakın.\n\n# load package\npacman::p_load(slider)  # slider used to calculate rolling averages\n\n# make dataset of daily counts and 7-day moving average\n#######################################################\nll_counts_7day &lt;- linelist %&gt;%    # begin with linelist\n  \n  ## count cases by date\n  count(date_onset, name = \"new_cases\") %&gt;%   # name new column with counts as \"new_cases\"\n  drop_na(date_onset) %&gt;%                     # remove cases with missing date_onset\n  \n  ## calculate the average number of cases in 7-day window\n  mutate(\n    avg_7day = slider::slide_index(    # create new column\n      new_cases,                       # calculate based on value in new_cases column\n      .i = date_onset,                 # index is date_onset col, so non-present dates are included in window \n      .f = ~mean(.x, na.rm = TRUE),    # function is mean() with missing values removed\n      .before = 6,                     # window is the day and 6-days before\n      .complete = FALSE),              # must be FALSE for unlist() to work in next step\n    avg_7day = unlist(avg_7day))       # convert class list to class numeric\n\n\n# plot\n######\nggplot(data = ll_counts_7day) +  # begin with new dataset defined above \n    geom_histogram(              # create epicurve histogram\n      mapping = aes(\n        x = date_onset,          # date column as x-axis\n        y = new_cases),          # height is number of daily new cases\n        stat = \"identity\",       # height is y value\n        fill=\"#92a8d1\",          # cool color for bars\n        colour = \"#92a8d1\",      # same color for bar border\n        )+ \n    geom_line(                   # make line for rolling average\n      mapping = aes(\n        x = date_onset,          # date column for x-axis\n        y = avg_7day,            # y-value set to rolling average column\n        lty = \"7-day \\nrolling avg\"), # name of line in legend\n      color=\"red\",               # color of line\n      size = 1) +                # width of line\n    scale_x_date(                # date scale\n      date_breaks = \"1 month\",\n      label = scales::label_date_short(), # automatic label formatting\n      expand = c(0,0)) +\n    scale_y_continuous(          # y-axis scale\n      expand = c(0,0),\n      limits = c(0, NA)) +       \n    labs(\n      x=\"\",\n      y =\"Number of confirmed cases\",\n      fill = \"Legend\")+ \n    theme_minimal()+\n    theme(legend.title = element_blank())  # removes title of legend\n\n\n\n\n\n\n\n\n\n\nFasetleme/küçük-katlar\nDiğer ggplot’larda olduğu gibi, fasetli grafikler (“küçük katlar”) oluşturabilirsiniz. Bu el kitabının [ggplot ipuçları] sayfasında açıklandığı gibi, ya facet_wrap() ya da facet_grid()kullanabilirsiniz. Burada facet_wrap()ile gösteriyoruz. Salgın eğrileri için, facet_wrap()genellikle daha kolaydır, çünkü muhtemelen yalnızca bir sütunda fasetleme yapmanız gerekir.\nGenel sözdizimi facet_wrap(rows ~ cols)şeklindedir; burada yaklaşık işaretinin (~) solunda fasetli grafiğin “satırları”na yayılacak bir sütunun adı ve yaklaşık işaretinin sağında, fasetli grafiğin “sütunlarına” yayılacak bir sütunun adı bulunur. En basitinden, yaklaşık işaretinin sağındaki bir sütun adı kullanın: facet_wrap(~age_cat).\nSerbest eksenler\nHer bir faset için eksenlerin ölçeklerinin aynı boyutlara “sabit” (varsayılan) veya “serbest” (yani, faset içindeki verilere göre değişecekleri) olup olmadığına karar vermeniz gerekecektir. Bunu, “free_x” veya “free_y” veya “free” belirterek facet_wrap() içindeki scales = argümanı ile yapın.\nFasetlerin sütun ve satır sayısı\nBu, facet_wrap()içinde ncol = ve nrow = ile belirtilebilir.\nPanellerin sırası\nGörünüm sırasını değiştirmek için, fasetleri oluşturmak için kullanılan faktör sütununun düzeylerinin temel sırasını değiştirin.\nEstetik\nYazı tipi boyutu ve yüzü, şerit rengi vb., theme() aracılığıyla aşağıdaki gibi argümanlarla değiştirilebilir:\n\nstrip.text = element_text() (boyut, renk, yüz, açı…)\nstrip.background = element_rect() (ör. element_rect(dolgu=“gri”))\n\nstrip.position = ((“alt”, “üst”, “sol” veya “sağ” şeridin konumu)\n\nŞerit etiketleri\nFaset grafiklerinin etiketleri, bir faktör olarak sütunun “etiketleri” aracılığıyla veya bir “etiketleyici” kullanılarak değiştirilebilir.\nggplot2’deki as_labeller()işlevini kullanarak böyle bir etiketleyici yapın. Ardından, etiketleyiciyi, aşağıda gösterildiği gibi facet_wrap()öğesinin labeller = argümanına yerleştirin.\n\nmy_labels &lt;- as_labeller(c(\n     \"0-4\"   = \"Ages 0-4\",\n     \"5-9\"   = \"Ages 5-9\",\n     \"10-14\" = \"Ages 10-14\",\n     \"15-19\" = \"Ages 15-19\",\n     \"20-29\" = \"Ages 20-29\",\n     \"30-49\" = \"Ages 30-49\",\n     \"50-69\" = \"Ages 50-69\",\n     \"70+\"   = \"Over age 70\"))\n\nÖrnek bir fasetli grafik  - age_cat sütunu ile fasetli.\n\n# make plot\n###########\nggplot(central_data) + \n  \n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = age_cat,\n      fill = age_cat),    # arguments inside aes() apply by group\n      \n    color = \"black\",      # arguments outside aes() apply to all data\n        \n    # histogram breaks\n    breaks = weekly_breaks_central)+  # pre-defined date vector (see earlier in this page)\n                      \n  # The labels on the x-axis\n  scale_x_date(\n    expand            = c(0,0),         # remove excess x-axis space below and after case bars\n    date_breaks       = \"2 months\",     # labels appear every 2 months\n    date_minor_breaks = \"1 month\",      # vertical lines appear every 1 month \n    label = scales::label_date_short())+     # date labels format\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+                       # removes excess y-axis space between bottom of bars and the labels\n  \n  # aesthetic themes\n  theme_minimal()+                                           # a set of themes to simplify plot\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    strip.text = element_text(face = \"bold\", size = 10),\n    strip.background = element_rect(fill = \"grey\"))+         # axis titles in bold\n  \n  # create facets\n  facet_wrap(\n    ~age_cat,\n    ncol = 4,\n    strip.position = \"top\",\n    labeller = my_labels)+             \n  \n  # labels\n  labs(\n    title    = \"Weekly incidence of cases, by age category\",\n    subtitle = \"Subtitle\",\n    fill     = \"Age category\",                                      # provide new title for legend\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly incident cases reported\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %&gt;% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))\n\n\n\n\n\n\n\n\nEtiketleyiciler hakkında daha fazla bilgi için bu bağlantıya bakın.\n\nFaset arka planında toplam salgın\nHer fasetin arka planında toplam salgını göstermek için, ggplot’a boş parantezlerle gghighlight() işlevini ekleyin. Bu, gghighlight paketinden bir komuttur. Tüm yönlerdeki maksimum y ekseninin artık tüm salgının zirvesine dayandığını unutmayın. [ggplot ipuçları] sayfasında bu paketin daha fazla örneği mevcuttur.\n\nggplot(central_data) + \n  \n  # epicurves by group\n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = age_cat,\n      fill = age_cat),  # arguments inside aes() apply by group\n    \n    color = \"black\",    # arguments outside aes() apply to all data\n    \n    # histogram breaks\n    breaks = weekly_breaks_central)+     # pre-defined date vector (see top of ggplot section)                \n  \n  # add grey epidemic in background to each facet\n  gghighlight::gghighlight()+\n  \n  # labels on x-axis\n  scale_x_date(\n    expand            = c(0,0),         # remove excess x-axis space below and after case bars\n    date_breaks       = \"2 months\",     # labels appear every 2 months\n    date_minor_breaks = \"1 month\",      # vertical lines appear every 1 month \n    label = scales::label_date_short())+     # date labels format\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+  # removes excess y-axis space below 0\n  \n  # aesthetic themes\n  theme_minimal()+                                           # a set of themes to simplify plot\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    strip.text = element_text(face = \"bold\", size = 10),\n    strip.background = element_rect(fill = \"white\"))+        # axis titles in bold\n  \n  # create facets\n  facet_wrap(\n    ~age_cat,                          # each plot is one value of age_cat\n    ncol = 4,                          # number of columns\n    strip.position = \"top\",            # position of the facet title/strip\n    labeller = my_labels)+             # labeller defines above\n  \n  # labels\n  labs(\n    title    = \"Weekly incidence of cases, by age category\",\n    subtitle = \"Subtitle\",\n    fill     = \"Age category\",                                      # provide new title for legend\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly incident cases reported\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %&gt;% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))\n\n\n\n\n\n\n\n\n\n\nVeri içeren bir faset\nTüm verileri içeren bir model kutusuna sahip olmak istiyorsanız, tüm veri setini çoğaltın ve kopyaları tek bir model değeri olarak değerlendirin. Aşağıdaki bir “yardımcı” işlevi CreateAllFacet() bu konuda yardımcı olabilir (bu blog yazısı sayesinde). Çalıştırıldığında, satır sayısı iki katına çıkar ve yinelenen satırların “tümü” değerine sahip olacağı ve orijinal satırların faset sütununun orijinal değerine sahip olacağı, facet adlı yeni bir sütun olacaktır. Şimdi sadece facet sütununda faset yapmanız gerekiyor.\nKullanabilmeniz için çalıştırılması gereken yardımcı fonksiyon buradadır:\n\n# Define helper function\nCreateAllFacet &lt;- function(df, col){\n     df$facet &lt;- df[[col]]\n     temp &lt;- df\n     temp$facet &lt;- \"all\"\n     merged &lt;-rbind(temp, df)\n     \n     # ensure the facet value is a factor\n     merged[[col]] &lt;- as.factor(merged[[col]])\n     \n     return(merged)\n}\n\nŞimdi yardımcı işlevi veri setine age_cat sütununda uygulayın:\n\n# Create dataset that is duplicated and with new column \"facet\" to show \"all\" age categories as another facet level\ncentral_data2 &lt;- CreateAllFacet(central_data, col = \"age_cat\") %&gt;%\n  \n  # set factor levels\n  mutate(facet = fct_relevel(facet, \"all\", \"0-4\", \"5-9\",\n                             \"10-14\", \"15-19\", \"20-29\",\n                             \"30-49\", \"50-69\", \"70+\"))\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `facet = fct_relevel(...)`.\nCaused by warning:\n! 1 unknown level in `f`: 70+\n\n# check levels\ntable(central_data2$facet, useNA = \"always\")\n\n\n  all   0-4   5-9 10-14 15-19 20-29 30-49 50-69  &lt;NA&gt; \n  454    84    84    82    58    73    57     7     9 \n\n\nggplot() komutundaki dikkate değer değişiklikler şunlardır:\n\nKullanılan veriler artık central_data2’dir (yeni “facet” sütunu ile satırları ikiye katlayın).\nEtiketleyici kullanılıyorsa güncellenmesi gerekecek.\n\n● İsteğe bağlı: dikey olarak yığılmış yüzeyler elde etmek için: model sütunu denklemin satır tarafına taşınır ve sağdaki “.” ile değiştirilir. (facet_wrap(facet~.)) ve ncol = 1. Kaydedilmiş png çizim görüntüsünün genişliğini ve yüksekliğini de ayarlamanız gerekebilir ([ggplot ipuçlarında] ggsave()’e bakın).\n\n\nggplot(central_data2) + \n  \n  # actual epicurves by group\n  geom_histogram(\n        mapping = aes(\n          x = date_onset,\n          group = age_cat,\n          fill = age_cat),  # arguments inside aes() apply by group\n        color = \"black\",    # arguments outside aes() apply to all data\n        \n        # histogram breaks\n        breaks = weekly_breaks_central)+    # pre-defined date vector (see top of ggplot section)\n                     \n  # Labels on x-axis\n  scale_x_date(\n    expand            = c(0,0),         # remove excess x-axis space below and after case bars\n    date_breaks       = \"2 months\",     # labels appear every 2 months\n    date_minor_breaks = \"1 month\",      # vertical lines appear every 1 month \n    label = scales::label_date_short())+     # date labels format\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+  # removes excess y-axis space between bottom of bars and the labels\n  \n  # aesthetic themes\n  theme_minimal()+                                           # a set of themes to simplify plot\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\")+               \n  \n  # create facets\n  facet_wrap(facet~. ,                            # each plot is one value of facet\n             ncol = 1)+            \n\n  # labels\n  labs(title    = \"Weekly incidence of cases, by age category\",\n       subtitle = \"Subtitle\",\n       fill     = \"Age category\",                                      # provide new title for legend\n       x        = \"Week of symptom onset\",\n       y        = \"Weekly incident cases reported\",\n       caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %&gt;% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Salgın eğrileri</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.tr.html#geçici-veriler",
    "href": "new_pages/epicurves.tr.html#geçici-veriler",
    "title": "32  Salgın eğrileri",
    "section": "32.3 Geçici veriler",
    "text": "32.3 Geçici veriler\nSalgın eğrilerinde gösterilen en son veriler genellikle geçici olarak işaretlenmeli veya raporlama gecikmelerine tabi olmalıdır. Bu, belirli sayıda gün boyunca dikey bir çizgi ve/veya dikdörtgen eklenerek yapılabilir. İşte iki seçenek:\n\nannotate() kullanın:\n\nBir satır için annotate(geom = \"segment\") kullanın. x, xend, y, ve yend’i temin edin. Boyutu, çizgi tipini (lty) ve rengi ayarlayın.\n\nDikdörtgen için annotate(geom = \"rect\") kullanın. xmin/xmax/ymin/ymax’ı temin edin. Rengi ve alfayı ayarlayın.\n\n\nVerileri geçici duruma göre gruplandırın ve bu çubukları farklı şekilde renklendirin.\n\nDİKKAT: Bir dikdörtgen çizmek için geom_rect()’i deneyebilirsiniz, ancak şeffaflığı ayarlamak bir satır listesi bağlamında çalışmaz. Bu işlev, her gözlem/sıra için bir dikdörtgeni kaplar!. Çok düşük bir alfa (ör. 0.01) veya başka bir yaklaşım kullanın. \n\nannotate() kullanma\n\nannotate(geom = \"rect\") içinde, xmin ve xmax argümanlarına Date sınıfının girdileri verilmelidir.\n\nBu veriler haftalık çubuklar halinde toplandığından ve son çubuk, son veri noktasından sonraki Pazartesi gününe kadar uzandığından, gölgeli bölgenin 4 haftayı kapsıyor gibi görünebileceğini unutmayın.\n\nİşte bir annotate() online örneği.\n\n\nggplot(central_data) + \n  \n  # histogram\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    breaks = weekly_breaks_central,   # pre-defined date vector - see top of ggplot section\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") +\n\n  # scales\n  scale_y_continuous(expand = c(0,0))+\n  scale_x_date(\n    expand = c(0,0),                   # remove excess x-axis space below and after case bars\n    date_breaks = \"1 month\",           # 1st of month\n    date_minor_breaks = \"1 month\",     # 1st of month\n    label = scales::label_date_short())+          # label format\n  \n  # labels and theme\n  labs(\n    title = \"Using annotate()\\nRectangle and line showing that data from last 21-days are tentative\",\n    x = \"Week of symptom onset\",\n    y = \"Weekly case indicence\")+ \n  theme_minimal()+\n  \n  # add semi-transparent red rectangle to tentative data\n  annotate(\n    \"rect\",\n    xmin  = as.Date(max(central_data$date_onset, na.rm = T) - 21), # note must be wrapped in as.Date()\n    xmax  = as.Date(Inf),                                          # note must be wrapped in as.Date()\n    ymin  = 0,\n    ymax  = Inf,\n    alpha = 0.2,          # alpha easy and intuitive to adjust using annotate()\n    fill  = \"red\")+\n  \n  # add black vertical line on top of other layers\n  annotate(\n    \"segment\",\n    x     = max(central_data$date_onset, na.rm = T) - 21, # 21 days before last data\n    xend  = max(central_data$date_onset, na.rm = T) - 21, \n    y     = 0,         # line begins at y = 0\n    yend  = Inf,       # line to top of plot\n    size  = 2,         # line size\n    color = \"black\",\n    lty   = \"solid\")+   # linetype e.g. \"solid\", \"dashed\"\n\n  # add text in rectangle\n  annotate(\n    \"text\",\n    x = max(central_data$date_onset, na.rm = T) - 15,\n    y = 15,\n    label = \"Subject to reporting delays\",\n    angle = 90)\n\n\n\n\n\n\n\n\nAynı siyah dikey çizgi aşağıdaki kodla da elde edilebilir, ancak geom_vline() fonksiyonunu kullanarak yüksekliği kontrol etme yeteneğinizi kaybedersiniz:\n\ngeom_vline(xintercept = max(central_data$date_onset, na.rm = T) - 21,\n           size = 2,\n           color = \"black\")\n\n\n\nÇubukların rengi\nAlternatif bir yaklaşım, geçici veri çubuklarının rengini veya görüntüsünü ayarlamak olabilir. Veri hazırlama aşamasında yeni bir sütun oluşturabilir ve bunu, geçici verilerin aes(fill = )değeri diğer çubuklardan farklı bir renk veya alfa olacak şekilde verileri gruplamak için kullanabilirsiniz.\n\n# add column\n############\nplot_data &lt;- central_data %&gt;% \n  mutate(tentative = case_when(\n    date_onset &gt;= max(date_onset, na.rm=T) - 7 ~ \"Tentative\", # tenative if in last 7 days\n    TRUE                                       ~ \"Reliable\")) # all else reliable\n\n# plot\n######\nggplot(plot_data, aes(x = date_onset, fill = tentative)) + \n  \n  # histogram\n  geom_histogram(\n    breaks = weekly_breaks_central,   # pre-defined data vector, see top of ggplot page\n    color = \"black\") +\n\n  # scales\n  scale_y_continuous(expand = c(0,0))+\n  scale_fill_manual(values = c(\"lightblue\", \"grey\"))+\n  scale_x_date(\n    expand = c(0,0),                   # remove excess x-axis space below and after case bars\n    date_breaks = \"3 weeks\",           # Monday every 3 weeks\n    date_minor_breaks = \"week\",        # Monday weeks \n    label = scales::label_date_short())+      # label format\n  \n  # labels and theme\n  labs(title = \"Show days that are tentative reporting\",\n    subtitle = \"\")+ \n  theme_minimal()+\n  theme(legend.title = element_blank())                 # remove title of legend",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Salgın eğrileri</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.tr.html#çok-seviyeli-tarih-etiketleri",
    "href": "new_pages/epicurves.tr.html#çok-seviyeli-tarih-etiketleri",
    "title": "32  Salgın eğrileri",
    "section": "32.4 Çok seviyeli tarih etiketleri",
    "text": "32.4 Çok seviyeli tarih etiketleri\nAlt etiket düzeylerini çoğaltmadan çok düzeyli tarih etiketleri (ör. ay ve yıl) istiyorsanız, aşağıdaki yaklaşımlardan birini göz önünde bulundurun:\nUnutmayın - her bir etiketin parçalarını aşağıdaki yeni bir satıra koymak için date_labels veya labels argümanları içinde \\n gibi araçları kullanabilirsiniz. Bununla birlikte, aşağıdaki kod, daha düşük bir satırda ve yalnızca bir kez yıllar veya aylar (örneğin) almanıza yardımcı olur. Aşağıdaki kodla ilgili birkaç not:\n\nVaka sayıları estetik nedenlerle haftalar halinde toplanır. Ayrıntılar için salgın eğrisi sayfasına (toplanmış veri sekmesi) bakın..\n\nAşağıdaki yüzey oluşturma yaklaşımı histogramlarla iyi çalışmadığından, histogram yerine geom_area()çizgisi kullanılır.\n\nHaftalık sayımlara toplayın\n\n# Create dataset of case counts by week\n#######################################\ncentral_weekly &lt;- linelist %&gt;%\n  filter(hospital == \"Central Hospital\") %&gt;%   # filter linelist\n  mutate(week = lubridate::floor_date(date_onset, unit = \"weeks\")) %&gt;%  \n  count(week) %&gt;%                              # summarize weekly case counts\n  drop_na(week) %&gt;%                            # remove cases with missing onset_date\n  complete(                                    # fill-in all weeks with no cases reported\n    week = seq.Date(\n      from = min(week),   \n      to   = max(week),\n      by   = \"week\"),\n    fill = list(n = 0))                        # convert new NA values to 0 counts\n\nGrafik yapın\n\n# plot with box border on year\n##############################\nggplot(central_weekly) +\n  geom_area(aes(x = week, y = n),    # make line, specify x and y\n            stat = \"identity\") +             # because line height is count number\n  scale_x_date(date_labels=\"%b\",             # date label format show month \n               date_breaks=\"month\",          # date labels on 1st of each month\n               expand=c(0,0)) +              # remove excess space on each end\n  scale_y_continuous(\n    expand  = c(0,0))+                       # remove excess space below x-axis\n  facet_grid(~lubridate::year(week), # facet on year (of Date class column)\n             space=\"free_x\",                \n             scales=\"free_x\",                # x-axes adapt to data range (not \"fixed\")\n             switch=\"x\") +                   # facet labels (year) on bottom\n  theme_bw() +\n  theme(strip.placement = \"outside\",         # facet labels placement\n        strip.background = element_rect(fill = NA, # facet labels no fill grey border\n                                        colour = \"grey50\"),\n        panel.spacing = unit(0, \"cm\"))+      # no space between facet panels\n  labs(title = \"Nested year labels, grey label border\")\n\n\n\n\n\n\n\n# plot with no box border on year\n#################################\nggplot(central_weekly,\n       aes(x = week, y = n)) +              # establish x and y for entire plot\n  geom_line(stat = \"identity\",              # make line, line height is count number\n            color = \"#69b3a2\") +            # line color\n  geom_point(size=1, color=\"#69b3a2\") +     # make points at the weekly data points\n  geom_area(fill = \"#69b3a2\",               # fill area below line\n            alpha = 0.4)+                   # fill transparency\n  scale_x_date(date_labels=\"%b\",            # date label format show month \n               date_breaks=\"month\",         # date labels on 1st of each month\n               expand=c(0,0)) +             # remove excess space\n  scale_y_continuous(\n    expand  = c(0,0))+                      # remove excess space below x-axis\n  facet_grid(~lubridate::year(week),        # facet on year (of Date class column)\n             space=\"free_x\",                \n             scales=\"free_x\",               # x-axes adapt to data range (not \"fixed\")\n             switch=\"x\") +                  # facet labels (year) on bottom\n  theme_bw() +\n  theme(strip.placement = \"outside\",                     # facet label placement\n          strip.background = element_blank(),            # no facet lable background\n          panel.grid.minor.x = element_blank(),          \n          panel.border = element_rect(colour=\"grey40\"),  # grey border to facet PANEL\n          panel.spacing=unit(0,\"cm\"))+                   # No space between facet panels\n  labs(title = \"Nested year labels - points, shaded, no label border\")\n\n\n\n\n\n\n\n\nYukarıdaki teknikler bu ve stackoverflow.com’daki bu gönderiden uyarlanmıştır.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Salgın eğrileri</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.tr.html#çift-eksen",
    "href": "new_pages/epicurves.tr.html#çift-eksen",
    "title": "32  Salgın eğrileri",
    "section": "32.5 Çift eksen",
    "text": "32.5 Çift eksen\nVeri görselleştirme topluluğu içinde ikili eksenlerin geçerliliği hakkında şiddetli tartışmalar olmasına rağmen, birçok salgın süpervizör hala ikinci bir eksenle kaplanmış yüzde içeren bir salgın eğrisi veya benzer bir grafik görmek istiyor. Bu, [ggplot ipuçları] sayfasında daha kapsamlı bir şekilde tartışılmıştır, ancak cowplot yöntemini kullanan bir örnek aşağıda gösterilmiştir:\n\nİki farklı grafik yapılır ve daha sonra cowplot paketi ile birleştirilir.\n\nGrafikler tam olarak aynı x eksenine (belirlenen sınırlar) sahip olmalıdır, aksi takdirde veriler ve etiketler hizalanmayacaktır.\n\nHer biri theme_cowplot()kullanır ve birinin y ekseni grafiğin sağ tarafına hareket ettirilir.\n\n\n#load package\npacman::p_load(cowplot)\n\n# Make first plot of epicurve histogram\n#######################################\nplot_cases &lt;- linelist %&gt;% \n  \n  # plot cases per week\n  ggplot()+\n  \n  # create histogram  \n  geom_histogram(\n    \n    mapping = aes(x = date_onset),\n    \n    # bin breaks every week beginning monday before first case, going to monday after last case\n    breaks = weekly_breaks_all)+  # pre-defined vector of weekly dates (see top of ggplot section)\n        \n  # specify beginning and end of date axis to align with other plot\n  scale_x_date(\n    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # min/max of the pre-defined weekly breaks of histogram\n  \n  # labels\n  labs(\n      y = \"Daily cases\",\n      x = \"Date of symptom onset\"\n    )+\n  theme_cowplot()\n\n\n# make second plot of percent died per week\n###########################################\nplot_deaths &lt;- linelist %&gt;%                        # begin with linelist\n  group_by(week = floor_date(date_onset, \"week\")) %&gt;%  # create week column\n  \n  # summarise to get weekly percent of cases who died\n  summarise(n_cases = n(),\n            died = sum(outcome == \"Death\", na.rm=T),\n            pct_died = 100*died/n_cases) %&gt;% \n  \n  # begin plot\n  ggplot()+\n  \n  # line of weekly percent who died\n  geom_line(                                # create line of percent died\n    mapping = aes(x = week, y = pct_died),  # specify y-height as pct_died column\n    stat = \"identity\",                      # set line height to the value in pct_death column, not the number of rows (which is default)\n    size = 2,\n    color = \"black\")+\n  \n  # Same date-axis limits as the other plot - perfect alignment\n  scale_x_date(\n    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # min/max of the pre-defined weekly breaks of histogram\n  \n  \n  # y-axis adjustments\n  scale_y_continuous(                # adjust y-axis\n    breaks = seq(0,100, 10),         # set break intervals of percent axis\n    limits = c(0, 100),              # set extent of percent axis\n    position = \"right\")+             # move percent axis to the right\n  \n  # Y-axis label, no x-axis label\n  labs(x = \"\",\n       y = \"Percent deceased\")+      # percent axis label\n  \n  theme_cowplot()                   # add this to make the two plots merge together nicely\n\nŞimdi iki grafiiği kaplamak için cowplot kullanın. x ekseni hizalamasına, y ekseninin yanına ve theme_cowplot()kullanımına dikkat edin.\n\naligned_plots &lt;- cowplot::align_plots(plot_cases, plot_deaths, align=\"hv\", axis=\"tblr\")\nggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Salgın eğrileri</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.tr.html#kümülatif-insidans",
    "href": "new_pages/epicurves.tr.html#kümülatif-insidans",
    "title": "32  Salgın eğrileri",
    "section": "32.6 Kümülatif İnsidans",
    "text": "32.6 Kümülatif İnsidans\nNot: incidence2 kullanıyorsanız, basit bir fonksiyonla kümülatif insidansı nasıl üretebileceğinize ilişkin bölüme bakın. Bu sayfa, kümülatif insidansın nasıl hesaplanacağını ve ggplot()ile nasıl çizileceğini ele alacaktır.\nBir vaka satır listesiyle başlıyorsanız, R tabanından cumsum() kullanarak bir salgındaki günlük kümülatif vaka sayısını içeren yeni bir sütun oluşturun:\n\ncumulative_case_counts &lt;- linelist %&gt;% \n  count(date_onset) %&gt;%                # count of rows per day (returned in column \"n\")   \n  mutate(                         \n    cumulative_cases = cumsum(n)       # new column of the cumulative number of rows at each date\n    )\n\nİlk 10 satır aşağıda gösterilmiştir:\n\n\n\n\n\n\nBu kümülatif sütun daha sonra geom_line()kullanılarak date_onset’e göre çizilebilir:\n\nplot_cumulative &lt;- ggplot()+\n  geom_line(\n    data = cumulative_case_counts,\n    aes(x = date_onset, y = cumulative_cases),\n    size = 2,\n    color = \"blue\")\n\nplot_cumulative\n\n\n\n\n\n\n\n\nAyrıca yukarıda ve [ggplot ipuçları] sayfasında açıklanan cowplot yöntemi kullanılarak çift eksenli salgın eğrisi üzerine bindirilebilir:\n\n#load package\npacman::p_load(cowplot)\n\n# Make first plot of epicurve histogram\nplot_cases &lt;- ggplot()+\n  geom_histogram(          \n    data = linelist,\n    aes(x = date_onset),\n    binwidth = 1)+\n  labs(\n    y = \"Daily cases\",\n    x = \"Date of symptom onset\"\n  )+\n  theme_cowplot()\n\n# make second plot of cumulative cases line\nplot_cumulative &lt;- ggplot()+\n  geom_line(\n    data = cumulative_case_counts,\n    aes(x = date_onset, y = cumulative_cases),\n    size = 2,\n    color = \"blue\")+\n  scale_y_continuous(\n    position = \"right\")+\n  labs(x = \"\",\n       y = \"Cumulative cases\")+\n  theme_cowplot()+\n  theme(\n    axis.line.x = element_blank(),\n    axis.text.x = element_blank(),\n    axis.title.x = element_blank(),\n    axis.ticks = element_blank())\n\nŞimdi iki grafiği kaplamak için cowplot kullanın. x ekseni hizalamasına, y ekseninin kenarına ve theme_cowplot()kullanımına dikkat edildi.\n\naligned_plots &lt;- cowplot::align_plots(plot_cases, plot_cumulative, align=\"hv\", axis=\"tblr\")\nggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Salgın eğrileri</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.tr.html#kaynaklar",
    "href": "new_pages/epicurves.tr.html#kaynaklar",
    "title": "32  Salgın eğrileri",
    "section": "32.7 Kaynaklar",
    "text": "32.7 Kaynaklar",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Salgın eğrileri</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.tr.html",
    "href": "new_pages/age_pyramid.tr.html",
    "title": "33  Demografik piramidler ve likert ölçekler",
    "section": "",
    "text": "33.1 Hazırlık",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Demografik piramidler ve likert ölçekler</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.tr.html#hazırlık",
    "href": "new_pages/age_pyramid.tr.html#hazırlık",
    "title": "33  Demografik piramidler ve likert ölçekler",
    "section": "",
    "text": "Paketleri yükleme\nAşağıdaki kod parçası, analizler için gerekli olan paketlerin yüklenmesini göstermektedir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() fonksiyonunu ön plana çıkardık. R tabanından library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakınız.\n\npacman::p_load(rio,       # verileri içe aktarmak için\n               here,      # dosyaları bulmak için\n               tidyverse, # verileri temizlemek, işlemek ve çizmek için (ggplot2 paketini içerir)\n               apyramid,  # yaş piramitleri oluşturmak için\n               janitor,   # tablo ve veri temizlemek için\n               stringr)   # başlık, alt yazı vb. dizelerle çalışmak için\n\n\n\nVeriyi içe aktarma\nBaşlamak için, Ebola salgını simulasyonuna ait temizlenmiş vaka listesini içe aktarıyoruz. Takip etmek isterseniz, “temiz satır listesi” dosyasını indirmek için tıklayınız. (.rds dosyası olarak). rio paketinden import() fonksiyonu ile veriler içe aktarılmalıdır (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe ve dışa aktarma] sayfasına bakınız).\n\n# vaka satır listesini içe aktar \nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nSatır listesinin ilk 50 satırı aşağıda gösterilmiştir.\n\n\n\n\n\n\n\n\nTemizleme\nGeleneksel bir yaş/cinsiyet demografik piramidi oluşturmak için verilerin öncelikle aşağıda tanımlandığı gibi temizlenmesi gerekir:\n\nCinsiyet sütunu temizlenmelidir.\n\nKullanmak istediğiniz yönteme bağlı olarak yaş, sayısal olarak veya yaş kategorisi sütununda saklanmalıdır.\n\nEğer Yaş kategorileri kullanılacaksa, sütun değerleri varsayılan olarak alfasayısal olarak veya sınıf faktörüne dönüştürülerek düzeltilmelidir.\nAşağıda, gender ve age_cat5 sütunlarını incelemek için janitor paketinden tabyl() fonksiyonunu kullanıyoruz.\n\nlinelist %&gt;% \n  tabyl(age_cat5, gender)\n\n age_cat5   f   m NA_\n      0-4 640 416  39\n      5-9 641 412  42\n    10-14 518 383  40\n    15-19 359 364  20\n    20-24 305 316  17\n    25-29 163 259  13\n    30-34 104 213   9\n    35-39  42 157   3\n    40-44  25 107   1\n    45-49   8  80   5\n    50-54   2  37   1\n    55-59   0  30   0\n    60-64   0  12   0\n    65-69   0  12   1\n    70-74   0   4   0\n    75-79   0   0   1\n    80-84   0   1   0\n      85+   0   0   0\n     &lt;NA&gt;   0   0  86\n\n\nAyrıca, temiz ve doğru şekilde sınıflandırıldığından emin olmak için “age” sütununu hızlıca histograma dönüştürüyoruz:\n\nhist(linelist$age)",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Demografik piramidler ve likert ölçekler</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.tr.html#apyramid-paketi",
    "href": "new_pages/age_pyramid.tr.html#apyramid-paketi",
    "title": "33  Demografik piramidler ve likert ölçekler",
    "section": "33.2 apyramid paketi",
    "text": "33.2 apyramid paketi\napyramid paketi R4Epis projesinin bir ürünüdür. Bu paket hakkında daha fazla bilgiyi buradan okuyabilirsiniz. Paket, hızlı bir şekilde bir yaş piramidi yapmanızı sağlar. Daha ayrıntılı durumlar için aşağıdaki bölüme bakabilirsiniz ggplot() kullanarak. R konsolunuza ?age_pyramid girerek yardım sayfasında apyramid paketi hakkında daha fazla bilgi edinebilirsiniz.\n\nLinelist data\nTemizlenmiş ‘satır listesi’ veri setini kullanarak, age_pyramid() komutuyla basit bir yaş piramidi oluşturabiliriz. Bu komutta:\n\ndata = argümanı “satır listesi” veri çerçevesi olarak ayarlanır\n\nage_group = argümanı (y ekseni için) kategorik yaş sütununun adına ayarlanır (tırnak içinde)\nsplit_by = argüman (x ekseni için) cinsiyet sütununa ayarlanır\n\n\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\")\n\n\n\n\n\n\n\n\nPiramit, proportional = TRUE argümanı dahil edilerek, sayılar yerine x eksenindeki tüm verileri yüzdesi ile görüntülenebilir.\n\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\",\n                      proportional = TRUE)\n\n\n\n\n\n\n\n\nagepyramid paketini kullanırken, split_by sütunu ikili ise (ör. erkek/dişi veya evet/hayır), sonuç bir piramit olarak görünecektir. Bununla birlikte, split_by sütununda ikiden fazla değer varsa (NA dahil değildir), piramit “arka planda” gri çubuklar olan yönlü bir çubuk grafiği olarak görünecektir. Bu durum yaş grubu gibi yönlü olmayan verilerin aralığını gösterir. Bu durumda, split_by = değerleri her yön panelinin üstünde etiketler olarak görünecektir. Örneğin, split_by =, hospital sütununa atanırsa kodun nasıl yazılacağı aşağıda belirtilmiştir.\n\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"hospital\")  \n\n\n\n\n\n\n\n\n\nEksik veriler\nEğer eksik veriler NA olarak kodlanmışsa, split_by = veya age_group = sütunlarındaki eksik veri olan satırlar, grafiğin oluşmasını etkilemez. Varsayılan olarak bu satırlar gösterilmeyecektir. Bununla birlikte, na.rm = FALSE argümanıyla üstte, ayrı bir bitişik çubuk grafiğinde görünmelerini sağlayabilirsiniz.\n\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\",\n                      na.rm = FALSE)         # show patients missing age or gender\n\n\n\n\n\n\n\n\n\n\nOranlar, renkler ve estetik\nVarsayılan olarak, çubuklar sayılarını belirtmektedir (yüzdelerini değil). Her grup kesikli bir orta çizgi ile gösterilir ve rengi yeşil/mordur. Bu parametrelerin her biri aşağıda gösterildiği gibi ayarlanabilir:\nİstediğiniz estetik ve etiket ayarlamalarını standart ggplot() fonksiyonu ve “+” argümanını kullanarak ek ggplot() komutlarıyla belirleyebilirsiniz:\n\napyramid::age_pyramid(\n  data = linelist,\n  age_group = \"age_cat5\",\n  split_by = \"gender\",\n  proportional = TRUE,              # yüzdeyi göster, sayıları değil\n  show_midpoint = FALSE,            # orta nokta çizgisini kaldır\n  #pal = c(\"orange\", \"purple\")      # burada alternatif renkler belirtebilirsiniz (ancak etiketleri değil)\n  )+                 \n  \n  # additional ggplot commands\n  theme_minimal()+                               # arka planı basitleştir\n  scale_fill_manual(                             # renkleri VE etiketleri belirtin\n    values = c(\"orange\", \"purple\"),              \n    labels = c(\"m\" = \"Male\", \"f\" = \"Female\"))+\n  labs(y = \"Percent of all cases\",              # x ve y laboratuvarları değiştirildiğine dikkat edin\n       x = \"Age categories\",                          \n       fill = \"Gender\", \n       caption = \"My data source and caption here\",\n       title = \"Title of my plot\",\n       subtitle = \"Subtitle with \\n a second line...\")+\n  theme(\n    legend.position = \"bottom\",                          # açıklama aşağıya\n    axis.text = element_text(size = 10, face = \"bold\"),  # font ve boyut\n    axis.title = element_text(size = 12, face = \"bold\"))\n\n\n\n\n\n\n\n\n\n\n\nToplu veri\nYukarıdaki örnekler, verilerinizin gözlem başına bir satır olacak şekilde bir satır listesi biçiminde olduğunu varsaymaktadır. Verileriniz zaten yaş kategorisine göre sayılar halinde toplanmışsa, aşağıda gösterildiği gibi apyramid paketini kullanmaya devam edebilirsiniz.\nÖrnek olması için, satır listesi verilerini yaş kategorisine ve cinsiyete göre sayımlar halinde “geniş” bir formatta topluyoruz. Burada, verileriniz başlangıçta sayıymış gibi simüle edilecektir. İlgili sayfalarında [Gruplama verileri] ve [Özetleme verileri] hakkında daha fazla bilgi edinebilirsiniz.\n\ndemo_agg &lt;- linelist %&gt;% \n  count(age_cat5, gender, name = \"cases\") %&gt;% \n  pivot_wider(\n    id_cols = age_cat5,\n    names_from = gender,\n    values_from = cases) %&gt;% \n  rename(`missing_gender` = `NA`)\n\n…bu da veri setinin şu şekilde görünmesini sağlar: yaş kategorisi, erkek sayısı, kadın sayısı ve eksik veri sütunları.\n\n\n\n\n\n\nBu verileri yaş piramidine uyarlamak için, veriler dplyr paketinden pivot_longer() fonksiyonuyla “long” formatına döndürülecektir. Bunun nedeni, ggplot() fonksiyonunun genellikle “long” verileri tercih etmesi ve apyramid paketinin ggplot()u kullanmasıdır.\n\n# Toplu veriyi long formatına döndür\ndemo_agg_long &lt;- demo_agg %&gt;% \n  pivot_longer(\n    col = c(f, m, missing_gender),            # long formatına çevrilecek sütunlar\n    names_to = \"gender\",                # kategori sütunu için yeni ad\n    values_to = \"counts\") %&gt;%           # sayım sütunları için yeni ad\n  mutate(\n    gender = na_if(gender, \"missing_gender\")) # \"missing_gender\"ı NA'ya çevir\n\n\n\n\n\n\n\nArdından, verilerdeki ilgili sütunları belirtmek için age_pyramid() fonksiyonunun split_by = ve count = argümanını kullanın:\n\napyramid::age_pyramid(data = demo_agg_long,\n                      age_group = \"age_cat5\",# yaş kategorisi sütunu için yeni ad\n                      split_by = \"gender\",   # cinsiyet sütunu için yeni ad\n                      count = \"counts\")      # vaka sayıları sütunu için yeni ad\n\n\n\n\n\n\n\n\nYukarıda “m” ve “f” faktör sırasının farklı olduğuna dikkat edin (ters piramit). Sıralamayı ayarlamak için, toplu verilerde cinsiyeti Faktör olarak yeniden tanımlamalı ve seviyeleri istediğiniz gibi sıralamalısınız. [Faktörler] sayfasına bakınız.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Demografik piramidler ve likert ölçekler</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.tr.html#demo_pyr_gg",
    "href": "new_pages/age_pyramid.tr.html#demo_pyr_gg",
    "title": "33  Demografik piramidler ve likert ölçekler",
    "section": "33.3 ggplot()",
    "text": "33.3 ggplot()\nYaş piramidinizi oluşturmak için ggplot()u kullanmak daha fazla esneklik sağlar, ancak ggplot()un nasıl çalıştığına dair daha fazla bilgi sahibi olmanız gerekmektedir. Çünkü bu pakette hata yapmak da daha kolaydır.\nDemografik piramitler yapmak üzere ggplot()u kullanmak için, iki çubuk grafiği (her cinsiyet için bir tane) oluşturursunuz, bir grafikteki değerleri negatife çevirirsiniz ve son olarak çubuk grafiklerini dikey olarak, tabanlarını görüntülemek için x ve y eksenlerini çevirirsiniz.\n\nHazırlık\nBu yaklaşım, age_cat5 verilerinin kategorik değil, sayısal yaş sütununu kullanır. Bu yüzden bu sütunun sınıfının gerçekten sayısal olup olmadığını kontrol edeceğiz.\n\nclass(linelist$age)\n\n[1] \"numeric\"\n\n\nAşağıdaki mantığı, geom_histogram() yerine geom_col() kullanarak kategorik verilerden bir piramit oluşturmak için de kullanabilirsiniz.\n\n\n\nGrafiği oluşturma\nİlk olarak, ggplot() kullanarak bir piramit yapmak için aşağıdaki yaklaşımı anlamanız gerekmektedir:\n\nggplot() içinde, sayısal yaş sütununu kullanarak iki histogram oluşturun: İki gruplama değerinin her biri için bir tane (bu durumda cinsiyetler erkek ve kadın). Bunu yapmak için, her bir histogram için veriler, ilgili filtreler “satır listesine” uygulanarak ilgili geom_histogram() komutlarında tanımlanır.\nBir grafik pozitif değerlere sahip olacak, diğeri ise negatif değerlere dönüştürülecek - bu, grafiğin ortasında “0” değeri olan bir “piramit” yaratır. Negatif değerler, özel bir ggplot2 terimi ..count.. kullanılarak ve -1 ile çarpılarak oluşturulur.\ncoord_flip() komutu X ve Y eksenlerini değiştirerek grafiklerin 90 derece dönmesine ve piramidin oluşturulmasına neden olur.\nSon olarak, sayım ekseni değer etiketleri, piramidin her iki tarafında “pozitif” sayımlar olarak görünecek şekilde değiştirilmelidir (bir taraftaki temel değerlerin negatif olmasına rağmen).\n\ngeom_histogram() fonksiyonu kullanılarak hazırlanan basit bir versiyonu aşağıdadır:\n\n  # ggplotu başlat\n  ggplot(mapping = aes(x = age, fill = gender)) +\n  \n  # kadın histogram\n  geom_histogram(data = linelist %&gt;% filter(gender == \"f\"),\n                 breaks = seq(0,85,5),\n                 colour = \"white\") +\n  \n  # erkek histogram (veriler negatife çevrilecek)\n  geom_histogram(data = linelist %&gt;% filter(gender == \"m\"),\n                 breaks = seq(0,85,5),\n                 mapping = aes(y = ..count..*(-1)),\n                 colour = \"white\") +\n  \n  # X ve Y eksenlerini çevir\n  coord_flip() +\n  \n  # sayım ekseni ölçeğini ayarla\n  scale_y_continuous(limits = c(-600, 900),\n                     breaks = seq(-600,900,100),\n                     labels = abs(seq(-600, 900, 100)))\n\n\n\n\n\n\n\n\nTEHLİKE: Sayım ekseninizin sınırları çok düşük ayarlanmışsa ve bir sayım çubuğu bunları aşarsa, çubuk tamamen kaybolur veya yapay olarak kısaltılır! Rutin olarak güncellenen verileri analiz ediyorsanız buna dikkat etmelisiniz. Sayım ekseni sınırlarınızın aşağıdaki gibi verilerinize göre otomatik olarak ayarlanmasını sağlayarak bunu önleyebilirsiniz.\nBu basit versiyonda değiştirebileceğiniz/ekleyebileceğiniz pek çok şey vardır:\n\nSayım ekseni ölçeğini verilerinize göre otomatik olarak ayarlama (aşağıdaki uyarıda açıklanan hatalardan kaçınmalısınız)\nRenkleri ve gösterge etiketlerini manuel olarak belirtme\n\nSayıları yüzdelere dönüştürme\nSayıları yüzdelere (toplamına göre) dönüştürmek için, hazırlıklarınızı çizimden önce yapmanız gerekmektedir. Aşağıda, yeni yüzde sütunları oluşturmak için yaş-cinsiyet sayılarını, ungroup() ve ardından mutate() fonksiyonlarını kullanıyoruz. Cinsiyete göre yüzdeleri istiyorsanız, ungroup() adımını atlayabilirsiniz.\n\n# toplama göre oranlamak için veri kümesi oluştur\npyramid_data &lt;- linelist %&gt;%\n  count(age_cat5,\n        gender,\n        name = \"counts\") %&gt;% \n  ungroup() %&gt;%                 # grubu çöz, böylece yüzdeler gruba göre belirlenmesin\n  mutate(percent = round(100*(counts / sum(counts, na.rm=T)), digits = 1), \n         percent = case_when(\n            gender == \"f\" ~ percent,\n            gender == \"m\" ~ -percent,     # erkeği negatife çevir\n            TRUE          ~ NA_real_))    # NA değeri de sayısal olmalıdır\n\nDaha da önemlisi, maksimum ve minimum değerleri kaydederek ölçeğin sınırlarının ne olması gerektiğini biliriz. Bunlar aşağıdaki ggplot() komutunda kullanılacaktır.\n\nmax_per &lt;- max(pyramid_data$percent, na.rm=T)\nmin_per &lt;- min(pyramid_data$percent, na.rm=T)\n\nmax_per\n\n[1] 10.9\n\nmin_per\n\n[1] -7.1\n\n\nSon olarak yüzde verisi üzerinde ggplot() komutunu kullanıyoruz. Önceden tanımlı uzunlukları her yönde (pozitif ve “negatif”) uzatmak için scale_y_continuous() fonksiyonunu tanımlıyoruz. Ondalık sayıları eksenin kenarı için uygun yöne (aşağı veya yukarı) yuvarlamak için floor() ve ceiling() argümanlarını kullanırız.\n\n# ggplot başlangıcı\n  ggplot()+  # varsayılan x ekseni, yıl cinsinden yaştır;\n\n  # vaka veri grafiği\n  geom_col(data = pyramid_data,\n           mapping = aes(\n             x = age_cat5,\n             y = percent,\n             fill = gender),         \n           colour = \"white\")+       # her çubuğun etrafı beyaz\n  \n  # piramidi dikey yapmak için X ve Y eksenlerini çevir\n  coord_flip()+\n  \n\n  # eksen boyunu düzenle\n  # scale_x_continuous(breaks = seq(0,100,5), labels = seq(0,100,5)) +\n  scale_y_continuous(\n    limits = c(min_per, max_per),\n    breaks = seq(from = floor(min_per),                # 2s ile değer dizisi\n                 to = ceiling(max_per),\n                 by = 2),\n    labels = paste0(abs(seq(from = floor(min_per),     # mutlak değerler dizisi, 2s ile, \"%\" ile\n                            to = ceiling(max_per),\n                            by = 2)),\n                    \"%\"))+  \n\n  #renkleri ve açıklama etiketlerini manuel olarak belirle\n  scale_fill_manual(\n    values = c(\"f\" = \"orange\",\n               \"m\" = \"darkgreen\"),\n    labels = c(\"Female\", \"Male\")) +\n  \n  # etiket değerleri (şimdi X ve Y'nin çevrildiğini unutmayın)\n  labs(\n    title = \"Age and gender of cases\",\n    x = \"Age group\",\n    y = \"Percent of total\",\n    fill = NULL,\n    caption = stringr::str_glue(\"Data are from linelist \\nn = {nrow(linelist)} (age or sex missing for {sum(is.na(linelist$gender) | is.na(linelist$age_years))} cases) \\nData as of: {format(Sys.Date(), '%d %b %Y')}\")) +\n  \n  # temayı görüntüle\n  theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    axis.line = element_line(colour = \"black\"),\n    plot.title = element_text(hjust = 0.5), \n    plot.caption = element_text(hjust=0, size=11, face = \"italic\")\n    )\n\n\n\n\n\n\n\n\n\n\n\nBaz değerleriyle ile karşılaştırma\nggplot()un esnekliğiyle, arka planda “gerçek” veya “baz” nüfus piramidini temsil eden ikinci bir çubuk katmanına sahip olabilirsiniz. Bu, gözlemlenenleri taban çizgisiyle karşılaştırmak için güzel bir görselleştirme sağlayabilir.\nNüfus verilerini içe aktarın ve görüntüleyin (bkz. [El kitabını ve verileri indirin] sayfası):\n\n# nüfus demografisi verilerini içe aktar\npop &lt;- rio::import(\"country_demographics.csv\")\n\n\n\n\n\n\n\nİlk önce bazı veri yönetimi adımları:\nBurada görünmesini istediğimiz yaş kategorilerinin sırasını kaydediyoruz. ggplot()un uygulanma biçimindeki bazı tuhaflıklar nedeniyle, bu özel senaryoda bunları bir karakter vektörü olarak saklamak ve daha sonra çizim işlevinde kullanmak en kolay yoldur.\n\n# doğru yaş kategorisi seviyelerini kaydedin\nage_levels &lt;- c(\"0-4\",\"5-9\", \"10-14\", \"15-19\", \"20-24\",\n                \"25-29\",\"30-34\", \"35-39\", \"40-44\", \"45-49\",\n                \"50-54\", \"55-59\", \"60-64\", \"65-69\", \"70-74\",\n                \"75-79\", \"80-84\", \"85+\")\n\nPopülasyon ve vaka verilerini dplyr paketinden bind_rows() fonksiyonu aracılığıyla birleştirin:\n\nİlk olarak, tam olarak aynı sütun adlarına, yaş kategorisi değerlerine ve cinsiyet değerlerine sahip olduklarından emin olmalısınız\nVerilerin aynı veri yapısına sahip olmalarını sağlayın: yaş kategorisi sütunları, cinsiyet, sayılar ve toplamın yüzdesi\nBunları üst üste gelecek şekilde birbirine bağlayın (bind_rows())\n\n\n# toplamın yüzdesi ile nüfus verilerini oluştur/dönüştür\n########################################################\npop_data &lt;- pop %&gt;% \n  pivot_longer(      # cinsiyet sütunlarını long formatına döndür\n    cols = c(m, f),\n    names_to = \"gender\",\n    values_to = \"counts\") %&gt;% \n  \n  mutate(\n    percent  = round(100*(counts / sum(counts, na.rm=T)),1),  # % of total\n    percent  = case_when(                                                        \n     gender == \"f\" ~ percent,\n     gender == \"m\" ~ -percent,               # erkek ise, %'yi negatife çevir\n     TRUE          ~ NA_real_))\n\nDeğiştirilen nüfus veri kümesini gözden geçirin\n\n\n\n\n\n\nŞimdi aynısını vaka satır listesi için uygulayın. Burada durum biraz farklıdır çünkü veriler vaka satırlarıyla başlıyor, sayılarla değil.\n\n# toplamın yüzdesi ile yaşa/cinsiyete göre vaka verileri oluştur\n#######################################################\ncase_data &lt;- linelist %&gt;%\n  count(age_cat5, gender, name = \"counts\") %&gt;%  # yaş-cinsiyet gruplarına göre say\n  ungroup() %&gt;% \n  mutate(\n    percent = round(100*(counts / sum(counts, na.rm=T)),1),  # yaş-cinsiyet grupları için toplamın yüzdesini hesapla\n    percent = case_when(                                     # erkek ise %'yi negatife çevir\n      gender == \"f\" ~ percent,\n      gender == \"m\" ~ -percent,\n      TRUE          ~ NA_real_))\n\nDeğiştirilen vaka veri kümesini gözden geçirin\n\n\n\n\n\n\nŞimdi iki veri çerçevesi, biri diğerinin üzerinde olacak şekilde birleştirilmiştir (aynı sütun adlarına sahiptirler). Veri çerçevesinin her birini yeniden “adlandırabiliriz” ve her satırın hangi veri çerçevesinden kaynaklandığını gösterecek yeni bir “veri_kaynağı” sütunu oluşturmak için .id = argümanını kullanabiliriz. Bu sütunu daha sonrasında ggplot() içinde filtrelemek için kullanabiliriz.\n\n# vaka ve popülasyon verilerini birleştir (aynı sütun adları, age_cat değerleri ve cinsiyet değerleri)\npyramid_data &lt;- bind_rows(\"cases\" = case_data, \"population\" = pop_data, .id = \"data_source\")\n\nÇizimin kapsamını tanımlamak için çizim işlevinde kullanılan maksimum ve minimum yüzde değerlerini saklayabilirsiniz (ve herhangi bir çubuğu daha kısa kesmeyin!)\n\n# Çizim sınırları için kullanılan yüzde ekseninin kapsamını tanımla\nmax_per &lt;- max(pyramid_data$percent, na.rm=T)\nmin_per &lt;- min(pyramid_data$percent, na.rm=T)\n\nŞimdi grafik ggplot() ile hazırlanabilir:\n\nNüfus verilerinin bir çubuk grafiği (daha geniş, daha şeffaf çubuklar)\nVaka verilerinin bir çubuk grafiği (küçük, daha opak çubuk)\n\n\n# ggplot'u başlat\n##############\nggplot()+  # varsayılan x ekseni, yıl cinsinden yaştır;\n\n  # nüfus veri grafiği\n  geom_col(\n    data = pyramid_data %&gt;% filter(data_source == \"population\"),\n    mapping = aes(\n      x = age_cat5,\n      y = percent,\n      fill = gender),\n    colour = \"black\",                               # çubukların etrafındaki siyah renk\n    alpha = 0.2,                                    # daha şeffaf\n    width = 1)+                                     # tam genişlik\n  \n  # vaka veri grafiği\n  geom_col(\n    data = pyramid_data %&gt;% filter(data_source == \"cases\"), \n    mapping = aes(\n      x = age_cat5,                               # orijinal X ekseni olarak yaş kategorileri\n      y = percent,                                # orijinal Y ekseni olarak %\n      fill = gender),                             # cinsiyete göre çubukların doldurulması\n    colour = \"black\",                               # çubukların etrafındaki siyah renk\n    alpha = 1,                                      # opak \n    width = 0.3)+                                   # yarım genişlik\n  \n  # piramidi dikey yapmak için X ve Y eksenlerini çevir\n  coord_flip()+\n  \n  # yaş ekseninin doğru sıralandığından manuel olarak emin ol\n  scale_x_discrete(limits = age_levels)+     # yukarıdaki parçada tanımlanmış\n  \n  # yüzde ekseni ayarla\n  scale_y_continuous(\n    limits = c(min_per, max_per),                                          # yukarıda tanımlanan min ve max\n    breaks = seq(floor(min_per), ceiling(max_per), by = 2),                # min%'den maksimum% 2'ye\n    labels = paste0(                                                       # etiketler için birlikte yapıştır...\n              abs(seq(floor(min_per), ceiling(max_per), by = 2)), \"%\"))+                                                  \n\n  # renkleri ve açıklama etiketlerini manuel olarak belirle\n  scale_fill_manual(\n    values = c(\"f\" = \"orange\",         # verilerdeki değerlere renk ata\n               \"m\" = \"darkgreen\"),\n    labels = c(\"f\" = \"Female\",\n               \"m\"= \"Male\"),      # göstergede görünen etiketleri değiştir, not sırası\n  ) +\n\n  # grafik etiketleri, başlıklar, başlık  \n  labs(\n    title = \"Case age and gender distribution,\\nas compared to baseline population\",\n    subtitle = \"\",\n    x = \"Age category\",\n    y = \"Percent of total\",\n    fill = NULL,\n    caption = stringr::str_glue(\"Cases shown on top of country demographic baseline\\nCase data are from linelist, n = {nrow(linelist)}\\nAge or gender missing for {sum(is.na(linelist$gender) | is.na(linelist$age_years))} cases\\nCase data as of: {format(max(linelist$date_onset, na.rm=T), '%d %b %Y')}\")) +\n  \n  # opsiyonel estetik ayarlamalar\n  theme(\n    legend.position = \"bottom\",                             # açıklamayı aşağıya taşı\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    axis.line = element_line(colour = \"black\"),\n    plot.title = element_text(hjust = 0), \n    plot.caption = element_text(hjust=0, size=11, face = \"italic\"))",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Demografik piramidler ve likert ölçekler</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.tr.html#likert-ölçek",
    "href": "new_pages/age_pyramid.tr.html#likert-ölçek",
    "title": "33  Demografik piramidler ve likert ölçekler",
    "section": "33.4 Likert ölçek",
    "text": "33.4 Likert ölçek\n‘ggplot()’ ile bir nüfus piramidi yapmak için kullanılan teknikler, Likert ölçekli anket verilerinin çizimlerini yapmak için de kullanılabilir.\nVerileri içe aktarın ([El kitabını ve verileri indir] sayfasına bakabilirsiniz).\n\n# likert anketi yanıt verilerini içe aktar\nlikert_data &lt;- rio::import(\"likert_data.csv\")\n\nHer katılımcının kategorik bir sınıflandırması (status) ve 4 puanlı Likert tipi bir ölçekte 8 soruya verdikleri yanıtlara (“Çok kötü”, “Kötü”, “İyi”, “Çok iyi”) ait verileri ele alacağız.\n\n\n\n\n\n\nİlk olarak, veri yönetimi adımları:\n\nVerileri pivot_longer fonksiyonuyla alt gruplarına döndürme\nYanıtın genellikle “olumlu” veya “olumsuz” olmasına bağlı olarak yeni bir direction sütunu oluşturma\nstatus sütunu ve Response sütunu için Faktör düzeyi sırasını ayarlama\n\nMaksimum sayım değerini, çizim sınırlarının uygun olması için saklama\n\n\nmelted &lt;- likert_data %&gt;% \n  pivot_longer(\n    cols = Q1:Q8,\n    names_to = \"Question\",\n    values_to = \"Response\") %&gt;% \n  mutate(\n    \n    direction = case_when(\n      Response %in% c(\"Poor\",\"Very Poor\")  ~ \"Negative\",\n      Response %in% c(\"Good\", \"Very Good\") ~ \"Positive\",\n      TRUE                                 ~ \"Unknown\"),\n    \n    status = fct_relevel(status, \"Junior\", \"Intermediate\", \"Senior\"),\n    \n    # çalışması için 'Çok Zayıf' ve 'Zayıf' kelimeleri tersine çevirilmelidir\n    Response = fct_relevel(Response, \"Very Good\", \"Good\", \"Very Poor\", \"Poor\")) \n\n# ölçek limitleri için en büyük değeri al\nmelted_max &lt;- melted %&gt;% \n  count(status, Question) %&gt;% # sayıları al\n  pull(n) %&gt;%                 # sütunu 'n'i\n  max(na.rm=T)                # maksimumu al\n\nŞimdi grafiği hazırlayabiliriz. Yukarıdaki yaş piramitlerinde olduğu gibi iki çubuk grafiği oluşturuyoruz ve bunlardan birinin değerlerini negatife çeviriyoruz.\ngeom_bar() fonksiyonunu kullanıyoruz çünkü verilerimiz toplu sayı olarak değil, gözlem başına bir satır olacak şekilde düzenlendi. Negatif değerleri (-1) tersine çevirmek için çubuk grafiklerden birinde özel ggplot2 terimi olan ..count..u ve değerlerin üstüne eklenmesi için position = \"stack\" argümanını kullanıyoruz.\n\n# garfiği hazırla\nggplot()+\n     \n  # \"olumsuz\" yanıtların çubuk grafiği \n     geom_bar(\n       data = melted %&gt;% filter(direction == \"Negative\"),\n       mapping = aes(\n         x = status,\n         y = ..count..*(-1),    # negatife çevrilen sayımlar\n         fill = Response),\n       color = \"black\",\n       closed = \"left\",\n       position = \"stack\")+\n     \n     # \"olumlu\" yanıtların çubuk grafiği\n     geom_bar(\n       data = melted %&gt;% filter(direction == \"Positive\"),\n       mapping = aes(\n         x = status,\n         fill = Response),\n       colour = \"black\",\n       closed = \"left\",\n       position = \"stack\")+\n     \n     # X ve Y eksenlerini çevirin\n     coord_flip()+\n  \n     # 0'da siyah dikey çizgi\n     geom_hline(yintercept = 0, color = \"black\", size=1)+\n     \n    # etiketlerin tümünü pozitif sayılara dönüştür\n    scale_y_continuous(\n      \n      # x ekseni ölçeğinin sınırları\n      limits = c(-ceiling(melted_max/10)*11,    # 10 ile negatiften pozitife doğru sıra, kenarlar dışa doğru en yakın 5'e yuvarlanır\n                 ceiling(melted_max/10)*10),   \n      \n      # x ekseni ölçeğinin değerleri\n      breaks = seq(from = -ceiling(melted_max/10)*10,\n                   to = ceiling(melted_max/10)*10,\n                   by = 10),\n      \n      # x ekseni ölçeğinin etiketleri\n      labels = abs(unique(c(seq(-ceiling(melted_max/10)*10, 0, 10),\n                            seq(0, ceiling(melted_max/10)*10, 10))))) +\n     \n    # manuel olarak atanan renk skalaları\n    scale_fill_manual(\n      values = c(\"Very Good\"  = \"green4\", # renk ata\n                \"Good\"      = \"green3\",\n                \"Poor\"      = \"yellow\",\n                \"Very Poor\" = \"red3\"),\n      breaks = c(\"Very Good\", \"Good\", \"Poor\", \"Very Poor\"))+ # açıklamanın sırası\n     \n    \n     \n    # tüm grafiği şekillendirin, böylece her soru bir alt grafik olur\n    facet_wrap( ~ Question, ncol = 3)+\n     \n    # etiketler, başlıklar, başlık\n    labs(\n      title = str_glue(\"Likert-style responses\\nn = {nrow(likert_data)}\"),\n      x = \"Respondent status\",\n      y = \"Number of responses\",\n      fill = \"\")+\n\n     # görselin ayarları \n     theme_minimal()+\n     theme(axis.text = element_text(size = 12),\n           axis.title = element_text(size = 14, face = \"bold\"),\n           strip.text = element_text(size = 14, face = \"bold\"),  # alt başlıklar\n           plot.title = element_text(size = 20, face = \"bold\"),\n           panel.background = element_rect(fill = NA, color = \"black\")) # her metin etrafındaki siyah çerçeve",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Demografik piramidler ve likert ölçekler</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.tr.html#kaynaklar",
    "href": "new_pages/age_pyramid.tr.html#kaynaklar",
    "title": "33  Demografik piramidler ve likert ölçekler",
    "section": "33.5 Kaynaklar",
    "text": "33.5 Kaynaklar\napyramid dokümantasyonu",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Demografik piramidler ve likert ölçekler</span>"
    ]
  },
  {
    "objectID": "new_pages/heatmaps.tr.html",
    "href": "new_pages/heatmaps.tr.html",
    "title": "34  Isı grafikleri",
    "section": "",
    "text": "34.1 Hazırlık",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Isı grafikleri</span>"
    ]
  },
  {
    "objectID": "new_pages/heatmaps.tr.html#hazırlık",
    "href": "new_pages/heatmaps.tr.html#hazırlık",
    "title": "34  Isı grafikleri",
    "section": "",
    "text": "Paketleri yükle\nBu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’ın p_load() fonksiyonunu vurguluyoruz. Ayrıca, R tabanı’ndan library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R temelleri] sayfasına bakın.\n\npacman::p_load(\n  tidyverse,       # data manipulation and visualization\n  rio,             # importing data \n  lubridate        # working with dates\n  )\n\nVeri setleri\nBu sayfa, iletim matrisi bölümü için simüle edilmiş bir salgının vaka satır listesini ve ölçüm izleme bölümü için tesise göre günlük sıtma vaka sayımlarının ayrı bir veri setini kullanır. Ayrı bölümlerine yüklenir ve temizlenirler.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Isı grafikleri</span>"
    ]
  },
  {
    "objectID": "new_pages/heatmaps.tr.html#geçiş-matrisi",
    "href": "new_pages/heatmaps.tr.html#geçiş-matrisi",
    "title": "34  Isı grafikleri",
    "section": "34.2 Geçiş matrisi",
    "text": "34.2 Geçiş matrisi\nIsı karoları, matrisleri görselleştirmek için faydalı olabilir. Örnek olarak, bir salgında “kimin kime bulaştığını” göstermektir. Bu, aktarım olayları hakkında bilgi sahibi olduğunuzu varsayar.\n[Temaslı izleme] sayfasının, vakaların yaşlarının ve kaynaklarının veri çerçevesinin aynı satırında düzgün bir şekilde hizalandığı farklı (belki de daha basit) bir veri kümesi kullanarak bir ısı karosu temas matrisi oluşturmanın başka bir örneğini içerdiğine dikkat edin. Bu aynı veriler, [ggplot ipuçları] sayfasında bir yoğunluk haritası yapmak için kullanılır. Aşağıdaki bu örnek, bir durum satır listesinden başlar ve bu nedenle, çizilebilir bir veri çerçevesi elde etmeden önce önemli miktarda veri işlemeyi içerir. Yani seçebileceğiniz birçok senaryo var…\nSimüle edilmiş bir Ebola salgınının vaka listesiyle başlıyoruz. Devam etmek istiyorsanız,  “temiz” satır listesini (.rds dosyası olarak) indirmek için tıklayın. Verilerinizi rio paketinden import() fonksiyonuyla içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için [İçe Aktarma ve Dışa Aktarma] sayfasına bakın).\nÇizgi listesinin ilk 50 satırı, gösterim için aşağıda gösterilmiştir:\n\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nBu satır listesinde:\n\ncase_id ile tanımlandığı gibi, vaka başına bir satır vardır\nSatır listesinde de bir vaka olan bulaştırıcı’nın case_id’sini içeren daha sonraki bir sütun olan infector vardır.\n\n\n\n\n\n\n\n\nVeri Hazırlama\nAmaç: Olası yaştan yaşa iletim yolu başına bir satır içeren ve satır listesindeki tüm gözlenen iletim olaylarının o satırın oranını kapsayan sayısal bir sütun içeren “uzun” tarzda bir veri çerçevesi elde etmemiz gerekiyor.\nBu, aşağıdakileri elde etmek için birkaç veri işleme adımı alacaktır:\n\nVaka veri çerçevesi yapmak\nBaşlamak için, vakaların, yaşlarının ve bulaştırıcılarının bir veri çerçevesini oluşturuyoruz - veri çerçevesine case_ages diyoruz. İlk 50 satır aşağıda gösterilmiştir.\n\ncase_ages &lt;- linelist %&gt;% \n  select(case_id, infector, age_cat) %&gt;% \n  rename(\"case_age_cat\" = \"age_cat\")\n\n\n\n\n\n\n\n\n\nBulaştırıcıların veri çerçevesini yapmak\nArdından, bulaşıcıların veri çerçevesini oluşturuyoruz - şu anda tek bir sütundan oluşuyor. Bunlar, satır listesindeki bulaştırıcı kimlikleridir. Her vakanın bilinen bir bulaştırıcısı yoktur, bu nedenle eksik değerleri kaldırıyoruz. İlk 50 satır aşağıda gösterilmiştir.\n\ninfectors &lt;- linelist %&gt;% \n  select(infector) %&gt;% \n  drop_na(infector)\n\n\n\n\n\n\n\nDaha sonra, bulaştırıcıların yaşlarını elde etmek için birleşimleri kullanırız. Bu basit değil, çünkü linelist’de, bulaştırıcının yaşları bu şekilde listelenmiyor. Bu sonuca, linelist’i bulaştırıcılara ekleyerek ulaşıyoruz. Bulaştırıcılarla başlıyoruz ve vaka linelist’ne left_join() (ekliyoruz), öyle ki infector kimliği sütunu sol taraftaki “temel” veri çerçevesi sağ taraftaki linelist veri çerçevesindeki case_id sütunuyla birleşiyor.\nBöylece satır listesindeki (yaş dahil) bulaştırıcının vaka kaydındaki veriler bulaştırıcı satırına eklenir. İlk 50 satır aşağıda gösterilmiştir.\n\ninfector_ages &lt;- infectors %&gt;%             # begin with infectors\n  left_join(                               # add the linelist data to each infector  \n    linelist,\n    by = c(\"infector\" = \"case_id\")) %&gt;%    # match infector to their information as a case\n  select(infector, age_cat) %&gt;%            # keep only columns of interest\n  rename(\"infector_age_cat\" = \"age_cat\")   # rename for clarity\n\n\n\n\n\n\n\nDaha sonra vakaları ve yaşlarını bulaştırıcılar ve yaşları ile birleştiriyoruz. Bu veri çerçevelerinin her biri sütun infector’e sahiptir, bu nedenle birleştirme için kullanılır. İlk satırlar aşağıda görüntülenir:\n\nages_complete &lt;- case_ages %&gt;%  \n  left_join(\n    infector_ages,\n    by = \"infector\") %&gt;%        # each has the column infector\n  drop_na()                     # drop rows with any missing data\n\nWarning in left_join(., infector_ages, by = \"infector\"): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 1 of `x` matches multiple rows in `y`.\nℹ Row 6 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\n\n\nAşağıda, vaka ve enfeksiyon etkeni yaş grupları arasındaki sayıların basit bir çapraz tablosu. Netlik için etiketler eklendi.\n\ntable(cases = ages_complete$case_age_cat,\n      infectors = ages_complete$infector_age_cat)\n\n       infectors\ncases   0-4 5-9 10-14 15-19 20-29 30-49 50-69 70+\n  0-4   105 156   105   114   143   117    13   0\n  5-9   102 132   110   102   117    96    12   5\n  10-14 104 109    91    79   120    80    12   4\n  15-19  85 105    82    39    75    69     7   5\n  20-29 101 127   109    80   143   107    22   4\n  30-49  72  97    56    54    98    61     4   5\n  50-69   5   6    15     9     7     5     2   0\n  70+     1   0     2     0     0     0     0   0\n\n\nBu tabloyu, R tabanından data.frame() ile bir veri çerçevesine dönüştürebiliriz, bu da onu otomatik olarak ggplot() için istenen “uzun” biçime dönüştürür. İlk satırlar aşağıda gösterilmiştir.\n\nlong_counts &lt;- data.frame(table(\n    cases     = ages_complete$case_age_cat,\n    infectors = ages_complete$infector_age_cat))\n\n\n\n\n\n\n\nŞimdi biz de aynısını yapıyoruz, ancak tabloya R tabanından prop.table() uygularız, böylece sayımlar yerine toplamın oranlarını elde ederiz. İlk 50 satır aşağıda gösterilmiştir.\n\nlong_prop &lt;- data.frame(prop.table(table(\n    cases = ages_complete$case_age_cat,\n    infectors = ages_complete$infector_age_cat)))\n\n\n\n\n\n\n\n\n\n\nIsı grafiği oluşturmak\nŞimdi nihayet geom_tile() fonksiyonunu kullanarak ggplot2 paketi ile ısı grafiğini oluşturabiliriz. Renk/dolgu ölçekleri, özellikle de scale_fill_gradient() fonksiyonu hakkında daha kapsamlı bilgi edinmek için [ggplot ipuçları] sayfasına bakın.\n\ngeom_tile() estetik aes()’inde x ve y’yi vaka yaşı ve bulaştırıcı yaşı olarak ayarlayın\nAyrıca aes() içinde fill = argümanını Freq sütununa ayarlayın - bu, kutucuk rengine dönüştürülecek değerdir\nscale_fill_gradient() ile bir ölçek rengi ayarlayın - yüksek/düşük renkleri belirleyebilirsiniz\n\nscale_color_gradient() öğesinin farklı olduğuna dikkat edin! Bu durumda doldurmak istersiniz\n\nRenk “doldurma” yoluyla yapıldığından, gösterge başlığını değiştirmek için labs() içindeki fill = bağımsız değişkenini kullanabilirsiniz.\n\n\nggplot(data = long_prop)+       # use long data, with proportions as Freq\n  geom_tile(                    # visualize it in tiles\n    aes(\n      x = cases,         # x-axis is case age\n      y = infectors,     # y-axis is infector age\n      fill = Freq))+            # color of the tile is the Freq column in the data\n  scale_fill_gradient(          # adjust the fill color of the tiles\n    low = \"blue\",\n    high = \"orange\")+\n  labs(                         # labels\n    x = \"Case age\",\n    y = \"Infector age\",\n    title = \"Who infected whom\",\n    subtitle = \"Frequency matrix of transmission events\",\n    fill = \"Proportion of all\\ntranmsission events\"     # legend title\n  )",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Isı grafikleri</span>"
    ]
  },
  {
    "objectID": "new_pages/heatmaps.tr.html#zaman-içinde-raporlama-metrikleri",
    "href": "new_pages/heatmaps.tr.html#zaman-içinde-raporlama-metrikleri",
    "title": "34  Isı grafikleri",
    "section": "34.3 Zaman içinde raporlama metrikleri",
    "text": "34.3 Zaman içinde raporlama metrikleri\nHalk sağlığında genellikle bir amaç, birçok kuruluş (tesisler, yargı alanları, vb.) için zaman içindeki eğilimleri değerlendirmektir. Bu tür eğilimleri zaman içinde görselleştirmenin bir yolu, x ekseninin zaman olduğu ve y ekseninde birçok öğenin bulunduğu bir ısı grafiğidir.\n\nVeri Hazırlama\nBirçok tesisten günlük sıtma raporlarının bir veri setini içe aktararak başlıyoruz. Raporlar bir tarih, il, ilçe ve sıtma sayılarını içerir. Bu verilerin nasıl indirileceği hakkında bilgi için [El kitabı ve verileri indirme] sayfasına bakın. İlk 30 satır aşağıdadır:\n\nfacility_count_data &lt;- import(\"malaria_facility_count_data.rds\")\n\n\n\n\n\n\n\n\nToplama ve özetleme\nBu örnekteki amaç, günlük tesis toplam sıtma vakası sayılarını (önceki sekmede görülen) tesis raporlama performansının haftalık özet istatistiklerine dönüştürmektir - bu durum için tesisin herhangi bir veriyi bildirdiği haftadaki günlerin oranıdır. Bu örnek için sadece Spring District için veri göstereceğiz.\nBunu başarmak için aşağıdaki veri yönetimi adımlarını uygulayacağız:\n\nVerileri uygun şekilde filtreleyin (yere, tarihe göre)\n\nlubridate paketinden floor_date() kullanarak bir hafta sütunu oluşturun\n\nBu fonksiyon, her haftanın belirli bir başlangıç tarihini (ör. “Pazartesileri”) kullanarak belirli bir tarihteki haftanın başlangıç tarihini döndürür.\n\nVeriler, “tesis-hafta” analiz birimlerini oluşturmak için “konum” ve “hafta” sütunlarına göre gruplandırılır.\nsummarise() işlevi, tesis-hafta grubu başına özet istatistikleri yansıtmak için yeni sütunlar oluşturur:\n\nHaftada gün sayısı (7 - statik bir değer)\n\nTesis-haftadan alınan rapor sayısı (7’den fazla olabilir!)\n\nTesis haftası tarafından bildirilen sıtma vakalarının toplamı (sadece merak için)\n\nTesis-haftadaki verilerin raporlandığı özel günlerin sayısı\n\nVerilerin rapor edildiği tesis-hafta başına 7 günün yüzdesi\n\n\nVeri setini tamamlamak için tüm olası tesis-hafta kombinasyonlarının kapsamlı bir listesi için veri çerçevesi right_join() ile birleştirilir. Tüm olası kombinasyonların matrisi, veri çerçevesinin bu iki sütununa veri tüneli akışı o anda olduğu gibi (. ile temsil edilir) expand() uygulanarak oluşturulur. Bir right_join() kullanıldığından, expand() veri çerçevesindeki tüm satırlar tutulur ve gerekirse agg_weeks’e eklenir. Bu yeni satırlar, NA (eksik) özetlenmiş değerlerle görünür.\n\nAşağıda adım adım gösteriyoruz:\n\n# Create weekly summary dataset\nagg_weeks &lt;- facility_count_data %&gt;% \n  \n  # filter the data as appropriate\n  filter(\n    District == \"Spring\",\n    data_date &lt; as.Date(\"2020-08-01\")) \n\nŞimdi veri setinde, daha önce nrow(facility_count_data) olduğunda, nrow(agg_weeks) satırı vardır.\nArdından, her kayıt için haftanın başlangıç tarihini yansıtan bir week sütunu oluştururuz. Bu, lubridate paketi ve “hafta” olarak ayarlanan ve haftaların Pazartesi gününden itibaren başlayacağı (haftanın 1. günü - Pazar 7 olacaktır) floor_date() fonksiyonuyla elde edilir. Üst sıralar aşağıda gösterilmiştir.\n\nagg_weeks &lt;- agg_weeks %&gt;% \n  # Create week column from data_date\n  mutate(\n    week = lubridate::floor_date(                     # create new column of weeks\n      data_date,                                      # date column\n      unit = \"week\",                                  # give start of the week\n      week_start = 1))                                # weeks to start on Mondays \n\nYeni hafta sütunu, veri çerçevesinin en sağında görülebilir\n\n\n\n\n\n\nŞimdi veriler tesis-haftalar halinde gruplandırılır ve tesis-hafta başına istatistik üretmek için bunlar özetlenir. İpuçları için [Açıklayıcı tablolar] sayfasına bakın. Gruplandırmanın kendisi veri çerçevesini değiştirmez, ancak sonraki özet istatistiklerin nasıl hesaplandığını etkiler.\nÜst sıralar aşağıda gösterilmiştir. Sütunların, istenen özet istatistikleri yansıtacak şekilde nasıl tamamen değiştiğine dikkat edin. Her satır bir tesis-haftayı yansıtır.\n\nagg_weeks &lt;- agg_weeks %&gt;%   \n\n  # Group into facility-weeks\n  group_by(location_name, week) %&gt;%\n  \n  # Create summary statistics columns on the grouped data\n  summarize(\n    n_days          = 7,                                          # 7 days per week           \n    n_reports       = dplyr::n(),                                 # number of reports received per week (could be &gt;7)\n    malaria_tot     = sum(malaria_tot, na.rm = T),                # total malaria cases reported\n    n_days_reported = length(unique(data_date)),                  # number of unique days reporting per week\n    p_days_reported = round(100*(n_days_reported / n_days))) %&gt;%  # percent of days reporting\n     \n  ungroup(location_name, week)\n\n\n\n\n\n\n\nSon olarak, daha önce eksik olsalar bile, olası TÜM tesis-haftalarının verilerde mevcut olduğundan emin olmak için aşağıdaki komutu çalıştırılır.\nKendi üzerinde bir right_join() kullanıyoruz (veri seti “.” ile temsil edilir), ancak week ve location_name sütunlarının tüm olası kombinasyonlarını içerecek şekilde genişletildi. [Pivoting] sayfasındaki expand() işleviyle ilgili belgelere bakın. Bu kodu çalıştırmadan önce veri seti nrow(agg_weeks) satırlarını içerir.\n\n# Create data frame of every possible facility-week\nexpanded_weeks &lt;- agg_weeks %&gt;% \n     tidyr::expand(location_name, week)\n\nexpanded_weeks burada:\n\n\n\n\n\n\nBu kodu çalıştırmadan önce agg_weeks, nrow(agg_weeks) satırlarını içerir.\n\n# Use a right-join with the expanded facility-week list to fill-in the missing gaps in the data\nagg_weeks &lt;- agg_weeks %&gt;%      \n  right_join(expanded_weeks) %&gt;%                            # Ensure every possible facility-week combination appears in the data\n  mutate(p_days_reported = replace_na(p_days_reported, 0))  # convert missing values to 0                           \n\nJoining with `by = join_by(location_name, week)`\n\n\nBu kodu çalıştırdıktan sonra agg_weeks, nrow(agg_weeks) satırlarını içerir.\n\n\n\n\nIsı grafiği oluştur\nggplot(), ggplot2 paketindeki geom_tile() kullanılarak yapılır:\n\nx eksenindeki haftalar tarihlere dönüştürülerek scale_x_date() kullanımına izin verilir,\ny eksenindeki location_name tüm tesis adlarını gösterecek,\nfill, p_days_reported, o tesisin haftalık performansı (sayısal),\nscale_fill_gradient() yüksek, düşük ve NA için renkleri belirterek sayısal dolguda kullanılır,\nscale_x_date(), her 2 haftada bir etiketleri ve formatlarını belirten x ekseninde kullanılır,\nEkran temaları ve etiketleri gerektiği gibi ayarlanabilir.\n\n\n\n\nTemel\nAşağıda, varsayılan renkler, ölçekler vb. kullanılarak temel bir ısı grafiği üretilmiştir.Yukarıda açıklandığı gibi, geom_tile() için aes() içinde bir x ekseni sütunu, y ekseni sütunu ve fill = için bir sütun sağlamalısınız. Dolgu, kutucuk rengi olarak sunulan sayısal değerdir.\n\nggplot(data = agg_weeks)+\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported))\n\n\n\n\n\n\n\n\n\n\nTemizlenmiş grafik\nAşağıda gösterildiği gibi ek ggplot2 işlevleri ekleyerek bu grafiğin daha iyi görünmesini sağlayabiliriz. Ayrıntılar için [ggplot ipuçları] sayfasına bakın.\n\nggplot(data = agg_weeks)+ \n  \n  # show data as tiles\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported),      \n    color = \"white\")+                 # white gridlines\n  \n  scale_fill_gradient(\n    low = \"orange\",\n    high = \"darkgreen\",\n    na.value = \"grey80\")+\n  \n  # date axis\n  scale_x_date(\n    expand = c(0,0),             # remove extra space on sides\n    date_breaks = \"2 weeks\",     # labels every 2 weeks\n    date_labels = \"%d\\n%b\")+     # format is day over month (\\n in newline)\n  \n  # aesthetic themes\n  theme_minimal()+                                  # simplify background\n  \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1,\"cm\"),           # height of legend key\n    legend.key.width  = grid::unit(0.6,\"cm\"),         # width of legend key\n    \n    axis.text.x = element_text(size=12),              # axis text size\n    axis.text.y = element_text(vjust=0.2),            # axis text alignment\n    axis.ticks = element_line(size=0.4),               \n    axis.title = element_text(size=12, face=\"bold\"),  # axis title size and bold\n    \n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),  # title right-aligned, large, bold\n    plot.caption = element_text(hjust = 0, face = \"italic\")  # caption right-aligned and italic\n    )+\n  \n  # plot labels\n  labs(x = \"Week\",\n       y = \"Facility name\",\n       fill = \"Reporting\\nperformance (%)\",           # legend title, because legend shows fill\n       title = \"Percent of days per week that facility reported data\",\n       subtitle = \"District health facilities, May-July 2020\",\n       caption = \"7-day weeks beginning on Mondays.\")\n\n\n\n\n\n\n\n\n\n\n\nSıralı y ekseni\nŞu anda tesisler, aşağıdan yukarıya doğru “alfa-nümerik olarak” sıralanmıştır. Eğer y ekseni tesislerinin sırasını ayarlamak istiyorsanız, bunları sınıf faktörüne dönüştürün ve sırayı sağlayın. İpuçları için [Faktörler] sayfasına bakın.\nPek çok tesis olduğundan ve hepsini yazmak istemediğimizden, başka bir yaklaşım deneyeceğiz bu da tesisleri bir veri çerçevesinde sıralamak ve sonuç sütununu faktör düzeyi sırası olarak kullanmak olacak. Aşağıda, location_name sütunu bir faktöre dönüştürülür ve düzeylerinin sırası, tüm zaman aralığında tesis tarafından dosyalanan toplam raporlama günü sayısına göre belirlenir.\nBunu yapmak için, artan düzende düzenlenmiş, tesis başına toplam rapor sayısını temsil eden bir veri çerçevesi oluşturuyoruz. Grafikteki faktör seviyelerini sıralamak için bu vektör kullanılabilir.\n\nfacility_order &lt;- agg_weeks %&gt;% \n  group_by(location_name) %&gt;% \n  summarize(tot_reports = sum(n_days_reported, na.rm=T)) %&gt;% \n  arrange(tot_reports) # ascending order\n\nAşağıdaki veri çerçevesine bakın:\n\n\n\n\n\n\nŞimdi, agg_weeks veri çerçevesindeki location_name faktör düzeylerinin sırası olmak için yukarıdaki veri çerçevesinden (facility_order$location_name) bir sütun kullanın:\n\n# load package \npacman::p_load(forcats)\n\n# create factor and define levels manually\nagg_weeks &lt;- agg_weeks %&gt;% \n  mutate(location_name = fct_relevel(\n    location_name, facility_order$location_name)\n    )\n\nVe şimdi, location_name sıralı bir faktör olacak şekilde veriler yeniden çizilir:\n\nggplot(data = agg_weeks)+ \n  \n  # show data as tiles\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported),      \n    color = \"white\")+                 # white gridlines\n  \n  scale_fill_gradient(\n    low = \"orange\",\n    high = \"darkgreen\",\n    na.value = \"grey80\")+\n  \n  # date axis\n  scale_x_date(\n    expand = c(0,0),             # remove extra space on sides\n    date_breaks = \"2 weeks\",     # labels every 2 weeks\n    date_labels = \"%d\\n%b\")+     # format is day over month (\\n in newline)\n  \n  # aesthetic themes\n  theme_minimal()+                                  # simplify background\n  \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1,\"cm\"),           # height of legend key\n    legend.key.width  = grid::unit(0.6,\"cm\"),         # width of legend key\n    \n    axis.text.x = element_text(size=12),              # axis text size\n    axis.text.y = element_text(vjust=0.2),            # axis text alignment\n    axis.ticks = element_line(size=0.4),               \n    axis.title = element_text(size=12, face=\"bold\"),  # axis title size and bold\n    \n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),  # title right-aligned, large, bold\n    plot.caption = element_text(hjust = 0, face = \"italic\")  # caption right-aligned and italic\n    )+\n  \n  # plot labels\n  labs(x = \"Week\",\n       y = \"Facility name\",\n       fill = \"Reporting\\nperformance (%)\",           # legend title, because legend shows fill\n       title = \"Percent of days per week that facility reported data\",\n       subtitle = \"District health facilities, May-July 2020\",\n       caption = \"7-day weeks beginning on Mondays.\")\n\n\n\n\n\n\n\n\n\n\n\nDeğerleri göster\nHer kutucuğun gerçek sayılarını görüntülemek için kutucukların üzerine bir geom_text() katmanı ekleyebilirsiniz. Çok sayıda küçük kutucuğunuz varsa, bunun hoş görünmeyebileceğini unutmayın!\nŞu kod eklendi: geom_text(aes(label = p_days_reported)). Bu, her döşemeye metin ekler. Görüntülenen metin, bu durumda renk gradyanını oluşturmak için kullanılan p_days_reported ile aynı sayısal sütuna ayarlanmış olan label = bağımsız değişkenine atanan değerdir.\n\nggplot(data = agg_weeks)+ \n  \n  # show data as tiles\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported),      \n    color = \"white\")+                 # white gridlines\n  \n  # text\n  geom_text(\n    aes(\n      x = week,\n      y = location_name,\n      label = p_days_reported))+      # add text on top of tile\n  \n  # fill scale\n  scale_fill_gradient(\n    low = \"orange\",\n    high = \"darkgreen\",\n    na.value = \"grey80\")+\n  \n  # date axis\n  scale_x_date(\n    expand = c(0,0),             # remove extra space on sides\n    date_breaks = \"2 weeks\",     # labels every 2 weeks\n    date_labels = \"%d\\n%b\")+     # format is day over month (\\n in newline)\n  \n  # aesthetic themes\n  theme_minimal()+                                    # simplify background\n  \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1,\"cm\"),           # height of legend key\n    legend.key.width  = grid::unit(0.6,\"cm\"),         # width of legend key\n    \n    axis.text.x = element_text(size=12),              # axis text size\n    axis.text.y = element_text(vjust=0.2),            # axis text alignment\n    axis.ticks = element_line(size=0.4),               \n    axis.title = element_text(size=12, face=\"bold\"),  # axis title size and bold\n    \n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),  # title right-aligned, large, bold\n    plot.caption = element_text(hjust = 0, face = \"italic\")  # caption right-aligned and italic\n    )+\n  \n  # plot labels\n  labs(x = \"Week\",\n       y = \"Facility name\",\n       fill = \"Reporting\\nperformance (%)\",           # legend title, because legend shows fill\n       title = \"Percent of days per week that facility reported data\",\n       subtitle = \"District health facilities, May-July 2020\",\n       caption = \"7-day weeks beginning on Mondays.\")",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Isı grafikleri</span>"
    ]
  },
  {
    "objectID": "new_pages/heatmaps.tr.html#kaynaklar",
    "href": "new_pages/heatmaps.tr.html#kaynaklar",
    "title": "34  Isı grafikleri",
    "section": "34.4 Kaynaklar",
    "text": "34.4 Kaynaklar\nscale_fill_gradient()\nR grafik galerisi - ısı haritası",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Isı grafikleri</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.tr.html",
    "href": "new_pages/diagrams.tr.html",
    "title": "35  Diyagramlar ve çizelgeler",
    "section": "",
    "text": "35.1 Hazırlık",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Diyagramlar ve çizelgeler</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.tr.html#hazırlık",
    "href": "new_pages/diagrams.tr.html#hazırlık",
    "title": "35  Diyagramlar ve çizelgeler",
    "section": "",
    "text": "Paketleri yükleme\nBu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman paketinin p_load() işlevini vurguluyoruz. Ayrıca, R tabanından library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R temelleri sayfasına bakabilirsiniz.\n\npacman::p_load(\n  DiagrammeR,     # akış diyagramları için\n  networkD3,      # Alluvial/Sankey diyagramları için\n  tidyverse)      # veri yönetimi ve görselleştirme\n\n\n\nVerileri içe aktarma\nBu sayfadaki içeriğin çoğu bir veri seti gerektirmez. Ancak, Sankey diyagramı bölümünde, simüle edilmiş bir Ebola salgınından vaka satır listesini kullanacağız. Bu bölümü takip etmek isterseniz, “temiz satır listesini” indirmek (.rds dosyası olarak) için tıklayabilirsiniz. rio paketinden import() fonksiyonuyla verileri içe aktarabilirsiniz (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe ve Dışa Aktarma] sayfasına bakınız).\n\n# satır listesini içe aktar\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nÇizgi listesinin ilk 50 satırı aşağıda gösterilmiştir.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Diyagramlar ve çizelgeler</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.tr.html#akış-diyagramları",
    "href": "new_pages/diagrams.tr.html#akış-diyagramları",
    "title": "35  Diyagramlar ve çizelgeler",
    "section": "35.2 Akış diyagramları",
    "text": "35.2 Akış diyagramları\nGrafikler/akış şemaları oluşturmak için R paketi olan DiagrammeR kullanılabilir. Akış şemaları ister statik olabilirler veya isterse bir veri kümesindeki değişikliklere göre kısıtlı bir şekilde dinamik olarak ayarlanabilirler.\nAraçlar\ngrViz() fonksiyonu bir “Graphviz” diyagramı oluşturmak için kullanılır. Bu fonksiyon, diyagramı oluşturmak için talimatlar içeren bir karakter dizisi girişini kabul eder. Bu dizi içinde, talimatlar DOT adı verilen farklı bir dilde yazılmıştır - temel bilgileri öğrenmek oldukça kolaydır.\nTemel yapı\n\ngrViz(\" talimatlarını açın\nGrafiğin yönlülüğünü ve adını belirtin ve parantezleri açın, örn. digraph my_flow_chart {\nGrafik ifadesi (düzen, sıralama yönü)\nDüğüm ifadeleri (düğüm oluşturma)\nKenar ifadeleri (düğümler arasında bağlantılar verir)\nTalimatları kapatın }\")\n\n\nBasit örnekler\nAşağıda iki basit örnek verilmiştir\nÇok minimal bir örnek:\n\n# Minimal bir grafik\nDiagrammeR::grViz(\"digraph {\n  \ngraph[layout = dot, rankdir = LR]\n\na\nb\nc\n\na -&gt; b -&gt; c\n}\")\n\n\n\n\n\nBiraz daha uygulamalı halk sağlığı bağlamına sahip bir örnek:\n\ngrViz(\"                           # Tüm talimatlar büyük bir karakter dizisi içindedir\ndigraph surveillance_diagram {    # digraph', 'yönlü grafik' anlamına gelir, ardından grafik adı\n  \n  # grafik ifadesi\n  #################\n  graph [layout = dot,\n         rankdir = TB,\n         overlap = true,\n         fontsize = 10]\n  \n  # düğümler\n  #######\n  node [shape = circle,           # shape = circle\n       fixedsize = true\n       width = 1.3]               # width of circles\n  \n  Primary                         # names of nodes\n  Secondary\n  Tertiary\n\n  # kenarlar\n  #######\n  Primary   -&gt; Secondary [label = ' case transfer']\n  Secondary -&gt; Tertiary [label = ' case transfer']\n}\n\")\n\n\n\n\n\n\n\nSözdizimi\nTemel sözdizimi\nDüğüm adları veya kenar ifadeleri boşluk, noktalı virgül veya yeni satırlarla ayrılabilir.\nSıra yönü\nGrafik ifadesi içindeki rankdir argümanı ayarlanarak bir çizim soldan sağa hareket edecek şekilde yeniden yönlendirilebilir. Varsayılan değer TB’dir (yukarıdan aşağıya), ancak LR (soldan sağa), RL (sağdan sola) veya BT (aşağıdan yukarıya) olabilir.\nDüğüm adları\nDüğüm adları, yukarıdaki basit örnekte olduğu gibi tek kelime olabilir. Çok kelimeli adları veya özel karakterleri (örneğin parantezler, tireler) kullanmak için düğüm adını tek tırnak (’ ’) içine koyun. Kısa bir düğüm adına sahip olmak ve aşağıda köşeli parantez [ ] içinde gösterildiği gibi bir etiket atamak daha kolay olabilir. Düğümün adında yeni bir satır olmasını istiyorsanız, bunu bir etiket aracılığıyla yapmalısınız - aşağıda gösterildiği gibi düğüm etiketinde tek tırnak içinde \\n kullanmalısınız.\nAlt gruplar\nKenar ifadeleri içinde, küme parantezleri ({ }) ile kenarın her iki tarafında alt gruplar oluşturulabilir. Kenar daha sonra parantez içindeki tüm düğümlere uygulanır - bu bir kısa gösterimdir.\nDüzenler\n\ndot (rankdir argümanını TB, LR, RL, BT seçeneklerinden biri olarak belirleyin)\nneato\n\ntwopi\n\ncirco\n\nDüğümler - düzenlenebilir nitelikler\n\nlabel (metin, çok kelimeli ise tek tırnak içinde)\n\nfillcolor (birçok olası renk)\n\nfontcolor\n\nalpha (şeffaflık 0-1)\n\nshape (elips, oval, elmas, yumurta, düz metin, nokta, kare, üçgen)\n\nstyle\n\nsides\n\nperipheries\n\nfixedsize (h x w)\n\nheight\n\nwidth\n\ndistortion\n\npenwidth (şekil kenarlığının genişliği)\n\nx (sola/sağa yer değiştirme)\n\ny (yukarı/aşağı yer değiştirme)\n\nfontname\n\nfontsize\n\nicon\n\nKenarlar - düzenlenebilir nitelikler\n\narrowsize\n\narrowhead (normal, kutu, karga, eğri, elmas, nokta, inv, yok, tee, vee)\n\narrowtail\n\ndir (yön, )\n\nstyle (kesik çizgili, …)\n\ncolor\n\nalpha\n\nheadport (ok başının önündeki metin)\n\ntailport (ok kuyruğunun arkasındaki metin)\n\nfontname\n\nfontsize\n\nfontcolor\n\npenwidth (ok genişliği)\n\nminlen (minimum uzunluk)\n\nRenk adları: onaltılık değerler veya ‘X11’ renk adları, X11 ayrıntıları için buraya bakabilirsiniz.\n\n\nKarmaşık örnekler\nAşağıdaki örnek, gsurveillance_diagram genişleterek karmaşık düğüm adları, gruplandırılmış kenarlar, renkler ve stil ekler\nDiagrammeR::grViz(\"               # Tüm talimatlar büyük bir karakter dizisi\ndigraph surveillance_diagram {    # digraph', 'yönlü grafik' anlamına gelir, ardından grafik adı\n  \n  # grafik ifadesi\n  #################\n  graph [layout = dot,\n         rankdir = TB,            # yukarıdan aşağıya düzen\n         fontsize = 10]\n  \n\n  # düğümler (daireler)\n  #################\n  node [shape = circle,           # shape = daire\n       fixedsize = true\n       width = 1.3]                      \n  \n  Primary   [label = 'Primary\\nFacility'] \n  Secondary [label = 'Secondary\\nFacility'] \n  Tertiary  [label = 'Tertiary\\nFacility'] \n  SC        [label = 'Surveillance\\nCoordination',\n             fontcolor = darkgreen] \n  \n  # kenarlar\n  #######\n  Primary   -&gt; Secondary [label = ' case transfer',\n                          fontcolor = red,\n                          color = red]\n  Secondary -&gt; Tertiary [label = ' case transfer',\n                          fontcolor = red,\n                          color = red]\n  \n  # gruplanmış kenar\n  {Primary Secondary Tertiary} -&gt; SC [label = 'case reporting',\n                                      fontcolor = darkgreen,\n                                      color = darkgreen,\n                                      style = dashed]\n}\n\")\n\n\n\n\n\n\nAlt grafik kümeleri\nDüğümleri kutulu kümeler halinde gruplamak için, onları aynı adlandırılmış alt grafik (subgraph name {}) içine koyun. Her bir alt grafiğin bir sınırlayıcı kutu içinde tanımlanmasını sağlamak için, aşağıdaki 4 kutu ile gösterildiği gibi alt grafiğin adına “küme” ile başlayın.\nDiagrammeR::grViz(\"             # Tüm talimatlar büyük bir karakter dizisi içindedir\ndigraph surveillance_diagram {  # 'digraph', 'yönlü grafik' anlamına gelir, ardından grafik adı\n  \n  # grafik ifadesi\n  #################\n  graph [layout = dot,\n         rankdir = TB,            \n         overlap = true,\n         fontsize = 10]\n  \n\n  # düğümler (daireler)\n  #################\n  node [shape = circle,                  # shape = daire\n       fixedsize = true\n       width = 1.3]                      # dairelerin genişliği\n  \n  subgraph cluster_passive {\n    Primary   [label = 'Primary\\nFacility'] \n    Secondary [label = 'Secondary\\nFacility'] \n    Tertiary  [label = 'Tertiary\\nFacility'] \n    SC        [label = 'Surveillance\\nCoordination',\n               fontcolor = darkgreen] \n  }\n  \n  # düğümler (kutular)\n  ###############\n  node [shape = box,                     # düğüm şekli\n        fontname = Helvetica]            # düğümdeki metin yazı tipi\n  \n  subgraph cluster_active {\n    Active [label = 'Active\\nSurveillance'] \n    HCF_active [label = 'HCF\\nActive Search']\n  }\n  \n  subgraph cluster_EBD {\n    EBS [label = 'Event-Based\\nSurveillance (EBS)'] \n    'Social Media'\n    Radio\n  }\n  \n  subgraph cluster_CBS {\n    CBS [label = 'Community-Based\\nSurveillance (CBS)']\n    RECOs\n  }\n\n  \n  # kenarlar\n  #######\n  {Primary Secondary Tertiary} -&gt; SC [label = 'case reporting']\n\n  Primary   -&gt; Secondary [label = 'case transfer',\n                          fontcolor = red]\n  Secondary -&gt; Tertiary [label = 'case transfer',\n                          fontcolor = red]\n  \n  HCF_active -&gt; Active\n  \n  {'Social Media' Radio} -&gt; EBS\n  \n  RECOs -&gt; CBS\n}\n\")\n\n\n\n\n\n\n\nDüğüm şekilleri\nLinkteki rehberden alınan aşağıdaki örnek, uygulanan düğüm şekillerini ve seri kenar bağlantıları için bir kısayol gösterir.\n\nDiagrammeR::grViz(\"digraph {\n\ngraph [layout = dot, rankdir = LR]\n\n# düğümlerin global stillerini tanımlar. İstersek bunları kutuda geçersiz kılabiliriz\nnode [shape = rectangle, style = filled, fillcolor = Linen]\n\ndata1 [label = 'Dataset 1', shape = folder, fillcolor = Beige]\ndata2 [label = 'Dataset 2', shape = folder, fillcolor = Beige]\nprocess [label =  'Process \\n Data']\nstatistical [label = 'Statistical \\n Analysis']\nresults [label= 'Results']\n\n# düğüm kimlikleri ile kenar tanımları\n{data1 data2}  -&gt; process -&gt; statistical -&gt; results\n}\")\n\n\n\n\n\n\n\nÇıktılar\nÇıktılar nasıl işlenir ve kaydedilir:\n\nÇıktılar, varsayılan olarak Dosyalar, Grafikler, Paketler ve Yardım’ın yanında sağ altta RStudio’nun Görüntüleyici bölmesinde görünecektir.\n\nDışa aktarmak için Görüntüleyiciden “Görüntü olarak kaydet” veya “Panoya kopyala” yapabilirsiniz. Grafik belirtilen boyuta ayarlanacaktır.\n\n\n\nParametreli şekiller\nSize önerebileceğimiz güzel bir rehberden bir alıntı ile başlamak istiyoruz: https://mikeyharper.uk/flowcharts-in-r-using-diagrammer/\n“Parametreli şekiller: Rakamları R içinde tasarlamanın büyük bir yararı, R değerlerini doğrudan akış şemalarımıza okuyarak rakamları doğrudan analizimizle bağlayabilmemizdir. Örneğin, bir işlemin her aşamasından sonra değerleri kaldıran bir filtreleme işlemi oluşturduğunuzu varsayalım, işleminizin her aşamasından sonra veri kümesinde kalan değerlerin sayısını gösteren bir şekle sahip olabilirsiniz. Bunu yapmak için, @@X sembolünü doğrudan şeklin içinde kullanabilir, ardından grafiğin alt bilgisinde [X]: kullanarak buna başvurabilirsiniz, burada X benzersiz bir sayısal dizindir.”\nParametrelendirme ilgilendiğiniz bir şeyse, bu rehberi incelemenizi öneririz.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Diyagramlar ve çizelgeler</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.tr.html#alluvialsankey-diyagramları",
    "href": "new_pages/diagrams.tr.html#alluvialsankey-diyagramları",
    "title": "35  Diyagramlar ve çizelgeler",
    "section": "35.3 Alluvial/Sankey Diyagramları",
    "text": "35.3 Alluvial/Sankey Diyagramları\n\nPaketleri yükleme\nBu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman paketinin p_load() işlevini vurguluyoruz. Ayrıca, R tabanından library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R temelleri sayfasına bakabilirsiniz.\nDiyagramı oluşturmak için networkD3 paketini ve ayrıca veri hazırlama adımları için tidyverse’i yüklüyoruz.\n\npacman::p_load(\n  networkD3,\n  tidyverse)\n\n\n\nVeri kümesinden grafik yapma\nBağlantıları bir veri kümesinde çizme. Aşağıda bu paketi vaka satırı listesinde kullanmayı gösteriyoruz. Çevrimiçi bir eğitime ulaşmak için bu linke tıklayabilirsiniz..\nHer benzersiz yaş kategorisi ve hastane kombinasyonu için vaka sayılarını alarak başlıyoruz. Anlaşılır olması için yaş kategorisine ait eksik değerleri kaldırdık. Ayrıca hospital ve age_cat sütunlarını sırasıyla source ve target olarak yeniden etiketliyoruz. Bunlar alluvial diyagramının iki yüzü olacaktır.\n\n# hastane ve yaş kategorisine göre sayımlar\nlinks &lt;- linelist %&gt;% \n  drop_na(age_cat) %&gt;% \n  select(hospital, age_cat) %&gt;%\n  count(hospital, age_cat) %&gt;% \n  rename(source = hospital,\n         target = age_cat)\n\nVeri kümesi şimdi şöyle görünmektedir:\n\n\n\n\n\n\nŞimdi sütun adı altında tüm diyagram düğümlerinin bir veri çerçevesini oluşturuyoruz. Bu, hospital ve age_cat’e ait bütün değerlerden oluşmaktadır. Birleştirmeden önce hepsinin karakter sınıfı olduğundan emin olmalı ve kimlik sütunlarını etiketler yerine sayı olacak şekilde ayarlamalıyız:\n\n# Benzersiz düğüm adları\nnodes &lt;- data.frame(\n  name=c(as.character(links$source), as.character(links$target)) %&gt;% \n    unique()\n  )\n\nnodes  # yazdır\n\n                                   name\n1                      Central Hospital\n2                     Military Hospital\n3                               Missing\n4                                 Other\n5                         Port Hospital\n6  St. Mark's Maternity Hospital (SMMH)\n7                                   0-4\n8                                   5-9\n9                                 10-14\n10                                15-19\n11                                20-29\n12                                30-49\n13                                50-69\n14                                  70+\n\n\nYukarıda oluşturduğumuz link veri çerçevesini count() ile düzenliyoruz. Düğümler arasındaki bağlantıları gerçekten yansıtacak/oluşturacak iki sayısal sütun IDsource ve IDtarget ekliyoruz. Bu sütunlar, kaynak ve hedef düğümlerin satır numaralarını (konumunu) tutacaktır. 1 çıkarılır, böylece bu konum numaraları 0’dan başlar (1 değil).\n\n# isimlerle değil sayılarla eşleştirir\nlinks$IDsource &lt;- match(links$source, nodes$name)-1 \nlinks$IDtarget &lt;- match(links$target, nodes$name)-1\n\nBağlantı veri kümesi şimdi şöyle görünür:\n\n\n\n\n\n\nŞimdi Sankey diyagramını sankeyNetwork() ile çizebiliriz. Konsolda ?sankeyNetwork komutunu çalıştırarak her bir bağımsız değişkeni hakkında daha fazla bilgi edinebilirsiniz. iterations = 0 olarak ayarlamadığınız sürece düğümlerinizin sırasının beklendiği gibi olmayabileceğini unutmayın.\n\n# grafik\n######\np &lt;- sankeyNetwork(\n  Links = links,\n  Nodes = nodes,\n  Source = \"IDsource\",\n  Target = \"IDtarget\",\n  Value = \"n\",\n  NodeID = \"name\",\n  units = \"TWh\",\n  fontSize = 12,\n  nodeWidth = 30,\n  iterations = 0)        # düğüm sırasının verilerdeki gibi olduğundan emin olun\np\n\n\n\n\n\nBurada hasta çıktısının da dahil edildiği bir örnek verilmiştir. Veri hazırlama adımında, yaş ile hastane arasındaki ve hastane ile sonuç arasındaki vaka sayılarını ayrı ayrı hesaplamamız gerektiğine ve ardından tüm bu sayıları bind_rows() ile birbirine bağlamamız gerektiğine dikkat etmelisiniz.\n\n# hastane ve yaş kategorisine göre sayımlar\nage_hosp_links &lt;- linelist %&gt;% \n  drop_na(age_cat) %&gt;% \n  select(hospital, age_cat) %&gt;%\n  count(hospital, age_cat) %&gt;% \n  rename(source = age_cat,          # yeniden adlandır\n         target = hospital)\n\nhosp_out_links &lt;- linelist %&gt;% \n    drop_na(age_cat) %&gt;% \n    select(hospital, outcome) %&gt;% \n    count(hospital, outcome) %&gt;% \n    rename(source = hospital,       # yeniden adlandır\n           target = outcome)\n\n# bağlantıları birleştir\nlinks &lt;- bind_rows(age_hosp_links, hosp_out_links)\n\n# Benzersiz düğüm adları\nnodes &lt;- data.frame(\n  name=c(as.character(links$source), as.character(links$target)) %&gt;% \n    unique()\n  )\n\n# Kimlik numaraları oluştur\nlinks$IDsource &lt;- match(links$source, nodes$name)-1 \nlinks$IDtarget &lt;- match(links$target, nodes$name)-1\n\n# grafik\n######\np &lt;- sankeyNetwork(Links = links,\n                   Nodes = nodes,\n                   Source = \"IDsource\",\n                   Target = \"IDtarget\",\n                   Value = \"n\",\n                   NodeID = \"name\",\n                   units = \"TWh\",\n                   fontSize = 12,\n                   nodeWidth = 30,\n                   iterations = 0)\np\n\n\n\n\n\nhttps://www.displayr.com/sankey-diagrams-r/",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Diyagramlar ve çizelgeler</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.tr.html#etkinlik-zaman-çizelgeleri",
    "href": "new_pages/diagrams.tr.html#etkinlik-zaman-çizelgeleri",
    "title": "35  Diyagramlar ve çizelgeler",
    "section": "35.4 Etkinlik zaman çizelgeleri",
    "text": "35.4 Etkinlik zaman çizelgeleri\nBelirli olayları gösteren bir zaman çizelgesi oluşturmak için vistime paketini kullanabilirsiniz.\nLinkteki bu gösterimi inceleyebilirsiniz\n\n# paketi yükle\npacman::p_load(vistime,  # zaman çizelgesini hazırla\n               plotly    # etkileşimli görselleştirme için\n               )\n\nİşte kodladığımız olaylar veri seti:\n\n\n\n\n\n\n\np &lt;- vistime(data)    # vistime'ı uygula\n\nlibrary(plotly)\n\n# 1. adım: bir listeye dönüştür\npp &lt;- plotly_build(p)\n\n# 2. adım: İşaretleyici boyutu\nfor(i in 1:length(pp$x$data)){\n  if(pp$x$data[[i]]$mode == \"markers\") pp$x$data[[i]]$marker$size &lt;- 10\n}\n\n# 3. adım: metin boyutu\nfor(i in 1:length(pp$x$data)){\n  if(pp$x$data[[i]]$mode == \"text\") pp$x$data[[i]]$textfont$size &lt;- 10\n}\n\n\n# 4. adım: metin konumu\nfor(i in 1:length(pp$x$data)){\n  if(pp$x$data[[i]]$mode == \"text\") pp$x$data[[i]]$textposition &lt;- \"right\"\n}\n\n#yazdır\npp",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Diyagramlar ve çizelgeler</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.tr.html#dagler",
    "href": "new_pages/diagrams.tr.html#dagler",
    "title": "35  Diyagramlar ve çizelgeler",
    "section": "35.5 DAG’ler",
    "text": "35.5 DAG’ler\nYukarıda açıklandığı gibi DiagammeR paketini ve DOT dilini kullanarak manuel olarak bir DAG oluşturabilirsiniz.\nAlternatif olarak, ggdag ve dagitty gibi paketler de var.\nDAG’lere giriş ggdag gösterimi\nR’deki dag’lere nedensellik",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Diyagramlar ve çizelgeler</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.tr.html#kaynaklar",
    "href": "new_pages/diagrams.tr.html#kaynaklar",
    "title": "35  Diyagramlar ve çizelgeler",
    "section": "35.6 Kaynaklar",
    "text": "35.6 Kaynaklar\nDOT diliyle ilgili yukarıdakilerin çoğu bu sitedeki öğreticiden uyarlanmıştır.\nDiagammeR hakkında daha ayrıntılı bir eğitim daha\nSankey diagramları hakkında bu sayfa",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Diyagramlar ve çizelgeler</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.tr.html",
    "href": "new_pages/combination_analysis.tr.html",
    "title": "36  Kombinasyon analizi",
    "section": "",
    "text": "36.1 Hazırlık",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Kombinasyon analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.tr.html#hazırlık",
    "href": "new_pages/combination_analysis.tr.html#hazırlık",
    "title": "36  Kombinasyon analizi",
    "section": "",
    "text": "Paketleri yükleyin\nBu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() vurgusu yapıyoruz. R tabanından library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakabilirsiniz.\n\npacman::p_load(\n  tidyverse,     # veri yönetimi ve görselleştirme\n  UpSetR,        # kombinasyon grafikleri için özel paket\n  ggupset)       # kombinasyon grafikleri için özel paket\n\n\n\n\nVerileri içe aktar\nBaşlamak için, simüle edilmiş bir Ebola salgınından temizlenmiş vaka listesini içe aktarıyoruz. Takip etmek isterseniz, “clean” dosyasını indirmek için tıklayın.  (.rds dosyası olarak). rio paketinden import() fonksiyonuyla verileri içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakın).\n\n# Vaka satırlistesini içe aktarın\nlinelist_sym &lt;- import(\"linelist_cleaned.rds\")\n\nBu satır listesi, bildirilen semptomlarla ilgili beş “evet/hayır” değişkeni içerir. Grafiğimizi oluşturmak için ggupset paketini kullanmak için bu değişkenleri biraz dönüştürmemiz gerekecek. Verileri görüntüleyin (semptom değişkenlerini görmek için sağa kaydırın).\n\n\n\n\n\n\n\n\n\nDeğerleri yeniden biçimlendir\nggupset tarafından beklenen formata uyum sağlamak için dplyr’den case_while() kullanarak gerçek semptom adını “evet” ve “hayır”a dönüştürürüz. “Hayır” ise, değeri boş olarak ayarlarız, bu nedenle değerler “NA” veya semptomdur.\n\n# noktalı virgülle ayrılmış olarak adlandırılmış belirtilerle sütun oluşturun\nlinelist_sym_1 &lt;- linelist_sym %&gt;% \n  \n  # \"evet\" ve \"hayır\" değerlerini semptom adının kendisine dönüştürün\n  mutate(fever = ifelse(fever == \"yes\", \"fever\", NA), \n       chills = ifelse(chills == \"yes\", \"chills\", NA),\n       cough = ifelse(cough == \"yes\", \"cough\", NA),\n       aches = ifelse(aches == \"yes\", \"aches\", NA),\n       vomit = ifelse(vomit == \"yes\", \"vomit\", NA))\n\nŞimdi iki son sütun yapıyoruz:\n\nHastanın tüm semptomlarını birleştirmek (birbirine yapıştırmak) (bir karakter sütunu)\nYukarıdaki sütunu list sınıfına dönüştürmek, böylece grafik yapmak için ggupset tarafından kabul edilebilir.\n\nstringr’den unite() fonksiyonu hakkında daha fazla bilgi edinmek için [Karakterler ve dizeler] hakkındaki sayfaya bakabilirsiniz.\n\nlinelist_sym_1 &lt;- linelist_sym_1 %&gt;% \n  unite(col = \"all_symptoms\",\n        c(fever, chills, cough, aches, vomit), \n        sep = \"; \",\n        remove = TRUE,\n        na.rm = TRUE) %&gt;% \n  mutate(\n    # all_symptoms sütununun, \"list\" sınıfının (bir sonraki adımda ggupset() kullanmak için gereklidir) bir kopyasını yapın\n    all_symptoms_list = as.list(strsplit(all_symptoms, \"; \"))\n    )\n\nYeni verileri görüntüleyin. Sağ uca doğru iki sütuna dikkat edin - yapıştırılan birleştirilmiş değerler ve liste",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Kombinasyon analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.tr.html#ggupset",
    "href": "new_pages/combination_analysis.tr.html#ggupset",
    "title": "36  Kombinasyon analizi",
    "section": "36.2 ggupset",
    "text": "36.2 ggupset\nPaketi yükleme\n\npacman::p_load(ggupset)\n\nGrafik oluşturun. Bir ggplot() ve geom_bar() ile başlıyoruz, ancak sonra ggupset’ten scale_x_upset() özel fonksiyonunu ekliyoruz.\n\nggplot(\n  data = linelist_sym_1,\n  mapping = aes(x = all_symptoms_list)) +\ngeom_bar() +\nscale_x_upset(\n  reverse = FALSE,\n  n_intersections = 10,\n  sets = c(\"fever\", \"chills\", \"cough\", \"aches\", \"vomit\"))+\nlabs(\n  title = \"Signs & symptoms\",\n  subtitle = \"10 most frequent combinations of signs and symptoms\",\n  caption = \"Caption here.\",\n  x = \"Symptom combination\",\n  y = \"Frequency in dataset\")\n\n\n\n\n\n\n\n\nggupset hakkında daha fazla bilgiyi çevrimiçi veya çevrimdışı olarak RStudio Yardım sekmeniz ?ggupset içindeki paket belgelerinde bulabilirsiniz.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Kombinasyon analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.tr.html#upsetr",
    "href": "new_pages/combination_analysis.tr.html#upsetr",
    "title": "36  Kombinasyon analizi",
    "section": "36.3 UpSetR",
    "text": "36.3 UpSetR\nUpSetR paketi grafiğin daha fazla özelleştirilmesine izin verir, ancak yürütülmesi daha zor olabilir:\nPaketi yüklemek\n\npacman::p_load(UpSetR)\n\nVeri temizliği\n‘satırlistesi’ semptom değerlerini 1 / 0’a çevirmeliyiz.\n\n# upSetR kullanarak yapın\n\nlinelist_sym_2 &lt;- linelist_sym %&gt;% \n  \n  # \"evet\" ve \"hayır\" değerlerini semptom adının kendisine dönüştürün\n     mutate(fever = ifelse(fever == \"yes\", 1, 0), \n            chills = ifelse(chills == \"yes\", 1, 0),\n            cough = ifelse(cough == \"yes\", 1, 0),\n            aches = ifelse(aches == \"yes\", 1, 0),\n            vomit = ifelse(vomit == \"yes\", 1, 0))\n\nDaha verimli bir komutla ilgileniyorsanız, mantıksal bir ifadeye dayalı olarak 1’lere ve 0’lara dönüştüren +() işlevinden yararlanabilirsiniz. Bu komut, aynı anda birden fazla sütunu değiştirmek için across() fonksiyonunu kullanır (daha fazla bilgi için Veri temizleme ve temel fonksiyonlar).\n\n# Efficiently convert \"yes\" to 1 and 0\nlinelist_sym_2 &lt;- linelist_sym %&gt;% \n  \n  # convert the \"yes\" and \"no\" values into 1s and 0s\n  mutate(across(c(fever, chills, cough, aches, vomit), .fns = ~+(.x == \"yes\")))\n\nŞimdi ‘upset()’ özel fonksiyonunu kullanarak grafiği yapın - yalnızca belirtiler sütunlarını kullanarak. Hangi “kümelerin” karşılaştırılacağını belirlemelisiniz (semptom sütunlarının adları). Alternatif olarak, yalnızca en iyi X kombinasyonlarını göstermek için nsets = ve order.by = \"freq\" kullanın.\n\n# Grafiği çizin\nlinelist_sym_2 %&gt;% \n     UpSetR::upset(\n       sets = c(\"fever\", \"chills\", \"cough\", \"aches\", \"vomit\"),\n       order.by = \"freq\",\n       sets.bar.color = c(\"blue\", \"red\", \"yellow\", \"darkgreen\", \"orange\"), # optional colors\n       empty.intersections = \"on\",\n       # nsets = 3,\n       number.angles = 0,\n       point.size = 3.5,\n       line.size = 2, \n       mainbar.y.label = \"Symptoms Combinations\",\n       sets.x.label = \"Patients with Symptom\")",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Kombinasyon analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.tr.html#kaynaklar",
    "href": "new_pages/combination_analysis.tr.html#kaynaklar",
    "title": "36  Kombinasyon analizi",
    "section": "36.4 Kaynaklar",
    "text": "36.4 Kaynaklar\nUpSetR üzerine github sayfası\nA Shiny uygulama versiyonu - kendi verinizi yükleyebilirsiniz\n*belgeler - yorumlanması zor",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Kombinasyon analizi</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.tr.html",
    "href": "new_pages/transmission_chains.tr.html",
    "title": "37  İletim Zincirleri",
    "section": "",
    "text": "37.1 Genel Bakış\nİletim zincirlerini ve temas izleme verilerini işlemek, analiz etmek ve görselleştirmek için birincil araç, RECON tarafından geliştirilen epicontacts paketidir. Daha fazla bilgi için imleci nodların üzerine getirerek, taşımak için sürükleyerek ve aşağı akış durumlarını vurgulamak için üzerlerine tıklayarak aşağıdaki etkileşimli grafiği deneyin\nWarning in epicontacts::make_epicontacts(linelist = linelist, contacts =\ncontacts, : Cycle(s) detected in the contact network: this may be unwanted",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>İletim Zincirleri</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.tr.html#hazırlık",
    "href": "new_pages/transmission_chains.tr.html#hazırlık",
    "title": "37  İletim Zincirleri",
    "section": "37.2 Hazırlık",
    "text": "37.2 Hazırlık\n\nPaketlerin yüklenmesi\nÖnce verilerin içe aktarılması ve işlenmesi için gereken standart paketleri yükleyin. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’ın ‘p_load()’ fonksiyonunu vurguluyoruz. Ayrıca R tabanı’ndan ‘library()’ ile paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R’ın temelleri[R Basics] sayfasına bakın.\n\npacman::p_load(\n   rio,          # Dosyanın içe aktarımı \n   here,         # Dosyanın konumlandırılması \n   tidyverse,    # Veri yönetimi + ggplot2 grafikleri\n   remotes       # github’dan paketlerin kurulumu  \n)\n\nPacman’ın p_install_github() fonksiyonu kullanılarak github’dan yüklenebilen epicontacts’ın geliştirme sürümüne ihtiyacınız olacak. Aşağıdaki komutu yalnızca bir kez çalıştırmanız gerekir, paketi her kullandığınızda değil (bundan sonra her zamanki gibi p_load() kullanabilirsiniz).\n\npacman::p_install_gh(\"reconhub/epicontacts@timeline\")\n\n\n\nVerinin içeri aktarımı\nSimüle edilmiş bir Ebola salgını vakalarından oluşan veri setini içe aktarıyoruz. Adım adım verileri indirmek istiyorsanız, el kitabı ve verilerin indirilmesi sayfasındaki talimatlara Download handbook and data bakın. Veri seti, rio paketinden import() fonkisyonu kullanılarak içe aktarılır. Verileri içe aktarmanın çeşitli yolları için İçe ve dışa aktarma sayfasına [Import and export] bakın.\n\n# satır listesini içe aktarın\nlinelist &lt;- import(\"linelist_cleaned.xlsx\")\n\nÇizgi listesinin ilk 50 satırı aşağıda gösterilmiştir. Özellikle ilgi çekici olan sütunlar : ‘case_id’, ‘generation’, ‘infector’ ve ‘source’.\n\n\n\n\n\n\n\n\nEpicontacts nesnesi oluşturma\nDaha sonra iki tür veri gerektiren bir epicontacts nesnesi oluşturmamız gerekiyor: • Sütunların değişken olduğu ve satırların benzersiz durumlara karşılık geldiği bir satır listesi • Benzersiz kimliklerle vakalar arasındaki bağlantıları tanımlayan kenarların bir listesi (bunlar kişiler, aktarım olayları vb. olabilir)\nHalihazırda bir satır listemiz olduğundan, vakalar arasında, daha spesifik olarak kimlikleri arasında bir kenar listesi oluşturmamız gerekiyor. Enfektör sütununu ‘case_id’ sütununa bağlayarak satır listesinden iletim bağlantılarını çıkarabiliriz. Bu noktada, vakaların kendilerini değil, iki durum arasındaki bağlantıyı tanımlayan herhangi bir değişkeni gösterdiğimiz kenar özelliklerini (edge properties) de ekleyebiliriz. Örnek olarak, iletim olayının konumunu tanımlayan bir konum değişkeni ve gün cinsinden temasın süresini tanımlayan bir süre değişkeni ekleyeceğiz.\nAşağıdaki kodda, dplyr fonksiyonu transmut’e, yalnızca fonksiyon içinde belirttiğimiz sütunları tutması dışında mutate’e benzer. drop_na fonksiyonu, belirtilen sütunlarda bir NA değeri olan tüm satırları filtreleyecektir; bu durumda, yalnızca bulaştırıcının bilindiği satırları tutmak istiyoruz.\n\n## kişileri oluştur\ncontacts &lt;- linelist %&gt;%\n  transmute(\n    infector = infector,\n    case_id = case_id,\n    location = sample(c(\"Community\", \"Nosocomial\"), n(), TRUE),\n    duration = sample.int(10, n(), TRUE)\n  ) %&gt;%\n  drop_na(infector)\n\nArtık ‘make_epicontacts’ fonksiyonunu kullanarak epicontacts nesnesini oluşturabiliriz. Satır listesindeki hangi sütunun benzersiz vaka tanımlayıcısına işaret ettiğini ve ayrıca ilgili kişilerdeki hangi sütunların bağlantıda yer alan vakaların benzersiz tanımlayıcılarına işaret ettiğini belirtmemiz gerekir. Bu bağlantılar, enfeksiyonun bulaştırıcıdan vakaya gittiği yöndedir, bu nedenle başlangıç ve sonuç değişkenlerini belirtmemiz gerekir. Bu sebeple, gelecekteki işlemleri etkileyecek olan yönlendirilmiş (directed) değişkenini TRUE olarak ayarladık.\n\n## epicontacts nesnesi oluştur \nepic &lt;- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts,\n  id = \"case_id\",\n  from = \"infector\",\n  to = \"case_id\",\n  directed = TRUE\n)\n\nWarning in make_epicontacts(linelist = linelist, contacts = contacts, id =\n\"case_id\", : Cycle(s) detected in the contact network: this may be unwanted\n\n\nEpicontacts nesnelerini inceledikten sonra, satır listesindeki case_id sütununun id olarak yeniden adlandırıldığını ve temaslılardaki case_id ve infector sütunlarının from (-den) ve to (-e) olarak yeniden adlandırıldığını görebiliriz. Bu adım, sonraki işleme, görselleştirme ve analiz işlemlerinde tutarlılık sağlar.\n\n##  epicontacts nesnesini göster\nepic\n\n\n/// Epidemiological Contacts //\n\n  // class: epicontacts\n  // 5,888 cases in linelist; 3,800 contacts; directed \n\n  // linelist\n\n# A tibble: 5,888 × 30\n   id     generation date_infection date_onset date_hospitalisation date_outcome\n   &lt;chr&gt;       &lt;dbl&gt; &lt;date&gt;         &lt;date&gt;     &lt;date&gt;               &lt;date&gt;      \n 1 5fe599          4 2014-05-08     2014-05-13 2014-05-15           NA          \n 2 8689b7          4 NA             2014-05-13 2014-05-14           2014-05-18  \n 3 11f8ea          2 NA             2014-05-16 2014-05-18           2014-05-30  \n 4 b8812a          3 2014-05-04     2014-05-18 2014-05-20           NA          \n 5 893f25          3 2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n 6 be99c8          3 2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n 7 07e3e8          4 2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n 8 369449          4 2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n 9 f393b4          4 NA             2014-06-05 2014-06-06           2014-06-18  \n10 1389ca          4 NA             2014-06-05 2014-06-07           2014-06-09  \n# ℹ 5,878 more rows\n# ℹ 24 more variables: outcome &lt;chr&gt;, gender &lt;chr&gt;, age &lt;dbl&gt;, age_unit &lt;chr&gt;,\n#   age_years &lt;dbl&gt;, age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;, hospital &lt;chr&gt;, lon &lt;dbl&gt;,\n#   lat &lt;dbl&gt;, infector &lt;chr&gt;, source &lt;chr&gt;, wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;,\n#   ct_blood &lt;dbl&gt;, fever &lt;chr&gt;, chills &lt;chr&gt;, cough &lt;chr&gt;, aches &lt;chr&gt;,\n#   vomit &lt;chr&gt;, temp &lt;dbl&gt;, time_admission &lt;chr&gt;, bmi &lt;dbl&gt;,\n#   days_onset_hosp &lt;dbl&gt;\n\n  // contacts\n\n# A tibble: 3,800 × 4\n   from   to     location   duration\n   &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;         &lt;int&gt;\n 1 f547d6 5fe599 Nosocomial        5\n 2 f90f5f b8812a Community         4\n 3 11f8ea 893f25 Nosocomial        1\n 4 aec8ec be99c8 Community        10\n 5 893f25 07e3e8 Nosocomial        8\n 6 133ee7 369449 Community         6\n 7 996f3a 2978ac Nosocomial        4\n 8 133ee7 57a565 Nosocomial        5\n 9 37a6f6 fc15ef Community         7\n10 9f6884 2eaa9a Community         5\n# ℹ 3,790 more rows",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>İletim Zincirleri</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.tr.html#idare",
    "href": "new_pages/transmission_chains.tr.html#idare",
    "title": "37  İletim Zincirleri",
    "section": "37.3 İdare",
    "text": "37.3 İdare\n\nAltkümeleme\nepicontacts nesneleri için subset() yöntemi, diğer nesnelerin yanı sıra, satır listesinin (“düğüm(nod) öznitelikleri”) ve kişiler veritabanının (“kenar öznitelikleri”) özelliklerine dayalı olarak ağların filtrelenmesine olanak tanır. Bu değerler, ilgili bağımsız değişkene adlandırılmış listeler olarak iletilmelidir. Örneğin, aşağıdaki kodda sadece Nisan-Temmuz 2014 arasında enfeksiyonu olan (tarihler aralık olarak belirtilmiştir) erkek vakaları ve hastanede meydana gelen bulaşma bağlantılarını satır listesinde tutuyoruz.\n\nsub_attributes &lt;- subset(\n  epic,\n  node_attribute = list(\n    gender = \"m\",\n    date_infection = as.Date(c(\"2014-04-01\", \"2014-07-01\"))\n  ), \n  edge_attribute = list(location = \"Nosocomial\")\n)\nsub_attributes\n\n\n/// Epidemiological Contacts //\n\n  // class: epicontacts\n  // 69 cases in linelist; 1,829 contacts; directed \n\n  // linelist\n\n# A tibble: 69 × 30\n   id     generation date_infection date_onset date_hospitalisation date_outcome\n   &lt;chr&gt;       &lt;dbl&gt; &lt;date&gt;         &lt;date&gt;     &lt;date&gt;               &lt;date&gt;      \n 1 5fe599          4 2014-05-08     2014-05-13 2014-05-15           NA          \n 2 893f25          3 2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n 3 2978ac          4 2014-05-30     2014-06-06 2014-06-08           2014-06-15  \n 4 57a565          4 2014-05-28     2014-06-13 2014-06-15           NA          \n 5 fc15ef          6 2014-06-14     2014-06-16 2014-06-17           2014-07-09  \n 6 99e8fa          7 2014-06-24     2014-06-28 2014-06-29           2014-07-09  \n 7 f327be          6 2014-06-14     2014-07-12 2014-07-13           2014-07-14  \n 8 90e5fe          5 2014-06-18     2014-07-13 2014-07-14           2014-07-16  \n 9 a47529          5 2014-06-13     2014-07-17 2014-07-18           2014-07-26  \n10 da8ecb          5 2014-06-20     2014-07-18 2014-07-20           2014-08-01  \n# ℹ 59 more rows\n# ℹ 24 more variables: outcome &lt;chr&gt;, gender &lt;chr&gt;, age &lt;dbl&gt;, age_unit &lt;chr&gt;,\n#   age_years &lt;dbl&gt;, age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;, hospital &lt;chr&gt;, lon &lt;dbl&gt;,\n#   lat &lt;dbl&gt;, infector &lt;chr&gt;, source &lt;chr&gt;, wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;,\n#   ct_blood &lt;dbl&gt;, fever &lt;chr&gt;, chills &lt;chr&gt;, cough &lt;chr&gt;, aches &lt;chr&gt;,\n#   vomit &lt;chr&gt;, temp &lt;dbl&gt;, time_admission &lt;chr&gt;, bmi &lt;dbl&gt;,\n#   days_onset_hosp &lt;dbl&gt;\n\n  // contacts\n\n# A tibble: 1,829 × 4\n   from   to     location   duration\n   &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;         &lt;int&gt;\n 1 f547d6 5fe599 Nosocomial        5\n 2 11f8ea 893f25 Nosocomial        1\n 3 893f25 07e3e8 Nosocomial        8\n 4 996f3a 2978ac Nosocomial        4\n 5 133ee7 57a565 Nosocomial        5\n 6 5d9e4d 8bd1e8 Nosocomial        7\n 7 ea3740 90e5fe Nosocomial        5\n 8 beb26e 959170 Nosocomial        8\n 9 567136 8ebf6e Nosocomial        1\n10 894024 e56412 Nosocomial        7\n# ℹ 1,819 more rows\n\n\nthin fonksiyonunu, ‘what = “linelist”’ değişkeniyle temaslılarda bulunan vakaları dahil etmek için satır listesini filtrelemek veya ‘what = “contacts”’ değişkeniyle satır listesinde bulunan vakaları dahil etmek için kullanabiliriz. Aşağıdaki kodda, yukarıda filtrelediğimiz Nisan ve Temmuz ayları arasında enfekte olan erkek vakaları içeren iletim bağlantılarını tutmak için epicontacts nesnesini ayrıca filtreliyoruz. Sadece iki bilinen iletim bağlantısının bu filtreye uyduğunu görebiliriz.\n\nsub_attributes &lt;- thin(sub_attributes, what = \"contacts\")\nnrow(sub_attributes$contacts)\n\n[1] 4\n\n\nNod ve kenar özniteliklerine göre alt kümelemeye ek olarak, ağlar yalnızca belirli nodlara bağlı bileşenleri içerecek şekilde budanabilir. ‘Cluster_id’ değişkeni, vaka kimliklerinin bir vektörünü alır ve doğrudan veya dolaylı olarak bu kimliklere bağlı bireylerin satır listesini getirir. Aşağıdaki kodda, ‘2ae019’ ve ‘71577a’ içeren kümelerde toplam 13 satır listesi vakasının yer aldığını görebiliriz.\n\nsub_id &lt;- subset(epic, cluster_id = c(\"2ae019\",\"71577a\"))\nnrow(sub_id$linelist)\n\n[1] 13\n\n\nepicontacts nesneleri için subset() yöntemi ayrıca cs, cs_min ve cs_max değişkenlerini kullanarak küme boyutuna göre filtrelemeye izin verir. Aşağıdaki kodda, yalnızca 10 vaka veya daha büyük kümelere dahil olan vakaları tutuyoruz ve bu kümelerde 271 satır listesi vakasının yer aldığını görebiliriz.\n\nsub_cs &lt;- subset(epic, cs_min = 10)\nnrow(sub_cs$linelist)\n\n[1] 271\n\n\n\n\nID’lere ulaşmak\nget_id() fonksiyonu, veri setindeki vaka kimlikleri hakkında bilgi toplar ve aşağıdaki gibi parametrelenebilir: • linelist: satır listesi verilerindeki kimlikler • contacts: temaslı veri setindeki kimlikler (“from-kimden” ve “to-kime” birleşik) • from: temaslı veri setinin “kimden” sütunundaki kimlikler • to: temaslı veri setinin “to” sütunundaki kimliklere • all: Her iki veri kümesinde de herhangi bir yerde görünen kimlikler • common: Hem temaslı veri setinde hem de satır listesinde görünen kimlikler\nÖrneğin, veri kümesindeki ilk on kimlik nedir?\n\ncontacts_ids &lt;- get_id(epic, \"contacts\")\nhead(contacts_ids, n = 10)\n\n [1] \"f547d6\" \"f90f5f\" \"11f8ea\" \"aec8ec\" \"893f25\" \"133ee7\" \"996f3a\" \"37a6f6\"\n [9] \"9f6884\" \"4802b1\"\n\n\nHem satır listesinde hem de temaslılarda kaç kimlik var?\n\nlength(get_id(epic, \"common\"))\n\n[1] 4352",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>İletim Zincirleri</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.tr.html#görselleştirme",
    "href": "new_pages/transmission_chains.tr.html#görselleştirme",
    "title": "37  İletim Zincirleri",
    "section": "37.4 Görselleştirme",
    "text": "37.4 Görselleştirme\n\nTemel grafik oluşturma\nEpicontacts nesnelerinin tüm görselleştirmeleri, plot fonksiyonu tarafından gerçekleşitirilr. İlk önce epicontacts nesnesini subset fonksiyonunu kullanarak yalnızca Haziran 2014 başlangıç tarihine sahip vakaları içerecek şekilde filtreleyeceğiz ve thin fonksiyonu kullanarak bu vakalarla bağlantılı kişileri dahil edeceğiz.\n\n## epicontacts nesnesi alt kümesi \nsub &lt;- epic %&gt;%\n  subset(\n    node_attribute = list(date_onset = c(as.Date(c(\"2014-06-30\", \"2014-06-01\"))))\n  ) %&gt;%\n thin(\"contacts\")\n\nDaha sonra basit bir etkileşimli grafiği aşağıdaki gibi kolay şekilde oluşturabiliriz:\n\n## epicontacts nesne grafiği\nplot(\n  sub,\n  width = 700,\n  height = 700\n)\n\n\n\n\n\nBu grafiği daha da değiştirmek için çok sayıda değişken bulunur. Esas olanları burada ele alacağız, ancak fonksiyonun tam bir açıklamasını elde etmek için ?vis_epicontacts (bir epicontacts nesnesi üzerinde çizim kullanılırken çağrılan fonksiyon) aracılığıyla belgelere bakın.\n####Nod özelliklerinin görselleştirilmesi {.unnumbered}\nNod rengi, şekli ve boyutu, node_color, node_shape ve node_size bağımsız değişkenleri kullanılarak satır listesindeki belirli bir sütuna eşlenebilir. Bu, ggplot2’den tanıyabileceğiniz aes sözdizimine benzer.\nNodların belirli renkleri, şekilleri ve boyutları aşağıdaki gibi belirlenebilir: • Col_pal değişkeni aracılığıyla, aşağıda yapıldığı gibi her rengin manuel olarak belirtilmesi için bir ad listesi yazarak ya da colorRampPalette(c(“siyah”, “kırmızı”, “turuncu”) gibi bir renk paleti fonksiyonu ile sağlayarak), belirtilenler arasında bir renk gradyanı oluşturulabilir. • Shapes (Şekiller) adlandırılmış bir liste ileterek, node_shape tarafından belirtilen satır listesi sütunundaki her benzersiz öğe için bir şekil belirtilebilir. Kullanılabilir şekiller için codeawesome’a bakın. • Size_range nodların boyut aralığını ileterek boyutlandırma. Rengin sonucu, cinsiyetin şekli ve yaşın ise boyutu temsil ettiği bir örnek:\n\nplot(\n  sub, \n  node_color = \"outcome\",\n  node_shape = \"gender\",\n  node_size = \"age\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  shapes = c(f = \"female\", m = \"male\"),\n  size_range = c(40, 60),\n  height = 700,\n  width = 700\n)\n\n\n\n\n\n\nKenar özelliklerinin görselleştirilmesi\nKenar rengi, genişliği ve çizgi tipi, edge_color, edge_width ve edge_linetype değişkenleri kullanılarak temasların veri çerçevesindeki belirli bir sütuna eşlenebilir. Kenarların belirli renkleri ve genişlikleri aşağıdaki gibi belirtilebilir:\n• Col_pal için kullanılanla aynı şekilde edge_col_pal aracılığıyla renkler. • Genişlik_aralığı argümanına nodların boyut aralığını ileterek genişlik belirlenir\nİşte bir örnek:\n\nplot(\n  sub, \n  node_color = \"outcome\",\n  node_shape = \"gender\",\n  node_size = 'age',\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  shapes = c(f = \"female\", m = \"male\"),\n  size_range = c(40, 60),\n  edge_color = 'location',\n  edge_linetype = 'location',\n  edge_width = 'duration',\n  edge_col_pal = c(Community = \"orange\", Nosocomial = \"purple\"),\n  width_range = c(1, 3),\n  height = 700,\n  width = 700\n)\n\n\n\n\n\n\n\n\nTemporal eksen\nx_axis değişkeni satır listesindeki bir sütuna eşleyerek ağı zamansal bir eksen boyunca görselleştirebiliriz. Aşağıdaki örnekte, x ekseni, semptom başlangıç tarihini temsil eder. Ayrıca okların çok büyük olmamasını sağlamak için arrow_size (ok boyutu) değişkenini belirledik ve şekli daha az karmaşık hale getirmek için label değişkenini = YANLIŞ olarak ayarladık.\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n\n\n\n\n\nBu ağın zamansal bir eksen boyunca nasıl görselleştirildiğini daha ayrıntılı olarak göstermek için çok sayıda ek argüman vardır; bunları ?vis_temporal_interactive (bir epicontacts nesnesi üzerinde çizimi x_axis üzerinden belirtilen şekilde göstermek çağrılan fonkisyon) aracılığıyla inceleyebilirsiniz. Aşağıda bazılarını gözden geçireceğiz.\n\nİletim ağacı şeklinin belirlenmesi\nNetwork_shape değişkeni kullanılarak belirtilen, iletim ağacının alabileceği iki ana şekil vardır. Birincisi, düz bir kenarın herhangi iki düğümü birleştirdiği, yukarıda gösterildiği gibi bir dallanma şeklidir. Bu en iyi anlaşılan temsildir, ancak yoğun bir şekilde bağlantılar içeren bir ağda üst üste binen kenarlara neden olabilir. İkinci şekil, bir filogenik ağaca benzeyen bir ağaç oluşturan dikdörtgendir. Örneğin:\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n\n\n\n\n\nHer durum nodunda, position_dodge değişkeni değiştirilerek benzersiz bir dikey konum atanabilir. Bağlantısız vakaların konumu (yani, bildirilen herhangi bir kişi olmadan), unlinked_pos değişkeni kullanılarak belirtilir.\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  position_dodge = TRUE,\n  unlinked_pos = \"bottom\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n\n\n\n\n\nÜst nodun alt nodlara göre konumu, ‘parent_pos’ değişkeni kullanılarak belirlenebilir. Varsayılan seçenek, üst nodu ortaya yerleştirmektir, ancak altta (parent_pos = ‘alt’) veya üstte (parent_pos = ‘üst’) yerleştirilebilir.\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  parent_pos = \"top\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n\n\n\n\n\n\n\nŞekil ve grafiklerin kaydedilmesi\nVisNetwork paketindeki ‘visSave’ fonksiyonuyla bir grafiği etkileşimli, bağımsız bir html dosyası olarak kaydedebilirsiniz:\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  parent_pos = \"top\",\n  arrow_size = 0.5,\n  node_size = 13,\n\"\"  label = FALSE,\n  height = 700,\n  width = 700\n) %&gt;%\n  visNetwork::visSave(\"network.html\")\n\nBu ağ çıktılarını bir görüntü olarak kaydetmek ne yazık ki zordur ve dosyayı bir html olarak kaydetmenizi ve ardından ‘webshot’ paketini kullanarak bu dosyanın ekran görüntüsünü almanızı gerektirir. Aşağıdaki kodda, yukarıda kaydedilen html dosyasını PNG’ye dönüştürüyoruz:\n\nwebshot(url = \"network.html\", file = \"network.png\")\n\n\n\n\nZaman Çizelgeleri\nAyrıca, her bir vakanın x ekseninde temsil edildiği zaman çizelgeleri de verebilirsiniz. Zaman çizergeleri, vaka konumlarını veya sonuca ulaşma zamanını görselleştirmek için kullanılabilir. Bir zaman çizelgesi oluşturmak için, vaka kimliğini, “olay”ın başlangıç tarihini ve “olay”ın bitiş tarihini gösteren en az üç sütundan oluşan bir veri çerçevesi oluşturmamız gerekiyor. Ayrıca, zaman çizelgesinin nod ve kenar özelliklerine eşlenebilecek başka bir sütun da ekleyebilirsiniz. Aşağıdaki kodda, semptom başlangıcından sonuç tarihine kadar bir zaman çizelgesi oluşturuyoruz ve nod şeklini ve rengini tanımlamak için kullandığımız sonuç ve hastane değişkenlerini veri tabanımızda tutuyoruz. Örneğin, bir vaka birden fazla hastane arasında sevk ediliyorsa, vaka başına birden fazla zaman çizelgesi satırına/olayına sahip olabileceğinizi unutmayın.\n\n## zaman çizelgesini oluştur\ntimeline &lt;- linelist %&gt;%\n  transmute(\n    id = case_id,\n    start = date_onset,\n    end = date_outcome,\n    outcome = outcome,\n    hospital = hospital\n  )\n\nDaha sonra zaman çizelgesi öğesini ‘timeline’ değişkenine iletiriz. Zaman çizelgesi özniteliklerini zaman çizelgesi nod renklerine, şekillerine ve boyutlarına önceki bölümlerde tanımlandığı şekilde eşleyebiliriz, ancak iki nodumuz vardır: Bir zaman çizelgesinin ayrı ayrı değişkenleri olan başlangıç ve bitiş nodları. Örneğin, ‘tl_start_node_color’, hangi zaman çizelgesi sütununun başlangıç nodunun rengiyle eşlendiğini tanımlarken ‘tl_end_node_shape’, hangi zaman çizelgesi sütununun bitiş nodunun şekliyle eşlendiğini tanımlar. Ayrıca ’tl_edge_*’ değişkenleri aracılığıyla renk, genişlik, çizgi tipi ve etiketleri zaman çizelgesi kenarına eşleyebiliriz.\nDeğişkenlerle ilgili ayrıntılı belgeler için ‘?vis_temporal_interactive’ e (bir epicontacts nesnesi çizilirken çağrılan fonksiyon) bakın. Her değişken aşağıdaki kodda da açıklanmıştır:\n\n## şekilleri tanımla\nshapes &lt;- c(\n  f = \"female\",\n  m = \"male\",\n  Death = \"user-times\",\n  Recover = \"heartbeat\",\n  \"NA\" = \"question-circle\"\n)\n\n## renkleri tanımla\ncolours &lt;- c(\n  Death = \"firebrick\",\n  Recover = \"green\",\n  \"NA\" = \"grey\"\n)\n\n## grafiği oluştur\nplot(\n  sub,\n  ## başlangıç tarihi için maksimum x koordinatı \n  x_axis = \"date_onset\",\n  ## dikdörtgen ağ şeklini kullan \n  network_shape = \"rectangle\",\n  ## nod şekillerini cinsiyet sütununa göre şekillendir \n  node_shape = \"gender\",\n  ## nod rengini herhangi bir sütun ile eşleştirmiyoruz çünkü varsayılan değeri id sütunudur bu da renk şemamızı bozar\n  node_color = NULL,\n  ## nod büyüklüğünü 30’a ayarla (nod büyüklüğü herhangi bir karakter değildir, herhangi bir sütuna eşleştirilmez, doğrudan nod büyüklüğü belirtilir\n  node_size = 30,\n  ## iletim bağlantısı kalınlığını 4’e ayarla (bu kalınlık bir karakter ile eşleşmemiştir) \n  edge_width = 4,\n  ## zaman çizelgesi nesnesi sağla \n  timeline = timeline,\n  ## bitiş nodunun şeklini zaman çizelgesi nesnesindeki sonuç sütununa eşle\n  tl_end_node_shape = \"outcome\",\n  ## son nodun boyutunu 15'e ayarla (bir karakter olmadığından, bu argüman bir sütuna eşlenmez, bunun yerine gerçek nod boyutu olarak yorumlanır)\n  tl_end_node_size = 15,\n  ## zaman çizelgesi kenarının rengini hastane sütununa eşle\n  tl_edge_color = \"hospital\",\n  ## zaman çizelgesi kenarının genişliğini 2'ye ayarla (bu bir karakter olmadığından, bu değişken bir sütuna eşlenmez, bunun yerine gerçek kenar genişliği olarak yorumlanır)\n  tl_edge_width = 2,\n  ## kenar etiketlerini hastane değişkenine eşleyin\n  tl_edge_label = \"hospital\",\n  ## nod şeklini belirt (yukarıda tanımlanmıştır)\n  shapes = shapes,\n  ## renk paletini belirt (yukarıda tanımlanmıştır)\n  col_pal = colours,\n  ## ok büyüklüğünü 0.5’e ayarla \n  arrow_size = 0.5,\n  ## lejantta iki sütun olsun \n  legend_ncol = 2,\n  ## font büyüklüğünü ayarla \n  font_size = 15,\n  ## tarih formatı ayarla \n  date_labels = c(\"%d %b %Y\"),\n  ## nodların altında ID etiketini grafik olarak gösterme\n  label = FALSE,\n  ## yüksekliği belirt \n  height = 1000,\n  ## genişliği belirt\n  width = 1200,\n  ## her vaka nodunun benzersiz bir y koordinatına sahip olduğundan emin olun - zaman çizelgelerini kullanırken bu çok önemlidir, aksi takdirde farklı vakalarda çakışan zaman çizelgeleriniz olur \n  position_dodge = TRUE\n)\n\nWarning in assert_timeline(timeline, x, x_axis): 5865 timeline row(s) removed\nas ID not found in linelist or start/end date is NA",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>İletim Zincirleri</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.tr.html#analiz",
    "href": "new_pages/transmission_chains.tr.html#analiz",
    "title": "37  İletim Zincirleri",
    "section": "37.5 Analiz",
    "text": "37.5 Analiz\n\nÖzetleme\n‘summary’ fonkisyonunu kullanarak bazı ağ özelliklerine genel bir bakış elde edebiliriz.\n\n## epicontacts nesnesini özetle \nsummary(epic)\n\n\n/// Overview //\n  // number of unique IDs in linelist: 5888\n  // number of unique IDs in contacts: 5511\n  // number of unique IDs in both: 4352\n  // number of contacts: 3800\n  // contacts with both cases in linelist: 56.868 %\n\n/// Degrees of the network //\n  // in-degree summary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.0000  0.0000  1.0000  0.5392  1.0000  1.0000 \n\n  // out-degree summary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.0000  0.0000  0.0000  0.5392  1.0000  6.0000 \n\n  // in and out degree summary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   1.000   1.000   1.078   1.000   7.000 \n\n/// Attributes //\n  // attributes in linelist:\n generation date_infection date_onset date_hospitalisation date_outcome outcome gender age age_unit age_years age_cat age_cat5 hospital lon lat infector source wt_kg ht_cm ct_blood fever chills cough aches vomit temp time_admission bmi days_onset_hosp\n\n  // attributes in contacts:\n location duration\n\n\nÖrneğin, temaslıların yalnızca %57’sinin satır listesinde her iki vakaya da sahip olduğunu görebiliriz. Bu iletim zincirlerine dahil olan önemli sayıda vaka hakkında linelist veriye sahip olmadığımız anlamına gelir.\n\n\nÇift Özellikleri\n‘get_pairwise()’ fonkisyonu, temaslı veri kümesindeki her bir çifte göre satır listesindeki değişken(ler)in işlenmesine izin verir. Aşağıdaki örnekte, her bir çift için hastalık başlangıç tarihi arasındaki farkı hesaplamak için, hastalık başlangıç tarihi satır listesinden çıkarılır. Bu karşılaştırmadan üretilen değer, seri aralığını (serial interval-si) temsil eder.\n\nsi &lt;- get_pairwise(epic, \"date_onset\")   \nsummary(si)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00    5.00    9.00   11.01   15.00   99.00    1820 \n\ntibble(si = si) %&gt;%\n  ggplot(aes(si)) +\n  geom_histogram() +\n  labs(\n    x = \"Serial interval\",\n    y = \"Frequency\"\n  )\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\nWarning: Removed 1820 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\n‘get_pairwise()’, karşılaştırma için kullanılan sütunun sınıfını yorumlayacak ve buna göre değerleri karşılaştırma yöntemini ayarlayacaktır. Sayılar ve tarihler için (yukarıdaki si örneğinde olduğu gibi) fonksiyon, değerleri çıkaracaktır. Karakter içeren veya kategorik sütunlara uygulandığında, get_pairwise() fonksiyonu değerleri birbirine yapıştırır. Fonksiyon aynı zamanda keyfi işlemeye de izin verdiğinden (bkz. “f” değişkeni), bu ayrık kombinasyonlar kolayca tablo haline getirilebilir ve analiz edilebilir.\n\nhead(get_pairwise(epic, \"gender\"), n = 10)\n\n [1] \"f -&gt; m\" NA       \"m -&gt; m\" NA       \"m -&gt; f\" \"f -&gt; f\" NA       \"f -&gt; m\"\n [9] NA       \"m -&gt; f\"\n\nget_pairwise(epic, \"gender\", f = table)\n\n           values.to\nvalues.from   f   m\n          f 464 516\n          m 510 468\n\nfisher.test(get_pairwise(epic, \"gender\", f = table))\n\n\n    Fisher's Exact Test for Count Data\n\ndata:  get_pairwise(epic, \"gender\", f = table)\np-value = 0.03758\nalternative hypothesis: true odds ratio is not equal to 1\n95 percent confidence interval:\n 0.6882761 0.9892811\nsample estimates:\nodds ratio \n 0.8252575 \n\n\nBurada, iletim bağlantıları ve cinsiyet arasında önemli bir ilişki görüyoruz.\n\n\nKümelerin tanımlanması\nget_clusters() fonksiyonu, bir epicontacts nesnesindeki bağlı bileşenleri tanımlamak için kullanılabilir. İlk olarak, küme bilgisini içeren bir veri çerçevesi elde etmek için kullanırız:\n\nclust &lt;- get_clusters(epic, output = \"data.frame\")\ntable(clust$cluster_size)\n\n\n   1    2    3    4    5    6    7    8    9   10   11   12   13   14 \n1536 1680 1182  784  545  342  308  208  171  100   99   24   26   42 \n\nggplot(clust, aes(cluster_size)) +\n  geom_bar() +\n  labs(\n    x = \"Cluster size\",\n    y = \"Frequency\"\n  )\n\n\n\n\n\n\n\n\nEn büyük kümelere bakalım. Bunun için epicontacts nesnesine küme bilgisi ekliyoruz ve ardından yalnızca en büyük kümeleri içerecek şekilde alt kümelerini oluşturuyoruz:\n\nepic &lt;- get_clusters(epic)\nmax_size &lt;- max(epic$linelist$cluster_size)\nplot(subset(epic, cs = max_size))\n\n\n\n\n\n\n\nDerecelerin hesaplanması\nBir nodun derecesi, kenar sayısına veya diğer nodlarla olan bağlantılarına karşılık gelir. ‘get_degree()’, epicontacts ağları için bu değeri hesaplamakta kolay bir yöntem sağlar. Bu bağlamda yüksek bir derece, başkalarıyla temas halinde olan bir kişiyi gösterir. ‘type’ değişkeni hem dereceyi hem de dereceyi saymak istediğimizi belirtir, ‘only_linelist’ değişkeni sadece satır listesindeki vakalar için dereceyi hesaplamak istediğimizi belirtir.\n\ndeg_both &lt;- get_degree(epic, type = \"both\", only_linelist = TRUE)\n\nHangi kişiler en fazla on temasa sahip?\n\nhead(sort(deg_both, decreasing = TRUE), 10)\n\n916d0a 858426 6833d7 f093ea 11f8ea 3a4372 38fc71 c8c4d5 a127a7 02d8fd \n     7      6      6      6      5      5      5      5      5      5 \n\n\nOrtalama temaslı sayısı nedir?\n\nmean(deg_both)\n\n[1] 1.078473",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>İletim Zincirleri</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.tr.html#kaynaklar",
    "href": "new_pages/transmission_chains.tr.html#kaynaklar",
    "title": "37  İletim Zincirleri",
    "section": "37.6 Kaynaklar",
    "text": "37.6 Kaynaklar\nepicontacts page Epicontacts sayfası, paket fonksiyonlarına genel bir bakış sağlar ve bazı daha ayrıntılı gösterimler içerir.\ngithub page Github sayfası, sorunları dile getirmek ve yeni özellikler talep etmek için kullanılabilir.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>İletim Zincirleri</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.tr.html",
    "href": "new_pages/phylogenetic_trees.tr.html",
    "title": "38  Filogenetik ağaçlar",
    "section": "",
    "text": "38.1 Genel Bakış\nFilogenetik ağaçlar, organizmaların genetik kodlarının sekansına göre akrabalıklarını ve evrimlerini görselleştirmek ve tanımlamak için kullanılır. Uzaklığa dayalı yöntemler (komşu birleştirme yöntemi gibi) veya karakter tabanlı yöntemler (maksimum olabilirlik ve Bayesian Markov Zinciri Monte Carlo yöntemi gibi) kullanılarak genetik sekanslardan oluşturulabilirler. Yeni nesil sekanslama (NGS) daha uygun fiyatlı hale gelerek bulaşıcı hastalıklara neden olan patojenleri tanımlamak için halk sağlığında daha yaygın olarak kullanılmaya başlandı. Taşınabilir sekanslama cihazları, bekleme süresini azaltır ve verileri gerçek zamanlı olarak salgın araştırmasını desteklemek için kullanılabilir hale getirir. NGS verileri, bir salgın suşunun kökenini, kaynağını ve yayılımını belirlemek ve ayrıca antimikrobiyal direnç genlerinin varlığını göstermek için kullanılabilir. Örnekler arasındaki genetik ilişkiyi görselleştirmek için bir filogenetik ağaç oluşturulur. Bu sayfada, filogenetik ağaçların bir veri çerçevesiyle birleştirilmiş halde görselleştirilmesine izin veren ggtree paketinin nasıl kullanılacağını öğreneceğiz. Bu, motifleri gözlemlememizi ve salgın dinamiğinin anlaşılmasını geliştirmemizi sağlayacaktır.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Filogenetik ağaçlar</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.tr.html#hazırlık",
    "href": "new_pages/phylogenetic_trees.tr.html#hazırlık",
    "title": "38  Filogenetik ağaçlar",
    "section": "38.2 Hazırlık",
    "text": "38.2 Hazırlık\n\nPaketlerin yüklenmesi\nBu kod parçası, gerekli paketlerin yüklenmesini göstermektedir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’ın p_load() fonksiyonunu vurguluyoruz. Ayrıca, temel R’dan library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R’ın temelleri sayfasına bakın.\n\npacman::p_load(\n  rio,             # içe/dışa aktarım \n  here,            # ilişkili dosya yolları\n  tidyverse,       # genel veri yönetimi ve görselleştirme\n  ape,             # filogenetik dosyaları içe ve dışa aktarmak için\n  ggtree,          # filogenetik dosyaları görselleştirmek için\n  treeio,          # filogenetik dosyaları görselleştirmek için\n  ggnewscale)      # ek renk şema katmanları eklemek için\n\n\n\nVerilerin içe aktarımı\nBu sayfadaki veriler, El kitabı ve verilerin indirilmesi sayfasındaki talimatlarla indirilebilir.\nBir filogenetik ağacın saklanabileceği birkaç farklı format vardır (örn. Newick, NEXUS, Phylip). Yaygın olanlardan biri, ağaçların bilgisayar tarafından okunabilir biçimde gösterimi için standart olan Newic dosya biçimidir (.nwk).\nBu, tüm ağacın “((t2:0.04,t1:0.34):0.89,(t5:0.37,(t4:0.03,t3:0.67):0.9):0.59);” gibi bir dize biçiminde ifade edilebileceği anlamına gelir. Bu dize tüm nodları ve uçları ve bunların birbirleriyle olan ilişkilerini (dal uzunluğu) listeler.\nNot: Filogenetik ağaç dosyasının kendi içinde sekans verileri içermediğini, yalnızca sekanslar arasındaki genetik mesafelerin bir sonucu olduğunu anlamak önemlidir. Bu nedenle, bir ağaç dosyasından sekanslama verilerini çıkaramıyoruz.\nİlk olarak, bir Newick filogenetik ağaç dosyasını .txt formatında içe aktarmak için ape paketinden read.tree() fonksiyonunu kullanırız ve “phylo” sınıfı bir liste nesnesinde saklarız. Gerekirse, ilgili dosya yolunu belirtmek için here paketindeki here() fonksiyonunu kullanın.\nNot: Bu durumda newick ağacı, Github’dan daha kolay kullanım ve indirme için bir .txt dosyası olarak kaydedilir.\n\ntree &lt;- ape::read.tree(\"Shigella_tree.txt\")\n\nAğaç nesnemizi inceliyoruz ve 299 uç (veya örnek) ve 236 nod içerdiğini görüyoruz.\n\ntree\n\n\nPhylogenetic tree with 299 tips and 236 internal nodes.\n\nTip labels:\n  SRR5006072, SRR4192106, S18BD07865, S18BD00489, S17BD08906, S17BD05939, ...\nNode labels:\n  17, 29, 100, 67, 100, 100, ...\n\nRooted; includes branch lengths.\n\n\nİkinci olarak, rio paketindeki import() fonksiyonunu kullanarak cinsiyet, menşe ülke ve antimikrobiyal direnç özellikleri gibi her numune için ek bilgiler içeren bir .csv dosyası olarak saklanan tabloyu içe aktarırız:\n\nsample_data &lt;- import(\"sample_data_Shigella_tree.csv\")\n\nAşağıda verilerin ilk 50 satırı verilmiştir:\n\n\n\n\n\n\n\n\nTemizleme ve inceleme\nVerilerimizi temizler ve inceleriz: Filogenetik ağaca doğru örnek verilerini atamak için, sample_data veri çerçevesindeki Sample_ID sütunundaki değerlerin ağaç dosyasındaki tip.labels değerleriyle eşleşmesi gerekir:\nAğaç dosyasındaki tip.labels formatını, R tabanından head() ile ilk 6 girişe bakarak kontrol ederiz.\n\nhead(tree$tip.label) \n\n[1] \"SRR5006072\" \"SRR4192106\" \"S18BD07865\" \"S18BD00489\" \"S17BD08906\"\n[6] \"S17BD05939\"\n\n\nAyrıca sample_data veri çerçevemizdeki ilk sütunun Sample_ID olduğundan emin oluruz. Temel R’dan colnames() kullanarak veri çerçevemizin sütun adlarına bakarız.\n\ncolnames(sample_data)   \n\n [1] \"Sample_ID\"                  \"serotype\"                  \n [3] \"Country\"                    \"Continent\"                 \n [5] \"Travel_history\"             \"Year\"                      \n [7] \"Belgium\"                    \"Source\"                    \n [9] \"Gender\"                     \"gyrA_mutations\"            \n[11] \"macrolide_resistance_genes\" \"MIC_AZM\"                   \n[13] \"MIC_CIP\"                   \n\n\nBiçimlendirmenin tip.label’dekiyle aynı olduğundan emin olmak için veri çerçevesindeki Sample_ID’lere bakarız (örneğin, harflerin tümü büyük harf olması, harfler ve sayılar arasında fazladan alt çizgi olmaması, vb.)\n\nhead(sample_data$Sample_ID) # we again inspect only the first 6 using head()\n\n[1] \"S17BD05944\" \"S15BD07413\" \"S18BD07247\" \"S19BD07384\" \"S18BD07338\"\n[6] \"S18BD02657\"\n\n\nAyrıca tüm örneklerin ağaç dosyasında bulunup bulunmadığını, eşleşip eşleşmedikleri bir DOĞRU veya YANLIŞ mantıksal vektörü oluşturarak karşılaştırabiliriz. (Basitleştirmek için burada gösterilmemiştir).\n\nsample_data$Sample_ID %in% tree$tip.label\n\ntree$tip.label %in% sample_data$Sample_ID\n\nBu vektörleri ağaçta olmayan herhangi bir örnek kimliğini göstermek için kullanabiliriz (hiçbiri yoktur).\n\nsample_data$Sample_ID[!tree$tip.label %in% sample_data$Sample_ID]\n\ncharacter(0)\n\n\nİnceleme sonucu, veri çerçevesindeki Sample_ID formatının tip.labels’deki örnek isimlerine karşılık geldiğini görebiliriz. Bunların eşleşmesi için aynı sırada sıralanması gerekmez.\nDevam etmeye hazırız!",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Filogenetik ağaçlar</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.tr.html#temel-ağaç-görselleştirmesi",
    "href": "new_pages/phylogenetic_trees.tr.html#temel-ağaç-görselleştirmesi",
    "title": "38  Filogenetik ağaçlar",
    "section": "38.3 Temel ağaç görselleştirmesi",
    "text": "38.3 Temel ağaç görselleştirmesi\n\nFarklı ağaç düzenlemeleri\nggtree birçok farklı düzen formatı sunar ve bazıları özel amacınız için diğerlerinden daha uygun olabilir. Aşağıda birkaç gösterim var. Diğer seçenekler için bu çevrimiçi kitaba bakabilirsiniz.\nİşte bazı örnek ağaç düzenleri:\n\nggtree(tree)                                            # basit doğrusal ağaç\nggtree(tree, branch.length = \"none\")                    # uçların hizalandığı basit doğrusal ağaç \nggtree(tree, layout=\"circular\")                         # basit dairesel ağaç\nggtree(tree, layout=\"circular\", branch.length = \"none\") # uçların hizalandığı basit dairesel ağaç \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nÖrnek veriyi içeren basit ağaç\n%&lt;+% operatörü, sample_data veri çerçevesini ağaç dosyasına bağlamak için kullanılır. Ağacınızın en basit gösterimi, uçlara örnek isimlerin eklenmesi, ayrıca uç noktalarının ve istenirse dalların renklendirilmesidir:\nİşte dairesel bir ağaç örneği:\n\nggtree(tree, layout = \"circular\", branch.length = 'none') %&lt;+% sample_data + #%&lt;+%, ağaca örnek verilerle veri çerçevesi ekler\n  aes(color = Belgium)+                       # dalları veri çerçevenizdeki bir değişkene göre renklendirin\n  scale_color_manual(\n    name = \"Sample Origin\",                      # renk düzeninizin adı (lejantta bu şekilde görünecektir)\n    breaks = c(\"Yes\", \"No\"),                     # değişkeninizdeki farklı seçenekler\n    labels = c(\"NRCSS Belgium\", \"Other\"),        # lejandınızda adı geçen farklı seçenekleri biçimlendirmenize olanak sağlar\n    values = c(\"blue\", \"black\"),                  # değişkene atamak istediğiniz renk\n    na.value = \"black\") +                        # renkli NA değerleri siyahtır\n  new_scale_color()+                             # başka bir değişken için ek bir renk şeması eklemeye izin verir\n  geom_tippoint(\n      mapping = aes(color = Continent),          # kıtaya göre uç rengi. \"shape =\" ekleyerek şekli değiştirebilirsiniz.\n      size = 1.5)+                               # uçtaki noktanın boyutunu tanımlayın\n  scale_color_brewer(\n    name = \"Continent\",                    # renk şemanızın adı (lejantta bu şekilde görünecektir)\n    palette = \"Set1\",                      # brewer paketiyle birlikte gelen bir dizi renk seçiyoruz\n    na.value = \"grey\") +                    # NA değerleri için gri rengi seçiyoruz\n  geom_tiplab2(                             # dalının ucuna numunenin adını ekler\n    color = 'black',                       # (+ ile istediğiniz kadar metin satırı ekleyin, ancak bunları yan yana yerleştirmek için ofset değerini ayarlamanız gerekebilir)\n    offset = 1,\n    size = 1,\n    geom = \"text\",\n    #align = TRUE\n    )+    \n  ggtitle(\"Phylogenetic tree of Shigella sonnei\")+       # grafiğinizin başlığı\n  theme(\n    axis.title.x = element_blank(), # x ekseni başlığını kaldırır\n    axis.title.y = element_blank(), # y ekseni başlığını kaldırır\n    legend.title = element_text(    # açıklama başlığının yazı tipi boyutunu ve biçimini tanımlar\n      face = \"bold\",\n      size = 12),   \n    legend.text=element_text(       # gösterge metninin yazı tipi boyutunu ve biçimini tanımlar\n      face = \"bold\",\n      size = 10),  \n    plot.title = element_text(      # grafik başlığının yazı tipi boyutunu ve biçimini tanımlar\n      size = 12,\n      face = \"bold\"),  \n    legend.position = \"bottom\",     # lejant yerleşimini tanımlar\n    legend.box = \"vertical\",        # lejant yerleşimini tanımlar\n    legend.margin = margin())   \n\n\n\n\n\n\n\n\nDiğer herhangi bir ggplot nesnesinde yaptığınız gibi, ağaç grafiğinizi ggsave() ile dışa aktarabilirsiniz. Bu şekilde yazıldığında, ggsave(), üretilen son grafiği belirttiğiniz dosya yoluna kaydeder. Alt klasörlere vb. kolayca kaydetmek için here() ve ilgili dosya yollarını kullanabileceğinizi unutmayın.\n\nggsave(\"example_tree_circular_1.png\", width = 12, height = 14)",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Filogenetik ağaçlar</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.tr.html#ağacın-manipülasyonu",
    "href": "new_pages/phylogenetic_trees.tr.html#ağacın-manipülasyonu",
    "title": "38  Filogenetik ağaçlar",
    "section": "38.4 Ağacın Manipülasyonu",
    "text": "38.4 Ağacın Manipülasyonu\nBazen çok büyük bir filogenetik ağacınız olabilir ve ağacın sadece bir kısmıyla ilgilenirsiniz. Örneğin, veri kümenizin büyük resimde nereye sığabileceğine dair geniş bir genel bakış elde etmek için tarihsel veya uluslararası örnekler içeren bir ağaç oluşturup daha sonra verilerinize daha yakından bakmak için daha büyük olan ağacın yalnızca o ilgilendiğiniz kısmını incelemek istersiniz.\nFilogenetik ağaç dosyası yalnızca sekanslama veri analizinin çıktısı olduğundan, dosyanın kendisindeki nodların ve dalların sırasını değiştiremeyiz. Bunlar, ham NGS verilerinden önceki analizlerde zaten belirlenmiştir. Yine de parçaları yakınlaştırabiliyor, parçaları gizleyebiliyor ve hatta ağacın parçalarını alt kümelere ayırabiliyoruz.\n\nYakınlaştırmak\nAğacınızı “kesmek” istemiyorsanız ve sadece bir kısmını daha yakından incelemek istiyorsanız, belirli bir kısmı görüntülemek için yakınlaştırabilirsiniz.\nİlk olarak, tüm ağacı doğrusal biçimde çiziyoruz ve ağaçtaki her bir noda sayısal etiketler ekliyoruz.\n\np &lt;- ggtree(tree,) %&lt;+% sample_data +\n  geom_tiplab(size = 1.5) +                # ağaç dosyasındaki örnek adıyla tüm dalların uçlarını etiketler\n  geom_text2(\n    mapping = aes(subset = !isTip,\n                  label = node),\n    size = 5,\n    color = \"darkred\",\n    hjust = 1,\n    vjust = 1)                            # ağaçtaki tüm nodları etiketler\n\np  # çıktı alın\n\n\n\n\n\n\n\n\nBelirli bir dalı yakınlaştırmak için (sağa doğru uzanarak), ggtree p nesnesinde viewClade() fonkisyonunu kullanın ve daha yakından bakmak için nod numarasını sağlayın:\n\nviewClade(p, node = 452)\n\n\n\n\n\n\n\n\n\n\nDaralan dallar\nAncak, bu dalı yok saymak isteyebiliriz ve aynı noddaki (nod nr. 452) collapse() fonksiyonunu kullanarak dalı daraltabiliriz. Bu ağaç p_collapsed olarak tanımlanır.\n\np_collapsed &lt;- collapse(p, node = 452)\np_collapsed\n\n\n\n\n\n\n\n\nAnlaşılır olması için, p_collapsed’ı yazdırdığımızda, daraltılmış dalın noduna geom_point2() ile mavi elmas şekli ekleriz.\n\np_collapsed + \ngeom_point2(aes(subset = (node == 452)),  # we assign a symbol to the collapsed node\n            size = 5,                     # define the size of the symbol\n            shape = 23,                   # define the shape of the symbol\n            fill = \"steelblue\")           # define the color of the symbol\n\n\n\n\n\n\n\n\n\n\nAğacın alt kümelere ayrılması\nDaha kalıcı bir değişiklik yapmak ya da çalışma için yeni ve küçültülmüş bir ağaç oluşturmak istiyorsak, ağacın bir kısmının tree_subset() ile alt kümesini alabiliriz. Ardından bu alt kümeyi yeni bir newick ağaç dosyası veya .txt dosyası olarak kaydedebilirsiniz.\nİlk olarak, neyin altküme olacağına karar vermek için ağaç nodlarını ve uç etiketlerini inceleriz.\n\nggtree(\n  tree,\n  branch.length = 'none',\n  layout = 'circular') %&lt;+% sample_data +               # %&lt;+% operatörünü kullanarak örnek verileri ekliyoruz\n  geom_tiplab(size = 1)+                                # ağaç dosyasında örnek adıyla tüm dalların uçlarını etiketliyoruz \n  geom_text2(\n    mapping = aes(subset = !isTip, label = node),\n    size = 3,\n    color = \"darkred\") +                                # ağaçtaki tüm nodları etiketler\n theme(\n   legend.position = \"none\",                            # lejantı uzaklaştırır\n   axis.title.x = element_blank(),\n   axis.title.y = element_blank(),\n   plot.title = element_text(size = 12, face=\"bold\"))\n\n\n\n\n\n\n\n\nŞimdi, ağacın 528 numaralı nodundan alt küme oluşturmaya karar verdiğimizi varsayalım (sadece bu dalda 528 nodundan sonraki uçlarını tutalım) ve onu yeni bir sub_tree1 nesnesi olarak kaydedelim:\n\nsub_tree1 &lt;- tree_subset(\n  tree,\n  node = 528)                                            # ağacın 528 nodundan alt kümesini oluşturuyoruz\n\n1 numaralı alt küme ağacına bir göz atalım:\n\nggtree(sub_tree1) +\n  geom_tiplab(size = 3) +\n  ggtitle(\"Subset tree 1\")\n\n\n\n\n\n\n\n\nAyrıca, “geriye” kaç tane nod eklemek istediğinizi belirterek belirli bir örneğe dayalı olarak alt kümeler oluşturabilirsiniz. Ağacın aynı kısmını bir örneğe dayanarak alt kümelendirelim, bu durumda S17BD07692 için 9 nod geriye giderek ve onu yeni bir sub_tree2 nesnesi olarak kaydedelim:\n\nsub_tree2 &lt;- tree_subset(\n  tree,\n  \"S17BD07692\",\n  levels_back = 9) # geri seviye sayısı, örnek ucundan geriye kaç nod gideceğinizi tanımlar.\n\nŞimdi alt küme ağacına bir göz atalım:\n\nggtree(sub_tree2) +\n  geom_tiplab(size =3)  +\n  ggtitle(\"Subset tree 2\")\n\n\n\n\n\n\n\n\nYeni ağacınızı, ape paketindeki write.tree() fonksiyonunu kullanarak bir Newick formatında veya hatta bir metin dosyası olarak da kaydedebilirsiniz\n\n# .nwk formatında kaydetmek için\nape::write.tree(sub_tree2, file='data/phylo/Shigella_subtree_2.nwk')\n\n# .txt formatında kaydetmek için\nape::write.tree(sub_tree2, file='data/phylo/Shigella_subtree_2.txt')\n\n\n\nAğaçtaki nodları döndürmek\nDaha önce de belirtildiği gibi, ağaçtaki uçların veya nodların sırasını değiştiremeyiz, çünkü bu onların genetik akrabalıklarına dayanır ve görsel manipülasyona izin yoktur. Ancak, görselleştirmemizi kolaylaştıracaksa, dalları nodların etrafında döndürebiliriz.\nİlk olarak, işlemek istediğimiz nodu seçmek için yeni alt küme ağacımızı (alt küme 2) nod etiketleriyle çizeriz ve bir ggtree çizim nesnesi ‘p’ olarak saklarız.\n\np &lt;- ggtree(sub_tree2) +  \n  geom_tiplab(size = 4) +\n  geom_text2(aes(subset=!isTip, label=node), # ağaçtaki tüm nodları etiketler\n             size = 5,\n             color = \"darkred\", \n             hjust = 1, \n             vjust = 1) \np\n\n\n\n\n\n\n\n\nArdından, ggtree::rotate() veya ggtree::flip() fonksiyonlarını uygulayarak nodları değiştirebiliriz: Not: Hangi nodları manuple ettiğimizi göstermek için, ilgilendiğimiz noddaki örnekleri vurgulamak için önce ggtree’den geom_hilight() fonksiyonunu uygularız. ggtree çizim nesnesini yeni bir nesne olarak (p1) saklayın.\n\np1 &lt;- p + geom_hilight(  # nod 39'u mavi olarak vurgular, \"extend =\" renk bloğunun uzunluğunu tanımlamamızı sağlar\n  node = 39,\n  fill = \"steelblue\",\n  extend = 0.0017) +  \ngeom_hilight(            # 37 numaralı düğümü sarı renkle vurgular\n  node = 37,\n  fill = \"yellow\",\n  extend = 0.0017) +               \nggtitle(\"Original tree\")\n\n\np1 # çıktı alın\n\n\n\n\n\n\n\n\nŞimdi p1 nesnesindeki nod 37’yi döndürebiliriz, böylece nod 38’deki örnekler en üste hareket eder. Döndürülen ağacı yeni bir p2 nesnesi olarak saklıyoruz.\n\np2 &lt;- ggtree::rotate(p1, 37) + \n      ggtitle(\"Rotated Node 37\")\n\n\np2   # çıktı alın\n\n\n\n\n\n\n\n\nYa da p1 nesnesindeki 36 nolu nodu döndürmek ve 37 nolu nodu yukarı ve 39 nolu nodu aşağıya çevirmek için flip (çevirme= komutunu kullanabiliriz. Ters çevrilmiş ağacı yeni bir p3 nesnesi olarak saklıyoruz.\n\np3 &lt;-  flip(p1, 39, 37) +\n      ggtitle(\"Rotated Node 36\")\n\n\np3   # çıktı alın\n\n\n\n\n\n\n\n\n\n\nNumune verilerini içeren açıklamalı örnek alt ağaç\n2017 ve 2018’de alt ağacımızda 39. nodda meydana gelen klonal genişlemeli vaka kümesini araştırdığımızı varsayalım. Yakın ilişkili diğer suşların kökenini görmek için suş izolasyonunun yanı sıra ülkeye göre seyahat geçmişi ve rengi de ekliyoruz:\n\nggtree(sub_tree2) %&lt;+% sample_data +     # sample_data'ya bağlanmak için %&lt;+% operatörünü kullanırız\n  geom_tiplab(                          # ağaç dosyasındaki numune adıyla tüm dalların uçlarını etiketler\n    size = 2.5,\n    offset = 0.001,\n    #align = TRUE\n    ) + \n  theme_tree2()+\n  xlim(0, 0.015)+                       # ağacımızın x ekseni sınırlarını ayarlar\n  geom_tippoint(aes(color=Country),     # uç noktasını kıtaya göre renklendir\n                size = 1.5)+ \n  scale_color_brewer(\n    name = \"Country\", \n    palette = \"Set1\", \n    na.value = \"grey\")+\n  geom_tiplab(                          # uçlara bir metin etiketi olarak izolasyon yılı ekleyin\n    aes(label = Year),\n    color = 'blue',\n    offset = 0.0045,\n    size = 3,\n    linetype = \"blank\" ,\n    geom = \"text\",\n    #align = TRUE\n    )+ \n  geom_tiplab(                          # uçlara kırmızı renkte bir metin etiketi olarak seyahat geçmişi ekleyin\n    aes(label = Travel_history),\n    color = 'red',\n    offset = 0.006,\n    size = 3,\n    linetype = \"blank\",\n    geom = \"text\",\n    #align = TRUE\n    )+ \n  ggtitle(\"Phylogenetic tree of Belgian S. sonnei strains with travel history\")+  # grafik başlığı ekle\n  xlab(\"genetic distance (0.001 = 4 nucleotides difference)\")+                    # x eksenine bir etiket ekleyin\n  theme(\n    axis.title.x = element_text(size = 10),\n    axis.title.y = element_blank(),\n    legend.title = element_text(face = \"bold\", size = 12),\n    legend.text = element_text(face = \"bold\", size = 10),\n    plot.title = element_text(size = 12, face = \"bold\"))\n\n\n\n\n\n\n\n\nGözlemimiz, yıllar içinde Belçika’da dolaşan ve en son salgınımıza neden olan Asya’dan kaynaklanan suşa işaret ediyor.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Filogenetik ağaçlar</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.tr.html#daha-karmaşık-ağaçlar-örnek-verilerin-ısı-haritalarını-ekleme",
    "href": "new_pages/phylogenetic_trees.tr.html#daha-karmaşık-ağaçlar-örnek-verilerin-ısı-haritalarını-ekleme",
    "title": "38  Filogenetik ağaçlar",
    "section": "Daha karmaşık ağaçlar: Örnek verilerin ısı haritalarını ekleme",
    "text": "Daha karmaşık ağaçlar: Örnek verilerin ısı haritalarını ekleme\nggtree::gheatmap() fonksiyonunu kullanarak bir ısı haritası biçiminde antimikrobiyal direnç genlerinin kategorik olarak varlığı ve antimikrobiyallere karşı ölçülen direnç için sayısal değerler gibi daha karmaşık bilgiler de ekleyebiliriz.\nİlk önce ağacımızı çizmemiz gerekiyor (bu doğrusal veya dairesel olabilir) ve ağacı yeni bir ggtree çizim nesnesi p’de saklamamız gerekiyor: Bölüm 3’teki sub_tree’yi kullanacağız.)\n\np &lt;- ggtree(sub_tree2, branch.length='none', layout='circular') %&lt;+% sample_data +\n geom_tiplab(size =3) + \n theme(\n   legend.position = \"none\",\n    axis.title.x = element_blank(),\n    axis.title.y = element_blank(),\n    plot.title = element_text(\n      size = 12,\n      face = \"bold\",\n      hjust = 0.5,\n      vjust = -15))\np\n\n\n\n\n\n\n\n\nİkinci olarak verilerimizi hazırlıyoruz. Farklı değişkenleri yeni renk şemaları ile görselleştirmek için veri çerçevemizi istenen değişkene göre alt gruplara ayırıyoruz. Sample_ID’yi satır adları olarak eklemek önemlidir, aksi takdirde verileri ağaç tip.labels ile eşleştiremez:\nÖrneğimizde Shigella enfeksiyonlarını tedavi etmek için kullanılan önemli bir birinci basamak antibiyotik olan siprofloksasine direnç kazandırabilecek mutasyonlara ve cinsiyete bakmak istiyoruz.\nCinsiyet için bir veri çerçevesi oluşturuyoruz:\n\ngender &lt;- data.frame(\"gender\" = sample_data[,c(\"Gender\")])\nrownames(gender) &lt;- sample_data$Sample_ID\n\nSiprofloksasin direncine nede olan gyrA genindeki mutasyonlar için bir veri çerçevesi oluşturuyoruz:\n\ncipR &lt;- data.frame(\"cipR\" = sample_data[,c(\"gyrA_mutations\")])\nrownames(cipR) &lt;- sample_data$Sample_ID\n\nSiprofloksasin için ölçülen minimum inhibitör konsantrasyonu (MIC) için bir veri çerçevesi oluşturuyoruz:\n\nMIC_Cip &lt;- data.frame(\"mic_cip\" = sample_data[,c(\"MIC_CIP\")])\nrownames(MIC_Cip) &lt;- sample_data$Sample_ID\n\nFilogenetik ağaca cinsiyet için ikili bir ısı haritası ekleyen ve onu yeni bir ggtree grafi nesnesi h1’de saklayan bir ilk grafik oluşturuyoruz:\n\nh1 &lt;-  gheatmap(p, gender,                                 # ağaç grafiğimize cinsiyet veri çerçevesinin ısı haritası katmanını ekliyoruz\n                offset = 10,                               # ofset, ısı haritasını sağa kaydırır,\n                width = 0.10,                              # genişlik, ısı haritası sütununun genişliğini tanımlar,\n                color = NULL,                              # renk, ısı haritası sütunlarının kenarlığını tanımlar\n         colnames = FALSE) +                               # ısı haritası için sütun adlarını gizler\n  scale_fill_manual(name = \"Gender\",                       # cinsiyet için renklendirme şemasını ve lejandı tanımlayın\n                    values = c(\"#00d1b1\", \"purple\"),\n                    breaks = c(\"Male\", \"Female\"),\n                    labels = c(\"Male\", \"Female\")) +\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\nh1\n\n\n\n\n\n\n\n\nArdından, gyrA genindeki siprofloksasine direnç sağlayan mutasyonlar hakkında bilgi ekliyoruz:\nNot: WGS verilerinde kromozomal nokta mutasyonlarının varlığı, Zankari ve arkadaşları tarafından geliştirilen PointFinder aracı kullanılarak önceden belirlenmiştir. (referanslar bölümündeki referansa bakın)\nİlk olarak, mevcut çizim nesnemiz h1’e yeni bir renk şeması atarız ve onu nesne h2’de saklarız. Bu, ısı haritasındaki ikinci değişkenimizin renklerini tanımlamamızı ve değiştirmemizi sağlar.\n\nh2 &lt;- h1 + new_scale_fill() \n\nArdından ikinci ısı haritası katmanını h2’ye ekler ve birleştirilmiş grafikleri yeni bir nesne h3’te saklarız:\n\nh3 &lt;- gheatmap(h2, cipR,         # Siprofloksasine direnç mutasyonlarını tanımlayan ikinci ısı haritası satırını ekler\n               offset = 12, \n               width = 0.10, \n               colnames = FALSE) +\n  scale_fill_manual(name = \"Ciprofloxacin resistance \\n conferring mutation\",\n                    values = c(\"#fe9698\",\"#ea0c92\"),\n                    breaks = c( \"gyrA D87Y\", \"gyrA S83L\"),\n                    labels = c( \"gyrA d87y\", \"gyrA s83l\")) +\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())+\n  guides(fill = guide_legend(nrow = 2,byrow = TRUE))\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\nh3\n\n\n\n\n\n\n\n\nİlk önce mevcut nesne h3’e yeni bir renk ölçeği katmanı ekleyerek ve ardından nihai nesne h5’i üretmek için elde edilen h4 nesnesine her suş için siprofloksasin için minimum inhibitör konsantrasyonu (MIC) verilerini ekleyerek yukarıdaki işlemi tekrarlıyoruz. :\n\n# İlk önce yeni renklendirme şemasını ekliyoruz:\nh4 &lt;- h3 + new_scale_fill()\n\n# sonra ikisini yeni bir grafikte birleştiriyoruz:\nh5 &lt;- gheatmap(h4, MIC_Cip,  \n               offset = 14, \n               width = 0.10,\n                colnames = FALSE)+\n  scale_fill_continuous(name = \"MIC for Ciprofloxacin\",  # burada MIC'in sürekli değişkeni için bir gradyan renk şeması tanımlıyoruz\n                      low = \"yellow\", high = \"red\",\n                      breaks = c(0, 0.50, 1.00),\n                      na.value = \"white\") +\n   guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\nh5\n\n\n\n\n\n\n\n\nAynı alıştırmayı doğrusal bir ağaç için de yapabiliriz:\n\np &lt;- ggtree(sub_tree2) %&lt;+% sample_data +\n  geom_tiplab(size = 3) + # labels the tips\n  theme_tree2()+\n  xlab(\"genetic distance (0.001 = 4 nucleotides difference)\")+\n  xlim(0, 0.015)+\n theme(legend.position = \"none\",\n      axis.title.y = element_blank(),\n      plot.title = element_text(size = 12, \n                                face = \"bold\",\n                                hjust = 0.5,\n                                vjust = -15))\np\n\n\n\n\n\n\n\n\nÖncelikle cinsiyeti giriyoruz\n\nh1 &lt;-  gheatmap(p, gender, \n                offset = 0.003,\n                width = 0.1, \n                color=\"black\", \n         colnames = FALSE)+\n  scale_fill_manual(name = \"Gender\",\n                    values = c(\"#00d1b1\", \"purple\"),\n                    breaks = c(\"Male\", \"Female\"),\n                    labels = c(\"Male\", \"Female\"))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\nh1\n\n\n\n\n\n\n\n\nArdından, başka bir renk şeması katmanı ekledikten sonra siprofloksasine direnç mutasyonlarını ekliyoruz:\n\nh2 &lt;- h1 + new_scale_fill()\nh3 &lt;- gheatmap(h2, cipR,   \n               offset = 0.004, \n               width = 0.1,\n               color = \"black\",\n                colnames = FALSE)+\n  scale_fill_manual(name = \"Ciprofloxacin resistance \\n conferring mutation\",\n                    values = c(\"#fe9698\",\"#ea0c92\"),\n                    breaks = c( \"gyrA D87Y\", \"gyrA S83L\"),\n                    labels = c( \"gyrA d87y\", \"gyrA s83l\"))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())+\n  guides(fill = guide_legend(nrow = 2,byrow = TRUE))\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\n h3\n\n\n\n\n\n\n\n\nArdından laboratuvar tarafından belirlenen minimum engelleyici konsantrasyonu (MIC) ekliyoruz:\n\nh4 &lt;- h3 + new_scale_fill()\nh5 &lt;- gheatmap(h4, MIC_Cip, \n               offset = 0.005,  \n               width = 0.1,\n               color = \"black\", \n                colnames = FALSE)+\n  scale_fill_continuous(name = \"MIC for Ciprofloxacin\",\n                      low = \"yellow\", high = \"red\",\n                      breaks = c(0,0.50,1.00),\n                      na.value = \"white\")+\n   guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 10),\n        legend.text = element_text(size = 8),\n        legend.box = \"horizontal\", legend.margin = margin())+\n  guides(shape = guide_legend(override.aes = list(size = 2)))\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\nh5",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Filogenetik ağaçlar</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.tr.html#kaynaklar",
    "href": "new_pages/phylogenetic_trees.tr.html#kaynaklar",
    "title": "38  Filogenetik ağaçlar",
    "section": "38.5 Kaynaklar",
    "text": "38.5 Kaynaklar\nhttp://hydrodictyon.eeb.uconn.edu/eebedia/index.php/Ggtree# Clade_Colors https://bioconductor.riken.jp/packages/3.2/bioc/vignettes/ggtree/inst/doc/treeManipulation.html https://guangchuangyu.github.io/ggtree-book/chapter-ggtree.html https://bioconductor.riken.jp/packages/3.8/bioc/vignettes/ggtree/inst/doc/treeManipulation.html\nEa Zankari, Rosa Allesøe, Katrine G Joensen, Lina M Cavaco, Ole Lund, Frank M Aarestrup, PointFinder: a novel web tool for WGS-based detection of antimicrobial resistance associated with chromosomal point mutations in bacterial pathogens, Journal of Antimicrobial Chemotherapy, Volume 72, Issue 10, October 2017, Pages 2764–2768, https://doi.org/10.1093/jac/dkx217",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Filogenetik ağaçlar</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.tr.html",
    "href": "new_pages/interactive_plots.tr.html",
    "title": "39  İnteraktif grafikler",
    "section": "",
    "text": "39.1 Hazırlık",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>İnteraktif grafikler</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.tr.html#hazırlık",
    "href": "new_pages/interactive_plots.tr.html#hazırlık",
    "title": "39  İnteraktif grafikler",
    "section": "",
    "text": "Paketleri yükleme\nAşağıdaki kod parçaso, analizler için gereken paketlerin yüklenmesini göstermektedir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() fonksiyonunu vurgulamaktayız. R tabanından library() ile daha öncesinde kurmuş olduğunuz paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R’ın temelleri sayfasına bakabilirsiniz.\n\npacman::p_load(\n  rio,       # Dosyaları içeri/dışarı aktarılması\n  here,      # Dosya yolağını tespit edilmesi \n  lubridate, # Tarihlerle çalışma\n  plotly,    # İnteraktif grafikler\n  scales,    # Yüzdelerin oranlara kolayca çevrilmesi\n  tidyverse  # Veri yönetimi ve görselleştirilmesi\n  ) \n\n\n\nggplot() hazırlama\nBu sayfada, etkileşimli hale dönüştürmek istediğiniz bir ggplot() grafiğiyle işe başladığınızı varsayıyoruz. Bu el kitabının birçok sayfasında kullanılan linelist metodunu kullanarak bu sayfadaki grafiklerden birkaçını oluşturacağız.\n\n\nVeriyi içe aktarma\nSimüle edilmiş bir Ebola salgınına ait vakaların veri setini içe aktarıyoruz. Takip etmek isterseniz,  “temiz satır listesi” dosyasını indirmek için tıklayın. (.rds dosyası olarak) Verilerinizi rio paketinden import() işleviyle içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için [İçe ve dışa aktarma] sayfasına bakın).\n\n# veri setini indir \nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nVeri setindeki ilk 50 satır aşağıda listelenmiştir.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>İnteraktif grafikler</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.tr.html#ggplotly-ile-grafikler",
    "href": "new_pages/interactive_plots.tr.html#ggplotly-ile-grafikler",
    "title": "39  İnteraktif grafikler",
    "section": "39.2 ggplotly() ile grafikler",
    "text": "39.2 ggplotly() ile grafikler\nplotly paketindeki ggplotly() işlevi bir ggplot() grafiğini kolayca etkileşimli hale dönüştürebilir. Kısaca “ggplot()” dosyanızı kaydedin ve ardından onu “ggplotly()” işlevine aktarın.\nAşağıda, belirli bir haftada ölen vakaların oranını gösteren basit bir grafik çizeceğiz:\nİlk olarak, her epidemiyolojik hafta için bir özet veri seti, çıktıları bilinen vakaların sayısı ve bu vakalardaki ölüm yüzdesini oluşturarak başlıyoruz.\n\nweekly_deaths &lt;- linelist %&gt;%\n  group_by(epiweek = floor_date(date_onset, \"week\")) %&gt;%  # veri setini epidemiyolojik hafta olarak oluştur ve grupla\n  summarise(                                              # yeni özet veri çerçevesi oluştur:\n    n_known_outcome = sum(!is.na(outcome), na.rm=T),      # bilinen çıktıları olan hasta sayısı\n    n_death  = sum(outcome == \"Death\", na.rm=T),          # ölen vaka sayısı\n    pct_death = 100*(n_death / n_known_outcome)           # çıktıları bilinen hastalar içinde ölen vaka oranı\n  )\n\nweekly_deaths veri setinin ilk 50 satırı:\n\n\n\n\n\n\nArdından ggplot2 ile geom_line() işlevini kullanarak grafiği oluşturuyoruz.\n\ndeaths_plot &lt;- ggplot(data = weekly_deaths)+            # weekly deaths verileri ile başla\n  geom_line(mapping = aes(x = epiweek, y = pct_death))  # çizgi oluştur\n\ndeaths_plot   # yazdır\n\n\n\n\n\n\n\n\nBu grafiği aşağıdaki gibi ggplotly() işleviyle basitçe etkileşimli hale getirebiliriz. X ve y değerlerini göstermek için farenizi çizginin üzerine getirin. Grafiği yakınlaştırabilir ve etrafa sürükleyebilirsiniz. Simgeleri grafiğin sağ üst köşesinde görebilirsiniz. Sırayla, aşağıdaki aksiyonları alabilirsiniz:\n\nGeçerli grafiği bir PNG görüntüsü olarak indirin\nSeçim kutusuyla görüntüyü yakınlaştırın\n“Kaydırma” çubuğu veya grafiği tıklayıp sürükleyerek grafik üzerinde hareket edin\nYakınlaştırın, uzaklaştırın veya varsayılan yakınlaştırmaya dönün\nEksenleri varsayılanlara sıfırlayın\nX ve y eksenlerine uzanan “interaktif çizgileri” açıp/kapayın\nVerilerin gösterilip gösterilmeyeceğine ilişkin ayarlamaları düzenleyin\n\n\ndeaths_plot %&gt;% plotly::ggplotly()\n\n\n\n\n\nggplotly() gruplanmış verilerde de çalışır. Aşağıda, çıktılarına göre gruplandırılmış haftalık bir epidemiyoloji eğrisi yapılmıştır. Yığılmış çubuklar etkileşimlidir. Grafikteki farklı öğelere tıklamayı deneyin (tıkladığınız öğeler görünecek / gizlenecektir).\n\n# incidence2 paketi ile epidemiyoloji eğrisi düzenle\np &lt;- incidence2::incidence(\n  linelist,\n  date_index = date_onset,\n  interval = \"weeks\",\n  groups = outcome) %&gt;% plot(fill = outcome)\n\n\n# İnteraktif grafik\np %&gt;% plotly::ggplotly()",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>İnteraktif grafikler</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.tr.html#değişiklikler",
    "href": "new_pages/interactive_plots.tr.html#değişiklikler",
    "title": "39  İnteraktif grafikler",
    "section": "39.3 Değişiklikler",
    "text": "39.3 Değişiklikler\n\nDosya boyutu\nR Markdown tarafından oluşturulan bir HTML’de dışa aktarırken (bu kitap gibi!) grafiğin veri boyutunu küçültmek isteyebilirsiniz (çoğu durumda hiçbir olumsuz yan etkisi yoktur). Bunun için interaktif grafiği yine plotly paketinden partial_bundle() işlevine aktarmanız yeterli olacaktır.\n\np &lt;- p %&gt;% \n  plotly::ggplotly() %&gt;%\n  plotly::partial_bundle()\n\n\n\nDüğmeler\nStandart bir plotly grafiğindeki bazı düğmeler dikkat dağıtıcı olabilir. İsterseniz, bunları kaldırabilirsiniz. Bunu, grafik çıktısını plotly paketinden config() işlevi içine aktararak yapabilirsiniz. İşlev içinde hangi düğmelerin kaldırılacağını belirtmeniz gerekmektedir. Aşağıdaki örnekte, kaldırılacak düğmelerin adlarını önceden belirleyip modeBarButtonsToRemove = argümanına yazıyoruz. Ayrıca plotly logosunu kaldırmak için de displaylogo = FALSE argümanını ekledik.\n\n## bu düğmeler dikkat dağıtıyor ve bunları kaldırmak istiyoruz\nplotly_buttons_remove &lt;- list('zoom2d','pan2d','lasso2d', 'select2d','zoomIn2d',\n                              'zoomOut2d','autoScale2d','hoverClosestCartesian',\n                              'toggleSpikelines','hoverCompareCartesian')\n\np &lt;- p %&gt;%          # etkileşimli grafiği bu düğmeler olmadan yeniden tanımla\n  plotly::config(displaylogo = FALSE, modeBarButtonsToRemove = plotly_buttons_remove)",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>İnteraktif grafikler</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.tr.html#isı-grafikleri",
    "href": "new_pages/interactive_plots.tr.html#isı-grafikleri",
    "title": "39  İnteraktif grafikler",
    "section": "39.4 Isı grafikleri",
    "text": "39.4 Isı grafikleri\nIsı haritası da dahil olmak üzere neredeyse tüm ggplot() grafiklerini interaktif hale getirebilirsiniz. Isı grafikleri sayfasında, belirli illerde kurulmuş olan malarya tesislerine ait bir grafiğin nasıl yapıldığı anlatılmaktadır. Bu grafikte haftanın bazı günlerinde tesislerden elde edilen veriler görselleştirilmiştir.\nÖrnek kodu, burada derinlemesine açıklamayacak olsak bile aşağıda paylaşıyoruz.\n\n# verileri içe aktar\nfacility_count_data &lt;- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\"))\n\n# Spring bölgesine ait verileri Weeks'te topla\nagg_weeks &lt;- facility_count_data %&gt;% \n  filter(District == \"Spring\",\n         data_date &lt; as.Date(\"2020-08-01\")) %&gt;% \n  mutate(week = aweek::date2week(\n    data_date,\n    start_date = \"Monday\",\n    floor_day = TRUE,\n    factor = TRUE)) %&gt;% \n  group_by(location_name, week, .drop = F) %&gt;%\n  summarise(\n    n_days          = 7,\n    n_reports       = n(),\n    malaria_tot     = sum(malaria_tot, na.rm = T),\n    n_days_reported = length(unique(data_date)),\n    p_days_reported = round(100*(n_days_reported / n_days))) %&gt;% \n  ungroup(location_name, week) %&gt;% \n  right_join(tidyr::expand(., week, location_name)) %&gt;% \n  mutate(week = aweek::week2date(week))\n\n# grafiği oluştur\nmetrics_plot &lt;- ggplot(agg_weeks,\n       aes(x = week,\n           y = location_name,\n           fill = p_days_reported))+\n  geom_tile(colour=\"white\")+\n  scale_fill_gradient(low = \"orange\", high = \"darkgreen\", na.value = \"grey80\")+\n  scale_x_date(expand = c(0,0),\n               date_breaks = \"2 weeks\",\n               date_labels = \"%d\\n%b\")+\n  theme_minimal()+ \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1,\"cm\"),\n    legend.key.width  = grid::unit(0.6,\"cm\"),\n    axis.text.x = element_text(size=12),\n    axis.text.y = element_text(vjust=0.2),\n    axis.ticks = element_line(size=0.4),\n    axis.title = element_text(size=12, face=\"bold\"),\n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),\n    plot.caption = element_text(hjust = 0, face = \"italic\")\n    )+\n  labs(x = \"Week\",\n       y = \"Facility name\",\n       fill = \"Reporting\\nperformance (%)\",\n       title = \"Percent of days per week that facility reported data\",\n       subtitle = \"District health facilities, April-May 2019\",\n       caption = \"7-day weeks beginning on Mondays.\")\n\nmetrics_plot # yazdır\n\n\n\n\n\n\n\n\nAşağıda, grafiği etkileşimli hale getiriyoruz. Düğmeleri ve dosya boyutunu değiştiriyoruz.\n\nmetrics_plot %&gt;% \n  plotly::ggplotly() %&gt;% \n  plotly::partial_bundle() %&gt;% \n  plotly::config(displaylogo = FALSE, modeBarButtonsToRemove = plotly_buttons_remove)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n–&gt;",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>İnteraktif grafikler</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.tr.html#kaynaklar",
    "href": "new_pages/interactive_plots.tr.html#kaynaklar",
    "title": "39  İnteraktif grafikler",
    "section": "39.5 Kaynaklar",
    "text": "39.5 Kaynaklar\nPlotly sadece R’da değil, aynı zamanda Python (ve JavaScript temelli herhangi bir veri bilimi kodlama dili) ile de çalışmaktadır. Daha fazla bilgiye plotly web sitesinden ulaşabilirsiniz.",
    "crumbs": [
      "Veri Görselleştirme",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>İnteraktif grafikler</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.tr.html",
    "href": "new_pages/rmarkdown.tr.html",
    "title": "40  R Markdown ile Raporlar",
    "section": "",
    "text": "40.1 Hazırlık\nR Markdown arkaplanı\nİlgili bazı kavram ve paketleri açıklamak için: • Markdown, html ve diğer formatlara dönüştürülebilen, düz metin kullanarak bir belge yazmanıza izin veren bir “dildir”. R’ye özgü değildir. Markdown’da yazılan dosyalar ‘.md’ uzantısına sahiptir. • R Markdown, R’ye özgü bir markdown varyasyonudur - metin üretmek, R kodunu gömmek ve çıktılarını görüntülemek için markdown kullanarak belge yazmanızı sağlar. R Markdown dosyaları “.Rmd” uzantısına sahiptir. • rmarkdown - paketi: Bu, R tarafından .Rmd dosyasını istenen çıktıya dönüştürmek için kullanılır. Odak noktası, dosyayı markdown (metin) sözdizimini dönüştürmektir. • knitr: Bu R paketi kod parçalarını okur, yürütür ve belgeye geri “örer”. Tablolar ve grafikler bu şekilde metnin yanına eklenir. • Pandoc: Son olarak, pandoc çıktıyı word/pdf/powerpoint vb.’ye dönüştürür. R’den ayrı bir yazılımdır ancak RStudio ile otomatik olarak yüklenir. • Özetle, arka planda gerçekleşen süreç (tüm bu adımları bilmenize gerek yoktur!), .Rmd dosyasının knitr’yi beslemesini içerir. Bu paket R kodu parçalarını yürütür ve yeni bir .md (markdown) dosyası oluşturur. R kodu ve işlenmiş çıktısı. .md dosyası daha sonra bitmiş ürünü oluşturmak için pandoc tarafından işlenir: bir Microsoft Word belgesi, HTML dosyası, powerpoint belgesi, pdf, vb. oluşturulur\n(kaynak: https://rmarkdown.rstudio.com/authoring_quick_tour.html):\nYükleme\nBir R Markdown çıktısı oluşturmak için aşağıdakilerin kurulu olması gerekir:\n• rmarkdown paketi (knitr ayrıca otomatik olarak kurulacaktır) • RStudio ile birlikte gelmesi gereken Pandoc. RStudio kullanmıyorsanız, Pandoc’u buradan indirebilirsiniz: http://pandoc.org. • PDF çıktısı oluşturmak istiyorsanız (biraz daha zor), LaTeX’i kurmanız gerekecek. Daha önce LaTeX yüklememiş olan R Markdown kullanıcıları için TinyTeX’i (https://yihui.name/tinytex/) yüklemenizi öneririz. Aşağıdaki komutları kullanabilirsiniz:\npacman::p_load(tinytex)     # tinytex paketini yükleyin \ntinytex::install_tinytex()  # TinyTeX yazılımını yüklemek için R komutu",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Markdown ile Raporlar</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.tr.html#başlangıç",
    "href": "new_pages/rmarkdown.tr.html#başlangıç",
    "title": "40  R Markdown ile Raporlar",
    "section": "40.2 Başlangıç",
    "text": "40.2 Başlangıç\n\nrmarkdown R paketini yükleme\nrmarkdown R paketini kurun. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’ın p_load() işlevini vurguluyoruz. Ayrıca, temel R’dan library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R temelleri ile ilgili sayfaya bakın.\n\npacman::p_load(rmarkdown)\n\n\n\nYeni bir Rmd dosyası başlatmak\nRStudio’da, ‘Dosya’, ardından ‘Yeni dosya’ ve ardından ‘R markdown…’ ile başlayan yeni bir R markdown dosyası açın.\n\n\n\n\n\n\n\n\n\nR Studio size bazı çıktı seçenekleri sunacaktır. Aşağıdaki örnekte bir html belgesi oluşturmak istediğimiz için “HTML”yi seçiyoruz. Başlık ve yazar isimleri önemli değildir. İstediğiniz çıktı belgesi türü bunlardan biri değilse endişelenmeyin - herhangi birini seçip daha sonra komut dosyasında değiştirebilirsiniz.\n\n\n\n\n\n\n\n\n\nBu, yeni bir .Rmd betiği açacaktır.\n\n\nBilinmesi önemli noktalar\nÇalışma dizini\nBir markdown dosyasının çalışma dizini, Rmd dosyasının kendisinin kaydedildiği yerdir. Örneğin, R projesi ‘~/Documents/projectX’ içindeyse ve Rmd dosyasının kendisi ‘~/Documents/projectX/markdownfiles/markdown.Rmd’ alt klasöründeyse, markdown içindeki read.csv(“data.csv”) kodu projelerdeki komut dosyalarının normalde otomatik olarak bakacağı kök proje klasöründe değil, ‘markdownfiles’ klasöründe bir csv dosyası arayacaktır.\nBaşka bir yerde dosyalara başvurmak için ya tam dosya dizinini kullanmanız ya da buradaki paketi kullanmanız gerekecektir. Buradaki paket, çalışma dizinini R projesinin kök klasörü olarak ayarlar. Bu işlem el kitabının R projeleri ve içe ve dışa aktarma sayfalarında ayrıntılı olarak açıklanmıştır. Örneğin, projeX klasöründen “data.csv” adlı bir dosyayı içe aktarmak için kod import(here(“data.csv”) olacaktır).\nR Markdown komut dosyalarında ‘setwd()’ fonksiyonunun kullanımının önerilmediğini unutmayın - yalnızca yazıldığı kod parçası için geçerlidir.\nBilgisayarınızda bir sürücü üzerinde çalışmak\nR Markdown, paylaşılan bir ağ sürücüsünde çalışırken pandoc sorunlarıyla karşılaşabileceğinden, klasörünüzün yerel makinenizde olması önerilir, örn. ‘Belgelerim’ içindeki bir projede. Git kullanıyorsanız (çok tavsiye edilir!), size tanıdık gelecektir. Daha fazla ayrıntı için, ağ sürücülerinde R’deki el kitabı sayfalarına ve [Hatalar ve yardım]’a bakın.",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Markdown ile Raporlar</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.tr.html#r-markdown-bileşenleri",
    "href": "new_pages/rmarkdown.tr.html#r-markdown-bileşenleri",
    "title": "40  R Markdown ile Raporlar",
    "section": "40.3 R Markdown bileşenleri",
    "text": "40.3 R Markdown bileşenleri\nBir R Markdown belgesi, standart bir R betiği gibi RStudio’da düzenlenebilir. Yeni bir R Markdown komut dosyası başlattığınızda, RStudio, R Markdown komut dosyasının farklı bölümlerini açıklayan bir şablon göstererek destek sağlar.\nAşağıdaki, bir html çıktısı oluşturmayı amaçlayan yeni bir Rmd betiğinin başlatıldığında izlenen bileşenler görülmektedir. (önceki bölüme göre).\n\n\n\n\n\n\n\n\n\nGördüğünüz gibi, bir Rmd dosyasının üç temel bileşeni vardır: YAML, Markdown metni ve R kodu parçaları.\nBunlar, belge çıktınızı oluşturacaktır. Aşağıdaki şemaya bakın:\n\n\n\n\n\n\n\n\n\n\nYAML metadatası\n“YAML meta verileri” veya yalnızca “YAML” olarak anılan bu bileşen, R Markdown belgesinin en üstündedir. Komut dosyasının bu bölümü, Rmd dosyanız için ne tür bir çıktı üretileceğini, biçimlendirme tercihlerini ve belge başlığı, yazar ve tarih gibi diğer meta verileri gösterecektir. Burada belirtilmeyen başka kullanımlar da vardır (Çıktı oluşturma’ bölümünde anlatılmaktadır). Girintilerin önemli olduğunu unutmayın; sekmeler kabul edilmez ancak boşluklar kabul edilir.\nBu bölüm yalnızca üç tire (—) içeren bir satırla başlamalı ve yalnızca üç tire içeren bir satırla kapatılmalıdır. YAML parametreleri anahtar:değer (key:value) çiftleri halinde kodlanır. YAML’de iki nokta üst üste işareti (:) yerleşimi önemlidir - anahtar:değer çiftleri iki nokta üst üste işareti ile ayrılır (eşittir işaretleriyle değil!).\nYAML, belge için meta verilerle başlamalıdır. Bu birincil YAML parametrelerinin (girintisiz) sırası önemli değildir. Örneğin:\ntitle: \"My document\"\nauthor: \"Me\"\ndate: \"2024-05-10\"\nR kodunu YAML değerleri içinde satır içi kod olarak (ters tikler içinde, r önce gelir) veya tırnak işaretleri içinde yazarak kullanabilirsiniz (tarih için yukarıdaki örneğe bakın:).\nYukarıdaki resimde, varsayılan çıktımızın bir html dosyası olacağını seçtiğimiz için, YAML’nin çıktı: html_document olarak kodlandığını görebiliriz. Ancak bunu powerpoint_presentation veya word_document veya hatta pdf_document olarak değiştirebiliriz.\n\n\nMetin\nMetin, başlıklar da dahil olmak üzere belgenizin anlatımıdır. Birçok farklı yazılımda kullanılan “markdown” dilinde yazılmıştır.\nAşağıda bu metni yazmanın temel yolları bulunmaktadır. RStudio web sitesindeki R Markdown “cheatsheet”te bulunan daha kapsamlı belgelere bakın. RStudio website.\n\nYeni Satırlar\nBenzersiz bir şekilde R Markdown’da yeni bir satır başlatmak için önceki satırın sonuna *iki boşluk** girin ve ardından Enter/Return uygulayın\n\n\nMetin Karakteri\nÇıktıda nasıl görüneceğini değiştirmek için normal metninizi bu karakterlerle çevreleyin.\n• İtalik yapmak için alt çizgi (metin) veya tek bir yıldız (metin) • Kalın metin için çift yıldız (metin) • Metni kod olarak görüntülemek için ters tik (metin)\nYazı tipinin gerçek görünümü, belirli şablonlar kullanılarak ayarlanabilir (YAML meta verilerinde belirtilir; örnek sekmelere bakın).\n\n\nRenk\nR Markdown’da metnin rengini değiştirmek için basit bir mekanizma yoktur. Çıktınız bir HTML dosyasıysa, geçici bir çözüm, işaretleme metnine bir HTML satırı eklemektir. Aşağıdaki HTML kodu, kalın kırmızı renkte bir metin satırı yazdıracaktır.\n&lt;span style=\"color: red;\"&gt;**_DANGER:_** This is a warning.&lt;/span&gt;  \n**__TEHLİKE:_** Bu bir uyarıdır.\n\n\nBaşlıklar\nBir R Markdown betiğinin metin bölümündeki hash (#) sembolü, bir başlık oluşturur. Bu, normal bir R betiğinde olduğu gibi, bir hash sembolünün yorum yapma/açıklama ekleme/devre dışı bırakma mekanizması olduğu komut dosyasındaki bir R kodundan farklıdır.\nYeni bir satırın başlangıcında farklı sayıda hash sembolü ile farklı başlık seviyeleri oluşturulur. Bir hash sembolü, bir başlık veya birincil başlıktır. İki hash sembol, ikinci düzey bir başlıktır. Üçüncü ve dördüncü seviye başlıklar, art arda daha fazla hash sembolü ile yapılabilir.\n# Birinci düzey başlık / Genel başlık\n\n## İkinci seviye başlık\n\n### Üçüncü seviye başlık \n\n\nMadde İşaretleri ve Numaralandırma\nBir madde işareti listesi oluşturmak için yıldız işaretlerini (*) kullanın. Önceki cümleyi bitirin, iki boşluk bırakın, iki kez Enter/Return yapın ve ardından madde işaretlerinizi başlatın. Yıldız işareti ile madde işareti ile metniniz arasına bir boşluk ekleyin. Her madde işaretinden sonra iki boşluk girin ve ardından Enter/Return yapın. Alt madde işaretleri aynı şekilde çalışır ancak girintilidir. Sayılar aynı şekilde çalışır, ancak yıldız işareti yerine 1), 2) vb. yazın. Aşağıda R Markdown komut dosyası metninizin nasıl görünebileceği açıklanmıştır.\nMadde işaretlerim (bu kolondan sonra iki boşluk var):\n\n* Madde 1 (ardından iki boşluk ve Enter/Return)\n* Madde 2 (ardından iki boşluk ve Enter/Return)\n   * Alt madde işareti 1 (ardından iki boşluk ve Enter/Return)\n   * Alt madde 2 (ardından iki boşluk ve Enter/Return)\n \n  \n\n\nMetne yorum yapılması\nTıpkı bir R parçasındaki bir R kodu satırını yorumlamak için “#” kullanabildiğiniz gibi, R İşaretleme metnini “yorumlayabilirsiniz”. Metni seçip ve Ctrl+Shift+c (Mac için Cmd+Shift+c) tuşlarına basın. Metin oklarla çevrelenecek ve yeşil renk alacaktır. Çıktınızda görünmeyecektir.\n\n\n\n\n\n\n\n\n\n\n\n\nKod parçaları\nKomut dosyasının R kodunu çalıştırmaya ayrılmış bölümlerine “parçalar” denir. Bu parçalar, paketleri yükleyebileceğiniz, verileri içe aktarabileceğiniz ve veri yönetimi ve görselleştirmesini gerçekleştirebileceğiniz yerlerdir. Çok sayıda kod parçası olabilir ve bu parçalar R kodunuzu metne serpiştirerek parçalar halinde organize etmenize yardımcı olabilir. Not: Bu “parçalar”, belgenin anlatım kısmından farklı bir arka plan rengine sahiptir. Her parça, üç ters tik ile başlayan bir satır ve parça için parametreleri içeren küme parantezleri ({ }) ile açılır. Parça üç tane daha geri tik ile sona erer.\n“Ctrl + Alt + i” (veya Mac’te Cmd + Shift + r) klavye kısa yollarını kullanarak veya komut dosyası düzenleyicinizin en üstünde ‘yeni bir kod parçası ekle’ simgesini tıklayarak yeni bir parça oluşturabilirsiniz. { } küme parantezlerinin içeriği hakkında bazı notlar:\n• Parça içindeki kodlama dilinin R olduğunu belirtmek için ‘r’ ile başlarlar. • r’den sonra isteğe bağlı olarak bir kod parçası “adı” yazabilirsiniz – bu ad gerekli değildir ancak işinizi organize etmenize yardımcı olabilir. Parçalarınızı adlandırırsanız, HER ZAMAN benzersiz adlar kullanmanız gerektiğini unutmayın, aksi takdirde R, oluşturmayı denediğinizde hata verir.\n• Kıvrımlı parantezler, etiket=değer olarak yazılan diğer seçenekleri de içerebilir, örneğin: • eval = FALSE R kodunu çalıştırmamak için • echo = FALSE parçayı R kaynak kodunu çıktı belgesine yazdırmamak için • warning =FALSE R kodu tarafından üretilen uyarıları yazdırmamak için • message = FALSE R kodu tarafından üretilen hiçbir mesajı yazdırmamak için • include = TRU/FALSE, parça çıktılarının (ör. grafikler) belgeye dahil edilip edilmeyeceği • out.width = ve out.height = … tarzında oluşturma için out.width = “%75” • fig.align = “center” şeklin sayfa boyunca nasıl hizalanacağını ayarlar • fig.show=‘hold’ parçanız birden fazla şekil yazdırıyorsa ve bunların yan yana yazdırılmasını istiyorsanız (out.width = c(“%33”, “%67”) ile eşleştirin. Fig.show =‘asis’, kendilerini oluşturan kodun altında şekilleri göstermek için, ‘hide’ gizlemek için veya ‘animate’.bir animasyonda birden çok şekli birleştirmek için • Bir satırda bir parça başlığı yazılmalıdır • Noktalardan, alt çizgilerden ve boşluklardan kaçınmaya çalışın. Ayırıcıya ihtiyacınız varsa bunun yerine kısa çizgi (hyphens) ( - ) kullanın. Buradan knitr özellikleri hakkında daha fazla bilgi edinin.\nYukarıdaki seçeneklerden bazıları, parçanın sağ üst köşesindeki ayar düğmeleri yapılandırılabilir. Burada, işlenen belgenin kodu, çıktıları ve uyarıları içermesini istediğiniz parçalarını belirtebilirsiniz. Bu, küme parantezleri içinde yazılı tercihler olarak görünecektir, örn. echo=FALSE ‘Yalnızca çıktıyı göster’ istediğinizi belirtir.\n\n\n\n\n\n\n\n\n\nAyrıca her parçanın sağ üst tarafında, kodu bir parça içinde veya tüm kodu önceki parçalarda çalıştırmak için yararlı olan iki ok vardır. Ne yaptıklarını görmek için üzerinde gezinin.\nKomut dosyasındaki tüm parçalara uygulanacak genel seçenekleri komut dosyasındaki ilk R kodu parçasında ayarlayabilirsiniz. Örneğin, her kod parçası için yalnızca çıktıların gösterilmesi ve kodun kendisinin gösterilmemesi için, bu komutu R kod parçasına dahil edebilirsiniz:\n\nknitr::opts_chunk$set(echo = FALSE) \n\n\nMetin İçinde R Kodu\nGeri tiklere minimum R kodunu da dahil edebilirsiniz. Geri tikler içinde, koda “r” ve bir boşluk ile başlayın, böylece RStudio, kodu R kodu olarak değerlendireceğini bilir. Aşağıdaki örneğe bakın.\nAşağıdaki örnek, birden çok seviyedeki başlıkları ve madde işaretlerini gösterir, geçerli tarihi çıktı olarak kullanmak için (Sys.Date()) için R kodunu kullanır.\n\n\n\n\n\n\n\n\n\nYukarıdaki örnek basittir (geçerli tarihi gösterir), ancak aynı sintaksı kullanarak daha karmaşık R kodu tarafından üretilen değerleri görüntüleyebilirsiniz (örneğin, bir sütunun min, medyan, maks. değerini hesaplamak gibi). Ayrıca, komut dosyasına daha önce R kodu parçalarında oluşturulmuş R nesnelerini veya değerlerini de entegre edebilirsiniz.\nÖrnek olarak, aşağıdaki komut dosyası, 18 yaşından küçük vakaların oranını tidyverse işlevlerini kullanarak hesaplar ve 18altı (less18), toplam (total) ve 18altıoran (less18prop) nesnelerini oluşturur. Bu dinamik değer sonraki metne eklenir. Bir word belgesine nasıl çıktı alındığını (örüldüğünü) görüyoruz.\n\n\n\n\n\n\n\n\n\n\n\n\nGörseller\nGörüntüleri R Markdown’ınıza iki yoldan biriyle dahil edebilirsiniz:\n\n![](\"path/to/image.png\")  \n\nYukarıdakiler işe yaramazsa, knitr::include_graphics() kullanmayı deneyin.\n\nknitr::include_graphics(\"path/to/image.png\")\n\n(unutmayın, dosya yolunuz buradaki paket kullanılarak yazılabilir)\n\nknitr::include_graphics(here::here(\"path\", \"to\", \"image.png\"))\n\n\n\nTablolar\nKısa çizgi ( - ) ve çubuklar ( | ) kullanarak bir tablo oluşturun. Çubukların önündeki/arasındaki kısa çizgi sayısı, metin yazılmaya başlamadan önceki boş karakter sayısını belirtir.\nColumn 1 |Column  2 |Column 3\n---------|----------|--------\nCell A   |Cell B    |Cell C\nCell D   |Cell E    |Cell F\nYukarıdaki kod aşağıdaki tabloyu oluşturur:\n\n\n\nColumn 1\nColumn 2\nColumn 3\n\n\n\n\nCell A\nCell B\nCell C\n\n\nCell D\nCell E\nCell F\n\n\n\n\n\nSekmeli Bölümler\nHTML çıktılarında bölümleri “sekmeler” halinde düzenleyebilirsiniz. Bunun için bir başlıktan sonra gelen küme parantezleri { } içine .tabset’i eklemeniz yeterlidir. Bu başlığın altındaki herhangi bir alt başlık (aynı seviyedeki başka bir başlığa kadar), kullanıcının tıklayabileceği sekmeler olarak görünecektir. Daha fazlasını buradan okuyabilirsiniz.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSekmelere kendilerine özgü bir görünüm vermek için .tabset’ten sonra ek olarak ‘.tabset-pills’ seçeneği ekleyebilirsiniz. Sekmeli HTML çıktısını görüntülerken, Ctrl+f arama işlevinin gizli sekmeleri değil, yalnızca “etkin” sekmeleri arayacağını unutmayın.",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Markdown ile Raporlar</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.tr.html#dosya-yapısı",
    "href": "new_pages/rmarkdown.tr.html#dosya-yapısı",
    "title": "40  R Markdown ile Raporlar",
    "section": "40.4 Dosya yapısı",
    "text": "40.4 Dosya yapısı\nR Markdown’unuzu ve ilişkili R komut dosyalarını yapılandırmanın birkaç yolu vardır. Her birinin avantajları ve dezavantajları vardır:\n• Kendine yeten R Markdown - rapor için gereken her şey R Markdown içinde içe aktarılır veya oluşturulur • Diğer dosyaları kaynak olarak kullanma - source() komutuyla harici R komut dosyalarını çalıştırabilir ve çıktılarını Rmd’de kullanabilirsiniz. • Alt komut dosyaları - source() için alternatif bir mekanizma • Bir “runfile” kullanın - R Markdown’ı oluşturmadan önce komutları bir R betiğinde çalıştırın\n\nKendine yeten Rmd\nNispeten basit bir rapor için, R Markdown komut dosyanızı “kendi kendine yeterli” olacak ve herhangi bir harici komut dosyası içermeyecek şekilde düzenlemeyi seçebilirsiniz.\nR markdown’ı çalıştırmak için ihtiyacınız olan her şey, tüm kod parçaları ve paket yüklenmesi dahil olmak üzere, Rmd dosyası içinde gerçekleşir. Bu “kendi kendine yeten” yaklaşım, çok fazla veri işleme yapmanız gerekmediğinde (örneğin, temiz veya yarı temiz bir veri dosyası getirdiğinde) uygundur ve R Markdown’ın oluşturulması çok uzun sürmez.\nBu senaryoda, R Markdown betiğinin bir mantıksal organizasyonu şöyle olabilir: 1. Küresel knitr seçeneklerini ayarlayın 2. Paketleri yükleyin 3. Verileri içe aktarın 4. Veriyi işleyin 5. Çıktılar (tablolar, grafikler, vb.) 6. Varsa çıktıları kaydedin (.csv, .png, vb.)\n\nDiğer dosyaları kaynak olarak kullanma\n“Kendi kendine yeterli” yaklaşımın bir varyasyonu, R Markdown kod parçalarının diğer R komut dosyalarını “kaynak” olarak kullanmasıdır (çalıştırma-run). Bu yaklaşım R Markdown betiğinizi daha az karmaşık, daha basit ve organize edilmesi daha kolay hale getirebilir. Son çıktıları raporun başında görüntülemek isterseniz de bu yaklaşım yardımcı olabilir. Bu yaklaşımda, son R Markdown betiği, önceden işlenmiş çıktıları bir belgede birleştirir.\nBunu yapmanın yolu, temel R ‘source()’ fonksiyonuna R komut dosyalarını (dosya yolu ve uzantılı ad) sağlamaktır.\n\nsource(\"your-script.R\", local = knitr::knit_global())\n# or sys.source(\"your-script.R\", envir = knitr::knit_global())\n\nR Markdown içinde source() kullanılırken, Rmd dosyanızın oluşturulması sırasında harici dosyaların çalışmaya devam edeceğini unutmayın. Bu nedenle, raporu her oluşturduğunuzda komut dosyası çalıştırılır. Bu nedenle, bu source() komutlarının R Markdown içinde olması çalışma sürenizi hızlandırmaz ve hata ayıklamaya büyük ölçüde yardımcı olmaz, çünkü üretilen hata R Markdown üretilirken yazdırılmaya devam eder.\nBir alternatif, child = knitr seçeneğini kullanmaktır.\nFarklı R ortamlarının farkında olmalısınız. Bir ortamda oluşturulan nesneler, R Markdown tarafından kullanılan ortamda bulunmayabilir.\n\n\n\nRunfile\nBu yaklaşım, R markdown ile beslenen nesneleri önceden işlemek için render() komutlarını içeren R betiğinin kullanılmasını içerir.\nBu yaklaşımla, paketleri yükleyebilir, verileri yükleyebilir ve temizleyebilir ve hatta render()’dan önce ilgilendiğiniz grafikleri oluşturabilirsiniz. Bu adımlar, R komut dosyasında veya kaynaklı diğer komut dosyalarında ortaya çıkabilir. Bu komutlar aynı RStudio oturumunda gerçekleştiği ve nesneler ortama kaydedildiği sürece, nesneler daha sonra Rmd içeriği içinde çağrılabilir. Ardından, R markdown tüm önceden işlenmiş nesnelerle çıktı üretmek için yalnızca son adım için kullanılacaktır. Bu yöntemde bir şeyler ters giderse hata ayıklamak için çok daha kolaydır.\nBu yaklaşım aşağıdaki nedenlerle yararlıdır: • Daha bilgilendirici hata mesajları - bu mesajlar R Markdown’dan değil, R betiğinden oluşturulacaktır. R markdown hataları, hangi parçada sorun olduğunu söyleme eğilimindedir, ancak hangi satırda olduğunu söylemez. • Uygunsa, uzun işleme adımlarını render() komutundan önce çalıştırabilirsiniz (yalnızca bir kez çalışır).\nAşağıdaki örnekte, bir veri nesnesini R ortamında önceden işlediğimiz ve ardından render() kullanarak “create_output.Rmd”yi oluşturduğumuz ayrı bir R betiğine sahibiz.\n\ndata &lt;- import(\"datafile.csv\") %&gt;%       # veriyi yükle ve ortama kaydet \n  select(age, hospital, weight)          # kısıtlı sütunları seç \n\nrmarkdown::render(input = \"create_output.Rmd\")   # Rmd dosyası oluştur\n\n\n\nDosya yapısı\nİş akışı, oluşturulan belgeler ve şekiller için bir “çıktı” klasörüne ve temizlenmiş veriler için “veri” veya “girişler” klasörlerini içeren genel klasör yapısıyla da ilgilidir. Burada daha fazla ayrıntıya girmiyoruz, ancak Rutin raporların düzenlenmesi sayfasına göz atın.",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Markdown ile Raporlar</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.tr.html#belgenin-oluşturulması",
    "href": "new_pages/rmarkdown.tr.html#belgenin-oluşturulması",
    "title": "40  R Markdown ile Raporlar",
    "section": "40.5 Belgenin oluşturulması",
    "text": "40.5 Belgenin oluşturulması\nBelgeyi aşağıdaki şekillerde oluşturabilirsiniz: • RStudio komut dosyası düzenleyicisinin üst kısmındaki “Knit” düğmesine manuel olarak basarak (hızlı ve kolay) • render() komutunu çalıştırın (R Markdown betiğinin dışında yürütülür)\n\nSeçenek 1: “Knit” butonu\nRmd dosyasını açtığınızda, dosyanın üstündeki ‘Knit’ simgesine/düğmesine basın.\nR Studio, ilerlemeyi R konsolunuzun yakınındaki ’R markdown sekmesinde gösterecektir. Belge tamamlandığında otomatik olarak açılır.\nBelge, R işaretleme betiğinizle aynı klasöre ve aynı dosya adıyla (uzantı dışında) kaydedilecektir. Bu yaklaşım sürüm kontrolü için ideal değildir (manuel olarak taşınmadıkça her dosya oluşturmada var olan dosyanın üzerine yazılır), çünkü daha sonra dosyayı kendiniz yeniden adlandırmanız gerekebilir (örneğin dosya ismine bir tarih ekleyin).\nBu, rmarkdown’dan render() işlevi için RStudio’nun kısayol düğmesidir. Bu yaklaşım, yalnızca gerekli tüm bileşenlerin bulunduğu veya dosya içinden kaynaklandığı kendi kendine yeten bir R markdown ile uyumludur.\n\n\n\n\n\n\n\n\n\n\n\nSeçenek 2: render() komutu\nR Markdown çıktınızı üretmenin başka bir yolu da render() işlevini çalıştırmaktır (rmarkdown paketinden). Bu komutu R Markdown betiğinin dışında yürütmelisiniz - yani ya ayrı bir R betiğinde (genellikle “run dosyası” olarak adlandırılır) ya da R Konsolunda bağımsız bir komut olarak.\n\nrmarkdown::render(input = \"my_report.Rmd\")\n\n“knit” ile olduğu gibi, varsayılan ayarlar Rmd çıktısını aynı dosya adıyla (dosya uzantısı dışında) Rmd komut dosyasıyla aynı klasöre kaydeder. Örneğin “my_report.Rmd” örüldüğünde bir word belgesine örüyorsanız “my_report.docx” dosyasını oluşturacaktır. Ancak render() kullanarak farklı ayarlar kullanma seçeneğiniz vardır. render() aşağıdaki argümanları kabul eder:\n• output_format = Bu, dönüştürülecek çıktı biçimidir (ör. “html_document”, “pdf_document”, “word_document” veya “all”). Bunu, R Markdown betiği içindeki YAML’de de belirtebilirsiniz. • output_file = Bu, çıktı dosyasının (ve dosya yolunun) adıdır. Bu, aşağıda gösterildiği gibi here() veya str_glue() gibi R işlevleri aracılığıyla oluşturulabilir. • output_dir = Bu, dosyayı kaydetmek için bir çıktı dizinidir (klasör). Bu, Rmd dosyasının kaydedildiği dizinden başka bir alternatif seçmenize olanak tanır. • output_options = YAML komut dosyasındakileri geçersiz kılacak bir seçenekler listesi elde edebilirsiniz (ör. ) • output_yaml = YAML özelliklerini içeren bir .yml dosyasının yolağını sağlayabilirsiniz • params = Aşağıdaki parametrelerle ilgili bölüme bakın • Tam listeye buradan bakın\nBir örnek olarak, sürüm kontrolünü iyileştirmek için aşağıdaki komut, çıktı dosyasını dosya adı ve geçerli tarihle birlikte bir “çıktılar” alt klasörüne kaydeder. Dosya adını oluşturmak için, stringr paketindeki str_glue() fonkisyonu, statik dizelerle (açıkça yazılır) dinamik R kodunu (kıvrımlı parantezler içinde yazılır) birbirine ‘yapıştırmak’ için kullanılır. Örneğin 10 Nisan 2021 ise dosya adı “Report_2021-04-10.docx” olacaktır. str_glue() hakkında daha fazla ayrıntı için Karakterler ve dizeler sayfasına bakın.\n\nrmarkdown::render(\n  input = \"create_output.Rmd\",\n  output_file = stringr::str_glue(\"outputs/Report_{Sys.Date()}.docx\")) \n\nDosya işlenirken, RStudio Konsolu size %100’e kadar işlemeninm ilerlemesini ve işlemenin tamamlandığını belirten son bir mesaj gösterecektir.\n\n\nSeçenek 3: reportfactory paketi\nR reportfactory paketi, raporları rutin olarak çalıştırdığınız senaryolara göre (örneğin günlük, haftalık…) R Markdown raporlarını düzenlemek ve derlemek için alternatif bir yöntem sunar. Birden çok R Markdown dosyasının derlenmesini ve çıktılarının organizasyonunu kolaylaştırır. Özünde, R Markdown raporlarını çalıştırabileceğiniz, çıktılar için otomatik olarak tarih ve zaman damgalı klasörler oluşturabileceğiniz ve “hafif” sürüm kontrolüne sahip olabileceğiniz bir “fabrika” sağlar.\nRutin raporları organize etme sayfasında bu iş akışı hakkında daha fazla bilgi edinebilirsiniz.",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Markdown ile Raporlar</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.tr.html#parametreli-raporlar",
    "href": "new_pages/rmarkdown.tr.html#parametreli-raporlar",
    "title": "40  R Markdown ile Raporlar",
    "section": "40.6 Parametreli Raporlar",
    "text": "40.6 Parametreli Raporlar\nBelirli bir ayarla (örneğin belirli bir tarih veya yer veya belirli örgü seçenekleriyle) çalıştırılabilmesi için bir raporu dinamik hale getirmek için parametreleştirmeyi kullanabilirsiniz. Aşağıda, temel bilgilere odaklanıyoruz, ancak parametreli raporlar hakkında çevrimiçi olarak daha fazla bilgi bulabilirsiniz.\nEbola vaka listesini örnek olarak kullanarak, her hastane için her gün standart bir gözetim raporu oluşturmak istediğimizi varsayalım. Bunun parametreleri kullanarak nasıl yapılabileceğini gösteriyoruz.\nÖnemli: Bitişik bir R komut dosyasında basit R nesneleri kullanarak resmi parametre yapısı (params) olmadan da dinamik raporlar oluşturmak mümkündür. Bu durum, bu bölümün sonunda açıklanmıştır.\n\nParametrelerin ayarlanması\nR Markdown çıktınız için parametre değerleri belirlemek için birkaç seçeneğiniz vardır.\n\nSeçenek 1: YAML içinde parametrelerin ayarlanması\nTanımlamak istediğiniz her parametre için girintili ifadeler içeren bir params: seçeneği eklemek için YAML’yi düzenleyin. Bu örnekte, değerlerini belirttiğimiz tarih ve hastane parametrelerini oluşturuyoruz. Bu değerler, rapor her çalıştırıldığında değişebilir. Çıktıyı üretmek için “Knit” düğmesini kullanırsanız, parametreler bu varsayılan değerlere sahip olacaktır. Benzer şekilde, render() komutunu kullanırsanız, render() komutunda aksi belirtilmedikçe parametreler bu varsayılan değerlere sahip olacaktır.\n---\ntitle: Surveillance report\noutput: html_document\nparams:\n date: 2021-04-10\n hospital: Central Hospital\n---\nArka planda, bu parametre değerleri, params adı verilen salt okunur bir listede bulunur. Böylece, ortamınızdaki başka bir R nesnesi/değeri gibi parametre değerlerini R koduna ekleyebilirsiniz. Params$ yazıp ardından parametre adını yazmanız yeterlidir. Örneğin, hastane adını temsil etmek için params$hospital (varsayılan olarak “Merkez Hastane- Central Hospital”).\nParametrelerin doğru veya yanlış değerleri de tutabileceğini ve bu nedenle bunların bir R kod parçası için knitr seçeneklerinize dahil edilebileceğini unutmayın. Örneğin, {r, eval=FALSE} yerine {r, eval=params$run} ayarını yapabilirsiniz, bu durumda kod parçasının çalışıp çalışmaması parametre çalıştırma: değerine bağlıdır.\nTarih olan parametrelerin bir dize olarak girileceğini unutmayın. Bu nedenle, params$date’in R kodunda yorumlanması için muhtemelen Date sınıfına dönüştürmek için as.Date() veya benzer bir fonksiyonla sarılması gerekir.\n\n\nSeçenek 2: Parametrelerin render() ile ayarlanması\nYukarıda bahsedildiği gibi, çıktı üretmek için “Ör-Knit” düğmesine basmaya alternatif olarak, ayrı bir komut dosyasından render() fonksiyonunu yürütmektir. Bu durumda, bu fonksiyonda kullanılacak parametreleri render()’ın params = argümanında belirtebilirsiniz.\nBurada sağlanan herhangi bir parametre değerinin, YAML içinde yazılan varsayılan değerlerin üzerine yazılacağını unutmayın. Değerleri tırnak içinde yazıyoruz çünkü karakter/string değerleri olarak tanımlanmaları gerekiyor.\nAşağıdaki komut, “surveillance_report.Rmd” dosyasını işler; dinamik bir çıktı dosyası adı ve klasörü belirtir. Ayrıca params = argümanına iki parametre sağlayan bir list() içerir.\n\nrmarkdown::render(\n  input = \"surveillance_report.Rmd\",  \n  output_file = stringr::str_glue(\"outputs/Report_{Sys.Date()}.docx\"),\n  params = list(date = \"2021-04-10\", hospital  = \"Central Hospital\"))\n\n\n\nSeçenek 3: Bir Görsel Kullanıcı Arayüzü kullanarak parametreleri ayarlayın\nDaha iyi etkileşim için, parametreler için değerleri manuel olarak seçebildiğiniz Grafik Kullanıcı Arayüzü’nü (GUI) da kullanabilirsiniz. Bunu yapmak için ‘Ör-Knit’ düğmesinin yanındaki açılır menüyü tıklayıp ’Parametrelerle ör- Knit with parameters’i seçebiliriz.\nBelgenin YAML’sinde oluşturulan parametreler için değerleri yazmanıza izin veren bir açılır pencere görünecektir.\n\n\n\n\n\n\n\n\n\nAynı sonucu, aşağıda gösterildiği gibi params = “ask” argümanını belirterek bir render() komutuyla da elde edebilirsiniz.\n\nrmarkdown::render(\n  input = \"surveillance_report.Rmd\",  \n  output_file = stringr::str_glue(\"outputs/Report_{Sys.Date()}.docx\"),\n  params = “ask”)\n\nAncak bu açılır pencereye değerlerin girilmesi hata ve yazım hatalarına tabidir. Açılır menülerden girilebilecek değerlere kısıtlamalar eklemeyi tercih edebilirsiniz. Bunu, her bir parametre için YAML’ye birkaç belirtim ekleyerek yapabilirsiniz params: entry\n\nlabel: söz konusu açılır menünün başlığı\nvalue: varsayılan (başlangıç) değerdir\ninput: açılır menü için select şekilde ayarlayın\nchoices: Açılır menüden uygun değerleri verin\n\nAşağıda hastane parametresi için bu özellikler yazılmıştır.\n---\ntitle: Surveillance report\noutput: html_document\nparams:\n date: 2021-04-10\n hospital: \n  label: “Town:”\n  value: Central Hospital\n  input: select\n  choices: [Central Hospital, Military Hospital, Port Hospital, St. Mark's Maternity Hospital (SMMH)]\n---\nÖrürken (‘parametrelerle ör(Knit)’ düğmesi aracılığıyla veya render() yoluyla), açılır pencerede seçim yapabileceğiniz seçenekler bulunur.\n\n\n\n\n\n\n\n\n\n\n\n\nParametreli örnek\nAşağıdaki kod, R Markdown’da sırasıyla params\\(date ve params\\)hospital olarak kullanılan tarih ve hastane için parametreler oluşturur.\nOrtaya çıkan rapor çıktısında, verilerin belirli bir hastaneye nasıl filtrelendiğini ve grafik başlığının doğru hastane ve tarihi ifade ettiğini görün. Burada “linelist_cleaned.rds” dosyasını kullanıyoruz, ancak satır listesinin parametreli tarihle uyumlu olması için bir tarih damgası olması uygun olacaktır.\n\n\n\n\n\n\n\n\n\nÖrme işlemi sonrası, varsayılan yazı tipi ve düzen ile son çıktı üretilir.\n\n\n\n\n\n\n\n\n\n\n\nparams olmadan parametreli hale getirme\nAyrı bir komut dosyasından render() ile bir R Markdown dosyası oluşturuyorsanız, params: kullanmadan parametreleştirmenin etkisini yaratabilirsiniz.\nÖrneğin, render() komutunu içeren R betiğinde, render() komutundan önce hastane ve tarihi iki R nesnesi (değeri) olarak basitçe tanımlayabilirsiniz. R Markdown’da, YAML’de bir params: bölümüne sahip olmanız gerekmez ve params\\(date yerine tarih nesnesine ve params\\)hospital yerine hastaneye başvururuz.\n\n# Bu, R Markdown'dan ayrı bir R betiğidir.\n\n# R nesnelerini tanımlayın\nhospital &lt;- \"Central Hospital\"\ndate &lt;- \"2021-04-10\"\n\n# R markdown oluşturun\nrmarkdown::render(input = \"create_output.Rmd\") \n\nBu yaklaşımı takip etmek, “parametrelerle öremeyeceğiniz”, GUI’yi kullanamayacağınız veya parametreler içinde örgü seçeneklerini ekleyemeyeceğiniz anlamına gelir. Bununla birlikte, avantajlı olabilecek daha basit koda izin verir.",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Markdown ile Raporlar</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.tr.html#döngülü-raporlar",
    "href": "new_pages/rmarkdown.tr.html#döngülü-raporlar",
    "title": "40  R Markdown ile Raporlar",
    "section": "40.7 Döngülü raporlar",
    "text": "40.7 Döngülü raporlar\nHer yetki alanı/birim için bir rapor üretmek için girdi parametrelerini değiştirerek bir raporu birden çok kez çalıştırmak isteyebiliriz. Bu, yineleme, döngü ve listeler sayfasında ayrıntılı olarak açıklanan yineleme araçları kullanılarak yapılabilir. Seçenekler, purrr paketini veya aşağıda açıklandığı gibi bir for döngüsünün kullanımını içerir.\nAşağıda, ilgili tüm hastaneler için bir gözetim raporu oluşturmak için basit bir for döngüsü kullanıyoruz. Bu, tek bir komutla yapılır (hastane parametresini hastaneler için birer birer manuel olarak değiştirmek yerine). Raporları işleme komutu, Rmd raporunun dışında ayrı bir komut dosyasında bulunmalıdır. Bu komut dosyası aynı zamanda “dönüştürülecek” tanımlanmış nesneleri - bugünün tarihini ve döngünün uygulanacağı hastane adları vektörünü içerecektir.\n\nhospitals &lt;- c(\"Central Hospital\",\n                \"Military Hospital\", \n                \"Port Hospital\",\n                \"St. Mark's Maternity Hospital (SMMH)\") \n\nDaha sonra, hastane vektöründeki her değer için komut çalıştıran bir döngü kullanarak bu değerlere render() fonksiyonunu uygularız. i harfi, yinelemede kullanılmakta olan hastanenin dizin konumunu (1 ila 4) temsil eder, öyle ki hospital_list[1] “Merkez Hastane” olur. Bu bilgi, render() komutunda iki yerde sağlanır:\n\nDosya adında. 10 Nisan 2021’de oluşturulan ilk yinelemenin dosya adı, çalışma dizininin ‘çıktı’ alt klasörüne kaydedilen “Report_Central Hospital_2021-04-10.docx” olacak şekilde belirlenmiştir.\nparams = argümanına. Rmd, params$hospital değeri çağrıldığında dahili olarak hastane adını kullanır (veri setini yalnızca belirli bir hastaneye filtrelemek amacıyla). Bu örnekte, her hastane için bir tane olmak üzere dört dosya oluşturulacaktır.\n\n\nfor(i in 1:length(hospitals)){\n  rmarkdown::render(\n    input = \"surveillance_report.Rmd\",\n    output_file = str_glue(\"output/Report_{hospitals[i]}_{Sys.Date()}.docx\"),\n    params = list(hospital  = hospitals[i]))\n}",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Markdown ile Raporlar</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.tr.html#şablonlar",
    "href": "new_pages/rmarkdown.tr.html#şablonlar",
    "title": "40  R Markdown ile Raporlar",
    "section": "40.8 Şablonlar",
    "text": "40.8 Şablonlar\nİstediğiniz biçimlendirmeyi içeren bir şablon belge kullanarak, Rmd çıktısının nasıl görüneceğinin estetiğini ayarlayabilirsiniz. Örneğin, istenen boyutlara, filigranlara (watermark), arka planlara ve yazı tiplerine sahip sayfaları/slaytları içeren bir MS Word veya Powerpoint dosyası oluşturabilirsiniz.\n\nWord belgeleri\nBir şablon oluşturmak için, yeni bir kelime word başlatın (veya size uygun formatta mevcut bir çıktıyı kullanın) ve stilleri tanımlayarak yazı tiplerini düzenleyin. Stillerde, Başlık 1, 2 ve 3 çeşitli markdown başlık seviyelerine atıfta bulunur (sırasıyla # Başlık 1, ## Başlık 2 ve ### Başlık 3). Paragrafın yanı sıra yazı tipi biçimlendirmesini de değiştirmek için stile sağ tıklayın ve ’değiştir’e tıklayın (örneğin, boşluk bırakmaya yardımcı olabilecek belirli stillerden önce sayfa ayrımları ekleyebilirsiniz). Kenar boşlukları, sayfa boyutu, başlıklar vb. gibi Word belgesinin diğer ayarları, üzerinde çalıştığınız normal bir kelime belgesi gibi doğrudan değiştirilebilir.\n\n\n\n\n\n\n\n\n\n\n\nPowerpoint belgeleri\nYukarıdaki gibi, yeni bir slayt seti oluşturun veya istenen formatta mevcut bir powerpoint dosyasını kullanın. Daha fazla düzenleme için, ‘Görünüm’ ve ‘Asıl Slaytın’ üzerine tıklayın. Buradan, metin kutularındaki metin biçimlendirmesini ve ayrıca genel sayfa için arka plan/sayfa boyutlarını düzenleyerek “ana” slayt görünümünü değiştirebilirsiniz.\n\n\n\n\n\n\n\n\n\nNe yazık ki, powerpoint dosyalarını düzenlemek biraz daha az esnektir: • Birinci düzey başlık (# Başlık 1) otomatik olarak yeni bir slaydın başlığı olur, • Bir ## Başlık 2 metni altyazı olarak değil, slaydın ana metin kutusundaki metin olarak görünecektir (Ana görünümü değiştirmenin bir yolunu bulamazsanız). • Çıktı alınan grafikler ve tablolar otomatik olarak yeni slaytlara geçecektir. Bunları birleştirmeniz gerekecektir, örneğin ggplot’ları birleştirmek için patchwork fonksiyonu, aynı sayfada görünmelerini sağlar. Birden çok görüntüyü tek bir slayta yerleştirmek için patchwork paketini kullanma hakkında [blog post] (https://mattherman.info/blog/ppt-patchwork/) gönderisine bakın. Powerpoint sunumlarıyla daha derinlemesine çalışacak bir araç için officer paketine officer package bakın.\n\n\nŞablonların YAML’e entegrasyonu\nBir şablon hazırlandıktan sonra, ilgili detaylar Rmd’nin YAML’sine ‘çıktı’ satırının altına ve belge tipinin belirtildiği yerin altına (ayrı bir satır olarak) eklenebilir. Not referans_doc, powerpoint slayt şablonları için kullanılabilir.\nŞablonu Rmd dosyasının bulunduğu klasöre (aşağıdaki örnekte olduğu gibi) veya içindeki bir alt klasöre kaydetmek en kolay yoldur.\n---\ntitle: Surveillance report\noutput: \n word_document:\n  reference_docx: \"template.docx\"\nparams:\n date: 2021-04-10\n hospital: Central Hospital\ntemplate:\n \n---\n\n\nHTML dosyalarının formatlanması\nHTML dosyaları şablon kullanmaz, ancak YAML içinde yapılandırılmış stiller içerebilir. HTML’ler etkileşimli ve esnek belgelerdir. Burada bazı temel seçenekleri ele alıyoruz.\n• Table of contents-İçindekiler): Aşağıda toc: true ile bir içindekiler tablosu ekleyebilir ve ayrıca toc_float: true ile siz kaydırdıkça görüntülenebilir formda olmasını (“kayan-floats”) belirtebiliriz.\n• Themes-Temalar: Bootswatch tema kitaplığından gelen önceden hazırlanmış bazı temalara başvurabiliriz. Aşağıdaki örnekte cerulean kullanıyoruz. Diğer seçenekler şunlardır: ournal, flatly, darkly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex ve yeti.\n• Highlight-Vurgula: Bu seçeneği yapılandırmak, vurgulanan metnin görünümünü değiştirir (örneğin, kod parçaları). Desteklenen stiller arasında default, tango, pygments, kate, monochrome, espresso, zenburn, haddock, breezedark ve textmate. bulunur.\nYukarıdaki seçeneklerin YAML’ye nasıl entegre edileceğine dair bir örnek.\n---\ntitle: \"HTML example\"\noutput:\n  html_document:\n    toc: true\n    toc_float: true\n    theme: cerulean\n    highlight: kate\n    \n---\nAşağıda, her ikisi de kayan formda içindekiler tablolarına sahip, ancak farklı tema ve vurgulama stilleri seçilen iki HTML çıktısı örneği verilmiştir:",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Markdown ile Raporlar</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.tr.html#dinamik-içerik",
    "href": "new_pages/rmarkdown.tr.html#dinamik-içerik",
    "title": "40  R Markdown ile Raporlar",
    "section": "40.9 Dinamik içerik",
    "text": "40.9 Dinamik içerik\nBir HTML çıktısında, rapor içeriğiniz dinamik olabilir. Aşağıda bazı örnekler verilmiştir:\n\nTablolar\nBir HTML raporunda, içeriğin dinamik olması için filtreler ve kaydırma çubukları ile veri çerçevesi / tibble yazdırabilirsiniz. Bu özelliği sunan birkaç paket mevcuttur.\nBunu DT paketiyle yapmak için, bu el kitabında kullanıldığı gibi, şöyle bir kod parçası ekleyebilirsiniz:\n\n\n\n\n\n\n\n\n\ndatatable() fonksiyonu, sağlanan veri çerçevesini okuyucu için dinamik bir tablo olarak yazdıracaktır. Tablonun en sol tarafını basitleştirmek için satır adları için rownames = argümanını FALSE-YANLIŞ olarak ayarlayabilirsiniz. filter = “top”, her sütun üzerinde bir filtre sağlar. option() fonksiyonunun argümanlar kısmına diğer özelliklerin bir listesini girin. Aşağıda iki tane argüman yer almaktadır: pageLength = 5, görünen satır sayısını 5 olarak ayarlar (kalan satırlar oklar arasında gezinerek görüntülenebilir) ve scrollX=TRUE tablonun altında bir kaydırma çubuğu etkinleştirir (sağa çok fazla uzanan sütunlar için).\nVeri setiniz çok büyükse, veri çerçevesini head() içine sararak yalnızca en üstteki X sayıdaki satırları görüntülemeyi düşünün.\n\n\nHTML araçları\nHTML widgets for R R için HTML widget’ları, JavaScript kitaplıklarını kullanarak artırılmış etkileşim sağlayan özel bir R paketleri sınıfıdır. Bu paketleri HTML R Markdown çıktılarına gömebilirsiniz.\nBu widget’ların bazı yaygın örnekleri şunları içerir:\n• Plotly (bu el kitabı sayfasında ve [İnteraktif grafikler] sayfasında kullanılır) • visNetwork (bu el kitabının İletim Zincirleri sayfasında kullanılır) • Leaflet (bu el kitabının GIS Temelleri sayfasında kullanılır) • dygraphs (zaman serisi verilerini etkileşimli olarak göstermek için kullanılır) • DT (datatable()) (filtre, sıralama vb. ile dinamik tabloları göstermek için kullanılır)\nPlotly’den ggplotly() fonksiyonunun kullanımı özellikle kolaydır. Etkileşimli grafikler sayfasına bakın.",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Markdown ile Raporlar</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.tr.html#kaynaklar",
    "href": "new_pages/rmarkdown.tr.html#kaynaklar",
    "title": "40  R Markdown ile Raporlar",
    "section": "40.10 Kaynaklar",
    "text": "40.10 Kaynaklar\nDaha fazla bilgi şuralarda bulunabilir:\n\nhttps://bookdown.org/yihui/rmarkdown/\nhttps://rmarkdown.rstudio.com/articles_intro.html\n\n• Markdown vs knitr vs R markdown’ın için iyi bir açıklama: https://stackoverflow.com/questions/40563479/relationship-between-r-markdown-knitr-pandoc-and-bookdown",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>R Markdown ile Raporlar</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.tr.html",
    "href": "new_pages/reportfactory.tr.html",
    "title": "41  Rutin raporların düzenlenmesi",
    "section": "",
    "text": "41.1 Hazırlık",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Rutin raporların düzenlenmesi</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.tr.html#hazırlık",
    "href": "new_pages/reportfactory.tr.html#hazırlık",
    "title": "41  Rutin raporların düzenlenmesi",
    "section": "",
    "text": "Paketleri yüklemek\nRStudio içinden, Github’dan reportfactory paketinin en son sürümünü yükleyin.\nBunu, Github’dan en son sürümün yüklenmesini zorlayacak olan p_load_current_gh() ile pacman paketi aracılığıyla yapabilirsiniz. Github organizasyonunu (reconverse) ve veri havuzunu (rapor fabrikası) belirten “reconverse/reportfactory” karakter dizisini sağlayın. Alternatif olarak remotes paketinden install_github() da kullanabilirsiniz.\n\n# Paketin en son sürümünü Github'dan yükleyin ve kurun\npacman::p_load_current_gh(\"reconverse/reportfactory\")\n# remotes::install_github(\"reconverse/reportfactory\") # alternatif yöntem",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Rutin raporların düzenlenmesi</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.tr.html#yeni-fabrika",
    "href": "new_pages/reportfactory.tr.html#yeni-fabrika",
    "title": "41  Rutin raporların düzenlenmesi",
    "section": "41.2 Yeni fabrika",
    "text": "41.2 Yeni fabrika\nYeni bir fabrika oluşturmak için new_factory() fonksiyonunu çalıştırın. Bu, yeni bir bağımsız R proje klasörü oluşturacaktır. Varsayılan olarak:\n\nFabrika çalışma dizininize eklenecektir.\nFabrika R projesinin adı “new_factory.Rproj” olarak adlandırılacaktır.\nRStudio oturumunuz bu R projesine “taşınacak”tır\n\n\n# Bu, fabrikayı çalışma dizininde yaratacaktır.\nnew_factory()\n\nFabrikanın içine baktığınızda, alt klasörlerin ve bazı dosyaların otomatik olarak oluşturulduğunu görebilirsiniz.\n\n\n\n\n\n\n\n\n\n\nreport_sources klasörü, raporlarınızı oluşturan R Markdown komut dosyalarınızı tutacaktır.\noutputs klasörü, rapor çıktılarını tutmak için(ör. HTML, Word, PDF, vb.)\nscripts klasörü, diğer R komut dosyalarını depolamak için kullanılabilir (örneğin, Rmd komut dosyalarınız tarafından sağlananlar)\ndata klasörü verilerinizi tutmak için kullanılabilir (“ham” ve “temiz” alt klasörler dahildir)\nBir .here dosyası, böylece alt klasörlerdeki dosyaları bu kök klasörle ilişkilerine göre çağırmak için here paketini kullanabilirsiniz (ayrıntılar için [R projeleri] sayfasına bakabilirsiniz)\nBu R projesini bir Github deposuna bağlamanız durumunda bir gitignore dosyası oluşturulur (bkz. [Sürüm kontrolü ve Github ile işbirliği])\nGithub deposu kullanıyorsanız, boş bir BENİOKU dosyası oluşur.\n\nUYARI: bilgisayarınızın ayarına bağlı olarak, “.here” gibi dosyalar var olabilir ancak görünmez olabilir.\nVarsayılan ayarlardan, ‘new_factory()’ komutuyla ayarlamak isteyebileceğiniz birkaç tanesi aşağıdadır:\n\nfactory = - Fabrika klasörü için bir ad girin (varsayılan “new_factory”)\npath = - Yeni fabrika için bir dosya yolu belirleyin (varsayılan çalışma dizinidir)\nreport_sources = R Markdown komut dosyalarını içeren alt klasör için alternatif bir ad sağlayın (varsayılan “report_sources”)\noutputs = Rapor çıktılarını tutan klasör için alternatif bir ad sağlayın (varsayılan “outputs”)\n\nDeğişkenlerin tam listesi için “?new_factory” konusuna bakabilirsiniz.\nYeni fabrika oluşturduğunuzda, R oturumunuz yeni R projesine aktarılır, bu nedenle reportfactory paketini tekrar yüklemelisiniz.\n\npacman::p_load(reportfactory)\n\nArtık fabrikadaki iç yapıyı (tüm klasörler ve dosyalar) görmek için factory_overview() komutunu çalıştırabilirsiniz.\n\nfactory_overview()            # fabrikaya genel bakışı konsola yazdır\n\nFabrika klasörlerinin ve dosyalarının aşağıdaki “ağacı” R konsoluna yazdırılır. “Veri” klasöründe “ham” ve “temiz” veriler ve örnek CSV verileri için alt klasörler bulunduğunu unutmayın. Ayrıca “report_sources” klasöründe “example_report.Rmd” vardır.",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Rutin raporların düzenlenmesi</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.tr.html#bir-rapor-oluşturun",
    "href": "new_pages/reportfactory.tr.html#bir-rapor-oluşturun",
    "title": "41  Rutin raporların düzenlenmesi",
    "section": "41.3 Bir rapor oluşturun",
    "text": "41.3 Bir rapor oluşturun\nFabrika R projesinin içinden, normalde yaptığınız gibi bir R Markdown raporu oluşturun ve bunu “report_sources” klasörüne kaydedin. Talimatlar için [R Markdown][R Markdown ile Raporlar] sayfasına bakabilirsiniz. Örnek olması açısından, fabrikaya aşağıdakileri ekledik:\n\n“report_sources” klasörüne kaydedilen “daily_sitrep.Rmd” başlıklı yeni bir R işaretleme komut dosyası\nRapor (“linelist_cleaned.rds”) verileri, “data” klasörü içindeki “clean” alt klasörüne kaydedilir\n\nfactory_overview() kullanarak “report_sources” klasöründeki R Markdown’ımızı ve “clean” veri klasöründeki (vurgulanan) veri dosyasını görebiliriz:\n\n\n\n\n\n\n\n\n\nAşağıda, R Markdown “daily_sitrep.Rmd” başlangıcının bir ekran görüntüsü bulunmaktadır. YAML başlığı “output: html_document” aracılığıyla çıktı biçiminin HTML olarak ayarlandığını görebilirsiniz.\n\n\n\n\n\n\n\n\n\nBu basit komut dosyasında şu komutlar vardır:\n\nGerekli paketleri yükleyin\nhere paketindeki bir dosya yolunu kullanarak satır listesi verilerini içe aktarın (daha fazlasını [İçe aktarma ve dışa aktarma] sayfasından okuyun)\n\n\nlinelist &lt;- import(here(\"data\", \"clean\", \"linelist_cleaned.rds\"))\n\n\nVakaların bir özet tablosunu yazdırın ve bunu bir .csv dosyası olarak export() ile dışa aktarın\nBir salgın eğrisi yazdırın ve ggsave() ile .png dosyası olarak dışa aktarın\n\nBu komutla “report_sources” klasöründeki yalnızca R Markdown raporlarının listesini inceleyebilirsiniz:\n\nlist_reports()",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Rutin raporların düzenlenmesi</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.tr.html#derlemek-compile",
    "href": "new_pages/reportfactory.tr.html#derlemek-compile",
    "title": "41  Rutin raporların düzenlenmesi",
    "section": "41.4 Derlemek (Compile)",
    "text": "41.4 Derlemek (Compile)\nBir rapor fabrikasında, bir R Markdown raporunu “derlemek”, .Rmd komut dosyasının çalıştırılacağı ve çıktının üretileceği anlamına gelir (YAML komut dosyasında belirtildiği gibi, örneğin HTML, Word, PDF, vb. olarak).\nFabrika, “outputs” klasöründeki çıktılar için otomatik olarak tarih ve zaman damgalı bir klasör oluşturacaktır.\nRaporun kendisi ve komut dosyası tarafından üretilen tüm dışa aktarılan dosyalar (örn. csv, png, xlsx) bu klasöre kaydedilecektir. Ek olarak, Rmd betiğinin kendisi bu klasöre kaydedilecektir, böylece betiğin o sürümünün bir kaydı olur.\nBu, çıktıları Rmd komut dosyasının konumuna kaydeden “örülmüş” bir R Markdown’ın normal davranışıyla çelişir. Bu varsayılan davranış, kalabalık, dağınık klasörlere neden olabilir. Fabrika, sık sık rapor çalıştırması gerektiğinde organizasyonu iyileştirmeyi amaçlar.\n\nAdına göre derleyin\nBelirli bir raporu ‘compile_reports()’ çalıştırarak ve Rmd komut dosyası adını (.Rmd uzantısı olmadan) ‘reports =’ olarak sağlayarak derleyebilirsiniz. Basit olması için, reports = kısmını atlayabilir ve R Markdown adını aşağıdaki gibi tırnak işaretleri içinde yazabilirsiniz.\n\n\n\n\n\n\n\n\n\nBu komut, yalnızca “daily_sitrep.Rmd” raporunu derleyerek, HTML raporunu ve .csv tablosunu ve .png epicurve dışa aktarmalarını, “outputs” klasörü içinde, rapora özel tarih ve zaman damgalı bir alt klasöre kaydeder.\n.Rmd uzantısını sağlamayı seçerseniz, uzantıyı dosya adına kaydedilirken doğru şekilde yazmanız gerektiğini unutmayın (.rmd ve .Rmd).\nAyrıca, derlerken, “report_sources” klasöründe geçici olarak birkaç dosyanın görünebileceğini unutmayın - ancak doğru “outputs” klasörüne aktarıldıkları için kısa sürede kaybolacaklardır.\n\n\nNumarasına göre derleyin\nAyrıca, reports = için bir sayı veya sayı vektörü sağlayarak derlenecek Rmd betiğini de belirtebilirsiniz. Rakamlar, list_reports() çalıştırdığınızda raporların göründüğü sıraya göre hizalanmalıdır.\n\n# İkinci ve dördüncü Rmds'yi \"report_sources\" klasöründe derleyin\ncompile_reports(reports = c(2, 4))\n\n\n\nTümünü Derleyin\n“report_sources” klasöründeki tüm R Markdown raporlarını, reports = değişkenini TRUE olarak ayarlayarak derleyebilirsiniz.\n\n\n\n\n\n\n\n\n\n\n\nAlt klasöründen derleyin\n“report_sources” klasörüne alt klasörler ekleyebilirsiniz. Bir alt klasörden R Markdown raporu çalıştırmak için, klasörün adını subfolder = olarak sağlamanız yeterlidir. Aşağıda, “report_sources” alt_klasöründe yaşayan bir Rmd raporunu derlemek için bir kod örneği verilmiştir.\n\ncompile_reports(\n     reports = \"summary_for_partners.Rmd\",\n     subfolder = \"for_partners\")\n\nAşağıdaki gibi sonunda bir eğik çizgi ile reports = alt klasör adını sağlayarak bir alt klasör içindeki tüm Rmd raporlarını derleyebilirsiniz.\n\ncompile_reports(reports = \"for_partners/\")\n\n\n\nParametrelendirme\n[R Markdown ile Raporlar] sayfasında belirtildiği gibi, belirtilen parametrelerle raporlar çalıştırabilirsiniz. Bu parametreleri, ‘params =’ değişkeni aracılığıyla ‘compile_reports()’ öğesine bir liste olarak iletebilirsiniz. Örneğin, bu kurgusal raporda, R Markdown raporlarına sağlanan üç parametre vardır.\n\ncompile_reports(\n  reports = \"daily_sitrep.Rmd\",\n  params = list(most_recent_data = TRUE,\n                region = \"NORTHERN\",\n                rates_denominator = 10000),\n  subfolder = \"regional\"\n)\n\n\n\n“Çalışma dosyası” kullanma\nÇalıştırılacak birden fazla raporunuz varsa, tüm ‘compile_reports()’ komutlarını içeren bir R betiği oluşturmayı düşünün. Bir kullanıcı bu R betiğindeki tüm komutları basitçe çalıştırabilir ve tüm raporlar derlenecektir. Bu “run-file” dosyasını “scripts” klasörüne kaydedebilirsiniz.",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Rutin raporların düzenlenmesi</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.tr.html#çıktılar",
    "href": "new_pages/reportfactory.tr.html#çıktılar",
    "title": "41  Rutin raporların düzenlenmesi",
    "section": "41.5 Çıktılar",
    "text": "41.5 Çıktılar\nRaporları birkaç kez derledikten sonra, “outputs” klasörü şöyle görünebilir (açıklık için vurgular eklendi):\n\n\n\n\n\n\n\n\n\n\n“Outputs” içerisinde her bir Rmd raporu için alt klasörler oluşturulmuştur.\nBunların içinde, her benzersiz derleme için başka alt klasörler oluşturulmuştur.\n\nBunlar tarih ve zaman damgalıdır (“2021-04-23_T11-07-36”, 23 Nisan 2021, 11:07:36 anlamına gelir)\nTarih/zaman damgası biçimini düzenleyebilirsiniz. ?compile_reports konusuna bakabilirsiniz.\n\nHer bir tarih/saat derlenmiş klasöründe, rapor çıktısı (ör. HTML, PDF, Word) Rmd betiği (sürüm kontrolü!) ve dışa aktarılan diğer dosyalar (ör. table.csv, epidemi_curve.png) ile birlikte depolanır.\n\n“daily_sitrep” raporu için tarih/saat damgalı klasörlerden birinin içindeki bir görünüm buradadır. Dosya yolu, vurgu için sarı renkle vurgulanmıştır.\n\n\n\n\n\n\n\n\n\nSon olarak, aşağıda HTML rapor çıktısının bir ekran görüntüsü bulunmaktadır.\n\n\n\n\n\n\n\n\n\nÇıktıların listesini gözden geçirmek için list_outputs() kullanabilirsiniz.",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Rutin raporların düzenlenmesi</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.tr.html#muhtelif-içerikler",
    "href": "new_pages/reportfactory.tr.html#muhtelif-içerikler",
    "title": "41  Rutin raporların düzenlenmesi",
    "section": "41.6 Muhtelif İçerikler",
    "text": "41.6 Muhtelif İçerikler\n\nKnit\nİsterseniz “knit” düğmesine basarak R Markdown raporlarınızdan birini hala “örebilirsiniz”. Bunu yaparsanız, varsayılan olarak, çıktılar Rmd’nin kaydedildiği klasörde - “report_sources” klasöründe görünecektir. reportfactory’nin önceki sürümlerinde, “report_sources” içinde Rmd olmayan dosyaların bulunması derlemeyi engellerdi, ancak artık durum böyle değil. compile_reports() komutunu çalıştırabilirsiniz ve herhangi bir hata oluşmaz.\n\n\nBetikler\n.Rmd komut dosyalarınız tarafından sağlanan “runfiles” veya .R komut dosyalarını depolamak için “scripts” klasörünü kullanmanızı öneririz. Kodunuzu birkaç dosyada nasıl yapılandıracağınıza ilişkin ipuçları için [R Markdown][R Markdown ile Raporlar] hakkındaki sayfaya bakabilirsiniz.\n\n\nEkstralar\n\nreportfactory ile, tüm fabrikadaki tüm raporlarda gerekli tüm paketleri listelemek için ‘list_deps()’ fonksiyonunu kullanabilirsiniz.\nGeliştirme aşamasında, raporların oluşturulmasında size yardımcı olacak daha fazla yardımcı fonksiyon sunan rfextras adlı bir paket vardır, örneğin:\n\nload_scripts() - belirli bir klasördeki tüm .R komut dosyalarını kaynaklar/yükler (varsayılan olarak “scripts” klasörü)\nfind_latest() - bir dosyanın en son sürümünü bulur (örneğin, en son veri kümesi)",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Rutin raporların düzenlenmesi</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.tr.html#kaynaklar",
    "href": "new_pages/reportfactory.tr.html#kaynaklar",
    "title": "41  Rutin raporların düzenlenmesi",
    "section": "41.7 Kaynaklar",
    "text": "41.7 Kaynaklar\nreportfactory paketleri Github sayfası\nrfextras paketleri Github sayfası",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Rutin raporların düzenlenmesi</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.tr.html",
    "href": "new_pages/flexdashboard.tr.html",
    "title": "42  R Markdown ile gösterge panelleri",
    "section": "",
    "text": "42.1 Hazırlık",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>R Markdown ile gösterge panelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.tr.html#hazırlık",
    "href": "new_pages/flexdashboard.tr.html#hazırlık",
    "title": "42  R Markdown ile gösterge panelleri",
    "section": "",
    "text": "Paketlerin yüklenmesi\nBu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’ın p_load() fonksiyonunu vurguluyoruz. Ayrıca, temel R’dan library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R’ın temelleri sayfasına bakın.\n\npacman::p_load(\n  rio,             # verinin içe / dışa aktarımı   \n  here,            # dosyaları bul\n  tidyverse,       # veri yönetimi ve görselleştirme\n  flexdashboard,   # R Markdown raporlarının panel sürümleri\n  shiny,           # interaktif figürler\n  plotly           # interaktif figürler\n)\n\n\n\nVerileri içe aktarın\nSimüle edilmiş bir Ebola salgını vakalarının veri setini içe aktarıyoruz. Devam etmek istiyorsanız, “temiz” satır listesini (.rds dosyası olarak) indirmek için tıklayın. Verileri rio paketinden import() fonksiyonuyla içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için İçe Aktarma ve Dışa Aktarma sayfasına bakabilirsiniz).click to download the “clean” linelist\n\n# satır listesini içe aktarma\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nSatır listesinin ilk 50 satırı aşağıda gösterilmiştir.",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>R Markdown ile gösterge panelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.tr.html#yeni-bir-r-markdown-oluştur",
    "href": "new_pages/flexdashboard.tr.html#yeni-bir-r-markdown-oluştur",
    "title": "42  R Markdown ile gösterge panelleri",
    "section": "42.2 Yeni bir R Markdown oluştur",
    "text": "42.2 Yeni bir R Markdown oluştur\nPaketi kurduktan sonra, Dosya &gt; Yeni dosya &gt; R Markdown yolunu kullanarak yeni bir R Markdown dosyası oluşturun.\n\n\n\n\n\n\n\n\n\nAçılan pencerede “From Template-Şablondan”ı seçin ve “Flex Dashboard” şablonunu seçin. Daha sonra belgeyi adlandırmanız istenecektir. Bu sayfanın örneğinde, R Markdown’ımızı “outbreak_dashboard.Rmd” olarak adlandıracağız.",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>R Markdown ile gösterge panelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.tr.html#komutlar",
    "href": "new_pages/flexdashboard.tr.html#komutlar",
    "title": "42  R Markdown ile gösterge panelleri",
    "section": "42.3 Komutlar",
    "text": "42.3 Komutlar\nKomut dosyası bir R Markdown komut dosyasıdır ve bu nedenle R Markdown ile Raporlar sayfasında açıklananla aynı bileşenlere ve organizasyona sahiptir. Bunları kısaca yeniden inceleyeceğiz ve diğer R Markdown çıktı biçimlerinden farklılıklarını vurgulayacağız.\n\nYAML\nKomut dosyasının en üstünde “YAML” başlığı bulunur. Bu kısım, üç tire ile başlamalı — ve üç tire ile kapatılmalıdır —. YAML parametreleri anahtar:değer çiftleri halinde gelir. YAML’de iki nokta üst üste işaretinin girintisi ve yerleşimi önemlidir - anahtar:değer çiftleri iki nokta üst üste ile ayrılır (eşittir işaretleri değil!).\nYAML, belge için meta verilerle başlamalıdır. Bu birincil YAML parametrelerinin (girintisiz) sırası önemli değildir. Örneğin:\n\ntitle: \"My document\"\nauthor: \"Me\"\ndate: \"`r Sys.Date()`\"\n\nYAML değerlerinde R kodunu, satır içi kod gibi (backticks içinde r’den önce gelir) veya tırnak işaretleri içine koyarak (Tarih için yukarıya bakın) kullanabilirsiniz. Üretilecek dosyanın türünü bir YAML parametresi çıktısı belirtir. (ör. html_document, pdf_document, word_document veya powerpoint_presentation).\nFlexdashboard için bu parametre değeri biraz kafa karıştırıcıdır - output:flexdashboard::flex_dashboard olarak ayarlanmalıdır. Tek ve çift sayıda iki nokta üst üste ve alt çizgiye noktalama işaretlerine dikkat edin. Bu YAML çıktı parametresini genellikle ek bir iki nokta üst üste ve girintili alt parametreler izler (aşağıdaki orientation:-oryantasyon: ve vertical_layout: -dikey_düzen: parametrelere bakın).\n\ntitle: \"My dashboard\"\nauthor: \"Me\"\ndate: \"`r Sys.Date()`\"\noutput:\n  flexdashboard::flex_dashboard:\n    orientation: rows\n    vertical_layout: scroll\n\nYukarıda gösterildiği gibi, alt parametreler için girintiler (2 boşluk) kullanılır. Bu durumda, birincilden sonra anahtar:değer: gibi ek bir iki nokta üst üste koymayı unutmayın.Uygunsa, mantık değerleri YAML’de küçük harfle (true, false, null) verilmelidir. İki nokta üst üste karakteri değerinizin bir parçasıysa (örneğin başlıkta), değeri tırnak içine alın. Aşağıdaki bölümlerdeki örneklere bakın.\n\n\nKod parçaları\nBir R Markdown komut dosyası birden çok kod “parçası” içerebilir - bunlar komut dosyasının çok satırlı R kodu yazabileceğiniz alanlarıdır ve tıpkı mini R komut dosyaları gibi çalışırlar.\nKod parçaları, içinde küçük bir “r” harfi bulunan üç ters tik işareti ve küme parantezleri ile oluşturulur. Kod parçası, üç ters tik ile kapatılır. Kendiniz yazarak, “Ctrl + Alt + i” (veya Mac’te Cmd + Shift + r) klavye kısayolunu kullanarak veya komut dosyası düzenleyicinizin en üstünde ‘yeni bir kod parçası ekle’ simgesini tıklayarak yeni bir kod parçası oluşturabilirsiniz.. Aşağıda birçok örnek verilmiştir.\n\n\nAnlatı metni\nBir R kodu “parçası” dışında, anlatı metni de yazabilirsiniz. R Markdown ile Raporlar sayfasında açıklandığı gibi, metni bir yıldız işaretiyle (*) çevreleyerek italik veya iki yıldız işaretiyle (**) çevreleyerek kalın yazabilirsiniz. Madde işaretleri ve numaralandırma düzenlerinin yeni satırlara, girintilere ve iki boşlukla bir satırı bitirmeye duyarlı olduğunu hatırlayın.\nAyrıca satır içi R kodunu, R Markdown ile Raporlar sayfasında açıklandığı gibi, kodu ters tiklerle çevreleyerek ve komutu “r”: 1+1 ile başlatarak metne ekleyebilirsiniz (yukarıdaki tarih içeren örneğe bakın).\n\n\nBaşlıklar\nR Markdown ile Raporlar sayfasında açıklandığı gibi, farklı sayıda hash sembolü ile farklı başlık seviyeleri oluşturulur.\nFlexdashboard’da, birincil başlık (#) gösterge tablosunun bir “sayfasını” oluşturur. İkinci düzey başlıklar (##), oryantasyonunuza bağlı olarak bir sütun veya satır oluşturur: Parametre (aşağıdaki ayrıntılara bakın). Üçüncü düzey başlıklar (###) çizimler, çizelgeler, tablolar, metin vb. için paneller oluşturur.\n# Birinci düzey başlık (sayfa)\n\n## İkinci düzey başlık (satır veya sütun)\n\n### Üçüncü düzey başlık (çizim, çizelge vb. için bölme)",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>R Markdown ile gösterge panelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.tr.html#bölüm-özellikleri",
    "href": "new_pages/flexdashboard.tr.html#bölüm-özellikleri",
    "title": "42  R Markdown ile gösterge panelleri",
    "section": "42.4 Bölüm Özellikleri",
    "text": "42.4 Bölüm Özellikleri\nNormal bir R Markdown dosyasında olduğu gibi, bir başlıktan sonra, küme parantezleri { } içinde anahtar=değer seçeneklerini ekleyerek gösterge tablonuzun bölümlerine uygulanacak özellikleri belirleyebilirsiniz. Örneğin, tipik bir HTML R Markdown raporunda, ## Başlığım {.tabset} ile alt başlıkları sekmeler halinde düzenleyebilirsiniz. Bu niteliklerin, komut dosyasının metin bölümünde bir başlıktan sonra yazıldığını unutmayın. Bunlar, out.height = gibi R kodu parçalarının üstüne eklenen knitr seçeneklerinden farklıdır.\nFlexdashboard’a özgü bölüm özellikleri şunları içerir: • {data-orientation=} Satırlara veya sütunlara göre ayarlama. Gösterge panelinizde birden fazla sayfa varsa, oryantasyonu belirtmek için bu özelliği her sayfaya ekleyin (düzen bölümünde daha ayrıntılı açıklanmıştır). • {data-width=} ve {data-height=}, aynı boyutta (yatay veya dikey) düzenlenen grafiklerin, sütunların, satırların göreli boyutunu ayarlar. Flexbox motoru sayesinde mutlak boyutlar, herhangi bir görüntüleme cihazındaki alanı en iyi şekilde dolduracak şekilde ayarlanır. • Grafiklerin yüksekliği, YAML parametresini vertical_layout: fill (dolgu) olarak mı yoksa vertical_layout: scroll (kaydırma) olarak mı ayarladığınıza da bağlıdır. Kaydırılacak şekilde ayarlanırsa, şekil yüksekliği, R kodu öbeğindeki geleneksel fig.height = seçeneğini yansıtacaktır. • flexdashboard web sitesindeki tam boyut belgelerine bakın • {.hidden} Belirli bir sayfayı gezinme çubuğundan hariç tutmak için bunu kullanın • {data-navbar=} Bunu, bir gezinme çubuğu açılır menüsü içine yerleştirmek için sayfa düzeyinde bir başlıkta kullanın. Açılır menünün adını (tırnak içinde) belirtin. Aşağıdaki örneğe bakın.",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>R Markdown ile gösterge panelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.tr.html#layout",
    "href": "new_pages/flexdashboard.tr.html#layout",
    "title": "42  R Markdown ile gösterge panelleri",
    "section": "42.5 Yerleşim Düzeni",
    "text": "42.5 Yerleşim Düzeni\nKontrol panelinizin düzenini aşağıdaki şekillerde ayarlayın: • R Markdown başlıklarına sahip sayfalar, sütunlar/satırlar ve grafikler ekleyin (ör. #, ## veya ###) • YAML parametre yönünü ayarlayın: Satırlara veya sütunlara • Düzenin tarayıcıyı dolduracağını ya da kaydırmaya mı izin vereceğini belirtin • Belirli bir bölüm başlığına sekmeler ekleyin\n\nSayfalar\nR Markdown’daki birinci düzey başlıklar (#), gösterge tablosunun “sayfalarını” temsil edecektir. Varsayılan olarak sayfalar, gösterge tablosunun üst kısmındaki bir gezinme çubuğunda görünür.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSayfa başlığına {data-navmenu=} özelliğini ekleyerek sayfaları üst gezinme çubuğunda bir “menü” halinde gruplayabilirsiniz. Dikkatli olun - eşittir işaretinin etrafına boşluk eklemeyin, aksi takdirde çalışmaz!\n\n\n\n\n\n\n\n\n\nİşte betiğin ürettiği:\n\n\n\n\n\n\n\n\n\n{.sidebar} özelliği ekleyerek, bir sayfayı veya sütunu kontrol panelinin sol tarafında bir “kenar çubuğuna” da dönüştürebilirsiniz. Metni (herhangi bir sayfadan görüntülenebilir) veya entegre shiny etkileşiminiz varsa, kaydırıcılar veya açılır menüler gibi kullanıcı giriş kontrollerini eklemek faydalı olabilir.\n\n\n\n\n\n\n\n\n\nİşte betiğin ürettiği:\n\n\n\n\n\n\n\n\n\n\n\nOryantasyon\nİkinci düzey (##) R Markdown başlıklarınızın nasıl yorumlanması gerektiğini belirtmek için oryantasyon: yaml parametresini ayarlayın - oryantasyon: sütunlar (orientation: columns) veya oryantasyon: satırlar (orientation: rows) olarak.\nİkinci düzey başlıklar (##), bu yönlendirme ayarına göre yeni sütunlar veya satırlar olarak yorumlanacaktır.\nOryantasyon: sütunlar (orientation: columns) olarak ayarlarsanız, ikinci düzey başlıklar gösterge tablosunda yeni sütunlar oluşturur. Aşağıdaki gösterge paneli, toplam üç panel içeren iki sütun içeren bir sayfaya sahiptir. Sütunların göreli genişliğini aşağıda gösterildiği gibi {data-width=} ile ayarlayabilirsiniz.\n\n\n\n\n\n\n\n\n\nİşte betiğin ürettiği:\n\n\n\n\n\n\n\n\n\nOryantasyon: satırlar (orientation: rows)olarak ayarlarsanız, ikinci düzey başlıklar sütunlar yerine yeni satırlar oluşturur. Aşağıda, yukarıdakiyle aynı komut dosyası vardır, ancak oryantasyon: satırlar olarak ayarlanmıştır, böylece ikinci düzey başlıklar sütunlar yerine satırlar oluşturur. {data-height=} ile satırların göreli yüksekliğini aşağıda gösterildiği gibi ayarlayabilirsiniz.\n\n\n\n\n\n\n\n\n\nİşte betiğin ürettiği:\n\n\n\n\n\n\n\n\n\nKontrol panelinizde birden fazla sayfa varsa, her sayfanın başlığına {data-orientation=} özniteliğini ekleyerek (tırnak işaretleri olmadan satırları veya sütunları belirtin) seçili sayfanın yönünü belirleyebilirsiniz.\n\n\nSekmeler\nDiğer HTML R Markdown çıktılarında olduğu gibi içeriği {.tabset} özniteliği ile sekmelere bölebilirsiniz.\nBu özelliği istediğiniz başlıktan sonra eklemeniz yeterlidir. Bu başlığın altındaki alt başlıklar sekmeler halinde görüntülenecektir. Örneğin, aşağıdaki örnek komut dosyasında sağdaki 2. sütun (##), salgın eğrisi ve tablo bölmeleri (###) sekmelerde görüntülenecek şekilde değiştirilir.\nOryantasyonunuz satırlarsa, aynısını satırlarla da yapabilirsiniz.\n\n\n\n\n\n\n\n\n\nİşte betiğin ürettiği:",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>R Markdown ile gösterge panelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.tr.html#içerik-ekleme",
    "href": "new_pages/flexdashboard.tr.html#içerik-ekleme",
    "title": "42  R Markdown ile gösterge panelleri",
    "section": "42.6 İçerik Ekleme",
    "text": "42.6 İçerik Ekleme\nBir kontrol paneli oluşturmaya başlayalım. Basit panomuz 1 sayfa, 2 sütun ve 4 panelden oluşacaktır. Gösteri için panelleri parça parça inşa edeceğiz.\nMetin, ggplot’lar ve tablolar gibi standart R çıktılarını kolayca dahil edebilirsiniz (Sunum için Tablolar sayfasına bakın). Bunları, diğer herhangi bir R Markdown betiğinde yaptığınız gibi, bir R kod parçası içinde kodlayın.\nNot: Tamamlanmış Rmd komut dosyasını ve HTML gösterge tablosu çıktısını indirebilirsiniz - El kitabı ve verilerin indirilmesi sayfasına bakın.\n\nMetin\nMarkdown metnini yazabilir ve diğer herhangi bir R Markdown çıktısında olduğu gibi satır içi kod ekleyebilirsiniz. Ayrıntılar için R Markdown ile Raporlar sayfasına bakın.\nBu panele, en son hastaneye yatış tarihini ve salgında bildirilen vaka sayısını gösteren dinamik metin içeren bir özet metin paneli ekledik.\n\n\nTablo\nTablolar gibi çıktıları yazdıran R kodu parçalarını dahil edebilirsiniz. Ancak, tablolarınızı görüntülemek için knitr’den kable() fonksiyonunu kullanırsanız, çıktı en iyi şekilde görünecek ve pencere boyutuna yanıt verecektir. Flextable fonksiyonları, kısaltılmış/kesilmiş tablolar üretebilir. Örneğin, hastaneye göre vakaların özet bir tablosunu oluşturmak için aşağıda linelist()’i bir count() komutuyla besliyoruz. Sonuç olarak, tablo knitr::kable()’a yönlendirilir ve sağ tarafında bir kaydırma çubuğu bulunur. Panelinizi kable() ve kableExtra ile özelleştirme hakkında daha fazla bilgiyi burada bulabilirsiniz. buradan.\n\n\n\n\n\n\n\n\n\nİşte betiğin ürettiği:\n\n\n\n\n\n\n\n\n\nKullanıcının veri çerçevesinin “sayfalarını” filtrelemesine, sıralamasına ve/veya tıklamasına izin veren dinamik bir tablo oluşturmak istiyorsanız, aşağıdaki kodda olduğu gibi DT paketini ve onun datatable() fonksiyonunu kullanın.\nAşağıdaki örnek kod, veri çerçevesi satır listesi yazdırılır. Yatay alanı korumak için rownames = FALSE ve her sütunun üstünde filtreler olması için filter = “top” argümanını ayarlayabilirsiniz. options = argümanı diğer özelliklerin bir listesi verebilir. Aşağıda, 5 satır görünecek şekilde pageLength = argümanını ve kullanıcının yatay olarak kaydırmak için alttaki kaydırma çubuğunu kullanabilmesi için scrollX = argümanını ayarladık. class = ‘white-space: nowrap’ argümanı, her satırın yalnızca bir satır (birden çok satır değil) içermesini sağlar. Diğer olası argümanlar ve değerler hakkında buradan veya ?datatable komutunu girerek bilgi edinebilirsiniz.\n\nDT::datatable(linelist, \n              rownames = FALSE, \n              options = list(pageLength = 5, scrollX = TRUE), \n              class = 'white-space: nowrap' )\n\n\n\nGrafikler\nGrafikleri, bir R komut dosyasında olduğu gibi bir panel bölmesine yazdırabilirsiniz. Örneğimizde, iki basit komutla yaş grubuna göre bir “salgın eğrisi” oluşturmak için incidence2 paketini kullanıyoruz (bkz. Salgın eğriler sayfası). Ancak, ggplot()’u kullanabilir ve aynı şekilde bir grafik oluşturabilirsiniz.\n\n\n\n\n\n\n\n\n\nİşte betiğin ürettiği:\n\n\n\n\n\n\n\n\n\n\n\nİnteraktif grafikler\nAyrıca standart bir ggplot veya başka bir grafik nesnesini plotly paketinden ggplotly() fonksiyonuna iletebilirsiniz (İnteraktif grafikler sayfasına bakabilirsiniz). Bu, grafiğinizi interaktif hale getirecek, okuyucunun “yaklaştırmasına” ve her veri noktasının değerinin (bu senaryoda eğrideki haftalık vaka sayısı ve yaş grubu) üzerinde fareyle gezinerek göstermesine izin verecektir.\n\nage_outbreak &lt;- incidence(linelist, date_onset, \"week\", groups = age_cat)\nplot(age_outbreak, fill = age_cat, col_pal = muted, title = \"\") %&gt;% \n  plotly::ggplotly()\n\nGösterge panelinde bunun nasıl göründüğü aşağıda açıklanmıştır(gif). Bu interaktif fonksiyon, paneli statik bir dosya olarak e-posta olarak gönderseniz bile (bir sunucuda çevrimiçi değil) çalışmaya devam edecektir.\n\n\n\n\n\n\n\n\n\n\n\nHTML Araçları\nR için HTML widget’ları, JavaScript kitaplıklarını kullanarak etkileşimi artıran özel bir R paketi sınıfıdır. Bunları R Markdown çıktılarına (bir flexdashboard gibi) ve shiny panolara gömebilirsiniz.\nBu widget’ların bazı yaygın örnekleri şunları içerir:\n• Plotly (Bu el kitabı sayfasında ve İnteraktif grafikler sayfasında kullanılır) • visNetwork (Bu el kitabının İletim Zincirleri sayfasında kullanılır) • Leaflet (Bu el kitabının GIS Temelleri sayfasında kullanılır) • dygraphs (Zaman serisi verilerini etkileşimli olarak göstermek için kullanışlıdır) • DT (datatable()) (filtre, sıralama vb. ile dinamik tabloları göstermek için kullanılır)\nAşağıda, gösterge paneline visNetwork kullanan bir salgın iletim zinciri eklemeyi gösteriyoruz. Komut dosyası, yalnızca R Markdown komut dosyasının “Sütun 2” bölümüne eklenen yeni kodu gösterir. Kodu, bu el kitabının İletim zincirleri sayfasında bulabilirsiniz.\n\n\n\n\n\n\n\n\n\nİşte betiğin ürettiği:",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>R Markdown ile gösterge panelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.tr.html#kodun-düzenlenmesi",
    "href": "new_pages/flexdashboard.tr.html#kodun-düzenlenmesi",
    "title": "42  R Markdown ile gösterge panelleri",
    "section": "42.7 Kodun düzenlenmesi",
    "text": "42.7 Kodun düzenlenmesi\nTüm kodun R Markdown flexdashboard komut dosyası içinde olmasını seçebilirsiniz. Alternatif olarak, daha temiz ve yoğun bir pano komut dosyasına sahip olmak için, harici R komut dosyalarında bulunan veya oluşturulan kod/şekilleri çağırmayı seçebilirsiniz. [R Markdown ile Raporlar] sayfasında daha ayrıntılı olarak açıklanmaktadır.",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>R Markdown ile gösterge panelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.tr.html#shiny",
    "href": "new_pages/flexdashboard.tr.html#shiny",
    "title": "42  R Markdown ile gösterge panelleri",
    "section": "42.8 Shiny",
    "text": "42.8 Shiny\nShiny R paketini entegre etmek, gösterge panellerini kullanıcı girdilerine karşı daha da reaktif hale getirebilir. Örneğin, kullanıcının bir yetki alanı veya bir tarih aralığı seçmesini ve panellerin seçimlerine tepki vermesini sağlayabilirsiniz (örneğin, görüntülenen verileri filtreleme). Shiny’nin reaktif özelliklerini flexdashboard’a gömmek için, flexdashboard R Markdown betiğinizde sadece birkaç değişiklik yapmanız yeterlidir.\nflexdashboard olmadan da uygulamalar/gösterge panoları oluşturmak için shiny’i kullanabilirsiniz. Shiny ile gösterge panelleri sayfası, shiny sintaksı, uygulama dosyası yapısı ve paylaşım/yayınlama seçenekleri (ücretsiz sunucu seçenekleri dahil) ile ilgili temel bilgiler dahil olmak üzere bu yaklaşıma genel bir bakış sunar. Bu sintaks ve genel ipuçları, flexdashboard bağlamında da düşünülebilir.\nAncak, flexdashboard’a shiny’i yerleştirmek, flexdashboard’unuz için temel bir değişikliktir. Artık e-posta ile gönderebileceğiniz ve herkesin açıp görüntüleyebileceği bir HTML çıktısı üretmeyecektir. Bunun yerine, bir “uygulama” olacaktır. Komut dosyasının üstündeki “Knit-Ör” düğmesinin yerini, etkileşimli panelin bir örneğini bilgisayarınızda yerel olarak açacak olan bir ” Run document- Belgeyi çalıştır” simgesi alacaktır.\nKontrol panelinizi paylaşmak artık şunları yapmanızı gerektirecek:\n• Rmd komut dosyasını görüntüleyiciye gönderin, bilgisayarlarınızda R’da açın ve uygulamayı çalıştırın veya • Uygulama/pano, izleyicinin erişebileceği bir sunucuda saklanmalıdır\nBu nedenle, shiny entegrasyonun faydaları vardır, aynı zamanda komplikasyonları da vardır. E-posta ile kolay paylaşım bir öncelikse ve shiny’nin reaktif özelliklerine ihtiyacınız yoksa, yukarıda gösterildiği gibi ggplotly() tarafından sunulan azaltılmış etkileşimli versiyonu düşünün.\nAşağıda, yukarıdakiyle aynı “outbreak_dashboard.Rmd”yi kullanarak çok basit bir örnek veriyoruz. Shiny’yi flexdashboard’a entegre etmeye ilişkin kapsamlı belgeleri buradan çevrimiçi olarak okuyabilirsiniz.\n\nAyarlar\nAşağıdaki gibi çıktı (output:) ile aynı girinti düzeyinde YAML parametresi ekleyerek (runtime: shiny) flexdashboard‘da shiny özelliğini etkinleştirin:\n---\ntitle: \"Outbreak dashboard (Shiny demo)\"\noutput: \n  flexdashboard::flex_dashboard:\n    orientation: columns\n    vertical_layout: fill\nruntime: shiny\n---\nKullanıcıdan bilgi toplayacak shiny giriş widget’larını tutmak için bir “kenar çubuğunu-side bar” etkinleştirmek de uygundur. Yukarıda açıklandığı gibi, bir sütun oluşturun ve sol tarafta bir kenar çubuğu oluşturmak için {.sidebar} seçeneğini belirtin. Bu sütuna shiny giriş komutlarını içeren metin ve R parçaları ekleyebilirsiniz.\nUygulamanız/gösterge tablonuz bir sunucudaysa ve aynı anda birden çok kullanıcıya sahipse, ilk R kodu parçasına “global” adını verin. Verilerinizi içe aktarmak/yüklemek için bu kod parçasına gereken komutları ekleyin. Bu özel adlandırılmış kod parçası farklı şekilde ele alınır ve içine aktarılan veriler yalnızca bir kez içe aktarılır (sürekli değil) ve tüm kullanıcılar tarafından kullanılabilir. Bu, uygulamanın başlatma hızını artırır.\n\n\nÜzerinde çalışılmış örnek\nBurada, “outbreak_dashboard.Rmd” flexdashboard komut dosyasını shiny’i içerecek şekilde uyarlıyoruz. Kullanıcıya açılır menüden bir hastane seçme yeteneği ekleyeceğiz ve salgın eğrisinin dinamik bir grafik başlığı ile yalnızca o hastaneden vakaları yansıtmasını sağlayacağız. Aşağıdakileri yapıyoruz:\n\n• YAML ’e runtime: shiny ekleyin • Kurulum yığınını global şeklinde yeniden adlandırın • Bir kenar çubuğu oluşturun • Benzersiz hastane adlarından oluşan vektörü oluşturmak için kod • Hastane isimleri seçimi ile bir selectInput() komutu (shiny açılır menüsü). Seçim, daha sonraki kodda input\\(hospital_choice olarak başvurulabilecek olan hospital_choice olarak kaydedilir.\n•   Salgın eğrisi kodu (sütun 2) renderPlot({ })ile sarılmıştır ve bunları içerir:\n•   Hastane sütununu input\\)hospital_choice’in geçerli değeriyle sınırlayan veri kümesindeki bir filtre • input$hospital_choice içeren dinamik bir grafik başlığı\n\nBir input$ değerine başvuran herhangi bir kodun (reaktif olması için) render({}) fonkisyonu içinde olması gerektiğini unutmayın.\nYAML, global kod parçası ve kenar çubuğu da dahil olmak üzere betiğin üst kısmı:\n\n\n\n\n\n\n\n\n\nReaktif eğri grafiğiyle birlikte 2. Sütun:\n\n\n\n\n\n\n\n\n\nVe işte kontrol paneli:\n\n\n\n\n\n\n\n\n\n\n\nDiğer Örnekler\nShiny etkileşimi ve broşür haritalama widget’ını kullanan bir Shiny-flexdashboard’un sağlıkla ilgili bir örneğini incelemek için Geospatial Health Data: R-INLA ve Shiny ile Modelleme ve Görselleştirme çevrimiçi kitabının bu bölümüne bakabilirsiniz.",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>R Markdown ile gösterge panelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.tr.html#paylaşım",
    "href": "new_pages/flexdashboard.tr.html#paylaşım",
    "title": "42  R Markdown ile gösterge panelleri",
    "section": "42.9 Paylaşım",
    "text": "42.9 Paylaşım\nShiny öğeleri içermeyen panolar, boyutu izin veriyorsa e-postayla gönderilebilecek bir HTML dosyası (.html) verir. “Gösterge paneli” raporunu gönderebildiğiniz için ve bir web sitesi olarak saklamak için bir sunucu kurmanız gerekmediği için bu yararlıdır.\nShiny öğelerini yerleştirdiyseniz, e-posta ile çıktı gönderemezsiniz, ancak komut dosyasının kendisini bir R kullanıcısına gönderebilir veya yukarıda açıklandığı gibi gösterge panelini bir sunucuda saklayabilirsiniz.",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>R Markdown ile gösterge panelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.tr.html#kaynaklar",
    "href": "new_pages/flexdashboard.tr.html#kaynaklar",
    "title": "42  R Markdown ile gösterge panelleri",
    "section": "42.10 Kaynaklar",
    "text": "42.10 Kaynaklar\nBu sayfanın referans aldığı mükemmel eğitimleri aşağıda bulunabilir. Bunları gözden geçirirseniz, büyük olasılıkla bir saat içinde kendi gösterge tablonuzu hazırlayabilirsiniz.\nhttps://bookdown.org/yihui/rmarkdown/dashboards.html\nhttps://rmarkdown.rstudio.com/flexdashboard/\nhttps://rmarkdown.rstudio.com/flexdashboard/using.html\nhttps://rmarkdown.rstudio.com/flexdashboard/examples.html",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>R Markdown ile gösterge panelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.tr.html",
    "href": "new_pages/shiny_basics.tr.html",
    "title": "43  Shiny ile Gösterge Panelleri",
    "section": "",
    "text": "43.1 Hazırlık",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Shiny ile Gösterge Panelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.tr.html#hazırlık",
    "href": "new_pages/shiny_basics.tr.html#hazırlık",
    "title": "43  Shiny ile Gösterge Panelleri",
    "section": "",
    "text": "Paketleri yükleme\nBu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’ın p_load() fonkisyonunu vurguluyoruz. Ayrıca, temel R’dan library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R temelleri sayfasına bakın.\nshiny R paketini kurarak başlıyoruz:\n\npacman::p_load(\"shiny\")\n\n\n\nVerileri içe aktarma\nBu sayfayı takip etmek isterseniz, el kitabının ve verilerin indirilmesi bölümüne bakabilirsiniz. Güncel Shiny uygulamasını oluşturan R komut dosyalarını ve veri dosyalarını indirmek için bağlantılar burada mevcuttur.Uygulamayı bu dosyaları kullanarak yeniden oluşturmaya çalışırsanız, lütfen kurs için oluşturulan R projesi klasör yapısının (örneğin, “veri” ve “işlevler” için klasörler) farkında olun.",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Shiny ile Gösterge Panelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.tr.html#shiny-uygulamasının-yapısı",
    "href": "new_pages/shiny_basics.tr.html#shiny-uygulamasının-yapısı",
    "title": "43  Shiny ile Gösterge Panelleri",
    "section": "43.2 Shiny uygulamasının yapısı",
    "text": "43.2 Shiny uygulamasının yapısı\n\nTemel dosya yapıları\nShiny’yi anlamak için önce uygulamanın dosya yapısının nasıl çalıştığını anlamamız gerekir! Başlamadan önce yepyeni bir dizin oluşturmalıyız. Bu aslında Rstudio’da yeni projeden Shiny Web Application seçilerek daha kolay hale getirilebilir. Bu, sizin için shiny uygulamasının temel yapısını oluşturacaktır.\nBu projeyi açarken, zaten app.R adında bir .R dosyası olduğunu fark edeceksiniz. İki temel dosya yapısından birine sahip olmamız önemlidir:\n\napp.R adında bir dosya veya\nBiri ui.R ve diğeri server.R olarak adlandırılan iki dosya\n\nBu sayfada, app.R adında bir dosyaya sahip olduğunuz ilk yaklaşımı kullanacağız. İşte örnek bir komut dosyası:\n\n#  app.R örneği\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n\n    # Uygulama başlığı\n    titlePanel(\"My app\"),\n\n    # Kaydırıcı giriş araçlı kenar çubuğu\n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(\"input_1\")\n        ),\n\n        # Grafiği göster   \n        mainPanel(\n           plotOutput(\"my_plot\")\n        )\n    )\n)\n\n# Bir histogram çizmek için gereken sunucu mantığını tanımlayın\nserver &lt;- function(input, output) {\n     \n     plot_1 &lt;- reactive({\n          plot_func(param = input_1)\n     })\n     \n    output$my_plot &lt;- renderPlot({\n       plot_1()\n    })\n}\n\n\n# Uygulamayı çalıştırın\nshinyApp(ui = ui, server = server)\n\nBu dosyayı açarsanız, biri kullanıcı arayüzü ve diğeri sunucu olarak adlandırılan iki nesnenin tanımlandığını fark edeceksiniz. Bu nesneler shiny uygulamasında tanımlanmalıdır ve uygulamanın kendi yapısının merkezinde yer alırlar! Aslında, yukarıda açıklanan iki dosya yapısı arasındaki tek fark, yapı 1’de hem kullanıcı arayüzünün hem de sunucunun tek bir dosyada tanımlanması, yapı 2’de ise ayrı dosyalarda tanımlanmalarıdır. Not: Ayrıca, uygulamamızda source() fonksiyonunu uygulayabileceğimiz başka .R dosyalarına da sahip olabiliriz (Daha büyük bir uygulamamız varsa bu şekilde yapmalıyız).\n\n\nSunucu ve kullanıcı arayüzü (ui)\nDaha sonra sunucu ve ‘ui’ nesnelerinin gerçekte ne yaptığını anlamamız gerekiyor. Basitçe söylemek gerekirse, bunlar, kullanıcı shiny uygulamasıyla etkileşime girdiğinde birbirleriyle etkileşime giren iki nesnedir.\nShiny bir uygulamasının UI öğesi, temel düzeyde bir HTML arayüzü oluşturan R kodudur. Bu, bir uygulamanın kullanıcı arayüzünde görüntülenen her şey anlamına gelir. Bu genellikle şunları içerir:\n• “Widget’lar” - kullanıcı tarafından etkileşime geçilebilecek açılır menüler, onay kutuları, kaydırıcılar vb. • Grafikler, tablolar, vb - R koduyla oluşturulan çıktılar • Bir uygulamanın gezinme yönleri - sekmeler, bölmeler, vb. • Genel metin, köprüler vb. • HTML ve CSS öğeleri (daha sonra ele alınacaktır)\nUI hakkında anlaşılması gereken en önemli şey, kullanıcıdan girdi alması ve sunucudan kaynaklanan çıktıları göstermesidir. Kullanıcı arabiriminde herhangi bir zamanda çalışan aktif kod yoktur - kullanıcı arabiriminde görülen tüm değişiklikler (az ya da çok) sunucudan geçirilir. Bu yüzden grafiklerimizi, dosya indirmelerimizi vb. sunucuda gerçekleştirmeliyiz.\nShiny uygulamasının sunucusu, uygulama başlatıldığında tüm kodun çalıştırıldığı yerdir. Sunucunun çalışma şekli biraz kafa karıştırıcı. Sunucu işlevi, kullanıcı arayüzüyle etkileşen kullanıcıya etkin bir şekilde tepki verir ve yanıt olarak kod parçalarını çalıştırır. Sunucuda bir şeyler değişirse, bunlar değişikliklerin görülebileceği kullanıcı arayüzüne geri iletilecektir. Daha da önemlisi, sunucudaki kod ardışık olmayan bir şekilde yürütülecektir (veya bu şekilde düşünmek en iyisidir). Temel olarak, kullanıcı arayüzünden veri girişi sunucudaki bir kod parçasını etkilediğinde, otomatik olarak çalışır ve bu çıktı üretilir ve görüntülenir.\nBunların hepsi muhtemelen şimdilik çok soyut geliyor, bu yüzden bunun gerçekte nasıl çalıştığına dair net bir fikir edinmek için bazı örnekler üzerinden anlatacağız.\n\n\nBir uygulama oluşturmadan önce\nBir uygulama oluşturmaya başlamadan önce, ne oluşturmak istediğinizi bilmek son derece yararlıdır. Kullanıcı arayüzünüz kodla yazılacağından, ne inşa ettiğinizi görselleştiremezsiniz önemlidir. Bu nedenle, neler yapabileceğiniz hakkında bir fikir edinmek için önceden shiny uygulama örneklerine bakmak son derece yararlıdır - bu uygulamaların arkasındaki kaynak koduna bakabilirseniz daha da iyi olur! Bunun için bazı harika kaynaklar şunlardır:\n\nRstudio uygulama galerisi\n\nNeyin mümkün olduğuna dair bir fikir edindikten sonra, sizinkinin nasıl görünmesini istediğinizi haritalamak da yararlıdır - bunu kağıt üzerinde veya herhangi bir çizim yazılımında (PowerPoint, MS paint, vb.) yapabilirsiniz. İlk uygulamanız için basit bir başlangıç yapmanız faydalı olacaktır! Ayrıca internette bulduğunuz güzel bir uygulamanın kodunu işiniz için şablon olarak kullanmaktan çekinmeyin- sıfırdan uygulama oluşturmaktan çok daha kolaydır!",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Shiny ile Gösterge Panelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.tr.html#kullanıcı-arayüzü-iu-oluşturmak",
    "href": "new_pages/shiny_basics.tr.html#kullanıcı-arayüzü-iu-oluşturmak",
    "title": "43  Shiny ile Gösterge Panelleri",
    "section": "43.3 Kullanıcı Arayüzü (IU) Oluşturmak",
    "text": "43.3 Kullanıcı Arayüzü (IU) Oluşturmak\nUygulamamızı oluştururken, ne yaptığımızı görebilmemiz ve herhangi bir sunucu hatası nedeniyle uygulamanın başarısız olma riskini almamamız için önce kullanıcı arayüzü üzerinde çalışmak daha kolaydır. Daha önce de belirtildiği gibi, kullanıcı arayüzü üzerinde çalışırken bir şablon kullanmak genellikle iyidir. Temel shiny paketinde bulunan ve shiny ile kullanılabilecek bir dizi standart şablon vardır, ancak shinydashboard gibi bir dizi paket uzantısının da bulunduğunu belirtmekte fayda var. Başlangıç için temel shiny’den bir örnek kullanacağız.\nShiny kullanıcı arayüzü genellikle aşağıdaki sırayla bir dizi iç içe fonksiyon olarak tanımlanır.\n\nGenel düzeni tanımlayan bir fonkisyon (en temel olanı fluidPage()’dir, ancak daha fazlası mevcuttur)\nŞablon içindeki paneller, örneğin: • bir kenar çubuğu (sidebarPanel()) • bir “ana” panel (mainPanel()) • bir sekme (tabPanel()) • genel bir “sütun” (sütun())\nWidget’lar ve çıktılar - bunlar sunucuya girdiler (widget’lar) veya sunucudan çıktılar (çıkışlar) verebilir • Widget’lar genellikle xxxInput() olarak biçimlendirilir, ör. selectInput() • Çıktılar genellikle xxxOutput() olarak biçimlendirilir, ör. plotÇıkış()\n\nBu yapıların soyut bir şekilde kolayca anlaşılmayacağını bir kez daha belirtmekte fayda var, bu yüzden bir örneğe bakmak en iyisi! Bölgeye göre sıtmayla savaş dispanseri sayım verilerini görselleştiren basit bir uygulama yapmayı düşünelim. Bu verinin birçok farklı parametresi vardır, bu nedenle son kullanıcının verileri uygun gördükleri şekilde yaş grubuna/bölgeye göre tabaklamak için bazı filtreler uygulayabilmesi harika olur! Başlangıç için çok basit bir shiny şablonu kullanabiliriz: Bir kenar çubuğu şablonu. Bu şablon, widget’ların soldaki bir kenar çubuğuna yerleştirildiği ve grafiğin sağ tarafa yerleştirildiği bir şablondur.\nUygulamamızı planlayalım - verileri görselleştirmek istediğimiz bölgeyi seçmemize izin veren bir seçiciyle ve ilgilendiğimiz yaş grubunu görselleştirmemize izin veren bir seçiciyle başlayabiliriz. Bu filtreleri bir salgın eğrisi (epicurve) çizmek için kullanacağız. Bunun için:\n\nİstediğimiz bölgeyi ve ilgilendiğimiz yaş grubunu seçmemizi sağlayan iki açılır menü.\nOrtaya çıkan salgın eğrimizi gösterebileceğimiz bir alan.\n\nBu şöyle görünebilir:\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # selector for district\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = c(\n                   \"All\",\n                   \"Spring\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selected = \"All\",\n              multiple = TRUE\n         ),\n         # selector for age group\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         )\n\n    ),\n\n    mainPanel(\n      # epicurve goes here\n      plotOutput(\"malaria_epicurve\")\n    )\n    \n  )\n)\n\napp.R yukarıdaki UI koduyla çalıştırıldığında (app.R’nin sunucu kısmında aktif kod olmadan) düzen şöyle görünür - Bir sunucu yoksa hiçbir çizim oluşturulmayacağını unutmayın, ancak girişlerimiz düzgün çalışmaktadır!\n\n\n\n\n\n\n\n\n\nBu örnek, widget’ların nasıl çalıştığını tartışmak için iyi bir fırsattır - her widget’ın bir inputId, bir etiket ve widget türüne özgü bir dizi başka seçeneği kabul ettiğini unutmayın. Bu inputId son derece önemlidir - bunlar, kullanıcı arabiriminden sunucuya bilgi aktarmak için kullanılan kimliklerdir. Bu nedenle benzersiz olmaları gerekir. Daha büyük uygulamalar söz konusu olduğunda, inputIDlere mantıklı ve etkileşime girdikleri yapılara özgü bir ad vermek için çaba göstermelisiniz.\nBu widget’ların her birinin ne yaptığıyla ilgili tüm ayrıntılar için belgeleri dikkatlice okumalısınız. Widget’lar, widget türüne bağlı olarak belirli veri türlerini sunucuya iletir ve bunun tam olarak anlaşılması gerekir. Örneğin, selectInput() sunucuya bir karakter tipi iletir:\n• Buradaki ilk widget için Spring’i seçersek, “Spring” karakter nesnesini sunucuya iletecektir. • Açılır menüden iki öğe seçersek, bunlar bir karakter vektörü olarak gelirler (örn. c(“Spring”, “Bolo”)).\nDiğer widget’lar, sunucuya farklı nesne türleri iletecektir! Örneğin: • numericInput(), sunucuya sayısal türde bir nesne iletir • checkboxInput(), sunucuya mantık nesnesi iletir (DOĞRU veya YANLIŞ)\nBurada yaş verileri için kullandığımız adlandırılmış vektörü de belirtmekte fayda var. Birçok pencere öğesi için, seçenekler olarak adlandırılmış bir vektörün kullanılması, vektörün adlarının seçenekler olarak görüntülenmesini sağlar, ancak sadece seçilen değeri vektörden sunucuya iletir. Yani burada birisi açılır menüden “15+” öğesini seçebilir ve kullanıcı arayüzü sunucuya “malaria_rdt_15” iletir - bu, ilgilendiğimiz sütunun adıdır!\nUygulamanızla birçok eylem yapmak için kullanabileceğiniz çok sayıda widget vardır. Widget’lar ayrıca uygulamanıza dosya yüklemenize ve çıktıları indirmenize olanak tanır. Ayrıca, temel shiny’den daha fazla widget’a erişmenizi sağlayan mükemmel shiny uzantılar da vardır - shinyWidgets paketi buna harika bir örnektir. Bazı örneklere bakmak için aşağıdaki bağlantılara bakabilirsiniz:\n\ntemel shiny widget galerisi\nshinyWidgets galerisi",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Shiny ile Gösterge Panelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.tr.html#verinin-uygulamamıza-yüklenmesi",
    "href": "new_pages/shiny_basics.tr.html#verinin-uygulamamıza-yüklenmesi",
    "title": "43  Shiny ile Gösterge Panelleri",
    "section": "43.4 Verinin uygulamamıza yüklenmesi",
    "text": "43.4 Verinin uygulamamıza yüklenmesi\nUygulama geliştirmemizdeki bir sonraki adım, sunucuyu çalışır duruma getirmektir. Ancak bunu yapmak için uygulamamıza bazı veriler aktarmamız ve yapacağımız tüm hesaplamaları bulmamız gerekiyor. Shiny uygulamasının hatalarını ayıklamak kolay değildir, çünkü hataların nereden geldiği genellikle net değildir, bu nedenle sunucunun kendisini yapmaya başlamadan önce tüm veri işleme ve görselleştirme kodumuzu çalışır duruma getirmek idealdir.\nKullanıcı girdisine göre değişen salgın eğrileri gösteren bir uygulama yapmak istediğimize göre, bunu normal bir R betiğinde çalıştırmak için hangi koda ihtiyacımız olacağını düşünmeliyiz. Şunlara ihtiyacımız olacak: 1. Paketlerimizi yükleyin 2. Verilerimizi yükleyin 3. Verilerimizi dönüştürün 4. Kullanıcı girdilerine dayalı olarak verilerimizi görselleştirmek için bir fonksiyon geliştirin\nBu liste oldukça basittir ve yapılması çok zor olmamalıdır. Artık bu sürecin hangi bölümlerinin yalnızca bir kez yapılması gerektiğini ve hangi bölümlerin kullanıcı girdilerine yanıt olarak çalıştırılması gerektiğini düşünmek önemlidir. Bunun nedeni, shiny uygulamalarının genellikle kullanımdan önce yalnızca bir kez çalıştırılan bazı kodları çalıştırmasıdır. Kodumuzun çoğu bu bölüme taşınabilirse, uygulamamızın performansına yardımcı olacaktır. Bu örnek için, sadece verilerimizi/paketlerimizi yüklememiz ve temel dönüşümleri bir kez yapmamız gerekiyor, böylece kodu sunucunun dışına yerleştirebiliriz. Bu, sunucuda ihtiyacımız olan tek kodun verilerimizi görselleştirecek kod olduğu anlamına gelir. Önce tüm bu bileşenleri bir komut dosyasında geliştirelim. Ancak verilerimizi bir fonksiyon ile görselleştirdiğimiz için, fonksiyonun kodunu sunucunun dışına da koyabiliriz, böylece uygulama çalıştığında fonksiyonumuz ortamda olur!\nÖnce verilerimizi yükleyelim. Yeni bir proje ile çalıştığımız ve temizlemek istediğimiz için data adında yeni bir dizin oluşturabilir ve sıtma verilerimizi oraya ekleyebiliriz. Aşağıdaki kodu, uygulamamızın yapısını temizlediğimizde sileceğimiz bir test komut dosyasında çalıştırabiliriz.\n\npacman::p_load(\"tidyverse\", \"lubridate\")\n\n# veriyi oku\nmalaria_data &lt;- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\")) %&gt;% \n  as_tibble()\n\nprint(malaria_data)\n\n# A tibble: 3,038 × 10\n   location_name data_date  submitted_date Province District `malaria_rdt_0-4`\n   &lt;chr&gt;         &lt;date&gt;     &lt;date&gt;         &lt;chr&gt;    &lt;chr&gt;                &lt;int&gt;\n 1 Facility 1    2020-08-11 2020-08-12     North    Spring                  11\n 2 Facility 2    2020-08-11 2020-08-12     North    Bolo                    11\n 3 Facility 3    2020-08-11 2020-08-12     North    Dingo                    8\n 4 Facility 4    2020-08-11 2020-08-12     North    Bolo                    16\n 5 Facility 5    2020-08-11 2020-08-12     North    Bolo                     9\n 6 Facility 6    2020-08-11 2020-08-12     North    Dingo                    3\n 7 Facility 6    2020-08-10 2020-08-12     North    Dingo                    4\n 8 Facility 5    2020-08-10 2020-08-12     North    Bolo                    15\n 9 Facility 5    2020-08-09 2020-08-12     North    Bolo                    11\n10 Facility 5    2020-08-08 2020-08-12     North    Bolo                    19\n# ℹ 3,028 more rows\n# ℹ 4 more variables: `malaria_rdt_5-14` &lt;int&gt;, malaria_rdt_15 &lt;int&gt;,\n#   malaria_tot &lt;int&gt;, newid &lt;int&gt;\n\n\nTidy (düzenli) veri standartları kullanırsak bu verilerle çalışmak daha kolay olacaktır, bu nedenle yaş grubunun bir sütun olduğu ve vakaların başka bir sütun olduğu uzun bir veri formatına da pivotlamalıyız. Verilerin pivotlanması sayfasında öğrendiklerimizi kullanarak bunu kolayca yapabiliriz.\n\nmalaria_data &lt;- malaria_data %&gt;%\n  select(-newid) %&gt;%\n  pivot_longer(cols = starts_with(\"malaria_\"), names_to = \"age_group\", values_to = \"cases_reported\")\n\nprint(malaria_data)\n\n# A tibble: 12,152 × 7\n   location_name data_date  submitted_date Province District age_group       \n   &lt;chr&gt;         &lt;date&gt;     &lt;date&gt;         &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;           \n 1 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_rdt_0-4 \n 2 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_rdt_5-14\n 3 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_rdt_15  \n 4 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_tot     \n 5 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_rdt_0-4 \n 6 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_rdt_5-14\n 7 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_rdt_15  \n 8 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_tot     \n 9 Facility 3    2020-08-11 2020-08-12     North    Dingo    malaria_rdt_0-4 \n10 Facility 3    2020-08-11 2020-08-12     North    Dingo    malaria_rdt_5-14\n# ℹ 12,142 more rows\n# ℹ 1 more variable: cases_reported &lt;int&gt;\n\n\nBu şeklide verilerimizi hazırlamayı bitirdik! Bu iş paketi, “R komut dosyasını test etme” için geliştirilecek şeyler listemizdeki 1, 2 ve 3 numaralı maddeleri kapsar. Son ve en zor görev, kullanıcı tanımlı parametrelere dayalı bir salgın eğrisi üretmek için bir fonksiyon oluşturmak olacaktır. Daha önce de belirtildiği gibi, shiny öğrenen herkesin, çalışma prensiplerini anlamak için önce fonksiyonel programlama (fonkisyonların yazılması) bölümünü incelemesi şiddetle tavsiye edilir!\nFonksiyonumuzu tanımlarken, hangi parametreleri dahil etmek istediğimizi planlamak zor olabilir. Shiny ile fonksiyonel programlama için, ilgili her parametrenin genellikle kendisiyle ilişkilendirilmiş bir widget’ı olacaktır, bu nedenle bunu planlamak genellikle oldukça kolaydır! Örneğin mevcut uygulamamızda, bölgeye göre filtreleme yapabilmek ve bunun için bir widget’ımız olmasını istiyoruz, bunun için bir bölge parametresini ekleyebiliriz. Tesise göre filtrelemek için herhangi bir uygulama işlevimiz şimdilik olmadığı için bu nedenle bunu bir parametre olarak eklememize gerek yoktur. Üç parametreli bir fonksiyon yazarak başlayalım:\n\nÇekirdek veri seti\nSeçim bölgesi\nTercih edilen yaş grubu\n\n\nplot_epicurve &lt;- function(data, district = \"All\", agegroup = \"malaria_tot\") {\n  \n  if (!(\"All\" %in% district)) {\n    data &lt;- data %&gt;%\n      filter(District %in% district)\n    \n    plot_title_district &lt;- stringr::str_glue(\"{paste0(district, collapse = ', ')} districts\")\n    \n  } else {\n    \n    plot_title_district &lt;- \"all districts\"\n    \n  }\n  \n  # kalan veri yoksa, NULL getir\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  data &lt;- data %&gt;%\n    filter(age_group == agegroup)\n  \n  \n  # kalan veri yoksa, NULL getir\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  if (agegroup == \"malaria_tot\") {\n      agegroup_title &lt;- \"All ages\"\n  } else {\n    agegroup_title &lt;- stringr::str_glue(\"{str_remove(agegroup, 'malaria_rdt')} years\")\n  }\n  \n  \n  ggplot(data, aes(x = data_date, y = cases_reported)) +\n    geom_col(width = 1, fill = \"darkred\") +\n    theme_minimal() +\n    labs(\n      x = \"date\",\n      y = \"number of cases\",\n      title = stringr::str_glue(\"Malaria cases - {plot_title_district}\"),\n      subtitle = agegroup_title\n    )\n  \n  \n  \n}\n\nNasıl çalıştığı nispeten basit olduğu için bu fonksiyon hakkında çok fazla ayrıntıya girmeyeceğiz. Bununla birlikte, not edilmesi gereken bir nota, hata vereceği zamanlarda NULL elde ederek hataları ayıklamamızdır. Bunun nedeni, shiny’de sunucu bir çizim nesnesi yerine bir NULL nesnesi ürettiğinde, kullanıcı arayüzünde hiçbir şey gösterilmeyecek olmasıdır! Bu önemlidir, aksi takdirde hatalar genellikle uygulamanızın çalışmayı durdurmasına neden olur.\nDikkat edilmesi gereken bir diğer nokta da, bölge girdisini değerlendirirken %in% operatörünün kullanılmasıdır. Yukarıda bahsedildiği gibi bu operatör birden çok değere sahip bir karakter vektörü olarak kullanılabilir ,bu nedenle %in% operatörünü kullanmak, == operatöründen daha esnektir.\nFonksiyonumuzu test edelim!\n\nplot_epicurve(malaria_data, district = \"Bolo\", agegroup = \"malaria_rdt_0-4\")\n\n\n\n\n\n\n\n\nFonksiyonumuz çalışırken, tüm bunların shiny uygulamamıza nasıl sığacağını anlamamız gerekiyor. Başlangıç kodu kavramından daha önce bahsetmiştik, ancak şimdi bunu uygulamamızın yapısına nasıl dahil edebileceğimize bakalım. Bunu yapabilmemizin iki yolu var!\n\nBu kodu app.R dosyanıza komut dosyasının başına (kullanıcı arayüzünün üstüne) koyun veya\nUygulamanızın global.R adlı dizininde yeni bir dosya oluşturun ve başlangıç kodunu bu dosyaya yerleştirin.\n\nBu noktada, dosya yapınızı basit bir şekilde ayırmanıza izin verdiği için, özellikle daha büyük uygulamalarda, ikinci seçenekteki dosya yapısını kullanmanın genellikle daha kolay olduğunu belirtmekte fayda var. Şimdi bu global.R betiğini tamamen geliştirelim. Böyle görünebilir:\n\n# global.R betiği\n\npacman::p_load(\"tidyverse\", \"lubridate\", \"shiny\")\n\n# veriyi oku\nmalaria_data &lt;- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\")) %&gt;% \n  as_tibble()\n\n# veriyi temizle ve uzun pivotla\nmalaria_data &lt;- malaria_data %&gt;%\n  select(-newid) %&gt;%\n  pivot_longer(cols = starts_with(\"malaria_\"), names_to = \"age_group\", values_to = \"cases_reported\")\n\n\n# grafik fonksiyonunu tanımla\nplot_epicurve &lt;- function(data, district = \"All\", agegroup = \"malaria_tot\") {\n  \n  # grafik başlığı oluştur\n  if (!(\"All\" %in% district)) {            \n    data &lt;- data %&gt;%\n      filter(District %in% district)\n    \n    plot_title_district &lt;- stringr::str_glue(\"{paste0(district, collapse = ', ')} districts\")\n    \n  } else {\n    \n    plot_title_district &lt;- \"all districts\"\n    \n  }\n  \n  # kalan veri yoksa, NULL sonucunu getir  \n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  # yaş grubuna filtrele\n  data &lt;- data %&gt;%\n    filter(age_group == agegroup)\n  \n  \n  # kalan veri yoksa, NULL sonucunu getir  \n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  if (agegroup == \"malaria_tot\") {\n      agegroup_title &lt;- \"All ages\"\n  } else {\n    agegroup_title &lt;- stringr::str_glue(\"{str_remove(agegroup, 'malaria_rdt')} years\")\n  }\n  \n  \n  ggplot(data, aes(x = data_date, y = cases_reported)) +\n    geom_col(width = 1, fill = \"darkred\") +\n    theme_minimal() +\n    labs(\n      x = \"date\",\n      y = \"number of cases\",\n      title = stringr::str_glue(\"Malaria cases - {plot_title_district}\"),\n      subtitle = agegroup_title\n    )\n  \n  \n  \n}\n\nBright’ın harika bir özelliği, app.R, server.R, ui.R ve global.R adlı dosyaların ne için olduğunu anlamasıdır, bu nedenle herhangi bir kod aracılığıyla bunları birbirine bağlamaya gerek yoktur. Bu yüzden sadece global.R’deki bu kodu dizinde bulundurmak uygulamamızı başlatmadan önce çalışması için yeterlidir!\nAyrıca, çizim işlevini kendi dosyasına taşımamızın uygulamamızın organizasyonunu iyileştireceğini de unutmamalıyız – bu eylem özellikle uygulamalar büyüdükçe yararlı olacaktır. Bunu yapmak için funcs adında başka bir dizin oluşturabilir ve bu işlevi plot_epicurve.R adlı bir dosyaya yerleştirebiliriz. Daha sonra bu işlevi global.R’de aşağıdaki komutla okuyabiliriz:\n\nsource(here(\"funcs\", \"plot_epicurve.R\"), local = TRUE)\n\nUygulama bir sunucuda yayınlandığında kaynak bulmayı etkileyeceğinden, shiny uygulamalarında her zaman local argümanını ‘local= TRUE’ belirtmeniz gerektiğini unutmayın.",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Shiny ile Gösterge Panelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.tr.html#bir-uygulama-sunucusu-geliştirme",
    "href": "new_pages/shiny_basics.tr.html#bir-uygulama-sunucusu-geliştirme",
    "title": "43  Shiny ile Gösterge Panelleri",
    "section": "43.5 Bir uygulama sunucusu geliştirme",
    "text": "43.5 Bir uygulama sunucusu geliştirme\nArtık kodumuzun çoğunu yazdığımıza göre, sadece sunucumuzu geliştirmemiz gerekiyor. Bu, uygulamamızın son parçasıdır ve muhtemelen anlaşılması en zor olanıdır. Sunucu büyük bir R işlevidir, ancak onu bir dizi daha küçük işlev veya uygulamanın gerçekleştirebileceği görevler olarak düşünmek yararlıdır. Bu işlevlerin doğrusal bir sırada yürütülmediğini anlamak önemlidir. Onlara verilen bir emir vardır ancak shiny’de başlangıç seviyesinde bu süreci tam olarak anlamak gerekli değildir. Çok temel düzeyde, bu görevler veya işlevler, geliştirici farklı davranacak şekilde ayarlamadıkça, sadece kullanıcı girdilerinde kendilerini etkileyen bir değişiklik olduğunda etkinleşir. Yine, bunların hepsi oldukça soyut kavramlardır. Ama önce üç temel shiny nesne türünü inceleyelim.\n\nReaktif kaynaklar - bu, kullanıcı girdileri için başka bir terimdir. Shiny sunucusu, programladığımız widget’lar aracılığıyla UI’den (kullanıcı arayüzünden) gelen çıktılara erişebilir. Değerleri her değiştirildiğinde, bu bilgi sunucuya iletilir.\nReaktif iletkenler - bunlar yalnızca shiny sunucusunun içinde bulunan nesnelerdir. Bunlara aslında basit uygulamalar için ihtiyacımız yoktur, yalnızca sunucu içinde görülebilen ve diğer işlemlerde kullanılabilen nesneler üretirler. Genellikle reaktif kaynaklara bağlıdırlar.\nSon noktalar - bunlar sunucudan kullanıcı arayüzüne iletilen çıktılardır. Örneğimizde, ürettiğimiz salgın eğrisi bu olacaktır.\n\nBunu akılda tutarak, sunucumuzu adım adım oluşturalım. Burada sadece referans olması için UI kodumuzu tekrar göstereceğiz:\n\nui &lt;- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # bölge için seçici\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = c(\n                   \"All\",\n                   \"Spring\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selected = \"All\",\n              multiple = TRUE\n         ),\n         # yaş grubu için seçici\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         )\n\n    ),\n\n    mainPanel(\n      # salgın eğrisi burada bulunur\n      plotOutput(\"malaria_epicurve\")\n    )\n    \n  )\n)\n\nBu kod kullanıcı arayüzünden elimize: • İki giriş ulaşır: • Bölge seçicisi(bir select_district giriş kimliğiyle) • Yaş grubu seçicisi (inputId’si select_agegroup olan)\n• Bir çıktı: • Salgın eğrisi (sıtma_epicurve çıkış kimliği ile)\nDaha önce de belirtildiği gibi, girdi ve çıktılarımıza atadığımız bu benzersiz isimler çok önemlidir. Benzersiz olmalıdırlar ve kullanıcı arayüzü ile sunucu arasında bilgi iletmek için kullanılırlar. Sunucumuzda girdilerimize ‘input\\(inputID' ve output sintaksı aracılığıyla erişiyoruz ve 'output\\)output_name’ sintaksı aracılığıyla kullanıcı arayüzüne iletiyoruz. Şimdi bir örneğe bakalım, çünkü bunu başka türlü anlaşılması güçtür.\n\nserver &lt;- function(input, output, session) {\n  \n  output$malaria_epicurve &lt;- renderPlot(\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  )\n  \n}\n\nBunun gibi basit bir uygulamanın sunucusu aslında oldukça basittir! Sunucunun üç parametreli bir fonksiyon olduğunu fark edeceksiniz - giriş, çıkış ve oturum - bunu anlamak bu basamakta o kadar önemli değildir , ancak bu kuruluma bağlı kalmak önemlidir! Sunucumuzda sadece bir görevimiz mevcuttur – bu da daha önce oluşturduğumuz fonksiyonumuza ve sunucudan gelen girdilere dayalı bir grafik oluşturmaktır. Giriş ve çıkış nesnelerinin adlarının, kullanıcı arabirimindekilere tam olarak nasıl karşılık geldiğine dikkat edin.\nSunucunun kullanıcı girdilerine nasıl tepki verdiğinin temellerini anlamak için, girdiler değiştiğinde çıktının (altta yatan paket aracılığıyla) da değişeceğin ve her değişimle bir grafik oluşturmak için bu fonksiyonu yeniden çalıştıracağını unutmamalısınız. Burada renderPlot() fonksiyonunu da kullandığımızı unutmayın – bu fonksiyon, nesneleri bir kullanıcı arabirimi çıktısına ileten sınıfa özgü fonkisyonlar ailesindendir. Benzer şekilde davranan birkaç fonksiyon vardır, ancak kullanılan fonksiyonun kullanıcı arayüzüne ilettiğiniz nesnenin sınıfıyla eşleştiğinden emin olmanız gerekir! Örneğin:\n\nrenderText() - kullanıcı arayüzüne metin gönderir\nrenderDataTable - kullanıcı arayüzüne etkileşimli bir tablo gönderir.\n\nBunların da kullanıcı arayüzünde kullanılan çıktı işleviyle eşleşmesi gerektiğini unutmayın - bu nedenle renderPlot(), plotOutput() ile eşleştirilir ve renderText(), textOutput() ile eşleştirilir.\nSonunda çalışan bir uygulama yaptık! Bunu Rstudio’da komut dosyası penceresinin sağ üst kısmındaki Uygulamayı Çalıştır düğmesine basarak çalıştırabiliriz. Uygulamanızı, diğer kullanıcılar için uygulamanın nasıl görüneceğini daha doğru bir şekilde yansıtacak olan varsayılan tarayıcınızda (Rstudio yerine) çalıştırmayı seçebileceğinizi unutmayın.\n\n\n\n\n\n\n\n\n\nUygulamanın R konsolunda “dinlediğini” fark etmek eğlencelidir! Reaktivite hakkında konuşun!",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Shiny ile Gösterge Panelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.tr.html#daha-fazla-işlevsellik-eklemek",
    "href": "new_pages/shiny_basics.tr.html#daha-fazla-işlevsellik-eklemek",
    "title": "43  Shiny ile Gösterge Panelleri",
    "section": "43.6 Daha fazla işlevsellik eklemek",
    "text": "43.6 Daha fazla işlevsellik eklemek\nBu noktada nihayet çalışan bir uygulamamız var, ancak işlevsellik düzeyi düşüktür. Ayrıca, shine paketiyle yapabileceklerin henüz çok az kısımını gördük, bu yüzden öğrenecek daha çok şey var! Bazı ekstra özellikler ekleyerek mevcut uygulamamızı oluşturmaya devam edelim. Eklemenin uygun olacağı bazı seçenekler şunlar olabilir:\n\nAçıklayıcı metinler\nGrafikler için bir indirme düğmesi - bu, kullanıcının uygulamada oluşturdukları görüntünün yüksek kaliteli bir sürümünü elde etmesini sağlar\nBelirli tesisler için bir seçici\nBaşka bir gösterge paneli sayfası - bu, verilerimizin bir tablosunu gösterebilir.\n\nBu şekilde eklenebilecek çok şey vardır, bu şekilde bir sürü farklı shiny özelliği hakkında bilgi edinebiliriz. Shiny hakkında öğrenilecek çok şey var (çok gelişmiş olabilir, ancak umarız ki kullanıcılar shiny’yi nasıl kullanacakları konusunda daha iyi bir fikre sahip olduklarında, harici öğrenme kaynaklarını kullanarak da daha rahat olabilirler).\n\nStatik metin eklemek\nÖnce shiny uygulamamıza statik metin eklemeyi tartışalım. İşin temellerini bildikten sonra, uygulamamıza metin eklemek son derece kolaydır. Shiny uygulamasında statik metin değişmediğinden (Değişmesini isterseniz, sunucudaki metin oluşturma fonkisyonlarını kullanabilirsiniz!), shiny’nin tüm statik metinleri genellikle uygulamanın kullanıcı arayüzüne eklenir. Bunu çok ayrıntılı olarak ele almayacağız, ancak R’ı HTML ve css ile arayüz olarak kullanarak; kullanıcı arayüzünüze (ve hatta özelleştirilmiş olanlara) bir dizi farklı öğe ekleyebilirsiniz.\nHTML ve css, kullanıcı arayüzü tasarımında açıkça yer alan dillerdir. Bunları çok iyi anlamamıza gerek yok, ancak HTML, UI’de nesneler oluşturur (metin kutusu veya tablo gibi) ve css genellikle bu nesnelerin stilini ve estetiğini değiştirmek için kullanılır. Shiny’nin çok sayıda HTML etiketine erişimi vardır – bunların arasında başlıklar, metin paragrafları, satır sonları, tablolar vb. gibi belirli bir şekilde davranan nesneler için bulunur. Bu örneklerden bazılarını şu şekilde kullanabiliriz:\n\nh1() - bu, ekteki metni otomatik olarak büyütecek ve yazı tipi yüzü, rengi vb. ile ilgili varsayılanları değiştirecek bir başlık etiketidir (uygulamanızın ana temasına bağlı olarak). h2() ile h6()’ya kadar daha küçük ve daha küçük alt başlıklara da erişebilirsiniz. Kullanım şuna benzer:\n\nh1(\"my header - section 1\")\n\np() - bu, içine alınmış metni bir metin gövdesindeki metne benzer hale getiren bir paragraf etiketidir. Bu metin otomatik olarak sarılır ve nispeten küçük bir boyutta olur (örneğin alt bilgiler daha küçük olabilir.) Bunu bir word belgesinin metin gövdesi olarak düşünün. Kullanım şuna benzer:\n\np(\"Bu, uygulamamın işlevini açıkladığım daha büyük bir metindir\")\n\ntags$b() ve tags$i() - bunlar kalın etiketler tags\\(b() ve italik etiketler tags\\)i() oluşturmak için kullanılır.\ntags$ul(), tags$ol() ve tags$li() - bunlar, listelerin oluşturulmasında kullanılan etiketlerdir. Bunların tümü aşağıdaki sintaks içinde kullanılır ve kullanıcının sıralı bir liste (tags\\(ol(); yani numaralandırılmış) veya sırasız liste (tags\\)ul(), yani madde işareti noktaları) oluşturmasına izin verir. Tags$li(), kullanılan liste türünden bağımsız olarak listedeki öğeleri belirtmek için kullanılır. Örneğin.:\n\n\ntags$ol(\n  \n  tags$li(\"Item 1\"),\n  \n  tags$li(\"Item 2\"),\n  \n  tags$li(\"Item 3\")\n  \n)\n\n\nbr() ve hr() - bu etiketler sırasıyla satır sonu ve yatay satır (satır sonu ile) oluşturur. Uygulamanızı ve metninizi bölümlerini ayırmak için bunları kullanın! Bu etiketlere herhangi bir öğe iletmeye gerek yoktur (parantezler boş kalabilir).\ndiv() - bu etiket her şeyi içerebilen ve herhangi bir adla adlandırılabilen genel bir etikettir. Kullanıcı arayüzü tasarımında ilerlediğinizde, bunları kullanıcı arayüzünüzü bölümlere ayırmak, belirli bölümlere belirli stiller vermek ve sunucu ile kullanıcı arabirimi öğeleri arasında etkileşimler oluşturmak için kullanabilirsiniz. Bunlara ayrıntılı olarak girmeyeceğiz, ancak bu etiketin farkında olmak önemlidir!\n\nBu nesnelerin her birine, tags$... aracılığıyla veya bazıları için de yalnızca fonksiyon aracılığıyla erişilebileceğini unutmayın. Bunlar eş anlamlıdır, ancak daha açık olmayı ve yanlışlıkla fonksiyonların üzerine yazmamayı tercih ederseniz, tags$... stili etiketleri kullanmak yardımcı olabilir. Bu aynı zamanda mevcut etiketlerin kapsamlı bir listesi değildir. Tüm etiketlerin tam listesi burada shiny olarak mevcuttur ve daha da fazlası HTML’yi doğrudan kullanıcı arayüzünüze ekleyerek kullanılabilir!\nKendinize güveniyorsanız, herhangi birindeki stil argümanı ile HTML etiketlerinize herhangi bir css stil öğesi de ekleyebilirsiniz. Bunun nasıl çalıştığına ayrıntılı olarak girmeyeceğiz, ancak bir kullanıcı arayüzündeki estetik değişiklikleri test etmek için, chrome’da (tarayıcıda çalıştırdığınız shiny uygulamanızın) HTML denetçi modunu kullanmak ve nesnelerin stilini kendiniz düzenleyebilirsiniz!\nUygulamamıza biraz metin ekleyelim\n\nui &lt;- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         h4(\"Options\"),\n         # selector for district\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = c(\n                   \"All\",\n                   \"Spring\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selected = \"All\",\n              multiple = TRUE\n         ),\n         # selector for age group\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         ),\n    ),\n\n    mainPanel(\n      # salgın eğrisi burada bulunur\n      plotOutput(\"malaria_epicurve\"),\n      br(),\n      hr(),\n      p(\"Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:\"),\n    tags$ul(\n      tags$li(tags$b(\"location_name\"), \" - the facility that the data were collected at\"),\n      tags$li(tags$b(\"data_date\"), \" - the date the data were collected at\"),\n      tags$li(tags$b(\"submitted_daate\"), \" - the date the data were submitted at\"),\n      tags$li(tags$b(\"Province\"), \" - the province the data were collected at (all 'North' for this dataset)\"),\n      tags$li(tags$b(\"District\"), \" - the district the data were collected at\"),\n      tags$li(tags$b(\"age_group\"), \" - the age group the data were collected for (0-5, 5-14, 15+, and all ages)\"),\n      tags$li(tags$b(\"cases_reported\"), \" - the number of cases reported for the facility/age group on the given date\")\n    )\n    \n  )\n)\n)\n\n\n\n\n\n\n\n\n\n\n\n\nBir link (köprü) eklemek\nBir web sitesine link eklemek için, bağlantıyla birlikte tags\\(a() kullanın ve metni aşağıda gösterildiği gibi görüntüleyin. Bağımsız bir paragrafa için metni p() içine koyun. Bir cümlenin sadece birkaç kelimesini linke bağlamak için, cümleyi parçalara ayırın ve köprülü kısım için tag\\)a() kullanın. Bağlantının yeni bir tarayıcı penceresinde açılmasını sağlamak için argüman olarak target = “_blank” ekleyin.\n\ntags$a(href = \"www.epiRhandbook.com\", \"Visit our website!\")\n\n\n\nİndirme düğmesi eklemek\nÜç özellikten ikincisine geçelim. İndirme düğmesini uygulamaya eklemek oldukça yaygındır ve yapılması oldukça kolaydır. Kullanıcı arayüzümüze başka bir widget eklememiz gerekiyor ve bunun için sunucumuza başka bir çıktı eklememiz gerekiyor. Bu örnekte reaktif iletkenleri de tanıtabiliriz!\nÖnce kullanıcı arabirimimizi güncelleyelim - bu kolay çünkü shiny, downloadButton() adlı bir widget ile birlikte gelir - ona bir inputId ve bir etiket verelim.\n\nui &lt;- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # selector for district\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = c(\n                   \"All\",\n                   \"Spring\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selected = \"All\",\n              multiple = FALSE\n         ),\n         # yaş grubu için seçici\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         ),\n         # dikey hat\n         hr(),\n         downloadButton(\n           outputId = \"download_epicurve\",\n           label = \"Download plot\"\n         )\n\n    ),\n\n    mainPanel(\n      # salgon eğrisi buradadır\n      plotOutput(\"malaria_epicurve\"),\n      br(),\n      hr(),\n      p(\"Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:\"),\n      tags$ul(\n        tags$li(tags$b(\"location_name\"), \" - the facility that the data were collected at\"),\n        tags$li(tags$b(\"data_date\"), \" - the date the data were collected at\"),\n        tags$li(tags$b(\"submitted_daate\"), \" - the date the data were submitted at\"),\n        tags$li(tags$b(\"Province\"), \" - the province the data were collected at (all 'North' for this dataset)\"),\n        tags$li(tags$b(\"District\"), \" - the district the data were collected at\"),\n        tags$li(tags$b(\"age_group\"), \" - the age group the data were collected for (0-5, 5-14, 15+, and all ages)\"),\n        tags$li(tags$b(\"cases_reported\"), \" - the number of cases reported for the facility/age group on the given date\")\n      )\n      \n    )\n    \n  )\n)\n\nBurada ek olarak bir hr() etiketi eklediğimizi unutmayın - bu, kontrol widgetlarımızı indirme widgetlarımızdan ayıran yatay bir çizgi ekler. Bu, daha önce tartıştığımız HTML etiketlerinden bir diğeridir.\nArtık kullanıcı arayüzümüz hazır olduğuna göre, sunucu bileşenini eklememiz gerekiyor. İndirmeler, downloadHandler() fonksiyonuyla sunucuda yapılır. Grafiğimize benzer şekilde, indirme düğmesiyle aynı inputId’ye sahip bir çıktıya eklememiz gerekiyor. Bu fonkisyonun iki argümanı vardır - dosya adı ve içerik - bunların ikisi de işlevdir. Tahmin edebileceğiniz gibi, dosya adı indirilen dosyanın adını belirtmek için, içerik ise neyin indirileceğini belirtmek için kullanılır. İçerik, verileri yerel olarak kaydetmek için kullanacağınız bir fonkisyon içerir - bu nedenle, bir csv dosyası indiriyorsanız rio::export() fonksiyonunu kullanabilirsiniz. Bir grafik indirdiğimiz için ggplot2::ggsave() kullanacağız. Bunu nasıl programlayacağımıza bakalım (henüz sunucuya eklemeyeceğiz).\n\nserver &lt;- function(input, output, session) {\n  \n  output$malaria_epicurve &lt;- renderPlot(\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  )\n  \n  output$download_epicurve &lt;- downloadHandler(\n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n}\n\nİçerik fonksiyonunun her zaman çıktı dosyası adının belirtildiği bir dosya argümanına ihtiyacı olduğunu unutmayın. Burada kodu tekrarladığımızı da fark edebilirsiniz - bu sunucuda bir kez indirme için ve bir kez de uygulamada görüntülenen grafik için olmak üzere plot_epicurve() fonksiyonumuzu iki kez kullanıyoruz. Bu, performansı büyük ölçüde etkilemeyecek olsa da, , kullanıcı bölge ve yaş grubunu belirten widgetları değiştirdiğinde ve grafiği indirmek istediğinde grafiği oluşturacak kodun çalıştırılması gerektiği anlamına gelir. Daha büyük uygulamalarda, bunun gibi optimal olmayan kararlar işleri daha da yavaşlatacaktır, bu nedenle uygulamamızı bu anlamda nasıl daha verimli hale getireceğimizi öğrenmek gerekir. Daha mantıklı olan, bölgeler/yaş grupları değiştiğinde epicurve kodunu çalıştırmanın bir yolu olması ve bunun renderPlot() ve downloadHandler() fonksiyonları tarafından kullanılmasına izin verilmesidir. Burada reaktif iletkenler devreye girer!\nReaktif iletkenler, shiny sunucusunda reaktif bir şekilde oluşturulan, ancak çıktısı alınmayan nesnelerdir - yalnızca sunucunun diğer bölümleri tarafından kullanılabilirler. Birkaç farklı türde reaktif iletken vardır, ancak temel ikisini inceleyeceğiz.\n1.reactive() - bu en temel reaktif iletkendir - içinde kullanılan herhangi bir girdi değiştiğinde tepki verir (bu durumda bölge/yaş grubu widget’larımız)\n\neventReactive()- bu rektif iletken, kullanıcının hangi girişlerin tekrar çalışmasına neden olduğunu belirleyebilmesi dışında, reaktif() ile aynı şekilde çalışır. Bu, reaktif iletkeninizin işlenmesi uzun zaman alıyorsa yararlıdır, ancak reaktif iletken daha sonra açıklanacaktır.\n\nİki örneğe bakalım:\n\nmalaria_plot_r &lt;- reactive({\n  \n  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  \n})\n\n\n# sadece bölge seçici değiştiğinde çalışır!\nmalaria_plot_er &lt;- eventReactive(input$select_district, {\n  \n  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  \n})\n\neventReactive() kurulumunu kullandığımızda, bu kod parçasının çalışmasına hangi girdilerin neden olduğunu belirleyebiliriz - bu şu anda bizim için pek kullanışlı değil, bu yüzden şimdilik bırakabiliriz. c() ile birden çok giriş ekleyebileceğinizi unutmayın.\nBunu sunucu kodumuza nasıl entegre edebileceğimize bakalım:\n\nserver &lt;- function(input, output, session) {\n  \n  malaria_plot &lt;- reactive({\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  })\n  \n  \n  \n  output$malaria_epicurve &lt;- renderPlot(\n    malaria_plot()\n  )\n  \n  output$download_epicurve &lt;- downloadHandler(\n    \n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             malaria_plot(),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n}\n\nHem indirme hem de grafik oluşturma işlevlerimizde tanımladığımız reaktif iletkenimizin çıktısını çağırdığımızı görebilirsiniz. Reaktiflerin çıktılarını fonksiyon gibi kullanmanız gerekir - bu nedenle sonlarına boş parantezler eklemelisiniz (yani, malaria_plot() doğrudur ve malaria_plot değil). Artık bu çözümü de eklediğimize göre, salgın eğrisi fonksiyonunu çalıştıran tüm kodlarımız tek bir yerde olduğundan uygulamamız daha düzenli (tidy), ve hızlıdır, değiştirilmesi de daha kolay.\n\n\n\n\n\n\n\n\n\n\n\nTesis seçici eklemek\nBir sonraki özelliğimize geçelim - belirli tesisler için bir seçici. Fonksiyonumuza kodumuzdan bir argüman olarak iletebileceğimiz başka bir parametre uygulayacağız. İlk önce bunu yapmaya odaklanalım. – Yeni parametre diğer parametrelerle aynı ilkelere göre çalışır. Fonksiyonumuzu güncelleyip test edelim.\n\nplot_epicurve &lt;- function(data, district = \"All\", agegroup = \"malaria_tot\", facility = \"All\") {\n  \n  if (!(\"All\" %in% district)) {\n    data &lt;- data %&gt;%\n      filter(District %in% district)\n    \n    plot_title_district &lt;- stringr::str_glue(\"{paste0(district, collapse = ', ')} districts\")\n    \n  } else {\n    \n    plot_title_district &lt;- \"all districts\"\n    \n  }\n  \n  # kalan veri yoksa, NULL getir\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  data &lt;- data %&gt;%\n    filter(age_group == agegroup)\n  \n  \n  # kalan veri yoksa, NULL getir\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  if (agegroup == \"malaria_tot\") {\n      agegroup_title &lt;- \"All ages\"\n  } else {\n    agegroup_title &lt;- stringr::str_glue(\"{str_remove(agegroup, 'malaria_rdt')} years\")\n  }\n  \n    if (!(\"All\" %in% facility)) {\n    data &lt;- data %&gt;%\n      filter(location_name == facility)\n    \n    plot_title_facility &lt;- facility\n    \n  } else {\n    \n    plot_title_facility &lt;- \"all facilities\"\n    \n  }\n  \n  # kalan veri yoksa, NULL getir\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n\n  \n  \n  ggplot(data, aes(x = data_date, y = cases_reported)) +\n    geom_col(width = 1, fill = \"darkred\") +\n    theme_minimal() +\n    labs(\n      x = \"date\",\n      y = \"number of cases\",\n      title = stringr::str_glue(\"Malaria cases - {plot_title_district}; {plot_title_facility}\"),\n      subtitle = agegroup_title\n    )\n  \n  \n  \n}\n\nHaydi deneyelim:\n\nplot_epicurve(malaria_data, district = \"Spring\", agegroup = \"malaria_rdt_0-4\", facility = \"Facility 1\")\n\n\n\n\n\n\n\n\nVerilerimizdeki tüm tesisler için hangi tesislerin hangi bölgelere karşılık geldiği çok net değildir - ve son kullanıcı da bu bilgiye erişemeyecektir. Bu, uygulamayı kullanmayı oldukça zor hale getirebilir. Bu nedenle, kullanıcı bölgeyi değiştirdikçe UI’deki tesis seçeneklerini dinamik olarak değiştirmeliyiz - biri diğerini filtrelemelidir! Seçeneklerde kullandığımız çok fazla değişken olduğundan, global.R dosyamızdaki kullanıcı arayüzü için bazı ayarlarımızı verilerimizden oluşturmak isteyebiliriz. Örneğin, verilerimizi okuduktan sonra bu kod parçasını global.R’ye ekleyebiliriz:\n\nall_districts &lt;- c(\"All\", unique(malaria_data$District))\n\n# bölgeye göre konum adlarının veri çerçevesi\nfacility_list &lt;- malaria_data %&gt;%\n  group_by(location_name, District) %&gt;%\n  summarise() %&gt;% \n  ungroup()\n\nBölgelere bakalım\n\nall_districts\n\n[1] \"All\"     \"Spring\"  \"Bolo\"    \"Dingo\"   \"Barnard\"\n\n\n\nfacility_list\n\n# A tibble: 65 × 2\n   location_name District\n   &lt;chr&gt;         &lt;chr&gt;   \n 1 Facility 1    Spring  \n 2 Facility 10   Bolo    \n 3 Facility 11   Spring  \n 4 Facility 12   Dingo   \n 5 Facility 13   Bolo    \n 6 Facility 14   Dingo   \n 7 Facility 15   Barnard \n 8 Facility 16   Barnard \n 9 Facility 17   Barnard \n10 Facility 18   Bolo    \n# ℹ 55 more rows\n\n\nBu yeni değişkenler, hem sunucu hem de kullanıcı arabirimi tarafından global olarak görünür olduklarından, herhangi bir sorun olmadan kullanıcı arabirimine geçirebiliriz! Arayüzümüzü güncelleyelim:\n\nui &lt;- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # bölge için seçici\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = all_districts,\n              selected = \"All\",\n              multiple = FALSE\n         ),\n         # yaş grubu için seçici\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         ),\n         # kurum için seçici\n         selectInput(\n           inputId = \"select_facility\",\n           label = \"Select Facility\",\n           choices = c(\"All\", facility_list$location_name),\n           selected = \"All\"\n         ),\n         \n         # dikey çizgi\n         hr(),\n         downloadButton(\n           outputId = \"download_epicurve\",\n           label = \"Download plot\"\n         )\n\n    ),\n\n    mainPanel(\n      # salgın eğrisi buradadır\n      plotOutput(\"malaria_epicurve\"),\n      br(),\n      hr(),\n      p(\"Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:\"),\n      tags$ul(\n        tags$li(tags$b(\"location_name\"), \" - the facility that the data were collected at\"),\n        tags$li(tags$b(\"data_date\"), \" - the date the data were collected at\"),\n        tags$li(tags$b(\"submitted_daate\"), \" - the date the data were submitted at\"),\n        tags$li(tags$b(\"Province\"), \" - the province the data were collected at (all 'North' for this dataset)\"),\n        tags$li(tags$b(\"District\"), \" - the district the data were collected at\"),\n        tags$li(tags$b(\"age_group\"), \" - the age group the data were collected for (0-5, 5-14, 15+, and all ages)\"),\n        tags$li(tags$b(\"cases_reported\"), \" - the number of cases reported for the facility/age group on the given date\")\n      )\n      \n    )\n    \n  )\n)\n\nArtık seçimlerimiz için değişkenleri kullanıcı arayüzünde kodlamak yerine nasıl ilettiğimize dikkat edin! Bu, kodumuzu da daha kompakt hale getirebilir! Son olarak, sunucuyu güncellememiz gerekecek. Yeni girdimizi dahil etmek için fonksiyonumuzu güncellemek kolay olacaktır (sadece yeni parametremize bir argüman olarak iletmemiz gerekiyor), ancak kullanıcı seçilen bölgeyi değiştirdiğinde kullanıcı arayüzünün dinamik olarak güncellenmesini istediğimizi hatırlamalıyız. Uygulama çalışırken widget’ların parametrelerini ve davranışını değiştirebileceğimizi burada anlamak önemlidir, ancak bunun sunucuda yapılması gerekir. Bunun nasıl yapılacağını öğrenmek için sunucuya çıktı almanın yeni bir yolunu anlamamız gerekiyor.\nBunu gerçekleştiren fonksiyonlar, gözlemci fonksiyonlar olarak bilinir ve davranışları reaktif fonksiyonlara benzer. Yine de önemli bir farkları var: • Reaktif fonksiyonlar, çıktıları doğrudan etkilemez ve sunucudaki diğer konumlarda görülebilen nesneler üretir. • Gözlemci fonksiyonlar, sunucu çıktılarını etkileyebilir, ancak bunu diğer fonksiyonların fonksiyonlar yan etkileri yoluyla yapar. (Başka şeyler de yapabilirler, ancak pratikte bu onların ana işlevidir)\nReaktif fonksiyonlara benzer şekilde, gözlemci fonksiyonların iki çeşidi vardır ve bunlar reaktif fonksiyonlarla aynı mantıkla sınıflandırılırlar:\n\nobserve() - bu fonksiyon, kullanılan herhangi bir girdi değiştiğinde çalışır\nobserveEvent() - bu fonksiyon, kullanıcı tarafından belirlenen bir girdi değiştiğinde çalışır\n\nAyrıca, widget’ları güncelleyen shiny fonksiyonlarını da anlamamız gerekir. Bunların çalıştırılması oldukça basittir - önce sunucu fonkisyonundan oturum nesnesini alırlar (bunun şimdilik anlaşılması gerekmez), ardından değiştirilecek fonksiyonun inputId’sini alırlar. Ardından, selectInput() tarafından seçilmiş olan tüm parametrelerin yeni sürümleri iletilir - bunlar widget’ta otomatik olarak güncellenecektir.\nBunu sunucumuzda nasıl kullanabileceğimize dair izole bir örneğe bakalım. Kullanıcı bölgeyi değiştirdiğinde, tesis gruplarımızı bölgeye göre filtrelemek ve seçenekleri yalnızca o bölgede mevcut olanları) yansıtacak (ve tüm tesisler için bir seçenek oluşturacak şekilde güncellemek istiyoruz.\n\nobserve({\n  \n  if (input$select_district == \"All\") {\n    new_choices &lt;- facility_list$location_name\n  } else {\n    new_choices &lt;- facility_list %&gt;%\n      filter(District == input$select_district) %&gt;%\n      pull(location_name)\n  }\n  \n  new_choices &lt;- c(\"All\", new_choices)\n  \n  updateSelectInput(session, inputId = \"select_facility\",\n                    choices = new_choices)\n  \n})\n\nVe bu kadar! Bunu sunucumuza ekleyebiliriz ve bu davranış şimdi işe yarayacaktır. Yeni sunucumuz şöyle görünmelidir:\n\nserver &lt;- function(input, output, session) {\n  \n  malaria_plot &lt;- reactive({\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)\n  })\n  \n  \n  \n  observe({\n    \n    if (input$select_district == \"All\") {\n      new_choices &lt;- facility_list$location_name\n    } else {\n      new_choices &lt;- facility_list %&gt;%\n        filter(District == input$select_district) %&gt;%\n        pull(location_name)\n    }\n    \n    new_choices &lt;- c(\"All\", new_choices)\n    \n    updateSelectInput(session, inputId = \"select_facility\",\n                      choices = new_choices)\n    \n  })\n  \n  \n  output$malaria_epicurve &lt;- renderPlot(\n    malaria_plot()\n  )\n  \n  output$download_epicurve &lt;- downloadHandler(\n    \n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             malaria_plot(),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n  \n  \n}\n\n\n\n\n\n\n\n\n\n\n\n\nTabloya yeni bir sekme eklemek\nŞimdi uygulamamıza eklemek istediğimiz son bileşene geçeceğiz. Kullanıcı arayüzünü iki sekmeye ayırmak isteyeceğiz, bunlardan biri, kullanıcının salgın eğrisini oluşturdukları verileri görebileceği etkileşimli bir tabloya sahip olacak. Bunu yapmak için, sekmelerle ilgili shiny ile birlikte gelen paket dahili kullanıcı arabirimi öğelerini kullanabiliriz. Temel düzeyde, ana panelimizin çoğunu bu genel yapıya dahil edebiliriz:\n\n# ... kullanıcı arayüzünden geri kalan\n\nmainPanel(\n  \n  tabsetPanel(\n    type = \"tabs\",\n    tabPanel(\n      \"Epidemic Curves\",\n      ...\n    ),\n    tabPanel(\n      \"Data\",\n      ...\n    )\n  )\n)\n\nBunu kullanıcı arayüzümüze uygulayalım. Ayrıca burada DT paketini kullanmak isteyeceğiz - bu, önceden var olan verilerden etkileşimli tablolar oluşturmak için harika bir pakettir. Bu örnekte DT::datatableOutput() fonksiyonunun kullanıldığını görebiliriz.\n\nui &lt;- fluidPage(\n     \n     titlePanel(\"Malaria facility visualisation app\"),\n     \n     sidebarLayout(\n          \n          sidebarPanel(\n               # bölge için seçici\n               selectInput(\n                    inputId = \"select_district\",\n                    label = \"Select district\",\n                    choices = all_districts,\n                    selected = \"All\",\n                    multiple = FALSE\n               ),\n               # yaş grubu için seçici\n               selectInput(\n                    inputId = \"select_agegroup\",\n                    label = \"Select age group\",\n                    choices = c(\n                         \"All ages\" = \"malaria_tot\",\n                         \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                         \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                         \"15+ yrs\" = \"malaria_rdt_15\"\n                    ), \n                    selected = \"All\",\n                    multiple = FALSE\n               ),\n               # kurum için seçici\n               selectInput(\n                    inputId = \"select_facility\",\n                    label = \"Select Facility\",\n                    choices = c(\"All\", facility_list$location_name),\n                    selected = \"All\"\n               ),\n               \n               # dikey çizgi\n               hr(),\n               downloadButton(\n                    outputId = \"download_epicurve\",\n                    label = \"Download plot\"\n               )\n               \n          ),\n          \n          mainPanel(\n               tabsetPanel(\n                    type = \"tabs\",\n                    tabPanel(\n                         \"Epidemic Curves\",\n                         plotOutput(\"malaria_epicurve\")\n                    ),\n                    tabPanel(\n                         \"Data\",\n                         DT::dataTableOutput(\"raw_data\")\n                    )\n               ),\n               br(),\n               hr(),\n               p(\"Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:\"),\n               tags$ul(\n                    tags$li(tags$b(\"location_name\"), \" - the facility that the data were collected at\"),\n                    tags$li(tags$b(\"data_date\"), \" - the date the data were collected at\"),\n                    tags$li(tags$b(\"submitted_daate\"), \" - the date the data were submitted at\"),\n                    tags$li(tags$b(\"Province\"), \" - the province the data were collected at (all 'North' for this dataset)\"),\n                    tags$li(tags$b(\"District\"), \" - the district the data were collected at\"),\n                    tags$li(tags$b(\"age_group\"), \" - the age group the data were collected for (0-5, 5-14, 15+, and all ages)\"),\n                    tags$li(tags$b(\"cases_reported\"), \" - the number of cases reported for the facility/age group on the given date\")\n               )\n               \n               \n          )\n     )\n)\n\nArtık uygulamamız sekmeler halinde düzenlenmiştir! Sunucuda da gerekli düzenlemeleri yapalım. Veri setimizi oluşturmadan önce değiştirmemiz gerekmediğinden, sadece malaria_data veri setini DT::renderDT() aracılığıyla kullanıcı arayüzüne dönüştürüyoruz!\n\nserver &lt;- function(input, output, session) {\n  \n  malaria_plot &lt;- reactive({\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)\n  })\n  \n  \n  \n  observe({\n    \n    if (input$select_district == \"All\") {\n      new_choices &lt;- facility_list$location_name\n    } else {\n      new_choices &lt;- facility_list %&gt;%\n        filter(District == input$select_district) %&gt;%\n        pull(location_name)\n    }\n    \n    new_choices &lt;- c(\"All\", new_choices)\n    \n    updateSelectInput(session, inputId = \"select_facility\",\n                      choices = new_choices)\n    \n  })\n  \n  \n  output$malaria_epicurve &lt;- renderPlot(\n    malaria_plot()\n  )\n  \n  output$download_epicurve &lt;- downloadHandler(\n    \n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             malaria_plot(),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n  \n  output$raw_data &lt;- DT::renderDT(\n    malaria_data\n  )\n  \n  \n}",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Shiny ile Gösterge Panelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.tr.html#shiny-uygulamalarının-paylaşılması",
    "href": "new_pages/shiny_basics.tr.html#shiny-uygulamalarının-paylaşılması",
    "title": "43  Shiny ile Gösterge Panelleri",
    "section": "43.7 Shiny Uygulamalarının Paylaşılması",
    "text": "43.7 Shiny Uygulamalarının Paylaşılması\nArtık uygulamanızı geliştirdiğinize göre, muhtemelen başkalarıyla paylaşmak istersiniz - bu, ne de olsa shiny’nin esas avantajıdır! Paylaşımı doğrudan kodu paylaşarak yapabiliriz veya bir sunucuda yayınlayabiliriz. Kodu paylaşırsak, başkaları ne yaptığınızı görebilir ve üzerine inşa edebilir, ancak bu, shiny’nin esas avantajlarından birini ortadan kaldıracaktır - son kullanıcıların bir R yükleme zorunluluğunu ortadan kaldırabilir. Bu nedenle, uygulamanızı R kullanmayan kullanıcılarla paylaşıyorsanız, sunucuda yayınlanan bir uygulamayı paylaşmak çok daha kolaydır.\nKodu paylaşmayı tercih ederseniz, uygulamanın bir .zip dosyası oluşturabilir veya daha iyisi uygulamanızı github’da yayınlayabilir ve ortak çalışanlar ekleyebilirsiniz. Daha fazla bilgi için burada github ile ilgili bölüme başvurabilirsiniz.\nAncak, uygulamayı çevrimiçi yayınlıyorsak, biraz daha çalışmamız gerekiyor. Sonuç olarak, başkalarının hızlı ve kolay bir şekilde erişebilmesi için uygulamanıza bir web URL’si aracılığıyla erişilebilmesini istiyoruz. Ne yazık ki, uygulamanızı bir sunucuda yayınlamak için, bir sunucuya erişiminiz olması gerekir! Bu söz konusu olduğunda bir dizi barındırma seçeneği vardır:\n• brightapps.io: Bu seçenekte shiny uygulamalarını yayınlamak için yapılandırma iş yükü düşüktür ve kısmen ücretsizdir, (ancak sınırlı lisanslara sahiptir) bu nedenle, shiny uygulamaları yayınlamak için en kolay yerdir. • RStudio Connect: Bu seçenek, shiny uygulamalarını yayınlamak dahil birçok işlemi gerçekleştirebilen bir R sunucusunun güçlü bir sürümüdür. Bununla birlikte, kullanımı daha zordur ve ilk kez kullananlar için daha az tavsiye edilir.\nBu metnin amaçları doğrultusunda, ilk kez kullananlar için daha kolay olduğu için brightapps.io’yu kullanacağız. Başlamak için buradan ücretsiz bir hesap oluşturabilirsiniz - gerekirse sunucu lisansları için farklı fiyat seçenekleri de vardır. Ne kadar çok kullanıcıya sahip olmayı planlıyorsunuz, fiyat planınız o kadar pahalı olabilir, bu yüzden bunu göz önünde bulundurun. Küçük bir grup kişinin kullanması için bir uygulama oluşturmak istiyorsanız, ücretsiz bir lisans tamamen uygun olabilir, ancak halka açık bir uygulama daha fazla lisansa ihtiyaç duyabilir.\nÖncelikle uygulamamızın bir sunucuda yayınlanmaya uygun olduğundan emin olmalıyız. Uygulamanızda, R oturumunuzu yeniden başlatmalı ve herhangi bir ekstra kod çalıştırmadan çalıştığından emin olmalısınız. Bu önemlidir, çünkü paket yükleme gerektiren bir uygulama veya uygulama kodunuzda tanımlanmayan veri olması durumunda sunucuda çalışmayacaktır. Ayrıca, uygulamanızda herhangi bir açık dosya yoluna sahip olamayacağınızı unutmayın - bunlar sunucu ayarında geçersiz olacaktır - buradaki paketi kullanmak bu sorunu çok iyi çözer. Son olarak, kuruluşunuzun sunucuları gibi kullanıcı kimlik doğrulaması gerektiren bir kaynaktan veri okuyorsanız, bu genellikle bir sunucuda çalışmaz. Shiny sunucusunu beyaz listeye nasıl ekleyeceğinizi öğrenmek için bilgi işlem departmanınızla bağlantı kurmanız gerekecek.\nHesabınızı aldıktan sonra, Hesaplar altındaki belirteçler (tokens) sayfasına gidebilirsiniz. Burada yeni bir belirteç eklemek isteyeceksiniz – bu belirteç, uygulamanızı dağıtmak için kullanılacaktır. Buradan, hesabınızın url’sinin uygulamanızın adını yansıtacağını unutmamalısınız - bu nedenle uygulamanızın adı my_app ise, url xxx.io/my_app/ olarak eklenecektir. Uygulamanızın adını akıllıca seçin! Artık hazır olduğunuza göre, dağıt’a (deploy) tıklayın - başarılı olursa, bu uygulamanızı seçtiğiniz web url’sinde çalıştıracaktır!\nbelgelerde uygulama yapma konusunda ek bir şey var mı?",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Shiny ile Gösterge Panelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.tr.html#ileri-okuma",
    "href": "new_pages/shiny_basics.tr.html#ileri-okuma",
    "title": "43  Shiny ile Gösterge Panelleri",
    "section": "43.8 İleri okuma",
    "text": "43.8 İleri okuma\nŞimdiye kadar, shiny’nin birçok yönünü ele aldık ancak tüm bilgiler göz önünde bulundurulursa shiny’yi ancak yüzeyel olarak gözden geçirdik. Bu kılavuz bir giriş niteliğinde olsa da, shiny’yi tam olarak anlamak için öğrenilecek daha çok şey var. Uygulamalar oluşturmaya başlamalı ve giderek daha fazla işlevsellik eklemelisiniz.",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Shiny ile Gösterge Panelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.tr.html#önerilen-shiny-uzantıları",
    "href": "new_pages/shiny_basics.tr.html#önerilen-shiny-uzantıları",
    "title": "43  Shiny ile Gösterge Panelleri",
    "section": "43.9 Önerilen shiny uzantıları",
    "text": "43.9 Önerilen shiny uzantıları\nAşağıdakiler, shiny’den çok daha fazlasını elde etmenize yardımcı olabilecek yüksek kalitede shiny uzantıların bir seçimini temsil etmektedir. Bu uzantılar belirli bir sırada değildir:\n• brightWidgets - bu paket size uygulamanızda kullanabileceğiniz çok daha fazla widget sunar. Bu pakette mevcut widgetların bir seçimini görmek için shinyWidgets::shinyWidgetsGallery()’yi çalıştırın. buradaki örneklere bakabilirsiniz.\n• shinyjs – bu uzantı, kullanıcıya bir dizi javascript aracılığıyla shiny’ye büyük ölçüde genişletme yeteneği veren mükemmel bir pakettir. Bu paketin uygulamaları çok basitten son derece gelişmişe kadar değişir, ancak ilk önce kullanıcı arabirimini öğeleri gizleme/gösterme veya düğmeleri etkinleştirme/devre dışı bırakma gibi basit yollarla değiştirmek için kullanmak isteyebilirsiniz. Daha fazlasını buradan öğrenin:\n• shinydashboard - bu paket, shiny’de kullanılabilecek mevcut kullanıcı arayüzünü büyük ölçüde genişletir ve özellikle kullanıcının çeşitli karmaşık düzenlerle karmaşık bir panel oluşturmasına izin verir. Burada daha fazlasını görün:\n• shinydashboardPlus - shinydashboard çerçevesinden daha da fazla özellik elde edin! Burada daha fazlasını görün:\n• shinythemes - çok çeşitli önceden ayarlanmış şablonlarla shiny uygulamanız için varsayılan css temasını değiştirin! Burada daha fazlasını görün:\nShiny uyumlu etkileşimli çıktılar oluşturmak için kullanılabilecek bir dizi paket de vardır. • DT, temel shiny’ye yarı entegredir, ancak etkileşimli tablolar oluşturmak için harika bir dizi fonksiyon sağlar. • plotly, kullanıcının uygulamada değiştirebileceği etkileşimli grafikler oluşturmaya yönelik bir pakettir. Ayrıca plotly::ggplotly() yoluyla grafiğinizi etkileşimli sürümlere dönüştürebilirsiniz! Alternatif olarak, dygraphs ve highcharter da mükemmeldir.\n\nshinyWidgets - this package gives you many many more widgets that can be used in your app. Run shinyWidgets::shinyWidgetsGallery() to see a selection of available widgets with this package. See examples\nshinyjs - bu uzantı, kullanıcıya bir dizi javascript aracılığıyla shiny’ye büyük ölçüde genişletme yeteneği veren mükemmel bir pakettir. Bu paketin uygulamaları çok basitten son derece gelişmişe kadar değişir, ancak ilk önce kullanıcı arabirimini öğeleri gizleme/gösterme veya düğmeleri etkinleştirme/devre dışı bırakma gibi basit yollarla değiştirmek için kullanmak isteyebilirsiniz. Daha fazlasını buradan öğrenin.\nshinydashboard - bu paket, shiny’de kullanılabilecek mevcut kullanıcı arayüzünü büyük ölçüde genişletir ve özellikle kullanıcının çeşitli karmaşık düzenlerle karmaşık bir panel oluşturmasına izin verir. Burada daha fazlasını görün\nshinydashboardPlus - shinydashboard çerçevesinden daha da fazla özellik elde edin! Burada daha fazlasını görün.\nshinythemes - çok çeşitli önceden ayarlanmış şablonlarla shiny uygulamanız için varsayılan css temasını değiştirin! Burada daha fazlasını görün.\n\nShiny uyumlu etkileşimli çıktılar oluşturmak için kullanılabilecek bir dizi paket de vardır. • DT, temel shiny’ye yarı entegredir, ancak etkileşimli tablolar oluşturmak için harika bir dizi fonksiyon sağlar. • plotly, kullanıcının uygulamada değiştirebileceği etkileşimli grafikler oluşturmaya yönelik bir pakettir. Ayrıca plotly::ggplotly() yoluyla grafiğinizi etkileşimli sürümlere dönüştürebilirsiniz! Alternatif olarak, dygraphs ve highcharter da mükemmeldir.",
    "crumbs": [
      "Raporlar ve gösterge panoları",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Shiny ile Gösterge Panelleri</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.tr.html",
    "href": "new_pages/writing_functions.tr.html",
    "title": "44  Yazma fonksiyonları",
    "section": "",
    "text": "44.1 Hazırlık",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Yazma fonksiyonları</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.tr.html#hazırlık",
    "href": "new_pages/writing_functions.tr.html#hazırlık",
    "title": "44  Yazma fonksiyonları",
    "section": "",
    "text": "Paketleri yüklemek\nBu kod parçası, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman’dan p_load() vurgusu yapıyoruz. R tabanından library() ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakabilirsiniz.\n\n\nVerileri içe aktar\nSimüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Adım adım izlenecek verileri indirmek istiyorsanız, [Kitap ve verileri indir] sayfasındaki talimatlara bakın. Veri kümesi, rio paketinden import() fonksiyonuyla kullanılarak içe aktarılır. Verileri içe aktarmanın çeşitli yolları için [İçe ve dışa aktar] hakkındaki sayfaya bakabilirsiniz.\nAyrıca bu sayfanın son bölümünde 2013’ten itibaren H7N9 gribiyle ilgili bazı verileri kullanacağız.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Yazma fonksiyonları</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.tr.html#fonksiyonlar",
    "href": "new_pages/writing_functions.tr.html#fonksiyonlar",
    "title": "44  Yazma fonksiyonları",
    "section": "44.2 Fonksiyonlar",
    "text": "44.2 Fonksiyonlar\nFonksiyonlar, kodların daha kolay anlaşılmasını, bir şekilde daha kısa olmasını ve hataya daha az meyilli olmasını sağladıklarından (fonksiyonun kendisinde herhangi bir hata olmadığı göz önüne alındığında) programlamada faydalıdır.\nBu el kitabında bu kadar ileri gittiyseniz, R’da her işlem bir fonksiyon çağrısı olduğundan sonsuz fonksiyonlarla karşılaşmışsınız demektir. +, for, if, [, $, { …. Örneğin, “x + y”, “+”(x, y)” ile aynıdır\nR, fonksiyonlarla en fazla çalışma olanağı sunan ve kullanıcıya bunları kolayca yazabilmesi için yeterli araçları sağlayan dillerden biridir. Fonksiyonları programlama zincirinin en üstünde veya sonunda sabit olarak düşünmemeliyiz, R onları vektörlermiş gibi kullanma ve hatta başka fonksiyonlar, listeler vb. içinde kullanma imkanı sunar.\nFonksiyonel programlama üzerine çok sayıda gelişmiş kaynak mevcuttur ve biz burada yalnızca kısa pratik örneklerle fonksiyonel programlamaya başlamanıza yardımcı olacak bir fikir vereceğiz. Daha sonra bu konuda daha fazla okumak için referanslardaki bağlantıları ziyaret etmeniz önerilir.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Yazma fonksiyonları</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.tr.html#neden-bir-fonksiyon-kullanırsın",
    "href": "new_pages/writing_functions.tr.html#neden-bir-fonksiyon-kullanırsın",
    "title": "44  Yazma fonksiyonları",
    "section": "44.3 Neden bir fonksiyon kullanırsın?",
    "text": "44.3 Neden bir fonksiyon kullanırsın?\nBu soruyu yanıtlamadan önce, bu el kitabının [Yineleme, döngüler ve listeler] sayfasındaki ilk R fonksiyonunuzu yazmak için ipuçlarına zaten sahip olduğunuzu belirtmek önemlidir. Aslında, “if/else” ve döngülerin kullanımı, genellikle birden fazla koşula izin vererek kodumuzun uygulamasını genişletmeye veya görevleri tekrarlamak için kodları yinelemeye kolayca yardımcı olduklarından, çoğu fonksiyonumuzun temel bir parçasıdır.\n\nFarklı bir değişkene veya verilere uygulamak için aynı kod bloğunu birden çok kez mi tekrarlıyorum?\nOndan kurtulmak, genel kodumu önemli ölçüde kısaltır ve daha hızlı çalışmasını sağlar mı?\nYazdığım kodun tekrar kullanılması ancak kodun birçok yerinde farklı bir değerle kullanılması mümkün müdür?\n\nÖnceki sorulardan birinin cevabı “EVET” ise, muhtemelen bir fonksiyon yazmanız gerekir.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Yazma fonksiyonları</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.tr.html#r-fonksiyonları-nasıl-oluşturur",
    "href": "new_pages/writing_functions.tr.html#r-fonksiyonları-nasıl-oluşturur",
    "title": "44  Yazma fonksiyonları",
    "section": "44.4 R, fonksiyonları nasıl oluşturur?",
    "text": "44.4 R, fonksiyonları nasıl oluşturur?\nR’daki fonksiyonların üç ana bileşeni vardır:\n\nfonksiyonu nasıl çağırabileceğimizi kontrol eden değişkenlerin listesi olan formals()\nfonksiyonun içindeki kod olan body(), yani nasıl yazdığımıza bağlı olarak parantez içinde veya devamında\n\nve,\n\nfonksiyonun değişkenlerini bulmaya yardımcı olacak ve fonksiyonun nasıl değer bulacağını belirleyen environment().\n\nFonksiyonunuzu oluşturduktan sonra, ilişkili fonksiyonu çağırarak bu bileşenlerin her birini doğrulayabilirsiniz.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Yazma fonksiyonları</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.tr.html#temel-sözdizimi-ve-yapı",
    "href": "new_pages/writing_functions.tr.html#temel-sözdizimi-ve-yapı",
    "title": "44  Yazma fonksiyonları",
    "section": "44.5 Temel sözdizimi ve yapı",
    "text": "44.5 Temel sözdizimi ve yapı\n\nBir fonksiyonun adını okuduğumuz anda işinin kolayca anlaşılması için düzgün bir şekilde adlandırılması gerekir. Aslında bu, temel R mimarisinin çoğunda zaten böyledir. ‘mean()’, ‘print()’, ‘summary()’ gibi fonksiyonların çok basit adları vardır.\nBir fonksiyon, üzerinde çalışılacak veriler ve diğer seçenekler arasında statik değerler olabilen diğer nesneler gibi bağımsız değişkenlere ihtiyaç duyacaktır.\nVe son olarak bir fonksiyon, temel görevine ve kendisine verilen değişkenlere dayalı olarak bir çıktı verecektir. Genellikle çıktıyı üretmek için yerleşik fonksiyonları print(), return()… olarak kullanırız. Çıktı, mantıksal bir değer, bir sayı, bir karakter, bir veri çerçevesi… kısacası herhangi bir R nesnesi olabilir.\n\nTemel olarak bu, bir fonksiyonun bileşimidir:\n\nfunction_name &lt;- function(argument_1, argument_2, argument_3){\n  \n           function_task\n  \n           return(output)\n}\n\ncontain_covid19() olarak adlandırılacak ilk fonksiyonumuzu oluşturabiliriz.\n\ncontain_covid19 &lt;- function(barrier_gest, wear_mask, get_vaccine){\n  \n                            if(barrier_gest == \"yes\" & wear_mask == \"yes\" & get_vaccine == \"yes\" ) \n       \n                            return(\"success\")\n  \n  else(\"please make sure all are yes, this pandemic has to end!\")\n}\n\nDaha sonra yeni oluşturulan fonksiyonumuzun bileşenlerini doğrulayabiliriz.\n\nformals(contain_covid19)\n\n$barrier_gest\n\n\n$wear_mask\n\n\n$get_vaccine\n\nbody(contain_covid19)\n\n{\n    if (barrier_gest == \"yes\" & wear_mask == \"yes\" & get_vaccine == \n        \"yes\") \n        return(\"success\")\n    else (\"please make sure all are yes, this pandemic has to end!\")\n}\n\nenvironment(contain_covid19)\n\n&lt;environment: R_GlobalEnv&gt;\n\n\nŞimdi fonksiyonumuzu test edeceğiz. Yazılı fonksiyonumuzu çağırmak için, onu tüm R fonksiyonlarını kullandığınız gibi, yani fonksiyon adını yazıp gerekli değişkenleri ekleyerek kullanabilirsiniz.\n\ncontain_covid19(barrier_gest = \"yes\", wear_mask = \"yes\", get_vaccine = \"yes\")\n\n[1] \"success\"\n\n\nÖnlem amaçlı olarak her bir değişkenin adını tekrar yazabiliriz. Ancak bunları belirtmeden kod çalışmalıdır çünkü R bellekte her değişkenin konumu vardır. Değişkenlerin değerlerini doğru sıraya koyduğun sürece, fonksiyonları çağırırken değişken isimlerini yazmayı atlayabilirsiniz.\n\ncontain_covid19(\"yes\", \"yes\", \"yes\")\n\n[1] \"success\"\n\n\nO zaman değerlerden biri \"hayır\" veya \"evet\" değil ise ne olduğuna bakalım.\n\ncontain_covid19(barrier_gest = \"yes\", wear_mask = \"yes\", get_vaccine = \"no\")\n\n[1] \"please make sure all are yes, this pandemic has to end!\"\n\n\nTanınmayan bir değişken sağlarsak bir hata alırız:\n\ncontain_covid19(barrier_gest = \"sometimes\", wear_mask = \"yes\", get_vaccine = \"no\")\n\nError in contain_covid19(barrier_gest = \"sometimes\", wear_mask = \"yes\",  :    \"contain_covid19\" fonksiyonu bulunamadı\nNOT: Bazı fonksiyonlar(çoğu zaman çok kısa ve anlaşılır) bir ada ihtiyaç duymayabilir ve hızlı görev yapmak için doğrudan bir kod satırında veya başka bir fonksiyonun içinde kullanılabilir. Bunlara anonim fonksiyonlar denir.\nÖrneğin, aşağıdaki veri kümesinde yalnızca karakter değişkenlerini tutan ilk anonim fonksiyondur.\n\nlinelist %&gt;% \n  dplyr::slice_head(n=10) %&gt;%  #R tabanı \"head\" fonksiyonuna eşdeğerdir ve bu, veri kümesinin ilk n gözlemini döndürür\n  select(function(x) is.character(x)) \n\n\n\n\n\n\n\nDaha sonra, veri setimizin her ikinci gözlemini seçen başka bir fonksiyon (örneğin, tarihe veya ziyarete göre sıralandıktan sonra hasta başına çok sayıda kayıt içeren boylamsal verilerimiz olduğunda alakalı olabilir). Bu durumda, dplyr dışına yazan uygun fonksiyon, tüm satır numaralarını içeren vektöre uygulanacak function (x) (x%%2 == 0) olacaktır.\n\nlinelist %&gt;%   \n   slice_head(n=20) %&gt;% \n   tibble::rownames_to_column() %&gt;% # son seçimi net bir şekilde görmek için her bir gözlemin indekslerini satır isimleri olarak ekleyin\n   filter(row_number() %%2 == 0)\n\n\n\n\n\n\n\nAynı görev için olası bir temel R kodu şöyle olacaktır:\n\nlinelist_firstobs &lt;- head(linelist, 20)\n\nlinelist_firstobs[base::Filter(function(x) (x%%2 == 0), seq(nrow(linelist_firstobs))),]\n\n\n\n\n\n\n\nUYARI: Fonksiyonları kullanmanın kodumuzda bize yardımcı olabileceği doğru olsa da, bazı fonksiyonları yazmak, iyice düşünülmemiş, yeterince yazılmamış ve sonuç olarak hatalar döndürüyorsa, o fonksiyonu düzeltmek zaman alıcı olabilir. Bu nedenle genellikle önce R kodunun yazılması, yapmak istediğimizi yaptığından emin olunması ve ardından yukarıda listelendiği gibi üç ana bileşeni ile bir fonksiyona dönüştürülmesi önerilir.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Yazma fonksiyonları</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.tr.html#örnekler",
    "href": "new_pages/writing_functions.tr.html#örnekler",
    "title": "44  Yazma fonksiyonları",
    "section": "44.6 Örnekler",
    "text": "44.6 Örnekler\n\nBirkaç sütun için orantı tablolarını döndürmek\nEvet, zaten birçok pakette bilgileri çok kolay ve güzel bir şekilde özetlememizi sağlayan güzel fonksiyonlarımız var. Ama yine de yazma fonksiyonlarına alışmak için ilk adımlarımızda kendimizinkini yapmaya çalışacağız.\nBu örnekte, basit bir fonksiyon yazmanın, aynı kodu defalarca kopyalayıp yapıştırmanızı nasıl önleyeceğini göstermek istiyoruz.\n\nproptab_multiple &lt;- function(my_data, var_to_tab){\n  \n  #tablolamayı yapmadan önce ilgilenilen her değişkenin adını yazdırın\n  print(var_to_tab)\n\n  with(my_data,\n       rbind( #aşağıdaki iki fonksiyonun sonuçlarını satıra bağla\n        #ilgilenilen değişkeni tablo haline getirin: sadece sayıları verir\n          table(my_data[[var_to_tab]], useNA = \"no\"),\n          #ilgilenilen her değişken için oranları hesaplayın ve değeri 2 ondalık basamağa yuvarlayın\n         round(prop.table(table(my_data[[var_to_tab]]))*100,2)\n         )\n       )\n}\n\n\nproptab_multiple(linelist, \"gender\")\n\n[1] \"gender\"\n\n\n           f       m\n[1,] 2807.00 2803.00\n[2,]   50.04   49.96\n\nproptab_multiple(linelist, \"age_cat\")\n\n[1] \"age_cat\"\n\n\n         0-4     5-9  10-14  15-19   20-29 30-49 50-69 70+\n[1,] 1095.00 1095.00 941.00 743.00 1073.00   754 95.00 6.0\n[2,]   18.87   18.87  16.22  12.81   18.49    13  1.64 0.1\n\nproptab_multiple(linelist, \"outcome\")\n\n[1] \"outcome\"\n\n\n       Death Recover\n[1,] 2582.00 1983.00\n[2,]   56.56   43.44\n\n\nİPUCU: Yukarıda gösterildiği gibi, genel programlama için yaptığınız fonksiyonlarınızı yorumlamanız çok önemlidir. Bir fonksiyonun amacının bir kodu okunmaya hazır, daha kısa ve daha verimli hale getirmek olduğunu unutmayın. O zaman sadece adını okuyarak fonksiyonun ne yaptığını anlayabilmeli ve yorumları okuyarak daha fazla ayrıntıya sahip olmalıyız.\nİkinci bir seçenek, işlemi bir kerede yapmak için bu fonksiyonu bir döngü aracılığıyla başka bir fonksiyonda kullanmaktır:\n\nfor(var_to_tab in c(\"gender\",\"age_cat\",  \"outcome\")){\n  \n  print(proptab_multiple(linelist, var_to_tab))\n  \n}\n\n[1] \"gender\"\n           f       m\n[1,] 2807.00 2803.00\n[2,]   50.04   49.96\n[1] \"age_cat\"\n         0-4     5-9  10-14  15-19   20-29 30-49 50-69 70+\n[1,] 1095.00 1095.00 941.00 743.00 1073.00   754 95.00 6.0\n[2,]   18.87   18.87  16.22  12.81   18.49    13  1.64 0.1\n[1] \"outcome\"\n       Death Recover\n[1,] 2582.00 1983.00\n[2,]   56.56   43.44\n\n\nDaha basit bir yol, aşağıda ifade edildiği gibi “for loop” yerine R “apply” tabanını kullanmak olabilir:\nİPUCU:R genellikle işlevsel bir programlama dili olarak tanımlanır ve neredeyse her zaman bir kod satırı çalıştırdığınızda bazı yerleşik fonksiyonları kullanırsınız. Yazma fonksiyonları konusunda daha rahat olmak için iyi bir alışkanlık, günlük olarak kullandığınız temel fonksiyonların nasıl oluşturulduğunu sık sık içsel olarak incelemektir. Bunu yapmanın kısayolu, fonksiyonun adını seçmek ve ardından Ctrl+F2 veya fn+F2 veya Cmd+F2 (bilgisayarınıza bağlı olarak) üzerine tıklamaktır.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Yazma fonksiyonları</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.tr.html#purrr-kullanımı-yinelemeli-olarak-uygulanabilen-yazma-fonksiyonları",
    "href": "new_pages/writing_functions.tr.html#purrr-kullanımı-yinelemeli-olarak-uygulanabilen-yazma-fonksiyonları",
    "title": "44  Yazma fonksiyonları",
    "section": "44.7 purrr kullanımı: yinelemeli olarak uygulanabilen yazma fonksiyonları",
    "text": "44.7 purrr kullanımı: yinelemeli olarak uygulanabilen yazma fonksiyonları\n\nBir veri kümesindeki birden çok sütunun sınıfını değiştirin\nOrijinal ‘satır listesi’ verilerindeki birçok karakter değişkeninin analiz ve çizim amaçları için “faktör” olarak değiştirilmesi gerektiğini varsayalım. Adımı birkaç kez tekrarlamak yerine, ilgili tüm değişkenlerin dönüşümünü tek bir kod satırında yapmak için sadece lapply() kullanabiliriz.\nUYARI: lapply() bir liste döndürür, bu nedenle kullanımı son adım olarak ek bir değişiklik gerektirebilir.\nAynı adım, purrr paketindeki map_if() fonksiyonu kullanılarak da yapılabilir.\n\nlinelist_factor2 &lt;- linelist %&gt;%\n  purrr::map_if(is.character, as.factor)\n\n\nlinelist_factor2 %&gt;%\n        glimpse()\n\nList of 30\n $ case_id             : Factor w/ 5888 levels \"00031d\",\"00086d\",..: 2134 3022 396 4203 3084 4347 179 1241 5594 430 ...\n $ generation          : num [1:5888] 4 4 2 3 3 3 4 4 4 4 ...\n $ date_infection      : Date[1:5888], format: \"2014-05-08\" NA ...\n $ date_onset          : Date[1:5888], format: \"2014-05-13\" \"2014-05-13\" ...\n $ date_hospitalisation: Date[1:5888], format: \"2014-05-15\" \"2014-05-14\" ...\n $ date_outcome        : Date[1:5888], format: NA \"2014-05-18\" ...\n $ outcome             : Factor w/ 2 levels \"Death\",\"Recover\": NA 2 2 NA 2 2 2 1 2 1 ...\n $ gender              : Factor w/ 2 levels \"f\",\"m\": 2 1 2 1 2 1 1 1 2 1 ...\n $ age                 : num [1:5888] 2 3 56 18 3 16 16 0 61 27 ...\n $ age_unit            : Factor w/ 2 levels \"months\",\"years\": 2 2 2 2 2 2 2 2 2 2 ...\n $ age_years           : num [1:5888] 2 3 56 18 3 16 16 0 61 27 ...\n $ age_cat             : Factor w/ 8 levels \"0-4\",\"5-9\",\"10-14\",..: 1 1 7 4 1 4 4 1 7 5 ...\n $ age_cat5            : Factor w/ 18 levels \"0-4\",\"5-9\",\"10-14\",..: 1 1 12 4 1 4 4 1 13 6 ...\n $ hospital            : Factor w/ 6 levels \"Central Hospital\",..: 4 3 6 5 2 5 3 3 3 3 ...\n $ lon                 : num [1:5888] -13.2 -13.2 -13.2 -13.2 -13.2 ...\n $ lat                 : num [1:5888] 8.47 8.45 8.46 8.48 8.46 ...\n $ infector            : Factor w/ 2697 levels \"00031d\",\"002e6c\",..: 2594 NA NA 2635 180 1799 1407 195 NA NA ...\n $ source              : Factor w/ 2 levels \"funeral\",\"other\": 2 NA NA 2 2 2 2 2 NA NA ...\n $ wt_kg               : num [1:5888] 27 25 91 41 36 56 47 0 86 69 ...\n $ ht_cm               : num [1:5888] 48 59 238 135 71 116 87 11 226 174 ...\n $ ct_blood            : num [1:5888] 22 22 21 23 23 21 21 22 22 22 ...\n $ fever               : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n $ chills              : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n $ cough               : Factor w/ 2 levels \"no\",\"yes\": 2 NA NA 1 2 2 NA 2 2 2 ...\n $ aches               : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n $ vomit               : Factor w/ 2 levels \"no\",\"yes\": 2 NA NA 1 2 2 NA 2 2 1 ...\n $ temp                : num [1:5888] 36.8 36.9 36.9 36.8 36.9 37.6 37.3 37 36.4 35.9 ...\n $ time_admission      : Factor w/ 1072 levels \"00:10\",\"00:29\",..: NA 308 746 415 514 589 609 297 409 387 ...\n $ bmi                 : num [1:5888] 117.2 71.8 16.1 22.5 71.4 ...\n $ days_onset_hosp     : num [1:5888] 2 1 2 2 1 1 2 1 1 2 ...\n\n\n\n\nDeğişkeninin farklı seviyeleri için yinelemeli olarak grafikler üretin\nHer eyalet için H7N9 salgını sırasında Çin’de hastaların sonucunun dağılımına bakmak için burada pasta grafiği üreteceğiz. Her biri için kodu tekrarlamak yerine sadece oluşturacağımız bir fonksiyonu uygulayacağız.\n\n#highchart kullanımı için kusursuz seçenekler\noptions(highcharter.theme =   highcharter::hc_theme_smpl(tooltip = list(valueDecimals = 2)))\n\n\n#\"chart_outcome_province\" adında, veri kümesini ve sonucun dağılımını çizeceği ilin adını değişken olarak alan bir fonksiyon oluşturun.\n\nchart_outcome_province &lt;- function(data_used, prov){\n  \n  tab_prov &lt;- data_used %&gt;% \n    filter(province == prov,\n           !is.na(outcome))%&gt;% \n    group_by(outcome) %&gt;% \n    count() %&gt;%\n    adorn_totals(where = \"row\") %&gt;% \n    adorn_percentages(denominator = \"col\", )%&gt;%\n    mutate(\n        perc_outcome= round(n*100,2))\n  \n  \n  tab_prov %&gt;%\n    filter(outcome != \"Total\") %&gt;% \n  highcharter::hchart(\n    \"pie\", hcaes(x = outcome, y = perc_outcome),\n    name = paste0(\"Distibution of the outcome in:\", prov)\n    )\n  \n}\n\nchart_outcome_province(flu_china, \"Shanghai\")\n\n\n\n\nchart_outcome_province(flu_china,\"Zhejiang\")\n\n\n\n\nchart_outcome_province(flu_china,\"Jiangsu\")\n\n\n\n\n\n\n\nBir değişkenin farklı seviyeleri için yinelemeli olarak tablolar üretin\nBurada bir tablo halinde özetlemek için üç gösterge oluşturacağız ve bu tabloyu her il için üretmek istiyoruz. Göstergelerimiz, başlangıç ile hastaneye yatış arasındaki gecikme, iyileşme yüzdesi ve vakaların medyan yaşıdır.\n\nindic_1 &lt;- flu_china %&gt;% \n  group_by(province) %&gt;% \n  mutate(\n    date_hosp= strptime(date_of_hospitalisation, format = \"%m/%d/%Y\"),\n    date_ons= strptime(date_of_onset, format = \"%m/%d/%Y\"), \n    delay_onset_hosp= as.numeric(date_hosp - date_ons)/86400,\n    mean_delay_onset_hosp = round(mean(delay_onset_hosp, na.rm=TRUE ), 0)) %&gt;%\n  select(province, mean_delay_onset_hosp)  %&gt;% \n  distinct()\n     \n\nindic_2 &lt;-  flu_china %&gt;% \n            filter(!is.na(outcome)) %&gt;% \n            group_by(province, outcome) %&gt;% \n            count() %&gt;%\n            pivot_wider(names_from = outcome, values_from = n) %&gt;% \n    adorn_totals(where = \"col\") %&gt;% \n    mutate(\n        perc_recovery= round((Recover/Total)*100,2))%&gt;% \n  select(province, perc_recovery)\n    \n    \n    \nindic_3 &lt;-  flu_china %&gt;% \n            group_by(province) %&gt;% \n            mutate(\n                    median_age_cases = median(as.numeric(age), na.rm = TRUE)\n            ) %&gt;% \n  select(province, median_age_cases)  %&gt;% \n  distinct()\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `median_age_cases = median(as.numeric(age), na.rm = TRUE)`.\nℹ In group 11: `province = \"Shanghai\"`.\nCaused by warning in `median()`:\n! NAs introduced by coercion\n\n#üç gösterge veri kümesine katılın\n\ntable_indic_all &lt;- indic_1 %&gt;% \n  dplyr::left_join(indic_2, by = \"province\") %&gt;% \n        left_join(indic_3, by = \"province\")\n\n\n#göstergeleri esnek bir tabloda yazdırın\n\n\nprint_indic_prov &lt;-  function(table_used, prov){\n  \n  #önce yazdırma kolaylığı için veri çerçevesini biraz dönüştürün\n  indic_prov &lt;- table_used %&gt;%\n    filter(province==prov) %&gt;%\n    pivot_longer(names_to = \"Indicateurs\", cols = 2:4) %&gt;% \n   mutate( indic_label = factor(Indicateurs,\n   levels= c(\"mean_delay_onset_hosp\",\"perc_recovery\",\"median_age_cases\"),\n   labels=c(\"Mean delay onset-hosp\",\"Percentage of recovery\", \"Median age of the cases\"))\n   ) %&gt;% \n    ungroup(province) %&gt;% \n    select(indic_label, value)\n  \n\n    tab_print &lt;- flextable(indic_prov)  %&gt;%\n    theme_vanilla() %&gt;% \n    flextable::fontsize(part = \"body\", size = 10) \n    \n    \n     tab_print &lt;- tab_print %&gt;% \n                  autofit()   %&gt;%\n                  set_header_labels( \n                indic_label= \"Indicateurs\", value= \"Estimation\") %&gt;%\n    flextable::bg( bg = \"darkblue\", part = \"header\") %&gt;%\n    flextable::bold(part = \"header\") %&gt;%\n    flextable::color(color = \"white\", part = \"header\") %&gt;% \n    add_header_lines(values = paste0(\"Indicateurs pour la province de: \", prov)) %&gt;% \nbold(part = \"header\")\n \n tab_print &lt;- set_formatter_type(tab_print,\n   fmt_double = \"%.2f\",\n   na_str = \"-\")\n\ntab_print \n    \n}\n\n\n\n\nprint_indic_prov(table_indic_all, \"Shanghai\")\n\nIndicateurs pour la province de: ShanghaiIndicateursEstimationMean delay onset-hosp4.0Percentage of recovery46.7Median age of the cases67.0\n\nprint_indic_prov(table_indic_all, \"Jiangsu\")\n\nIndicateurs pour la province de: JiangsuIndicateursEstimationMean delay onset-hosp6.0Percentage of recovery71.4Median age of the cases55.0",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Yazma fonksiyonları</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.tr.html#iyi-işleyen-fonksiyonlar-için-ipuçları-ve-en-iyi-uygulamalar",
    "href": "new_pages/writing_functions.tr.html#iyi-işleyen-fonksiyonlar-için-ipuçları-ve-en-iyi-uygulamalar",
    "title": "44  Yazma fonksiyonları",
    "section": "44.8 İyi işleyen fonksiyonlar için ipuçları ve en iyi Uygulamalar",
    "text": "44.8 İyi işleyen fonksiyonlar için ipuçları ve en iyi Uygulamalar\nFonksiyonel programlama, kodu kolaylaştırmak içindir ve okunmasını kolaylaştırır. Aşağıdaki ipuçları, temiz bir koda ve okunması kolay bir koda sahip olmanıza yardımcı olacaktır.\n\nAdlandırma ve sözdizimi\n\nOrtamınızda zaten mevcut olan diğer fonksiyonlar tarafından kolayca alınmış olabilecek karakterleri kullanmaktan kaçının\nFonksiyon adının başka bir okuyucu için kısa ve anlaşılır olması önerilir.\nFonksiyon adı olarak fiiller, değişken adları için isimler kullanılması tercih edilir.\n\n\n\nSütun adları ve düzenli değerlendirme\nDeğişken olarak kodunuza sağlanan sütun adlarına nasıl başvuracağınızı öğrenmek istiyorsanız, bu tidyverse programlama kılavuzunu okuyabilirsiniz. Kapsanan konular arasında tidy evaluation ve embrace { } “çift ayraç” kullanımı yer alır.\nÖrneğin, hemen yukarıda bahsedilen sayfa eğitiminden hızlı bir iskelet şablon kodu:\n\nvar_summary &lt;- function(data, var) {\n  data %&gt;%\n    summarise(n = n(), min = min({{ var }}), max = max({{ var }}))\n}\nmtcars %&gt;% \n  group_by(cyl) %&gt;% \n  var_summary(mpg)\n\n\n\nTest ve Hata işleme\nBir fonksiyonun görevi ne kadar karmaşıksa, hata olasılığı da o kadar yüksek olur. Bu nedenle, bazen hatanın nereden geldiğini hızlı bir şekilde anlamaya ve düzeltmenin bir yolunu bulmaya yardımcı olmak için fonksiyona bazı doğrulamalar eklemek gerekir.\n\neksik(değişken) kullanarak bir değişkenin eksikliğini kontrol etmek şiddetle tavsiye edilmektedir. Bu basit kontrol, “DOĞRU” veya “YANLIŞ” değerini döndürebilir.\n\n\ncontain_covid19_missing &lt;- function(barrier_gest, wear_mask, get_vaccine){\n  \n  if (missing(barrier_gest)) (print(\"please provide arg1\"))\n  if (missing(wear_mask)) print(\"please provide arg2\")\n  if (missing(get_vaccine)) print(\"please provide arg3\")\n\n\n  if (!barrier_gest == \"yes\" | wear_mask ==\"yes\" | get_vaccine == \"yes\" ) \n       \n       return (\"you can do better\")\n  \n  else(\"please make sure all are yes, this pandemic has to end!\")\n}\n\n\ncontain_covid19_missing(get_vaccine = \"yes\")\n\n[1] \"please provide arg1\"\n[1] \"please provide arg2\"\n\n\nError in contain_covid19_missing(get_vaccine = \"yes\"): argument \"barrier_gest\" is missing, with no default\n\n\n\nDaha fazla algılanabilir hata için stop() kullanın.\n\n\ncontain_covid19_stop &lt;- function(barrier_gest, wear_mask, get_vaccine){\n  \n  if(!is.character(barrier_gest)) (stop(\"arg1 should be a character, please enter the value with `yes`, `no` or `sometimes\"))\n  \n  if (barrier_gest == \"yes\" & wear_mask ==\"yes\" & get_vaccine == \"yes\" ) \n       \n       return (\"success\")\n  \n  else(\"please make sure all are yes, this pandemic has to end!\")\n}\n\n\ncontain_covid19_stop(barrier_gest=1, wear_mask=\"yes\", get_vaccine = \"no\")\n\nError in contain_covid19_stop(barrier_gest = 1, wear_mask = \"yes\", get_vaccine = \"no\"): arg1 should be a character, please enter the value with `yes`, `no` or `sometimes\n\n\n\nYerleşik fonksiyonların çoğunu çalıştırdığımızda gördüğümüz gibi, belirli koşullarda açılabilen mesajlar ve uyarılar vardır. Bunları yazılı fonksiyonlarımıza message() ve warning() fonksiyonlarını kullanarak entegre edebiliriz.\nBir fonksiyonu değişken olarak alan ve onu güvenli bir şekilde yürüten safely() kullanarak da hataları halledebiliriz. Aslında, bir hatayla karşılaşırsa fonksiyon durmadan yürütülür. safely() çıktı olarak, sonuçlar ve “atladığı” hata olan iki nesne içeren bir liste döndürür.\n\nÖnce mean() fonksiyonunu fonksiyon olarak çalıştırıp sonra safely() ile çalıştırarak doğrulayabiliriz.\n\nmap(linelist, mean)\n\n$case_id\n[1] NA\n\n$generation\n[1] 16.56165\n\n$date_infection\n[1] NA\n\n$date_onset\n[1] NA\n\n$date_hospitalisation\n[1] \"2014-11-03\"\n\n$date_outcome\n[1] NA\n\n$outcome\n[1] NA\n\n$gender\n[1] NA\n\n$age\n[1] NA\n\n$age_unit\n[1] NA\n\n$age_years\n[1] NA\n\n$age_cat\n[1] NA\n\n$age_cat5\n[1] NA\n\n$hospital\n[1] NA\n\n$lon\n[1] -13.23381\n\n$lat\n[1] 8.469638\n\n$infector\n[1] NA\n\n$source\n[1] NA\n\n$wt_kg\n[1] 52.64487\n\n$ht_cm\n[1] 124.9633\n\n$ct_blood\n[1] 21.20686\n\n$fever\n[1] NA\n\n$chills\n[1] NA\n\n$cough\n[1] NA\n\n$aches\n[1] NA\n\n$vomit\n[1] NA\n\n$temp\n[1] NA\n\n$time_admission\n[1] NA\n\n$bmi\n[1] 46.89023\n\n$days_onset_hosp\n[1] NA\n\n\n\nsafe_mean &lt;- safely(mean)\nlinelist %&gt;% \n  map(safe_mean)\n\n$case_id\n$case_id$result\n[1] NA\n\n$case_id$error\nNULL\n\n\n$generation\n$generation$result\n[1] 16.56165\n\n$generation$error\nNULL\n\n\n$date_infection\n$date_infection$result\n[1] NA\n\n$date_infection$error\nNULL\n\n\n$date_onset\n$date_onset$result\n[1] NA\n\n$date_onset$error\nNULL\n\n\n$date_hospitalisation\n$date_hospitalisation$result\n[1] \"2014-11-03\"\n\n$date_hospitalisation$error\nNULL\n\n\n$date_outcome\n$date_outcome$result\n[1] NA\n\n$date_outcome$error\nNULL\n\n\n$outcome\n$outcome$result\n[1] NA\n\n$outcome$error\nNULL\n\n\n$gender\n$gender$result\n[1] NA\n\n$gender$error\nNULL\n\n\n$age\n$age$result\n[1] NA\n\n$age$error\nNULL\n\n\n$age_unit\n$age_unit$result\n[1] NA\n\n$age_unit$error\nNULL\n\n\n$age_years\n$age_years$result\n[1] NA\n\n$age_years$error\nNULL\n\n\n$age_cat\n$age_cat$result\n[1] NA\n\n$age_cat$error\nNULL\n\n\n$age_cat5\n$age_cat5$result\n[1] NA\n\n$age_cat5$error\nNULL\n\n\n$hospital\n$hospital$result\n[1] NA\n\n$hospital$error\nNULL\n\n\n$lon\n$lon$result\n[1] -13.23381\n\n$lon$error\nNULL\n\n\n$lat\n$lat$result\n[1] 8.469638\n\n$lat$error\nNULL\n\n\n$infector\n$infector$result\n[1] NA\n\n$infector$error\nNULL\n\n\n$source\n$source$result\n[1] NA\n\n$source$error\nNULL\n\n\n$wt_kg\n$wt_kg$result\n[1] 52.64487\n\n$wt_kg$error\nNULL\n\n\n$ht_cm\n$ht_cm$result\n[1] 124.9633\n\n$ht_cm$error\nNULL\n\n\n$ct_blood\n$ct_blood$result\n[1] 21.20686\n\n$ct_blood$error\nNULL\n\n\n$fever\n$fever$result\n[1] NA\n\n$fever$error\nNULL\n\n\n$chills\n$chills$result\n[1] NA\n\n$chills$error\nNULL\n\n\n$cough\n$cough$result\n[1] NA\n\n$cough$error\nNULL\n\n\n$aches\n$aches$result\n[1] NA\n\n$aches$error\nNULL\n\n\n$vomit\n$vomit$result\n[1] NA\n\n$vomit$error\nNULL\n\n\n$temp\n$temp$result\n[1] NA\n\n$temp$error\nNULL\n\n\n$time_admission\n$time_admission$result\n[1] NA\n\n$time_admission$error\nNULL\n\n\n$bmi\n$bmi$result\n[1] 46.89023\n\n$bmi$error\nNULL\n\n\n$days_onset_hosp\n$days_onset_hosp$result\n[1] NA\n\n$days_onset_hosp$error\nNULL\n\n\nDaha önce de belirtildiği gibi, kodlarımızı iyi yorumlamak, çalışmalarımızda dokümantasyona sahip olmak için zaten iyi bir yoldur.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Yazma fonksiyonları</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.tr.html#kaynaklar",
    "href": "new_pages/writing_functions.tr.html#kaynaklar",
    "title": "44  Yazma fonksiyonları",
    "section": "44.9 Kaynaklar",
    "text": "44.9 Kaynaklar\nVeri Bilimi için R\nİleri R Programlama Pratik Kılavuzu\npurr Paket Pratik Kılavuzu\nHadley Wickham’dan Video-ACM konuşması: Fonksiyonel programlamanın keyfi (map_dbl nasıl çalışır?)",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Yazma fonksiyonları</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.tr.html",
    "href": "new_pages/directories.tr.html",
    "title": "45  Dizin etkileşimleri",
    "section": "",
    "text": "45.1 Hazırlık",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Dizin etkileşimleri</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.tr.html#hazırlık",
    "href": "new_pages/directories.tr.html#hazırlık",
    "title": "45  Dizin etkileşimleri",
    "section": "",
    "text": "fs paketi\nfs paketi, dizin etkileşimlerini kolaylaştıran ve bazı R tabanı fonksiyonlarını geliştiren bir tidyverse paketidir. Aşağıdaki bölümlerde genellikle fs’den gelen fonksiyonları kullanacağız.\n\npacman::p_load(\n  fs,             # dosya/dizin etkileşimleri\n  rio,            # içe aktar/dışa aktar\n  here,           # göreceli dosya yolakları\n  tidyverse)      # veri yönetimi ve görselleştirme\n\n\n\nDizini bir dendrogram ağacı olarak yazdır\nfs’den dir_tree() fonksiyonunu kullanın.\nKlasör dosya yolunu path = olarak sağlayın ve yalnızca bir seviyeyi mi (recurse = FALSE) yoksa tüm alt seviyelerdeki tüm dosyaları mı (recurse = TRUE) göstermek istediğinize karar verin. Aşağıda, R projesi için kısayol olarak here() kullanıyoruz ve bu R el kitabı için kullanılan tüm verileri içeren alt klasör “verilerini” belirledik. “veri” ve alt klasörlerindeki (örneğin “önbellek”, “salgın modelleri”, “nüfus”, “shp” ve “hava durumu”) içindeki tüm dosyaları gösterecek şekilde ayarladık.\n\nfs::dir_tree(path = here(\"data\"), recurse = TRUE)\n\nC:/Users/ngulu864/AppData/Local/Temp/Rtmp8MqjVI/file26d814722557/data\n├── africa_countries.geo.json\n├── cache\n│   └── epidemic_models\n│       ├── 2015-04-30\n│       │   ├── estimated_reported_cases_samples.rds\n│       │   ├── estimate_samples.rds\n│       │   ├── latest_date.rds\n│       │   ├── reported_cases.rds\n│       │   ├── summarised_estimated_reported_cases.rds\n│       │   ├── summarised_estimates.rds\n│       │   └── summary.rds\n│       ├── epinow_res.rds\n│       ├── epinow_res_small.rds\n│       ├── generation_time.rds\n│       └── incubation_period.rds\n├── case_linelists\n│   ├── cleaning_dict.csv\n│   ├── fluH7N9_China_2013.csv\n│   ├── linelist_cleaned.rds\n│   ├── linelist_cleaned.xlsx\n│   └── linelist_raw.xlsx\n├── country_demographics.csv\n├── covid_example_data\n│   ├── covid_example_data.xlsx\n│   └── covid_shapefile\n│       ├── FultonCountyZipCodes.cpg\n│       ├── FultonCountyZipCodes.dbf\n│       ├── FultonCountyZipCodes.prj\n│       ├── FultonCountyZipCodes.sbn\n│       ├── FultonCountyZipCodes.sbx\n│       ├── FultonCountyZipCodes.shp\n│       ├── FultonCountyZipCodes.shp.xml\n│       └── FultonCountyZipCodes.shx\n├── covid_incidence.csv\n├── covid_incidence_map.R\n├── district_count_data.xlsx\n├── example\n│   ├── Central Hospital.csv\n│   ├── district_weekly_count_data.xlsx\n│   ├── fluH7N9_China_2013.csv\n│   ├── hospital_linelists.xlsx\n│   ├── linelists\n│   │   ├── 20201007linelist.csv\n│   │   ├── case_linelist20201006.csv\n│   │   ├── case_linelist_2020-10-02.csv\n│   │   ├── case_linelist_2020-10-03.csv\n│   │   ├── case_linelist_2020-10-04.csv\n│   │   ├── case_linelist_2020-10-05.csv\n│   │   └── case_linelist_2020-10-08.xlsx\n│   ├── Military Hospital.csv\n│   ├── Missing.csv\n│   ├── Other.csv\n│   ├── Port Hospital.csv\n│   └── St. Mark's Maternity Hospital (SMMH).csv\n├── facility_count_data.rds\n├── flexdashboard\n│   ├── outbreak_dashboard.html\n│   ├── outbreak_dashboard.Rmd\n│   ├── outbreak_dashboard_shiny.Rmd\n│   ├── outbreak_dashboard_test.html\n│   └── outbreak_dashboard_test.Rmd\n├── fluH7N9_China_2013.csv\n├── gis\n│   ├── africa_countries.geo.json\n│   ├── covid_incidence.csv\n│   ├── covid_incidence_map.R\n│   ├── linelist_cleaned_with_adm3.rds\n│   ├── population\n│   │   ├── sle_admpop_adm3_2020.csv\n│   │   └── sle_population_statistics_sierraleone_2020.xlsx\n│   └── shp\n│       ├── README.txt\n│       ├── sle_adm3.CPG\n│       ├── sle_adm3.dbf\n│       ├── sle_adm3.prj\n│       ├── sle_adm3.sbn\n│       ├── sle_adm3.sbx\n│       ├── sle_adm3.shp\n│       ├── sle_adm3.shp.xml\n│       ├── sle_adm3.shx\n│       ├── sle_hf.CPG\n│       ├── sle_hf.dbf\n│       ├── sle_hf.prj\n│       ├── sle_hf.sbn\n│       ├── sle_hf.sbx\n│       ├── sle_hf.shp\n│       └── sle_hf.shx\n├── godata\n│   ├── cases_clean.rds\n│   ├── contacts_clean.rds\n│   ├── followups_clean.rds\n│   └── relationships_clean.rds\n├── likert_data.csv\n├── linelist_cleaned.rds\n├── linelist_cleaned.xlsx\n├── linelist_raw.xlsx\n├── make_evd_dataset-DESKTOP-JIEUMMI.R\n├── make_evd_dataset.R\n├── malaria_app\n│   ├── app.R\n│   ├── data\n│   │   └── facility_count_data.rds\n│   ├── funcs\n│   │   └── plot_epicurve.R\n│   ├── global.R\n│   ├── malaria_app.Rproj\n│   ├── server.R\n│   └── ui.R\n├── malaria_facility_count_data.rds\n├── phylo\n│   ├── sample_data_Shigella_tree.csv\n│   ├── Shigella_subtree_2.nwk\n│   ├── Shigella_subtree_2.txt\n│   └── Shigella_tree.txt\n├── rmarkdown\n│   ├── outbreak_report.docx\n│   ├── outbreak_report.html\n│   ├── outbreak_report.pdf\n│   ├── outbreak_report.pptx\n│   ├── outbreak_report.Rmd\n│   ├── report_tabbed_example.html\n│   └── report_tabbed_example.Rmd\n├── standardization\n│   ├── country_demographics.csv\n│   ├── country_demographics_2.csv\n│   ├── deaths_countryA.csv\n│   ├── deaths_countryB.csv\n│   └── world_standard_population_by_sex.csv\n├── surveys\n│   ├── population.xlsx\n│   ├── survey_data.xlsx\n│   └── survey_dict.xlsx\n└── time_series\n    ├── campylobacter_germany.xlsx\n    └── weather\n        ├── germany_weather2002.nc\n        ├── germany_weather2003.nc\n        ├── germany_weather2004.nc\n        ├── germany_weather2005.nc\n        ├── germany_weather2006.nc\n        ├── germany_weather2007.nc\n        ├── germany_weather2008.nc\n        ├── germany_weather2009.nc\n        ├── germany_weather2010.nc\n        └── germany_weather2011.nc",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Dizin etkileşimleri</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.tr.html#bir-dizindeki-dosyaları-listeleyin",
    "href": "new_pages/directories.tr.html#bir-dizindeki-dosyaları-listeleyin",
    "title": "45  Dizin etkileşimleri",
    "section": "45.2 Bir dizindeki dosyaları listeleyin",
    "text": "45.2 Bir dizindeki dosyaları listeleyin\nBir dizindeki yalnızca dosya adlarını listelemek için R tabanından dir() kullanabilirsiniz. Örneğin, bu komut, içindeki “data” klasörünün “population” alt klasöründeki dosyaların adlarını listeler. Göreli dosya yolu, ‘here()’ kullanılarak sağlanır (bunun hakkında daha fazla bilgiyi [İçe aktarma ve dışa aktarma] sayfasında okuyabilirsiniz).\n\n# dosya adları\ndir(here(\"data\", \"gis\", \"population\"))\n\n[1] \"sle_admpop_adm3_2020.csv\"                       \n[2] \"sle_population_statistics_sierraleone_2020.xlsx\"\n\n\nDizin dosyalarının tam dosya yollarını listelemek için fs’den dir_ls() kullanabilirsiniz. Bir diğer R alternatifi “list.files()”dir.\n\n# dosya yolları\ndir_ls(here(\"data\", \"gis\", \"population\"))\n\nC:/Users/ngulu864/AppData/Local/Temp/Rtmp8MqjVI/file26d814722557/data/gis/population/sle_admpop_adm3_2020.csv\nC:/Users/ngulu864/AppData/Local/Temp/Rtmp8MqjVI/file26d814722557/data/gis/population/sle_population_statistics_sierraleone_2020.xlsx\n\n\nBir dizindeki her dosyayla ilgili tüm meta veri bilgilerini almak için (ör. yol, değişiklik tarihi vb.), fs’den dir_info() kullanabilirsiniz.\nBu, örneğin dosyanın en son sürümünü içe aktarmak istediğinizde, dosyanın son değişiklik zamanını çıkarmak istiyorsanız özellikle yararlı olabilir. Bunun bir örneği için [İçe ve dışa aktar] sayfasına bakın.\n\n# dosya bilgisi\ndir_info(here(\"data\", \"gis\", \"population\"))\n\nİşte döndürülen veri çerçevesi. Tüm sütunları görmek için sağa kaydırın.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Dizin etkileşimleri</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.tr.html#dosya-bilgisi",
    "href": "new_pages/directories.tr.html#dosya-bilgisi",
    "title": "45  Dizin etkileşimleri",
    "section": "45.3 Dosya bilgisi",
    "text": "45.3 Dosya bilgisi\nBelirli bir dosya hakkında meta veri bilgilerini çıkarmak için, fs’den file_info() (veya R tabanından file.info()) kullanabilirsiniz.\n\nfile_info(here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))\n\n\n\n\n\n\n\nBurada sonucu dizine eklemek ve yalnızca “modification_time” değerini döndürmek için $ kullanıyoruz.\n\nfile_info(here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))$modification_time\n\n[1] \"2024-05-10 05:58:19 CEST\"",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Dizin etkileşimleri</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.tr.html#var-olup-olmadığını-kontrol-edin",
    "href": "new_pages/directories.tr.html#var-olup-olmadığını-kontrol-edin",
    "title": "45  Dizin etkileşimleri",
    "section": "45.4 Var olup olmadığını kontrol edin",
    "text": "45.4 Var olup olmadığını kontrol edin\n\nR nesneleri\nBir R nesnesinin * R içinde * olup olmadığını kontrol etmek için ‘exists()’ kullanabilirsiniz (nesne adını tırnak içinde sağlayın).\n\nexists(\"linelist\")\n\n[1] FALSE\n\n\nBazı R tabanı paketlerinin, sahne arkasında “data” gibi genel nesne adları kullandığını ve “inherit= YANLIŞ” belirtilmediği sürece DOĞRU olarak görüneceğini unutmayın. Bu, veri kümenizi “data” olarak adlandırmamanın bir nedenidir.\n\nexists(\"data\")\n\n[1] TRUE\n\nexists(\"data\", inherit = FALSE)\n\n[1] FALSE\n\n\nBir fonksiyon yazıyorsanız, bir değişken olup olmadığını kontrol etmek için ‘exists()’ yerine ‘missing()’ kullanmalısınız.\n\n\nDizinler\nBir dizinin var olup olmadığını kontrol etmek için, fs’den is_dir() dizinine dosya yolunu (ve dosya adını) sağlayın. “TRUE” yazısının yazdırıldığını görmek için sağa kaydırın.\n\nis_dir(here(\"data\"))\n\nC:/Users/ngulu864/AppData/Local/Temp/Rtmp8MqjVI/file26d814722557/data \n                                                                 TRUE \n\n\nAlternatif olarak file.exists() kullanılabilir.\n\n\nDosyalar\nBelirli bir dosyanın var olup olmadığını kontrol etmek için fs’den is_file() kullanın. “TRUE” yazısının yazdırıldığını görmek için sağa kaydırın.\n\nis_file(here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))\n\nC:/Users/ngulu864/AppData/Local/Temp/Rtmp8MqjVI/file26d814722557/data/case_linelists/linelist_cleaned.rds \n                                                                                                     TRUE \n\n\nAlternatif olarak file.exists() kullanılabilir.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Dizin etkileşimleri</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.tr.html#oluşturmak",
    "href": "new_pages/directories.tr.html#oluşturmak",
    "title": "45  Dizin etkileşimleri",
    "section": "45.5 Oluşturmak",
    "text": "45.5 Oluşturmak\n\nDizinler\nYeni bir dizin (klasör) oluşturmak için fs’den dir_create() kullanabilirsiniz. Dizin zaten mevcutsa, üzerine yazılmaz ve hiçbir hata döndürülmez.\n\ndir_create(here(\"data\", \"test\"))\n\nBir alternatif, dizin zaten mevcutsa bir hata gösterecek olan dir.create()dir. Buna karşılık, bu senaryoda dir_create() sessiz olacaktır.\n\n\nDosyalar\nfs’den file_create() ile (boş) bir dosya oluşturabilirsiniz. Dosya zaten mevcutsa, üzerine yazılmaz veya değiştirilmez.\n\nfile_create(here(\"data\", \"test.rds\"))\n\nAlternatifi file.create(). Ancak dosya zaten mevcutsa, bu seçenek dosyayı kesecektir. file_create() kullanırsanız, dosya değişmeden kalacaktır.\n\n\nYoksa oluştur\nYAPIM AŞAMASINDA…",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Dizin etkileşimleri</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.tr.html#silmek",
    "href": "new_pages/directories.tr.html#silmek",
    "title": "45  Dizin etkileşimleri",
    "section": "45.6 Silmek",
    "text": "45.6 Silmek\n\nR nesneleri\nBir R nesnesini kaldırmak için ‘rm()’ kullanın.\n\n\nDizinler\nfs’den dir_delete() kullanın.\n\n\nDosyalar\nDosyaları fs içinden file_delete() ile silebilirsiniz.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Dizin etkileşimleri</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.tr.html#diğer-dosyaları-çalıştırma",
    "href": "new_pages/directories.tr.html#diğer-dosyaları-çalıştırma",
    "title": "45  Dizin etkileşimleri",
    "section": "45.7 Diğer dosyaları çalıştırma",
    "text": "45.7 Diğer dosyaları çalıştırma\n\nsource()\nBir R betiğini başka bir R betiğinden çalıştırmak için source() komutunu kullanabilirsiniz (R tabanından).\n\nsource(here(\"scripts\", \"cleaning_scripts\", \"clean_testing_data.R\"))\n\nBu, yukarıdaki R komut dosyasını görüntülemeye ve komut dosyasının sağ üst köşesindeki “Kaynak” düğmesine tıklamaya eşdeğerdir. Bu, betiği çalıştıracak, ancak özellikle istenmedikçe sessizce yapacak (R konsoluna çıktı yok). Soru-cevap modunda R konsolu aracılığıyla bir kullanıcıyla etkileşim kurmak için “source()” kullanma örnekleri için [Etkileşimli konsol] sayfasındaki sayfaya bakabilirsiniz.\n\n\n\n\n\n\n\n\n\n\n\nrender()\n“render()”, en sık R işaretleme komut dosyaları için kullanılan “source()”un bir varyasyonudur. R işaretleme dosyası olan input = ve ayrıca output_format = (tipik olarak “html_document”, “pdf_document”, “word_document”, ““) sağlamaktadır.\nDaha fazla ayrıntı için [R Markdown ile Raporlar] hakkındaki sayfaya bakabilirsiniz. Ayrıca “render()” belgelerine buradan veya “?render” girerek bakabilirsiniz.\n\n\nDosyaları dizinde çalıştırın\nBir for loop oluşturabilir ve bunu ‘dir()’ ile tanımlanan bir dizindeki her dosyayı ‘source()’ için kullanabilirsiniz.\n\nfor(script in dir(here(\"scripts\"), pattern = \".R$\")) {   # R Project'in \"scripts\" klasöründeki her bir komut dosyası adı için (.R uzantılı)\n  source(here(\"scripts\", script))                        # dosyayı, komut dosyaları klasöründe bulunan eşleşen adla kaynaklayın\n}\n\nYalnızca belirli komut dosyalarını çalıştırmak istiyorsanız, bunları şu şekilde adlarıyla tanımlayabilirsiniz:\n\nscripts_to_run &lt;- c(\n     \"epicurves.R\",\n     \"demographic_tables.R\",\n     \"survival_curves.R\"\n)\n\nfor(script in scripts_to_run) {\n  source(here(\"scripts\", script))\n}\n\nfs ve R tabanı fonksiyonlarının karşılaştırması\n\n\nDosyaları dizine aktarın\nTek tek dosyaları içe ve dışa aktarmak için [İçe ve dışa aktarma] hakkındaki sayfaya bakabilirsiniz.\nAyrıca dosya meta verilerine bakarak veya dosya adındaki bir tarihe dayalı olarak en son dosyayı otomatik olarak içe aktarma yöntemleri için [İçe ve dışa aktar] sayfasına bakabilirsiniz.\npurrr paketinin aşağıdakileri gösterdiği bir örnek için [Yineleme, döngüler ve listeler] hakkındaki sayfaya bakabilirsiniz:\n\nBir veri çerçevesini bölme ve birden çok CSV dosyası olarak kaydetme\nBir veri çerçevesini bölme ve her bir parçayı tek bir Excel çalışma kitabında ayrı bir sayfa olarak kaydetme\nBirden fazla CSV dosyasını içe aktarma ve bunları tek bir veri çerçevesinde birleştirme\nBirden çok sayfa içeren bir Excel çalışma kitabını içe aktarma ve bunları tek bir veri çerçevesinde birleştirme",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Dizin etkileşimleri</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.tr.html#r-tabanı",
    "href": "new_pages/directories.tr.html#r-tabanı",
    "title": "45  Dizin etkileşimleri",
    "section": "45.8 R tabanı",
    "text": "45.8 R tabanı\nBelirtilen bir dizindeki dosyaları listelemekle aynı işlemi gerçekleştiren list.files() ve dir() fonksiyonlarına aşağıda bakın. “ignore.case =” veya aranacak belirli bir desen belirtebilirsiniz.\n\nlist.files(path = here(\"data\"))\n\nlist.files(path = here(\"data\"), pattern = \".csv\")\n# dir(path = here(\"data\"), pattern = \".csv\")\n\nlist.files(path = here(\"data\"), pattern = \"evd\", ignore.case = TRUE)\n\nBir dosya şu anda “açık” ise, klasörünüzde “~$hospital_linelists.xlsx” gibi bir yaklaşık işareti olacak şekilde görüntülenir.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Dizin etkileşimleri</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.tr.html#kaynaklar",
    "href": "new_pages/directories.tr.html#kaynaklar",
    "title": "45  Dizin etkileşimleri",
    "section": "45.9 Kaynaklar",
    "text": "45.9 Kaynaklar\nhttps://cran.r-project.org/web/packages/fs/vignettes/function-comparisons.html",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Dizin etkileşimleri</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.tr.html",
    "href": "new_pages/collaboration.tr.html",
    "title": "46  Git ve Github ile sürüm kontrolü ve işbirliği",
    "section": "",
    "text": "46.1 Git nedir?\nGit, bir klasördeki değişiklikleri izlemeye izin veren bir sürüm kontrol yazılımıdır. Word, LibreOffice veya Google belgelerindeki “değişikliği izle” seçeneği gibi kullanılabilir. Sürüm kontrolü için en güçlü ve en çok kullanılan seçeneklerden biridir.\nNeden hiç duymadım?  Geliştirici geçmişine sahip kişiler rutin olarak sürüm kontrol yazılımlarını (Git, Mercurial, Subversion veya diğerleri) kullanmayı öğrenirken, nicel disiplinlerden pek azımıza bu beceriler öğretilir. Sonuç olarak, çoğu epidemiyolog, çalışmaları sırasında bunu asla duymaz ve iş sırasında öğrenmek zorundadır.\nBekle, Github’ı duydum, aynı mı? Tam olarak değil, ancak bunları sıklıkla birlikte kullanıyorsunuz ve size nasıl yapılacağını göstereceğiz. Kısacası: Git, bir yazılım parçası olan sürüm kontrol sistemidir. Bilgisayarınızda yerel olarak veya bir klasörü ana bilgisayar web sitesi ile senkronize etmek için kullanabilirsiniz. Varsayılan olarak, komut satırında Git talimatlarını vermek için bir terminal kullanılır.\nKomut satırından kaçınmak ve aynı eylemleri gerçekleştirmek için bir Git istemcisi/arayüz kullanabilirsiniz (en azından basit, çok yaygın olanlar için).\nKlasörünüzü başkalarıyla işbirliği yapmak için bir ana web sitesinde depolamak istiyorsanız, Github, Gitlab, Bitbucket veya diğerlerinde bir hesap oluşturabilirsiniz.\nBöylece, dosyalarınızı hem yerel olarak bilgisayarınızda hem de bir Github sunucusunda uzaktan yönetmek için arka planda Git kullanan Github Desktop istemcisini/arayüzünü kullanabilirsiniz.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Git ve Github ile sürüm kontrolü ve işbirliği</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.tr.html#neden-git-ve-github-kombinasyonunu-kullanmalısınız",
    "href": "new_pages/collaboration.tr.html#neden-git-ve-github-kombinasyonunu-kullanmalısınız",
    "title": "46  Git ve Github ile sürüm kontrolü ve işbirliği",
    "section": "46.2 Neden Git ve Github kombinasyonunu kullanmalısınız?",
    "text": "46.2 Neden Git ve Github kombinasyonunu kullanmalısınız?\nGit kullanımı şunları kolaylaştırır:\n\nHerhangi bir önceki duruma kolayca geri dönebilmeniz için belgelenmiş sürümleri artımlı değişikliklerle arşivleme\nParalel dallara sahip olmak, yani gözden geçirmeden sonra değişiklikleri entegre etmek için yapılandırılmış yollarla geliştirilen/“çalışan” sürümler\n\nBu, başkalarıyla işbirliği yapmasanız bile bilgisayarınızda yerel olarak yapılabilir. Sen hiç:\n\nbir kod bölümünü sildiğiniz için pişmanlık duydunuz, ancak iki ay sonra gerçekten ihtiyacınız olduğunu fark ettiniz mi?\nduraklatılmış bir projeye geri dönün ve modellerden birinde bu zor değişikliği yapıp yapmadığınızı hatırlamaya çalıştınız mı?\ndenemek için bir model_1.R dosyası ve başka bir model_1_test.R dosyası ve bir model_1_not_working.R dosyası mı vardı?\nbir report.Rmd dosyası, bir report_full.Rmd dosyası, bir report_true_final.Rmd dosyası, bir report_final_20210304.Rmd dosyası, bir report_final_20210402.Rmd dosyası vardı ve arşivleme becerilerinize lanet mi okudunuz?\n\nGit tüm bunlara yardımcı olacak ve sadece bunun için öğrenmeye değer.\nAncak, işbirlikçi projeleri desteklemek için Github gibi bir çevrimiçi depo ile kullanıldığında daha da güçlü hale gelir. Bu şunları kolaylaştırır:\n\nİşbirliği: diğerleri değişiklikleri inceleyebilir, yorumlayabilir ve değişiklikleri kabul edebilir/reddetebilir\nKodunuzu, verilerinizi ve çıktılarınızı paylaşmak ve halktan (veya ekibinizle özel olarak) geri bildirim davet etmek ve şunlardan kaçınmak:\n“Hata, son sürümü göndermeyi unuttum ve şimdi bu yeni dosya üzerinde iki günlük çalışmayı yeniden yapmanız gerekiyor”\nMina, Henry ve Oumar aynı anda tek bir komut dosyası üzerinde çalıştı ve değişikliklerini manuel olarak birleştirmeleri gerekiyor\nDropbox ve Sharepoint üzerinde iki kişi aynı dosyayı değiştirmeye çalışıyor ve bu bir senkronizasyon hatası yaratıyor.\n\n\nKulağa karmaşık geliyor, ben programcı değilim\nOlabilir. Gelişmiş kullanım örnekleri oldukça korkutucu olabilir. Ancak, R’ye ve hatta Excel’e çok benzer şekilde, aracın avantajlarından yararlanmak için uzman olmanıza gerek yoktur. Az sayıda işlev ve kavram öğrenmek, değişikliklerinizi izlemenize, dosyalarınızı çevrimiçi bir havuzda senkronize etmenize ve çok kısa bir süre içinde iş arkadaşlarınızla işbirliği yapmanıza olanak tanır.\nÖğrenme eğrisi nedeniyle, acil durum bağlamı bu araçları öğrenmek için en iyi zaman olmayabilir. Ancak öğrenme adım adım gerçekleştirilebilir. Birkaç kavram edindikten sonra, iş akışınız oldukça verimli ve hızlı olabilir.\nGit aracılığıyla insanlarla işbirliği yapmanın bir zorunluluk olduğu bir proje üzerinde çalışmıyorsanız, ortak çalışmaya dalmadan önce onu solo olarak kullanmaktan emin olmak için iyi bir zamandır.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Git ve Github ile sürüm kontrolü ve işbirliği</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.tr.html#kurmak",
    "href": "new_pages/collaboration.tr.html#kurmak",
    "title": "46  Git ve Github ile sürüm kontrolü ve işbirliği",
    "section": "46.3 Kurmak",
    "text": "46.3 Kurmak\n\nGit’i yükleyin\nGit, bilgisayarınızda değişiklikleri, dalları (sürümleri), birleştirmeleri ve geri dönmeyi izleyen perde arkasındaki motordur. Önce yapmanız gerekir https://git-scm.com/downloads adresinden Git’i yükleyin.\n\n\nBir arayüz kurun (isteğe bağlı ancak önerilir)\nGit’in komut satırı terminaline yazılabilen kendi komut dili vardır. Bununla birlikte, birçok istemci/arayüz vardır ve geliştirici olmayanlar olarak, günlük kullanımınızda Git ile doğrudan etkileşime nadiren _ihtiyacınız olur ve arayüz genellikle dosya değişiklikleri veya dalları için güzel görselleştirme araçları sağlar.\nYeni başlayanlardan daha karmaşık olanlara kadar tüm işletim sistemlerinde birçok seçenek mevcuttur. Yeni başlayanlar için iyi seçenekler arasında RStudio Git bölmesi ve Github Desktop, ki bu bölümde durum nasıl olacak.\nOrta (daha güçlü, ancak daha karmaşık) seçenekler arasında Source Tree, Gitkracken, Smart Git ve diğerleri bulunur.\nGit istemcileri hakkında hızlı açıklama.\nNot: Arabirimlerin tümü Git’i dahili olarak kullandığından, bunlardan birkaçını deneyebilir, belirli bir projede birinden diğerine geçebilir, konsolu arabiriminizin desteklemediği bir eylem için zamanında kullanabilir ve hatta üzerinde herhangi bir sayıda çevrimiçi eylem gerçekleştirebilirsiniz. Github.\nAşağıda belirtildiği gibi, zaman zaman Git komutlarını RStudio terminal bölmesi (R Konsoluna bitişik bir sekme) veya Git Bash terminali gibi bir terminale yazmanız gerekebilir.\n\n\nGithub hesabı\ngithub.com adresinde ücretsiz bir hesap için kaydolun.\nBir uygulama ile iki faktörlü kimlik doğrulamayı ayarlamanız istenebilir. Telefonunuz. Github yardım belgelerinde daha fazlasını okuyun.\nGithub Desktop kullanıyorsanız, kurulumdan sonra bu adımları izleyerek Gitub kimlik bilgilerinizi girebilirsiniz. . Bunu bilmiyorsanız, daha sonra yapmaya çalıştığınızda kimlik bilgileri sorulacaktır. Github’dan bir projeyi klonlayın.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Git ve Github ile sürüm kontrolü ve işbirliği</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.tr.html#kelime-bilgisi-kavramlar-ve-temel-işlevler",
    "href": "new_pages/collaboration.tr.html#kelime-bilgisi-kavramlar-ve-temel-işlevler",
    "title": "46  Git ve Github ile sürüm kontrolü ve işbirliği",
    "section": "46.4 Kelime bilgisi, kavramlar ve temel işlevler",
    "text": "46.4 Kelime bilgisi, kavramlar ve temel işlevler\nR öğrenirken olduğu gibi Git’i anlamak için hatırlamanız gereken biraz kelime hazinesi vardır. İşte başlamanıza yardımcı olacak temel bilgiler/ etkileşimli öğretici. Sonraki bölümlerde, arayüzlerin nasıl kullanılacağını göstereceğiz, ancak zihinsel modelinizi oluşturmak için kelime dağarcığı ve kavramları aklınızda bulundurmak iyidir ve arayüzleri kullanırken bunlara ihtiyacınız olacaktır.\n\nDepo\nGit repo (“repo”), projeniz için tüm alt klasörleri ve dosyaları (veriler, kodlar, resimler vb.) ve bunların revizyon geçmişlerini içeren bir klasördür. Depodaki değişiklikleri onunla izlemeye başladığınızda Git, tüm izleme bilgilerini içeren gizli bir klasör oluşturacaktır. Tipik bir Git deposu, R Project klasörünüzdür ([R projeleri] hakkındaki el kitabı sayfasına bakın).\nGithub, Github Desktop veya Rstudio’dan bir Git deposunun nasıl oluşturulacağını (initialize) sonraki bölümlerde göstereceğiz.\n\n\nTaahhütler\ntaahhüt, projenin belirli bir zamanda anlık görüntüsüdür. Projede bir değişiklik yaptığınızda, dosyalarınızda yapılan değişiklikleri (delta) izlemek için yeni bir taahhütte bulunacaksınız. Örneğin, bazı kod satırlarını düzenlemiş ve ilgili bir veri kümesini güncellemiş olabilirsiniz. Değişiklikleriniz kaydedildikten sonra, bu değişiklikleri tek bir “taahhüt” altında toplayabilirsiniz. Her işlemin benzersiz bir kimliği vardır (bir karma). Sürüm kontrolü amacıyla, taahhütlere dayalı olarak projenizi zamanında geri alabilirsiniz, bu nedenle onları nispeten küçük ve tutarlı tutmak en iyisidir. Ayrıca, “taahhüt mesajı” adı verilen değişikliklerin kısa bir açıklamasını da ekleyeceksiniz.\nAşamalı değişiklikler? Değişiklikleri aşamaya geçirmek, bir sonraki işleme hazırlanmak için bunları hazırlama alanına eklemektir. Buradaki fikir, belirli bir taahhütte hangi değişikliklerin dahil edileceğine ince bir şekilde karar verebilmenizdir. Örneğin, bir komut dosyasında model belirtimi üzerinde çalıştıysanız ve daha sonra başka bir komut dosyasındaki bir şekil üzerinde çalıştıysanız, iki farklı kesinliğe sahip olmak mantıklı olacaktır (şekildeki değişiklikleri geri almak isteyip modeli).\n\n\nŞubeler\nDal, deponuzdaki bağımsız bir değişiklik satırını, proje dosyalarınızın paralel, alternatif bir sürümünü temsil eder.\nDallar, değişiklikleri genellikle projenizin birincil/son/“canlı” versiyonu olan ana dalına dahil edilmeden önce test etmek için kullanışlıdır. Bir dal üzerinde denemeyi bitirdiğinizde, değişiklikleri birleştirerek ana dalınıza getirebilir veya değişiklikler o kadar başarılı olmazsa silebilirsiniz.\nNot: Şubeleri kullanmak için başka kişilerle işbirliği yapmanız veya uzak bir çevrimiçi veri havuzuna sahip olmanız gerekmez.\n\n\nYerel ve uzak depolar\nKlonlamak, Git deposunun bir kopyasını başka bir yerde oluşturmaktır.\nÖrneğin, Github’dan bilgisayarınızda yerel olarak bir çevrimiçi depoyu klonlayabilirsiniz veya yerel bir depoyla başlayabilir ve onu çevrimiçi olarak Github’a kopyalayabilirsiniz.\nBir havuzu klonladığınızda, proje dosyaları iki yerde bulunur:\n\nfiziksel bilgisayarınızdaki YEREL veri havuzu. Dosyalarda/kodda asıl değişiklikleri yaptığınız yer burasıdır.\nUZAK, çevrimiçi depo: Github deposundaki (veya başka herhangi bir web barındırıcısındaki) proje dosyalarınızın sürümleri.\n\nBu depoları senkronize etmek için daha fazla fonksiyon kullanacağız. Gerçekten de, Sharepoint, Dropbox veya diğer senkronizasyon yazılımlarından farklı olarak Git, yerel deponuzu veya çevrimiçi olanı temel alarak veya tam tersi şekilde otomatik olarak güncellemez. Ne zaman ve nasıl senkronize edeceğinizi siz seçersiniz.\n\ngit fetch uzak depodaki yeni değişiklikleri indirir ancak yerel deponuzu değiştirmez. Bunu uzak deponun durumunu kontrol etmek olarak düşünün.\ngit pull uzak depolardaki yeni değişiklikleri indirir ve yerel deponuzu günceller.\nYerel olarak bir veya birkaç taahhütte bulunduğunuzda, taahhütleri uzak depoya git push edebilirsiniz. Bu, değişikliklerinizi Github’a gönderir, böylece diğer insanlar isterlerse onları görebilir ve çekebilir.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Git ve Github ile sürüm kontrolü ve işbirliği</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.tr.html#başlayın-yeni-bir-depo-oluşturun",
    "href": "new_pages/collaboration.tr.html#başlayın-yeni-bir-depo-oluşturun",
    "title": "46  Git ve Github ile sürüm kontrolü ve işbirliği",
    "section": "46.5 Başlayın: yeni bir depo oluşturun",
    "text": "46.5 Başlayın: yeni bir depo oluşturun\nYeni depolar oluşturmanın birçok yolu vardır. Bunu konsoldan, Github’dan bir arayüzden yapabilirsiniz.\nKurulum için iki genel yaklaşım şunlardır:\n\nMevcut veya yeni bir Github deposundan yeni bir R Projesi oluşturun (yeni başlayanlar için tercih edilir) veya\nMevcut bir R projesi için bir Github deposu oluşturun\n\n\nBaşlangıç dosyaları\nYeni bir havuz oluşturduğunuzda, isteğe bağlı olarak aşağıdaki dosyaların tümünü oluşturabilir veya daha sonraki bir aşamada havuzunuza ekleyebilirsiniz. Genellikle havuzun “kök” klasöründe yaşarlar.\n\nREADME dosyası, projenizin neden var olduğunu ve onu kullanmak için başka neleri bilmeleri gerektiğini anlamak için birinin okuyabileceği bir dosyadır. İlk başta boş olacak, ancak daha sonra tamamlamanız gerekir.\nBir .gitignore dosyası, her satırın Git’in yok sayması gereken (değişiklikleri izlememesi) klasörleri veya dosyaları içerdiği bir metin dosyasıdır. Bununla ilgili daha fazla bilgi edinin ve örneklere bakınburadan.\nÇalışmanız için bir lisans seçebilirsiniz, böylece diğer insanlar çalışmanızı hangi koşullar altında kullanabileceklerini veya çoğaltabileceklerini bilsinler. Daha fazla bilgi için bkz. [Creative Commons lisansları] https://creativecommons.org/licenses/).\n\n\n\nGithub’da yeni bir depo oluşturun\nYeni bir depo oluşturmak için Github’da oturum açın ve yeni bir depo oluşturmak için yeşil düğmeyi arayın. Artık boş olan bu depo bilgisayarınıza yerel olarak klonlanabilir (bir sonraki bölüme bakın).\n\n\n\n\n\n\n\n\n\nDeponuzun genel (internetteki herkes tarafından görülebilir) veya özel (yalnızca izne sahip olanlar tarafından görülebilir) olmasını seçmelisiniz. Verileriniz hassassa, bunun önemli etkileri vardır. Deponuz özelse, kodunuzu bulutta otomatik olarak çalıştırmak için Github actions kullanıyorsanız, örneğin gelişmiş özel durumlarda bazı kotalarla karşılaşırsınız.\n\n\nGithub deposundan klonlama\nBilgisayarınızda yeni bir yerel R projesi oluşturmak için mevcut bir Github deposunu klonlayabilirsiniz.\nGithub deposu, zaten var olan ve içerik içeren bir depo olabilir veya az önce oluşturduğunuz boş bir depo olabilir. Bu ikinci durumda, esasen Github deposunu ve yerel R projesini aynı anda yaratıyorsunuz (yukarıdaki talimatlara bakın).\nNot: Bir Github deposunda katkıda bulunma hakkınız yoksa, önce depoyu profilinize fork yapmak ve ardından diğer işlemlere geçmek mümkündür. Çatallanma bu bölümün sonunda açıklanmıştır, ancak önce diğer bölümleri okumanızı öneririz.\nAdım 1: Github’da depoya gidin, yeşil “Kod” düğmesine tıklayın ve HTTPS klon URL’sini kopyalayın (aşağıdaki resme bakın)\n\n\n\n\n\n\n\n\n\nBir sonraki adım herhangi bir arayüzde gerçekleştirilebilir. Rstudio ve Github masaüstü ile örneklendireceğiz.\n\nRstudio’da\nRStudio’da Dosya &gt; Yeni Proje &gt;Sürüm Kontrolü &gt; Git’e tıklayarak yeni bir R projesi başlatın.\n\n“Depo URL’si” istendiğinde, HTTPS URL’sini Github'dan yapıştırın\nR projesine kısa, bilgilendirici bir ad verin\n\nYeni R Projesinin yerel olarak nereye kaydedileceğini seçin\n\n“Yeni oturumda aç” seçeneğini işaretleyin ve “Proje oluştur” u tıklayın\n\nArtık Github deposunun bir klonu olan yeni, yerel bir RStudio projesindesiniz. Bu yerel proje ve Github deposu artık bağlantılı.\n\n\nGithub Desktop’ta\n\nDosya &gt; Bir depoyu klonla üzerine tıklayın\nURL sekmesini seçin\nGithub’dan HTTPS URL’sini ilk kutuya yapıştırın\nYerel deponuzun olmasını istediğiniz klasörü seçin\n“KLON” u tıklayın\n\n\n\n\n\n\n\n\n\n\n\n\n\nMevcut R projesinden yeni Github deposu\nAlternatif bir kurulum senaryosu, içeriği olan mevcut bir R projeniz olması ve bunun için bir Github deposu oluşturmak istemenizdir.\n\nProje için yeni, boş bir Github deposu oluşturun (yukarıdaki talimatlara bakın)\n\nBu depoyu yerel olarak klonlayın (yukarıdaki HTTPS talimatlarına bakın)\n\nÖnceden var olan R projenizdeki tüm içeriği (kodlar, veriler, vb.) bu yeni boş, yerel depoya kopyalayın (örn. kopyala ve yapıştır kullanın).\n\nYeni projenizi RStudio’da açın ve Git bölmesine gidin. Yeni dosyalar, artık Git tarafından izlenen dosya değişiklikleri olarak kaydedilmelidir. Bu nedenle, bu değişiklikleri bir taahhüt olarak paketleyebilir ve Github’a gönderebilirsiniz. Bir kez basıldığında, Github’daki depo tüm dosyaları yansıtacaktır.\n\nBu işlemle ilgili ayrıntılar için aşağıdaki Github iş akışı bölümüne bakın.\n\n\nŞimdi nasıl görünüyor?\n\nRStudio’da\nBir Github deposunu yeni bir R projesine klonladığınızda, artık RStudio’da bir “Git” sekmesi görürsünüz. Bu sekme, R Ortamınız ile aynı RStudio bölmesinde görünür:\n\n\n\n\n\n\n\n\n\nLütfen yukarıdaki resimde daire içine alınmış butonlara dikkat edin, çünkü bunlar daha sonra atıfta bulunuldu (soldan sağa):\n\nKaydedilen dosya değişikliklerini yerel şubede kabul etme düğmesi (bu, yeni bir pencere açar)\nÇekmek için mavi ok (dalın uzak/Github sürümünde yapılan değişikliklerle şubenin yerel sürümünüzü güncelleyin)\nPush için yeşil ok (dalın yerel sürümünüz için tüm taahhütleri/değişiklikleri o dalın uzak/Github sürümüne gönderin)\nRStudio’daki Git sekmesi\nSağda taban olarak gösterilen yerel şubeyi kullanarak YENİ bir şube oluşturma düğmesi. Neredeyse her zaman ana daldan ayrılmak istersiniz (ana dalı güncellemek için ilk kez çektikten sonra)\nŞu anda çalıştığınız şube\nKodda veya diğer dosyalarda yaptığınız değişiklikler aşağıda görünecektir\n\n\n\nGithub Masaüstünde\nGithub Desktop, tüm depolarınızı yönetmenize izin veren bağımsız bir uygulamadır. Açtığınızda, arayüz üzerinde çalışmak istediğiniz depoyu seçmenize ve ardından oradan temel Git eylemlerini gerçekleştirmenize olanak tanır.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Git ve Github ile sürüm kontrolü ve işbirliği</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.tr.html#git-github-iş-akışı",
    "href": "new_pages/collaboration.tr.html#git-github-iş-akışı",
    "title": "46  Git ve Github ile sürüm kontrolü ve işbirliği",
    "section": "46.6 Git + Github iş akışı",
    "text": "46.6 Git + Github iş akışı\n\nSürece genel bakış\nKurulumu tamamladığınızda (yukarıda açıklanmıştır), yerel bir R projesine bağlı (klonlanmış) bir Github deposuna sahip olacaksınız. main dalı (varsayılan olarak oluşturulur), tüm dosyaların sözde “canlı” versiyonudur. Değişiklik yapmak istediğinizde, ana daldan yeni bir dal oluşturmak (“Kopya Oluştur” gibi) iyi bir uygulamadır. Dal oluşturmak kolay ve hızlı olduğu için bu Git’teki tipik bir iş akışıdır.\nTipik bir iş akışı aşağıdaki gibidir:\n\nYerel deponuzun güncel olduğundan emin olun, değilse güncelleyin\nDaha önce çalıştığınız şubeye gidin veya bazı şeyleri denemek için yeni bir şube oluşturun.\nBilgisayarınızda yerel olarak dosyalar üzerinde çalışın, bu şubeye bir veya birkaç taahhütte bulunun\nŞubenin uzak sürümünü değişikliklerinizle güncelleyin (push)\nŞubenizden memnun kaldığınızda, değişiklikleri aktarmak için çalışan şubenin çevrimiçi sürümünü çevrimiçi “ana” şubeye birleştirebilirsiniz.\n\nDiğer ekip üyeleri de aynı şeyi kendi şubeleriyle yapıyor olabilir veya belki de sizin çalışma şubenize taahhütlere katkıda bulunuyor olabilir.\nYukarıdaki süreci aşağıda daha ayrıntılı olarak adım adım inceliyoruz. İşte geliştirdiğimiz bir şema - iki yönlü bir tablo biçiminde olduğundan epidemiyologların anlamasına yardımcı olmalıdır.\n\n\n\n\n\n\n\n\n\nİşte başka bir şema.\nNot: Yakın zamana kadar “master” dal terimi kullanılıyordu, ancak şimdi “main” dal olarak anılıyor.\n\n\n\n\n\n\n\n\n\nGörüntü source",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Git ve Github ile sürüm kontrolü ve işbirliği</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.tr.html#yeni-bir-dal-oluştur",
    "href": "new_pages/collaboration.tr.html#yeni-bir-dal-oluştur",
    "title": "46  Git ve Github ile sürüm kontrolü ve işbirliği",
    "section": "46.7 Yeni bir dal oluştur",
    "text": "46.7 Yeni bir dal oluştur\nÜzerinde çalışmak için bir dal seçtiğinizde Git, çalışma dizininizi bu dalda en son bulunduğunuz zamanki gibi sıfırlar.\n\nRstudio Git bölmesinde\n“Ana” dalda olduğunuzdan emin olun ve ardından yeni bir dal oluşturmak için mor simgeye tıklayın (yukarıdaki resme bakın).\n\nŞubenize tek kelimelik açıklayıcı bir ad vermeniz istenecektir (gerekirse alt çizgi kullanabilirsiniz).\nYerel olarak hala aynı R projesinde olduğunuzu ancak artık “ana” dal üzerinde çalışmadığınızı göreceksiniz.\nYeni şube oluşturulduktan sonra Github web sitesinde şube olarak da görünecektir.\n\n“Geçmiş” e tıkladıktan sonra Rstudio’daki Git Bölmesi’ndeki dalları görselleştirebilirsiniz.\n\n\n\n\n\n\n\n\n\n\n\nMasaüstünde Github\nİşlem çok benzer, dalınıza bir isim vermeniz isteniyor. Ardından, yeni şubenin uzak depoda da görünmesini sağlamak için “Dalınızı Github’da yayınla” denilmelidir.\n\n\n\n\n\n\n\n\n\n\n\nKonsol Kullanırken\nPerde arkasında gerçekte olan şey, “git dalı” ile yeni bir şube oluşturmanız ve ardından “git checkout” ile dala gitmenizdir (Örneğin Git’e sonraki taahhütlerinizin orada gerçekleşeceğini söyleyin). Git deponuzdan:\n\ngit branch my-new-branch  # Yeni bir dal oluşturun\ngit checkout my-new-branch # Oluşturulan dala gidin\ngit checkout -b my-new-branch # İkisi aynı anda (Kısayol)\n\nKonsolu kullanma hakkında daha fazla bilgi için sondaki Git komutlarına bakınız.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Git ve Github ile sürüm kontrolü ve işbirliği</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.tr.html#değişiklikleri-uygula-commit-changes",
    "href": "new_pages/collaboration.tr.html#değişiklikleri-uygula-commit-changes",
    "title": "46  Git ve Github ile sürüm kontrolü ve işbirliği",
    "section": "46.8 Değişiklikleri Uygula (Commit Changes)",
    "text": "46.8 Değişiklikleri Uygula (Commit Changes)\nArtık kodu düzenleyebilir, yeni dosyalar ekleyebilir, veri kümelerini güncelleyebilirsiniz.\nDeğişikliklerinizin her biri ilgili dosya kaydedildikten sonra izlenir. Değiştirilen dosyalar RStudio Git sekmesinde, Github Desktop’ta veya terminalde ‘git status’ komutu kullanılarak görünecektir (aşağıya bakın).\nÖnemli değişiklikler yaptığınızda (örneğin, bir kod bölümü ekleme veya güncelleme), bu değişiklikleri duraklatın ve kabul edin. Bir taahhüdü, ortak bir amaçla ilgili değişikliklerin bir “topluluğu” olarak düşünün. Üzerinde değişiklik yaptıktan sonra bir dosyayı her zaman revize etmeye devam edebilirsiniz.\nUygulamayla ilgili tavsiye: genel olarak, bir sorun ortaya çıktığında kolayca geri alınabilecek küçük uygulamalar yapmak, ortak bir amaç ile ilgili değişiklikleri birlikte yapmak daha iyidir. Bunu başarmak için sık sık uygulamalarda bulunmanız gerektiğini göreceksiniz. Başlangıçta, muhtemelen sık sık uygulamada bulunmayı unutacaksınız, ancak daha sonra alışkanlık halini almaktadır.\n\nRstudio’da\nAşağıdaki örnek, son işlemden bu yana, “collaboration.Rmd” R Markdown komut dosyasının değiştiğini ve birkaç PNG görüntüsünün eklendiğini göstermektedir.\n\n\n\n\n\n\n\n\n\nDosya adlarının yanındaki sarı, mavi, yeşil ve kırmızı karelerin neyi temsil ettiğini merak ediyor olabilirsiniz. İşte RStudio kolay kullanım sayfasından anlamlarını açıklayan bir anlık görüntü. Değişikliklerin sarı “?” ile işaretlendiğine, halen görüntülenebilir, işlenebilir ve gönderilebilir(push) olduğuna dikkat edin.\n\n\n\n\n\n\n\n\n\n\nGit sekmesindeki “Commit” düğmesine basın, yeni bir pencere açılacaktır(aşağıda gösterilmiştir)\nSol üstteki kutuda bir dosya adına tıklayın\nBu dosyada yaptığınız değişiklikleri gözden geçirin (aşağıda yeşil veya kırmızı renkle vurgulanmıştır)\nGönderirken bu değişiklikleri içerecek olan dosyayı “stage” yapın. Bunu dosya adının yanındaki kutuyu işaretleyerek yapabilirsiniz. Alternatif olarak, birden fazla dosya adını vurgulayabilir ve ardından “Stage(Aşama)” yı tıklayabilir.\nKısa ama açıklayıcı bir Commit mesajı yazın (gereklidir)\n“Commit” düğmesine basın. Başarıyı gösteren bir açılır kutu veya bir hata mesajı görünecektir.\n\nArtık istediğiniz kadar değişiklikte bulunabilir ve commit edebilirsiniz.\n\n\n\n\n\n\n\n\n\n\n\nMasaüstünde Github\nSolda değiştirilen dosyaların listesini görebilirsiniz. Eğer bir metin dosyası seçerseniz, yapılan değişikliklerin bir özetini görürsünüz. sağ bölmede (görünüm .docs veya .xlsx gibi daha karmaşık dosyalarda çalışmaz).\nDeğişiklikleri düzenlemek için dosya adlarının yanındaki küçük kutuyu işaretlemeniz yeterlidir. Ne zaman bu uygulamaları eklemek istediğiniz dosyaları seçerseniz commit edebilirsiniz. Bir isim verip, isteğe bağlı olarak bir açıklama yazmanın ardından commit edilebilir.\n\n\n\n\n\n\n\n\n\n\n\nKonsolda\nSahne arkasında kullanılan iki fonksiyon, seçme/sahneleme için “git add” fonksiyonudur. dosyalar ve ‘git commit’ commit etmek içindir.\n\ngit status # değişiklikleri izle \n\ngit add new_pages/collaboration.Rmd  # commit edilecek dosyaları seçin (= değişiklikleri yapın)\n\ngit commit -m \"Describe commit from Github Desktop\" # değişiklikleri bir mesajla commit et\n\ngit log  # geçmiş commitlerle ilgili bilgileri görüntüle\n\n\n\nÖnceki bir commit’i değiştirin\nBazı değişiklikler yaparsanız, çalışmaya devam ederseniz ve geçmiş commit’e “ait” olması gereken değişiklikler yaptığınızı fark ederseniz ne olur (sizce). Korkmayın! Bu değişiklikleri önceki gönderinize ekleyebilirsiniz.\nRstudio’da, COMMIT düğmesiyle aynı satırda bir “Önceki commit’i değiştir” kutusu olduğu için oldukça açıktır.\nBelirsiz bir nedenle, işlevsellik Github Desktop’ta olduğu gibi uygulanmamıştır, ancak (kavramsal olarak garip ama kolay) bir yol vardır. Henüz değişikliklerinizi commit etmiş ancak push etmediyseniz, COMMIT düğmesinin hemen altında bir “GERİ AL” düğmesi görünür. Üzerine tıklayın geri alacaktır (ancak aşamalı dosyalarınızı ve commit mesajınızı saklayın). Değişikliklerinizi kaydedin, gerekirse commit’e yeni dosyalar ekleyin ve tekrar commit edin.\nKonsolda:\n\ngit add [YOUR FILES] # Yeni değişikliklerinizi aşamalandırın\n\ngit commit --amend  # Önceki commit'i değiştir\n\ngit commit --amend -m \"An updated commit message\"  # Önceki commitlerini değiştirin VE mesajını güncelleyin\n\nNot: Zaten herkese açık olan ve ortak çalışanlarınızla paylaşılan commitleri değiştirmeden önce düşünün.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Git ve Github ile sürüm kontrolü ve işbirliği</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.tr.html#değişiklikleri-githuba-kadar-çekin-ve-iletin",
    "href": "new_pages/collaboration.tr.html#değişiklikleri-githuba-kadar-çekin-ve-iletin",
    "title": "46  Git ve Github ile sürüm kontrolü ve işbirliği",
    "section": "46.9 Değişiklikleri Github’a kadar çekin ve iletin",
    "text": "46.9 Değişiklikleri Github’a kadar çekin ve iletin\n“Önce PULL (çekin), sonra PUSH(iletin)”\nProjeniz üzerinde çalışmaya başlamadan önce fetch(getirmek) ve pull(çekmek), yerel bilgisayarınızdaki dalın sürümünü uzak/Github sürümünde yapılan değişikliklerle güncellemek iyi bir uygulamadır.\nsık sık ÇEKİN. tereddüt etmeyin. İtmeden önce daima çekin. Değişiklikleriniz yapıldığında ve commit edildiğinde ve projenizin durumundan memnun olduğunuzda, gönderilerinizi dalınızın uzak/Github sürümüne iletebilirsiniz.\nDepo üzerinde çalışırken tekrarlayın.\nNot: Commit edilen ancak gönderilmeyen (yani hala yerel olan) değişiklikleri geri almak, uzak depoya gönderilen (ve belki de zaten başka biri tarafından çekilmiş) değişiklikleri geri almaktan çok daha kolaydır, bu nedenle üzerinde çalıştığınız görevde değişiklik yapmayı bitirdiğinizde commit etmek daha iyidir.\n\nRstudio’da\nPULL - İlk olarak, “Çek” simgesine (aşağı ok) tıklayın.\nPUSH - Yeşil “Çek” simgesine (yukarı ok) tıklayın. Github kullanıcı adınızı ve şifrenizi girmeniz istenebilir. İlk sorulduğunda, Terminal’e Git komut satırını girmeniz gerekebilir:\n\ngit config –global user.email “[siz@example.com (mailto:siz@example.com){.email}” (Github e-posta adresiniz) ve\n\ngit config –global user.name “Github kullanıcı adınız”\n\nBu komutların nasıl girileceği hakkında daha fazla bilgi edinmek için aşağıdaki Git komutları bölümüne bakın.\nİPUCU: Parolanızı çok sık mı istedi? Havuza bağlanmak için bu [eğiticinin (https://happygitwithr.com/credential-caching.html#credential-caching) 10. ve 11. bölümlerine bakın.\n\n\nGithub Desktop’ta\nUzak depoda yeni commitler olup olmadığını kontrol etmek için “Fetch Origin” düğmesine tıklayın.\n\n\n\n\n\n\n\n\n\nGit, uzak depoda yeni taahhütler bulursa, düğme bir “Çek” düğmesine dönüşür. İtme ve çekme için aynı düğme kullanıldığından, daha önce çekmediyseniz değişikliklerinizi itemezsiniz.\n\n\n\n\n\n\n\n\n\nTüm commitleri (sizin ve diğerleri) görmek için “Geçmiş” sekmesine (“Değişiklikler” sekmesinin yanında) gidebilirsiniz. Bu, işbirlikçilerinizin yaptıkları hakkında bilgi edinmenin güzel bir yoludur. Commit mesajını, varsa açıklamasını okuyabilir ve diff bölmesini kullanarak iki dosyanın kodunu karşılaştırabilirsiniz.\n\n\n\n\n\n\n\n\n\nTüm uzaktan değişiklikler çekildikten ve en az bir yerel değişiklik yapıldıktan sonra, aynı düğmeye tıklayarak basabilirsiniz.\n\n\n\n\n\n\n\n\n\n\n\nKonsol\nŞaşırtıcı olmayan bir şekilde, komutlar getir(fetch), çek(pull) ve ittir(push) şeklindedir.\n\ngit fetch  # uzak dizinde yeni commitler var mı?\ngit pull   # Uzak commitleri yerel dalınıza getirin\ngit push   # Bu dalın yerel commitlerini uzak dala aktarın\n\n\n\nÇekmek istiyorum ama yerel işim var\nBu bazen olabilir: yerel deponuzda bazı değişiklikler yaptınız, ancak uzak depo sizin çekmediğinizi commit etti.\nGit, değişikliklerinizin üzerine yazabileceği için çekmeyi reddedecek. Değişikliklerinizi korumak için [Happy Git with R (https://happygitwithr.com/pull-tricky.html) bölümünde iyi açıklanan birkaç strateji vardır. - değişikliklerinizi gerçekleştirin, uzaktan değişiklikleri alın, bunları çekin, gerekirse çakışmaları çözün (aşağıdaki bölüme bakın) ve her şeyi çevrimiçine gönderin - Değişikliklerinizi ‘saklayın’, bu tür onları bir kenara depolar, çeker, geri yükler ve ardından commit eder, herhangi bir çakışmayı çözer ve iter.\nUzak değişikliklerle ilgili dosyalar ve yerel değişikliklerinizle ilgili dosyalar çakışmıyorsa Git, çakışmaları otomatik olarak çözebilir.\nGithub Desktop’ta bu, düğmelerle yapılabilir. Saklamak için Branch&gt;Tüm değişiklikleri sakla seçeneğine gidin.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Git ve Github ile sürüm kontrolü ve işbirliği</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.tr.html#dalını-ana-gövde-ile-birleştir",
    "href": "new_pages/collaboration.tr.html#dalını-ana-gövde-ile-birleştir",
    "title": "46  Git ve Github ile sürüm kontrolü ve işbirliği",
    "section": "46.10 Dalını Ana Gövde ile birleştir",
    "text": "46.10 Dalını Ana Gövde ile birleştir\nDeğişiklik yapmayı bitirdiyseniz, bu değişiklikleri ana dalda birleştirme işlemine başlayabilirsiniz. Durumunuza bağlı olarak bu hızlı olabilir veya ekip arkadaşlarınızı içeren kasıtlı inceleme ve onay adımlarını atmış olabilirsiniz.\n\nYerel olarak Github Desktop’ta\nGithub Desktop kullanarak dalları yerel olarak birleştirebilirsiniz. İlk olarak, commitlerin alıcısı olacak dallara, yani güncellemek istediğiniz dala gidin. Ardından Dal&gt; Geçerli gövdeye birleştir menüsüne gidin ve tıklayın. Bir kutu, içe aktarmak istediğiniz dalı seçmenize olanak tanır.\n\n\n\n\n\n\n\n\n\n\n\nKonsolda\nİlk önce değişikliklerin alıcısı olacak dala geri dönün. Bu genellikle master şeklindedir, ancak başka bir dal da olabilir. Sonra master içine çalışma dalınızı birleştirin.\n\ngit checkout master  # Master'a (veya taşımak istediğiniz dala) geri dönün\ngit merge this_fancy_new_branch\n\nBu sayfa daha gelişmiş bir dallanma örneği gösterir ve perde arkasında neler olduğunu biraz açıklar .\n\n\nGithub’da: çekme istekleri gönderme\nİki dalı yerel olarak veya kimseye haber vermeden birleştirmek tamamen mümkün olmakla birlikte, bir birleşme ana gövdeye entegre edilmeden önce birkaç kişi tarafından tartışılabilir veya araştırılabilir. Sürece yardımcı olmak için Github, birleştirme ile ilgili bazı tartışma özellikleri sunar: çekme isteği.\nBir çekme isteği (bir “PR”), bir dalı diğeriyle birleştirme isteğidir (başka bir deyişle, çalışan dalınızın “ana” dala çekilmesine yönelik bir istek).\nBir çekme isteği, genellikle birden çok commit içerir. Bir çekme isteği, genellikle kabul edilmeden ve dal birleştirilmeden önce bir konuşma ve inceleme sürecini başlatır. Örneğin, [dplyr’s github] (https://github.com/tidyverse/dplyr/pulls) üzerinden çekme isteği tartışmalarını okuyabilirsiniz.\nDoğrudan web sitesinden (aşağıda gösterildiği gibi) veya Github Desktop’tan bir çekme isteği (PR) gönderebilirsiniz.\n\nGithub deposuna gidin (çevrimiçi)\n“Çekme İstekleri” sekmesini görüntüleyin ve “Yeni çekme isteği” düğmesini tıklayın\nDalınızı ana gövde ile birleştirmek için açılır menüden seçin\nAyrıntılı bir Çekme Talebi yorumu yazın ve “Çekme Talebi Oluştur” u tıklayın.\n\nAşağıdaki resimde, “ormanlar” dalı “ana” ile birleştirilmek üzere seçilmiştir:\n\n\n\n\n\n\n\n\n\nŞimdi çekme isteğini görebilmelisiniz (aşağıdaki örnek resim):\n\nDal birleştirilirse “ana” dalın nasıl değişeceğini görmek için “Dosyalar değişti” sekmesini inceleyin.\n\nSağ tarafta, Github ID’lerini etiketleyerek ekibinizin üyelerinden inceleme talep edebilirsiniz. İsterseniz, ana ile birleştirmek için havuz ayarlarını bir onay incelemesi gerektirecek şekilde ayarlayabilirsiniz.\n\nÇekme talebi onaylandıktan sonra, “Birleştirme çekme isteği” aktif hale gelecektir. Buna tıklayın.\n\nTamamlandıktan sonra dalınızı aşağıda açıklandığı gibi silin.\n\n\n\n\n\n\n\n\n\n\n\n\nÇakışmaları çözme\nİki kişi aynı satırları aynı anda değiştirdiğinde, birleştirme çatışması ortaya çıkar. Aslında Git, hangi sürümün tutulacağına karar vermeyi reddeder, ancak çatışmanın nerede olduğunu bulmanıza yardımcı olur. PANİK YAPMA. Çoğu zaman, çözmek oldukça basittir.\nÖrneğin, Github’da:\n\n\n\n\n\n\n\n\n\nBirleştirme bir çakışma yarattıktan sonra, dosyayı favori düzenleyicinizde açın. Çatışma bir dizi karakterle belirtilecektir:\n\n\n\n\n\n\n\n\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD ve ======= arasındaki metin yerel deponuzdan gelir ve ======= ile arasındaki metin &gt;&gt;&gt;&gt;&gt;&gt;&gt; diğer daldan (orijin, master veya seçtiğiniz herhangi bir dal olabilir).\nKodun hangi sürümünü tercih ettiğinize karar vermeniz (veya uygunsa her iki taraftaki değişiklikler de dahil olmak üzere üçüncü bir tane yazmanız), gerisini silmeniz ve Git’in eklediği tüm işaretleri kaldırmanız gerekir (&lt;&lt;&lt;&lt;&lt; &lt;&lt; HEAD, =======,&gt;&gt;&gt;&gt;&gt;&gt;&gt; Origin/master/your_branch_name).\nArdından, dosyayı kaydedin, düzenleyin ve commit edin: bu, birleştirilmiş sürümü “resmi” yapan committir. Daha sonra itmeyi unutmayın.\nSiz ve işbirlikçileriniz ne kadar sık ​​​​çekip iterseniz, çatışmalar o kadar küçük olur.\nNot: Konsolla kendinizi rahat hissediyorsanız, daha fazla gelişmiş birleştirme seçenekleri (ör. boşlukları yok sayma, ortak çalışana öncelik verme vb.).\n\n\nDalınızı silin\nBir dal ana dalla birleştirildiğinde ve artık gerekli olmadığında, onu silebilirsiniz.\n\n46.10.0.1 Github + Rstudio\nGithub’daki depoya gidin ve tüm dalları görüntülemek için düğmeye tıklayın (dalları seçmek için açılır menünün yanında). Şimdi dalınızı bulun ve yanındaki çöp kutusu simgesine tıklayın. Dal silmeyle ilgili daha fazla ayrıntıyı buradan okuyun -deponuzdaki-dallar#dal silme).\nDalı bilgisayarınızdan yerel olarak da sildiğinizden emin olun. Bu otomatik olarak olmayacak.\n\nRStudio’dan Ana gövdede olduğunuzdan emin olun.\nRStudio “Terminal”de (R konsolunun bitişiğindeki sekme) Git komutlarını yazmaya geçin ve şunu yazın: git branch -d branch_name, burada “branch_name” silinecek dalınızın adıdır\nGit sekmenizi yenileyin, dal gitmiş olmalı\n\n\n\n46.10.0.2 Github Masaüstünde\nSilmek istediğiniz dalı kontrol edin ve menüye gidin Dal&gt; Sil.\n\n\n\nÇatallama\nBir projeye katkıda bulunmak istiyorsanız, ancak bunu yapma hakkına sahip değilseniz veya sadece kişisel kullanımınız için değiştirmek istiyorsanız, bir projeyi çatallayabilirsiniz. Çatallamanın kısa bir açıklaması burada bulunabilir.\nGithub’da “Çatal” düğmesine tıklayın:\n\n\n\n\n\n\n\n\n\nBu, orijinal depoyu klonlayacaktır, ancak kendi profilinizde. Şimdi, Github’da deponun iki sürümü var: değiştiremeyeceğiniz orijinal sürüm ve profilinizdeki klonlanmış sürüm.\nArdından, önceki bölümlerde açıklanan yöntemlerden herhangi birini kullanarak çevrimiçi depo sürümünüzü yerel olarak bilgisayarınızda klonlamaya devam edebilirsiniz. Ardından, yeni bir dal oluşturabilir, değişiklik yapabilir, commit edebilir ve bunları uzak deponuza gönderebilirsiniz.\nSonuçtan memnun kaldığınızda, orijinal deponun sahipleri/koruyucuları ile konuşmaya başlamak için Github veya Github Desktop’tan bir Çekme Talebi oluşturabilirsiniz.\nYa resmi depodan bazı yeni commitlere ihtiyacınız olursa?\nBirinin, klonlanmış sürümünüze dahil etmek istediğiniz resmi depoda kritik bir değişiklik yaptığını hayal edin. Fork’unuzu resmi depo ile senkronize etmek mümkündür. Terminalin kullanılmasını içerir, ancak çok karmaşık değildir. Çoğunlukla şunu hatırlamanız gerekir: - upstream = değiştiremeyeceğiniz resmi depo - origin = Github profilinizdeki depo sürümünüz\n[Bu öğreticiyi (https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork) okuyabilir veya aşağıdakileri takip edebilirsiniz:\nİlk önce Git terminalinizi yazın (deponuzun içine):\n\ngit remote -v\n\nYukarı akış deposunu henüz yapılandırmadıysanız, Origin ile başlayan iki satır görmelisiniz. “fetch” ve “push”un işaret ettiği uzak depoyu gösterirler. Unutmayın, Origin, Github’daki deponun kendi sürümünüz için geleneksel takma addır. Örneğin:\n\n\n\n\n\n\n\n\n\nŞimdi yeni bir uzak depo ekleyin:\n\ngit remote add upstream https://github.com/appliedepi/epirhandbook_eng.git\n\nBurada adres, bir depoyu klonladığınızda Github’un ürettiği adrestir (klonlama ile ilgili bölüme bakın). Şimdi dört uzak işaretçiniz olacak:\n\n\n\n\n\n\n\n\n\nArtık kurulum tamamlandığında, değişiklikleri orijinal (upstream) deposundan almak istediğinizde, güncellemek istediğiniz dala(checkout) gitmeniz ve şunu yazmanız yeterlidir:\n\ngit fetch upstream # Uzak depodan yeni commitleri alın\ngit checkout the_branch_you_want_to_update\ngit merge upstream/the_branch_you_want_to_update  # Yukarı akış dalını kendi dalınızla birleştirin.\ngit push # Uzak deponun kendi sürümünüzü güncelleyin\n\nÇakışmalar varsa, bunları Çakışmaları çözme bölümünde açıklandığı gibi çözmeniz gerekecektir.\nÖzet: çatallama klonlanıyor, ancak Github sunucu tarafında. Eylemlerin geri kalanı, tipik işbirliği iş akışı eylemleridir. (klonlama, itme, çekme, commit etme, birleştirme, çekme isteklerini gönderme…).\nNot: forking bir Git komutu değildir bir kavram olsa da, [Bitbucket] https://www.atlassian.com/git/tutorials/comparing-workflows/forking-workflow gibi diğer Web ana bilgisayarlarında da bulunur).",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Git ve Github ile sürüm kontrolü ve işbirliği</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.tr.html#öğrendiklerimiz",
    "href": "new_pages/collaboration.tr.html#öğrendiklerimiz",
    "title": "46  Git ve Github ile sürüm kontrolü ve işbirliği",
    "section": "46.11 Öğrendiklerimiz",
    "text": "46.11 Öğrendiklerimiz\nŞunları nasıl yapacağınızı öğrendiniz:\n\nGit’i klasörlerinizdeki değişiklikleri takip edecek şekilde ayarlayın,\nyerel deponuzu uzak bir çevrimiçi depoya bağlayın,\ndeğişiklikleri commit edin,\nyerel ve uzak depolarınızı senkronize edin.\n\nBütün bunlar sizi harekete geçirmeli ve epidemiyologlar olarak ihtiyaçlarınızın çoğu için yeterli olmalıdır. Genellikle geliştiriciler kadar gelişmiş kullanıma sahip değiliz.\nAncak, daha ileri gitmek isterseniz (veya buna ihtiyaç duyarsanız) Git’in commit geçmişlerini basitleştirmek, bir veya birkaç işlemi geri almak, kesin bir işlem yapmak vb. için daha fazla güç sunduğunu bilin. Bazıları tam bir sihirbazlık gibi gelebilir, ancak şimdi temellere sahipseniz, üzerine inşa etmek daha kolaydır.\nRstudio ve Github Desktop’taki Git bölmesi, çalışma alanımızda yeni başlayanlar / günlük kullanım için iyi olsa da, bazı orta / gelişmiş Git işlevleri için bir arayüz sunmadıklarını unutmayın. Bazı daha eksiksiz arayüzler, işaretle ve tıkla (genellikle daha karmaşık bir düzen pahasına) ile daha fazlasını yapmanıza olanak tanır.\nDeponuzu izlemek için herhangi bir noktada herhangi bir aracı kullanabildiğiniz için, bazen denemek veya ara sıra daha az yaygın karmaşık görevleri gerçekleştirmek için bir arabirimi çok kolay bir şekilde kurabileceğinizi ve geri kalan zaman için basitleştirilmiş bir arabirimi tercih edebileceğinizi unutmayın ( örneğin çoğu zaman Github Desktop’ı kullanmak ve bazı özel görevler için SourceTree veya Gitbash’a geçmek).",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Git ve Github ile sürüm kontrolü ve işbirliği</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.tr.html#git",
    "href": "new_pages/collaboration.tr.html#git",
    "title": "46  Git ve Github ile sürüm kontrolü ve işbirliği",
    "section": "46.12 Git komutları",
    "text": "46.12 Git komutları\n\nÖnerilen öğrenim\nEtkileşimli bir eğiticide Git komutlarını öğrenmek için bu web sitesine bakabilirsiniz.\n\n\nKomutların girileceği yer\nGit kabuğuna komutlar girersiniz.\nSeçenek 1 RStudio’da yeni bir Terminal açabilirsiniz. Bu sekmenin yanında R Konsolu. İçine herhangi bir metin yazamıyorsanız, “Terminal”in altındaki açılır menüye tıklayın ve “Yeni terminal”i seçin. Komutları, dolar işareti “$” önündeki yanıp sönen boşluğa yazın.\n\n\n\n\n\n\n\n\n\nSeçenek 2 Git sekmesinde (RStudio Ortamı yakınında) mavi “dişliler” simgesine tıklayarak bir kabuk (komut girmek için bir terminal) de açabilirsiniz. Açılır menüden “Kabuk” öğesini seçin. “$” dolar işaretinden sonra komutları yazabileceğiniz yeni bir pencere açılacaktır.\nSeçenek 3 Aynı tür terminali açacak olan “Git Bash burada”yı açmak için sağ tıklayın veya uygulama listenizden Git Bash’i açın [Git Bash hakkında daha fazla başlangıç seviyesi bilgisi (https://happygitwithr.com/shell.html), nasıl bulunur ve ihtiyacınız olacak bazı bash komutları.\n\n\nÖrnek komutlar\nAşağıda birkaç yaygın git komutu sunuyoruz. Bunları kullandığınızda, eylemi değiştireceğinden, hangi dalın aktif olduğunu (check-out) aklınızda bulundurun!\nAşağıdaki komutlarda,  bir dal adını temsil eder , belirli bir commitin karma kimliğini temsil eder.  bir sayıyı temsil eder. &lt; veya &gt; sembollerini yazmayın.\n\n\n\n\n\n\n\nGit komutları\nEylem\n\n\n\n\ngit branch &lt;name&gt;\n adıyla yeni bir dal oluşturun\n\n\ngit checkout &lt;name&gt;\nGeçerli dalı  olarak değiştir\n\n\ngit checkout -b &lt;name&gt;\nYeni dal oluşturmak için kısayol * ve * ona geçiş yapın\n\n\ngit status\nİzlenmeyen değişiklikleri görün\n\n\ngit add &lt;file&gt;\nDosyayı aşamalandırma\n\n\ngit commit -m &lt;message&gt;\nŞu anda aşamalı değişiklikleri mevcut dalda mesajla commit et\n\n\ngit fetch\nUzak depodan değişiklikleri getir\n\n\ngit pull\nGeçerli daldaki uzak depodan değişiklikleri çekin\n\n\ngit push\nYerel değişiklikleri uzak dizine itin\n\n\ngit switch\nGit’te aşamalı olarak kullanılan “git checkout”a bir alternatif\n\n\ngit merge &lt;name&gt;\n dalını geçerli dal ile birleştir\n\n\ngit rebase &lt;name&gt;\nGeçerli daldan değişiklikleri  şubesine ekle",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Git ve Github ile sürüm kontrolü ve işbirliği</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.tr.html#kaynaklar",
    "href": "new_pages/collaboration.tr.html#kaynaklar",
    "title": "46  Git ve Github ile sürüm kontrolü ve işbirliği",
    "section": "46.13 Kaynaklar",
    "text": "46.13 Kaynaklar\nBu sayfanın çoğu, Jenny Bryan’ın bu “Happy Git with R” web sitesi çalışmasından faydalanılarak hazırlanmıştır. Bu web sitesinin yaygın Git sorunlarını gidermenize yardımcı olan bölümü ve R ile ilgili hatalara çok yardımcı çözümleri mevcuttur.\nGithub.com belgeleri ve başlangıç ​​kılavuzu.\nRStudio ile Git hakkında ipuçları içeren RStudio “IDE” yardım sayfası.\nhttps://ohi-science.org/news/github-coming-back-in-time\nYeni başlayanlar için Git komutları\nÖğrenmek için bir etkileşimli öğretici\nhttps://www.freecodecamp.org/news/an-introduction-to-git-for-absolute-beginners-86fa1d32ff71/: Kendi bilgisayarınızdaki bir klasördeki değişiklikleri izlemek için mutlak temel bilgileri öğrenmek için iyi.\nDalları anlamak için güzel şemalar: https://speakerdeck.com/alicebartlett/git-for-humans&gt;\nHem temel hem de ileri düzey konuları kapsayan eğitimler\nhttps://tutorialzine.com/2016/06/learn-git-in-30-dakika\nhttps://dzone.com/articles/git-tutorial-commands-and-operations-in-git https://swcarpentry.github.io/git-novice/ (kısa kurs &lt;https://rsjakob .gitbooks.io/git/content/chapter1.html&gt;\nPro Git kitabı resmi bir referans olarak kabul edilir. Bazı bölümler iyi olsa da, genellikle biraz teknik. Git’i biraz kullandıktan ve ne olduğunu ve nasıl daha ileri gidileceğini biraz daha kesin olarak öğrenmek istediğinizde muhtemelen iyi bir kaynaktır.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Git ve Github ile sürüm kontrolü ve işbirliği</span>"
    ]
  },
  {
    "objectID": "new_pages/errors.tr.html",
    "href": "new_pages/errors.tr.html",
    "title": "47  Yaygın hatalar",
    "section": "",
    "text": "47.1 Hata mesajlarını yorumlama\nR hataları bazen şifreli olabilir, bu nedenle Google sizin arkadaşınızdır. Hata mesajını “R” ile arayın ve StackExchange.com, stackoverflow.com, community.rstudio.com twitter (#rstats) ve programcılar tarafından soru ve cevapları dosyalamak için kullanılan diğer forumlar içindeki son gönderileri arayın. Benzer sorunları çözen son gönderileri bulmaya çalışın.\nÇok fazla arama yaptıktan sonra sorununuza bir yanıt bulamıyorsanız, tekrarlanabilir bir örnek (“reprex”) oluşturmayı ve soruyu kendiniz göndermeyi düşünün. Tekrarlanabilir bir örneğin nasıl oluşturulacağı ve forumlara nasıl gönderileceğiyle ilgili ipuçları için [Yardım alma] hakkındaki sayfaya bakabilirsiniz.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Yaygın hatalar</span>"
    ]
  },
  {
    "objectID": "new_pages/errors.tr.html#yaygın-hatalar",
    "href": "new_pages/errors.tr.html#yaygın-hatalar",
    "title": "47  Yaygın hatalar",
    "section": "47.2 Yaygın hatalar",
    "text": "47.2 Yaygın hatalar\nAşağıda, bazı yaygın hataları ve olası açıklamaları/çözümleri listeliyoruz. Bunlardan bazıları, Stack Overflow’ta R hata mesajları hakkında en yaygın forum gönderilerini analiz eden Noam Ross’tan ödünç alınmıştır (analiz için buraya bakın /stack-overflow-common-r-errors.md))\n\nYazım hataları\nError: unexpected symbol in:\n\"  geom_histogram(stat = \"identity\")+\n  tidyquant::geom_ma(n=7, size = 2, color = \"red\" lty\"\n“Beklenmeyen simge” görürseniz, eksik virgül olup olmadığını kontrol edin\n\n\nPaket hataları\ncould not find function \"x\"...\nBu muhtemelen fonksiyon adını yanlış yazdığınız veya bir paketi yüklemeyi unuttuğunuz anlamına gelir.\nError in select(data, var) : unused argument (var)\n‘dplyr::select()’ kullandığınızı düşünüyorsunuz, ancak ‘select()’ fonksiyonu ‘MASS::select()’, ‘dplyr::’ belirten veya dplyr için paketinizi yeniden sipariş eden tarafından maskelenmiştir.\nDiğer yaygın maskeleme hataları şunlardan kaynaklanır: “plyr::summarise()” ve “stats::filter()”. Çatışmalı paketi kullanmayı düşünün.\nError in install.packages : ERROR: failed to lock directory ‘C:\\Users\\Name\\Documents\\R\\win-library\\4.0’ for modifying\nTry removing ‘C:\\Users\\Name\\Documents\\R\\win-library\\4.0/00LOCK’\nBir “00LOCK” dosyasını kaldırmanız gerektiğini söyleyen bir hata alırsanız, bilgisayar dizininizdeki “R” kitaplığınıza gidin (örn. R/win-library/) ve “00LOCK” adlı bir klasör arayın. Bunu manuel olarak silin ve paketi yeniden yüklemeyi deneyin. Daha önceki bir yükleme işlemi muhtemelen kesintiye uğramıştır ve bu duruma yol açmıştır.\n\n\nNesne hataları\nNo such file or directory:\nDışa veya içe aktarmaya çalıştığınızda böyle bir hata görürseniz: Dosyanın ve dosya yolunun yazımını kontrol edin ve yol eğik çizgi içeriyorsa bunların ileri / olduğundan ve geriye doğru değil \\ olduğundan emin olun. Ayrıca doğru dosya uzantısını (ör. .csv, .xlsx) kullandığınızdan emin olun.\nobject 'x' not found \nBu, başvurduğunuz bir nesnenin mevcut olmadığı anlamına gelir. Belki yukarıdaki kod düzgün çalışmamıştır?\nError in 'x': subscript out of bounds\nBu, orada olmayan bir şeye (bir vektörün veya bir listenin öğesi) erişmeye çalıştığınız anlamına gelir.\n\n\nFonksiyon sözdizimi hataları\n# mutate(x = recode(x, OLD= NEW) içindeki x değişkenini yeniden belirtmek için kodu tekrarlayın\nError: Problem with `mutate()` input `hospital`.\nx argument \".x\" is missing, with no default\ni Input `hospital` is `recode(...)`.\nSütunun adını ilk değişken olarak sağlamanızı beklediği yerde “recode()” veya “replace_na()” gibi bir fonksiyon sağlıyorsanız, yukarıdaki bu hata (“değişken .x eksik, varsayılan yok”) “mutate()”de yaygındır. Bunu unutmak kolaydır.\n\n\nMantık hataları\nError in if\nBu, muhtemelen DOĞRU veya YANLIŞ olmayan bir şeye bir “if” ifadesinin uygulandığı anlamına gelir.\n\n\nFaktör hataları\n#Bir faktöre bir değer (\"Eksik\") eklemeye çalışın (bir faktör üzerinde çalışan replace_na ile)\n'age_cat' girişi 'mutate()' ile ilgili sorun olur.\ni invalid factor level, NA generated\ni Input `age_cat` is `replace_na(age_cat, \"Missing\")`.invalid factor level, NA generated\nGeçersiz faktör seviyeleri hakkında bu hatayı görüyorsanız, muhtemelen bir sınıf Faktör sütununuz (önceden tanımlanmış seviyeleri içeren) var ve ona yeni bir değer eklemeye çalışıyorsunuz. Yeni bir değer eklemeden önce onu Karakter sınıfına dönüştürün.\n\n\nÇizim hataları\nError: Insufficient values in manual scale. 3 needed but only 2 provided. ggplot() scale_fill_manual() değerleri = c(“turuncu”, “mor”) … faktör düzeyi sayısı için yetersiz … NA’nın artık bir faktör düzeyi olup olmadığını düşünün…\nCan't add x object\nMuhtemelen silmeniz gereken bir ggplot komutunun sonunda fazladan bir “+” işaretiniz vardır.\n\n\nR Markdown hataları\nHata mesajı şöyle bir şey içeriyorsa Error in options[[sprintf(\"fig.%s\", i)]], her bir parçanın üstündeki knitr seçeneklerinizin doğru şekilde kullanıldığını kontrol edin. out.width = veya out.height = ve not fig.width= ve fig.height=.\n\n\nÇeşitli Konular\nTünellenmiş dplyr fiillerini yeniden düzenlediğinizi ve ortadaki bir tüneli değiştirmediğinizi veya yeniden düzenledikten sonra tüneli sondan çıkarmadığınızı düşünün.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Yaygın hatalar</span>"
    ]
  },
  {
    "objectID": "new_pages/errors.tr.html#kaynaklar",
    "href": "new_pages/errors.tr.html#kaynaklar",
    "title": "47  Yaygın hatalar",
    "section": "47.3 Kaynaklar",
    "text": "47.3 Kaynaklar\nBu bölüm, [yeni başlayanların karşılaştığı yaygın R programlama hatalarını] listeleyen başka bir blog gönderisidir(https://www.r-bloggers.com/2016/06/common-r-programming-errors-faced-by-beginners/)",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Yaygın hatalar</span>"
    ]
  },
  {
    "objectID": "new_pages/help.tr.html",
    "href": "new_pages/help.tr.html",
    "title": "48  Yardım alma",
    "section": "",
    "text": "48.1 Github sorunları\nBirçok R paketi ve projesinin kodu Github.com web sitesinde barındırılmaktadır. Bir “Sorun” göndererek bu web sitesi aracılığıyla yazarlarla doğrudan iletişim kurabilirsiniz.\nÇalışmanızı Github’da nasıl saklayacağınızla ilgili daha fazla bilgiyi [İşbirliği ve Github] sayfasından okuyabilirsiniz.\nGithub’da her proje bir depo içinde bulunur. Her depoda kod, veri, çıktılar, yardım belgeleri vb. bulunur. Ayrıca “Sorunlar” adı verilen yazarlarla iletişim kurmak için bir araç da vardır.\nincidence2 paketi (salgın eğrileri oluşturmak için kullanılır) için Github sayfasının altına bakın. Sarı renkle vurgulanmış “Sorunlar” sekmesini görebilirsiniz. 5 tane açık konu olduğunu görebilirsiniz.\nSorunlar sekmesinde, açık sorunları görebilirsiniz. Sorununuzun henüz ele alınmadığından emin olmak için bunları gözden geçirin. Sağdaki yeşil butona tıklayarak yeni bir konu açabilirsiniz. Bunu yapmak için bir Github hesabına ihtiyacınız olacak.\nSorununuzla ilgili olarak, minimal, tekrarlanabilir bir örnek sağlamak için aşağıdaki talimatları izleyin. Ve lütfen nazik olun! R paketleri ve projeleri geliştiren çoğu kişi boş zamanlarında bunu yapıyor (bu el kitabı gibi!).\nKendi Github deponuzdaki sorunları ele almayla ilgili daha gelişmiş materyalleri okumak için Github Sorunlarla ilgili belgelere bakabilirsiniz.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Yardım alma</span>"
    ]
  },
  {
    "objectID": "new_pages/help.tr.html#tekrarlanabilir-örnek",
    "href": "new_pages/help.tr.html#tekrarlanabilir-örnek",
    "title": "48  Yardım alma",
    "section": "48.2 Tekrarlanabilir örnek",
    "text": "48.2 Tekrarlanabilir örnek\nTekrarlanabilir bir örnek (“reprex”) sağlamak, bir forumda veya Github sayısında gönderi yayınlarken yardım almanın anahtarıdır. İnsanlar sana yardım etmek istiyor ama onlara kendi bilgisayarlarında çalışabilecekleri bir örnek vermelisin. Bu örnekte:\n\nKarşılaştığınız sorunu gösterin\nMinimal olun, yalnızca sorununuzu yeniden oluşturmak için gereken verileri ve kodu gönderin\nTüm nesneler (ör. veri), paket çağrıları (ör. ‘library()’ veya ‘p_load()’) dahil edilecek şekilde tekrarlanabilir olsun\n\nAyrıca, reprex ile herhangi bir hassas veri göndermediğinizden emin olun! Örnek veri çerçeveleri oluşturabilir veya R’da yerleşik veri çerçevelerinden birini kullanabilirsiniz (bu veri kümelerinin bir listesini açmak için data() komutunu girin).\n\nreprex paketi\nreprex paketi, tekrarlanabilir bir örnek oluşturmanıza yardımcı olur:\n\nreprex, tidyverse ile kurulur, bu nedenle her iki paketi de yüklemelisiniz\n\n\n# tidyverse kurun/yükleyin (reprex içerir)\npacman::p_load(tidyverse)\n\n\nPaketleri ve verileri yüklemekten başlayarak adım adım sorununuzu oluşturan bir R betiği başlatın.\n\n\n# paketleri yükleyin\npacman::p_load(\n     tidyverse,  # veri yönetimi ve görselleştirme\n     outbreaks)  # salgın veri kümelerinin örneği\n\n# grip salgını vaka satır listesi\noutbreak_raw &lt;- outbreaks::fluH7N9_china_2013  # salgın paketinden veri kümesini al\n\n# veri kümesini temizle\noutbreak &lt;- outbreak_raw %&gt;% \n     mutate(across(contains(\"date\"), as.Date))\n\n# salgın grafiğini çiz\n\nggplot(data = outbreak)+\n     geom_histogram(\n          mapping = aes(x = date_of_onset),\n          binwidth = 7\n     )+\n  scale_x_date(\n    date_format = \"%d %m\"\n  )\n\nTüm kodu panonuza kopyalayın ve aşağıdaki komutu çalıştırın:\n\nreprex::reprex()\n\nRStudio Görüntüleyici bölmesinde bir HTML çıktısının göründüğünü göreceksiniz. Tüm kodunuzu ve tüm uyarıları, hataları veya çizim çıktılarını içerecektir. Bu çıktı aynı zamanda panonuza da kopyalanır, böylece doğrudan bir Github sorununa veya bir forum gönderisine gönderebilirsiniz.\n\n\n\n\n\n\n\n\n\n\n‘session_info = TRUE’ olarak ayarlarsanız, R paket sürümlerinize ‘sessioninfo::session_info()’ çıktısı dahil edilecektir.\nwd = için bir çalışma dizini sağlayabilirsiniz.\nDeğişkenler ve olası varyasyonlar hakkında daha fazla bilgiyi documentation adresinden veya ?reprex girerek okuyabilirsiniz.\n\nYukarıdaki örnekte, ‘ggplot()’ komutu, ‘date_format =’ değişkeni doğru olmadığı için çalışmadı - ‘date_labels =’ olmalı idi.\n\n\nMinimum veri\nYardımcıların verilerinizi kullanabilmesi gerekir - ideal olarak verileri kodla oluşturabilmeleri gerekir.\nMinimum bir veri kümesi oluşturmak için, anonimleştirmeyi ve gözlemlerin yalnızca bir alt kümesini kullanmayı düşünün.\nYAPIM AŞAMASINDA… - minimal veri kümesi oluşturmak için ‘dput()’ fonksiyonunu da kullanabilirsiniz.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Yardım alma</span>"
    ]
  },
  {
    "objectID": "new_pages/help.tr.html#bir-foruma-gönderme",
    "href": "new_pages/help.tr.html#bir-foruma-gönderme",
    "title": "48  Yardım alma",
    "section": "48.3 Bir foruma gönderme",
    "text": "48.3 Bir foruma gönderme\nBol bol forum yazıları okuyun. Hangi gönderilerin iyi yazıldığını ve hangilerinin yazılmadığını anlayın.\n\nİlk olarak, soruyu sorup sormamaya karar verin. Sorunuzun daha önce sorulup sorulmadığını görmek için çeşitli arama terimlerini deneyerek forum web sitesini iyice incelediniz mi?\nSorunuza bilgilendirici bir başlık verin (“Yardım! Bu çalışmıyor” değil).\nSorunuzu yazın:\n\n\nDurumunuzu ve probleminizi tanıtın\nBenzer sorunların gönderilerine bağlantı verin ve sorunuzu nasıl yanıtlamadıklarını açıklayın\nÇalışmanızın bağlamını bilmeyen birine yardımcı olmak için ilgili bilgileri ekleyin\nR oturum bilgilerinizle minimum tekrarlanabilir bir örnek verin\nDoğru yazım, dil bilgisi, noktalama işaretleri kullanın ve sorunuzu daha kolay okunabilmesi için paragraflara ayırın\n\n\nHerhangi bir açıklama talebine yanıt vermek için sorunuzu yayınladıktan sonra izleyin. Nazik ve kibar olun - yanıtlayan kişiler genellikle size yardım etmek için zamanlarını gönüllü olarak harcarlar. Takip eden bir sorunuz varsa, bunun ayrı bir soru olması gerekip gerekmediğini düşünün.\neğer isteği karşılayan bir yanıt alırsanız, soruyu yanıtlandı olarak işaretlemeyi unutmayın. Bu durum, başkalarının çözümü daha sonra hızlı bulmasına yardımcı olur.\n\nİyi bir soru nasıl sorulur hakkında Stackoverflow davranış kuralları hakkındaki bu yayınları okuyun.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Yardım alma</span>"
    ]
  },
  {
    "objectID": "new_pages/help.tr.html#kaynaklar",
    "href": "new_pages/help.tr.html#kaynaklar",
    "title": "48  Yardım alma",
    "section": "48.4 Kaynaklar",
    "text": "48.4 Kaynaklar\nNasıl [yardım alacağınız] hakkında Tidyverse sayfası!(https://www.tidyverse.org/help/#:~:text=When%20you%20want%20to%20make,to%20load%20the%20reprex%20package.&text=Enter%20reprex()%20in%20the,preview%20of%20your%20rendered%20reprex.)\nMinimum bir veri kümesi üretmeye ilişkin ipuçları\ndput fonksiyonu için belgeler",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Yardım alma</span>"
    ]
  },
  {
    "objectID": "new_pages/network_drives.tr.html",
    "href": "new_pages/network_drives.tr.html",
    "title": "49  Ağ sürücülerinde R",
    "section": "",
    "text": "49.1 Genel Bakış\nR’ı ağda veya “şirket” ortak sürücülerinde kullanmak ek zorluklar ortaya çıkarabilir. Bu sayfa, bu sorunlar üzerinde çalışırken edindiğimiz deneyimlerden sorunları gidermeye yönelik yaklaşımları, yaygın hataları ve önerileri içerir. Bölüm ayrıca R Markdown’ı da içeren özellikle hassas durumlar için ipuçları içerir.\nAğ Sürücülerinde R Kullanımı: Kapsamlı ilkeler",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>Ağ sürücülerinde R</span>"
    ]
  },
  {
    "objectID": "new_pages/network_drives.tr.html#genel-bakış",
    "href": "new_pages/network_drives.tr.html#genel-bakış",
    "title": "49  Ağ sürücülerinde R",
    "section": "",
    "text": "Bilgisayarınız için yönetici erişimi almalısınız. RStudio’yu özellikle yönetici olarak çalışacak şekilde kurun.\nMümkün olduğunda paketleri harfli bir sürücüdeki (örneğin “C:”) bir kitaplığa kaydedin. Mümkün olduğunca az yolu “\\\" ile başlayan bir paket kitaplığı kullanın.\nrmarkdown paketi bir “\\\" paket kitaplığında olmamalıdır, çünkü bu durumda TinyTex veya Pandoc’a bağlanamaz.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>Ağ sürücülerinde R</span>"
    ]
  },
  {
    "objectID": "new_pages/network_drives.tr.html#yönetici-olarak-rstudio",
    "href": "new_pages/network_drives.tr.html#yönetici-olarak-rstudio",
    "title": "49  Ağ sürücülerinde R",
    "section": "49.2 Yönetici olarak RStudio",
    "text": "49.2 Yönetici olarak RStudio\nRStudio’yu açmak için RStudio simgesine tıkladığınızda, bunu sağ tıklatarak yapın. Makinenize bağlı olarak, “Yönetici Olarak Çalıştır” seçeneğini görebilirsiniz. Aksi takdirde, Özellikler’i seçmek için bir seçenek görebilirsiniz (daha sonra “Uyumluluk” seçeneğinin olduğu bir pencere görünmelidir ve “Yönetici Olarak Çalıştır” onay kutusunu seçebilirsiniz).",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>Ağ sürücülerinde R</span>"
    ]
  },
  {
    "objectID": "new_pages/network_drives.tr.html#faydalı-komutlar",
    "href": "new_pages/network_drives.tr.html#faydalı-komutlar",
    "title": "49  Ağ sürücülerinde R",
    "section": "49.3 Faydalı komutlar",
    "text": "49.3 Faydalı komutlar\nAşağıda, ağ sürücülerinde R kullanarak sorunları gidermeye yarayan bazı yararlı komutlar verilmiştir.\nYolları R’ın kullandığı paket kitaplıklarına döndürebilirsiniz. Bunlar, R’ın paketleri kurmak/yüklemek/aramak için kullandığı sırayla listelenecektir. Bu nedenle, R’ın farklı bir varsayılan kitaplık kullanmasını istiyorsanız, bu yolların sırasını değiştirebilirsiniz (aşağıya bakın).\n\n# kitaplığı bul\n.libPaths()                   # R'ın yüklediği/aradığı sırayla listelenmiş kitaplık yollarınız.\n                              # Not: tüm kitaplıklar listelenecektir, ancak bazılarına (örneğin C :) yüklemek için\n                              # RStudio'yu yönetici olarak çalıştırmanız gerekebilir \n                              # (paket kitaplığı açılır menüsü yükleyin)\n\nR tarafından kullanılan paket kitaplıklarının sırasını değiştirmek isteyebilirsiniz. Örneğin, R “\\\" ile başlayan ve büyük bir harfle başlayan bir kitaplık konumu alıyorsa, örn.”D:“. .libPaths() sırasını aşağıdaki kod ile ayarlayabilirsiniz.\n\n# Kitaplıkların sırasını değiştir\n# bu, R'ın bir paket bulma önceliğini etkileyebilir. Örneğin. C: kitaplığınızın önce listelenmesini isteyebilirsiniz\nmyPaths &lt;- .libPaths() # yolakları al\nmyPaths &lt;- c(myPaths[2], myPaths[1]) # değiştir\n.libPaths(myPaths) # yeniden ata\n\nPandoc’a bağlanan R Markdown ile ilgili sorunlar yaşıyorsanız, RStudio’nun Pandoc kurulumunuzun nerede olduğunu düşündüğünü öğrenmek için bu kodla başlayın.\n\n# Pandoc'u bul\nSys.getenv(\"RSTUDIO_PANDOC\")  # RStudio'nun Pandoc kurulumunuzun nerede olduğunu düşündüğünü bulun\n\nBir paketin hangi kütüphaneden yüklendiğini görmek istiyorsanız aşağıdaki kodu deneyin:\n\n# bir paket bulun\n# paketin ilk konumunu verir (kütüphanelerinizin sırasını not edin)\nfind.package(\"rmarkdown\", lib.loc = NULL, quiet = FALSE, verbose = getOption(\"verbose\"))",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>Ağ sürücülerinde R</span>"
    ]
  },
  {
    "objectID": "new_pages/network_drives.tr.html#sık-karşılaşılan-hataları-giderme",
    "href": "new_pages/network_drives.tr.html#sık-karşılaşılan-hataları-giderme",
    "title": "49  Ağ sürücülerinde R",
    "section": "49.4 Sık karşılaşılan hataları giderme",
    "text": "49.4 Sık karşılaşılan hataları giderme\n“rmarkdown’da…tex derlenemedi”\n\nTinyTex kurulumunu kontrol edin veya TinyTex’i C: konumuna kurun. TinyTex’in nasıl kurulacağını öğrenmek için [R temelleri] sayfasına bakabilirsiniz.\n\n\n# tinytex'i kontrol edin/yükleyin, C: konumuna\ntinytex::install_tinytex()\ntinytex:::is_tinytex() #  DOĞRU döndürmelidir (üç kolonu da not alın)\n\nİnternet rutinleri yüklenemiyor\nÖrneğin, Error in tools::startDynamicHelp() : internet rutinleri yüklenemiyor\n\nAraçlar/Global Seçenekler aracılığıyla RStudio’dan 32 bit sürümü seçmeyi deneyin.\n\nnot: Menüde 32 bit sürüm görünmüyorsa, RStudio v1.2’yi kullanmadığınızdan emin olun.\n\nAlternatif olarak, R’ı kaldırıp farklı bir bit sürümüyle yeniden yüklemeyi deneyin (64 yerine 32)\n\nC: kitaplık paketleri manuel olarak yüklemeye çalıştığımda bir seçenek olarak görünmüyor\n\nRStudio’yu yönetici olarak çalıştırın, bu seçenek görünecektir.\nRStudio’yu her zaman yönetici olarak çalışacak şekilde ayarlamak için Rstudio simgesine sağ tıklayın\n\nAşağıdaki resim, bir paketin kurulacağı kitaplığı manuel olarak nasıl seçebileceğinizi gösterir. Bu pencere, Paketler RStudio bölmesini açtığınızda ve “Yükle” yi tıkladığınızda görünür.\n\n\n\n\n\n\n\n\n\nPandoc 1 hatası\nAğ sürücülerinde R Markdowns komut dosyalarını örerken “pandoc hatası 1” alıyorsanız:\n\nBirden fazla kitaplık konumundan önce harfli sürücüye sahip olanı listeleyin (yukarıdaki kodlara bakın)\nYukarıdaki çözüm, yerel sürücüde örerken ancak ağ bağlantılı bir internet bağlantısındayken işe yaradı.\nBurada daha fazla ipucu bulabilirsiniz: https://ciser.cornell.edu/rmarkdown-knit-to-html-word-pdf/\n\nPandoc Hatası 83\nHata şuna benzer: can't find file...rmarkdown...lua.... Bu, bu dosyayı bulamadığı anlamına gelir.\nhttps://stackoverflow.com/questions/58830927/rmarkdown-unable-to-locate-lua-filter-while-knitting-to-word ’e bakın\nOlasılıklar:\n\nRmarkdown paketi kurulu değil\nRmarkdown paketi bulunamadı\nBir yönetici hakları sorunu.\n\nR’ın rmarkdown paket dosyasını bulamaması mümkündür, bu nedenle rmarkdown paketinin hangi kütüphanede olduğunu kontrol edin (yukarıdaki koda bakın). Paket, erişilemeyen (örneğin, “\\\" ile başlayan) bir kitaplığa kuruluysa, onu manuel olarak C:’ye veya başka bir adlandırılmış sürücü kitaplığına taşımayı düşünün. rmarkdown paketinin TinyTex kurulumuna bağlanabilmesi gerektiğini, bu nedenle bir ağ sürücüsündeki bir kitaplıkta yaşayamayacağını unutmayın.\nPandoc Hatası 61\nÖrneğin: Error: pandoc document conversion failed with error 61 or Could not fetch...\n\nRStudio’yu yönetici olarak çalıştırmayı deneyin (simgeye sağ tıklayın, yönetici olarak çalıştır’ı seçin, yukarıdaki talimatlara bakın)\nAyrıca ulaşılamayan belirli paketin C: kitaplığına taşınıp taşınamayacağına da bakın.\n\nLaTex hatası (aşağıya bakın)\nŞuna benzer bir hata: ! Package pdftex.def Error: File 'cict_qm2_2020-06-29_files/figure-latex/unnamed-chunk-5-1.png' not found: using draft setting. or Error: LaTeX failed to compile file_name.tex.\n\nHata ayıklama ipuçları için https://yihui.org/tinytex/r/#debugging adresine bakın.\nDaha fazla bilgi için file_name.log’a bakın.\n\nPandoc Hatası 127\nBu bir RAM (boşluk) sorunu olabilir. R oturumunuzu yeniden başlatın ve tekrar deneyin.\nAğ sürücülerini eşleme\nBir ağ sürücüsünü eşlemek riskli olabilir. Bunu denemeden önce bilgi işlem departmanınıza danışın.\nBu [forum tartışmasından] ödünç alınmış bir yorumdur: (https://stackoverflow.com/questions/48161177/r-markdown-openbinaryfile-does-not-exist-no-such-file-or-directory/55616529?noredirect=1#comment97966859_55616529):\n“Eşlenmiş bir ağ sürücüsü aracılığıyla” bir dosya nasıl açılır?\n\nÖncelikle, erişmeye çalıştığınız ağ konumunu bilmeniz gerekir.\nArdından, Windows dosya yöneticisinde, sağdaki bölmede “Bu PC”ye sağ tıklamanız ve “Bir ağ sürücüsünü eşle”yi seçmeniz gerekecektir.\nAğ konumunu daha önce harfli bir sürücü olarak tanımlamak için diyalogu gözden geçirin.\nArtık açtığınız dosyaya ulaşmanın iki yolu var. Sürücü harfi yolunu kullanmak işe yaramalıdır.\n\ninstall.packages() dosyasında hata\nBir “kilit” dizininden bahseden bir hata alırsanız, örneğin: Error in install.packages : ERROR: failed to lock directory... Paket kitaplığınıza baktığınızda adı “00LOCK” ile başlayan bir klasör göreceksiniz. Aşağıdakileri deneyin:\n\n“00LOCK” klasör dizinini paket kitaplığınızdan manuel olarak silin. Paketi yeniden yüklemeyi deneyin.\nAyrıca pacman::p_unlock() komutunu da deneyebilirsiniz (bu komutu proje her açıldığında çalışması için Rprofile’e de koyabilirsiniz.). Ardından paketi yeniden yüklemeyi deneyin. Birkaç deneme gerektirebilir.\nRStudio’yu Yönetici modunda çalıştırmayı deneyin ve paketleri tek tek yüklemeyi deneyin.\nDiğerleri başarısız olursa, paketi başka bir kitaplığa veya klasöre (örn. Temp) kurun ve ardından paketin klasörünü istenen kitaplığa manuel olarak kopyalayın.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>Ağ sürücülerinde R</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.tr.html",
    "href": "new_pages/data_table.tr.html",
    "title": "50  Veri tablosu",
    "section": "",
    "text": "50.1 Veri tablolarına giriş\nBir veri tablosu, karmaşık gruplama işlemlerinin gerçekleştirilmesine izin veren bir veri çerçevesi gibi 2 boyutlu bir veri yapısıdır. data.table sözdizimi, satırlar, sütunlar ve gruplar üzerinde işlemler gerçekleştirilebilecek şekilde yapılandırılmıştır.\nYapı DT[i, j, by] şeklindedir ve 3 parça ile ayrılmıştır; i, j ve by değişkenleri. i değişkeni gerekli satırların alt kümelenmesine, j değişkeni sütunlar üzerinde işlem yapmanıza ve by değişkeni sütunlar üzerinde gruplara göre işlem yapmanıza olanak tanır.\nBu sayfa aşağıdaki konuları ele alacaktır:",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Veri tablosu</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.tr.html#veri-tablolarına-giriş",
    "href": "new_pages/data_table.tr.html#veri-tablolarına-giriş",
    "title": "50  Veri tablosu",
    "section": "",
    "text": "Verileri içe aktarma ve fread() ve fwrite() kullanımı\ni değişkenini kullanarak satırları seçme ve filtreleme\n%like%, %chin%, %between% yardımcı fonksiyonlarını kullanma\nj değişkenini kullanarak sütunları seçme ve hesaplama\nby değişkenini kullanan gruplara göre hesaplama\n:= kullanarak veri tablolarına veri ekleme ve güncelleme",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Veri tablosu</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.tr.html#paketleri-yükleyin-ve-verileri-içe-aktarın",
    "href": "new_pages/data_table.tr.html#paketleri-yükleyin-ve-verileri-içe-aktarın",
    "title": "50  Veri tablosu",
    "section": "50.2 Paketleri yükleyin ve verileri içe aktarın",
    "text": "50.2 Paketleri yükleyin ve verileri içe aktarın\n\nPaketleri yükleyin\npacman’den p_load() fonksiyonunu kullanarak, bu analiz için gerekli paketleri yükleriz (ve gerekirse kurarız).\n\npacman::p_load(\n  rio,        # verileri içe aktarmak için\n  data.table, # verileri gruplamak ve temizlemek için\n  tidyverse,  # bu bölümde tünelleme (%&gt;%) fonksiyonunun kullanılmasına izin verir\n  here \n  ) \n\n\n\nVerileri içe aktar\nBu sayfa, el kitabında atıfta bulunulan vaka satır listesini kullanarak data.table’ın bazı temel fonksiyonlarını keşfedecektir.\nSimüle edilmiş bir Ebola salgınından vakaların veri setini içe aktarıyoruz. Adım adım izlenecek verileri indirmek istiyorsanız, [Kitap ve verileri indir] sayfasındaki talimatlara bakın. Veri kümesi, rio paketinden import() fonksiyonu kullanılarak içe aktarılır. Verileri içe aktarmanın çeşitli yolları için [İçe ve dışa aktar] hakkındaki sayfaya bakın. Buradan veri çerçevesini bir veri tablosuna dönüştürmek için data.table() kullanıyoruz.\n\nlinelist &lt;- rio::import(here(\"data\", \"linelist_cleaned.xlsx\")) %&gt;% data.table()\n\n‘fread()’ fonksiyonu, .csv dosyaları gibi normal sınırlandırılmış dosyaları doğrudan bir veri tablosu biçimine içe aktarmak için kullanılır. Data.tables’ı düzenli sınırlandırılmış dosyalar olarak yazmak için kullanılan bu işlev ve muadili ‘fwrite()’, büyük veritabanları için çok hızlı ve hesaplama açısından verimli seçeneklerdir.\n“linelist”in ilk 20 satırı:\nVeri çerçeveleri için kullanılan ‘dim()’ gibi R Tabanı komutları, veri tabloları için de kullanılabilir.\n\ndim(linelist) #veri tablosundaki satır ve sütun sayısını verir\n\n[1] 5888   30",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Veri tablosu</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.tr.html#i-değişkeni-satırları-seçme-ve-filtreleme",
    "href": "new_pages/data_table.tr.html#i-değişkeni-satırları-seçme-ve-filtreleme",
    "title": "50  Veri tablosu",
    "section": "50.3 i değişkeni: satırları seçme ve filtreleme",
    "text": "50.3 i değişkeni: satırları seçme ve filtreleme\nDT[i, j, by] yapısını hatırlayarak, satır numaralarını veya mantıksal ifadeleri kullanarak satırları filtreleyebiliriz. i değişkeni ilk; bu nedenle, DT[i] veya DT[i,] sözdizimi kullanılabilir.\nİlk örnek veri tablosunun ilk 5 satırını alır, ikinci örnek alt küme vakaları 18 yaş ve üzeridir ve üçüncü örnek alt kümeler 18 yaş veya üzeri ancak Merkez Hastanede teşhis edilmemiş vakaları içerir:\n\nlinelist[1:5] #1.ila 5. satır arasını getirir\nlinelist[age &gt;= 18] #alt küme vakaları 18 yaşa eşit veya daha büyük\nlinelist[age &gt;= 18 & hospital != \"Central Hospital\"] #18 yaşına eşit veya daha büyük ancak Merkez Hastanede teşhis edilmemiş alt kümeler\n\ni bağımsız değişkeninde .N kullanılması, veri tablosundaki toplam satır sayısını temsil eder. Bu, satır numaralarını alt kümelemek için kullanılabilir:\n\nlinelist[.N] #son satırı getirir\nlinelist[15:.N] #15. satırdan son satıra kadar getirir\n\n\nFiltreleme için yardımcı fonksiyonları kullanma\nVeri tablosu, alt küme satırlarını kolaylaştıran yardımcı fonksiyonları kullanır. ‘%like%’ bir sütundaki kalıbı eşleştirmek için kullanılır, ‘%chin%’ belirli bir karakteri eşleştirmek için kullanılır ve ‘%between%’ önceden belirlenmiş bir aralıktaki sayısal sütunları eşleştirmek için kullanılır.\nAşağıdaki örneklerde: * hastane değişkeninin “Hastane” içerdiği satırları filtreleyin * sonucun “İyileşme” veya “Ölüm” olduğu satırları filtreleyin * 40-60 yaş aralığındaki satırları filtreleyin\n\nlinelist[hospital %like% \"Hospital\"] #hastane değişkeninin \"Hastane\" içerdiği satırları filtreleyin\nlinelist[outcome %chin% c(\"Recover\", \"Death\")] #sonucun \"İyileşme\" veya \"Ölüm\" olduğu satırları filtreleyin\nlinelist[age %between% c(40, 60)] #40-60 yaş aralığındaki satırları filtreleyin\n\n#%between% 2 uzunlukta bir vektör almalıdır, oysa %chin% &gt;= 1 uzunlukta vektörler alabilir",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Veri tablosu</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.tr.html#j-değişkeni-sütunları-seçme-ve-hesaplama",
    "href": "new_pages/data_table.tr.html#j-değişkeni-sütunları-seçme-ve-hesaplama",
    "title": "50  Veri tablosu",
    "section": "50.4 j değişkeni: sütunları seçme ve hesaplama",
    "text": "50.4 j değişkeni: sütunları seçme ve hesaplama\nDT[i, j, by] yapısını kullanarak sayıları veya isimleri kullanarak sütunları seçebiliriz. j değişkeni ikinci sıradadır; bu nedenle DT[, j] sözdizimi kullanılır. j değişkenindeki hesaplamaları kolaylaştırmak için, ‘list()’ ya da ‘.()’ kullanılarak sütun sarılır.\n\nSütunları seçme\nİlk örnek, veri tablosunun birinci, üçüncü ve beşinci sütunlarını alır; ikinci örnek, boy, ağırlık ve cinsiyet sütunları dışındaki tüm sütunları seçer. Üçüncü örnek, case_id ve outcome sütunlarını seçmek için .() sarmasını kullanır.\n\nlinelist[ , c(1,3,5)]\nlinelist[ , -c(\"gender\", \"age\", \"wt_kg\", \"ht_cm\")]\nlinelist[ , list(case_id, outcome)] #linelist[ , .(case_id, outcome)] aynı şekilde çalışır\n\n\n\nSütunlarda hesaplama\ni ve j değikenlerini birleştirerek, satırları filtrelemek ve sütunlarda hesaplama yapmak mümkündür. j değişkeninde .N kullanılması ayrıca veri tablosundaki toplam satır sayısını temsil eder ve satır filtrelemeden sonra satır sayısını döndürmek için yararlı olabilir.\nAşağıdaki örneklerde: * Hastanede 7 günden fazla kalan vaka sayısını sayın * Askeri hastanede ölen vakaların yaş ortalamasını hesaplayın * Merkez hastanede iyileşen vakaların standart sapma, ortanca, yaş ortalamasını hesaplayın\n\nlinelist[days_onset_hosp &gt; 7 , .N]\n\n[1] 189\n\nlinelist[hospital %like% \"Military\" & outcome %chin% \"Death\", .(mean(age, na.rm = T))] #na.rm = T siler N/A değerleri\n\n        V1\n     &lt;num&gt;\n1: 15.9084\n\nlinelist[hospital == \"Central Hospital\" & outcome == \"Recover\", \n                 .(mean_age = mean(age, na.rm = T),\n                   median_age = median(age, na.rm = T),\n                   sd_age = sd(age, na.rm = T))] #bu sözdizimi yardımcı fonksiyonları kullanmaz ancak aynı şekilde çalışır\n\n   mean_age median_age   sd_age\n      &lt;num&gt;      &lt;num&gt;    &lt;num&gt;\n1: 16.85185         14 12.93857\n\n\nj değişkeninde .() sarma kullanmanın hesaplamayı kolaylaştırdığını, bir veri tablosu döndürdüğünü ve sütun adlandırmasına izin verdiğini unutmayın.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Veri tablosu</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.tr.html#değişkene-göre-gruplara-göre-hesaplama",
    "href": "new_pages/data_table.tr.html#değişkene-göre-gruplara-göre-hesaplama",
    "title": "50  Veri tablosu",
    "section": "50.5 Değişkene göre: gruplara göre hesaplama",
    "text": "50.5 Değişkene göre: gruplara göre hesaplama\nby değişkeni, DT[i, j, by] yapısındaki üçüncü değişkendir. by değişkeni hem bir karakter vektörünü hem de ‘list()’ veya ‘.()’ sözdizimini kabul eder. by değişkeninde .() sözdizimini kullanmak, anında sütun yeniden adlandırılmasına izin verir.\nAşağıdaki örneklerde: * vaka sayısını hastaneye göre gruplandırın * 18 yaş ve üzeri vakalarda cinsiyete göre vakaların ortalama boy ve kilolarını, iyileşip ölmediklerini hesaplayın * 7 günü aşan başvurularda, vaka sayısını yattığı aya ve yattığı hastaneye göre sayısını hesaplayın\n\nlinelist[, .N, .(hospital)] #hastaneye göre vaka sayıları\n\n                               hospital     N\n                                 &lt;char&gt; &lt;int&gt;\n1:                                Other   885\n2:                              Missing  1469\n3: St. Mark's Maternity Hospital (SMMH)   422\n4:                        Port Hospital  1762\n5:                    Military Hospital   896\n6:                     Central Hospital   454\n\nlinelist[age &gt; 18, .(mean_wt = mean(wt_kg, na.rm = T),\n                             mean_ht = mean(ht_cm, na.rm = T)), .(gender, outcome)] #NAs, verilerin eksik olduğu kategorileri temsil eder\n\n   gender outcome  mean_wt  mean_ht\n   &lt;char&gt;  &lt;char&gt;    &lt;num&gt;    &lt;num&gt;\n1:      m Recover 71.90227 178.1977\n2:      f   Death 63.27273 159.9448\n3:      m   Death 71.61770 175.4726\n4:      f    &lt;NA&gt; 64.49375 162.7875\n5:      m    &lt;NA&gt; 72.65505 176.9686\n6:      f Recover 62.86498 159.2996\n7:   &lt;NA&gt; Recover 67.21429 175.2143\n8:   &lt;NA&gt;   Death 69.16667 170.7917\n9:   &lt;NA&gt;    &lt;NA&gt; 70.25000 175.5000\n\nlinelist[days_onset_hosp &gt; 7, .N, .(month = month(date_hospitalisation), hospital)]\n\n    month                             hospital     N\n    &lt;num&gt;                               &lt;char&gt; &lt;int&gt;\n 1:     5                    Military Hospital     3\n 2:     6                        Port Hospital     4\n 3:     7                        Port Hospital     8\n 4:     8 St. Mark's Maternity Hospital (SMMH)     5\n 5:     8                    Military Hospital     9\n 6:     8                                Other    10\n 7:     8                        Port Hospital    10\n 8:     9                        Port Hospital    28\n 9:     9                              Missing    27\n10:     9                     Central Hospital    10\n11:     9 St. Mark's Maternity Hospital (SMMH)     6\n12:    10                              Missing     2\n13:    10                    Military Hospital     3\n14:     3                        Port Hospital     1\n15:     4                    Military Hospital     1\n16:     5                                Other     2\n17:     5                     Central Hospital     1\n18:     5                              Missing     1\n19:     6                              Missing     7\n20:     6 St. Mark's Maternity Hospital (SMMH)     2\n21:     6                    Military Hospital     1\n22:     7                    Military Hospital     3\n23:     7                                Other     1\n24:     7                              Missing     2\n25:     7 St. Mark's Maternity Hospital (SMMH)     1\n26:     8                     Central Hospital     2\n27:     8                              Missing     6\n28:     9                                Other     9\n29:     9                    Military Hospital    11\n30:    10                        Port Hospital     3\n31:    10                                Other     4\n32:    10 St. Mark's Maternity Hospital (SMMH)     1\n33:    10                     Central Hospital     1\n34:    11                              Missing     2\n35:    11                        Port Hospital     1\n36:    12                        Port Hospital     1\n    month                             hospital     N\n\n\nData.table ayrıca zincirleme ifadelere aşağıdaki gibi izin verir:\n\nlinelist[, .N, .(hospital)][order(-N)][1:3] #1. tüm vakaları hastaneye göre seçer, 2. vakaları azalan sırayla sıralar, 3. en büyük vaka yüküne sahip 3 hastaneyi alt kümeler\n\n            hospital     N\n              &lt;char&gt; &lt;int&gt;\n1:     Port Hospital  1762\n2:           Missing  1469\n3: Military Hospital   896\n\n\nBu örneklerde, veri tablosundaki bir satırın yeni bir duruma eşit olduğu varsayımını izliyoruz ve bu nedenle veri tablosundaki satır sayısını temsil etmek için .N’yi kullanabiliriz. Benzersiz durumların sayısını temsil eden başka bir yararlı fonksiyon, belirli bir girdideki benzersiz değerlerin sayısını döndüren “uniqueN()” dir. Aşağıda gösterilmektedir:\n\nlinelist[, .(uniqueN(gender))] #hatırlayın .() j değişkeninde bir veri tablosu döndürür\n\n      V1\n   &lt;int&gt;\n1:     3\n\n\nCinsiyet sütunundaki benzersiz değerler m, f ve N/A olduğundan cevap 3’tür. Belirli bir girdideki tüm benzersiz değerleri döndüren temel R fonksiyonu “unique()” ile karşılaştırın:\n\nlinelist[, .(unique(gender))]\n\n       V1\n   &lt;char&gt;\n1:      m\n2:      f\n3:   &lt;NA&gt;\n\n\nBelirli bir aydaki benzersiz vakaların sayısını bulmak için aşağıdakileri yazarız:\n\nlinelist[, .(uniqueN(case_id)), .(month = month(date_hospitalisation))]\n\n    month    V1\n    &lt;num&gt; &lt;int&gt;\n 1:     5    62\n 2:     6   100\n 3:     7   198\n 4:     8   509\n 5:     9  1170\n 6:    10  1228\n 7:    11   813\n 8:    12   576\n 9:     1   434\n10:     2   310\n11:     3   290\n12:     4   198",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Veri tablosu</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.tr.html#veri-tablolarına-ekleme-ve-güncelleme",
    "href": "new_pages/data_table.tr.html#veri-tablolarına-ekleme-ve-güncelleme",
    "title": "50  Veri tablosu",
    "section": "50.6 Veri tablolarına ekleme ve güncelleme",
    "text": "50.6 Veri tablolarına ekleme ve güncelleme\n:= operatörü, bir veri tablosuna veri eklemek veya bu tabloya veri güncellemek için kullanılır. Veri tablonuza sütun eklemek aşağıdaki şekillerde yapılabilir:\n\nlinelist[, adult := age &gt;= 18] #bir sütun ekler\nlinelist[, c(\"child\", \"wt_lbs\") := .(age &lt; 18, wt_kg*2.204)] #birden çok sütun eklemek için c(\"\") ve list() veya .() sözdizimi gerekir\nlinelist[, `:=` (bmi_in_range = (bmi &gt; 16 & bmi &lt; 40),\n                         no_infector_source_data = is.na(infector) | is.na(source))] #bu yöntem :='yi fonksiyonel operatör olarak `:=` kullanır\nlinelist[, adult := NULL] #sütunu siler\n\nDaha karmaşık toplamalar bu giriş bölümünün kapsamı dışındadır, ancak buradaki fikir, verileri gruplama ve temizleme için dplyr’e popüler ve uygulanabilir bir alternatif sağlamaktır. data.table paketi, düzgün ve okunabilir koda izin veren harika bir pakettir.",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Veri tablosu</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.tr.html#kaynaklar",
    "href": "new_pages/data_table.tr.html#kaynaklar",
    "title": "50  Veri tablosu",
    "section": "50.7 Kaynaklar",
    "text": "50.7 Kaynaklar\n\nhttps://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html\nhttps://github.com/Rdatatable/data.table\nhttps://s3.amazonaws.com/assets.datacamp.com/img/blog/data+table+cheat+sheet.pdf\nhttps://www.machinelearningplus.com/data-manipulation/datatable-in-r-complete-guide/\nhttps://www.datacamp.com/community/tutorials/data-table-r-tutorial\n\nGruplandırılmış veriler üzerinde herhangi bir özet fonksiyonu gerçekleştirebilirsiniz; Daha fazla bilgi için buradaki pratik belgeye bakın: https://s3.amazonaws.com/assets.datacamp.com/blog_assets/datatable_Cheat_Sheet_R.pdf",
    "crumbs": [
      "Çeşitli",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Veri tablosu</span>"
    ]
  }
]