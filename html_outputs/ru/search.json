[
  {
    "objectID": "index.ru.html",
    "href": "index.ru.html",
    "title": "Справочник эпидемиолога R",
    "section": "",
    "text": "Добро пожаловать",
    "crumbs": [
      "Добро пожаловать"
    ]
  },
  {
    "objectID": "index.ru.html#r-для-прикладной-эпидемиологии-и-общественного-здравоохранения",
    "href": "index.ru.html#r-для-прикладной-эпидемиологии-и-общественного-здравоохранения",
    "title": "Справочник эпидемиолога R",
    "section": "R для прикладной эпидемиологии и общественного здравоохранения",
    "text": "R для прикладной эпидемиологии и общественного здравоохранения\nИспользование: Настоящее руководство было использовано более 1 миллиона раз 300 000 человек по всему миру.\nЗадача: Служит кратким справочником по R (онлайн и [оффлайн][Скачивание руководства и данных]) с примерами, ориентированными на задачи, которые направлены на часто встречающиеся проблемы в эпидемиологии.\nВы только начинаете работать с R? Воспользуйтесь нашими бесплатными интерактивными самоучителями или синхронным виртуальным вводным курсом который используют CDC США, ВОЗ, а также более 75+ других медицинских организаций и Программ обучения прикладных эпидемиологов по всему миру.\nЯзыки: Английский (English), Французский (Français), испанский (Español), вьетнамский (Tiếng Việt), Японский (日本), турецкий (Türkçe), португальский (Português), Русский\n\n\n\n\n\n\n\n Written by epidemiologists, for epidemiologists\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\nApplied Epi - некоммерческая организация и движение специалистов прикладной эпидемиологии по всему миру. Мы пишем в свободное время, чтобы дать сообществу ресурсы. Ваши комментарии и обратная связь приветствуются:\n\nПосетите наш веб-сайт и присоединяйтесь к списку контактов\n\ncontact@appliedepi.org, твиттер @appliedepi, или LinkedIn\n\nО проблемах сообщайте в нашем репозитории Github\n\nМы предлагаем онлайн обучение по R от инструкторов с десятилетиями опыта в прикладной эпидемиологии - напишите нам для обсуждения.",
    "crumbs": [
      "Добро пожаловать"
    ]
  },
  {
    "objectID": "index.ru.html#как-пользоваться-этим-руководством",
    "href": "index.ru.html#как-пользоваться-этим-руководством",
    "title": "Справочник эпидемиолога R",
    "section": "Как пользоваться этим руководством",
    "text": "Как пользоваться этим руководством\n\nПросматривайте страницы в Содержании, либо используйте поле поиска\nКликните на икноки “копировать”, чтобы скопировать код\n\nВы можете работать параллельно с помощью [примера данных][Скачивание руководства и данных]\n\nОффлайн версия\nСм. инструкции на странице [Скачивание руководства и данных].",
    "crumbs": [
      "Добро пожаловать"
    ]
  },
  {
    "objectID": "index.ru.html#благодарности",
    "href": "index.ru.html#благодарности",
    "title": "Справочник эпидемиолога R",
    "section": "Благодарности",
    "text": "Благодарности\nДанное руководство подготовлено независимой группой эпидемиологов со всего мира на основе опыта работы с организациями, включая местные, государственные, провинциальные и национальные органы здравоохранения, Всемирную организацию здравоохранения (ВОЗ), организацию “Врачи без границ” (MSF), больничные системы и академические институты.\nНастоящее руководство не является одобренным продуктом какой-то отдельной организации. Хотя мы стремимся обеспечить правильность, мы не предоставляем гарантий касательно содержания этой книги.\n\nУчаствовали в подготовке\nРедактор: Neale Batra\nАвторы: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonathan Polonsky, Yurie Izawa, Chris Bailey, Daniel Molling, Isha Berry, Emma Buajitti, Mathilde Mousset, Sara Hollis, Wen Lin\nРецензенты и лица, оказавшие поддержку: Pat Keating, Amrish Baidjoe, Annick Lenglet, Margot Charette, Danielly Xavier, Marie-Amélie Degail Chabrat, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Kate Kelsey, Berhe Etsay, John Rossow, Mackenzie Zendt, James Wright, Laura Haskins, Flavio Finger, Tim Taylor, Jae Hyoung Tim Lee, Brianna Bradley, Wayne Enanoria, Manual Albela Miranda, Molly Mantus, Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao Muianga\nИллюстрации: Calder Fong\n\n\n\n\n\n\nФинансирование и поддержка\nНастоящее руководства является проектом преимущественно на добровольной основе, на создание которого ушли тысячи часов.\nРуководство получало некоторое поддерживающее финансирование через грант по наращиванию потенциала в контексте COVID-19 от TEPHINET, глобальной сети Программ обучения прикладных эпидемиологов (FETP).\nАдминистративную поддержку предоставила сеть выпускников EPIET (EAN), особая благодарность выражается Аннике Уендланд. EPIET - европейская программа обучения интервенционной эпидемиологии.\nОсобая благодарность организации Врачи без границ (MSF), Операционному центру в Амстердами (OCA) за поддержку в разработке настоящего руководства.\nДанная публикация была поддержана Соглашением о сотрудничестве номер NU2GGH001873, финансируемым Центрами по контролю и профилактике заболеваний через TEPHINET, программой Рабочей группы по глобальному здоровью (Task Force for Global Health). Ответственность за содержание публикации лежит исключительно на авторах, и оно не обязательно отражает официальную точку зрения Центров по контролю и профилактике заболеваний, Министерства здравоохранения и социальных служб, Task Force for Global Health, Inc. или TEPHINET.\n\n\nВдохновение\nНа соответствующих страницах делаются отсылки на ряд самоучителей и виньеток, которые представили информацию для разработки содержания руководства.\nВ целом, источниками вдохновения для настоящего руководства были:\nПроект “R4Epis” (a collaboration between MSF and RECON)\nR Epidemics Consortium (RECON)\nКнига R for Data Science (R4DS)\nbookdown: Authoring Books and Technical Documents with R Markdown\nNetlify hosts this website",
    "crumbs": [
      "Добро пожаловать"
    ]
  },
  {
    "objectID": "index.ru.html#условия-использования-и-участия",
    "href": "index.ru.html#условия-использования-и-участия",
    "title": "Справочник эпидемиолога R",
    "section": "Условия использования и участия",
    "text": "Условия использования и участия\n\nЛицензия\n Applied Epi Incorporated, 2021 Данная работа лицензирована Applied Epi Incorporated в рамках лицензии Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\nАкадемические курсы и программы обучения эпидемиологов могут связаться с нами по вопросам использования или адаптации этих материалов (email contact@appliedepi.org).\n\n\nЦитирование\nBatra, Neale, et al. The Epidemiologist R Handbook. 2021. \n\n\nУчастие\nЕсли вы хотите внести свой вклад в разработку содержания, сначала свяжитесь с нами через Github issues или по электронной почте. Мы разрабатываем график обновлений и создаем руководство для разработчиков.\nОбратите внимание, что проект epiRhandbook разрабатывается на основе Кодекса поведения участников. Принимая участие в разработке, вы соглашаетесь с этими условиями.",
    "crumbs": [
      "Добро пожаловать"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.ru.html",
    "href": "new_pages/editorial_style.ru.html",
    "title": "1  Редакционные и технические замечания",
    "section": "",
    "text": "1.1 Подход и стиль\nПотенциальная аудитория этой книги обширна. Ею наверняка будут пользоваться как новички в R, так и опытные пользователи R, ищущие лучшие практики и советы. Поэтому книга должна быть одновременно доступной и лаконичной. Следовательно, мы будем предоставлять минимальные необходимые текстовые пояснения, чтобы применить код мог новичок и понимал, что делает код.\nЕще несколько моментов:",
    "crumbs": [
      "Об этой книге",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Редакционные и технические замечания</span>"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.ru.html#подход-и-стиль",
    "href": "new_pages/editorial_style.ru.html#подход-и-стиль",
    "title": "1  Редакционные и технические замечания",
    "section": "",
    "text": "Это справочная книга по коду, сопровождаемая относительно короткими примерами, а не подробный учебник по R или науке о данных\n\nЭто Руководство по R для использования в рамках прикладной эпидемиологии - а не учебник о методах или науке прикладной эпидемиологии\n\nЭто меняющийся документ - оптимальные пакеты R для конкретной задачи часто меняются, и мы приветствуем обсуждение о том, что стоит осветить в данном руководстве\n\n\nПакеты R\nТакой большой выбор\nОдним из наиболее сложных аспектов изучения языка R является определение того, какой пакет R следует использовать для решения той или иной задачи. Часто случается так, что с трудом справляешься с задачей, а потом понимаешь - эй, есть пакет R, который делает все это в одной командной строке!\nВ данном руководстве мы стараемся предложить Вам как минимум два способа решения каждой задачи: один проверенный метод (возможно, в базовом R или tidyverse) и один специальный пакет R, созданный специально для этой цели. Мы хотим, чтобы у вас было несколько вариантов на случай, если вы не сможете загрузить данный пакет или он не подойдет вам по каким-либо другим причинам.\nПри выборе пакетов для использования мы отдавали предпочтение пакетам и подходам R, которые были протестированы и проверены сообществом, минимизируют количество пакетов, используемых в типичной рабочей сессии, являются стабильными (не меняются очень часто) и решают поставленную задачу просто и чисто.\nВ данном руководстве приоритет отдается пакетам и функциям R из tidyverse. Tidyverse - это набор пакетов R, предназначенных для работы с данными и имеющих общую грамматику и структуры данных. Все пакеты tidyverse могут быть установлены или загружены с помощью пакета tidyverse. Более подробно читайте на веб-сайте tidyverse.\nПри необходимости мы также предлагаем варианты кода с использованием базового R - пакетов и функций, поставляемых вместе с R при установке. Мы понимаем, что у некоторых читателей этой книги может не быть надежного Интернета для загрузки дополнительных пакетов.\nСвязывание функций с пакетами в явной форме\nВ учебниках по R часто бывает неприятно, когда функция показана в коде, но вы не знаете, из какого она пакета! Мы стараемся избежать такой ситуации.\nВ описательном тексте имена пакетов выделяются жирным шрифтом (например, dplyr), а функции записываются следующим образом: mutate(). Мы стараемся явно указывать, из какого пакета происходит та или иная функция, либо ссылаясь на пакет в соседнем тексте, либо явно указывая пакет в коде, например, так: dplyr::mutate(). Это может выглядеть излишним, но мы это делаем специально.\nСм. страницу Основы R для информации о пакетах и функциях.\n\n\nСтиль кода\nВ руководстве мы часто используем “новые строки”, чтобы наш код выглядел “длинным”. Мы это делаем по нескольким причинам:\n\nМы можем написать пояснительные комментарии с помощью #, которые будут находиться рядом с каждой частью кода\n\nКак правило, длинный (вертикальный) код легче читать\n\nЕго легче читать на узком экране (не надо пролистывать вбок)\n\nС отступами легче понять, какой аргумент относится к какой функции\n\nВ результате код, который мог бы быть записан так:\n\nlinelist %&gt;% \n  group_by(hospital) %&gt;%  # группируем строки по больницам\n  slice_max(date, n = 1, with_ties = F) # если равенство (даты), взять первую строку\n\n…записывается так:\n\nlinelist %&gt;% \n  group_by(hospital) %&gt;% # группируем строки по больницам\n  slice_max(\n    date,                # сохранить строку на группу с максимальным значением даты \n    n = 1,               # сохранить только одну самую верхнюю строку \n    with_ties = F)       # если равенство (даты), взять первую строку\n\nНа R-код, как правило, не влияют новые строки и отступы. При написании кода, если инициировать новую строку после запятой, то будет применена автоматическая схема отступов.\nМы также используем пробелы (например, n = 1 вместо n=1), поскольку так легче читать. Будьте дружелюбны к людям, которые читают ваш код!\n\n\nНоменклатура\nВ этом руководстве мы как правило используем понятия “столбцы” и “строки” вместо “переменных” и “наблюдений”. Как объясняется в этом материале по “аккуратным данным”, большинство эпидемиологических статистических наборов данных структурно состоят из строк, столбцов и значений.\nПеременные содержат значения, которые измеряют одинаковый базовый атрибут (например, возрастная группа, исход или дата возникновения симпмтомов). Наблюдения содержат все значения, измеренные для одной единицы (например, человека, места или лабораторного образца). Так что эти аспекты может быть сложнее определить.\nВ “аккуратных” наборах данных каждый столбец - это переменная, каждая строка - это наблюдение, а каждая ячейка - это одно значение. Однако некоторые наборы данных, с которыми вы столкнетесь, не будут соответствовать этому шаблону - в наборе данных “широкого” формата переменная может быть разбита на несколько столбцов (см. пример на странице Поворот данных). Аналогичным образом, наблюдения могут быть разбиты на несколько строк.\nБольшая часть этого справочника посвящена управлению и преобразованию данных, поэтому ссылки на конкретные структуры данных - строки и столбцы - более уместны, чем на более абстрактные наблюдения и переменные. Исключение составляют страницы, посвященные анализу данных, где можно встретить больше упоминаний о переменных и наблюдениях.\n\n\nПримечания\nВот несколько типов примечаний, которые вы можете встретить в руководстве:\nПРИМЕЧАНИЕ: Это примечание.\nСОВЕТ: Это совет.\nВНИМАНИЕ: Это предупредительное замечание.\nВНИМАНИЕ: Это предупреждение.",
    "crumbs": [
      "Об этой книге",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Редакционные и технические замечания</span>"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.ru.html#редакционные-решения",
    "href": "new_pages/editorial_style.ru.html#редакционные-решения",
    "title": "1  Редакционные и технические замечания",
    "section": "1.2 Редакционные решения",
    "text": "1.2 Редакционные решения\nНиже мы приводим основные редакционные решения, связанные с выбором пакетов и функций. Если вы не согласны или хотите предложить новый инструмент для рассмотрения, пожалуйста, присоединяйтесь к обсуждению на нашей странице Github.\nТаблица пакетов, функций и других редакционных решений\n\n\n\n\n\n\n\n\n\nТема\nРассматривали\nРешение\nКраткое обоснование\n\n\n\n\nОбщий подход к кодированию\ntidyverse, data.table, base\ntidyverse, со страницей о data.table, а также упоминаниями базовых альтернатив для читателей без интернета\ntidyverseчитаемость, универсальность, чаще всего изучается\n\n\nЗагрузка пакетов\nlibrary(),install.packages(), require(), pacman\npacman\nСокращает и упрощает код для большинства установок/применения нескольких пакетов\n\n\nИмпорт и экспорт\nrio, многие другие пакеты\nrio\nПростота для многих типов файлов\n\n\nГруппирование для сводной статистики\ndplyr group_by(), stats aggregate()\ndplyr group_by()\nСоответствует фокусу на tidyverse\n\n\nПоворот\ntidyr (функции поворота), reshape2 (расплав/изготовление), tidyr (растягивание/сбор)\ntidyr (функции поворота)\nreshape2 вышел из употребления, tidyr использует функции поворота с версии v1.0.0\n\n\nЧистые имена столбцов\nlinelist, janitor\njanitor\nПодчеркивается консолидация пакетов\n\n\nЭпиднедели\nlubridate, aweek, tsibble, zoo\nlubridate в целом, другие для конкретных случаев\nгибкость lubridate, последовательность, перспективы поддержки пакета\n\n\nПодписи ggplot\nlabs(), ggtitle()/ylab()/xlab()\nlabs()\nвсе подписи в одном месте, простота\n\n\nКонвертация в фактор\nfactor(), forcats\nforcats\nразные функции также конвертируют в фактор в той же команде\n\n\nЭпидемические кривые\nincidence, ggplot2, EpiCurve\nincidence2 как быстрый, ggplot2 как детальный\nнадежность\n\n\nКонкатенация\npaste(), paste0(), str_glue(), glue()\nstr_glue()\nБолее простой синтаксис, чем функции paste; внутри stringr",
    "crumbs": [
      "Об этой книге",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Редакционные и технические замечания</span>"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.ru.html#основные-пересмотры",
    "href": "new_pages/editorial_style.ru.html#основные-пересмотры",
    "title": "1  Редакционные и технические замечания",
    "section": "1.3 Основные пересмотры",
    "text": "1.3 Основные пересмотры\n\n\n\nДата\nОсновные изменения\n\n\n\n\n10 мая 2021\nВыпуск версии 1.0.0\n\n\n20 ноя 2022\nВыпуск версии 1.0.1\n\n\n\nНОВОСТИ В версии 1.0.1 были внесены следующие изменения:\n\nОбновление до версии R 4.2\n\nВычистка данных: переход от {linelist} к {matchmaker}, удалили лишнюю строку из примера case_when()\n\nДаты: поменяли {linelist} guess_date() на {parsedate} parse_date()\nПоворот: небольшое обновление в pivot_wider() id_cols=\n\nАнализ опросов: поменяли plot_age_pyramid() на age_pyramid(), небольшое изменение кода аллювиального графика\n\nТепловые графики: добавили ungroup() во фрагмент agg_weeks\n\nИнтерактивные графики: добавили ungroup() во фрагмент, который создает agg_weeks, чтобы expand() работала как надо\n\nВременные ряды: добавили data.frame() вокруг объектов внутри всех команд trending::fit() и predict()\n\nАнализ комбинаций: поменяли case_when() на ifelse() и добавили опциональный код для подготовки данных across()\n\nЦепочки распространения: Обновление до более свежей версии {epicontacts}",
    "crumbs": [
      "Об этой книге",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Редакционные и технические замечания</span>"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.ru.html#информация-о-сессии-r-rstudio-пакеты",
    "href": "new_pages/editorial_style.ru.html#информация-о-сессии-r-rstudio-пакеты",
    "title": "1  Редакционные и технические замечания",
    "section": "1.4 Информация о сессии (R, RStudio, пакеты)",
    "text": "1.4 Информация о сессии (R, RStudio, пакеты)\nНиже приведена информация о версиях R, RStudio и пакетов R, использованных при составлении данного Руководства.\n\nsessioninfo::session_info()\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31 ucrt)\n os       Windows 11 x64 (build 22621)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       Europe/Stockholm\n date     2024-05-10\n pandoc   3.1.11 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n cli           3.6.2   2023-12-11 [2] CRAN (R 4.3.2)\n digest        0.6.35  2024-03-11 [1] CRAN (R 4.3.3)\n evaluate      0.23    2023-11-01 [2] CRAN (R 4.3.2)\n fastmap       1.1.1   2023-02-24 [2] CRAN (R 4.3.2)\n htmltools     0.5.8   2024-03-25 [1] CRAN (R 4.3.3)\n htmlwidgets   1.6.4   2023-12-06 [2] CRAN (R 4.3.2)\n jsonlite      1.8.8   2023-12-04 [2] CRAN (R 4.3.2)\n knitr         1.45    2023-10-30 [2] CRAN (R 4.3.2)\n rlang         1.1.3   2024-01-10 [2] CRAN (R 4.3.2)\n rmarkdown     2.26    2024-03-05 [1] CRAN (R 4.3.3)\n rstudioapi    0.15.0  2023-07-07 [2] CRAN (R 4.3.2)\n sessioninfo   1.2.2   2021-12-06 [2] CRAN (R 4.3.2)\n xfun          0.43    2024-03-25 [1] CRAN (R 4.3.3)\n\n [1] C:/Users/ngulu864/AppData/Local/R/win-library/4.3\n [2] C:/Program Files/R/R-4.3.2/library\n\n──────────────────────────────────────────────────────────────────────────────",
    "crumbs": [
      "Об этой книге",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Редакционные и технические замечания</span>"
    ]
  },
  {
    "objectID": "new_pages/data_used.ru.html",
    "href": "new_pages/data_used.ru.html",
    "title": "2  Скачивание руководства и данных",
    "section": "",
    "text": "2.1 Download offline handbook\nВы можете загрузить автономную версию этого справочника в виде HTML-файла, чтобы просмотреть его в веб-браузере, даже если у вас больше нет доступа к Интернету. Если вы рассматриваете возможность использования справочника Epi R в автономном режиме, то следует обратить внимание на следующие моменты:\nСуществует два способа скачивания руководства:",
    "crumbs": [
      "Об этой книге",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Скачивание руководства и данных</span>"
    ]
  },
  {
    "objectID": "new_pages/data_used.ru.html#download-offline-handbook",
    "href": "new_pages/data_used.ru.html#download-offline-handbook",
    "title": "2  Скачивание руководства и данных",
    "section": "",
    "text": "При открытии файла может потребоваться минута или две для загрузки изображений и оглавления\n\nВ автономном режиме руководство имеет несколько иной вид - одна очень длинная страница с оглавлением слева. Для поиска конкретных терминов используйте Ctrl+f (Cmd-f)\n\nСм. страницу Рекомендованные пакеты, которая поможет вам установить соответствующие пакеты R до потери подключения к Интернету\n\nУстановите наш пакет R epirhandbook, который содержит все примеры данных (процесс установки описан ниже)\n\n\n\nИспользовать ссылку для скачивания\nЖдя быстрого доступа правый щелчок по этой ссылке и выберите “Save link as - сохранить ссылку как”.\nЕсли вы работаете на компьютере Mac, используйте Cmd+щелчок. Если вы используете мобильный телефон, нажмите и удерживайте ссылку, затем выберите “Сохранить ссылку”. Руководство будет загружено на ваше устройство. Если появится окно с необработанным HTML-кодом, убедитесь, что вы выполнили приведенные выше инструкции, или попробуйте вариант 2.\n\n\nИспользовать наш пакет R\nМы предлагаем пакет R под названием epirhandbook. Он включает функцию download_book(), которая скачивает файл с руководством с нашего репозитория Github на компьютер.\nЭтот пакет также содержит функцию get_data(), которая скачивает все примеры данных на ваш компьютер.\nВыполните следующий код, чтобы установить наш пакет R epirhandbook с репозитория Github appliedepi. Этого пакета нет в CRAN, поэтому используйте специальную функцию p_install_gh(), чтобы установить его с Github.\n\n# устанавливаем последнюю версию пакета по Руководству для R для эпидемиологов\npacman::p_install_gh(\"appliedepi/epirhandbook\")\n\nТеперь загрузите пакет для использования в текущей сессии R:\n\n# загружаем пакет для использования\npacman::p_load(epirhandbook)\n\nДалее, выполните функцию пакета download_book() (с пустыми скобками), чтобы скачать руководство на ваш компьютер. Если вы находитесь в RStudio, появится окно, позволяющее вам выбрать место для сохранения.\n\n# скачиваем оффлайн руководство на компьютер\ndownload_book()",
    "crumbs": [
      "Об этой книге",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Скачивание руководства и данных</span>"
    ]
  },
  {
    "objectID": "new_pages/data_used.ru.html#скачивание-данных-для-параллельной-работы",
    "href": "new_pages/data_used.ru.html#скачивание-данных-для-параллельной-работы",
    "title": "2  Скачивание руководства и данных",
    "section": "2.2 Скачивание данных для параллельной работы",
    "text": "2.2 Скачивание данных для параллельной работы\nЧторбы “работать параллельно” при просмотре страниц руководства, вы можете скачать пример данных и выходных результатов.\n\nИспользуем наш пакет R\nСамый простой подход для скачивания всех данных - установить наш пакет R epirhandbook. В нем есть функция get_data(), которая сохраняет все примеры данных в выбранную папку на компьютере.\nЧтобы установить наш пакет R epirhandbook, выполните следующий код. Этого пакета нет в CRAN, поэтому используйте функцию p_install_gh(), чтобы его установить. Входные параметры ссылаются на нашу организацию в Github (“appliedepi”) и пакет epirhandbook.\n\n# устанавливаем последню версию пакета для руководства по R\npacman::p_install_gh(\"appliedepi/epirhandbook\")\n\nТеперь загрузите пакет для использования в текущей сессии R:\n\n# загружаем пакет для использования\npacman::p_load(epirhandbook)\n\nДалее используем функцию пакета get_data(), чтобы скачать пример данных на ваш компьютер. Выполните get_data(\"all\"), чтобы получить все примеры данных, либо укажите конкретное имя файлы и расширение внутри кавычек, чтобы получитьт только этот файл.\nДанные уже загружены вместе с пакетом, и их необходимо просто перенести в папку на компьютере. Появится всплывающее окно, в котором можно выбрать местоположение папки для сохранения. Мы рекомендуем создать новую папку “data”, поскольку в ней находится около 30 файлов (включая примеры данных и примеры выходных данных).\n\n# скачиваем все примеры данных в папку на компьютере\nget_data(\"all\")\n\n# скачиваем только пример данных построчного списка в папку на компьютере\nget_data(file = \"linelist_cleaned.rds\")\n\n\n# скачиваем конкретный файл в папку на вашем компьютере\nget_data(\"linelist_cleaned.rds\")\n\nКак только вы использовали get_data(), чтобы сохранить файл на компьютер, вам все еще нужно будет импортировать его в R. См. детали на странице Импорт и экспорт.\nЕсли хотите, вы можете рассмотреть все данные, используемые в этом руководстве, в папке “data” в нашем репозитории Github.\n\n\nСкачивание по одному\nЭтот вариант предполагает загрузку данных пофайлово из нашего репозитория Github либо по ссылке, либо с помощью команды R, специфичной для данного файла. Для некоторых типов файлов предусмотрена кнопка загрузки, в то время как другие можно загрузить с помощью команды R.\n\nПострочный список случаев\nЭто вымышленная вспышка Эболы, расширенная командой, готовившей руководство, из набора данных для практики ebola_sim в пакете outbreaks.\n\nКликните, чтобы скачать the “сырой” построчный список (.xlsx). “Сырой” построчный список случаев - таблица Excel с хаотичными данными. Используйте ее, чтобы выполнять шаги на странице Вычистка данных и ключевые функции.\nКликните, чтобы скачать “чистый” построчный список (.rds). Используйте этот файл для всех других страниц данного руководства, где используется построчный список. Файл .rds - это конкретный тип файла для R, который сохраняет классы столбцов. Это позволит вам выполнить лишь минимальную вычистку после импорта данных в R.\n\nДругие связанные файлы:\n\nКликните, чтобы скачать the “чистый” построчный список в виде файла Excel\nЧасть страницы вычистки использует “словарь вычистки” (.csv файл). Вы можете загрузить его напрямую в R, выполнив следующие команды:\n\n\npacman::p_load(rio) # установка/загрузка пакета rio\n\n# импорт файла напрямую из Github\ncleaning_dict &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/cleaning_dict.csv\")\n\n\n\nДанные о количестве случаев малярии\nЭти данные представляют собой фиктивное количество случаев заболевания малярией по возрастным группам, учреждениям и дням. Файл .rds - это специфический для R тип файла, сохраняющий классы столбцов. Благодаря этому после импорта данных в R вам придется выполнить лишь минимальную вычистку.\n Кликните, чтобы скачать данные о количестве случаев малярии (.rds файл) \n\n\nДанные для шкалы Лайкерта\nЭто вымышленные данные из опроса Лайкерта, используемые на странице Демографические пирамиды и шкалы Лайкерта. Вы можете загрузить эти данные напрямую в R, выполнив следующие команды:\n\npacman::p_load(rio) # установка/загрузка пакета rio\n\n# импорт файла напрямую из Github\nlikert_data &lt;- import(\"https://raw.githubusercontent.com/appliedepi/epirhandbook_eng/master/data/likert_data.csv\")\n\n\n\nFlexdashboard\nНиже есть ссылки на файлы для страницы Информационные панели c R Markdown:\n\nЧтобы скачать R Markdown для информационной панели для вспышки, кликните правой кнопкой на этуссылку (Cmd+click для Mac) и выберите “Сохранить ссылку как”.\n\nЧтобы скачать информационную панель HTML, кликните правой кнопкой на эту ссылку (Cmd+click for Mac) и выберите “Сохранить ссылку как”.\n\n\n\nОтслеживание контактов\nСтраница Отслеживание контактов демонстрирует анализ данных по отслеживанию контактов, используя пример данных из Go.Data. Данные, используемые на этой странице, могут быть скачены как файлы .rds, кликнув на следующие ссылки:\n Кликните, чтобы скачать данные по расследованию случая (.rds файл) \n Кликните, чтобы скачать данные по отслеживанию контактов (.rds файл) \n Кликните, чтобы скачать данные по мониторингу контактов (.rds файл) \nПРИМЕЧАНИЕ: Структурированные данные по отслеживанию контактов из других программ (например, KoBo, DHIS2 Tracker, CommCare) могут выглядеть по-другому. Если вы хотите использовать альтернативные данные лоя рьпащца иои содержания этой страницы, свяжитесь с нами.\nСОВЕТ: Если вы используете данные Go.Data и хотите связать это с вашим API, см. страницу Импорта и экспорта (раздел по API) и Сообщество практиков Go.Data.\n\n\nГИС\nУ шейп-файлов есть много файлов суб-компонентов, каждый со своим расширением файла. У одного файла будет расширение “.shp”, а у других могут быть “.dbf”, “.prj”, и т.п.\nНа странице Основы ГИС даны ссылки на веб-сайт Humanitarian Data Exchange, где вы можете скачать шейп-файлы напрямую в архивах.\nНапример, можно скачать точечные данные по медицинским организациям тут. Скачайте “hotosm_sierra_leone_health_facilities_points_shp.zip”. После сохранения на компьютер, разархивируйте папку. Вы увидите несколько файлов с разными расширениями (например, “.shp”, “.prj”, “.shx”) - их все нужно сохранять в одну папку на компьютере. Затем импортируйте в R, задайте путь к файлу и имя файла “.shp” в st_read() из пакетаsf (как описано на странице Основы ГИС).\nЕсли вы используете Вариант 1 для скачивания всех примеров данных (через наш пакет R epirhandbook), все шейп-файлы уже включены.\nВ качестве альтернативы можно загрузить шейп-файлы из папки “data” справочника R на Github (см. вложенную папку “gis”). Однако учтите, что вам придется загружать каждый подфайл по отдельности на свой компьютер. В Github щелкните на каждом файле по отдельности и загрузите их, нажав на кнопку “Download”. Ниже показано, что шейпфайл “sle_adm3” состоит из множества файлов, каждый из которых необходимо загрузить с Github.\n\n\n\n\n\n\n\n\n\n\n\nФилогенетические деревья\nСм. страницу Филогенетические деревья. Файл Newick филогенетического дерева, построенного на основе полногеномного секвенирования 299 образцов Shigella sonnei, и соответствующие данные по образцам (преобразованы в текстовый файл). Бельгийские образцы и полученные данные любезно предоставлены Бельгийским центром по изучению сальмонелл и шигелл в рамках проекта, осуществляемого стипендиатом EUPHEM ECDC, и также будут опубликованы в рукописи. Международные данные находятся в открытом доступе в общедоступных базах данных (ncbi) и были опубликованы ранее.\n\nЧтобы скачать файл с филогенетическим деревом “Shigella_tree.txt”, кликните правой кнопкой по этой ссылке (Cmd+click for Mac) и выберите “Сохранить ссылку как”.\n\nЧтобы скачать “sample_data_Shigella_tree.csv” с дополнительной информацией по каждому образцу, кликните правой кнопкой по этой ссылке (Cmd+click для Mac) и выберите “Сохранить ссылку как”.\n\nЧтобы увидеть новое, созданное дерево с подмножеством, кликните правой кнопкой по этой ссылке (Cmd+click для Mac) и выберите “Сохранить ссылку как”. Файл .txt скачается на ваш компьютер.\n\nВы можете затем импортировать файлы .txt с помощью read.tree() из пакета ape, как объяснялось на странице.\n\nape::read.tree(\"Shigella_tree.txt\")\n\n\n\nСтандартизация\nСм. страницу Стандартизированные коэффициенты. Вы можете загрузить данные напрямую из нашего репозитория Github в интернете в свою сессию R с помощью следующих команд:\n\n# установка/загрузка пакета rio\npacman::p_load(rio) \n\n##############\n# Страна A\n##############\n# импорт демографических данных по Стране A напрямую из Github\nA_demo &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/Страна_demographics.csv\")\n\n# импорт смертей по Стране A напрямую из Github\nA_deaths &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_СтранаA.csv\")\n\n##############\n# Страна B\n##############\n# импорт демографических данных по Стране B напрямую из Github\nB_demo &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/Страна_demographics_2.csv\")\n\n# импорт смертей по Стране B напрямую из Github\nB_deaths &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_СтранаB.csv\")\n\n\n###############\n# Референтная популяция\n###############\n# импорт демографических данных по Стране B напрямую из Github\nstandard_pop_data &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/world_standard_population_by_sex.csv\")\n\n\n\nВременные ряды и обнаружение вспышек\nСм. страницу Временные ряды и обнаружение вспышек. Мы используем случаи кампилобактера, зарегистрированные в Германии в 2002-2011, доступные в пакете R surveillance. (примечание этот набор данных был адаптирован из оригинального в той части, что 3 месяца данных конца 2011 года были удалены в целях демонстрации)\n Кликните, чтобы скачать  Campylobacter in Germany (.xlsx) \nМы также используем климатические данные по Германии за 2002-2011 гг. (температура в градусах Цельсия и количество осадков в миллиметрах). Они были загружены из набора данных спутникового реанализа ЕС Copernicus с помощью пакета ecmwfr. Вам нужно будет скачать их все и импортировать с помощью stars::read_stars(), как объясняется на странице по временным рядам.\n Кликните, чтобы скачать  Погоду в Германии за 2002 (.nc файл) \n Кликните, чтобы скачать  Погоду в Германии за 2003 (.nc файл) \n Кликните, чтобы скачать  Погоду в Германии за 2004 (.nc файл) \n Кликните, чтобы скачать  Погоду в Германии за 2005 (.nc файл) \n Кликните, чтобы скачать  Погоду в Германии за 2006 (.nc файл) \n Кликните, чтобы скачать  Погоду в Германии за 2007 (.nc файл) \n Кликните, чтобы скачать  Погоду в Германии за 2008 (.nc файл) \n Кликните, чтобы скачать  Погоду в Германии за 2009 (.nc файл) \n Кликните, чтобы скачать  Погоду в Германии за 2010 (.nc файл) \n Кликните, чтобы скачать  Погоду в Германии за 2011 (.nc файл) \n\n\nАнализ опросов\nДля страницы Анализ опросов мы используем выдуманные данные исследования смертности на основе шаблонов опросов MSF OCA. Этот выдуманный набор данных был сгенерирован в рамках проекта “R4Epis”.\n Кликните, чтобы скачать  Вымышленные данные опроса (.xlsx) \n Кликните, чтобы скачать  Словарь данных вымышленного опроса (.xlsx) \n Кликните, чтобы скачать  Популяционные данные вымышленного опроса (.xlsx) \n\n\nShiny\nСтраница Информационные панели с Shiny демонстрирует создание простого приложения для отображения данных по малярии.\nЧтобы скачать файлы R, которые создают приложение Shiny:\nYou can  кликните, чтобы скачать файл app.R, который содержит код и для UI, и для сервера для приложения Shiny.\nYou can  кликните, чтобы скачать файл facility_count_data.rds, который содержит данные по малярии для приложения Shiny. Обратите внимание, что вам нужно их сохранить в папке “data”, чтобы работал путь к файлу через here().\nYou can  кликните, чтобы скачать файл global.R, который должен быть выполнен до открытия приложения, как объясняется на странице.\nYou can  кликните, чтобы скачать файл plot_epicurve.R, к которому обращается global.R. Обратите внимание, что его нужно сохранить в папке “funcs”, чтобы работал путь к файлу через here().",
    "crumbs": [
      "Об этой книге",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Скачивание руководства и данных</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.ru.html",
    "href": "new_pages/basics.ru.html",
    "title": "3  Основы R",
    "section": "",
    "text": "3.1 Зачем использовать R?\nКак указано на нашем веб-сайте проекта по R, R - язык программирования и среда для статистических расчетов и графики. Он очень разнообразный, гибкий и развивается усилиями сообщества.\nСтоимость\nR можно использовать бесплатно! Сообщество придерживается принципов бесплатных и открытых материалов.\nВоспроизводимость\nУправление вашими данными и проведение анализа с использованием языка программирования (а не Excel или другого готового/ручного инструмента) повышает воспроизводимость, облегчает обнаружение ошибок, а также уменьшает объем работы.\nСообщество\nУ R очень большое и активно сотрудничающее сообщество пользователей. Новые пакеты и инструменты для решения реальных проблем разрабатываются практически ежедневно, а сообщество пользователей их проверяет. Например, R-Ladies - международная организация, чьей миссией является продвижение гендерного разнообразия в сообществе пользователей R, также является одной из крупнейших организацией пользователей R. У нее наверняка есть отделение недалеко от вас!",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.ru.html#ключевые-понятия",
    "href": "new_pages/basics.ru.html#ключевые-понятия",
    "title": "3  Основы R",
    "section": "3.2 Ключевые понятия",
    "text": "3.2 Ключевые понятия\nRStudio - RStudio - это графический интерфейс пользователя (ГИП), облегчающий использование R. Дополнительную информацию можно найти в разделе RStudio.\nОбъекты - Все, что вы сохраняете в R - наборы данных, переменные, список названий населенных пунктов, количество населения, а также выходные данные, такие как графики - это все объекты, которым присваивается имя и на которые можно ссылаться в последующих командах. Дополнительную информацию можно найти в разделе Объекты.\nФункции - Функция - это закодированная операция, которая принимает входные данные и выдает преобразованный результат. Дополнительную информацию можно найти в разделе Функции.\nПакеты - Пакет R - набор функций, которыми можно поделиться. Дополнительную информацию можно найти в разделе Пакеты.\nСкрипты - Скрипт - документ, который содержит ваши команды. Дополнительную информацию можно найти в разделе Скрипты",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.ru.html#learning",
    "href": "new_pages/basics.ru.html#learning",
    "title": "3  Основы R",
    "section": "3.3 Ресурсы для обучения",
    "text": "3.3 Ресурсы для обучения\n\nРесурсы внутри RStudio\nСправочная документация\nПоищите документацию по пакетам и конкретным функциям R во вкладке “Help” (справка) в RStudio. Она находится в панели, где содержатся Файлы, Графики и Пакеты (как правило, нижняя правая панель). Альтернативно, вы можете также поставить вопросительный знак и после него напечатать название пакета или функции в консоли R, чтобы открыть соответствующую страницу Справки. Не включайте скобки.\nНапример: ?filter или ?diagrammeR.\nИнтерактивное обучение\nЕсть несколько способов интерактивного изучения R внутри RStudio.\nСама RStudio предлагает панель Tutorial (обучение), которая основана на learnr R package. Просто установите этот пакет и откройте самоучитель через новую вкладку “Tutorial” (обучение) в верхней правой панели RStudio (в которой также находятся вкладки Environment (рабочая среда) и History (история)).\nПакет R swirl предлагает интерактивное обучение в Консоли R. Установите и загрузите этот пакет, затем выполните команду swirl() (с пустыми скобками) в консоли R. В Консоли появятся подсказки. Печатайте ответ в Консоли. Пакет поможет вам пройти интересующий курс.\n\n\nШпаргалки\nСуществует много PDF “шпаргалок” на сайте RStudio, например:\n\nКоэффициенты в пакете forcats\n\nДаты и время в пакете lubridate\n\nПоследовательности в пакете stringr\n\nПовторяющиеся операции в пакете purrr\n\nИмпорт данных\n\nШпаргалка по преобразованию данных с помощью пакета dplyr\n\nR Markdown (чтобы создавать документы в формате PDF, Word, Powerpoint…)\n\nShiny (чтобы создавать интерактивные веб-приложения)\n\nВизуализация данных в пакете ggplot2\n\nКартография (GIS)\n\nПакет leaflet (интерактивные карты)\n\nPython с помощью R (пакет reticulate)\n\nЕсть онлайн ресурс по R специально для пользователей Excel\n\n\nTwitter\nУ R есть активное твиттер-сообщество, в котором вы можете найти полезные советы, подсказки, а также новости - подпишитесь на следующие аккаунты:\n\nПодпишитесь на нас! @epiRhandbook\n\nR Функция Дня @rfuntionaday - замечательный ресурс\n\nR для Науки о данных @rstats4ds\n\nRStudio @RStudio\n\nRStudio Советы @rstudiotips\n\nR-Bloggers @Rbloggers\n\nR-ladies @RLadiesGlobal\n\nHadley Wickham @hadleywickham\n\nТакже:\n#epitwitter и #rstats\n\n\nБесплатные онлайн ресурсы\nАвторитетный источник по R для Аналитики Данных - книга Гарретта Гролемунда и Хэдли Викхэма\nВеб-сайт проекта R4Epis направлен на “разработку стандартизированных инструментов вычистки, анализа данных и ответности, которые бы охватывали основные типы исследований по вспышкам и популяционных исследований, которые могут проводиться в условиях экстренного реагирования Врачей Без Границ.” Там вы можете найти материалы для обучения основам R, шаблоны для отчетов RMarkdown по вспышкам и исследованиям, а также самоучители, которые помогут вам их настроить.\n\n\nЯзыки кроме английского\nMateriales de RStudio en Español\nIntroduction à R et au tidyverse (Francais)",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.ru.html#установка",
    "href": "new_pages/basics.ru.html#установка",
    "title": "3  Основы R",
    "section": "3.4 Установка",
    "text": "3.4 Установка\n\nR и RStudio\nКак установить R\nЗайдите на этот вебсайт https://www.r-project.org/ и скачайте последнюю версию R, подходящую для вашего компьютера.\nКак установить RStudio\nЗайдите на этот вебсайт https://rstudio.com/products/rstudio/download/ и скачайте последнюю версию десктоп приложения RStudio, подходящую для вашего компьютера.\nРазрешения\nОбратите внимание, что устанавливать R и RStudio нужно на диск, для которого у вас есть разрешения для чтения и внесения изменений. Иначе у вас будут проблемы с установкой пакетов R (это часто случается). Если вы столкнетесь с проблемой, попробуйте открыть RStudio правым кликом мышки и выберите вариант “Запуск от имени администратора”. Дополнительные соеветы можно найти на странице R на сетевых дисках.\nКак обновлять R и RStudio\nНомер версии R написан на Консоли при запуске. Вы можете это также проверить через sessionInfo().\nЧтобы обновить R, зайдите на указанный выше веб-сайт и переустановите R. Альтернативно, вы можете использовать пакет installr (на Windows), выполнив команду installr::updateR(). Она откроет диалоговые окна, с помощью которых вы можете скачать последнюю версию R и обновить свои пакеты до самой новой версии R. Дополнительную информацию можно найти в installr документации.\nИмейте ввиду, что старая версия R все еще будет существовать на вашем компьютере. Вы можете временно запустить более старую версию (установленную ранее) R, нажав на “Tools” -&gt; “Global Options” в RStudio и выбрав версию R. Это может быть полезным, если вам нужно использовать пакет, который не был обновлен для работы в последней версии R.\nЧтобы обновить RStudio, вы можете зайти на указанный выше сайт и повторно скачать RStudio. Еще один вариант - кликнуть на “Help” -&gt; “Check for Updates” (справка-проверить обновления) в RStudio, но там не всегда будут отображаться самые последние обновления.\nЧтобы увидеть, какие версии R, RStudio, либо пакетов использовались на момент создания данного Руководства, см. страницу Редакторские и технические заметки.\n\n\nДругие программы, которые вам может понадобиться установить\n\nTinyTeX (для преобразования документа RMarkdown в PDF)\n\nPandoc (для формирования документов RMarkdown)\n\nRTools (для создания пакетов для R)\n\nphantomjs (для сохранения статичных изображений из анимированных сетей, например, цепочек передачи инфекции)\n\n\nTinyTex\nTinyTex - кастомизированный дистрибутив LaTeX, полезен при создании PDF из R.\nДополнительную информацию можно найти по адресу https://yihui.org/tinytex/.\nЧтобы установить TinyTex из R:\n\ninstall.packages('tinytex')\ntinytex::install_tinytex()\n# чтобы удалить TinyTeX, выполните tinytex::uninstall_tinytex()\n\n\n\nPandoc\nPandoc - конвертер документов, отдельная от R программа. Она идет в комплекте с RStudio и обычно не требует отдельного скачивания. Она помогает в процессе конвертации документов в такие форматы как .pdf и добавлении сложного функционала.\n\n\nRTools\nRTools - коллекция программного обеспечения для создания пакетов для R\nУстановите с веб-сайта: https://cran.r-project.org/bin/windows/Rtools/\n\n\nphantomjs\nЧасто используется для создания “снимков экрана” веб-страниц. Например, когда вы создаете цепочки передачи инфекции с помощью пакета epicontacts, создается HTML файл, который является интерактивным и динамичным. Если вам нужно статичное изображение, полезно будет использовать пакет webshot для автоматизации этого процесса. Это также потребует внешней программы “phantomjs”. Вы можете установить phantomjs с помощью пакета webshot, использовав команду webshot::install_phantomjs().",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.ru.html#rstudio",
    "href": "new_pages/basics.ru.html#rstudio",
    "title": "3  Основы R",
    "section": "3.5 RStudio",
    "text": "3.5 RStudio\n\nОриентация в RStudio\nВо-первых, откройте RStudio. Поскольку иконки выглядят похоже, убедитесь, что вы открыли именно RStudio, а не R.\nДля работы RStudio у вас на компьютере должен быть установлен R (см. инструкции по установке выше).\nRStudio - это интерфейс (ГИП) для облегчения использования R. Можете представить себе R как двигатель автомобиля, который выполняет основную работу, а RStudio как кузов автомобиля (с сидениями, аксессуарами и т.п.), который помогает использовать двигатель для движения! Вы можете полную шпаргалку по пользовательскому интерфейсу RStudio (PDF) здесь\nПо умолчанию RStudio отображает четыре прямоугольные панели.\n\n\n\n\n\n\n\n\n\nСОВЕТ: Если в вашем RStudio отображается только одна левая панель, это происходит потому что вы еще не открыли скрипты.\nПанель Source (источник)\nЭта панель, по умолчанию расположенная в верхней левой части, представляет собой пространство для редактирования, выполнения и сохранения ваших скриптом. Скрипты содержат команды, которые вы хотите выполнить. На этой панели также могут отображаться наборы данных (датафреймы) для просмотра.\nДля пользователей Stata, данная панель похожа на окна Do-file и Data Editor.\nПанель R Console (консоль)\nКонсоль R, по умолчанию расположенная в нижней левой части в R Studio, является местом расположения “двигателя” R. Здесь происходит собственно выполнение команд, и там же появляются неграфические выходные данные и сообщения об ошибках/предупреждения. Вы можете вводить и выполнять команды напрямую в Консоли R, но нужно понимать, что эти команды не сохраняются, как при выполнении команд из скрипта.\nЕсли вы знакомы со Stata, Консоль R похожа на командное окно и окно результатов.\nПанель Environment (рабочая среда)\nДанная панель, по умолчанию расположенная в верхней правой части, является наиболее часто используемой для просмотра краткой информации по объектам в рабочей среде R в рамках текущей сессии. Эти объекты могут включать импортированные, модифицированные или созданные наборы данных, заданные вами параметры (например, конкретная эпиднеделя для анализа), либо векторы или списки, которые вы задали во время анализа (например, названия регионов). Вы можете нажат на стрелку рядом с названием датафрейма, чтобы увидеть его переменные.\nЭта понель похожа на окно Менеджера переменных в Stata.\nВ этой панели также содержится Источрия, где вы можете увидеть предыдущие команды. В ней также есть вкладка “Tutorial” (обучение), где вы можете пройти интерактивное обучение по R, если у вас установлен пакет learnr. It also has a “Connections” pane for external connections, and can have a “Git” pane if you choose to interface with Github.\nПанель Plots (графики), Viewer (просмотр), Packages (пакеты), и Help (справка)\nНижняя правая панель включает в себя несколько важных вкладок. Типичные графики, включая карты, будут отображаться на панели Plot (график). Интерактивные или HTML выходные данные будут отображаться в панели Viewer (просмотр). Панель Help (справка) может отображать файлы с документацией и со справкой. Панель Files (файлы) является средством просмотра, который можно использовать для открытия или удаления файлов. Панель Packages (пакеты) позволяет вам видеть, устанавливать, обновлять, удалять загружать/сбрасывать пакеты R, а также просматривать, какая у вас версия пакета. Чтобы получить дополнительную информацию о пакетах, см. раздел пакеты ниже.\nВ данную панель входит функционал, похожий на окна Менеджера графиков и Менеджера проекта в Stata.\n\n\nНастройки RStudio\nИзменить настройки и вид RStudio можно в выпадающем меню во вкладке Tools (инструменты), выбрав Global Options (глобальные опции). Там можно изменить настройки по умолчанию, включая внешний вид/цвет фона.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nПерезапуск\nЕсли R зависнет, вы можете перезапустить R, зайдя в меню Сессии и нажав “Restart R (перезапуск R)”. Это позволит избежать необходимости закрытия и открытия RStudio. Когда вы выполните это действие, все объекты из вашей рабочей среды будут удалены.\n\n\nГорячие клавиши\nНиже представлены полезные сочетания клавиш. См. все горячие клавиши для Windows, Max и Linux на второй странице данной шпаргалки по пользовательскому интерфейсу RStudio.\n\n\n\n\n\n\n\n\nWindows/Linux\nMac\nДействие\n\n\n\n\nEsc\nEsc\nПрерывает текущую команду (полезно, если вы случайно выполнили неполную команду, не можете выйти и видите “+” в консоли R)\n\n\nCtrl+s\nCmd+s\nСохраняет (скрипт)\n\n\nTab\nTab\nАвтозаполнение\n\n\nCtrl + Enter\nCmd + Enter\nВыполняет текущую строку(и)/выбранный код\n\n\nCtrl + Shift + C\nCmd + Shift + c\nКомментирование/снятие комментария с выделенных строк\n\n\nAlt + -\nOption + -\nВставка &lt;-\n\n\nCtrl + Shift + m\nCmd + Shift + m\nВставка %&gt;%\n\n\nCtrl + l\nCmd + l\nОчистка консоли R\n\n\nCtrl + Alt + b\nCmd + Option + b\nВыполнить, начиная с начала до текущей строки\n\n\nCtrl + Alt + t\nCmd + Option + t\nВыполнить текущий раздел кода (R Markdown)\n\n\nCtrl + Alt + i\nCmd + Shift + r\nВставить блок кода (в R Markdown)\n\n\nCtrl + Alt + c\nCmd + Option + c\nВыполнить текущий блок кода (R Markdown)\n\n\nСтрелки вверх/вниз на консоли R\nТе же\nПереключение через последние выполненные команды\n\n\nShift + Стрелки вверх/вниз в скрипте| Те же\nВыбор нескольких строк кода\n\n\nCtrl + f\nCmd + f\nНайти и заменить в текущем скрипте\n\n\nCtrl + Shift + f\nCmd + Shift + f\nНайти в файлах (поиск/замена в нескольких скриптах)\n\n\nAlt + l\nCmd + Option + l\nСвернуть выбранный код\n\n\nShift + Alt + l\nCmd + Shift + Option+l\nРазвернуть выбранный код\n\n\n\nСОВЕТ: Используйте клавишу Tab при печатании, чтобы задействовать функционал RStudio по автозаполнению. Это позволит избежать ошибок в правописании. Нажмите Tab при печатании, чтобы вышло выпадающее меню с наиболее вероятными функциями и объектами, исходя из уже напечатанного вами текста.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.ru.html#functions",
    "href": "new_pages/basics.ru.html#functions",
    "title": "3  Основы R",
    "section": "3.6 Функции",
    "text": "3.6 Функции\nФункции лежат в основе использования R. Функции позволяют выполнять задачи и операции. Многие функции уже установлены в R, многие доступны к скачиванию в пакетах (объясняются в разделе пакеты), и вы можете даже написать свои собственные функции!\nВ этом разделе по основам функций объясняется:\n\nЧто такое функция и как она работает\n\nЧто такое аргументы функции\n\nКак получить помощь, чтобы понять функцию\n\nКраткий комментарий по синтаксису: В данном руководстве функции записаны в тексте кода с открытыми скобками, например: filter(). Как объясняет раздел пакеты, функции скачиваются в пакетах. В данном руководстве названия пакетов пишутся жирным, например, dplyr. Иногда в примере кода вы можете увидеть название функции, сразу связанное с названием пакета с помощью двойного двоеточия (::), например: dplyr::filter(). Цель такой связки объясняется в разделе пакеты.\n\n\nПростые функции\nФункция как машина, которая получает вводные данные, как-то их преобразует и выдает результат. Каким будет результат, зависит от функции.\nФункции, как правило, работают над каким-то объектом, размещенным в скобках в функции. Например, функция sqrt() вычисляет квадратный корень числа:\n\nsqrt(49)\n\n[1] 7\n\n\nОбъектом, заданным для функции, может быть столбец в наборе данных (см. раздел Объекты для более детальной информации о всех типах объектов). Поскольку в R может храниться несколько наборов данных, вам нужно будет уточнить и набор данных, и столбец. Это можно сделать, используя знак $, чтобы связать название набора данных и название столбца (dataset$column). В примере ниже функция summary() применяется к числовому столбцу age (возраст) в наборе данных linelist, а результатом является сводная информация по числовым и отсутствующим значениям в столбце.\n\n# Печатает сводную статистику по столбцу 'age' в наборе данных 'linelist'\nsummary(linelist$age)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00    6.00   13.00   16.07   23.00   84.00      86 \n\n\nПРИМЕЧАНИЕ: Фоново функция представляет собой сложный дополнительный код, который упакован для пользователя в одну простую команду.\n\n\n\nФункции с несколькими аргументами\nФункции часто требуют нескольких вводных данных, которые называются аргументы, которые располагаются внутри скобок функции, и, как правило, разделяются запятыми.\n\nНекоторые аргументы обязательны для правильной работы функции, другие являются опциональными\n\nОпциональные аргументы имеют настройки по умолчанию\n\nАргументы могут быть текстовыми, числовыми, логическими (TRUE/FALSE (ИСТИНА/ЛОЖЬ)) и другими\n\nЗдесь вы видите интересную выдуманную функцию, которая называется oven_bake() (печем пирог), она является примером типичной функции. Она берет входной объект (например, набор данных или в данном случае “тесто”) и проводит операции с ним, указанные с помощью дополнительных аргументов (minutes = (минуты) и temperature = (температура)). Выходные данные могут быть напечатаны в консоли, либо сохранены в качестве объекта, используя оператор присваивания &lt;-.\n\n\n\n\n\n\n\n\n\nЕсли рассмотреть более реалистичный пример, команда age_pyramid() ниже создает график возрастной пирамиды на основе заданных возрастных групп и двоичной графы gender (пол). Функции задаются три аргумента в скобках, которые отделяются запятыми. Значения, заданные в виде аргументов, определяют используемый датафрейм linelist, age_cat5 как столбец для подсчета, а gender как двоичный столбец для разделения пирамиды по цветам.\n\n# Создание возрастной пирамиды\nage_pyramid(data = linelist, age_group = \"age_cat5\", split_by = \"gender\")\n\n\n\n\n\n\n\n\nУказанные выше команды могут быть также записаны так, как указано ниже, более длинным стилем, где каждый аргумент начинается с новой строки. Этот стиль кодирования легче читать, к нему легче писать “комментарии” с помощью знака #, чтобы пояснить каждую часть (подробные комментарии - хорошая практика!). Чтобы выполнить эту более длинную команду, вы можете выделить всю команду и нажать “Run”, либо просто поместите курсор в первую строку и нажмите одновременно клавиши Ctrl и Enter.\n\n# Создание возрастной пирамиды\nage_pyramid(\n  data = linelist,        # использовать построчный список случаев\n  age_group = \"age_cat5\", # задать столбец возрастной группы\n  split_by = \"gender\"     # использовать столбец gender для двух сторон пирамиды\n  )\n\n\n\n\n\n\n\n\nПервая половина присваивания аргумента (например, data =) не обязательно требует уточнения, если аргументы пишутся в указанном порядке (порядок указывается в документации по функции). Указанный ниже код выдаст абсолютно идентичную пирамиду, что и выше, поскольку функция ожидает порядка аргументов: датафрейм, переменная age_group (возрастная группа), переменная split_by (разделить по).\n\n# Эта команда выдаст такой же график, что и выше\nage_pyramid(linelist, \"age_cat5\", \"gender\")\n\nБолее сложная команда age_pyramid() может включать опциональные аргументы, чтобы:\n\nПоказать пропорции вместо абсолютных чисел (установить proportional = TRUE, хотя по умолчанию стоит FALSE)\n\nУказать два цвета, которые будут использованы (pal = это сокращение от слова “палетка”, в которой есть векторы двух названий цветов. См. страницу объекты для получения информации о том, как функция c() создает вектор)\n\nПРИМЕЧАНИЕ: Для аргументов, для которых вы указываете обе части аргумента (например, proportional = TRUE), их порядок среди всех других аргументов не имеет значения.\n\nage_pyramid(\n  linelist,                    # использовать построчный список случаев\n  \"age_cat5\",                  # столбец возрастной группы\n  \"gender\",                    # разделить по полу\n  proportional = TRUE,         # проценты вместо абсолютного количества\n  pal = c(\"orange\", \"purple\")  # цвета\n  )\n\n\n\n\n\n\n\n\n\n\n\nНаписание Функций\nR - язык, построенный на основе функций, поэтому вы можете свободно писать свои собственные функции. Создание функций даст вам ряд преимуществ:\n\nОблегчит модульное программирование - разделение кода на независимые и управляемые блоки\n\nЗаменит многократное копирование и вставку, которое несет риск ошибок\n\nДаст блокам кода запоминающиеся названия\n\nНаписание функции более детально изучается на странице Написание функций.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.ru.html#packages",
    "href": "new_pages/basics.ru.html#packages",
    "title": "3  Основы R",
    "section": "3.7 Пакеты",
    "text": "3.7 Пакеты\nПакеты содержат функции.\nПакет R - набор кода и документации, которыми можно делиться и которые содержат заранее заданные функции. Пользователи в сообществе R все время разрабатывают пакеты для решения конкретных проблем, вероятно, что кто-то из них сможет помочь вам с вашей работой! В процессе использования R вы будете устанавливать и использовать множество пакетов.\nПри установке R содержит “базовые” пакеты и функции, которые выполняют частые элементарные задачи. Но многие пользователи R создают специализированные функции, которые проверяются сообществом R, и которые вы можете скачать в виде пакета для собственного использования. В данном руководстве названия пакетов записываются жирным. Одним из сложных аспектов R является то, что часто существует множество функций или пакетов для выполнения одной и той же задачи, из которых вы можете выбирать.\n\nУстановка и загрузка\nФункции содержатся внутри пакетов, которые можно скачать (“установить”) на ваш компьютер с интернета. Как только пакет скачан, он хранится в вашей “библиотеке”. Затем вы можете получить доступ к функциям, которые содержатся в пакетах в ходе текущей сессии R, “загрузив” пакет.\nСчитайте R вашей личной библиотекой: Когда вы скачиваете пакет, в вашей библиотеке появляется новая книга функций, но каждый раз, когда вы хотите использовать функцию из этой книги, вам нужно взять эту книгу (“загрузить”) из библиотеки.\nПодведем итог: чтобы использовать функции, доступные в пакете R, необходимо выполнить 2 шага:\n\nПакет необходимо установить (один раз), и\n\nПакет необходимо загрузить (при каждой сессии R)\n\n\nВаша библиотека\nВаша “библиотека” на самом деле является папкой в вашем компьютере, в которой содержится папка для каждого пакета, который был установлен. Найдите, где установлен R на вашем компьютере, найдите папку под названием “win-library”. Например: R\\win-library\\4.0 (4.0 - это версия R - у вас будет разная библиотека для каждой скаченной версии R).\nВы можете вывести путь к файлу для вашей библиотеки, введя .libPaths() (пустые скобки). Это станет особенно важно, если вы работаете с R на сетевых дисках.\n\n\nУстановка из CRAN\nНаиболее часто пользователи R скачивают пакеты из CRAN. CRAN (Комплексная сеть архива R) - это онлайн публичное хранилище пакетов R, которые были опубликованы сообществом R.\nВы боитесь вирусов и обеспокоены вопросами безопасности при скачивании пакета с CRAN? Прочитайте эту статью по данной теме.\n\n\nКак установить и загрузить\nВ данном руководстве мы советуем использовать пакет pacman (сокращение от “package manager (менеджер пакетов)”). В нем есть удобная функция p_load(), которая установит пакет, если необходимо, и загрузит его для использования в текущей сессии R.\nСинаксис очень прост. Просто укажите названия пакетов внутрти скобок p_load(), отделив запятыми. Эта команда установит пакеты rio, tidyverse и here, если они еще не установлены, а также загрузит их для использования. Это делает подход p_load() удобным и кратким, если вы делитесь скриптами с другими. Обратите внимание, что названия пакетов чувствительны к регистру.\n\n# Установить (если необходимо) и загрузить пакеты для использования\npacman::p_load(rio, tidyverse, here)\n\nОбратите внимание, что мы использовали синтаксис pacman::p_load(), в котором четко записано название пакета (pacman) перед названием функции (p_load()), и они соединены двумя двоеточиями ::. Этот синтаксис полезен, поскольку он также загружает пакет pacman (если он уже установлен).\nСуществуют альтернативные базовые функции R, с которыми вы будете часто сталкиваться. Базовая функция R для установки пакета - это install.packages(). Название пакета для установки необходимо указать в скобках в кавычках. Если вы хотите установить несколько пакетов одной командой, они должны быть перечислены внутри вектора символов c().\nПримечание: эта команда устанавливает пакет, но не загружает его для использования в текущей сессии.\n\n# установка одного пакета с помощью базового R\ninstall.packages(\"tidyverse\")\n\n# установка нескольких пакетов с помощью базового R\ninstall.packages(c(\"tidyverse\", \"rio\", \"here\"))\n\nУстановку можно также выполнить, зайдя в панель RStudio “Packages” (пакеты) и нажав “Install” (установить) и поискав название необходимого пакета.\nБазовая функция в R для загрузки пакета для использования (после того, как он установлен) - это library(). Она может загружать только по одному пакету за раз (еще одна причина, почему лучше использовать p_load()). Вы можете указать название пакета с или без кавычек.\n\n# загружает пакеты для использованя с базовым R\nlibrary(tidyverse)\nlibrary(rio)\nlibrary(here)\n\nЧтобы проверить, установлен ли и/или загружен ли пакет, вы можете просмотреть панель Packages (пакеты) в RStudio. Если пакет установлен, он будет отражаться там с номером версии. Если стоит галочка рядом с ним, значит он загружен для текущей сессии.\nУстановка с Github\nИногда может потребоваться установить пакет, которого еще нет на CRAN. Или, может быть, пакет есть на CRAN, но вам нужна версия разработчиков с новыми свойствами, которые еще недоступны в более стабильной опубликованной версии CRAN. Такие пакеты часто размещаются на сайте github.com в бесплатном общедоступном “репозитории” кода. Более детальную информацию о Github вы можете получить в данном руководстве на странице [Контроль версий и совместная работа с помощью Git и Github].\nЧтобы скачать пакеты R с Github, вы можете использовать функцию p_load_gh() из pacman, которая установит пакет, если необходимо, и загрузит для использования в текущей сессии R. Альтернативно можно провести установку с помощью пакетов remotes или devtools. Более подробную информацию обо всех функциях pacman можно прочитать в документации по пакету.\nДля установки с Github вам нужно задать больше информации. Вы должны указать:\n\nGithub ID владельца репозитория\nНазвание репозитория, в котором содержится пакет\n\n(опционально) Название “ветви” (конкретной версии разработчика), которую вы хотите скачать\n\nВ примерах ниже первое слово в кавычках - это Github ID владельца репозитория, после слэша идет название репозитория (название пакета).\n\n# установка/загрузка пакета epicontacts из репозитория Github\np_load_gh(\"reconhub/epicontacts\")\n\nЕсли вы хотите произвести установку из другой “ветви” (версии), а не из основной ветви, добавьте название ветви после “@”, после названия репозитория.\n\n# установка ветви \"timeline\" для пакета epicontacts из Github\np_load_gh(\"reconhub/epicontacts@timeline\")\n\nЕсли нет разницы между версией в Github и версией на вашем компьютере, никакие действия не будут выполнены. Вы можете принудительно сделать переустановку, используя p_load_current_gh() с аргументом update = TRUE. Более подробно о pacman можно почитать в этой онлайн виньетке\nУстановка из ZIP или TAR\nВы можете установить пакет из URL:\n\npackageurl &lt;- \"https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz\"\ninstall.packages(packageurl, repos=NULL, type=\"source\")\n\nЛибо скачать его на свой компьютер в архиве:\nВариант 1: использовать install_local() из пакета remotes\n\nremotes::install_local(\"~/Downloads/dplyr-master.zip\")\n\nВариант 2: использовать install.packages() из базового R, указав путь к ZIP файлу и установив type = \"source и repos = NULL.\n\ninstall.packages(\"~/Downloads/dplyr-master.zip\", repos=NULL, type=\"source\")\n\n\n\n\nСинтаксис кода\nДля ясности в руководстве функции иногда приводятся с указанием сначала названия пакета, используя символ :: следующим образом: package_name::function_name()\nКак только пакет загружен для сессии такой подробный стиль уже не нужен. Можно просто использовать function_name(). Однако написание названия пакета полезно, если у функции частое название, которое может существовать в нескольких пакетах (например, plot()). Написание названия пакета также позволит загрузить пакет, если он еще не загружен.\n\n# Данная команда использует пакет \"rio\" и его функцию \"import()\" для импорта набора данных\nlinelist &lt;- rio::import(\"linelist.xlsx\", which = \"Sheet1\")\n\n\n\nСправка по функциям\nЧтобы почитать дополнительную информацию о функции вы можете найти ее во вкладке Help (справка) в нижней правой части RStudio. Вы можете также выполнить команду ?thefunctionname (напишите название функции после знака вопрос) и появится страница Справка на панели Справка. Либо можно поискать ресурсы онлайн.\n\n\nОбновление пакетов\nВы можете обновить пакеты, переустановив их. Вы можете также кликнуть зеленую кнопку “Update” (обновления) на панели RStudio Packages (пакеты), чтобы проверить, у каких пакетов есть новые версии для установки. Имейте ввиду, что может потребоваться обновление вашего старого кода, если произошли серьезные изменения в работе функции!\n\n\nУдаление пакетов\nИспользуйте p_delete() из pacman, или remove.packages() из базового R. Альтернативно, найдите папку, в которой содержится ваша библиотека, и вручную удалите папку.\n\n\nВзаимозависимости\nВ работе пакеты часто зависят от других пакетов. Это называется взаимозависимостью. Если взаимозависимость не установлена, тогда, возможно, зависящий от нее пакет также не установится.\nПроверить взаимозависимости пакета можно с помощью p_depends(), а увидеть, какие пакеты зависят от этого с помощью p_depends_reverse()\n\n\nМаскирование функций\nЧасто бывает так, что в двух или нескольких пакетах есть функции с одинаковыми названиями. Например, в пакете dplyr есть функция filter(), но она же есть и в пакете stats. То, какая функция filter() будет использоваться по умолчанию, зависит от порядка, в котором изначально загружены эти пакеты в сессии R - более поздняя будет функцией по умолчанию для команды filter().\nВы можете проверить порядок в панели Environment (рабочая среда) в R Studio - кликните в выпадающем меню на “Global Environment” (глобальная среда) и посмотрите порядок пакетов. Функции из пакетов, расположенных ниже в этом выпадающем списке будут маскировать функции с тем же названием в пакетах, которые расположены выше в выпадающем списке. Изначально при загрузке пакета R предупредит вас в консоли, если происходит маскирование, но это предупреждение легко пропустить.\n\n\n\n\n\n\n\n\n\nСпособы исправления маскирования:\n\nУказать название пакета в команде. Например, используйте dplyr::filter()\n\nИзменить порядок загрузки пакетов (например, в p_load()), и начать новую сессию R\n\n\n\nОткрепление / сброс\nЧтобы открепить (сбросить) пакет, используйте эту команду с правильным названием пакета и с одним двоеточием. Обратите внимание, что это не всегда устранит маскирование.\n\ndetach(package:PACKAGE_NAME_HERE, unload=TRUE)\n\n\n\nУстановка более старой версии\nСм. данное руководство, чтобы установить более старую версию конкретного пакета.\n\n\nРекомендованные пакеты\nСм. страницу Рекомендованные пакеты со списком пакетов, которые мы рекомендуем для повседневной эпидемиологии.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.ru.html#scripts",
    "href": "new_pages/basics.ru.html#scripts",
    "title": "3  Основы R",
    "section": "3.8 Скрипты",
    "text": "3.8 Скрипты\nСкрипты - фундаментальная часть программироввания. Это документы, которые содержат ваши команды (например, функции для создания и модификации наборов данных, вывода визуализаций и т.п.). Вы можете сохранить скрипт и выполнить его еще раз позже. Существует множество преимуществ хранения и выполнения команд из скрипта (по сравнению с печатанием команд по одной в консоли R в “командной строке”):\n\nПереносимость - вы можете делиться своей работой с другими, отправив им свои скрипты\n\nВоспроизводимость - чтобы и вы, и другие точно знали, что именно вы сделали\n\nКонтроль версий - чтобы вы могли отслеживать изменения, которые внесли вы сами или коллеги\n\nКомментирование/аннотации - чтобы пояснить коллегам, что вы сделали\n\n\nКомментирование\nВ скрипте вы можете также комментировать свой код R. Комментирование полезно, чтобы объяснить самому себе и другим пользователям, что именно вы делаете. Добавить комментарий можно, напечатав символ решетки (#) и записав после него свой комментарий. Текст комментария будет выделен другим цветом по сравнению с кодом R.\nКод, записанный после знака #, не будет выполняться. Следовательно, вы можете поставить # перед кодом, чтобы временно заблокировать строку кода (“закомментировать”), если вы не хотите удалять ее). Вы можете закомментировать/снять комментирование с нескольких строк сразу, выделив их и нажав Ctrl+Shift+c (Cmd+Shift+c для Mac).\n\n# Комментарий может быть отдельной строкой\n# Импорт данных\nlinelist &lt;- import(\"linelist_raw.xlsx\") %&gt;%   # комментарий может стоять после кода\n# filter(age &gt; 50)                          # Может быть использован для деактивации/блокировки строки кода\n  count()\n\n\nКомментируйте, что вы делаете и почему вы это делаете.\n\nРазбивайте код на логичные разделы\n\nСопровождайте код текстовым пошаговым описанием того, что вы делаете (например, пронумерованные шаги)\n\n\n\nСтиль\nВажно обращать внимание на свой стиль кодирования - особенно при работе в команде. Мы призываем использовать tidyverse руководство по стилю. Существуют также такие пакеты, как styler и lintr, которые помогут вам соблюдать этот стиль.\nНесколько простых правил, чтобы ваш код был понятен другим:\n* При именовании объектов используйте только строчные буквы, цифры и нижние подчеркивания _, например, my_data\n* Часто используйте пробелы, в том числе вокруг операторов, например, n = 1 и age_new &lt;- age_old + 3\n\n\nПример скрипта\nНиже представлен пример короткого скрипта в R. Помните, чем лучше вы сможете кратко пояснить свой код в комментариях, тем больше ваши коллеги будут вас любить!\n\n\n\n\n\n\n\n\n\n\n\n\nR markdown\nСкрипт R markdown - тип скрипта R, в котором сам скрипт становится выводимым в результате документом (PDF, Word, HTML, Powerpoint, и т.п.). Это очень полезные и разнообразные инструменты, которые часто используются для создания динамичных и автоматизированных отчетов. Даже этот сайт и руководство создано с помощью скриптов R markdown!\nСледует отметить, что новички в R также могут использовать R Markdown - не бойтесь его! Для получения дополнительной информации см. страницу руководства Отчеты с помощью R Markdown.\n\n\n\nR notebooks\nНет разницы между написанием в Rmarkdown и R notebook. Однако выполнение документа чуть отличается. См. сайт для получения дополнительной информации.\n\n\n\nShiny\nПриложения/сайты Shiny содержатся внутри одного скрипта, который должен называться app.R. У этого файла три компонента:\n\nПользовательский интерфейс (ui)\n\nСерверная функция\n\nФункция обращения к shinyApp\n\nСм. страницу руководства Информационные панели с Shiny, либо онлайн самоучитель: Самоучитель по Shiny\nРаньше указанный выше файл делился на два файла (ui.R и server.R)\n\n\nСворачивание кода\nВы можете свернуть блоки кода, чтобы улучшить читаемость вашего скрипта.\nЧтобы это сделать, создайте заголовок текста с помощью #, напишите заголовок, после него поставьте не менее 4 дефисов (-), решеток (#) или знаков равно (=). После того, как вы это сделаете, на “полях” слева (рядом с номером строки) появится маленькая стрелочка. Вы можете кликнуть на эту стрелку и код под ней до следующего заголовка будет свернут, а вместо него появится иконка с двойной стрелкой.\nЧтобы развернуть код, кликните снова на стрелку на полях, либо на иконку с двойной стрелкой. Существуют также быстрые сочетания клавиш на клавиатуре, которые представлены в разделе RStudio на данной странице.\nСоздавая заголовки с помощью #, вы также активируете Содержание внизу вашего скрипта (см. ниже), которое вы сможете использовать для навигации по скрипту. Вы можете создавать подзаголовки, добавляя дополнительные символы #, например, # для основного заголовка, ## для подзаголовка второго уровня и ### для подзаголовка третьего уровня.\nНиже представлены две версии примера скрипта. Слева представлен оригинал с комментируемыми заголовками. Справа после каждого заголовка напечатаны четыре дефиса, что делает их сворачиваемыми. Два из них свернуты, и вы можете увидеть, что теперь в Содержании внизу указан каждый раздел.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nДругие зоны кода, которые автоматически могут сворачиваться, включают блоки со скобками { }, например определения функций или условные блоки (утверждения по принципу, если нет). Вы можете почитать дополнительную информацию о сворачивании кода на сайте RStudio.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.ru.html#рабочая-директория",
    "href": "new_pages/basics.ru.html#рабочая-директория",
    "title": "3  Основы R",
    "section": "3.9 Рабочая директория",
    "text": "3.9 Рабочая директория\nРабочая директория - корневая папка, используемая для вашей работы в R - то, где R ищет и сохраняет файлы по умолчанию. По умолчанию, программа будет сохранять новые файлы и выходные данные в эту папку, а также там будет искать файлы для импорта (например, наборы данных).\nРабочая директория отражается серым текстом в верхней части панели Console (консоль) RStudio. Вы можете также вывести текущую директорию, выполнив команду getwd() (оставьте скобки пустыми).\n\n\n\n\n\n\n\n\n\n\nРекомендованный подход\nСм. страницу [Проекты R] для получения детальной информации о рекомендуемом нами подходе к управлению рабочей директорией.\nЧастым, эффективным и беспроблемным способом управления рабочей директорией и путем к файлам является сочетание следующих 3 элементов в рабочем процессе в [Проекте R][R projects]:\n\nR Проект для хранения всех ваших файлов (см. страницу Проекты R)\n\nПакет here для расположения файлов (см. страницу Импорт и экспорт)\n\nПакет rio для импорта/экспорта файлов (см. страницу [Импорт и экспорт(importing.ru.qmd)])\n\n\n\n\nУстановка по команде\nДо недавних пор многих учили начинать скрипты в R с команды setwd(). Вместо этого, рассмотрите возможность использования рабочий процесс, ориентированный на Проект R и прочитайтепричины не использовать setwd(). Вкратце, ваша работа становится специфичной для вашего компьютера, пути к файлам, использованные для импорта и экспорта становятся “машинно-зависимыми”, а это серьезно осложняет совместную работу и использование вашего кода на других компьютерах Существуют простые альтернативы!\nКак указано выше, хотя мы и не рекомендуем этот подход в большинстве ситуаций, вы можете использовать команду setwd() и указать желаемый путь к файлу в кавычках, например:\n\nsetwd(\"C:/Documents/R Files/My analysis\")\n\nВНИМАНИЕ: Установка рабочей директории с помощью setwd() может создать “машинно-зависимый” путь, если путь к файлу специфичен для конкретного компьютера. Вместо этого используйте пути к файлу, относительные для корневой директории R проекта (с помощью пакета here).\n\n\n\nУстановка вручную\nЧтобы установить рабочую директорию вручную (кликовый аналог setwd()), кликните на меню Session (сессия), перейдите на “Set Working Directory” (установить рабочую директорию), а затем “Choose Directory” (выбрать директорию). Это задаст рабочую директорию для конкретной сессии R. Примечание: при использовании этого подхода, вам придется вручную выполнять это действие каждый раз, когда вы открываете RStudio.\n\n\n\nВнутри проекта R\nПри использовании проекта R рабочая директория по умолчанию будет установлена на корневую папку проекта R, в которой находится файл “.rproj”. Это применимо, если вы открыли RStudio, кликнув на проект R (файл с расширением “.rproj”).\n\n\n\nРабочая директория для R markdown\nВ скрипте R markdown рабочей директорией по умолчанию будет папка, в которой сохранен файл Rmarkdown (.Rmd). При использовании проекта R и пакета here, этот принцип не применим, а рабочая директория будет here(), как объясняется на странице Проекты R.\nЕсли вы хоитте сменить рабочую директорию отдельного R markdown (не в проекте R), если вы используете setwd(), это будет применимо только к этому конкретному блоку кода. Чтобы изменения были внесены во все блоки кода в R markdown, редактируйте установочный блок и добавьте параметр root.dir =, как указано ниже:\n\nknitr::opts_knit$set(root.dir = 'desired/directorypath')\n\nГораздо проще просто использовать R markdown в рамках проекта R и использовать пакет here.\n\n\n\nУказание пути к файлу\nНаверное, самым большим источником раздражения для начинающего пользователя R (по крайней мере, на компьютере на Windows) является впечатывание пути к файлу для импорта или экспорта данных. На странице Импорт и экспорт есть подробное объяснение того, как лучше всего указывать пути к фалам, но пока приведем ключевые моменты:\nСломанный путь к файлу\nНиже представлен пример “абсолютного” или “полного” пути к файлу. Такие пути могут быть сломаны при использовании на другом компьютере. Исключением является ситуация, когда вы используете общий/сетевой диск.\nC:/Users/Name/Document/Analytic Software/R/Projects/Analysis2019/data/March2019.csv  \nНаправление слэшей\nПри впечатывании пути к файлу обращайте внимание на направление слэшей. Используйте прямой слэш (/), чтобы отделить компоненты (“data/provincial.csv”). Для пользователей Windows по умолчанию отображаются пути к файлу с обратным слэшем (\\) - так что вам нужно будет изменить направление каждого слэша. Если вы используете пакет here, как описано на странице проекты R направление слэшей не будет для вас проблемой.\nОтносительный путь к файлу\nКак правило, мы рекомендуем указывать “относительный” путь к файлу - то есть, путь к файлу относительно коренной папки вашего Проекта R. Вы можете также сделать это с помощью пакета here, как указано на странице Проекты R. Относительный путь к файлу может выглядеть следующим образом:\n\n# Импорт построчного списка в csv из подпапок data/linelist/clean/ для проекта R\nlinelist &lt;- import(here(\"data\", \"clean\", \"linelists\", \"marin_country.csv\"))\n\nДаже при использовании относительного пути к файлу в Проекте R, вы все еще можете использовать абсолютные пути для импорта/экспорта данных вне Проекта R.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.ru.html#objects",
    "href": "new_pages/basics.ru.html#objects",
    "title": "3  Основы R",
    "section": "3.10 Объекты",
    "text": "3.10 Объекты\nВсё в R является объектом, а R является “объектно-ориентированным” языком. В следующих разделах будет объяснено:\n\nКак создавать объекты (&lt;-)\nТипы объектов (например, датафреймы, векторы..)\n\nКак получить доступ к частям объекта (например, переменным в наборе данных)\n\nКлассы объектов (например, числовые, логические, цельночисленные, двойной точности, знаки, факторы)\n\n\n\nВсё является объектом\nЭтот раздел адаптирован из проекта R4Epis.\nВсё, что вы храните в R - наборы данных, переменные, список названий населенных пунктов, общее население, даже такие выходные данные, как графики - это объекты, которым присваивается имя и на которые можно ссылаться в последующих командах.\nОбъект существует, когда вы присвоили ему значение (см. раздел по присвоению ниже). При присваивании значения объект появится в Рабочей среде (см. правую верхнюю панель в RStudio). Затем с ним можно работать, преобразовывать, изменять или менять его определение.\n\n\n\nОпределение объектов (&lt;-)\nСоздание объектов путем присвоения им значения с помощью оператора &lt;- .\nВы можете рассматривать оператор присваивания &lt;- как аналог слов “определяется как”. Команды присвоения, как правило, используют стандартный порядок:\nназвание_объекта &lt;- значение (или процесс/расчет, который даст значение)\nНапример, вы можете зафиксировать текущую эпидемиологическую отчетную неделю в качестве объекта, чтобы дальше ссылаться на нее в коде. В данном примере создается объект current_week, когда ему присваивается значение \"2018-W10\" (кавычки задают значение как текстовое). Объект current_week затем появится в панели Environment (Рабочая среда) RStudio (верхняя правая) и на него можно будет ссылаться в последующих командах.\nСм. команды R и их выходные данные во вставках ниже.\n\ncurrent_week &lt;- \"2018-W10\"   # эта команда создает объект current_week путем присвоения ему значения\ncurrent_week                 # эта команда выводит текущее значение объекта current_week в консоли\n\n[1] \"2018-W10\"\n\n\nПРИМЕЧАНИЕ: Обратите внимание на [1] в выходных данных на консоли R просто указывает на то, что вы просматриваете первый пункт выходных данных\nВНИМАНИЕ: Значение объекта можно заменить в любой момент времени, выполнив команду присвоения для пересмотра значения. Таким образом порядо выполнения команд очень важен.\nСледующая команда заменит значение current_week:\n\ncurrent_week &lt;- \"2018-W51\"   # присваивает НОВОЕ значение объекту current_week\ncurrent_week                 # выводит текущее значение current_week в консоли\n\n[1] \"2018-W51\"\n\n\nЗнаки равно =\nВы также будете встречать знаки равно в коде R:\n\nДвойное равно == между двумя объектами или значениями задает логический вопрос: “равно ли одно другому?”.\n\nВы также будете видеть знаки равно внутри функций для указания значений аргументов функции (дополнительная информация об этом в разделах ниже), например, max(age, na.rm = TRUE).\n\nВы можете использовать один знак равно = вместо &lt;- для создания и определения объектов, но мы не рекомендуем этого делать. Вы можете прочитать о том, почему это не рекомендуется, здесь.\n\nНаборы данных\nНаборы данных - это также объекты (как правило, “датафреймы”), им необходимо присваивать имена при импорте. С помощью кода ниже созодается объект linelist и ему присваивается значение файла CSV, импортироавнного с помощью пакета rio и его функции import().\n\n# создается построчный список и ему присваивается значение импортируемого CSV файла\nlinelist &lt;- import(\"my_linelist.csv\")\n\nВы можете прочитать дополнительную информацию об импорте и экспорте наборов данных в разделе Импорт и экспорт.\nВНИМАНИЕ: Короткий комментарий по именованию объектов:\n\nВ названиях объектов не должно быть пробелов, вместо этого используйте нижнее подчеркивание (_) или точку (.).\n\nНазвания объектов чувствительны к регистру (то есть Dataset_A отличается от dataset_A).\nНазвания объектов должны начинаться с буквы (не могут начинаться с цифры, например, 1, 2 или 3).\n\nВыходные данные\nВыходные данные, такие как таблицы и графики, являются примером того, как можно сохранять выходные данные в виде объектов, либо выводить их без сохранения. Перекрестная таблица по полу и возрасту и ее результат с использованием базовой функции R table() можно вывести напрямую в консоль R (без сохранения).\n\n# только выводится на консоль R\ntable(linelist$gender, linelist$outcome)\n\n   \n    Death Recover\n  f  1227     953\n  m  1228     950\n\n\nНо ту же самую таблицу можно сохранить как именованный объект. Затем, при необходимости ее можно вывести (напечатать) на консоль.\n\n# сохранить\ngen_out_table &lt;- table(linelist$gender, linelist$outcome)\n\n# печать\ngen_out_table\n\n   \n    Death Recover\n  f  1227     953\n  m  1228     950\n\n\nСтолбцы\nСтолбцы в наборе данных - также объекты, которые можно определить, переопределить и создать, как описано в разделе Столбцы ниже.\nВы можете использовать оператор присваивания из базового R, чтобы создать новый столбец. Ниже создается новый столбец bmi (Индекс массы тела), а для каждой строки новое значение является результатом математической операции со значениями строки в столбцах wt_kg и ht_cm.\n\n# создание нового столбца \"bmi\" с помощью синтаксиса базового R\nlinelist$bmi &lt;- linelist$wt_kg / (linelist$ht_cm/100)^2\n\nОднако в данном руководстве мы подчеркиваем другой подход к определению столбцов, который использует функцию mutate() из пакета dplyr и привязывание с помощью оператора канала (%&gt;%). Такой синтаксис легче читать, а также имеются другие преимущества, которые объясняются на странице Вычистка данных и ключевые функции. Вы можете более подробно почитать про оператор канала в разделе Использование каналов ниже.\n\n# создание нового столбца \"bmi\" с помощью синтаксиса dplyr\nlinelist &lt;- linelist %&gt;% \n  mutate(bmi = wt_kg / (ht_cm/100)^2)\n\n\n\n\nСтруктура объекта\nОбъекты могут быть одним элементом данных (например, my_number &lt;- 24), либо могут состоять из структурированных данных.\nИзображенмие ниже взято из данного онлайн самоучителя по R. Там показаны некоторые часто встречающиеся структуры данных и их названия. В эту графику не включены пространственные данные, которые рассматриваются на страницы Основы ГИС.\n\n\n\n\n\n\n\n\n\nВ эпидемиологии (а особенно в прикладной эпидемиологии), вы чаще всего будете сталкиваться с датафреймами и векторами:\n\n\n\n\n\n\n\n\n4 Частая структура\nВекторы\nОбъяснение | Пример | ==================================================================================================+=====================================================================================+ Контейнер для последовательности уникальных объектов, все из одного класса (например, числовые, текстовые). | “Переменные” (столбцы) в датафреймах являются векторами (например, столбец age_years).\n\n\n\n\nДатафреймы | Векторы (например, столбцы), которые объединены, которые имеют одинаковое количество строк\nВекторы (например, столбцы), которые объединены, которые имеют одинаковое количество строк | linelist является датафреймом. |\n\n\n\nОбратите внимание, что для создания “отдельного” вектора (который не является частью датафрейма) используется функция c() для связи разных элементов. Например, при создании вектора цветовой шкалы графика: vector_of_colors &lt;- c(\"blue\", \"red2\", \"orange\", \"grey\")\n\n\n\nКлассы объектов\nВсе объекты, хранящиеся в R имеют класс, который говорит R, как обращаться с объектом. Существует множество возможных классов, наиболее часто встречающиеся включают:\n\n\n\n5 Класс\nТекстовый\nОбъяснение | Примеры | =========================================================================================================================================================================================+=======================================================================================================+ Это текст/слова/предложения “в кавычках”. С этими объектами нельзя выполнять математические действия. | “Текстовые объекты пишутся в кавычках” |\n\n\n\n\n\n\n\n\n\n\nЦельночисленный | Только целые числа (без десятичных знаков) | -5, 14, or 2000 |\n\n\n\n\n\nЧисловые | Числа, которые могут включать десятичные знаки. Если они будут в кавычках, они будут считаться текстовым классом. | 23.1 или 14 |\n\n\n\n\n\nФакторы | Это векторы с конкретным порядком или иерархией значений | Переменная экономического статуса с упорядоченными значениями\n\n\nЭто векторы с конкретным порядком или иерархией значений | Переменная экономического статуса с упорядоченными значениями |\n\n\nДата\nКак только вы скажете R, что определенные данные являются датой, с этими данными можно будет работать и отображать особенным образом. См. страницу Работа с датами для получения детальной информации. | 2018-04-12 или 15/3/1954 или Wed 4 Jan 1980\n\n\n\n\nЛогические | Значения могут быть одним из двух специальных значений TRUE или FALSE (ИСТИНА или ЛОЖЬ) (обратите внимание, что это не “TRUE” и “FALSE” в кавычках) | TRUE или FALSE |\n\n\n\n\n\ndata.frame\nДатафрейм - то, как R хранит типичный набор данных. Он состоит из векторов (столбцов) объединенных данных, у всех из которых одинаковое количество наблюдений (строк). | Пример набора данных AJS под названием linelist_raw содержит 68 переменных и по 300 наблюдений (строк) для каждой. |\n\n\n\n\ntibble\nтаблицы tibble - вариация датафрейма, для которой основное отличие в том, что она более удобно выводится на консоль (отображает первые 10 строк и только те столбцы, которые влезут на экран) | Любой датафрейм, список или матрицу можно конвертировать в таблицу tibble с помощью as_tibble() |\n\n\n\n\nСписок | Список похож на вектор, но содержит другие объекты, которые могут быть в других классах | Список может содержать оодно число, датафрейм, вектор и даже другой список! |\n\n\n\n\n\n\nВы можете проверить класс объекта, задав его имя в функции class(). Примечание: вы можете ссылаться на конкретный столбец в наборе данных, используя знак $, чтобы отделить название набора данных и название столбца.\n\nclass(linelist)         # класс должен быть датафрейм (dataframe) или tibble\n\n[1] \"data.frame\"\n\nclass(linelist$age)     # класс должен быть числовой (numeric)\n\n[1] \"numeric\"\n\nclass(linelist$gender)  # класс должен быть текстовый (character)\n\n[1] \"character\"\n\n\nИногда R автоматически конвертирует столбец в другой класс. Следите за этим! Например, если у вас есть вектор или столбец чисел, но вставлено текстовое значение… весь столбец изменится на текстовый класс.\n\nnum_vector &lt;- c(1,2,3,4,5) # определение вектора как только чисел\nclass(num_vector)          # вектор числового класса\n\n[1] \"numeric\"\n\nnum_vector[3] &lt;- \"three\"   # конвертирован третий элемент в текстовый\nclass(num_vector)          # вектор стал относиться к текстовому классу\n\n[1] \"character\"\n\n\nЧастым примером этого является ситуация, когда вы изменяете датафрейм, чтобы напечатать таблицу - если вы создадите строку Итого и попытаетесь вставить/слепить проценты в той же ячейке, что числа (например, 23 (40%)), весь числовой столбец над этой ячейкой будет конвертирован в текстовы и больше не сможете проводить с ним математические расчеты.Иногда вам нужно будет конвертировать объекты или столбцы в другой класс.\n\n\n\n6 Функция\nas.character()\n7 Действие\nКонвертирует в текстовый класс\n\n\n\n\n\n\n\n\nas.numeric()\nКонвертирует в числовой класс\n\n\n\nas.integer()\nКонвертирует в цельночисленный класс\n\n\n\nas.Date()\nКонвертирует в класс Дата - Примечание: см. раздел даты для информации |\n\n\n\nfactor()\nКонвертирует в фактор - Примечание: изменение порядка уровней значений требует дополнительных аргументов\n\n\n\n\nАналогично, существуют базовые функции R, чтобы проверить, относится ли объект к конкретному классу, например, is.numeric(), is.character(), is.double(), is.factor(), is.integer()\nЗдесь представлен дополнительный онлайн материал по классам и структурам данных в R.\n\n\n\nСтолбцы/Переменные ($)\nСтолбец в датафрейме технически является “вектором” (см. таблицу выше) - последовательностью значений, все из которых должны относиться к одному классу (текстовый, числовой, логический и т.п.).\nВектор может существовать независимо от датафрейма, например, вектор названий столбцов, которые вы хотите включать как независимые переменные в модель. Чтобы создать “отдельный” вектор, используйте функцию c(), как показано ниже:\n\n# определение отдельного вектора текстовых значений\nexplanatory_vars &lt;- c(\"gender\", \"fever\", \"chills\", \"cough\", \"aches\", \"vomit\")\n\n# печать значений данного именованного вектора\nexplanatory_vars\n\n[1] \"gender\" \"fever\"  \"chills\" \"cough\"  \"aches\"  \"vomit\" \n\n\nСтолбцы датафрейма также являются векторами, их можно называть, ссылаться, извлекать или создавать, используя символ $. Символ $ связывает имя столбца и имя датафрейма. В данном руководстве мы стараемся использовать слово “столбец” вместо “переменная”.\n\n# Извлечение длины вектора age_years\nlength(linelist$age) # (age - столбец в датафрейме linelist)\n\nЕсли вы напечатаете название датафрейма, а затем $, вы увидите выпадающий список всех столбцов в датафрейме. Вы можете пролистать его с помощью клавиши стрелка, выбрать нужный пункт с помощью Enter и таким образом вы избежите орфографических ошибок!\n\n\n\n\n\n\n\n\n\nПРОДВИНУТЫЙ СОВЕТ: Некоторые более сложные объекты (например, спосок или объект epicontacts) могут иметьт несколько уровней, к которым вы можете получить доступ, используя несколько знаков доллара. Например, epicontacts$linelist$date_onset\n\n\n\nДоступ/индекс с помощью квадратных скобок ([ ])\nВам может потребоваться просмотр частей объектов, что также называют “индексирование”, это часто делают с помощью квадратных скобок [ ]. Использование $ для датафрема для доступа к столбцу также является типом индексирования.\n\nmy_vector &lt;- c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\")  # определение вектора\nmy_vector[5]                                  # вывод на печать 5го элемента\n\n[1] \"e\"\n\n\nКвадратные скобки также работают, чтобы выдать вам конкретные части выданных выходных данных, например, результат функции summary():\n\n# Вся сводная информация\nsummary(linelist$age)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00    6.00   13.00   16.07   23.00   84.00      86 \n\n# Только второй элемент сводной информации с названием (используя одноуровневые квадратные скобки)\nsummary(linelist$age)[2]\n\n1st Qu. \n      6 \n\n# Только второй элемент сводной информации без названия (используя двойные квадратные скобки)\nsummary(linelist$age)[[2]]\n\n[1] 6\n\n# Извлечь элемент по названию, не показывая название\nsummary(linelist$age)[[\"Median\"]]\n\n[1] 13\n\n\nКвадратные скобки также работают в датафреймах для просмотра конкретных строк и столбцов. Вы можете это сделать с помощью следующего синтаксиса dataframe[rows, columns]:\n\n# Просмотр конкретной строки (2) из набора данных со всеми столбцами (не забудьте запятую!)\nlinelist[2,]\n\n# Просмотр всех строк, но только одного столбца\nlinelist[, \"date_onset\"]\n\n# Просмотр значений из строки 2 и столбцов с 5 по 10\nlinelist[2, 5:10] \n\n# Просмотр значений из строки 2 и столбцов с 5 по 10 и 18\nlinelist[2, c(5:10, 18)] \n\n# Просмотр строк со 2 по 20, и конкретных столбцов\nlinelist[2:20, c(\"date_onset\", \"outcome\", \"age\")]\n\n# Просмотр строк и столбцов по критериям\n# *** Обратите внимание, что необходимо назвать датафрейм в критериях!\nlinelist[linelist$age &gt; 25 , c(\"date_onset\", \"outcome\", \"age\")]\n\n# Использование View(), чтобы просмотреть выходные данные в панели RStudio Viewer (просмотр) (так легче читать) \n# *** Обратите внимание на заглавную букву \"V\" в функции View()\nView(linelist[2:20, \"date_onset\"])\n\n# Сохранение как нового объекта\nnew_table &lt;- linelist[2:20, c(\"date_onset\")] \n\nОбратите внимание, что вы можете провести указанное выше индексирование строк/столбцов в датафреймах и таблицах tibble, используя синтаксис dplyr (функции filter() для строк и select() для столбцов). Более подробную информацию по этим ключевым функциям вы можете получить на странице Вычистка данных и ключевые функции.\nДля фильтра на основе “номера строки” вы можете использовать функцию dplyr row_number() с открытыми скобками как чатью утверждения для логического фильтра. Часто вы будете использовать оператор %in% и диапазон чисел в качестве логического утверждения, как показано ниже. Чтобы увидеть первые N строк, вы можете использовать специальную функцию dplyr head().\n\n# Просмотр первых 100 строк\nlinelist %&gt;% head(100)\n\n# Показать только строку 5\nlinelist %&gt;% filter(row_number() == 5)\n\n# Просмотр строк со 2 по 20, а также трех конкретных столбцов (обратите внимание, что не нужны кавычки для названия столбцов)\nlinelist %&gt;% filter(row_number() %in% 2:20) %&gt;% select(date_onset, outcome, age)\n\nПри индексации объекта в классе list (список), однократные скобки всегда выдают класс список, даже если выдан только один объект. Однако можно использовать двойные скобки для доступа к одному элементу и выведения его в другом классе, не как список.\nСкобки могут быть также записаны одна за другой, как представлено ниже.\nДанное визуальное объяснение индексации списков с перечницами является смешным и полезным.\n\n# определение демо списка\nmy_list &lt;- list(\n  # Первый элемент в списке - текстовый вектор\n  hospitals = c(\"Central\", \"Empire\", \"Santa Anna\"),\n  \n  # второй элемент в списке - датафрейм адресов\n  addresses   = data.frame(\n    street = c(\"145 Medical Way\", \"1048 Brown Ave\", \"999 El Camino\"),\n    city   = c(\"Andover\", \"Hamilton\", \"El Paso\")\n    )\n  )\n\nВот так будет выглядеть список при печати в консоли. Обратите внимание на два именованных элемента:\n\nhospitals, текстовый вектор\n\naddresses, датафрейм адресов\n\n\nmy_list\n\n$hospitals\n[1] \"Central\"    \"Empire\"     \"Santa Anna\"\n\n$addresses\n           street     city\n1 145 Medical Way  Andover\n2  1048 Brown Ave Hamilton\n3   999 El Camino  El Paso\n\n\nТеперь мы проведем извлечение разными методами:\n\nmy_list[1] # выдает элемент класса \"list\" (список) - название элемента все еще отображается\n\n$hospitals\n[1] \"Central\"    \"Empire\"     \"Santa Anna\"\n\nmy_list[[1]] # выдает только текстовый вектор (без названия)\n\n[1] \"Central\"    \"Empire\"     \"Santa Anna\"\n\nmy_list[[\"hospitals\"]] # вы можете также провести индексирование по названию элемента списка\n\n[1] \"Central\"    \"Empire\"     \"Santa Anna\"\n\nmy_list[[1]][3] # выдает третий элемент текстового вектора \"hospitals\"\n\n[1] \"Santa Anna\"\n\nmy_list[[2]][1] # выдает первый столбец (\"street\") датафрейма адресов\n\n           street\n1 145 Medical Way\n2  1048 Brown Ave\n3   999 El Camino\n\n\n\n\n\nУдаление объектов\nВы можете удалять отдельные объекты из вашей рабочей среды R, написав название в скобках в функции rm() (без кавычек):\n\nrm(object_name)\n\nВы можете удалить все объекты (очистить рабочее пространство), выполнив:\n\nrm(list = ls(all = TRUE))",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.ru.html#использование-каналов",
    "href": "new_pages/basics.ru.html#использование-каналов",
    "title": "3  Основы R",
    "section": "7.1 Использование каналов (%>%)",
    "text": "7.1 Использование каналов (%&gt;%)\nДва общих подхода к работе с объектами:\n\nКаналы/tidyverse - каналы передают объект из функции в функцию - фокус на действии, а не на объекте\n\nОпределение промежуточных объектов - объект постоянно переопределяется - фокус на объекте\n\n\n\nКаналы\nЕсли объяснять простыми словами, оператор канала (%&gt;%) передает промежуточные выходные данные из одной функции в другую.\nПредставьте, что это как написать слово “затем”. Многие функции могут быть связаны между собой с помощью %&gt;%.\n\nПередача по каналу подчеркивает порядок действий, а не объект, с которым производятся действия\n\nКаналы лучше всего использовать, когда с одним объектом необходимо провести последовательные действия\n\nКаналы взяты из пакета magrittr, который автоматически включен в пакеты dplyr и tidyverse\nКаналы делают код чище и более удобно читаемым и интуитивно понятным\n\nБолее детально об этом подходе можно почитать в руководстве по стилю tidyverse\nРассмотрим выдуманный пример для сравнения, используя выдуманные функции “выпечки пирога”. Сначала используем метод каналов:\n\n# Выдуманный пример того, как испечь пирог, используя синтаксис каналов\n\ncake &lt;- flour %&gt;%       # чтобы определить пирог, начинаем с муки, затем...\n  add(eggs) %&gt;%   # добавляем яйца\n  add(oil) %&gt;%    # добавляем масло\n  add(water) %&gt;%  # добавляем воду\n  mix_together(         # смешиваем\n    utensil = spoon,\n    minutes = 2) %&gt;%    \n  bake(degrees = 350,   # выпекаем\n       system = \"fahrenheit\",\n       minutes = 35) %&gt;%  \n  let_cool()            # даем остыть\n\nВот еще одна ссылка, которая описывает полезность каналов.\nРабота с каналами - это не базовая функция. Чтобы использовать каналы, необходимо установить и загрузить пакет magrittr (как правило, это делается при загрузке пакета tidyverse или dplyr, в которые он уже включен). Вы можете почитать детали об использовании каналов в документации по magrittr.\nОбратите внимание, что как и в других командах R, каналы могут использоваться как для вывода результата, так и для сохранения/пересохранения объекта, в зависимости от того, используется ли оператор присваивания &lt;-. См. ниже оба варианта:\n\n# Создание или перезапись объекта, определение его как подсчета совокупного количества по возрастной категории (без печати)\nlinelist_summary &lt;- linelist %&gt;% \n  count(age_cat)\n\n\n# Печать таблицы с подсчетом совокупного количества на консоли, но без сохранения\nlinelist %&gt;% \n  count(age_cat)\n\n  age_cat    n\n1     0-4 1095\n2     5-9 1095\n3   10-14  941\n4   15-19  743\n5   20-29 1073\n6   30-49  754\n7   50-69   95\n8     70+    6\n9    &lt;NA&gt;   86\n\n\n%&lt;&gt;%\nЭто “оператор присвоения” из пакета magrittr, который передает объект по каналу вперед и также переопределяет объект. Он должен быть первым оператором канала в цепочке. Это краткий вариант. Две команды, указанные ниже, являются эквивалентными:\n\nlinelist &lt;- linelist %&gt;%\n  filter(age &gt; 50)\n\nlinelist %&lt;&gt;% filter(age &gt; 50)\n\n\n\n\nОпределение промежуточных объектов\nДанный подход к изменению объектов/датафреймов может быть более подходящим, если:\n\nВам нужно работать с несколькими объектами\n\nСуществуют важные промежуточные шаги, которые требуют отдельных названий объектов\n\nРиски:\n\nСоздание новых объектов для каждого шага означает создание большого количества объектов. Вы можете перепутать объекты, не заметив этого!\n\nПрисвоение названий всем объектам может вас запутать\n\nМожет быть сложно заметить ошибки\n\nМожно называть каждый промежуточный объект, переписывать изначальный объект, либо комбинировать все функции. Во всех подходах есть свои риски.\nНиже представлен тот же выдуманный пример с “пирогом”, но с использованием другого стиля:\n\n# выдуманный пример выпечки пирога другим методом (определение промежуточных объектов)\nbatter_1 &lt;- left_join(flour, eggs)\nbatter_2 &lt;- left_join(batter_1, oil)\nbatter_3 &lt;- left_join(batter_2, water)\n\nbatter_4 &lt;- mix_together(object = batter_3, utensil = spoon, minutes = 2)\n\ncake &lt;- bake(batter_4, degrees = 350, system = \"fahrenheit\", minutes = 35)\n\ncake &lt;- let_cool(cake)\n\nОбъединение всех функций - это будет сложно читать:\n\n# пример объединения/комбинирования нескольких функций - сложно читать\ncake &lt;- let_cool(bake(mix_together(batter_3, utensil = spoon, minutes = 2), degrees = 350, system = \"fahrenheit\", minutes = 35))",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.ru.html#operators",
    "href": "new_pages/basics.ru.html#operators",
    "title": "3  Основы R",
    "section": "7.2 Ключевые операторы и функции",
    "text": "7.2 Ключевые операторы и функции\nВ данном разделе рассматриваются операторы в R, такие как:\n\nОператоры определения\n\nОператоры отношения (меньше,чем, равно..)\n\nЛогические операторы (и, или…)\n\nРабота с отсутствующими значениями\n\nМатематические операторы и функции (+/-, &gt;, sum(), median(), …)\n\nОператор %in%\n\n\n\nОператоры присвоения\n&lt;-\nБазовый оператор присвоения в R - это &lt;-. Например, object_name &lt;- value.\nЭтот оператор+ присвоения можно также записать как =. Мы советуем для R использовать &lt;-.\nМы также советуем до и по=сле таких операторов ставить пробелы для улучшения читаемости.\n&lt;&lt;-\nНаписание функций или использование R интерактивным образом со скриптами с источниками может потребовать использования следующего оператора присвоения &lt;&lt;- (из базового R). Данный оператор используется, чтобы определить объект в более высокой ‘родительской’ среде R. См. онлайн материал.\n%&lt;&gt;%\nЭто “оператор присвоения” из пакета magrittr, который передает объект вперед и также переопределяет объект. Он должен быть первым оператором канала в цепочке. Это краткая записаь, как показано ниже в двух равнозначных примерах:\n\nlinelist &lt;- linelist %&gt;% \n  mutate(age_months = age_years * 12)\n\nПример выше эквивалентен следующему примеру:\n\nlinelist %&lt;&gt;% mutate(age_months = age_years * 12)\n\n%&lt;+%\nЭтот оператор используется для добавления данных в филогенетические деревья в пакете ggtree. См. страницу Филогенетические деревья или данный онлайн справочник.\n\n\n\nОператоры отношения и логические операторы\nОператоры отношения сравнивают значения и часто используются при определении новых переменных и поднаборов данных. Ниже приведены часто используемые операторы отношений в R:\n\n\n\nЗначение | Оператор | Пример ==========================+============+============== Равно | == | \"A\" == \"a\"\n\n\nПример результата | ========================================================================================================================================================+ FALSE (поскольку R чувствителен к регистру) Обратите внимание, что == (двойное равно) отличается от = (одинарного равно), которое работает как оператор присвоения &lt;- |\n\n\n\n\n\n\n\n\n\n\nНе равно\n!=\n2 != 0\nTRUE\n\n\n\nБольше, чем\n&gt;\n4 &gt; 2\nTRUE\n\n\n\nМеньше, чем\n&lt;\n4 &lt; 2\nFALSE\n\n\n\nБольше или равно\n&gt;=\n6 &gt;= 4\nTRUE\n\n\n\nМеньше или равно\n&lt;=\n6 &lt;= 4\nFALSE\n\n\n\nЗначение отсутствует\nis.na()\nis.na(7)\nFALSE (см. страницу Отсутствующие данные)\n\n\n\nЗначение не отсутствует\n!is.na()\n!is.na(7)\nTRUE\n\n\n\n\nЛогические операторы, такие как И и ИЛИ, часто используются для связи операторов отношения и создания более сложных критериев. Сложные утверждения могут потребовать скобок ( ) для группирования и определения порядка применения.\n\n\n\n\n\n\n\nЗначение\nОператор\n\n\n\n\nИ\n&\n\n\nИЛИ\n| (вертикальная черта)\n\n\nСкобки\n( ) Для группировки критериев и уточнения порядка операций\n\n\n\nНапример, ниже у нас есть построчный список с двумя переменными, которые мы хотим использовать для создания определения случая, hep_e_rdt, результат теста и other_cases_in_hh, которая скажет нам, есть ли другие случаи в домохозяйстве. Команда ниже использует функцию case_when(), чтобы создать новую переменную case_def, чтобы:\n\nlinelist_cleaned &lt;- linelist %&gt;%\n  mutate(case_def = case_when(\n    is.na(rdt_result) & is.na(other_case_in_home)            ~ NA_character_,\n    rdt_result == \"Positive\"                                 ~ \"Confirmed\",\n    rdt_result != \"Positive\" & other_cases_in_home == \"Yes\"  ~ \"Probable\",\n    TRUE                                                     ~ \"Suspected\"\n  ))\n\n\n\n\n\n\n\n\nКритерии в примере выше\nРезультат в новой переменной “case_def”\n\n\n\n\nЕсли значения переменной rdt_result и other_cases_in_home отсутствуют\nNA (отсутствует)\n\n\nЕсли значение в rdt_result “Positive” (положительный)\n“Confirmed” (подтвержденный)\n\n\nЕсли значение в rdt_result НЕ “Positive” И значение в other_cases_in_home “Yes” (да)\n“Probable” (вероятный)\n\n\nЕсли один из указанных выше критериев не выполнен\n“Suspected” (подозрительный)\n\n\n\nОбратите внимание, что R чувствителен к регистру, так что “Positive” отличается от “positive”…\n\n\n\nОтсутствующие значения\nВ R отсутствующие значения представлены особым значением NA (“зарезервированное” значение) (заглавные буквы N и A - без кавычек). Если вы импортируете данные, которые кодируют отсутствующие значения иным образом (например, 99, “Missing”, или .), вам, возможно, нужно перекодировать эти значения в NA. То, как это делать, рассмотрено на странице Импорт и экспорт.\nTo test whether a value is NA, use the special function is.na(), which returns TRUE or FALSE.\n\nrdt_result &lt;- c(\"Positive\", \"Suspected\", \"Positive\", NA)   # два положительных случая, один подозрительный и один неизвестный\nis.na(rdt_result)  # Тестирует, является ли значение rdt_result NA\n\n[1] FALSE FALSE FALSE  TRUE\n\n\nБолее подробно почитать об отсутствующих, бесконечных, NULL и невозможных значениях можно на странице [Отсутствующие данные]. Узнайте, как конвертировать отсутствующие значения при импорте данных на странице Импорт и экспорт.\n\n\n\nМатематика и статистика\nВсе операторы и функции на этой странице автоматически доступны в базовом R.\n\nМатематические операторы\nИх часто использует для сложения, деления, создания новых столбцов и т.п. Ниже представлены часто используемые математические операторы в R. Наличие пробелов перед и после операторов не имеет значения.\n\n\n\nЦель\nПример в R\n\n\n\n\nсложение\n2 + 3\n\n\nвычитание\n2 - 3\n\n\nумножение\n2 * 3\n\n\nделение\n30 / 5\n\n\nвозведение в степень\n2^3\n\n\nпорядок операций\n( )\n\n\n\n\n\nМатематические функции\n\n\n\nЦель\nФункция\n\n\n\n\nокругление\nround(x, digits = n)\n\n\nокругление\njanitor::round_half_up(x, digits = n)\n\n\nокругление большее\nceiling(x)\n\n\nокругление меньшее\nfloor(x)\n\n\nабсолютное значение\nabs(x)\n\n\nквадратный корень\nsqrt(x)\n\n\nэкспонента\nexponent(x)\n\n\nнатур.логарифм\nlog(x)\n\n\nlog по основанию 10\nlog10(x)\n\n\nlog по основанию 2\nlog2(x)\n\n\n\nПримечание: для round() параметр digits = указывает количество знаков после запятой. Используйте signif() для округления чисел до значимой цифры.\n\n\nНаучная запись\nВероятность использования научной записи зависит от значения опции scipen.\nИз документации по ?options: scipen - штраф, который применяется при принятии решений о выводе числовых значений в фиксированной или научной записи. Положительные значения склоняются к фиксированной записи, а отрицательные - к научной записи: фиксированная запись будет предпочтительной, кроме случаев, когда она шире, чем количество знаков ‘scipen’.\nЕсли опция установлена на маленькое число (например, 0), она будет “включена” всегда. Чтобы “отключить” научную запись в сессии R, установите параметр на очень большое число, например:\n\n# выключение научной записи\noptions(scipen=999)\n\n\n\nОкругление\nВНИМАНИЕ: round() использует “банковское округление”, которое округляет в большую сторону от .5 только, если большее число четное. Используйте round_half_up() из пакета janitor для последовательного округления половин до ближайшего полного числа. См. данное объяснение\n\n# используйте подходящую для вашей работы функцию округления\nround(c(2.5, 3.5))\n\n[1] 2 4\n\njanitor::round_half_up(c(2.5, 3.5))\n\n[1] 3 4\n\n\n\n\nСтатистические функции\nВНИМАНИЕ: Функции ниже по умолчанию будут включать отсутствующие значения в расчеты. Отсутствующие значения приведут к выводу NA, кроме случаев, когда уточнен аргумент na.rm = TRUE. Это можно кратко записать как na.rm = T.\n\n\n\nЗадача\nФункция\n\n\n\n\nсреднее\nmean(x, na.rm=T)\n\n\nмедиана\nmedian(x, na.rm=T)\n\n\nстандартное отклонение\nsd(x, na.rm=T)\n\n\nквантили*\nquantile(x, probs)\n\n\nсумма\nsum(x, na.rm=T)\n\n\nминимальное значение\nmin(x, na.rm=T)\n\n\nмаксимальное значение\nmax(x, na.rm=T)\n\n\nдиапазон числов.значений\nrange(x, na.rm=T)\n\n\nсводные данные**\nsummary(x)\n\n\n\nПримечание:\n\n*quantile(): x - это числовой вектор для рассмотрения, а probs = это числовой вектор с вероятностями от 0 до 1.0, например, c(0.5, 0.8, 0.85)\n**summary(): дает сводную информацию о числовом векторе, включая среднее значение, медиану и частые процентили\n\nВНИМАНИЕ: При указании вектора чисел для одной из указанных выше функций, не забудьте обернуть числа в c() .\n\n# Если вы даете сырые числа функции, оберните их в c()\nmean(1, 6, 12, 10, 5, 0)    # !!! НЕПРАВИЛЬНО !!!  \n\n[1] 1\n\nmean(c(1, 6, 12, 10, 5, 0)) # ПРАВИЛЬНО\n\n[1] 5.666667\n\n\n\n\nДругие полезные функции\n\n\n\n\n\n\n\n\nЗадача\nФункция\nПример\n\n\n\n\nСоздание последовательности\nseq(from, to, by)\nseq(1, 10, 2)\n\n\nповторить x, n раз\nrep(x, ntimes)\nrep(1:3, 2) or rep(c(\"a\", \"b\", \"c\"), 3)\n\n\nразделить числовой вектор\ncut(x, n)\ncut(linelist$age, 5)\n\n\nвзять случайную выборку\nsample(x, size)\nsample(linelist$id, size = 5, replace = TRUE)\n\n\n\n\n\n\n\n%in%\nОчень полезный оператор для сопоставления значений и быстрой оценки того, относится ли значение к вектору или датафрейму.\n\nmy_vector &lt;- c(\"a\", \"b\", \"c\", \"d\")\n\n\n\"a\" %in% my_vector\n\n[1] TRUE\n\n\"h\" %in% my_vector\n\n[1] FALSE\n\n\nЧтобы спросить, если значение не является %in% вектором, поставьте восклицательный знак (!) перед логическим утверждением:\n\n# для отрицания, поставьте перед утверждением восклицательный знак\n!\"a\" %in% my_vector\n\n[1] FALSE\n\n!\"h\" %in% my_vector\n\n[1] TRUE\n\n\n%in% полезен при использовании функции case_when() пакета dplyr. Вы можеет определить заранее вектор, затем ссылаться на него. Например:\n\naffirmative &lt;- c(\"1\", \"Yes\", \"YES\", \"yes\", \"y\", \"Y\", \"oui\", \"Oui\", \"Si\")\n\nlinelist &lt;- linelist %&gt;% \n  mutate(child_hospitaled = case_when(\n    hospitalized %in% affirmative & age &lt; 18 ~ \"Hospitalized Child\",\n    TRUE                                      ~ \"Not\"))\n\nПримечание: Если вы хотите обнаружить частичную последовательность, например, используя функцию str_detect() из stringr, она не примет текстовый вектор, как c(\"1\", \"Yes\", \"yes\", \"y\"). Вместо этого ей нужно задать обычное выражение - сжатую последовательность с черточками ИЛИ, например, “1|Yes|yes|y”. Например, str_detect(hospitalized, \"1|Yes|yes|y\"). См. страницу Текст и последовательности для получения дополнительной информации.\nМы можете конвертировать текстовый вектор в именованное обычное выражение с помощью следующей команды:\n\naffirmative &lt;- c(\"1\", \"Yes\", \"YES\", \"yes\", \"y\", \"Y\", \"oui\", \"Oui\", \"Si\")\naffirmative\n\n[1] \"1\"   \"Yes\" \"YES\" \"yes\" \"y\"   \"Y\"   \"oui\" \"Oui\" \"Si\" \n\n# сжать до \naffirmative_str_search &lt;- paste0(affirmative, collapse = \"|\")  # вариант с базовым R\naffirmative_str_search &lt;- str_c(affirmative, collapse = \"|\")   # вариант с пакетом stringr\n\naffirmative_str_search\n\n[1] \"1|Yes|YES|yes|y|Y|oui|Oui|Si\"",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.ru.html#ошибки-и-предупреждения",
    "href": "new_pages/basics.ru.html#ошибки-и-предупреждения",
    "title": "3  Основы R",
    "section": "7.3 Ошибки и предупреждения",
    "text": "7.3 Ошибки и предупреждения\nЭтот раздел объясняет:\n\nРазницу между ошибками и предупреждениями\n\nОбщие советы по синтаксису для написания кода R\n\nПомощь в коде\n\nЧастые ошибки и предупреждения, а также советы по выявлению и решению проблем можно найти на странице Ошибки и справка.\n\n\nОшибки и предупреждения\nПри выполнении команды на консоли R могут появиться сообщения о предупреждениях или ошибках красным текстом.\n\nПредупреждение означает, что R выполнил вашу команду, но системе пришлось предпринимать дополнительные шаги или она дала неожиданные выходные данные, о котором вам нужно знать.\nОшибка означает, что R не смог завершить выполнение вашей команды.\n\nИщите подсказки:\n\nСообщение об ошибке/предупреждении часто будет включать номер строки, в которой обнаружена проблема.\nЕсли объект “is unknown” (неизвестен) или “not found” (не найден), возможно, вы допустили орфографическую ошибку, забыли вызвать пакет из библиотеки library(), либо забыли повторно выполнить скрипт после внесения изменений.\n\nЕсли ничего не помогает, скопируйте сообщение об ошибке в Google вместе с ключевыми словами - возможно, кто-то уже решил эту проблему!\n\n\n\nОбщие советы по синтаксису\nНесколько пунктов, которые нужно запомнить при написании команд в R, чтобы избежать ошибок и предупреждений:\n\nВсегда закрывайте скобки - совет: посчитайте количество открывающих “(” и закрывающих скобок “)” для каждого блока кода\nИзбегайте пробелов в названиях столбцов и объектов. Вместо этого используйте нижнее подчеркивание ( _ ) или точки ( . )\nОтслеживайте и помните, что нужно отделять аргументы функций запятыми\nR чувствителен к регистру, значит, Variable_A отличается от variable_A\n\n\n\n\nПомощь в коде\nЛюбой скрипт (RMarkdown или другой) будет давать подсказки, если вы допустили ошибку. Например, если вы забыли написать запятую там, где она нужна, либо закрыть скобку, RStudio поставит флажок на этой строке скрипта, чтобы вас предупредить.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Основы R</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.ru.html",
    "href": "new_pages/transition_to_R.ru.html",
    "title": "4  Переход к R",
    "section": "",
    "text": "4.1 Из Excel\nПереход от Excel напрямую к R является очень достижимой целью. Это может показаться сложным, но вы справитесь!\nДействительно, человек с хорошими навыками Excel может делать очень продвинутые вещи сразу в Excel - даже использовать инструменты написания скрипта, такие как VBA. Excel используется по всему миру и является важным для эпидемиологов инструментом. Однако, если вы добавите к нему R, это может существенно улучшить и расширить ваши потоки работы.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Переход к R</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.ru.html#из-excel",
    "href": "new_pages/transition_to_R.ru.html#из-excel",
    "title": "4  Переход к R",
    "section": "",
    "text": "Преимущества\nВы заметите, что использование R дает существенные выгоды в плане экономии времени, обеспечения более последовательного и точного анализа, воспроизводимости, возможности поделиться файлом, а также более быстрого исправления ошибок. Как с любой новой программой, требуется некоторое время для обучения. Выгоды при этом будут значительными, и для вас откроются широкие новые возможности использования R.\nExcel - хорошо известная программа, которой очень легко пользоваться новичкам для простого анализа и визуализации по принципу “указания и щелчка”. Для сравнения, чтобы почувствовать себя комфортно с функциями и интерфейсом R может потребоваться пара недель. Однако за последние годы R стал гораздо более удобным для новичков.\nМногие потоки работы в Excel полагаются на память и на повторение - таким образом, возникает множество моментов, где могут быть допущены ошибки. Более того, в целом, вычистка данных, методология анализа и уравнения скрыты из вида. Для нового коллеги может потребоваться значительное время, чтобы узнать, что делает рабочая книга Excel, и как искать и устранять проблемы. В R все шаги четко записаны в скрипте, их легко просматривать, редактировать, исправлять и применять к другим наборам данных.\nЧтобы начать переход от Excel к R вы должны немного поменять мышление:\n\n\nАккуратные данные\nИспользуйте машиночитаемые “аккуратные” данные вместо “хаотичных, читаемых человеком” данных. Для “аккуратных” данных существует три основных требования, как объясняется в самоучителе по “аккуратным” данным в R:\n\nУ каждой переменной должен быть свой столбец\n\nУ каждого наблюдения должна быть своя строка\n\nУ каждого значения должна быть своя ячейка\n\nДля пользователей Excel - представьте себе, какую роль играют “таблицы” Excel в стандартизации данных и обеспечении предсказуемости формата.\nПримером “аккуратных” данных может быть построчный список случаев, используемый в данном руководстве - каждая переменная содержится в одном столбце, у каждого наблюдения (одного случая) есть своя строка, а каждое значение занимает только одну ячейку. Ниже вы можете увидеть первые 50 строк построчного списка:\n\n\n\n\n\n\nОсновная причина того, почему мы видим неаккуратные данные, состоит в том, что таблицы Excel разработаны таким образом, чтобы их было удобно читать человеку, а не для легкости прочтения машинами/программами.\nЧтобы проиллюстрировать отличия, ниже представлены некоторые выдуманные примеры неаккуратных данных, которые отдают приоритет читаемости для человека, а не читаемости для машины:\n\n\n\n\n\n\n\n\n\nПроблемы: В указанной выше электронной таблице есть объединенные ячейки, которые R сложно воспринимать. Непонятно, какую строку считать “заголовком”. Цветовая кодировка представлена справа, а значения ячеек представлены цветами - R это сложно интерпретировать (и сложно будет людям с цветослепотой!). Более того, в одной ячейке объединены разные элементы информации (несколько партнерских организаций, работающих в одном районе, либо статус “требует уточнения” (“TBC”) в той же ячейке, что “Part112ner D”).\n\n\n\n\n\n\n\n\n\nПроблемы: В приведенной выше электронной таблице существует несколько дополнительных пустых строк и столбцов в наборе данных - это будет вызывать проблемы при вычистке в R. Более того, GPS координаты растянуты на две строки для отдельной медицинской организации. Дополнительно следует указать, что координаты GPS представлены в двух разных форматах!\n“Аккуратные” наборы данных могут быть более сложны для восприятия человеку, но они существенно облегчают вычистку и анализ данных! Аккуратные данные можно хранить в разных форматах, например “длинном” (вертикальном) и “широком” (горизонтальным) (см. страницу Поворот данных), но указанные выше принципы все равно соблюдаются.\n\n\nФункции\nСлово “функция” в R может быть новым, но концепция существует и в Excel в виде формул. Формулы в Excel также требуют строгого синтаксиса (например, размещение точек с запятой и скобок). Вам нужно лишь выучить несколько новых функций и понять, как они совместно работают в R.\n\n\nСкрипты\nВместо того, чтобы кликать на кнопки и протягивать ячейки, вы будете записывать каждый шаг и процедуру в “скрипт”. Пользователям Excel могут быть знакомы “макросы VBA”, которые также используют подход написания скриптов.\nСкрипт R состоит из пошаговых инструкций. Это позволит любому вашему коллеге прочитать скрипт и легко понять, какие шаги вы выполнили. Это также помогает проводить дебаггинг ошибок или неправильных расчетов. См. раздел Основы R по скриптам для изучения примеров.\nНиже представлен пример скрипта R:\n\n\n\n\n\n\n\n\n\n\n\nРесурсы для перехода из Excel в R\nНиже представлены ссылки на самоучители, которые помогут вам перейти к R из Excel:\n\nR и Excel\n\nКурс по RStudio в R для пользователей Excel\n\n\n\nВзаимодействие R и Excel\nВ R есть хорошие инструменты для импорта рабочих книг Excel, работы с данными, экспорта/сохранения Excel файлов, а также для работы с нюансами листов Excel.\nДействительно, некоторая эстетика форматирования Excel может быть потеряна при переносе (например, курсив, боковой текст и т.п.). Если ваша работа требует постоянного переноса файлов между R и Excel при сохранении оригинального форматирования Excel, попробуйте такие пакеты, как openxlsx.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Переход к R</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.ru.html#из-stata",
    "href": "new_pages/transition_to_R.ru.html#из-stata",
    "title": "4  Переход к R",
    "section": "4.2 Из Stata",
    "text": "4.2 Из Stata\n\nПереход в R из Stata\nМногих эпидемиологов изначально учили пользоваться Stata, и им может казаться сложным переход к R. Однако если вы уверенно пользуетесь Stata, переход к R может оказаться проще, чем вы думаете. Хотя и существуют некоторые ключевые различия между Stata и R в том, как можно создавать и изменять данные, а также в том, как реализуются функции анализа - изучив эти ключевые различия, вы сможете адаптировать свои навыки.\nНиже представлены некоторые ключевые особенности Stata и R, которые могут быть вам полезны при изучении данного руководства.\nОбщие комментарии\n\n\n\nSTATA\nR\n\n\n\n\nВы можете просматривать и изменять только один набор данных за раз\nВы можете просматривать и работать с несколькими наборами данных одновременно, поэтому вам часто нужно будет уточнять набор данных в коде\n\n\nДоступно онлайн сообщество в https://www.statalist.org/\nДоступно онлайн сообщество в RStudio, StackOverFlow, а также R-bloggers\n\n\nОпция функционала “указать и щелкнуть”\nМинимальный функционал “указать и щелкнуть”\n\n\nСправка по коммандам доступна с помощью help [command]\nСправка доступна с помощью [function]? или поиска в панели Help (справка)\n\n\nКомментирование кода с помощью * или /// или /* TEXT */\nКомментирование кода с помощью #\n\n\nПочти все команды встроены в Stata. Новые/написанные пользователем функции могут быть установлены как ado файлы, используя ssc install [пакет]\nR устанавливается с базовыми функциями, но, как правило, для его использования требуется установка других пакетов из CRAN (см. страницу Основы R)\n\n\nАнализ, как правило, записывается как файлы do\nАнализ записывается в виде скрипта R в панели RStudio source (источник). Альтернативой являются скрипты R markdown.\n\n\n\nРабочая директория\n\n\n\nSTATA\nR\n\n\n\n\nРабочие директории требуют абсолютного пути к файлу (например, “C:/usename/documents/projects/data/”)\nРабочие директории могут иметь абсолютный или относительный путь к корневой папке проекта, используя пакет here (см. Импорт и экспорт)\n\n\nПросмотр текущей директории с помощью pwd\nИспользуется getwd() или here() (при использовании пакета here), с пустыми скобками\n\n\nРабочая директория задается с помощью cd “место расположения папки”\nИспользуется setwd(“место расположения папки”), или set_here(\"место расположения папки) (при использовании пакета here)\n\n\n\nИмпорт и просмотр данных\n\n\n\nSTATA\nR\n\n\n\n\nСпецифичные команды по типам файлов\nИспользуется import() из пакета rio почти для всех типов файлов. Специфичные функции существуют в качестве альтернатив (см. Импорт и экспорт)\n\n\nЧтение csv файлов осуществляется через import delimited “filename.csv”\nИспользуйте import(\"filename.csv\")\n\n\nЧтение xslx файлов осуществляется через import excel “filename.xlsx”\nИспользуйте import(\"filename.xlsx\")\n\n\nПросмотр ваших данных в новом окне с помощью команды browse\nПросмотр набора данных на панели source (источник) RStudio с помощью View(dataset). Вам нужно уточнить название вашего набора данных для функции в R, поскольку в нем может содержаться несколько наборов данных одновременно. Обратите внимание на заглавную “V” в этой функции\n\n\nПолучение краткого обзора вашего набора данных с помощью summarize, которая даст названия переменных и основную информацию\nПолучение краткого обзора вашего набора данных с помощью summary(dataset)\n\n\n\nПростые манипуляции с данными\n\n\n\nSTATA\nR\n\n\n\n\nСтолбцы набора данных часто называют “переменные”\nЧаще называют “столбцы” или иногда “векторы” или “переменные”\n\n\nНет необходимости указывать название набора данных\nВ каждой из указанных ниже команд вам необходимо указывать набор данных - см. примеры на странице Вычистка данных и ключевые функции\n\n\nНовые переменные создаются с помощью команды generate varname =\nНовые переменные создаются с помощью функции mutate(varname = ). См. детальную информацию по всем указанным ниже функциям dplyr на странице Вычистка данных и ключевые функции.\n\n\nПеременные переименовываются с помощью rename old_name new_name\nСтолбцы можно переименовать с помощью функции rename(new_name = old_name)\n\n\nПеременные выбрасываются с помощью drop varname\nСтолбцы можно удалить, используя функцию select() с названием столбца в скобках после знака минус\n\n\nПеременные факторы можно подписать, используя серию команд, таких как label define\nПеременные подписываются путем конвертации столбца в класс фактор и уточнения уровней. См. страницу Факторы. Названия столбцов, как правило, не подписываются так, как в Stata.\n\n\n\nОписательный анализ\n\n\n\nSTATA\nR\n\n\n\n\nПодсчет количества по переменной с помощью tab varname\nУкажите название набора данных и столбца в table(), например, table(dataset$colname). Либо используйте count(varname) из пакета dplyr, как указано в разделе Группирование данных\n\n\nПерекрестная табуляция по двум переменным в таблице 2x2 проводится с помощью tab varname1 varname2\nИспользуйте table(dataset$varname1, dataset$varname2 или count(varname1, varname2)\n\n\n\nХотя в этом списке представлен обзор того, как основные команды из Stata выглядят в R, он не является исчерпывающим. Существует множество других замечательных ресурсов для пользователей Stata по переходу к использованию R, которые могут быть вам интересны:\n\nhttps://dss.princeton.edu/training/RStata.pdf\n\nhttps://clanfear.github.io/Stata_R_Equivalency/docs/r_stata_commands.html\n\nhttp://r4stats.com/books/r4stata/",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Переход к R</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.ru.html#из-sas",
    "href": "new_pages/transition_to_R.ru.html#из-sas",
    "title": "4  Переход к R",
    "section": "4.3 Из SAS",
    "text": "4.3 Из SAS\n\nПереход от SAS к R\nSAS часто используется органами общественного здравоохранения и академическими исследователями. Хотя переход к новому языку редко является простым процессом, понимание ключевых различий между SAS и R поможет вам начать разбираться в новом языке, использовав привычный для вас язык. Ниже представлены ключевые моменты по управлению данными и описательному анализу при переходе от SAS к R.\nОбщие комментарии\n\n\n\nSAS\nR\n\n\n\n\nДоступно онлайн сообщество через Клиентскую поддержку SAS\nДоступно онлайн сообщество через RStudio, StackOverFlow, и R-bloggers\n\n\nСправка по командам доступна через help [command]\nСправка доступна через [function]? или через поиск на панели Help (Справка)\n\n\nКомментирование кода с помощью * TEXT ; или /* TEXT */\nКомментирование кода с помощью #\n\n\nПочти все команды встроены. Пользователи могут писать новые функции с помощью SAS macro, SAS/IML, SAS Component Language (SCL), и в последнее время через процедуры Proc Fcmp и Proc Proto\nR устанавливается с базовыми функциями, но при использовании, как правило, требуется установка других пакетов из CRAN (см. страницу Основы R)\n\n\nАнализ, как правило, проводится с помощью написания программы SAS в окне Editor.\nАнализ записывается в виде скрипта R на панели source (источник) в RStudio. Альтернативой являются скрипты R markdown.\n\n\n\nРабочая директория\n\n\n\nSAS\nR\n\n\n\n\nРабочие директории могут иметь абсолютный или относительный путь к корневой папке проекта, используя %let rootdir=/root path; %include “&rootdir/subfoldername/filename”\nРабочие директории могут иметь абсолютный или относительный путь к корневой папке проекта, используя пакет here (см. Импорт и экспорт)\n\n\nПросмотр текущей рабочей директории с помощью %put %sysfunc(getoption(work));\nИспользуется getwd() или here() (при использовании пакета here), с пустыми скобками\n\n\nРабочая директория задается с помощью libname “folder location”\nИспользуется setwd(“место расположения папки”), или set_here(\"место расположения папки) (при использовании пакета here)\n\n\n\nИмпорт и просмотр данных\n\n\n\nSAS\nR\n\n\n\n\nИспользуйте процедуру Proc Import или утверждение Data Step Infile.\nИспользуйте import() из пакета rio почти для всех типов файлов. Существуют специфические функции в качестве альтернатив (см. Импорт и экспорт)\n\n\nЧтение csv файлов осуществляется с помощью Proc Import datafile=”filename.csv” out=work.filename dbms=CSV; run; ИЛИ с помощью Утверждения Data Step Infile\nUse import(\"filename.csv\")\n\n\nЧтение xslx файлов осуществляется с помощью Proc Import datafile=”filename.xlsx” out=work.filename dbms=xlsx; run; ИЛИ с помощью Утверждения Data Step Infile\nUse import(“filename.xlsx”)\n\n\nПросмотр данных в новом окне с помощью открытия окна Explorer и выбора нужной библиотеки и набора данных\nПросмотр набора данных на панели source (источник) RStudio с помощью View(dataset). Вам нужно уточнить название вашего набора данных для функции в R, поскольку в нем может содержаться несколько наборов данных одновременно. Обратите внимание на заглавную “V” в этой функции\n\n\n\nПростые манипуляции с данными\n\n\n\nSAS\nR\n\n\n\n\nСтолбцы набора данных часто называют “переменными”\nБолее часто называют “столбцы”, иногда “векторы” или “переменные”\n\n\nНе требуются особые процедуры для создания переменной. Новые переменные создаются просто путем впечатывания названия новой переменной, после которой ставится знак равно, а затем выражение для определения значения\nНовые переменные создаются с помощью функции mutate(varname = ). См. детальную информацию по всем указанным ниже функциям dplyr на странице Вычистка данных и ключевые функции.\n\n\nПеременные переименовываются с помощью rename *old_name=new_name*\nСтолбцы можно переименовасть с помощью функции rename(new_name = old_name)\n\n\nПеременные сохраняются с помощью **keep**=varname\nПеременные можно выбрать с помощью функции select() с названием столбца в скобках\n\n\nПеременные можно удалить с помощью **drop**=varname\nСтолбцы можно удалить с помощью функции select() с названием столбца в скобках после знака минус\n\n\nПеременные факторы можно подписать на этапе данных, используя утверждение Label\nПодпись переменных можно осуществить через конвертацию столбца в класс факторов, уточнив уровни. См. страницу Факторы. Названия столбцов, как правило, не подписываются.\n\n\nЗаписи можно выбрать с помощью утверждений Where или If на этапе данных. Несколько условий выбора отделяются с помощью команды “and”.\nЗаписи выбирают с помощью функции filter(), а несколько условий выбора отделяются оператором AND (&) или запятой.\n\n\nНаборы данных объединяются с помощью утверждения Merge на этапе данных. Наборы данных, которые нужно объединить, должны быть сначала отсортированы с помощью процедуры Proc Sort.\nПакет dplyr предлагает новые функции для объединения наборов данных. См. детали на странице Объединение данных.\n\n\n\nОписательный анализ\n\n\n\nSAS\nR\n\n\n\n\nОбщий обзор вашего набора данных можно получить с помощью процедуры Proc Summary, которая дает названия переменных и описательную статистику\nПолучить общий обзор вашего набора данных можно с помощью summary(dataset) или skim(dataset) из пакета skimr\n\n\nПодсчитать количество по переменной можно с помощью proc freq data=Dataset; Tables varname; Run;\nСм. страницу Описательные таблицы. Опции, среди прочего, включают table() из базового R, и tabyl() из пакета janitor. Обратите внимание, что вам нужно будет уточнить название набора данных и столбца, так как R содержит несколько наборов данных.\n\n\nПерекрестная табуляция двух переменных в таблице 2x2 выполняется с помощью proc freq data=Dataset; Tables rowvar*colvar; Run;\nОпять же, вы можете использовать table(), tabyl() или другие варианты, как описано на странице Описательные таблицы.\n\n\n\nНекоторые полезные ресурсы:\nR для пользователей SAS и SPSS (2011)\nSAS и R, Второе издание (2014)",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Переход к R</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.ru.html#совместимость-данных",
    "href": "new_pages/transition_to_R.ru.html#совместимость-данных",
    "title": "4  Переход к R",
    "section": "4.4 Совместимость данных",
    "text": "4.4 Совместимость данных\n\nСм. страницу [Импорт и экспорт] для получения детальной информации о том, как пакет R rio может импортировать и экспортировать такие файлы, как файлы STATA .dta, файлы SAS .xpt и .sas7bdat, файлы SPSS .por и .sav, а также многие другие.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Переход к R</span>"
    ]
  },
  {
    "objectID": "new_pages/packages_suggested.ru.html",
    "href": "new_pages/packages_suggested.ru.html",
    "title": "5  Рекомендованные пакеты",
    "section": "",
    "text": "5.1 Пакеты из CRAN\n##########################################\n# Список полезных пакетов R для эпидемиологии #\n##########################################\n\n# Данный скрипт использует функцию p_load() из пакета R pacman, \n# которая устанавливает пакет, если он отсутствует, и загружает его, если он уже установлен\n\n\n# Проверяет, что пакет \"pacman\" установлен\nif (!require(\"pacman\")) install.packages(\"pacman\")\n\n\n# Пакеты доступные на CRAN\n##############################\npacman::p_load(\n     \n     # изучение R\n     ############\n     learnr,   # интерактивные самоучители на панели RStudio Tutorial (обучение)\n     swirl,    # интерактивные самоучители в консоли R\n        \n     # управление проектом и файлами\n     #############################\n     here,     # пути к файлам, относительные для корневой папки проекта R\n     rio,      # импорт/экспорт многих типов данных\n     openxlsx, # импорт/экспорт рабочих книг Excel с несколькими листами \n     \n     # установка и управление пакетами\n     ################################\n     pacman,   # установка/загрузка пакетов\n     renv,     # управление версиями пакетов при совместной работе в группах\n     remotes,  # установка с github\n     \n     # Общие вопросы управления данными\n     #########################\n     tidyverse,    # включает множество пакетов для работы и презентации аккуратных данных\n          #dplyr,      # управление данными\n          #tidyr,      # управление данными\n          #ggplot2,    # визуализация данных\n          #stringr,    # работа с последовательностями и текстом\n          #forcats,    # работа с факторами \n          #lubridate,  # работа с датами\n          #purrr       # повторения и работа со списками\n     linelist,     # вычистка построчных списков\n     naniar,       # оценка отсутствующих данных\n     \n     # статистика  \n     ############\n     janitor,      # таблицы и вычистка данных\n     gtsummary,    # создание описательных и статистических таблиц\n     rstatix,      # быстрое проведение статистических тестов и кратких сводок\n     broom,        # вычистка результатов регрессий\n     lmtest,       # тесты на отношение правдоподобия\n     easystats,\n          # parameters, # альтернатива для вычистки результатов регрессий\n          # see,        # альтернатива для визуализации форест-диаграмм \n     \n     # моделирование эпидемий\n     ###################\n     epicontacts,  # анализ сетей распространения инфекции\n     EpiNow2,      # оценка Rt\n     EpiEstim,     # оценка Rt\n     projections,  # прогнозирование заболеваемости\n     incidence2,   # создание эпидкривых и работа с данными по заболеваемости\n     i2extras,     # дополнительные функции из пакета incidence2\n     epitrix,      # полезные эпидемиологические функции\n     distcrete,    # дискретные распределения времени задержки\n     \n     \n     # графики - общие моменты\n     #################\n     #ggplot2,         # включен в tidyverse\n     cowplot,          # объединение графиков  \n     # patchwork,      # объединение графиков (альтернатива)     \n     RColorBrewer,     # цветовые шкалы\n     ggnewscale,       # для добавления дополнительных слоев цветовых схем\n\n     \n     # графики - специфические типы\n     ########################\n     DiagrammeR,       # диаграммы с использованием языка DOT\n     incidence2,       # эпидемические кривые\n     gghighlight,      # выделяет подмножество\n     ggrepel,          # смарт подписи\n     plotly,           # интерактивные графики\n     gganimate,        # анимированные графики \n\n     \n     # ГИС\n     ######\n     sf,               # для управления пространственными данными с использованием формата простого пространственного объекта\n     tmap,             # для создания простых кар, работает как с интерактивными, так и со статичными картами\n     OpenStreetMap,    # для добавления базовой карты OSM на карту ggplot\n     spdep,            # пространственная статистика \n     \n     # рутинные отчеты\n     #################\n     rmarkdown,        # создание файлов PDF, Word, Powerpoint и HTML\n     reportfactory,    # авто-организация выходных данных R Markdown\n     officer,          # презентации powerpoint\n     \n     # информационные панели\n     ############\n     flexdashboard,    # конвертация скрипта R Markdown в информационную панель\n     shiny,            # интерактивные веб-приложения\n     \n     # таблицы для презентации\n     #########################\n     knitr,            # генерирование отчета R Markdown и html таблиц\n     flextable,        # таблицы HTML\n     #DT,              # таблицы HTML (альтернатива)\n     #gt,              # таблицы HTML (альтернатива)\n     #huxtable,        # таблицы HTML (альтернатива)\n     \n     # филогенетика\n     ###############\n     ggtree,           # визуализация и аннотация деревьев\n     ape,              # анализ филогенетики и эволюции\n     treeio            # визуализация филогенетических файлов\n \n)",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Рекомендованные пакеты</span>"
    ]
  },
  {
    "objectID": "new_pages/packages_suggested.ru.html#пакеты-с-github",
    "href": "new_pages/packages_suggested.ru.html#пакеты-с-github",
    "title": "5  Рекомендованные пакеты",
    "section": "5.2 Пакеты с Github",
    "text": "5.2 Пакеты с Github\nНиже представлены команды для установки пакетов напрямую из репозиториев Github.\n\nВерсия разработчиков для пакета epicontacts содержит возможность создания деревьев распространения с временной осью x\n\nПакет epirhandbook содержит все примеры данных для данного руководства и может быть использован для скачивания оффлайн версии руководства.\n\n\n# Пакеты, которые можно скачать с Github (не доступные на CRAN)\n##########################################################\n\n# Версия разработчиков пакета epicontacts (для цепочек передачи с временем на оси x)\npacman::p_install_gh(\"reconhub/epicontacts@timeline\")\n\n# Пакет для данного руководства, который включает все примеры данных  \npacman::p_install_gh(\"appliedepi/epirhandbook\")",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Рекомендованные пакеты</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.ru.html",
    "href": "new_pages/r_projects.ru.html",
    "title": "6  Проекты R",
    "section": "",
    "text": "6.1 Предложения по использованию\nЧастым, эффективным и беспроблемным способом использования R является объединение этих 3 элементов. Один определенный рабочий проект размещается в одном проекте R. Каждый элемент описывается в разделах ниже.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Проекты R</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.ru.html#предложения-по-использованию",
    "href": "new_pages/r_projects.ru.html#предложения-по-использованию",
    "title": "6  Проекты R",
    "section": "",
    "text": "Проект R\n\nсамодостаточная рабочая среда с папками для данных, скриптов, выходных данных и т.п.\n\n\nПакет here для относительных путей к файлу\n\nПути к файлу записываются относительно корневой папки проекта R - см. дополнительную информацию на странице Импорт и экспорт\n\n\nПакет rio для импорта/экспорта\n\nimport() и export() работают с любым типом файла по его расширению (например, .csv, .xlsx, .png)",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Проекты R</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.ru.html#создание-проекта-r",
    "href": "new_pages/r_projects.ru.html#создание-проекта-r",
    "title": "6  Проекты R",
    "section": "6.2 Создание проекта R",
    "text": "6.2 Создание проекта R\nЧтобы создать проект R, выберите “New Project” (новый проект) из меню File (файл).\n\nЕсли вы хотите создать новую папку для проекта, выберите “New directory” (новая директория) и укажите, где вы хотите ее создать.\n\nЕсли вы хотите создать проект внутри существующей папки, кликните “Existing directory” (существующая директория) и укажите папку.\n\nЕсли вы хотите клонировать репозиторий Github, выберите третий вариант “Version Control” (контроль версий) и затем “Git”. См. страницу Контроль версий и совместная работа с помощью Git и Github для получения дополнительной информации.\n\n\n\n\n\n\n\n\n\n\nПроект R, который вы создаете, будет создан в форме папки, содержащей файл .Rproj. Этот файл является ярлыком и, скорее всего, основным способом открытия вашего проекта. Вы можете также открыть проект, выбрав опцию “Open Project” (открыть проект) из меню File (файл). Альтернативно в правой верхней части Studio вы увидите иконку R project (проект) и выпадающее меню доступных проектов R.\nЧтобы выйти из проекта R, либо откройте новый проект, либо закройте проект (File (файл) - Close Project (закрыть проект)).\n\nПереключение между проектами\nЧтобы переключиться между проектами, кликните иконку проекта R и выпадающее меню в верхней правой части RStudio. Вы увидите опции Close Project (закрыть проект), Open Project (открыть проект), а также список недавних проектов.\n\n\n\n\n\n\n\n\n\n\n\nНастройки\nВ целом, рекомендуется запускать RStudio каждый раз с “чистого листа” - то есть, без сохранения рабочего пространства с предыдущей сессии. Это означает, что ваши объекты и результаты не будут сохраняться от сессии к сессии (вы должны будете их воссоздать, выполнив команды из скриптов). Это хорошо, поскольку это заставит вас писать более хорошие скрипты и избегать ошибок в долгосрочной перспективе.\nЧтобы настроить RStudio на работу с “чистого листа” каждый раз при запуске:\n\nВыберите “Project Options” (опции проекта) из меню Tools (инструменты).\n\nВо вкладке “General” (Общие опции), установите RStudio на не восстанавливать .RData в рабочем пространстве при запуске, а также не сохранять рабочее пространство в .RData при выходе.\n\n\n\nОрганизация\nВ проекте часто имеются подпапки. Подумайте над возможностью создания таких папок, как “data” (данные), “scripts” (скрипты), “figures” (рисунки), “presentations” (презентации). Вы можете добавить папки обычным способом, как вы создаете новую папку на вашем компьютере. Альтернативно, см. страницу Взаимодействие директорий, чтобы узнать, как создавать новые папки с помощью команд R.\n\n\nКонтроль версий\nРассмотрите возможность использования системы контроля версий. Это может быть простое решение - использование дат в названиях скриптов (например, “transmission_analysis_2020-10-03.R”) и наличие папки “архива”. Также подумайте об использовании заголовка в виде комментария в начале каждого скрипта с описанием, ярлыками, авторами, а также журналом изменений.\nБолее сложный метод - использовать Github или аналогичную платформу контроля версий. См. страницу Контроль версий и совместная работа с помощью Git и Github.\nХороший совет - поиск по всему проекту или папке, используя инструмент “Find in Files” (найти в файлах) (меню Edit - редактирование). С его помощью можно искать и даже заменять последовательности в нескольких файлах.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Проекты R</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.ru.html#примеры",
    "href": "new_pages/r_projects.ru.html#примеры",
    "title": "6  Проекты R",
    "section": "6.3 Примеры",
    "text": "6.3 Примеры\nНиже представлены некоторые примеры импорта/экспорта/сохранения, используя here() изнутри проекта R. Более подробную информацию об использовании пакета here вы можете найти на странице Импорт и экспорт.\nИмпорт linelist_raw.xlsx из папки “data” в ваш проект R\n\nlinelist &lt;- import(here(\"data\", \"linelist_raw.xlsx\"))\n\nЭкспорт объекта R linelist в виде “my_linelist.rds” в папку “clean” внутри папки “data” в вашем проекте R.\n\nexport(linelist, here(\"data\",\"clean\", \"my_linelist.rds\"))\n\nСохранение наиболее свежего напечатанного графика в виде файла “epicurve_2021-02-15.png” внутри папки “epicurves” в папке “outputs” в вашем проекте R.\n\nggsave(here(\"outputs\", \"epicurves\", \"epicurve_2021-02-15.png\"))",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Проекты R</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.ru.html#ресурсы",
    "href": "new_pages/r_projects.ru.html#ресурсы",
    "title": "6  Проекты R",
    "section": "6.4 Ресурсы",
    "text": "6.4 Ресурсы\nВеб-страница RStudio по использованию проектов R",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Проекты R</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.ru.html",
    "href": "new_pages/importing.ru.html",
    "title": "7  Импорт и экспорт",
    "section": "",
    "text": "7.1 Обзор\nПри импорте “набора данных” в R, вы, как правило, создаете новый датафрейм объект в рабочей среде R и определяете его как импортированный файл (например, Excel, CSV, TSV, RDS), который расположен в директориях папок по определенному пути к файлу/адресу.\nВы можете импортировать/экспортировать многие типы файлов, включая и те, которые созданы другими статистическими программами (SAS, STATA, SPSS). Вы можете также связать их с реляционными базами данных.\nR даже имеет свои собственные форматы данных:",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Импорт и экспорт</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.ru.html#обзор",
    "href": "new_pages/importing.ru.html#обзор",
    "title": "7  Импорт и экспорт",
    "section": "",
    "text": "Файл RDS (.rds) хранит единственный объект R, например, датафрейм. Такие файлы полезны для хранения вычищенных данных, поскольку в них сохраняются классы столбцов R. Боолее подробно читайте в этом разделе.\n\nФайл RData (.Rdata) может использоваться для хранения нескольких объектов, либо даже полного рабочего пространства R. Более подробно читайте в этом разделе.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Импорт и экспорт</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.ru.html#пакет-rio",
    "href": "new_pages/importing.ru.html#пакет-rio",
    "title": "7  Импорт и экспорт",
    "section": "7.2 Пакет rio",
    "text": "7.2 Пакет rio\nМы рекомендуем пакет R: rio. Название “rio” - это сокращение от “R I/O” (ввод/вывод).\nЕго функции import() и export() могут справляться с разными типами файлов (например, .xlsx, .csv, .rds, .tsv). Когда вы указываете путь к файлу для любой из этих двух функций (включая такие расширения файлов, как “.csv”), rio прочитает расширение и будет использовать правильный инструмент для импорта или экспорта файла.\nАльтернативой использованию rio является использование функций из многих других проектов, каждая из которых специфична для какого-то типа файла. Например, read.csv() (базовый R), read.xlsx() (пакет openxlsx), write_csv() (пакет readr) и др. Эти альтернативы может быть сложно запомнить, а использование import() и export() из rio легко.\nФункции rio import() и export() используют подходящий пакет и функцию для определенного файла, основываясь на расширении файла. См. полную таблицу того, какие пакеты/функции rio использует фоново, в конце данной страницы. Этот пакет можно также использовать для импорта файлов STATA, SAS и SPSS, а также десятки других типов файлов.\nИмпорт/экспорт шейп-файлов требует других пакетов, что описано на странице Основы ГИС.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Импорт и экспорт</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.ru.html#here",
    "href": "new_pages/importing.ru.html#here",
    "title": "7  Импорт и экспорт",
    "section": "7.3 Пакет here",
    "text": "7.3 Пакет here\nПакет here и его функция here() позволяет с легкостью указать R, где найти и сохранить ваши файлы - по сути, он строит пути к файлам.\nПри сочетании с проектом R, here позволяет вам описать расположение файлов в вашем проекте R по отношению к корневой директории (папке верхнего уровня) проекта R. Это полезно, когда над проектом R ведется совместная работа, либо к нему нужен доступ нескольким людям/с разных компьютеров. Это позволяет предотвратить осложнения, вызванные уникальными путями к файлам на разных компьютерах (например, \"C:/Users/Laura/Documents...\" благодаря тому, что путь к файлу “начинается” с общего для всех пользователей расположения (с корневой папки проекта R).\nВот как работает here() в рамках проекта R:\n\nКогда пакет here загружается первый раз в проекте R, он размещает небольшой файл, под названием “.here” в корневой папке вашего проекта R в качестве “бенчмарки” или “якоря”\n\nЧтобы сделать ссылку на файл в подпапке проекта R в ваших скриптах, вы будете использовать функцию here(), чтобы построить путь к файлу относительно этого якоря\nЧтобы построить путь к файлу, напишите названия папок после корневой папки в кавычках, разделенными запятыми, а в конце указывается название и расширение файла, как показано ниже\n\nПути к файлу с помощью here() могут быть использованы как для импорта, так и для экспорта\n\nНапример, ниже функции import() задается путь к файлу, который составлен с помощью here().\n\nlinelist &lt;- import(here(\"data\", \"linelists\", \"ebola_linelist.xlsx\"))\n\nКоманда here(\"data\", \"linelists\", \"ebola_linelist.xlsx\") на самом деле предоставляет полный путь к файлу, который уникален для компьютера пользователя:\n\"C:/Users/Laura/Documents/my_R_project/data/linelists/ebola_linelist.xlsx\"\nПрелесть состоит в том, что команду с использованием here() можно успешно запустить на любом компьютере, который получает доступ к проекту R.\nСОВЕТ: Если вы не уверены, где расположена корневая папка “.here”, выполните функцию here() с пустыми скобками.\nБолее подробно о пакете here вы можете почитать по этой ссылке.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Импорт и экспорт</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.ru.html#пути-к-файлам",
    "href": "new_pages/importing.ru.html#пути-к-файлам",
    "title": "7  Импорт и экспорт",
    "section": "7.4 Пути к файлам",
    "text": "7.4 Пути к файлам\nПри импорте или экспорте данных, вы должны указать путь к файлу. Вы можете это сделать одним из трех способов:\n\nРекомендованный: указать “относительный” путь к файлу с помощью пакета here\n\nУказать “полный” / “абсолютный” путь к файлу\n\nВыбор файла вручную\n\n\n“Относительные пути к файлу”\nВ R “относительные” пути к файлу состоят из пути к файлу относительно корневой папки проекта R. Они позволяют обеспечить простые пути к файлу, которые могут работать на разных компьютерах (например, если проект R находится на сетевом диске или отправляется по электронной почте). Как указано выше, относительные пути к файлу строятся с помощью пакета here.\nНиже приведен пример относительного пути к файлу, построенного с помощью here(). Мы предполагаем, что работа идет в проекте R, который содержит подпапку “data”, а внутри нее подпапку “linelists”, в которой есть интересующий нас .xlsx файл.\n\nlinelist &lt;- import(here(\"data\", \"linelists\", \"ebola_linelist.xlsx\"))\n\n\n\n“Абсолютные” пути к файлу\nАбсолютные или “полные” пути к файлам могут быть заданы для таких функций, какimport(), но они являются “хрупкими”, так как они уникальны для конкретного компьютера пользователя и, следовательно, мы их не рекомендуем.\nНиже представлен пример абсолютного пути к файлу, где на компьютере Лауры есть папка “analysis”, подпапка “data”, а внутри нее подпапка “linelists”, в которой находится интересующий нас .xlsx файл.\n\nlinelist &lt;- import(\"C:/Users/Laura/Documents/analysis/data/linelists/ebola_linelist.xlsx\")\n\nНесколько важных моментов по поводу абсолютных путей к файлам:\n\nИзбегайте использования абсолютных путей к файлам, поскольку они сломаются, если запустить скрипт на другом компьютере\nИспользуйте прямые слэши (/), как в примере выше (примечание: это НЕ является опцией по умолчанию для путей к файлам в Windows)\n\nПути к файлам, начинающиеся с двойного слэша (например, “//…”), скорее всего, не будут распознаны R и выдадут ошибку. Попробуйте переместить вашу работу на “именованный” диск или диск, который начинается с буквы (например, “J:” или “C:”). См. страницу Взаимодействие директорий для получения более детальной информации по этому вопросу.\n\nОдин сценарий, при котором абсолютные пути к файлу могут быть для вас подходящим вариантом, включает ту ситуацию, когда вы хотите импортировать файл с общего диска, который имеет одинаковый путь к файлу для всех пользователей.\nСОВЕТ: чтобы быстро конвертировать все \\ в /, выделите интересующий код, используйте Ctrl+f (для Windows), отметьте ячейку опции “In selection” (в выбранном), а затем используйте функционал replace (замены) для их конвертации.\n\n\n\nВыбор файла вручную\nВы можете импортировать данные вручную с помощью одного из этих методов:\n\nПанель RStudio Environment (рабочая среда), кликните “Import Dataset” (импортировать набор данных), затем выберите тип данных\nКликните File (Файл) / Import Dataset (импорт набора данных) / (выберите тип данных)\n\nЧтобы жестко закодировать ручной выбор, используйте команду из базового R file.choose() (оставьте скобки пустыми), чтобы вызвать появление всплывающего окна, которое позволяет пользователю вручную выбрать файл со своего компьютера. Например:\n\n\n# Выбор файла вручную. когда выполняется эта команда, возникнет ВСПЛЫВАЮЩЕЕ окно. \n# Выбранный путь к файлу будет передан в команду import().\n\nmy_data &lt;- import(file.choose())\n\nСОВЕТ: Всплывающее окно может появиться ЗА вашим окном RStudio.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Импорт и экспорт</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.ru.html#импорт-данных",
    "href": "new_pages/importing.ru.html#импорт-данных",
    "title": "7  Импорт и экспорт",
    "section": "7.5 Импорт данных",
    "text": "7.5 Импорт данных\nИспользовать import() для импорта набора данных очень просто. Просто укажите путь к файлу (включая название файла и расширение файла) в кавычках. При использовании here() для построения пути к фаайлу, следуйте указанным выше инструкциям. Ниже приведены несколько примеров:\nИмпорт csv файла, который расположен в “рабочей директории” или в корневой папке проекта R:\n\nlinelist &lt;- import(\"linelist_cleaned.csv\")\n\nИмпортирование первого листа рабочей книги Excel, который расположен в подпапках “data” и “linelists” проекта R (путь к файлу построен с помощью here()):\n\nlinelist &lt;- import(here(\"data\", \"linelists\", \"linelist_cleaned.xlsx\"))\n\nИмпортирование датафрейма (файла .rds) с помощью абсолютного пути к файлу:\n\nlinelist &lt;- import(\"C:/Users/Laura/Documents/tuberculosis/data/linelists/linelist_cleaned.rds\")\n\n\nКонкретные листы Excel\nПо умолчанию, если вы указываете рабочую книгу Excel (.xlsx) функции import(), будет импортирован первый лист рабочей книги. Если вы хотите импортировать конкретный лист, включите название листа в аргумент which =. Например:\n\nmy_data &lt;- import(\"my_excel_file.xlsx\", which = \"Sheetname\")\n\nПри использовании метода here() для того, чтобы указать относительный путь к файлу для import(), вы можете также указать конкретный лист, добавив аргумент which = после закрытия скобок функции here().\n\n# Демонстрация: импорт конкретного листа Excel при использовании относительного пути к файлу с помощью пакета 'here'\nlinelist_raw &lt;- import(here(\"data\", \"linelist.xlsx\"), which = \"Sheet1\")`  \n\nЧтобы экспортировать датафрейм из R на конкретный лист Excel, и чтобы остальная рабочая книга Excel при этом осталась неизменной, вам нужно будет проводить импорт, редактирование и экспорт с помощью альтернативного пакета, предназначенного для этой цели, такого как openxlsx. Более подробную информацию можно получить на странице Взаимодействие директорий или на этой странице github.\nЕсли ваша рабочая книга Excel имеет расширение .xlsb (рабочая книга Excel в двоичном формате), вы, возможно, не сможете ее импортировать с помощью rio. Рассмотрите возможность пересохранения в формате .xlsx, или используйте такой пакет, как readxlsb, который предназначен для этой цели.\n\n\n\nОтсутствующие значения\nВы можете установить значение(я), которое в вашем наборе данных будет считаться отсутствующим. Как объясняется на странице Отсутствующие данные, значение в R для отсутствующих данных обозначается как NA, но тот набор данных, которые вы импортируете, вместо этого использует 99, “Missing”, или просто пустое текстовое поле ““.\nИспользуйте аргумент na = для import() и укажите значение(я) в кавычках (даже если они числовые).Вы можете указать несколько значений, включив их внутрь вектора, используя c(), как указано ниже.\nЗдесь значение “99” в импортируемом наборе данных считается отсутствующим и конвертируется в NA в R.\n\nlinelist &lt;- import(here(\"data\", \"my_linelist.xlsx\"), na = \"99\")\n\nЗдесь любое из значений “Missing”, “” (пустая ячейка), или ” ” (один пробел) в импортируемом наборе данных конвертируются в NA в R.\n\nlinelist &lt;- import(here(\"data\", \"my_linelist.csv\"), na = c(\"Missing\", \"\", \" \"))\n\n\n\n\nПропуск строк\nИногда вы можете захотеть пропустить строку данных при импорте. Вы это можете сделать с помощью аргумента skip =, если используете import() из rio с файлом .xlsx или .csv. Задайте число строк, которое вы хотите пропустить.\n\nlinelist_raw &lt;- import(\"linelist_raw.xlsx\", skip = 1)  # не импортирует строку заголовка\n\nК сожалению skip = принимает только одно числовое значение, а не диапазон (например, “2:10” не работает). Чтобы пропустить импорт конкретных непоследовательно расположенных строк сверху, рассмотрите импорт несколько раз и использование bind_rows() из dplyr. См. пример ниже по пропуску только строки 2.\n\n\nУправление второй строкой заголовка\nИногда у ваших данных может быть вторая строка, например, если это строка “data dictionary”, как указано ниже. Эта ситуация может быть проблематичной, поскольку это может привести к тому, что все столбцы будут импортированы как “текстовый” класс.\nНиже представлен пример такого набора данных (где первая строка data dictionary).\n\n\n\n\n\n\n\nУдаление второй строки заголовка\nЧтобы выбросить вторую строку заголовка, вам, скорее всего, потребуется дважды импортировать данные.\n\nИмпортируйте данные, чтобы сохранить правильные названия столбцов\n\nВновь импортируйте данные, пропустив первые две строки (строку заголовка и вторую строку)\n\nОбъедините правильные названия в сокращенный датафрейм\n\nТочный аргумент для объединения правильных названий столбцов зависят от типа файла с данными (.csv, .tsv, .xlsx, etc.). Это происходит потому, что rio использует разные функции для разных типов файлов (см. таблицу выше).\nДля файлов Excel: (col_names =)\n\n# импорт в первый раз; сохранение названий столбцов\nlinelist_raw_names &lt;- import(\"linelist_raw.xlsx\") %&gt;% names()  # save true column names\n\n# импорт во второй раз; пропускает строку 2, и присваивает названия столбца аргументу col_names =\nlinelist_raw &lt;- import(\"linelist_raw.xlsx\",\n                       skip = 2,\n                       col_names = linelist_raw_names\n                       ) \n\nДля файлов CSV: (col.names =)\n\n# импорт в первый раз; сохранение названий столбцов\nlinelist_raw_names &lt;- import(\"linelist_raw.csv\") %&gt;% names() # сохранение истинных названий столбцов\n\n# отметить аргумент для файлов 'col.names = '\nlinelist_raw &lt;- import(\"linelist_raw.csv\",\n                       skip = 2,\n                       col.names = linelist_raw_names\n                       ) \n\nЗапасной вариант - изменение названий столбцов как отдельная команда\n\n# присваивание/перезапись заголовков, используя базовую функцию 'colnames()'\ncolnames(linelist_raw) &lt;- linelist_raw_names\n\n\n\nСоздание словаря данных\nБонус! Если у вас есть вторая строка, которая является словарем данных, вы можете легко создать правильный словарь данных. Этот совет взят из следующего поста.\n\ndict &lt;- linelist_2headers %&gt;%             # начало: построчный список со словарем в качестве первой строки\n  head(1) %&gt;%                             # сохраните только названия столбцов и первую строку словаря                \n  pivot_longer(cols = everything(),       # поверните все столбцы в вертикальный формат\n               names_to = \"Column\",       # присвойте новые названия столбцов\n               values_to = \"Description\")\n\n\n\n\n\n\n\n\n\nОбъединение двух строк заголовков\nВ некоторых случаях, когда в вашем наборе данных две строки заголовка (или, если говорить более конкретно, 2ая строка данных является подзаголовком), вы можете их “объединить” или добавить значения второй строки заголовка в первую строку заголовка.\nКоманда ниже определит названия столбцов датафрейма, как комбинацию (слияние) первого (истинного) заголовка со значением, которое идет непосредственно под ним (в первой строке).\n\nnames(my_data) &lt;- paste(names(my_data), my_data[1, ], sep = \"_\")\n\n\n\n\n\nЛист Google\nВы можете импортировать из электронных таблиц Google с помощью пакета googlesheet4 и через аутентификацию вашего доступа к электронной таблице.\n\npacman::p_load(\"googlesheets4\")\n\nНиже импортируется и сохраняется демо таблица Google. Эта команда может потребовать аутентификации в вашем Google аккаунте. Следуйте подсказкам и требованиям во всплывающих окнах вашего интернет-браузера, чтобы дать пакетам Tidyverse API разрешения на редактирование, создание и удаление электронных таблиц на Google диске.\nСм. лист ниже, который “доступен к просмотру любому со ссылкой”, вы можете попробовать его импортировать.\n\nGsheets_demo &lt;- read_sheet(\"https://docs.google.com/spreadsheets/d/1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY/edit#gid=0\")\n\nЛист можно также импортировать, используя только ID листа, более короткую часть URL:\n\nGsheets_demo &lt;- read_sheet(\"1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY\")\n\nДругой пакет, googledrive, предлагает полезные функции для написания, редактирования и удаления Google таблиц. Например, используя функции gs4_create() и sheet_write() из этого пакета.\nВот некоторые полезные онлайн самоучители:\nсамоучитель по основам импорта из Google таблиц\nболее детальный самоучитель\nвзаимодействие между googlesheets4 и tidyverse",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Импорт и экспорт</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.ru.html#несколько-файлов---импорт-экспорт-разделение-объединение",
    "href": "new_pages/importing.ru.html#несколько-файлов---импорт-экспорт-разделение-объединение",
    "title": "7  Импорт и экспорт",
    "section": "7.6 Несколько файлов - импорт, экспорт, разделение, объединение",
    "text": "7.6 Несколько файлов - импорт, экспорт, разделение, объединение\nСм. страницу Итерации, циклы и списки, где приведены примеры того, как импортировать и объединять несколько файлов или несколько рабочих книг Excel. На этой странице также приведены примеры того, как разделить датафрейм на части, и экспортировать каждую из частей отдельно, либо в качестве именованных объектов в рабочей книге Excel.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Импорт и экспорт</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.ru.html#import_github",
    "href": "new_pages/importing.ru.html#import_github",
    "title": "7  Импорт и экспорт",
    "section": "7.7 Импорт из Github",
    "text": "7.7 Импорт из Github\nИмпорт данных напрямую из Github в R может быть простым, а может потребовать нескольких шагов - в зависимости от типа файла. Ниже приведен ряд подходов:\n\nCSV файлы\nИмпортироавть .csv файл напрямую из Github в R с помощью команды R может быть очень просто.\n\nЗайдите в репозиторий Github, найдите интересующий вас файл, кликните на него\n\nКликните на кнопку “Raw” (сырые данные) (вы затем увидите “сырые” csv данные, как показано ниже)\n\nСкопируйте URL (веб-адрес)\n\nРазместите URL в кавычках в команде import() в R\n\n\n\n\n\n\n\n\n\n\n\n\nXLSX файлы\nВозможно, у вас не получится просмотреть “сырые” данные для некоторых файлов (например, .xlsx, .rds, .nwk, .shp)\n\nЗайдите в репозиторий Github, найдите интересующий вас файл, кликните на него\n\nКликните на кнопку “Download” (скачать), как показано ниже\n\nСохраните файл на своем компьютере и импортируйте его в R\n\n\n\n\n\n\n\n\n\n\n\n\nШейп-файлы\nШейп-файлы могут иметь много файлов суб-компонентов, каждый с разным расширением файла. У одного файла будет расширение “.shp”, а у других оно может быть “.dbf”, “.prj”, и т.д. Чтобы скачать шейп-файл с Github, вам нужно загрузить каждый файл суб-компонент отдельно и сохранить их все в одну и ту же папку на вашем компьютере. В Github кликните отдельно на каждый файл и скачайте каждый, нажав кнопку “Download” (скачать).\nПосле сохранения на компьютер, вы можете испортировать шейп-файл, как описано на странице Основы ГИС, используя st_read() из пакета sf. Вам нужно только задать путь к файлу и имя файла “.shp” - при условии, что другие связанные файлы находятся в той же папке на вашем компьютере.\nНиже вы можете увидеть. что шейп-файл “sle_adm3” состоит из множества файлов - каждый из которых нужно скачать с Github.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Импорт и экспорт</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.ru.html#ручной-ввод-данных",
    "href": "new_pages/importing.ru.html#ручной-ввод-данных",
    "title": "7  Импорт и экспорт",
    "section": "7.8 Ручной ввод данных",
    "text": "7.8 Ручной ввод данных\n\nВвод по строкам\nИспользуйте функцию tribble из пакета tibble из tidyverse (онлайн справка по tibble).\nОбратите внимание, что заголовки столбцов начинаются с тильды (~). Также обратите внимание, что в каждом столбце должен содержаться только один класс данных (текстовых, числовых и т.п.). Вы можете использовать табуляцию, пробелы и новые строки, чтобы сделать ввод данных более интуитивно понятным и читаемым. Пробелы не важны между значениями, но каждую строку таблицы нужно представлять новой строкой кода. Например:\n\n# создание нового набора данных вручную по строкам\nmanual_entry_rows &lt;- tibble::tribble(\n  ~colA, ~colB,\n  \"a\",   1,\n  \"b\",   2,\n  \"c\",   3\n  )\n\nТеперь мы отобразим новый набор данных:\n\n\n\n\n\n\n\n\nВвод по столбцам\nПоскольку датафрейм состоит из векторов (вертикальных столбцов), базовый подход к ручному созданию датафрейма в R ожидает, что вы определите каждый столбец и объедините их. Это может показаться интуитивно противоречивым в эпидемиологии, поскольку мы мыслим строками (как показано выше).\n\n# определите каждый вектор (вертикальный столбец) отдельно, дав каждому собственное имя\nPatientID &lt;- c(235, 452, 778, 111)\nTreatment &lt;- c(\"Да\", \"No\", \"Да\", \"Да\")\nDeath     &lt;- c(1, 0, 1, 0)\n\nВНИМАНИЕ: Все векторы должны быть одной длины (то же самое количество значений).\nЗатем векторы можно связать вместе, используя функцию data.frame():\n\n# объедините столбцы в датафрейм, дав ссылку на имена векторов\nmanual_entry_cols &lt;- data.frame(PatientID, Treatment, Death)\n\nТеперь отобразим новый набор данных:\n\n\n\n\n\n\n\n\nВставка из буфера обмена\nЕсли вы копируете данные откуда-то, и они есть у вас в буфере обмена, вы можете попробовать один из указанных ниже способов:\nВ пакете clipr вы можете использовать read_clip_tbl() для импорта в виде датафрейма, либо просто read_clip() для импорта в виде текстового вектора. В обоих случаях оставьте скобки пустыми.\n\nlinelist &lt;- clipr::read_clip_tbl()  # импортирует текущую информацию из буфера обмена в виде датафрейма\nlinelist &lt;- clipr::read_clip()      # импортирует в виде текстового вектора\n\nВы можете также легко произвести импорт из буфера обмена вашей системы с помощью clipr. См. раздел ниже по Экспорту.\nАльтернативно вы можете использовать функцию read.table() из базового R с file = \"clipboard\") для импорта в виде датафрейма:\n\ndf_from_clipboard &lt;- read.table(\n  file = \"clipboard\",  # уточните, что это \"clipboard\" (буфер обмена)\n  sep = \"t\",           # разделителем может быть табуляция, запятые и т.п.\n  header=TRUE)         # если есть строка заголовка",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Импорт и экспорт</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.ru.html#импорт-самого-последнего-файла",
    "href": "new_pages/importing.ru.html#импорт-самого-последнего-файла",
    "title": "7  Импорт и экспорт",
    "section": "7.9 Импорт самого последнего файла",
    "text": "7.9 Импорт самого последнего файла\nЧасто вы можете получать обновления для своих наборов данных. В таком случае вам нужно написать код, который будет импортировать самый последний файл. Ниже представлены два подхода к тому, как это сделать:\n\nВыбор файла по дате в названии файла\n\nВыбор файла на основе мета-данных файла (последнее изменение)\n\n\nДаты в именах файлов\nЭтот подход основан на трех предположениях:\n\nВы доверяете датам в именах файлов\n\nДаты являются числовыми и представлены, как правило, в одном формате (например, год, потом месяц, потом день)\n\nВ имени файла нет иных цифр\n\nМы объясним каждый шаг, затем покажем их вам в объединенном виде в конце.\nСначала используем dir() из базового R для извлечения только имен файлов для каждого файла в интересующей нас папке. См. страницу Взаимодействие директорий для получения более детальной информации о dir(). В данном примере нас интересует папка “linelists” внутри папки “example” внутри папки “data” в проекте R.\n\nlinelist_filenames &lt;- dir(here(\"data\", \"example\", \"linelists\")) # получаем имена файлов из папки\nlinelist_filenames                                              # печать\n\n[1] \"20201007linelist.csv\"          \"case_linelist_2020-10-02.csv\" \n[3] \"case_linelist_2020-10-03.csv\"  \"case_linelist_2020-10-04.csv\" \n[5] \"case_linelist_2020-10-05.csv\"  \"case_linelist_2020-10-08.xlsx\"\n[7] \"case_linelist20201006.csv\"    \n\n\nКак только у вас будет вектор имен, вы можете извлечь из него даты, применив str_extract() из stringr, используя обычное выражение. Эта функция извлечет любые числа в имени файла (включая другие знаки посередине, такие как дефисы или слэши). Более детально о stringr вы можете прочитать на странице Последовательности и текст.\n\nlinelist_dates_raw &lt;- stringr::str_extract(linelist_filenames, \"[0-9].*[0-9]\") # извлекает числа и любые знаки между ними\nlinelist_dates_raw  # печать\n\n[1] \"20201007\"   \"2020-10-02\" \"2020-10-03\" \"2020-10-04\" \"2020-10-05\"\n[6] \"2020-10-08\" \"20201006\"  \n\n\nПредполагая, что даты, как правило, пишутся в одинаковом формате (например, год,потом месяц, потом день) и годы представлены 4 цифрами, вы можете использовать функции гибкой конвертации из lubridate (ymd(), dmy(), или mdy()), чтобы конвертировать их в даты. Для этих функций не имеют значения дефисы, пробелы или слэши, важен только порядок цифр. Более детально об этом можно почитать на странице Работа с датами.\n\nlinelist_dates_clean &lt;- lubridate::ymd(linelist_dates_raw)\nlinelist_dates_clean\n\n[1] \"2020-10-07\" \"2020-10-02\" \"2020-10-03\" \"2020-10-04\" \"2020-10-05\"\n[6] \"2020-10-08\" \"2020-10-06\"\n\n\nЗатем можно использовать функцию базового R which.max(), которая выдаст индексную позицию (например, 1ую, 2ую, 3ю, …) максимального значения даты. Последним будет правильно выбран 6-й файл - “case_linelist_2020-10-08.xlsx”.\n\nindex_latest_file &lt;- which.max(linelist_dates_clean)\nindex_latest_file\n\n[1] 6\n\n\nЕсли сжать все эти команды, полноценный код будет выглядеть так, как код ниже. Обратите внимание, что . в последней строке является заполнителем для объекта, который будет привязан в канал в этом месте канала. В этот момент значением является только цифра 6. Ее размещаем в двойные квадратные скобки, чтобы извлечь 6-й элемент вектора имены файла, полученного из dir().\n\n# загрузка пакетов\npacman::p_load(\n  tidyverse,         # управление данными\n  stringr,           # работа с последовательностями/текстом\n  lubridate,         # работа с датами\n  rio,               # импорт / экспорт\n  here,              # относительный путь к файлу\n  fs)                # взаимодействие директорий\n\n# извлечение имени самого последнего по дате файла\nlatest_file &lt;- dir(here(\"data\", \"example\", \"linelists\")) %&gt;%  # имена файлов из подпапки \"linelists\"          \n  str_extract(\"[0-9].*[0-9]\") %&gt;%                  # извлечение дат (чисел)\n  ymd() %&gt;%                                        # конвертация цифр в даты (предполагая формат год-месяц-день)\n  which.max() %&gt;%                                  # получение индекса максимальной даты (самый последний по времени файл)\n  dir(here(\"data\", \"example\", \"linelists\"))[[.]]              # возврат имени файла самого последнего построчного списка\n\nlatest_file  # печать имени самого последнего файла\n\n[1] \"case_linelist_2020-10-08.xlsx\"\n\n\nТеперь вы можете использовать это имя файла для завершения относительного пути к файлу с помощью here():\n\nhere(\"data\", \"example\", \"linelists\", latest_file) \n\nИ теперь вы сможете импортировать самый последний по времени файл:\n\n# import\nimport(here(\"data\", \"example\", \"linelists\", latest_file)) # import \n\n\n\nИспользование информации о файле\nЕсли в имени ваших файлов не указана дата (или если вы не доверяете указанным датам), вы можете попробовать извлечь дату последнего изменения из метаданных файлов. Используйте функции из пакета fs для изучения информации из метаданных для каждого файла, которая включает время последнего изменения и путь к файлу.\nНиже мы указываем для функции dir_info() из пакета fs нужную нам папку. В данном случае нас интересует папка в проекте R, папка “data”, подпапка “example”, и подпапка в ней “linelists”. Результатом является датафрейм с одной строчкой на кадлый файл и со столбцами modification_time (время изменения), path (путь) и т.п. Вы можете увидеть визуальный пример на странице Взаимодействие директорий.\nМы можем отсортировать этот датафрейм файлов по столбцу modification_time, затем сохранить только верхнюю/последнюю строку (файл) с помощью функции head() из базового R. Затем мы можем извлечь путь к файлу этого самого последнего файла с помощью функции pull() из пакета dplyr из столбца path. Наконец мы можем вставить этот файл в import(). Импортированный файл сохраняется как latest_file.\n\nlatest_file &lt;- dir_info(here(\"data\", \"example\", \"linelists\")) %&gt;%  # собирает файл по всем файлам в директории\n  arrange(desc(modification_time)) %&gt;%      # сортировка по времени изменения\n  head(1) %&gt;%                               # сохраняет тролько верхний (самый последний) файл\n  pull(path) %&gt;%                            # извлекает только путь к файлу\n  import()                                  # импорт файла",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Импорт и экспорт</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.ru.html#import_api",
    "href": "new_pages/importing.ru.html#import_api",
    "title": "7  Импорт и экспорт",
    "section": "7.10 API",
    "text": "7.10 API\nАвтоматизированный программный интерфейс (API) может быть использован для прямого запроса данных с веб-сайта. API - набор правил, которые позволяют одному программному приложению взаимодействовать с другим. Клиент (вы) направляет “запрос” и получает “ответ”, в котором есть какое-то содержимое. Пакеты R httr и jsonlite могут организовать этот процесс.\nКаждый сайт с возможностью API будет иметь собственную документацию и специфику, с которыми нужно быть знакомым. Некоторые сайты являются доступными для всех. Другие, такие как платформы с логинами пользователей и их идентифицирующей информацией требуют аутентификации для получения доступа к их данным.\nКонечно же, для импорта данных через API требуется интернет-соединение. Мы приведем краткие примеры использования API для импорта данных и дадим вам ссылку на дополнительные ресурсы.\nПримечание: помните, что данные могут быть размещены* на веб-сайте без API, что может упростить их извлечение. Например, размещенный CSV файл может быть доступен просто через указание URL сайта в функции import(), как было описано в разделе Импорт из Github.*\n\nЗапрос HTTP\nОбмен API наиболее часто производится через запрос HTTP. HTTP - гипертекстовый транспортный протокол, и он является базовым форматом запроса/ответа между клиентом и сервером. Точные входные и выходные данные могут варьироваться в зависимости от типа API, но процесс всегда одинаковый - “Запрос” (часто HTTP запрос) от пользователя, часто содержащий вопрос, после которого идет “Ответ”, содержащий информацию о статусе запроса и возможно запрошенное содержание.\nВот несколько компонентов HTTP запроса:\n\nURL конечной точки API\n\n“Метод” (или “Глагол”)\n\nЗаголовки\n\nОсновной текст\n\n“Метод” запроса HTTP - действие, которое вы должны предпринять. Два наиболее частых метода HTTP - это GET и POST, но есть и другие, которые могут включать PUT, DELETE, PATCH, и так далее. При импорте данных в R вы скорее всего будете использовать GET.\nПосле вашего запроса компьютер получит “ответ” в формате, похожем на тот, который вы отправили, включая URL, статус HTTP (вам нужен Status 200!), тип файла, размер, а также желаемое содержимое. Затем вам нужно будет проанализировать этот ответ и превратить его в датафрейм, с которым можно работать в среде R.\n\n\nПакеты\nПакет httr хорошо работает с HTTP запросами в R. Он не требует больших предварительных знаний веб-API, его могут использовать люди, не очень знакомые с терминологией программного обеспечения. Кроме того, если ответ HTTP является .json, вы можете использовать jsonlite для анализа ответа.\n\n# загрузка пакетов\npacman::p_load(httr, jsonlite, tidyverse)\n\n\n\nПублично-доступные данные\nНиже представлен пример запроса HTTP, взятый из самоучителя the Trafford Data Lab. На этом сайте есть несколько других ресурсов для изучения, а также упражнения по API.\nСценарий: мы хотим импортировать список фаст-фуд ресторанов города Траффорд, Великобритания. Доступ к данным можно получить из API из Агентства по стандартам продуктов питания, которое предоставляет данные по рейтингу продовольственной гигиены по Великобритании.\nВот параметры нашего запроса:\n\nHTTP глагол: GET\n\nAPI URL конечной точки: http://api.ratings.food.gov.uk/Establishments\n\nВыбранные параметры: name, address, longitude, latitude, businessTypeId, ratingKey, localAuthorityId\n\nHeaders: “x-api-version”, 2\n\nФормат(ы) данных: JSON, XML\n\nДокументация: http://api.ratings.food.gov.uk/help\n\nКод R будет выглядеть следующим образом:\n\n# подготовка запроса\npath &lt;- \"http://api.ratings.food.gov.uk/Establishments\"\nrequest &lt;- GET(url = path,\n             query = list(\n               localAuthorityId = 188,\n               BusinessTypeId = 7844,\n               pageNumber = 1,\n               pageSize = 5000),\n             add_headers(\"x-api-version\" = \"2\"))\n\n# проверка ошибок сервера (\"200\" это хорошо!)\nrequest$status_code\n\n# подача запроса, анализ ответа и конвертация в датафрейм\nresponse &lt;- content(request, as = \"text\", encoding = \"UTF-8\") %&gt;%\n  fromJSON(flatten = TRUE) %&gt;%\n  pluck(\"establishments\") %&gt;%\n  as_tibble()\n\nВы теперь можете вычистить и использовать датафрейм ответа response, который содержит по одной строке на каждый фаст-фуд ресторан.\n\n\nТребуемая аутентификация\nНекоторые API требуют аутентификации - чтобы вы указали, кто вы, чтобы получили доступ к ограниченным данным. Чтобы импортировать эти данные, вам может быть необходимо сначала использовать метод POST, чтобы предоставить имя пользователя, пароль или код. Это вам выдаст токен доступа, который может быть использован для последующих запросов методом GET для извлечения нужных данных.\nНиже представлен пример запроса данных из Go.Data, который является инструментом расследования вспышек. Go.Data использует API для всех взаимодействий между веб фронт-энд и приложениями смартфона, используемыми для сбора данных. Go.Data используется по всему миру. Поскольку данные о вспышках являются чувствительными, и вам должен быть открыт доступ только к данным по вашей вспышке, требуется аутентификация.\nНиже представлен пример кода R с использованием httr и jsonlite для связи с Go.Data API для импорта данных по отслеживанию контактов в вашей вспышке.\n\n# установка идентификационных данных для авторизации\nurl &lt;- \"https://godatasampleURL.int/\"           # правильный адрес экземпляра Go.Data\nusername &lt;- \"username\"                          # правильное имя пользователя Go.Data \npassword &lt;- \"password\"                          # правильный пароль Go.Data \noutbreak_id &lt;- \"xxxxxx-xxxx-xxxx-xxxx-xxxxxxx\"  # правильное ID вспышки в Go.Data\n\n# получение токена на доступ\nurl_request &lt;- paste0(url,\"api/oauth/token?access_token=123\") # определение базового запроса URL\n\n# погдготовка запроса\nresponse &lt;- POST(\n  url = url_request,  \n  body = list(\n    username = username,    # используйте сохраненное выше имя пользователя/пароль для авторизации                               \n    password = password),                                       \n    encode = \"json\")\n\n# исполнение запроса и анализ ответа\ncontent &lt;-\n  content(response, as = \"text\") %&gt;%\n  fromJSON(flatten = TRUE) %&gt;%          # сведение вложенного JSON\n  glimpse()\n\n# сохранение токена доступа из ответа\naccess_token &lt;- content$access_token    # сохраните токен доступа, чтобы разрешить указанные ниже запросы API\n\n# импорт контактов по вспышке\n# использование токена доступа \nresponse_contacts &lt;- GET(\n  paste0(url,\"api/outbreaks/\",outbreak_id,\"/contacts\"),          # запрос GET\n  add_headers(\n    Authorization = paste(\"Bearer\", access_token, sep = \" \")))\n\njson_contacts &lt;- content(response_contacts, as = \"text\")         # конвертация в текст JSON\n\ncontacts &lt;- as_tibble(fromJSON(json_contacts, flatten = TRUE))   # сведение JSON в таблицу tibble\n\nВНИМАНИЕ: Если вы импортируете большие объемы данных из API, требующего аутентификации, может выйти время. Чтобы этого избежать, заново извлекайте access_token перед каждым запросом API GET и попробуйте использовать фильтры или ограничения в запросе. \nСОВЕТ: Функция fromJSON() в пакете jsonlite не делает полное разложение с первого раза применения, поэтому, скорее всего, у вас останутся части в виде списка в получившейся таблице tibble. Вам нужно дополнительно разложить некоторые переменные, в зависимости от того, как был построен вложенный .json is. Для получения дополнительной информации, см. документацию по пакету jsonlite, например, функция flatten(). \nДля получения дополнительной информации, см. документацию по LoopBack Explorer, страницу Отслеживание контактов или советы по API в Github репозитории Go.Data\nВы можете больше прочитать о пакете httr здесь\nИнформация для данного раздела была также взята из этого самоучителя и этого самоучителя.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Импорт и экспорт</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.ru.html#экспорт",
    "href": "new_pages/importing.ru.html#экспорт",
    "title": "7  Импорт и экспорт",
    "section": "7.11 Экспорт",
    "text": "7.11 Экспорт\n\nС помощью пакета rio\nВ rio вы можете использовать функцию export() очень похожим образом, как и import(). Сначала задайте имя объекта R, который вы хотите сохранить (например, linelist) и затем в кавычках укажите путь к файлу, по которому вы хотите сохранить файл, включая желаемое имя и расширение файла. Например:\nЭто сохраняет датафрейм linelist как рабочую книгу Excel в рабочую директорию/корневую папку проекта R:\n\nexport(linelist, \"my_linelist.xlsx\") # сохранит в рабочую директорию\n\nВы можете сохранить тот же датафрейм как csv файл, изменив расширение. Например, мы также можем указать путь к файлу, построенный с помощью here():\n\nexport(linelist, here(\"data\", \"clean\", \"my_linelist.csv\"))\n\n\n\nВ буфер обмена\nЧтобы экспортировать датафрейм в буфер обмена вашего компьютера (чтобы потом вставить в другую программу, такую как Excel, Google Spreadsheets и т.п.), вы можете использовать write_clip() из пакета clipr.\n\n# экспорт датафрейма linelist в буфер обмена вашего компьютера\nclipr::write_clip(linelist)",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Импорт и экспорт</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.ru.html#import_rds",
    "href": "new_pages/importing.ru.html#import_rds",
    "title": "7  Импорт и экспорт",
    "section": "7.12 RDS файлы",
    "text": "7.12 RDS файлы\nКроме .csv, .xlsx, и т.п., вы можете также экспортировать/сохранять R датафреймы как .rds файлы. Это формат файла, специфичный для R, и он также очень полезен, если вы знаете, что вам снова нужно будет работать с экспортированными данными в R.\nКлассы столбцов сохраняются, так что вам не придется снова делать вычистку при импорте (с файлами Excel или даже CSV это может быть сложно!). Также этот файл меньшего размера, что полезно для экспорта и импорта больших наборов данных.\nНапример, если вы работаете в команде эпидемиологов и вам нужно отправить файлы команде по GIS для составления карты, а они также используют R, просто отправьте им файл .rds! Тогда сохранятся все классы столбцов, и вы уменьшите им работу.\n\nexport(linelist, here(\"data\", \"clean\", \"my_linelist.rds\"))",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Импорт и экспорт</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.ru.html#import_rdata",
    "href": "new_pages/importing.ru.html#import_rdata",
    "title": "7  Импорт и экспорт",
    "section": "7.13 Файлы Rdata и списки",
    "text": "7.13 Файлы Rdata и списки\nФайлы .Rdata могут содержать несколько объектов R - например, несколько датафреймов, результаты моделирования, списки и т.п. Это может быть очень полезным для консолидации или обмена большим количеством данных для определенного проекта.\nВ примере ниже несколько объектов R хранятся в экспортированном файле “my_objects.Rdata”:\n\nrio::export(my_list, my_dataframe, my_vector, \"my_objects.Rdata\")\n\nПримечание: если вы пытаетесь импортировать список, используйте import_list() из пакета rio для импорта с полной оригинальной структурой и содержимым.\n\nrio::import_list(\"my_list.Rdata\")",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Импорт и экспорт</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.ru.html#сохранение-графиков",
    "href": "new_pages/importing.ru.html#сохранение-графиков",
    "title": "7  Импорт и экспорт",
    "section": "7.14 Сохранение графиков",
    "text": "7.14 Сохранение графиков\nИнструкции по сохранению графиков, например, созданных с помощью ggplot(), детально приведены на странице основы ggplot.\nЕсли говорить кратко, выполните ggsave(\"my_plot_filepath_and_name.png\") после печати вашего графика. Вы можете либо указать объект сохраненного графика в аргументе plot =, либо указать только путь к файлу назначения (с расширением файла), чтобы сохранить последний выведенный на экран график. Вы можете контролировать width = (ширину), height = (высоту), units = (единицы), и dpi = (точки на дюйм).\nСохранение сетевого графика, например, дерева передачи, рассматривается на странице Цепочки распространения.",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Импорт и экспорт</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.ru.html#ресурсы",
    "href": "new_pages/importing.ru.html#ресурсы",
    "title": "7  Импорт и экспорт",
    "section": "7.15 Ресурсы",
    "text": "7.15 Ресурсы\nРуководство по импорту/экспорту данных в R\nR для аналитики данных, глава по импорту данных\nДокументация ggsave()\nНиже представлена таблица, взятая из онлайн виньетки по rio. Для каждого типа данных она показывает: ожидаемое расширение файла, пакет, который rio использует для импорта или экспорта данных, а также включен ли этот функционал в версию rio, установленную по умолчанию.\n\n\n\n\n\n\n\n\n\n\nФормат\nОбычное расширение\nПакет для импорта\nПакет для экспорта\nУстановлен по умолчанию\n\n\n\n\nДанные, разделенные запятыми\n.csv\ndata.table fread()\ndata.table\nДа\n\n\nДанные, разделенные вертикальной чертой\n.psv\ndata.table fread()\ndata.table\nДа\n\n\nДанные, разделенные знаками табуляции\n.tsv\ndata.table fread()\ndata.table\nДа\n\n\nSAS\n.sas7bdat\nhaven\nhaven\nДа\n\n\nSPSS\n.sav\nhaven\nhaven\nДа\n\n\nStata\n.dta\nhaven\nhaven\nДа\n\n\nSAS\nXPORT\n.xpt\nhaven\nhaven\n\n\nSPSS Portable\n.por\nhaven\n\nДа\n\n\nExcel\n.xls\nreadxl\n\nДа\n\n\nExcel\n.xlsx\nreadxl\nopenxlsx\nДа\n\n\nСинтакс R\n.R\nбазовый\nбазовый\nДа\n\n\nСохраненные объекты R\n.RData, .rda\nбазовый\nбазовый\nДа\n\n\nСерийные объекты R\n.rds\nбазовый\nбазовый\nДа\n\n\nEpiinfo\n.rec\nforeign\n\nДа\n\n\nMinitab\n.mtp\nforeign\n\nДа\n\n\nSystat\n.syd\nforeign\n\nДа\n\n\n“XBASE”\nфайлы базы данных\n.dbf\nforeign\nforeign\n\n\nФормат файлов связи атрибутов Weka\n.arff\nforeign\nforeign\nДа\n\n\nФормат обмена данными\n.dif\nutils\n\nДа\n\n\nДанные Fortran\nno recognized extension\nutils\n\nДа\n\n\nФормат данных с фиксированной шириной\n.fwf\nutils\nutils\nДа\n\n\ngzip данные, разделенные запятыми\n.csv.gz\nutils\nutils\nДа\n\n\nCSVY (CSV + YAML metadata header)\n.csvy\ncsvy\ncsvy\nНет\n\n\nEViews\n.wf1\nhexView\n\nНет\n\n\nФормат обмена Feather R/Python\n.feather\nfeather\nfeather\nНет\n\n\nFast Storage\n.fst\nfst\nfst\nНет\n\n\nJSON\n.json\njsonlite\njsonlite\nНет\n\n\nMatlab\n.mat\nrmatio\nrmatio\nНет\n\n\nOpenDocument Spreadsheet\n.ods\nreadODS\nreadODS\nНет\n\n\nТаблицы HTML\n.html\nxml2\nxml2\nНет\n\n\nShallow XML documents\n.xml\nxml2\nxml2\nНет\n\n\nYAML\n.yml\nyaml\nyaml\nНет\n\n\nБуфер обмена по умолчанию tsv\n\nclipr\nclipr\nНет",
    "crumbs": [
      "Основы",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Импорт и экспорт</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.ru.html",
    "href": "new_pages/cleaning.ru.html",
    "title": "8  Вычистка данных и ключевые функции",
    "section": "",
    "text": "Ключевые функции\nЭто руководство подчеркивает использование функций из семьи пакетов R tidyverse. Основные функции R, представленные на данной странице, перечислены ниже.\nМногие из этих функций относятся к пакету R dplyr, который предоставляет “глагольные” функции для решения проблем манипуляций с данными (название является отсылкой на “датафрейм-Plier - щипцы. dplyr является частью семьи пакетов R tidyverse (она также включает в себя ggplot2, tidyr, stringr, tibble, purrr, magrittr, forcats и другие).\nЕсли вы хотите увидеть сравнение этих функций с командами в Stata или SAS, см. страницу [Переход к R]((transition_to_R.ru.qmd).\nВы можете столкнуться с альтернативной системой управления данными из пакета R data.table с такими операторами, как := и частым использованием квадратных скобок [ ]. Такой подход и синтаксис кратко объясняются на странице Таблицы данных.",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Вычистка данных и ключевые функции</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.ru.html#канал-вычистки",
    "href": "new_pages/cleaning.ru.html#канал-вычистки",
    "title": "8  Вычистка данных и ключевые функции",
    "section": "8.1 Канал вычистки",
    "text": "8.1 Канал вычистки\nНа этой странице представлены типичные шаги по вычистке данных, и они последовательно добавляются в канал вычистки.\nВ эпидемиологическом анализе и обработке данных шаги по вычистке часто проводятся последовательно и связываются вместе. В R это часто выглядит как “цепочка канала”, где сырой набор данных передается или “ставится в канал” из одного шага вычистки в другой.\nТакие цепочки используют “глагольные функции” dplyr и оператор канала из magrittr %&gt;%. Этот канал начинается с “сырых” данных (“linelist_raw.xlsx”) и оканчивается “чистым” датафреймом в R (linelist), который можно использовать, сохранять, экспортировать и т.п.\nВ цепочке канала вычистки очень важен порядок шагов. Шаги по вычистке могут включать:\n\nИмпорт данных\n\nВычистка или изменение названия столбцов\n\nДедупликация\n\nСоздание столбцов и трансформация (например, перекодирование или стандартизация значений)\n\nФильтрация или добавления строк",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Вычистка данных и ключевые функции</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.ru.html#загрузка-пакетов",
    "href": "new_pages/cleaning.ru.html#загрузка-пакетов",
    "title": "8  Вычистка данных и ключевые функции",
    "section": "8.2 Загрузка пакетов",
    "text": "8.2 Загрузка пакетов\nДанный фрагмент кода показывает загрузку пакетов, требуемых для анализа. В данном руководстве мы полагаемся на p_load() из pacman, который устанавливает пакеты, если необходимо, и загружает их для использования. Вы также можете загружать установленные пакеты с помощью library() из базового R. См. страницу Основы R для получения более подробной информации о пакетах R.\n\npacman::p_load(\n  rio,        # импорт данных  \n  here,       # относительные пути к файлу  \n  janitor,    # вычистка данных и таблицы\n  lubridate,  # работа с датами\n  matchmaker, # вычистка на основе словаря\n  epikit,     # функция age_categories() (возрастные категории)\n  tidyverse   # управление данными и визуализация\n)",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Вычистка данных и ключевые функции</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.ru.html#импорт-данных",
    "href": "new_pages/cleaning.ru.html#импорт-данных",
    "title": "8  Вычистка данных и ключевые функции",
    "section": "8.3 Импорт данных",
    "text": "8.3 Импорт данных\n\nИмпорт\nЗдесь мы импортируем “сырой” Excel файл с построчным списком, используя функцию import() из пакета rio. Пакет rio гибко работает с многими типами файлов (например, .xlsx, .csv, .tsv, .rds. См. страницу Импорт и экспорт для получения более подробной информации и советов по необычным ситуациям (например, пропуск строк, установка отсутствующих значений, импорт Google таблиц и т.п.).\nЕсли вы хотите параллельно повторять эти действия, кликните для скачивания “сырого” построчного списка (as .xlsx file).\nЕсли ваш набор данных большой и требует много времени для импортирования, может быть полезно сделать импорт командой, отдельной от цепочки канала и сохранить “сырой” набор данных как отдельный файл. Это позволит легко проводить сопоставление между оригиналом и вычищенными версиями.\nНиже мы импортируем сырой Excel файл и сохраняем его как датафрейм linelist_raw. Мы предполагаем, что файл расположен в вашей рабочей директории или корневой папке проекта R, поэтому в пути к файлу не уточняются подпапки.\n\nlinelist_raw &lt;- import(\"linelist_raw.xlsx\")\n\nВы можете видеть первые 50 строк датафрейма ниже. Примечание: базовая функция R head(n) позволяет вам просматривать только первое n количество строк в консоли R.\n\n\n\n\n\n\n\n\nОбзор\nВы можете использовать функцию skim() из пакета skimr, чтобы сделать обзор всего датафрейма (см. страницу Описательные таблицы для получения более детальной информации). Столбцы резюмируются по классу/типу, например, текстовые, числовые. Примечание: “POSIXct” - это тип класса сырых данных (см. Работа с датами.\n\nskimr::skim(linelist_raw)\n\n\n\n\nData summary\n\n\nName\nlinelist_raw\n\n\nNumber of rows\n6611\n\n\nNumber of columns\n28\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n17\n\n\nnumeric\n8\n\n\nPOSIXct\n3\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\ncase_id\n137\n0.98\n6\n6\n0\n5888\n0\n\n\ndate onset\n293\n0.96\n10\n10\n0\n580\n0\n\n\noutcome\n1500\n0.77\n5\n7\n0\n2\n0\n\n\ngender\n324\n0.95\n1\n1\n0\n2\n0\n\n\nhospital\n1512\n0.77\n5\n36\n0\n13\n0\n\n\ninfector\n2323\n0.65\n6\n6\n0\n2697\n0\n\n\nsource\n2323\n0.65\n5\n7\n0\n2\n0\n\n\nage\n107\n0.98\n1\n2\n0\n75\n0\n\n\nage_unit\n7\n1.00\n5\n6\n0\n2\n0\n\n\nfever\n258\n0.96\n2\n3\n0\n2\n0\n\n\nchills\n258\n0.96\n2\n3\n0\n2\n0\n\n\ncough\n258\n0.96\n2\n3\n0\n2\n0\n\n\naches\n258\n0.96\n2\n3\n0\n2\n0\n\n\nvomit\n258\n0.96\n2\n3\n0\n2\n0\n\n\ntime_admission\n844\n0.87\n5\n5\n0\n1091\n0\n\n\nmerged_header\n0\n1.00\n1\n1\n0\n1\n0\n\n\n…28\n0\n1.00\n1\n1\n0\n1\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\n\n\n\n\ngeneration\n7\n1.00\n16.60\n5.71\n0.00\n13.00\n16.00\n20.00\n37.00\n\n\nlon\n7\n1.00\n-13.23\n0.02\n-13.27\n-13.25\n-13.23\n-13.22\n-13.21\n\n\nlat\n7\n1.00\n8.47\n0.01\n8.45\n8.46\n8.47\n8.48\n8.49\n\n\nrow_num\n0\n1.00\n3240.91\n1857.83\n1.00\n1647.50\n3241.00\n4836.50\n6481.00\n\n\nwt_kg\n7\n1.00\n52.69\n18.59\n-11.00\n41.00\n54.00\n66.00\n111.00\n\n\nht_cm\n7\n1.00\n125.25\n49.57\n4.00\n91.00\n130.00\n159.00\n295.00\n\n\nct_blood\n7\n1.00\n21.26\n1.67\n16.00\n20.00\n22.00\n22.00\n26.00\n\n\ntemp\n158\n0.98\n38.60\n0.95\n35.20\n38.30\n38.80\n39.20\n40.80\n\n\n\nVariable type: POSIXct\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nmedian\nn_unique\n\n\n\n\ninfection date\n2322\n0.65\n2012-04-09\n2015-04-27\n2014-10-04\n538\n\n\nhosp date\n7\n1.00\n2012-04-20\n2015-04-30\n2014-10-15\n570\n\n\ndate_of_outcome\n1068\n0.84\n2012-05-14\n2015-06-04\n2014-10-26\n575",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Вычистка данных и ключевые функции</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.ru.html#имена-столбцов",
    "href": "new_pages/cleaning.ru.html#имена-столбцов",
    "title": "8  Вычистка данных и ключевые функции",
    "section": "8.4 Имена столбцов",
    "text": "8.4 Имена столбцов\nВ R имена столбцов - это “заголовок” или “верхнее” значение в столбце. Они используются, чтобы ссылаться на столбцы в коде, а также являются значеними по умолчанию в подписях к диаграммам.\nДругие статистические программы, такие как SAS и STATA используют “подписи”, которые существуют параллельно как более длинные печатные версии коротких имен столбцов. Хотя в R и есть возможность добавлять подписи столбцов к данным, на практике это не часто применяется. Чтобы сделать имена столбцов более удобными для печати графиков, как правило, их отображение корректируется в рамках команд для построения диаграммы, которые создают выходные данные (например, подписи осей или легенду для графика или заголовки столбцов в печатной таблице - см. раздел по шкалам на странице с советами по использованию ggplot и страницу Таблицы для презентации). Если вы хотите присвоить подписи столбцов в данных, более детально прочитайте об этом тут и тут.\nТак как имена столбцов очень часто используются в R, они должны иметь “чистый” синтаксис. Мы рекомендуем следующее:\n\nКороткие имена\nБез пробелов (замените пробелы на нижние подчеркивания _ )\nБез специальных знаков (&, #, &lt;, &gt;, …)\n\nНоменклатура в едином стиле (например, все столбцы с датами названы по принципу дата_заболевания, дата_регистрации, дата_смерти)\n\nНазвания столбцов набора данных linelist_raw напечатаны ниже с помощью names() из базового R. Мы можем увидеть, что изначально:\n\nНекоторые имена содержат пробелы (например, infection date)\n\nДля дат используются разные принципы именования (date onset или infection date)\n\nНаверное, был объединенный заголовок в двух последних столбцах в .xlsx. Мы это знаем, поскольку имя двух объединенных столбцов (“merged_header”) было просто присвоено R первому столбцу, а второму столбцу было присвоено временное имя “…28” (поскольку он был пустым и это 28й столбец).\n\n\nnames(linelist_raw)\n\n [1] \"case_id\"         \"generation\"      \"infection date\"  \"date onset\"     \n [5] \"hosp date\"       \"date_of_outcome\" \"outcome\"         \"gender\"         \n [9] \"hospital\"        \"lon\"             \"lat\"             \"infector\"       \n[13] \"source\"          \"age\"             \"age_unit\"        \"row_num\"        \n[17] \"wt_kg\"           \"ht_cm\"           \"ct_blood\"        \"fever\"          \n[21] \"chills\"          \"cough\"           \"aches\"           \"vomit\"          \n[25] \"temp\"            \"time_admission\"  \"merged_header\"   \"...28\"          \n\n\nПРИМЕЧАНИЕ: Чтобы ссылаться на имя столбца, которое содержит пробелы, заключите это имя в обратные одинарные кавычки, например: linelist$` '\\x60infection date\\x60'`. Обратите внимание, что на клавиатуре обратная кавычка (`) отличается от простой одинарной кавычки (’).\n\nАвтоматическая вычистка\nФункция clean_names() из пакета janitor стандартизирует имена столбцов и делает их уникальными следующим образом:\n\nКонвертирует все имена так, чтобы они содержали только нижние подчеркивания, цифры и буквы\n\nСимволы с диакритическими знаками транслитерируются в ASCII (например, немецкая о умлаут становится “o”, испанская “энье” становится “n”)\n\nПредпочтения по капитализации для новых имен столбцов можно указать, используя аргумент case = (“snake” это значение по умолчанию, альтернативами могут быть “sentence”, “title”, “small_camel”…)\n\nВы можете уточнить конкретную замену имен, указав вектор в аргументе replace = (например, replace = c(onset = \"date_of_onset\"))\n\nЗдесь есть онлайн виньетка\n\nНиже начинается цепочка канала вычистки, мы используем clean_names() для сырого построчного списка.\n\n# подставляем сырой набор данных через функцию clean_names(), присваиваем результату имя \"linelist\"  \nlinelist &lt;- linelist_raw %&gt;% \n  janitor::clean_names()\n\n# смотрим новые имена столбцов\nnames(linelist)\n\n [1] \"case_id\"         \"generation\"      \"infection_date\"  \"date_onset\"     \n [5] \"hosp_date\"       \"date_of_outcome\" \"outcome\"         \"gender\"         \n [9] \"hospital\"        \"lon\"             \"lat\"             \"infector\"       \n[13] \"source\"          \"age\"             \"age_unit\"        \"row_num\"        \n[17] \"wt_kg\"           \"ht_cm\"           \"ct_blood\"        \"fever\"          \n[21] \"chills\"          \"cough\"           \"aches\"           \"vomit\"          \n[25] \"temp\"            \"time_admission\"  \"merged_header\"   \"x28\"            \n\n\nПРИМЕЧАНИЕ: Имя последнего столбца “…28” было изменено на “x28”.\n\n\nВычистка имен вручную\nЧасто даже после шага стандартизации, описанного выше, может потребоваться переименовать имена столбцов вручную. Ниже производится переименование с помощью функции rename() из пакета dplyr в рамках цепочки канала. rename() использует стиль NEW = OLD - новое имя столбца приводится до старого имени столбца.\nНиже к цепочке канала вычистки добавляется команда переименования. Пробелы добавляются стратегическим образом, чтобы выровнять код для облегчения его чтения.\n\n# ЦЕПОЧКА КАНАЛА ВЫЧИСТКИ (начинается с сырых данных, которые подставляются в шаги по вычистке)\n##################################################################################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # стандартизируем синтаксис имен столбцов\n    janitor::clean_names() %&gt;% \n    \n    # вручную переименовываем столбцы\n           # НОВОЕ имя             # СТАРОЕ имя\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome)\n\nВы можете увидеть, что изменились имена столбцов:\n\n\n [1] \"case_id\"              \"generation\"           \"date_infection\"      \n [4] \"date_onset\"           \"date_hospitalisation\" \"date_outcome\"        \n [7] \"outcome\"              \"gender\"               \"hospital\"            \n[10] \"lon\"                  \"lat\"                  \"infector\"            \n[13] \"source\"               \"age\"                  \"age_unit\"            \n[16] \"row_num\"              \"wt_kg\"                \"ht_cm\"               \n[19] \"ct_blood\"             \"fever\"                \"chills\"              \n[22] \"cough\"                \"aches\"                \"vomit\"               \n[25] \"temp\"                 \"time_admission\"       \"merged_header\"       \n[28] \"x28\"                 \n\n\n\nПереименование по положению столбца\nВы можете также делать переименование по положению столбца вместо имени столбца, например:\n\nrename(newNameForFirstColumn  = 1,\n       newNameForSecondColumn = 2)\n\n\n\nПереименование с помощью select() и summarise()\nВ качестве быстрого способа вы также можете переименовывать столбцы с помощью функций select() и summarise() из dplyr. select() используется, чтобы сохранить только некоторые столбцы (она описана ниже на этой странице). Функция summarise() разбирается на страницах Группирование данных и Описательные таблицы. Эти функции также используют формат new_name = old_name. Пример:\n\nlinelist_raw %&gt;% \n  select(# НОВОЕ имя             # СТАРОЕ имя\n         date_infection       = `infection date`,    # переименовать и СОХРАНИТЬ ТОЛЬКО эти столбцы\n         date_hospitalisation = `hosp date`)\n\n\n\n\nПрочие сложности\n\nПустые имена столбцов в Excel\nВ R не может быть столбцов в наборе данных без имени столбца (заголовка). Поэтому если вы импортируете набор данных Excel с данными, но без заголовков столбцов, R заполнит эти заголовки названиями как “…1” или “…2”. Цифра представляет собой номер столбца (например, 4-й столбец в наборе данных не имеет заголовка, тогда R назовет его “…4”).\nВы можете вычистить эти имена вручную, указав номер их положения (см. пример выше), либо присвоенное им имя (linelist_raw$...1).\n\n\nОбъединенные имена столбцов и ячейки в Excel\nОбъединенные ячейки в Excel файле встречаются довольно часто в полученных данных. Как объясняется на странице Переход к R, объединенные ячейки могут быть более удобны для чтения данных человеком, но не являются “аккуратными данными” и могут вызввать много проблем для машинного чтения данных. R не может справиться с объединенными ячейками.\nНапоминайте людям, осуществляющим ввод данных, что данные, читаемые человеком - не то же самое, что машиночитаемые данные. Стремитесь обучать пользователей принципам аккуратных данных. Если возможно, попробуйте изменить процедуры, чтобы данные поступали в аккуратном формате без объединенных ячеек.\n\nУ каждой переменной должен быть свой столбец.\n\nУ каждого наблюдения должна быть своя строка.\n\nУ каждого значения должна быть своя ячейка.\n\nПри использовании функции import() из rio, значение в объединенной ячейке будет присвоено первой ячейке, а последующие ячейки останутся пустыми.\nОдно из решений для проблемы объединенных ячеек - импортировать данные с помощью функции readWorkbook() из пакета openxlsx. Задайте аргумент fillMergedCells = TRUE. Это задает значение из объединенной ячейки для всех ячеек в объединенном диапазоне.\n\nlinelist_raw &lt;- openxlsx::readWorkbook(\"linelist_raw.xlsx\", fillMergedCells = TRUE)\n\nВНИМАНИЕ: Если имена столбцов объединены с помощью readWorkbook(), у вас получатся дублирующиеся имена столбцов, которые вам нужно будет исправить вручную - R не очень хорошо справляется с дублирующимися именами столбцов! Вы можете переименовать их, ссылаясь на их положение (например, столбец 5), как говорится в разделе по вычистке имен столбцов вручную.",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Вычистка данных и ключевые функции</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.ru.html#выбор-или-смена-порядка-столбцов",
    "href": "new_pages/cleaning.ru.html#выбор-или-смена-порядка-столбцов",
    "title": "8  Вычистка данных и ключевые функции",
    "section": "8.5 Выбор или смена порядка столбцов",
    "text": "8.5 Выбор или смена порядка столбцов\nИспользуйте select() из пакета dplyr для выбора столбцов, которые вы хотите сохранить, а также для уточнения их порядка в датафрейме.\nВНИМАНИЕ: В примерах ниже датафрейм linelist модифицируется с помощью select() и отображается, но не сохраняется. Это сделано в целях демонстрации. Модифицированные имена столбцов печатаются с помощью передачи датафрейм в канале в функцию names().\nЗдесь представлены ВСЕ имена столбцов в построчном списке на этом этапе цепочки канала вычистки:\n\nnames(linelist)\n\n [1] \"case_id\"              \"generation\"           \"date_infection\"      \n [4] \"date_onset\"           \"date_hospitalisation\" \"date_outcome\"        \n [7] \"outcome\"              \"gender\"               \"hospital\"            \n[10] \"lon\"                  \"lat\"                  \"infector\"            \n[13] \"source\"               \"age\"                  \"age_unit\"            \n[16] \"row_num\"              \"wt_kg\"                \"ht_cm\"               \n[19] \"ct_blood\"             \"fever\"                \"chills\"              \n[22] \"cough\"                \"aches\"                \"vomit\"               \n[25] \"temp\"                 \"time_admission\"       \"merged_header\"       \n[28] \"x28\"                 \n\n\n\nСохранение столбцов\nВыберите только те столбцы, которые вы хотите сохранить\nВставьте их имена в команду select() без кавычек. Они появятся в датафрейме в том порядке, который вы указали. Обратите внимание, что если вы включите имя несуществующего столбца, R выдаст ошибку (см. использование any_of() ниже, если вы хотите избежать ошибок в этой ситуации).\n\n# набор данных linelist передается в канал в команду select(), а names() выводит на печать только имена столбцов\nlinelist %&gt;% \n  select(case_id, date_onset, date_hospitalisation, fever) %&gt;% \n  names()  # отображает имена столбцов\n\n[1] \"case_id\"              \"date_onset\"           \"date_hospitalisation\"\n[4] \"fever\"               \n\n\n\n\nФункции-помощники “tidyselect”\nЭти функции-помощники существуют, чтобы упростить уточнение того, какие столбцы сохранить, убрать или преобразовать. Это функции из пакета tidyselect, который включен в tidyverse и лежит в основе того, как столбцы выбираются в функциях dplyr.\nНапример, если вы хотите изменить порядок столбцов, полезной функцией является everything(), которая означает “все другие еще не упомянутые столбцы”. Команда ниже перемещает столбцы date_onset и date_hospitalisation в начало (влево) набора данных, но сохраняет все другие столбцы после. Обратите внимание, что everything() записана с пустыми скобками:\n\n# перемещает date_onset и date_hospitalisation в начало\nlinelist %&gt;% \n  select(date_onset, date_hospitalisation, everything()) %&gt;% \n  names()\n\n [1] \"date_onset\"           \"date_hospitalisation\" \"case_id\"             \n [4] \"generation\"           \"date_infection\"       \"date_outcome\"        \n [7] \"outcome\"              \"gender\"               \"hospital\"            \n[10] \"lon\"                  \"lat\"                  \"infector\"            \n[13] \"source\"               \"age\"                  \"age_unit\"            \n[16] \"row_num\"              \"wt_kg\"                \"ht_cm\"               \n[19] \"ct_blood\"             \"fever\"                \"chills\"              \n[22] \"cough\"                \"aches\"                \"vomit\"               \n[25] \"temp\"                 \"time_admission\"       \"merged_header\"       \n[28] \"x28\"                 \n\n\nНиже представлены другие функции-помощники “tidyselect”, которые также работают внутри функций dplyr, такие как select(), across() и summarise():\n\neverything() - все другие не упомянутые столбцы\n\nlast_col() - последний столбец\n\nwhere() - применяет функцию ко всем столбцам и выбирает, какие из них являются ИСТИНОЙ\n\ncontains() - столбцы, содержащие последовательность знаков\n\nпример: select(contains(\"time\"))\n\n\nstarts_with() - соответствует упомянутому префиксу\n\nпример: select(starts_with(\"date_\"))\n\n\nends_with() - соответствует упомянутому суффиксу\n\nпример: select(ends_with(\"_post\"))\n\n\nmatches() - для применения регулярного выражения (regex)\n\nпример: select(matches(\"[pt]al\"))\n\n\nnum_range() - числовой диапазон, например, x01, x02, x03\n\nany_of() - соответствует ЕСЛИ столбец существует, но не выдает ошибку, если он не найден\n\nпример: select(any_of(date_onset, date_death, cardiac_arrest))\n\n\nКроме того, используйте обычные операторы, например, c(), чтобы перечислить несколько столбцов, : для последовательно расположенных столбцов, ! для противоположных, & для И, и | для ИЛИ.\nИспользуйте where(), чтобы уточнить логические критерии для столбцов. Если вы представляете функцию внутри where(), не включайте пустые скобки функции. Команда ниже выбирает столбцы с числовым классом.\n\n# выбирает столбцы в числовом классе\nlinelist %&gt;% \n  select(where(is.numeric)) %&gt;% \n  names()\n\n[1] \"generation\" \"lon\"        \"lat\"        \"row_num\"    \"wt_kg\"     \n[6] \"ht_cm\"      \"ct_blood\"   \"temp\"      \n\n\nИспользуйте contains(), чтобы выбрать только те столбцы, в которых название столбцы содержит конкретную последовательность знаков. ends_with() и starts_with() дадут вам большую детализацию.\n\n# выбирает столбцы, содержащие определенные знаки\nlinelist %&gt;% \n  select(contains(\"date\")) %&gt;% \n  names()\n\n[1] \"date_infection\"       \"date_onset\"           \"date_hospitalisation\"\n[4] \"date_outcome\"        \n\n\nФункция matches() работает аналогично функции contains(), но ей может быть задано регулярное выражение (см. страницу Текст и последовательности), например, несколько последовательностей, разделенных чертами со значением ИЛИ внутри скобок:\n\n# поиск нескольких соответствий знаков\nlinelist %&gt;% \n  select(matches(\"onset|hosp|fev\")) %&gt;%   # обратите внимание на символ ИЛИ \"|\"\n  names()\n\n[1] \"date_onset\"           \"date_hospitalisation\" \"hospital\"            \n[4] \"fever\"               \n\n\nВНИМАНИЕ: Если имя столбца, которое вы задали, не существует в данных, вам будет выдана ошибка, а выполнение кода будет остановлено. Рассмотрите возможность использования any_of(), чтобы перечислить столбцы, которые, возможно, не существуют, что особенно полезно при отрицательном выборе (удалении).\nСуществует только один из этих столбцов, но программа не выдает ошибку, и выполнение кода продолжается без остановки канала вычистки.\n\nlinelist %&gt;% \n  select(any_of(c(\"date_onset\", \"village_origin\", \"village_detection\", \"village_residence\", \"village_travel\"))) %&gt;% \n  names()\n\n[1] \"date_onset\"\n\n\n\n\nУдаление столбцов\nУкажите, какие столбцы удалить, поставив знак минус “-” перед именем столбца (например, select(-outcome)), или вектором имен столбцов (как показано ниже). Все другие столбцы будут сохранены.\n\nlinelist %&gt;% \n  select(-c(date_onset, fever:vomit)) %&gt;% # удаляет date_onset и все столбцы от fever до vomit\n  names()\n\n [1] \"case_id\"              \"generation\"           \"date_infection\"      \n [4] \"date_hospitalisation\" \"date_outcome\"         \"outcome\"             \n [7] \"gender\"               \"hospital\"             \"lon\"                 \n[10] \"lat\"                  \"infector\"             \"source\"              \n[13] \"age\"                  \"age_unit\"             \"row_num\"             \n[16] \"wt_kg\"                \"ht_cm\"                \"ct_blood\"            \n[19] \"temp\"                 \"time_admission\"       \"merged_header\"       \n[22] \"x28\"                 \n\n\nВы можете также удалить столбец, используя базовый синтаксис R, определив его как NULL. Например:\n\nlinelist$date_onset &lt;- NULL   # удаление столбца с помощью базового синтаксиса R \n\n\n\nОтдельная команда\nselect() также может использоваться как независимая команда (не как часть канала). В таком случае первым аргументом будет изначальный датафрейм, с которым проводится операция.\n\n# Создание нового построчного списка со столбцами с идентификатором и возрастом\nlinelist_age &lt;- select(linelist, case_id, contains(\"age\"))\n\n# отображение имен столбцов\nnames(linelist_age)\n\n[1] \"case_id\"  \"age\"      \"age_unit\"\n\n\n\nДобавление в цепочку канала\nВ linelist_raw, существует несколько столбцов, которые нам не нужны: row_num, merged_header и x28. Мы удаляем их с помощью команды select() в цепочке канала вычистки:\n\n# ЦЕПОЧКА КАНАЛА ВЫЧИСТКИ (начинается с сырых данных, которые передаются по шагам вычистки)\n##################################################################################\n\n# начало цепочки канала вычистки\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # стандартизируем синтаксис имени столбца\n    janitor::clean_names() %&gt;% \n    \n    # переименовываем столбцы вручную\n           # НОВОЕ имя             # СТАРОЕ имя\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # ВЫШЕ ПОКАЗАНЫ РАНЕЕ ПРОДЕЛАННЫЕ И ПРЕДСТАВЛЕННЫЕ ШАГИ ВЫЧИСТКИ\n    #####################################################\n\n    # удаляем столбцы\n    select(-c(row_num, merged_header, x28))",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Вычистка данных и ключевые функции</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.ru.html#дедупликация",
    "href": "new_pages/cleaning.ru.html#дедупликация",
    "title": "8  Вычистка данных и ключевые функции",
    "section": "8.6 Дедупликация",
    "text": "8.6 Дедупликация\nСм. страницу руководства Дедупликация, где показан широкий спектр вариантов дедупликации данных. Здесь представлен только простой пример дедупликации строки.\nПакет dplyr предлагает функцию distinct(). Эта функция рассматривает каждую строку и сокращает датафрейм только до уникальных строк. То есть, она удаляет те строки, которые являются 100% дубликатами.\nПри оценке дублирующихся строк она принимает во внимание диапазон столбцов - по умолчанию рассматриваются все столбцы. Как показано на странице по дедупликации, вы можете скорректировать диапазон столбцов, чтобы уникальность строк оценивуалась только по определенным столбцам.\nВ этом простом примере мы просто добавляем пустую команду distinct() в цепочку канала. Она сделает так, что не останется строк, которые являются 100% дубликатами других строк (оценивается по всем столбцам).\nМы начинаем с nrow(linelist) строк в linelist.\n\nlinelist &lt;- linelist %&gt;% \n  distinct()\n\nПосле дедупликации у нас осталось nrow(linelist) строк. Любые удаленные строки были 100% дубликатами других строк.\nНиже в цепочку канала добавляется команда distinct():\n\n# ЦЕПОЧКА КАНАЛА ВЫЧИСТКИ (начинается с сырых данных, которые передаются по шагам вычистки)\n##################################################################################\n\n# начало цепочки канала вычистки\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # стандартизируем синтаксис имен столбцов\n    janitor::clean_names() %&gt;% \n    \n    # переименовываем столбцы вручную\n           # НОВОЕ имя             # СТАРОЕ имя\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # удаляем столбцы\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # ВЫШЕ ПОКАЗАНЫ РАНЕЕ ПРОДЕЛАННЫЕ И ПРЕДСТАВЛЕННЫЕ ШАГИ ВЫЧИСТКИ\n    #####################################################\n    \n    # дедупликация\n    distinct()",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Вычистка данных и ключевые функции</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.ru.html#создание-и-преобразование-столбцов",
    "href": "new_pages/cleaning.ru.html#создание-и-преобразование-столбцов",
    "title": "8  Вычистка данных и ключевые функции",
    "section": "8.7 Создание и преобразование столбцов",
    "text": "8.7 Создание и преобразование столбцов\nМы рекомендуем использовать функцию mutate() из dplyr, чтобы добавить новый столбец или преобразовать существующий.\nНиже представлен пример создания нового столбца с помощью mutate(). Синтаксис: mutate(новое_имя_столбца = значение или преобразование)\nВ Stata есть похожая команда generate, но функцию R mutate() можно также использовать для модификации существующего столбца.\n\nНовые столбцы\nСамая простая команда mutate() для создания нового столбца может выглядеть следующим образом. Она создает новый столбец new_col, где значения в каждой строке - 10.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(new_col = 10)\n\nВы также можете ссылаться на значения в других столбцах для проведения расчетов. Ниже создается столбец bmi, который должен содержать индекс массы тела (ИМТ) для каждого случая, он рассчитывается по формуле ИМТ = кг/м^2, используя столбец ht_cm и столбец wt_kg.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(bmi = wt_kg / (ht_cm/100)^2)\n\nЕсли вы создаете несколько новых столбцов, отделите каждый запятой и новой строкой. Ниже представлены некоторые примеры новых столбцов, включая те, которые состоят из значений из других столбцов, объединенных с помощью str_glue() из пакета stringr (см. страницу Текст и последовательности.\n\nnew_col_demo &lt;- linelist %&gt;%                       \n  mutate(\n    new_var_dup    = case_id,             # новый столбец = дубликат/копия другого существующего столбца\n    new_var_static = 7,                   # новый столбец = все значения такие же\n    new_var_static = new_var_static + 5,  # вы можете переписать столбец, это может быть расчет с использованием других переменных\n    new_var_paste  = stringr::str_glue(\"{hospital} on ({date_hospitalisation})\") # новый столбец = склейка значений других столбцов\n    ) %&gt;% \n  select(case_id, hospital, date_hospitalisation, contains(\"new\"))        # показывает только новые столбцы в демонстрационных целях\n\nРассмотрите новые столбцы. В демонстрационных целях показаны только новые столбцы и столбцы, использованные для их создания:\n\n\n\n\n\n\nСОВЕТ: Вариацией mutate() является функция transmute(). Эта функция добавляет новый столбец, как и mutate(), но также выкидывает/удаляет все другие столбцы, которые вы не упомянули внутри скобок.\n\n# СПРЯТАНО ОТ ЧИТАТЕЛЯ\n# удаляем новые демонстрационные столбцы, созданные выше\n# linelist &lt;- linelist %&gt;% \n#   select(-contains(\"new_var\"))\n\n\n\nКонвертация класса столбцов\nСтолбцы, содержащие значения, которые являются датами, числами или логическими значениями (ИСТИНА/ЛОЖЬ) будут вести себя в соответствии с ожиданиями, только если они правильно классифицированы. Есть разница между “2” в текстовом классе и 2 в числовом классе!\nСуществуют способы, чтобы задать класс столбцов в командах импорта, но это часто сложно сделать. См. раздел Основы R по классам объектов, чтобы получить дополнительную информацию о конвертации класса объектов и столбцов.\nСначала давайте проведем некоторые проверки важных столбцов, чтобы посмотреть, к правильному классу ли они относятся. Мы это также видели в начале, когда выполняли команду skim().\nВ настоящее время столбец age относится к текстовому классу. Чтобы провести количественный анализ, нам нужно, чтобы цифры распознавались как числовой класс!\n\nclass(linelist$age)\n\n[1] \"character\"\n\n\nКласс столбца date_onset также является текстовым! Для проведения анализа даты должны распознаваться как даты!\n\nclass(linelist$date_onset)\n\n[1] \"character\"\n\n\nЧтобы устранить эту проблему, используйте возможность функции mutate() по переопределению столбца с трансформацией. Мы определяем столбец как самого себя, но конвертируем его в другой класс. Здесь приведен базовый пример конвертации, чтобы класс столбца age был числовым:\n\nlinelist &lt;- linelist %&gt;% \n  mutate(age = as.numeric(age))\n\nАналогичным образом вы можете использовать as.character() и as.logical(). Чтобы конвертировать класс в Фактор, вы можете использовать factor() из базового R или as_factor() из forcats. Более подробно вы можете об этом узнать на странице Факторы.\nВы должны быть осторожны при конвертации в класс Дата. На странице Работа с датами объясняются несколько методов. Как правило, сырые значения даты должны быть в одинаковом формате, чтобы конвертация прошла правильно (например, “ММ/ДД/ГГГГ”, или “ДД ММ ГГГГ”). После конвертации в класс Дата, проверьте ваши данные, чтобы подтвердить, что каждое значение было сконвертировано верно.\n\n\nСгруппированные данные\nЕсли ваш датафрейм уже сгруппирован (см. страницу Группирование данных), mutate() может повести себя иначе, чем в наборе данных без группировки. Любые резюмирующие функции, такие как mean() (среднее значение), median() (медиана), max() (максимум) и т.п. будут рассчитаны по группе, а не по всем строкам.\n\n# возраст нормализован по среднему значению для ВСЕХ строк\nlinelist %&gt;% \n  mutate(age_norm = age / mean(age, na.rm=T))\n\n# возраст нормализован по среднему значению по группе больниц\nlinelist %&gt;% \n  group_by(hospital) %&gt;% \n  mutate(age_norm = age / mean(age, na.rm=T))\n\nБолее подробно об использовании mutate () в сгруппированных датафреймах можно почитать в этой документации по tidyverse mutate.\n\n\nТрансформация нескольких столбцов\nЧасто чтобы написать краткий код, вы можете захотеть применить одинаковую трансформацию сразу к нескольким столбцам. Трансформацию можно применить одновременно к нескольким столбцам, используя функцию across() из пакета dplyr (также содержится внутри пакета tidyverse). across() можно использовать с любой функцией dplyr, но она часто используется внутри select(), mutate(), filter() или summarise(). См. применение этой функции к summarise() на странице Описательные таблицы.\nУкажите столбцы в аргументе .cols = и функцию(и) к применению в .fns =. Любые дополнительные аргументы, которые должны быть заданы для функции .fns могут быть включены после запятой, все еще внутри across().\n\nВыбор столбцов в across()\nУкажите столбцы в аргументе .cols =. Вы можете назвать их по отдельности или использовать функцию-помощника “tidyselect”. Уточните функцию в .fns =. Обратите внимание, что в использовании режима функции ниже, функция пишется без скобок ( ).\nЗдесь трансформация as.character() применяется к конкретным столбцам, названным внутри across().\n\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))\n\nДоступны функции-помощники “tidyselect”, которые помогут вам в указании столбцов. Они детально представлены выше в разделе по Выбору и изменению порядка столбцов, и включают в себя: everything(), last_col(), where(), starts_with(), ends_with(), contains(), matches(), num_range() и any_of().\nЗдесь приведен пример того, как можно изменить все столбцы в текстовый класс:\n\n#чтобы изменить все столбцы на текстовый класс\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = everything(), .fns = as.character))\n\nКонвертация в текстовый класс всех столбцов, где в названии есть последовательность символов “date” (обратите внимание на размещение запятых и скобок):\n\n#чтобы изменить все столбцы на текстовый класс\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = contains(\"date\"), .fns = as.character))\n\nНиже представлен пример мутации столбцов, которые в настоящее время относятся к классу POSIXct (сырой класс датывремени, который показывает метки времени) - иными словами, где функция is.POSIXct() оценивается как TRUE (истина). Затем мы хотим применить функцию as.Date() к этим столбцам, чтобы конвертировать их в обычный класс Дата.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = where(is.POSIXct), .fns = as.Date))\n\n\nОбратите внимание, что внутри across() мы также используем функцию where() как is.POSIXct для оценки ИСТИНА или ЛОЖЬ.\n\nОбратите внимание, что is.POSIXct() относится к пакету lubridate. Другие похожие “is” функции, такие как is.character(), is.numeric() и is.logical() относятся к базовому R\n\n\n\nФункции across()\nВы можете прочитать документацию по ?across для получения дополнительной информации о том, как задавать функции для across(). Несколько общих моментов: существует несколько способов, чтобы уточнить, какую(ие) функцию(и) выполнить для столбца, и вы даже можете задать собственные функции:\n\nВы можете задать только имя функции (например, mean или as.character)\n\nВы можете задать функцию в стиле purrr (например, ~ mean(.x, na.rm = TRUE)) (см. [эту страницу][Итерации, циклы и списки])\n\nВы можете задать несколько функций, представив список (например, list(mean = mean, n_miss = ~ sum(is.na(.x))).\n\nЕсли вы задаете несколько функций, несколько трансформированных столбцов будут выданы вам на столбец входных данных, с уникальными именами в формате col_fn. Вы можете скорректировать, как будут названы новые столбцы с помощью аргумента .names =, используя синтаксис glue (см. страницу Текст и последовательности), где {.col} и {.fn} являются сокращениями для столбца входных данных и функции.\n\n\nВот несколько онлайн ресурсов по использованию across(): мысли/обоснование создателя Хэдли Уикема\n\n\n\ncoalesce()\nЭта функция dplyr находит первое неотсутствующее значение в каждом положении. Она “заполняет” отсутствующие значения первым доступным значением в указанном вами порядке.\nВот пример вне контекста датафрейма: Представим, что у вас есть два вектора, один содержит деревню, в которой выявлен пациент, а другой - деревню проживания пациента. Вы можете использовать coalesce для выбора первого неотсутствующего значения для каждого индекса:\n\nvillage_detection &lt;- c(\"a\", \"b\", NA,  NA)\nvillage_residence &lt;- c(\"a\", \"c\", \"a\", \"d\")\n\nvillage &lt;- coalesce(village_detection, village_residence)\nvillage    # печать\n\n[1] \"a\" \"b\" \"a\" \"d\"\n\n\nЭто работает таким же образом, если вы зададите столбцы датафрейма: для каждой строки функция присвоит новое значение столбца с помощью первого неотсутствующего значения в указанных вами столбцах (в указанном порядке).\n\nlinelist &lt;- linelist %&gt;% \n  mutate(village = coalesce(village_detection, village_residence))\n\nЭто пример “построчной” операции. Чтобы посмотреть более сложные построчные расчеты, см. раздел ниже по построчным расчетам.\n\n\nКумулятивная математика\nЕсли вы хотите, чтобы столбец отражал кумулятивную сумму/среднее значение/минимум/максимум и т.п., как оценено по строкам датафрейма на этот момент, используйте следующие функции:\ncumsum() выдает кумулятивную сумму, как показано ниже:\n\nsum(c(2,4,15,10))     # выдает только одно число\n\n[1] 31\n\ncumsum(c(2,4,15,10))  # выдает кумулятивную сумму на каждом шаге\n\n[1]  2  6 21 31\n\n\nЭто можно использовать в датафрейме при создании нового столбца. Например, чтобы рассчитать кумулятивное количество случаев в день при вспышке, можно использовать следующий код:\n\ncumulative_case_counts &lt;- linelist %&gt;%  # начинаем с построчного списка случаев\n  count(date_onset) %&gt;%                 # подсчитываем строки в день как столбец 'n'   \n  mutate(cumulative_cases = cumsum(n))  # новый столбец кумулятивной суммы на каждой строке\n\nНиже представлены первые 10 строк:\n\nhead(cumulative_case_counts, 10)\n\n   date_onset n cumulative_cases\n1  2012-04-15 1                1\n2  2012-05-05 1                2\n3  2012-05-08 1                3\n4  2012-05-31 1                4\n5  2012-06-02 1                5\n6  2012-06-07 1                6\n7  2012-06-14 1                7\n8  2012-06-21 1                8\n9  2012-06-24 1                9\n10 2012-06-25 1               10\n\n\nСм. также страницу Эпидемические кривые, чтобы узнать, как построить график кумулятивной заболеваемости с помощью эпидкривой.\nСм. также:\ncumsum(), cummean(), cummin(), cummax(), cumany(), cumall()\n\n\nИспользование базового R\nЧтобы определить новый столбец (или переопределить столбец), используя базовый R, напишите имя датафрейма, соединенного с помощью $, для нового столбца (или столбца, который должен быть модифицирован). Используйте оператор присваивания &lt;-, чтобы определить новое(ые) значение(я). Помните, что при использовании базового R вы должны уточнять имя датафрейма каждый раз перед именем столбца (например, dataframe$column). Здесь приведен пример создания столбца bmi с использованием базового R:\n\nlinelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)\n\n\n\nДобавление к цепочке канала\nНиже добавляется новый столбец к цепочке канала, а также конвертируются некоторые классы.\n\n# ЦЕПОЧКА КАНАЛА ВЫЧИСТКИ (начинается с сырых данных, которые передаются по шагам вычистки)\n##################################################################################\n\n# начало цепочки канала вычистки\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # стандартизируем синтаксис имен столбцов\n    janitor::clean_names() %&gt;% \n    \n    # переименовываем столбцы вручную\n           # НОВОЕ имя             # СТАРОЕ имя\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # удаляем столбцы\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # дедупликация\n    distinct() %&gt;% \n  \n    # ВЫШЕ ПОКАЗАНЫ РАНЕЕ ПРОДЕЛАННЫЕ И ПРЕДСТАВЛЕННЫЕ ШАГИ ВЫЧИСТКИ\n    ###################################################\n    # добавляем новый столбец\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %&gt;% \n  \n    # конвертируем класс столбцов\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age))",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Вычистка данных и ключевые функции</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.ru.html#перекодирование-значений",
    "href": "new_pages/cleaning.ru.html#перекодирование-значений",
    "title": "8  Вычистка данных и ключевые функции",
    "section": "8.8 Перекодирование значений",
    "text": "8.8 Перекодирование значений\nЗдесь представлено несколько сценариев, при которых вам нужно перекодировать (изменить) значения:\n\nчтобы редактировать одно конкретное значение (например, одна дата с неправильным годом или форматом)\n\nчтобы сделать единообразными значения, которые имеют разное правописание\nчтобы создать новый столбец категориальных значений\n\nчтобы создать новый столбец числовых категорий (например, возрастные категории)\n\n\nКонкретные значения\nЧтобы изменить значения вручную, вы можете использовать функцию recode() внутри функции mutate().\nПредставьте,что в дате стоит какая-то бессмысленная дата (например, “2014-14-15”): вы можете исправить дату вручную в сырых исходных данных, либо вы можете записать изменение в рамках цепочки канала вычистки с помощью mutate() и recode(). Последний вариант будет более прозрачным и воспроизводимям, если кто-то захочет понять или повторить ваш анализ.\n\n# исправление неправильных значений     # старое значение  # новое значение\nlinelist &lt;- linelist %&gt;% \n  mutate(date_onset = recode(date_onset, \"2014-14-15\" = \"2014-04-15\"))\n\nСтроку mutate() выше можно прочитать как: “изменить столбец date_onset, чтобы он был равен столбцу date_onset с перекодированием, так чтобы СТАРОЕ ЗНАЧЕНИЕ было изменено на НОВОЕ ЗНАЧЕНИЕ”. Обратите внимание, что эта последовательность (СТАРОЕ = НОВОЕ) в recode() противоположна большинству последовательностей в R (новое = старое). Сообщество разработчиков R уже работает над этим изменением.\nВот еще один пример перекодирования нескольких значений в одном столбце.\nВ linelist необходимо вычистить значения в столбце “hospital”. Есть несколько вариантов написания и много отсутствующих значений.\n\ntable(linelist$hospital, useNA = \"always\")  # печать таблицы всех уникальных значений, включая отсутствующие  \n\n\n                     Central Hopital                     Central Hospital \n                                  11                                  457 \n                          Hospital A                           Hospital B \n                                 290                                  289 \n                    Military Hopital                    Military Hospital \n                                  32                                  798 \n                    Mitylira Hopital                    Mitylira Hospital \n                                   1                                   79 \n                               Other                         Port Hopital \n                                 907                                   48 \n                       Port Hospital St. Mark's Maternity Hospital (SMMH) \n                                1756                                  417 \n  St. Marks Maternity Hopital (SMMH)                                 &lt;NA&gt; \n                                  11                                 1512 \n\n\nКоманда recode() ниже переопределяет столбец “hospital” (больницы) как текущий столбец “hospital”, но с указанными изменениями по перекодированию. Не забывайте запятые после каждого!\n\nlinelist &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital,\n                     # для справки: СТАРОЕ = НОВОЕ\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      ))\n\nТеперь мы видим, что написание в столбце hospital было исправлено и унифицировано:\n\ntable(linelist$hospital, useNA = \"always\")\n\n\n                    Central Hospital                           Hospital A \n                                 468                                  290 \n                          Hospital B                    Military Hospital \n                                 289                                  910 \n                               Other                        Port Hospital \n                                 907                                 1804 \nSt. Mark's Maternity Hospital (SMMH)                                 &lt;NA&gt; \n                                 428                                 1512 \n\n\nСОВЕТ: Количество пробелов до и после знака равно не имеет значения. Упростите чтение вашего кода, выровнив знаки = для всех или большинства строк. Кроме того, рассмотрите возможность добавления комментария со знаком решетка, чтобы пояснить будущим читателям, какая сторона является СТАРОЙ, а какая - НОВОЙ. \nСОВЕТ: Иногда в наборе данных может иметься пустое текстовое значение (не стандартное значение в R для отсутствующих значений - NA). Вы можете ссылаться на это значения с помощью двух кавычек без пробела между ними (““).\n\n\nПо логике\nНиже мы показываем, как перекодировать значения в столбце, используя логику и условия:\n\nИспользуя replace(), ifelse() и if_else() для простой логики\nИспользуя case_when() для более сложной логики\n\n\n\nПростая логика\n\nreplace()\nЧтобы перекодировать с простыми логическими критериями, вы можете использовать replace() внутри mutate(). replace() - это функция из базового R. Используйте логическое условие, чтобы уточнить, какие строки менять. Общий синтаксис выглядит следующим образом:\nmutate(col_to_change = replace(col_to_change, критерии для строк, новое значение)).\nОдна из частых ситуаций для использования replace() - это изменение только одного значения в одной строке, используя уникальный идентификатор строки. Ниже пол меняется на “Female” в строке, где столбец case_id равен “2195”.\n\n# Пример: изменение пола в одном конкретном наблюдении на \"Female\" \nlinelist &lt;- linelist %&gt;% \n  mutate(gender = replace(gender, case_id == \"2195\", \"Female\"))\n\nЭквивалент команды с использованием синтаксиса базового R и индексных квадратных скобок [ ] приведен ниже. Его следует читать как: “Изменить значение столбца gender в датаврейме linelist (для строк, где столбец case_id в linelist имеет значение ‘2195’) на ‘Female’”.\n\nlinelist$gender[linelist$case_id == \"2195\"] &lt;- \"Female\"\n\n\n\nifelse() и if_else()\nЕще один инструмент простой логики - это ifelse() и функция-партнер if_else(). Однако в большинстве случаев перекодирования понятнее будет использовать case_when() (описан ниже). Эти команды “if else” (если не) являются упрощенными версиями программного утверждения if (если) и else (кроме). Общий синтаксис выглядит следующим образом:\nifelse(условие, значение, которое выдается, если условие оценено как ИСТИНА, значение, которое выдается, если условие оценено как ЛОЖЬ)\nНиже определяется столбецsource_known. Его значение в соответствующей строке установлено на “known” (известен), если в столбце source не отсутствует значение строки. Если в столбце source отсутствует значение, тогда значение source_known устанавливается как “unknown” (неизвестен).\n\nlinelist &lt;- linelist %&gt;% \n  mutate(source_known = ifelse(!is.na(source), \"known\", \"unknown\"))\n\nif_else() - это специальная версия из dplyr, которая работает с датами. Обратите внимание, что если ‘true’ (истиным) значением является дата, то ‘false’ (ложное) значение должно также квалифицироваться как дата, поэтому вместо просто NA используется специальное значение NA_real_ .\n\n# создаем столбец дата смерти, в котором значение будет NA, если пациент не умер.\nlinelist &lt;- linelist %&gt;% \n  mutate(date_death = if_else(outcome == \"Death\", date_outcome, NA_real_))\n\nИзбегайте использования чрезмерно большого количества команд ifelse одновременно… вместо этого используйте case_when()! case_when() гораздо легче читать, и вы допустите меньше ошибок.\n\n\n\n\n\n\n\n\n\nВне контекста датафрейма, если вы хотите, чтобы объект, используемые в вашем коде, поменял значение, рассмотрите использование switch() из базового R.\n\n\n\nСложная логика\nИспользуйте case_when() из dplyr, если вы перекодируете в большое количество новых групп, либо если вам нужно использовать сложные логические утверждения для перекодирования значений. Эта функция оценивает каждую строку в датафрейме, оценивает, соответствуют ли строки указанным критериям и присваивает правильное новое значение.\nКоманды case_when() состоят из утверждений, которые имеют правую сторону и левую сторону, разделенную “тильдой” ~. Логические критерии указаны слева, а согласующиеся значения - справа в каждом утверждении. Утверждения разделяются запятыми.\nНапример, здесь мы используем столбцы age и age_unit, чтобы создать столбец age_years:\n\nlinelist &lt;- linelist %&gt;% \n  mutate(age_years = case_when(\n       age_unit == \"years\"  ~ age,       # если единица возраста годы\n       age_unit == \"months\" ~ age/12,    # если единица возраста месяцы, разделить возраст на 12\n       is.na(age_unit)      ~ age))      # если единица возраста отсутствует, предположить, что это годы\n                                         # в любых других обстоятельствах - присвоить NA (отсутствует)\n\nПо мере того как оценивается каждая строка данных, применяются/оцениваются критерии в порядке написания утверждений case_when() - сверху вниз. Если верхний критерий оценивается как TRUE (истина) для определенной строки, присваивается значение из правой стороны, а остальные критерии даже не тестируются для этой строки данных. Таким образом, лучше сначала записать наиболее специфичный критерий, а последним записать наиболее общий критерий. Строке данных, которая не соответствует ни одному критерию, будет присвоено NA.\nИногда вы можете записать финальное утверждение, которое присваивает значение для всех прочих сценариев, не описанных в одной из предыдущих строк. Чтобы это сделать, разместите TRUE в левой стороне, что охватит любую строку, которая не соответствовала ни одному из предыдущих критериев. Правой стороне этого утверждения можно присвоить значение, например “проверь меня!” или отсутствует.\nНиже приведен еще один пример использования case_when() для создания нового столбца с классификацией пациента в соответствии с определением случая подтвержденного и подозрительного случая:\n\nlinelist &lt;- linelist %&gt;% \n     mutate(case_status = case_when(\n          \n          # если у пациента есть лабораторный тест и он положительный,\n          # тогда он отмечается как подтвержденный случай \n          ct_blood &lt; 20                   ~ \"Confirmed\",\n          \n          # при условии, что у пациента нет положительного лабораторного теста,\n          # если у пациента есть \"источник\" (эпидемиологическая связь) И есть жар, \n          # тогда он маркируется как подозрительный случай\n          !is.na(source) & fever == \"yes\" ~ \"Suspect\",\n          \n          # любой другой пациент, не рассмотренный выше \n          # отмечается для  дальнейшего наблюдения\n          TRUE                            ~ \"To investigate\"))\n\nВНИМАНИЕ: Значения справа должны быть все в одном классе - либо числовые, текстовые, дата, логические и т.п. Чтобы присвоить отсутствующее значение (NA), вам может потребоваться использовать особые варианты NA, такие как NA_character_, NA_real_ (для числовых или POSIX), и as.Date(NA). Более детально см. страницу Работа с датами.\n\n\nОтсутствующие значения\nНиже приведены специальные функции для работы с отсутствующими значениями в контексте вычистки данных.\nСм. страницу Отсутствующие данные для получения более детальных советов о том, как определять и работать с отсутствующими значениями. Например, функция is.na(), которая логически тестирует на предмет отсутствия.\nreplace_na()\nЧтобы изменить отсутствующие значения (NA) на конкретное значение, например “Missing” (“Отсутствует”), используйте функцию replace_na() из dplyr внутри mutate(). Обратите внимание, что она используется таким же образом, как и recode выше - имя переменной необходимо повторить в replace_na().\n\nlinelist &lt;- linelist %&gt;% \n  mutate(hospital = replace_na(hospital, \"Missing\"))\n\nfct_explicit_na()\nЭто функция из пакета forcats. Пакет forcats работает со столбцами с классом Фактор. Факторы - то, как R работает с порядковыми значениями, такими как c(\"First\" (первый), \"Second\" (второй), \"Third\"(третий)) или задает порядок, в котором появляются значения (например, больницы) в таблицах и графиках. См. страницу Факторы.\nЕсли ваши данные относятся к классу Фактор и вы попытаетесь конвертировать NA в “Missing” (“отсутствует”) с помощью replace_na(), вы увидите следующее сообщение об ошибке: invalid factor level, NA generated (недействительный уровень фактора, сгенерирован NA). Вы попытались добавить “Missing” как значение, а оно не было определено как возможный уровень фактора и было отклонено.\nСамый простой способ решить эту проблему - использовать функцию из пакета forcats fct_explicit_na(), которая конвертирует столбец в класс фактор и конвертирует значения NA на текстовые “(Missing - отсутствует)”.\n\nlinelist %&gt;% \n  mutate(hospital = fct_explicit_na(hospital))\n\nБолее медленная альтернатива - добавить уровень фактора, используя fct_expand() и затем конвертируя отсутствующие значения.\nna_if()\nЧтобы конвертировать конкретное значение в NA, используйте функцию na_if() из dplyr. Команда ниже проводит противоположную replace_na() операцию. В примере ниже любые значения “Missing” в столбце hospital конвертируются в NA.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(hospital = na_if(hospital, \"Missing\"))\n\nПримечание: na_if() не может использоваться для логических критериев (например, “all values &gt; 99” (“все значения &gt; 99”)) - используйте replace() или case_when() для этих целей:\n\n# Конвертация температуры выше 40 в NA \nlinelist &lt;- linelist %&gt;% \n  mutate(temp = replace(temp, temp &gt; 40, NA))\n\n# Конвертация даты заболевания раньше, чем 1 января 2000 в отсутствующую\nlinelist &lt;- linelist %&gt;% \n  mutate(date_onset = replace(date_onset, date_onset &gt; as.Date(\"2000-01-01\"), NA))\n\n\n\nСловарь вычистки\nИспользуйте пакет R matchmaker и его функцию match_df() для вычистки датафрейма с помощью словаря вычистки.\n\nСоздайте словарь вычистки с 3 столбцами:\n\nстолбец “из” (неправильное значение)\n\nстолбец “в” (правильное значение)\n\nстолбец, указывающий столбец, к которому применяются изменения (или “.global”, чтобы применить ко всем столбцам)\n\n\nПримечание: записи в словаре для конкретного столбца будут превалировать над записями в словаре .global.\n\n\n\n\n\n\n\n\n\n\nИмпортируйте файл со словарем в R. Этот пример можно скачать, следуя инструкциям на странице Скачивание руководства и данных.\n\n\ncleaning_dict &lt;- import(\"cleaning_dict.csv\")\n\n\nПоставьте сырой постройчный список в функцию match_df(), уточнив dictionary = датафрейм словаря вычистки. Аргумент from = должен указывать на имя столбца словаря, в котором содержатся “старые значения”, аргумент by = должен быть столбцом словаря, в котором содержатся соответствующие “новые” значения, а третий столбец указывает столбец, в котором необходимо проводить изменение. Используйте .global в столбце by =, чтобы применить изменение ко всем столбцам. Четвертый столбец словаря order может быть использован для уточнения порядка факторов новых значений.\n\nДополнительные детали можно прочитать в документации по пакету, выполнив ?match_df. Обратите внимание, что эта функция может потребовать длительного времени выполнения для большого набора данных.\n\nlinelist &lt;- linelist %&gt;%     # укажите или поставьте в канал ваш набор данных\n     matchmaker::match_df(\n          dictionary = cleaning_dict,  # имя вашего словаря\n          from = \"from\",               # столбец со значениям, которые нужно заменить (по умолчанию столбец 1)\n          to = \"to\",                   # столбец с итоговыми значениями (по умолчанию столбец 2)\n          by = \"col\"                   # столбец с названиями столбцов (по умолчанию столбец 3)\n  )\n\nТеперь пролистайте вправо, чтобы увидеть, как изменились значения - особенно gender (со строчных на заглавные), а все столбцы с симптомами были трансформированы из yes/no в 1/0.\n\n\n\n\n\n\nОбратите внимание, что ваши имена столбцов в словаре вычистки должны соответствовать именам столбцов в вашем скрипте вычистки на данный момент. См. онлайн ссылку для пакета по построчным спискам для получения дополнительной информации.\n\nДобавление в цепочку канала\nНиже в цепочку канала добавляются некоторые новые столбцы и проводятся преобразования столбцов.\n\n# ЦЕПОЧКА КАНАЛА ВЫЧИСТКИ (начинается с сырых данных, которые передаются по шагам вычистки)\n##################################################################################\n\n# начало цепочки канала вычистки\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # стандартизируем синтаксис имен столбцов\n    janitor::clean_names() %&gt;% \n    \n    # переименовываем столбцы вручную\n           # НОВОЕ имя             # СТАРОЕ имя\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # удаляем столбцы\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # дедупликация\n    distinct() %&gt;% \n  \n    # добавляем столбец\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %&gt;%     \n\n    # конвертируем класс столбцов\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %&gt;% \n    \n    # добавляем столбец: задержка госпитализации\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %&gt;% \n    \n   # ВЫШЕ ПОКАЗАНЫ РАНЕЕ ПРОДЕЛАННЫЕ И ПРЕДСТАВЛЕННЫЕ ШАГИ ВЫЧИСТКИ\n   ###################################################\n\n    # чистые значения столбца hospital\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %&gt;% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %&gt;% \n\n    # создаем столбец age_years (из age и age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_))",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Вычистка данных и ключевые функции</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.ru.html#num_cats",
    "href": "new_pages/cleaning.ru.html#num_cats",
    "title": "8  Вычистка данных и ключевые функции",
    "section": "8.9 Числовые категории",
    "text": "8.9 Числовые категории\nЗдесь мы опишем некоторые особые подходы к созданию категорий из числовых столбцов. Частые примеры включают возрастные категории, группы лабораторных результатов и т.п. Здесь мы обсудим:\n\nage_categories(), из пакета epikit\n\ncut(), из базового R\n\ncase_when()\n\nквантильные разбивки с помощью quantile() и ntile()\n\n\nОбзор распределения\nДля данного примера мы создадим столбец age_cat, используя столбец age_years.\n\n# проверьте класс переменной возраста в linelist\nclass(linelist$age_years)\n\n[1] \"numeric\"\n\n\nСначала рассмотрим распределение ваших данных, чтобы определить соответствующие пороговые точки. См. страницу основы ggplot.\n\n# рассмотрим распределение\nhist(linelist$age_years)\n\n\n\n\n\n\n\n\n\nsummary(linelist$age_years, na.rm=T)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00    6.00   13.00   16.04   23.00   84.00     107 \n\n\nВНИМАНИЕ: Иногда числовые переменные импортируются как “текстовый” класс. Это происходит, если в каких-то значениях имеются нечисловые символы, например, запись возраста как “2 месяца” или (в зависимости от настроек вашего региона в R), если вместо точки используется запятая в десятичных числах (например, “4,5” как четыре с половиной года)..\n\n\n\nage_categories()\nС пакетом epikit вы можете использовать функцию age_categories(), чтобы легким образом разделить на категории и промаркировать числовые столбцы (примечание: эту функцию можно применить и к невозрастным числовым переменным). В качестве бонуса, получившийся столбец автоматически будет являться упорядоченным фактором.\nВот несколько требуемых входных данных:\n\nЧисловой вектор (столбец)\n\nАргумент breakers = - предоставляет числовой вектор точек разрыва на новые группы\n\nДля начала самый простой пример:\n\n# Простой пример\n################\npacman::p_load(epikit)                    # загружаем пакеты\n\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = age_categories(             # создаем новый столбец\n      age_years,                            # числовой столбец, из которого будут сделаны группы\n      breakers = c(0, 5, 10, 15, 20,        # точки разрыва\n                   30, 40, 50, 60, 70)))\n\n# показать таблицу\ntable(linelist$age_cat, useNA = \"always\")\n\n\n  0-4   5-9 10-14 15-19 20-29 30-39 40-49 50-59 60-69   70+  &lt;NA&gt; \n 1227  1223  1048   827  1216   597   251    78    27     7   107 \n\n\nЗначения точек разрыва, которые вы указываете, по умолчанию будут нижними порогами - т.е. они включаются в “более высокую” группу / группы “открыты” с нижней/левой стороны. Как показано ниже, вы можете добавить 1 к каждому значению разрыва, чтобы создать группы, которые будут открыты сверху/справа.\n\n# Включаем верхние границы для тех же категорий\n############################################\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      breakers = c(0, 6, 11, 16, 21, 31, 41, 51, 61, 71)))\n\n# показать таблицу\ntable(linelist$age_cat, useNA = \"always\")\n\n\n  0-5  6-10 11-15 16-20 21-30 31-40 41-50 51-60 61-70   71+  &lt;NA&gt; \n 1469  1195  1040   770  1149   547   231    70    24     6   107 \n\n\nВы можете скорректировать то, как будут отображаться подписи с помощью separator =. По умолчанию ставится “-”\nВы можете скорректировать обращение с верхними цифрами с помощью аргумента ceiling =. Чтобы задать верхний разрыв установите ceiling = TRUE. В таком случае будет предоставлено самое высокое значение разрыва, которое будет “потолком” и не будет создаваться категория “XX+”. Любые значения выше наивысшего разрыва (или upper =, если он определен) будут категоризироваьтся как NA. Ниже представлен пример, где ceiling = TRUE, поэтому нет категории XX+ и значениям выше 70 (самое высокое значение разрыва) присваивается значение NA.\n\n# устанавливаем потолок на TRUE (ИСТИНА)\n##########################\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70),\n      ceiling = TRUE)) # 70 - это потолок, все, что выше, становится NA\n\n# показать таблицу\ntable(linelist$age_cat, useNA = \"always\")\n\n\n  0-4   5-9 10-14 15-19 20-29 30-39 40-49 50-59 60-70  &lt;NA&gt; \n 1227  1223  1048   827  1216   597   251    78    28   113 \n\n\nАльтернативно вместо breakers = вы можете предоставить все значения для lower =, upper =, и by =:\n\nlower = самое нижнее число, которое вы хотите рассмотреть - по умолчанию 0\n\nupper = самое верхнее число, которое вы хотите рассмотреть\n\nby = количество лет между группами\n\n\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      lower = 0,\n      upper = 100,\n      by = 10))\n\n# показать таблицу\ntable(linelist$age_cat, useNA = \"always\")\n\n\n  0-9 10-19 20-29 30-39 40-49 50-59 60-69 70-79 80-89 90-99  100+  &lt;NA&gt; \n 2450  1875  1216   597   251    78    27     6     1     0     0   107 \n\n\nСм. справку по функции для получения дополнительной информации (введите ?age_categories в консоли R).\n\n\n\ncut()\ncut() - это альтернатива для age_categories() из базового R, но, я думаю, вы увидите, почему была разработана функция age_categories() для упрощения процесса. Некоторые заметные различия от age_categories() включают:\n\nВам не нужно устанавливать/загружать другой пакет\n\nВы можете уточнить, будут ли группы открыты/закрыты справа/слева\n\nВы можете сами задать точные подписи\n\nЕсли вы хотите, чтобы 0 был включен в самую нижнюю группу, вы должны это указать\n\nБазовый синтаксис внутри cut() - сначала задать числовой столбец, который нужно вырезать (age_years), и затем аргумент с разрывами, который является числовым вектором c() разрывов. При использовании cut(), получившийся в результате столбец будет упорядоченным фактором.\nПо умолчанию разделение на категории происходит таким образом, что правая/верхняя сторона является “открытой” и инклюзивной (а левая/нижняя сторона является “закрытой” или исключающей). Это поведение, противоположное функции age_categories(). По умолчанию подписи используют запись “(A, B]”, что означает, что A не включается, а B включается. Вы можете задать обратное поведение, указав аргумент right = TRUE.\nТаким образом, по умолчанию, значения “0” исключаются из самой нижней группы и категоризируются как NA! Значения “0” могут включать младенцев, закодированных как возраст 0, так что будьте осторожны! Чтобы это изменить, добавьте аргумент include.lowest = TRUE, чтобы любые значения с “0” включались в самую нижнюю группу. Автоматически сгенерированная подпись для самой нижней категории тогда будет “[A],B]”. Обратите внимание, что если вы включите аргумент include.lowest = TRUE и right = TRUE, экстремальное включение теперь будет применяться к наивысшему значению разрыва и категории, а не к самой нижней.\nВы можете задать вектор пользовательских подписей, используя аргумент labels =. Так как они записываются вручную, убедитесь, что они записаны правильно” Проверьте свою работу, используя кросс-табуляцию, как описано ниже.\nВ качестве примера применим cut() к age_years, чтобы создать новую переменную age_cat:\n\n# Создаем новую переменную, разделив числовую переменную возраста\n# нижний разрыв исключается, а верхний разрыв включен в каждую категорию\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = cut(\n      age_years,\n      breaks = c(0, 5, 10, 15, 20,\n                 30, 50, 70, 100),\n      include.lowest = TRUE         # включаем 0 в самую нижнюю группу\n      ))\n\n# подсчитываем количество наблюдений в каждой группе\ntable(linelist$age_cat, useNA = \"always\")\n\n\n   [0,5]   (5,10]  (10,15]  (15,20]  (20,30]  (30,50]  (50,70] (70,100] \n    1469     1195     1040      770     1149      778       94        6 \n    &lt;NA&gt; \n     107 \n\n\nПроверьте свою работу!!! Проверьте, что каждое значение возраста было распределено в правильную категорию, проведя кросс-табуляцию числовых и категориальных столбцов. Рассмотрите присвоение пограничных значений (например, 15, если соседние категории включают 10-15 и 16-20).\n\n# Кросс-табуляция числовыъ и категориальных столбцов. \ntable(\"Numeric Values\" = linelist$age_years,   # имена, указанные в таблице для ясности.\n      \"Categories\"     = linelist$age_cat,\n      useNA = \"always\")                        # не забудьте проверить значения NA\n\n                    Categories\nNumeric Values       [0,5] (5,10] (10,15] (15,20] (20,30] (30,50] (50,70]\n  0                    136      0       0       0       0       0       0\n  0.0833333333333333     1      0       0       0       0       0       0\n  0.25                   2      0       0       0       0       0       0\n  0.333333333333333      6      0       0       0       0       0       0\n  0.416666666666667      1      0       0       0       0       0       0\n  0.5                    6      0       0       0       0       0       0\n  0.583333333333333      3      0       0       0       0       0       0\n  0.666666666666667      3      0       0       0       0       0       0\n  0.75                   3      0       0       0       0       0       0\n  0.833333333333333      1      0       0       0       0       0       0\n  0.916666666666667      1      0       0       0       0       0       0\n  1                    275      0       0       0       0       0       0\n  1.5                    2      0       0       0       0       0       0\n  2                    308      0       0       0       0       0       0\n  3                    246      0       0       0       0       0       0\n  4                    233      0       0       0       0       0       0\n  5                    242      0       0       0       0       0       0\n  6                      0    241       0       0       0       0       0\n  7                      0    256       0       0       0       0       0\n  8                      0    239       0       0       0       0       0\n  9                      0    245       0       0       0       0       0\n  10                     0    214       0       0       0       0       0\n  11                     0      0     220       0       0       0       0\n  12                     0      0     224       0       0       0       0\n  13                     0      0     191       0       0       0       0\n  14                     0      0     199       0       0       0       0\n  15                     0      0     206       0       0       0       0\n  16                     0      0       0     186       0       0       0\n  17                     0      0       0     164       0       0       0\n  18                     0      0       0     141       0       0       0\n  19                     0      0       0     130       0       0       0\n  20                     0      0       0     149       0       0       0\n  21                     0      0       0       0     158       0       0\n  22                     0      0       0       0     149       0       0\n  23                     0      0       0       0     125       0       0\n  24                     0      0       0       0     144       0       0\n  25                     0      0       0       0     107       0       0\n  26                     0      0       0       0     100       0       0\n  27                     0      0       0       0     117       0       0\n  28                     0      0       0       0      85       0       0\n  29                     0      0       0       0      82       0       0\n  30                     0      0       0       0      82       0       0\n  31                     0      0       0       0       0      68       0\n  32                     0      0       0       0       0      84       0\n  33                     0      0       0       0       0      78       0\n  34                     0      0       0       0       0      58       0\n  35                     0      0       0       0       0      58       0\n  36                     0      0       0       0       0      33       0\n  37                     0      0       0       0       0      46       0\n  38                     0      0       0       0       0      45       0\n  39                     0      0       0       0       0      45       0\n  40                     0      0       0       0       0      32       0\n  41                     0      0       0       0       0      34       0\n  42                     0      0       0       0       0      26       0\n  43                     0      0       0       0       0      31       0\n  44                     0      0       0       0       0      24       0\n  45                     0      0       0       0       0      27       0\n  46                     0      0       0       0       0      25       0\n  47                     0      0       0       0       0      16       0\n  48                     0      0       0       0       0      21       0\n  49                     0      0       0       0       0      15       0\n  50                     0      0       0       0       0      12       0\n  51                     0      0       0       0       0       0      13\n  52                     0      0       0       0       0       0       7\n  53                     0      0       0       0       0       0       4\n  54                     0      0       0       0       0       0       6\n  55                     0      0       0       0       0       0       9\n  56                     0      0       0       0       0       0       7\n  57                     0      0       0       0       0       0       9\n  58                     0      0       0       0       0       0       6\n  59                     0      0       0       0       0       0       5\n  60                     0      0       0       0       0       0       4\n  61                     0      0       0       0       0       0       2\n  62                     0      0       0       0       0       0       1\n  63                     0      0       0       0       0       0       5\n  64                     0      0       0       0       0       0       1\n  65                     0      0       0       0       0       0       5\n  66                     0      0       0       0       0       0       3\n  67                     0      0       0       0       0       0       2\n  68                     0      0       0       0       0       0       1\n  69                     0      0       0       0       0       0       3\n  70                     0      0       0       0       0       0       1\n  72                     0      0       0       0       0       0       0\n  73                     0      0       0       0       0       0       0\n  76                     0      0       0       0       0       0       0\n  84                     0      0       0       0       0       0       0\n  &lt;NA&gt;                   0      0       0       0       0       0       0\n                    Categories\nNumeric Values       (70,100] &lt;NA&gt;\n  0                         0    0\n  0.0833333333333333        0    0\n  0.25                      0    0\n  0.333333333333333         0    0\n  0.416666666666667         0    0\n  0.5                       0    0\n  0.583333333333333         0    0\n  0.666666666666667         0    0\n  0.75                      0    0\n  0.833333333333333         0    0\n  0.916666666666667         0    0\n  1                         0    0\n  1.5                       0    0\n  2                         0    0\n  3                         0    0\n  4                         0    0\n  5                         0    0\n  6                         0    0\n  7                         0    0\n  8                         0    0\n  9                         0    0\n  10                        0    0\n  11                        0    0\n  12                        0    0\n  13                        0    0\n  14                        0    0\n  15                        0    0\n  16                        0    0\n  17                        0    0\n  18                        0    0\n  19                        0    0\n  20                        0    0\n  21                        0    0\n  22                        0    0\n  23                        0    0\n  24                        0    0\n  25                        0    0\n  26                        0    0\n  27                        0    0\n  28                        0    0\n  29                        0    0\n  30                        0    0\n  31                        0    0\n  32                        0    0\n  33                        0    0\n  34                        0    0\n  35                        0    0\n  36                        0    0\n  37                        0    0\n  38                        0    0\n  39                        0    0\n  40                        0    0\n  41                        0    0\n  42                        0    0\n  43                        0    0\n  44                        0    0\n  45                        0    0\n  46                        0    0\n  47                        0    0\n  48                        0    0\n  49                        0    0\n  50                        0    0\n  51                        0    0\n  52                        0    0\n  53                        0    0\n  54                        0    0\n  55                        0    0\n  56                        0    0\n  57                        0    0\n  58                        0    0\n  59                        0    0\n  60                        0    0\n  61                        0    0\n  62                        0    0\n  63                        0    0\n  64                        0    0\n  65                        0    0\n  66                        0    0\n  67                        0    0\n  68                        0    0\n  69                        0    0\n  70                        0    0\n  72                        1    0\n  73                        3    0\n  76                        1    0\n  84                        1    0\n  &lt;NA&gt;                      0  107\n\n\nСмена подписи значений NA\nВам может потребоваться присвоить значениям NA подпись, например, “Missing” (отсутствует). Поскольку новый столбец относится к классу Фактор (ограниченные значения), вы не можете просто использовать replace_na(), поскольку это значение будет отклонено. Вместо этого используйте fct_explicit_na() из пакета forcats, как объясняется на странице Факторы.\n\nlinelist &lt;- linelist %&gt;% \n  \n  # cut() создает age_cat, автоматически в классе Фактор      \n  mutate(age_cat = cut(\n    age_years,\n    breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          \n    right = FALSE,\n    include.lowest = TRUE,        \n    labels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\", \"20-29\", \"30-49\", \"50-69\", \"70-100\")),\n         \n    # делает отсутствующие значения явными\n    age_cat = fct_explicit_na(\n      age_cat,\n      na_level = \"Missing age\")  # вы можете задать подпись\n  )    \n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `age_cat = fct_explicit_na(age_cat, na_level = \"Missing age\")`.\nCaused by warning:\n! `fct_explicit_na()` was deprecated in forcats 1.0.0.\nℹ Please use `fct_na_value_to_level()` instead.\n\n# таблица для просмотра подсчета\ntable(linelist$age_cat, useNA = \"always\")\n\n\n        0-4         5-9       10-14       15-19       20-29       30-49 \n       1227        1223        1048         827        1216         848 \n      50-69      70-100 Missing age        &lt;NA&gt; \n        105           7         107           0 \n\n\nБыстрое создание разрывов и подписей\nДля быстрого создания разрывов и векторов подписей можно использовать код ниже. См. страницу Основы R для получения информации о seq() и rep().\n\n# Создание разрывов от 0 до 90 с шагом 5\nage_seq = seq(from = 0, to = 90, by = 5)\nage_seq\n\n# Создание подписей для созданных выше категорий, предполагая настройки cut() по умолчанию\nage_labels = paste0(age_seq + 1, \"-\", age_seq + 5)\nage_labels\n\n# Проверьте, что оба вектора имеют одинаковую длину\nlength(age_seq) == length(age_labels)\n\nБолее подробно о cut() можно прочитать на странице Справки, введя ?cut в консоли R.\n\n\nРазрывы по квантилям\nКак правило, “квантили” или “процентили” означают значение, ниже которого находится определенная доля значений. Например, 95-й процентиль возрастов в linelist будет возраст, ниже которого находится 95% всех возрастов.\nОднако в простой речи “квартили” и “децили” могут также означать группы данных, равномерно разделенных на 4 или 10 групп (обратите внимание, будет на один разрыв больше, чем групп).\nЧтобы получить разрывы по квантилям, можете использовать quantile() из пакета stats из базового R. Вы задаете числовой вектор (например, столбец в наборе данных) и вектор значений числовой вероятности, варьирующихся от 0 до 1.0. Разрывы будут выданы как числовой вектор. Детали статистической методологии можно изучить, введя ?quantile.\n\nЕсли у вашего входного числового вектора есть какие-то отсутствующие значения, лучше установить na.rm = TRUE\n\nЗадайте names = FALSE, чтобы получить неименованный числовой вектор\n\n\nquantile(linelist$age_years,               # укажите числовой вектор, с которым надо работать\n  probs = c(0, .25, .50, .75, .90, .95),   # укажите, какие процентили вам нужны\n  na.rm = TRUE)                            # игнорировать отсутствующие значения \n\n 0% 25% 50% 75% 90% 95% \n  0   6  13  23  33  41 \n\n\nВы можете использовать результаты quantile() в качестве разрывов в age_categories() или cut(). Ниже мы создаем новый столбец deciles, используя cut(), где разрывы задаются с использованием quantiles() для age_years. Ниже мы отображаем результаты, используя tabyl() из пакета janitor, чтобы вы могли увидеть проценты (см. страницу Описательные таблицы). Обратите внимание, что они не составляют точно 10% в каждой группе.\n\nlinelist %&gt;%                                # начинаем с построчного списка\n  mutate(deciles = cut(age_years,           # создаем новый столбец decile через cut() по столбцу age_years\n    breaks = quantile(                      # определяем разрывы, используя quantile()\n      age_years,                               # операция для age_years\n      probs = seq(0, 1, by = 0.1),             # от 0.0 до 1.0 с шагом 0.1\n      na.rm = TRUE),                           # игнорировать отсутствующие значения\n    include.lowest = TRUE)) %&gt;%             # для cut() включите возраст 0\n  janitor::tabyl(deciles)                   # передайте по каналу для создания таблицы для отображения\n\n deciles   n    percent valid_percent\n   [0,2] 748 0.11319613    0.11505922\n   (2,5] 721 0.10911017    0.11090601\n   (5,7] 497 0.07521186    0.07644978\n  (7,10] 698 0.10562954    0.10736810\n (10,13] 635 0.09609564    0.09767728\n (13,17] 755 0.11425545    0.11613598\n (17,21] 578 0.08746973    0.08890940\n (21,26] 625 0.09458232    0.09613906\n (26,33] 596 0.09019370    0.09167820\n (33,84] 648 0.09806295    0.09967697\n    &lt;NA&gt; 107 0.01619249            NA\n\n\n\n\nГруппы равного размера\nЕще один инструмент для создания числовых групп - функция ntile() из пакета dplyr, которая попробует разбить ваши данные на n групп равного размера - но помните, что в отличие от quantile(), одно и то же значение может появиться в нескольких группах. Задайте числовой вектор и затем количество групп. Значения в новом созданном столбце - просто “номера” групп (например, от 1 до 10), а не диапазон самих значений, как при использовании cut().\n\n# создаем группы с помощью ntile()\nntile_data &lt;- linelist %&gt;% \n  mutate(even_groups = ntile(age_years, 10))\n\n# создаем таблицу с подсчетом количества и пропорциями по группам\nntile_table &lt;- ntile_data %&gt;% \n  janitor::tabyl(even_groups)\n  \n# присваиваем мин/макс значения, чтобы продемонстрировать диапазоны\nntile_ranges &lt;- ntile_data %&gt;% \n  group_by(even_groups) %&gt;% \n  summarise(\n    min = min(age_years, na.rm=T),\n    max = max(age_years, na.rm=T)\n  )\n\nWarning: There were 2 warnings in `summarise()`.\nThe first warning was:\nℹ In argument: `min = min(age_years, na.rm = T)`.\nℹ In group 11: `even_groups = NA`.\nCaused by warning in `min()`:\n! no non-missing arguments to min; returning Inf\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\n# объединяем и печатаем - обратите внимание, что значения присутствуют в нескольких группах\nleft_join(ntile_table, ntile_ranges, by = \"even_groups\")\n\n even_groups   n    percent valid_percent min  max\n           1 651 0.09851695    0.10013844   0    2\n           2 650 0.09836562    0.09998462   2    5\n           3 650 0.09836562    0.09998462   5    7\n           4 650 0.09836562    0.09998462   7   10\n           5 650 0.09836562    0.09998462  10   13\n           6 650 0.09836562    0.09998462  13   17\n           7 650 0.09836562    0.09998462  17   21\n           8 650 0.09836562    0.09998462  21   26\n           9 650 0.09836562    0.09998462  26   33\n          10 650 0.09836562    0.09998462  33   84\n          NA 107 0.01619249            NA Inf -Inf\n\n\n\n\n\ncase_when()\nМожно использовать функцию case_when() из dplyr для создания категорий из числового столбца, но легче использовать age_categories() из epikit или cut(), поскольку они автоматически создадут упорядоченный фактор.\nПри использовании case_when(), пожалуйста, проверьте правильность использования, как описывалось выше в разделе по перекодированию данной страницы. Также помните, что значения в правой стороне должны быть одного класса. Так что, если вы хотите видеть NA справа, вам следует написать “Missing” или использовать специальное значение NA в виде NA_character_.\n\n\nДобавление в цепочку канала\nНиже код для создания двух категориальных столбцов возраста добавляется в цепочку канала вычистки:\n\n# ЦЕПОЧКА КАНАЛА ВЫЧИСТКИ (начинается с сырых данных, которые передаются по шагам вычистки)\n##################################################################################\n\n# начало цепочки канала вычистки\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # стандартизируем синтаксис имен столбцов\n    janitor::clean_names() %&gt;% \n    \n    # переименовываем столбцы вручную\n           # НОВОЕ имя             # СТАРОЕ имя\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # удаляем столбцы\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # дедупликация\n    distinct() %&gt;% \n\n    # добавляем столбец\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %&gt;%     \n\n    # конвертируем класс столбцов\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %&gt;% \n    \n    # добавляем столбец: задержка госпитализации\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %&gt;% \n    \n    # чистые значения столбца hospital\n    mutate(hospital = recode(hospital,\n                      # СТАРОЕ = НОВОЕ\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %&gt;% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %&gt;% \n\n    # создаем столбец age_years (из age и age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age)) %&gt;% \n  \n    # ВЫШЕ ПОКАЗАНЫ РАНЕЕ ПРОДЕЛАННЫЕ И ПРЕДСТАВЛЕННЫЕ ШАГИ ВЫЧИСТКИ\n    ###################################################   \n    mutate(\n          # возрастные категории: пользовательские\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # возрастные категории: от 0 до 85 по 5 лет\n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Вычистка данных и ключевые функции</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.ru.html#добавление-строк",
    "href": "new_pages/cleaning.ru.html#добавление-строк",
    "title": "8  Вычистка данных и ключевые функции",
    "section": "8.10 Добавление строк",
    "text": "8.10 Добавление строк\n\nПо одной\nДобавление строк вручную по одной является трудоемким процессом, но это можно сделать с помощью add_row() из пакета dplyr. Помните, что каждый столбец должен содержать значения только из одного класса (либо текстовые, либо числовые, либо логические и т.п.). Поэтому добавление строки требует определенных нюансов для сохранения этой структуры.\n\nlinelist &lt;- linelist %&gt;% \n  add_row(row_num = 666,\n          case_id = \"abc\",\n          generation = 4,\n          `infection date` = as.Date(\"2020-10-10\"),\n          .before = 2)\n\nИспользуйте .before и .after. для уточнения места размещения добавляемой строки. .before = 3 разместит новую строку перед текущей 3-й строкой. По умолчанию строка добавляется в конце. Не уточненные столбцы останутся пустыми (NA).\nНовый номер строки может выглядеть странно (“…23”) но номера строк ранее существовавших строк изменились. Поэтому если вы дважды используете команду, внимательно рассмотрите/протестируйте вставку.\nЕсли класс, который вы задаете, не сходится, возникнет такое сообщение об ошибке:\nError: Can't combine ..1$infection date &lt;date&gt; and ..2$infection date &lt;character&gt;\n(При вставке строки со значением даты, помните, что нужно дату нужно указать в функции as.Date(), например, as.Date(\"2020-10-10\")).\n\n\nСвязывание строк\nЧтобы объединить наборы данных путем связывания строк одного датафрейма с нижней частью другого датафрейма, вы можете использовать bind_rows() из пакета dplyr. Это более подробно объясняется на странице Соединение данных.",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Вычистка данных и ключевые функции</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.ru.html#фильтрация-строк",
    "href": "new_pages/cleaning.ru.html#фильтрация-строк",
    "title": "8  Вычистка данных и ключевые функции",
    "section": "8.11 Фильтрация строк",
    "text": "8.11 Фильтрация строк\nТипичный шаг вычистки после того, как вы провели вычистку столбцов и перекодировали значения, включает фильтрацию датафрейма до конкретных строк, используя глагольную функцию filter() из пакета dplyr.\nВнутри функции filter(), увкажите логику, которая должна быть истинной TRUE, чтобы сохранить строку в наборе данных. Ниже мы покажем, как отфильтровать строки на основе простых и сложных логических условий.\n\n\nПростой фильтр\nЭтот простой пример переопределяет датафрейм linelist как самого себя после фильтрации строк, чтобы они соответствовали логическому условию. Сохраняются только те строки, где логическое утверждение внутри скобок оценивается как истинное TRUE.\nВ данном примере логическим утверждением является gender == \"f\", которое проверяет, является ли значение в столбце gender равным “f” (чувствительно к регистру).\nДо применения фильтра количество строк в linelist равно nrow(linelist).\n\nlinelist &lt;- linelist %&gt;% \n  filter(gender == \"f\")   # сохраняются только те строки, где пол равен \"f\"\n\nПосле применения фильтра количество строк в linelist равно linelist %&gt;% filter(gender == \"f\") %&gt;% nrow().\n\n\nОтфильтровывание отсутствующих значений\nДостаточно часто нужно отфильтровывать строки, в которых имеются отсутствующие значения. Не поддавайтесь желанию просто записать filter(!is.na(column) & !is.na(column)), а вместо этого используйте функцию tidyr, которая специально создана для этой цели: drop_na(). При выполнении с пустыми скобками она удаляет строки с любыми отсутствующими значениями. Альтернативно, вы можете указать имена конкретных столбцов, которые надо оценить на предмет отсутствия значений, либо использовать функции-помощники “tidyselect”, описанные выше.\n\nlinelist %&gt;% \n  drop_na(case_id, age_years)  # удаляет строки с отсутствующими значениями в case_id или age_years\n\nСм. страницу Отсутствующие данные, где показаны многие приемы для анализа и управления отсутствующими значениями в ваших данных.\n\n\nФильтр по номеру строки\nВ датафрейме или таблице tibble у каждой строки, как правило, будет “номер строки”, который (при просмотре в окне просмотра R Viewer) появляется слева от первого столбца. Этот номер сам по себе не является истинным столбцом данных, но он может быть использован в утверждении для filter().\nЧтобы отфильтровать по “номеру строки”, вы можете использовать функцию row_number() из dplyr с открытыми скобками, как часть логического утверждения для фильтрации. Часто нужно использовать оператор %in% и диапазон чисел как часть логического утверждения, как показано ниже. Чтобы увидеть первое N количество строк, вы можете также использовать специальную функцию из dplyr head().\n\n# Просмотр первых 100 строк\nlinelist %&gt;% head(100)     # или используйте tail(), чтобы просмотреть последнее n количество строк\n\n# Показать только 5 строку\nlinelist %&gt;% filter(row_number() == 5)\n\n# Просмотреть строки с 2 по 20, а также три конкретных столбца\nlinelist %&gt;% filter(row_number() %in% 2:20) %&gt;% select(date_onset, outcome, age)\n\nВы также можете конвертировать номера строк в истинный столбец, передав ваш датафрейм в функцию tibble rownames_to_column() (ничего не пишите в скобках).\n\n\n\nСложный фильтр\nМожно выстроить более сложные логические утверждения с использованием скобок ( ), операторов ИЛИ |, отрицание !, %in%, а также И &. Пример приведен ниже:\nПримечание: Вы можете использовать оператор ! перед логическим критериями, чтобы их отрицать. Например, !is.na(column) оценивает как истину, если значения столбца не отсутствует. Аналогично, !column %in% c(\"a\", \"b\", \"c\") оценивает как истину, если значение столбца не является вектором.\n\nРассмотрение данных\nНиже представлена простая команда из одной строки для создания гистограммы даты заболевания. Обратите внимание, что вторая более мелкая вспышка 2012-2013 гг. также включена в этот сырой набор данных. Для нашего анализа нам нужно удалить записи по этой более ранней вспышке.\n\nhist(linelist$date_onset, breaks = 50)\n\n\n\n\n\n\n\n\n\n\nКак фильтры работают с отсутствующими числовыми значениями и датами\nМожем ли мы просто отфильтровать по date_onset до строк только после июня 2013? Внимание! Применение кода filter(date_onset &gt; as.Date(\"2013-06-01\"))) удалит строки в более поздней эпидемии с отсутствующей датой заболевания!\nВНИМАНИЕ: Фильтра по больше чем (&gt;) или меньше чем (&lt;) дата или число может удалить любые строки с отсутствующими значениями (NA)! Это происходит потому, что NA рассматривается как бесконечно большое или малое число.\n(См. страницу Работа с датами для получения более детальной информации о работе с датами и пакете lubridate)\n\n\nДизайн фильтра\nРассмотрите кросс-табуляцию, чтобы убедиться, что мы исключили только нужные строки:\n\ntable(Hospital  = linelist$hospital,                     # название больницы\n      YearOnset = lubridate::year(linelist$date_onset),  # год в date_onset\n      useNA     = \"always\")                              # показать отсутствующие значения\n\n                                      YearOnset\nHospital                               2012 2013 2014 2015 &lt;NA&gt;\n  Central Hospital                        0    0  351   99   18\n  Hospital A                            229   46    0    0   15\n  Hospital B                            227   47    0    0   15\n  Military Hospital                       0    0  676  200   34\n  Missing                                 0    0 1117  318   77\n  Other                                   0    0  684  177   46\n  Port Hospital                           9    1 1372  347   75\n  St. Mark's Maternity Hospital (SMMH)    0    0  322   93   13\n  &lt;NA&gt;                                    0    0    0    0    0\n\n\nПо каким еще критериям мы можем отфильтровать для удаления первой вспышки (в 2012 и2013) из набора данных? Мы видим, что:\n\nПервая эпидемия в 2012 и 2013 годах произошла в больницах Hospital A, Hospital B, а также было 10 случаев в Port Hospital.\n\nБольницы Hospitals A и B не имели случаев во второй эпидемии, а в Port Hospital они были.\n\nМы хотим исключить:\n\nnrow(linelist %&gt;% filter(hospital %in% c(\"Hospital A\", \"Hospital B\") | date_onset &lt; as.Date(\"2013-06-01\"))) строк и началом в 2012 и 2013 в больницах hospital A, B, или Port:\n\nИсключить nrow(linelist %&gt;% filter(date_onset &lt; as.Date(\"2013-06-01\"))) строк с началом в 2012 и 2013\nИсключить nrow(linelist %&gt;% filter(hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset))) строк из Hospitals A и B с отсутствующими датами заболевания\n\nНе исключать nrow(linelist %&gt;% filter(!hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset))) других строк с отсутствующими датами заболевания.\n\n\nМы начинаем с пострточного списка из nrow(linelist)` строк. Ниже представлено наше утверждение для фильтра:\n\nlinelist &lt;- linelist %&gt;% \n  # сохраняет строки, где дата заболевания после 1 июня 2013 ИЛИ где отсутствует дата заболевания и это была больница КРОМЕ Hospital A или B\n  filter(date_onset &gt; as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))\n\nnrow(linelist)\n\n[1] 6019\n\n\nКогда мы повторно делаем кросс-табуляцию, мы видим, что Hospitals A и B были полностью удалены, также удалены 10 случаев из больницы Port Hospital от 2012 и 2013 года, а другие значения остались - как мы и хотели.\n\ntable(Hospital  = linelist$hospital,                     # название больницы\n      YearOnset = lubridate::year(linelist$date_onset),  # год date_onset\n      useNA     = \"always\")                              # показать отсутствующие значения\n\n                                      YearOnset\nHospital                               2014 2015 &lt;NA&gt;\n  Central Hospital                      351   99   18\n  Military Hospital                     676  200   34\n  Missing                              1117  318   77\n  Other                                 684  177   46\n  Port Hospital                        1372  347   75\n  St. Mark's Maternity Hospital (SMMH)  322   93   13\n  &lt;NA&gt;                                    0    0    0\n\n\nВ одну команду фильтра можно включить несколько утверждений (отделенных запятыми), либо вы всегда можете поставить в канал отдельную команду filter() для ясности.\nПримечание: некоторые читатели могут заметить, что было бы проще просто отфильтровать по date_hospitalisation, поскольку этот столбец заполнен на 100% без отсутствующих значений. Это верно. Но date_onset использовался для демонстрации сложного фильтра.\n\n\n\nОтдельная команда\nФильтрацию можно также выполнять как отдельную команду (не как часть цепочки канала). Как и другие глагольные функции dplyr, в данном случае первым аргументом должен быть сам набор данных.\n\n# датафрейм &lt;- фильтр(датафрейм, условие(я) для сохранения строк)\n\nlinelist &lt;- filter(linelist, !is.na(case_id))\n\nВы можете также использовать базовый R, для выделения подмножества, используя квадратные скобки, которые отражают [строки, столбцы], которые вы хотите сохранить.\n\n# датафрейм &lt;- датафрейм[условия строки, условия столбца] (пустое пространство означает сохранить все)\n\nlinelist &lt;- linelist[!is.na(case_id), ]\n\n\n\nБыстрое рассмотрение записей\nЧасто вам может быть необходимо быстро просмотреть несколько записей только по некоторым столбцам. Базовая функция R View() напечатает датафрейм для просмотра в RStudio.\nПросмотр построчного списка в RStudio:\n\nView(linelist)\n\nЗдесь приведены два примера просмотра конкретных ячеек (конкретные строки и конкретные столбцы):\nС функциями dplyr filter() и select():\nВ функции View() передайте набор данных в функцию filter(), чтобы сохранить определенные строки, затем select() для сохранения определенных столбцов. Например, чтобы рассмотреть даты заболевания и госпитализации по 3 конкретным случаям:\n\nView(linelist %&gt;%\n       filter(case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\")) %&gt;%\n       select(date_onset, date_hospitalisation))\n\nВы можете сделать то же самое с синтаксисом базового R, используя квадратные скобки [ ], чтобы определить подмножество, которое вы хотите видеть.\n\nView(linelist[linelist$case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\"), c(\"date_onset\", \"date_hospitalisation\")])\n\n\nДобавление в цепочку канала\n\n# ЦЕПОЧКА КАНАЛА ВЫЧИСТКИ (начинается с сырых данных, которые передаются по шагам вычистки)\n##################################################################################\n\n# начало цепочки канала вычистки\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # стандартизируем синтаксис имен столбцов\n    janitor::clean_names() %&gt;% \n    \n    # переименовываем столбцы вручную\n           # НОВОЕ имя             # СТАРОЕ имя\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # удаляем столбцы\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # дедупликация\n    distinct() %&gt;% \n\n    # добавляем столбец\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %&gt;%     \n\n    # конвертируем класс столбцов\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %&gt;% \n    \n    # добавляем столбец: задержка госпитализации\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %&gt;% \n    \n    # чистые значения столбца hospital\n    mutate(hospital = recode(hospital,\n                      # СТАРОЕ = НОВОЕ\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %&gt;% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %&gt;% \n\n    # создаем столбец age_years (из age и age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age)) %&gt;% \n  \n    mutate(\n          # возрастные категории: пользовательские\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # возрастные категории: от 0 до 85 по 5 лет\n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5))) %&gt;% \n    \n    # ВЫШЕ ПОКАЗАНЫ РАНЕЕ ПРОДЕЛАННЫЕ И ПРЕДСТАВЛЕННЫЕ ШАГИ ВЫЧИСТКИ\n    ###################################################\n    filter(\n          # сохраняем только строки, где case_id не отсутствует\n          !is.na(case_id),  \n          \n          # также фильтруем, чтобы сохранить только вторую вспышку\n          date_onset &gt; as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Вычистка данных и ключевые функции</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.ru.html#построчные-расчеты",
    "href": "new_pages/cleaning.ru.html#построчные-расчеты",
    "title": "8  Вычистка данных и ключевые функции",
    "section": "8.12 Построчные расчеты",
    "text": "8.12 Построчные расчеты\nЕсли вы хотите провести расчеты внутри строки, вы можете использовать функцию rowwise() из dplyr. См. эту онлайн виньетку по построчным расчетам.\nНапример, этот код применяет rowwise() и затем создает новый столбец, который складывает количество указанных столбцов симптомов, которые имеют значение “yes” (да), для каждой строки в построчном списке. Столбцы указываются внутри функции sum() по имени внутри вектора c(). rowwise(), по сути, является особым типом group_by(), так что лучше использовать ungroup(), когда вы закончите (см. страницу Группирование данных).\n\nlinelist %&gt;%\n  rowwise() %&gt;%\n  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == \"yes\")) %&gt;% \n  ungroup() %&gt;% \n  select(fever, chills, cough, aches, vomit, num_symptoms) # for display\n\n# A tibble: 5,888 × 6\n   fever chills cough aches vomit num_symptoms\n   &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;        &lt;int&gt;\n 1 no    no     yes   no    yes              2\n 2 &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;            NA\n 3 &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;            NA\n 4 no    no     no    no    no               0\n 5 no    no     yes   no    yes              2\n 6 no    no     yes   no    yes              2\n 7 &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;            NA\n 8 no    no     yes   no    yes              2\n 9 no    no     yes   no    yes              2\n10 no    no     yes   no    no               1\n# ℹ 5,878 more rows\n\n\nПри указании столбцов для оценки вы можете использовать функции-помощники “tidyselect”, описанные в разделе select() данной страницы. Вам может потребоваться лишь одна корректировка (поскольку вы не используете их внутри функции dplyr, такой как select() или summarise()).\nПоместите критерии, уточняющие столбец, внутрь функции c_across() из dplyr. Это необходимо сделать, поскольку c_across (документация) разработан для работы конкретно с rowwise(). Например, следующий код:\n\nПрименяет rowwise(), так что следующая операция (sum()) применяется к каждой строке (не сумма по всем столбцам)\n\nСоздает новый столбец num_NA_dates, определенный для каждой строки как число столбцов (с именем, содержащим “date”), для которого is.na() оценивается как TRUE (истина) (в них отсутствуют данные).\n\nungroup() для удаления эффектов от применения rowwise() для последующих шагов\n\n\nlinelist %&gt;%\n  rowwise() %&gt;%\n  mutate(num_NA_dates = sum(is.na(c_across(contains(\"date\"))))) %&gt;% \n  ungroup() %&gt;% \n  select(num_NA_dates, contains(\"date\")) # для отображения\n\n# A tibble: 5,888 × 5\n   num_NA_dates date_infection date_onset date_hospitalisation date_outcome\n          &lt;int&gt; &lt;date&gt;         &lt;date&gt;     &lt;date&gt;               &lt;date&gt;      \n 1            1 2014-05-08     2014-05-13 2014-05-15           NA          \n 2            1 NA             2014-05-13 2014-05-14           2014-05-18  \n 3            1 NA             2014-05-16 2014-05-18           2014-05-30  \n 4            1 2014-05-04     2014-05-18 2014-05-20           NA          \n 5            0 2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n 6            0 2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n 7            0 2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n 8            0 2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n 9            1 NA             2014-06-05 2014-06-06           2014-06-18  \n10            1 NA             2014-06-05 2014-06-07           2014-06-09  \n# ℹ 5,878 more rows\n\n\nВы также можете задать другие функции, такие как max(), чтобы получить последнюю или наиболее недавнюю дату для каждой строки:\n\nlinelist %&gt;%\n  rowwise() %&gt;%\n  mutate(latest_date = max(c_across(contains(\"date\")), na.rm=T)) %&gt;% \n  ungroup() %&gt;% \n  select(latest_date, contains(\"date\"))  # для отображения\n\n# A tibble: 5,888 × 5\n   latest_date date_infection date_onset date_hospitalisation date_outcome\n   &lt;date&gt;      &lt;date&gt;         &lt;date&gt;     &lt;date&gt;               &lt;date&gt;      \n 1 2014-05-15  2014-05-08     2014-05-13 2014-05-15           NA          \n 2 2014-05-18  NA             2014-05-13 2014-05-14           2014-05-18  \n 3 2014-05-30  NA             2014-05-16 2014-05-18           2014-05-30  \n 4 2014-05-20  2014-05-04     2014-05-18 2014-05-20           NA          \n 5 2014-05-29  2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n 6 2014-05-24  2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n 7 2014-06-01  2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n 8 2014-06-07  2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n 9 2014-06-18  NA             2014-06-05 2014-06-06           2014-06-18  \n10 2014-06-09  NA             2014-06-05 2014-06-07           2014-06-09  \n# ℹ 5,878 more rows",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Вычистка данных и ключевые функции</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.ru.html#упорядочивание-и-сортировка",
    "href": "new_pages/cleaning.ru.html#упорядочивание-и-сортировка",
    "title": "8  Вычистка данных и ключевые функции",
    "section": "8.13 Упорядочивание и сортировка",
    "text": "8.13 Упорядочивание и сортировка\nИспользуйте функцию arrange() из dplyr для сортировки или упорядочивания строк по значениям столбцов.\nПросто перечислите столбцы в порядке, в котором они должны быть отсортированы. Укажите .by_group = TRUE, если вы хотите, чтобы сортировка сначала произошла по любым группировкам, применяемым к данным (см. страницу Группирование данных).\nПо умолчанию столбец будет отсортирован в “возрастающем” порядке (который применяется как к числовым, так и текстовым столбцам). Вы можете отсортировать переменную в “убывающем” порядке, обернув ее в desc().\nСортировка данных с помощью arrange() особенно полезна, когда вы готовите Таблицы для презентации, используя slice(), чтобы взять “верхние” строки в каждой группе, либо чтобы задать порядок уровня факторов по порядку появления.\nНапример, чтобы отсортировать строки нашего построчного списка по больницам hospital, затем по дате заболевания date_onset в убывающем порядке, мы используем:\n\nlinelist %&gt;% \n   arrange(hospital, desc(date_onset))",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Вычистка данных и ключевые функции</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.ru.html",
    "href": "new_pages/dates.ru.html",
    "title": "9  Работа с датами",
    "section": "",
    "text": "9.1 Подготовка",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Работа с датами</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.ru.html#подготовка",
    "href": "new_pages/dates.ru.html#подготовка",
    "title": "9  Работа с датами",
    "section": "",
    "text": "Загрузка пакетов\nЭтот фрагмент кода показывает загрузку пакетов, необходимых для данной страницы. В этом руководстве мы подчеркиваем использование p_load() из пакета pacman, которая устанавливает пакет, если необходимо, и загружает его для использования. Вы можете также загрузить установленные пакеты с помощью library() из базового R. См. страницу Основы R для получения более подробной информации о пакетах R.\n\n# Проверяет, установлен ли пакет, устанавливает, если необходимо, и загружает пакет для текущей сессии\n\npacman::p_load(\n  lubridate,  # общий пакет для работы и конвертации дат  \n  parsedate,   # имеет функцию для \"угадывания\" хаотичных дат\n  aweek,      # еще один вариант конвертации дат в недели, а недель - в даты\n  zoo,        # дополнительные функции даты/времени\n  here,       # управление файлами\n  tidyverse,  # управление данными и визуализация  \n  rio)        # импорт/экспорт данных\n\n\n\nИмпорт данных\nМы импортируем набор данных по случаям из имитационной эпидемии Эболы. Если вы хотите скачать эти данные и повторять все шаги, см. инструкции на странице Скачивание руководства и данных. Мы предполагаем, что файл находится в рабочей директории, поэтому в пути к файлу не указаны подпапки.\n\nlinelist &lt;- import(\"linelist_cleaned.xlsx\")",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Работа с датами</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.ru.html#текущая-дата",
    "href": "new_pages/dates.ru.html#текущая-дата",
    "title": "9  Работа с датами",
    "section": "9.2 Текущая дата",
    "text": "9.2 Текущая дата\nВы можете получить текущую “системную” дату или системное датувремя вашего компьютера, выполнив следующую команду из базового R.\n\n# получить системную дату - это класс ДАТА\nSys.Date()\n\n[1] \"2024-05-10\"\n\n# получить системное время - это класс ДАТАВРЕМЯ\nSys.time()\n\n[1] \"2024-05-10 06:13:42 CEST\"\n\n\nПри использовании пакета lubridate эти же сведения вы можете получить через today() и now(), соответственно. date() даст вам текущую дату и время с указанием дня недели и названием месяца.",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Работа с датами</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.ru.html#конвертация-в-дату",
    "href": "new_pages/dates.ru.html#конвертация-в-дату",
    "title": "9  Работа с датами",
    "section": "9.3 Конвертация в дату",
    "text": "9.3 Конвертация в дату\nПосле импорта набора данных в R, значения столбца даты могут выглядеть как “1989/12/30”, “05/06/2014”, или “13 Jan 2020”. В таких случаях R, вероятно, все еще рассматривает эти значения как текстовый класс. R нужно указать, что эти значения являются датами… и каков формат даты (какая часть означает день, какая - месяц, какая - год и т.п.).\nКак только это будет задано, R конвертирует эти значения в класс Дата. Фоново R сохранит даты как числа (количество дней с даты отсчета 1 января 1970). Вы не часто будете видеть это число даты, но это позволяет R рассматривать даты как непрерывные переменные, а также позволяет проводить специальные операции, такие как расчет дистанции между датами.\nПо умолчанию значения класса Дата в R отображаются в формате ГГГГ-ММ-ДД. Позднее в этом разделе мы обсудим, как менять отображение значений даты.\nНиже мы представляем два подхода к конвертации столбцы из текстового класса в Дату.\nСОВЕТ: Вы можете проверить текущий класс столбца с функцией из базового R class(), например, class(linelist$date_onset).\n\nбазовый R\nas.Date() является стандартной функцией базового R для конвертации объекта или столбца в класс Date (Дата) (обратите внимание на заглаувную “D”).\nИспользование as.Date() требует, чтобы:\n\nВы уточнили существующий формат сырой текстовой даты или дату отсчета, если даты заданы как числа (см. раздел Даты в Excel)\n\nПри использовании для текстового столбца все значения должны быть абсолютно в идентичном формате (если это не так, попробуйте parse_date() из пакета parsedate)\n\nВо-первых, проверьте класс вашего столбца с помощью class() из базового R. Если вы не уверены или запутались в классе ваших данных (например, вы видите “POSIXct” и т.п.), может быть проще сначала конвертировать столбец в текстовый класс с помощью as.character(), а затем конвертировать его в класс Даты.\nВо-вторых, внутри функции as.Date() используйте аргумент format =, чтобы указать R текущий формат текстовых компонентов даты - какие знаки означают месяц, какие - день, а какие - год и то, как они отделены. Если ваши значения уже находятся в одном из стандартных форматов даты в R (“ГГГГ-ММ-ДД” или “ГГГГ/ММ/ДД”) аргумент format = не обязателен.\nВ аргументе format = задайте текстовую последовательность (в кавычках), которая представляет собой текущий формат даты, используя специальные сокращения “strptime”, представленные ниже. Например, если ваши текстовые даты сейчас заданы в формате “ДД/ММ/ГГГГ”, как “24/04/1968”, тогда вы используете format = \"%d/%m/%Y\" для конвертации значений в даты. Необходимо поместить формат в кавычки. И не забудьте дефисы или слэши!\n\n# Конвертация в класс даты\nlinelist &lt;- linelist %&gt;% \n  mutate(date_onset = as.Date(date_of_onset, format = \"%d/%m/%Y\"))\n\nБольшинство сокращений strptime перечислены ниже. Вы можете увидеть полный список, выполнив ?strptime.\n%d = Номер дня месяца (5, 17, 28, и т.п.)\n%j = Номер дня года (день по Юлианскому календарю 001-366)\n%a = Сокращенный день недели (Mon, Tue, Wed, и т.п.)\n%A = Полный день недели (Monday, Tuesday, и т.п.) %w = Номер дня недели (0-6, где воскресенье - это 0)\n%u = Номер дня недели (1-7, где понедельник - это 1)\n%W = Номер недели (00-53, начало недели в понедельник)\n%U = Номер недели (01-53, начало недели в воскресенье)\n%m = Номер месяца (например, 01, 02, 03, 04)\n%b = Сокращенный месяц (Jan, Feb, и т.п.)\n%B = Полный месяц (January, February, и т.п.)\n%y = 2-значный год (например, 89)\n%Y = 4-значный год (например, 1989)\n%h = часы (24-часовые часы)\n%m = минуты\n%s = секунды %z = Отсчет от GMT\n%Z = Часовой пояс (текстовый)\nСОВЕТ: Аргумент format = в функции as.Date() не говорит R, в каком формате вы хотите, чтобы была дата, а скорее показывает, как определить части даты до выполнения команды.\nСОВЕТ: Убедитесь, что в аргументе format = вы используете разделитель частей даты (например, /, -, или пробел), который используется в ваших датах.\nКак только значения будут в классе Дата, R по умолчанию отобразит их в стандартном формате, а именно ГГГГ-ММ-ДД.\n\n\nlubridate\nКонвертация текстовых объектов в даты может быть упрощена с пакетом lubridate. Это пакет из tidyverse, разработанный для облегчения и более последовательной работы с датами и временем, чем в базовом R. По этим причинам lubridate часто считается золотым стандартом для использования для даты и времени и всегда рекомендуется при работе с ними.\nПакет lubridate предоставляет несколько функций-помощников, разработанных для конвертации текстовых объектов в даты интуитивно понятным и удобным образом, чем указание формата через as.Date(). Эти функции специфичны для приблизительного формата даты, но распознают ряд разделителей и синонимов дат (например, 01 или Jan или January) - они названы по аббревиатурам форматов даты.\n\n# установка/загрузка lubridate \npacman::p_load(lubridate)\n\nФункция ymd() гибко конвертирует значения даты, представленыне в формате год, потом месяц, потом день.\n\n# чтение даты в формате год-месяц-день\nymd(\"2020-10-11\")\n\n[1] \"2020-10-11\"\n\nymd(\"20201011\")\n\n[1] \"2020-10-11\"\n\n\nФункция mdy() гибко конвертирует значения даты, представленные в формате месяц, потом день, потом год.\n\n# чтение даты в формате месяц-день-год\nmdy(\"10/11/2020\")\n\n[1] \"2020-10-11\"\n\nmdy(\"Oct 11 20\")\n\n[1] \"2020-10-11\"\n\n\nФункция dmy() гибко конвертирует значения даты, представленные в формате день, потом месяц, потом год.\n\n# чтение даты в формате день-месяц-год\ndmy(\"11 10 2020\")\n\n[1] \"2020-10-11\"\n\ndmy(\"11 October 2020\")\n\n[1] \"2020-10-11\"\n\n\n\n\n\n\nЕсли используете канал, конвертация текстового столбца в даты с помощью lubridate может выглядеть следующим образом:\n\nlinelist &lt;- linelist %&gt;%\n  mutate(date_onset = lubridate::dmy(date_onset))\n\nПосле завершения вы можете выполнить команду class(), чтобы проверить класс столбца\n\n# Проверка класса столбца\nclass(linelist$date_onset)  \n\nКак только значения будут в классе Даты, R по умолчанию отобразит их в стандартном формате, то есть ГГГГ-ММ-ДД.\nОбратите внимание, что указанные выше функции лучше всего работают с четырехзначными годами. 2-значные годы могут дать неожиданные результаты, поскольку lubridate будет пытаться угадать век.\nЧтобы конвертировать 2-значный год в 4-значный (все в одном веке), вы можете конвертировать в текстовый класс и затем объединить существующие знаки с префиксом, используя str_glue() из пакета stringr (см. Текст и последовательности). Затем конвертировать в дату.\n\ntwo_digit_years &lt;- c(\"15\", \"15\", \"16\", \"17\")\nstr_glue(\"20{two_digit_years}\")\n\n2015\n2015\n2016\n2017\n\n\n\n\nОбъединение столбцов\nВы можете использовать функции lubridate make_date() и make_datetime() для объединения нескольких числовых столбцов в один столбец даты. Например, у вас могут быть числовые столбцы onset_day (день заболевания), onset_month (месяц заболевания) и onset_year (год заболевания) в датафрейме linelist:\n\nlinelist &lt;- linelist %&gt;% \n  mutate(onset_date = make_date(year = onset_year, month = onset_month, day = onset_day))",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Работа с датами</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.ru.html#даты-excel",
    "href": "new_pages/dates.ru.html#даты-excel",
    "title": "9  Работа с датами",
    "section": "9.4 Даты Excel",
    "text": "9.4 Даты Excel\nФоново большинство программ хранят даты как числа. R хранит даты с точки отсчета 1го января 1970 года. Таким образом, если вы выполните as.numeric(as.Date(\"1970-01-01)) вы получите 0.\nMicrosoft Excel хранит даты с точкой отсчета либо 30 декабря 1899 (Windows) или 1 января 1904 (Mac), в зависимости от вашей операционной системы. См. это руководство Microsoft для получения более детальной информации.\nДаты Excel часто импортируются в R как эти числовые значения, а не текст. Если набор данных, который вы импортировали из Excel, показывает даты как числа или знаки в формате “41369”… используйте as.Date() (или функцию as_date() из lubridate) для конвертации, но вместо указания “формата”, как мы это делали выше, укажите дату отсчета Excel в аргументе origin =.\nЭто не сработает, если дата Excel хранится в R в текстовом типе, поэтому убедитесь, что число находится в числовом классе!\nПРИМЕЧАНИЕ: Вы должны указать дату отсчета в формате даты по умолчанию для R (“ГГГГ-ММ-ДД”).\n\n# Пример предоставления 'даты отсчета' Excel при конвертации числовых дат Excel\ndata_cleaned &lt;- data %&gt;% \n  mutate(date_onset = as.numeric(date_onset)) %&gt;%   # убедитесь, что класс числовой\n  mutate(date_onset = as.Date(date_onset, origin = \"1899-12-30\")) # Конвертируйте в дату, используя точку отсчета Excel",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Работа с датами</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.ru.html#хаотичные-даты",
    "href": "new_pages/dates.ru.html#хаотичные-даты",
    "title": "9  Работа с датами",
    "section": "9.5 Хаотичные даты",
    "text": "9.5 Хаотичные даты\nФункция parse_date() из пакета parsedate попытается прочитать столбец с “хаотичными” датами, содержащий даты в разных форматах, и конвертировать даты в стандартный формат. Вы можете прочитать больше деталей о parse_date() онлайн.\nНапример, parse_date() увидит вектор следующих текстовых дат “03 Jan 2018”, “07/03/1982” и “08/20/85” и конвертирует их в класс Дата в виде: 2018-01-03, 1982-03-07 и 1985-08-20.\n\nparsedate::parse_date(c(\"03 January 2018\",\n                        \"07/03/1982\",\n                        \"08/20/85\"))\n\n[1] \"2018-01-03 UTC\" \"1982-07-03 UTC\" \"1985-08-20 UTC\"\n\n\n\n# Пример использования parse_date() в столбце date_onset\nlinelist &lt;- linelist %&gt;%      \n  mutate(date_onset = parse_date(date_onset))",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Работа с датами</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.ru.html#работа-с-классом-дата-время",
    "href": "new_pages/dates.ru.html#работа-с-классом-дата-время",
    "title": "9  Работа с датами",
    "section": "9.6 Работа с классом дата-время",
    "text": "9.6 Работа с классом дата-время\nКак указывалось ранее, R также поддерживает класс datetime - столбец, который содержит информацию о дате и времени. Как и в случае с классом Date, их часто нужно конвертировать из текстовых объектов character в объекты датывремени datetime.\n\nКонвертация дат со временем\nСтандартный объект datetime форматируется с указанием сначала даты, а затем компонента времени - например, 01 Jan 2020, 16:30. Как и в случае с датами, существует много способов форматирования, а также существует ряд уровней точности (часы, минуты, секунды).\nК счастью, также существуют функции-помощники lubridate для конвертации этих последовательностей в объекты datetime. Эти функции являются расширениями функций-помощников по дате, с добавлением _h (указаны только часы), _hm (указаны часы и минуты) или _hms (указаны часы, минуты и секунды) в конце (например, dmy_hms()). Их можно использовать следующим образом:\nКонвертация датывремени только с часами в объект датывремени\n\nymd_h(\"2020-01-01 16hrs\")\n\n[1] \"2020-01-01 16:00:00 UTC\"\n\nymd_h(\"2020-01-01 4PM\")\n\n[1] \"2020-01-01 16:00:00 UTC\"\n\n\nКонвертация датывремени с часами и минутами в объект датывремени\n\ndmy_hm(\"01 January 2020 16:20\")\n\n[1] \"2020-01-01 16:20:00 UTC\"\n\n\nКонвертация датывремени с часами,минутами и секундами в объект датывремени\n\nmdy_hms(\"01 January 2020, 16:20:40\")\n\n[1] \"2020-01-20 16:20:40 UTC\"\n\n\nВы можете указать часовой пояс, но он игнорируется. См. раздел ниже по часовым поясам.\n\nmdy_hms(\"01 January 2020, 16:20:40 PST\")\n\n[1] \"2020-01-20 16:20:40 UTC\"\n\n\nПри работе с датафреймом, столбцы времени и даты можно объединить, чтобы создать столбец датавремя, используя str_glue() из пакета stringr и соответствующую функцию lubridate. См. страницу Текст и последовательности для получения детальной информации о stringr.\nВэтом примере в датафрейме linelist есть столбец в формате “часы:минуты”. Чтобы конвертировать его в датувремя, мы выполняем несколько шагов:\n\nСоздаем столбец “чистое” время госпитализации, где отсутствующие значения заполняются медианным значением столбца. Мы это делаем, поскольку lubridate не будет работать с отсутствующими значениями. Объедините со столбцом date_hospitalisation, а затем используйте для конвертации функцию ymd_hm().\n\n\n# пакеты\npacman::p_load(tidyverse, lubridate, stringr)\n\n# time_admission - это столбец в формате часы:минуты\nlinelist &lt;- linelist %&gt;%\n  \n  # когда время госпитализации не указано, присвойте медианное время госпитализации\n  mutate(\n    time_admission_clean = ifelse(\n      is.na(time_admission),         # если время отсутствует\n      median(time_admission),        # присваиваем медиану\n      time_admission                 # если не отсутствует, оставить как есть\n  ) %&gt;%\n  \n    # используйте str_glue() для объединения столбцов дата и время для создания одного текстового столбца\n    # затем используйте ymd_hm() для конвертации в датувремя\n  mutate(\n    date_time_of_admission = str_glue(\"{date_hospitalisation} {time_admission_clean}\") %&gt;% \n      ymd_hm()\n  )\n\n\n\nКонвертация только времени\nЕсли ваши данные содержат только текстовое время (часы и минуты), вы можете их конвертировать и манипулировать как временем, используя strptime() из базового R. Например, чтобы получить разницу между двумя значениями времени:\n\n# сырое текстовое время\ntime1 &lt;- \"13:45\" \ntime2 &lt;- \"15:20\"\n\n# Время конвертируется в класс датавремя\ntime1_clean &lt;- strptime(time1, format = \"%H:%M\")\ntime2_clean &lt;- strptime(time2, format = \"%H:%M\")\n\n# Разница по умолчанию в классе \"difftime\", здесь конвертируется в числовые часы \nas.numeric(time2_clean - time1_clean)   # разница в часах\n\n[1] 1.583333\n\n\nОбратите внимание, что без указания значения даты, система предполагает, что эта дата - сегодня. Чтобы объединить последовательность даты и последовательность времени, см. раздел stringr выше. Дополнительную информацию о strptime() можно получить тут.\nЧтобы конвертировать однозначные цифры в двухзначные (например, добавить нули к часам или минутам, чтобы получить два знака), см. раздел “Наращивание длины” страницы Текст и последовательности.\n\n\nИзвлечение времени\nВы можете извлечь элементы времени с помощью hour(), minute() или second() из lubridate.\nНиже приведен пример извлечения часа и затем классификации по времени суток. Мы начинаем со столбца time_admission, который относится к текстовому классу в формате “ЧЧ:ММ”. Сначала используется strptime(), как описано выше, чтобы конвертировать текст в класс датывремени. Затем извлекаем час с помощью hour(), что даст нам число от 0-24. Наконец, создается столбец time_period, используя логику с помощью case_when() для классификации строк на утро/день/вечер/ночь в зависимости от часа госпитализации.\n\nlinelist &lt;- linelist %&gt;%\n  mutate(hour_admit = hour(strptime(time_admission, format = \"%H:%M\"))) %&gt;%\n  mutate(time_period = case_when(\n    hour_admit &gt; 06 & hour_admit &lt; 12 ~ \"Morning\",\n    hour_admit &gt;= 12 & hour_admit &lt; 17 ~ \"Afternoon\",\n    hour_admit &gt;= 17 & hour_admit &lt; 21 ~ \"Evening\",\n    hour_admit &gt;=21 | hour_admit &lt;= 6 ~ \"Night\"))\n\nЧтобы получить дополнительную информацию о фукнции case_when(), см. страницу Вычистка данных и ключевые функции.",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Работа с датами</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.ru.html#работа-с-датами",
    "href": "new_pages/dates.ru.html#работа-с-датами",
    "title": "9  Работа с датами",
    "section": "9.7 Работа с датами",
    "text": "9.7 Работа с датами\nМожно также использовать lubridate для ряда других функций, например, для извлечения определенных аспектов даты/времени, проведения арифметических расчетов с датой, либо расчета интервала дат\nНиже мы определяем дату для использования в данном примере:\n\n# создаем объект в классе Дата\nexample_date &lt;- ymd(\"2020-03-01\")\n\n\nИзвлекаем компоненты даты\nМожно извлечь общие аспекты, такие как месяц, день, день недели:\n\nmonth(example_date)  # номер месяца\n\n[1] 3\n\nday(example_date)    # день (номер) в месяце\n\n[1] 1\n\nwday(example_date)   # номер дня недели (1-7)\n\n[1] 1\n\n\nВы можете также извлечь компоненты времени из объекта или столбца datetime. Это может быть полезно, если вы хотите увидеть распределение времени госпитализации.\n\nexample_datetime &lt;- ymd_hm(\"2020-03-01 14:45\")\n\nhour(example_datetime)     # извлекаем час\nminute(example_datetime)   # извлекаем минуту\nsecond(example_datetime)   # извлекаем секунду\n\nСуществует ряд вариантов для извлечения недель. См. раздел Эпидемиологические недели ниже.\nОбратите внимание, что если вы стремитесь отобразить дату определенным образом (например, “Jan 2020” или “Thursday 20 March” или “Week 20, 1977”), вы можете это более гибко сделать в соответствии с описанием в разделе Отображение даты.\n\n\nВычисления с датами\nВы можете добавить определенное количество дней или недель, используя соответствующую функцию из lubridate.\n\n# добавляем 3 дня к этой дате\nexample_date + days(3)\n\n[1] \"2020-03-04\"\n\n# добавляем 7 недель и отнимаем два дня от этой даты\nexample_date + weeks(7) - days(2)\n\n[1] \"2020-04-17\"\n\n\n\n\nИнтервалы дат\nРазницу между датами можно рассчитать следующим образом:\n\nУбедитесь, что обе даты относятся к классу дата\n\nИспользуйте вычитание, чтобы получить разницу “difftime” между двумя датами\n\nЕсли необходимо, конвертируйте результат в числовой класс, чтобы провести дальнейшие математические расчеты\n\nНиже рассчитывается и отображается интервал между двумя датами. Вы можете найти интервалы, используя знак вычитания “минус” для значений, которые относятся к классу Дата. Однако обратите внимание, что класс выданного значения будет “difftime”, как указано ниже, и его нужно конвертировать в числовой.\n\n# находим интервал между этой датой и 20 февраля 2020 \noutput &lt;- example_date - ymd(\"2020-02-20\")\noutput    # печать\n\nTime difference of 10 days\n\nclass(output)\n\n[1] \"difftime\"\n\n\nЧтобы провести дальнейшие операции с разницей времени “difftime”, конвертируйте ее в числовой формат с помощью as.numeric().\nЭто все можно соединить для работы с данными - например:\n\npacman::p_load(lubridate, tidyverse)   # загружаем пакеты\n\nlinelist &lt;- linelist %&gt;%\n  \n  # конвертируем дату заболевания из текстового класса в объект даты, указав формат dmy\n  mutate(date_onset = dmy(date_onset),\n         date_hospitalisation = dmy(date_hospitalisation)) %&gt;%\n  \n  # отфильтровываем все случаи, не имеющие дату заболевания в марте\n  filter(month(date_onset) == 3) %&gt;%\n    \n  # находим разницу дней между заболеванием и госпитализацией\n  mutate(days_onset_to_hosp = date_hospitalisation - date_of_onset)\n\nВ контексте датафрейма, если одна из указанных выше дат отсутствует, операция будет неуспешна для этой строки. Это приведет к результату NA вместо числового значения. Когда вы используете этот столбец для расчетов, убедитесь, что вы задали аргумент na.rm = как TRUE. Например:\n\n# рассчитываем медианное количество дней до госпитализации для всех случаев, где имеются данные\nmedian(linelist_delay$days_onset_to_hosp, na.rm = T)",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Работа с датами</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.ru.html#отображение-даты",
    "href": "new_pages/dates.ru.html#отображение-даты",
    "title": "9  Работа с датами",
    "section": "9.8 Отображение даты",
    "text": "9.8 Отображение даты\nКак только даты относятся к правильному классу, часто вам их нужно отобразить в другом виде, например, “Monday 05 January” вместо “2018-01-05”. Вам может быть также необходимо откорректировать отображение, чтобы потом сгруппировать строки по отображенным элементам даты - например, по месяцу-году.\n\nformat()\nКорректируйте отображение даты с помощью функции из базового R format(). Эта функция принимает последовательность знаков (в кавычках), указывающую желаемый формат на выходе в виде сокращений “%” strptime (тот же синтаксис используется для as.Date()). Ниже приведены наиболее частые сокращения.\nПримечание: использование format() конвертирует значения в текстовый класс, поэтому, как правило, эта операция проводится в конце анализа и только для целей отображения! Полный список вы можете увидеть, выполнив команду ?strptime.\n%d = номер дня месяца (5, 17, 28, и т.п.)\n%j = номер дня года (дни по Юлианскому календарю 001-366)\n%a = сокращенный день недели (Mon, Tue, Wed, и т.п.)\n%A = полный день недели (Monday, Tuesday, и т.п.)\n%w = номер дня недели (0-6, где воскресенье - 0)\n%u = номер дня недели (1-7, где понедельник - 1)\n%W = номер недели (00-53, понедельник - начало недели)\n%U = номер недели (01-53, воскресенье - начало недели)\n%m = номер месяца (например, 01, 02, 03, 04)\n%b = сокращенный месяц (Jan, Feb, и т.п.)\n%B = полный месяц (January, February, и т.п.)\n%y = 2-значный год (например, 89)\n%Y = 4-значный год (например, 1989)\n%h = часы (24-часовые часы)\n%m = минуты\n%s = секунды\n%z = отсчет от GMT\n%Z = часовой пояс (текстовый)\nПример форматирования сегодняшней даты:\n\n# сегодняшняя дата с форматированием\nformat(Sys.Date(), format = \"%d %B %Y\")\n\n[1] \"10 May 2024\"\n\n# легкий способ получения полной даты и времени (форматирование по умолчанию)\ndate()\n\n[1] \"Fri May 10 06:13:43 2024\"\n\n# отформатированные комбинированные дата, время и часовой пояс, используя функцию str_glue()\nstr_glue(\"{format(Sys.Date(), format = '%A, %B %d %Y, %z  %Z, ')}{format(Sys.time(), format = '%H:%M:%S')}\")\n\nFriday, May 10 2024, +0000  UTC, 06:13:43\n\n# Использование формата для отображения недель\nformat(Sys.Date(), \"%Y Week %W\")\n\n[1] \"2024 Week 19\"\n\n\nОбратите внимание, что при использовании str_glue() необходимо помнить, что внутри ожидаемых двойных кавычек ” вы должны использовать одинарные кавычки (как показано выше).\n\n\nМесяц-Год\nЧтобы конвертировать столбец даты в формат месяц-год, мы предлагаем использовать функцию as.yearmon() из пакета zoo. Она конвертирует дату в класс “yearmon” и сохраняет правильный порядок. Для сравнения, использование format(column, \"%Y %B\") конвертирует в текстовый класс и упорядочит значения алфавитно (неправильно).\nНиже создается новый столбец yearmonth из столбца date_onset, используя функцию as.yearmon(). Упорядочивание по умолчанию (правильное) полученных в результате значений показано в таблице.\n\n# создаем новый столбец \ntest_zoo &lt;- linelist %&gt;% \n     mutate(yearmonth = zoo::as.yearmon(date_onset))\n\n# печать таблицы\ntable(test_zoo$yearmon)\n\n\nApr 2014 May 2014 Jun 2014 Jul 2014 Aug 2014 Sep 2014 Oct 2014 Nov 2014 \n       7       64      100      226      528     1070     1112      763 \nDec 2014 Jan 2015 Feb 2015 Mar 2015 Apr 2015 \n     562      431      306      277      186 \n\n\nДля сравнения, вы можете увидеть, что format() даст желаемый формат отображения, но не даст правильного порядка.\n\n# создаем новый столбец\ntest_format &lt;- linelist %&gt;% \n     mutate(yearmonth = format(date_onset, \"%b %Y\"))\n\n# печать таблицы\ntable(test_format$yearmon)\n\n\nApr 2014 Apr 2015 Aug 2014 Dec 2014 Feb 2015 Jan 2015 Jul 2014 Jun 2014 \n       7      186      528      562      306      431      226      100 \nMar 2015 May 2014 Nov 2014 Oct 2014 Sep 2014 \n     277       64      763     1112     1070 \n\n\nПримечание: Если вы работаете в рамках ggplot() и хотите откорректировать только то, как отображаются даты, может быть достаточно просто задать формат в аргументе date_labels = в scale_x_date() - вы можете использовать \"%b %Y\" или \"%Y %b\". См. страницу советы по использованию ggplot.\nzoo также предлагает функцию as.yearqtr(), и вы можете использовать scale_x_yearmon() при использовании ggplot().",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Работа с датами</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.ru.html#dates_epi_wks",
    "href": "new_pages/dates.ru.html#dates_epi_wks",
    "title": "9  Работа с датами",
    "section": "9.9 Эпидемиологические недели",
    "text": "9.9 Эпидемиологические недели\n\nlubridate\nСм. страницу [Группирование данных] для получения более подробных примеров по группированию данных по дате. Ниже мы кратко рассказываем о группировании данных по неделям.\nМы, как правило, рекомендуем использовать функцию floor_date() из lubridate с аргументом unit = \"week\". Это округляет дату в меньшую сторону до “начала” недели, которое задано аргументом week_start =. По умолчанию неделя начинается на 1 (для понедельников), но вы можете уточнить любой день недели, как ее начало (например, 7 для воскресенья). floor_date() является очень гибкой и может использоваться для округления в нижнюю сторону других единиц времени, установив unit = на “second” (секунда), “minute” (минута), “hour” (час), “day” (день), “month” (месяц), или “year” (год).\nПолученное значение - дата начала недели в классе Дата. Класс Дата полезен при построении графика данных, поскольку его легко сможет распознать и упорядочить ggplot().\nЕсли вас интересует только корректировка дат для отображения по неделям на графике, см. раздел на этой странице по Отображению данных. Например, при построении эпидкривой вы можете отформатировать отображение даты путем указания необходимой вам номенклатуры strptime “%”. Например, используйте “%Y-%W” или “%Y-%U”, чтобы получить год и номер недели (с началом недели в понедельник или воскресенье, соответственно).\n\n\nЕженедельное количество\nСм. страницу [Группирование данных], где приводится детальное объяснение группирования данных с помощью count(), group_by() и summarise(). Краткий пример представлен ниже.\n\nСоздайте новый столбец ‘week’ с помощью mutate(), используя floor_date() с unit = \"week\"\n\nПодсчитайте количество строк (случаев) в неделю с помощью count(); отфильтруйте случаи с отсутствующей датой\n\nЗавершите функцией complete() из tidyr, чтобы убедиться, что все недели отразились в данных - даже те, где нет строк/случаев. По умолчанию значения подсчета для любых “новых” строк - NA, но вы можете превратить их в 0 с помощью аргумента fill =, который ожидает именованного списка (ниже n - это имя столбца с подсчетом количества).\n\n\n# Создаем агрегированный набор данных еженедельного количества случаев\nweekly_counts &lt;- linelist %&gt;% \n  drop_na(date_onset) %&gt;%             # удаляем случаи с отсутствующей датой заболевания\n  mutate(weekly_cases = floor_date(   # создаем новый столбец, неделя заболевания\n    date_onset,\n    unit = \"week\")) %&gt;%            \n  count(weekly_cases) %&gt;%           # группируем данные по неделе и считаем количество строк в группе (создает столбец 'n')\n  tidyr::complete(                  # убедитесь, что все недели есть в наличии, даже те, в которых не зарегистрировано случаев\n    weekly_cases = seq.Date(          # переопределение столбца \"weekly_cases\" в качестве полной последовательности,\n      from = min(weekly_cases),       # от минимальной даты\n      to = max(weekly_cases),         # до максимальной даты\n      by = \"week\"),                   # по неделям\n    fill = list(n = 0))             # заполняем NA в столбце подсчета количества n цифрой 0\n\nЗдесь вы видите первые строки получившегося датафрейма:\n\n\n\n\n\n\n\n\nАльтернативы для эпиднедель\nОбратите внимание, что в lubridate также есть функции week(), epiweek() и isoweek(), у каждой из которых немного разные даты начала и другие нюансы. В целом, вам должно быть достаточно floor_date(). Детальную информацию об этих функциях можно прочитать, введя ?week в консоль, либо вы можете прочитать документацию тут.\nВы можете рассмотреть возможность использования пакета aweek, чтобы задать эпидемиологические недели. Более детально вы можете почитать о нем на сайте RECON. В нем есть функции date2week() и week2date(), в которых вы можете установить день начала недели с помощью week_start = \"Monday\". Этот пакет самый простой, если вам нужны выходные данные в неделях (например, “2020-W12”). Еще одним преимуществом aweek является то, что когда применяется date2week() к столбцу даты, полученный в результате столбец (формат недели) автоматически классифицируется как фактор и включает уровни для всех недель во временном диапазоне (это позволяет избежать дополнительного шага с complete(), который описывался выше). Однако aweek не имеет функционала по округлению дат до других единиц времени, таких как месяцы, годы и т.п.\nЕще одной альтернативой для временных рядов, которая также хорошо работает, является демонстрация формата “недель” (“2020 W12”) с помощью yearweek() из пакета tsibble, что демонстрируется на странице [Временные ряды и обнаружение вспышек].",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Работа с датами</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.ru.html#конвертация-датчасовых-поясов",
    "href": "new_pages/dates.ru.html#конвертация-датчасовых-поясов",
    "title": "9  Работа с датами",
    "section": "9.10 Конвертация дат/часовых поясов",
    "text": "9.10 Конвертация дат/часовых поясов\nКогда данные представлены в разных часовых поясах, часто важной будет стандартизация этих данных в едином часовом поясе. Это может стать дополнительной проблемой, поскольку компонент часового пояса в данных нужно кодировать вручную в большинстве случаев.\nВ R каждый объект датывремени имеет компонент часового пояса. По умолчанию все объекты датывремени будут относиться к местному часовому поясу, в котором работает компьютер, как правило, это устанавливается по локали, а не по именованному часовому поясу, так как время в локали может меняться на зимнее/летнее время. Невозможно провести правильную компенсацию часовых поясов без компонента времени для даты, поскольку событие, которое представляет столбец даты, не может быть отнесено к конкретному времени, следовательно, невозможно правильно учесть промежутки времени в часах.\nДля работы с часовыми поясами существует ряд функций-помощников в lubridate, которые можно использовать для изменения часового пояса объекта датывремени с местного на другой часовой пояс. Часовые пояса устанавливаются путем присваивания действительного часового пояса из базы данных tz объекту датафрейма. Этот список можно найти здесь - если локаль, из которой вы используете данные, не включена в этот список, доступны соседние крупные города в том же часовом поясе, которые могут быть использованы для этих целей.\nhttps://en.wikipedia.org/wiki/List_of_tz_database_time_zones\n\n# присваиваем столбцу текущее время\ntime_now &lt;- Sys.time()\ntime_now\n\n[1] \"2024-05-10 06:13:44 CEST\"\n\n# используем with_tz(), чтобы присвоить столбцу новый часовой пояс, при этом МЕНЯЯ время на часах\ntime_london_real &lt;- with_tz(time_now, \"Europe/London\")\n\n# use force_tz(), чтобы присвоить столбцу новый часовой пояс, при этом СОХРАНЯЯ время на часах\ntime_london_local &lt;- force_tz(time_now, \"Europe/London\")\n\n\n# Обратите внимание, что если компьютер, используемый для выполнения этого кода работает НЕ по Лондонскому времени,\n# возникнет разница во времени \n# (количество часов разницы между часовым поясом компьютера и Лондоном)\ntime_london_real - time_london_local\n\nTime difference of -1 hours\n\n\nЭто может показаться абстрактной концепцией, и часто она даже вам не нужна, кроме случаев, когда вы работаете с разными часовыми поясами.",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Работа с датами</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.ru.html#отстающие-и-опережающие-расчеты",
    "href": "new_pages/dates.ru.html#отстающие-и-опережающие-расчеты",
    "title": "9  Работа с датами",
    "section": "9.11 Отстающие и опережающие расчеты",
    "text": "9.11 Отстающие и опережающие расчеты\nlead() и lag() - функции из пакета dplyr, которые помогают найти предыдущее (отстающее) или последующее (опережающее) значение вектора - как правило, числового вектора или вектора даты. Это полезно при проведении расчетов изменения/разницы между единицами времени.\nПредставим, что вам нужно рассчитать разницу случаев между текущей неделей и предыдущей. Данные изначально представлены в количестве в неделю, как показано ниже.\n\n\n\n\n\n\nПри использовании lag() или lead() очень важен порядок строк в датафрейме! - обращайте внимание на то, ваши даты/числа находятся в возрастающем или убывающем порядке\nСначала создадим новый столбец, содержащий значение предыдущей (отстающей) недели.\n\nКонтролируйте число единиц назад/вперед с помощью n = (должно быть не отрицательным целым числом)\n\nИспользуйте default =, чтобы определить значение, размещенное в несуществующих строках (например, первая строка, по которой нет отстающего значения). По умолчанию это будет NA.\n\nИспользуйте order_by = TRUE, если ваши строки не упорядочены по вашему референс столбцу.\n\n\ncounts &lt;- counts %&gt;% \n  mutate(cases_prev_wk = lag(cases_wk, n = 1))\n\n\n\n\n\n\n\nДалее создаем новый столбец, который является разницей между двумя столбцами случаев:\n\ncounts &lt;- counts %&gt;% \n  mutate(cases_prev_wk = lag(cases_wk, n = 1),\n         case_diff = cases_wk - cases_prev_wk)\n\n\n\n\n\n\n\nВы можете более подробно прочитать о lead() и lag() в документации тут, либо введя в консоли ?lag.",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Работа с датами</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.ru.html#ресурсы",
    "href": "new_pages/dates.ru.html#ресурсы",
    "title": "9  Работа с датами",
    "section": "9.12 Ресурсы",
    "text": "9.12 Ресурсы\nlubridate страница tidyverse\nlubridate RStudio шпаргалка\nR for Data Science страница даты и время\nОнлайн самоучитель Форматы даты",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Работа с датами</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.ru.html",
    "href": "new_pages/characters_strings.ru.html",
    "title": "10  Текст и последовательности",
    "section": "",
    "text": "10.1 Подготовка",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Текст и последовательности</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.ru.html#подготовка",
    "href": "new_pages/characters_strings.ru.html#подготовка",
    "title": "10  Текст и последовательности",
    "section": "",
    "text": "Загрузка пакетов\nУстановите или загрузите stringr и другие пакеты tidyverse.\n\n# установка/загрузка пакетов\npacman::p_load(\n  stringr,    # много функций для работы с последовательностями\n  tidyverse,  # для опциональных манипуляций с данными\n  tools)      # альтернативы для капитализации всех слов\n\n\n\nИмпорт данных\nНа этой странице мы иногда ссылаемся на вычищенный построчный список случаев linelist по имитационной эпидемии Эболы. Если вы хотите параллельно выполнять действия, кликните, чтобы скачать “чистый” построчный список (as .rds file). Импортируйте данные с помощою функции import() из пакета rio (она может работать с разными типами файлов, такими как .xlsx, .csv, .rds - см. страницу Импорт и экспорт для получения детальной информации).\n\n# импорт построчного списка случаев \nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nПервые 50 строк построчного списка отображены ниже.",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Текст и последовательности</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.ru.html#объединение-разделение-и-упорядочивание",
    "href": "new_pages/characters_strings.ru.html#объединение-разделение-и-упорядочивание",
    "title": "10  Текст и последовательности",
    "section": "10.2 Объединение, разделение и упорядочивание",
    "text": "10.2 Объединение, разделение и упорядочивание\nВ этом разделе разбирается:\n\nИспользование str_c(), str_glue() и unite() для объединения последовательностей\n\nИспользование str_order() для упорядочивания последовательностей\n\nИспользование str_split() и separate() для разделения последовательностей\n\n\n\nОбъединение последовательностей\nЧтобы объединить или сцепить несколько последовательностей в одну, мы предлагаем использовать str_c из пакета stringr. Если у вас есть конкретные текстовые значения для объединения, просто задайте их как уникальные аргументы, разделенные запятыми.\n\nstr_c(\"String1\", \"String2\", \"String3\")\n\n[1] \"String1String2String3\"\n\n\nАргумент sep = вставляет текстовое значение между каждым из аргументов, которые вы задали (например, вставляет запятую, пробел или новую строку \"\\n\")\n\nstr_c(\"String1\", \"String2\", \"String3\", sep = \", \")\n\n[1] \"String1, String2, String3\"\n\n\nАргумент collapse = актуален, если вы закладываете несколько векторов в виде аргументов в str_c(). Он используется для разделения элементов того, что должно стать выходным вектором, так чтобы у выходного вектора был только один длинный текстовый элемент.\nПример ниже показывает комбинирование двух векторов в один (имена и фамилии). Еще одним похожим примером могут быть юрисдикции и количество случаев. В данном примере:\n\nЗначение sep = появляется между каждым именем и фамилией\n\nЗначение collapse = появляется между каждым человеком\n\n\nfirst_names &lt;- c(\"abdul\", \"fahruk\", \"janice\") \nlast_names  &lt;- c(\"hussein\", \"akinleye\", \"okeke\")\n\n# sep отображается между соответствующими входными последовательностями, а collapse отображается между созданными элементами\nstr_c(first_names, last_names, sep = \" \", collapse = \";  \")\n\n[1] \"abdul hussein;  fahruk akinleye;  janice okeke\"\n\n\nПримечание: В зависимости от желаемого контекста отображения при печати такой объединенной последовательности с новыми строками, вам может потребоваться обернуть всю фразу в cat(), чтобы новые строки правильно напечатались:\n\n# Чтобы новые строки были напечатаны правильно, возможно, потребуется обернуть всю фразу в cat()\ncat(str_c(first_names, last_names, sep = \" \", collapse = \";\\n\"))\n\nabdul hussein;\nfahruk akinleye;\njanice okeke\n\n\n\n\n\nДинамические последовательности\nИспользуйте str_glue(), чтобы вставить динамический код R в последовательность. Это очень полезная функция для создания динамических подписей к графикам, как показано ниже.\n\nВсе содержимое размещается внутри двойных кавычек str_glue(\"\")\n\nЛюбой динамический код или ссылки на заранее определенные значения размещаются в фигурных скобках {} внутри двойных кавычек. В одной команде str_glue() может быть много фигурных скобок.\n\nЧтобы отобразить текстовые кавычки ’’, используйте одинарные кавычки внутри двойных кавычек (например, при указании формата даты - см. пример ниже)\n\nСовет: вы можете использовать \\n, чтобы принудительно перейти на новую строку\n\nСовет: вы можете использовать format(), чтобы откорректировать отображение даты, и использовать Sys.Date(), чтобы отобразить текущую дату.\n\nПростой пример динамической подписи к графику:\n\nstr_glue(\"Data include {nrow(linelist)} cases and are current to {format(Sys.Date(), '%d %b %Y')}.\")\n\nData include 5888 cases and are current to 10 May 2024.\n\n\nАльтернативный формат - использовать заполнители внутри скобок, а код определить в отдельном аргументе в конце функции str_glue(), как показано ниже. Это может повысить читаемость кода, если текст длинный.\n\nstr_glue(\"Linelist as of {current_date}.\\nLast case hospitalized on {last_hospital}.\\n{n_missing_onset} cases are missing date of onset and not shown\",\n         current_date = format(Sys.Date(), '%d %b %Y'),\n         last_hospital = format(as.Date(max(linelist$date_hospitalisation, na.rm=T)), '%d %b %Y'),\n         n_missing_onset = nrow(linelist %&gt;% filter(is.na(date_onset)))\n         )\n\nLinelist as of 10 May 2024.\nLast case hospitalized on 30 Apr 2015.\n256 cases are missing date of onset and not shown\n\n\nИзвлечение из датафрейма\nИногда полезно взять данные датафрейма и вставить их последовательно вместе. Ниже приведен пример датафрейма. Мы используем его, чтобы создать сводное утверждение о юрисдикциях и количестве новых и общем количестве случаев.\n\n# создаем датафрейм случаев\ncase_table &lt;- data.frame(\n  zone        = c(\"Zone 1\", \"Zone 2\", \"Zone 3\", \"Zone 4\", \"Zone 5\"),\n  new_cases   = c(3, 0, 7, 0, 15),\n  total_cases = c(40, 4, 25, 10, 103)\n  )\n\n\n\n\n\n\n\nИспользуем str_glue_data(), которая специально создана для того, чтобы взять данные из строк датафрейма:\n\ncase_table %&gt;% \n  str_glue_data(\"{zone}: {new_cases} ({total_cases} total cases)\")\n\nZone 1: 3 (40 total cases)\nZone 2: 0 (4 total cases)\nZone 3: 7 (25 total cases)\nZone 4: 0 (10 total cases)\nZone 5: 15 (103 total cases)\n\n\nОбъединение последовательностей между строками\nЕсли вы пытаетесь свести значения в столбце датафрейма, например, объединить значения из нескольких строк в одну строку, вставив их через разделитесь, см. раздел на странице Дедупликация по “Сведение” значений.\nДатафрейм в одну строку\nВы можете сделать так, чтобы утверждение появлялось одной строкой, используя str_c() (уточнив датафрейм и имена столбцов), а также задав аргументы sep = и collapse =.\n\nstr_c(case_table$zone, case_table$new_cases, sep = \" = \", collapse = \";  \")\n\n[1] \"Zone 1 = 3;  Zone 2 = 0;  Zone 3 = 7;  Zone 4 = 0;  Zone 5 = 15\"\n\n\nВы можете добавить текстовый префикс “New Cases:” в начало утверждение, обернув его в отдельную команду str_c() (если “New Cases:” было в оригинальной str_c(), эта фраза появится несколько раз).\n\nstr_c(\"New Cases: \", str_c(case_table$zone, case_table$new_cases, sep = \" = \", collapse = \";  \"))\n\n[1] \"New Cases: Zone 1 = 3;  Zone 2 = 0;  Zone 3 = 7;  Zone 4 = 0;  Zone 5 = 15\"\n\n\n\n\nОбъединение столбцов\nОбъединить текстовые значения из нескольких столбцов в датафрейме можно с помощью unite() из tidyr. Это действие, противоположное separate().\nЗадайте имя нового объединенного столбца. Затем задайте имена столбцов, которые вы хотите объединить.\n\nПо умолчанию разделителем, используемым в объединенном столбце, будет нижнее подчеркивание _, но его можно изменить в аргументе sep =.\n\nremove = удаляет входные столбцы из датафрейма (по умолчанию TRUE (истина))\n\nna.rm = удаляет отсутствующие значения при объединении (по умолчанию FALSE (ложь))\n\nНиже мы определяем мини-датафрейм для демонстрации:\n\ndf &lt;- data.frame(\n  case_ID = c(1:6),\n  symptoms  = c(\"jaundice, fever, chills\",     # пациент 1\n                \"chills, aches, pains\",        # пациент 2 \n                \"fever\",                       # пациент 3\n                \"vomiting, diarrhoea\",         # пациент 4\n                \"bleeding from gums, fever\",   # пациент 5\n                \"rapid pulse, headache\"),      # пациент 6\n  outcome = c(\"Recover\", \"Death\", \"Death\", \"Recover\", \"Recover\", \"Recover\"))\n\n\ndf_split &lt;- separate(df, symptoms, into = c(\"sym_1\", \"sym_2\", \"sym_3\"), extra = \"merge\")\n\nWarning: Expected 3 pieces. Missing pieces filled with `NA` in 2 rows [3, 4].\n\n\nВот пример датафрейма:\n\n\n\n\n\n\nНиже мы объединяем три столбца симптомов:\n\ndf_split %&gt;% \n  unite(\n    col = \"all_symptoms\",         # имя нового объединенного столбца\n    c(\"sym_1\", \"sym_2\", \"sym_3\"), # столбцы для объединения\n    sep = \", \",                   # разделитель, который будет использован в объединенном столбце\n    remove = TRUE,                # если TRUE (истина), удаляет входные столбцы из датафрейма\n    na.rm = TRUE                  # если TRUE (истина), отсутствующие значения удаляются перед объединением\n  )\n\n  case_ID                all_symptoms outcome\n1       1     jaundice, fever, chills Recover\n2       2        chills, aches, pains   Death\n3       3                       fever   Death\n4       4         vomiting, diarrhoea Recover\n5       5 bleeding, from, gums, fever Recover\n6       6      rapid, pulse, headache Recover\n\n\n\n\n\nРазделение\nЧтобы разделить последовательность на основе комбинации символов, используйте str_split(). Она оценивает последовательность(и) и выдает список текстовых векторов list для только что разделенных значений.\nПростой пример ниже оценивает одну последовательность и разделяет ее на три. По умолчанию команда выдает объект класса list с одним элементом (текстовым вектором) для каждой изначально заданой последовательности. Если simplify = TRUE команда выдает текстовую матрицу.\nВ данном примере задается одна последовательность, а функция выдает список с одним элементом - текстовым вектором с тремя значениями.\n\nstr_split(string = \"jaundice, fever, chills\",\n          pattern = \",\")\n\n[[1]]\n[1] \"jaundice\" \" fever\"   \" chills\" \n\n\nЕсли выходной продукт сохраняется, вы можете затем получить доступ к n-ному разделенному значению с помощью синтаксиса с квадратными скобками. Чтобы получить доступ к конкретному значению, вы можете использовать подобный синтаксис: the_returned_object[[1]][2], который получит доступ ко второму значению из первой оцениваемой последовательности (“fever”). См. страницу [Основы R] для получения более детальной информации о доступе к элементам.\n\npt1_symptoms &lt;- str_split(\"jaundice, fever, chills\", \",\")\n\npt1_symptoms[[1]][2]  # извлекает 2-е значение из 1-го (и только) элемента списка\n\n[1] \" fever\"\n\n\nЕсли в str_split() заданы несколько последовательностей, то будет выдано больше 1 элемента в получившемся списке.\n\nsymptoms &lt;- c(\"jaundice, fever, chills\",     # пациент 1\n              \"chills, aches, pains\",        # пациент 2 \n              \"fever\",                       # пациент 3\n              \"vomiting, diarrhoea\",         # пациент 4\n              \"bleeding from gums, fever\",   # пациент 5\n              \"rapid pulse, headache\")       # пациент 6\n\nstr_split(symptoms, \",\")                     # разделить симптомы каждого пациента\n\n[[1]]\n[1] \"jaundice\" \" fever\"   \" chills\" \n\n[[2]]\n[1] \"chills\" \" aches\" \" pains\"\n\n[[3]]\n[1] \"fever\"\n\n[[4]]\n[1] \"vomiting\"   \" diarrhoea\"\n\n[[5]]\n[1] \"bleeding from gums\" \" fever\"            \n\n[[6]]\n[1] \"rapid pulse\" \" headache\"  \n\n\nЧтобы вместо этого получить “текстовую матрицу”, которая может быть полезна, если вы создаете столбцы датафрейма, задайте аргумент simplify = TRUE, как показано ниже:\n\nstr_split(symptoms, \",\", simplify = TRUE)\n\n     [,1]                 [,2]         [,3]     \n[1,] \"jaundice\"           \" fever\"     \" chills\"\n[2,] \"chills\"             \" aches\"     \" pains\" \n[3,] \"fever\"              \"\"           \"\"       \n[4,] \"vomiting\"           \" diarrhoea\" \"\"       \n[5,] \"bleeding from gums\" \" fever\"     \"\"       \n[6,] \"rapid pulse\"        \" headache\"  \"\"       \n\n\nВы можете также скорректировать количество разделенных частей, которые вы создаете, с помощью аргумента n =. Например, это ограничивает количество разделенных частей до 2. Любые дополнительные запятые остаются во втором значении.\n\nstr_split(symptoms, \",\", simplify = TRUE, n = 2)\n\n     [,1]                 [,2]            \n[1,] \"jaundice\"           \" fever, chills\"\n[2,] \"chills\"             \" aches, pains\" \n[3,] \"fever\"              \"\"              \n[4,] \"vomiting\"           \" diarrhoea\"    \n[5,] \"bleeding from gums\" \" fever\"        \n[6,] \"rapid pulse\"        \" headache\"     \n\n\nПримечание - те же выходные данные можно получить с помощью str_split_fixed(), где вы не задаете аргумент simplify, но вместо этого указываете количество столбцов (n).\n\nstr_split_fixed(symptoms, \",\", n = 2)\n\n\n\nРазделение столбцов\nЕсли вы пытаетесь разделить столбец датафрейма, лучше использовать функцию separate() из dplyr. Она используется для разделения одного текстового столбца на другие столбцы.\nПредставим, что у нас есть простой датафрейм df (определенный и объединенный в разделе объединения), содержащий столбец case_ID, один текстовый столбец с множеством симптомов, а также столбец исхода. Наша цель - разделить столбец symptoms на несколько столбцов - в каждом из которых будет один симптом.\n\n\n\n\n\n\nЕсли предположить, что данные передаются в отдельную функцию separate(), сначала задайте столбец, который нужно разделить. Затем задайте into = как вектор c( ), содержащий новые имена столбцов, как показано ниже.\n\nsep = разделитесь, может быть текстовым знаком или числом (интерпретируется как позиция текстового знака, где происходит разделение)\nremove = по умолчанию FALSE (ложь), удаляет входной столбец\n\nconvert = по умолчанию FALSE (ложь), превращает “NA” в последовательности в NA\n\nextra = контролирует, что происходит, если разделением создается больше значений, чем новых именованных столбцов.\n\nextra = \"warn\" означает, что вы увидите предупреждение, но система выкинет излишние значения (по умолчанию)\n\nextra = \"drop\" означает, что излишние значения будут выкинуты без предупреждения\n\nextra = \"merge\" разделит только на количество новых столбцов, указанных в into - эта опция сохранит все ваши данные\n\n\nПример с использованием extra = \"merge\" приведен ниже - никакие данные не теряются. Определены два новых столбца, но любые третьи симптомы остаются во втором новом столбце:\n\n# третьи симптомы объединяются во втором новом столбце\ndf %&gt;% \n  separate(symptoms, into = c(\"sym_1\", \"sym_2\"), sep=\",\", extra = \"merge\")\n\nWarning: Expected 2 pieces. Missing pieces filled with `NA` in 1 rows [3].\n\n\n  case_ID              sym_1          sym_2 outcome\n1       1           jaundice  fever, chills Recover\n2       2             chills   aches, pains   Death\n3       3              fever           &lt;NA&gt;   Death\n4       4           vomiting      diarrhoea Recover\n5       5 bleeding from gums          fever Recover\n6       6        rapid pulse       headache Recover\n\n\nКогда ниже используется значение по умолчанию extra = \"drop\", выдается предупреждение, но третьи симптомы теряются:\n\n# третьи симптомы теряются\ndf %&gt;% \n  separate(symptoms, into = c(\"sym_1\", \"sym_2\"), sep=\",\")\n\nWarning: Expected 2 pieces. Additional pieces discarded in 2 rows [1, 2].\n\n\nWarning: Expected 2 pieces. Missing pieces filled with `NA` in 1 rows [3].\n\n\n  case_ID              sym_1      sym_2 outcome\n1       1           jaundice      fever Recover\n2       2             chills      aches   Death\n3       3              fever       &lt;NA&gt;   Death\n4       4           vomiting  diarrhoea Recover\n5       5 bleeding from gums      fever Recover\n6       6        rapid pulse   headache Recover\n\n\nВНИМАНИЕ: Если вы не зададите достаточное количество значений into для новых столбцов, ваши данные могут быть подрезаны.\n\n\n\nУпорядочивание в алфавитном порядке\nНесколько последовательностей можно отсортировать в алфавитном порядке. str_order() выдает порядок, а str_sort() выдает последовательности в этом порядке.\n\n# последовательности\nhealth_zones &lt;- c(\"Alba\", \"Takota\", \"Delta\")\n\n# выдает алфавитный порядок\nstr_order(health_zones)\n\n[1] 1 3 2\n\n# выдает последовательности в алфавитном порядке\nstr_sort(health_zones)\n\n[1] \"Alba\"   \"Delta\"  \"Takota\"\n\n\nЧтобы использовать другой алфавит, добавьте аргумент locale =. См. полный список локалей, введя stringi::stri_locale_list() в консоли R.\n\n\n\nбазовые функции R\nЧасто используются базовые функции R paste() и paste0(), которые сцепляют векторы после конвертации всех частей в текстовые. Они работают похожим на str_c() образом, но синтаксис считается более сложным - в скобках, где каждая часть отделена запятой. Части либо являются текстом (в кавычках), либо заранее определенными объектами кода (без кавычек). Например:\n\nn_beds &lt;- 10\nn_masks &lt;- 20\n\npaste0(\"Regional hospital needs \", n_beds, \" beds and \", n_masks, \" masks.\")\n\n[1] \"Regional hospital needs 10 beds and 20 masks.\"\n\n\nМожно уточнить аргументы sep = и collapse =. paste() - это просто paste0() с sep = \" \" по умолчанию (один пробел).",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Текст и последовательности</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.ru.html#вычистка-и-стандартизация",
    "href": "new_pages/characters_strings.ru.html#вычистка-и-стандартизация",
    "title": "10  Текст и последовательности",
    "section": "10.3 Вычистка и стандартизация",
    "text": "10.3 Вычистка и стандартизация\n\n\nИзменение регистра\nЧасто бывает необходимость менять капитализацию значения последовательности, например, названий юрисдикций. Используйте str_to_upper(), str_to_lower() и str_to_title() из stringr, как показано ниже:\n\nstr_to_upper(\"California\")\n\n[1] \"CALIFORNIA\"\n\nstr_to_lower(\"California\")\n\n[1] \"california\"\n\n\nМожно добиться того же, что и выше, с помощью функций toupper(), tolower() из *базового** R.\nКапитализация всех слов\nТрансформация последовательности таким образом, чтобы каждое слово было капитализировано, может быть выполнена с помощью str_to_title():\n\nstr_to_title(\"go to the US state of california \")\n\n[1] \"Go To The Us State Of California \"\n\n\nИспользуйте toTitleCase() из пакета tools для более сложной капитализации (где не капитализируются такие слова, как “to”, “the” и “of”).\n\ntools::toTitleCase(\"This is the US state of california\")\n\n[1] \"This is the US State of California\"\n\n\nВы можете также использовать str_to_sentence(), которая капитализирует только первую букву последовательности.\n\nstr_to_sentence(\"the patient must be transported\")\n\n[1] \"The patient must be transported\"\n\n\n\n\nНаращивание длины\nИспользуйте str_pad(), чтобы добавить знаки в последовательность до минимальной длины. По умолчанию добавляются пробелы, но вы можете наращивать и с помощью других знаков, используя аргумент pad =.\n\n# Коды МКБ разной длины\nICD_codes &lt;- c(\"R10.13\",\n               \"R10.819\",\n               \"R17\")\n\n# Коды МКБ наращиваются до 7 знаков с правой стороны\nstr_pad(ICD_codes, 7, \"right\")\n\n[1] \"R10.13 \" \"R10.819\" \"R17    \"\n\n# Наращивание точками вместо пробелов\nstr_pad(ICD_codes, 7, \"right\", pad = \".\")\n\n[1] \"R10.13.\" \"R10.819\" \"R17....\"\n\n\nНапример, чтобы нарастить числа нулями в начале (например, для часов или минут), вы можете нарастить число до минимальной длины в 2 знака с помощью pad = \"0\".\n\n# Добавляем нули в начале до получения двух знаков (например, для минут/часов)\nstr_pad(\"4\", 2, pad = \"0\") \n\n[1] \"04\"\n\n# пример использования числового столбца с именем \"hours\"\n# hours &lt;- str_pad(hours, 2, pad = \"0\")\n\n\n\nУкорачивание\nstr_trunc() задает максимальную длину каждой последовательности. Если последовательность превышает эту длину, она обрезается (укорачивается) и добавляется многоточие (…), чтобы указать, что ранее последовательность была длиннее. Обратите внимание, что многоточие считается в длине. Знаки многоточия можно изменить с помощью аргумента ellipsis =. Опциональный аргумент side = указывает, где появится многоточие в укороченной последовательности (“left” (слева), “right” (справа), либо “center” (в центре)).\n\noriginal &lt;- \"Symptom onset on 4/3/2020 with vomiting\"\nstr_trunc(original, 10, \"center\")\n\n[1] \"Symp...ing\"\n\n\n\n\nСтандартизация длины\nИспользуйте str_trunc(), чтобы задать максимальную длину, а затем используйте str_pad(), чтобы расширить очень короткие последовательности до этой укороченной длины. В примере ниже, 6 задается как максимальная длина (одно значение укорачивается), а затем одно очень короткое значение наразивается до длины в 6 знаков.\n\n# МКБ коды разной длины\nICD_codes   &lt;- c(\"R10.13\",\n                 \"R10.819\",\n                 \"R17\")\n\n# укорачиваем до максимальной длины в 6 знаков\nICD_codes_2 &lt;- str_trunc(ICD_codes, 6)\nICD_codes_2\n\n[1] \"R10.13\" \"R10...\" \"R17\"   \n\n# расширяем до минимальной длины в 6 знаков\nICD_codes_3 &lt;- str_pad(ICD_codes_2, 6, \"right\")\nICD_codes_3\n\n[1] \"R10.13\" \"R10...\" \"R17   \"\n\n\n\n\nУдаление пустого пространства в начале/в конце\nИспользуйте str_trim(), чтобы удалить пробелы, новые строки (\\n) или отступы (\\t) по бокам последовательности. Добавьте \"right\" (справа), \"left\" (слева), или \"both\" (оба) к команде, чтобы уточнить, какую сторону обрезать (например, str_trim(x, \"right\").\n\n# ID номера с лишними пробелами справа\nIDs &lt;- c(\"provA_1852  \", # два лишних пробела\n         \"provA_2345\",   # ноль лишних пробелов\n         \"provA_9460 \")  # один лишний пробел\n\n# ID номера укорачиваются, чтобы удалить лишние пробелы только с правой стороны\nstr_trim(IDs)\n\n[1] \"provA_1852\" \"provA_2345\" \"provA_9460\"\n\n\n\n\nУдаление повторяющихся пробелов внутри последовательности\nИспользуйте str_squish() для удаления повторяющихся пробелов внутри последовательности. Например, чтобы конвертировать двойные пробелы в одинарные пробелы. Эта команда также удаляет пробелы, новые строки или табуляцию на внешних концах последовательности, как str_trim().\n\n# в оригинале внутри последовательности есть лишние пробелы\nstr_squish(\"  Pt requires   IV saline\\n\") \n\n[1] \"Pt requires IV saline\"\n\n\nВведите ?str_trim, ?str_pad на консоли R для получения дополнительной информации.\n\n\nСоздание абзацев\nИспользуйте str_wrap(), чтобы из длинного неструктурированного текста создать структурированный абзац с фиксированной длиной строк. Укажите идеальную длину для каждой строки и функция применит алгоритм по вставке разрывов строк внутри абзаца, как показано в примере ниже.\n\npt_course &lt;- \"Symptom onset 1/4/2020 vomiting chills fever. Pt saw traditional healer in home village on 2/4/2020. On 5/4/2020 pt symptoms worsened and was admitted to Lumta clinic. Sample was taken and pt was transported to regional hospital on 6/4/2020. Pt died at regional hospital on 7/4/2020.\"\n\nstr_wrap(pt_course, 40)\n\n[1] \"Symptom onset 1/4/2020 vomiting chills\\nfever. Pt saw traditional healer in\\nhome village on 2/4/2020. On 5/4/2020\\npt symptoms worsened and was admitted\\nto Lumta clinic. Sample was taken and pt\\nwas transported to regional hospital on\\n6/4/2020. Pt died at regional hospital\\non 7/4/2020.\"\n\n\nУказанная выше команда может быть обернута в Базовую функцию cat(), чтобы напечатать получившийся результат, отображающий новые добавленные строки.\n\ncat(str_wrap(pt_course, 40))\n\nSymptom onset 1/4/2020 vomiting chills\nfever. Pt saw traditional healer in\nhome village on 2/4/2020. On 5/4/2020\npt symptoms worsened and was admitted\nto Lumta clinic. Sample was taken and pt\nwas transported to regional hospital on\n6/4/2020. Pt died at regional hospital\non 7/4/2020.",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Текст и последовательности</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.ru.html#работа-с-последовательностями-на-основе-их-позиции",
    "href": "new_pages/characters_strings.ru.html#работа-с-последовательностями-на-основе-их-позиции",
    "title": "10  Текст и последовательности",
    "section": "10.4 Работа с последовательностями на основе их позиции",
    "text": "10.4 Работа с последовательностями на основе их позиции\n\nИзвлечение по позиции текстового знака\nИспользуйте str_sub(), чтобы выдать только часть последовательности. Эта фукнция использует три основных аргумента:\n\nтекстовый вектор(ы)\n\nстартовая позиция\n\nконечная позиция\n\nНесколько комментариев по числам позиции:\n\nЕсли число позиции положительное, позиция считается, начиная с левой части последовательности.\n\nЕсли число позиции отрицательное, она считается, начиная с правой части последовательности.\n\nЧисла позиции считаются включительно.\n\nПозиции за пределами последовательности будут укорочены (удалены).\n\nНиже приведены некоторые примеры применительно к последовательности “pneumonia”:\n\n# начало и окончание на третьем слева (3я буква слева)\nstr_sub(\"pneumonia\", 3, 3)\n\n[1] \"e\"\n\n# 0 не присутствует\nstr_sub(\"pneumonia\", 0, 0)\n\n[1] \"\"\n\n# от 6го слева до 1го справа\nstr_sub(\"pneumonia\", 6, -1)\n\n[1] \"onia\"\n\n# от 5го справа до 2го справа\nstr_sub(\"pneumonia\", -5, -2)\n\n[1] \"moni\"\n\n# от 4го слева до позиции за пределами последовательности\nstr_sub(\"pneumonia\", 4, 15)\n\n[1] \"umonia\"\n\n\n\n\nИзвлечение по позиции слова\nЧтобы извлечь n-ое ‘слово’, используйте word(), также из пакета stringr. Укажите последовательность(и), затем первую позицию слова для извлечения, а также последнюю позицию слова для извлечения.\nПо умолчанию разделителем между ‘словами’ считается пробел, если не указано иное в аргументе sep = (например, sep = \"_\", когда слова отделяются нижними подчеркиваниями.\n\n# последовательности для оценки\nchief_complaints &lt;- c(\"I just got out of the hospital 2 days ago, but still can barely breathe.\",\n                      \"My stomach hurts\",\n                      \"Severe ear pain\")\n\n# извлечь с 1го по 3е слово каждой последовательности\nword(chief_complaints, start = 1, end = 3, sep = \" \")\n\n[1] \"I just got\"       \"My stomach hurts\" \"Severe ear pain\" \n\n\n\n\nЗамена по позиции текстового знака\nstr_sub() вместе с оператором присваивания (&lt;-) может быть использован для модификации части последовательности:\n\nword &lt;- \"pneumonia\"\n\n# конвертирует третий и четвертый знаки в X \nstr_sub(word, 3, 4) &lt;- \"XX\"\n\n# печать\nword\n\n[1] \"pnXXmonia\"\n\n\nПример применения к нескольким последовательностям (например, к столбцу). Обратите внимание на длину “HIV”.\n\nwords &lt;- c(\"pneumonia\", \"tubercolosis\", \"HIV\")\n\n# конвертирует третий и четвертый знаки в X \nstr_sub(words, 3, 4) &lt;- \"XX\"\n\nwords\n\n[1] \"pnXXmonia\"    \"tuXXrcolosis\" \"HIXX\"        \n\n\n\n\nОценка длины\n\nstr_length(\"abc\")\n\n[1] 3\n\n\nАльтернативно используйте nchar() из базового R",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Текст и последовательности</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.ru.html#комбинации-символов",
    "href": "new_pages/characters_strings.ru.html#комбинации-символов",
    "title": "10  Текст и последовательности",
    "section": "10.5 Комбинации символов",
    "text": "10.5 Комбинации символов\nМногие функции stringr работают для обнаружения, поиска, извлечения, поиска соответствия, замены и разделения на основе указанной комбинации символов.\n\n\nОбнаружение комбинации символов\nИспользуйте str_detect(), как показано ниже, чтобы обнаружить наличие/отсутствие комбинации символов внутри последовательности. Сначала задайте последовательность или вектор, в котором будет идти поиск (string =), а затем комбинацию символов, которую нужно искать (pattern =). Обратите внимание, что по умолчанию, этот поиск чувствителен к регистру!\n\nstr_detect(string = \"primary school teacher\", pattern = \"teach\")\n\n[1] TRUE\n\n\nМожно включить аргумент negate = и установить на TRUE (истина), если вы хотите узнать, что комбинации символов НЕТ.\n\nstr_detect(string = \"primary school teacher\", pattern = \"teach\", negate = TRUE)\n\n[1] FALSE\n\n\nЧтобы игнорировать регистр/капитализацию, оберните вокруг комбинации символов команду regex(), а внутри regex() добавьте аргумент ignore_case = TRUE (или T в качестве сокращения).\n\nstr_detect(string = \"Teacher\", pattern = regex(\"teach\", ignore_case = T))\n\n[1] TRUE\n\n\nКогда применяется str_detect() к текстовому вектору или столбцу датафрейма, команда выдаст TRUE (истина) или FALSE (ложь) для каждого из значений.\n\n# вектор/столбец рода занятий \noccupations &lt;- c(\"field laborer\",\n                 \"university professor\",\n                 \"primary school teacher & tutor\",\n                 \"tutor\",\n                 \"nurse at regional hospital\",\n                 \"lineworker at Amberdeen Fish Factory\",\n                 \"physican\",\n                 \"cardiologist\",\n                 \"office worker\",\n                 \"food service\")\n\n# Обнаружение наличия комбинации символов \"teach\" в каждой последовательности - выходным результатом будет вектор TRUE/FALSE\nstr_detect(occupations, \"teach\")\n\n [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nЕсли вам надо подсчитать количество значений TRUE, просто используйте sum() для выходных результатов. Команда подсчитает количество значений TRUE.\n\nsum(str_detect(occupations, \"teach\"))\n\n[1] 1\n\n\nЧтобы искать включительно по нескольким терминам, включите их и разделите вертикальными чертами ИЛИ (|) внутри аргумента pattern =, как показано ниже:\n\nsum(str_detect(string = occupations, pattern = \"teach|professor|tutor\"))\n\n[1] 3\n\n\nЕсли вам нужно построить длинный список условий поиска, вы можете объединить их, используя str_c() и sep = |, затем определите как текстовый объект, а затем позже вы можете ссылаться на вектор более кратким образом. Пример ниже включает возможные виды деятельности для поиска медицинских работников на передовой.\n\n# условия поиска\noccupation_med_frontline &lt;- str_c(\"medical\", \"medicine\", \"hcw\", \"healthcare\", \"home care\", \"home health\",\n                                \"surgeon\", \"doctor\", \"doc\", \"physician\", \"surgery\", \"peds\", \"pediatrician\",\n                               \"intensivist\", \"cardiologist\", \"coroner\", \"nurse\", \"nursing\", \"rn\", \"lpn\",\n                               \"cna\", \"pa\", \"physician assistant\", \"mental health\",\n                               \"emergency department technician\", \"resp therapist\", \"respiratory\",\n                                \"phlebotomist\", \"pharmacy\", \"pharmacist\", \"hospital\", \"snf\", \"rehabilitation\",\n                               \"rehab\", \"activity\", \"elderly\", \"subacute\", \"sub acute\",\n                                \"clinic\", \"post acute\", \"therapist\", \"extended care\",\n                                \"dental\", \"dential\", \"dentist\", sep = \"|\")\n\noccupation_med_frontline\n\n[1] \"medical|medicine|hcw|healthcare|home care|home health|surgeon|doctor|doc|physician|surgery|peds|pediatrician|intensivist|cardiologist|coroner|nurse|nursing|rn|lpn|cna|pa|physician assistant|mental health|emergency department technician|resp therapist|respiratory|phlebotomist|pharmacy|pharmacist|hospital|snf|rehabilitation|rehab|activity|elderly|subacute|sub acute|clinic|post acute|therapist|extended care|dental|dential|dentist\"\n\n\nЭта команда выдает число видов деятельности, которые содержат одно из терминов поиска для передовых медицинских работников (occupation_med_frontline):\n\nsum(str_detect(string = occupations, pattern = occupation_med_frontline))\n\n[1] 2\n\n\nФункции поиска по последовательности в базовом R\nФункция базового R grepl() работает аналогично str_detect(), в том плане, что она ищет соответствие комбинации символов и выдает логический вектор. Базовый синтаксис: grepl(pattern, strings_to_search, ignore.case = FALSE, ...). Преимуществом является то, что аргумент ignore.case легче написать (нет необходимости использовать функцию regex()).\nАналогично, базовые функции sub() и gsub() работают похожим на str_replace() образом. Их основной синтаксис: gsub(pattern, replacement, strings_to_search, ignore.case = FALSE). sub() заменит первое совпадение по комбинации, а gsub() заменит все совпадения по комбинации.\n\nКонвертация запятых в точки\nВот пример использования gsub() для конвертации запятых в точки в векторе чисел. Это может быть полезно, если вы получаете данные из регионов мира за пределами США или Великобритании.\nВнутренняя команда gsub(), которая сначала работает над lengths конвертирует любые точки в отсутствие пробелов ““. Знак точки”.” должен быть “изолирован” с помощью двух слэшей, чтобы он собственно означал точку, поскольку “.” в регулярном выражении(regex) означает “любой знак”. Затем результат (только с запятыми) передается во внешнюю функцию gsub(), в которой запятые заменяются на точки.\n\nlengths &lt;- c(\"2.454,56\", \"1,2\", \"6.096,5\")\n\nas.numeric(gsub(pattern = \",\",                # находит запятые     \n                replacement = \".\",            # меняет их на точки\n                x = gsub(\"\\\\.\", \"\", lengths)  # вектор с другими точками удаляется (точки изолируются)\n                )\n           )                                  # конвертация выходных данных в числовые\n\n\n\n\nЗаменить все\nИспользуйте str_replace_all() в качестве инструмента “найти и заменить”. Во-первых, задайте, какие последовательности будут оцениваться в аргументе string =, затем комбинацию, которую нужно заменить в pattern =, и затем на какое значение менять в replacement =. Пример ниже заменяет все случаи, когда встречается “dead” (мертвый) на “deceased” (скончавшийся). Обратите внимание, команда ЧУВСТВИТЕЛЬНА к регистру.\n\noutcome &lt;- c(\"Karl: dead\",\n            \"Samantha: dead\",\n            \"Marco: not dead\")\n\nstr_replace_all(string = outcome, pattern = \"dead\", replacement = \"deceased\")\n\n[1] \"Karl: deceased\"      \"Samantha: deceased\"  \"Marco: not deceased\"\n\n\nПримечания:\n\nЧтобы заменить комбинацию на NA, используйте str_replace_na().\n\nФункция str_replace() заменяет только первое совпадение комбинации в каждой оцениваемой последовательности.\n\n\n\n\nОбнаружение в рамках логических функций\nВ рамках case_when()\nstr_detect() часто используется в рамках case_when() (из dplyr). Представим, что в построчном списке есть столбец occupations. Функция mutate() ниже создает новый столбец под названием is_educator, используя условную логику с помощью case_when(). См. страницу вычистка данных для получения более подробной информации о case_when().\n\ndf &lt;- df %&gt;% \n  mutate(is_educator = case_when(\n    # поиск по термину в роде деятельности, не чувствителен к регистру\n    str_detect(occupations,\n               regex(\"teach|prof|tutor|university\",\n                     ignore_case = TRUE))              ~ \"Educator\",\n    # все прочие\n    TRUE                                               ~ \"Not an educator\"))\n\nНапоминаем, что может быть важным добавить критерии исключения в логику условий (negate = F):\n\ndf &lt;- df %&gt;% \n  # значение в новом столбце is_educator основано на условной логике\n  mutate(is_educator = case_when(\n    \n    # столбец род деятельности должен соответствовать 2 критериям, чтобы ему было присвоено значение \"Educator\":\n    # он должен иметь термин из поиска и НЕ СООТВЕТСТВОВАТЬ условиям исключения\n    \n    # должен иметь термин из поиска\n    str_detect(occupations,\n               regex(\"teach|prof|tutor|university\", ignore_case = T)) &              \n    \n    # И НЕ ДОЛЖЕН подпадать под критерии исключения\n    str_detect(occupations,\n               regex(\"admin\", ignore_case = T),\n               negate = TRUE                        ~ \"Educator\"\n    \n    # Все строки, не соответствующие указанным выше критериям\n    TRUE                                            ~ \"Not an educator\"))\n\n\n\n\nПоиск позиции комбинации\nЧтобы найти первую позицию комбинации, используйте str_locate(). В качестве результата вы получите стартовую и конечную позицию.\n\nstr_locate(\"I wish\", \"sh\")\n\n     start end\n[1,]     5   6\n\n\nКак и другие фукнции str, существует версия “_all” (str_locate_all()), которая выдает позиции всех случаев, когда встречается комбинация в каждой последовательности. Выходным результатом будет list.\n\nphrases &lt;- c(\"I wish\", \"I hope\", \"he hopes\", \"He hopes\")\n\nstr_locate(phrases, \"h\" )     # позиция *первого* случая комбинации\n\n     start end\n[1,]     6   6\n[2,]     3   3\n[3,]     1   1\n[4,]     4   4\n\nstr_locate_all(phrases, \"h\" ) # позиция *каждого* случая комбинации\n\n[[1]]\n     start end\n[1,]     6   6\n\n[[2]]\n     start end\n[1,]     3   3\n\n[[3]]\n     start end\n[1,]     1   1\n[2,]     4   4\n\n[[4]]\n     start end\n[1,]     4   4\n\n\n\n\n\nИзвлечение совпадений\nstr_extract_all() выдает сами совпадающие комбинации, что наиболее полезно, если вы предложили несколько комбинаций с условием “ИЛИ”. Например, поиск по последовательности вектора рода занятий (см. предыдушую вкладку) любого из вариантов “teach”, “prof” или “tutor”.\nstr_extract_all() выдает список list, который содержит все совпадения для каждой оцениваемой последовательности. См. ниже, что у рода деятельности 3 имеется два соответствия по комбинациям.\n\nstr_extract_all(occupations, \"teach|prof|tutor\")\n\n[[1]]\ncharacter(0)\n\n[[2]]\n[1] \"prof\"\n\n[[3]]\n[1] \"teach\" \"tutor\"\n\n[[4]]\n[1] \"tutor\"\n\n[[5]]\ncharacter(0)\n\n[[6]]\ncharacter(0)\n\n[[7]]\ncharacter(0)\n\n[[8]]\ncharacter(0)\n\n[[9]]\ncharacter(0)\n\n[[10]]\ncharacter(0)\n\n\nstr_extract() извлекает только первое совпадение в каждой оцениваемой последовательности, создавая текстовый вектор с одним элементом для каждой оцениваемой последовательности. Команда выдает NA в тех случаях, где не было совпадений. NA можно удалить, если вы обернете полученный вектор в na.exclude(). Обратите внимание, что второе совпадение рода деятельности 3 не показано.\n\nstr_extract(occupations, \"teach|prof|tutor\")\n\n [1] NA      \"prof\"  \"teach\" \"tutor\" NA      NA      NA      NA      NA     \n[10] NA     \n\n\n\n\n\nПодмножество и подсчет\nФункции сопоставления включают str_subset() и str_count().\nstr_subset() выдает собственно значения, которые содержат комбинацию:\n\nstr_subset(occupations, \"teach|prof|tutor\")\n\n[1] \"university professor\"           \"primary school teacher & tutor\"\n[3] \"tutor\"                         \n\n\nstr_count() выдает вектор чисел: количество раз появления поискового термина в каждом оцениваемом значении.\n\nstr_count(occupations, regex(\"teach|prof|tutor\", ignore_case = TRUE))\n\n [1] 0 1 2 1 0 0 0 0 0 0\n\n\n\n\n\nГруппы регулярных выражений\nНАХОДИТСЯ В РАЗРАБОТКЕ",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Текст и последовательности</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.ru.html#специальные-символы",
    "href": "new_pages/characters_strings.ru.html#специальные-символы",
    "title": "10  Текст и последовательности",
    "section": "10.6 Специальные символы",
    "text": "10.6 Специальные символы\nОбратный слэш \\ для изолирования\nОбратный слэш \\ используется для “изолирования” значения следующего знака. Таким образом, бэкслэш можно использовать, чтобы отобразить кавычку внутри других кавычек (\\\") - кавычка в середине не “поломает” кавычки вокруг.\nПримечание - таким образом, если вам нужно отобразить обратный слэш, вы должны изолировать его значение еще одним обратным слэшем. То есть, вам нужно написать два обратных слэша, \\\\ чтобы отобразить один.\nСпециальные символы\n\n\n\n\n\n\n\nСпециальный символ\nПредставляет собой\n\n\n\n\n\"\\\\\"\nобратный слэш\n\n\n\"\\n\"\nновая строка\n\n\n\"\\\"\"\nдвойные кавычки внутри двойных кавычек\n\n\n'\\''\nодинарная кавычка внутри одинарных кавычек\n\n\n\"\\“| аксан грав”| возврат каретки“| tab”| вертикальный tab“`\nbackspace\n\n\n\nЧтобы увидеть полный список этих специальных символов выполните ?\"'\" в консоли R (он появится на панели RStudio Help (справка)).",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Текст и последовательности</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.ru.html#регулярные-выражения-regex",
    "href": "new_pages/characters_strings.ru.html#регулярные-выражения-regex",
    "title": "10  Текст и последовательности",
    "section": "10.7 Регулярные выражения (regex)",
    "text": "10.7 Регулярные выражения (regex)",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Текст и последовательности</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.ru.html#регулярные-выражения-и-специальные-знаки",
    "href": "new_pages/characters_strings.ru.html#регулярные-выражения-и-специальные-знаки",
    "title": "10  Текст и последовательности",
    "section": "10.8 Регулярные выражения и специальные знаки",
    "text": "10.8 Регулярные выражения и специальные знаки\nРегулярные выражения, или “regex” - это краткий язык описания комбинаций в последовательностях. Если вы с ним не знакомы, регулярное выражение может выглядеть как незнакомый язык. Здесь мы постараемся немного раскрыть его тайны.\nЭтот раздел во многом заимствован из этого самоучителя and this cheatsheet. Мы включили сюда некоторые его части, понимая, что данное руководство могут просматривать пользователи без доступа к интернету и возможности просмотра других учебников.\nРегулярное выражение часто применяется для извлечения конкретных комбинаций из “неструктурированного” текста - например, медицинских записей, основных жалоб, анамнеза жизни или иных столбцов со свободным текстом в датафрейме.\nВот четыре основных инструмента, которые можно использовать для создания простого регулярного выражения:\n\nНаборы символов\n\nМета символы\n\nКвантификаторы\n\nГруппы\n\nНаборы символов\nНаборы символов - способ выражения опций перечисления для совпадения по символам внутри скобок. Таким образом, будет определено совпадение, если любой из символов в скобках будет обнаружен в последовательности. НАпример, чтобы искать гласные буквы, можно использовать набор символов: “[aeiou]”. Часто встречаются следующие наборы символов:\n\n\n\n\n\n\n\nНабор символов\nСовпадение для\n\n\n\n\n\"[A-Z]\"\nлюбая одна заглавная буква\n\n\n\"[a-z]\"\nлюбая одна строчная буква\n\n\n\"[0-9]\"\nлюбая цифра\n\n\n[:alnum:]\nлюбой алфавитно-цифровой символ\n\n\n[:digit:]\nлюбая числовая цифра\n\n\n[:alpha:]\nлюбая буква (заглавная или строчная)\n\n\n[:upper:]\nлюбая заглавная буква\n\n\n[:lower:]\nлюбая строчная буква\n\n\n\nНаборы символов можно комбинировать в одних квадратных скобках (без пробелов!), например: \"[A-Za-z]\" (любая заглавная или строчная буква), еще один пример: \"[t-z0-5]\" (строчная буква от t до z ИЛИ цифра от 0 до 5).\nМета символы\nМета символы - сокращения для набора символов. Некоторые наиболее важные перечислены ниже:\n\n\n\n\n\n\n\nМета символ\nПредставляет собой\n\n\n\n\n\"\\\\s\"\nодин пробел\n\n\n\"\\\\w\"\nлюбой один алфавитно-цифровой знак (A-Z, a-z, or 0-9)\n\n\n\"\\\\d\"\nлюбая одна цифра (0-9)\n\n\n\nКвантификаторы\nКак правило, вы не ищете совпадение только по одному символу. Квантификаторы позволяют вам определить длину букв/цифр, чтобы считать их совпадением.\nКвантификаторы - цифры, записанные в фигурных скобках { } после знака, который они количественно определяют, например,\n\n\"A{2}\" выдаст случаи двух заглавных букв A.\n\n\"A{2,4}\" выдаст случаи, где от двух до четырех заглавных букв A (не ставьте пробелы!).\n\n\"A{2,}\" выдаст случаи двух или более заглавных букв A.\n\n\"A+\" выдаст случаи одной или более заглавной буквы A (группа расширяется, пока не будет встречен другой символ).\n\nПоставьте в начале звездочку *, чтобы получить ноль или более совпадений (полезно, если вы не уверены, есть ли совпадения по комбинации)\n\nЕсли вы используете знак плюс + как квантификатор, совпадение будет происходить, пока не будет встречен другой символ. Например, это выражение выдаст вам все слова (алфавитные символы: \"[A-Za-z]+\"\n\n# проверка последовательности с квантификаторами\ntest &lt;- \"A-AA-AAA-AAAA\"\n\nКогда используется квантификатор {2}, выдаются только пары последовательно идущих A. В AAAA выявляется две пары.\n\nstr_extract_all(test, \"A{2}\")\n\n[[1]]\n[1] \"AA\" \"AA\" \"AA\" \"AA\"\n\n\nКогда используется квантификатор {2,4}, выдаются группы последовательных A длиной от двух до четырех.\n\nstr_extract_all(test, \"A{2,4}\")\n\n[[1]]\n[1] \"AA\"   \"AAA\"  \"AAAA\"\n\n\nПри использовании квантификатора +, выдаются группы с одной или более:\n\nstr_extract_all(test, \"A+\")\n\n[[1]]\n[1] \"A\"    \"AA\"   \"AAA\"  \"AAAA\"\n\n\nОтносительная позиция\nВыражает требования к тому, что идет до или после комбинации. НАпример, чтобы извлечь предложения, “два числа, за которыми идет точка” (\"\"). (?&lt;=\\.)\\s(?=[A-Z])\n\nstr_extract_all(test, \"\")\n\n[[1]]\n [1] \"A\" \"-\" \"A\" \"A\" \"-\" \"A\" \"A\" \"A\" \"-\" \"A\" \"A\" \"A\" \"A\"\n\n\n\n\n\n\n\n\n\nЗаявление о позиции\nСоответствует\n\n\n\n\n\"(?&lt;=b)a\"\n“a” перед которой стоит “b”\n\n\n\"(?&lt;!b)a\"\n“a” перед которой НЕ стоит “b”\n\n\n\"a(?=b)\"\n“a” после которой идет “b”\n\n\n\"a(?!b)\"\n“a” после которой НЕ идет “b”\n\n\n\nГруппы\nУчет групп в вашем регулярном выражении является способом получения более структурированных выходных данных после извлечения.\nПримеры регулярных выражений\nНиже представлен свободный текст примера. Мы попробуем извлечь из него полезную информацию, используя поиск с помощью регулярного выражения.\n\npt_note &lt;- \"Patient arrived at Broward Hospital emergency ward at 18:00 on 6/12/2005. Patient presented with radiating abdominal pain from LR quadrant. Patient skin was pale, cool, and clammy. Patient temperature was 99.8 degrees farinheit. Patient pulse rate was 100 bpm and thready. Respiratory rate was 29 per minute.\"\n\nДанное выражение ищет совпадения со всеми словами (любой символ, пока не наткнется на не-символ, например, пробел):\n\nstr_extract_all(pt_note, \"[A-Za-z]+\")\n\n[[1]]\n [1] \"Patient\"     \"arrived\"     \"at\"          \"Broward\"     \"Hospital\"   \n [6] \"emergency\"   \"ward\"        \"at\"          \"on\"          \"Patient\"    \n[11] \"presented\"   \"with\"        \"radiating\"   \"abdominal\"   \"pain\"       \n[16] \"from\"        \"LR\"          \"quadrant\"    \"Patient\"     \"skin\"       \n[21] \"was\"         \"pale\"        \"cool\"        \"and\"         \"clammy\"     \n[26] \"Patient\"     \"temperature\" \"was\"         \"degrees\"     \"farinheit\"  \n[31] \"Patient\"     \"pulse\"       \"rate\"        \"was\"         \"bpm\"        \n[36] \"and\"         \"thready\"     \"Respiratory\" \"rate\"        \"was\"        \n[41] \"per\"         \"minute\"     \n\n\nВыражение \"[0-9]{1,2}\" ищет совпадения с последовательно расположенными цифрами, длиной 1 или 2 знака. Его можно также записать как \"\\\\d{1,2}\", либо \"[:digit:]{1,2}\".\n\nstr_extract_all(pt_note, \"[0-9]{1,2}\")\n\n[[1]]\n [1] \"18\" \"00\" \"6\"  \"12\" \"20\" \"05\" \"99\" \"8\"  \"10\" \"0\"  \"29\"\n\n\n\n\n\n\nВы можете просмотреть полезный список выражений regex и советы на странице 2 данной шпаргалки\nТакже посмотрите этот самоучитель.",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Текст и последовательности</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.ru.html#ресурсы",
    "href": "new_pages/characters_strings.ru.html#ресурсы",
    "title": "10  Текст и последовательности",
    "section": "10.9 Ресурсы",
    "text": "10.9 Ресурсы\nСправочный лист по функциям stringr можно найти тут\nВиньетку по stringr можно найти тут",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Текст и последовательности</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.ru.html",
    "href": "new_pages/factors.ru.html",
    "title": "11  Факторы",
    "section": "",
    "text": "11.1 Подготовка",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Факторы</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.ru.html#подготовка",
    "href": "new_pages/factors.ru.html#подготовка",
    "title": "11  Факторы",
    "section": "",
    "text": "Загрузка пакетов\nДанный фрагмент кода показывает загрузку пакетов, необходимых для анализа. В данном руководстве мы фокусируемся на использовании p_load() из пакета pacman, которая устанавливает пакет, если необходимо, и загружает его для использования. Вы можете также загрузить установленные пакеты с помощью library() из базового R. См. страницу Основы R для получения дополнительной информации о пакетах R.\n\npacman::p_load(\n  rio,           # импорт/экспорт\n  here,          # пути к файлу\n  lubridate,     # работа с датами\n  forcats,       # факторы\n  aweek,         # создание эпиднедель с автоматическими уровнями факторов\n  janitor,       # таблицы\n  tidyverse      # управление данными и визуализация\n  )\n\n\n\nИмпорт данных\nМы импортируем набор данных о случаях из имитационной эпидемии Эболы. Если вы хотите выполнять шаги параллельно, кликните, чтобы скачать “чистый” построчный список (as .rds file). Импортируйте ваши данные с помощью функции import() из пакета rio (она работает с многими типами файлов, такими как .xlsx, .rds, .csv - см. страницу Импорт и экспорт для получения детальной информации).\n\n# импорт вашего набора данных\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\n\n\nНовая категориальная переменная\nДля демонстрации на этой странице мы будем использовать часто встречающийся сценарий - создание новой категориальной переменной.\nОбратите внимание, что если вы конвертируете числовой столбец в класс фактор, вы не сможете рассчитывать числовую статистику по этому столбцу.\n\nСоздание столбца\nМы используем существующий столбец days_onset_hosp (дней с момента появления симптомов до госпитализации) и создаем новый столбец delay_cat путем классификации каждой строки в одну из нескольких категорий. Мы это делаем с помощью функции case_when() из dplyr, которая последовательно применяет логические критерии (правая сторона) к каждой строке и выдает соответствующее значение с левой стороны для нового столбца delay_cat. Более детально о case_when() вы можете почитать на странице Вычистка данных и ключевые функции.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(delay_cat = case_when(\n    # критерии                                 # новое значение, если TRUE (истина)\n    days_onset_hosp &lt; 2                        ~ \"&lt;2 days\",\n    days_onset_hosp &gt;= 2 & days_onset_hosp &lt; 5 ~ \"2-5 days\",\n    days_onset_hosp &gt;= 5                       ~ \"&gt;5 days\",\n    is.na(days_onset_hosp)                     ~ NA_character_,\n    TRUE                                       ~ \"Check me\"))  \n\n\n\nПорядок значений по умолчанию\nТак как новый столбец delay_cat создан с помощью case_when(), он будет категориальным столбцом в текстовом классе - а не фактором. Таким образом, в частотной таблице мы увидим, что уникальные значения появляются в алфавитно-числовом порядке по умолчанию - этот порядок не имеет особого интуитивного смысла:\n\ntable(linelist$delay_cat, useNA = \"always\")\n\n\n &lt;2 days  &gt;5 days 2-5 days     &lt;NA&gt; \n    2990      602     2040      256 \n\n\nАналогично, если мы будем создавать столбчатую диаграмму, значения также появятся в этом порядке на оси x (см. страницу [основы ggplot] для получения более подробной информации о ggplot2 - наиболее часто используемом пакете для визуализации в R).\n\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = delay_cat))",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Факторы</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.ru.html#конвертация-в-фактор",
    "href": "new_pages/factors.ru.html#конвертация-в-фактор",
    "title": "11  Факторы",
    "section": "11.2 Конвертация в фактор",
    "text": "11.2 Конвертация в фактор\nЧтобы конвертировать текстовый или числовой столбец в класс фактор, вы можете использовать любую функцию из пакета forcats (многие детально рассматриваются ниже). Они конвертируют в класс фактор и затем также проводят или допускают определенное упорядочивание уровней - например, использование fct_relevel() позволяет вам вручную указать порядок уровней. Функция as_factor() просто конвертирует класс без дополнительных возможностей.\nбазовая функция R factor() конвертирует столбец в фактор и позволяет вам вручную указать порядок уровней, как текстовый вектор в аргументе levels =.\nНиже мы используем mutate() и fct_relevel(), чтобы конвертировать столбец delay_cat из текстового класса в фактор. Столбец delay_cat был создан в разделе Подготовка выше.\n\nlinelist &lt;- linelist %&gt;%\n  mutate(delay_cat = fct_relevel(delay_cat))\n\nУникальные “значения” в данном столбце теперь считаются “уровнями” фактора. Уровни имеют порядок, который можно напечатать с помощью функции базового R levels(), либо альтернативно можно просмотреть в таблице подсчета через table() из базового R или tabyl() из janitor. По умолчанию порядок уровней будет алфавитно-числовым, как ранее. Обратите внимание, что NA не является уровнем фактора.\n\nlevels(linelist$delay_cat)\n\n[1] \"&lt;2 days\"  \"&gt;5 days\"  \"2-5 days\"\n\n\nФункция fct_relevel() имеет дополнительный функционал, поскольку позволяет вам вручную указать порядок уровней. Просто запишите значения уровня в нужном порядке в кавычках, разделенные запятыми, как показано ниже. Обратите внимание, что правописание должно быть идентичным значениям. Если вы хотите создать уровни, которые не существуют в данных, используйте вместо этого fct_expand()).\n\nlinelist &lt;- linelist %&gt;%\n  mutate(delay_cat = fct_relevel(delay_cat, \"&lt;2 days\", \"2-5 days\", \"&gt;5 days\"))\n\nТеперь мы видим, что уровни упорядочены, как указано в предыдущей команде, в понятном порядке.\n\nlevels(linelist$delay_cat)\n\n[1] \"&lt;2 days\"  \"2-5 days\" \"&gt;5 days\" \n\n\nТеперь порядок в графике имеет более интуитивно-понятный смысл.\n\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = delay_cat))",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Факторы</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.ru.html#добавление-или-удаление-уровней",
    "href": "new_pages/factors.ru.html#добавление-или-удаление-уровней",
    "title": "11  Факторы",
    "section": "11.3 Добавление или удаление уровней",
    "text": "11.3 Добавление или удаление уровней\n\nДобавление\nЕсли вам нужно добавить уровни к фактору, вы это можете сделать с помощью fct_expand(). Просто напишите название столбца, после которого идут новые уровни (разделенные запятыми). С помощью табулирования значений мы можем увидеть новые уровни и количество ноль. Вы можете использовать table() из базового R, либо tabyl() из janitor:\n\nlinelist %&gt;% \n  mutate(delay_cat = fct_expand(delay_cat, \"Not admitted to hospital\", \"Transfer to other jurisdiction\")) %&gt;% \n  tabyl(delay_cat)   # печать таблицы\n\n                      delay_cat    n    percent valid_percent\n                        &lt;2 days 2990 0.50781250     0.5308949\n                       2-5 days 2040 0.34646739     0.3622159\n                        &gt;5 days  602 0.10224185     0.1068892\n       Not admitted to hospital    0 0.00000000     0.0000000\n Transfer to other jurisdiction    0 0.00000000     0.0000000\n                           &lt;NA&gt;  256 0.04347826            NA\n\n\nПримечание: существует специальная функция forcats, чтобы легко добавить отсутствующие значения (NA) в качестве уровня. См. раздел Отсутствующие значения ниже.\n\n\nУдаление\nЕсли вы используете fct_drop(), “неиспользованные” уровни с нулевым количеством будут удалены из набора уровней. Уровень, который мы добавили выше (“Not admitted to a hospital”), существует в качестве уровня, но ни в одной из строк на самом деле нет таких значений. Поэтому они будут удалены при применении fct_drop() к столбцу фактор:\n\nlinelist %&gt;% \n  mutate(delay_cat = fct_drop(delay_cat)) %&gt;% \n  tabyl(delay_cat)\n\n delay_cat    n    percent valid_percent\n   &lt;2 days 2990 0.50781250     0.5308949\n  2-5 days 2040 0.34646739     0.3622159\n   &gt;5 days  602 0.10224185     0.1068892\n      &lt;NA&gt;  256 0.04347826            NA",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Факторы</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.ru.html#fct_adjust",
    "href": "new_pages/factors.ru.html#fct_adjust",
    "title": "11  Факторы",
    "section": "11.4 Корректировка порядка уровней",
    "text": "11.4 Корректировка порядка уровней\nПакет forcats предлагает полезные функции, чтобы легко скорректировать порядок уровней фактора (после того, как столбец определен как класс фактор):\nЭти функции можно применить к столбцу фактор в двух контекстах:\n\nК столбцу датафрейма, как обычно, чтобы трансформация была доступна при последующем использовании данных\n\nВнутри графика, чтобы это изменение применялось только к этому графику\n\n\nВручную\nЭта функция используется, чтобы вручную упорядочить уровни факторов. При использовании для столбца, который не относится к классу фактор, столбец сначала нужно конвертировать в класс фактор.\nВ скобках сначала укажите имя столбца фактора, затем укажите:\n\nЛибо все уровни в желаемом порядке (как текстовый вектор c()),\n\nЛибо один уровень и его правильное размещение, используя аргумент after =\n\nВот пример переопределения столбца delay_cat (который уже в классе Фактор) и уточнения желаемого порядка всех уровней.\n\n# переопределение порядка уровней\nlinelist &lt;- linelist %&gt;% \n  mutate(delay_cat = fct_relevel(delay_cat, c(\"&lt;2 days\", \"2-5 days\", \"&gt;5 days\")))\n\nЕсли вы хотите передвинуть только один уровень, вы можете его уточнить с помощью fct_relevel() отдельно и задать цифру в аргументе after =, чтобы указать, где в порядке он должен быть. Например, команда ниже сдвигает “&lt;2 days” на вторую позицию:\n\n# переопределение порядка уровней\nlinelist %&gt;% \n  mutate(delay_cat = fct_relevel(delay_cat, \"&lt;2 days\", after = 1)) %&gt;% \n  tabyl(delay_cat)\n\n\n\nВ графике\nКоманды forcats могут быть использованы, чтобы задать порядок уровней в датафрейме, либо только на графике. Используя команду, чтобы “обернуть” имя столбца внутри команды построения графика ggplot(), вы можете поменять порядок/уровень и трансформация будет применена только на этом графике.\nНиже мы создаем два графика с помощью ggplot() (см. страницу [Основы ggplot]). В первом, столбец delay_cat откладывается на оси x графика, с порядком уровней по умолчанию, как в данных linelist. Во втором примере, он обернут в fct_relevel(), и порядок меняется на графике.\n\n# Алфавитно-цифровой порядок по умолчанию - без корректировки в ggplot\nggplot(data = linelist)+\n    geom_bar(mapping = aes(x = delay_cat))\n\n# Порядок уровней фактора корректируется в рамках ggplot\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = fct_relevel(delay_cat, c(\"&lt;2 days\", \"2-5 days\", \"&gt;5 days\"))))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nОбратите внимание, что подпись оси x по умолчанию теперь выглядит достаточно сложно - вы можете ее изменить с помощью аргумента labs() в ggplot2.\n\n\nОбратный порядок\nДостаточно часто вам может потребоваться обратный порядок уровней. Просто оберните фактор в fct_rev().\nОбратите внимание, что если вы хотите получить обратный порядок только в легенде графика, но не хотите менять сами уровни фактора, вы можете это сделать с помощью guides() (см. [советы по использованию ggplot]).\n\n\nПо частоте\nЧтобы упорядочить по частоте возникновения значения в данных, используйте fct_infreq(). Любые отсутствующие значения (NA) будут автоматически включены в конце, если только они не конвертированы в конкретный уровень (см. этот раздел). Вы можете создать обратный порядок, дополнительно обернув в fct_rev().\nЭту функцию можно использовать в рамках ggplot(), как показано ниже.\n\n# упорядочивание по частоте\nggplot(data = linelist, aes(x = fct_infreq(delay_cat)))+\n  geom_bar()+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Ordered by frequency\")\n\n# обратная частота\nggplot(data = linelist, aes(x = fct_rev(fct_infreq(delay_cat))))+\n  geom_bar()+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Reverse of order by frequency\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nПо порядку появления\nИспользуйте fct_inorder(), чтобы установить порядок уровней в соответствии с порядком появления в данных, начиная с первой строки. Это может быть полезно, если вы сначала тщательно упорядочили данные в датафрейме с помощью arrange(), а затем используете это для определения порядка факторов.\n\n\nПо сводной статистике другого столбца\nВы можете использовать fct_reorder(), чтобы упорядочить уровни одного столбца по сводной статистике другого столбца. Визуально это может создать красивые графики, где столбцы/точки расположены в возрастающем или убывающем порядке на графике.\nВ примерах ниже ось х - это delay_cat, а ось y числовой столбец ct_blood (значение порогового цикла). Коробчатая диаграмма показывает распределение значения CT (порогового цикла) по группам delay_cat. Мы хотим упорядочить коробчатые диаграммы в возрастающем порядке по медианному значению CT в группе.\nВ первом примере ниже используется алфавитно-числовой порядок уровней по умолчанию. Вы можете видеть, что высота коробчатой диаграммы смешана, в ней нет определенного порядка. Во втором примере столбец delay_cat (отложенный на оси x) обернут в fct_reorder(), столбец ct_blood указан как второй аргумент, а “median” (медиана) задана в качестве третьего аргумента (вы можете также использовать “max” (максимум), “mean” (среднее), “min” (минимум) и т.п.). Таким образом порядок уровней delay_cat теперь будет отражать медиану значений CT в возрастающем порядке для медианных значений CT каждой группы delay_cat. Это отражается на втором графике - коробчатая диаграмма была упорядочена по возрастанию. Обратите внимание, что NA (отсутствующие значения) будут показаны в конце, если они не конвертированы в конкретный уровень.\n\n# коробчатая диаграмма упорядочена по оригинальным уровням фактора\nggplot(data = linelist)+\n  geom_boxplot(\n    aes(x = delay_cat,\n        y = ct_blood, \n        fill = delay_cat))+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Ordered by original alpha-numeric levels\")+\n  theme_classic()+\n  theme(legend.position = \"none\")\n\n\n# коробчатая диаграмма упорядочена по медианному значению CT\nggplot(data = linelist)+\n  geom_boxplot(\n    aes(x = fct_reorder(delay_cat, ct_blood, \"median\"),\n        y = ct_blood,\n        fill = delay_cat))+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Ordered by median CT value in group\")+\n  theme_classic()+\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nОбратите внимание, что не требуется шагов до ggplot() - группирование и расчеты делаются внутри команды ggplot.\n\n\nПо “конечному” значению\nИспользуйте fct_reorder2() для сгруппированных линейных диаграмм. Она упорядочивает уровни (и следовательно, легенду) так, чтобы организовать вертикальный порядок линий в “конце” графика. Технически, “упорядочивание идет по значениям на оси y, связанным с самыми высокими значениями x.”\nНапример, если у вас линии показывают количество случаев по больницам по времени, вы можете применить fct_reorder2() к аргументу color = в рамках aes(), так чтобы вертикальный порядок больниц, появляющийся в легенде, совпадал с порядком линий в конце графика. Более детально читайте в онлайн документации.\n\nepidemic_data &lt;- linelist %&gt;%         # начинаем с построчного списка   \n    filter(date_onset &lt; as.Date(\"2014-09-21\")) %&gt;%    # пороговая дата для визуальной ясности\n    count(                                            # получаем количество случаев по неделям и по больницам\n      epiweek = lubridate::floor_date(date_onset, \"week\"),  \n      hospital                                            \n    ) \n  \nggplot(data = epidemic_data)+                       # начинаем построение графика\n  geom_line(                                        # создаем линии\n    aes(\n      x = epiweek,                                  # ось x эпиднеделя\n      y = n,                                        # высота - количество случаев в неделю\n      color = fct_reorder2(hospital, epiweek, n)))+ # данные группируются и окрашиваются по больницам, а фактор упорядочен по высоте в конце графика\n  labs(title = \"Factor levels (and legend display) by line height at end of plot\",\n       color = \"Hospital\")                          # изменяем заголовок легенды",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Факторы</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.ru.html#fct_missing",
    "href": "new_pages/factors.ru.html#fct_missing",
    "title": "11  Факторы",
    "section": "11.5 Отсутствующие значения",
    "text": "11.5 Отсутствующие значения\nЕсли в вашем столбце фактора есть значения NA, вы с легкостью можете их конвертировать в именованный уровень, например, “Missing” с помощью fct_explicit_na(). Значения NA конвертируются в “(Missing)” в конце порядка уровней по умолчанию. Вы можете откорректировать имя уровня с помощью аргумента na_level =.\nНиже мы проводим эту операцию для столбца delay_cat и печатаем таблицу с помощью tabyl(), а NA конвертируются в “Missing delay”.\n\nlinelist %&gt;% \n  mutate(delay_cat = fct_explicit_na(delay_cat, na_level = \"Missing delay\")) %&gt;% \n  tabyl(delay_cat)\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `delay_cat = fct_explicit_na(delay_cat, na_level = \"Missing\n  delay\")`.\nCaused by warning:\n! `fct_explicit_na()` was deprecated in forcats 1.0.0.\nℹ Please use `fct_na_value_to_level()` instead.\n\n\n     delay_cat    n    percent\n      2-5 days 2040 0.34646739\n       &lt;2 days 2990 0.50781250\n       &gt;5 days  602 0.10224185\n Missing delay  256 0.04347826",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Факторы</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.ru.html#объединение-уровней",
    "href": "new_pages/factors.ru.html#объединение-уровней",
    "title": "11  Факторы",
    "section": "11.6 Объединение уровней",
    "text": "11.6 Объединение уровней\n\nВручную\nВы можете откорректировать отображения уровней вручную с помощью fct_recode(). Это похоже на функцию recode() в dplyr (см. страницу [Вычистка данных и ключевые функции]), но она позволяет создавать новые уровни факторов. Если вы используете просто recode() для фактора, новые перекодированные значения будут отклонены, если только они не заданы как разрешенные уровни.\nЭтот инструмент можно также использовать для “объединения” уровней, путем присваивания нескольким уровням одинакового перекодированного значения. Просто будьте осторожны, чтобы не потерять информацию! Попробуйте выполнить эти шаги объединения в новом столбце (вместо того, чтобы переделывать существующий столбец).\nfct_recode() имеет иной синтаксис, чем recode(). recode() использует СТАРЫЙ = НОВЫЙ, а fct_recode() использует НОВЫЙ = СТАРЫЙ.\nТекущие уровни delay_cat:\n\nlevels(linelist$delay_cat)\n\n[1] \"&lt;2 days\"  \"2-5 days\" \"&gt;5 days\" \n\n\nНовые уровни создаются с помощью синтаксиса fct_recode(столбец, \"новый\" = \"старый\", \"новый\" = \"старый\", \"новый\" = \"старый\") и печатаются:\n\nlinelist %&gt;% \n  mutate(delay_cat = fct_recode(\n    delay_cat,\n    \"Less than 2 days\" = \"&lt;2 days\",\n    \"2 to 5 days\"      = \"2-5 days\",\n    \"More than 5 days\" = \"&gt;5 days\")) %&gt;% \n  tabyl(delay_cat)\n\n        delay_cat    n    percent valid_percent\n Less than 2 days 2990 0.50781250     0.5308949\n      2 to 5 days 2040 0.34646739     0.3622159\n More than 5 days  602 0.10224185     0.1068892\n             &lt;NA&gt;  256 0.04347826            NA\n\n\nЗдесь они вручную объединяются с помощью fct_recode(). Обратите внимание, что не возникает ошибки при создании нового уровня “Less than 5 days”.\n\nlinelist %&gt;% \n  mutate(delay_cat = fct_recode(\n    delay_cat,\n    \"Less than 5 days\" = \"&lt;2 days\",\n    \"Less than 5 days\" = \"2-5 days\",\n    \"More than 5 days\" = \"&gt;5 days\")) %&gt;% \n  tabyl(delay_cat)\n\n        delay_cat    n    percent valid_percent\n Less than 5 days 5030 0.85427989     0.8931108\n More than 5 days  602 0.10224185     0.1068892\n             &lt;NA&gt;  256 0.04347826            NA\n\n\n\n\nСвертывание в “Прочие”\nВы можете использовать fct_other(), чтобы вручную присвоить уровни фактора к уровню “Other” (прочие). Ниже все уровни столбца hospital, кроме “Port Hospital” и “Central Hospital”, объединяются в “Other” (прочие). Вы можете задать вектор либо для keep =, либо drop =. Вы можете изменить отображение уровня “Other” с помощью other_level =.\n\nlinelist %&gt;%    \n  mutate(hospital = fct_other(                      # корректируем уровни\n    hospital,\n    keep = c(\"Port Hospital\", \"Central Hospital\"),  # эти оставляем отдельно\n    other_level = \"Other Hospital\")) %&gt;%            # все прочие идут в \"Other Hospital\"\n  tabyl(hospital)                                   # печать таблицы\n\n         hospital    n    percent\n Central Hospital  454 0.07710598\n    Port Hospital 1762 0.29925272\n   Other Hospital 3672 0.62364130\n\n\n\n\nСвертывание по частоте\nВы можете объединять наименее часто встречающиеся уровни факторов автоматически, используя fct_lump().\nЧтобы объединить несколько уровней с низкой частотой в группу “Other” (прочие), выполните одно из следующих действий:\n\nЗадайте n = как число групп, которые вы хотите сохранить. n количество наиболее часто встречающихся уровней будет сохранено, а все остальные будут объединены в “Other” (прочие).\n\nЗадайте prop = как порог доли частоты для уровней, выше которого вы хотите сохранить уровни. Все остальные значения будут объединены в “Other” (прочие).\n\nВы можете изменить отображение уровня “Other” с помощью other_level =. Ниже все больницы, кроме двух встречающихся наиболее часто, объединены в “Other Hospital” (прочие больницы).\n\nlinelist %&gt;%    \n  mutate(hospital = fct_lump(                      # корректируем уровни\n    hospital,\n    n = 2,                                          # сохраняем 2 верхних уровня\n    other_level = \"Other Hospital\")) %&gt;%            # все другие идут в \"Other Hospital\"\n  tabyl(hospital)                                   # печать таблицы\n\n       hospital    n   percent\n        Missing 1469 0.2494905\n  Port Hospital 1762 0.2992527\n Other Hospital 2657 0.4512568\n\n\n, warn ## Показать все уровни\nОдно из преимуществ использования факторов - стандартизировать вид легенд графиков и таблиц, вне зависимости от того, какие значения собственно присутствуют в наборе данных.\nЕсли вы готовите много рисунков (например, по множеству юрисдикций), вам нужно, чтобы легенды и таблицы выглядели идентично даже при разных уровнях полноты и состава данных.\n\n\nНа графиках\nНа рисунке ggplot() просто добавьте аргумент drop = FALSE в соответствующей функции scale_xxxx(). Все уровни факторов будут отображены, вне зависимости от того, присутствуют ли они в данных. Если ваши уровни столбца фактора отображены с помощью fill =, тогда в scale_fill_discrete() вам нужно включить drop = FALSE, как показано ниже. Если ваши уровни отображены с помощью x = (по оси x) color = или size = задайте этот аргумент в scale_color_discrete() или scale_size_discrete(), соответственно.\nВ данном примере мы строим столбчатую диаграмму с накоплением возрастных категорий по больницам. Добавление scale_fill_discrete(drop = FALSE) гарантирует, что все возрастные группы отобразятся в легенде, даже если их нет в данных.\n\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = hospital, fill = age_cat)) +\n  scale_fill_discrete(drop = FALSE)+                        # покажет все возрастные группы в легенде, даже если их нет\n  labs(\n    title = \"All age groups will appear in legend, even if not present in data\")\n\n\n\n\n\n\n\n\n\n\nВ таблицах\nКак функция table() из базового R, так и tabyl() из janitor покажет все уровни факторов (даже неиспользуемые уровни).\nЕсли вы используете count() или summarise() из dplyr, чтобы создать таблицу, добавьте аргумент .drop = FALSE, чтобы включить подсчет количества всех уровней фактора, даже не используемых.\nЧитайте дополнительную информацию на странице [Описательные таблицы], либо документацию scale_discrete, либо документацию count(). См. еще один пример на странице [Отслеживание контактов].",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Факторы</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.ru.html#эпиднедели",
    "href": "new_pages/factors.ru.html#эпиднедели",
    "title": "11  Факторы",
    "section": "11.7 Эпиднедели",
    "text": "11.7 Эпиднедели\nПожалуйста, см. детальное обсуждение того, как создавать эпидемиологические недели на странице [Группирование данных].\nТакже см. страницу [Работа с датами] для получения советов по тому, как создавать и форматировать эпидемиологические недели.\n\nЭпиднедели на графике\nЕсли ваша цель - создать эпиднедели для отображения на графике, вы можете это сделать с помощью floor_date() из lubridate, как объясняется на странице [Группирование данных]. Выданные значения будут в классе Дата в формате ГГГГ-ММ-ДД. Если вы используете этот столбец в графике, даты будут естественным образом отображены правильно, и вам нет необходимости переживать об уровнях или конвертации в класс Фактор. См. гистограмму ggplot() дат заболевания ниже.\nВ данном подходе вы можете откорректировать отображение дат на оси с помощью scale_x_date(). См. страницу [Эпидемические кривые] для получения более детальной информации. Вы можете уточнить формат отображения “strptime” в аргументе date_labels = в scale_x_date(). Эти форматы используют заполнители “%” и рассматриваются на странице [Работа с датами]. Используйте “%Y”, чтобы представить 4-значный год, и либо “%W”, либо “%U”, чтобы отобразить номер недели (недели с понедельника или воскресенья, соответственно).\n\nlinelist %&gt;% \n  mutate(epiweek_date = floor_date(date_onset, \"week\")) %&gt;%  # создаем столбец недель (week)\n  ggplot()+                                                  # начинаем ggplot\n  geom_histogram(mapping = aes(x = epiweek_date))+           # гистограмма по дате заболевания\n  scale_x_date(date_labels = \"%Y-W%W\")                       # корректируем отображение дат в формат ГГГГ-Ннн\n\n\n\n\n\n\n\n\n\n\nЭпиднедели в данных\nОднако, если ваша цель использования факторов заключается не в построении графиков, вы можете подойти к этому одним из двух способов:\n\nДля детального контроля отображения, конвертируйте столбец эпиднедели lubridate (ГГГГ-ММ-ДД) в желаемый формат отображения (ГГГГ-Ннн) внутри самого датафрейма, а затем конвертируйте его в класс Фактор.\n\nВо-первых, используйте format() из базового R для конвертации отображения даты из ГГГГ-ММ-ДД в ГГГГ-Ннн (см. страницу [Работа с датами]). В этом процессе класс будет конвертирован в текстовый. Затем конвертируйте из текстового класса в класс Фактор с помощью factor().\n\nlinelist &lt;- linelist %&gt;% \n  mutate(epiweek_date = floor_date(date_onset, \"week\"),       # создаем эпиднедели (ГГГГ-ММ-ДД)\n         epiweek_formatted = format(epiweek_date, \"%Y-W%W\"),  # Конвертируем для отображения (ГГГГ-Ннн)\n         epiweek_formatted = factor(epiweek_formatted))       # Конвертируем в фактор\n\n# Отображаем уровни\nlevels(linelist$epiweek_formatted)\n\n [1] \"2014-W13\" \"2014-W14\" \"2014-W15\" \"2014-W16\" \"2014-W17\" \"2014-W18\"\n [7] \"2014-W19\" \"2014-W20\" \"2014-W21\" \"2014-W22\" \"2014-W23\" \"2014-W24\"\n[13] \"2014-W25\" \"2014-W26\" \"2014-W27\" \"2014-W28\" \"2014-W29\" \"2014-W30\"\n[19] \"2014-W31\" \"2014-W32\" \"2014-W33\" \"2014-W34\" \"2014-W35\" \"2014-W36\"\n[25] \"2014-W37\" \"2014-W38\" \"2014-W39\" \"2014-W40\" \"2014-W41\" \"2014-W42\"\n[31] \"2014-W43\" \"2014-W44\" \"2014-W45\" \"2014-W46\" \"2014-W47\" \"2014-W48\"\n[37] \"2014-W49\" \"2014-W50\" \"2014-W51\" \"2015-W00\" \"2015-W01\" \"2015-W02\"\n[43] \"2015-W03\" \"2015-W04\" \"2015-W05\" \"2015-W06\" \"2015-W07\" \"2015-W08\"\n[49] \"2015-W09\" \"2015-W10\" \"2015-W11\" \"2015-W12\" \"2015-W13\" \"2015-W14\"\n[55] \"2015-W15\" \"2015-W16\"\n\n\nВНИМАНИЕ: Если вы разместите недели перед годами (“Ннн-ГГГГ”) (“%W-%Y”), алфавитно-числовое упорядочивание по умолчанию будет неверным (например, 01-2015 будет стоять раньше 35-2014). Возможно, вам потребуется вручную откорректировать порядок, что будет долгим и сложным процессом.\n\nДля быстрого отображения по умолчанию используйте пакет aweek и его функцию date2week(). Вы можете задать день начала недели week_start =, и если вы зададите factor = TRUE, тогда выходной столбец будет упорядоченным фактором. В качестве бонуса, фактор включает уровни для всех возможных недель в диапазоне - даже если нет случаев в эту неделю.\n\n\ndf &lt;- linelist %&gt;% \n  mutate(epiweek = date2week(date_onset, week_start = \"Monday\", factor = TRUE))\n\nlevels(df$epiweek)\n\nСм. страницу [Работа с датами] для получения более детальной информации о aweek. На ней также предлагается обратная функция week2date().",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Факторы</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.ru.html#ресурсы",
    "href": "new_pages/factors.ru.html#ресурсы",
    "title": "11  Факторы",
    "section": "11.8 Ресурсы",
    "text": "11.8 Ресурсы\nR for Data Science страница факторы\nвиньетка по пакету aweek",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Факторы</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.ru.html",
    "href": "new_pages/pivoting.ru.html",
    "title": "12  Поворот данных",
    "section": "",
    "text": "12.1 Подготовка",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Поворот данных</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.ru.html#подготовка",
    "href": "new_pages/pivoting.ru.html#подготовка",
    "title": "12  Поворот данных",
    "section": "",
    "text": "Загрузка пакетов\nДанный фрагмент кода показывает загрузку пакетов, необходимых для анализа. В данном руководстве мы фокусируемся на использовании p_load() из пакета pacman, которая устанавливает пакет, если необходимо, и загружает его для использования. Вы можете также загрузить установленные пакеты с помощью library() из базового R. См. страницу Основы R для получения дополнительной информации о пакетах R.\n\npacman::p_load(\n  rio,          # Импорт файла\n  here,         # Место расположения файла\n  kableExtra,   # Построение и манипуляции со сложными таблицами\n  tidyverse)    # Управление данными + графика ggplot2\n\n\n\nИмпорт данных\n\n\nДанные о количестве случаев малярии\nНа данной странице мы будем использовать выдуманный набор данных с ежедневным количеством случаев малярии в разбивке по организациям и возрастным группам. Если вы хотите параллельно выполнять все шаги, кликните сюда, чтобы скачать (в виде файла .rds). Импортируйте данные с помощью функции import() из пакета rio (он работает с множеством типов файлов, таких как .xlsx, .csv, .rds - см. детальную информацию на странице Импорт и экспорт).\n\n# Импорт данных\ncount_data &lt;- import(\"malaria_facility_count_data.rds\")\n\nПервые 50 строк отображены ниже.\n\n\n\n\n\n\n\n\nПострочный список случаев\nДальше на этой странице мы будем также использовать набор данных по случаям из имитационной эпидемии Эболы. Если вы хотите выполнять действия параллельно, кликните, чтобы скачать “чистый” построчный список (as .rds file). Импортируйте данные с помощью функции import() из пакета rio (он работает с множеством типов файлов, таких как .xlsx, .rds, .csv - см. детальную информацию на странице Импорт и экспорт).\n\n# импорт вашего набора данных\nlinelist &lt;- import(\"linelist_cleaned.xlsx\")",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Поворот данных</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.ru.html#из-широкой-в-длинную",
    "href": "new_pages/pivoting.ru.html#из-широкой-в-длинную",
    "title": "12  Поворот данных",
    "section": "12.2 Из широкой в длинную",
    "text": "12.2 Из широкой в длинную\n\n\n\n\n\n\n\n\n\n\n\n“Широкий” формат\nДанные часто вводятся и хранятся в “широком” формате - где характеристики или ответы субъекта хранятся в одной строке. Хотя это может быть полезно для презентации, это не очень подходит для некоторых типов анализа.\nДавайте возьмем набор данных count_data, испортированный в разделе Подготовка, в качестве примера. Вы можете видеть, что каждая строка представляет собой “день организации”. Фактическое количество случаев (в самом правом столбце) хранится в “широком” формате таким образом, что информация для каждой возрастной группы в конкретный день в организации хранится в одной строке.\n\n\n\n\n\n\nКаждое наблюдение в наборе данных относится к количеству случаев малярии в одной из 65 медицинских организаций в конкретную дату и варьируется от count_data$data_date %&gt;% min() до count_data$data_date %&gt;% max(). Эти организации расположены в одной провинции Province (Север) и в четырех районах District (Spring, Bolo, Dingo и Barnard). Набор данных дает общее количество случаев малярии, а также количество по трем возрастным группам - &lt;4 лет, 5-14 лет и 15 лет и старше.\n“Широкие” данные, такие как эти, не соответствуют стандартам “аккуратных данных”, поскольку заголовки столбцов на самом деле не представляют собой “переменные” - они представляют собой значения гипотетической переменной “возрастная группа”.\nЭтот формат может быть полезен для представления информации в таблице, либо для ввода данных (например, в Excel) из форм регистрации случаев. Однако на этапе анализа эти данные, как правило, следует трансформировать в более “длинный” формат в соответствии со стандартами “аккуратных данных”. Пакет построения графиков в R ggplot2, например, лучше всего работает с данными в “длинном” формате.\nВизуализация общего количества случаев малярии со временем не представляет собой сложности с данными в текущем формате:\n\nggplot(count_data) +\n  geom_col(aes(x = data_date, y = malaria_tot), width = 1)\n\n\n\n\n\n\n\n\nА если бы мы хотели отобразить относительный вклад каждой возрастной группы в это общее количество? В таком случае нам нужно убедиться, что интересующая переменная (возрастная группа) появляется в наборе данных в одном столбце, который можно указать в аргументе эстетики aes() в {ggplot2}.\n\n\n\npivot_longer()\nФункция pivot_longer() из tidyr поворачивает данные “вертикально”. tidyr является частью пакетов R tidyverse.\nОна принимает диапазон столбцов для трансформации (указываются в cols =). Следовательно, она может работать только над частью набора данных. Это полезно для данных по малярии, так как нам нужно повернуть только столбцы с количеством случаев.\nВ этом процессе у вас в итоге получится два “новых” столбца - один с категориями (раньше были именами столбцов), и один - с соответствующими значениям (например, количеством случаев). Вы можете принять имена по умолчанию для этих новых столбцов, либо вы можете указать собственные имена в names_to = и values_to =, соответственно.\nДавайте посмотрим pivot_longer() в действии…\n\n\nСтандартный поворот\nМы хотим использовать функцию pivot_longer() из tidyr, чтобы конвертировать “широкие” данные в “длинный” формат. В частности, чтобы конвертировать четыре числовых столбца с данными по количеству случаев малярии в два новых столбца: один, содержащий возрастные группы, и один, содержащий соответствующие значения.\n\ndf_long &lt;- count_data %&gt;% \n  pivot_longer(\n    cols = c(`malaria_rdt_0-4`, `malaria_rdt_5-14`, `malaria_rdt_15`, `malaria_tot`)\n  )\n\ndf_long\n\nОбратите внимание, что в новом созданном датафрейме (df_long) больше строк (12,152 по сравнению с 3,038); он стал длиннее. По сути он стал в четыре раза длиннее, поскольку каждая строка оригинального набора данных теперь представляет собой четыре строки в df_long, по одной для каждого из наблюдений по количеству случаев (&lt;4 лет, 5-14 лет, 15+ лет, и итого).\nКроме того, что набор данных стал длиннее, в нем стало меньше столбцов (8 против 10), поскольку те данные, которые раньше хранились в четырех столбцах (те, которые начинались с префикса malaria_), теперь хранятся в двух.\nПоскольку имена этих четырех столбцов все начинаются с префикса malaria_, мы могли бы использовать удобную функцию из “tidyselect” starts_with(), чтобы добиться того же результата (см. страницу Вычистка данных и ключевые функции для получения информации о других подобных функциях-помощниках).\n\n# задайте столбец с помощью функции-помощника tidyselect\ncount_data %&gt;% \n  pivot_longer(\n    cols = starts_with(\"malaria_\")\n  )\n\n# A tibble: 12,152 × 8\n   location_name data_date  submitted_date Province District newid name    value\n   &lt;chr&gt;         &lt;date&gt;     &lt;date&gt;         &lt;chr&gt;    &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;   &lt;int&gt;\n 1 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malari…    11\n 2 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malari…    12\n 3 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malari…    23\n 4 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malari…    46\n 5 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malari…    11\n 6 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malari…    10\n 7 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malari…     5\n 8 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malari…    26\n 9 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malari…     8\n10 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malari…     5\n# ℹ 12,142 more rows\n\n\nлибо по позиции:\n\n# задайте столбцы по позиции\ncount_data %&gt;% \n  pivot_longer(\n    cols = 6:9\n  )\n\nлибо по именованному диапазону:\n\n# задайте диапазон последовательных столбцов\ncount_data %&gt;% \n  pivot_longer(\n    cols = `malaria_rdt_0-4`:malaria_tot\n  )\n\nЭтим двум новым столбцам даются имена по умолчанию name и value, но мы можем их поменять, чтобы задать более осмысленные имена, которые помогут запомнить, что хранится в этих столбцах, используя аргументы names_to и values_to. Давайте использовать имена age_group и counts:\n\ndf_long &lt;- \n  count_data %&gt;% \n  pivot_longer(\n    cols = starts_with(\"malaria_\"),\n    names_to = \"age_group\",\n    values_to = \"counts\"\n  )\n\ndf_long\n\n# A tibble: 12,152 × 8\n   location_name data_date  submitted_date Province District newid age_group    \n   &lt;chr&gt;         &lt;date&gt;     &lt;date&gt;         &lt;chr&gt;    &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;        \n 1 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_…\n 2 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_…\n 3 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_…\n 4 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_tot  \n 5 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_…\n 6 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_…\n 7 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_…\n 8 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_tot  \n 9 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malaria_rdt_…\n10 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malaria_rdt_…\n# ℹ 12,142 more rows\n# ℹ 1 more variable: counts &lt;int&gt;\n\n\nТеперь мы можем передать этот новый набор данных в {ggplot2}, и отложить новый столбец count по оси y, а новый столбец age_group указать в аргументе fill = (внутренняя заливка столбца). Это позволит отобразить подсчет случаев малярии в виде столбчатой диаграммы с накоплением по возрастным группам:\n\nggplot(data = df_long) +\n  geom_col(\n    mapping = aes(x = data_date, y = counts, fill = age_group),\n    width = 1\n  )\n\n\n\n\n\n\n\n\nРассмотрите этот новый график и сравните его с графиком, который мы создали ранее - что пошло не так?\nМы столкнулись с частой проблемой при работе с данными эпиднадзора - мы также включили общее количество случаев из столбца malaria_tot, поэтому высота каждого столбика на графике в два раза выше, чем должна быть.\nМы можем решить эту проблему рядом способов. Мы просто отфильтруем это общее количество из набора данных, прежде чем передать его в ggplot():\n\ndf_long %&gt;% \n  filter(age_group != \"malaria_tot\") %&gt;% \n  ggplot() +\n  geom_col(\n    aes(x = data_date, y = counts, fill = age_group),\n    width = 1\n  )\n\n\n\n\n\n\n\n\nАльтернативно мы могли бы исключить эту переменную при выполнении pivot_longer(), оставив ее в наборе данных как отдельную переменную. См. как значения “расширяются”, чтобы заполнить эти новые строки.\n\ncount_data %&gt;% \n  pivot_longer(\n    cols = `malaria_rdt_0-4`:malaria_rdt_15,   # не включает столбец итого\n    names_to = \"age_group\",\n    values_to = \"counts\"\n  )\n\n# A tibble: 9,114 × 9\n   location_name data_date  submitted_date Province District malaria_tot newid\n   &lt;chr&gt;         &lt;date&gt;     &lt;date&gt;         &lt;chr&gt;    &lt;chr&gt;          &lt;int&gt; &lt;int&gt;\n 1 Facility 1    2020-08-11 2020-08-12     North    Spring            46     1\n 2 Facility 1    2020-08-11 2020-08-12     North    Spring            46     1\n 3 Facility 1    2020-08-11 2020-08-12     North    Spring            46     1\n 4 Facility 2    2020-08-11 2020-08-12     North    Bolo              26     2\n 5 Facility 2    2020-08-11 2020-08-12     North    Bolo              26     2\n 6 Facility 2    2020-08-11 2020-08-12     North    Bolo              26     2\n 7 Facility 3    2020-08-11 2020-08-12     North    Dingo             18     3\n 8 Facility 3    2020-08-11 2020-08-12     North    Dingo             18     3\n 9 Facility 3    2020-08-11 2020-08-12     North    Dingo             18     3\n10 Facility 4    2020-08-11 2020-08-12     North    Bolo              49     4\n# ℹ 9,104 more rows\n# ℹ 2 more variables: age_group &lt;chr&gt;, counts &lt;int&gt;\n\n\n\n\nПоворот данных нескольких классов\nПриведенный выше пример хорошо работает в тех ситуациях, где все столбцы, которые вы хотите “повернуть вертикально”, относятся к одному классу (текстовый, числовой, логический…).\nОднако может быть много случаев, когда вы, как прикладной эпидемиолог, будете работать с данными, которые были подготовлены неспециалистами и которые следуют своей нестандартной логике - как сказал Хэдли Уикэм (ссылаясь на Толстого) в своей знаковой статье по поводу принципов Аккуратных данных: “Как и семьи, аккуратные данные все одинаковы, но хаотичные данные хаотичны по-своему.”\nОдной из частых проблем, с которой вы можете столкнуться, будет необходимость поворачивать столбцы, которые содержат разные классы данных. Такой поворот приведет к тому, что эти разные типы данных будут храниться в одном столбце, что не очень хорошо. Существует ряд подходов, которые можно выбрать, чтобы разобраться с созданным хаосом, но есть важный шаг, который вы можете предпринять, используя pivot_longer(), чтобы избежать создания такой ситуации.\nПредставьте ситуацию, в которой у вас есть ряд наблюдений с разными временными отрезками для каждого из трех пунктов A, B и C. Такими пунктами могут быть отдельные люди (например, контакты случая Эболы, которые отслеживаются каждый день в течение 21 дня) или отдаленные сельские медицинские пункты, в которых идет мониторинг раз в год, чтобы убедиться, что они все еще работают. Давайте используем пример с отслеживанием контактов. Представьте, что данные хранятся следующим образом:\n\n\n\n\n\n\nКак видите, данные несколько запутаны. В каждой строке хранится информация об одном элементе, но при этом временной ряд с течением времени уходит все дальше и дальше вправо. Кроме того, классы столбцов чередуются между датой и текстовыми значениями.\nОдин из особенно плохих примеров, с которым столкнулся автор руководства, включал данные по эпиднадзору за холерой, в которых 8 столбцов наблюдений добавлялись каждый день в течение 4 лет. Даже просто открытие этого Excel файла с данными требовало &gt;10 минут на моем ноутбуке!\nЧтобы работать с этими данными, нам нужно преобразовать датафрейм в длинный формат, но при этом сохранить разделение между столбцом date (дата) и текстовым столбцом character (статус) для каждого наблюдения для каждого пункта. Если мы этого не сделаем, у нас может получиться смесь типов переменных в одном столбце (а это большое табу для управления данными и аккуратных данных):\n\ndf %&gt;% \n  pivot_longer(\n    cols = -id,\n    names_to = c(\"observation\")\n  )\n\n# A tibble: 18 × 3\n   id    observation value     \n   &lt;chr&gt; &lt;chr&gt;       &lt;chr&gt;     \n 1 A     obs1_date   2021-04-23\n 2 A     obs1_status Healthy   \n 3 A     obs2_date   2021-04-24\n 4 A     obs2_status Healthy   \n 5 A     obs3_date   2021-04-25\n 6 A     obs3_status Unwell    \n 7 B     obs1_date   2021-04-23\n 8 B     obs1_status Healthy   \n 9 B     obs2_date   2021-04-24\n10 B     obs2_status Healthy   \n11 B     obs3_date   2021-04-25\n12 B     obs3_status Healthy   \n13 C     obs1_date   2021-04-23\n14 C     obs1_status Missing   \n15 C     obs2_date   2021-04-24\n16 C     obs2_status Healthy   \n17 C     obs3_date   2021-04-25\n18 C     obs3_status Healthy   \n\n\nВыше поворот данных привел к слиянию дат и текста в один столбец значений value. R отреагирует путем конвертации всего столбца в текстовый класс, и польза от дат будет потеряна.\nЧтобы предотвратить такую ситуацию, мы можем воспользоваться структурой синтаксиса оригинальных имен столбцов. Существует общая структура именования с номером наблюдения, нижним подчеркиванием и либо “статусом”, либо “датой”. Мы можем использовать этот синтаксис, чтобы сохранить эти два типа данных в разных столбцах после поворота.\nМы это делаем следующим образом:\n\nУказываем текстовый вектор в аргументе names_to =, где второй пункт (\".value\" ). Это особое условие указывает на то, что повернутые столбцы будут разделены в зависимости от символа в их имени…\n\nВы также должны указать “разделяющий” символ в аргументе names_sep =. В данном случае это нижнее подчеркивание “_“.\n\nТаким образом, именование и разделение новых столбцов основано на нижнем подчеркивании в существующих именах переменных.\n\ndf_long &lt;- \n  df %&gt;% \n  pivot_longer(\n    cols = -id,\n    names_to = c(\"observation\", \".value\"),\n    names_sep = \"_\"\n  )\n\ndf_long\n\n# A tibble: 9 × 4\n  id    observation date       status \n  &lt;chr&gt; &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;  \n1 A     obs1        2021-04-23 Healthy\n2 A     obs2        2021-04-24 Healthy\n3 A     obs3        2021-04-25 Unwell \n4 B     obs1        2021-04-23 Healthy\n5 B     obs2        2021-04-24 Healthy\n6 B     obs3        2021-04-25 Healthy\n7 C     obs1        2021-04-23 Missing\n8 C     obs2        2021-04-24 Healthy\n9 C     obs3        2021-04-25 Healthy\n\n\nПоследние штрихи:\nОбратите внимание, что столбец дата date в настоящее время относится к текстовому классу - мы можем легко конвертировать его в правильный класс даты, используя функции mutate() и as_date(), описанные на странице Работа с датами.\nНам может быть также необходимо конвертировать столбец наблюдение observation в числовой формат numeric, убрав префикс “obs” и конвертации в числовой класс. Мы можем это сделать с помощью str_remove_all() из пакета stringr (см. страницу Текст и последовательности).\n\ndf_long &lt;- \n  df_long %&gt;% \n  mutate(\n    date = date %&gt;% lubridate::as_date(),\n    observation = \n      observation %&gt;% \n      str_remove_all(\"obs\") %&gt;% \n      as.numeric()\n  )\n\ndf_long\n\n# A tibble: 9 × 4\n  id    observation date       status \n  &lt;chr&gt;       &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;  \n1 A               1 2021-04-23 Healthy\n2 A               2 2021-04-24 Healthy\n3 A               3 2021-04-25 Unwell \n4 B               1 2021-04-23 Healthy\n5 B               2 2021-04-24 Healthy\n6 B               3 2021-04-25 Healthy\n7 C               1 2021-04-23 Missing\n8 C               2 2021-04-24 Healthy\n9 C               3 2021-04-25 Healthy\n\n\nТеперь мы можем начать работать с данными в этом формате, например, построив описательную мозаичную тепловую карту:\n\nggplot(data = df_long, mapping = aes(x = date, y = id, fill = status)) +\n  geom_tile(colour = \"black\") +\n  scale_fill_manual(\n    values = \n      c(\"Healthy\" = \"lightgreen\", \n        \"Unwell\" = \"red\", \n        \"Missing\" = \"orange\")\n  )",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Поворот данных</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.ru.html#из-длинной-в-широкую",
    "href": "new_pages/pivoting.ru.html#из-длинной-в-широкую",
    "title": "12  Поворот данных",
    "section": "12.3 Из длинной в широкую",
    "text": "12.3 Из длинной в широкую\n\n\n\n\n\n\n\n\n\nВ некоторых случаях нам может быть необходимо конвертировать набор данных в широкий формат. Для этого мы можем использовать функцию pivot_wider().\nТипичный пример применения - когда мы хотим трансформировать результаты анализа в формат, который более удобен для читателя (например, [Таблицы для презентации][Таблицы для презентации]). Как правило, это требует трансформации набора данных, в котором информация об одном субъекте распределена на несколько строк, в формат, где информация хранится в одной строке.\n\nДанные\nДля данного раздела страницы мы будем использовать построчный список случаев (см. раздел Подготовка), который содержит по одной строке на случай.\nHere are the first 50 rows:\n\n\n\n\n\n\nПредставим, что нам нужно узнать количество лиц в разных возрастных группах по полу:\n\ndf_wide &lt;- \n  linelist %&gt;% \n  count(age_cat, gender)\n\ndf_wide\n\n   age_cat gender   n\n1      0-4      f 640\n2      0-4      m 416\n3      0-4   &lt;NA&gt;  39\n4      5-9      f 641\n5      5-9      m 412\n6      5-9   &lt;NA&gt;  42\n7    10-14      f 518\n8    10-14      m 383\n9    10-14   &lt;NA&gt;  40\n10   15-19      f 359\n11   15-19      m 364\n12   15-19   &lt;NA&gt;  20\n13   20-29      f 468\n14   20-29      m 575\n15   20-29   &lt;NA&gt;  30\n16   30-49      f 179\n17   30-49      m 557\n18   30-49   &lt;NA&gt;  18\n19   50-69      f   2\n20   50-69      m  91\n21   50-69   &lt;NA&gt;   2\n22     70+      m   5\n23     70+   &lt;NA&gt;   1\n24    &lt;NA&gt;   &lt;NA&gt;  86\n\n\nЭто даст нам длинный набор данных, который хорошо подходит для подготовки визуализаций в ggplot2, но не очень подходит для презентации в виде таблицы:\n\nggplot(df_wide) +\n  geom_col(aes(x = age_cat, y = n, fill = gender))\n\n\n\n\n\n\n\n\n\n\nГоризонтальный поворот\nСледовательно, мы можем использовать pivot_wider(), чтобы преобразовать данные в более подходящий формат, чтобы включить в виде таблиц в наши отчеты.\nАргумент names_from определяет столбец, из которого генерируются новые имена столбца, а аргумент values_from уточняет столбец, из которого нужно взять значения для заполнения ячеек. Аргумент id_cols = является опциональным, но через него может быть задан вектор имен столбцов, которые не нужно поворачивать, и он таким образом определит каждую строку.\n\ntable_wide &lt;- \n  df_wide %&gt;% \n  pivot_wider(\n    id_cols = age_cat,\n    names_from = gender,\n    values_from = n\n  )\n\ntable_wide\n\n# A tibble: 9 × 4\n  age_cat     f     m  `NA`\n  &lt;fct&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n1 0-4       640   416    39\n2 5-9       641   412    42\n3 10-14     518   383    40\n4 15-19     359   364    20\n5 20-29     468   575    30\n6 30-49     179   557    18\n7 50-69       2    91     2\n8 70+        NA     5     1\n9 &lt;NA&gt;       NA    NA    86\n\n\nЭта таблица гораздо более удобна для читателя, следовательно, она больше подходит для включения в наши отчеты. Вы можете проводить конвертацию в красивую таблицу с помощью ряда пакетов, включая flextable и knitr. Этот процесс более детально рассматривается на странице [Таблицы для презентации].\n\ntable_wide %&gt;% \n  janitor::adorn_totals(c(\"row\", \"col\")) %&gt;% # добавляем итого по строкам и столбцам\n  knitr::kable() %&gt;% \n  kableExtra::row_spec(row = 10, bold = TRUE) %&gt;% \n  kableExtra::column_spec(column = 5, bold = TRUE) \n\n\n\n\n\nage_cat\nf\nm\nNA\nTotal\n\n\n\n\n0-4\n640\n416\n39\n1095\n\n\n5-9\n641\n412\n42\n1095\n\n\n10-14\n518\n383\n40\n941\n\n\n15-19\n359\n364\n20\n743\n\n\n20-29\n468\n575\n30\n1073\n\n\n30-49\n179\n557\n18\n754\n\n\n50-69\n2\n91\n2\n95\n\n\n70+\nNA\n5\n1\n6\n\n\nNA\nNA\nNA\n86\n86\n\n\nTotal\n2807\n2803\n278\n5888",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Поворот данных</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.ru.html#заполнение",
    "href": "new_pages/pivoting.ru.html#заполнение",
    "title": "12  Поворот данных",
    "section": "12.4 Заполнение",
    "text": "12.4 Заполнение\nВ некоторых ситуациях после поворота pivot, и еще чаще после связывания bind, у нас остаются пробелы в некоторых ячейках, которые нам нужно заполнить.\n\n\nДанные\nНапример, возьмем два набора данных, каждый с наблюдениями для номера измерений, названия организации, а также количеством случаев на этот момент. Однако во втором наборе данных есть также переменная Year.\n\ndf1 &lt;- \n  tibble::tribble(\n       ~Measurement, ~Facility, ~Cases,\n                  1,  \"Hosp 1\",     66,\n                  2,  \"Hosp 1\",     26,\n                  3,  \"Hosp 1\",      8,\n                  1,  \"Hosp 2\",     71,\n                  2,  \"Hosp 2\",     62,\n                  3,  \"Hosp 2\",     70,\n                  1,  \"Hosp 3\",     47,\n                  2,  \"Hosp 3\",     70,\n                  3,  \"Hosp 3\",     38,\n       )\n\ndf1 \n\n# A tibble: 9 × 3\n  Measurement Facility Cases\n        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;\n1           1 Hosp 1      66\n2           2 Hosp 1      26\n3           3 Hosp 1       8\n4           1 Hosp 2      71\n5           2 Hosp 2      62\n6           3 Hosp 2      70\n7           1 Hosp 3      47\n8           2 Hosp 3      70\n9           3 Hosp 3      38\n\ndf2 &lt;- \n  tibble::tribble(\n    ~Year, ~Measurement, ~Facility, ~Cases,\n     2000,            1,  \"Hosp 4\",     82,\n     2001,            2,  \"Hosp 4\",     87,\n     2002,            3,  \"Hosp 4\",     46\n  )\n\ndf2\n\n# A tibble: 3 × 4\n   Year Measurement Facility Cases\n  &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;\n1  2000           1 Hosp 4      82\n2  2001           2 Hosp 4      87\n3  2002           3 Hosp 4      46\n\n\nКогда мы проводим bind_rows(), чтобы соединить два набора данных, переменная Year заполняется NA для тех строк, по которым не было предварительной информации (т..е первый набор данных):\n\ndf_combined &lt;- \n  bind_rows(df1, df2) %&gt;% \n  arrange(Measurement, Facility)\n\ndf_combined\n\n# A tibble: 12 × 4\n   Measurement Facility Cases  Year\n         &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1           1 Hosp 1      66    NA\n 2           1 Hosp 2      71    NA\n 3           1 Hosp 3      47    NA\n 4           1 Hosp 4      82  2000\n 5           2 Hosp 1      26    NA\n 6           2 Hosp 2      62    NA\n 7           2 Hosp 3      70    NA\n 8           2 Hosp 4      87  2001\n 9           3 Hosp 1       8    NA\n10           3 Hosp 2      70    NA\n11           3 Hosp 3      38    NA\n12           3 Hosp 4      46  2002\n\n\n\n\n\nfill()\nВ данном случае Year является полезной переменной для включения, особенно если мы хотим изучить тренды со временем. Следовательно, мы используем fill(), чтобы заполнить эти пустые ячейки, указав столбец для заполнения и направление (в данном случае up - вверх):\n\ndf_combined %&gt;% \n  fill(Year, .direction = \"up\")\n\n# A tibble: 12 × 4\n   Measurement Facility Cases  Year\n         &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1           1 Hosp 1      66  2000\n 2           1 Hosp 2      71  2000\n 3           1 Hosp 3      47  2000\n 4           1 Hosp 4      82  2000\n 5           2 Hosp 1      26  2001\n 6           2 Hosp 2      62  2001\n 7           2 Hosp 3      70  2001\n 8           2 Hosp 4      87  2001\n 9           3 Hosp 1       8  2002\n10           3 Hosp 2      70  2002\n11           3 Hosp 3      38  2002\n12           3 Hosp 4      46  2002\n\n\nАльтернативно, мы можем сменить порядок данных, чтобы заполнять в направлении вниз:\n\ndf_combined &lt;- \n  df_combined %&gt;% \n  arrange(Measurement, desc(Facility))\n\ndf_combined\n\n# A tibble: 12 × 4\n   Measurement Facility Cases  Year\n         &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1           1 Hosp 4      82  2000\n 2           1 Hosp 3      47    NA\n 3           1 Hosp 2      71    NA\n 4           1 Hosp 1      66    NA\n 5           2 Hosp 4      87  2001\n 6           2 Hosp 3      70    NA\n 7           2 Hosp 2      62    NA\n 8           2 Hosp 1      26    NA\n 9           3 Hosp 4      46  2002\n10           3 Hosp 3      38    NA\n11           3 Hosp 2      70    NA\n12           3 Hosp 1       8    NA\n\ndf_combined &lt;- \n  df_combined %&gt;% \n  fill(Year, .direction = \"down\")\n\ndf_combined\n\n# A tibble: 12 × 4\n   Measurement Facility Cases  Year\n         &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1           1 Hosp 4      82  2000\n 2           1 Hosp 3      47  2000\n 3           1 Hosp 2      71  2000\n 4           1 Hosp 1      66  2000\n 5           2 Hosp 4      87  2001\n 6           2 Hosp 3      70  2001\n 7           2 Hosp 2      62  2001\n 8           2 Hosp 1      26  2001\n 9           3 Hosp 4      46  2002\n10           3 Hosp 3      38  2002\n11           3 Hosp 2      70  2002\n12           3 Hosp 1       8  2002\n\n\nТеперь у нас есть полезный набор данных для построения графика:\n\nggplot(df_combined) +\n  aes(Year, Cases, fill = Facility) +\n  geom_col()\n\n\n\n\n\n\n\n\nНо этот набор данных в меньшей степени подходит для презентации в виде таблицы, поэтому давайте попрактикуем конвертацию этого длинного неаккуратного датафрейма в широкий аккуратный датафрейм:\n\ndf_combined %&gt;% \n  pivot_wider(\n    id_cols = c(Measurement, Facility),\n    names_from = \"Year\",\n    values_from = \"Cases\"\n  ) %&gt;% \n  arrange(Facility) %&gt;% \n  janitor::adorn_totals(c(\"row\", \"col\")) %&gt;% \n  knitr::kable() %&gt;% \n  kableExtra::row_spec(row = 5, bold = TRUE) %&gt;% \n  kableExtra::column_spec(column = 5, bold = TRUE) \n\n\n\n\n\nMeasurement\nFacility\n2000\n2001\n2002\nTotal\n\n\n\n\n1\nHosp 1\n66\nNA\nNA\n66\n\n\n2\nHosp 1\nNA\n26\nNA\n26\n\n\n3\nHosp 1\nNA\nNA\n8\n8\n\n\n1\nHosp 2\n71\nNA\nNA\n71\n\n\n2\nHosp 2\nNA\n62\nNA\n62\n\n\n3\nHosp 2\nNA\nNA\n70\n70\n\n\n1\nHosp 3\n47\nNA\nNA\n47\n\n\n2\nHosp 3\nNA\n70\nNA\n70\n\n\n3\nHosp 3\nNA\nNA\n38\n38\n\n\n1\nHosp 4\n82\nNA\nNA\n82\n\n\n2\nHosp 4\nNA\n87\nNA\n87\n\n\n3\nHosp 4\nNA\nNA\n46\n46\n\n\nTotal\n-\n266\n245\n162\n673\n\n\n\n\n\n\n\n\nПримечание: В данном случае нам нужно было уточнить, что нужно включать только три переменных Facility, Year и Cases, поскольку дополнительная переменная Measurement мешала бы созданию таблицы:\n\ndf_combined %&gt;% \n  pivot_wider(\n    names_from = \"Year\",\n    values_from = \"Cases\"\n  ) %&gt;% \n  knitr::kable()\n\n\n\n\nMeasurement\nFacility\n2000\n2001\n2002\n\n\n\n\n1\nHosp 4\n82\nNA\nNA\n\n\n1\nHosp 3\n47\nNA\nNA\n\n\n1\nHosp 2\n71\nNA\nNA\n\n\n1\nHosp 1\n66\nNA\nNA\n\n\n2\nHosp 4\nNA\n87\nNA\n\n\n2\nHosp 3\nNA\n70\nNA\n\n\n2\nHosp 2\nNA\n62\nNA\n\n\n2\nHosp 1\nNA\n26\nNA\n\n\n3\nHosp 4\nNA\nNA\n46\n\n\n3\nHosp 3\nNA\nNA\n38\n\n\n3\nHosp 2\nNA\nNA\n70\n\n\n3\nHosp 1\nNA\nNA\n8",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Поворот данных</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.ru.html#ресурсы",
    "href": "new_pages/pivoting.ru.html#ресурсы",
    "title": "12  Поворот данных",
    "section": "12.5 Ресурсы",
    "text": "12.5 Ресурсы\nВот полезный самоучитель",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Поворот данных</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.ru.html",
    "href": "new_pages/grouping.ru.html",
    "title": "13  Группирование данных",
    "section": "",
    "text": "13.1 Подготовка",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Группирование данных</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.ru.html#подготовка",
    "href": "new_pages/grouping.ru.html#подготовка",
    "title": "13  Группирование данных",
    "section": "",
    "text": "Загрузка пакетов\nДанный фрагмент кода показывает загрузку пакетов, необходимых для анализа. В данном руководстве мы фокусируемся на использовании p_load() из пакета pacman, которая устанавливает пакет, если необходимо, и загружает его для использования. Вы можете также загрузить установленные пакеты с помощью library() из базового R. См. страницу Основы R для получения дополнительной информации о пакетах R.\n\npacman::p_load(\n  rio,       # для импорта данных\n  here,      # для расположения файла\n  tidyverse, # для вычистки, работы с данными и построения графиков (включает dplyr)\n  janitor)   # добавление строк и столбцов с итогами\n\n\n\nИмпорт данных\nМы импортируем набор данных о случаях имитированной эпидемии Эболы. Если вы хотите параллельно выполнять действия, кликните, чтобы скачать “чистый” построчный список (as .rds file). Набор данных импортируется с помощью функции import() из пакета rio. См. страницу Импорт и экспорт, где указаны разные способы импорта данных.\n\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nПервые 50 строк linelist:",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Группирование данных</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.ru.html#группирование",
    "href": "new_pages/grouping.ru.html#группирование",
    "title": "13  Группирование данных",
    "section": "13.2 Группирование",
    "text": "13.2 Группирование\nФункция group_by() из пакета dplyr группирует строки по уникальным значениям в указанном для функции столбце. Если указаны несколько столбцов, строки группируются по уникальным комбинациям значений по всем столбцам. Каждое уникальное значение (или комбинация значений) составляет группу. Дальнейшие изменения в наборе данных или расчетах затем можно проводить в контексте каждой группы.\nНапример, команда ниже берет linelist и группирует строки по уникальным значениям в столбце outcome, сохраняя выходные данные как новый датафрейм ll_by_outcome. Столбец(цы), по которым идет группирование, размещаются внутри скобок функции group_by().\n\nll_by_outcome &lt;- linelist %&gt;% \n  group_by(outcome)\n\nОбратите внимание, что в наборе данных нет видимых изменений после выполнения group_by(), пока не будет применена другая глагольная функция dplyr, такая как mutate(), summarise(), либо arrange() к “группированному” датафрейму.\nОднако вы можете “увидеть” группирование, напечатав датафрейм. Когда вы печатаете сгруппированный датафрейм, вы увидите, что он превратился в объект класса tibble который при печати отображает, какое группирование применено и сколько существует групп - это пишется над строкой заголовка.\n\n# печать, чтобы увидеть, какие группы активны\nll_by_outcome\n\n# A tibble: 5,888 × 30\n# Groups:   outcome [3]\n   case_id generation date_infection date_onset date_hospitalisation\n   &lt;chr&gt;        &lt;dbl&gt; &lt;date&gt;         &lt;date&gt;     &lt;date&gt;              \n 1 5fe599           4 2014-05-08     2014-05-13 2014-05-15          \n 2 8689b7           4 NA             2014-05-13 2014-05-14          \n 3 11f8ea           2 NA             2014-05-16 2014-05-18          \n 4 b8812a           3 2014-05-04     2014-05-18 2014-05-20          \n 5 893f25           3 2014-05-18     2014-05-21 2014-05-22          \n 6 be99c8           3 2014-05-03     2014-05-22 2014-05-23          \n 7 07e3e8           4 2014-05-22     2014-05-27 2014-05-29          \n 8 369449           4 2014-05-28     2014-06-02 2014-06-03          \n 9 f393b4           4 NA             2014-06-05 2014-06-06          \n10 1389ca           4 NA             2014-06-05 2014-06-07          \n# ℹ 5,878 more rows\n# ℹ 25 more variables: date_outcome &lt;date&gt;, outcome &lt;chr&gt;, gender &lt;chr&gt;,\n#   age &lt;dbl&gt;, age_unit &lt;chr&gt;, age_years &lt;dbl&gt;, age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;,\n#   hospital &lt;chr&gt;, lon &lt;dbl&gt;, lat &lt;dbl&gt;, infector &lt;chr&gt;, source &lt;chr&gt;,\n#   wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;, ct_blood &lt;dbl&gt;, fever &lt;chr&gt;, chills &lt;chr&gt;,\n#   cough &lt;chr&gt;, aches &lt;chr&gt;, vomit &lt;chr&gt;, temp &lt;dbl&gt;, time_admission &lt;chr&gt;,\n#   bmi &lt;dbl&gt;, days_onset_hosp &lt;dbl&gt;\n\n\n\nУникальные группы\nСозданные группы отображают каждую уникальную комбинацию значений по столбцам группирования.\nЧтобы увидеть группы и количество строк в каждой группе, передайте группированные данные в функцию tally().Чтобы увидеть только уникальные группы без подсчета количества вы можете передать их в group_keys().\nСм. ниже, что существует три уникальных значения в группируемом столбце исхода outcome: “Death” (смерть), “Recover” (выздоровление), и NA (отсутствует). Вы видите, что было nrow(linelist %&gt;% filter(outcome == \"Death\")) смертей, nrow(linelist %&gt;% filter(outcome == \"Recover\")) выздоровевших и nrow(linelist %&gt;% filter(is.na(outcome))) без документированного исхода.\n\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  tally()\n\n# A tibble: 3 × 2\n  outcome     n\n  &lt;chr&gt;   &lt;int&gt;\n1 Death    2582\n2 Recover  1983\n3 &lt;NA&gt;     1323\n\n\nВы можете группировать более чем по одному столбцу. Ниже датафрейм группируется по исходу outcome и полу gender, а затем делается подсчет. Обратите внимание, что каждая уникальная комбинация исхода outcome и пола gender регистрируется как отдельная группа - включая отсутствующие значения для каждого столбца.\n\nlinelist %&gt;% \n  group_by(outcome, gender) %&gt;% \n  tally()\n\n# A tibble: 9 × 3\n# Groups:   outcome [3]\n  outcome gender     n\n  &lt;chr&gt;   &lt;chr&gt;  &lt;int&gt;\n1 Death   f       1227\n2 Death   m       1228\n3 Death   &lt;NA&gt;     127\n4 Recover f        953\n5 Recover m        950\n6 Recover &lt;NA&gt;      80\n7 &lt;NA&gt;    f        627\n8 &lt;NA&gt;    m        625\n9 &lt;NA&gt;    &lt;NA&gt;      71\n\n\n\n\nНовые столбцы\nВы можете также создать новый столбец группирования внутри утверждения group_by(). Это все равно что поставить mutate() перед group_by(). Этот стиль может подойти для быстрого подсчета, но для ясности кода попробуйте создавать этот столбец отдельным шагом mutate() и потом присоединяйте его по каналу в group_by().\n\n# группирование данных на основе двоичного столбца, созданного *внутри* команды group_by()\nlinelist %&gt;% \n  group_by(\n    age_class = ifelse(age &gt;= 18, \"adult\", \"child\")) %&gt;% \n  tally(sort = T)\n\n# A tibble: 3 × 2\n  age_class     n\n  &lt;chr&gt;     &lt;int&gt;\n1 child      3618\n2 adult      2184\n3 &lt;NA&gt;         86\n\n\n\n\nДобавление/удаление столбцов группирования\nПо умолчанию если вы выполните group_by() для данных, которые уже сгруппированы, старые группы будут удалены и будут применены новые группы. Если вы хотите добавить новые группы к существующим, включите аргумент .add = TRUE.\n\n# Сгруппировано по исходу\nby_outcome &lt;- linelist %&gt;% \n  group_by(outcome)\n\n# Добавляем дополнительное группирование по полу\nby_outcome_gender &lt;- by_outcome %&gt;% \n  group_by(gender, .add = TRUE)\n\nСохраняем все группы\nЕсли вы сгруппируете по столбцу в классе фактор, могут быть уровни фактора, которых в настоящее время нет в данных. Если вы проведете группирование по этому столбцу, по умолчанию эти отсутствующие уровни будут выкинуты и не будут включены как группы. Чтобы это изменить так, чтобы все уровни появлялись как группы (даже если их нет в наличии в данных), установите в команде group_by() аргумент .drop = FALSE.",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Группирование данных</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.ru.html#разгруппирование",
    "href": "new_pages/grouping.ru.html#разгруппирование",
    "title": "13  Группирование данных",
    "section": "13.3 Разгруппирование",
    "text": "13.3 Разгруппирование\nДанные, которые были сгруппированы, останутся сгруппированными, пока вы их не разгруппируете с помощью ungroup(). Если вы забудете разгруппировать, это может привести к ошибкам в расчетах! Ниже представлен пример снятия всех группирований:\n\nlinelist %&gt;% \n  group_by(outcome, gender) %&gt;% \n  tally() %&gt;% \n  ungroup()\n\nВы можете также снять группирование только конкретных столбцов, разместив имя этого столбца внутри ungroup().\n\nlinelist %&gt;% \n  group_by(outcome, gender) %&gt;% \n  tally() %&gt;% \n  ungroup(gender) # снимаем группирование по полу, сохраняем группирование по исходу\n\nПРИМЕЧАНИЕ: Глагол count() автоматически разгруппирует данные после подсчета.",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Группирование данных</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.ru.html#group_summarise",
    "href": "new_pages/grouping.ru.html#group_summarise",
    "title": "13  Группирование данных",
    "section": "13.4 Резюмирование",
    "text": "13.4 Резюмирование\nСм. раздел dplyr страницы [Описательные таблицы] для получения детального описания того, как создавать суммарные таблицы с помощью summarise(). Здесь мы кратко рассматриваем то, как меняется поведение этой функции при применениии к группированным данным.\nфункция summarise() (или summarize()) из dplyr берет датафрейм и конвертирует его в новый сводный датафрейм, где столбцы содержат сводную статистику, которую вы зададите. В негруппированном датафрейме сводная статистика рассчитывается по всем строкам. Применение summarise() к группированным данным выдаст такую статистику для каждой группы.\nСинтаксис summarise() таков, что вы задаете имя(имена) нового сводного столба(ов), знак равно, а затем статистическую функцию, которую нужно применить к данным, как показано ниже. Например, min() (минимум), max() (максимум), median() (медиана), либо sd() (стандартное отклонение). В рамках статистической функции укажите столбец, над которым нужно работать и необходимый аргумент (например, na.rm = TRUE). Вы можете использовать sum() (сумма), чтобы подсчитать количество строк, соответствующих логическому критерию (с двойным знаком равно ==).\nНиже представлен пример применения summarise() без группирования данных. Полученная статистика является результатом для всего набора данных.\n\n# сводная статистика по разгруппированному построчному списку\nlinelist %&gt;% \n  summarise(\n    n_cases  = n(),\n    mean_age = mean(age_years, na.rm=T),\n    max_age  = max(age_years, na.rm=T),\n    min_age  = min(age_years, na.rm=T),\n    n_males  = sum(gender == \"m\", na.rm=T))\n\n  n_cases mean_age max_age min_age n_males\n1    5888 16.01831      84       0    2803\n\n\nДля сравнения, ниже представлено то же самое утверждение summarise(), но применительно к группированным данным. Статистика рассчитывается для каждой группы исходов outcome. Обратите внимание, что столбцы группирования переносятся в новый датафрейм.\n\n# сводная статистика по группированному построчному списку\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  summarise(\n    n_cases  = n(),\n    mean_age = mean(age_years, na.rm=T),\n    max_age  = max(age_years, na.rm=T),\n    min_age  = min(age_years, na.rm=T),\n    n_males    = sum(gender == \"m\", na.rm=T))\n\n# A tibble: 3 × 6\n  outcome n_cases mean_age max_age min_age n_males\n  &lt;chr&gt;     &lt;int&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;int&gt;\n1 Death      2582     15.9      76       0    1228\n2 Recover    1983     16.1      84       0     950\n3 &lt;NA&gt;       1323     16.2      69       0     625\n\n\nСОВЕТ: Функция резюмирования работает и в британском, и в американском написании слова - summarise() и summarize() выполняют одинаковую функцию.",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Группирование данных</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.ru.html#подсчет-с-помощью-count-и-tally",
    "href": "new_pages/grouping.ru.html#подсчет-с-помощью-count-и-tally",
    "title": "13  Группирование данных",
    "section": "13.5 Подсчет с помощью count и tally",
    "text": "13.5 Подсчет с помощью count и tally\ncount() и tally() выполняют схожий функционал, но отличаются друг от друга. Более подробно об этих отличиях между tally() и count() можно прочитать тут\n\ntally()\ntally() - это сокращение для summarise(n = n()) и не группирует данные. Таким образом, чтбы получить группированный подсчет, перед ней должна идти команда group_by(). Вы можете добавить sort = TRUE, чтобы сначала увидеть более крупные группы.\n\nlinelist %&gt;% \n  tally()\n\n     n\n1 5888\n\n\n\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  tally(sort = TRUE)\n\n# A tibble: 3 × 2\n  outcome     n\n  &lt;chr&gt;   &lt;int&gt;\n1 Death    2582\n2 Recover  1983\n3 &lt;NA&gt;     1323\n\n\n\n\ncount()\nА команда count() работает следующим образом:\n\nприменяет group_by() к указанному столбцу(ам)\n\nприменяет summarise() и выдает столбец n с количеством строк на группу\n\nприменяет ungroup()\n\n\nlinelist %&gt;% \n  count(outcome)\n\n  outcome    n\n1   Death 2582\n2 Recover 1983\n3    &lt;NA&gt; 1323\n\n\nКак и в случаев с group_by() вы можете создать новый столбец внутри команды count():\n\nlinelist %&gt;% \n  count(age_class = ifelse(age &gt;= 18, \"adult\", \"child\"), sort = T)\n\n  age_class    n\n1     child 3618\n2     adult 2184\n3      &lt;NA&gt;   86\n\n\ncount() можно вызывать несколько раз, а ее функционал будет “комбинироватся”. Например, чтобы свести количество больниц, в которых есть каждый пол, выполните следующее. Обратите внимание, что имя итогового столбца меняется с имени по умолчанию “n” для большей ясности (с помощью name  =).\n\nlinelist %&gt;% \n  # создаем подсчет по уникальным группам исход-пол\n  count(gender, hospital) %&gt;% \n  # собираем строки по полу (3) и считаем количество больниц на пол (6)\n  count(gender, name = \"hospitals per gender\" ) \n\n  gender hospitals per gender\n1      f                    6\n2      m                    6\n3   &lt;NA&gt;                    6\n\n\n\n\nДобавить подсчеты\nВместо count() и summarise() вы можете использовать add_count(), чтобы добавить новый столбец n с подсчетом строк на группу, при этом сохранив все остальные столбцы датафрейма.\nЭто означает, что подсчитанное количество по группе в новом столбце n будет напечатано в каждой строке группы. Для демонстрации мы добавим этот столбец, а затем переупорядочим столбцы для облегчения просмотра. См. раздел ниже фильтр по размеру группы, где приведен еще один пример.\n\nlinelist %&gt;% \n  as_tibble() %&gt;%                   # конвертируем в таблицу tibble для более красивой печати \n  add_count(hospital) %&gt;%           # добавляем столбец n с подсчетами по больнице\n  select(hospital, n, everything()) # переупорядочиваем для демонстрации\n\n# A tibble: 5,888 × 31\n   hospital                       n case_id generation date_infection date_onset\n   &lt;chr&gt;                      &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt; &lt;date&gt;         &lt;date&gt;    \n 1 Other                        885 5fe599           4 2014-05-08     2014-05-13\n 2 Missing                     1469 8689b7           4 NA             2014-05-13\n 3 St. Mark's Maternity Hosp…   422 11f8ea           2 NA             2014-05-16\n 4 Port Hospital               1762 b8812a           3 2014-05-04     2014-05-18\n 5 Military Hospital            896 893f25           3 2014-05-18     2014-05-21\n 6 Port Hospital               1762 be99c8           3 2014-05-03     2014-05-22\n 7 Missing                     1469 07e3e8           4 2014-05-22     2014-05-27\n 8 Missing                     1469 369449           4 2014-05-28     2014-06-02\n 9 Missing                     1469 f393b4           4 NA             2014-06-05\n10 Missing                     1469 1389ca           4 NA             2014-06-05\n# ℹ 5,878 more rows\n# ℹ 25 more variables: date_hospitalisation &lt;date&gt;, date_outcome &lt;date&gt;,\n#   outcome &lt;chr&gt;, gender &lt;chr&gt;, age &lt;dbl&gt;, age_unit &lt;chr&gt;, age_years &lt;dbl&gt;,\n#   age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;, lon &lt;dbl&gt;, lat &lt;dbl&gt;, infector &lt;chr&gt;,\n#   source &lt;chr&gt;, wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;, ct_blood &lt;dbl&gt;, fever &lt;chr&gt;,\n#   chills &lt;chr&gt;, cough &lt;chr&gt;, aches &lt;chr&gt;, vomit &lt;chr&gt;, temp &lt;dbl&gt;,\n#   time_admission &lt;chr&gt;, bmi &lt;dbl&gt;, days_onset_hosp &lt;dbl&gt;\n\n\n\n\nДобавление Итого\nЧтобы легко добавить итоговую сумму по строкам или столбцам после применения tally() или count(), см. раздел janitor на странице Описательные таблицы. Этот пакет предлагает другие функции, такие как adorn_totals() и adorn_percentages(), чтобы складывать итоговые показатели и конвертировать для отображения в виде процентов. Ниже приведен короткий пример:\n\nlinelist %&gt;%                                  # построчный список случаев\n  tabyl(age_cat, gender) %&gt;%                  # кросс-табуляция подсчета по двум столбцам\n  adorn_totals(where = \"row\") %&gt;%             # добавляем строку итого\n  adorn_percentages(denominator = \"col\") %&gt;%  # конвертируем в долю со знаменателем столбца\n  adorn_pct_formatting() %&gt;%                  # конвертируем долю в проценты\n  adorn_ns(position = \"front\") %&gt;%            # отображаем как: \"count (percent)\"\n  adorn_title(                                # корректируем заголовки\n    row_name = \"Age Category\",\n    col_name = \"Gender\")\n\n                      Gender                            \n Age Category              f              m          NA_\n          0-4   640  (22.8%)   416  (14.8%)  39  (14.0%)\n          5-9   641  (22.8%)   412  (14.7%)  42  (15.1%)\n        10-14   518  (18.5%)   383  (13.7%)  40  (14.4%)\n        15-19   359  (12.8%)   364  (13.0%)  20   (7.2%)\n        20-29   468  (16.7%)   575  (20.5%)  30  (10.8%)\n        30-49   179   (6.4%)   557  (19.9%)  18   (6.5%)\n        50-69     2   (0.1%)    91   (3.2%)   2   (0.7%)\n          70+     0   (0.0%)     5   (0.2%)   1   (0.4%)\n         &lt;NA&gt;     0   (0.0%)     0   (0.0%)  86  (30.9%)\n        Total 2,807 (100.0%) 2,803 (100.0%) 278 (100.0%)\n\n\nЧтобы добавить более сложные строки Итого, которые требуют сводной статистики, а не просто суммы, см. этот раздел страницы Описательные таблицы.",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Группирование данных</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.ru.html#группировка-по-дате",
    "href": "new_pages/grouping.ru.html#группировка-по-дате",
    "title": "13  Группирование данных",
    "section": "13.6 Группировка по дате",
    "text": "13.6 Группировка по дате\nПри группировании данных по дате, у вас должен быть (или вам нужно создать) столбец с интересующей единицей даты - например, “день”, “эпиднеделя”, “месяц” и т.п. Вы можете создать этот столбец, используя floor_date() из lubridate, как объясняется в разделе Эпидемиологические недели страницы [Работа с датами]. Как только у вас будет такой столбец, вы можете использовать count() из dplyr, чтобы сгруппировать строки по этим уникальным значениям даты и получить агрегированный подсчет.\nЕще один дополнительный шаг, часто встречающийся в ситуации с датами - “заполнение” дат в последовательности, которые не присутствуют в данных. Используйте complete() из tidyr, чтобы агрегированный ряд дат был полным, включая все возможные единицы дат в диапазоне. Без этого шага неделя, в которой не было зарегистрировано случаев, может не появиться в ваших данных!\nВ рамках complete() вы переопределяете ваш столбец дата как последовательность дат seq.Date() от минимальной до максимальной - таким образом расширяются даты. По умолчанию значения подсчета случаев в любых новых “расширенных” строках будут NA. Вы можете их установить на 0, используя аргумент fill = в complete(), который ожидает именованного списка (если ваш столбец подсчет назван n, задайте fill = list(n = 0). См. ?complete для получения более детальной информации, а также пример на странице Работа с датами.\n\nПострочный список случаев по дням\nЗдесь приведен пример группирования случаев по дням без использования complete(). Обратите внимание, что первые строки пропускают даты без случаев.\n\ndaily_counts &lt;- linelist %&gt;% \n  drop_na(date_onset) %&gt;%        # удаляем те, в которых отсутствует дата заболевания (date_onset)\n  count(date_onset)              # считаем количество строк на уникальную дату\n\n\n\n\n\n\n\nНиже мы добавляем команду complete(), чтобы убедиться, что каждый день в диапазоне представлен.\n\ndaily_counts &lt;- linelist %&gt;% \n  drop_na(date_onset) %&gt;%                 # удаляем случаи, где отсутствует дата заболевания (date_onset)\n  count(date_onset) %&gt;%                   # считаем количество строк на уникальную дату\n  complete(                               # чтобы появились все даты, даже без случаев\n    date_onset = seq.Date(                # переопределяем столбец дата как ежедневную последовательность дат\n      from = min(date_onset, na.rm=T), \n      to = max(date_onset, na.rm=T),\n      by = \"day\"),\n    fill = list(n = 0))                   # задаем отображение 0 во всех новых заполненных строках в столбце n (вместо NA как отображается по умолчанию) \n\n\n\n\n\n\n\n\n\nПострочный список случаев по неделям\nТот же принцип можно применить к неделям. Сначала создаем новый столбец - неделя случая, используя floor_date() с аргументом unit = \"week\". Затем используем count(), как показано выше, чтобы получить понедельное количество случаев. Затем закончите с помощью complete(), чтобы убедиться, что присутствуют все недели, даже если в них не было случаев.\n\n# Создаем набор данных с недельным количеством случаев\nweekly_counts &lt;- linelist %&gt;% \n  drop_na(date_onset) %&gt;%                 # удаляем случаи с отсутствующей датой заболевания (date_onset)\n  mutate(week = lubridate::floor_date(date_onset, unit = \"week\")) %&gt;%  # новый столбец недели заболевания\n  count(week) %&gt;%                         # группируем данные по неделе и считаем количество строк на группу\n  complete(                               # чтобы появились все дни, даже без случаев\n    week = seq.Date(                      # переопределяем столбец дата как ежедневную последовательность дат\n      from = min(week, na.rm=T), \n      to = max(week, na.rm=T),\n      by = \"week\"),\n    fill = list(n = 0))                   #  задаем отображение 0 во всех новых заполненных строках в столбце n (вместо NA как отображается по умолчанию)\n\nВот первые 50 строк получившегося датафрейма:\n\n\n\n\n\n\n###Построчный список случаев по месяцам {.unnumbered}\nЧтобы агрегировать случаи по месяцам, снова используйте floor_date() из пакета lubridate, но с аргументом unit = \"months\". Это округлит дату вниз до 1го числа месяца. Выходные данные будут в классе Дата. Обратите внимание, что в шаге complete(), мы также используем аргумент by = \"months\".\n\n# Создаем набор данных ежемесячного количества случаев\nmonthly_counts &lt;- linelist %&gt;% \n  drop_na(date_onset) %&gt;% \n  mutate(month = lubridate::floor_date(date_onset, unit = \"months\")) %&gt;%  # новый столбец, 1е число месяца заболевания\n  count(month) %&gt;%                          # подсчет количества случаев по месяцу\n  complete(\n    month = seq.Date(\n      min(month, na.rm=T),     # включает все месяцы, где не было зарегистрировано случаев\n      max(month, na.rm=T),\n      by=\"month\"),\n    fill = list(n = 0))\n\n\n\n\n\n\n\n\n\nЕжедневное количество в недельное\nЧтобы агрегировать ежедневное количество случаев в недельное количество, используйте floor_date() как показано выше. Однако, используйте group_by() и summarize() вместо count(), поскольку вам нужна сумма sum() ежедневного количества случаев, а не просто подсчет количества строк в неделю.\n\nЕжедневное количество в месячное\nЧтобы агрегировать ежедневное количество случаев в месячное количество, используйте floor_date() с аргументом unit = \"month\", как показано выше. Однако, используйте group_by() и summarize() вместо count(), поскольку вам нужна сумма sum() ежедневного количества случаев, а не просто подсчет количества строк в месяц.",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Группирование данных</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.ru.html#упорядочивание-сгруппированных-данных",
    "href": "new_pages/grouping.ru.html#упорядочивание-сгруппированных-данных",
    "title": "13  Группирование данных",
    "section": "13.7 Упорядочивание сгруппированных данных",
    "text": "13.7 Упорядочивание сгруппированных данных\nИспользование глагольной функции arrange() из dplyr, чтобы упорядочить строки в датафрейме, даст вам такое же поведение, как и при группировании данных, если только вы не зададите аргумент .by_group =TRUE. В таком случае строки будут сначала упорядочены по группированным столбцам, которые вы укажете в аргументе arrange().",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Группирование данных</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.ru.html#фильтр-по-группированным-данным",
    "href": "new_pages/grouping.ru.html#фильтр-по-группированным-данным",
    "title": "13  Группирование данных",
    "section": "13.8 Фильтр по группированным данным",
    "text": "13.8 Фильтр по группированным данным\n\nfilter()\nПри применении в сочетании с функциями, которые оценивают датафрейм (например, max(), min(), mean()), эти функции теперь будут применяться к группам. Например, если вы хотите фильтровать и сохранить те строки, где пациенты старше медианного возраста, это теперь будет применяться по группам - фильтр, чтобы сохранить строки выше медианного возраста группы.\n\n\nВыбор строк в группе\nФункция slice() из dplyr, которая фильтрует строки на основе их положения в данных, может также применяться к группе. Помните, что нужно учесть сортировку данных внутри каждой группы, чтобы получить желаемый “срез”.\nНапример, чтобы извлечь только последние 5 госпитализаций из каждой больницы:\n\nСгруппируйте построчный список по столбцу hospital\n\nУпорядочьте записи от самой последней к самой ранней дате госпитализации date_hospitalisation внутри каждой группы больниц\n\nИспользуйте slice, чтобы извлечь первые 5 строк для каждой больницы\n\n\nlinelist %&gt;%\n  group_by(hospital) %&gt;%\n  arrange(hospital, date_hospitalisation) %&gt;%\n  slice_head(n = 5) %&gt;% \n  arrange(hospital) %&gt;%                            # для отображения\n  select(case_id, hospital, date_hospitalisation)  # для отображения\n\n# A tibble: 30 × 3\n# Groups:   hospital [6]\n   case_id hospital          date_hospitalisation\n   &lt;chr&gt;   &lt;chr&gt;             &lt;date&gt;              \n 1 20b688  Central Hospital  2014-05-06          \n 2 d58402  Central Hospital  2014-05-10          \n 3 b8f2fd  Central Hospital  2014-05-13          \n 4 acf422  Central Hospital  2014-05-28          \n 5 275cc7  Central Hospital  2014-05-28          \n 6 d1fafd  Military Hospital 2014-04-17          \n 7 974bc1  Military Hospital 2014-05-13          \n 8 6a9004  Military Hospital 2014-05-13          \n 9 09e386  Military Hospital 2014-05-14          \n10 865581  Military Hospital 2014-05-15          \n# ℹ 20 more rows\n\n\nslice_head() - выбирает n строк сверху\nslice_tail() - выбирает n строк снизу\nslice_sample() - случайно выбирает n строк\nslice_min() - выбирает n строк с наибольшими значениями в столбце order_by =, используйте with_ties = TRUE, чтобы сохранить связи\nslice_max() - выбирает n строк с наименьшими значениями в столбце order_by =, используйте with_ties = TRUE, чтобы сохранить связи\nСм. страницу [Дедупликация], где представлено больше примеров и деталей по slice().\n\n\nФильтр по размеру группы\nФукнция add_count() добавляет столбец n к оригинальным данным, указывая количество строк в этой группе строк.\nНиже показано, как add_count() применяется к столбцу hospital, так что значения в новом столбце n отражают количество строк в группе больниц этой строки. Обратите внимание, что значения в столбце n повторяются. В примере ниже, столбец n можно изменить, используя name = внутри add_count(). Для демонстрационных целей мы переупорядочиваем столбцы с помощью select().\n\nlinelist %&gt;% \n  as_tibble() %&gt;% \n  add_count(hospital) %&gt;%          # добавляем \"количество строк госпитализированных в ту же больницу, что и эта строка\" \n  select(hospital, n, everything())\n\n# A tibble: 5,888 × 31\n   hospital                       n case_id generation date_infection date_onset\n   &lt;chr&gt;                      &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt; &lt;date&gt;         &lt;date&gt;    \n 1 Other                        885 5fe599           4 2014-05-08     2014-05-13\n 2 Missing                     1469 8689b7           4 NA             2014-05-13\n 3 St. Mark's Maternity Hosp…   422 11f8ea           2 NA             2014-05-16\n 4 Port Hospital               1762 b8812a           3 2014-05-04     2014-05-18\n 5 Military Hospital            896 893f25           3 2014-05-18     2014-05-21\n 6 Port Hospital               1762 be99c8           3 2014-05-03     2014-05-22\n 7 Missing                     1469 07e3e8           4 2014-05-22     2014-05-27\n 8 Missing                     1469 369449           4 2014-05-28     2014-06-02\n 9 Missing                     1469 f393b4           4 NA             2014-06-05\n10 Missing                     1469 1389ca           4 NA             2014-06-05\n# ℹ 5,878 more rows\n# ℹ 25 more variables: date_hospitalisation &lt;date&gt;, date_outcome &lt;date&gt;,\n#   outcome &lt;chr&gt;, gender &lt;chr&gt;, age &lt;dbl&gt;, age_unit &lt;chr&gt;, age_years &lt;dbl&gt;,\n#   age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;, lon &lt;dbl&gt;, lat &lt;dbl&gt;, infector &lt;chr&gt;,\n#   source &lt;chr&gt;, wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;, ct_blood &lt;dbl&gt;, fever &lt;chr&gt;,\n#   chills &lt;chr&gt;, cough &lt;chr&gt;, aches &lt;chr&gt;, vomit &lt;chr&gt;, temp &lt;dbl&gt;,\n#   time_admission &lt;chr&gt;, bmi &lt;dbl&gt;, days_onset_hosp &lt;dbl&gt;\n\n\nЗатем становится легче фильтровать по строкам случаев, которые были госпитализированы в “маленькую” больницу, например, в больницу, куда госпитализировано менее 500 пациентов:\n\nlinelist %&gt;% \n  add_count(hospital) %&gt;% \n  filter(n &lt; 500)",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Группирование данных</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.ru.html#функция-mutate-для-сгруппированных-данных",
    "href": "new_pages/grouping.ru.html#функция-mutate-для-сгруппированных-данных",
    "title": "13  Группирование данных",
    "section": "13.9 Функция mutate для сгруппированных данных",
    "text": "13.9 Функция mutate для сгруппированных данных\nЧтобы сохранить все столбцы и строки (не обобщать) и добавить новый столбец, содержащий стастистику группы, используйте mutate() после group_by() вместо summarise().\nЭто полезно, если вы хотите получить статистику группы в оригинальном наборе данных с сохранением всех остальных столбцов - например, для расчетов, которые сравнивают одну строку с ее группой.\nНапример, код ниже рассчитывает разницу между задержкой госпитализации строки и медианной задержкой по этой больнице. Выполняются следующие шаги:\n\nГруппируем данные по больнице\n\nИспользуем столбец days_onset_hosp (задержка госпитализации), чтобы создать новый столбец, содержащий среднюю задержку в больнице из этой строки\n\nРассчитываем разницу между двумя столбцами\n\nМы выбираем только некоторые столбцы для отображения с помощью select() для целей демонстрации.\n\nlinelist %&gt;% \n  # группируем данные по больнице (еще не изменяем построчный список)\n  group_by(hospital) %&gt;% \n  \n  # новые столбцы\n  mutate(\n    # среднее количество дней до госпитализации по больнице (округляется до 1 десятичного знака)\n    group_delay_admit = round(mean(days_onset_hosp, na.rm=T), 1),\n    \n    # разница между задержкой строки и средней задержкой в этой больнице (округляется до 1 десятичного знака)\n    diff_to_group     = round(days_onset_hosp - group_delay_admit, 1)) %&gt;%\n  \n  # выбираем только определенные строки для демонстрации/просмотра\n  select(case_id, hospital, days_onset_hosp, group_delay_admit, diff_to_group)\n\n# A tibble: 5,888 × 5\n# Groups:   hospital [6]\n   case_id hospital              days_onset_hosp group_delay_admit diff_to_group\n   &lt;chr&gt;   &lt;chr&gt;                           &lt;dbl&gt;             &lt;dbl&gt;         &lt;dbl&gt;\n 1 5fe599  Other                               2               2             0  \n 2 8689b7  Missing                             1               2.1          -1.1\n 3 11f8ea  St. Mark's Maternity…               2               2.1          -0.1\n 4 b8812a  Port Hospital                       2               2.1          -0.1\n 5 893f25  Military Hospital                   1               2.1          -1.1\n 6 be99c8  Port Hospital                       1               2.1          -1.1\n 7 07e3e8  Missing                             2               2.1          -0.1\n 8 369449  Missing                             1               2.1          -1.1\n 9 f393b4  Missing                             1               2.1          -1.1\n10 1389ca  Missing                             2               2.1          -0.1\n# ℹ 5,878 more rows",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Группирование данных</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.ru.html#функция-select-для-сгруппированных-данных",
    "href": "new_pages/grouping.ru.html#функция-select-для-сгруппированных-данных",
    "title": "13  Группирование данных",
    "section": "13.10 Функция select для сгруппированных данных",
    "text": "13.10 Функция select для сгруппированных данных\nГлагольная функция select() работает на сгруппированных данных, но столбцы группирования всегда включаются (даже если не упомянуты в select()). Если вам не нужны эти столбцы группирования, используйте сначала ungroup().",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Группирование данных</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.ru.html#ресурсы",
    "href": "new_pages/grouping.ru.html#ресурсы",
    "title": "13  Группирование данных",
    "section": "13.11 Ресурсы",
    "text": "13.11 Ресурсы\nВот некоторые полезные ресурсы с дополнительной информацией:\nВы можете применять любую резюмирующую функцию к группированным данным; см. Шпаргалку по преобразованию данных в RStudio\nСтраница Data Carpentry в dplyr\nСправочная страница tidyverse по group_by() и группированию\nСтраница по Манипуляциям с данными\nОбобщение с условиями в dplyr",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Группирование данных</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.ru.html",
    "href": "new_pages/joining_matching.ru.html",
    "title": "14  Соединение данных",
    "section": "",
    "text": "14.1 Подготовка",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Соединение данных</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.ru.html#подготовка",
    "href": "new_pages/joining_matching.ru.html#подготовка",
    "title": "14  Соединение данных",
    "section": "",
    "text": "Загрузка пакетов\nДанный фрагмент кода показывает загрузку пакетов, необходимых для анализа. В данном руководстве мы фокусируемся на использовании p_load() из пакета pacman, которая устанавливает пакет, если необходимо, и загружает его для использования. Вы можете также загрузить установленные пакеты с помощью library() из базового R. См. страницу Основы R для получения дополнительной информации о пакетах R.\n\npacman::p_load(\n  rio,            # импорт и экспорт\n  here,           # пути к файлам \n  tidyverse,      # управление данными и визуализация\n  RecordLinkage,  # вероятностные совпадения\n  fastLink        # вероятностные совпадения\n)\n\n\n\nИмпорт данных\nДля начала мы импортируем чистый построчный список случаев из имитации эпидемии Эболы. Если вы хотите выполнять действия параллельно, кликните, чтобы скачать “чистый” построчный список (как .rds файл). Импортируйте данные с помощью функции import() из пакета rio (она работает с разными типами файлов, такими как .xlsx, .csv, .rds - см. страницу Импорт и экспорт для получения детальной информации).\n\n# импорт построчного списка случаев \nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nПервые 50 строк построчного списка отображены ниже.\n\n\n\n\n\n\n\n\n\nПримеры наборов данных\nВ разделе соединения ниже, мы используем следующие наборы данных:\n\n“уменьшенную” версию построчного списка случаев linelist, содержащую только столбцы case_id, date_onset и hospital, и только первые 10 строк\n\nотдельный датафрейм под названием hosp_info, который содержит более детальную информацию о каждой больнице\n\nВ разделе вероятностного сопоставления мы будем использовать два разных маленьких набора данных. Код для создания этих наборов данных представлен в соответствующем разделе.\n\n“Уменьшенный” построчный список linelist\nНиже представлен уменьшенный построчный список, который содержит лишь 10 строк и только столбцы case_id, date_onset и hospital.\n\nlinelist_mini &lt;- linelist %&gt;%                 # начинаем с оригинального построчного списка\n  select(case_id, date_onset, hospital) %&gt;%   # выбираем столбцы\n  head(10)                                    # берем только верхние 10 строк\n\n\n\n\n\n\n\n\n\nДатафрейм с информацией о больницах\nНиже представлен код для создания отдельного датафрейма с дополнительной информацией о семи больницах (прикрепленное население, уровень доступной помощи). Обратите внимание, что название “Military Hospital” относится к двум разным больницам - одной на первичном уровне, обслуживающей 10000 жителей, а другой - на вторичном уровне, обслуживающей 50280 жителей.\n\n# Создаем датафрейм с информацией о больницах\nhosp_info = data.frame(\n  hosp_name     = c(\"central hospital\", \"military\", \"military\", \"port\", \"St. Mark's\", \"ignace\", \"sisters\"),\n  catchment_pop = c(1950280, 40500, 10000, 50280, 12000, 5000, 4200),\n  level         = c(\"Tertiary\", \"Secondary\", \"Primary\", \"Secondary\", \"Secondary\", \"Primary\", \"Primary\")\n)\n\nВот этот датафрейм:\n\n\n\n\n\n\n\n\n\n\nПредварительная вычистка\nТрадиционные соединения (невероятностные) чувствительны к регистру и требуют точного соответствия знаков между значениями в двух датафреймах. Чтобы продемонстрировать некоторые шаги вычистки, которые вам могут потребоваться до соединения, мы вычистим и унифицируем наборы данных linelist_mini и hosp_info.\nВыявление различий\nНам нужно, чтобы значения в столбце hosp_name в датафрейме hosp_info соответствовали значениям столбца hospital в датафрейме linelist_mini.\nЗдесь представлены значения в датафрейме linelist_mini, напечатанные с помощью функции базового R unique():\n\nunique(linelist_mini$hospital)\n\n[1] \"Other\"                               \n[2] \"Missing\"                             \n[3] \"St. Mark's Maternity Hospital (SMMH)\"\n[4] \"Port Hospital\"                       \n[5] \"Military Hospital\"                   \n\n\nа здесь значения в датафрейме hosp_info:\n\nunique(hosp_info$hosp_name)\n\n[1] \"central hospital\" \"military\"         \"port\"             \"St. Mark's\"      \n[5] \"ignace\"           \"sisters\"         \n\n\nВы видите, что хотя некоторые больницы существуют в обоих датафреймах, существует множество расхождений в написании.\nУнификация значений\nМы начинаем с вычистки значений в датафрейме hosp_info. Как объяснялось на странице Вычистка данных и ключевые функции, мы можем перекодировать значения с помощью логических критериев, используя функцию из dplyr case_when(). Для четырех больниц, которые существуют в обоих датафреймах, мы меняем значения, чтобы они совпадали со значениями в linelist_mini. Для других больниц мы оставим значения как есть (TRUE ~ hosp_name).\nВНИМАНИЕ: Как правило, при вычистке следует создавать новый столбец (например, hosp_name_clean), но для облегчения демонстрации мы покажем модификацию старого столбца\n\nhosp_info &lt;- hosp_info %&gt;% \n  mutate(\n    hosp_name = case_when(\n      # критерии                         # новое значение\n      hosp_name == \"military\"          ~ \"Military Hospital\",\n      hosp_name == \"port\"              ~ \"Port Hospital\",\n      hosp_name == \"St. Mark's\"        ~ \"St. Mark's Maternity Hospital (SMMH)\",\n      hosp_name == \"central hospital\"  ~ \"Central Hospital\",\n      TRUE                             ~ hosp_name\n      )\n    )\n\nНазвания больниц, которые появляются в обоих датафреймах, унифицированы. Есть две больницы в hosp_info, которых нет в linelist_mini - мы с этим разберемся позже при присоединении.\n\nunique(hosp_info$hosp_name)\n\n[1] \"Central Hospital\"                    \n[2] \"Military Hospital\"                   \n[3] \"Port Hospital\"                       \n[4] \"St. Mark's Maternity Hospital (SMMH)\"\n[5] \"ignace\"                              \n[6] \"sisters\"                             \n\n\nПеред присоединением часто легче всего конвертировать столбец во все строчные или все заглавные буквы. Если вам нужно конвертировать все значения в столбце в ЗАГЛАВНЫЕ или строчные буквы, используйте mutate() и оберните столбец в одну из следующих функций из пакета stringr, как показано на странице Текст и последовательности.\nstr_to_upper()\nstr_to_upper()\nstr_to_title()",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Соединение данных</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.ru.html#соединения-в-dplyr",
    "href": "new_pages/joining_matching.ru.html#соединения-в-dplyr",
    "title": "14  Соединение данных",
    "section": "14.2 Соединения в dplyr",
    "text": "14.2 Соединения в dplyr\nПакет dplyr предлагает ряд разных функций соединения. dplyr включен в пакет tidyverse. Эти функции присоединения описаны ниже с простыми примерами их применения.\nБлагодарим https://github.com/gadenbuie за информативные gif!\n\n\nОбщий синтаксис\nКоманды присоединения можно выполнять как отдельные команды для соединения двух датафреймов в один новый объект, либо их можно использовать в рамках цепочки канала (%&gt;%), чтобы объединить один датафрейм с другим по мере его вычистки или другой модификации.\nВ примере ниже используется функция left_join() в качестве отдельной команды для создания нового объединенного датафрейма joined_data. Входными данными являются датафреймы 1 и 2 (df1 и df2). Первый указанный датафрейм - базовый датафрейм, а второй указанный датафрейм присоединяется к нему.\nТретий аргумент by = - это аргумент, в котором вы указываете столбцы в каждом датафрейме, которые будут использоваться для сопоставления строк в двух датафреймах. Если имена этих столбцов различаются, задайте их в рамках вектора c(), как показано ниже, где строки сопоставляются на основе общих значений между столбцом ID в df1 и столбцом identifier в df2.\n\n# Соединение на основе общих значений между столбцом \"ID\" (первый датафрейм) и столбцом \"identifier\" (второй датафрейм)\njoined_data &lt;- left_join(df1, df2, by = c(\"ID\" = \"identifier\"))\n\nЕсли у столбцов, по которым вы группируете (by), в обоих датафреймах одинаковое название, вы можете указать это одно название в кавычках.\n\n# Соединение на основе общих значений в столбце \"ID\" в обоих датафреймах\njoined_data &lt;- left_join(df1, df2, by = \"ID\")\n\nЕсли вы соединяете датафреймы на основе общих значений между несколькими полями, укажите эти поля в векторе c(). Этот пример соединяет строки, если значения в трех столбцах каждого набора данных абсолютно совпадают.\n\n# Соединение на основе имени, фамилии и возраста\njoined_data &lt;- left_join(df1, df2, by = c(\"name\" = \"firstname\", \"surname\" = \"lastname\", \"Age\" = \"age\"))\n\nКоманды соединения можно также выполнять в рамках цепочки канала. Это будет модифицировать тот датафрейм, который передан по каналу.\nВ примере ниже по каналу передается датафрейм df1, df2 к нему присоединяется, таким образом модифицируется и переопределяетсяdf.\n\ndf1 &lt;- df1 %&gt;%\n  filter(date_onset &lt; as.Date(\"2020-03-05\")) %&gt;% # прочая вычистка \n  left_join(df2, by = c(\"ID\" = \"identifier\"))    # присоединение df2 к df1\n\nВНИМАНИЕ: Соединения чувствительны к регистру! Поэтому полезно конвертировать все значения в строчные или заглавные до соединения. См. страницу по Тексту и последовательности.\n\n\n\nЛевое и правое соединение\nЛевое или правое соединение обычно используется, чтобы добавить информацию к датафрейму - новая информация добавляется только к тем строкам, которые уже существовали в базовом датафрейме. Это частые соединения в эпидемиологической работе, так как они используются, чтобы добавить информацию из одного набора данных к другому.\nПри использовании этих соединений очень важен письменный порядок датафреймов в команде*.\n\nВ левом соединении базовый датафрейм записывается первым\nВ правом соединении базовый датафрейм записывается вторым\n\nВсе строки базового датафрейма сохраняются Информация в другом (вторичном) датафрейме присоединяется к базовому датафрейму, только если есть совпадение по столбцу идентификатору(ам). Кроме того:\n\nСтроки во вторичном датафрейме, по которым нет совпадения, отбрасываются.\n\nЕсли существует много базовых строк, которые совпадают с одной строкой во вторичном датафрейме (много-к-одному), вторичная информация добавляется к каждой совпадающей базовой строке.\n\nЕсли базовая строка совпадает с несколькими строками во вторичном наборе данных (одна-ко-многим), даются все комбинации, то есть могут быть добавлены новые строки к выданному в результате датафрейму!\n\nАнимированные примеры левого и правого соединения (источник изображения)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nПример\nНиже представлены выходные данные левого соединения left_join() списка hosp_info (вторичный датафрейм, см.здесь) к linelist_mini (базовый датафрейм, см.здесь). В оригинальном linelist_mini было nrow(linelist_mini) строк. Отображен модифицированный linelist_mini. Обратите внимание на следующее:\n\nК левой стороне linelist_mini были добавлены два новых столбца, catchment_pop и level\n\nВсе оригинальные строки базового датафрейма linelist_mini сохранены\n\nЛюбые оригинальные строки в linelist_mini для “Military Hospital” продублированы, посколько он совпадает с двумя строками во вторичном датафрейме, поэтому выдаются обе комбинации\n\nСтолбец идентификатора, по которому идет соединение, во вторичном наборе данных (hosp_name) исчез, поскольку он повторяет столбец идентификатор в основном наборе данных (hospital)\n\nКогда строка базового датафрейма не совпала ни с одной строкой вторичного датафрейма (например, когда больница hospital указана как “Other” (Прочее) или “Missing” (Отсутствует)), NA (пропуск) заполняет столбцы из вторичного датафрейма\n\nСтроки во вторичном датафрейме без совпадения по базовому датафрейму (больницы “sisters” и “ignace”) были отброшены.\n\n\nlinelist_mini %&gt;% \n  left_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))\n\n\n\nWarning in left_join(., hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 5 of `x` matches multiple rows in `y`.\nℹ Row 4 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\n\n“Какое соединение мне использовать: левое или правое?”\nЧтобы ответить на указанный выше вопрос, спросите себя: “какой датафрейм должен сохранить все строки?” - и используйте его как датафрейм. Левое соединение сохраняет все строки первого датафрейма, записанного в команде, а правое соединение сохраняет все строки второго датафрейма.\nДве команды, указанные ниже, добиваются одних и тех же выходных данных - 10 строк hosp_info присоединяются к базовому списку linelist_mini, но они используют разные соединения. Результатом является то, что порядок столбцов будет отличаться в зависимости от того, будет ли добавлена информация hosp_info справа (в левом соединении), либо добавлена слева (в правом соединении). Порядок строк может также измениться соответствующим образом. Но с этими последствиями можно потом работать, используя select() для переупорядочивания столбцов или arrange() для сортировки строк.\n\n# Две команды ниже приводят к появлению тех же самых данных, но с разным порядком строк и столбцов\nleft_join(linelist_mini, hosp_info, by = c(\"hospital\" = \"hosp_name\"))\nright_join(hosp_info, linelist_mini, by = c(\"hosp_name\" = \"hospital\"))\n\nВот результат присоединения hosp_info к linelist_mini через левое соединение (новые столбцы добавлены справа)\n\n\nWarning in left_join(linelist_mini, hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 5 of `x` matches multiple rows in `y`.\nℹ Row 4 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\nВот результат присоединения hosp_info к linelist_mini через правое соединение (новые столбцы добавлены слева)\n\n\nWarning in right_join(hosp_info, linelist_mini, by = c(hosp_name = \"hospital\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 4 of `x` matches multiple rows in `y`.\nℹ Row 5 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\nТакже примите во внимание, применяете ли вы соединение в рамках цепочки канала (%&gt;%). Если набор данных в канале - базовый набор, вы, скорее всего, будете использовать левое соединение, чтобы добавить к нему данные.\n\n\n\n\nПолное соединение\nПолное соединение - наиболее инклюзивное из соединений - оно выдает все строки из обоих датафреймов.\nЕсли есть какие-то строки в одном датафрейме и их нет в другом (не найдено совпадение), датафрейм их включит и станет длиннее. Для заполнения созданных пробелов будут использоваться отсутствующие значения NA. По мере соединения обращайте внимание на количество строк и столбцов, чтобы решить проблему чувствительности к регистру и полных совпадений символов.\n“Базовый” датафрейм - тот, который записан первым в команде. Изменение этого порядка не повлияет на то, какие записи будут выданы после соединения, но может повлиять на порядок столбцов, порядок строк, полученный в результате, а также на то, какие столбцы-идентификаторы будут сохранены.\n\n\n\n\n\n\n\n\n\nАнимированный пример полного соединения (источник изображения)\nПример\nНиже представлен пример результата полного присоединения full_join() списка hosp_info (изначально nrow(hosp_info), см.здесь) к списку linelist_mini (изначально nrow(linelist_mini), см.здесь). Обратите внимание на нижеследующее:\n\nСохранены все строки базового датафрейма (linelist_mini)\n\nСтроки во вторичном датафрейме, которые не совпадали с базовым, сохранены (“ignace” и “sisters”), а значения по соответствующим столбцам базового датафрейма case_id и onset заполнены как отсутствующие значения\n\nАналогично, строки базового набора данных, которые не совпали с вторичным (“Other” и “Missing”) сохранены, а вторичные столбцы catchment_pop и level заполнены как отсутствующие значения\n\nВ случае совпадений один-ко-многим и много-к-одному (например, строки для “Military Hospital”), выданы все возможные комбинации (что удлинняет итоговый датафрейм)\n\nСохраняется только один столбец-идентификатор из базового датафрейма (hospital)\n\n\nlinelist_mini %&gt;% \n  full_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))\n\n\n\nWarning in full_join(., hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 5 of `x` matches multiple rows in `y`.\nℹ Row 4 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\n\n\n\nВнутреннее соединение\nВнутреннее соединение - наиболее ограничивающее из соединений - оно выдает только строки с совпадениями по обоим датафреймам.\nЭто означает, что количество строк в базовом датафрейме может даже сократиться. Изменение того, какой датафрейм будет “базовым” (первым записанным в функции) не повлияет на то, какие строки будут выданы, но повлияет на порядок столбцов, порядок строк, а также то, какие столбцы-идентификаторы будут сохранены.\n\n\n\n\n\n\n\n\n\nАнимированный пример внутреннего соединения (источник изображения)\nПример\nНиже представлены выходные данные внутреннего соединения inner_join() списка linelist_mini (базовый) с hosp_info (вторичный). Обратите внимание на нижеследующее:\n\nБазовые строки без совпадений во вторичных данных удаляются (строки, где больница hospital “Missing” (отсутствует) или указана как “Other” (прочие))\n\nАналогично, строки из вторичного датафрейма, по которым нет соответствия в базовом, удаляются (строки, где название больницы hosp_name указано как “sisters” или “ignace”)\n\nСохраняется только столбец-идентификатор из базового датафрейма (hospital)\n\n\nlinelist_mini %&gt;% \n  inner_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))\n\n\n\nWarning in inner_join(., hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 5 of `x` matches multiple rows in `y`.\nℹ Row 4 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\n\n\n\nПолусоединение\nПолусоединение - это “фильтрующее соединение”, которое использует еще один набор данных не для добавления строк или столбцов, а для проведения фильтрации.\nПолусоединение сохраняет все наблюдения в базовом датафрейме, по которым есть совпадения во вторичном датафрейме (но не добавляет новые столбцы и не дублирует строки, чтобы создать множественные совпадения). Более детально о таких “фильтрующих” соединениях читайте тут.\n\n\n\n\n\n\n\n\n\nАнимированный пример полусоединения (источник изображения)\nВ качестве примера, код ниже выдает строки из датафрейма hosp_info, которые имеют совпадения с linelist_mini на основе названия больницы.\n\nhosp_info %&gt;% \n  semi_join(linelist_mini, by = c(\"hosp_name\" = \"hospital\"))\n\n                             hosp_name catchment_pop     level\n1                    Military Hospital         40500 Secondary\n2                    Military Hospital         10000   Primary\n3                        Port Hospital         50280 Secondary\n4 St. Mark's Maternity Hospital (SMMH)         12000 Secondary\n\n\n\n\n\nАнти-соединение\nАнти-соединение - это еще одно “фильтрующее соединение”, которое выдает строки в базовом наборе данных, которые не имеют совпадений во вторичном датафрейме.\nБолее детально о таких “фильтрующих” соединениях читайте тут.\nЧастый сценарий применения анти-соединения - выявление записей, не представленных в другом датафрейме, выявление проблем с написанием при соединении (просмотр записей, которые должны были совпасть), а также рассмотрение записей, которые были исключены после другого соединения.\nКак и при right_join() и left_join(), важен базовый датафрейм (указанный первым). Выдаваемые строки будут только из базового набора данных. Обратите внимание в gif ниже, что строка во вторичном датафрейме (фиолетовая строка 4) не выдается, хотя по ней и нет совпадения в базовом датафрейме.\n\n\n\n\n\n\n\n\n\nАнимированный пример анти-соединения (источник изображения)\n\nПростой пример anti_join()\nВ качестве простого примера давайте найдем больницы hosp_info, в которых нет случаев, присутствующих в linelist_mini. Мы указываем hosp_info первым, как базовый датафрейм. Будут выданы больницы, которые не присутствуют в linelist_mini.\n\nhosp_info %&gt;% \n  anti_join(linelist_mini, by = c(\"hosp_name\" = \"hospital\"))\n\n\n\n\n\n\n\n\n\nСложный пример anti_join()\nВ качестве еще одного примера допустим, мы провели внутреннее соединение inner_join() для linelist_mini и hosp_info. Это нам выдаст подмножество оригинальных записей из linelist_mini, так как некоторые не присутствуют в hosp_info.\n\nlinelist_mini %&gt;% \n  inner_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))\n\n\n\nWarning in inner_join(., hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 5 of `x` matches multiple rows in `y`.\nℹ Row 4 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\nЧтобы рассмотреть записи linelist_mini, которые были исключены в ходе внутреннего соединения, мы можем выполнить анти-соединение с теми же настройками (linelist_mini в качестве базового).\n\nlinelist_mini %&gt;% \n  anti_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))\n\n\n\n\n\n\n\nЧтобы увидеть записи hosp_info, которые были исключены при внутреннем соединении, мы могли бы также выполнить анти-соединение с hosp_info в качестве базового датафрейма.",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Соединение данных</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.ru.html#вероятностные-совпадения",
    "href": "new_pages/joining_matching.ru.html#вероятностные-совпадения",
    "title": "14  Соединение данных",
    "section": "14.3 Вероятностные совпадения",
    "text": "14.3 Вероятностные совпадения\nЕсли у вас нет общего уникального идентификатора между наборами данных, по которому вы можете сделать соединение, рассмотрите возможность применения вероятностных алгоритмов поиска совпадений. Они найдут совпадения между записями на основе схожести (например, сходства Джара—Винклера по расстоянию последовательности, либо по числовому расстоянию). Ниже приведен простой пример использования пакета fastLink .\nЗагрузка пакетов\n\npacman::p_load(\n  tidyverse,      # манипуляции с данными и визуализация\n  fastLink        # сопоставление записей\n  )\n\nВот два коротких набора данных для примера, которые мы используем, чтобы продемонстрировать поиск вероятностных совпадений (cases и test_results):\nВот код, который был использован для создания наборов данных:\n\n# создаем наборы данных\n\ncases &lt;- tribble(\n  ~gender, ~first,      ~middle,     ~last,        ~yr,   ~mon, ~day, ~district,\n  \"M\",     \"Amir\",      NA,          \"Khan\",       1989,  11,   22,   \"River\",\n  \"M\",     \"Anthony\",   \"B.\",        \"Smith\",      1970, 09, 19,      \"River\", \n  \"F\",     \"Marialisa\", \"Contreras\", \"Rodrigues\",  1972, 04, 15,      \"River\",\n  \"F\",     \"Elizabeth\", \"Casteel\",   \"Chase\",      1954, 03, 03,      \"City\",\n  \"M\",     \"Jose\",      \"Sanchez\",   \"Lopez\",      1996, 01, 06,      \"City\",\n  \"F\",     \"Cassidy\",   \"Jones\",      \"Davis\",     1980, 07, 20,      \"City\",\n  \"M\",     \"Michael\",   \"Murphy\",     \"O'Calaghan\",1969, 04, 12,      \"Rural\", \n  \"M\",     \"Oliver\",    \"Laurent\",    \"De Bordow\" , 1971, 02, 04,     \"River\",\n  \"F\",      \"Blessing\",  NA,          \"Adebayo\",   1955,  02, 14,     \"Rural\"\n)\n\nresults &lt;- tribble(\n  ~gender,  ~first,     ~middle,     ~last,          ~yr, ~mon, ~day, ~district, ~result,\n  \"M\",      \"Amir\",     NA,          \"Khan\",         1989, 11,   22,  \"River\", \"positive\",\n  \"M\",      \"Tony\",   \"B\",         \"Smith\",          1970, 09,   19,  \"River\", \"positive\",\n  \"F\",      \"Maria\",    \"Contreras\", \"Rodriguez\",    1972, 04,   15,  \"Cty\",   \"negative\",\n  \"F\",      \"Betty\",    \"Castel\",   \"Chase\",        1954,  03,   30,  \"City\",  \"positive\",\n  \"F\",      \"Andrea\",   NA,          \"Kumaraswamy\",  2001, 01,   05,  \"Rural\", \"positive\",      \n  \"F\",      \"Caroline\", NA,          \"Wang\",         1988, 12,   11,  \"Rural\", \"negative\",\n  \"F\",      \"Trang\",    NA,          \"Nguyen\",       1981, 06,   10,  \"Rural\", \"positive\",\n  \"M\",      \"Olivier\" , \"Laurent\",   \"De Bordeaux\",  NA,   NA,   NA,  \"River\", \"positive\",\n  \"M\",      \"Mike\",     \"Murphy\",    \"O'Callaghan\",  1969, 04,   12,  \"Rural\", \"negative\",\n  \"F\",      \"Cassidy\",  \"Jones\",     \"Davis\",        1980, 07,   02,  \"City\",  \"positive\",\n  \"M\",      \"Mohammad\", NA,          \"Ali\",          1942, 01,   17,  \"City\",  \"negative\",\n  NA,       \"Jose\",     \"Sanchez\",   \"Lopez\",        1995, 01,   06,  \"City\",  \"negative\",\n  \"M\",      \"Abubakar\", NA,          \"Abullahi\",     1960, 01,   01,  \"River\", \"positive\",\n  \"F\",      \"Maria\",    \"Salinas\",   \"Contreras\",    1955, 03,   03,  \"River\", \"positive\"\n  )\n\nВ наборе данных cases есть 9 записей пациентов, которые ожидают результатов теста.\n\n\n\n\n\n\nНабор данных test_results содержит 14 записей и содержит столбец с результатом result, который мы хотим добавить к записям в списке случаев cases на основе вероятностного поиска совпадений записей.\n\n\n\n\n\n\n\nВероятностные совпадения\nФункция fastLink() из пакета fastLink может использоваться для применения алгоритмов поиска соответствий. Ниже представлена базовая информация. Более детальную информацию вы можете получить, введя в консоль ?fastLink.\n\nЗадайте два датафрейма для сравнения в аргументы dfA = и dfB =\n\nВ varnames = задайте все названия столбцов, которые будут использоваться для сопоставления. Они должны существовать и в dfA, и в dfB.\n\nВ stringdist.match = задайте столбцы из varnames, которые будут оцениваться по “расстоянию” последовательности.\n\nВ numeric.match = задайте столбцы из varnames, которые будут оцениваться по числовому расстоянию.\n\nОтсутствующие значения игнорируются\n\nПо умолчанию, каждая строка в любом из датафреймов определяется как совпадение максимум к одной строке в другом датафрейме. Если вы хотите увидеть все оцененные совпадения, установите dedupe.matches = FALSE. Дедупликация проводится с помощью решения Винклера для линейной задачи о назначениях.\n\nСовет: разделите один столбец даты на три отдельных числовых столбца, используя day(), month() и year() из lubridate\nПорог по умолчанию для совпадений составляет 0.94 (threshold.match =), но вы можете его повысить или понизить. Если вы определеяете порог, учтите, что более высокий порог может дать вам больше ложно-отрицательных результатов (строк, которые не совпали, но должны были совпасть), а более низкий порог даст вам больше ложно-положительных совпадений.\nНиже данные сопоставляются по расстоянию последовательности в столбцах имя и район, а также по числовому расстоянию для года, месяца и дня рождения. Установлен порог совпадения с вероятностью 95%.\n\nfl_output &lt;- fastLink::fastLink(\n  dfA = cases,\n  dfB = results,\n  varnames = c(\"gender\", \"first\", \"middle\", \"last\", \"yr\", \"mon\", \"day\", \"district\"),\n  stringdist.match = c(\"first\", \"middle\", \"last\", \"district\"),\n  numeric.match = c(\"yr\", \"mon\", \"day\"),\n  threshold.match = 0.95)\n\n\n==================== \nfastLink(): Fast Probabilistic Record Linkage\n==================== \n\nIf you set return.all to FALSE, you will not be able to calculate a confusion table as a summary statistic.\nCalculating matches for each variable.\nGetting counts for parameter estimation.\n    Parallelizing calculation using OpenMP. 1 threads out of 8 are used.\nRunning the EM algorithm.\nGetting the indices of estimated matches.\n    Parallelizing calculation using OpenMP. 1 threads out of 8 are used.\nDeduping the estimated matches.\nGetting the match patterns for each estimated match.\n\n\nПросмотр совпадений\nМы определили объект, выдаваемый функцией fastLink() как fl_output. Он в классе list и на самом деле внутри себя содержит несколько датафреймов, детализирующих результаты поиска совпадений. Один из этих датафреймов - это датафрейм matches, который содержит наиболее вероятные совпадения по cases (случаям) и results (результатам). Вы можете оценить этот датафрейм “совпадений” с помощью fl_output$matches. Ниже он сохраняется как my_matches для удобства дальнейшего доступа.\nКогда печатается my_matches, вы видите два вектора столбцов: пары номеров строк/индексы (также называемые “rownames” - имена строк) в cases (“inds.a”) и в results (“inds.b”), представляющие собой наилучшие совпадения. Если номер строки из датафрейма отсутствует, это значит, что не было найдено совпадения в другом датафрейме в рамках указанного порога совпадения.\n\n# печать совпадений\nmy_matches &lt;- fl_output$matches\nmy_matches\n\n  inds.a inds.b\n1      1      1\n2      2      2\n3      3      3\n4      4      4\n5      8      8\n6      7      9\n7      6     10\n8      5     12\n\n\nОбратите внимание:\n\nСовпадения были найдены несмотря на небольшие различия в написании имен и датах рождения:\n\n“Tony B. Smith” сопоставлен с “Anthony B Smith”\n\n“Maria Rodriguez” сопоставлена с “Marialisa Rodrigues”\n\n“Betty Chase” сопоставлена с “Elizabeth Chase”\n\n“Olivier Laurent De Bordeaux” сопоставлена с “Oliver Laurent De Bordow” (игнорируется отсутствующая дата рождения)\n\n\nПо одной строке из cases (для “Blessing Adebayo”, строка 9) не было хороших соответствий в results, поэтому ее нет в my_matches.\n\nСоединение на основе вероятностных совпадений\nЧтобы использовать эти совпадения для присоединения results к cases, одна из стратегий будет:\n\nИспользовать левое соединение left_join(), чтобы присоединить my_matches к cases (сопоставление имен строк в cases с “inds.a” в my_matches)\n\nЗатем использовать еще одно левое соединение left_join(), чтобы присоединить results к cases (сопоставление нового полученного “inds.b” в cases с rownames в results)\n\nПеред соединениями мы должны вычистить три датафрейма:\n\nИ в dfA, и в dfB номера строк (“rowname”) должны быть конвертированы в полноценный столбец.\n\nОба столбца в my_matches конвертируются в текстовый класс, чтобы их можно было соединять с текстовыми rownames\n\n\n# Вычистка данных до соединения\n#############################\n\n# конвертируем имена строк случаев cases (rownames) в столбец \ncases_clean &lt;- cases %&gt;% rownames_to_column()\n\n# конвертируем имена строк результатов test_results (rownames) в столбец\nresults_clean &lt;- results %&gt;% rownames_to_column()  \n\n# конвертируем все столбцы в наборе данных совпадений в текстовый класс, чтобы их можно было присоединить к rownames\nmatches_clean &lt;- my_matches %&gt;%\n  mutate(across(everything(), as.character))\n\n\n\n# Присоединяем совпадения к dfA, затем добавляем dfB\n###################################\n# столбец \"inds.b\" добавляется к dfA\ncomplete &lt;- left_join(cases_clean, matches_clean, by = c(\"rowname\" = \"inds.a\"))\n\n# столбец(столбцы) из dfB добавляются \ncomplete &lt;- left_join(complete, results_clean, by = c(\"inds.b\" = \"rowname\"))\n\nПри выполнении указанного выше кода полученный в результате датафрейм complete будет содержать все столбцы и из cases, и из results. Ко многим будут подставлены суффиксы “.x” и “.y”, поскольку иначе дублировались бы имена столбцов.\n\n\n\n\n\n\nАльтернативно, чтобы получить только “оригинальные” 9 записей в cases с новым столбцом(ами) из results, используйте select() для results до соединений, чтобы там содержались только имена строк (rownames) и столбцы, которые вы хотите добавить к cases (например, столбец result).\n\ncases_clean &lt;- cases %&gt;% rownames_to_column()\n\nresults_clean &lt;- results %&gt;%\n  rownames_to_column() %&gt;% \n  select(rowname, result)    # выберите только определенные столбцы \n\nmatches_clean &lt;- my_matches %&gt;%\n  mutate(across(everything(), as.character))\n\n# joins\ncomplete &lt;- left_join(cases_clean, matches_clean, by = c(\"rowname\" = \"inds.a\"))\ncomplete &lt;- left_join(complete, results_clean, by = c(\"inds.b\" = \"rowname\"))\n\n\n\n\n\n\n\nЕсли вы хотите выбрать подмножество данных из любого набора данных, чтобы оно включало только совпадающие строки, вы можете использовать код ниже:\n\ncases_matched &lt;- cases[my_matches$inds.a,]  # строки cases, которые совпали со строкой в results\nresults_matched &lt;- results[my_matches$inds.b,]  # Строки в results, которые совпали со строкой в cases\n\nЛибо, чтобы увидеть только те строки, по которым нет совпадения:\n\ncases_not_matched &lt;- cases[!rownames(cases) %in% my_matches$inds.a,]  # Строки в cases, по которым НЕТ совпадений со строкой в results\nresults_not_matched &lt;- results[!rownames(results) %in% my_matches$inds.b,]  # Строки в results, по которым НЕТ совпадений со строкой в cases\n\n\n\nВероятностная дедупликация\nПоиск вероятностных совпадений можно использовать и для дедупликации набора данных. См. страницу по дедупликации, где описаны другие методы дедупликации.\nЗдесь мы начинаем с набора данных cases, но сейчас назовем его cases_dup, поскольку в нем 2 дополнительных строки, которые могут быть дубликатами предыдущих строк: See “Tony” with “Anthony”, and “Marialisa Rodrigues” with “Maria Rodriguez”.\n\n\n\n\n\n\nВыполняем fastLink() как и ранее, но сравниваем датафрейм cases_dup с самим собой, если два датафрейма оказываются идентичными, функция предполагает, что вы хотите провести дедупликацию. Обратите внимание, что мы не уточняе stringdist.match = или numeric.match =, как мы это делали ранее.\n\n## Выполняем fastLink на том же наборе данных\ndedupe_output &lt;- fastLink(\n  dfA = cases_dup,\n  dfB = cases_dup,\n  varnames = c(\"gender\", \"first\", \"middle\", \"last\", \"yr\", \"mon\", \"day\", \"district\")\n)\n\n\n==================== \nfastLink(): Fast Probabilistic Record Linkage\n==================== \n\nIf you set return.all to FALSE, you will not be able to calculate a confusion table as a summary statistic.\ndfA and dfB are identical, assuming deduplication of a single data set.\nSetting return.all to FALSE.\n\nCalculating matches for each variable.\nGetting counts for parameter estimation.\n    Parallelizing calculation using OpenMP. 1 threads out of 8 are used.\nRunning the EM algorithm.\nGetting the indices of estimated matches.\n    Parallelizing calculation using OpenMP. 1 threads out of 8 are used.\nCalculating the posterior for each pair of matched observations.\nGetting the match patterns for each estimated match.\n\n\nТеперь вы можете рассмотреть потенциальные дубликаты с помощью getMatches(). Укажите датафрейм и в dfA =, и в dfB =, а также задайте выходной результат функции fastLink() как fl.out =. fl.out должен быть классом fastLink.dedupe, иными словами, результатом fastLink().\n\n## Выполняем getMatches()\ncases_dedupe &lt;- getMatches(\n  dfA = cases_dup,\n  dfB = cases_dup,\n  fl.out = dedupe_output)\n\nПосмотрите на самый правый столбец, который указывает дублирующиеся ID - последние две строки определены, как вероятные дубликаты строк 2 и 3.\n\n\n\n\n\n\nЧтобы получить номера тех строк, которые, вероятно, являются дубликатами, вы можете посчитать количество строк на уникальное значение в столбце dedupe.ids, а затем отфильтровать, чтобы сохранить только те, где более одной строки. В данном случае, это оставит строки 2 и 3.\n\ncases_dedupe %&gt;% \n  count(dedupe.ids) %&gt;% \n  filter(n &gt; 1)\n\n  dedupe.ids n\n1          2 2\n2          3 2\n\n\nЧтобы просмотреть полные строки вероятных дубликатов, укажите номер строки в следующую команду:\n\n# отображает строку 2 и все вероятные дубликаты в ней\ncases_dedupe[cases_dedupe$dedupe.ids == 2,]   \n\n   gender   first middle  last   yr mon day district dedupe.ids\n2       M Anthony     B. Smith 1970   9  19    River          2\n10      M    Tony     B. Smith 1970   9  19    River          2",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Соединение данных</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.ru.html#связывание-и-упорядочивание",
    "href": "new_pages/joining_matching.ru.html#связывание-и-упорядочивание",
    "title": "14  Соединение данных",
    "section": "14.4 Связывание и упорядочивание",
    "text": "14.4 Связывание и упорядочивание\nЕще один метод объединения двух датафреймов - это их “связывание”. Можете представить это, как “добавление” строк или столбцов.\nВ данном разделе мы также обсудим, как “упорядочивать” порядок строк одного датафрейма относительно порядка в другом датафрейме. Эта тема обсуждается ниже в разделе Связывание столбцов.\n\nСвязывание строк\nЧтобы связать строки одного датафрейма с нижней частью другого датафрейма, используйте bind_rows() из dplyr. Это очень инклюзивная функция, поэтому любой столбец, присутствующий в одном из датафреймов, будет включен в результат. Несколько замечаний:\n\nВ отличие от базовой версии R row.bind(), функция bind_rows() из dplyr не требует, чтобы порядок столбцов был одинаковым в обоих датафреймах. Главное, чтобы названия столбцов были написано одинаково, тогда она их правильно упорядочит.\n\nОпционально вы можете задать аргумент .id =. Укажите текстовое имя столбца. Это создаст новый столбец, который будет использован для определения, из какого датафрейма изначально взяли каждую строку.\n\nВы можете использовать bind_rows() для объекта list аналогично структурированных датафреймов для объединения их в один датафрейм. См. пример на странице [Итерации, циклы и списки], где показан импорт нескольких построчных списков с помощью purrr.\n\nОдним из частых примеров связывания строк является связывание строки “итого” с описательной таблицей, используя функцию summarise() из dplyr. Ниже мы создаем таблицу с подсчетом случаев и медианными значениями CT по больнице со строкой итого.\nФункция summarise() используется для данных, сгруппированных по больнице, чтобы выдать сводный датафрейм по больнице. Но функция summarise() не создает автоматически строку “итого”, поэтому мы создаем ее, сведя данные еще раз, но в этот раз не группируя данные по больнице. Это создает второй датафрейм всего с одной строкой. Затем мы можем связать эти датафрейма вместе, чтобы получить итоговую таблицу.\nСм. другие подобные примеры на страницах [Описательные таблицы] и [Таблицы для презентации].\n\n# Создаем основную таблицу\n###################\nhosp_summary &lt;- linelist %&gt;% \n  group_by(hospital) %&gt;%                        # группируем данные по больнице\n  summarise(                                    # создаем новые сводные столбцы по интересующим индикаторам\n    cases = n(),                                  # количество строк на группу больница-исход     \n    ct_value_med = median(ct_blood, na.rm=T))     # медианное значение CT на группу\n\nВот датафрейм hosp_summary:\n\n\n\n\n\n\nСоздаем датафрейм с “итоговой” статистикой (не сгруппированной по больницам). Это выдаст нам только одну строку.\n\n# создаем итого\n###############\ntotals &lt;- linelist %&gt;% \n  summarise(\n    cases = n(),                               # количество строк для всего набора данных     \n    ct_value_med = median(ct_blood, na.rm=T))  # медианное CT для всего набора данных\n\nНиже вы видите этот датафрейм totals. Обратите внимание, что в нем только два столбца. Эти столбцы также есть в hosp_summary, но в hosp_summary есть один столбец, которого нет в totals (hospital).\n\n\n\n\n\n\nТеперь мы связываем строки с помощью bind_rows().\n\n# связываем датафреймы\ncombined &lt;- bind_rows(hosp_summary, totals)\n\nТеперь мы можем увидеть результат. Обратите внимание, как в последней строке пустое значение NA заполняется для столбца hospital, который не присутствовал в hosp_summary. Как объяснялось на странице [Таблицы для презентации], вы можете “заполнить” эту ячейку “итогом” используя replace_na().\n\n\n\n\n\n\n\n\nСвязывание столбцов\nЕсть похожая функция в dplyr bind_cols(), которую вы можете использовать, чтобы соединить два датафрейма боком. Обратите внимание, что строки сопоставляются друг с другом по позиции (в отличие от соединения выше) - например, 12я строка в каждом датафрейме будет выровнена.\nНапример, мы связываем несколько суммарных таблиц. Чтобы это сделать, мы также демонстрируем, как изменить порядок строк в одном датафрейме, чтобы он соответствовал порядку в другом датафрейме, с помощью match().\nЗдесь мы определяем case_info как сводный датафрейм построчного списка случаев, по больницам, с количеством случаев и количеством смертей.\n\n# Информация о случаях\ncase_info &lt;- linelist %&gt;% \n  group_by(hospital) %&gt;% \n  summarise(\n    cases = n(),\n    deaths = sum(outcome == \"Death\", na.rm=T)\n  )\n\n\n\n\n\n\n\nИ давайте представим, что у нас есть другой датафрейм, contact_fu, в котором содержится информация о проценте расследованных контактов, по которым был сделан мониторинг, опять же по больницам.\n\ncontact_fu &lt;- data.frame(\n  hospital = c(\"St. Mark's Maternity Hospital (SMMH)\", \"Military Hospital\", \"Missing\", \"Central Hospital\", \"Port Hospital\", \"Other\"),\n  investigated = c(\"80%\", \"82%\", NA, \"78%\", \"64%\", \"55%\"),\n  per_fu = c(\"60%\", \"25%\", NA, \"20%\", \"75%\", \"80%\")\n)\n\n\n\n\n\n\n\nОбратите внимание, что больницы одинаковые, но в разном порядке в каждом датафрейме. Самым простым решением было бы использовать left_join() по столбцу hospital, но можно использовать и bind_cols() с одним дополнительным шагом.\n\nИспользуйте match() для унификации порядка\nПоскольку порядок строк отличается, простая команда bind_cols() приведет к неправильному сопоставлению данных. Чтобы это исправить, мы можем использовать match() из базового R, чтобы унифицировать порядок строк датафрейма с порядком в другом датафрейме. Мы предполагаем для этого подхода, что ни в одном из датафреймов нет дубликатов.\nКогда мы используем match(), синтаксис будет выглядеть как match(TARGET ORDER VECTOR, DATA FRAME COLUMN TO CHANGE), где первым аргументом является желаемый порядок (либо отдельный вектор, либо, как в данном случае, столбец в датафрейме), а вторым аргументом является столбец в датафрейме в том датафрейме, который будет переупорядочен. На выходе после match() мы получаем вектор чисел, представляющий правильный порядок позиций. Вы можете более детально об этом прочитать с помощью ?match.\n\nmatch(case_info$hospital, contact_fu$hospital)\n\n[1] 4 2 3 6 5 1\n\n\nВы можете использовать этот числовой вектор, чтобы переупорядочить датафрейм - разместите его внутри квадратных скобок подмножества [ ] перед запятой. Более детально можете прочитать о таком синтаксисе подмножества в базовом R на странице [Основы R]. Команда ниже создает новый датафрейм, определенный как старый датафрейм, в котором порядок строк меняется в соответствии с указанным выше числовым вектором.\n\ncontact_fu_aligned &lt;- contact_fu[match(case_info$hospital, contact_fu$hospital),]\n\n\n\n\n\n\n\nТеперь мы можем связать столбцы датафрейма с правильным порядком строк. Обратите внимание. что по некоторым столбцам имеется дублирование, и они потребуют вычистки с помощью rename(). Более подробно о bind_rows() можно прочитать тут.\n\nbind_cols(case_info, contact_fu)\n\nNew names:\n• `hospital` -&gt; `hospital...1`\n• `hospital` -&gt; `hospital...4`\n\n\n# A tibble: 6 × 6\n  hospital...1                     cases deaths hospital...4 investigated per_fu\n  &lt;chr&gt;                            &lt;int&gt;  &lt;int&gt; &lt;chr&gt;        &lt;chr&gt;        &lt;chr&gt; \n1 Central Hospital                   454    193 St. Mark's … 80%          60%   \n2 Military Hospital                  896    399 Military Ho… 82%          25%   \n3 Missing                           1469    611 Missing      &lt;NA&gt;         &lt;NA&gt;  \n4 Other                              885    395 Central Hos… 78%          20%   \n5 Port Hospital                     1762    785 Port Hospit… 64%          75%   \n6 St. Mark's Maternity Hospital (…   422    199 Other        55%          80%   \n\n\nАльтернатива для bind_cols в базовом R - это cbind(), которая проводит ту же операцию.",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Соединение данных</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.ru.html#ресурсы",
    "href": "new_pages/joining_matching.ru.html#ресурсы",
    "title": "14  Соединение данных",
    "section": "14.5 Ресурсы",
    "text": "14.5 Ресурсы\nСтраница tidyverse по соединениям\nСтраница R for Data Science по реляционным данным\nСтраница tidyverse по dplyr on binding\nВиньетка по fastLink at the package’s Github page\nПубликация, описывающая методологию fastLink\nПубликация, описывающая пакет RecordLinkage",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Соединение данных</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.ru.html",
    "href": "new_pages/deduplication.ru.html",
    "title": "15  Дедупликация",
    "section": "",
    "text": "15.1 Подготовка",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Дедупликация</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.ru.html#подготовка",
    "href": "new_pages/deduplication.ru.html#подготовка",
    "title": "15  Дедупликация",
    "section": "",
    "text": "Загрузка пакетов\nДанный фрагмент кода показывает загрузку пакетов, необходимых для анализа. В данном руководстве мы фокусируемся на использовании p_load() из пакета pacman, которая устанавливает пакет, если необходимо, и загружает его для использования. Вы можете также загрузить установленные пакеты с помощью library() из базового R. См. страницу Основы R для получения дополнительной информации о пакетах R.\n\npacman::p_load(\n  tidyverse,   # функции дедупликации, группирования и среза\n  janitor,     # функция обзора дубликатов\n  stringr)      # для поисков по последовательности, может быть использован в \"комбинированных\" значениях\n\n\n\nИмпорт данных\nДля демонстрации мы будем использовать пример набора данных, который создан с помощью кода R ниже.\nДанные - записи разговоров по телефону в контексте COVID-19, которые включают в себя беседы с контактами и случаями. Столбцы включают recordID (сгенерированный компьютером), personID (идентификатор человека), name (имя), date (дату) беседы, time (время) беседы, purpose (цель) беседы (интервью как со случаем или как с контактом), а также symptoms_ever (симптомы) (были ли у человека когда-либо симптомы).\nВот код для создания набора данных obs:\n\nobs &lt;- data.frame(\n  recordID  = c(1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18),\n  personID  = c(1,1,2,2,3,2,4,5,6,7,2,1,3,3,4,5,5,7,8),\n  name      = c(\"adam\", \"adam\", \"amrish\", \"amrish\", \"mariah\", \"amrish\", \"nikhil\", \"brian\", \"smita\", \"raquel\", \"amrish\",\n                \"adam\", \"mariah\", \"mariah\", \"nikhil\", \"brian\", \"brian\", \"raquel\", \"natalie\"),\n  date      = c(\"1/1/2020\", \"1/1/2020\", \"2/1/2020\", \"2/1/2020\", \"5/1/2020\", \"5/1/2020\", \"5/1/2020\", \"5/1/2020\", \"5/1/2020\",\"5/1/2020\", \"2/1/2020\",\n                \"5/1/2020\", \"6/1/2020\", \"6/1/2020\", \"6/1/2020\", \"6/1/2020\", \"7/1/2020\", \"7/1/2020\", \"7/1/2020\"),\n  time      = c(\"09:00\", \"09:00\", \"14:20\", \"14:20\", \"12:00\", \"16:10\", \"13:01\", \"15:20\", \"14:20\", \"12:30\", \"10:24\",\n                \"09:40\", \"07:25\", \"08:32\", \"15:36\", \"15:31\", \"07:59\", \"11:13\", \"17:12\"),\n  encounter = c(1,1,1,1,1,3,1,1,1,1,2,\n                2,2,3,2,2,3,2,1),\n  purpose   = c(\"contact\", \"contact\", \"contact\", \"contact\", \"case\", \"case\", \"contact\", \"contact\", \"contact\", \"contact\", \"contact\",\n                \"case\", \"contact\", \"contact\", \"contact\", \"contact\", \"case\", \"contact\", \"case\"),\n  symptoms_ever = c(NA, NA, \"No\", \"No\", \"No\", \"Yes\", \"Yes\", \"No\", \"Yes\", NA, \"Yes\",\n                    \"No\", \"No\", \"No\", \"Yes\", \"Yes\", \"No\",\"No\", \"No\")) %&gt;% \n  mutate(date = as.Date(date, format = \"%d/%m/%Y\"))\n\n\nВот датафрейм\nИспользуйте ячейки фильтра наверху, чтобы рассмотреть беседы с каждым человеком.\n\n\n\n\n\n\nНесколько аспектов, на которые нужно обратить внимание, при просмотре данных:\n\nПервые две записи являются 100% дубликатами, включая дублирующийся recordID (наверное, ошибка компьютера!)\n\nВторые две строки являются дубликатами по всем столбцам, кроме recordID\n\nУ нескольких человек было несколько телефонных бесед в разные даты и время, в качестве контактов и/или случаев\n\nПри каждой беседе человека спрашивали, были ли у него когда-либо симптомы, и некоторая такая информация отсутствует.\n\nВот краткое резюме по людям и целям бесед с ними с помощью функции tabyl() из janitor:\n\nobs %&gt;% \n  tabyl(name, purpose)\n\n    name case contact\n    adam    1       2\n  amrish    1       3\n   brian    1       2\n  mariah    1       2\n natalie    1       0\n  nikhil    0       2\n  raquel    0       2\n   smita    0       1",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Дедупликация</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.ru.html#дедупликация",
    "href": "new_pages/deduplication.ru.html#дедупликация",
    "title": "15  Дедупликация",
    "section": "15.2 Дедупликация",
    "text": "15.2 Дедупликация\nДанный раздел описывает, как проводить обзор и удалять дублирующиеся строки в датафрейме. В ней также рассказывается, как работать с дублирующимися элементами вектора.\n\n\nРассмотрение дублирующихся строк\nЧтобы быстро рассмотреть строки, имеющие дубликаты, вы можете использовать get_dupes() из пакета janitor. По умолчанию будут рассмотрены все столбцы, когда будут оцениваться дубликаты - полученные в результате выполнения функции строки будут являться 100% дубликатами, принимая во внимание значения во всех столбцах.\nВ датафрейме obs первые две строки являются 100% дубликатами - у них совпадают значения в каждом столбце (включая столбец recordID, который должен быть уникальным - наверное, возникла ошибка компьютера). Полученный в результате датафрейм автоматически включает новый столбец dupe_count с правой стороны, показывающий количество строк с такой комбинацией дублирующихся значений.\n\n# 100% дубликаты по всем столбцам\nobs %&gt;% \n  janitor::get_dupes()\n\n\n\n\n\n\n\nСм. оригинальные данные\nОднако если мы решим игнорировать recordID, 3я и 4я строки также являются дубликатами друг друга. То есть, в них совпадают значения во всех столбцах, кроме recordID. Вы можете уточнить несколько столбцов, которые нужно игнорировать в функции, используя знак -.\n\n# Дубликаты без учета столбца recordID\nobs %&gt;% \n  janitor::get_dupes(-recordID)         # если несколько столбцов, оберните их в c()\n\n\n\n\n\n\n\nВы можете также в положительном ключе указать те столбцы, которые надо рассмотреть. Ниже нам выданы только те строки, у которых совпадают значения в столбцах name (имя) и purpose (цель). Обратите внимание, у “amrish” теперь количество дубликатов dupe_count равно 3, что отражает три беседы с “контактом”.\n*Прокрутите влево, чтобы увидеть остальные строки**\n\n# дубликаты ТОЛЬКО на основе столбца имени и цели\nobs %&gt;% \n  janitor::get_dupes(name, purpose)\n\n\n\n\n\n\n\nСм. оригинальные данные.\nДополнительную информацию можно получить через ?get_dupes или в этой онлайн справке\n\n\n\nСохранение только уникальных строк\nЧтобы сохранить только уникальные строки датафрейма, используйте distinct() из dplyr (как показано на странице Вычистка данных и ключевые функции). Дублирующиеся строки удаляются таким образом, что сохраняется только первая из таких строк. По умолчанию, “первая” означает строка с более высоким номером строки rownumber (порядок строк сверху вниз). Остаются только уникальные строки.\nВ примере ниже мы выполняем distinct() таким образом, чтобы столбец recordID был исключен из рассмотрения - таким образом, удаляются две дублирующихся строки. Первая строка (строка “adam”) была 100% дубликатом и была удалена. Также строка 3 (строка “amrish”) была дубликатом в каждом столбце, кроме recordID (который не принимается во внимание) и также удаляется. В наборе данных obs n теперь стала nrow(obs)-2, а не nrow(obs) строк).\nПрокрутите влево, чтобы увидеть весь датафрейм\n\n# добавляется в цепочку канала (например, вычистки данных)\nobs %&gt;% \n  distinct(across(-recordID), # сокращает датафрейм только до уникальных строк (сохраняет первый из дубликатов)\n           .keep_all = TRUE) \n\n# если вне канала, то нужно в качестве первого аргумента включить данные \n# distinct(obs)\n\n\n\n\n\n\n\nВНИМАНИЕ: Если вы используете distinct() для группированных данных, функция будет применена к каждой группе.\nДедупликация на основе конкретных столбцов\nВы можете также уточнить столбцы, которые станут основанием для дедупликации. Таким образом, дедупликация применяется только к строкам, которые являются дубликатами по конкретным столбцам. Если вы не установите .keep_all = TRUE, все не упомянутые столбцы будут выкинуты.\nВ примере ниже дедупликация применяется только к тем строкам, которые имеют идентичные значения в столбцах name (имя) и purpose (цель). Таким образом, по “brian” у нас только 2 строки вместо 3 - первая “беседа с контактом” и единственная “беседа со случаем”. Чтобы сохранить последнюю беседу с Брайаном для каждой цели, см. вкладку Срез внутри групп.\nПрокрутите влево, чтобы увидеть весь датафрейм\n\n# добавляем к цепочке канала (например, вычистки данных)\nobs %&gt;% \n  distinct(name, purpose, .keep_all = TRUE) %&gt;%  # сохраняет строки, уникальные по имени и цели, сохраняет все столбцы\n  arrange(name)                                  # упорядочиваем для более удобного просмотра\n\n\n\n\n\n\n\nСм. оригинальные данные.\n\n\n\nДедупликация элементов в векторе\nФункция duplicated() из базового R оценит вектор (столбец) и выдаст логический вектор той же длины (TRUE/FALSE-ИСТИНА/ЛОЖЬ). Первый раз, когда появится значение, она выдаст FALSE (не дубликат), а в последующие разы это значение будет появляться, она выдаст TRUE (ИСТИНА). Обратите внимание, что NA рассматривается как любое другое значение.\n\nx &lt;- c(1, 1, 2, NA, NA, 4, 5, 4, 4, 1, 2)\nduplicated(x)\n\n [1] FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n\n\nЧтобы выдать только дублированные элементы, вы можете использовать квадратные скобки для определения подмножества из оригинального вектора:\n\nx[duplicated(x)]\n\n[1]  1 NA  4  4  1  2\n\n\nЧтобы выдать только уникальные элементы, используйте unique() из базового R. Чтобы удалить NA из выходных данных, поставьте na.omit() внутрь unique().\n\nunique(x)           # альтернативно, используйте x[!duplicated(x)]\n\n[1]  1  2 NA  4  5\n\nunique(na.omit(x))  # удаляет NA \n\n[1] 1 2 4 5\n\n\n\n\n\nИспользование базового R\nЧтобы выдать дублирующиеся строки\nВ базовом R вы можете также посмотреть, какие строки являются 100% дубликатами в датафрейме df с помощью команды duplicated(df) (выдает логический вектор строк).\nТаким образом, вы можете также использовать базовую команду подмножества [ ] для датафрейма, чтобы увидеть дублирующиеся строки с помощью df[duplicated(df),] (не забудьте запятую, что означает, что вы хотите увидеть все столбцы!).\nЧтобы выдать уникальные строки\nСм. заметки выше. Чтобы увидеть уникальные строки, вы добавляете логическое отрицание ! перед функцией duplicated():\ndf[!duplicated(df),]\nЧтобы выдать строки, которые являются дубликатами только определенных столбцов\nВыберите подмножество df, которое находится внутри скобок в duplicated(), чтобы эта функция работала только применительно к некоторым столбцам df.\nЧтобы уточнить столбцы, задайте номера или имена столбцов после запятой (помните, все это находится внутри функции duplicated()).\nУбедитесь, что вы сохранили запятую , также и за пределами функции duplicated()!\nНапример, чтобы оценить только столбцы со 2 по 5 на предмет дубликатов: df[!duplicated(df[, 2:5]),]\nЧтобы оценить только столбцы name и purpose на предмет дубликатов: df[!duplicated(df[, c(\"name\", \"purpose)]),]",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Дедупликация</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.ru.html#срез",
    "href": "new_pages/deduplication.ru.html#срез",
    "title": "15  Дедупликация",
    "section": "15.3 Срез",
    "text": "15.3 Срез\nЧтобы сделать “срез” датафрейма, чтобы применить фильтр к строкам по номеру/позиции строки. Это становится особенно полезно, если у вас по несколько строк на функциональную группу (например, на человека) и вам нужно сохранить только некоторые из них.\nВ базовом виде, функция slice() принимает числа и выдает строки в этих позициях. Если предоставляются положительные числа, выдаются только эти строки. Если отрицательные числа - эти строки не выдаются. Числа должны быть либо все положительными, либо все отрицательными.\n\nobs %&gt;% slice(4)  # выдает 4ю строку\n\n  recordID personID   name       date  time encounter purpose symptoms_ever\n1        3        2 amrish 2020-01-02 14:20         1 contact            No\n\n\n\nobs %&gt;% slice(c(2,4))  # выдает строки 2 и 4\n\n  recordID personID   name       date  time encounter purpose symptoms_ever\n1        1        1   adam 2020-01-01 09:00         1 contact          &lt;NA&gt;\n2        3        2 amrish 2020-01-02 14:20         1 contact            No\n\n#obs %&gt;% slice(c(2:4))  # выдает строки с 2 по 4\n\nСм. оригинальные данные.\nСуществует несколько вариаций: Для них нужно задавать столбец и количество строк, которые необходимо выдать (в n =).\n\nslice_min() и slice_max() сохраняет только строку(и) с минимальными или максимальными значениями по указанному столбцу. Также работает, чтобы выдать “минимум” и “максимум” упорядоченных факторов.\n\nslice_head() и slice_tail() - сохраняет только первую или последнюю строку(и).\n\nslice_sample() - сохраняет только случайную выборку строк.\n\n\nobs %&gt;% slice_max(encounter, n = 1)  # выдает строки с самым большим количеством бесед (encounter)\n\n  recordID personID   name       date  time encounter purpose symptoms_ever\n1        5        2 amrish 2020-01-05 16:10         3    case           Yes\n2       13        3 mariah 2020-01-06 08:32         3 contact            No\n3       16        5  brian 2020-01-07 07:59         3    case            No\n\n\nИспользуйте аргументы n = или prop =, чтобы указать число или долю строк, которые нужно сохранить. Если вы используете эту функцию не в рамках цепочки канала, сначала укажите аргумент данных (data) (например, slice(data, n = 2)). Для получения дополнительной информации, см. ?slice.\nДругие аргументы:\n.order_by = используется в slice_min() и slice_max(), это столбец, по которому идет упорядочивание до среза.\nwith_ties = по умолчанию TRUE (ИСТИНА), что означает, что равные значения сохраняются.\n.preserve = по умолчанию FALSE (ЛОЖЬ). Если TRUE (ИСТИНА), тогда структура группирования пересчитывается после среза.\nweight_by = опциональный, числовой столбец, по которому идет взвешивание (чем больше число, тем больше вероятность попасть в выборку). Также replace = чтобы указать, делается ли выборка с/без замещения.\nСОВЕТ: При использовании slice_max() и slice_min(), убедитесь, что вы указали/написали n = (например, n = 2, а не просто 2). В противном случае может возникнуть ошибка Error:…is not empty. \nПРИМЕЧАНИЕ: Вы можете столкнуться с функцией top_n(), вместо которой были введены функции slice.\n\n\nСрез с группами\nФункции slice_*() могут быть очень полезны, если будут применены к группированному датафрейму, поскольку операция среза проводится отдельно для каждой группы. Используйте функцию group_by() в сочетании со slice(), чтобы сгруппировать данные и сделать срез из каждой группы.\nЭто полезно для дедупликации, если у вас по несколько строк на человека, но вы хотите сохранить только одну из них. Сначала вы используете group_by() с ключевыми столбцами, которые относятся к одному и тому же человеку, а затем используйте функцию среза по столбцу, который отличается среди группированных строк.\nВ примере ниже, чтобы сохранить только самую последнюю беседу с каждым человеком, мы группируем строки по имени name, а затем используем slice_max() с n = 1 по столбцу дата date. Будьте внимательны! Чтобы применить такую функцию, как slice_max() к датам, столбец даты должен быть в классе Дата.\nПо умолчанию, “равенство” (например, та же дата в этом сценарии) сохраняются, и мы все равно получим по нескольку строк для некоторых людей (например, adam). Чтобы этого избежать, мы устанавливаем аргумент with_ties = FALSE. Мы получим только по одной строке на человека.\nВНИМАНИЕ: При использовании arrange(), уточните .by_group = TRUE, чтобы данные были упорядочены внутри каждой группы.\nВНИМАНИЕ: Если with_ties = FALSE, будет сохраняться первая строка равенства. Это может вводить в заблуждение. Обратите внимание, что у Mariah было две беседы в последний день (6 Jan), и была сохранена первая из них (более ранняя). Нам скорее всего интересна более поздняя беседа в этот день. Чтобы решить проблему равенства дат, см. следующий пример. \n\nobs %&gt;% \n  group_by(name) %&gt;%       # группируем строки по 'name'\n  slice_max(date,          # сохраняем строку в группе с максимальным значением даты \n            n = 1,         # сохраняем только один верхний ряд \n            with_ties = F) # если есть равенство (даты), берем первую строку\n\n\n\n\n\n\n\nНапример, выше мы можем увидеть, что у участника Amrish была сохранена только строка от 5 января, а у Brian только строка от 7 января. См. оригинальные данные.\nРешение проблемы “равенства”\nДля решения проблемы “равенства” можно выполнить ряд утверждений для среза. В данном случае, если с человеком было несколько бесед в самую последнюю дату, сохраняется беседа с самым последним временем (lubridate::hm() используется для конвертации текстового времени в сортируемый класс времени).\nОбратите внимание, что сейчас сохраняется одна строка для “Mariah” от 6 янвакря, и это беседа 3 в 08:32, а не беседа 2 в 07:25.\n\n# Пример нескольких утверждений в slice, чтобы решить проблему равенства\nobs %&gt;%\n  group_by(name) %&gt;%\n  \n  # ПЕРВОЕ - срез по последней дате\n  slice_max(date, n = 1, with_ties = TRUE) %&gt;% \n  \n  # ВТОРОЕ - если есть равенство, выбрать строку с более поздним временем; равенство запрещено\n  slice_max(lubridate::hm(time), n = 1, with_ties = FALSE)\n\n\n\n\n\n\n\nВ примере выше можно также сделать срез по номеру беседы encounter, но для примера мы показали срез по дате и времени date и time.\nСОВЕТ: Чтобы использовать slice_max() или slice_min() для текстового столбца, преобразуйте его с помощью mutate в класс упорядоченных факторов!\nСм. оригинальные данные.\n\n\n\nСохранить все, но пометить\nЕсли вы хотите сохранить все записи, но отметить лишь некоторые для анализа, рассмотрите использование двухэтапного подхода, используя уникальный идентификационный номер/номер беседы:\n\nСократите/срежьте оригинальный датафрейм до двух строк для анализа. Сохраните этот сокращенный датафрейм.\n\nВ оригинальном датафрейме отметьте соответствующие строки с помощью case_when(), основываясь на том, присутствует ли их уникальный идентификатор записи (в данном случае recordID) в сокращенном датафрейме.\n\n\n# 1. Определите датафрейм строк для сохранения для анализа\nobs_keep &lt;- obs %&gt;%\n  group_by(name) %&gt;%\n  slice_max(encounter, n = 1, with_ties = FALSE) # сохраняем только последнюю беседу для каждого человека\n\n\n# 2. Делаем пометки в оригинальном датафрейме\nobs_marked &lt;- obs %&gt;%\n\n  # создаем новый столбец дублирующихся записей dup_record\n  mutate(dup_record = case_when(\n    \n    # если запись есть в датафрейме obs_keep\n    recordID %in% obs_keep$recordID ~ \"For analysis\", \n    \n    # все остальные случаи отмечаются как игнорировать \"Ignore\" для целей анализа\n    TRUE                            ~ \"Ignore\"))\n\n# печать\nobs_marked\n\n   recordID personID    name       date  time encounter purpose symptoms_ever\n1         1        1    adam 2020-01-01 09:00         1 contact          &lt;NA&gt;\n2         1        1    adam 2020-01-01 09:00         1 contact          &lt;NA&gt;\n3         2        2  amrish 2020-01-02 14:20         1 contact            No\n4         3        2  amrish 2020-01-02 14:20         1 contact            No\n5         4        3  mariah 2020-01-05 12:00         1    case            No\n6         5        2  amrish 2020-01-05 16:10         3    case           Yes\n7         6        4  nikhil 2020-01-05 13:01         1 contact           Yes\n8         7        5   brian 2020-01-05 15:20         1 contact            No\n9         8        6   smita 2020-01-05 14:20         1 contact           Yes\n10        9        7  raquel 2020-01-05 12:30         1 contact          &lt;NA&gt;\n11       10        2  amrish 2020-01-02 10:24         2 contact           Yes\n12       11        1    adam 2020-01-05 09:40         2    case            No\n13       12        3  mariah 2020-01-06 07:25         2 contact            No\n14       13        3  mariah 2020-01-06 08:32         3 contact            No\n15       14        4  nikhil 2020-01-06 15:36         2 contact           Yes\n16       15        5   brian 2020-01-06 15:31         2 contact           Yes\n17       16        5   brian 2020-01-07 07:59         3    case            No\n18       17        7  raquel 2020-01-07 11:13         2 contact            No\n19       18        8 natalie 2020-01-07 17:12         1    case            No\n     dup_record\n1        Ignore\n2        Ignore\n3        Ignore\n4        Ignore\n5        Ignore\n6  For analysis\n7        Ignore\n8        Ignore\n9  For analysis\n10       Ignore\n11       Ignore\n12 For analysis\n13       Ignore\n14 For analysis\n15 For analysis\n16       Ignore\n17 For analysis\n18 For analysis\n19 For analysis\n\n\n\n\n\n\n\n\nСм. оригинальные данные.\n\n\n\nРасчет полноты строк\nСоздайте столбец, который содержит метрику полноты строки (не-отсутствия). Это может быть полезным при определении того, какие строки будут более приоритетными по сравнению с другими при дедупликации/срезе.\nВ данном примере, “ключевые” столбцы, по которым вы будете измерять полноту, сохраняются как вектор имен столбцов.\nЗатем создается новый столбец key_completeness с помощью mutate(). Новое значение в каждой строке определяется как рассчитанная дробь: количество неотсутствующих значений в этой строке среди ключевых столбцов, разделенное на количество ключевых столбцов.\nЭто требует функции rowSums() из базового R. Также используется ., что внутри канала относится к датафрейму на тот момент канала (в данном случае используется подмножество с квадратными скобками []).\n*Прокрутите вправо, чтобы увидеть больше строк**\n\n# создаем столбец \"полноты ключевых переменных\"\n# это *доля* от столбцов, указанных как ключевые \"key_cols\", в которых значения не отсутствуют\n\nkey_cols = c(\"personID\", \"name\", \"symptoms_ever\")\n\nobs %&gt;% \n  mutate(key_completeness = rowSums(!is.na(.[,key_cols]))/length(key_cols)) \n\n\n\n\n\n\n\nСм. оригинальные данные.",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Дедупликация</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.ru.html#str_rollup",
    "href": "new_pages/deduplication.ru.html#str_rollup",
    "title": "15  Дедупликация",
    "section": "15.4 Комбинирование значений",
    "text": "15.4 Комбинирование значений\nВ данном разделе описано:\n\nКак “комбинировать” значения из нескольких строк в одну строку с некоторыми вариациями\n\nКак только у вас есть “комбинированные” значения, как переписать/приоритезировать значения в каждой ячейке\n\nЗдесь используется пример набора данных из раздела Подготовка.\n\n\nКомбинирование значений в одну строку\nПример кода ниже использует group_by() и summarise(), чтобы сгруппировать строки по лицам, а затем вставить вместе все уникальные значения в группированных строках. Таким образом, вы получаете одну сводную строку на человека. Несколько замечаний:\n\nКо всем новым столбцам добавляется суффикс (в данном случае “_roll”)\n\nЕсли вы хотите показать только уникальные значения в клетке, тогда оберните na.omit() в unique()\n\nna.omit() удаляет значения NA, но если вам это нежелательно, его можно удалить с помощью paste0(.x)…\n\n\n# \"Комбинируем\" значения в одну строку на группу (на один \"personID\") \ncases_rolled &lt;- obs %&gt;% \n  \n  # создаем группы по имени\n  group_by(personID) %&gt;% \n  \n  # упорядочиваем строки внутри каждой группы (например, по дате)\n  arrange(date, .by_group = TRUE) %&gt;% \n  \n  # для каждого столбца вставляем вместе все значения в группированных строках, отделенные \";\"\n  summarise(\n    across(everything(),                           # применяем ко всем столбцам\n           ~paste0(na.omit(.x), collapse = \"; \"))) # определяется функция, которая комбинирует значения, которые не являются NA\n\nРезультатом будет одна строка на группу (ID) с записями, упорядоченными по дате и вставленными вместе. Прокрутите влево, чтобы увидеть больше строк\n\n\n\n\n\n\nСм. оригинальные данные.\nДанная вариация показывает только уникальные значения:\n\n# Вариация - показать только уникальные значения \ncases_rolled &lt;- obs %&gt;% \n  group_by(personID) %&gt;% \n  arrange(date, .by_group = TRUE) %&gt;% \n  summarise(\n    across(everything(),                                   # применяем ко всем столбцам\n           ~paste0(unique(na.omit(.x)), collapse = \"; \"))) # определяется функция, которая комбинирует уникальные значения, которые не являются NA\n\n\n\n\n\n\n\nДанная вариация добавляет суффикс к каждому столбцу.\nВ данном случае “_roll” указывает на то, что столбец скомбинирован:\n\n# Вариация - к именам столбцов добавляется суффикс \ncases_rolled &lt;- obs %&gt;% \n  group_by(personID) %&gt;% \n  arrange(date, .by_group = TRUE) %&gt;% \n  summarise(\n    across(everything(),                \n           list(roll = ~paste0(na.omit(.x), collapse = \"; \")))) # _roll добавляется к именам столбцов\n\n\n\n\n\n\n\n\n\n\nПерезапись значений/иерархия\nЕсли вы затем хотите оценить все комбинированные значения и сохранить только конкретное значение (например, “наилучшее” или “максимальное” значение), вы можете использовать mutate() по нужным столбцам, чтобы выполнить case_when(), которая использует str_detect() из пакета stringr для последовательного поиска последовательностей символов, и перезаписать содержимое ячейки.\n\n# ЧИСТЫЕ СЛУЧАИ\n#############\ncases_clean &lt;- cases_rolled %&gt;% \n    \n    # чистые переменные Yes-No-Unknown (Да-Нет-Неизвестно): замещает текст \"самым высоким\" значением, присутствующим в последовательности\n    mutate(across(c(contains(\"symptoms_ever\")),                     # работает для указанных столбцов (Y/N/U)\n             list(mod = ~case_when(                                 # добавляет суффикс \"_mod\" к новым столбцам; выполняет case_when()\n               \n               str_detect(.x, \"Yes\")       ~ \"Yes\",                 # если обнаружено \"Yes\", тогда значение ячейки конвертируется на Yes (да)\n               str_detect(.x, \"No\")        ~ \"No\",                  # затем, если обнаружено \"No\", тогда значение ячейки консертируется на No (нет)\n               str_detect(.x, \"Unknown\")   ~ \"Unknown\",             # затем, если обнаружено \"Unknown\", тогда значение ячейки конвертируется на Unknown (неизвестно)\n               TRUE                        ~ as.character(.x)))),   # затем, в остальных случаях сохраняется как есть\n      .keep = \"unused\")                                             # старые столбцы удаляются, остаются только столбцы _mod\n\nТеперь вы видите в столбце symptoms_ever, что если человек КОГДА-ЛИБО ответил да на симптомы (“Yes”), то отобразится только “Yes”.\n\n\n\n\n\n\nСм. оригинальные данные.",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Дедупликация</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.ru.html#вероятностная-дедупликация",
    "href": "new_pages/deduplication.ru.html#вероятностная-дедупликация",
    "title": "15  Дедупликация",
    "section": "15.5 Вероятностная дедупликация",
    "text": "15.5 Вероятностная дедупликация\nИногда вам может потребоваться выявить “вероятные” дубликаты на основе похожести (например, расстояния последовательности) по нескольким столбцам, таким как имя, возраст, пол, дата рождения и т.п. Вы можете применить алгоритмы поиска вероятностных совпадений, чтобы выявить вероятные дубликаты.\nСм. страницу [Соединение данных], где объясняется этот метод. В разделе по вероятностным соответствиям есть пример применения этих алгоритмов для сравнения датафрейма с самим собой, таким образом проводя вероятностную дедупликацию.",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Дедупликация</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.ru.html#ресурсы",
    "href": "new_pages/deduplication.ru.html#ресурсы",
    "title": "15  Дедупликация",
    "section": "15.6 Ресурсы",
    "text": "15.6 Ресурсы\nБольшая часть информации на этой странице взята из следующих онлайн ресурсов и виньеток:\ndatanovia\nсправка по dplyr tidyverse\nвиньетка cran janitor",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Дедупликация</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.ru.html",
    "href": "new_pages/iteration.ru.html",
    "title": "16  Итерации, циклы и списки",
    "section": "",
    "text": "16.1 Подготовка",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Итерации, циклы и списки</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.ru.html#подготовка",
    "href": "new_pages/iteration.ru.html#подготовка",
    "title": "16  Итерации, циклы и списки",
    "section": "",
    "text": "Загрузка пакетов\nДанный фрагмент кода показывает загрузку пакетов, необходимых для анализа. В данном руководстве мы фокусируемся на использовании p_load() из пакета pacman, которая устанавливает пакет, если необходимо, и загружает его для использования. Вы можете также загрузить установленные пакеты с помощью library() из базового R. См. страницу [Основы R] для получения дополнительной информации о пакетах R.\n\npacman::p_load(\n     rio,         # импорт/экспорт\n     here,        # расположение файла\n     purrr,       # итерации\n     grates,      # шкалы в ggplot\n     tidyverse    # управление данными и визуализация\n)\n\n\n\nИмпорт данных\nМы импортируем набор данных о случаях имитированной эпидемии Эболы. Если вы хотите выполнять действия параллельно, кликните, чтобы скачать “чистый” построчный список (как .rds файл). Импортируйте данный с помощью функции import() из пакета rio (он работает с многими типами файлов, такими как .xlsx, .csv, .rds - см. детали на странице [Импорт и экспорт]).\n\n# импортируем построчный список\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nПервые 50 строк построчного списка отображены ниже.",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Итерации, циклы и списки</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.ru.html#циклы-for",
    "href": "new_pages/iteration.ru.html#циклы-for",
    "title": "16  Итерации, циклы и списки",
    "section": "16.2 Циклы for",
    "text": "16.2 Циклы for\n\nЦиклы for в R\nЦиклы for не очень часто применяются в R, но часто встречаются в других языках программирования. Вам, как начинающему, они могут быть полезны для изучения и практики, поскольку их легче изучать, проводить дебаггинг и разобраться, что происходит при каждой итерации, особенно если вы еще не умеете писать собственные функции.\nВы можете быстро перейти от циклов for к итерации с помощью построенных функций в purrr (см. раздел ниже).\n\n\nКлючевые компоненты\nВ цикле for есть три ключевых части:\n\nПоследовательность элементов, по которым проводится итерация\n\nОперации, которые проводятся для каждого элемента последовательности\n\nКонтейнер для результатов (опционально)\n\nБазовый синтаксис выглядит следующим образом: for (элемент в последовательности) {сделать операции с элементом}. Обратите внимание, что есть скобки и фигурные скобки. Результаты можно вывести на консоль, либо сохранить в контейнере объекта R.\nПростой пример цикла for представлен ниже.\n\nfor (num in c(1,2,3,4,5)) {  # определяем ПОСЛЕДОВАТЕЛЬНОСТЬ (числа с 1 по 5) и цикл открывается с помощью \"{\"\n  print(num + 2)             # ОПЕРАЦИИ (добавить два к каждому числу последовательности и вывести на печать)\n}                            # закрываем цикл с помощью \"}\"                            \n\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n\n                             # В данном примере нет \"контейнера\"\n\n\n\nПоследовательность\nЭто элемент “for” (для) в цикле for - операции будут проводиться “для” каждого элемента в последовательности. Последовательность может быть рядом значений (например, имен юрисдикций, болезней, имен столбцов, элементов списка и т.п.), либо она может быть рядом последовательно идущих чисел (например, 1,2,3,4,5). Каждый из подходов имеет свое применение, что описано ниже.\nБазовая структура утверждения в последовательности - item in vector (элемент в векторе).\n\nВы можете записать любой знак или слово вместо “item”(“элемента”) (например, “i”, “num”, “hosp”, “district”, и т.п.). Значение этого “элемента” меняется при каждой итерации цикла, проходя по каждому значению в векторе.\n\nВектор может быть текстовыми значениями, именами столбцов, либо последовательностью чисел - это значения, которые будут меняться при каждой итерации. Вы можете их использовать внутри операций цикла for, через термин “item” (элемент).\n\nПример: последовательность текстовых значений\nВ данном примере цикл выполняется для каждого значения в заранее установленном текстовом векторе имен больниц.\n\n# создаем вектор имен больниц\nhospital_names &lt;- unique(linelist$hospital)\nhospital_names # печать\n\n[1] \"Other\"                               \n[2] \"Missing\"                             \n[3] \"St. Mark's Maternity Hospital (SMMH)\"\n[4] \"Port Hospital\"                       \n[5] \"Military Hospital\"                   \n[6] \"Central Hospital\"                    \n\n\nМы выбрали термин hosp для отражения значений из вектора hospital_names. Для первой итерации цикла, значением hosp будет hospital_names[[1]]. Во втором цикле это будет hospital_names[[2]]. И так далее…\n\n# 'цикл for' с текстовой последовательностью\n\nfor (hosp in hospital_names){       # последовательность\n  \n       # ЗДЕСЬ ОПЕРАЦИИ\n  }\n\nПример: последовательность имен столбцов\nЭто вариация текстовой последовательности, приведенной выше, в которой имена существующего объекта R извлекаются и становятся вектором. Например, имена столбцов в датафрейме. Что удобно, в коде операций циклов for, имена столбцов могут быть использованы для индексирования (подмножества) оригинального датафрейма\nНиже последовательностью являются names() (имена столбцов) датафрейма linelist. Название нашего “элемента” - col, что отражает каждое название столбца по мере проведения циклов.\nДля примера мы включаем код операций внутри цикла for, который проводится для каждого значения в последовательности. В этом коде значения последовательности (имена столбцов) используются для индексирования (подмножества) linelist, по одному. Как рассказано на странице [Основы R], двойные квадратные скобки используются для подмножества [[ ]]. Полученный в результате столбец передается в is.na(), затем в sum() для получения количества отсутствующих значений в столбце. Результат печатается в консоли - одно число для каждого столбца.\nПримечание по индексированию с помощью имен столбцов - когда вы ссылаетесь на сам столбец, не пишите просто “col”! col отражает только текстовое имя столбца! Чтобы сослаться на весь столбец, вы должны использовать имя столбца как индекс в linelist с помощью linelist[[col]].\n\nfor (col in names(linelist)){        # цикл выполняется для каждого столбца в построчном списке; имя столбца представлено как \"col\" \n  \n  # Пример кода операций - печать количества отсутствующих значений в столбце\n  print(sum(is.na(linelist[[col]])))  # построчный список индексируется текущим значением \"col\"\n     \n}\n\n[1] 0\n[1] 0\n[1] 2087\n[1] 256\n[1] 0\n[1] 936\n[1] 1323\n[1] 278\n[1] 86\n[1] 0\n[1] 86\n[1] 86\n[1] 86\n[1] 0\n[1] 0\n[1] 0\n[1] 2088\n[1] 2088\n[1] 0\n[1] 0\n[1] 0\n[1] 249\n[1] 249\n[1] 249\n[1] 249\n[1] 249\n[1] 149\n[1] 765\n[1] 0\n[1] 256\n\n\nПоследовательность чисел\nВ данном подходе последовательность - ряд последовательно расположенных чисел. Таким образом, значение “элемента” - то не текстовое значение (например, “Central Hospital” или “date_onset”), а число. Это полезно для того, чтобы выполнить циклы для датафреймов, поскольку можно использовать номер “элемента” внутри цикла for, чтобы индексировать датафрейм по номеру строки.\nНапример, представим, что вы хотите выполнить цикл для каждой строки в вашем датафрейме и извлечь определенную информацию. Вашими “элементами” будут числовые номера строк. Часто в этом случае элементы (“items”) записывают как i.\nПроцесс циклов for можно объяснить словами следующим образом: “для каждого элемента последовательности чисел от 1 до общего количества строк в моем датафрейме, выполнить X”. Для первой итерации цикла значеним элемента (“item”) i будет 1. Для второй - i будет 2 и т.п.\nВот так выглядит последовательность в виде кода: for (i в 1:nrow(linelist)) {КОД ОПЕРАЦИЙ} где i отражает “item” (элемент), а 1:nrow(linelist) создает последовательность последовательно идущих чисел от 1 до количества строк в linelist.\n\nfor (i in 1:nrow(linelist)) {  # применяем к датафрейму\n  # ЗДЕСЬ ОПЕРАЦИИ\n}  \n\nЕсли вы хотите, чтобы последовательность была числами, но вы начинаете с вектора (а не датафрейма), используйте seq_along(), чтобы выдать последовательность чисел для каждого элемента вектора. Например, for (i in seq_along(hospital_names) {КОД ОПЕРАЦИЙ}.\nПриведенный ниже код выдает числа, которые станут значением i в своем соответствующем цикле.\n\nseq_along(hospital_names)  # используем для именованного вектора\n\n[1] 1 2 3 4 5 6\n\n\nПреимуществом использования чисел в последовательности является то, что легко использовать число i для индексации контейнера, который хранит выходные результаты цикла. Пример представлен в разделе Операции ниже.\n\n\nОперации\nЭтот код записан внутри фигурных скобок { } в цикле for. Вам нужно, чтобы этот код выполнялся для каждого “элемента” в последовательности. Следовательно, будьте внимательны, чтобы каждая часть вашего кода, которая меняет “элемент”, была правильно закодирована таким образом, чтобы он действительно изменился! Например, помните, что для индексирования нужно использовать [[ ]].\nВ примере ниже мы проводим итерацию для каждой строки в linelist. Значения пола (gender) и возраста (age) каждой строки вставляются вместе и хранятся в векторе-контейнере cases_demographics. Обратите внимание, как мы также используем индексирование [[i]], чтобы сохранить выходные результаты цикла в правильной позиции в векторе “контейнере”.\n\n# создаем контейнер для хранения результатов - текстовый вектор\ncases_demographics &lt;- vector(mode = \"character\", length = nrow(linelist))\n\n# цикл for\nfor (i in 1:nrow(linelist)){\n  \n  # ОПЕРАЦИИ\n  # извлекаем значения из построчного списка для строки i, используя квадратные скобки для индексирования\n  row_gender  &lt;- linelist$gender[[i]]\n  row_age     &lt;- linelist$age_years[[i]]    # не забудьте индексировать!\n     \n  # объединяем пол-возраст и храним в векторе-контейнере в указанной индексом локации\n  cases_demographics[[i]] &lt;- str_c(row_gender, row_age, sep = \",\") \n\n}  # окончание цикла\n\n\n# отображаем первые 10 строк контейнера\nhead(cases_demographics, 10)\n\n [1] \"m,2\"  \"f,3\"  \"m,56\" \"f,18\" \"m,3\"  \"f,16\" \"f,16\" \"f,0\"  \"m,61\" \"f,27\"\n\n\n\n\nКонтейнер\nИногда результаты циклов for будут печататься в консоли или на панели RStudio Plots (Графики). А иногда вам нужно будет сохранить выходные данные в “контейнере” для использования позже. Такой контейнер может быть вектором, датафреймом или даже списком.\nНаиболее эффективным способом является создание контейнера для результатов еще до начала цикла for. На практике это означает, что необходимо создать пустой вектор, датафрейм или список. Их можно создать с помощью функции vector() для векторов или списков, либо с помощью matrix() и data.frame() для датафрейма.\nПустой вектор\nИспользуйте vector() и уточните mode = на основе ожидаемого класса объектов, которые вы вставите, либо “double” (двойной точности - для чисел), “character” (текстовый), или “logical” (логический). Вам также нужно заранее задать длину length =. Это должна быть длина вашей последовательности циклов for.\nДопустим, вы хотите сохранить медианную задержку госпитализации для каждой больницы. Вы можете использовать “double” (число двойной точности) и установить длину на количество ожидаемых выходных данных (количество уникальных больниц в наборе данных).\n\ndelays &lt;- vector(\n  mode = \"double\",                            # мы ожидаем, что нужно сохранить числа\n  length = length(unique(linelist$hospital))) # число уникальных больниц в наборе данных\n\nПустой датафрейм\nВы можете создать пустой датафрейм, указав количество строк и столбцов следующим образом:\n\ndelays &lt;- data.frame(matrix(ncol = 2, nrow = 3))\n\nПустой список\nВы можете также сохранить некоторые графики, созданные циклом for, в виде списка. Список похож на вектор, но содержит другие объекты R внутри себя, которые могут быть разных классов. Элементы в списке могут быть отдельным числом, датафреймом, вектором или даже еще одним списком.\nВы создаете пустой список, используя ту же команду vector(), что указана выше, но с аргументом mode = \"list\". Уточните любую желаемую длину.\n\nplots &lt;- vector(mode = \"list\", length = 16)\n\n\n\nПечать\nОбратите внимание, что для печати изнутри цикла for вам скорее всего нужно будет дополнительно обернуть с помощью функции print().\nВ примере ниже последовательность является текстовым вектором, который используется для создания подмножества из построчного списка по больницам. Результаты не сохраняются в контейнере, а печатаются в консоли с помощью функции print().\n\nfor (hosp in hospital_names){ \n     hospital_cases &lt;- linelist %&gt;% filter(hospital == hosp)\n     print(nrow(hospital_cases))\n}\n\n[1] 885\n[1] 1469\n[1] 422\n[1] 1762\n[1] 896\n[1] 454\n\n\n\n\nТестирование цикла for\nЧтобы протестировать ваш цикл, вы можете выполнить команду для временного присваивания “элемента”, например, i &lt;- 10 или hosp &lt;- \"Central Hospital\". Сделайте это за пределами цикла и затем выполните только ваш код операций (код внутри фигурных скобок), чтобы посмотреть, будут ли созданы ожидаемые результаты.\n\n\nЦиклы для графиков\nЧтобы объединить все три компонента (контейнер, последовательность и операции), давайте попробуем построить эпидкривую для каждой больницу (см. страницу [Эпидемические кривые]).\nМы можем создать красивую эпидемическую кривую всех случаев по полу, используя пакет incidence2, как показано ниже:\n\n# создаем объект 'incidence' (заболеваемость)\noutbreak &lt;- incidence2::incidence(   \n     x = linelist,                   # датафрейм - полный построчный список\n     date_index = \"date_onset\",        # столбец дата\n     interval = \"week\",              # суммарный подсчет по неделе\n     groups = \"gender\")               # группируем значения по полу\n     #na_as_group = TRUE)             # отсутствующий пол в отдельную группу\n\n# строим эпидемическую кривую\nggplot(outbreak, # имя объекта заболеваемости\n        aes(x = date_index, #эстетика и оси\n            y = count, \n            fill = gender), # цвет заливки столбцов по полу\n       color = \"black\"      # контур столбцов\n       ) +  \n     geom_col() + \n     facet_wrap(~gender) +\n     theme_bw() + \n     labs(title = \"Outbreak of all cases\", #подписи\n          x = \"Counts\", \n          y = \"Date\", \n          fill = \"Gender\", \n          color = \"Gender\")\n\n\n\n\n\n\n\n\nЧтобы создать отдельный график для случаев по каждой больнице, мы можем код эпидкривой заложить в цикл for.\nСначала мы сохраняем именованный вектор уникальных имен больниц, hospital_names. Цикл for будет выполнен один раз для каждого из этих имен: for (hosp in hospital_names). В каждой итерации цикла for, текущее имя больницы из вектора будет представлено как hosp для использования внутри цикла.\nВнутри операций цикла вы можете писать код R как обычно, но используйте “элемент” (в данном случае hosp), зная, что его значение будет меняться. Внутри этого цикла:\n\nПрименяется filter() к построчному списку linelist, так чтобы столбец hospital был равен текущему значению hosp\n\nСоздается объект incidence (заболеваемость) в отфильтрованном построчном списке\n\nСоздается график для текущей больницы с автоматически изменяемым заголовком, который использует hosp\n\nГрафик для текущей больницы временно сохраняется и затем печатается\n\nЗатем цикл переходит дальше и повторяет процесс со следующей больницей в hospital_names\n\n\n# создаем вектор имен больниц\nhospital_names &lt;- unique(linelist$hospital)\n\n# для каждого имени (\"hosp\") в hospital_names, создаем и печатаем эпидкривую\nfor (hosp in hospital_names) {\n     \n     # создаем объект incidence (заболеваемость) конкретно для текущей больницы\n     outbreak_hosp &lt;- incidence2::incidence(\n          x = linelist %&gt;% filter(hospital == hosp),   # построчный список фильтруется до текущей больницы\n          date_index = \"date_onset\",\n          interval = \"week\", \n          groups = \"gender\"#,\n          #na_as_group = TRUE\n     )\n     \n      plot_hosp &lt;- ggplot(outbreak_hosp, # имя объекта incidence\n                         aes(x = date_index, #axes\n                             y = count, \n                             fill = gender), # цвет заливки по полу\n                         color = \"black\"      # цвет контура столбца\n                         ) +  \n          geom_col() + \n          facet_wrap(~gender) +\n          theme_bw() + \n          labs(title = stringr::str_glue(\"Epidemic of cases admitted to {hosp}\"), #заголовок\n               x = \"Counts\", \n               y = \"Date\", \n               fill = \"Gender\", \n               color = \"Gender\")\n     \n     # В более старых версиях R удалите # перед na_as_group и используйте вместо этого эту команду для графика\n    # plot_hosp &lt;- plot(\n#       outbreak_hosp,\n#       fill = \"gender\",\n#       color = \"black\",\n#       title = stringr::str_glue(\"Epidemic of cases admitted to {hosp}\")\n#     )\n     \n     #печать графика больниц\n     print(plot_hosp)\n     \n} # цикл for заканчивается. когда он пройдет по каждой больнице hospital_names \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nОтслеживание прогресса цикла\nЦикл с большим количеством итераций может занять минуты или даже часы. Поэтому может полезным печатать прогресс в консоли R. Утверждение if ниже можно разместить внутри операций цикла, чтобы печатать каждое 100е число. Просто скорректируйте его таким образом, чтобы i была “элементом” в вашем цикле.\n\n# цикл с кодом для печати прогресса каждые 100 итераций\nfor (i in seq_len(nrow(linelist))){\n\n  # печать прогресса\n  if(i %% 100==0){    # оператор %% - это остаток\n    print(i)\n\n}",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Итерации, циклы и списки</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.ru.html#iter_purrr",
    "href": "new_pages/iteration.ru.html#iter_purrr",
    "title": "16  Итерации, циклы и списки",
    "section": "16.3 purrr и списки",
    "text": "16.3 purrr и списки\nЕще один подход к итеративным операциям - это пакет purrr - это подход к итерациям из tidyverse.\nЕсли вы столкнулись с выполнением одной и той же задачи несколько раз, наверное, имеет смысл создать обобщенное решение, которое вы можете использовать со многими входными данными. Например, создание графиков для нескольких юрисдикций, либо импорт и объединение множества файлов.\nЕсть также другие преимущества purrr - вы можете использовать его с операторами канала %&gt;%, он справляется с ошибками лучше обычного цикла for, а синтаксис является весьма чистым и простым! Если вы используете цикл for, вы, скорее всего, сможете сделать то же самое более понятным и коротким образом с помощью purrr!\nПомните, что purrr является инструментом функционального программирования. То есть, операции, которые будут применяться циклично, оборачиваются в функции. См. страницу [Написание функций], чтобы узнать, как писать собственные функции.\npurrr также почти полностью основана на списках и векторах - поэтому воспринимайте ее как применение функции к каждому элементу этого списка/вектора!\n\nЗагрузка пакетов\npurrr является частью tidyverse, поэтому нет необходимости устанавливать/загружать отдельный пакет.\n\npacman::p_load(\n     rio,            # импорт/экспорт\n     here,           # относительные пути к файлу\n     tidyverse,      # управление данными и визуализация\n     writexl,        # написание файла Excel с несколькими листами\n     readxl          # импорт Excel с несколькими листами\n)\n\n\n\nmap()\nОдна из ключевых функций purrr - это функция map(), которая “сопоставляет” (применяет) функцию к каждому входному элементу списка/вектора, который вы зададите.\nБазовый синтаксис: map(.x = ПОСЛЕДОВАТЕЛЬНОСТЬ, .f = ФУНКЦИЯ, ДРУГИЕ АРГУМЕНТЫ). Если смотреть более детально:\n\n.x = это входные данные, к которым будет итеративно применяться функция .f - например, вектор имен юрисдикций, столбцов в датафрейме или списка датафреймов\n\n.f = это функция, которая применяется в каждому элементу входных данных .x - это может быть такая функция, как print() которая уже существует, либо это может быть пользовательская функция, которую вы создадите. Функция часто записывается после тильды ~ (детали ниже).\n\nЕще несколько комментариев по синтаксису:\n\nЕсли для функции не требуется уточнять дополнительные аргументы, ее можно записать без скобок и без тильды (например, .f = mean). Чтобы указать аргументы, которые будут иметь одинаковое значение для каждой итерации, задайте их с помощью map(), но за пределами аргумента .f =, например, na.rm = T в map(.x = my_list, .f = mean, na.rm=T).\n\nВы можете использовать .x (или просто .) внутри функции .f = в качестве заполнителя для значения .x для этой итерации\n\nИспользуйте синтаксис тильды (~), чтобы обеспечить больший контроль над функцией - запишите функцию как обычно со скобками, например: map(.x = my_list, .f = ~mean(., na.rm = T)). В частности, используйте этот синтаксис, если значение аргумента будет меняться каждую итерацию, либо если это значение самого .x (см. примеры ниже)\n\nВыходным результатом использования map() будет список list - list (список) является классом объектов, как и вектор, но его элементы могут относиться к разным классам. Таким образом, если список, созданный с помощью map(), может содержать много датафреймов, либо много векторов, много отдельных значений или даже много списков! Существуют альтернативные версии map(), объясненные ниже, которые создают другие типы выходных данных (например, map_dfr() для создания датафрейма, map_chr() для создания текстовых векторов, и map_dbl() для создания числовых векторов).\n\nПример - импорт и объединение листов Excel\nДавайте продемонстрируем на примере частой задачи эпидемиолога: - Вам нужно импортировать рабочую книгу Excel с данными о случаях, но данные разделены на разные именованные листы рабочей книги. Как эффективно импортировать и объединить эти листы в один датафрейм?\nПредставим, что нам прислали указанную ниже рабочую книгу Excel. На каждом листе содержатся случаи из конкретной больницы.\n\n\n\n\n\n\n\n\n\nВот один подход, который использует map():\n\nиспользуйте map() для функции import(), чтобы она выполнялась для каждого листа Excel\n\nкомбинируйте импортированные датафреймы в один, используя bind_rows()\n\nпо ходу выполнения сохраните оригинальное имя листа для каждой строки, сохраняя эту информацию в новом столбце итогового датафрейма\n\nВо-первых, нам нужно извлечь имена листов и сохранить их. Мы зададим путь к файлу рабочей книги Excel для функции excel_sheets() из пакета readxl, который извлекает имена листов. Мы их храним в текстовом векторе, называемом sheet_names.\n\nsheet_names &lt;- readxl::excel_sheets(\"hospital_linelists.xlsx\")\n\nВот эти имена:\n\nsheet_names\n\n[1] \"Central Hospital\"              \"Military Hospital\"            \n[3] \"Missing\"                       \"Other\"                        \n[5] \"Port Hospital\"                 \"St. Mark's Maternity Hospital\"\n\n\nТеперь, когда у нас есть этот вектор имен, map() может задавать их по одному функции import(). В этом примере sheet_names - это .x, а import() - это функция .f.\nВспомните, на странице [Импорт и экспорт] мы говорили, что при использовании для рабочих книг Excel, import() может принять аргумент which =, указывающий, какой лист импортировать. Внутри функции .f import(), мы задаем which = .x, чье значение будет меняться при каждой итерации по вектору sheet_names - сначала “Central Hospital”, потом “Military Hospital” и т.п.\nСледует отметить - поскольку мы использовали map(), данные из каждого листа Excel будут сохранены как отдельный датафрейм внутри списка. Мы хотим, чтобы у каждого из этих элементов списка (датафреймов) было имя, поэтому до того, как мы подставим sheet_names к map(), мы передаем его через set_names() из purrr, чтобы у каждого элемента списка было соответствующее имя.\nМы сохраняем полученный в результате список как combined.\n\ncombined &lt;- sheet_names %&gt;% \n  purrr::set_names() %&gt;% \n  map(.f = ~import(\"hospital_linelists.xlsx\", which = .x))\n\nПри рассмотрении выходного результата мы видим, что данные из каждого листа Excel сохранены в списке с определенным именем. Это хорошо, но мы еще не закончили.\n\n\n\n\n\n\n\n\n\nНаконец, мы используем функцию bind_rows() (из dplyr), которая принимает список аналогичным образом структурированных датафреймов и комбинирует их в один датафрейм. Чтобы создать новый столбец из элемента списка names (имена), мы используем аргумент .id = и задаем ему желаемое имя для нового столбца.\nНиже представлена полная последовательность команд:\n\nsheet_names &lt;- readxl::excel_sheets(\"hospital_linelists.xlsx\")  # извлекаем имена листов\n \ncombined &lt;- sheet_names %&gt;%                                     # начинаем с имен листов\n  purrr::set_names() %&gt;%                                        # задаем их имена\n  map(.f = ~import(\"hospital_linelists.xlsx\", which = .x)) %&gt;%  # проводим итерации, импорт, сохраняем в списке\n  bind_rows(.id = \"origin_sheet\") # объединяем список датафреймов, сохраняем их источник в новом столбце  \n\nТеперь у нас есть один датафрейм со столбцом, содержащим лист происхождения!\n\n\n\n\n\n\n\n\n\nСуществуют вариации map(), о которых вам нужно знать. Например, map_dfr() выдает датафрейм, а не список. Таким образом, мы могли бы использоватьт ее для указанной выше задачи и нам не пришлось бы связывать строки. Но тогда мы бы не смогли зафиксировать, из какого листа (больницы) мы получили каждый случай.\nДругие вариации включают map_chr(), map_dbl(). Эти функции очень полезны по двум причинам. Во-первых, они автоматически конвертируют выходные данные итеративной функции в вектор (не список). Во-вторых, они могут четко контролировать, в каком классе будут выданы данные, вы можете обеспечить текстовый вектор на выходе с помощью map_chr(), либо числовой вектор с помощью map_dbl(). Вернемся к ним позднее в этом разделе!\nФункции map_at() и map_if() также очень полезны для итерации - они позволяют вам уточнить, по каким элементам списка вам нужна итерация! Они работают просто с помощью применения вектора индексов/имен (в случае map_at()) или логического теста (в случае map_if()).\nДавайте используем пример, где мы не хотим прочитывать первый лист данных по больнице. Мы используем map_at() вместо map(), и уточняем аргумент .at = в c(-1), что означает не использовать первый элемент .x. Альтернативно вы можете задать вектор положительных чисел или имен в .at =, чтобы уточнить, какие элементы использовать.\n\nsheet_names &lt;- readxl::excel_sheets(\"hospital_linelists.xlsx\")\n\ncombined &lt;- sheet_names %&gt;% \n     purrr::set_names() %&gt;% \n     # exclude the first sheet\n     map_at(.f = ~import( \"hospital_linelists.xlsx\", which = .x),\n            .at = c(-1))\n\nОбратите внимание, что имя первого листа все еще будет появляться как элемент выходного списка - но это только текстовое имя (не датафрейм). Вам нужно удалить этот элемент до связывания строк. Мы рассмотрим, как удалять и модифицировать элементы списка в одном из разделов ниже.\n\n\n\nРазделение набора данных и экспорт\nНиже мы приведем пример того, как разделять набор данных на части и затем использовать итерацию map() для экспорта каждой части как отдельного листа Excel, либо как отдельного файла CSV.\n\nРазделение набора данных\nПредставим, что у нас есть полный построчный список случаев linelist в виде датафрейма, и теперь мы хотим создать отдельный построчный список для каждой больницы и экспортировать его как отдельный CSV файл. Ниже мы выполним следующие шаги:\nИспользуем group_split() (из dplyr), чтобы разделить датафрейм linelist по уникальным значениям в столбце hospital. На выходе мы получим список, содержащий по одному датафрейму на подмножество больниц.\n\nlinelist_split &lt;- linelist %&gt;% \n     group_split(hospital)\n\nМы можем выполнить View(linelist_split) и увидеть, что в этом списке есть 6 датафреймов (таблицы”tibble”), каждая из которых представляет случаи из одной больницы.\n\n\n\n\n\n\n\n\n\nОднако обратите внимание, что датафреймы в списке по умолчанию не имеют имен! Мы хотим, чтобы у каждого было имя, а затем использовать это имя при сохранении CSV файла.\nОдним из подходов к извлечению имен будет использовать pull() (из dplyr), чтобы извлечь столбец hospital для каждого датафрейма в списке. Затем, чтобы перестраховаться, мы конвертируем значения в текстовые и затем используем unique(), чтобы получить имя для этого конкретного датафрейма. Все эти шаги применяются к каждому датафрейму с помощью map().\n\nnames(linelist_split) &lt;- linelist_split %&gt;%   # присваиваем именам указанных датафреймов \n     # извлекаем имена, выполнив нижеследующее для каждого датафрейма: \n     map(.f = ~pull(.x, hospital)) %&gt;%        # берем столбец hospital\n     map(.f = ~as.character(.x)) %&gt;%          # конвертируем на всякий случай в текстовый\n     map(.f = ~unique(.x))                    # берем уникальное имя больницы\n\nТеперь мы можем увидеть, что у каждого элемента списка есть имя. Эти имена мы можем увидеть с помощью names(linelist_split).\n\n\n\n\n\n\n\n\n\n\nnames(linelist_split)\n\n[1] \"Central Hospital\"                    \n[2] \"Military Hospital\"                   \n[3] \"Missing\"                             \n[4] \"Other\"                               \n[5] \"Port Hospital\"                       \n[6] \"St. Mark's Maternity Hospital (SMMH)\"\n\n\n\nБолее одного столбца group_split()\nЕсли вы хотите разделить построчный список более чем по одному столбцу группировки, например, создать подмножество из построчного списка на пересечении больницы И пола, вам нужен другой подход к именованию элементов списка. Это требует сбора уникальных “ключей групп”, используя group_keys() из dplyr - они выдаются как датафрейм. Затем вы можете комбинировать групповые ключи в значения с помощью unite(), как показано ниже, и присвоить эти составные имена к linelist_split.\n\n# разделяем построчный список по уникальным комбинациям больницы-пола\nlinelist_split &lt;- linelist %&gt;% \n     group_split(hospital, gender)\n\n# извлекаем group_keys() в виде датафрейма\ngroupings &lt;- linelist %&gt;% \n     group_by(hospital, gender) %&gt;%       \n     group_keys()\n\ngroupings      # показываем уникальные группы \n\n# A tibble: 18 × 2\n   hospital                             gender\n   &lt;chr&gt;                                &lt;chr&gt; \n 1 Central Hospital                     f     \n 2 Central Hospital                     m     \n 3 Central Hospital                     &lt;NA&gt;  \n 4 Military Hospital                    f     \n 5 Military Hospital                    m     \n 6 Military Hospital                    &lt;NA&gt;  \n 7 Missing                              f     \n 8 Missing                              m     \n 9 Missing                              &lt;NA&gt;  \n10 Other                                f     \n11 Other                                m     \n12 Other                                &lt;NA&gt;  \n13 Port Hospital                        f     \n14 Port Hospital                        m     \n15 Port Hospital                        &lt;NA&gt;  \n16 St. Mark's Maternity Hospital (SMMH) f     \n17 St. Mark's Maternity Hospital (SMMH) m     \n18 St. Mark's Maternity Hospital (SMMH) &lt;NA&gt;  \n\n\nТеперь мы объединяем эти группировки, разделенные дефисами, и присваиваем их как имена элементов списка в linelist_split. Здесь потребуются несколько дополнительных строк кода, так как мы меняем NA на “Missing”, используем unite() из dplyr для объединения значений столбца (разделенных дефисами), а затем конвертируем в неименованный вектор, чтобы он мог быть использован в качестве имен linelist_split.\n\n# Комбинируем в одно значение имени \nnames(linelist_split) &lt;- groupings %&gt;% \n     mutate(across(everything(), replace_na, \"Missing\")) %&gt;%  # меняем NA на \"Missing\" во всех столбцах\n     unite(\"combined\", sep = \"-\") %&gt;%                         # рбъединяем все значения столбца в одно\n     setNames(NULL) %&gt;% \n     as_vector() %&gt;% \n     as.list()\n\n\n\n\nЭкспорт в виде листов Excel\nЧтобы экспортировать построчные списки больниц в виде рабочей книги Excel с одним построчным списком на лист, мы можем просто указать именованный список linelist_split в функции write_xlsx() из пакета writexl. Это позволит сохранить одну рабочую книгу Excel с несколькими листами. Имена элементов списка автоматически будут применены к именам листов.\n\nlinelist_split %&gt;% \n     writexl::write_xlsx(path = here(\"data\", \"hospital_linelists.xlsx\"))\n\nТеперь вы можете открыть Excel файл и увидеть, что у каждой больницы есть свой лист.\n\n\n\n\n\n\n\n\n\n\n\nЭкспорт в виде CSV файлов\nЭто чуть более сложная команда, но вы можете также экспортировать каждый построчный список по конкретной больнице в виде отдельного CSV файла с названием файла, специфичным для этой больницы.\nОпять же, мы используем map(): мы берем вектор имен элементов списка (показан выше) и применяем map(), чтобы провести по ним итерации, применяя export() (из пакета rio, см. страницу [Импорт и экспорт]) к датафрейму в списке linelist_split, у которого такое имя. Мы также используем имя для создания уникального имени файла. Вот как это работает:\n\nМы начинаем с вектора текстовых имен, подставляем в map() как .x\n\nФункцией .f является export(), которая требует датафрейма и пути к файлу, куда его записать\n\nВходные данные .x (имя больницы) используется внутри .f для извлечения/индекса этого конкретного элемента из списка linelist_split. Это приводит к тому, что только один датафрейм за раз указывается для export().\n\nНапример, когда map() проводит итерацию для “Military Hospital”, тогда linelist_split[[.x]] на самом деле является linelist_split[[\"Military Hospital\"]], выдавая таким образом второй элемент linelist_split - а именно, все случаи из больницы Military Hospital.\n\nПуть к файлу, указанный для export() является динамичным с помощью использования str_glue() (см. страницу [Текст и последовательности]):\n\nhere() используется, чтобы получить базовый путь к файлу и указать папку “data” (обратите внимание на одинарные кавычки, чтобы не прерывать двойные кавычки str_glue())\n\n\nЗатем слэш /, а затем снова .x, что напечатает текущее имя больницы, чтобы сделать файл идентифицируемым\n\nНаконец, расширение “.csv”, которое export() использует для создания CSV файла\n\n\nnames(linelist_split) %&gt;%\n     map(.f = ~export(linelist_split[[.x]], file = str_glue(\"{here('data')}/{.x}.csv\")))\n\nNow you can see that each file is saved in the “data” folder of the R Project “Epi_R_handbook”!\n\n\n\n\n\n\n\n\n\n\n\n\nПользовательские функции\nВы можете захотеть создать собственную функцию, которую зададите в map().\nПредставим, что вы хотите создать эпидемические кривые для случаев по каждой больнице. Чтобы это сделать, используя purrr, наша функция .f может быть ggplot() и расширения с помощью +, как обычно. В качестве выходных данных map() мы всегда получаем список, графики сохраняются в списке (list). Поскольку это графики, их можно извлечь и построить с помощью функции ggarrange() из пакета ggpubr (документация).\n\n# загрузите пакет для построения элементов из списка\npacman::p_load(ggpubr)\n\n# постройте по вектору 6 имен больниц (созданных ранее)\n# используйте указанную функцию ggplot\n# выходным результатом будет список с 6 графиками ggplot\n\nhospital_names &lt;- unique(linelist$hospital)\n\nmy_plots &lt;- map(\n  .x = hospital_names,\n  .f = ~ggplot(data = linelist %&gt;% filter(hospital == .x)) +\n                geom_histogram(aes(x = date_onset)) +\n                labs(title = .x)\n)\n\n# напечатайте графики ggplot (они хранятся в списке)\nggarrange(plotlist = my_plots, ncol = 2, nrow = 3)\n\n\n\n\n\n\n\n\nЕсли этот код map() выглядит слишком хаотично, вы можете получить тот же результат, сохранив вашу конкретную команду ggplot() как пользовательскую функцию, например, мы можем ее назвать make_epicurve()). Эта функция затем используется внутри map(). .x будет итеративно замещаться именем больницы и будет использован как hosp_name в функции make_epicurve(). См. страницу [Написание функций].\n\n# Создаем функцию\nmake_epicurve &lt;- function(hosp_name){\n  \n  ggplot(data = linelist %&gt;% filter(hospital == hosp_name)) +\n    geom_histogram(aes(x = date_onset)) +\n    theme_classic()+\n    labs(title = hosp_name)\n  \n}\n\n\n# сопоставляем\nmy_plots &lt;- map(hospital_names, ~make_epicurve(hosp_name = .x))\n\n# печатаем графики ggplot (они хранятся в списке)\nggarrange(plotlist = my_plots, ncol = 2, nrow = 3)\n\n\n\nПрименение функций к нескольким столбцам\nЕще один частый пример - применить функцию к нескольким столбцам. Ниже мы применяем функцию t.test() с помощью map() к числовым столбцам в датафрейме linelist, сравнивая числовые значения по полу.\nВспмоните из страницы [Простые статистические тесты], что t.test() может принять входные данные в формате формулы, такие как t.test(числовой столбец ~ двоичный столбец). В этом примере мы делаем нижеследующее:\n\nИнтересующие числовые столбцы выбираются из linelist - они становятся входными данными .x для map()\n\nФункция t.test() указывается как функция .f, которая применяется к каждому числовому столбцу\n\nВнутри скобок t.test():\n\nпервая ~ стоит перед .f, по которой map() будет проводить итерацию .x\n\n.x отражает текущий столбец, который подается в функцию t.test()\n\nвторая ~ является частью уравнения t-test, описанного выше\n\nфункция t.test() ожидает двоичный столбец с правой стороны уравнения. Мы задаем вектор linelist$gender независимо и статично (обратите внимание, что он не включен в select()).\n\n\nmap() выдает список, поэтому выходными результатами является список результатов t-теста - по одному элементу списка для каждого проанализированного числового столбца.\n\n# Результаты сохраняются как список\nt.test_results &lt;- linelist %&gt;% \n  select(age, wt_kg, ht_cm, ct_blood, temp) %&gt;%  # сохраняем только некоторые числовые столбцы для map across\n  map(.f = ~t.test(.x ~ linelist$gender))        # функция t.test, с уравнением ЧИСЛОВОЕ ~ КАТЕГОРИАЛЬНОЕ\n\nВот как выглядит список t.test_results при открытии (просмотре) в RStudio. Мы выделили те части, которые важны для примеров на этой странице.\n\nВы можете увидеть сверху, что весь список называется t.test_results и содержит пять элементов. Эти пять элементов называются age, wt_km, ht_cm, ct_blood, temp по каждой переменной, которая использовалась в t-тесте с gender (пол) из построчного списка linelist.\n\nКаждый из этих пяти элементов сам по себе является списком с такими элементами внутри, как p.value и conf.int. Некоторые из этих элементов, такие как p.value являются отдельными числами, а некоторы - например, estimate, состоят из двух или более элементов (mean in group f(среднее в группе f) и mean in group m (среднее в группе m)).\n\n\n\n\n\n\n\n\n\n\nПримечание: Помните, что если вы хотите применить функцию только к определенным столбцам в датафрейме, вы можете просто использовать mutate() и across(), как объяснялось на странице [Вычистка данных и ключевые функции]. Ниже приведен пример применения as.character() только к столбцу “age” (возраст). Обратите внимание на размещение скобок и запятых.\n\n# конвертируем столбцы с именем столбца, содержащим \"age\" в текстовый класс\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = contains(\"age\"), .fns = as.character))  \n\n\n\nИзвлечение из списков\nТак как map() выдает выходной результат в классе список, мы обсудим, как извлекать данные из списков, используя соответствующие функции purrr. Чтобы это продемонстрировать, мы будем использовать список t.test_results из предыдущего раздела. Это список из 5 списков - каждый из 5 списков содержит результаты t-теста между столбцом из датафрейма linelist и его двоичным столбцом gender. См. изображение в разделе выше, где показана структура списка визуально.\n\nИмена элементов\nЧтобы извлечь имена самих элементов, просто используйте names() из базового R. В таком случае мы используем names() для t.test_results, чтобы выдать имена каждого под-списка, которые являются именами 5 переменных, по которым проводились t-тесты.\n\nnames(t.test_results)\n\n[1] \"age\"      \"wt_kg\"    \"ht_cm\"    \"ct_blood\" \"temp\"    \n\n\n\n\nЭлементы по имени или позиции\nЧтобы извлечь элементы списка по именам или по позиции, вы можете использовать квадратные скобки [[ ]], как описано на странице [Основы R]. Ниже мы используем двойные квадратные скобки, чтобы индексировать список t.tests_results и отобразить первый элемент, который является результатом t-теста по age (возраст).\n\nt.test_results[[1]] # первый элемент по позиции\n\n\n    Welch Two Sample t-test\n\ndata:  .x by linelist$gender\nt = -21.3, df = 4902.9, p-value &lt; 2.2e-16\nalternative hypothesis: true difference in means between group f and group m is not equal to 0\n95 percent confidence interval:\n -7.544409 -6.272675\nsample estimates:\nmean in group f mean in group m \n       12.66085        19.56939 \n\nt.test_results[[1]][\"p.value\"] # выдает элемент с именем \"p.value\" из первого элемента  \n\n$p.value\n[1] 2.350374e-96\n\n\nОднако ниже мы продемонстрируем использование простых и гибких функций purrr map() и pluck() для достижения таких же результатов.\n\n\npluck()\npluck() извлекает элемент по имени или позиции. Например - чтобы извлечь результаты t-теста для возраста, вы можете использовать pluck() следующим образом:\n\nt.test_results %&gt;% \n  pluck(\"age\")        # альтернативно, используем pluck(1)\n\n\n    Welch Two Sample t-test\n\ndata:  .x by linelist$gender\nt = -21.3, df = 4902.9, p-value &lt; 2.2e-16\nalternative hypothesis: true difference in means between group f and group m is not equal to 0\n95 percent confidence interval:\n -7.544409 -6.272675\nsample estimates:\nmean in group f mean in group m \n       12.66085        19.56939 \n\n\nИндексируйте более глубокие уровни, указывая последующие уровни запятыми. Приведенный ниже код извлекает элемент под названием “p.value” из списка age внутри списка t.test_results. Вы можете также использовать числа вместо текстовых имен.\n\nt.test_results %&gt;% \n  pluck(\"age\", \"p.value\")\n\n[1] 2.350374e-96\n\n\nВы можете извлекать такие внутренние элементы из всех элементов первого уровня, используя map(), чтобы выполнить функцию pluck() по каждому элементу первого уровня. Например, код ниже извлекает элементы “p.value” из всех списков внутри t.test_results. Список результатов т-теста является .x, по которому проводится итерация, pluck() является функцией .f, которая подлежит итерации, а значение “p-value” задается в функцию.\n\nt.test_results %&gt;%\n  map(pluck, \"p.value\")   # выдать каждое p-значение\n\n$age\n[1] 2.350374e-96\n\n$wt_kg\n[1] 2.664367e-182\n\n$ht_cm\n[1] 3.515713e-144\n\n$ct_blood\n[1] 0.4473498\n\n$temp\n[1] 0.5735923\n\n\nВ качестве еще одной альтернативы map() предлагает сокращение, где вы можете записать имя элемента в кавычках, и она его извлечет. Если вы используете map(), выходным результатом будет список, а если вы используете map_chr() - это будет именованный текстовый вектор, а если вы используете map_dbl() - то именованный числовой вектор.\n\nt.test_results %&gt;% \n  map_dbl(\"p.value\")   # выдать p-значения как именованный числовой вектор\n\n          age         wt_kg         ht_cm      ct_blood          temp \n 2.350374e-96 2.664367e-182 3.515713e-144  4.473498e-01  5.735923e-01 \n\n\nБолее детально о pluck() вы можете прочитать в purrr документации. У нее есть родственная функция chuck(), которая выдаст ошибку вместо NULL, если элемент не существует.\n\n\n\nКонвертация списка в датафрейм\nЭто сложная тема - см. раздел Ресурсы с более полными самоучителями. Тем не менее, мы продемонстрируем конвертацию списка результатов t-теста в датафрейм. Мы создадим датафрейм со столбцами для переменной, ее p-значения и со средними значениями из двух групп (мужчины и женщины).\nВот некоторые из новых подходов и функций, которые будут использованы:\n\nФнукция tibble() будет использована для создания таблицы tibble (как датафрейм)\n\nМы заключаем функцию tibble() в фигурные скобки { }, чтобы предотвратить сохранение всех t.test_results в качестве первого столбца tibble\n\n\nВнутри tibble() создается каждый столбец, похожим образом как в синтаксисе mutate():\n\n. представляет t.test_results\nЧтобы создать столбец с именами переменных t-теста (имена каждого элемента списка), мы используем names(), как описано выше\n\nЧтобы создать столбец с p-значениями, мы используем map_dbl() как описано выше, чтобы извлечь элементы p.value и конвертировать их в числовой вектор\n\n\n\nt.test_results %&gt;% {\n  tibble(\n    variables = names(.),\n    p         = map_dbl(., \"p.value\"))\n  }\n\n# A tibble: 5 × 2\n  variables         p\n  &lt;chr&gt;         &lt;dbl&gt;\n1 age       2.35e- 96\n2 wt_kg     2.66e-182\n3 ht_cm     3.52e-144\n4 ct_blood  4.47e-  1\n5 temp      5.74e-  1\n\n\nНо теперь давайте добавим столбцы, содержащие средние значения для каждой группы (мужчины и женщины).\nНам нужно извлечь элемент estimate, но он на самом деле содержит два элемента (mean in group f (среднее значение в группе f) и mean in group m(среднее значение в группе m)). Таким образом, его невозможно упростить в вектор с помощью map_chr() или map_dbl(). Вместо этого, мы используем map(), которая при использовании внутри tibble() создаст столбец класса список (list) внутри tibble! Да, это возможно!\n\nt.test_results %&gt;% \n  {tibble(\n    variables = names(.),\n    p = map_dbl(., \"p.value\"),\n    means = map(., \"estimate\"))}\n\n# A tibble: 5 × 3\n  variables         p means       \n  &lt;chr&gt;         &lt;dbl&gt; &lt;named list&gt;\n1 age       2.35e- 96 &lt;dbl [2]&gt;   \n2 wt_kg     2.66e-182 &lt;dbl [2]&gt;   \n3 ht_cm     3.52e-144 &lt;dbl [2]&gt;   \n4 ct_blood  4.47e-  1 &lt;dbl [2]&gt;   \n5 temp      5.74e-  1 &lt;dbl [2]&gt;   \n\n\nКак только у вас будет этот столбец в классеп список, есть несколько функций tidyr (часть tidyverse), которые помогут вам разложить эти столбцы “многоуровневого списка”. Более подробно прочитайте об этом тут, либо введя vignette(\"rectangle\"). Вкратце:\n\nunnest_wider() - дает каждому элементу столбца-списка свой собственный столбец\n\nunnest_longer() - дает каждому элементу столбца-списка свою собственную строку\nhoist() - действует как unnest_wider(), но вы уточняете, какие элементы разложить\n\nНиже мы задаем tibble в unnest_wider(), уточняя столбец из tibble means (который является многоуровневым списком). Результатом будет то, что вместо means мы получаем два новых столбца, каждый из которых отображает два элемента, которые раньше находились в каждой ячейке means.\n\nt.test_results %&gt;% \n  {tibble(\n    variables = names(.),\n    p = map_dbl(., \"p.value\"),\n    means = map(., \"estimate\")\n    )} %&gt;% \n  unnest_wider(means)\n\n# A tibble: 5 × 4\n  variables         p `mean in group f` `mean in group m`\n  &lt;chr&gt;         &lt;dbl&gt;             &lt;dbl&gt;             &lt;dbl&gt;\n1 age       2.35e- 96              12.7              19.6\n2 wt_kg     2.66e-182              45.8              59.6\n3 ht_cm     3.52e-144             109.              142. \n4 ct_blood  4.47e-  1              21.2              21.2\n5 temp      5.74e-  1              38.6              38.6\n\n\n\n\nУдаление, сохранение и сжатие списков\nПоскольку работа с purrr так часто предполагает списки, мы кратко рассмотрим некоторые функции purrr для модификации списков. См. раздел Ресурсы, где указаны более подробные самоучители по функциям purrr.\n\nlist_modify() имеет множество применений, в том числе для удаления элемента списка\n\nkeep() сохраняет элементы, указанные в .p =, либо там, где функция, указанная в .p = оценена как TRUE (ИСТИНА)\n\ndiscard() удаляет элементы, указанные в .p, либо там, где функция, указанная в .p = оценена как TRUE (ИСТИНА)\n\ncompact() удаляет все пустые элементы\n\nВот некоторые примеры использования списка combined, созданного в разделе выше использование map() для импорта и объединения нескольких файлов (он содержит 6 датафреймов построчного списка случаев):\nЭлементы могут быть удалены по имени с помощью list_modify() и установки имени (name) равного NULL.\n\ncombined %&gt;% \n  list_modify(\"Central Hospital\" = NULL)   # удаляем элемент списка по имени\n\nВы можете также удалить элементы по критериям, задасв “предикативное” уравнение в .p = (уравнение, которое оценивает как TRUE (ИСТИНА) или FALSE(ЛОЖЬ)). Разместите тильду ~ до функции и используйте .x, чтобы отобразить элемент списка. При использовании keep() элементы списка, оцененые как TRUE (ИСТИНА) будут сохранены. И наборот, при использовании discard() элементы списка, оцененные как TRUE (ИСТИНА) будут удалены.\n\n# сохраняем только элементы списка, где более 500 строк\ncombined %&gt;% \n  keep(.p = ~nrow(.x) &gt; 500)  \n\nВ примере ниже, элементы списка удаляются, если они не относятся к классу датафрейма.\n\n# удаляем все элементы списка, которые не являются датафреймами\ncombined %&gt;% \n  discard(.p = ~class(.x) != \"data.frame\")\n\nВаша предикативная функция также может ссылаться на элементы/столбцы внутри каждого элемента списка. Например, ниже удаляются элементы списка, где среднее значение столбца ct_blood составляет более 25.\n\n# сохраняем только те элементы списка, где среднее значение столбца ct_blood выше 25\ncombined %&gt;% \n  discard(.p = ~mean(.x$ct_blood) &gt; 25)  \n\nЭта команда удалит все пустые элементы списка:\n\n# Удаляем все пустые элементы списка\ncombined %&gt;% \n  compact()\n\n\n\npmap()\nРАЗДЕЛ НАХОДИТСЯ В РАЗРАБОТКЕ",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Итерации, циклы и списки</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.ru.html#функции-apply",
    "href": "new_pages/iteration.ru.html#функции-apply",
    "title": "16  Итерации, циклы и списки",
    "section": "16.4 Функции Apply",
    "text": "16.4 Функции Apply\nСемейство фукнций “apply” является альтернативой purrr для итеративных операций из базового R. Более подробно можно об этом почитать тут.",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Итерации, циклы и списки</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.ru.html#ресурсы",
    "href": "new_pages/iteration.ru.html#ресурсы",
    "title": "16  Итерации, циклы и списки",
    "section": "16.5 Ресурсы",
    "text": "16.5 Ресурсы\nциклы for с Data Carpentry\nR для науки о данных страница по итерациям\nВиньетка по написанию/прочтению Excel файлов\npurrr самоучитель от jennybc\nЕще один purrr самоучитель от Rebecca Barter\npurrr самоучитель по map, pmap, и imap\nШпаргалка по purrr\nСоветы и хитрости в purrr\nсохранение и удаление",
    "crumbs": [
      "Управление данными",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Итерации, циклы и списки</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.ru.html",
    "href": "new_pages/tables_descriptive.ru.html",
    "title": "17  Описательные таблицы",
    "section": "",
    "text": "17.1 Подготовка",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Описательные таблицы</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.ru.html#подготовка",
    "href": "new_pages/tables_descriptive.ru.html#подготовка",
    "title": "17  Описательные таблицы",
    "section": "",
    "text": "Загрузка пакетов\nЭтот фрагмент кода показывает загрузку пакетов для анализа. В этом руководстве мы подчеркиваем использование p_load() из pacman, которая устанавливает пакет, если необходимо, и загружает его для использования. Вы можете также загрузить установленные пакеты с помощью library() из базового R. См. страницу Основы R для получения более подробной информации о пакетах R.\n\npacman::p_load(\n  rio,          # импорт файлов\n  here,         # путь к файлу\n  skimr,        # получение обзора данных\n  tidyverse,    # управление данными + графика ggplot2 \n  gtsummary,    # сводная статистика и тесты\n  rstatix,      # сводная статистика и статистические тесты\n  janitor,      # добавление итогов и процентов к таблицам\n  scales,       # простая конвертация долей в проценты  \n  flextable     # конвертация таблиц в красивые рисунки\n  )\n\n\n\nИмпорт данных\nМы импортируем набор данных о случаях имитированной эпидемии Эболы. Если вы хотите выполнять действия параллельно, кликните, чтобы скачать “чистый” построчный список (как .rds файл). Импортируйте ваши данные с помощью функции import() из пакета rio (она работает с разными файлами, такими как .xlsx, .rds, .csv - см. детали на странице Импорт и экспорт).\n\n# импорт построчного списка\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nПервые 50 строк построчного списка отображены ниже.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Описательные таблицы</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.ru.html#просмотр-данных",
    "href": "new_pages/tables_descriptive.ru.html#просмотр-данных",
    "title": "17  Описательные таблицы",
    "section": "17.2 Просмотр данных",
    "text": "17.2 Просмотр данных\n\nпакет skimr\nС помощью пакета skimr вы можете получить детальную информацию и эстетически приятный обзор по каждой переменной в вашем наборе данных. Более подробно о skimr можно прочитать на странице github.\nНиже функция skim() применяется ко всему датафрейму linelist. Создается обзор датафрейма и сводная информация по каждому столбцу (по классам).\n\n## получаем информацию о каждой переменной в наборе данных \nskim(linelist)\n\n\n\n\nData summary\n\n\nName\nlinelist\n\n\nNumber of rows\n5888\n\n\nNumber of columns\n30\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n13\n\n\nDate\n4\n\n\nfactor\n2\n\n\nnumeric\n11\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\ncase_id\n0\n1.00\n6\n6\n0\n5888\n0\n\n\noutcome\n1323\n0.78\n5\n7\n0\n2\n0\n\n\ngender\n278\n0.95\n1\n1\n0\n2\n0\n\n\nage_unit\n0\n1.00\n5\n6\n0\n2\n0\n\n\nhospital\n0\n1.00\n5\n36\n0\n6\n0\n\n\ninfector\n2088\n0.65\n6\n6\n0\n2697\n0\n\n\nsource\n2088\n0.65\n5\n7\n0\n2\n0\n\n\nfever\n249\n0.96\n2\n3\n0\n2\n0\n\n\nchills\n249\n0.96\n2\n3\n0\n2\n0\n\n\ncough\n249\n0.96\n2\n3\n0\n2\n0\n\n\naches\n249\n0.96\n2\n3\n0\n2\n0\n\n\nvomit\n249\n0.96\n2\n3\n0\n2\n0\n\n\ntime_admission\n765\n0.87\n5\n5\n0\n1072\n0\n\n\n\nVariable type: Date\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nmedian\nn_unique\n\n\n\n\ndate_infection\n2087\n0.65\n2014-03-19\n2015-04-27\n2014-10-11\n359\n\n\ndate_onset\n256\n0.96\n2014-04-07\n2015-04-30\n2014-10-23\n367\n\n\ndate_hospitalisation\n0\n1.00\n2014-04-17\n2015-04-30\n2014-10-23\n363\n\n\ndate_outcome\n936\n0.84\n2014-04-19\n2015-06-04\n2014-11-01\n371\n\n\n\nVariable type: factor\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nordered\nn_unique\ntop_counts\n\n\n\n\nage_cat\n86\n0.99\nFALSE\n8\n0-4: 1095, 5-9: 1095, 20-: 1073, 10-: 941\n\n\nage_cat5\n86\n0.99\nFALSE\n17\n0-4: 1095, 5-9: 1095, 10-: 941, 15-: 743\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\n\n\n\n\ngeneration\n0\n1.00\n16.56\n5.79\n0.00\n13.00\n16.00\n20.00\n37.00\n\n\nage\n86\n0.99\n16.07\n12.62\n0.00\n6.00\n13.00\n23.00\n84.00\n\n\nage_years\n86\n0.99\n16.02\n12.64\n0.00\n6.00\n13.00\n23.00\n84.00\n\n\nlon\n0\n1.00\n-13.23\n0.02\n-13.27\n-13.25\n-13.23\n-13.22\n-13.21\n\n\nlat\n0\n1.00\n8.47\n0.01\n8.45\n8.46\n8.47\n8.48\n8.49\n\n\nwt_kg\n0\n1.00\n52.64\n18.58\n-11.00\n41.00\n54.00\n66.00\n111.00\n\n\nht_cm\n0\n1.00\n124.96\n49.52\n4.00\n91.00\n129.00\n159.00\n295.00\n\n\nct_blood\n0\n1.00\n21.21\n1.69\n16.00\n20.00\n22.00\n22.00\n26.00\n\n\ntemp\n149\n0.97\n38.56\n0.98\n35.20\n38.20\n38.80\n39.20\n40.80\n\n\nbmi\n0\n1.00\n46.89\n55.39\n-1200.00\n24.56\n32.12\n50.01\n1250.00\n\n\ndays_onset_hosp\n256\n0.96\n2.06\n2.26\n0.00\n1.00\n1.00\n3.00\n22.00\n\n\n\n\n\nВы можете также использовать функцию summary() из базового R, чтобы получить информацию о всем наборе данных, но такие выходные данные может быть сложнее прочитать, чем при использовании skimr. Поэтому выходной результат не приводится ниже в целях экономии пространства на странице.\n\n## получаем информацию о каждом столбце в наборе данных \nsummary(linelist)\n\n\n\nСводная статистика\nВы можете использовать функции базового R для получения сводной статистики по числовому столбцу. Вы можете получить наиболее важную сводную статистику для числового столбца, используя summary(), как показано ниже. Обратите внимание, что необходимо уточнять набор данных, как это сделано ниже.\n\nsummary(linelist$age_years)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00    6.00   13.00   16.02   23.00   84.00      86 \n\n\nВы можете получить доступ и сохранить конкретную часть с помощью индексных квадратных скобок [ ]:\n\nsummary(linelist$age_years)[[2]]            # выдать только 2-й элемент\n\n[1] 6\n\n# эквивалент, альтернатива указанному выше по имени элемента\n# summary(linelist$age_years)[[\"1st Qu.\"]]  \n\nВы можете получить отдельные статистические показатели с помощью базовых функций R, таких как max() (максимум), min() (минимум), median() (медиана), mean() (среднее значение), quantile() (квантиль), sd() (стандартное отклонение) и range() (диапазон). См. полный список на странице Основы R.\nВНИМАНИЕ: Если ваши данные содержат отсутствующие значения, R хочет, чтобы вы это знали, поэтому выдаст NA, если только вы не укажете в указанных выше математических фукнциях, что вы хотите, чтобы R игнорировал отсутствующие значения, с помощью аргумента na.rm = TRUE.\nВы можете использовать функцию get_summary_stats() из rstatix, чтобы получить сводную статистику в формате датафрейма. Это может быть полезным для проведения последующих операций или составления графика с числами. См. страницу Простые статистические тесты для получения дополнительной информации о пакете rstatix и его функциях.\n\nlinelist %&gt;% \n  get_summary_stats(\n    age, wt_kg, ht_cm, ct_blood, temp,  # столбцы, для которых нужен расчет\n    type = \"common\")                    # получаемая сводная статистика\n\n# A tibble: 5 × 10\n  variable     n   min   max median   iqr  mean     sd    se    ci\n  &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 age       5802   0    84     13      17  16.1 12.6   0.166 0.325\n2 wt_kg     5888 -11   111     54      25  52.6 18.6   0.242 0.475\n3 ht_cm     5888   4   295    129      68 125.  49.5   0.645 1.26 \n4 ct_blood  5888  16    26     22       2  21.2  1.69  0.022 0.043\n5 temp      5739  35.2  40.8   38.8     1  38.6  0.977 0.013 0.025",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Описательные таблицы</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.ru.html#tbl_janitor",
    "href": "new_pages/tables_descriptive.ru.html#tbl_janitor",
    "title": "17  Описательные таблицы",
    "section": "17.3 пакет janitor",
    "text": "17.3 пакет janitor\nПакет janitor предлагает функцию tabyl() для создания табуляций и кросс-табуляций, которые могут быть “оформлены” или модифицированы с помощью функций-помощников, чтобы отображать проценты, доли, подсчет количества и т.п.\nНиже мы передаем датафрейм linelist в функции janitor и печатаем результат. Если нужно, вы можете также сохранить получившиеся в результате таблицы с помощью оператора присваивания &lt;-.\n\nПростая таблица tabyl\nИспользование tabyl() по умолчанию применительно к конретному столбцу создает уникальные значения, подсчеты и постолбцовые “проценты” (на самом деле доли). Доли могут иметь много десятичных знаков. Вы можете откорректировать количество знаков после запятой с помощью adorn_rounding(), как описано ниже.\n\nlinelist %&gt;% tabyl(age_cat)\n\n age_cat    n     percent valid_percent\n     0-4 1095 0.185971467   0.188728025\n     5-9 1095 0.185971467   0.188728025\n   10-14  941 0.159816576   0.162185453\n   15-19  743 0.126188859   0.128059290\n   20-29 1073 0.182235054   0.184936229\n   30-49  754 0.128057065   0.129955188\n   50-69   95 0.016134511   0.016373664\n     70+    6 0.001019022   0.001034126\n    &lt;NA&gt;   86 0.014605978            NA\n\n\nКак вы видите выше, если есть отсутствующие значения, они отображаются в строке, подписанной как &lt;NA&gt;. Вы можете их заблокировать с помощью show_na = FALSE. Если нет отсутствующих значений, эта строка не будет появляться. Если есть отсутствующие значения, все доли будут приведены как сырые (знаменатель включает количество NA) и “валидные” (знаменатель исключает количество NA).\nЕсли столбец относится к классу Фактор и только некоторые уровни присутствуют в ваших данных, все уровни все равно будут отображены в таблице. Вы можете заблокировать этот параметр, уточнив show_missing_levels = FALSE. Более детально читайте об этом на странице Факторы.\n\n\nКросс-табуляция\nПодсчет в кросс-табуляции достигается путем добавления одного или более дополнительных столбцов внутри tabyl(). Обратите внимание, чтор теперь будет выдан только подсчет, а проценты можно добавить с помощью дополнительных шагов, указанных ниже.\n\nlinelist %&gt;% tabyl(age_cat, gender)\n\n age_cat   f   m NA_\n     0-4 640 416  39\n     5-9 641 412  42\n   10-14 518 383  40\n   15-19 359 364  20\n   20-29 468 575  30\n   30-49 179 557  18\n   50-69   2  91   2\n     70+   0   5   1\n    &lt;NA&gt;   0   0  86\n\n\n\n\n“Оформление” таблицы tabyl\nИспользуйте функции “adorn” (“оформление”) из janitor, чтобы добавить итого или конвертировать в доли, проценты, либо как-то иначе откорректировать отображение. Часто необходимо составить канал для таблицы tabyl и применить к ней несколько из этих функций.\n\n\n\n\n\n\n\nФункция\nРезультат\n\n\n\n\nadorn_totals()\nДобавляет итого (where = “row”, “col”, or “both”). Установите name = для “Total” (Итого).\n\n\nadorn_percentages()\nКонвертирует количество в доли, с знаменателем denominator = “row” (строка), “col” (столбец), или “all” (все)\n\n\nadorn_pct_formatting()\nКонвертирует доли в проценты. Укажите digits =. Удалите символ “%” с помощью affix_sign = FALSE.\n\n\nadorn_rounding()\nЧтобы округлить пропорции до нужного количества десятичных знаков digits =. Чтобы округлить проценты, используйте adorn_pct_formatting() с digits =.\n\n\nadorn_ns()\nДобавить подсчет абсолютного количества в таблицу долей или процентов. Укажите position = “rear”, чтобы показать абсолютное количество в скобках, либо “front”, чтобы проценты были в скобках.\n\n\nadorn_title()\nДобавить последовательность с помощью аргументов row_name =(имя строки) и/или col_name = (имя столбца)\n\n\n\nОбращайте внимание на порядок применения этих функций. Ниже приведены некоторые примеры.\nПростая одновходовая таблица с процентами вместо долей по умолчанию.\n\nlinelist %&gt;%               # построчный список случаев\n  tabyl(age_cat) %&gt;%       # табуляция абсолютного количества и долей по возрастной категории\n  adorn_pct_formatting()   # конвертация долей в проценты\n\n age_cat    n percent valid_percent\n     0-4 1095   18.6%         18.9%\n     5-9 1095   18.6%         18.9%\n   10-14  941   16.0%         16.2%\n   15-19  743   12.6%         12.8%\n   20-29 1073   18.2%         18.5%\n   30-49  754   12.8%         13.0%\n   50-69   95    1.6%          1.6%\n     70+    6    0.1%          0.1%\n    &lt;NA&gt;   86    1.5%             -\n\n\nКросс-табуляция со строкой итого и процентами по строке\n\nlinelist %&gt;%                                  \n  tabyl(age_cat, gender) %&gt;%                  # подсчет по возрасту и полу\n  adorn_totals(where = \"row\") %&gt;%             # добавляем строку итого\n  adorn_percentages(denominator = \"row\") %&gt;%  # конвертируем количество в доли\n  adorn_pct_formatting(digits = 1)            # конвертируем доли в проценты\n\n age_cat     f     m    NA_\n     0-4 58.4% 38.0%   3.6%\n     5-9 58.5% 37.6%   3.8%\n   10-14 55.0% 40.7%   4.3%\n   15-19 48.3% 49.0%   2.7%\n   20-29 43.6% 53.6%   2.8%\n   30-49 23.7% 73.9%   2.4%\n   50-69  2.1% 95.8%   2.1%\n     70+  0.0% 83.3%  16.7%\n    &lt;NA&gt;  0.0%  0.0% 100.0%\n   Total 47.7% 47.6%   4.7%\n\n\nСкорректированная кросс-табуляция, чтобы отобразить и абсолютное количество и проценты.\n\nlinelist %&gt;%                                  # построчный список случаев\n  tabyl(age_cat, gender) %&gt;%                  # кросс-табуляция абсолютного количества\n  adorn_totals(where = \"row\") %&gt;%             # добавляем строку итого\n  adorn_percentages(denominator = \"col\") %&gt;%  # конвертируем в доли\n  adorn_pct_formatting() %&gt;%                  # конвертируем в проценты\n  adorn_ns(position = \"front\") %&gt;%            # отображаем как: \"абсолютное количество (процент)\"\n  adorn_title(                                # корректируем заголовки\n    row_name = \"Age Category\",\n    col_name = \"Gender\")\n\n                      Gender                            \n Age Category              f              m          NA_\n          0-4   640  (22.8%)   416  (14.8%)  39  (14.0%)\n          5-9   641  (22.8%)   412  (14.7%)  42  (15.1%)\n        10-14   518  (18.5%)   383  (13.7%)  40  (14.4%)\n        15-19   359  (12.8%)   364  (13.0%)  20   (7.2%)\n        20-29   468  (16.7%)   575  (20.5%)  30  (10.8%)\n        30-49   179   (6.4%)   557  (19.9%)  18   (6.5%)\n        50-69     2   (0.1%)    91   (3.2%)   2   (0.7%)\n          70+     0   (0.0%)     5   (0.2%)   1   (0.4%)\n         &lt;NA&gt;     0   (0.0%)     0   (0.0%)  86  (30.9%)\n        Total 2,807 (100.0%) 2,803 (100.0%) 278 (100.0%)\n\n\n\n\nПечать таблицы tabyl\nПо умолчанию таблица tabyl будет напечатана в сыром виде на вашей консоли R.\nАльтернативно, вы можете передать таблицу tabyl в flextable или аналогичный пакет, чтобы распечатать “красивое” изображение на панели просмотра RStudio (Viewer), которое можно экспортировать как .png, .jpeg, .html, и т.п. Это обсуждается на странице Таблицы для презентации. Обратите внимание, что при печати таким образом и использовании adorn_titles(), вам нужно задать placement = \"combined\".\n\nlinelist %&gt;%\n  tabyl(age_cat, gender) %&gt;% \n  adorn_totals(where = \"col\") %&gt;% \n  adorn_percentages(denominator = \"col\") %&gt;% \n  adorn_pct_formatting() %&gt;% \n  adorn_ns(position = \"front\") %&gt;% \n  adorn_title(\n    row_name = \"Age Category\",\n    col_name = \"Gender\",\n    placement = \"combined\") %&gt;% # необходимо для печати как картинки\n  flextable::flextable() %&gt;%    # конвертирует в красивую картинку\n  flextable::autofit()          # формат на одну линию на строку \n\nAge Category/GenderfmNA_Total0-4640 (22.8%)416 (14.8%)39 (14.0%)1,095 (18.6%)5-9641 (22.8%)412 (14.7%)42 (15.1%)1,095 (18.6%)10-14518 (18.5%)383 (13.7%)40 (14.4%)941 (16.0%)15-19359 (12.8%)364 (13.0%)20  (7.2%)743 (12.6%)20-29468 (16.7%)575 (20.5%)30 (10.8%)1,073 (18.2%)30-49179  (6.4%)557 (19.9%)18  (6.5%)754 (12.8%)50-692  (0.1%)91  (3.2%)2  (0.7%)95  (1.6%)70+0  (0.0%)5  (0.2%)1  (0.4%)6  (0.1%)0  (0.0%)0  (0.0%)86 (30.9%)86  (1.5%)\n\n\n\n\nПрименение к другим таблицам\nВы можете использовать функции adorn_*() из janitor для других таблиц, например, созданных с помощью summarise() и count() из dplyr, либо table() из базового R. Просто передайте таблицу в соответствующую функцию из janitor. Например:\n\nlinelist %&gt;% \n  count(hospital) %&gt;%   # функция dplyr\n  adorn_totals()        # функция janitor\n\n                             hospital    n\n                     Central Hospital  454\n                    Military Hospital  896\n                              Missing 1469\n                                Other  885\n                        Port Hospital 1762\n St. Mark's Maternity Hospital (SMMH)  422\n                                Total 5888\n\n\n\n\nСохранение таблицы tabyl\nЕсли вы конвертируете таблицу в “красивый” рисунок с помощью такого пакета, как flextable, вы можете ее сохранить с помощью функций из этого пакета - например, save_as_html(), save_as_word(), save_as_ppt() и save_as_image() из flextable (более подробно объясняется на странице Таблицы для презентации). Ниже таблица сохраняется как документ Word, в котором ее можно дополнительно редактировать вручную.\n\nlinelist %&gt;%\n  tabyl(age_cat, gender) %&gt;% \n  adorn_totals(where = \"col\") %&gt;% \n  adorn_percentages(denominator = \"col\") %&gt;% \n  adorn_pct_formatting() %&gt;% \n  adorn_ns(position = \"front\") %&gt;% \n  adorn_title(\n    row_name = \"Age Category\",\n    col_name = \"Gender\",\n    placement = \"combined\") %&gt;% \n  flextable::flextable() %&gt;%                     # конвертируем в изображение\n  flextable::autofit() %&gt;%                       # проверяем, что только одна линия на строку\n  flextable::save_as_docx(path = \"tabyl.docx\")   # сохраняем как документ Word по указанному пути к файлу\n\n\n\n\n\n\n\n\n\n\n\n\nСтатистика\nВы можете применять статистические тесты к таблицам tabyl, например, chisq.test() или fisher.test() из пакета stats, как показано ниже. Обратите внимание, что отсутствующие значения не разрешены, поэтому они исключены из таблицы tabyl с помощью show_na = FALSE.\n\nage_by_outcome &lt;- linelist %&gt;% \n  tabyl(age_cat, outcome, show_na = FALSE) \n\nchisq.test(age_by_outcome)\n\n\n    Pearson's Chi-squared test\n\ndata:  age_by_outcome\nX-squared = 6.4931, df = 7, p-value = 0.4835\n\n\nДополнительные примеры кода и советы по статистике приведены на странице Простые статистические тесты.\n\n\nДругие советы\n\nВключайте аргумент na.rm = TRUE, чтобы исключить отсутствующие значения из любого указанного выше расчета.\n\nПри применении любой функции-помощника adorn_*() к таблицам, которые были созданы не с помощью tabyl(), вы можете уточнить конкретные столбцы, к которым нужно применить, например, adorn_percentage(,,,c(cases,deaths)) (уточните их в 4м неименованном аргументе). Синтаксис непростой. Рассмотрите возможность вместо этого использовать summarise().\n\nБолее подробно вы можете прочитать на странице по janitor и в этой виньетке по tabyl.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Описательные таблицы</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.ru.html#пакет-dplyr",
    "href": "new_pages/tables_descriptive.ru.html#пакет-dplyr",
    "title": "17  Описательные таблицы",
    "section": "17.4 пакет dplyr",
    "text": "17.4 пакет dplyr\ndplyr является частью пакетов tidyverse и очень часто используемым инструментом управления данными. Создание таблиц с помощью функций из dplyr summarise() и count() является очень полезным подходом к рассчету сводной статистики, обобщения по группе или для передачи таблиц в ggplot().\nsummarise() создает новый сводный датафрейм. Если данные не группированы, она выдаст датафрейм с одной строкой с указанной сводной статистикой по всему датафрейму. Если данные сгруппированы, новый датафрейм будет содержать по одной строке на группу (см. страницу [Группирование данных])(grouping.ru.qmd).\nВнутри скобок в summarise() вы задаете имена каждого нового сводного столбца, за которыми следует знак равно и статистическая функция, которую нужно применить.\nСОВЕТ: Функция summarise (обобщить) работает и в британском и американском написании (summarise() и summarize()).\n\nСделать подсчет количества\nСамая простая функция, которую можно применить в summarise() - это n(). Оставьте скобки пустыми, чтобы подсчитать количество строк.\n\nlinelist %&gt;%                 # начинаем с построчного списка\n  summarise(n_rows = n())    # выдает новый сводный датафрейм со столбцом n_rows\n\n  n_rows\n1   5888\n\n\nЭто становится более интересным, если у нас данные были до этого сгруппированы.\n\nlinelist %&gt;% \n  group_by(age_cat) %&gt;%     # группируем данные по уникальным значениям в столбце age_cat\n  summarise(n_rows = n())   # выдает количество строк *в группе*\n\n# A tibble: 9 × 2\n  age_cat n_rows\n  &lt;fct&gt;    &lt;int&gt;\n1 0-4       1095\n2 5-9       1095\n3 10-14      941\n4 15-19      743\n5 20-29     1073\n6 30-49      754\n7 50-69       95\n8 70+          6\n9 &lt;NA&gt;        86\n\n\nУказанную выше команду можно сократить, используя функцию count(). count() выполняет следующие действия:\n\nГруппирует данные по заданным ей столбцам\n\nОбобщает их с помощью n() (создает столбец n)\n\nРазгруппирует данные\n\n\nlinelist %&gt;% \n  count(age_cat)\n\n  age_cat    n\n1     0-4 1095\n2     5-9 1095\n3   10-14  941\n4   15-19  743\n5   20-29 1073\n6   30-49  754\n7   50-69   95\n8     70+    6\n9    &lt;NA&gt;   86\n\n\nВы можете изменить имя столбца с подсчетом со значения по умолчанию n на что-либо другое, задав это имя в аргумент name =.\nТабуляция подсчетов по двум или более столбцам группирования выдается в “длинном” формате с количеством, указанным в столбце n. См. страницу Поворот данных , чтобы больше узнать о “длинном” и “широком” формате данных.\n\nlinelist %&gt;% \n  count(age_cat, outcome)\n\n   age_cat outcome   n\n1      0-4   Death 471\n2      0-4 Recover 364\n3      0-4    &lt;NA&gt; 260\n4      5-9   Death 476\n5      5-9 Recover 391\n6      5-9    &lt;NA&gt; 228\n7    10-14   Death 438\n8    10-14 Recover 303\n9    10-14    &lt;NA&gt; 200\n10   15-19   Death 323\n11   15-19 Recover 251\n12   15-19    &lt;NA&gt; 169\n13   20-29   Death 477\n14   20-29 Recover 367\n15   20-29    &lt;NA&gt; 229\n16   30-49   Death 329\n17   30-49 Recover 238\n18   30-49    &lt;NA&gt; 187\n19   50-69   Death  33\n20   50-69 Recover  38\n21   50-69    &lt;NA&gt;  24\n22     70+   Death   3\n23     70+ Recover   3\n24    &lt;NA&gt;   Death  32\n25    &lt;NA&gt; Recover  28\n26    &lt;NA&gt;    &lt;NA&gt;  26\n\n\n\n\nПоказать все уровни\nЕсли вы делаете табуляцию по столбцу с классом фактор, вы можете убедиться, что показаны все уровни (а не только уровни со значениями в данных), добавив .drop = FALSE в команду summarise() или count().\nЭтот прием полезен для стандартизации ваших таблиц/графиков. Например, если вы создаете рисунки по нескольким подгруппам, либо постоянно создаете рисунок для рутинных отчетов. В каждом случае наличие значения в данных может колебаться, но вы можете определить уровни, которые будут оставаться постоянными.\nСм. дополнительную информацию на странице Факторы.\n\n\nДоли\nДоли могут быть добавлены с помощью передачи таблицы в функцию mutate(), чтобы создать новый столбец. Определите новый столбец как столбец с подсчетом (n по умолчанию), разделенный на сумму столбца подсчета количества sum() (это выдаст вам долю).\nОбратите внимание, что в этом случае sum() в команде mutate() выдаст сумму всего столбца n для использования в качестве знаменателя при расчете доли. Как объяснялось на странице Группирование данных, если используется sum() для группированных данных (например, если mutate() идет непосредственно после команды group_by()), она выдаст суммы по группам. Как указано чуть выше, count() завершает свои действия разгруппированием. Таким образом, в этом сценарии мы получим доли по полным столбцам.\nЧтобы легко отобразить проценты, вы можете обернуть долю в функцию percent() из пакета scales (обратите внимание, что это конвертирует в текстовый класс).\n\nage_summary &lt;- linelist %&gt;% \n  count(age_cat) %&gt;%                     # группируем и считаем по полу (создает столбец \"n\")\n  mutate(                                # создаем процент столбца - обратите внимание на знаменатель\n    percent = scales::percent(n / sum(n))) \n\n# печать\nage_summary\n\n  age_cat    n percent\n1     0-4 1095  18.60%\n2     5-9 1095  18.60%\n3   10-14  941  15.98%\n4   15-19  743  12.62%\n5   20-29 1073  18.22%\n6   30-49  754  12.81%\n7   50-69   95   1.61%\n8     70+    6   0.10%\n9    &lt;NA&gt;   86   1.46%\n\n\nНиже приведен метод расчета долей внутри групп. Он полагается на разные уровни группирования данных, которые селективно применяются и снимаются. Сначала данные группируются по исходу outcome с помощью group_by(). Затем применяется count(). Эта функция далее группирует данные по age_cat и выдает подсчет для каждой комбинации исхода-возрастной категории outcome-age-cat. Что важно - после того как процесс завершен, count() также разгруппирует группирование по возрастным категориям age_cat, так что единственным оставшимся группированием будет оригинальное группирование по исходам outcome. Таким образом, последний шаг расчета долей (знаменатель sum(n)) все еще имеет группирование по исходу outcome.\n\nage_by_outcome &lt;- linelist %&gt;%                  # начинаем с построчного списка\n  group_by(outcome) %&gt;%                         # группируем по исходу \n  count(age_cat) %&gt;%                            # группируем и считаем по age_cat, а затем снимаем группировку age_cat\n  mutate(percent = scales::percent(n / sum(n))) # рассчитываем процент - обратите внимание, что знаменатель по группе исхода\n\n\n\n\n\n\n\n\n\nПостроение графика\nОтобразить “длинную” выходную таблицу, как показано выше, с помощью ggplot() достаточно просто. Данные естественным образом находятся в “длинном” формате, который естественно воспринимается ggplot(). См. дополнительные примепры на страницах Основы ggplot и Советы по использованию ggplot.\n\nlinelist %&gt;%                      # начинаем с построчного списка\n  count(age_cat, outcome) %&gt;%     # группируем и считаем количество по двум столбцам\n  ggplot()+                       # передаем новый датафрейм в ggplot\n    geom_col(                     # создаем столбчатую диаграмму\n      mapping = aes(   \n        x = outcome,              # строим исход по оси x\n        fill = age_cat,           # age_cat отражаем в заливке\n        y = n))                   # строим столбец подсчета `n` по высоте\n\n\n\n\n\n\n\n\n\n\nСводная статистика\nОдним из важных преимуществ dplyr и summarise() является способность выдать более продвинутые статистические сводные данные, такие как median() (медиана), mean() (среднее), max() (максимум), min() (минимум), sd() (стандартное отклонение) и процентили. Вы также можете использовать sum(), чтобы получить количество строк, которые соответствуют определенным логическим критериям. Как указано выше, эти выходные данные мы можем получить по всему датафрейму или по группам.\nСинтаксис тот же - внутри скобок summarise() вы задаете имена каждого нового сводного столбца, после чего идет знак равно и статистическая функция, которую нужно применить. Внутри статистической функции задайте столбец(столбцы), с которыми нужно проделать операцию и любые необходимые аргументы (например, na.rm = TRUE для большинства математических функций).\nВы также можете использовать sum(), чтобы выдать количество строк, которые соответствуют логическим критериям. Выражение внутри считается, если оно оценено как TRUE (ИСТИНА). Например:\n\nsum(age_years &lt; 18, na.rm=T)\n\nsum(gender == \"male\", na.rm=T)\n\nsum(response %in% c(\"Likely\", \"Very Likely\"))\n\nНиже данные linelist обобщаются, чтобы описать дни задержки от появления симптомов до госпитализации (столбец days_onset_hosp), по больницам.\n\nsummary_table &lt;- linelist %&gt;%                                        # начинаем с построчного списка, сохраняем как новый объект\n  group_by(hospital) %&gt;%                                             # группируем все расчеты по больницам\n  summarise(                                                         # выдаются только указанные ниже сводные столбцы\n    cases       = n(),                                                # количество строк на группу\n    delay_max   = max(days_onset_hosp, na.rm = T),                    # максимальная задержка\n    delay_mean  = round(mean(days_onset_hosp, na.rm=T), digits = 1),  # средняя задержка, округленная\n    delay_sd    = round(sd(days_onset_hosp, na.rm = T), digits = 1),  # стандартное отклонение задержек, округленное\n    delay_3     = sum(days_onset_hosp &gt;= 3, na.rm = T),               # количество строк с задержкой 3 или более дня\n    pct_delay_3 = scales::percent(delay_3 / cases)                    # конвертирует ранее установленный столбец задержки в проценты \n  )\n\nsummary_table  # печать\n\n# A tibble: 6 × 7\n  hospital               cases delay_max delay_mean delay_sd delay_3 pct_delay_3\n  &lt;chr&gt;                  &lt;int&gt;     &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;   &lt;int&gt; &lt;chr&gt;      \n1 Central Hospital         454        12        1.9      1.9     108 24%        \n2 Military Hospital        896        15        2.1      2.4     253 28%        \n3 Missing                 1469        22        2.1      2.3     399 27%        \n4 Other                    885        18        2        2.2     234 26%        \n5 Port Hospital           1762        16        2.1      2.2     470 27%        \n6 St. Mark's Maternity …   422        18        2.1      2.3     116 27%        \n\n\nНекоторые советы:\n\nИспользуйте sum() с логическим утверждением, чтобы “посчитать” строки, которые соответствуют определенным критериям (==)\n\nОбратите внимание на использование аргумента na.rm = TRUE внутри математических функций, таких как sum(), иначе NA будут выданы, если есть отсутствующие значения\n\nИспользуйте функцию percent() из пакета scales, чтобы легко конвертировать в проценты\n\nУстановите точность accuracy = на 0.1 или 0.01, чтобы было 1 или два знака после запятой, соответственно\n\n\nИспользуйте round() из базового R, чтобы уточнить количество десятичных знаков\n\nЧтобы рассчитать эти статистические показатели для всего набора данных, используйте summarise() без group_by()\n\nВы можете создать столбцы в целях расчетов позднее (например, знаменатели), которые вы в конечном идее удалите из датафрейма с помощью select().\n\n\n\nСтатистика по условиям\nВам может потребоваться статистика по условиям - например, максимум строк, которые соответствуют определенным критериям. Это можно сделать, определив подмножество столбца с помощью квадратных скобок [ ]. Пример ниже выдает максимальную температуру для пациентов, классифицированных как имеющих и не имеющих повышенную температуру. Однако имейте ввиду, что может быть лучше добавить еще один столбец в команду group_by() и pivot_wider() (как показано ниже).\n\nlinelist %&gt;% \n  group_by(hospital) %&gt;% \n  summarise(\n    max_temp_fvr = max(temp[fever == \"yes\"], na.rm = T),\n    max_temp_no = max(temp[fever == \"no\"], na.rm = T)\n  )\n\n# A tibble: 6 × 3\n  hospital                             max_temp_fvr max_temp_no\n  &lt;chr&gt;                                       &lt;dbl&gt;       &lt;dbl&gt;\n1 Central Hospital                             40.4        38  \n2 Military Hospital                            40.5        38  \n3 Missing                                      40.6        38  \n4 Other                                        40.8        37.9\n5 Port Hospital                                40.6        38  \n6 St. Mark's Maternity Hospital (SMMH)         40.6        37.9\n\n\n\n\nСклеивание\nФункция str_glue() из stringr является полезной для объединения значений из нескольких столбцов в один новый столбец. В этом контексте она, как правило, используется после команды summarise().\nНа странице Текст и последовательности обсуждаются разные спомобы объединения столбцов, включая unite() и paste0(). В данном применении мы предлагаем использовать str_glue(), поскольку она более гибкая, чем unite(), и имеет более простой синтаксис, чем paste0().\nНиже датафрейм summary_table (созданный выше) изменяется таким образом, что столбцы delay_mean и delay_sd объединяются, добавляется форматирование со скобками для нового столбца, а соответствующие старые столбцы удаляются.\nЗатем, чтобы сделать таблицу более презентабельной, добавляется строка итого с помощью adorn_totals() из janitor (которая игнорирует нечисловые столбцы). Наконец, мы используем select() из dplyr, чтобы изменить порядок и сменить имена столбцов на более хорошие.\nТеперь вы можете передать в flextable и напечататьт таблицу в Word, .png, .jpeg, .html, Powerpoint, RMarkdown и т.п.! (См. страницу Таблицы для презентации).\n\nsummary_table %&gt;% \n  mutate(delay = str_glue(\"{delay_mean} ({delay_sd})\")) %&gt;%  # объединяем и форматируем другие значения\n  select(-c(delay_mean, delay_sd)) %&gt;%                       # удаляем два старых столбца   \n  adorn_totals(where = \"row\") %&gt;%                            # добавляем строку итого\n  select(                                                    # упорядочиваем и переименовываем столбцы\n    \"Hospital Name\"   = hospital,\n    \"Cases\"           = cases,\n    \"Max delay\"       = delay_max,\n    \"Mean (sd)\"       = delay,\n    \"Delay 3+ days\"   = delay_3,\n    \"% delay 3+ days\" = pct_delay_3\n    )\n\n                        Hospital Name Cases Max delay Mean (sd) Delay 3+ days\n                     Central Hospital   454        12 1.9 (1.9)           108\n                    Military Hospital   896        15 2.1 (2.4)           253\n                              Missing  1469        22 2.1 (2.3)           399\n                                Other   885        18   2 (2.2)           234\n                        Port Hospital  1762        16 2.1 (2.2)           470\n St. Mark's Maternity Hospital (SMMH)   422        18 2.1 (2.3)           116\n                                Total  5888       101         -          1580\n % delay 3+ days\n             24%\n             28%\n             27%\n             26%\n             27%\n             27%\n               -\n\n\n\nПроцентили\nПроцентили и квантили в dplyr заслуживают отдельного упоминания. Чтобы получить квантили, используйте quantile() с аргументами по умолчанию, либо уточните значение(я), которое(ые) вы хотите с помощью probs =.\n\n# получаем значения процентилей возраста по умолчанию (0%, 25%, 50%, 75%, 100%)\nlinelist %&gt;% \n  summarise(age_percentiles = quantile(age_years, na.rm = TRUE))\n\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\nℹ Please use `reframe()` instead.\nℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n\n\n  age_percentiles\n1               0\n2               6\n3              13\n4              23\n5              84\n\n# получаем уточненные вручную значения процентилей возраста (5%, 50%, 75%, 98%)\nlinelist %&gt;% \n  summarise(\n    age_percentiles = quantile(\n      age_years,\n      probs = c(.05, 0.5, 0.75, 0.98), \n      na.rm=TRUE)\n    )\n\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\nℹ Please use `reframe()` instead.\nℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n\n\n  age_percentiles\n1               1\n2              13\n3              23\n4              48\n\n\nЕсли вы хотите получить квантили по группе, вы можете получить длинные и менее полезные выходные данные, если вы просто добавите еще один столбец в group_by(). Поэтому вместо этого попробуйте такой подход - создайте столбец для каждого нужного уровня квантиля.\n\n# получите уточненные вручную значения процентилей возраста (5%, 50%, 75%, 98%)\nlinelist %&gt;% \n  group_by(hospital) %&gt;% \n  summarise(\n    p05 = quantile(age_years, probs = 0.05, na.rm=T),\n    p50 = quantile(age_years, probs = 0.5, na.rm=T),\n    p75 = quantile(age_years, probs = 0.75, na.rm=T),\n    p98 = quantile(age_years, probs = 0.98, na.rm=T)\n    )\n\n# A tibble: 6 × 5\n  hospital                               p05   p50   p75   p98\n  &lt;chr&gt;                                &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Central Hospital                         1    12    21  48  \n2 Military Hospital                        1    13    24  45  \n3 Missing                                  1    13    23  48.2\n4 Other                                    1    13    23  50  \n5 Port Hospital                            1    14    24  49  \n6 St. Mark's Maternity Hospital (SMMH)     2    12    22  50.2\n\n\nХотя функция summarise() из dplyr однозначно предлагает более детальный контроль, вы можете увидеть, что необходимую вам статистику можно подготовить и с помощью get_summary_stat() из пакета rstatix. При работе с сгруппированными данными, она выдаст 0%, 25%, 50%, 75% и 100%. При применении к негруппированным данным, вы можете уточнить процентили с помощью probs = c(.05, .5, .75, .98).\n\nlinelist %&gt;% \n  group_by(hospital) %&gt;% \n  rstatix::get_summary_stats(age, type = \"quantile\")\n\n# A tibble: 6 × 8\n  hospital                         variable     n  `0%` `25%` `50%` `75%` `100%`\n  &lt;chr&gt;                            &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1 Central Hospital                 age        445     0     6    12    21     58\n2 Military Hospital                age        884     0     6    14    24     72\n3 Missing                          age       1441     0     6    13    23     76\n4 Other                            age        873     0     6    13    23     69\n5 Port Hospital                    age       1739     0     6    14    24     68\n6 St. Mark's Maternity Hospital (… age        420     0     7    12    22     84\n\n\n\nlinelist %&gt;% \n  rstatix::get_summary_stats(age, type = \"quantile\")\n\n# A tibble: 1 × 7\n  variable     n  `0%` `25%` `50%` `75%` `100%`\n  &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1 age       5802     0     6    13    23     84\n\n\n\n\n\nОбобщение агрегированных данных\nЕсли вы начинаете с агрегированных данных, использование n() выдаст количество строк, а не сумму агрегированных подсчетов. Чтобы получить суммы, примените sum() к столбцу с подсчетом в данных.\nНапример, представим, что вы начинаете с датафреймом подсчета ниже, который называется linelist_agg - он отображает в “длинном” формате подсчет случаев по исходу и полу.\nНиже мы создаем этот пример датафрейма с подсчетом случаев из linelist по исходу и полу (для ясности отсутствующие значения удаляются).\n\nlinelist_agg &lt;- linelist %&gt;% \n  drop_na(gender, outcome) %&gt;% \n  count(outcome, gender)\n\nlinelist_agg\n\n  outcome gender    n\n1   Death      f 1227\n2   Death      m 1228\n3 Recover      f  953\n4 Recover      m  950\n\n\nЧтобы сложить количества (в столбце n) по группам, вы можете использовать summarise(), но установить новый столбец равным sum(n, na.rm=T). Чтобы добавить элемент условия к операции суммы, вы можете использовать синтаксис квадратных скобок подмножества [ ] для столбца с подсчетом.\n\nlinelist_agg %&gt;% \n  group_by(outcome) %&gt;% \n  summarise(\n    total_cases  = sum(n, na.rm=T),\n    male_cases   = sum(n[gender == \"m\"], na.rm=T),\n    female_cases = sum(n[gender == \"f\"], na.rm=T))\n\n# A tibble: 2 × 4\n  outcome total_cases male_cases female_cases\n  &lt;chr&gt;         &lt;int&gt;      &lt;int&gt;        &lt;int&gt;\n1 Death          2455       1228         1227\n2 Recover        1903        950          953\n\n\n\n\nacross() по нескольким столбцам\nВы можете применить summarise() к нескольким столбцам, используя across(). Это упростит жизнь, если вы хотите рассчитать одинаковые статистические показатели для нескольких столбцов. Поставьте across() внутри summarise() и уточните следующее:\n\n.cols = как либо вектор имен столбцов c() или функции-помощники “tidyselect” (объясняется ниже)\n\n.fns = выполняемая функция (без скобок) - вы можете указать несколько внутри list()\n\nНиже среднее значение mean() применяется к нескольким числовым столбцам. Вектор столбцов записывается в .cols =, а одна функция mean (среднее значение) указывается (без скобок) в .fns =. Любые дополнительные аргументы для функции (например, na.rm=TRUE) задаются после .fns =, отделенные запятой.\nПри использовании across() может быть сложно указать скобки и запятые в правильном порядке. Помните, что внутри across() вы должны включить столбцы, функции, а также дополнительные аргументы, необходимые функциям.\n\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm),  # столбцы\n                   .fns = mean,                               # функция\n                   na.rm=T))                                  # дополнительные аргументы\n\nWarning: There was 1 warning in `summarise()`.\nℹ In argument: `across(...)`.\nℹ In group 1: `outcome = \"Death\"`.\nCaused by warning:\n! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\nSupply arguments directly to `.fns` through an anonymous function instead.\n\n  # Previously\n  across(a:b, mean, na.rm = TRUE)\n\n  # Now\n  across(a:b, \\(x) mean(x, na.rm = TRUE))\n\n\n# A tibble: 3 × 5\n  outcome age_years  temp wt_kg ht_cm\n  &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Death        15.9  38.6  52.6  125.\n2 Recover      16.1  38.6  52.5  125.\n3 &lt;NA&gt;         16.2  38.6  53.0  125.\n\n\nНесколько функций можно выполнять одновременно. Ниже в .fns = указываются функции mean (среднее) и sd (стандартное отклонение) внутри list(). У вас есть возможность задать текстовые имена (например, “mean” и “sd”), которые будут добавлены к новым названиям столбцов.\n\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm), # столбцы\n                   .fns = list(\"mean\" = mean, \"sd\" = sd),    # несколько функций \n                   na.rm=T))                                 # дополнительные аргументы\n\n# A tibble: 3 × 9\n  outcome age_years_mean age_years_sd temp_mean temp_sd wt_kg_mean wt_kg_sd\n  &lt;chr&gt;            &lt;dbl&gt;        &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;\n1 Death             15.9         12.3      38.6   0.962       52.6     18.4\n2 Recover           16.1         13.0      38.6   0.997       52.5     18.6\n3 &lt;NA&gt;              16.2         12.8      38.6   0.976       53.0     18.9\n# ℹ 2 more variables: ht_cm_mean &lt;dbl&gt;, ht_cm_sd &lt;dbl&gt;\n\n\nВот функции-помощники “tidyselect”, которые вы можете указать в .cols =, чтобы выбрать столбцы:\n\neverything() - все остальные не упомянутые столбцы\n\nlast_col() - последний столбец\n\nwhere() - применяет функцию ко всем столбцам и выбирает те, которые оценены как TRUE (ИСТИНА)\n\nstarts_with() - ищет совпадение с установленным префиксом. Пример: starts_with(\"date\")\nends_with() - ищет совпадение с установленным суффиксом. Пример: ends_with(\"_end\")\n\ncontains() - столбцы, содержащие текстовую последовательностоь. Пример: contains(\"time\")\nmatches() - чтобы применить регулярное выражение (regex). Пример: contains(\"[pt]al\")\n\nnum_range() -\nany_of() - ищет совпадение, если столбец именованный. Полезно, если имя не существует. Пример: any_of(date_onset, date_death, cardiac_arrest)\n\nНапример, чтобы выдать среднее значение каждого числового столбца, используйте where() и задайте функцию as.numeric() (без скобок). Все это остается внутри команды across().\n\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  summarise(across(\n    .cols = where(is.numeric),  # все числовые столбцы в датафрейме\n    .fns = mean,\n    na.rm=T))\n\n# A tibble: 3 × 12\n  outcome generation   age age_years   lon   lat wt_kg ht_cm ct_blood  temp\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;\n1 Death         16.7  15.9      15.9 -13.2  8.47  52.6  125.     21.3  38.6\n2 Recover       16.4  16.2      16.1 -13.2  8.47  52.5  125.     21.1  38.6\n3 &lt;NA&gt;          16.5  16.3      16.2 -13.2  8.47  53.0  125.     21.2  38.6\n# ℹ 2 more variables: bmi &lt;dbl&gt;, days_onset_hosp &lt;dbl&gt;\n\n\n\n\nПоворот горизонтально\nЕсли вы предпочитаете таблицу в “широком” формате, вы можете ее преобразовать, используя функцию pivot_wider() изtidyr. Вам, скорее всего, нужно будет переименовать столбцы с помощью rename(). Дополнительную информацию см. на странице [Поворот данных].\nПример ниже начинается с “длинной” таблицы age_by_outcome из раздела доли. Мы создаем ее снова и печатаем, для ясности:\n\nage_by_outcome &lt;- linelist %&gt;%                  # начинаем с построчного списка\n  group_by(outcome) %&gt;%                         # группируем по исходу \n  count(age_cat) %&gt;%                            # группируем и считаем по age_cat, а затем снимаем группировку age_cat\n  mutate(percent = scales::percent(n / sum(n))) # рассчитываем процент - обратите внимание, что знаменатель по группе исходов\n\n\n\n\n\n\n\nЧтобы повернуть горизонтально, мы создаем новые столбцы из значений в существующем столбце age_cat (установив names_from = age_cat). Мы также уточняем, что новые значения таблицы будут взяты из существующего столбца n, с values_from = n. Столбцы, не упомянутые в нашей команде поворота (outcome) останутся неизменными в левой стороне.\n\nage_by_outcome %&gt;% \n  select(-percent) %&gt;%   # сохраняем только подсчет количества для простоты\n  pivot_wider(names_from = age_cat, values_from = n)  \n\n# A tibble: 3 × 10\n# Groups:   outcome [3]\n  outcome `0-4` `5-9` `10-14` `15-19` `20-29` `30-49` `50-69` `70+`  `NA`\n  &lt;chr&gt;   &lt;int&gt; &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n1 Death     471   476     438     323     477     329      33     3    32\n2 Recover   364   391     303     251     367     238      38     3    28\n3 &lt;NA&gt;      260   228     200     169     229     187      24    NA    26\n\n\n\n\nСтроки Итого\nКогда summarise() применяется к группированным данным, она не создает автоматически статистические показатели “итого”. Ниже представлены два подхода к добавлению строки “итого”:\n\nadorn_totals() из janitor\nЕсли ваша таблица состоит только из абсолютного количества или долей/процентов, которые могут быть суммированы в “итого”, тогда вы можете добавить сложение итогов, используя функцию adorn_totals() из janitor, как описано в разделе выше. Обратите внимание, что эта функция может выдавать сумму только по числовым столбцам - если вы хотите посчитать другую итоговую сводную статистику, см. следующий подход с использованием dplyr.\nНиже linelist группируется по полу и обобщается в таблицу, которая описывает количество случаев с известным исходом, смертью и выздоровлением. Передав таблицу в adorn_totals(), мы добавляем строку итого внузи, отражающую сумму каждого столбца. Дальнейшие функции adorn_*() корректируют отображение, как указывают примечания к коду.\n\nlinelist %&gt;% \n  group_by(gender) %&gt;%\n  summarise(\n    known_outcome = sum(!is.na(outcome)),           # Количество строк в группе, где исход не отсутствует\n    n_death  = sum(outcome == \"Death\", na.rm=T),    # Количество строк в группе, где исход - смерть\n    n_recover = sum(outcome == \"Recover\", na.rm=T), # Количество строк в группе, где исход - выздоровление\n  ) %&gt;% \n  adorn_totals() %&gt;%                                # оформаляем строку итого (сумма каждого числового столбца)\n  adorn_percentages(\"col\") %&gt;%                      # получаем доли по столбцам\n  adorn_pct_formatting() %&gt;%                        # конвертируем доли в проценты\n  adorn_ns(position = \"front\")                      # отображаем % и абсолютное количество (с абсолютным количеством сначала)\n\n gender  known_outcome        n_death      n_recover\n      f 2,180  (47.8%) 1,227  (47.5%)   953  (48.1%)\n      m 2,178  (47.7%) 1,228  (47.6%)   950  (47.9%)\n   &lt;NA&gt;   207   (4.5%)   127   (4.9%)    80   (4.0%)\n  Total 4,565 (100.0%) 2,582 (100.0%) 1,983 (100.0%)\n\n\n\n\nsummarise() к данным “итого” и затем связывание строк bind_rows()\nЕсли ваша таблица состоит из сводной статистики, такой как median(), mean() и т.п., подход adorn_totals(), показанный выше, не будет достаточным. Вместо этого, чтобы получить сводную статистику для всего набора данных, вам нужно рассчитать их с помощью отдельной команды summarise() и затем привязать результаты к оригинальной сгруппированной суммарной таблице. Чтобы сделать это связывание, вы можете использовать bind_rows() из dplyr, как описано на странице [Объединение данных]. Ниже приведен пример:\nВы делаете суммарную таблицу исходов по больнице с помощью group_by() и summarise() следующим образом:\n\nby_hospital &lt;- linelist %&gt;% \n  filter(!is.na(outcome) & hospital != \"Missing\") %&gt;%  # удаляем случаи с отсутствующим исходом или больницей\n  group_by(hospital, outcome) %&gt;%                      # группируем данные\n  summarise(                                           # создаем новые сводные столбцы интересующих индикаторов\n    N = n(),                                            # количество строк на группу больница-исход     \n    ct_value = median(ct_blood, na.rm=T))               # медианное значение CT на группу\n  \nby_hospital # печать таблицы\n\n# A tibble: 10 × 4\n# Groups:   hospital [5]\n   hospital                             outcome     N ct_value\n   &lt;chr&gt;                                &lt;chr&gt;   &lt;int&gt;    &lt;dbl&gt;\n 1 Central Hospital                     Death     193       22\n 2 Central Hospital                     Recover   165       22\n 3 Military Hospital                    Death     399       21\n 4 Military Hospital                    Recover   309       22\n 5 Other                                Death     395       22\n 6 Other                                Recover   290       21\n 7 Port Hospital                        Death     785       22\n 8 Port Hospital                        Recover   579       21\n 9 St. Mark's Maternity Hospital (SMMH) Death     199       22\n10 St. Mark's Maternity Hospital (SMMH) Recover   126       22\n\n\nЧтобы получить итого, выполните ту же команду summarise(), но сгруппируйте данные только по исходу (не по больнице), следующим образом:\n\ntotals &lt;- linelist %&gt;% \n      filter(!is.na(outcome) & hospital != \"Missing\") %&gt;%\n      group_by(outcome) %&gt;%                            # группируем только по исходу, не по больнице    \n      summarise(\n        N = n(),                                       # Эти статистические показатели теперь представлены только по исходу     \n        ct_value = median(ct_blood, na.rm=T))\n\ntotals # печать таблицы\n\n# A tibble: 2 × 3\n  outcome     N ct_value\n  &lt;chr&gt;   &lt;int&gt;    &lt;dbl&gt;\n1 Death    1971       22\n2 Recover  1469       22\n\n\nМы можем связать эти два датафрейма вместе. Обратите внимание, что у by_hospital 4 столбца, а у totals 3 столбца. Используя bind_rows(), столбцы связываются по имени, а любое лишнее пространство заполняется NA (например, значения столбца hospital для двух новых строк итого totals). После связывания строк мы конвертируем эти пустые места в итого “Total”, используя replace_na() (см. страницу [Вычистка данных и ключевые функции]).\n\ntable_long &lt;- bind_rows(by_hospital, totals) %&gt;% \n  mutate(hospital = replace_na(hospital, \"Total\"))\n\nВот новая таблица со строками “Итого” внизу.\n\n\n\n\n\n\nЭта таблица представлена в “длинном” формате, который может вам подходить. Опционально, вы можете повернуть эту таблицу горизонтально, чтобы сделать ее более читабельной. См. раздел по повороту горизонтально выше, а также страницу [Поворот данных]. Вы можете также добавить дополнительные столбцы и красиво их упорядочить. Код приведен ниже.\n\ntable_long %&gt;% \n  \n  # Поворот горизонтально и форматирование\n  ########################\n  mutate(hospital = replace_na(hospital, \"Total\")) %&gt;% \n  pivot_wider(                                         # Поворот из длинной в широкую\n    values_from = c(ct_value, N),                       # новые значения из столбцов ct и подсчет\n    names_from = outcome) %&gt;%                           # новые имена столбцов из исходов (outcomes)\n  mutate(                                              # добавляем новые столбцы\n    N_Known = N_Death + N_Recover,                               # количество с известным исходом\n    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # процент умерших случаев (1 знак после запятой)\n    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %&gt;% # процент выздоровевших (1 знак после запятой)\n  select(                                              # Переупорядочиваем столбцы\n    hospital, N_Known,                                   # вводные столбцы\n    N_Recover, Pct_Recover, ct_value_Recover,            # столбцы выздоровевших\n    N_Death, Pct_Death, ct_value_Death)  %&gt;%             # столбцы смерти\n  arrange(N_Known)                                  # Упорядочиваем строки от наименьшего к наибольшему (строка Итого внизу)\n\n# A tibble: 6 × 8\n# Groups:   hospital [6]\n  hospital      N_Known N_Recover Pct_Recover ct_value_Recover N_Death Pct_Death\n  &lt;chr&gt;           &lt;int&gt;     &lt;int&gt; &lt;chr&gt;                  &lt;dbl&gt;   &lt;int&gt; &lt;chr&gt;    \n1 St. Mark's M…     325       126 38.8%                     22     199 61.2%    \n2 Central Hosp…     358       165 46.1%                     22     193 53.9%    \n3 Other             685       290 42.3%                     21     395 57.7%    \n4 Military Hos…     708       309 43.6%                     22     399 56.4%    \n5 Port Hospital    1364       579 42.4%                     21     785 57.6%    \n6 Total            3440      1469 42.7%                     22    1971 57.3%    \n# ℹ 1 more variable: ct_value_Death &lt;dbl&gt;\n\n\nЗатем вы можете это красиво напечатать в виде изображения - ниже представлены выходные данные с помощью flextable. Вы можете более детально прочитать об этом примере и о том, как делать такую “красивую” таблицу на странице [Таблицы для презентации].\n\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Описательные таблицы</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.ru.html#tbl_gt",
    "href": "new_pages/tables_descriptive.ru.html#tbl_gt",
    "title": "17  Описательные таблицы",
    "section": "17.5 Пакет gtsummary",
    "text": "17.5 Пакет gtsummary\nЕсли вы хотите распечатать свою сводную статистику в виде красивой и готовой к публикации графики, вы можете использовать пакет gtsummary и его функцию tbl_summary(). Код может сначала показаться сложным, но выходные данные выглядят очень красиво и печатаются в вашей панели просмотра RStudio Viewer в виде изображения HTML. Прочитайте виньетку тут.\nВы можете также добавить результаты статистических тестов в таблицы gtsummary. Этот процесс описывается в разделе gtsummary на странице Простые статистические тесты.\nЧтобы представить tbl_summary() мы сначала покажем наиболее базовое поведение, которое на самом деле создает большую и красивую таблицу. Затем мы детально рассмотрим, как вносить корректировки и делать более адаптированные под потребности таблицы.\n\nСуммарная таблица\nПоведение tbl_summary() по умолчанию на самом деле весьма невероятное - она берет заданные вами столбцы и создает суммарную таблицу в рамках одной команды. Функция печатает статистические показатели, подходящие для класса столбца: медиану и межквартильный диапазон (IQR) для числовых столбцов, и абсолютное количество (%) для категориальных столбцов. Отсутствующие значения конвертируются в “Unknown”. Внизу добавляются примечания, объясняющие статистику, а итого N показывается наверху.\n\nlinelist %&gt;% \n  select(age_years, gender, outcome, fever, temp, hospital) %&gt;%  # сохраняем только интересующие столбцы\n  tbl_summary()                                                  # по умолчанию\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nN = 5,8881\n\n\n\n\nage_years\n13 (6, 23)\n\n\n    Unknown\n86\n\n\ngender\n\n\n\n\n    f\n2,807 (50%)\n\n\n    m\n2,803 (50%)\n\n\n    Unknown\n278\n\n\noutcome\n\n\n\n\n    Death\n2,582 (57%)\n\n\n    Recover\n1,983 (43%)\n\n\n    Unknown\n1,323\n\n\nfever\n4,549 (81%)\n\n\n    Unknown\n249\n\n\ntemp\n38.80 (38.20, 39.20)\n\n\n    Unknown\n149\n\n\nhospital\n\n\n\n\n    Central Hospital\n454 (7.7%)\n\n\n    Military Hospital\n896 (15%)\n\n\n    Missing\n1,469 (25%)\n\n\n    Other\n885 (15%)\n\n\n    Port Hospital\n1,762 (30%)\n\n\n    St. Mark's Maternity Hospital (SMMH)\n422 (7.2%)\n\n\n\n1 Median (IQR); n (%)\n\n\n\n\n\n\n\n\n\n\n\nКорректировки\nТеперь мы объясним, как работает функция и как вносить корректировки. Ключевые аргументы представлены ниже:\nby =\nВы можете стратифицировать свою таблицу по столбцу (например, по outcome), создав двухвходовую таблицу.\nstatistic =\nИспользуйте уравнения, чтобы уточнить, какие статистические показатели показать и как их отобразить. В уравнении две стороны, разделенные тильдой ~. Справа в кавычках представлено желаемое статистическое отображение, а слева - столбцы, к которым будет применяться это отображение.\n\nПравая сторона уравнения использует синтаксис str_glue() из stringr (см. [Текст и последовательности]), где желаемое отображение последовательности представлено в кавычках, а сами статистические показатели в фигурных скобках. Вы можете включить такие статистические показатели, как “n” (для подсчета количества), “N” (для знаменателя), “mean” (среднее), “median” (медиана), “sd” (стандартное отклонение), “max” (максимум), “min” (минимум), процентили в виде “p##”, например, “p25”, или процент от общего как “p”. См. детали в ?tbl_summary.\n\nДля левой стороны уравнения вы можете указать столбцы по имени (например, age или c(age, gender)), либо использовать функции-помощники, такие как all_continuous(), all_categorical(), contains(), starts_with() и т.п.\n\nПростой пример уравнения statistic = может выглядеть следующим образом, он печатает только среднее значение по столбцу age_years:\n\nlinelist %&gt;% \n  select(age_years) %&gt;%         # сохраняем только интересующие столбцы \n  tbl_summary(                  # создаем суммарную таблицу\n    statistic = age_years ~ \"{mean}\") # печать среднего значения по возрасту\n\n\n\n\n\n\n\n\nCharacteristic\nN = 5,8881\n\n\n\n\nage_years\n16\n\n\n    Unknown\n86\n\n\n\n1 Mean\n\n\n\n\n\n\n\n\n\nЧуть более сложное уравнение может выглядеть как \"({min}, {max})\", включая максимальное и минимальное значения внутри скобок, разделенное запятой:\n\nlinelist %&gt;% \n  select(age_years) %&gt;%                       # сохраняем только интересующие столбцы \n  tbl_summary(                                # создаем суммарную таблицу\n    statistic = age_years ~ \"({min}, {max})\") # печать минимума и максимума по возрасту\n\n\n\n\n\n\n\n\nCharacteristic\nN = 5,8881\n\n\n\n\nage_years\n(0, 84)\n\n\n    Unknown\n86\n\n\n\n1 (Range)\n\n\n\n\n\n\n\n\n\nВы можете также дифференцировать синтаксис для отдельных столбцов или типов столбцов. В более сложном примере ниже, значение, указанное в statistc =, является списком, указывающим, что для всех непрерывных столбцов таблица должна напечатать среднее значение со стандартным отклонением в скобках, а для категориальных столбцов - напечатать n, знаменатель и процент.\ndigits =\nКорректирует количество знаков и округление. Опционально, можно задать только для непрерывных столбцов (как ниже).\nlabel =\nКорректирует то, как должно отображаться имя столбца. Задайте имя столбца и желаемую подпись через тильду. По умолчанию будет имя столбца.\nmissing_text =\nКорректирует, как отображаются отсутствующие значения. По умолчанию - “Unknown”.\ntype =\nИспользуется для корректирования того, сколько уровней статистических показателей показывать. Синтаксис похож на statistic = в том, что вы задаете уравнение со столбцами слева и значением справа. Два частых сценария включают:\n\ntype = all_categorical() ~ \"categorical\" заставляет бинарные столбцы (например, fever да/нет) показывать все уровни, а не только строки “yes” (да)\n\ntype = all_continuous() ~ \"continuous2\" разрешает статистические показатели на несколько строк для переменной, как показано в более позднем разделе\n\nВ примере ниже каждый из этих аргументов используется для модификации оригинальной суммарной таблицы:\n\nlinelist %&gt;% \n  select(age_years, gender, outcome, fever, temp, hospital) %&gt;% # сохраняем только интересующие столбцы\n  tbl_summary(     \n    by = outcome,                                               # стратифицируем всю таблицу по исходам\n    statistic = list(all_continuous() ~ \"{mean} ({sd})\",        # статистика и формат для непрерывных столбцов\n                     all_categorical() ~ \"{n} / {N} ({p}%)\"),   # статистика и формат для категориальных столбцов\n    digits = all_continuous() ~ 1,                              # округление для непрерывных столбцов\n    type   = all_categorical() ~ \"categorical\",                 # заставляет отображать все категориальные уровни\n    label  = list(                                              # отображает подписи для имен столбцов\n      outcome   ~ \"Outcome\",                           \n      age_years ~ \"Age (years)\",\n      gender    ~ \"Gender\",\n      temp      ~ \"Temperature\",\n      hospital  ~ \"Hospital\"),\n    missing_text = \"Missing\"                                    # как должны отображаться отсутствующие значения\n  )\n\n1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nDeath, N = 2,5821\nRecover, N = 1,9831\n\n\n\n\nAge (years)\n15.9 (12.3)\n16.1 (13.0)\n\n\n    Missing\n32\n28\n\n\nGender\n\n\n\n\n\n\n    f\n1,227 / 2,455 (50%)\n953 / 1,903 (50%)\n\n\n    m\n1,228 / 2,455 (50%)\n950 / 1,903 (50%)\n\n\n    Missing\n127\n80\n\n\nfever\n\n\n\n\n\n\n    no\n458 / 2,460 (19%)\n361 / 1,904 (19%)\n\n\n    yes\n2,002 / 2,460 (81%)\n1,543 / 1,904 (81%)\n\n\n    Missing\n122\n79\n\n\nTemperature\n38.6 (1.0)\n38.6 (1.0)\n\n\n    Missing\n60\n55\n\n\nHospital\n\n\n\n\n\n\n    Central Hospital\n193 / 2,582 (7.5%)\n165 / 1,983 (8.3%)\n\n\n    Military Hospital\n399 / 2,582 (15%)\n309 / 1,983 (16%)\n\n\n    Missing\n611 / 2,582 (24%)\n514 / 1,983 (26%)\n\n\n    Other\n395 / 2,582 (15%)\n290 / 1,983 (15%)\n\n\n    Port Hospital\n785 / 2,582 (30%)\n579 / 1,983 (29%)\n\n\n    St. Mark's Maternity Hospital (SMMH)\n199 / 2,582 (7.7%)\n126 / 1,983 (6.4%)\n\n\n\n1 Mean (SD); n / N (%)\n\n\n\n\n\n\n\n\n\n\n\nСтатистические показатели на нескольких строках для непрерывных переменных\nЕсли вы хотите напечатать несколько строк статистики для непрерывных переменных, вы можете это указать путем установки type = на “continuous2”. Вы можете объединить все ранее показанные элементы в одну таблицу, выбрав, какие статистические показатели вы хотите показать. Чтобы это сделать, вам нужно сказать функции, что вы хотите получить назад таблицу, введя тип как “continuous2”. Количество отсутствующих значений показано как “Unknown”.\n\nlinelist %&gt;% \n  select(age_years, temp) %&gt;%                      # сохраняем только интересующие столбцы\n  tbl_summary(                                     # создаем суммарную таблицу\n    type = all_continuous() ~ \"continuous2\",       # указываем, что мы хотим напечатать несколько статистических показателей \n    statistic = all_continuous() ~ c(\n      \"{mean} ({sd})\",                             # строка 1: среднее и стандартное отклонение\n      \"{median} ({p25}, {p75})\",                   # строка 2: медиана и межквартильный диапазон IQR\n      \"{min}, {max}\")                              # строка 3: минимум и максимум\n    )\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nN = 5,888\n\n\n\n\nage_years\n\n\n\n\n    Mean (SD)\n16 (13)\n\n\n    Median (IQR)\n13 (6, 23)\n\n\n    Range\n0, 84\n\n\n    Unknown\n86\n\n\ntemp\n\n\n\n\n    Mean (SD)\n38.56 (0.98)\n\n\n    Median (IQR)\n38.80 (38.20, 39.20)\n\n\n    Range\n35.20, 40.80\n\n\n    Unknown\n149\n\n\n\n\n\n\n\n\nСуществует множество другие способов для модификации этих таблиц, включая добавление p-значений, корректировку цвета и заголовков и т.п. Многие из них описаны в документации (введите ?tbl_summary в консоли), а некоторые приведены в разделе статистические тесты.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Описательные таблицы</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.ru.html#базовый-r",
    "href": "new_pages/tables_descriptive.ru.html#базовый-r",
    "title": "17  Описательные таблицы",
    "section": "17.6 базовый R",
    "text": "17.6 базовый R\nВы можете использовать функцию table(), чтобы выполнить табуляцию и кросс-табуляцию столбцов. В отличие от указанных выше вариантов, здесь нужно уточнять датафрейм каждый раз, когда вы ссылаетесь на имя столбца, как показано ниже.\nВНИМАНИЕ: NA (отсутствующие) значения не будут подсчитаны в табуляции, если вы не включите аргумент useNA = \"always\" (который может также быть задан как “no” или “ifany”).\nСОВЕТ: Вы можете использовать %$% из magrittr, чтобы снять необходимость постоянного указания датафрейма в базовых функциях. Например, представленный ниже код можно записать как linelist %$% table(outcome, useNA = \"always\") \n\ntable(linelist$outcome, useNA = \"always\")\n\n\n  Death Recover    &lt;NA&gt; \n   2582    1983    1323 \n\n\nКросс-табуляцию нескольких столбцов можно сделать, указав их один за другим, отделив запятыми. Опционально вы можете также присвоить каждому столбцу “имя”, как Outcome = linelist$outcome.\n\nage_by_outcome &lt;- table(linelist$age_cat, linelist$outcome, useNA = \"always\") # сохраняем таблицу как объект\nage_by_outcome   # печать таблицы\n\n       \n        Death Recover &lt;NA&gt;\n  0-4     471     364  260\n  5-9     476     391  228\n  10-14   438     303  200\n  15-19   323     251  169\n  20-29   477     367  229\n  30-49   329     238  187\n  50-69    33      38   24\n  70+       3       3    0\n  &lt;NA&gt;     32      28   26\n\n\n\nДоли\nЧтобы получить доли, передайте указанную выше таблицу в функцию prop.table(). Используйте аргумент margins = для уточнения того, хотите ли вы доли от строк (1), столбцов (2), либо всей таблицы (3). Для ясности мы передаем таблицу в функцию round() из базового R, уточнив 2 знака.\n\n# получаем доли по определенной выше таблице по строкам, округленно\nprop.table(age_by_outcome, 1) %&gt;% round(2)\n\n       \n        Death Recover &lt;NA&gt;\n  0-4    0.43    0.33 0.24\n  5-9    0.43    0.36 0.21\n  10-14  0.47    0.32 0.21\n  15-19  0.43    0.34 0.23\n  20-29  0.44    0.34 0.21\n  30-49  0.44    0.32 0.25\n  50-69  0.35    0.40 0.25\n  70+    0.50    0.50 0.00\n  &lt;NA&gt;   0.37    0.33 0.30\n\n\n\n\nИтого\nЧтобы добавить строки и таблицы “итого”, передайте таблицу в addmargins(). Это работает и для абсолютного количества, и для долей.\n\naddmargins(age_by_outcome)\n\n       \n        Death Recover &lt;NA&gt;  Sum\n  0-4     471     364  260 1095\n  5-9     476     391  228 1095\n  10-14   438     303  200  941\n  15-19   323     251  169  743\n  20-29   477     367  229 1073\n  30-49   329     238  187  754\n  50-69    33      38   24   95\n  70+       3       3    0    6\n  &lt;NA&gt;     32      28   26   86\n  Sum    2582    1983 1323 5888\n\n\n\n\nКонвертация в датафрейм\nКонвертация объекта table() напрямую в датафрейм не такая простая. Один из подходов продемонстрирован ниже:\n\nСоздаем таблицу без использования useNA = \"always\". Вместо этого конвертируем значения NA в “(Missing)” с помощью fct_explicit_na() из forcats.\n\nДобавляем итого (опционально), передав в addmargins()\n\nПередаем в функцию базового R as.data.frame.matrix()\n\nПередаем таблицу в функцию из tibble rownames_to_column(), уточнив имя для первого столбца\n\nПечатаем, просматриваем или экспортируем по желанию. В этом примере мы используем flextable() из пакета flextable, как описано на странице [Таблицы для презентации]. Это напечатает в панели просмотра RStudio viewer красивое изображение в формате HTML.\n\n\ntable(fct_explicit_na(linelist$age_cat), fct_explicit_na(linelist$outcome)) %&gt;% \n  addmargins() %&gt;% \n  as.data.frame.matrix() %&gt;% \n  tibble::rownames_to_column(var = \"Age Category\") %&gt;% \n  flextable::flextable()\n\nAge CategoryDeathRecover(Missing)Sum0-44713642601,0955-94763912281,09510-1443830320094115-1932325116974320-294773672291,07330-4932923818775450-693338249570+3306(Missing)32282686Sum2,5821,9831,3235,888",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Описательные таблицы</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.ru.html#ресурсы",
    "href": "new_pages/tables_descriptive.ru.html#ресурсы",
    "title": "17  Описательные таблицы",
    "section": "17.7 Ресурсы",
    "text": "17.7 Ресурсы\nЗначительная часть информации на данной странице взята из следующих онлайн ресурсов и виньеток:\ngtsummary\ndplyr",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Описательные таблицы</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.ru.html",
    "href": "new_pages/stat_tests.ru.html",
    "title": "18  Простые статистические тесты",
    "section": "",
    "text": "18.1 Подготовка",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Простые статистические тесты</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.ru.html#подготовка",
    "href": "new_pages/stat_tests.ru.html#подготовка",
    "title": "18  Простые статистические тесты",
    "section": "",
    "text": "Загрузка пакетов\nДанный фрагмент кода показывает загрузку пакетов, необходимых для анализа. В данном руководстве мы фокусируемся на использовании p_load() из пакета pacman, которая устанавливает пакет, если необходимо, и загружает его для использования. Вы можете также загрузить установленные пакеты с помощью library() из базового R. См. страницу Основы R для получения дополнительной информации о пакетах R.\n\npacman::p_load(\n  rio,          # импорт файлов\n  here,         # путь к файлу\n  skimr,        # получение обзора данных\n  tidyverse,    # управление данными + графики ggplot2, \n  gtsummary,    # сводная статистика и тесты\n  rstatix,      # статистика\n  corrr,        # анализ корреляции числовых переменных\n  janitor,      # добавление итого и процентов в таблицы\n  flextable     # конвертация таблиц в HTML\n  )\n\n\n\nИмпорт данных\nМы импортируем набор данных о случаях из имитированной эпидемии Эболы. Если вы хотите выполнять действия параллельно, кликните, чтобы скачать “чистый” построчный список (как .rds файл). Импортируйте ваши данные с помощью функции import() из пакета rio (она работает со многими типами файлов, такими как .xlsx, .rds, .csv - см. детали на странице Импорт и экспорт).\n\n# импорт построчного списка\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nПервые 50 строк построчного списка отображены ниже.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Простые статистические тесты</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.ru.html#базовый-r",
    "href": "new_pages/stat_tests.ru.html#базовый-r",
    "title": "18  Простые статистические тесты",
    "section": "18.2 базовый R",
    "text": "18.2 базовый R\nВы можете использовать функции базового R для проведения статистических тестов. Команды относительно просты, а результаты будут напечатаны для просмотра в консоли R. Однако выходные данные, как правило, являются списками, поэтому с ними слложнее работать, если вы хотите использовать результаты в дальнейших операциях.\n\nT-тесты\nt-тест, также называемый “t-тест Стьюдента”, как правило, используется для определения того, есть ли значительная разница между средними значениями какой-либо числовой переменной между двумя группами. Здесь мы покажем синтаксис для выполнения этого теста в зависимости от того, находятся ли столбцы в том же датафрейме.\nСинтаксис 1: Это синтаксис, если ваш числовой и категориальный столбец находятся в одном датафрейме. Укажите числовой столбец в левой части уровнения, а категориальный столбец - в правой части. Укажите набор данных в data =. Опционально, установите paired = TRUE и conf.level = (0.95 по умолчанию), а также alternative = (либо “two.sided”, “less”, либо “greater”). Для получения детальной информации введите ?t.test.\n\n## сравниваем средний возраст по группе исходов с помощью t-теста\nt.test(age_years ~ gender, data = linelist)\n\n\n    Welch Two Sample t-test\n\ndata:  age_years by gender\nt = -21.344, df = 4902.3, p-value &lt; 2.2e-16\nalternative hypothesis: true difference in means between group f and group m is not equal to 0\n95 percent confidence interval:\n -7.571920 -6.297975\nsample estimates:\nmean in group f mean in group m \n       12.60207        19.53701 \n\n\nСинтаксис 2: Вы можете сравнить два числовых вектора, используя этот альтернативный синтаксис. Например, если два столбца находятся в разных наборах данных.\n\nt.test(df1$age_years, df2$age_years)\n\nВы можете также использовать t-тест, чтобы определить, отличается ли среднее значение выборки значительным образом от какого-то конкретного значения. Здесь мы проведем одновыборочный t-тест с известным/построенным на основе гипотезы популяционным средним значением mu =:\n\nt.test(linelist$age_years, mu = 45)\n\n\n\nКритерий Шапиро-Уилка\nКритерий Шапиро-Уилка может использоваться для определения того, была ли взята выборка из популяции с нормальным распределением (это допущение для многих других тестов и анализа, например, для t-теста). Однако, его можно использовать только на выборке от 3 до 5000 наблюдений. Для более крупных выборок может быть полезным квантиль-квантиль график.\n\nshapiro.test(linelist$age_years)\n\n\n\nКритерий ранговой суммы Уилкоксона\nКритерий ранговой суммы Уилкоксона, также называемый U тест Манна-Уитни, часто используется, чтобы помочь определить, относятся ли две числовых выборки к тому же распределению, когда их популяции не являются нормально распределенными или имеют неравную дисперсию.\n\n## сравниваем возрастное распределение по группе исходов с помощью теста Уилкоксона\nwilcox.test(age_years ~ outcome, data = linelist)\n\n\n    Wilcoxon rank sum test with continuity correction\n\ndata:  age_years by outcome\nW = 2501868, p-value = 0.8308\nalternative hypothesis: true location shift is not equal to 0\n\n\n\n\nКритерий Крускала-Уоллиса\nКритерий Крускала-Уоллиса является расширением Критерия ранговой суммы Уилкоксона, который может использоватьсядля тестировния различий в распределении более, чем двух выборок. Когда используются только две выборки, результаты идентичны Критерию ранговой суммы Уилкоксона.\n\n## сравниваем возрастное распределение по группе исходов с помощью Критерия Крускала-Уоллиса\nkruskal.test(age_years ~ outcome, linelist)\n\n\n    Kruskal-Wallis rank sum test\n\ndata:  age_years by outcome\nKruskal-Wallis chi-squared = 0.045675, df = 1, p-value = 0.8308\n\n\n\n\nКритерий хи-квадрат\nКритерий хи-квадрат Пирсона используется при тестировании значительных отличий между категорияльными группами.\n\n## сравниваем доли в каждой группе с помощью критерия хи-квадрат\nchisq.test(linelist$gender, linelist$outcome)\n\n\n    Pearson's Chi-squared test with Yates' continuity correction\n\ndata:  linelist$gender and linelist$outcome\nX-squared = 0.0011841, df = 1, p-value = 0.9725",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Простые статистические тесты</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.ru.html#пакет-rstatix",
    "href": "new_pages/stat_tests.ru.html#пакет-rstatix",
    "title": "18  Простые статистические тесты",
    "section": "18.3 Пакет rstatix",
    "text": "18.3 Пакет rstatix\nПакет rstatix предлагает способность выполнять статистические тесты и извлекать результаты в структуре, удобной для каналов. Результаты автоматически представляются в датафрейме, так что вы можете проводить с результатами последующие операции. Также легко группировать данные, которые передаются в функции, чтобы статистические показатели считались для каждой группы.\n\nСводная статистика\nФункция get_summary_stats() является быстрым способом выдачи сводной статистики. Просто передайте ваш набор данных в эту функцию и задайте столбцы для анализа. Если не указаны столбцы, статистика считается для всех столбцов.\nПо умолчанию выдаетсыя полный диапазон сводной статистики: n, max (максимум), min (минимум), median (медиана), 25%ile (25 процентиль), 75%ile (75 процентиль), IQR (межквартильный диапазон), median absolute deviation (mad) (медианное абсолютное отклонение), mean (среднее), standard deviation (стандартное отклонение), standard error (стандартная ошибка), а также confidence interval of the mean (доверительный интервал от среднего).\n\nlinelist %&gt;%\n  rstatix::get_summary_stats(age, temp)\n\n# A tibble: 2 × 13\n  variable     n   min   max median    q1    q3   iqr    mad  mean     sd    se\n  &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 age       5802   0    84     13     6    23      17 11.9    16.1 12.6   0.166\n2 temp      5739  35.2  40.8   38.8  38.2  39.2     1  0.741  38.6  0.977 0.013\n# ℹ 1 more variable: ci &lt;dbl&gt;\n\n\nВы можете указать подмножество сводной статистике, которое вам нужно, задав одно из следующих значений в type =: “full”, “common”, “robust”, “five_number”, “mean_sd”, “mean_se”, “mean_ci”, “median_iqr”, “median_mad”, “quantile”, “mean”, “median”, “min”, “max”.\nМожно использовать также для группированных данных, так чтобы выдавалась строка для каждой группы-переменной:\n\nlinelist %&gt;%\n  group_by(hospital) %&gt;%\n  rstatix::get_summary_stats(age, temp, type = \"common\")\n\n# A tibble: 12 × 11\n   hospital     variable     n   min   max median   iqr  mean     sd    se    ci\n   &lt;chr&gt;        &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 Central Hos… age        445   0    58     12    15    15.7 12.5   0.591 1.16 \n 2 Central Hos… temp       450  35.2  40.4   38.8   1    38.5  0.964 0.045 0.089\n 3 Military Ho… age        884   0    72     14    18    16.1 12.4   0.417 0.818\n 4 Military Ho… temp       873  35.3  40.5   38.8   1    38.6  0.952 0.032 0.063\n 5 Missing      age       1441   0    76     13    17    16.0 12.9   0.339 0.665\n 6 Missing      temp      1431  35.8  40.6   38.9   1    38.6  0.97  0.026 0.05 \n 7 Other        age        873   0    69     13    17    16.0 12.5   0.422 0.828\n 8 Other        temp       862  35.7  40.8   38.8   1.1  38.5  1.01  0.034 0.067\n 9 Port Hospit… age       1739   0    68     14    18    16.3 12.7   0.305 0.598\n10 Port Hospit… temp      1713  35.5  40.6   38.8   1.1  38.6  0.981 0.024 0.046\n11 St. Mark's … age        420   0    84     12    15    15.7 12.4   0.606 1.19 \n12 St. Mark's … temp       410  35.9  40.6   38.8   1.1  38.5  0.983 0.049 0.095\n\n\nВы также можете использовать rstatix для проведения статистических тестов:\n\n\nT-тест\nИспользуйте синтаксис формулы, чтобы уточнить числовой и категориальный столбцы:\n\nlinelist %&gt;% \n  t_test(age_years ~ gender)\n\n# A tibble: 1 × 10\n  .y.   group1 group2    n1    n2 statistic    df        p    p.adj p.adj.signif\n* &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;int&gt; &lt;int&gt;     &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;       \n1 age_… f      m       2807  2803     -21.3 4902. 9.89e-97 9.89e-97 ****        \n\n\nИли используйте ~ 1 и уточните mu = для одновыборочного t-теста. Это также можно сделать по группе.\n\nlinelist %&gt;% \n  t_test(age_years ~ 1, mu = 30)\n\n# A tibble: 1 × 7\n  .y.       group1 group2         n statistic    df     p\n* &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;      &lt;int&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 age_years 1      null model  5802     -84.2  5801     0\n\n\nЕсли применимо, статистические тесты можно выполнять по группе, как показано ниже:\n\nlinelist %&gt;% \n  group_by(gender) %&gt;% \n  t_test(age_years ~ 1, mu = 18)\n\n# A tibble: 3 × 8\n  gender .y.       group1 group2         n statistic    df         p\n* &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;      &lt;int&gt;     &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;\n1 f      age_years 1      null model  2807    -29.8   2806 7.52e-170\n2 m      age_years 1      null model  2803      5.70  2802 1.34e-  8\n3 &lt;NA&gt;   age_years 1      null model   192     -3.80   191 1.96e-  4\n\n\n\n\nКритерий Шапиро-Уилка\nКак указано выше, размер выборки должен быть от 3 до 5000.\n\nlinelist %&gt;% \n  head(500) %&gt;%            # первые 500 строк построчного списка случаев, только в целях примера\n  shapiro_test(age_years)\n\n# A tibble: 1 × 3\n  variable  statistic        p\n  &lt;chr&gt;         &lt;dbl&gt;    &lt;dbl&gt;\n1 age_years     0.917 6.67e-16\n\n\n\n\nКритерий ранговой суммы Уилкоксона\n\nlinelist %&gt;% \n  wilcox_test(age_years ~ gender)\n\n# A tibble: 1 × 9\n  .y.       group1 group2    n1    n2 statistic        p    p.adj p.adj.signif\n* &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;  &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;       \n1 age_years f      m       2807  2803   2829274 3.47e-74 3.47e-74 ****        \n\n\n\n\nКритерий Крускала-Уоллиса\nТакже известен как U-тест Манна-Уитни.\n\nlinelist %&gt;% \n  kruskal_test(age_years ~ outcome)\n\n# A tibble: 1 × 6\n  .y.           n statistic    df     p method        \n* &lt;chr&gt;     &lt;int&gt;     &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;         \n1 age_years  5888    0.0457     1 0.831 Kruskal-Wallis\n\n\n\n\nКритерий хи-квадрат\nФункция критерия хи-квадрата принимает таблицу, поэтому сначала создадим кросс-табуляцию. Существует много способов создания кросс-табуляции (см. Описательные таблицы), но здесь мы используем tabyl() из janitor и удаляем самый левый столбец подписей значений до того, как передаем в chisq_test().\n\nlinelist %&gt;% \n  tabyl(gender, outcome) %&gt;% \n  select(-1) %&gt;% \n  chisq_test()\n\n# A tibble: 1 × 6\n      n statistic     p    df method          p.signif\n* &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt;           &lt;chr&gt;   \n1  5888      3.53 0.473     4 Chi-square test ns      \n\n\nС помощью пакета rstatix можно выполнить еще много функций и провести статистические тесты с этими функциями. См. документацию по rstatix онлайн тут или введите ?rstatix.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Простые статистические тесты</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.ru.html#stats_gt",
    "href": "new_pages/stat_tests.ru.html#stats_gt",
    "title": "18  Простые статистические тесты",
    "section": "18.4 пакет gtsummary",
    "text": "18.4 пакет gtsummary\nИспользуйте gtsummary, если вы хотите добавить результаты статистического теста в красивую таблицу, которая была создана с помощью. этого пакета (как описано в разделе gtsummary страницы Описательные таблицы).\nПроведение статистических тестов сравнения с tbl_summary делается путем добавления функции add_p к таблице и уточнения, какой тест использовать. Возможно откорректировать p-значения для множественного тестирования, используя функцию add_q. Детали можно получить с помощью ?tbl_summary.\n\nКритерий хи-квадрат\nСравнтие доли категориальной переменной в двух группах. Статистическим тестом по умолчанию для add_p() при применении к категориальной переменной является критерий хи-квадрат независимости с корректировкой непрерывности, но если ожидаемое количество вызовов ниже 5, то используется точный критерий Фишера.\n\nlinelist %&gt;% \n  select(gender, outcome) %&gt;%    # сохраняем интересующие переменные\n  tbl_summary(by = outcome) %&gt;%  # создаем суммарную таблицу и уточняем переменную группирования\n  add_p()                        # уточняем, какой тест провести\n\n1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nDeath, N = 2,5821\nRecover, N = 1,9831\np-value2\n\n\n\n\ngender\n\n\n\n\n&gt;0.9\n\n\n    f\n1,227 (50%)\n953 (50%)\n\n\n\n\n    m\n1,228 (50%)\n950 (50%)\n\n\n\n\n    Unknown\n127\n80\n\n\n\n\n\n1 n (%)\n\n\n2 Pearson’s Chi-squared test\n\n\n\n\n\n\n\n\n\n\n\nT-тесты\nСравниваем разницу средних значений непрерывной переменной в двух группах. Например, сравниваем средний возраст по исходам пациентов.\n\nlinelist %&gt;% \n  select(age_years, outcome) %&gt;%             # сохраняем интересующие переменные\n  tbl_summary(                               # создаем суммарную таблицу\n    statistic = age_years ~ \"{mean} ({sd})\", # уточняем, какую статистику показать\n    by = outcome) %&gt;%                        # уточняем переменную группирования\n  add_p(age_years ~ \"t.test\")                # уточняем, какие тесты провести\n\n1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nDeath, N = 2,5821\nRecover, N = 1,9831\np-value2\n\n\n\n\nage_years\n16 (12)\n16 (13)\n0.6\n\n\n    Unknown\n32\n28\n\n\n\n\n\n1 Mean (SD)\n\n\n2 Welch Two Sample t-test\n\n\n\n\n\n\n\n\n\n\n\nКритерий ранговой суммы Уилкоксона\nСравниваем распределение непрерывной переменной в двух группах. По умолчанию используется Критерий ранговой суммы Уилкоксона и медиана (IQR) при сравнении двух групп. Однако для не-нормально распределенных данных или при сравнении нескольких групп более подходящим будет Критерий Крускала-Уоллиса.\n\nlinelist %&gt;% \n  select(age_years, outcome) %&gt;%                       # сохраняем интересующие переменные\n  tbl_summary(                                         # создаем суммарную таблицу\n    statistic = age_years ~ \"{median} ({p25}, {p75})\", # уточняем, какую статистику показать (по умолчанию, так что можно удалить)\n    by = outcome) %&gt;%                                  # уточняем переменную группирования\n  add_p(age_years ~ \"wilcox.test\")                     # уточняем, какой тест провести (по умолчанию, так что можно оставить скобки пустыми)\n\n1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nDeath, N = 2,5821\nRecover, N = 1,9831\np-value2\n\n\n\n\nage_years\n13 (6, 23)\n13 (6, 23)\n0.8\n\n\n    Unknown\n32\n28\n\n\n\n\n\n1 Median (IQR)\n\n\n2 Wilcoxon rank sum test\n\n\n\n\n\n\n\n\n\n\n\nКритерий Крускала-Уоллиса\nСравниваем распределение непрерывной переменной в двух или более группах, вне зависимости от того, имеют ли данные нормальное распределение.\n\nlinelist %&gt;% \n  select(age_years, outcome) %&gt;%                       # сохраняем интересующие переменные\n  tbl_summary(                                         # создаем суммарную таблицу\n    statistic = age_years ~ \"{median} ({p25}, {p75})\", # уточняем, какую статистику показать (по умолчанию, так что можно удалить)\n    by = outcome) %&gt;%                                  # уточняем переменную группирования\n  add_p(age_years ~ \"kruskal.test\")                    # уточняем, какой тест провести\n\n1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nDeath, N = 2,5821\nRecover, N = 1,9831\np-value2\n\n\n\n\nage_years\n13 (6, 23)\n13 (6, 23)\n0.8\n\n\n    Unknown\n32\n28\n\n\n\n\n\n1 Median (IQR)\n\n\n2 Kruskal-Wallis rank sum test",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Простые статистические тесты</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.ru.html#корреляции",
    "href": "new_pages/stat_tests.ru.html#корреляции",
    "title": "18  Простые статистические тесты",
    "section": "18.5 Корреляции",
    "text": "18.5 Корреляции\nКорреляцию между числовыми переменными можно изучить с помощью пакета tidyverse\ncorrr. Он позволяет вам рассчитать корреляции, используя коэффициент Пирсона, тау Кендалла или коэффициент корреляции Спирмена. Пакет создает таблицу, а также имеет функцию по автоматическому построению графика значений.\n\ncorrelation_tab &lt;- linelist %&gt;% \n  select(generation, age, ct_blood, days_onset_hosp, wt_kg, ht_cm) %&gt;%   # сохраняем интересующие числовые переменные\n  correlate()      # создаем таблицу корреляции (используя по умолчанию коэффициент Пирсона)\n\ncorrelation_tab    # печать\n\n# A tibble: 6 × 7\n  term            generation      age ct_blood days_onset_hosp    wt_kg    ht_cm\n  &lt;chr&gt;                &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;           &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n1 generation        NA       -2.22e-2  0.179         -0.288    -0.0302  -0.00942\n2 age               -0.0222  NA        0.00849       -0.000635  0.833    0.877  \n3 ct_blood           0.179    8.49e-3 NA             -0.600    -0.00636  0.0181 \n4 days_onset_hosp   -0.288   -6.35e-4 -0.600         NA         0.0153  -0.00953\n5 wt_kg             -0.0302   8.33e-1 -0.00636        0.0153   NA        0.884  \n6 ht_cm             -0.00942  8.77e-1  0.0181        -0.00953   0.884   NA      \n\n## удаляем дублирующиеся записи (зеркало таблицы выше) \ncorrelation_tab &lt;- correlation_tab %&gt;% \n  shave()\n\n## просмотр таблицы корреляции \ncorrelation_tab\n\n# A tibble: 6 × 7\n  term            generation       age ct_blood days_onset_hosp  wt_kg ht_cm\n  &lt;chr&gt;                &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;           &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 generation        NA       NA        NA              NA       NA        NA\n2 age               -0.0222  NA        NA              NA       NA        NA\n3 ct_blood           0.179    0.00849  NA              NA       NA        NA\n4 days_onset_hosp   -0.288   -0.000635 -0.600          NA       NA        NA\n5 wt_kg             -0.0302   0.833    -0.00636         0.0153  NA        NA\n6 ht_cm             -0.00942  0.877     0.0181         -0.00953  0.884    NA\n\n## график корреляций \nrplot(correlation_tab)",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Простые статистические тесты</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.ru.html#ресурсы",
    "href": "new_pages/stat_tests.ru.html#ресурсы",
    "title": "18  Простые статистические тесты",
    "section": "18.6 Ресурсы",
    "text": "18.6 Ресурсы\nМногая информация на этой странице была взята из следующих онлайн ресурсов и виньеток:\ngtsummary dplyr corrr корреляция sthda",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Простые статистические тесты</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.ru.html",
    "href": "new_pages/regression.ru.html",
    "title": "19  Однофакторная и многофакторная регрессия",
    "section": "",
    "text": "19.1 Подготовка",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Однофакторная и многофакторная регрессия</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.ru.html#подготовка",
    "href": "new_pages/regression.ru.html#подготовка",
    "title": "19  Однофакторная и многофакторная регрессия",
    "section": "",
    "text": "Загрузка пакетов\nДанный фрагмент кода показывает загрузку пакетов, необходимых для анализа. В данном руководстве мы фокусируемся на использовании p_load() из пакета pacman, которая устанавливает пакет, если необходимо, и загружает его для использования. Вы можете также загрузить установленные пакеты с помощью library() из базового R. См. страницу Основы R для получения дополнительной информации о пакетах R.\n\npacman::p_load(\n  rio,          # импорт файлов\n  here,         # путь к файлам\n  tidyverse,    # управление данными + графика ggplot2, \n  stringr,      # манипуляции с текстовыми последовательностями \n  purrr,        # циклы над объектами по принципам аккуратных данных\n  gtsummary,    # сводная статистика и тесты \n  broom,        # приведение результатов регрессий в аккуратный вид\n  lmtest,       # тесты на отношение правдоподобия\n  parameters,   # альтернатива для приведения результатов регрессий в аккуратный вид\n  see          # альтернатива для визуализации форест-графиков\n  )\n\n\n\nИмпорт данных\nМы импортируем набор данных о случаях имитированной эпидемии Эболы. Если вы хотите выполнять действия параллельно, кликните, чтобы скачать “чистый” построчный список (как файл .rds). Импортируйте данный с помощью функции import() из пакета rio (он работает с многими типами файлов, такими как .xlsx, .csv, .rds - см. детали на странице Импорт и экспорт).\n\n# импорт построчного списка\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nПервые 50 строк построчного списка отображены ниже.\n\n\n\n\n\n\n\n\nВычистка данных\n\nСохранение независимых переменных\nМы храним имена столбцов независимых переменных как текстовый вектор. На него мы будем ссылаться позже.\n\n## определяем интересующие переменные \nexplanatory_vars &lt;- c(\"gender\", \"fever\", \"chills\", \"cough\", \"aches\", \"vomit\")\n\n\n\nКонвертация в 1 и 0\nНиже мы конвертируем столбцы независимых переменных с “yes”/“no”, “m”/“f”, и “dead”/“alive” на 1 / 0, чтобы соответствовать ожиданиям моделей логистической регрессии. Чтобы это сделать эффективным образом, используем across() из dplyr, чтобы преобразовать сразу несколько столбцов. Функция, которую мы применяем к каждому столбцу, называется case_when() (также из dplyr), она применяет логику для конвертации указанных значений в 1 и 0. См. разделы по across() и case_when() на странице Вычистка данных и ключевые функции).\nПримечание: “.” ниже представляет столбец, который обрабатывается в этот момент функцией across().\n\n## конвертируем двоичные переменные в 0/1 \nlinelist &lt;- linelist %&gt;%  \n  mutate(across(                                      \n    .cols = all_of(c(explanatory_vars, \"outcome\")),  ## для каждого указанного столбца и \"outcome\"\n    .fns = ~case_when(                              \n      . %in% c(\"m\", \"yes\", \"Death\")   ~ 1,           ## перекодируем, мужской пол, да и смерть на 1\n      . %in% c(\"f\", \"no\",  \"Recover\") ~ 0,           ## женский пол, нет и выздоровление на 0\n      TRUE                            ~ NA_real_)    ## в остальных случаях - отсутствующее значение\n    )\n  )\n\n\n\nУдаление строк с отсутствующими значениями\nЧтобы удалить строки с отсутствующими значениям, мы можем использовать функцию drop_na() из tidyr. Однако мы хотим это сделать только для строк, у которых отсутствуют значения в интересующих нас столбцах.\nПервое, что нам нужно сделать, это убедиться, что наш вектор независимых переменных explanatory_vars включает столбец возраста age (age выдал бы ошибку в предыдущей операции case_when(), которая была только для двоичных переменных). Затем мы передаем linelist в команду drop_na(), чтобы удалить строки с отсутствующими значениями в столбце outcome или любом из столбцов независимых переменных explanatory_vars.\nДо выполнения кода количество строк в linelist составляет nrow(linelist).\n\n## добавляем age_category к независимым переменным \nexplanatory_vars &lt;- c(explanatory_vars, \"age_cat\")\n\n## удаляем строки с отсутствующей информацией по интересующим переменным \nlinelist &lt;- linelist %&gt;% \n  drop_na(any_of(c(\"outcome\", explanatory_vars)))\n\nКоличество строк, остающихся в linelist, составляет nrow(linelist).",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Однофакторная и многофакторная регрессия</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.ru.html#однофакторный",
    "href": "new_pages/regression.ru.html#однофакторный",
    "title": "19  Однофакторная и многофакторная регрессия",
    "section": "19.2 Однофакторный",
    "text": "19.2 Однофакторный\nКак и в материалах на странице Описательные таблицы, конкретный способ применения определит, какой пакет R вам использовать. Мы представим две опции для проведения однофакторного анализа:\n\nИспользуйте функции, доступные в базовом R, чтобы быстро напечатать результаты в консоли. Используйте пакет broom, чтобы привести выходные данные в аккуратный вид.\n\nИспользуйте пакет gtsummary, чтобы моделировать и получать готовые к публикации выходные данные.\n\n\n\nбазовый R\n\nЛинейная регрессия\nФункция базового R lm() создает линейную регрессию, оценивая отношения между числовыми независимыми и зависимыми переменными, между которыми предполагается линейное отношение.\nЗадайте уровнение в виде формулы, разделив названия столбцов независимой и зависимой переменной тильдой ~. Также уточните набор данных в аргументе data =. Определите результаты модели как объект R, чтобы их можно было использовать позже.\n\nlm_results &lt;- lm(ht_cm ~ age, data = linelist)\n\nЗатем вы можете выполнить summary() для результатов модели, чтобы увидеть коэффициенты (возможные значения), P-значение, остатки и другие меры.\n\nsummary(lm_results)\n\n\nCall:\nlm(formula = ht_cm ~ age, data = linelist)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-128.579  -15.854    1.177   15.887  175.483 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  69.9051     0.5979   116.9   &lt;2e-16 ***\nage           3.4354     0.0293   117.2   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 23.75 on 4165 degrees of freedom\nMultiple R-squared:  0.7675,    Adjusted R-squared:  0.7674 \nF-statistic: 1.375e+04 on 1 and 4165 DF,  p-value: &lt; 2.2e-16\n\n\nАльтернативно вы можете использовать функцию tidy() из пакета broom, чтобы извлечь результаты в таблицу. Результаты нам говорят, что для каждого года увеличения возраста рост увеличивается на 3.5 см. и это является статистически значимым.\n\ntidy(lm_results)\n\n# A tibble: 2 × 5\n  term        estimate std.error statistic p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;\n1 (Intercept)    69.9     0.598       117.       0\n2 age             3.44    0.0293      117.       0\n\n\nЗатем вы можете также использовать эту регрессию, чтобы добавить ее к ggplot, для этого мы сначала переносим точки из наблюдаемых данных и построенной линии в один датафрейм, используя функцию augment() из broom.\n\n## сводим точки регрессии и наблюдаемые данные в один набор данных\npoints &lt;- augment(lm_results)\n\n## строим график данных, используя возраст в качестве оси x \nggplot(points, aes(x = age)) + \n  ## добавляем точки для роста \n  geom_point(aes(y = ht_cm)) + \n  ## добавляем линию регрессии \n  geom_line(aes(y = .fitted), colour = \"red\")\n\n\n\n\n\n\n\n\nТакже можно добавить простую линейную регрессию сразу в ggplot, используя функцию geom_smooth().\n\n## добавляем данные к графику \n ggplot(linelist, aes(x = age, y = ht_cm)) + \n  ## показываем точки\n  geom_point() + \n  ## добавляем линейную регрессию \n  geom_smooth(method = \"lm\", se = FALSE)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nСм. раздел Ресурсы в конце главы, в котором приведены более подробные руководства.\n\n\nЛогистическая регрессия\nФункция glm() из пакета stats (часть базового R) используется, чтобы строить Обобщенные линейные модели (GLM).\nglm() может использоваться для однофакторной и многофакторной логистической регрессии (например, чтобы получить отношения шансов). Вот ключевые части:\n\n# аргументы для glm()\nglm(formula, family, data, weights, subset, ...)\n\n\nformula = Модель задакется в glm() в виде уравнения, с зависимыми переменными слева, а независимыми переменными справа от тильды ~.\n\nfamily = Определяет тип модели, который надо выполнить. Для логистической регрессии используйте family = \"binomial\", для пуассоновской - используйте family = \"poisson\". Другие примеры приведены в таблице ниже.\n\ndata = Уточните ваш датафрейм\n\nЕсли необходимо, вы можете также уточнить функцию связку через синтаксис family = familytype(link = \"linkfunction\")). Вы можете более подробно ознакомиться с документацией о других семействах и опциональных аргументах, таких как weights = и subset = (?glm).\n\n\n\nСемейство\nФункция связки по умолчанию\n\n\n\n\n\"биномиальное\"\n(link = \"logit\")\n\n\n\"гауссово\"\n(link = \"identity\")\n\n\n\"гамма\"\n(link = \"inverse\")\n\n\n\"обратное гауссово\"\n(link = \"1/mu^2\")\n\n\n\"пуассона\"\n(link = \"log\")\n\n\n\"квази\"\n(link = \"identity\", variance = \"constant\")\n\n\n\"квазибиномиальное\"\n(link = \"logit\")\n\n\n\"квазипуассона\"\n(link = \"log\")\n\n\n\nПри выполнении glm() чаще всего результаты сохраняются как именованный объект R. Затем вы можете напечатать результаты в консоли, используя summary(), как показано ниже, либо провести другие операции с результатами (например, возвести в степень).\nЕсли вам нужно выполнить отрицательную биномиальную регрессию, вы можете использовать пакет MASS; glm.nb() использует тот же синтаксис, что glm(). Для описания работы разных видов регрессии, см. страницу статистики UCLA.\n\n\nОднофакторная glm()\nВ данном примере мы оцениваем связь между разными возрастными категориями и исходом смерти (закодирована как 1 в разделе Подготовка). Ниже представлена однофакторная модель исхода outcome по возрастной категории age_cat. Мы сохраняем выходные данные модели как model, затем печатаем их с помощью summary() в консоли. Обратите внимание, что представленные оценки являются логарифмами отношения шансов, и что базовый уровень является первым уровнем фактора в возрастной категории age_cat (“0-4”).\n\nmodel &lt;- glm(outcome ~ age_cat, family = \"binomial\", data = linelist)\nsummary(model)\n\n\nCall:\nglm(formula = outcome ~ age_cat, family = \"binomial\", data = linelist)\n\nCoefficients:\n              Estimate Std. Error z value Pr(&gt;|z|)   \n(Intercept)   0.233738   0.072805   3.210  0.00133 **\nage_cat5-9   -0.062898   0.101733  -0.618  0.53640   \nage_cat10-14  0.138204   0.107186   1.289  0.19726   \nage_cat15-19 -0.005565   0.113343  -0.049  0.96084   \nage_cat20-29  0.027511   0.102133   0.269  0.78765   \nage_cat30-49  0.063764   0.113771   0.560  0.57517   \nage_cat50-69 -0.387889   0.259240  -1.496  0.13459   \nage_cat70+   -0.639203   0.915770  -0.698  0.48518   \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 5712.4  on 4166  degrees of freedom\nResidual deviance: 5705.1  on 4159  degrees of freedom\nAIC: 5721.1\n\nNumber of Fisher Scoring iterations: 4\n\n\nЧтобы изменить базовый уровень определенной переменной, убедитесь, что столбец относится к классу фактор и передвиньте нужный уровень на первую позицию с помощью fct_relevel() (см. страницу Факторы). Например, ниже мы берем столбец age_cat и устанавливаем “20-29” в качестве базового уровня до передачи измененного датафрейма в glm().\n\nlinelist %&gt;% \n  mutate(age_cat = fct_relevel(age_cat, \"20-29\", after = 0)) %&gt;% \n  glm(formula = outcome ~ age_cat, family = \"binomial\") %&gt;% \n  summary()\n\n\nCall:\nglm(formula = outcome ~ age_cat, family = \"binomial\", data = .)\n\nCoefficients:\n             Estimate Std. Error z value Pr(&gt;|z|)    \n(Intercept)   0.26125    0.07163   3.647 0.000265 ***\nage_cat0-4   -0.02751    0.10213  -0.269 0.787652    \nage_cat5-9   -0.09041    0.10090  -0.896 0.370220    \nage_cat10-14  0.11069    0.10639   1.040 0.298133    \nage_cat15-19 -0.03308    0.11259  -0.294 0.768934    \nage_cat30-49  0.03625    0.11302   0.321 0.748390    \nage_cat50-69 -0.41540    0.25891  -1.604 0.108625    \nage_cat70+   -0.66671    0.91568  -0.728 0.466546    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 5712.4  on 4166  degrees of freedom\nResidual deviance: 5705.1  on 4159  degrees of freedom\nAIC: 5721.1\n\nNumber of Fisher Scoring iterations: 4\n\n\n\n\nПечать результатов\nДля большинства случаев использования необходимо внести некоторые изменения в указанные выше выходные данные. Функция tidy() из пакета broom является удобной, чтобы сделать результаты модели презентабельными.\nЗдесь мы демонстрируем, как комбинировать выходные данные модели с таблицей подсчетов.\n\nПолучите возведенные в степень оценочные логарифмы отношения шансов и доверительных интервалов, передав модель в функцию tidy() и установив exponentiate = TRUE и conf.int = TRUE.\n\n\nmodel &lt;- glm(outcome ~ age_cat, family = \"binomial\", data = linelist) %&gt;% \n  tidy(exponentiate = TRUE, conf.int = TRUE) %&gt;%        # возводим в степень и создаем ДИ\n  mutate(across(where(is.numeric), round, digits = 2))  # округляем все числовые столбцы\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `across(where(is.numeric), round, digits = 2)`.\nCaused by warning:\n! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\nSupply arguments directly to `.fns` through an anonymous function instead.\n\n  # Previously\n  across(a:b, mean, na.rm = TRUE)\n\n  # Now\n  across(a:b, \\(x) mean(x, na.rm = TRUE))\n\n\nНиже представлена полученная на выходе таблица tibble model:\n\n\n\n\n\n\n\nОбъединяем эти результаты модели с таблицей подсчета. Ниже мы создаем перекрестную таблицу подсчета с помощью функции tabyl() из пакета janitor, как объяснялось на странице Описательные таблицы.\n\n\ncounts_table &lt;- linelist %&gt;% \n  janitor::tabyl(age_cat, outcome)\n\n\n\n\n\n\n\n\n\n\n\nВот как выглядит этот датафрейм counts_table:\n\n\n\n\n\n\nТеперь мы можем связать counts_table и результаты модели model вместе горизонтально с помощью bind_cols() (dplyr). Помните, что при использовании bind_cols() строки в двух датафреймах должны идеально соответствовать. В данном коде поскольку мы связываем внутри цепочки канала, мы используем ., чтобы представить поставленный в канал объект counts_table, когда мы его привязываем к модели model. Чтобы завершить процесс, мы используем select(), чтобы выбрать необходимые столбцы и их порядок, и наконец применяем функцию из базового R round() ко всем числовым столбцам, чтобы уточнить два знака после запятой.\n\ncombined &lt;- counts_table %&gt;%           # начинаем с таблицы подсчета\n  bind_cols(., model) %&gt;%              # объединяем с выходными данными регрессии \n  select(term, 2:3, estimate,          # выбираем и изменяем порядок столбцов\n         conf.low, conf.high, p.value) %&gt;% \n  mutate(across(where(is.numeric), round, digits = 2)) ## округляем до 2 знаков после запятой\n\nВот так выглядит объединенный датафрейм, красиво напечатанный в виде изображения с помощью функции из flextable. На странице Таблицы для презентации объясняется, как адаптировать такие таблицы с помощью flextable, либо вы можете использовать другие пакеты, такие как knitr или GT.\n\ncombined &lt;- combined %&gt;% \n  flextable::qflextable()\n\n\n\nСоздание цикла для нескольких однофакторных моделей\nНиже мы представим метод с использованием glm() и tidy() для более простого подхода, см. раздел gtsummary.\nЧтобы выполнить модели на нескольких переменных воздействия, чтобы получить однофакторные отношения шансов (т.е. без контроля по отношению друг к другу), вы можете использовать подход, описанный ниже. В нем используется str_c() из пакета stringr для создания однофакторных формул (см. Текст и последовательности), выполняется регрессия glm() для каждой формулы, каждый результат регрессии glm() передается в tidy() и наконец объединяются все результаты моделей с помощью bind_rows() из tidyr. Этот подход использует для итераций map() из пакета purrr - см. страницу Итерации, циклы и списки для более подробной информации об этом инструменте.\n\nСоздаем вектор имен столбцов независимых переменных. У нас уже есть explanatory_vars из раздела Подготовка на этой странице.\nИспользуем str_c(), чтобы создать несколько формул последовательности, при этом outcome будет в левой части, а название столбца из explanatory_vars - в правой. Точка . заменяет название столбца из explanatory_vars.\n\n\nexplanatory_vars %&gt;% str_c(\"outcome ~ \", .)\n\n[1] \"outcome ~ gender\"  \"outcome ~ fever\"   \"outcome ~ chills\" \n[4] \"outcome ~ cough\"   \"outcome ~ aches\"   \"outcome ~ vomit\"  \n[7] \"outcome ~ age_cat\"\n\n\n\nПередайте эти формулы-последовательности в map() и установите ~glm() в качестве функции, которая будет применяться к каждому входному параметру. Внутри glm() установите формулу регрессию как as.formula(.x), где .x будет заменяться на формулу-последовательность, определенную шагом выше. map() выполнит цикл для каждой из формул-последовательностей, выполнив для каждой регрессию.\nВыходные данные этой первой функции map() передаются во вторую команду map(), которая применяет tidy() к результатам регрессии.\nНаконец, выходные данные второй map() (список аккуратных датафреймов) сжимается с помощью bind_rows(), что приводит к созданию одного датафрейма со всеми однофакторными результатами.\n\n\nmodels &lt;- explanatory_vars %&gt;%       # начинаем с интересующей переменной\n  str_c(\"outcome ~ \", .) %&gt;%         # объединяем каждую переменную в формулу (\"исход (outcome) ~ интересующая переменная\")\n  \n  # проводим итерацию через каждую однофакторную формулу\n  map(                               \n    .f = ~glm(                       # по одной передаем формулы в glm()\n      formula = as.formula(.x),      # внутри glm() формула-последовательность - это .x\n      family = \"binomial\",           # уточняем тип glm (логистическая)\n      data = linelist)) %&gt;%          # набор данных\n  \n  # приводим результаты регрессий glm, сделанных выше, в аккуратный формат\n  map(\n    .f = ~tidy(\n      .x, \n      exponentiate = TRUE,           # возводим в степень \n      conf.int = TRUE)) %&gt;%          # получаем доверительные интервалы\n  \n  # сжимаем список выходных данных регрессии в один датафрейм\n  bind_rows() %&gt;% \n  \n  # округляем все числовые столбцы\n  mutate(across(where(is.numeric), round, digits = 2))\n\nВ этот раз конечный объект models длиннее, поскольку теперь представляет объединенные результаты нескольких однофакторных регрессий. Пролистайте все строки model.\n\n\n\n\n\n\nКак и ранее, мы создаем таблицу подсчета из linelist для каждой независимой переменной, связываем ее с models и создаем прекрасную таблицу. Мы начинаем с переменных, проводим по ним итерацию с помощью map(). Мы проводим итерацию по разным определенным пользователям функциям, что требует создания таблицы подсчета с помощью функций dplyr. Затем результаты объединяются и связываются с результатами модели models.\n\n## для каждой независимой переменной\nuniv_tab_base &lt;- explanatory_vars %&gt;% \n  map(.f = \n    ~{linelist %&gt;%                ## начинаем с построчного списка\n        group_by(outcome) %&gt;%     ## группируем набор данных по исходу\n        count(.data[[.x]]) %&gt;%    ## создаем подсчет по интересующей переменной\n        pivot_wider(              ## разворачиваем на широкий формат (как в кросс-табуляции)\n          names_from = outcome,\n          values_from = n) %&gt;% \n        drop_na(.data[[.x]]) %&gt;%         ## удаляем строки с отсутствующими значениями\n        rename(\"variable\" = .x) %&gt;%      ## меняем столбец интересующей переменной на \"variable\"\n        mutate(variable = as.character(variable))} ## конвертируем в текст, иначе недвоичные (категориальные) переменные выйдут, как фактор, и их нельзя будет объединить\n      ) %&gt;% \n  \n  ## сжимаем список выходных данных подсчетов в один датафрейм\n  bind_rows() %&gt;% \n  \n  ## объединяем с выходными данными регрессии \n  bind_cols(., models) %&gt;% \n  \n  ## сохраняем только интересующие нас столбцы \n  select(term, 2:3, estimate, conf.low, conf.high, p.value) %&gt;% \n  \n  ## округляем знаки после запятой\n  mutate(across(where(is.numeric), round, digits = 2))\n\nНиже представлен датафрейм. См. страницу Таблицы для презентации, чтобы ознакомиться с идеями о том, как еще конвертировать эту таблицу в красивую таблицу в HTML (например, с помощью flextable).\n\n\n\n\n\n\n\n\n\n\nПакет gtsummary\nНиже мы представляем использование tbl_uvregression() из пакета gtsummary. Как и на странице Описательные таблицы, функции gtsummary хорошо справляются с расчетом статистики и подготовкой профессионально выглядящих результатов. Эта функция создает таблицу результатов однофакторной регрессии.\nМы выбираем только необходимые столбцы из linelist (независимые переменные и переменная исхода) и подставляем их в tbl_uvregression(). Мы выполним однофакторную регрессию для каждого из столбцов, который мы определили как explanatory_vars на этапе Подготовки данных (пол, жар, озноб, кашель, боли, рвота, и возрастные категории age_cat).\nВнутри самой функции мы задаем method = как glm (без кавычек), y = столбец исхода (outcome), уточняем в method.args =, что мы хотим выполнить логистическую регрессию с помощью family = binomial, а также говорим, что нужно возвести результаты в степень\nВыходным результатом будет HTML, который содержит подсчеты\n\nuniv_tab &lt;- linelist %&gt;% \n  dplyr::select(explanatory_vars, outcome) %&gt;% ## выбираем интересующие переменные\n\n  tbl_uvregression(                         ## создаем однофакторную таблицу\n    method = glm,                           ## задаем, какую регрессию выполнить (обобщенная линейная модель)\n    y = outcome,                            ## задаем переменную исхода\n    method.args = list(family = binomial),  ## dопределяем, какой тип glm надо выполнить (логистическая)\n    exponentiate = TRUE                     ## возводим в степень, чтобы получить отношения шансов (а не логарифм отношения шансов)\n  )\n\n## просматриваем таблицу однофакторных результатов \nuniv_tab\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nN\nOR1\n95% CI1\np-value\n\n\n\n\ngender\n4,167\n1.00\n0.88, 1.13\n&gt;0.9\n\n\nfever\n4,167\n1.00\n0.85, 1.17\n&gt;0.9\n\n\nchills\n4,167\n1.03\n0.89, 1.21\n0.7\n\n\ncough\n4,167\n1.15\n0.97, 1.37\n0.11\n\n\naches\n4,167\n0.93\n0.76, 1.14\n0.5\n\n\nvomit\n4,167\n1.09\n0.96, 1.23\n0.2\n\n\nage_cat\n4,167\n\n\n\n\n\n\n\n\n    0-4\n\n\n—\n—\n\n\n\n\n    5-9\n\n\n0.94\n0.77, 1.15\n0.5\n\n\n    10-14\n\n\n1.15\n0.93, 1.42\n0.2\n\n\n    15-19\n\n\n0.99\n0.80, 1.24\n&gt;0.9\n\n\n    20-29\n\n\n1.03\n0.84, 1.26\n0.8\n\n\n    30-49\n\n\n1.07\n0.85, 1.33\n0.6\n\n\n    50-69\n\n\n0.68\n0.41, 1.13\n0.13\n\n\n    70+\n\n\n0.53\n0.07, 3.20\n0.5\n\n\n\n1 OR = Odds Ratio, CI = Confidence Interval\n\n\n\n\n\n\n\n\n\nС этими выходными данными вы можете сделать множество модификаций, например, адаптировать текстовые подписи, выделить строки жирным в зависимости от их p-значений и т.п. См. самоучители тут и в других онлайн источниках.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Однофакторная и многофакторная регрессия</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.ru.html#стратифицированный",
    "href": "new_pages/regression.ru.html#стратифицированный",
    "title": "19  Однофакторная и многофакторная регрессия",
    "section": "19.3 Стратифицированный",
    "text": "19.3 Стратифицированный\nСтратифицированный анализ в настоящее время разрабатывается для gtsummary, эта страница будет обновляться.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Однофакторная и многофакторная регрессия</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.ru.html#многофакторный",
    "href": "new_pages/regression.ru.html#многофакторный",
    "title": "19  Однофакторная и многофакторная регрессия",
    "section": "19.4 Многофакторный",
    "text": "19.4 Многофакторный\nДля многофакторного анализа мы также представим два подхода:\n\nglm() и tidy()\n\nпакет gtsummary\n\nПоток работ будет похож для них, отличаться будет только последний шаг свода в итоговую таблицу.\n\nПроведение многофакторного анализа\nЗдесь мы используем glm(), но добавляем больше переменных для анализа в правой стороне уравнения, отделяя символом плюс (+).\nЧтобы выполнить модель со всеми независимыми переменными, мы выполним:\n\nmv_reg &lt;- glm(outcome ~ gender + fever + chills + cough + aches + vomit + age_cat, family = \"binomial\", data = linelist)\n\nsummary(mv_reg)\n\n\nCall:\nglm(formula = outcome ~ gender + fever + chills + cough + aches + \n    vomit + age_cat, family = \"binomial\", data = linelist)\n\nCoefficients:\n              Estimate Std. Error z value Pr(&gt;|z|)\n(Intercept)   0.069054   0.131726   0.524    0.600\ngender        0.002448   0.065133   0.038    0.970\nfever         0.004309   0.080522   0.054    0.957\nchills        0.034112   0.078924   0.432    0.666\ncough         0.138584   0.089909   1.541    0.123\naches        -0.070705   0.104078  -0.679    0.497\nvomit         0.086098   0.062618   1.375    0.169\nage_cat5-9   -0.063562   0.101851  -0.624    0.533\nage_cat10-14  0.136372   0.107275   1.271    0.204\nage_cat15-19 -0.011074   0.113640  -0.097    0.922\nage_cat20-29  0.026552   0.102780   0.258    0.796\nage_cat30-49  0.059569   0.116402   0.512    0.609\nage_cat50-69 -0.388964   0.262384  -1.482    0.138\nage_cat70+   -0.647443   0.917375  -0.706    0.480\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 5712.4  on 4166  degrees of freedom\nResidual deviance: 5700.2  on 4153  degrees of freedom\nAIC: 5728.2\n\nNumber of Fisher Scoring iterations: 4\n\n\nЕсли вы хотите включить две переменные и взаимодействие между ними, вы можете отделить их звездочкой * вместо +. Отделяйте их двоеточием :, если вы только уточняете взаимодействие. Например:\n\nglm(outcome ~ gender + age_cat * fever, family = \"binomial\", data = linelist)\n\nОпционально вы можете использовать этот код, чтобы воспользоваться заранее определенным вектором имен столбцов и воссоздать использованную выше команду с помощью str_c(). Это может быть полезным, если у вас меняются имена независимых переменных или если вы не хотите их все снова печатать.\n\n## выполняем регрессию со всеми интересующими переменными \nmv_reg &lt;- explanatory_vars %&gt;%  ## начинаем с вектора имен столбцов независимых переменных\n  str_c(collapse = \"+\") %&gt;%     ## объединяем все имена интересующих переменных, которые отделяются плюсом\n  str_c(\"outcome ~ \", .) %&gt;%    ## объединяем имена интересующих переменных с исходом в стиле формулы\n  glm(family = \"binomial\",      ## задаем тип glm как логистическую регрессию,\n      data = linelist)          ## определяем набор данных\n\n\nПостроение модели\nВы можете построить свою модель шаг за шагом, сохраняя разные модели, которые включают определенные независимые переменные. Вы можете сравнить эти модели с помощью тестов на отношение правдоподобия, используя lrtest() из пакета lmtest, как показано ниже:\nПРИМЕЧАНИЕ: Использование базовой функции anova(model1, model2, test = \"Chisq) даст те же результаты \n\nmodel1 &lt;- glm(outcome ~ age_cat, family = \"binomial\", data = linelist)\nmodel2 &lt;- glm(outcome ~ age_cat + gender, family = \"binomial\", data = linelist)\n\nlmtest::lrtest(model1, model2)\n\nLikelihood ratio test\n\nModel 1: outcome ~ age_cat\nModel 2: outcome ~ age_cat + gender\n  #Df  LogLik Df Chisq Pr(&gt;Chisq)\n1   8 -2852.6                    \n2   9 -2852.6  1 2e-04     0.9883\n\n\nЕще один вариант - взять объект модели и применить функцию step() из пакета stats. При построении этой модели уточните, какое направление выбора переменной вы хотите использовать.\n\n## выберите модель, используя выбор вперед на основе критерия AIC\n## вы также можете сделать выбор \"назад\" (\"backward\") или в обе стороны (\"both\"), исправив направление\nfinal_mv_reg &lt;- mv_reg %&gt;%\n  step(direction = \"forward\", trace = FALSE)\n\nВы также можете отключить экспоненциальный формат записи в вашей сессии R для ясности:\n\noptions(scipen=999)\n\nКак описывается в разделе по однофакторнуму анализу, передайте выходные данные модели в tidy(), чтобы возвести в степень логарифмы отношения шансов и ДИ. Наконец, мы округляем все числовые столбцы до двух знаков после запятой. Просмотрите все строки.\n\nmv_tab_base &lt;- final_mv_reg %&gt;% \n  broom::tidy(exponentiate = TRUE, conf.int = TRUE) %&gt;%  ## получаем аккуратный датафрейм с оценками \n  mutate(across(where(is.numeric), round, digits = 2))          ## округляем \n\nВот как выглядит получившийся датафрейм:\n\n\n\n\n\n\n\n\n\n\nОбъединение однофакторного и многофакторного анализа\n\nОбъединяем с помощью gtsummary\nВ пакете gtsummary есть функция tbl_regression(), которая берет выходные результаты регрессии (в данном случае glm()) и создает хорошую суммарную таблицу.\n\n## показываем таблицу результатов итоговой регрессии \nmv_tab &lt;- tbl_regression(final_mv_reg, exponentiate = TRUE)\n\nДавайте посмотрим таблицу:\n\nmv_tab\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nOR1\n95% CI1\np-value\n\n\n\n\ngender\n1.00\n0.88, 1.14\n&gt;0.9\n\n\nfever\n1.00\n0.86, 1.18\n&gt;0.9\n\n\nchills\n1.03\n0.89, 1.21\n0.7\n\n\ncough\n1.15\n0.96, 1.37\n0.12\n\n\naches\n0.93\n0.76, 1.14\n0.5\n\n\nvomit\n1.09\n0.96, 1.23\n0.2\n\n\nage_cat\n\n\n\n\n\n\n\n\n    0-4\n—\n—\n\n\n\n\n    5-9\n0.94\n0.77, 1.15\n0.5\n\n\n    10-14\n1.15\n0.93, 1.41\n0.2\n\n\n    15-19\n0.99\n0.79, 1.24\n&gt;0.9\n\n\n    20-29\n1.03\n0.84, 1.26\n0.8\n\n\n    30-49\n1.06\n0.85, 1.33\n0.6\n\n\n    50-69\n0.68\n0.40, 1.13\n0.14\n\n\n    70+\n0.52\n0.07, 3.19\n0.5\n\n\n\n1 OR = Odds Ratio, CI = Confidence Interval\n\n\n\n\n\n\n\n\n\nВы также можете объединять несколько разных таблиц выходных результатов, созданных gtsummary с помощью функции tbl_merge(). Сейчас мы объединим результаты многофакторного анализа с помощью gtsummary с результатам однофакторного анализа, который мы создали выше:\n\n## объединяем с результатами однофакторного анализа \ntbl_merge(\n  tbls = list(univ_tab, mv_tab),                          # объединяем\n  tab_spanner = c(\"**Univariate**\", \"**Multivariable**\")) # задаем имена заголовков\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nUnivariate\nMultivariable\n\n\nN\nOR1\n95% CI1\np-value\nOR1\n95% CI1\np-value\n\n\n\n\ngender\n4,167\n1.00\n0.88, 1.13\n&gt;0.9\n1.00\n0.88, 1.14\n&gt;0.9\n\n\nfever\n4,167\n1.00\n0.85, 1.17\n&gt;0.9\n1.00\n0.86, 1.18\n&gt;0.9\n\n\nchills\n4,167\n1.03\n0.89, 1.21\n0.7\n1.03\n0.89, 1.21\n0.7\n\n\ncough\n4,167\n1.15\n0.97, 1.37\n0.11\n1.15\n0.96, 1.37\n0.12\n\n\naches\n4,167\n0.93\n0.76, 1.14\n0.5\n0.93\n0.76, 1.14\n0.5\n\n\nvomit\n4,167\n1.09\n0.96, 1.23\n0.2\n1.09\n0.96, 1.23\n0.2\n\n\nage_cat\n4,167\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    0-4\n\n\n—\n—\n\n\n—\n—\n\n\n\n\n    5-9\n\n\n0.94\n0.77, 1.15\n0.5\n0.94\n0.77, 1.15\n0.5\n\n\n    10-14\n\n\n1.15\n0.93, 1.42\n0.2\n1.15\n0.93, 1.41\n0.2\n\n\n    15-19\n\n\n0.99\n0.80, 1.24\n&gt;0.9\n0.99\n0.79, 1.24\n&gt;0.9\n\n\n    20-29\n\n\n1.03\n0.84, 1.26\n0.8\n1.03\n0.84, 1.26\n0.8\n\n\n    30-49\n\n\n1.07\n0.85, 1.33\n0.6\n1.06\n0.85, 1.33\n0.6\n\n\n    50-69\n\n\n0.68\n0.41, 1.13\n0.13\n0.68\n0.40, 1.13\n0.14\n\n\n    70+\n\n\n0.53\n0.07, 3.20\n0.5\n0.52\n0.07, 3.19\n0.5\n\n\n\n1 OR = Odds Ratio, CI = Confidence Interval\n\n\n\n\n\n\n\n\n\n\n\nОбъединение с помощью dplyr\nАльтернативным способом объединения результатов однофакторного и многофакторного анализа glm()/tidy() будет использование функций соединения из dplyr.\n\nОбъединяем полученные ранее результаты однофакторного анализа (univ_tab_base, где содержится подсчет) с аккуратными результатами многофакторного анализа mv_tab_base\n\nИспользуем select(), чтобы сохранить только те столбцы, которые нам нужны, уточнить их порядок и переименовать их\n\nИспользуем round(), чтобы задать два знака после запятой всем столбцам в классе Double (число двойной точности)\n\n\n## объединяем однофакторную и многофакторную таблицу \nleft_join(univ_tab_base, mv_tab_base, by = \"term\") %&gt;% \n  ## выбираем столбцы и переименовываем\n  select( # новое имя =  старое имя\n    \"characteristic\" = term, \n    \"recovered\"      = \"0\", \n    \"dead\"           = \"1\", \n    \"univ_or\"        = estimate.x, \n    \"univ_ci_low\"    = conf.low.x, \n    \"univ_ci_high\"   = conf.high.x,\n    \"univ_pval\"      = p.value.x, \n    \"mv_or\"          = estimate.y, \n    \"mvv_ci_low\"     = conf.low.y, \n    \"mv_ci_high\"     = conf.high.y,\n    \"mv_pval\"        = p.value.y \n  ) %&gt;% \n  mutate(across(where(is.double), round, 2))   \n\n# A tibble: 20 × 11\n   characteristic recovered  dead univ_or univ_ci_low univ_ci_high univ_pval\n   &lt;chr&gt;              &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;     &lt;dbl&gt;\n 1 (Intercept)          909  1168    1.28        1.18         1.4       0   \n 2 gender               916  1174    1           0.88         1.13      0.97\n 3 (Intercept)          340   436    1.28        1.11         1.48      0   \n 4 fever               1485  1906    1           0.85         1.17      0.99\n 5 (Intercept)         1472  1877    1.28        1.19         1.37      0   \n 6 chills               353   465    1.03        0.89         1.21      0.68\n 7 (Intercept)          272   309    1.14        0.97         1.34      0.13\n 8 cough               1553  2033    1.15        0.97         1.37      0.11\n 9 (Intercept)         1636  2114    1.29        1.21         1.38      0   \n10 aches                189   228    0.93        0.76         1.14      0.51\n11 (Intercept)          931  1144    1.23        1.13         1.34      0   \n12 vomit                894  1198    1.09        0.96         1.23      0.17\n13 (Intercept)          338   427    1.26        1.1          1.46      0   \n14 age_cat5-9           365   433    0.94        0.77         1.15      0.54\n15 age_cat10-14         273   396    1.15        0.93         1.42      0.2 \n16 age_cat15-19         238   299    0.99        0.8          1.24      0.96\n17 age_cat20-29         345   448    1.03        0.84         1.26      0.79\n18 age_cat30-49         228   307    1.07        0.85         1.33      0.58\n19 age_cat50-69          35    30    0.68        0.41         1.13      0.13\n20 age_cat70+             3     2    0.53        0.07         3.2       0.49\n# ℹ 4 more variables: mv_or &lt;dbl&gt;, mvv_ci_low &lt;dbl&gt;, mv_ci_high &lt;dbl&gt;,\n#   mv_pval &lt;dbl&gt;",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Однофакторная и многофакторная регрессия</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.ru.html#форест-график",
    "href": "new_pages/regression.ru.html#форест-график",
    "title": "19  Однофакторная и многофакторная регрессия",
    "section": "19.5 Форест-график",
    "text": "19.5 Форест-график\nЭтот раздел показывает, как создать график с результатами вашей регрессии. Есть две опции, вы можете построить график самостоятельно с помощью ggplot2 или использовать мета-пакет под названием easystats (пакет, который включает много пакетов).\nСм. страницу Основы ggplot, если вы не знакомы с пакетом построения графиков ggplot2.\n\n\nПакет ggplot2\nВы можете построить форест-график с помощью ggplot(), построив график с результатами многофакторной регрессии. Добавляйте слои на графики с помощью “геомов”:\n\nоценочные данные с помощью geom_point()\n\nдоверительные интервалы с помощью geom_errorbar()\n\nвертикальная линия на ОШ = 1 с geom_vline()\n\nПрежде чем построить график, возможно нужно использовать fct_relevel() из пакета forcats, чтобы задать порядок переменных/уровни на оси y. ggplot() может отобразить их в буквенно-числовом порядке, который не очень хорошо работает для значений возрастных категорий (“30” будет раньше, чем “5”). См. дополнительную информацию на странице Факторы.\n\n## удаляем свободный член из результатов многофакторного анализа\nmv_tab_base %&gt;% \n  \n  #задаем порядок уровней по оси y\n  mutate(term = fct_relevel(\n    term,\n    \"vomit\", \"gender\", \"fever\", \"cough\", \"chills\", \"aches\",\n    \"age_cat5-9\", \"age_cat10-14\", \"age_cat15-19\", \"age_cat20-29\",\n    \"age_cat30-49\", \"age_cat50-69\", \"age_cat70+\")) %&gt;%\n  \n  # удаляем строку \"intercept\" из графика\n  filter(term != \"(Intercept)\") %&gt;% \n  \n  ## строим график с переменной по оси y и оценочным показателем (ОШ) по оси x\n  ggplot(aes(x = estimate, y = term)) +\n  \n  ## показываем оценку как точку\n  geom_point() + \n  \n  ## добавляем столбец ошибки для доверительных интервалов\n  geom_errorbar(aes(xmin = conf.low, xmax = conf.high)) + \n  \n  ## показываем, где ОШ = 1 в виде пунктирной линии для справки\n  geom_vline(xintercept = 1, linetype = \"dashed\")\n\n\n\n\n\n\n\n\n\n\n\nПакеты easystats\nВ качестве альтернативы, если вам не нужен такой детальный уровень контроля, как дает ggplot2, можно использовать комбинацию пакетов easystats.\nФункция model_parameters() из parameters выполняет действия, эквивалентные функции tidy() из пакета broom. Пакет see затем принимает эти выходные данные и создает форест-график по умолчанию в виде объекта ggplot().\n\npacman::p_load(easystats)\n\n## удаляем свободный член из результатов многофакторного анализа\nfinal_mv_reg %&gt;% \n  model_parameters(exponentiate = TRUE) %&gt;% \n  plot()",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Однофакторная и многофакторная регрессия</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.ru.html#ресурсы",
    "href": "new_pages/regression.ru.html#ресурсы",
    "title": "19  Однофакторная и многофакторная регрессия",
    "section": "19.6 Ресурсы",
    "text": "19.6 Ресурсы\nИнформация для содержания этой страницы была взята из следующих онлайн ресурсов и виньеток:\nЛинейная регрессия в R\ngtsummary\nСтраница по статистике UCLA\nПошаговая регрессия sthda",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Однофакторная и многофакторная регрессия</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.ru.html",
    "href": "new_pages/missing_data.ru.html",
    "title": "20  Отсутствующие данные",
    "section": "",
    "text": "20.1 Подготовка",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Отсутствующие данные</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.ru.html#подготовка",
    "href": "new_pages/missing_data.ru.html#подготовка",
    "title": "20  Отсутствующие данные",
    "section": "",
    "text": "Загрузка пакетов\nДанный фрагмент кода показывает загрузку пакетов, необходимых для анализа. В данном руководстве мы фокусируемся на использовании p_load() из пакета pacman, которая устанавливает пакет, если необходимо, и загружает его для использования. Вы можете также загрузить установленные пакеты с помощью library() из базового R. См. страницу Основы R для получения дополнительной информации о пакетах R.\n\npacman::p_load(\n  rio,           # импорт/экспорт\n  tidyverse,     # управление данными и визуализация\n  naniar,        # оценка и визуализация отсутствующих данных\n  mice           # вменение отсутствующих данных\n)\n\n\n\nИмпорт данных\nМы импортируем набор данных о случаях имитированной эпидемии Эболы. Если вы хотите выполнять действия параллельно, кликните, чтобы скачать “чистый” построчный список (как файл .rds). Импортируйте данный с помощью функции import() из пакета rio (он работает с многими типами файлов, такими как .xlsx, .csv, .rds - см. детали на странице Импорт и экспорт).\n\n# импортируем построчный список\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nПервые 50 строк построчного списка отображены ниже.\n\n\n\n\n\n\n\n\nКонвертируем отсутствующие данные при импорте\nПри импорте ваших данных помните о значениях, которые следует классифицировать как отсутствующие. Например, 99, 999, “Missing”, пустые ячейки (““), либо ячейки с пустым пространством (” “). Вы можете их конвертировать в NA (версия обозначения отсутствующих данных в R) в рамках команды импорта.\nСм. страницу Импорт раздел Отсутствующие данные для получения детальной информации, так как точный синтаксис будет варьироваться в зависимости от типа файла.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Отсутствующие данные</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.ru.html#отсутствующие-значения-в-r",
    "href": "new_pages/missing_data.ru.html#отсутствующие-значения-в-r",
    "title": "20  Отсутствующие данные",
    "section": "20.2 Отсутствующие значения в R",
    "text": "20.2 Отсутствующие значения в R\nНиже мы рассматриваем способы представления и оценки отсутствия данных в R, а также некоторые смежные значения и функции.\n\nNA\nВ R отсутствующие значения представлены зарезервированным (специальным) значением - NA. Обратите внимание, что оно печатается без кавычек. “NA” отличается от него и является просто обычным текстовым значениям (а также строчкой из песни Beatles - Hey Jude).\nВ ваших данных могут быть другие способы представления отсутствующих данных, например, “99”, либо “Missing” (отсутствует), либо “Unknown” (неизвестно) - у вас даже может быть пустое текстовое значение ““, которое кажется”пустым”, либо один пробел ” “. Помните о таких значениях и подумайте, надо ли конвертировать их в NA при импорте или при вычистке данных с помощью na_if().\nПри вычистке данных вы можете также конвертировать в противоположном направлении - изменить все NA на “Missing” или нечто похожее с помощью replace_na() или fct_explicit_na() для факторов.\n\n\nВерсии NA\nВ большинстве случаев NA представляет отсутствующее значение и все прекрасно работает. Однако в некоторых ситуациях вы можете столкнуться с необходимостью в вариациях NA для конкретного класса объекта (текстовый, числовой и т.п.). Это случается редко, но вам следует об этом знать.\nТипичный сценарий этого - создание нового столбца с помощью функции dplyr case_when(). Как описывается на странице Вычистка данных и ключевые функции, эта функция оценивает каждую строку датафрейма, оценивает, соответствуют ли строки конкретным логическим критериям (правая сторона кода), и присваивает правильное новое значение (левая сторона кода). Важно: все значения в правой стороне должны быть одного класса.\n\nlinelist &lt;- linelist %&gt;% \n  \n  # Создайте новый столбец \"age_years\" из столбца \"age\"\n  mutate(age_years = case_when(\n    age_unit == \"years\"  ~ age,       # если возраст приведен в годах, присвоить оригинальное значение\n    age_unit == \"months\" ~ age/12,    # если возраст приведен в месяцах, разделить на 12\n    is.na(age_unit)      ~ age,       # если отсутствует ЕДИНИЦА возраста, предположить годы\n    TRUE                 ~ NA_real_)) # в любых других обстоятельствах, присвоить отсутствующее значение\n\nЕсли вам нужно NA с правой стороны, возможно вам потребуется уточнить одну из специальных опций NA, указанных ниже. Если другие значения в правой стороны являются текстовыми, рассмотрите возможность использования “Missing” вместо этого, либо используйте NA_character_. Если значения числовые - используйте NA_real_. Если они все являются датами или логическими, вы можете использовать NA.\n\nNA - используется для данных или логических TRUE/FALSE (ИСТИНА/ЛОЖЬ)\nNA_character_ - используется для текстовых значений\n\nNA_real_ - используется для числовых значений\n\nОпять же, вы вряд ли столкнетесь с этими вариациями, кроме случаев, когда вы используете case_when() для создания нового столбца. См. Документацию R по NA для получения более подробной информации.\n\n\nNULL\nNULL - еще одно зарезервированное значение в R. Это логическое представление утверждения, которое не является ни истиной, ни ложью. Оно выдается выражениями или функциями, чье значение не определено. Как правило, не присваивайте NULL значение, кроме случаев написания функций или использования [приложения shiny][Информационные панели с Shiny], чтобы выдать NULL в конкретных сценариях.\nНеопределенное значение Null можно оценить с помощью is.null(), а конвертацию можно сделать с as.null().\nСм. этот пост в блоге, где обсуждаются различия между NULL и NA.\n\n\nNaN\nНевозможные значения представлены специальным значением NaN. Примером может быть ситуация, когда вы заставляете R разделить 0 на 0. Вы можете это оценить с помощью is.nan(). Вы можете также столкнуться с дополнительными функциями, включая is.infinite() и is.finite().\n\n\nInf\nInf представляет бесконечное значение, например, когда вы делите число на 0.\nВ качестве примера того, как это может повлиять на вашу работу: представим, что у вас есть вектор/столбец z, который содержит эти значения: z &lt;- c(1, 22, NA, Inf, NaN, 5)\nЕсли вы хотите использовать max() для столбца, чтобы найти наибольшее значение, вы можете использовать na.rm = TRUE, чтобы удалить NA из расчета, но Inf и NaN останутся, и будет выдано Inf. Чтобы решить эту проблему, вы можете использовать квадратные скобки [ ] и is.finite(), чтобы создать подмножество таким образом, чтобы для расчета использовались только конечные значения: max(z[is.finite(z)]).\n\nz &lt;- c(1, 22, NA, Inf, NaN, 5)\nmax(z)                           # выдает NA\nmax(z, na.rm=T)                  # выдает Inf\nmax(z[is.finite(z)])             # выдает 22\n\n\n\nПримеры\n\n\n\n\n\n\n\nКоманда R\nРезультат\n\n\n\n\n5 / 0\nInf\n\n\n0 / 0\nNaN\n\n\n5 / NA\nNA\n\n\n5 / Inf |0NA - 5|NAInf / 5|Infclass(NA)| \"logical\" (логический)class(NaN)| \"numeric\" (числовой)class(Inf)| \"numeric\" (числовой)class(NULL)`\n“NULL”\n\n\n\n“NAs introduced by coercion” (NA вводятся принудительно) - частое предупреждение. Это может произойти, если вы пытаетесь провести недопустимую конвертацию, например, вставить текстовое значение в вектор, который является числовым.\n\nas.numeric(c(\"10\", \"20\", \"thirty\", \"40\"))\n\nWarning: NAs introduced by coercion\n\n\n[1] 10 20 NA 40\n\n\nNULL игнорируется в векторе.\n\nmy_vector &lt;- c(25, NA, 10, NULL)  # определяем\nmy_vector                         # печатаем\n\n[1] 25 NA 10\n\n\nДисперсия одного числа выдает NA.\n\nvar(22)\n\n[1] NA",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Отсутствующие данные</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.ru.html#полезные-функции",
    "href": "new_pages/missing_data.ru.html#полезные-функции",
    "title": "20  Отсутствующие данные",
    "section": "20.3 Полезные функции",
    "text": "20.3 Полезные функции\nНиже приведены полезные функции базового R для оценки или работы с отсутствующими значениями:\n\nis.na() и !is.na()\nИспользуйте is.na() для определения отсутствующих значений, либо используйте ее противоположность (поставив в начале !), чтобы определить не отсутствующие значения. Обе этих команды выдают логическое значение (TRUE или FALSE). Помните, что вы можете использовать sum() для получившегося вектора, чтобы посчитать количество результатов TRUE, например, sum(is.na(linelist$date_outcome)).\n\nmy_vector &lt;- c(1, 4, 56, NA, 5, NA, 22)\nis.na(my_vector)\n\n[1] FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE\n\n!is.na(my_vector)\n\n[1]  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\n\nsum(is.na(my_vector))\n\n[1] 2\n\n\n\n\nna.omit()\nЭта функция, при применении к датафрейму, удалит строки с любыми отсутствующими значениями. Она также из базового R.\nПри применении к вектору, она удалит значения NA из вектора, к которому она применена. Например:\n\nna.omit(my_vector)\n\n[1]  1  4 56  5 22\nattr(,\"na.action\")\n[1] 4 6\nattr(,\"class\")\n[1] \"omit\"\n\n\n\n\ndrop_na()\nЭто функция из tidyr, которая полезна в [цепочке канала вычистки данных][Вычистка данных и ключевые функции]. При выполнении с пустыми скобками, она удаляет строки с любыми отсутствующими значениями. Если указаны названия столбцов в скобках, удалены будут строки с отсутствующими значениями в этих столбцах. Вы можете также использовать синтаксис “tidyselect”, чтобы уточнить столбцы.\n\nlinelist %&gt;% \n  drop_na(case_id, date_onset, age) # удаляет строки с отсутствующими значениями в любом из этих столбцов\n\n\n\nna.rm = TRUE\nКогда вы выполняете математическую функцию, такую как max(), min(), sum() или mean(), если присутствуют значения NA, она выдаст значение NA. Это поведение по умолчанию определено намерено, чтобы вы увидели, что отсутствуют какие-то данные.\nВы можете этого избежать, удалив отсутствующие значения из расчета. Чтобы это сделать, включите аргумент na.rm = TRUE (“na.rm” означает “remove NA” (удалить NA)).\n\nmy_vector &lt;- c(1, 4, 56, NA, 5, NA, 22)\n\nmean(my_vector)     \n\n[1] NA\n\nmean(my_vector, na.rm = TRUE)\n\n[1] 17.6",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Отсутствующие данные</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.ru.html#оценка-отсутствующих-данных-в-датафрейме",
    "href": "new_pages/missing_data.ru.html#оценка-отсутствующих-данных-в-датафрейме",
    "title": "20  Отсутствующие данные",
    "section": "20.4 Оценка отсутствующих данных в датафрейме",
    "text": "20.4 Оценка отсутствующих данных в датафрейме\nВы можетеиспользовать пакет naniar, чтобы оценить и визуализировать отсутствующие данные в датафрейме linelist.\n\n# устанавливаем и/или загружаем пакет\npacman::p_load(naniar)\n\n\nКоличественное выражение отсутствующих данных\nЧтобы найти процент всех значений, которые отсутствуют, используйте pct_miss(). Используйте n_miss(), чтобы получить число отсутствующих значений.\n\n# процент отсутствующих значений от ВСЕХ значений датафрейма\npct_miss(linelist)\n\n[1] 6.688745\n\n\nДве функции, представленные ниже, выдают процент строк с любыми отсутствующими значениями, либо тех, которые заполнены полностью, соответственно. Помните, что NA означает отсутствующие, а `\"\" или \" \" не будут считаться отсутствующими.\n\n# Процент строк с любым отсутствующим значением\npct_miss_case(linelist)   # используйте n_complete() для подсчета абсолютного количества\n\n[1] 69.12364\n\n\n\n# Процент строк, которые являются полными (без отсутствующих значений)  \npct_complete_case(linelist) # используйте n_complete() для подсчета абсолютного количества\n\n[1] 30.87636\n\n\n\n\nВизуализация отсутствующих данных\nФункция gg_miss_var() покажет вам количество (или %) отсутствующих значений в каждом столбце. Несколько нюансов:\n\nВы можете добавить имя столбца (не в кавычках) в аргумент facet =, чтобы увидеть график по группам\n\nПо умолчанию показывается абсолютное количество, а не проценты, это можно изменить с помощью show_pct = TRUE\n\nВы можете добавить подписи осей и заголовок как в обычном ggplot() с помощью + labs(...)\n\n\ngg_miss_var(linelist, show_pct = TRUE)\n\n\n\n\n\n\n\n\nЗдесь данные передаются по каналу %&gt;% в функцию. Аргумент facet = также используется для разделения данных.\n\nlinelist %&gt;% \n  gg_miss_var(show_pct = TRUE, facet = outcome)\n\n\n\n\n\n\n\n\nВы можете использовать vis_miss(), чтобы визуализировать датафрейм в виде тепловой карты, показывая отсутствует ли каждое значение. Вы также можете выбрать некоторые столбцы из датафрейма с помощью select() и передать только эти столбцы в функцию.\n\n# Тепловая карта отсутствующих данных по всему датафрейму  \nvis_miss(linelist)\n\n\n\n\n\n\n\n\n\n\nИзучение и визуализация отношений отсутствия данных\nКак визуализировать то, чего нет??? По умолчанию ggplot() удаляет точки с отсутствующими значениями с графиков.\nnaniar предлагает решение с помощью geom_miss_point(). При создании диаграммы рассеяния двух столбцов записи с одним отсутствующим значением и одним присутствующим значением показаны с помощью установки отсутствуюдщего значения на 10% ниже самого меньшего значения в столбце и закрашивания их отдельным цветом.\nВ диаграмме рассеяния ниже, красные точки - записи, где значение одного столбца присутствует, а значение другого - отсутствует. Это позволяет вам увидеть распределение отсутствующих значений относительно неотсутствующих значений.\n\nggplot(\n  data = linelist,\n  mapping = aes(x = age_years, y = temp)) +     \n  geom_miss_point()\n\n\n\n\n\n\n\n\nЧтобы оценить отсутствующие значения в датафрейме, стратифицированном по другому столбцу, рассмотрите возможность применения gg_miss_fct(), которая выдаст тепловую карту процента отсутствия значений в датафрейме по фактору/категориальному столбцу (или дате):\n\ngg_miss_fct(linelist, age_cat5)\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `age_cat5 = (function (x) ...`.\nCaused by warning:\n! `fct_explicit_na()` was deprecated in forcats 1.0.0.\nℹ Please use `fct_na_value_to_level()` instead.\nℹ The deprecated feature was likely used in the naniar package.\n  Please report the issue at &lt;https://github.com/njtierney/naniar/issues&gt;.\n\n\n\n\n\n\n\n\n\nЭта функция может также использоваться со столбцом даты, чтобы посмотреть, как отсутствие данных меняется со временем:\n\ngg_miss_fct(linelist, date_onset)\n\nWarning: Removed 29 rows containing missing values or values outside the scale range\n(`geom_tile()`).\n\n\n\n\n\n\n\n\n\n\n\n“Теневые” столбцы\nЕще один способ визуализации отсутствия данных в годном столбце по значениям во втором столбце - использовать “тень”, которую может создать naniar. bind_shadow() создает двоичный столбец NA/не NA для каждого существующего столбца и связывает эти новые столбцы с оригинальным набором данных с помощью добавления “_NA”. Это удваивает число столбцов - см. ниже:\n\nshadowed_linelist &lt;- linelist %&gt;% \n  bind_shadow()\n\nnames(shadowed_linelist)\n\n [1] \"case_id\"                 \"generation\"             \n [3] \"date_infection\"          \"date_onset\"             \n [5] \"date_hospitalisation\"    \"date_outcome\"           \n [7] \"outcome\"                 \"gender\"                 \n [9] \"age\"                     \"age_unit\"               \n[11] \"age_years\"               \"age_cat\"                \n[13] \"age_cat5\"                \"hospital\"               \n[15] \"lon\"                     \"lat\"                    \n[17] \"infector\"                \"source\"                 \n[19] \"wt_kg\"                   \"ht_cm\"                  \n[21] \"ct_blood\"                \"fever\"                  \n[23] \"chills\"                  \"cough\"                  \n[25] \"aches\"                   \"vomit\"                  \n[27] \"temp\"                    \"time_admission\"         \n[29] \"bmi\"                     \"days_onset_hosp\"        \n[31] \"case_id_NA\"              \"generation_NA\"          \n[33] \"date_infection_NA\"       \"date_onset_NA\"          \n[35] \"date_hospitalisation_NA\" \"date_outcome_NA\"        \n[37] \"outcome_NA\"              \"gender_NA\"              \n[39] \"age_NA\"                  \"age_unit_NA\"            \n[41] \"age_years_NA\"            \"age_cat_NA\"             \n[43] \"age_cat5_NA\"             \"hospital_NA\"            \n[45] \"lon_NA\"                  \"lat_NA\"                 \n[47] \"infector_NA\"             \"source_NA\"              \n[49] \"wt_kg_NA\"                \"ht_cm_NA\"               \n[51] \"ct_blood_NA\"             \"fever_NA\"               \n[53] \"chills_NA\"               \"cough_NA\"               \n[55] \"aches_NA\"                \"vomit_NA\"               \n[57] \"temp_NA\"                 \"time_admission_NA\"      \n[59] \"bmi_NA\"                  \"days_onset_hosp_NA\"     \n\n\nЭти “теневые” столбцы могут использоваться, чтобы построить график доли отсутствующих значений по другому столбцу.\nНапример, график ниже показывает долю отсутствующих записей days_onset_hosp (количество дней с появления симптомов до госпитализации), по значению этой записи в date_hospitalisation. По сути, вы строите диаграмму плотности столбца оси x, но стратифицируете результаты (color =) по интересующему теневому столбцу. Этот анализ лучше всего работает, если ваша ось x является числовым столбцом или датой.\n\nggplot(data = shadowed_linelist,          # датафрейм с теневыми столбцами\n  mapping = aes(x = date_hospitalisation, # числовой столбец или столбец даты\n                colour = age_years_NA)) + # интересующий теневой столбец\n  geom_density()                          # график кривых плотности\n\n\n\n\n\n\n\n\nВы также можете использовать эти “теневые” столбцы для стратификации статистической сводной информации, как показано ниже:\n\nlinelist %&gt;%\n  bind_shadow() %&gt;%                # создаем теневые столбцы\n  group_by(date_outcome_NA) %&gt;%    # теневой столбец для стратификации\n  summarise(across(\n    .cols = age_years,             # интересующая переменная для расчета\n    .fns = list(\"mean\" = mean,     # статистика для расчета\n                \"sd\" = sd,\n                \"var\" = var,\n                \"min\" = min,\n                \"max\" = max),  \n    na.rm = TRUE))                 # другие аргументы для расчета статистики\n\nWarning: There was 1 warning in `summarise()`.\nℹ In argument: `across(...)`.\nℹ In group 1: `date_outcome_NA = !NA`.\nCaused by warning:\n! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\nSupply arguments directly to `.fns` through an anonymous function instead.\n\n  # Previously\n  across(a:b, mean, na.rm = TRUE)\n\n  # Now\n  across(a:b, \\(x) mean(x, na.rm = TRUE))\n\n\n# A tibble: 2 × 6\n  date_outcome_NA age_years_mean age_years_sd age_years_var age_years_min\n  &lt;fct&gt;                    &lt;dbl&gt;        &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n1 !NA                       16.0         12.6          158.             0\n2 NA                        16.2         12.9          167.             0\n# ℹ 1 more variable: age_years_max &lt;dbl&gt;\n\n\nАльтернативный способ построения графика долей значений столбца, которые отсутствуют на временном промежутке, показан ниже. Он не требует использования naniar. Этот пример показывает процент отсутствующих наблюдений по неделям).\n\nагрегируем данные по полезной единице времени (дни, недели и т.п.), обобщив долю наблюдений с NA (и любых других интересующих значений)\n\nпостроим график доли отсутствующих данных в виде линии с помощью ggplot()\n\nНиже мы берем построчный список, добавляем новый столбец для недели, группируем данные по неделям, а затем рассчитываем процент записей за эту неделю, в которых отсутствует значение. (примечание: если вы хотите % от 7 дней, расчет будет чуть иным).\n\noutcome_missing &lt;- linelist %&gt;%\n  mutate(week = lubridate::floor_date(date_onset, \"week\")) %&gt;%   # создаем новый столбец недель\n  group_by(week) %&gt;%                                             # группируем строки по неделе\n  summarise(                                                     # получаем сводные данные по каждой неделе\n    n_obs = n(),                                                  # количество записей\n    \n    outcome_missing = sum(is.na(outcome) | outcome == \"\"),        # количество записей с отсутствующим значением\n    outcome_p_miss  = outcome_missing / n_obs,                    # доля записей с отсутствующим значением\n  \n    outcome_dead    = sum(outcome == \"Death\", na.rm=T),           # количество записей с исходом смерть\n    outcome_p_dead  = outcome_dead / n_obs) %&gt;%                   # доля записей с исходом смерть\n  \n  tidyr::pivot_longer(-week, names_to = \"statistic\") %&gt;%         # поворачиваем все столбцы, кроме недель, в длинный формат для ggplot\n  filter(stringr::str_detect(statistic, \"_p_\"))                  # сохраняем только значения долей\n\nЗатем мы откладываем долю отсутствующих в виде линии по неделям. См. страницу [Основы ggplot], если вы не знакомы с пакетом построения графиков ggplot2.\n\nggplot(data = outcome_missing)+\n    geom_line(\n      mapping = aes(x = week, y = value, group = statistic, color = statistic),\n      size = 2,\n      stat = \"identity\")+\n    labs(title = \"Weekly outcomes\",\n         x = \"Week\",\n         y = \"Proportion of weekly records\") + \n     scale_color_discrete(\n       name = \"\",\n       labels = c(\"Died\", \"Missing outcome\"))+\n    scale_y_continuous(breaks = c(seq(0,1,0.1)))+\n  theme_minimal()+\n  theme(legend.position = \"bottom\")",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Отсутствующие данные</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.ru.html#использование-данных-с-отсутствующими-значениями",
    "href": "new_pages/missing_data.ru.html#использование-данных-с-отсутствующими-значениями",
    "title": "20  Отсутствующие данные",
    "section": "20.5 Использование данных с отсутствующими значениями",
    "text": "20.5 Использование данных с отсутствующими значениями\n\nОтфильтруем строкис отсутствующими значениями\nЧтобы быстро удалить строки с отсутствующими значениями, используем функцию drop_na() из dplyr.\nВ оригинальном linelist было nrow(linelist) строк. Скорректированное количество строк показано ниже:\n\nlinelist %&gt;% \n  drop_na() %&gt;%     # удаляем строки с ЛЮБЫМИ отсутствующими значениями\n  nrow()\n\n[1] 1818\n\n\nВы можете уточнить, что нужно удалить строки с отсутствующими данными в определенных столбцах:\n\nlinelist %&gt;% \n  drop_na(date_onset) %&gt;% # удаляем строки, где отсутствует date_onset \n  nrow()\n\n[1] 5632\n\n\nВы можете указать столбцы один за другим, либо использовать функции-помощники “tidyselect”:\n\nlinelist %&gt;% \n  drop_na(contains(\"date\")) %&gt;% # удаляем строки с отсутствующими значениями в любом столбце \"date\" (дата) \n  nrow()\n\n[1] 3029\n\n\n\n\n\nРабота с NA в ggplot()\nЧасто полезно сообщать о количестве значений, исключенных из графика, в подписи. Ниже приведен пример:\nВ ggplot() вы можете добавить labs() и внутри него caption =. В этой подписи вы можете использовать str_glue() из пакета stringr, чтобы вставить вместе значения в предложение динамичным образом, чтобы они адаптировались под данные. Пример приведен ниже:\n\nОбратите внимание на использование \\n для новой строки.\n\nОбратите внимание, что если несколько столбцов приводят к тому, что значения не откладываются на графике (например, возраст или пол, если они отображены на графике), тогда вам нужно фильтровать и по этим столбцам, чтобы правильно отобразить не показанное число.\n\n\nlabs(\n  title = \"\",\n  y = \"\",\n  x = \"\",\n  caption  = stringr::str_glue(\n  \"n = {nrow(central_data)} from Central Hospital;\n  {nrow(central_data %&gt;% filter(is.na(date_onset)))} cases missing date of onset and not shown.\"))  \n\nИногда легче будет сохранить последовательность как объект в команде до команды ggplot() и потом просто ссылаться на имя объекта последовательности внутри str_glue().\n\n\n\nNA в факторах\nЕсли интересующий вас столбец является фактором, используйте fct_explicit_na() из пакета forcats, чтобы конвертировать значения NA в текстовое значение. Более детальную информацию см. на странице [Факторы]. По умолчанию новое значение будет “(Missing)”, но это можно скорректировать с помощью аргумента na_level =.\n\npacman::p_load(forcats)   # загружаем пакет\n\nlinelist &lt;- linelist %&gt;% \n  mutate(gender = fct_explicit_na(gender, na_level = \"Missing\"))\n\nlevels(linelist$gender)\n\n[1] \"f\"       \"m\"       \"Missing\"",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Отсутствующие данные</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.ru.html#вменение",
    "href": "new_pages/missing_data.ru.html#вменение",
    "title": "20  Отсутствующие данные",
    "section": "20.6 Вменение",
    "text": "20.6 Вменение\nИногда при анализе данных возникает необходимость “заполнить пробелы” и вписать недостающие данные. Хотя всегда можно просто проанализировать набор данных после удаления всех недостающих значений, это может привести к различным проблемам. Вот два примера:\n\nУдаление всех наблюдений с пропущенными значениями или переменных с большим количеством пропущенных данных может снизить мощность или возможности проведения некоторых видов анализа. Например, как мы выяснили ранее, только небольшая часть наблюдений в нашем наборе данных linelist не имеет пропущенных данных по всем переменным. Если бы мы удалили большую часть нашего набора данных, то потеряли бы очень много информации! Кроме того, большинство наших переменных имеют некоторое количество пропущенных данных - для большинства видов анализа, вероятно, нецелесообразно отбрасывать все переменные, имеющие большое количество пропущенных данных.\nВ зависимости от того, почему отсутствуют данные, анализ только не пропущенных данных может привести к смещенным или вводящим в заблуждение результатам. Например, как мы выяснили ранее, для некоторых пациентов отсутствуют данные о том, были ли у них какие-либо важные симптомы, например жар или кашель. Но, как вариант, может быть, эта информация не была записана для людей, которые просто явно не были сильно больны. В этом случае, если мы просто удалим эти наблюдения, мы исключим из нашего набора данных самых здоровых людей, и это может исказить результаты.\n\nВажно не только понять, сколько данных отсутствует, но и подумать о том, почему они могут отсутствовать. Это поможет решить, насколько важно вменять недостающие данные, а также какой метод вменения недостающих данных лучше всего использовать в вашей ситуации.\n\nТипы отсутствующих данных\nВот три основных типа отсутствующих данных:\n\nПолностью случайные пропуски (MCAR). Это означает, что между вероятностью отсутствия данных и любыми другими переменными в ваших данных нет никакой связи. Вероятность отсутствия данных одинакова для всех случаев Это редкая ситуация. Но если у вас есть веские основания полагать, что ваши данные являются MCAR, анализ только не пропущенных данных без вменения не исказит ваши результаты (хотя вы можете потерять некоторую мощность). [СДЕЛАТЬ: рассмотреть обсуждение статистических тестов для MCAR]\nСлучайные пропуски (MAR). На самом деле это название немного вводит в заблуждение, поскольку MAR означает, что ваши данные отсутствуют систематическим, предсказуемым образом на основе другой имеющейся у вас информации. Например, может быть, каждое наблюдение в нашем наборе данных с отсутствующим значением температуры на самом деле не было зарегистрировано, поскольку предполагалось, что у каждого пациента с ознобом и ломотой температура просто не измерялась. Если это так, то мы могли бы легко предсказать, что у каждого пропущенного наблюдения с ознобом и ломотой также была температура, и использовать эту информацию для вменения недостающих данных. На практике это больше похоже на спектр. Возможно, если у пациента были и озноб, и ломота, то у него с большей вероятностью будет и жар, если ему не измеряли температуру, но не всегда. Это все равно предсказуемо, даже если не идеально предсказуемо. Это распространенный тип отсутствующих данных\nНеслучайные пропуски (MNAR). Иногда называются Not Missing at Random (NMAR). Здесь предполагается, что вероятность того, что значение отсутствует, НЕ является систематической или предсказуемой с помощью другой имеющейся у нас информации, но и не является случайной. В этой ситуации данные отсутствуют по неизвестным причинам или по причинам, о которых у вас нет никакой информации. Например, в нашем наборе данных может отсутствовать информация о возрасте, поскольку некоторые очень пожилые пациенты либо не знают, либо отказываются говорить, сколько им лет. В этой ситуации отсутствие данных о возрасте связано с самим значением (и, следовательно, не является случайным) и не предсказуемо на основе другой имеющейся у нас информации. MNAR - сложная проблема, и часто лучшим способом ее решения является попытка собрать больше данных или информации о причинах отсутствия данных, а не пытаться их вменить.\n\nВ целом, вменять данные MCAR часто достаточно просто, а MNAR - очень сложно или даже невозможно. Многие часто используемые методы вменения предполагают MAR.\n\n\nПолезные пакеты\nНекоторые полезные пакеты для вменения отсутствующих данных включают в себя Mmisc, missForest (который использует случайные леса для вменения отсутствующих данных), и mice (Multivariate Imputation by Chained Equations - Многомерное вменение с помощью цепных уравнений). Для этого раздела мы воспользуемся пакетом mice, который использует ряд приемов. Сопровождающий пакета mice опубликовал онлайн книгу о вменении отсутствующих данных, которая рассматривает дополнительные детали (https://stefvanbuuren.name/fimd/).\nВот код для загрузки пакета mice:\n\npacman::p_load(mice)\n\n\n\nВменение среднего\nИногда, если вы проводите простой анализ или у вас есть веские основания полагать, что вы можете предположить MCAR, вы можете просто установить недостающие числовые значения на среднее значение этой переменной. Возможно, мы можем предположить, что пропущенные измерения температуры в нашем наборе данных были либо MCAR, либо просто нормальными значениями. Вот код для создания новой переменной, которая заменяет пропущенные значения температуры на среднее значение температуры в нашем наборе данных. Однако во многих ситуациях замена данных средним значением может привести к погрешности, поэтому будьте осторожны.\n\nlinelist &lt;- linelist %&gt;%\n  mutate(temp_replace_na_with_mean = replace_na(temp, mean(temp, na.rm = T)))\n\nАналогичный процесс можно проделать и для замены категориальных данных конкретным значением. Для нашего набора данных представим, что вы знаете, что все наблюдения с отсутствующим значением результата (который может быть ” Death” (умер) или “Recover” (выздоровел)) на самом деле были умершими людьми (примечание: это не совсем верно для данного набора данных):\n\nlinelist &lt;- linelist %&gt;%\n  mutate(outcome_replace_na_with_death = replace_na(outcome, \"Death\"))\n\n\n\nВменение регрессии\nНесколько более продвинутый метод заключается в использовании некоторой статистической модели для предсказания вероятного значения отсутствующей величины и замены его предсказанным значением. Здесь приведен пример создания предсказанных значений для всех наблюдений, в которых температура отсутствует, а возраст и жар - нет, с помощью простой линейной регрессии, использующей в качестве предикторов состояние жара и возраст в годах. На практике лучше использовать более совершенную модель, чем такой простой подход.\n\nsimple_temperature_model_fit &lt;- lm(temp ~ fever + age_years, data = linelist)\n\n#используем нашу простую модель температуры, чтобы спрогнозировать значения для наблюдений, где отсутствует температура (temp)\npredictions_for_missing_temps &lt;- predict(simple_temperature_model_fit,\n                                        newdata = linelist %&gt;% filter(is.na(temp))) \n\nЛибо, используя тот же подход к моделированию в пакете mice, создаем вмененные значения для отсутствующих наблюдений температуры:\n\nmodel_dataset &lt;- linelist %&gt;%\n  select(temp, fever, age_years)  \n\ntemp_imputed &lt;- mice(model_dataset,\n                            method = \"norm.predict\",\n                            seed = 1,\n                            m = 1,\n                            print = F)\n\nWarning: Number of logged events: 1\n\ntemp_imputed_values &lt;- temp_imputed$imp$temp\n\nПодобный подход используется в некоторых более продвинутых методах, например, в пакете missForest для замены отсутствующих данных предсказанными значениями. В этом случае модель предсказания представляет собой случайный лес, а не линейную регрессию. Для этого можно использовать и другие типы моделей. Однако, хотя этот подход хорошо работает в рамках MCAR, следует быть немного осторожным, если вы считаете, что MAR или MNAR более точно описывают вашу ситуацию. Качество вменения будет зависеть от того, насколько хороша ваша модель предсказания, и даже при очень хорошей модели изменчивость вмененных данных может быть недооценена.\n\n\nLOCF и BOCF\nLast observation carried forward (LOCF) (Перенос данных последнего наблюдения вперед) и baseline observation carried forward (BOCF) (использование исходного документированного значения) - это методы вменения для временных рядов/продольных данных. Идея заключается в том, чтобы взять предыдущее наблюдаемое значение в качестве замены отсутствующих данных. Когда отсутствует несколько значений подряд, метод ищет последнее наблюдаемое значение.\nФункцию fill() из пакета tidyr можно использовать для вменения как LOCF, так и BOCF (однако другие пакеты, такие как HMISC, zoo и data.table также включают методы для этого). Чтобы показать синтаксис fill(), создадим простой набор с временным рядом, содержащий количество случаев заболевания для каждого квартала 2000 и 2001 годов. Однако значение года для кварталов после Q1 отсутствует, так что нам нужно его вменить. Функция fill() также демонстрируется на странице [Поворот данных].\n\n#создаем простой набор данных\ndisease &lt;- tibble::tribble(\n  ~quarter, ~year, ~cases,\n  \"Q1\",    2000,    66013,\n  \"Q2\",      NA,    69182,\n  \"Q3\",      NA,    53175,\n  \"Q4\",      NA,    21001,\n  \"Q1\",    2001,    46036,\n  \"Q2\",      NA,    58842,\n  \"Q3\",      NA,    44568,\n  \"Q4\",      NA,    50197)\n\n#вменяем отсутствующие значения года:\ndisease %&gt;% fill(year)\n\n# A tibble: 8 × 3\n  quarter  year cases\n  &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;\n1 Q1       2000 66013\n2 Q2       2000 69182\n3 Q3       2000 53175\n4 Q4       2000 21001\n5 Q1       2001 46036\n6 Q2       2001 58842\n7 Q3       2001 44568\n8 Q4       2001 50197\n\n\nПримечание: убедитесь, что ваши данные правильно отсортированы до использования функции fill(). fill() по умолчанию заполняет “вниз”, но вы можете также вменять значения в других направлениях, изменив параметр .direction. Мы можем создать похожий набор данных, где значение года записывается только в конце года и отсутствует для кварталов до этого:\n\n#создаем чуть отличающийся набор данных\ndisease &lt;- tibble::tribble(\n  ~quarter, ~year, ~cases,\n  \"Q1\",      NA,    66013,\n  \"Q2\",      NA,    69182,\n  \"Q3\",      NA,    53175,\n  \"Q4\",    2000,    21001,\n  \"Q1\",      NA,    46036,\n  \"Q2\",      NA,    58842,\n  \"Q3\",      NA,    44568,\n  \"Q4\",    2001,    50197)\n\n#вменяем отсутствующие значения года в направлении \"вверх\" (\"up\"):\ndisease %&gt;% fill(year, .direction = \"up\")\n\n# A tibble: 8 × 3\n  quarter  year cases\n  &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;\n1 Q1       2000 66013\n2 Q2       2000 69182\n3 Q3       2000 53175\n4 Q4       2000 21001\n5 Q1       2001 46036\n6 Q2       2001 58842\n7 Q3       2001 44568\n8 Q4       2001 50197\n\n\nВ данном примере LOCF и BOCF, несомненно, являются правильными, однако в более сложных ситуациях может быть сложнее решить, подходят ли эти методы. Например, у вас могут отсутствовать лабораторные показатели для пациента больницы после первого дня пребывания. Иногда это может означать, что лабораторные показатели не изменились… но это также может означать, что пациент выздоровел, и после первого дня его показатели будут совсем другими! Используйте эти методы с осторожностью.\n\n\nМножественное вменение\nВ онлайн книге, которую мы упоминали ранее, от автора пакета mice (https://stefvanbuuren.name/fimd/) есть детальное объяснение вменения множественных данных и того, зачем его использовать. Ниже приведено короткое объяснение этого метода:\nПри вменении множественных данных создается несколько наборов данных, в которых недостающие значения вменены как правдоподобные значения данных (в зависимости от данных исследования может потребоваться создание большего или меньшего количества таких наборов, но в пакете mice по умолчанию установлено число 5). Разница заключается в том, что вместо одного конкретного значения каждое вмененное значение берется из оценочного распределения (таким образом, в нем присутствует некоторая случайность). В результате каждый из этих наборов данных будет иметь несколько различные вмененные значения (однако неотсутствующие данные будут одинаковыми в каждом из этих вмененных наборов). Вы все еще используете какого-то рода предиктивную модель для вменения в каждом из этих новых наборов данных (в mice есть много опций для предикторных методов, включя Метод согласования предсказанного среднего, логистическую регрессию и случайный лес), но пакет mice может справиться с многими деталями моделирования.\nЗатем, создав эти новые вмененные наборы данных, можно применить любую статистическую модель или анализ, который вы планировали провести для каждого из этих новых вмененных наборов данных, и объединить результаты этих моделей вместе. Это очень хорошо работает для уменьшения ошибки как в MCAR, так и во многих MAR, и часто приводит к более точным оценкам стандартной ошибки.\nВот пример применения процесса множественного вменения для прогнозирования температуры в нашем наборе данных построчного списка, используя возраст и статус жара (наш упрощенный набор данных model_dataset, созданный выше):\n\n# вменяем отсутствующие значения для всех переменных в model_dataset, и создаем 10 новых вмененных наборов данных\nmultiple_imputation = mice(\n  model_dataset,\n  seed = 1,\n  m = 10,\n  print = FALSE) \n\nWarning: Number of logged events: 1\n\nmodel_fit &lt;- with(multiple_imputation, lm(temp ~ age_years + fever))\n\nbase::summary(mice::pool(model_fit))\n\n         term     estimate    std.error    statistic        df       p.value\n1 (Intercept) 3.703143e+01 0.0270863456 1.367162e+03  26.83673  1.583113e-66\n2   age_years 3.867829e-05 0.0006090202 6.350905e-02 171.44363  9.494351e-01\n3    feveryes 1.978044e+00 0.0193587115 1.021785e+02 176.51325 5.666771e-159\n\n\nЗдесь мы использовали метод вменения по умолчанию, который представляет собой Метод согласования предсказанного среднего. Затем мы использовали эти вмененные наборы данных для отдельной оценки и последующего объединения результатов простой линейной регрессии для каждого из этих наборов данных. Существует множество деталей, на которые мы не обратили внимания, и множество настроек, которые можно регулировать в процессе множественного вменения при использовании пакета mice. Например, не всегда есть числовые данные, и может потребоваться использование других методов вменения (для многих других типов данных и методов можно по-прежнему использовать пакет mice). Однако для более надежного анализа, когда отсутствующие данные представляют собой серьезную проблему, множественное вменение является хорошим решением, которое не всегда требует больше усилий, чем проведение полного анализа случая.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Отсутствующие данные</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.ru.html#ресурсы",
    "href": "new_pages/missing_data.ru.html#ресурсы",
    "title": "20  Отсутствующие данные",
    "section": "20.7 Ресурсы",
    "text": "20.7 Ресурсы\nВиньетка для пакета naniar\nГалерея визуализаций отсутствующих данных\nОнлайн учебник по множественному вменению в R от сопровождающего пакета mice",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Отсутствующие данные</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.ru.html",
    "href": "new_pages/standardization.ru.html",
    "title": "21  Стандартизированные коэффициенты",
    "section": "",
    "text": "21.1 Обзор\nСуществует два основных способа стандартиации: прямая и косвенная стандартизация Представим, что вам нужно стандартизировать коэффициент смертности по возрасту и полу для страны A и страны B, а также сравнить стандартизированные коэффициенты между этими странами.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Стандартизированные коэффициенты</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.ru.html#обзор",
    "href": "new_pages/standardization.ru.html#обзор",
    "title": "21  Стандартизированные коэффициенты",
    "section": "",
    "text": "Для прямой стандартизации необходимо знать численность населения, подверженного риску, и количество смертей для каждой половозрастной страты в стране А и стране Б. Одной из страт в нашем примере могут быть женщины в возрасте 15-44 лет.\n\nДля косвенной стандартизации достаточно знать общее число умерших и половозрастную структуру населения каждой страны. Поэтому этот вариант возможен, если отсутствуют возрастные и половые коэффициенты смертности или численность населения. Кроме того, косвенная стандартизация предпочтительна в случае небольшого числа страт, так как на оценки при прямой стандартизации будет влиять значительный разброс выборки.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Стандартизированные коэффициенты</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.ru.html#подготовка",
    "href": "new_pages/standardization.ru.html#подготовка",
    "title": "21  Стандартизированные коэффициенты",
    "section": "21.2 Подготовка",
    "text": "21.2 Подготовка\nЧтобы показать, как проводится стандартизация, мы будем использовать фиктивные данные о численности населения и смертности в странах А и Б с разбивкой по возрасту (в категориях 5 лет) и полу (женщины, мужчины). Чтобы подготовить наборы данных к использованию, выполним следующие подготовительные действия:\n\nЗагрузим пакеты\n\nЗагрузим наборы данных\n\nСоединим данные по населению и смертям по двум странам\nПовернем вертикально, чтобы была одна строка на половозрастную страту\nВычистим референтную популяцию (мировое стандартное население) и присоединим ее к страновым данным\n\nВ вашем сценарии данные могут быть представлены в другом формате. Возможно, данные представлены по провинциям, городам или другим районам. У вас может быть одна строка для каждого случая смерти и информация о возрасте и поле для каждого (или значительной части) из этих случаев смерти. В таком случае, см. страницы Группирование данных, Поворот данных и Описательные таблицы, чтобы создать набор данных с подсчетом событий и населения по половозрастным стратам.\nНам также нужна референтная популяция, стандартное население. В этом упражнении мы будет использовать world_standard_population_by_sex. Мировое стандартное население основано на населении 46 стран и было разработано в 1960. Существует много “стандартных” популяций - в качестве примера см. веб-сайт Медицинской службы Шотландии, который является очень информативным в вопросах Европейского стандартного населения, Мирового стандартного населения и Стандартного населения Шотландии.\n\n\nЗагрузка пакетов\nДанный фрагмент кода показывает загрузку пакетов, необходимых для анализа. В данном руководстве мы фокусируемся на использовании p_load() из пакета pacman, которая устанавливает пакет, если необходимо, и загружает его для использования. Вы можете также загрузить установленные пакеты с помощью library() из базового R. См. страницу Основы R для получения дополнительной информации о пакетах R.\n\npacman::p_load(\n     rio,                 # импорт/экспорт данных\n     here,                # путь к файлам\n     stringr,             # вычистка текста и последовательностей\n     frailtypack,         # необходим для dsr, для моделей, учитывающих индивидуальную уязвимость\n     dsr,                 # стандартизированные коэффициенты\n     PHEindicatormethods, # альтернатива для стандартизации коэффициентов\n     tidyverse)           # управление данными и визуализация\n\nВНИМАНИЕ: Если у вас более новая версия R, пакет dsr нельзя напрямую скачать с CRAN. Однако он все еще доступен в архиве CRAN. Вы можете установить и использовать этот. \nДляф всех пользователей, кроме Mac:\n\npackageurl &lt;- \"https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz\"\ninstall.packages(packageurl, repos=NULL, type=\"source\")\n\n\n# другое решение, которое может сработать\nrequire(devtools)\ndevtools::install_version(\"dsr\", version=\"0.2.2\", repos=\"http:/cran.us.r.project.org\")\n\nДля пользователей Mac:\n\nrequire(devtools)\ndevtools::install_version(\"dsr\", version=\"0.2.2\", repos=\"https://mac.R-project.org\")\n\n\n\nЗагружаем популяционные данные\nДля получения инструкций о том, как скачать все данные для примеров из руководства см. страницу [Скачивание руководства и данных]. Вы можете импортировать данные для страницы Стандартизация напрямую в R из нашего репозитория Github, выполнив следующие команды import():\n\n# импорт демографических данных по стране A напрямую из Github\nA_demo &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics.csv\")\n\n# импорт данных о смертях для страны A напрямую из Github\nA_deaths &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryA.csv\")\n\n# импорт демографических данных по стране B напрямую из Github\nB_demo &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics_2.csv\")\n\n# импорт данных о смертях для страны B напрямую из Github\nB_deaths &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryB.csv\")\n\n# импорт демографических данных по стране B напрямую из Github\nstandard_pop_data &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/world_standard_population_by_sex.csv\")\n\nСначала мы загружаем демографические данные (количество мужчин и женщин по 5-летним возрастным категориям) для двух стран, которые мы будем сравнивать, “Страны A” и “Страны B”.\n\n# Страна A\nA_demo &lt;- import(\"country_demographics.csv\")\n\n\n\n\n\n\n\n\n# Страна B\nB_demo &lt;- import(\"country_demographics_2.csv\")\n\n\n\n\n\n\n\n\n\nЗагружаем данные о количестве смертей\nЧто удобно, у нас также естьт количество смертей за интересующий временной период по полу и возрасту. Количество по каждой стране представлено в отдельном файле, показанном ниже.\nСмерти в Стране A\n\n\n\n\n\n\nСмерти в Стране B\n\n\n\n\n\n\n\n\nВычищаем данные по населению и смертям\nНам нужно соединить и трансформировать эти данные следующим образом:\n\nОбъединить населения стран в один набор данных и повернуть вертикально, чтобы каждая половозрастная страта занимала одну строку\n\nОбъединить количество смертей стран и повернуть вертикально, чтобы каждая половозрастная страта занимала одну строку\n\nПрисоединить смерти к популяциям\n\nСначала объединим наборы данных с населением стран, повернем вертикально и проведем небольшую вычистку. См. страницу [Поворот данных] для получения более подробной информации.\n\npop_countries &lt;- A_demo %&gt;%  # начнем с набора данных по Стране A\n     bind_rows(B_demo) %&gt;%        # связываем строки, поскольку столбцы имеют одинаковые названия\n     pivot_longer(                       # поворачиваем вертикально\n          cols = c(m, f),                   # столбцы объединяются в один\n          names_to = \"Sex\",                 # имя для нового столбца, содержащего категорию (\"m\" или \"f\") \n          values_to = \"Population\") %&gt;%     # имя для нового столбца, содержащего повернутые числовые значения\n     mutate(Sex = recode(Sex,            # перекодируем значения для ясности\n          \"m\" = \"Male\",\n          \"f\" = \"Female\"))\n\nОбъединенные данные по населению теперь выглядят вот так (пролистайте, чтобы увидеть страны A и B):\n\n\n\n\n\n\nТеперь проведем похожие операции с двумя наборами данных о смертях.\n\ndeaths_countries &lt;- A_deaths %&gt;%    # начинаем с набора данных о смертях в стране A\n     bind_rows(B_deaths) %&gt;%        # связываем строки с набором данных B, поскольку столбцы имеют одинаковые названия\n     pivot_longer(                  # поворачиваем вертикально\n          cols = c(Male, Female),        # столбцы трансформируются в один\n          names_to = \"Sex\",              # имя для нового столбца, содержащего категорию (\"m\" или \"f\") \n          values_to = \"Deaths\") %&gt;%      # имя для нового столбца, содержащего повернутые числовые значения\n     rename(age_cat5 = AgeCat)      # переименуем для ясности\n\nДанные о смертях теперь выглядят вот так и содержат данные из обеих стран:\n\n\n\n\n\n\nТеперь мы соединим данные о смертях и о населении на основе общих столбцов Country (страна), age_cat5 (возрастная категория) и Sex (пол). Это добавит столбец Deaths (смерти).\n\ncountry_data &lt;- pop_countries %&gt;% \n     left_join(deaths_countries, by = c(\"Country\", \"age_cat5\", \"Sex\"))\n\nТеперь мы классифицируем Sex, age_cat5 и Country как факторы и установим порядок уровней с помощью функции fct_relevel() из пакета forcats, как описано на странице [Факторы]. Обратите внимание, что классификация уровней фактора не меняет видимые данные, а команда arrange() сортирует по Стране, возрастной категории и полу.\n\ncountry_data &lt;- country_data %&gt;% \n  mutate(\n    Country = fct_relevel(Country, \"A\", \"B\"),\n      \n    Sex = fct_relevel(Sex, \"Male\", \"Female\"),\n        \n    age_cat5 = fct_relevel(\n      age_cat5,\n      \"0-4\", \"5-9\", \"10-14\", \"15-19\",\n      \"20-24\", \"25-29\",  \"30-34\", \"35-39\",\n      \"40-44\", \"45-49\", \"50-54\", \"55-59\",\n      \"60-64\", \"65-69\", \"70-74\",\n      \"75-79\", \"80-84\", \"85\")) %&gt;% \n          \n  arrange(Country, age_cat5, Sex)\n\n\n\n\n\n\n\nВНИМАНИЕ: Если у вас мало смертей на страту, рассмотрите возможность использования 10- или 15-летних категорий вместо 5-летних категорий возраста.\n\n\nЗагрузка референтной популяции\nИ последнее, для прямой стандартизации мы импортируем референтную популяцию (мировое “стандартное население” по полу)\n\n# референтная популяция\nstandard_pop_data &lt;- import(\"world_standard_population_by_sex.csv\")\n\n\n\n\n\n\n\n\n\n\nВычистка референтной популяции\nЗначения возрастных категорий в country_data и standard_pop_data необходимо унифицировать.\nВ настоящее время значения столбца age_cat5 в датафрейме standard_pop_data содержат слова “years” и “plus”, а в датафрейме country_data их нет. Нам нужно, чтобы значения возрастных категорий совпадали. Мы используем str_replace_all() из пакета stringr, как описано на странице [Текст и последовательности], чтобы заменить эти комбинации символов на отсутствие пробела \"\".\nБолее того, пакет dsr ожидает, что в стандартном населении столбец, где содержится количество, должен называться \"pop\". Поэтому нам нужно переименовать столбец соответствующим образом.\n\n# удаляем конкретную последовательность из значений столбца\nstandard_pop_clean &lt;- standard_pop_data %&gt;%\n     mutate(\n          age_cat5 = str_replace_all(age_cat5, \"years\", \"\"),   # удаляем \"year\"\n          age_cat5 = str_replace_all(age_cat5, \"plus\", \"\"),    # удаляем \"plus\"\n          age_cat5 = str_replace_all(age_cat5, \" \", \"\")) %&gt;%   # удаляем пробел \" \"\n     \n     rename(pop = WorldStandardPopulation)   # меняем имя столбца на \"pop\", так как этого ожидает пакет dsr\n\nВНИМАНИЕ: Если вы будете пытаться использовать str_replace_all(), чтобы удалить символ плюс, она не сработает, поскольку это специальный символ. “Изолируйте” этот особый характер символа, поставив перед ним два обратных слэша, вот так str_replace_call(column, \"\\\\+\", \"\"). \n\n\nСоздание набора данных со стандартным населением\nНаконец пакет PHEindicatormethods, который де6тально описан ниже, ожидает присоединения стандартных популяций к данным о количестве случаев события и населении. Поэтому в этих целях мы создадим набор данных all_data.\n\nall_data &lt;- left_join(country_data, standard_pop_clean, by=c(\"age_cat5\", \"Sex\"))\n\nЭтот полный набор данных выглядит следующим образом:",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Стандартизированные коэффициенты</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.ru.html#пакет-dsr",
    "href": "new_pages/standardization.ru.html#пакет-dsr",
    "title": "21  Стандартизированные коэффициенты",
    "section": "21.3 Пакет dsr",
    "text": "21.3 Пакет dsr\nНиже мы демонстрируем расчет и сравнение прямых стандартизированных коэффициентов, используя пакет dsr. Пакет dsr позволяет вам рассчитывать и сравнивать прямые стандартизированные коэффициенты (не косвенные стандартизированные коэффициенты!).\nВ разделе Подготовка данных мы создали отдельные наборы данных для подсчета по странам и стандартного населения:\n\nобъект country_data, который является популяционной таблицей с количеством населения и количеством смертей по стратам по стране\n\nобъект standard_pop_clean, содержащий количество населения по стратам для референтной популяции, Мирового стандартного населения\n\nМы будем использовать эти отдельные наборы данных для подхода с использованием dsr.\n\n\nСтандартизированные коэффициенты\nНиже мы рассчитываем коэффициенты по стране, стандартизированные прямым образом по полу и возрасту. Мы используем функцию dsr().\nНеобходимо отметить, что dsr() ожидает одного датафреймя для населения страны и количество случаев события (смертей) и отдельный датафрейм с референтной популяцией. Она также ожидает, что в этом наборе референтной популяции имя столбца за единицу времени будет “pop” (мы это сделали на этапе Подготовки данных).\nСуществует много аргументов, как показано в коде ниже. Необходимо отметить, что event = задается как столбец Deaths, а fu = (“отслеживание”) задается как столбец Population. Мы устанавливаем подгруппы сравнения как столбец Country и стандартизируем на основе age_cat5 и Sex. Этим последним двум столбцам не присваивается конкретный именованный аргумент. См. ?dsr для получения дополнительной информации.\n\n# Рассчитываем коэффициенты по стране, стандартизированные прямым образом по возрасту и полу\nmortality_rate &lt;- dsr::dsr(\n     data = country_data,  # уточняем объект, содержащий количество смертей по страте\n     event = Deaths,       # столбец, содержащий количество смертей по страте \n     fu = Population,      # столбец, содержащий количество населения по страте\n     subgroup = Country,   # единицы, которые мы бы хотели сравнить\n     age_cat5,             # другие столбцы - коэффициенты будут стандартизированы по этим\n     Sex,\n     refdata = standard_pop_clean, # датафрейм референтной популяции со столбцом под названием pop\n     method = \"gamma\",      # метод расчета 95% ДИ\n     sig = 0.95,            # уровень значимости\n     mp = 100000,           # нам нужны коэффициенты на 100 000 населения\n     decimals = 2)          # количество десятичных знаков)\n\n\n# Печать выходнрых данных в виде красивой таблицы HTML\nknitr::kable(mortality_rate) # показываем коэффициент смертности до и после прямой стандартизации\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSubgroup\nNumerator\nDenominator\nCrude Rate (per 1e+05)\n95% LCL (Crude)\n95% UCL (Crude)\nStd Rate (per 1e+05)\n95% LCL (Std)\n95% UCL (Std)\n\n\n\n\nA\n11344\n86790567\n13.07\n12.83\n13.31\n23.57\n23.08\n24.06\n\n\nB\n9955\n52898281\n18.82\n18.45\n19.19\n19.33\n18.46\n20.22\n\n\n\n\n\nВыше мы видим, что хотя у страны A был ниже общий коэффициент смертности, чем у страны B, у нее выше стандартизированный коэффициент после прямой стандартизации по полу и возрасту.\n\n\n\nStandardized rate ratios\n\n# Рассчитываем ОР\nmortality_rr &lt;- dsr::dsrr(\n     data = country_data, # уточняем объект, содержащий количество смертей по страте\n     event = Deaths,      # столбец, содержащий количество смертей по страте \n     fu = Population,     # столбец, содержащий количество населения по страте\n     subgroup = Country,  # единицы, которые мы бы хотели сравнить\n     age_cat5,\n     Sex,                 # характеристики, по которым мы хотим стандартизировать \n     refdata = standard_pop_clean, # референтная популяция, с числами в столбце под названием pop\n     refgroup = \"B\",      # референс для сравнения\n     estimate = \"ratio\",  # тип оценки\n     sig = 0.95,          # уровень значимости\n     mp = 100000,         # нам нужны коэффициенты на 100 000 населения\n     decimals = 2)        # количество десятичных знаков\n\n# Печать таблицы\nknitr::kable(mortality_rr) \n\n\n\n\n\n\n\n\n\n\n\n\nComparator\nReference\nStd Rate (per 1e+05)\nRate Ratio (RR)\n95% LCL (RR)\n95% UCL (RR)\n\n\n\n\nA\nB\n23.57\n1.22\n1.17\n1.27\n\n\nB\nB\n19.33\n1.00\n0.94\n1.06\n\n\n\n\n\nСтандартизированный коэффициент смертности в 1.22 раза выше в стране A по сравнению со страной B (95% ДИ 1.17-1.27).\n\n\n\nРазница стандартизированных коэффициентов\n\n# Calculate RD\nmortality_rd &lt;- dsr::dsrr(\n     data = country_data,       # уточняем объект, содержащий количество смертей по страте\n     event = Deaths,            # столбец, содержащий количество смертей по страте \n     fu = Population,           # столбец, содержащий количество населения по страте\n     subgroup = Country,        # единицы, которые мы бы хотели сравнить\n     age_cat5,                  # характеристики, по которым мы хотим стандартизировать\n     Sex,                        \n     refdata = standard_pop_clean, # референтная популяция, с числами в столбце под названием pop\n     refgroup = \"B\",            # референс для сравнения\n     estimate = \"difference\",   # тип оценки\n     sig = 0.95,                # уровень значимости\n     mp = 100000,               # нам нужны коэффициенты на 100 000 населения\n     decimals = 2)              # количество десятичных знаков\n\n# Печать таблицы\nknitr::kable(mortality_rd) \n\n\n\n\n\n\n\n\n\n\n\n\nComparator\nReference\nStd Rate (per 1e+05)\nRate Difference (RD)\n95% LCL (RD)\n95% UCL (RD)\n\n\n\n\nA\nB\n23.57\n4.24\n3.24\n5.24\n\n\nB\nB\n19.33\n0.00\n-1.24\n1.24\n\n\n\n\n\nВ стране A имеется 4.24 дополнительных смертей на 100.000 населения (95% ДИ 3.24-5.24) по сравнению со страной A.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Стандартизированные коэффициенты</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.ru.html#standard_phe",
    "href": "new_pages/standardization.ru.html#standard_phe",
    "title": "21  Стандартизированные коэффициенты",
    "section": "21.4 Пакет PHEindicatormethods",
    "text": "21.4 Пакет PHEindicatormethods\nЕще один способ расчета стандартизированных коэффициентов - использовать пакет PHEindicatormethods. Этот пакет позволяет вам рассчитывать как прямые, так и косвенные стандартизированные коэффициенты. Мы покажем оба варианта.\nВ этом разделе используется датафрейм all_data, созданный в конце раздела Подготовка. Этот датафрейм включает населения стран, смерти и мировую стандартную референтную популяцию. Вы можете посмотреть это тут.\n\n\nПрямые стандартизированные коэффициенты\nНиже мы сначала группируем данные по Стране, затем передаем их в функцию phe_dsr(), чтобы получить прямые стандартизированные коэффициенты по странам.\nСледует отметить, что референтное (стандартное) население может быть указано как столбец внутри датафрейма для конкретной страны, либо как отдельный вектор. Если вы его указываете внутри странового датафрейма, вы должны установить аргумент stdpoptype = \"field\". Если вы его указываете как вектор, установите stdpoptype = \"vector\". В последнем случае вам необходимо убедиться, что упорядочивание строк по стратам аналогично и в страновом датафрейме, и в референтной популяции, так как записи будут сопоставляться по позиции. В примере ниже мы задали референтную популяцию как столбец внутри странового датафрейма.\nСм. справку с помощью ?phr_dsr или ссылки в разделе Ресурсы для получения более подробной информации.\n\n# Рассчитываем коэффициенты по стране, стандартизированные прямым образом по полу и возрасту\nmortality_ds_rate_phe &lt;- all_data %&gt;%\n     group_by(Country) %&gt;%\n     PHEindicatormethods::phe_dsr(\n          x = Deaths,                 # столбец с наблюдаемым количеством событий\n          n = Population,             # столбец с нестандартным населением для каждой страты\n          stdpop = pop,               # стандартное население для каждой страты\n          stdpoptype = \"field\")       # либо \"vector\" (вектор) для отдельного вектора, либо \"field\" (поле), что означает, что стандартное население указано в данных  \n\n# Печать таблицы\nknitr::kable(mortality_ds_rate_phe)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCountry\ntotal_count\ntotal_pop\nvalue\nlowercl\nuppercl\nconfidence\nstatistic\nmethod\n\n\n\n\nA\n11344\n86790567\n23.56686\n23.08107\n24.05944\n95%\ndsr per 100000\nDobson\n\n\nB\n9955\n52898281\n19.32549\n18.45516\n20.20882\n95%\ndsr per 100000\nDobson\n\n\n\n\n\n\n\n\nКосвенные стандартизированные коэффиенты\nДля косвенной стандартизации вам нужна референтная популяция с количеством смертей и количеством населения на страту. В данном примере мы будем рассчитывать коэффициенты для Страны A, используя страну B в качестве референтной популяции, так как референтная популяция standard_pop_clean не включает количество смертей на страту.\nНиже мы сначала создаем референтную популяцию из страны B. Затем мы передаем данные о смертности и населении страны A, объединяем их с референтной популяцией и передаем в функцию calculate_ISRate(), чтобы получить косвенные стандартизированные коэффициенты. Конечно, можно сделать и наоборот.\nСледует отметить - в примере ниже референтная популяция задается как отдельный датафрейм. В этом случае нужно убедиться, что векторы x =, n =, x_ref = и n_ref = все упорядочены по тем же значениям категории стандартизации (страты), что и в страновом датафрейме, так как сопоставление записей делается по позиции.\nСм. справку ?phr_isr или ссылки в разделе Ресурсы для получения дополнительной информации.\n\n# Создаем референтную популяцию\nrefpopCountryB &lt;- country_data %&gt;% \n  filter(Country == \"B\") \n\n# Рассчитываем коэффициенты для страны А, косвенным образом стандартизированные по возрасту и полу\nmortality_is_rate_phe_A &lt;- country_data %&gt;%\n     filter(Country == \"A\") %&gt;%\n     PHEindicatormethods::calculate_ISRate(\n          x = Deaths,                 # столбец с наблюдаемым количеством событий\n          n = Population,             # столбец с нестандартным населением для каждой страты\n          x_ref = refpopCountryB$Deaths,  # референтное количество смертей для каждой страты\n          n_ref = refpopCountryB$Population)  # референтная популяция по каждой страте\n\n# Печать таблицы\nknitr::kable(mortality_is_rate_phe_A)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nobserved\nexpected\nref_rate\nvalue\nlowercl\nuppercl\nconfidence\nstatistic\nmethod\n\n\n\n\n11344\n15847.42\n18.81914\n13.47123\n13.22446\n13.72145\n95%\nindirectly standardised rate per 100000\nByars",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Стандартизированные коэффициенты</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.ru.html#ресурсы",
    "href": "new_pages/standardization.ru.html#ресурсы",
    "title": "21  Стандартизированные коэффициенты",
    "section": "21.5 Ресурсы",
    "text": "21.5 Ресурсы\nЕсли вам нужен еще один воспроизводимый пример использования dsr, см. эту виньетку\nЕще один пример использования PHEindicatormethods доступен на этом сайте\nСм. PHEindicatormethods справочный pdf файл",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Стандартизированные коэффициенты</span>"
    ]
  },
  {
    "objectID": "new_pages/moving_average.ru.html",
    "href": "new_pages/moving_average.ru.html",
    "title": "22  Скользящие средние значения",
    "section": "",
    "text": "22.1 Подготовка",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Скользящие средние значения</span>"
    ]
  },
  {
    "objectID": "new_pages/moving_average.ru.html#подготовка",
    "href": "new_pages/moving_average.ru.html#подготовка",
    "title": "22  Скользящие средние значения",
    "section": "",
    "text": "Загрузка пакетов\nДанный фрагмент кода показывает загрузку пакетов, необходимых для анализа. В данном руководстве мы фокусируемся на использовании p_load() из пакета pacman, которая устанавливает пакет, если необходимо, и загружает его для использования. Вы можете также загрузить установленные пакеты с помощью library() из базового R. См. страницу Основы R для получения дополнительной информации о пакетах R.\n\npacman::p_load(\n  tidyverse,      # для управления данными и визуализации\n  slider,         # для расчета скользящего среднего\n  tidyquant       # для расчета скользящего среднего внутри ggplot\n)\n\n\n\nИмпорт данных\nМы импортируем набор данных о случаях из имитированной эпидемии Эболы. Если вы хотите выполнять действия параллельно, кликните, чтобы скачать “чистый” построчный список (как файл .rds). Импортируйте данные с помощью функции import() из пакета rio (она работает с разными типами файлов, такими как .xlsx, .csv, .rds - см. дополнительную информацию на странице Импорт и экспорт).\n\n# импортируем построчный список\nlinelist &lt;- import(\"linelist_cleaned.xlsx\")\n\nПервые 50 строк построчного списка отображены ниже.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Скользящие средние значения</span>"
    ]
  },
  {
    "objectID": "new_pages/moving_average.ru.html#расчет-с-помощью-slider",
    "href": "new_pages/moving_average.ru.html#расчет-с-помощью-slider",
    "title": "22  Скользящие средние значения",
    "section": "22.2 Расчет с помощью slider",
    "text": "22.2 Расчет с помощью slider\nИспользуйте этот подход для расчета скользящего среднего в датафрейме до создания графика.\nПакет slider предоставляет несколько функций “скользящего окна” для расчета скользящих средних значений, нарастающей суммы, скользящих регрессий и т.п. Он рассматривает датафрейм как вектор строк, позволяя итерации по строкам в датафрейме.\nВот некоторые часто используемые функции:\n\nslide_dbl() - проводит итерации по числовому столбцу (отсюда “_dbl”), выполняя операцию с использованием скользящего окна\n\nslide_sum() - краткая функция скользящей суммы для slide_dbl()\n\nslide_mean() - краткая фукнция скользящего среднего значения для slide_dbl()\n\nslide_index_dbl() - применяет скользящее окно к числовому столбцу, используя отдельный столбец для индексирования прогресса окна (полезно, если скользит по дате с некоторыми отсутствующими датами)\n\nslide_index_sum() - краткая функция скользящей суммы с индексированием\n\nslide_index_mean() - краткая функция скользящего среднего с индексированием\n\n\nВ пакете slider есть множество других функций, которые упоминяются в разделе Ресурсы на этой странице. Мы кратко расскажем о наиболее часто использующихся из них.\nКлючевые аргументы\n\n.x, первым аргументом по умолчанию является вектор, по которому будет идти итерация и которому будет применяться функция\n\n.i = для “индексных” версий функций slider - задайте столбец для “индексирования” скольжения (см. раздел ниже)\n\n.f =, второй аргумент по умолчанию, либо:\n\nФункция, написанная без скобок, например, mean, или\n\nФормула, которая будет конвертирована в функцию. Например, ~ .x - mean(.x) выдаст результат текущего значения минус среднее значение окна.\n\nДополнительную информацию см. в этом справочном материале\n\nРазмер окна\nУточните размер окна, используя либо .before, .after, либо оба аргумента:\n\n.before = - задайте число\n\n.after = - задайте число\n\n.complete = - Установите как TRUE, если вы хотите, чтобы расчет делалася только на полных окнах\n\nНапример, чтобы получить 7-дневное окно, включая текущее значение и шесть предыдущих, используйте .before = 6. Чтобы получить “отцентрованное” окно, задайте то же число и в .before =, и в .after =.\nПо умолчанию .complete = будет FALSE (ЛОЖЬ), так что если не существует полное окно строк, функция использует имеющиеся строки для расчета. Установка на TRUE (ИСТИНА) ограничивает расчеты так, чтобы они проводились только с полными окнами.\nРасширение окна\nЧтобы выполнить операции с накоплением, установите аргумент .before = на Inf. Это позволит проводить операцию над текущим значеним и всеми предыдущими.\n\nСкольжение по дате\nСамый частый вариант применения скользящих расчетов в прикладной эпидемиологии - рассмотрение метрики во времени. Например, рассмотрение скользящего показателя заболеваемости на основе ежедневного количества случаев.\nЕсли у вас есть чистые данные по временным рядам со значениями для каждой даты, возможно, вы сможете использовать slide_dbl(), как показано на странице Временные ряды и обнаружение вспышек.\nОднако во многих ситуациях в прикладной эпидемиологии у вас могут быть отсутствующие даты в данных, когда не было задокументировано событий. В этих случаях лучше использовать “индексированные” версии функций slider.\n\n\nИндексируемые данные\nНиже мы показываем пример использования slide_index_dbl() для построчного списка случаев. Представим, что наша задача - рассчитать скользящую 7-дневную заболеваемость - сумму случаев, используя скользящее 7-дневное окно. Если вам нужен пример скользящего среднего значения, см. раздел ниже сгруппированное скользящее.\nДля начала создаем набор данных daily_counts, чтобы отразить ежедневное количество случаев из linelist, что рассчитывается с помощью count() из dplyr.\n\n# создаем набор данных ежедневных случаев\ndaily_counts &lt;- linelist %&gt;% \n  count(date_hospitalisation, name = \"new_cases\")\n\nВот датафрейм daily_counts - в нем nrow(daily_counts) строк, каждый день представлен одной строкой, но на самых ранних этапах эпидемии некоторые дни не отражаются (в эти дни не поступали случаи).\n\n\n\n\n\n\nОчень важно понимать, что стандартная скользящая функция (например, slide_dbl() будет использовать окно из 7 строк, а не 7 дней. Поэтому если даты отсутствуют, некоторые окна могут растягиваться больше, чем на 7 календарных дней!\nМожно создать “умное” скользящее окно с помощью slide_index_dbl(). “index” (индекс) означает, что функция использует отдельный столбец в качестве “индекса” для скользящего окна. Окно не просто основано на строках датафрейма.\nЕсли индексным столбцом является дата, у вас появляется дополнительная возможность уточнить протяженность окна с помощью .before = и/или .after = в единицах из lubridate days() или months(). Если вы это сделаете, функция включит отсутствующие дни в окно, как если бы они имелись (как значения NA).\nДавайте покажем сравнение. Ниже мы рассчитываем скользящую 7-дневную заболеваемость с обычными и индексированными окнами.\n\nrolling &lt;- daily_counts %&gt;% \n  mutate(                                # создаем новые столбцы\n    # Используем slide_dbl()\n    ###################\n    reg_7day = slide_dbl(\n      new_cases,                         # расчет для new_cases\n      .f = ~sum(.x, na.rm = T),          # функция sum() с удалением отсутствующих значений\n      .before = 6),                      # окно - СТРОКА и 6 предыдущих СТРОК\n    \n    # Используем slide_index_dbl()\n    #########################\n    indexed_7day = slide_index_dbl(\n        new_cases,                       # расчет для new_cases\n        .i = date_hospitalisation,       # индексируем по date_onset \n        .f = ~sum(.x, na.rm = TRUE),     # функция sum() с удалением отсутствующих значений\n        .before = days(6))               # окно - ДЕНЬ и 6 предыдущих ДНЕЙ\n    )\n\nПосмотрите, что в обычном столбце в первых 7 строках количество стабильно возрастает, хотя строки не находятся в диапазоне 7 дней друг от друга! Соседний “индексированный” столбец учитывает эти отсутствующие календарные дни, поэтому в ней 7-дневные суммы гораздо меньше, по крайней мере в этот период эпидемии, когда между случаями проходит больше времени.\n\n\n\n\n\n\nТеперь вы можете отразить эти данные на графике, используя ggplot():\n\nggplot(data = rolling)+\n  geom_line(mapping = aes(x = date_hospitalisation, y = indexed_7day), size = 1)\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nСкользящее по группе\nЕсли вы группируете свои данные до использования функции slider, скользящие окна будут применены по группам. Внимательно упорядочите ваши строки в нужном порядке по группе.\nКаждый раз, когда начинается новая группа, будет перезапускаться скользящее окно. Следовательно, необходимо помнить о том нюансе, что если ваши данные сгруппированы и вы установили .complete = TRUE, у вас будут пустые значения при каждом переходе между группами. По мере того как функция двигается вниз по строкам, каждый переход в столбце группирования будет перезапускать накопление минимального размера окна, чтобы начать расчет.\nСм. страницу руководствча [Группирование данных] для получения детальной информации о группировании данных.\nНиже мы считаем случаи построчного списка по дате и по больнице. Затем мы упорядочиваем строки по возрастанию, сначала упорядочив по больнице, а затем внутри этих групп - по дате. Далее мы устанавливаем group_by(). Затем мы можем создать наге новое скользящее среднее.\n\ngrouped_roll &lt;- linelist %&gt;%\n\n  count(hospital, date_hospitalisation, name = \"new_cases\") %&gt;% \n\n  arrange(hospital, date_hospitalisation) %&gt;%   # arrange rows by hospital and then by date\n  \n  group_by(hospital) %&gt;%              # группируем по больнице \n    \n  mutate(                             # скользящее среднее  \n    mean_7day_hosp = slide_index_dbl(\n      .x = new_cases,                 # количество случаев на больницу на день\n      .i = date_hospitalisation,      # индексирование по дате госпитализации\n      .f = mean,                      # используем mean()                   \n      .before = days(6)               # используем день и 6 предыдущих дней\n      )\n  )\n\nВот новый набор данных:\n\n\n\n\n\n\nТеперь мы можем построить график скользящих средних значений, отобразив данные по группе, задав ~ hospital в facet_wrap() в ggplot(). Для интереса построим две геометрии - geom_col(), показывающий количество случаев в день и geom_line(), показывающий 7-дневное скользящее среднее.\n\nggplot(data = grouped_roll)+\n  geom_col(                       # строим график количества случаев в день в виде серых столбцов\n    mapping = aes(\n      x = date_hospitalisation,\n      y = new_cases),\n    fill = \"grey\",\n    width = 1)+\n  geom_line(                      # строим график скользящего среднего в виде линии, цвет которой указан по больнице\n    mapping = aes(\n      x = date_hospitalisation,\n      y = mean_7day_hosp,\n      color = hospital),\n    size = 1)+\n  facet_wrap(~hospital, ncol = 2)+ # создаем мини-графики по больнице\n  theme_classic()+                 # упрощаем фон  \n  theme(legend.position = \"none\")+ # удаляем легенду\n  labs(                            # устанавливаем подписи\n    title = \"7-day rolling average of daily case incidence\",\n    x = \"Date of admission\",\n    y = \"Case incidence\")\n\n\n\n\n\n\n\n\nВНИМАНИЕ: Если у вас появится ошибка “slide() was deprecated in tsibble 0.9.0 and is now defunct. Please use slider::slide() instead.”, это означает, что функция slide() из пакета tsibble маскирует функцию slide() из пакета slider. Это можно исправить, уточнив в команде пакет, например: slider::slide_dbl().",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Скользящие средние значения</span>"
    ]
  },
  {
    "objectID": "new_pages/moving_average.ru.html#расчет-с-помощью-tidyquant-внутри-ggplot",
    "href": "new_pages/moving_average.ru.html#расчет-с-помощью-tidyquant-внутри-ggplot",
    "title": "22  Скользящие средние значения",
    "section": "22.3 Расчет с помощью tidyquant внутри ggplot()",
    "text": "22.3 Расчет с помощью tidyquant внутри ggplot()\nПакет tidyquant предлагает еще один подход к расчету скользящих средних значений - на этот раз внутри команды ggplot().\nНиже данные linelist считаются по дате появления симптомов и это отображается в виде серой линии (alpha &lt; 1). На нее накладывается линия, созданная с помощью geom_ma() из пакета tidyquant, с заданным окном на 7 дней (n = 7) с уточнением цвета и толщины.\nПо умолчанию geom_ma() использует простое скользящее среднее (ma_fun = \"SMA\"), но можно задать другие типы, такие как:\n\n“EMA” - экспоненциальное скользящее среднее (больше вес у более недавних наблюдений)\n\n“WMA” - взвешенное скользящее среднее (wts используются, чтобы взвесить наблюдения в скользящем среднем)\n\nВ документации по функции можно найти и другие виды\n\n\nlinelist %&gt;% \n  count(date_onset) %&gt;%                 # подсчет количества случаев в день\n  drop_na(date_onset) %&gt;%               # удаляем случаи с отсутствующей датой появления симптомов\n  ggplot(aes(x = date_onset, y = n))+   # начинаем ggplot\n    geom_line(                          # график сырых значений\n      size = 1,\n      alpha = 0.2                       # полупрозрачная линия\n      )+             \n    tidyquant::geom_ma(                 # график скользящего среднего\n      n = 7,           \n      size = 1,\n      color = \"blue\")+ \n  theme_minimal()                       # простой фон\n\nWarning: Using the `size` aesthetic in this geom was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` in the `default_aes` field and elsewhere instead.\n\n\n\n\n\n\n\n\n\nСм. эту виньетку для получения более подробной информации об опциях, доступных в tidyquant.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Скользящие средние значения</span>"
    ]
  },
  {
    "objectID": "new_pages/moving_average.ru.html#ресурсы",
    "href": "new_pages/moving_average.ru.html#ресурсы",
    "title": "22  Скользящие средние значения",
    "section": "22.4 Ресурсы",
    "text": "22.4 Ресурсы\nСм. полезную онлайн виньетку для пакета slider\nСм. slider страницу в github\nslider виньетка\nВиньетка tidyquant\nЕсли в вашем случае нужно “пропускать” выходные или праздники, вам может понравиться пакет almanac.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Скользящие средние значения</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.ru.html",
    "href": "new_pages/time_series.ru.html",
    "title": "23  Временные ряды и обнаружение вспышек",
    "section": "",
    "text": "23.1 Обзор\nНа этой странице демонстрируется использование нескольких пакетов для анализа временных рядов. Мы в основном полагаемся на пакеты из семейства tidyverts, но также будем использовать пакет RECON trending, чтобы строить модели, которые больше подходят для эпидемиологии инфекционных заболеваний.\nОбратите внимание, что в примере ниже мы используем набор данных из пакета surveillance по кампилобактеру в Германии (см. главу по данным руководства для получения дополнительной информации). Однако, если бы вы хотели выполнить тот же код для набора данных с несколькими странами или другими стратами, тогда вот есть пример шаблона кода для этих целей в репозитории r4epis github.\nРассматриваемые темы включают:",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Временные ряды и обнаружение вспышек</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.ru.html#обзор",
    "href": "new_pages/time_series.ru.html#обзор",
    "title": "23  Временные ряды и обнаружение вспышек",
    "section": "",
    "text": "Данные временных рядов\nОписательный анализ\nПостроение регрессий\nОтношения между двумя временными рядами\nОбнаружение вспышек\nПрерванные временные ряды",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Временные ряды и обнаружение вспышек</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.ru.html#подготовка",
    "href": "new_pages/time_series.ru.html#подготовка",
    "title": "23  Временные ряды и обнаружение вспышек",
    "section": "23.2 Подготовка",
    "text": "23.2 Подготовка\n\nПакеты\nДанный фрагмент кода показывает загрузку пакетов, необходимых для анализа. В данном руководстве мы фокусируемся на использовании p_load() из пакета pacman, которая устанавливает пакет, если необходимо, и загружает его для использования. Вы можете также загрузить установленные пакеты с помощью library() из базового R. См. страницу Основы R для получения дополнительной информации о пакетах R.\n\npacman::p_load(rio,          # импорт файлов\n               here,         # путь к файлам\n               tidyverse,    # управление данными + графика ggplot2\n               tsibble,      # работа с наборами данных с временными рядами\n               slider,       # для расчета скользящих средних значений\n               imputeTS,     # для заполненеия отсутствующих значений\n               feasts,       # для разложения временных рядов и автокорреляции\n               forecast,     # построение sin и cosin по данным (примечание: необходимо загружать после feasts)\n               trending,     # построение и оценка моделей \n               tmaptools,    # для получения геокоординат (долготоа/широта) на основе названий локаций\n               ecmwfr,       # для взаимодействия с CDS API спутника copernicus \n               stars,        # для прочтения файлов .nc (климатические данные)\n               units,        # для определения единиц измерения (климатические данные)\n               yardstick,    # для рассмотрения точности модели\n               surveillance  # для выявления аберраций\n               )\n\n\n\nЗагрузка данных\nВы можете скачать все данные, используемые в данном руководстве, следуя инструкциям на странице [Скачивание руководства и данных].\nПример набора данных, используемый в данном разделе, отражает еженедельное количество случаев кампилобактера, зарегистрированных в Германии в период с 2001 по 2011.  Кликните сюда для скачивания этого файла с данными (.xlsx).\nЭтот набор данных - сокращенная версия набора данных, доступного в пакете surveillance. (для дополнительной информации загрузите пакет surveillance и посмотрите ?campyDE)\nИмпортируйте эти данные с помощью функции import() из пакета rio (он работает со многими типами файлов, такими как .xlsx, .csv, .rds - см. детали на страниец Импорт и экспорт).\n\n# импорт количества случаев в R\ncounts &lt;- rio::import(\"campylobacter_germany.xlsx\")\n\nПервые 10 строк количества случаев отображены ниже.\n\n\n\n\n\n\n\n\nВычистка данных\nКод ниже проверяет, что столбец даты находится в правильном формате. Для этой вкладки мы будем использовать пакет tsibble, так что для создания переменной календарной недели будет использоваться функция yearweek. Существует ряд других способов это сделать (см. страницу Работа с датами для получения дополнительной информации), однако для временных рядов лучше придерживаться одной системы (tsibble).\n\n## проверяем правильность формата столбца даты\ncounts$date &lt;- as.Date(counts$date)\n\n## создаем переменную календарной недели \n## соответствующую определению недель ИСПО с началом недели в понедельник\ncounts &lt;- counts %&gt;% \n     mutate(epiweek = yearweek(date, week_start = 1))\n\n\n\nСкачивание климатических данных\nВ разделе отношения между двумя временными рядами этой страницы мы будем сравнивать количество случаев кампилобактер с климатическими данными.\nКлиматические данные для любой точки мира можно скачать со спутника ЕС Copernicus. Эти измерения не являются абсолютно точными, а основаны на модели (похоже на интерполяцию), однако преимуществом является глобальный ежечасный охват и прогнозы.\nВы можете скачать эти файлы климатических данных со страницы Скачивание руководства и данных.\nВ демонстрационных целях мы покажем код R для использования пакета ecmwfr, чтобы получить эти данные из Хранилища климатических данных Copernicus. Вам нужно будет создать для этого бесплатный аккаунт. На веб-сайте пакета есть полезная пошаговая инструкция о том, как это сделать. Ниже приведен пример кода, который вы можете использовать, как только у вас будут необходимые ключи API. Вы должны заменить X ниже на свое ID аккаунта. Вам нужно скачивать по году данных за раз, иначе истекает время ожидания на сервере.\nЕсли вы не уверены в координатах нужной вам локации, для которой вы хотите скачать данные, вы можете использовать пакет tmaptools, чтобы взять координаты с open street maps. В качестве альтернативы есть пакет photon, однако он еще не выпущен на CRAN; плюс пакета photon в том, что он дает больше контекстуальных данных, когда есть несколько совпадений по вашему поиску.\n\n## получение координат места\ncoords &lt;- geocode_OSM(\"Germany\", geometry = \"point\")\n\n## свести воедино долготы/широты в формате для запросов к ERA-5 (ограничительная рамка)\n## (поскольку нужна только одна точка, можно повторить координаты)\nrequest_coords &lt;- str_glue_data(coords$coords, \"{y}/{x}/{y}/{x}\")\n\n\n## Получения данных, смоделированных спутником copernicus(ERA-5 реанализ)\n## https://cds.climate.copernicus.eu/cdsapp#!/software/app-era5-explorer?tab=app\n## https://github.com/bluegreen-labs/ecmwfr\n\n## создание ключа для погодных данных \nwf_set_key(user = \"XXXXX\",\n           key = \"XXXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXX\",\n           service = \"cds\") \n\n## выполнение для каждого интересующего года (otherwise server times out)\nfor (i in 2002:2011) {\n  \n  ## формирование запроса \n  ## см. тут как это сделать: https://bluegreen-labs.github.io/ecmwfr/articles/cds_vignette.html#the-request-syntax\n  ## изменяем запрос на список, используя кнопку добавления выше (python в list)\n  ## Target (цель) - имя файла на выходе!!\n  request &lt;- request &lt;- list(\n    product_type = \"reanalysis\",\n    format = \"netcdf\",\n    variable = c(\"2m_temperature\", \"total_precipitation\"),\n    year = c(i),\n    month = c(\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\"),\n    day = c(\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\",\n            \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\",\n            \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\"),\n    time = c(\"00:00\", \"01:00\", \"02:00\", \"03:00\", \"04:00\", \"05:00\", \"06:00\", \"07:00\",\n             \"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\", \"13:00\", \"14:00\", \"15:00\",\n             \"16:00\", \"17:00\", \"18:00\", \"19:00\", \"20:00\", \"21:00\", \"22:00\", \"23:00\"),\n    area = request_coords,\n    dataset_short_name = \"reanalysis-era5-single-levels\",\n    target = paste0(\"germany_weather\", i, \".nc\")\n  )\n  \n  ## скачиваем файл и сохраняем в текущей рабочей директории\n  file &lt;- wf_request(user     = \"XXXXX\",  # ID пользователя (для авторизации)\n                     request  = request,  # запрос\n                     transfer = TRUE,     # скачиваем файл\n                     path     = here::here(\"data\", \"Weather\")) ## путь для сохранения данных\n  }\n\n\n\nЗагрузка климатических данных\nВне зависимости от того, скачали ли вы данные по климату с помощью руководства или кода выше, у вас в одной папке на компьютере теперь должны быть в наличии файлы “.nc” с климатическими данными за 10 лет.\nИспользуйте код ниже, чтобы импортировать эти файлы в R с помощью пакета stars.\n\n## определяем путь к папке с погодными данными (weather) \nfile_paths &lt;- list.files(\n  here::here(\"data\", \"time_series\", \"weather\"), # замените на собственный путь к файлу \n  full.names = TRUE)\n\n## сохраняем только те, которые имеют интересующее нас в данный момент имя \nfile_paths &lt;- file_paths[str_detect(file_paths, \"germany\")]\n\n## прочитываем все файлы как объект stars \ndata &lt;- stars::read_stars(file_paths)\n\nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \n\n\nКак только эти файлы были импортированы как объект data, мы их конвертируем в датафрейм.\n\n## изменяем на датафрейм \ntemp_data &lt;- as_tibble(data) %&gt;% \n  ## добавляем переменные и правильные единицы измерения\n  mutate(\n    ## создаем переменную календарная неделя \n    epiweek = tsibble::yearweek(time), \n    ## создаем переменную дата (начало календарной недели)\n    date = as.Date(epiweek),\n    ## меняем температуру с градусов по Кельвину на градусы по Цельсию\n    t2m = set_units(t2m, celsius), \n    ## меняем осадки из метров в миллиметры \n    tp  = set_units(tp, mm)) %&gt;% \n  ## группируем по неделе (но сохраняем дату)\n  group_by(epiweek, date) %&gt;% \n  ## получаем среднее за неделю\n  summarise(t2m = as.numeric(mean(t2m)), \n            tp = as.numeric(mean(tp)))\n\n`summarise()` has grouped output by 'epiweek'. You can override using the\n`.groups` argument.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Временные ряды и обнаружение вспышек</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.ru.html#данные-временных-рядов",
    "href": "new_pages/time_series.ru.html#данные-временных-рядов",
    "title": "23  Временные ряды и обнаружение вспышек",
    "section": "23.3 Данные временных рядов",
    "text": "23.3 Данные временных рядов\nСуществует ряд различных пакетов для структурирования и рабботы с данными временных рядов. Как мы говорили, мы будем фокусироваться на семействе пакетов tidyverts, поэтому мы используем пакет tsibble для определения нашего объекта временного ряда. Определение набора данных как объекта временного ряда означает, что нам будет легче структурировать анализ.\nЧтобы это сделать, используем функцию tsibble() и уточним “index” (индекс), т.е. переменную, указывающую интересующую нас единицу времени. В данном случае это переменная эпиднеделя (epiweek).\nЕсли бы у нас был набор данных с еженедельным количеством случаев по провинции, например, мы бы также могли определить переменную группирования, используя аргумент key =. Это позволило бы нам проводить анализ для каждой группы.\n\n## определяем объект временного ряда \ncounts &lt;- tsibble(counts, index = epiweek)\n\nЕсли рассмотреть class(counts), вы увидите, что это не просто аккуратный датафрейм (“tbl_df”, “tbl”, “data.frame”), но у него еще есть дополнительные свойства датафрейма временного ряда (“tbl_ts”).\nВы можете быстро просмотреть свои данные, используя ggplot2. Из графика мы видим, что есть четкая сезонность, а также что нет отсутствующих данных. Однако кажется есть проблема с отчетностью в начале каждого года; количество случаев падает в последнюю неделю года, а затем увеличивается в первую неделю следующего года.\n\n## строим линейный график количества случаев по неделям\nggplot(counts, aes(x = epiweek, y = case)) + \n     geom_line()\n\n\n\n\n\n\n\n\nВНИМАНИЕ: Большинство наборов данных не такие чистые, как этот пример. Вам нужно будет проверить дубликаты и отсутствующие данные, как показано ниже. \n\n\nДубликаты\ntsibble не допускает дублирующиеся наблюдения. Поэтому каждая строка должна быть уникальной, либо уникальной внутри группы (переменная key). В пакете есть функции, которые помогают выявить дубликаты. Они включают are_duplicated(), которая даст вам вектор TRUE/FALSE (ИСТИНА/ЛОЖЬ), показывающий является ли строка дубликатом, и duplicates(), которая даст вам датафрейм дублирующихся строк.\nСм. деталио том, как выбирать нужные вам строки на странице Дедупликация.\n\n## получаем вектор TRUE/FALSE (ИСТИНА/ЛОЖЬ) того, являются ли строки дубликатами\nare_duplicated(counts, index = epiweek) \n\n## получаем датафрейм любых дублирующихся строк \nduplicates(counts, index = epiweek) \n\n\n\n\nОтсутствующие данные\nИз краткого рассмотрения данных выше мы видели, что нет отсутствующих данных, но при этом мы заметили проблему с задержкой в отчетности в районе нового года. Один из способов решить эту проблему - задать эти значения как отсутствующие и затем вменить значения. Самая простая форма вменения временных рядов - прочертить прямую линию между последним неотсутствующим и следующим неотсутствующим значением. Чтобы это сделать, мы используем функцию na_interpolation() из пакета imputeTS.\nСм. страницу Отсутствующие данные для рассмотрения других вариантов вменения.\nЕще одна альтернатива - рассчитать скользящее среднее, чтобы сгладить эти проблемы с отчетностью (см. следующий раздел и страницу Скользящие средние значения).\n\n## создаем переменную с отсутствующими значениями вместо недель с проблемами с отчетностью\ncounts &lt;- counts %&gt;% \n     mutate(case_miss = if_else(\n          ## если эпиднеделя содержит 52, 53, 1 или 2\n          str_detect(epiweek, \"W51|W52|W53|W01|W02\"), \n          ## тогда установить на отсутствующее \n          NA_real_, \n          ## в остальных случаях - сохранить значение case\n          case\n     ))\n\n## альтернативно интерполяция отсутствующих значений по линейному тренду \n## между двумя ближайшими соседними точками\ncounts &lt;- counts %&gt;% \n  mutate(case_int = imputeTS::na_interpolation(case_miss)\n         )\n\n## чтобы проверить, какие значения были вменены по сравнению с оригинальными\nggplot_na_imputations(counts$case_miss, counts$case_int) + \n  ## создаем традиционную диаграмму (с черными осями и белым фоном)\n  theme_classic()",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Временные ряды и обнаружение вспышек</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.ru.html#описательный-анализ",
    "href": "new_pages/time_series.ru.html#описательный-анализ",
    "title": "23  Временные ряды и обнаружение вспышек",
    "section": "23.4 Описательный анализ",
    "text": "23.4 Описательный анализ\n\n\nСкользящие средние значения\nЕсли в данных много шума (количество подскакивает и падает), тогда может быть полезно рассчитать скользящие средние значения. В примере ниже мы рассчитываем для каждой недели среднее количество случаев за четыре предыдущих недели. Это выравнивает данные, чтобы сделать их более легко интерпретируемыми. В нашем случае это не слишком много меняет, поэтому мы будем использовать интерполированные данные для дальнейшего анализа. См. страницу Скользящие средние значения для получения дополнительной информации.\n\n## создаем переменную скользящего среднего (работает с отсутствующими значениями)\ncounts &lt;- counts %&gt;% \n     ## создаем переменную ma_4w \n     ## скользим по каждой строке переменной case (случаи)\n     mutate(ma_4wk = slider::slide_dbl(case, \n                               ## для каждой строки рассчитываем имя\n                               ~ mean(.x, na.rm = TRUE),\n                               ## используем 4 предыдущих недели\n                               .before = 4))\n\n## создаем визуализацию различий \nggplot(counts, aes(x = epiweek)) + \n     geom_line(aes(y = case)) + \n     geom_line(aes(y = ma_4wk), colour = \"red\")\n\n\n\n\n\n\n\n\n\n\n\nПериодичность\nНиже мы определяем пользовательскую функцию, чтобы создать периодограмму. См. страницу [Написание функций] для получения информации о том, как писать функции в R.\nСначала определяется функция. Ее аргументы включают набор данных со столбцом counts, start_week =, которая является первой неделей набора данных, число, которое указывает количество периодов в году (например, 52, 12), и наконец, стиль выходных данных (см. детали в коде ниже).\n\n## Аргументы функции\n#####################\n## x - набор данных\n## counts - переменная с данными о количестве или коэффициентами в x \n## start_week - первая неделя вашего набора данных\n## period - период, сколько единиц в году \n## output - выходные данные - вы хотите получить спектральную периодограмму или пиковые недели\n  ## \"periodogram\" или \"weeks\"\n\n# Определяем функцию\nperiodogram &lt;- function(x, \n                        counts, \n                        start_week = c(2002, 1), \n                        period = 52, \n                        output = \"weeks\") {\n  \n\n    ## убедитесь, что это не tsibble, фильтр, чтобы защитить и сохранить только интересующие столбцы\n    prepare_data &lt;- dplyr::as_tibble(x)\n    \n    # готовим данные: prepare_data &lt;- prepare_data[prepare_data[[strata]] == j, ]\n    prepare_data &lt;- dplyr::select(prepare_data, {{counts}})\n    \n    ## создаем промеждуточный временной ряд \"zoo\", чтобы использовать для spec.pgram\n    zoo_cases &lt;- zoo::zooreg(prepare_data, \n                             start = start_week, frequency = period)\n    \n    ## получаем спектральную периодограмму, не используя быстрые трансформации фурье \n    periodo &lt;- spec.pgram(zoo_cases, fast = FALSE, plot = FALSE)\n    \n    ## на выходе получаем пиковые недели \n    periodo_weeks &lt;- 1 / periodo$freq[order(-periodo$spec)] * period\n    \n    if (output == \"weeks\") {\n      periodo_weeks\n    } else {\n      periodo\n    }\n    \n}\n\n## получаем спектральную периодограмму для извлечения недель с саамыми высокими частотами \n## (проверка сезонности) \nperiodo &lt;- periodogram(counts, \n                       case_int, \n                       start_week = c(2002, 1),\n                       output = \"periodogram\")\n\n## переносим спектр и частоту в датафрейм для построения графика\nperiodo &lt;- data.frame(periodo$freq, periodo$spec)\n\n## строим периодограмму, показывающую наиболее часто возникающую периодичность \nggplot(data = periodo, \n                aes(x = 1/(periodo.freq/52),  y = log(periodo.spec))) + \n  geom_line() + \n  labs(x = \"Period (Weeks)\", y = \"Log(density)\")\n\n\n\n\n\n\n\n## получаем вектор недель в возрастающем порядке \npeak_weeks &lt;- periodogram(counts, \n                          case_int, \n                          start_week = c(2002, 1), \n                          output = \"weeks\")\n\nПРИМЕЧАНИЕ: Можно использовать указанные выше недели, чтобы добавить их в условия sin и cosine, однако мы будем использовать функцию для генерации этих условий (см. раздел регрессия ниже) \n\n\n\nРазложение\nКлассическое разложение используется для разбивки временного ряда на несколько частей, которые при рассмотрении вместе создают закономерности, которые вы видите. Эти различные части включают:\n\nЦикл тренда (долгосрочное направление данных)\n\nСезонность (повторяющиеся закономерности)\n\nСлучайность (то, что осталось после удаления тренда и сезонности)\n\n\n## разложим набор данных counts \ncounts %&gt;% \n  # используя аддитивную классическую модель разложения\n  model(classical_decomposition(case_int, type = \"additive\")) %&gt;% \n  ## извлекаем важную информацию из модели\n  components() %&gt;% \n  ## генерируем график \n  autoplot()\n\n\n\n\n\n\n\n\n\n\n\nАвтокорреляция\nАвтокорреляция показывает вам отношения между количеством каждой недели и недель до нее (называемых лагами).\nИспользуя функцию ACF(), мы можем создать график, который покажет нам количество линий для отношения при разных лагах. То, где лаг составляет 0 (x = 0), эта линия всегда будет 1, так как она показывает отношение между наблюдением и самим собой (здесь не показано). Первая линия, показанная здесь (x = 1), отражает отношениие между каждым наблюдением и наблюдением перед ним (лаг 1), вторая - показывает отношение между каждым наблюдением и предпоследним наблюдением до него (лаг 2) и так далее до лага 52, который отражает отношение между каждым наблюдением и наблюдением за 1 год до этого (52 недели ранее).\nПри использовании функции PACF() (для частичной автокорреляции) мы увидим тот же тип отношений, но скорректированный для всех промежуточных недель. Это менее информативно для определения периодичности.\n\n## используем набор данных количества случаев counts\ncounts %&gt;% \n  ## рассчитываем автокорреляцию, используя лаги на 1 год\n  ACF(case_int, lag_max = 52) %&gt;% \n  ## показываем график\n  autoplot()\n\n\n\n\n\n\n\n## используем набор данных количества случаев counts \ncounts %&gt;% \n  ## рассчитываем частичную автокорреляцию, используя лаги за полный год\n  PACF(case_int, lag_max = 52) %&gt;% \n  ## показываем график\n  autoplot()\n\n\n\n\n\n\n\n\nВы можете формально протестировать нулевую гипотезу независимости во временном ряде (т.е. что нет автокорреляции), используя тест Льюнг-Бокса (в пакете stats). Значительное p-значение указывает на то, что существует автокорреляция в данных.\n\n## тест на независимость \nBox.test(counts$case_int, type = \"Ljung-Box\")\n\n\n    Box-Ljung test\n\ndata:  counts$case_int\nX-squared = 462.65, df = 1, p-value &lt; 2.2e-16",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Временные ряды и обнаружение вспышек</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.ru.html#построение-регрессий",
    "href": "new_pages/time_series.ru.html#построение-регрессий",
    "title": "23  Временные ряды и обнаружение вспышек",
    "section": "23.5 Построение регрессий",
    "text": "23.5 Построение регрессий\nДля временного ряда можно построить большое количество разных регрессий, однако здесь мы продемонстрируем, как построить отрицательную биномиальную регрессию - так как часто она является наиболее подходящей для данных об абсолютном количестве для инфекционных заболеваний.\n\n\nУсловия Фурье\nУсловия Фурье - эквивалент кривых синуса и косинуса. Разница состоит в том, что они строятся на основе поиска наиболее подходящей комбинации кривых для объяснения ваших данных.\nПостроение только одного условия фурье будет эквивалентно построению синусоиды и косинусоиды для наиболее часто встречающегося лага в периодограмме (в нашем случае 52 недели). Мы используем функцию fourier() из пакета forecast.\nВ коде ниже мы проводим присваивание с помощью $, поскольку fourier() выдает два столбца (один для синуса и один для косинуса), они добавляются в набор данных в виде списка под названием “fourier” - но этот список затем можно использовать как обычную переменную в регрессии.\n\n## добавляем условия фурье, используя переменные epiweek и case_int\ncounts$fourier &lt;- select(counts, epiweek, case_int) %&gt;% \n  fourier(K = 1)\n\n\n\n\nОтрицательная биномиальная\nМожно построить регрессии, используя базовые функции stats или MASS (например, lm(), glm() и glm.nb()). Однако мы будем использовать функции из пакета trending, так как они позволяют рассчитывать соответствующие доверительные интервалы и интервалы прогнозирования (которые иначе недоступны). Синтаксис тот же самый, и вы задаете переменную результата, затем тильда (~), а затем добавляете различные интересующие переменные воздействия, отделяемые знаками плюс (+).\nЕще отличие заключается в том, что мы сначала определяем модель, а затем строим ее с помощью fit() с использованием данных. Это полезно, поскольку это позволяет сравнивать несколько разных моделей\nс одинаковым синтаксисом.\nСОВЕТ: Если вы хотите использовать коэффициенты, а не абсолютное количество, вытможете включить популяционную переменную в качестве логарифмического условия смещения, добавив offset(log(population). Затем нужно задать популяцию как 1, прежде чем использовать predict(), чтобы получить коэффициент. \nСОВЕТ: Чтобы построить более сложные модели, такие как ARIMA или prophet, см. пакет fable.\n\n## определяем модель, которую хотим построить (отрицательная биномиальная) \nmodel &lt;- glm_nb_model(\n  ## задаем количество случаев как интересующий результат\n  case_int ~\n    ## используем эпиднедели (epiweek), чтобы учесть тренд\n    epiweek +\n    ## используем условия фурье, чтобы учесть сезонность\n    fourier)\n\n## строим модель, используя набор данных counts\nfitted_model &lt;- trending::fit(model, data.frame(counts))\n\n## рассчитываем доверительные интервалы и интервалы прогнозирования \nobserved &lt;- predict(fitted_model, simulate_pi = FALSE)\n\nestimate_res &lt;- data.frame(observed$result)\n\n## строим график регрессии \nggplot(data = estimate_res, aes(x = epiweek)) + \n  ## добавляем линию с оценкой модели\n  geom_line(aes(y = estimate),\n            col = \"Red\") + \n  ## добавляем полосу интервалов прогнозирования \n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## добавляем линию для наблюдаемого количества случаев\n  geom_line(aes(y = case_int), \n            col = \"black\") + \n  ## создаем традиционный график (с черными осями и белым фоном)\n  theme_classic()\n\n\n\n\n\n\n\n\n\n\n\nОстатки\nЧтобы посмотреть, насколько хорошо наша модель соответствует наблюдаемым данным, необходимо посмотреть на остатки. Остатки - разница между наблюдаемым количеством и количеством, оцененным моделью Мы можем их рассчитать просто с помощью case_int - estimate, но функция residuals() извлекает их для нас напрямую из регрессии.\nЧто мы видим ниже - мы не объяснили все что мы не объясняем всю вариацию которые мы могли бы объяснить с помощью этой модели. Возможно, нам следует подобрать больше условий Фурье, и обратить внимание на амплитуду. Однако для данного примера мы оставим все как есть. Графики показывают нам, что модель дает более плохие результаты в периоды пиков и минимумов (когда количество случаев самое большое или самое низкое) и что модель с большей вероятностью недооценивает наблюдаемое количество.\n\n## рассчитываем остатки \nestimate_res &lt;- estimate_res %&gt;% \n  mutate(resid = fitted_model$result[[1]]$residuals)\n\n## достаточно ли постоянны остатки в разные периоды времени (если нет: вспышки? изменение практики?)\nestimate_res %&gt;%\n  ggplot(aes(x = epiweek, y = resid)) +\n  geom_line() +\n  geom_point() + \n  labs(x = \"epiweek\", y = \"Residuals\")\n\n\n\n\n\n\n\n## есть ли автокорреляция в остатках (есть ли закономерности в ошибке?)  \nestimate_res %&gt;% \n  as_tsibble(index = epiweek) %&gt;% \n  ACF(resid, lag_max = 52) %&gt;% \n  autoplot()\n\n\n\n\n\n\n\n## имеют ли остатки нормальное распределение (недооценивание или переоценивание?)  \nestimate_res %&gt;%\n  ggplot(aes(x = resid)) +\n  geom_histogram(binwidth = 100) +\n  geom_rug() +\n  labs(y = \"count\") \n\n\n\n\n\n\n\n## сравниваем наблюдаемое количество с остатками \n  ## также не должно быть закономерностей \nestimate_res %&gt;%\n  ggplot(aes(x = estimate, y = resid)) +\n  geom_point() +\n  labs(x = \"Fitted\", y = \"Residuals\")\n\n\n\n\n\n\n\n## формально тестируем автокорреляцию остатков\n## H0 - остатки представляют собой ряд с белым шумом (т.е. случайные)\n## тестируем на независимость \n## если значение p значимое, тогда не случайность\nBox.test(estimate_res$resid, type = \"Ljung-Box\")\n\n\n    Box-Ljung test\n\ndata:  estimate_res$resid\nX-squared = 336.25, df = 1, p-value &lt; 2.2e-16",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Временные ряды и обнаружение вспышек</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.ru.html#отношения-двух-временных-рядов",
    "href": "new_pages/time_series.ru.html#отношения-двух-временных-рядов",
    "title": "23  Временные ряды и обнаружение вспышек",
    "section": "23.6 Отношения двух временных рядов",
    "text": "23.6 Отношения двух временных рядов\nЗдесь мы рассмотрим использование погодных данных (в частности, температуры) для объяснения количество случаев кампилобактера.\n\n\nОбъединение наборов данных\nМы можем объединить наши наборы данных, используя переменную недели. Дополнительную информацию об объединении см. в разделе руководства Соединение данных.\n\n## используем левое соединение, чтобы у нас были только те строки, которые уже имеются в counts\n## удаляем переменную даты из temp_data (иначе она будет дублироваться)\ncounts &lt;- left_join(counts, \n                    select(temp_data, -date),\n                    by = \"epiweek\")\n\n\n\n\nОписательный анализ\nСначала постройте график ваших данных, чтобы увидеть, есть ли какие-то очевидные связи. График ниже показывает, что есть четкая связь с сезонностью двух переменных, и что пик температуры, возможно, достигается за несколько недель до пика количества случаев. Для получения дополнительной информации о повороте данных, см. раздел руководства Поворот данных.\n\ncounts %&gt;% \n  ## сохраняем интересующие нас переменные \n  select(epiweek, case_int, t2m) %&gt;% \n  ## меняем данные в длинный формат\n  pivot_longer(\n    ## используем epiweek в качестве ключа\n    !epiweek,\n    ## перемещаем имена столбцов в новый столбец \"measure\"\n    names_to = \"measure\", \n    ## перемещаем значения ячеек в новый столбец \"values\"\n    values_to = \"value\") %&gt;% \n  ## создаем график с набором данных, указанным выше\n  ## откладываем эпиднедели (epiweek) на оси x, а значения (values) (количество/градусы по Цельсию) на оси y \n  ggplot(aes(x = epiweek, y = value)) + \n    ## создаем отдельный график для температуры и количества случаев \n    ## разрешаем задать собственные оси y\n    facet_grid(measure ~ ., scales = \"free_y\") +\n    ## составляем линейный график обоих\n    geom_line()\n\n\n\n\n\n\n\n\n\n\n\nЛаги и взаимнокорреляционная функция (кросс-корреляция)\nЧтобы формально протестировать, для каких недель самая большая связь между случаями и температурой. Мы можем использовать функцию кросс-корреляции (CCF()) из пакета feasts. Вы также можете визуализировать (вместо использования arrange) с помощью функции autoplot().\n\ncounts %&gt;% \n  ## рассчитываем кросс-корреляцию между интерполированными подсчетами и температурой\n  CCF(case_int, t2m,\n      ## устанавливаем максимальный лаг на 52 недели\n      lag_max = 52, \n      ## выдаем коэффициент корреляции \n      type = \"correlation\") %&gt;% \n  ## сортируем в порядке уменьшения коэффициента корреляции \n  ## показываем наиболее связанные лаги\n  arrange(-ccf) %&gt;% \n  ## показываем только топ 10 \n  slice_head(n = 10)\n\n# A tsibble: 10 x 2 [1W]\n        lag   ccf\n   &lt;cf_lag&gt; &lt;dbl&gt;\n 1      -4W 0.749\n 2      -5W 0.745\n 3      -3W 0.735\n 4      -6W 0.729\n 5      -2W 0.727\n 6      -7W 0.704\n 7      -1W 0.695\n 8      -8W 0.671\n 9       0W 0.649\n10      47W 0.638\n\n\nТз этого мы видим, что лаг 4 недель имеет наиболее высокую корреляцию, поэтому мы создаем переменную температуры с лагом, которую включим в нашу регрессию.\nВНИМАНИЕ: Обратите внимание, что первые 4 недели данных в переменной температуры с лагом отсутствуют (NA) - так как не существует четырех недель до, из которых можно было бы получить эти данные. Чтобы использовать этот набор данных в функции trending predict(), нам нужно использовать аргумент simulate_pi = FALSE внутри predict() ниже. Если мы хотим использовать опцию симуляции, тогда нам нужно отбросить эти отсутствующие значения и сохранить как новый набор данных, добавив drop_na(t2m_lag4) во фрагмент кода ниже.\n\ncounts &lt;- counts %&gt;% \n  ## создаем новую переменную температуры с лагом 4 недели\n  mutate(t2m_lag4 = lag(t2m, n = 4))\n\n\n\n\nОтрицательная биномиальная с двумя переменными\nМы строим отрицательную биномиальную регрессию, как это делалось ранее. В этот раз добавим переменную температуры с лагом 4 недели.\nВНИМАНИЕ: Обратите внимание на использование simulate_pi = FALSE внутри аргумента predict(). Это необходимо потому, что поведение trending по умолчанию состоит в использовании пакета ciTools для оценки интервала прогнозирования. Это не работает, если есть количество NA, и также создает более детальные интервалы. См. дополнительную информацию в ?trending::predict.trending_model_fit. \n\n## определяем модель, по которой мы хотим построить регрессию (отрицательную биномиальную) \nmodel &lt;- glm_nb_model(\n  ## задаем количество случаев как интересующий результат\n  case_int ~\n    ## используем эпиднедели (epiweek), чтобы учесть тренд\n    epiweek +\n    ## используем условие фурье, чтобы учесть сезонность\n    fourier + \n    ## используем температуру с лагом 4 недели \n    t2m_lag4\n    )\n\n## строим модель с набором данных counts\nfitted_model &lt;- trending::fit(model, data.frame(counts))\n\n## рассчитываем доверительные интервалы и интервалы прогнозирования \nobserved &lt;- predict(fitted_model, simulate_pi = FALSE)\n\nЧтобы изучить индивидуальные условия, мы можем извлечь оригинальную отрицательную биномиальную регрессию из формата trending, используя get_model() и передать ее в функцию tidy() из пакета broom, чтобы получить возведенные в степень оценки и соответствующие доверительные интервалы.\nЭто нам показывает, что температура с лагом, после учета тренда и сезонности, схожа с количеством случаев (оценка ~ 1) и имеет значительную связь. Это указывает на то, что это может быть хорошей переменной для прогнозирования будущего количества случаев (так как климатические прогнозы легко доступны).\n\nfitted_model %&gt;% \n  ## извлекаем оригинальную отрицательную биномиальную регрессию\n  get_fitted_model() #%&gt;% \n\n[[1]]\n\nCall:  glm.nb(formula = case_int ~ epiweek + fourier + t2m_lag4, data = data.frame(counts), \n    init.theta = 32.80689607, link = log)\n\nCoefficients:\n (Intercept)       epiweek  fourierS1-52  fourierC1-52      t2m_lag4  \n   5.825e+00     8.464e-05    -2.850e-01    -1.954e-01     6.672e-03  \n\nDegrees of Freedom: 504 Total (i.e. Null);  500 Residual\n  (4 observations deleted due to missingness)\nNull Deviance:      2015 \nResidual Deviance: 508.2    AIC: 6784\n\n  ## получаем аккуратный датафрейм результатов\n  #tidy(exponentiate = TRUE, \n  #     conf.int = TRUE)\n\nБыстрый визуальный осмотр модели показывает, что она может лучше справиться с оценкой наблюдаемого количества случаев.\n\nestimate_res &lt;- data.frame(observed$result)\n\n## строим график регрессии \nggplot(data = estimate_res, aes(x = epiweek)) + \n  ## добавляем линию для оценки модели\n  geom_line(aes(y = estimate),\n            col = \"Red\") + \n  ## добавляем диапазон интервалов прогнозирования \n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## добавляем линию наблюдаемого количества случаев\n  geom_line(aes(y = case_int), \n            col = \"black\") + \n  ## создаем классический график (с черными осями и белым фоном)\n  theme_classic()\n\n\n\n\n\n\n\n\n\nОстатки\nМы снова исследуем остатки, чтобы проверить, насколько хорошо наша модель согласуется с наблюдаемыми данными. Результаты и интерпретация здесь аналогичны результатам предыдущей регрессии, поэтому, возможно, целесообразнее придерживаться более простой модели без температуры.\n\n## рассчитываем остатки \nestimate_res &lt;- estimate_res %&gt;% \n  mutate(resid = case_int - estimate)\n\n## достаточно ли постоянны остатки в разные периоды времени (если нет: вспышки? изменение практики?)\nestimate_res %&gt;%\n  ggplot(aes(x = epiweek, y = resid)) +\n  geom_line() +\n  geom_point() + \n  labs(x = \"epiweek\", y = \"Residuals\")\n\n\n\n\n\n\n\n## есть ли автокорреляция в остатках (есть ли закономерности в ошибке?)  \nestimate_res %&gt;% \n  as_tsibble(index = epiweek) %&gt;% \n  ACF(resid, lag_max = 52) %&gt;% \n  autoplot()\n\n\n\n\n\n\n\n## имеют ли остатки нормальное распределение (недооценивание или переоценивание?)  \nestimate_res %&gt;%\n  ggplot(aes(x = resid)) +\n  geom_histogram(binwidth = 100) +\n  geom_rug() +\n  labs(y = \"count\") \n\n\n\n\n\n\n\n## сравниваем наблюдаемое количество с остатками \n  ## также не должно быть закономерностей \nestimate_res %&gt;%\n  ggplot(aes(x = estimate, y = resid)) +\n  geom_point() +\n  labs(x = \"Fitted\", y = \"Residuals\")\n\n\n\n\n\n\n\n## формально тестируем автокорреляцию остатков\n## H0 - остатки представляют собой ряд с белым шумом (т.е. случайные)\n## тестируем на независимость \n## если значение p значимое, тогда не случайность\nBox.test(estimate_res$resid, type = \"Ljung-Box\")\n\n\n    Box-Ljung test\n\ndata:  estimate_res$resid\nX-squared = 339.52, df = 1, p-value &lt; 2.2e-16",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Временные ряды и обнаружение вспышек</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.ru.html#обнаружение-вспышки",
    "href": "new_pages/time_series.ru.html#обнаружение-вспышки",
    "title": "23  Временные ряды и обнаружение вспышек",
    "section": "23.7 Обнаружение вспышки",
    "text": "23.7 Обнаружение вспышки\nЗдесь мы продемонстрируем два (похожих) метода обнаружения вспышки. Первый метод основан на описанных выше разделах. Мы используем пакет trending, чтобы построить регрессии по предыдущим годам, а потом прогнозируем, что мы ожидаем увидеть в следующем году. Если наблюдаемое количество больше, чем мы ожидали, тогда это может указывать на вспышку. Второй метод основан на похожих принципах, но использует пакет surveillance, в котором есть ряд различных алгоритмов для выявления аберраций.\nВНИМАНИЕ: Как правило, вас интересует текущий год (где вы знаете количество только до текущей недели). Поэтому в этом примере мы представим, что мы находимся на 39 неделе 2011.\n\n\nПакет trending\nДля этого метода мы определим базовый уровень (как правило, для этого нужно около 5 лет данных). Мы строим регрессию по базовым данным, а затем используем для прогнозирования оценок на следующий год.\n\n\nДата окончания сбора данных\nЛегче всего определить ваши даты в одном месте и затем использовать их в остальном коде.\nЗдесь мы задаем дату начала (когда начались наши наблюдения) и дату окончания сбора данных (конец базового периода - и начало периода прогнозирования). ~Мы также определяем, сколько недель в интересующем нас году (том, который мы прогнозируем)~. Мы также задаем, сколько недель между нашей последней датой базового периода и последней датой для прогнозирования.\nПРИМЕЧАНИЕ: В этом примере мы представим, что мы в настоящее время находимся в конце сентября 2011 (“2011 W39”).\n\n## определяем дату начала (когда начались наблюдения)\nstart_date &lt;- min(counts$epiweek)\n\n## определяем неделю окончания сбора данных (окончание базового периода, начало периода прогнозирования)\ncut_off &lt;- yearweek(\"2010-12-31\")\n\n## определяем последнюю интересующую дату (т.е. окончание прогнозирования)\nend_date &lt;- yearweek(\"2011-12-31\")\n\n## считаем количество недель в интересующем периоде (году)\nnum_weeks &lt;- as.numeric(end_date - cut_off)\n\n\n\n\nДобавление строк\nЧтобы мы могли прогнозировать в формате tidyverse, нам нужно иметь правильное количество строк в нашем наборе данных, т.е. по одной строке для каждой недели до end_date, определенной ниже. Код ниже позволяет вам добавить эти строки по переменной группирования - например, если у нас в одном наборе данных несколько стран, мы можем сгруппировать по странам, а затем добавить строки для каждой. Функция group_by_key() из tsibble позволяет нам выполнить это группирование и затем передать\nсгруппированные данные в функции dplyr, group_modify() и add_row(). Затем мы задаем последовательность недель между одной после максимальной недели имеющейся в данных, и конечной неделей.\n\n## добавляем отсутствующие недели до конца года \ncounts &lt;- counts %&gt;%\n  ## группируем по региону\n  group_by_key() %&gt;%\n  ## для каждой группы добавляем строки от самой последней эпиднедели до конца года\n  group_modify(~add_row(.,\n                        epiweek = seq(max(.$epiweek) + 1, \n                                      end_date,\n                                      by = 1)))\n\n\n\n\nУсловия Фурье\nНам необходимо переопределить наши условия Фурье - поскольку мы хотим подогнать их только к базовой дате, а затем предсказать (экстраполировать) эти условия на следующий год. Чтобы это сделать, нам нужно объединить два полученных на выходе списка из функции fourier(); первый список для базовых данных, а второй - прогнозирует интересующий год (с помощью определения аргумента h).\nПримечание чтобы связать строки нам нужно использовать rbind() (а не bind_rows из tidyverse), поскольку столбцы фурье являются списком (не именованы индивидуально).\n\n## определяем условия фурье (sincos) \ncounts &lt;- counts %&gt;% \n  mutate(\n    ## объединяем условия фурье для недель до и после даты окончания в 2010\n    ## (примечание: условия фурье на 2011 прогнозируются)\n    fourier = rbind(\n      ## получаем условия фурье по предыдущим годам\n      fourier(\n        ## сохраняем только строки до 2011\n        filter(counts, \n               epiweek &lt;= cut_off), \n        ## включаем один набор условий sin cos \n        K = 1\n        ), \n      ## прогнозируем условия фурье на 2011 (используя базовые данные)\n      fourier(\n        ## сохраняем только строки до 2011\n        filter(counts, \n               epiweek &lt;= cut_off),\n        ## включаем один набор условий sin cos \n        K = 1, \n        ## прогнозируем на 52 недели вперед\n        h = num_weeks\n        )\n      )\n    )\n\n\n\n\nРазделение данных и построение регрессии\nТеперь нам надо разделить наш набор данных на базовый период и период прогнозирования. Это делается с помощью функции group_split() из dplyr после group_by(), что создаст список с двумя датафреймами - один до даты окончания сбора данных и один после.\nЗатем мы используем функцию pluck() из пакета purrr, чтобы извлечь наборы данных из списка (эквивалентно использованию квадратных скобок, например, dat[[1]]), и затем можем построить модель по базовым данным, а затем используем функцию predict() для интересующих нас данных после даты окончания сбора данных.\nСм. страницу [Итерация, циклы и списки], чтобы получить дополнительную информацию о purrr.\nВНИМАНИЕ: Обратите внимание на использование simulate_pi = FALSE внутри аргумента predict(). Это происходит из-за того, что поведение по умолчанию для trending - использовать пакет ciTools, чтобы оценить интервал прогнозирования. Это не работает, если есть количество NA, а также создает более детальные интервалы. см. детали в ?trending::predict.trending_model_fit. \n\n# разделяем данные для построения модели и прогнозирования\ndat &lt;- counts %&gt;% \n  group_by(epiweek &lt;= cut_off) %&gt;%\n  group_split()\n\n## определяем модель, которую мы хотим построить (отрицательная биномиальная) \nmodel &lt;- glm_nb_model(\n  ## задаем число случаев как интересующий результат\n  case_int ~\n    ## используем epiweek, чтобы учесть тренд\n    epiweek +\n    ## используем условия фурье, чтобы учесть сезонность\n    fourier\n)\n\n# определяем, какие данные использовать для построения, а какие - для прогнозирования\nfitting_data &lt;- pluck(dat, 2)\npred_data &lt;- pluck(dat, 1) %&gt;% \n  select(case_int, epiweek, fourier)\n\n# строим модель \nfitted_model &lt;- trending::fit(model, data.frame(fitting_data))\n\n# получаем доверительный интервал и оценки по построенным данным\nobserved &lt;- fitted_model %&gt;% \n  predict(simulate_pi = FALSE)\n\n# прогнозируем с данными, с которыми нужен прогноз \nforecasts &lt;- fitted_model %&gt;% \n  predict(data.frame(pred_data), simulate_pi = FALSE)\n\n## объединяем базовый и прогнозный набор данных\nobserved &lt;- bind_rows(observed$result, forecasts$result)\n\nКак и ранее, мы можем визуализировать нашу модель с помощью ggplot. Мы выделяем предупреждения красными точками для наблюдаемого количества, превышающего 95% интервал прогнозирования. В этот раз мы также добавляем вертикальную линию к подписи, чтобы показать, где начинается прогнозирование.\n\n## строим график регрессии \nggplot(data = observed, aes(x = epiweek)) + \n  ## добавляем линию для оценки модели\n  geom_line(aes(y = estimate),\n            col = \"grey\") + \n  ## добавляем полосу для интервалов прогнозирования \n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## добавляем линию для наблюдаемого количества случаев\n  geom_line(aes(y = case_int), \n            col = \"black\") + \n  ## откладываем на графике точки для наблюдаемого количества, превышающего ожидаемое\n  geom_point(\n    data = filter(observed, case_int &gt; upper_pi), \n    aes(y = case_int), \n    colour = \"red\", \n    size = 2) + \n  ## добавляем вертикальную линию и подпись, чтобы показать, где начинается прогнозирование\n  geom_vline(\n           xintercept = as.Date(cut_off), \n           linetype = \"dashed\") + \n  annotate(geom = \"text\", \n           label = \"Forecast\", \n           x = cut_off, \n           y = max(observed$upper_pi) - 250, \n           angle = 90, \n           vjust = 1\n           ) + \n  ## создаем традиционный график (с черными осями и белым фоном)\n  theme_classic()\n\nWarning: Removed 13 rows containing missing values or values outside the scale range\n(`geom_line()`).\n\n\n\n\n\n\n\n\n\n\n\n\nВалидация прогноза\nПомимо проверки остатков, важно изучить, насколько хорошо ваша модель при прогнозировании случаев в будущем. Это дает представление о том, насколько надежны ваши пороговые предупреждения.\nТрадиционный способ валидации заключается в том, чтобы проверить, насколько хорошо вы можете предсказать последний год, предшествующий текущему (поскольку вы еще не знаете подсчетов для “текущего года”). Например, в нашем наборе данных мы используем данные с 2002 по 2009 год, чтобы предсказать 2010 год, а затем посмотрим, насколько точны эти прогнозы. Затем мы перестраиваем модель, добавляя в нее данные за 2010 год и используем их для прогнозирования количествав 2011 году.\nКак можно увидеть на рисунке ниже, подготовленном Hyndman и соавторами в “Принципах и практике прогнозирования”.\n рисунок приведен с разрешения авторов\nНедостатком является то, что вы не используете все доступные для вас данные, и это не финальная модель, которую вы используете для прогноза.\nАльтернативным вариантом является использование метода, называемого кросс-валидацией. В этом сценарии перебираются все имеющиеся данные, чтобы построить несколько моделей для прогнозирования на один год вперед. В каждой модели используется все больше и больше данных, как показано на рисунке ниже из той же [работы Хиндмана и соавторов]((https://otexts.com/fpp3/). Например, первая модель использует 2002, чтобы спрогнозировать 2003, вторая использует 2002 и 2003 для прогнозирования 2004, и так далее.  рисунок приведен с разрешения авторов\nНиже мы используем функцию map() из пакета purrr, чтобы пройти цикл по каждому набору данных. Мы затем размещаем оценки в один набор данных и объединяем его с оригинальным количеством случаев, чтобы использовать пакет yardstick для расчета мер точности. Мы рассчитываем четыре меры, включая: средняя квадратическая ошибка (RMSE), средняя абсолютная ошибка\n(MAE), Средняя абсолютная масштабированная ошибка (MASE), Средняя абсолютная процентная ошибка (MAPE).\nВНИМАНИЕ: Обратите внимание на использование simulate_pi = FALSE внутри аргумента predict(). Это происходит, поскольку поведение trending по умолчанию состоит в использовании пакета ciTools для оценки интервала прогнозирования. Это не работает, если есть количество NA, а также создает более детальные интервалы. См. детали в ?trending::predict.trending_model_fit. \n\n## Перекрестная валидация: прогнозирование на неделю(и) вперед на основе скользящего окна\n\n## расширим данные путем скольжения по окнам в 52 недели (до + после) \n## чтобы спрогнозировать на 52 вперед\n## (создает все более длинные и длинные цепочки наблюдений - сохраняет более старые данные)\n\n## определяем окно, по которому мы хотим скользить\nroll_window &lt;- 52\n\n## определяем недели вперед, на которые хотим спрогнозировать \nweeks_ahead &lt;- 52\n\n## создаем набор данных повторяющихся все более длинных данных\n## подписываем каждый набор данных уникальным id\n## используем только случаи до интересующего года (т.е 2011)\ncase_roll &lt;- counts %&gt;% \n  filter(epiweek &lt; cut_off) %&gt;% \n  ## сохраняем только переменные недели и количества случаев\n  select(epiweek, case_int) %&gt;% \n    ## отбрасываем последние x наблюдений \n    ## в зависимости от того, на сколько недель вперед прогнозируем \n    ## (иначе прогноз будет до \"неизвестно\")\n    slice(1:(n() - weeks_ahead)) %&gt;%\n    as_tsibble(index = epiweek) %&gt;% \n    ## скользим по каждой недели в x по окнам, чтобы создать ID группы \n    ## в зависимости от того, что задают скользящие окна\n    stretch_tsibble(.init = roll_window, .step = 1) %&gt;% \n  ## отбрасываем первые несколько - поскольку нет случаев \"до\"\n  filter(.id &gt; roll_window)\n\n\n## для каждого уникального набора данных выполняем код ниже\nforecasts &lt;- purrr::map(unique(case_roll$.id), \n                        function(i) {\n  \n  ## сохраняем только текущий раз построения \n  mini_data &lt;- filter(case_roll, .id == i) %&gt;% \n    as_tibble()\n  \n  ## создаем пустой набор данных для прогнозирования \n  forecast_data &lt;- tibble(\n    epiweek = seq(max(mini_data$epiweek) + 1,\n                  max(mini_data$epiweek) + weeks_ahead,\n                  by = 1),\n    case_int = rep.int(NA, weeks_ahead),\n    .id = rep.int(i, weeks_ahead)\n  )\n  \n  ## добавляем данные прогноза к оригинальным \n  mini_data &lt;- bind_rows(mini_data, forecast_data)\n  \n  ## определяем последнюю дату на основе последних неотсутствующих данных о количестве \n  cv_cut_off &lt;- mini_data %&gt;% \n    ## сохраняем только неотсутствующие строки\n    drop_na(case_int) %&gt;% \n    ## получаем последнюю неделю\n    summarise(max(epiweek)) %&gt;% \n    ## извлекаем, чтобы она не была в датафрейме\n    pull()\n  \n  ## создаем mini_data в виде tsibble\n  mini_data &lt;- tsibble(mini_data, index = epiweek)\n  \n  ## определяем условия фурье (sincos) \n  mini_data &lt;- mini_data %&gt;% \n    mutate(\n    ## объединяем условия фурье для недель до и после даты окончания сбора данных\n    fourier = rbind(\n      ## получаем условия фурье по предыдущим годам\n      forecast::fourier(\n        ## сохраняем только строки до даты окончания сбора данных\n        filter(mini_data, \n               epiweek &lt;= cv_cut_off), \n        ## включаем один набор условий sin cos \n        K = 1\n        ), \n      ## прогнозируем условия фурье для следующего года (используя базовые данные)\n      fourier(\n        ## сохраняем только строки до даты окончания сбора данных\n        filter(mini_data, \n               epiweek &lt;= cv_cut_off),\n        ## включаем один набор условий sin cos \n        K = 1, \n        ## прогнозируем на 52 недели вперед\n        h = weeks_ahead\n        )\n      )\n    )\n  \n  \n  # разделяем данные для построения регрессии и прогнозирования\n  dat &lt;- mini_data %&gt;% \n    group_by(epiweek &lt;= cv_cut_off) %&gt;%\n    group_split()\n\n  ## определяем модель, которую мы хотим построить (отрицательная биномиальная) \n  model &lt;- glm_nb_model(\n    ## задаем число случаев в качестве интересующего результата\n    case_int ~\n      ## используем эпиднеделю (epiweek), чтобы учесть тренд\n      epiweek +\n      ## используем условия фурье, чтобы учесть сезонность\n      fourier\n  )\n\n  # определяем, какие данные использовать для построения регрессии и какие - для прогноза\n  fitting_data &lt;- pluck(dat, 2)\n  pred_data &lt;- pluck(dat, 1)\n  \n  # строим модель \n  fitted_model &lt;- trending::fit(model, fitting_data)\n  \n  # прогнозируем с данными, с которыми мы хотим выполнить прогноз \n  forecasts &lt;- fitted_model %&gt;% \n    predict(data.frame(pred_data), simulate_pi = FALSE)\n  forecasts &lt;- data.frame(forecasts$result[[1]]) %&gt;% \n       ## сохраняем только неделю и прогнозную оценку\n    select(epiweek, estimate)\n    \n  }\n  )\n\n## превращаем список в датафрейм со всеми прогнозами\nforecasts &lt;- bind_rows(forecasts)\n\n## соединяем прогнозы с наблюдаемыми данными\nforecasts &lt;- left_join(forecasts, \n                       select(counts, epiweek, case_int),\n                       by = \"epiweek\")\n\n## используя {yardstick} рассчитываем метрики\n  ## RMSE: средняя квадратическая ошибка\n  ## MAE:  средняя абсолютная ошибка    \n  ## MASE: средняя абсолютная масштабированная ошибка\n  ## MAPE: средняя абсолютная процентная ошибка\nmodel_metrics &lt;- bind_rows(\n  ## в вашем спрогнозированном наборе данных сравниваем наблюдаемые данные с прогнозом\n  rmse(forecasts, case_int, estimate), \n  mae( forecasts, case_int, estimate),\n  mase(forecasts, case_int, estimate),\n  mape(forecasts, case_int, estimate),\n  ) %&gt;% \n  ## сохраняем только тип метрики и его выходной результат\n  select(Metric  = .metric, \n         Measure = .estimate) %&gt;% \n  ## превращаем в широкий формат, чтобы можно было после этого связать строки\n  pivot_wider(names_from = Metric, values_from = Measure)\n\n## выдаем метрики модели \nmodel_metrics\n\n# A tibble: 1 × 4\n   rmse   mae  mase  mape\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1  252.  199.  1.96  17.3\n\n\n\n\n\n\nпакет surveillance\nВ этом разделе мы используем пакет surveillance, чтобы создать пороги предупреждения, основанные на алгоритмах обнаружения вспышек. Существуют ряд разных методов, доступных в этом пакете, однако мы сфокусируемся на двух опциях. Для получения детальной информации см. работы по применению и теории использованных алгоритмов.\nПервая опция использует улучшенный метод Фаррингтона. Он строит отрицательную биномиальную обобщенную линейную модель (glm) (включая тренд) и снижает веса прошлых вспышек (аномальных значений) для создания порогового уровня.\nВторой вариант - использовать метод glrnb. Он также строит отрицательную биномиальную обобщенную линейную модель (glm), но включает тренд и условия фурье (поэтому мы его считаем предпочтительным). Регрессия используется для расчета “контрольного среднего” (~построенные значения) - затем используется рассчитанная статистика обобщенного отношения правдоподобия, чтобы оценить, есть ли смещение среднего для каждой недели. Обратите внимание, что порог для каждой недели принимает во внимание предыдущие недели, так что есть существует устойчивый сдвиг, сработает предупреждение. (Также обратите вниимание, что после каждого срабатывания предупреждения, алгоритм перезапускается)\nЧтобы работать с пакетом surveillance, нам нужно сначала определить объект “временной ряд эпиднадзора (surveillance time series)” (используя функцию sts() ), чтобы он соответствовал рамкам.\n\n## определяем объект временной ряд эпиднадзора\n## примечание: вы можете включить знаменатель с популяционным объектом (см. ?sts)\ncounts_sts &lt;- sts(observed = counts$case_int[!is.na(counts$case_int)],\n                  start = c(\n                    ## подмножество, чтобы сохранить только год с момента start_date \n                    as.numeric(str_sub(start_date, 1, 4)), \n                    ## подмножество, чтобы сохранить только неделю с момента start_date\n                    as.numeric(str_sub(start_date, 7, 8))), \n                  ## определяем тип данных (в данном случае случаев в неделю)\n                  freq = 52)\n\n## определяем диапазон недель, которые мы хотим включить (т.е. период прогнозирования)\n## примечание: объект sts только считает наблюдения без присваивания им идентификатора \n## недели или года - поэтому мы используем наши данные, чтобы определить соответствующие наблюдения\nweekrange &lt;- cut_off - start_date\n\n\n\nМетод Фаррингтона\nМы определяем каждый из наших параметров для метода Фаррингтона в списке list. Затем мы выполняем алгоритм, используя farringtonFlexible() и затем мы можем извлечь порог предупреждения, используя farringtonmethod@upperbound, чтобы включить его в наш набор данных. Можно также извлечь ИСТИНУ/ЛОЖЬ (TRUE/FALSE) для каждой недели, чтобы узнать, сработало ли предупреждение (превышен ли порог), используя farringtonmethod@alarm.\n\n## определяем контроль\nctrl &lt;- list(\n  ## определяем для какого временного периода нам нужен порог (т.е. 2011)\n  range = which(counts_sts@epoch &gt; weekrange),\n  b = 9, ## на сколько лет назад базовый уровень\n  w = 2, ## размер скользящего окна в неделях\n  weightsThreshold = 2.58, ## изменение весов прошлых вспышек (улучшенный метод нуфайли (noufaily) - оригинальный предлагает 1)\n  ## pastWeeksNotIncluded = 3, ## используем все доступные недели (noufaily предлагает отбросить 26)\n  trend = TRUE,\n  pThresholdTrend = 1, ## 0.05 как правило, однако в улучшенном методе рекомендуется 1 (т.е. всегда сохранять)\n  thresholdMethod = \"nbPlugin\",\n  populationOffset = TRUE\n  )\n\n## применяем гибкий метод фаррингтона\nfarringtonmethod &lt;- farringtonFlexible(counts_sts, ctrl)\n\n## создаем новую переменную в оригинальном наборе данных, называемую threshold (порог)\n## содержашую верхнюю границу из фаррингтона \n## примечание: это только для недель в 2011 (так что нужно подмножество строк)\ncounts[which(counts$epiweek &gt;= cut_off & \n               !is.na(counts$case_int)),\n              \"threshold\"] &lt;- farringtonmethod@upperbound\n\nМы можем визуализировать результаты на ggplot, как это делали ранее.\n\nggplot(counts, aes(x = epiweek)) + \n  ## добавляем наблюдаемое количество случаев как линию\n  geom_line(aes(y = case_int, colour = \"Observed\")) + \n  ## добавляем верхнюю границу алгоритма аберрации\n  geom_line(aes(y = threshold, colour = \"Alert threshold\"), \n            linetype = \"dashed\", \n            size = 1.5) +\n  ## определяем цвета\n  scale_colour_manual(values = c(\"Observed\" = \"black\", \n                                 \"Alert threshold\" = \"red\")) + \n  ## создаем традиционный график (с черными осями и белым фоном)\n  theme_classic() + \n  ## удаляем заголовок легенды \n  theme(legend.title = element_blank())\n\n\n\n\n\n\n\n\n\n\n\nМетод GLRNB\nАналогично, для метода GLRNB (процедура на основе обобщенного отношения правдоподобия), мы определяем каждый из наших параметров в списке list, затем строим алгоритм и извлекаем верхние границы.\nВНИМАНИЕ: Этот метод использует “грубую силу” (похож на бутстреппинг) для расчета порогов, поэтому может занять много времени!\nСм. виньетку GLRNB для получения дополнительной информации.\n\n## определяем опции контроля\nctrl &lt;- list(\n  ## определяем, для какого периода нам нужен порог (т.е. 2011)\n  range = which(counts_sts@epoch &gt; weekrange),\n  mu0 = list(S = 1,    ## количество условий фурье (гармоник), которые нужно включить\n  trend = TRUE,   ## включать ли тренд\n  refit = FALSE), ## строить ли заново модель после каждого сигнала предупреждения\n  ## cARL = порог для статистики обобщенной линейной модели (GLR) (спорный)\n     ## 3 ~ средняя позиция для минимизации ложных срабатываний\n     ## 1 строит до 99% интервала прогнозирования glm. примечание - с изменениями после пиков (снижается порог предупреждения)\n   c.ARL = 2,\n   # theta = log(1.5), ## равняется 50% увеличению случаев во вспышке\n   ret = \"cases\"     ## выдает верхнюю границу порога как количество случаев\n  )\n\n## применяем метод glrnb\nglrnbmethod &lt;- glrnb(counts_sts, control = ctrl, verbose = FALSE)\n\n## создаем новую переменную в оригинальном наборе данных под именем threshold (порог)\n## содержащую верхнюю границу glrnb \n## примечание: это только для недель в 2011 (так что нужно подмножество строк)\ncounts[which(counts$epiweek &gt;= cut_off & \n               !is.na(counts$case_int)),\n              \"threshold_glrnb\"] &lt;- glrnbmethod@upperbound\n\nВизуализируем выходные результаты как ранее.\n\nggplot(counts, aes(x = epiweek)) + \n  ## добавляем наблюдаемое количество случаев как линию\n  geom_line(aes(y = case_int, colour = \"Observed\")) + \n  ## добавляем верхнюю границу алгоритма аберрации\n  geom_line(aes(y = threshold_glrnb, colour = \"Alert threshold\"), \n            linetype = \"dashed\", \n            size = 1.5) +\n  ## определяем цвета\n  scale_colour_manual(values = c(\"Observed\" = \"black\", \n                                 \"Alert threshold\" = \"red\")) + \n  ## создаем традиционный график (с черными осями и белым фоном)\n  theme_classic() + \n  ## удаляем заголовок легенды \n  theme(legend.title = element_blank())",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Временные ряды и обнаружение вспышек</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.ru.html#прерванные-временные-ряды",
    "href": "new_pages/time_series.ru.html#прерванные-временные-ряды",
    "title": "23  Временные ряды и обнаружение вспышек",
    "section": "23.8 Прерванные временные ряды",
    "text": "23.8 Прерванные временные ряды\nПрерванные временные ряды (также называемые сегментированная регрессия или анализ вмешательств), часто используются при оценке воздействия вакцин на заболеваемость. Но они могут использоваться для оценки широкого спекта вмешательств или заражений. Например, изменений в больничных процедурах или появление нового штамма заболевания в популяции. В данном примере представим, что появился новый штамм Кампилобактера в Германии в конце 2008, и посмотрим, повлияло ли это на количество случаев. Мы снова используем отрицательную биномиальную регрессию. В этот раз регрессия будет поделена на две части, одна до вмешательства (или в данном случае появления нового штамма) и одна после (периоды до и после). Это позволит нам рассчитать коэффициент частоты заболеваемости, сравнивающий два периода. Объяснение уравнения может прояснить ситуацию (если нет - просто игнорируйте его!).\nОтрицательную биномиальную регрессию можно определить следующим образом:\n\\[\\log(Y_t)= β_0 + β_1 \\times t+ β_2 \\times δ(t-t_0) + β_3\\times(t-t_0 )^+ + log(pop_t) + e_t\\]\nГде: \\(Y_t\\) - количество случаев, наблюдаемых во время \\(t\\)\n\\(pop_t\\) - размер популяции в 100,000 во время \\(t\\) (здесь не используется)\n\\(t_0\\) - последний год периода до (включая время перехода, если есть)\n\\(δ(x\\) - индикаторная функция (она будет it0, если x≤0 и 1 при x&gt;0)\n\\((x)^+\\) оператор отсечки (он равен x если x&gt;0 и 0 в других случаях)\n\\(e_t\\) означает остаток При необходимости можно добавить дополнительные условия тренда и сезона.\n\\(β_2 \\times δ(t-t_0) + β_3\\times(t-t_0 )^+\\) - обобщенная линейная часть периода после и равна нулю в период до. Это означает, что оценки \\(β_2\\) и \\(β_3\\) являются эффектами вмешательства.\nНам нужно пересчитать условия фурье без прогнозирования, поскольку мы используем все доступные нам данные (т.е. ретроспективно). Кроме того, нам нужно рассчитать дополнительные условия, необходимые для регрессии.\n\n## добавляем условия фурье, используя переменные epiweek и case_int\ncounts$fourier &lt;- select(counts, epiweek, case_int) %&gt;% \n  as_tsibble(index = epiweek) %&gt;% \n  fourier(K = 1)\n\n## определяем неделю вмешательства \nintervention_week &lt;- yearweek(\"2008-12-31\")\n\n## определяем переменные для регрессии \ncounts &lt;- counts %&gt;% \n  mutate(\n    ## соответствует t в формуле\n      ## количество недель (можно просто использовать напрямую переменную epiweeks)\n    # linear = row_number(epiweek), \n    ## соответствует дельта(t-t0) в формуле\n      ## период до и после вмешательства\n    intervention = as.numeric(epiweek &gt;= intervention_week), \n    ## соответствует (t-t0)^+ в формуле\n      ## количество недель после вмешательства\n      ## (выбираем более большое число между 0 и тем, что будет получено в расчетах)\n    time_post = pmax(0, epiweek - intervention_week + 1))\n\nЗатем мы используем эти условия для построения отрицательной биномиальной регрессии и создаем таблицу с процентными изменениями. Этот пример показывает, что не было существенного изменения.\nВНИМАНИЕ: Обратите внимание на использование simulate_pi = FALSE внутри аргумента predict(). Это происходит потому, что поведение по умолчанию trending состоит в том, чтобы использовать пакет ciTools для оценки интервала прогнозирования. Это не работает, если существует количество NA, и также создает более детальные интервалы. См. детали в ?trending::predict.trending_model_fit. \n\n## определяем модель, которую надо построить (отрицательная биномиальная) \nmodel &lt;- glm_nb_model(\n  ## задаем количество случаев как интересующий результат\n  case_int ~\n    ## используем эпиднеделю (epiweek), чтобы учесть тренд\n    epiweek +\n    ## используем условия фурье, чтобы учесть сезонность\n    fourier + \n    ## добавляем в периоде до или после \n    intervention + \n    ## добавляем время после вмешательства \n    time_post\n    )\n\n## строим модель, используя набор данных counts\nfitted_model &lt;- trending::fit(model, counts)\n\n## рассчитываем доверительные интервалы и интервалы прогнозирования \nobserved &lt;- predict(fitted_model, simulate_pi = FALSE)\n\n\n## показываем оценки и процентное изменение в таблице\nfitted_model %&gt;% \n  ## извлекаем оригинальную отрицательную биномиальную регрессию\n  get_model() %&gt;% \n  ## получаем аккуратный датафрейм результатов\n  tidy(exponentiate = TRUE, \n       conf.int = TRUE) %&gt;% \n  ## сохраняем только значение вмешательства \n  filter(term == \"intervention\") %&gt;% \n  ## изменяем коэффициент частоты заболеваемости на процентное изменение для оценки и ДИ \n  mutate(\n    ## для каждого из интересующих столбцов создаем новый столбец\n    across(\n      all_of(c(\"estimate\", \"conf.low\", \"conf.high\")), \n      ## применяем формулу, чтобы рассчитать процентные изменения\n            .f = function(i) 100 * (i - 1), \n      ## добавляем суффикс к именам новых столбцов \"_perc\"\n      .names = \"{.col}_perc\")\n    ) %&gt;% \n  ## сохраняем (и переименовываем) некоторые столбцы \n  select(\"IRR\" = estimate, \n         \"95%CI low\" = conf.low, \n         \"95%CI high\" = conf.high,\n         \"Percentage change\" = estimate_perc, \n         \"95%CI low (perc)\" = conf.low_perc, \n         \"95%CI high (perc)\" = conf.high_perc,\n         \"p-value\" = p.value)\n\nКак и ранее, мы можем визуализировать выходные результаты регрессии.\n\nestimate_res &lt;- data.frame(observed$result)\n\nggplot(estimate_res, aes(x = epiweek)) + \n  ## добавляем наблюдаемое количество случаев как линию\n  geom_line(aes(y = case_int, colour = \"Observed\")) + \n  ## добавляем линию для оценки модели\n  geom_line(aes(y = estimate, col = \"Estimate\")) + \n  ## добавляем полосу для интервалов прогнозирования \n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## добавляем вертикальную линию и подпись, чтобы показать, где началось прогнозирование\n  geom_vline(\n           xintercept = as.Date(intervention_week), \n           linetype = \"dashed\") + \n  annotate(geom = \"text\", \n           label = \"Intervention\", \n           x = intervention_week, \n           y = max(observed$upper_pi), \n           angle = 90, \n           vjust = 1\n           ) + \n  ## определяем цвета\n  scale_colour_manual(values = c(\"Observed\" = \"black\", \n                                 \"Estimate\" = \"red\")) + \n  ## создаем традиционный график (с черными осями и белым фоном)\n  theme_classic()\n\nWarning: Unknown or uninitialised column: `upper_pi`.\n\n\nWarning in max(observed$upper_pi): no non-missing arguments to max; returning\n-Inf",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Временные ряды и обнаружение вспышек</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.ru.html#ресурсы",
    "href": "new_pages/time_series.ru.html#ресурсы",
    "title": "23  Временные ряды и обнаружение вспышек",
    "section": "23.9 Ресурсы",
    "text": "23.9 Ресурсы\nУчебник Прогнозирование: принципы и практики\nКейсы EPIET по анализу временных рядов\nКурс Penn State Рукопись по пакету Surveillance",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Временные ряды и обнаружение вспышек</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.ru.html",
    "href": "new_pages/epidemic_models.ru.html",
    "title": "24  Моделирование эпидемий",
    "section": "",
    "text": "24.1 Обзор\nСуществует растущий набор инструментов моделирования эпидемий, который позволяет нам проводить достаточно сложные виды анализа при минимальных усилиях. В данном разделе представлен обзор того, как использовать эти инструменты для следующих целей:\nЭтот раздел не является обзором методологий и статистических методов, лежащих в основе этих инструментов, для работ по этой теме см. вкладку Ресурсы. Убедитесь, что вы понимаете эти методы, прежде чем начнете использовать эти инструменты; это позволит вам правильно интерпретировать полученные результаты.\nНиже приведен пример выходных данных, которые мы подготовим в этом разделе.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Моделирование эпидемий</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.ru.html#обзор",
    "href": "new_pages/epidemic_models.ru.html#обзор",
    "title": "24  Моделирование эпидемий",
    "section": "",
    "text": "оценка эффективного репродуктивного числа Rt и связанной с ним статистических показателей, таких как время удваивания\nподготовка краткосрочных прогнозов будущей заболеваемости",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Моделирование эпидемий</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.ru.html#подготовка",
    "href": "new_pages/epidemic_models.ru.html#подготовка",
    "title": "24  Моделирование эпидемий",
    "section": "24.2 Подготовка",
    "text": "24.2 Подготовка\nМы будем использовать два разных методов и пакетов для оценки Rt, в частности, EpiNow и EpiEstim, а также пакет projections для прогнозирования заболеваемости.\nДанный фрагмент кода показывает загрузку пакетов, необходимых для анализа. В настоящем руководстве мы фокусируемся на использовании p_load() из pacman, которая устанавливает пакет, если необходимо, и загружает его для использования. Вы можете также установить пакеты с помощью library() из базового R. См. страницу Основы R для получения дополнительной информации о пакетах R.\n\npacman::p_load(\n   rio,          # импорт файлов\n   here,         # расположение файла\n   tidyverse,    # управление данными + графика ggplot2\n   epicontacts,  # анализ сетей передачи\n   EpiNow2,      # оценка Rt\n   EpiEstim,     # оценка Rt\n   projections,  # прогнозирование заболеваемости\n   incidence2,   # работа с данными по заболеваемости\n   epitrix,      # полезные эпидемиологические функции\n   distcrete     # дискретные распределения задержек\n)\n\nМы будем использовать вычищенный построчный список для всего анализа в данном разделе. Если вы хотите выполнять шаги параллельно, кликните, чтобы скачать “вычищенный” построчный список (как файл .rds). См. страницу Скачивание руководства и данных, чтобы скачать все примеры данных, используемые в данном руководстве.\n\n# импорт вычищенного построчного списка\nlinelist &lt;- import(\"linelist_cleaned.rds\")",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Моделирование эпидемий</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.ru.html#оценка-rt",
    "href": "new_pages/epidemic_models.ru.html#оценка-rt",
    "title": "24  Моделирование эпидемий",
    "section": "24.3 Оценка Rt",
    "text": "24.3 Оценка Rt\n\nEpiNow2 или EpiEstim\nРепродуктивное число R - мера трансмиссивности заболевания и определяется как ожидаемое число вторичных случаев на один инфицированный случай. В полностью восприимчивой популяции, данное число представляет собой базовое репродуктивное число R0. Однако поскольку число восприимчивых лиц в популяции меняется в ходе вспышки или пандемии, а также по мере реализации различных мер реагирования, наиболее часто используемой мерой трансмиссивности является эффективное репродуктивное число Rt; оно определяется как ожидаемое число вторичных случаев на один инфицированный случай в определенное время t.\nПакет EpiNow2 дает наиболее продвинутые рамки для оценки Rt. У него имеются два ключевых преимущества по сравнению с другим часто используемым пакетом, EpiEstim:\n\nОн учитывает задержку в регистрации, следовательно может оценить Rt, даже если последние данные неполные.\nОн оценивает Rt в даты заражения, а не даты возникновения симпмтомов или регистрации, что означает, чтор эффект вмешательства будет немедленно отображаться в изменении в Rt, а не с задержкой.\n\nОднако у него имеются два ключевых недостатка:\n\nОн требует знания распределения времени генерации (т.е. распределения задержки между заражением первичного и вторичных случаев), распределения инкубационного периода (т.е. распределения задержек между заражением и появлением симптомов), а также распределения других задержек, актуальных для ваших данных (например, если у вас есть даты отчетности, вам нужно распределение задержек от момента возникновения симптомов до даты отчетности). Хотя это обеспечивает более точную оценку Rt, EpiEstim требует только распределения серийного интервала (т.е. распределения задержек между появлением симптомов у первичного и вторичного случая), что может быть единственным доступным вам распределением.\nEpiNow2 - значительно более медленный, чем EpiEstim, в некоторых случаях в 100-1000 раз! Например, оценка Rt для примера вспышки, рассматриваемого в данном разделе, занимает около 4 часов (выполнено для большого количества итераций, чтобы обеспечить высокую точность, количество которых можно сократить, при необходимости, однако это не отменяет того, что алгоритм в целом работает медленно. Это может быть проблематичным, если вы регулярно обновляете свои оценки Rt.\n\nТо, какой пакет вы выберете, зависит от ваших данных, времени, а также доступных вычислительных мощностей.\n\n\nEpiNow2\n\nОценка распределений задержек\nРаспределения задержек, требуемые для выполнения EpiNow2, зависят от имеющихся данных. По сути, вам нужно описать задержку от даты заражения до даты события, которое вы хотите использовать для оценки Rt. Если вы используете дату появления симптомов, это будет просто распределение инкубационного периода. Если вы используете дату регистрации, вам нужна задержка между заражением и регистрацией. Поскольку это распределение вряд ли будет известно напрямую, EpiNow2 позволяет вам связать несколько распределений задержек вместе; в данном случае, задержку от заражения до появления симптомов (т.е. инкубационный период, который, скорее всего, известен), а также с момента появления симптомов до регистрации (что вы часто можете оценить, исходя из своих данных).\nПоскольку в нашем построчном списке есть даты возникновения симптомов для всех случаев, нам потребуется только распределение инкубационного периода, чтобы связать наши данные (т.е. даты возникновения симптомов) с датой заражения. Мы можем либо оценить это распределение исхода из данных, либо использовать данные из литературы.\nВ литературе оценочный инкубационный период Эболы (взят из этой работы) имеет среднее значение 9.1, стандартное отклонение 7.3, а максимальное значение 30, что записывается следующим образом:\n\nincubation_period_lit &lt;- list(\n  mean = log(9.1),\n  mean_sd = log(0.1),\n  sd = log(7.3),\n  sd_sd = log(0.1),\n  max = 30\n)\n\nОбратите внимание, что EpiNow2 требует предоставления распределений задержек в логарифмической шкале, поэтому вокруг каждого значения имеется log (кроме параметра max, который, внезапно, должен указываться в натуральных величинах). mean_sd и sd_sd задают оценки стандартного отклонения среднего значения и стандартного отклонения. Поскольку они в данном случае неизвестны, мы выбираем условное значение 0.1.\nВ данном анализе мы вместо этого оцениваем распределение инкубационного периода из самого построчного списка, используя функцию bootstrapped_dist_fit, которая построит логнормальное распределение наблюдаемых задержек между инфекцией и возникновением симптомов в построчном списке.\n\n## оценка инкубационного периода\nincubation_period &lt;- bootstrapped_dist_fit(\n  linelist$date_onset - linelist$date_infection,\n  dist = \"lognormal\",\n  max_value = 100,\n  bootstraps = 1\n)\n\nЕще одно нужное распределение - время генерации. Поскольку у нас есть данные по времени заражения и цепочкам передачи, мы можем оценить это распределение из построчного списка, рассчитав задержку между временем заражения по парам инфицирующий-инфицируемый. Чтобы это сделать, мы используем удобную функцию get_pairwise из пакета epicontacts, который позволяет нам рассчитать попарные разницы по свойствам построчного списка между парами передачи. Сначала мы создадим объект эпидконтактов (epicontacts) (см. страницу [Цепочки передачи] для получения детальной информации):\n\n## генерация контактов\ncontacts &lt;- linelist %&gt;%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %&gt;%\n  drop_na()\n\n## генерация объекта epicontacts\nepic &lt;- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n\nЗатем мы строим разницу между временем заражения по парам передачи, рассчитываем используя get_pairwise, по гамма распределению:\n\n## оцениваем гамма время генерации\ngeneration_time &lt;- bootstrapped_dist_fit(\n  get_pairwise(epic, \"date_infection\"),\n  dist = \"gamma\",\n  max_value = 20,\n  bootstraps = 1\n)\n\n\n\nВыполняем EpiNow2\nТеперь нам нужно рассчитать ежедневную заболеваемость из построчного списка, что мы легко можем сделать с помощью функций dplyr group_by() и n(). Обратите внимание, что EpiNow2 требует, чтобы названия столбцов были date и confirm.\n\n## получаем заболеваемость из дат появления симптомов\ncases &lt;- linelist %&gt;%\n  group_by(date = date_onset) %&gt;%\n  summarise(confirm = n())\n\nЗатем мы можем оценить Rt, используя функцию epinow. Несколько комментариев по вводным данным:\n\nМы можем представить любое количество ‘сцепленных’ распределений задержки в аргумент delays; Мы просто вставляем их рядом с объектом incubation_period внутри функции delay_opts.\nreturn_output обеспечит выведение выходных данных в R, а не просто сохранение в файл.\nverbose указывает, что мы хотим видеть вывод прогресса.\nhorizon указывает, на сколько дней мы хотим прогнозировать будущую заболеваемость.\nМы указываем дополнительные опции в аргументе stan, чтобы указать, на какой срок мы хотем делать предположения. Увеличение samples и chains даст вам более точную оценку, которая лучше характеризует неопределенность, однако потребует больше времени на вычисления.\n\n\n## запуск epinow\nepinow_res &lt;- epinow(\n  reported_cases = cases,\n  generation_time = generation_time,\n  delays = delay_opts(incubation_period),\n  return_output = TRUE,\n  verbose = TRUE,\n  horizon = 21,\n  stan = stan_opts(samples = 750, chains = 4)\n)\n\n\n\nАнализ выходных данных\nКак только закончится выполнение кода, мы можем легко отобразить сводную информацию. Пролистайте изображение, чтобы увидеть все детали.\n\n## выводим сводный график\nplot(epinow_res)\n\n\n\n\n\n\n\n\nМы можем также рассмотреть сводную статистику:\n\n## сводная таблица\nepinow_res$summary\n\n                                 measure                  estimate\n                                  &lt;char&gt;                    &lt;char&gt;\n1: New confirmed cases by infection date                4 (2 -- 6)\n2:        Expected change in daily cases                    Unsure\n3:            Effective reproduction no.        0.88 (0.73 -- 1.1)\n4:                        Rate of growth -0.012 (-0.028 -- 0.0052)\n5:          Doubling/halving time (days)          -60 (130 -- -25)\n    numeric_estimate\n              &lt;list&gt;\n1: &lt;data.table[1x9]&gt;\n2:              0.56\n3: &lt;data.table[1x9]&gt;\n4: &lt;data.table[1x9]&gt;\n5: &lt;data.table[1x9]&gt;\n\n\nДля дополнительного анализа и кастомизированного построения графиков, вы можете зайти в обобщенные ежедневные оценки с помощью $estimates$summarised. Мы конвертируем их из формата по умолчанию data.table в таблицу tibble для более удобного использования dplyr.\n\n## извлечение сводной информации и конвертация в tibble\nestimates &lt;- as_tibble(epinow_res$estimates$summarised)\nestimates\n\n\n\n\n\n\n\nВ качестве примера давайте построим график времени удваивания и Rt. Мы посмотрим лишь первые несколько месяцев вспышки, когда Rt составляет значительно больше единицы, чтобы избежать построения очень высокого времени удваивания.\nМы используем формулу log(2)/growth_rate для расчета времени удваивания из оценочного темпа роста.\n\n## составим широкий df для построения графика медианы\ndf_wide &lt;- estimates %&gt;%\n  filter(\n    variable %in% c(\"growth_rate\", \"R\"),\n    date &lt; as.Date(\"2014-09-01\")\n  ) %&gt;%\n  ## конвертируем темпы роста во время удваивания\n  mutate(\n    across(\n      c(median, lower_90:upper_90),\n      ~ case_when(\n        variable == \"growth_rate\" ~ log(2)/.x,\n        TRUE ~ .x\n      )\n    ),\n    ## переименовываем переменные, чтобы отразить преобразование\n    variable = replace(variable, variable == \"growth_rate\", \"doubling_time\")\n  )\n\n## составим длинный df для графика квантилей\ndf_long &lt;- df_wide %&gt;%\n  ## здесь мы сопоставляем совпадающие квантили (например lower_90 к upper_90)\n  pivot_longer(\n    lower_90:upper_90,\n    names_to = c(\".value\", \"quantile\"),\n    names_pattern = \"(.+)_(.+)\"\n  )\n\n## строим график\nggplot() +\n  geom_ribbon(\n    data = df_long,\n    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = date, y = median)\n  ) +\n  ## используем label_parsed, чтобы разрешить подстрочную подпись\n  facet_wrap(\n    ~ variable,\n    ncol = 1,\n    scales = \"free_y\",\n    labeller = as_labeller(c(R = \"R[t]\", doubling_time = \"Doubling~time\"), label_parsed),\n    strip.position = 'left'\n  ) +\n  ## вручную устанавливаем прозрачность квантилей\n  scale_alpha_manual(\n    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = NULL,\n    alpha = \"Credibel\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    strip.background = element_blank(),\n    strip.placement = 'outside'\n  )\n\n\n\n\n\n\n\n\n\n\n\n\nEpiEstim\nЧтобы выполнить EpiEstim, нам нужно задать данные по ежедневной заболеваемости и указать серийный интервал (т.е. распределение задержек между появлением симптомов первичных и вторичных случаев).\nДанные о заболеваемости могут быть заданы в EpiEstim виде вектора, датафрейма или объекта incidence из оригинального пакета incidence. Вы можете даже различать завозные и местные случаи; см. документацию ?estimate_R для получения детальной информации.\nМы создадим входные данные, используя incidence2. См. дополнительные примеры с пакетом incidence2 на странице [Эпидемические кривые]. Поскольку произошли обновления пакета incidence2, которые не совсем совпадают с ожидаемыми входными данными для estimateR(), требуются некоторые дополнительные шаги. Объект заболеваемости состоит из таблицы tibble с датами и соответствующим им количеством случаев. Мы используем complete() из tidyr, чтобы убедиться, что все даты включены (даже те, когда не было случаев), а затем rename() для переименования столбцов, чтобы они соответствовали тому, чего будет ожидать estimate_R() на последующем шаге.\n\n## получаем заболеваемость из даты появления симптомов\ncases &lt;- incidence2::incidence(linelist, date_index = \"date_onset\") %&gt;% # получаем количество случаев по дням\n  tidyr::complete(date_index = seq.Date(                              # проверяем, что все даты представлены\n    from = min(date_index, na.rm = T),\n    to = max(date_index, na.rm=T),\n    by = \"day\"),\n    fill = list(count = 0)) %&gt;%                                       # конвертируем NA в 0\n  rename(I = count,                                                   # переименовываем в имена, которые ожидает estimateR\n         dates = date_index)\n\nПакет дает несколько вариантов для указания серийного интервала, детальная информация о которых представленра в документации ?estimate_R. Мы рассмотрим два из них.\n\nИспользование оценок серийного интервала из литературы\nИспользуя опцию method = \"parametric_si\", мы можем вручную установить среднее значение и стандартное отклонение серийного интервалав объекте config, созданном используя функцию make_config. Мы используем среднее значение и стандартное отклонение 12.0 и 5.2, соответственно, взятые из этой работы:\n\n## создание config\nconfig_lit &lt;- make_config(\n  mean_si = 12.0,\n  std_si = 5.2\n)\n\nМы можем затем оценить Rt с помощью функции estimate_R:\n\ncases &lt;- cases %&gt;% \n     filter(!is.na(date))\n\n\n#создаем датафрейм для функции estimate_R()\ncases_incidence &lt;- data.frame(dates = seq.Date(from = min(cases$dates),\n                               to = max(cases$dates), \n                               by = 1))\n\ncases_incidence &lt;- left_join(cases_incidence, cases) %&gt;% \n     select(dates, I) %&gt;% \n     mutate(I = ifelse(is.na(I), 0, I))\n\nJoining with `by = join_by(dates)`\n\nepiestim_res_lit &lt;- estimate_R(\n  incid = cases_incidence,\n  method = \"parametric_si\",\n  config = config_lit\n)\n\nDefault config will estimate R on weekly sliding windows.\n    To change this change the t_start and t_end arguments. \n\n\nи выводим сводные выходные данные:\n\nplot(epiestim_res_lit)\n\n\n\n\n\n\n\n\n\n\nИспользуем оценки серийного интервала из данных\nПоскольку у нас есть данные по датам появления симптомов и цепочкам передачи, мы можем также оценить серийный интервал из построчного списка, рассчитав задержку между датами появления симптомов в парах инфицирующий-инфицируемый. Как мы это делали в разделе EpiNow2, мы используем функцию get_pairwise из пакета epicontacts, которая позволяет нам рассчитать попарные разницы в свойствах построчного списка между парами передачи. Сначала мы создаем объект epicontacts (см. страницу [Цепочки передачи] для получения детальной информации):\n\n## генерируем контакты \ncontacts &lt;- linelist %&gt;%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %&gt;%\n  drop_na()\n\n## генерируем объект epicontacts\nepic &lt;- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n\nЗатем мы строим разницу в датах появления симптомов между парами передачи, рассчитанную с помощью get_pairwise, по гамма распределению. Мы используем удобную функцию fit_disc_gamma из пакета epitrix для этой процедуры построения, так как нам нужно дискретезированное распределение.\n\n## оцениваем гамма серийный интервал\nserial_interval &lt;- fit_disc_gamma(get_pairwise(epic, \"date_onset\"))\n\nМы затем передаем эту информацию в объект config, выполняем снова EpiEstim и строим график результатов:\n\n## создаем config\nconfig_emp &lt;- make_config(\n  mean_si = serial_interval$mu,\n  std_si = serial_interval$sd\n)\n\n## выполняем epiestim\nepiestim_res_emp &lt;- estimate_R(\n  incid = cases_incidence,\n  method = \"parametric_si\",\n  config = config_emp\n)\n\nDefault config will estimate R on weekly sliding windows.\n    To change this change the t_start and t_end arguments. \n\n## строим график выходных данных\nplot(epiestim_res_emp)\n\n\n\n\n\n\n\n\n\n\nОпределение периода для времени оценки\nЭти варианты по умолчанию предоставят недельную скользящую оценку и могут служить предупреждением о том, что оцениваете Rt на слишком раннем этапе вспышки, чтобы получить точную оценку. Вы можете изменить это, установив более позднюю дату начала для оценки, как показано ниже. К сожалению, EpiEstim дает только очень тяжелый способ указания этого времени оценки, там нужно задавать вектор целых чисел, относящийся к дате начала и окончания каждого временного периода.\n\n## определяем вектор дат, начиная с 1 июня\nstart_dates &lt;- seq.Date(\n  as.Date(\"2014-06-01\"),\n  max(cases$dates) - 7,\n  by = 1\n) %&gt;%\n  ## отнимаем дату начала, чтобы конвертировать в числовое значение\n  `-`(min(cases$dates)) %&gt;%\n  ## конвертируем в целое число\n  as.integer()\n\n## добавляем 6 дней для скользящего недельного периода\nend_dates &lt;- start_dates + 6\n  \n## создаем config\nconfig_partial &lt;- make_config(\n  mean_si = 12.0,\n  std_si = 5.2,\n  t_start = start_dates,\n  t_end = end_dates\n)\n\nТеперь повторно выполним EpiEstim и мы можем увидеть, что оценки начинаются с июня:\n\n## выполняем epiestim\nepiestim_res_partial &lt;- estimate_R(\n  incid = cases_incidence,\n  method = \"parametric_si\",\n  config = config_partial\n)\n\n## строим график выходных данных\nplot(epiestim_res_partial)\n\n\n\n\n\n\n\n\n\n\nАнализ выходных данных\nДоступ к основным выходным данным можно получить через $R. В качестве примера создадим график Rt и меру “потенциала распространения”, которую получаем из произведения Rt и числа случаев, зарегистрированных в этот день; это отражает ожидаемое количество случаев в следующем поколении инфекции.\n\n## создаем широкий датафрейм для медианы\ndf_wide &lt;- epiestim_res_lit$R %&gt;%\n  rename_all(clean_labels) %&gt;%\n  rename(\n    lower_95_r = quantile_0_025_r,\n    lower_90_r = quantile_0_05_r,\n    lower_50_r = quantile_0_25_r,\n    upper_50_r = quantile_0_75_r,\n    upper_90_r = quantile_0_95_r,\n    upper_95_r = quantile_0_975_r,\n    ) %&gt;%\n  mutate(\n    ## извлекаем медианную дату из t_start и t_end\n    dates = epiestim_res_emp$dates[round(map2_dbl(t_start, t_end, median))],\n    var = \"R[t]\"\n  ) %&gt;%\n  ## объединяем с данными по ежедневной заболеваемости\n  left_join(cases, \"dates\") %&gt;%\n  ## рассчитываем риск по всем оценкам r\n  mutate(\n    across(\n      lower_95_r:upper_95_r,\n      ~ .x*I,\n      .names = \"{str_replace(.col, '_r', '_risk')}\"\n    )\n  ) %&gt;%\n  ## отделяем оценки r и оценки рисков\n  pivot_longer(\n    contains(\"median\"),\n    names_to = c(\".value\", \"variable\"),\n    names_pattern = \"(.+)_(.+)\"\n  ) %&gt;%\n  ## присваиваем уровни фактора\n  mutate(variable = factor(variable, c(\"risk\", \"r\")))\n\n## создаем длинный датафрейм из квантилей\ndf_long &lt;- df_wide %&gt;%\n  select(-variable, -median) %&gt;%\n  ## отделяем оценки r/рисков и уровни квантилей\n  pivot_longer(\n    contains(c(\"lower\", \"upper\")),\n    names_to = c(\".value\", \"quantile\", \"variable\"),\n    names_pattern = \"(.+)_(.+)_(.+)\"\n  ) %&gt;%\n  mutate(variable = factor(variable, c(\"risk\", \"r\")))\n\n## создаем график\nggplot() +\n  geom_ribbon(\n    data = df_long,\n    aes(x = dates, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = dates, y = median),\n    alpha = 0.2\n  ) +\n  ## используем label_parsed, чтобы разрешить подстрочные подписи\n  facet_wrap(\n    ~ variable,\n    ncol = 1,\n    scales = \"free_y\",\n    labeller = as_labeller(c(r = \"R[t]\", risk = \"Transmission~potential\"), label_parsed),\n    strip.position = 'left'\n  ) +\n  ## вручную задаем прозрачность квантилей\n  scale_alpha_manual(\n    values = c(`50` = 0.7, `90` = 0.4, `95` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = NULL,\n    alpha = \"Credible\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    strip.background = element_blank(),\n    strip.placement = 'outside'\n  )",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Моделирование эпидемий</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.ru.html#прогнозирование-заболеваемости",
    "href": "new_pages/epidemic_models.ru.html#прогнозирование-заболеваемости",
    "title": "24  Моделирование эпидемий",
    "section": "24.4 Прогнозирование заболеваемости",
    "text": "24.4 Прогнозирование заболеваемости\n\nEpiNow2\nКроме оценки Rt, EpiNow2 также поддерживает прогнозирование Rt и прогнозирование количества случаев с помощью внутренней интеграфии с пакетом EpiSoon. Вам нужно лишь задать аргумент horizon в функции epinow, указав на сколько дней в будущее вам нужен прогноз; см. раздел EpiNow2 в “Оценка Rt” для получения дополнительной информации о том, как получить и настроить EpiNow2. В данном разделе мы просто построим график выходных данных из анализа, хранящихся в объекте epinow_res.\n\n## определяем минимальную дату для графика\nmin_date &lt;- as.Date(\"2015-03-01\")\n\n## извлекаем сводные оценки\nestimates &lt;-  as_tibble(epinow_res$estimates$summarised)\n\n## извлекаем сырые данные по заболеваемости\nobservations &lt;- as_tibble(epinow_res$estimates$observations) %&gt;%\n  filter(date &gt; min_date)\n\n## извлекаем прогнозируемые оценки количества случаев\ndf_wide &lt;- estimates %&gt;%\n  filter(\n    variable == \"reported_cases\",\n    type == \"forecast\",\n    date &gt; min_date\n  )\n\n## конвертируем в еще более длинный формат для построения графика квантилей\ndf_long &lt;- df_wide %&gt;%\n  ## здесь мы сопоставляем соответствующие квантили (например, lower_90 с upper_90)\n  pivot_longer(\n    lower_90:upper_90,\n    names_to = c(\".value\", \"quantile\"),\n    names_pattern = \"(.+)_(.+)\"\n  )\n\n## создаем график\nggplot() +\n  geom_histogram(\n    data = observations,\n    aes(x = date, y = confirm),\n    stat = 'identity',\n    binwidth = 1\n  ) +\n  geom_ribbon(\n    data = df_long,\n    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = date, y = median)\n  ) +\n  geom_vline(xintercept = min(df_long$date), linetype = 2) +\n  ## вручную задаем прозрачность квантилей\n  scale_alpha_manual(\n    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = \"Daily reported cases\",\n    alpha = \"Credible\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14)\n\n\n\n\n\n\n\n\n\n\nПрогнозы\nПакет projections, разработанный RECON, облегчает создание краткосрочных прогнозов заболеваемости, он требует только знания эффективного репродуктивного числа Rt и серийного интервала. Здесь мы рассмотрим, как использовать оценки серийного интервала из литературы, а также как использовать наши собственные оценки из построчного списка.\n\nИспользование оценок серийного интервала из литературы\nprojections требует дискретизированного распределения серийного интервала класса distcrete из пакета distcrete. Мы будем использовать гамма распределение со средним значением 12.0 и стандартным отклонением 5.2, взятое из этой работы. Чтобы конвертировать эти значения в параметры формы и шкалы, требуемые для гамма распределения, мы будем использовать функцию gamma_mucv2shapescale из пакета epitrix.\n\n## получаем параметры формы и шкалы из среднего значения mu и коэффициента\n## вариации (например, коэффициент стандартного отклонения к среднему)\nshapescale &lt;- epitrix::gamma_mucv2shapescale(mu = 12.0, cv = 5.2/12)\n\n## создаем объект distcrete\nserial_interval_lit &lt;- distcrete::distcrete(\n  name = \"gamma\",\n  interval = 1,\n  shape = shapescale$shape,\n  scale = shapescale$scale\n)\n\nВот быстрая проверка, чтобы убедиться, что серийный интервал выглядит верно. Мы смотрим на плотность гамма распределения, которую мы только что задали с помощью $d, что эквивалентно вызову dgamma:\n\n## проверяем, чтобы убедиться, что серийный интервал выглядит верно\nqplot(\n  x = 0:50, y = serial_interval_lit$d(0:50), geom = \"area\",\n  xlab = \"Serial interval\", ylab = \"Density\"\n)\n\nWarning: `qplot()` was deprecated in ggplot2 3.4.0.\n\n\n\n\n\n\n\n\n\n\n\nИспользование оценок серийного интервала из данных\nПоскольку у нас есть данные по датам появления симптомов и цепочкам передачи, мы можем также оценить серийный интервал из построчного списка, рассчитав задержку между датам появления симптомов в парах инфицирующий-инфицируемый. Как мы это делали в разделе EpiNow2, мы вызываем функцию get_pairwise из пакета epicontacts, что позволяет нам рассчитать попарную разницу свойств построчного списка между парами передачи. Сначала мы создаем объект epicontacts (см. страницу [Цепочки передачи] для получения детальной информации):\n\n## генерируем контакты\ncontacts &lt;- linelist %&gt;%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %&gt;%\n  drop_na()\n\n## генерируем объект epicontacts\nepic &lt;- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n\nЗатем мы строим разницу в датах появления симптомов между парами передачи, рассчитанную с использованием get_pairwise, по гамма распределению. Мы используем удобную функцию fit_disc_gamma из пакета epitrix для этой процедуры построения, так как нам нужно дискретизированное распределение.\n\n## оцениваем гамма серийный интервал\nserial_interval &lt;- fit_disc_gamma(get_pairwise(epic, \"date_onset\"))\n\n## изучаем оценки\nserial_interval[c(\"mu\", \"sd\")]\n\n$mu\n[1] 11.51047\n\n$sd\n[1] 7.696056\n\n\n\n\nПрогнозирование заболеваемости\nЧтобы прогнозировать будущую заболеваемость, нам нужно задать историческую заболеваемость в форме объекта incidence, а также выборку реалистичных значений Rt. Мы сгенерируем эти значения, используя оценки Rt, сгенерированные EpiEstim в предыдущем разделе (в “Оценке Rt”) и хранящиеся в объекте epiestim_res_emp. В коде ниже мы извлекаем оценки среднего значения и стандартного отклонения для Rt для последнего временного периода вспышки (используя функцию tail для оценки последнего элемента вектора), и делаем моделирование 1000 значений из гамма распределения, используя rgamma. Вы можете также задать собственный вектор значений Rt, которые вы хотите использовать для прогнозов на будущее.\n\n## создаем объект заболеваемости из дат появления симптомов\ninc &lt;- incidence::incidence(linelist$date_onset)\n\n256 missing observations were removed.\n\n## извлекаем реалистичные значения r из наиболее свежей оценки\nmean_r &lt;- tail(epiestim_res_emp$R$`Mean(R)`, 1)\nsd_r &lt;- tail(epiestim_res_emp$R$`Std(R)`, 1)\nshapescale &lt;- gamma_mucv2shapescale(mu = mean_r, cv = sd_r/mean_r)\nplausible_r &lt;- rgamma(1000, shape = shapescale$shape, scale = shapescale$scale)\n\n## проверяем распределение\nqplot(x = plausible_r, geom = \"histogram\", xlab = expression(R[t]), ylab = \"Counts\")\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nЗатем используем функцию project(), чтобы сделать сам прогноз. Мы указываем, на сколько дней мы хотим делать прогноз, с помощью аргументов n_days, и задаем число симуляций с помощью аргумента n_sim.\n\n## делаем прогноз\nproj &lt;- project(\n  x = inc,\n  R = plausible_r,\n  si = serial_interval$distribution,\n  n_days = 21,\n  n_sim = 1000\n)\n\nЗатем мы можем построить график заболеваемости и прогнозов, используя функции plot() и add_projections(). Мы можем легко взять подмножество в объекте incidence, чтобы показать только самые последние случаи, с помощью оператора квадратных скобок.\n\n## строим график заболеваемости и прогнозов\nplot(inc[inc$dates &gt; as.Date(\"2015-03-01\")]) %&gt;%\n  add_projections(proj)\n\n\n\n\n\n\n\n\nМожно легко извлечь сырые оценочные данные по ежедневному количеству случаев, конвертировав выходные данные в датафрейм.\n\n## конвертируем в датафрейм для сырых данных\nproj_df &lt;- as.data.frame(proj)\nproj_df",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Моделирование эпидемий</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.ru.html#ресурсы",
    "href": "new_pages/epidemic_models.ru.html#ресурсы",
    "title": "24  Моделирование эпидемий",
    "section": "24.5 Ресурсы",
    "text": "24.5 Ресурсы\n\nВот страница, описывающая методологию, реализуемую в EpiEstim.\nВот страница, описывающая методологию, реализуемую в EpiNow2.\nВот страница, описывающая различные методологические и практические аспекты для оценок в Rt.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Моделирование эпидемий</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.ru.html",
    "href": "new_pages/contact_tracing.ru.html",
    "title": "25  Отслеживание контактов",
    "section": "",
    "text": "25.1 Подготовка",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Отслеживание контактов</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.ru.html#подготовка",
    "href": "new_pages/contact_tracing.ru.html#подготовка",
    "title": "25  Отслеживание контактов",
    "section": "",
    "text": "Загрузка пакетов\nДанный фрагмент кода показывает загрузку пакетов, необходимых для анализа. В данном руководстве мы фокусируемся на использовании p_load() из пакета pacman, которая устанавливает пакет, если необходимо, и загружает его для использования. Вы можете также загрузить установленные пакеты с помощью library() из базового R. См. страницу Основы R для получения дополнительной информации о пакетах R.\n\npacman::p_load(\n  rio,          # импорт данных  \n  here,         # относительные пути к файлу  \n  janitor,      # вычистка данных и таблицы\n  lubridate,    # работа с датами\n  epikit,       # функция age_categories()\n  apyramid,     # возрастные пирамиды\n  tidyverse,    # манипуляции с данными и визуализация\n  RColorBrewer, # цветовые палитры\n  formattable,  # красивые таблицы\n  kableExtra    # форматирование таблиц\n)\n\n\n\nИмпорт данных\nМы испортируем примеры наборов данных по контактам и их “мониторингу”. Эти данные были получены и разложены из Go.Data API и сохранены как файлы “.rds”.\nВы можете скачать все примеры данных для этого руководства на странице Скачивание руководства и данных.\nЕсли вы хотите скачать пример данных по отслеживанию контактов, конкретно для этой страницы, используйте три ссылки для скачивания ниже:\n Кликните, чтобы скачать данные по расследованию случаев (.rds файл) \n Кликните, чтобы скачать данные по регистрации контактов (.rds файл) \n Кликните, чтобы скачать данные по мониторингу контактов (.rds файл) \n\n\n\nВ своей оригинальной форме в скачиваемом файле данные отражают данные в той форме, в которой они предоставляются Go.Data API (читайте о API тут). Для иллюстрации мы вычистим данные, чтобы их легче было читать на этой странице. Если вы используете данные Go.Data, вы можете посмотреть подробные инструкции о том, как извлечь ваши данные тут.\nНиже мы импортируем наборы данных, используя функцию import() из пакета rio. См. страницу [Импорт и экспорт] для получения информации о разных способах импорта данных. Мы используем here(), чтобы уточнить путь к файлу - вы должны задать путь к файлу, специфичный для вашего компьютера. Затем мы используем select(), чтобы выбрать только определенные столбцы данных, чтобы упростить демонстрацию.\n\nДанные о случаях\nЭти данные являются таблицей случаев и информацией о них.\n\ncases &lt;- import(here(\"data\", \"godata\", \"cases_clean.rds\")) %&gt;% \n  select(case_id, firstName, lastName, gender, age, age_class,\n         occupation, classification, was_contact, hospitalization_typeid)\n\nВот nrow(cases) случаев:\n\n\n\n\n\n\n\n\nДанные о контактах\nЭти данные являются таблицей всех контактных лиц и информацией о них. Опять же, задайте собственный путь к файлу. После импорта мы проведем несколько предварительных шагов по вычистке данных, включая:\n\nУстанавливаем age_class как фактор и меняем порядок так, чтобы более молодой возраст шел первым\n\nВыбираем только некоторые столбцы, при этом переименовывая один из них\n\nИскусственно присваиваем строки с отсутствующим admin level 2 в “Djembe”, чтобы повысить наглядность некоторых примеров визуализации\n\n\ncontacts &lt;- import(here(\"data\", \"godata\", \"contacts_clean.rds\")) %&gt;% \n  mutate(age_class = forcats::fct_rev(age_class)) %&gt;% \n  select(contact_id, contact_status, firstName, lastName, gender, age,\n         age_class, occupation, date_of_reporting, date_of_data_entry,\n         date_of_last_exposure = date_of_last_contact,\n         date_of_followup_start, date_of_followup_end, risk_level, was_case, admin_2_name) %&gt;% \n  mutate(admin_2_name = replace_na(admin_2_name, \"Djembe\"))\n\nВот nrow(contacts) строк набора данных contacts:\n\n\n\n\n\n\n\n\nДанные о мониторинге\nЭти данные являются записями “мониторингового” взаимодействия с контактами. Мониторинг для каждого контакта должен проводиться каждый день в течение 14 дней после воздействия.\nМы импортируем и проводим некоторую вычистку. Мы выбираем некоторые столбцы, также конвертируем текстовый столбец на все строчные буквы.\n\nfollowups &lt;- rio::import(here::here(\"data\", \"godata\", \"followups_clean.rds\")) %&gt;% \n  select(contact_id, followup_status, followup_number,\n         date_of_followup, admin_2_name, admin_1_name) %&gt;% \n  mutate(followup_status = str_to_lower(followup_status))\n\nВот первые 50 строк из nrow(followups)-строчного набора данных followups (каждая строка является мониторинговым взаимодействием со статусом результата в столбце followup_status):\n\n\n\n\n\n\n\n\nДанные об отношениях\nЗдесь мы импортируем данные, показывающие отношения между случаями и контактами. Мы выбираем для показа некоторые столбцы.\n\nrelationships &lt;- rio::import(here::here(\"data\", \"godata\", \"relationships_clean.rds\")) %&gt;% \n  select(source_visualid, source_gender, source_age, date_of_last_contact,\n         date_of_data_entry, target_visualid, target_gender,\n         target_age, exposure_type)\n\nНиже представлены первые 50 строк набора данных relationships, в котором задокументированы все отношения между случаями и контактами.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Отслеживание контактов</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.ru.html#описательный-анализ",
    "href": "new_pages/contact_tracing.ru.html#описательный-анализ",
    "title": "25  Отслеживание контактов",
    "section": "25.2 Описательный анализ",
    "text": "25.2 Описательный анализ\nВы можете использовать приемы, рассмотренные на других страницах этого руководства, чтобы провести описательный анализ ваших случаев, контактов и отношений между ними. Ниже представлены некоторые примеры\n\nДемографические характеристики\nКак показано на странице, рассматривающей [Демографические пирамиды][Демографические пирамиды и шкалы Лайкерта], вы можете визуализировать возрастное и половое распределение (здесь мы используем пакет apyramid).\n\nВозраст и пол контактов\nПредставленная ниже пирамида сравнивает возрастное распределение контактов по полу. Обратите внимание, что контакты с отсутствующим возрастом включены в отдельный столбец сверху. Вы можете изменить такое поведение по умолчанию, но тогда попробуйте указать количество отсутствующих данных в подписи.\n\napyramid::age_pyramid(\n  data = contacts,                                   # используем набор данных contacts (контакты)\n  age_group = \"age_class\",                           # категориальный столбец age (возраст)\n  split_by = \"gender\") +                             # пол для половинок пирамиды\n  labs(\n    fill = \"Gender\",                                 # заголовок легенды\n    title = \"Age/Sex Pyramid of COVID-19 contacts\")+ # заголовок графика\n  theme_minimal()                                    # простой фон\n\n\n\n\n\n\n\n\nВ структуре данных Go.Data набор данных об отношениях relationships содержит возраста и случаев, и контактов, поэтому вы можете использовать этот набор данных и создать возрастную пирамиду, показывающую различия между двумя группами людей. Датафрейм relationships пройдет мутацию, чтобы преобразовать числовые столбцы возраста в категории (см. страницу [Вычистка данных и ключевые функции]). Мы также поворачиваем датафрейм вертикально, чтобы облегчить построение графика в ggplot2 (см. [Поворот данных]).\n\nrelation_age &lt;- relationships %&gt;% \n  select(source_age, target_age) %&gt;% \n  transmute(                              # transmute похожа на mutate(), но удаляет все остальные не упомянутые столбцы\n    source_age_class = epikit::age_categories(source_age, breakers = seq(0, 80, 5)),\n    target_age_class = epikit::age_categories(target_age, breakers = seq(0, 80, 5)),\n    ) %&gt;% \n  pivot_longer(cols = contains(\"class\"), names_to = \"category\", values_to = \"age_class\")  # поворачиваем вертикально\n\n\nrelation_age\n\n# A tibble: 200 × 2\n   category         age_class\n   &lt;chr&gt;            &lt;fct&gt;    \n 1 source_age_class 80+      \n 2 target_age_class 15-19    \n 3 source_age_class &lt;NA&gt;     \n 4 target_age_class 50-54    \n 5 source_age_class &lt;NA&gt;     \n 6 target_age_class 20-24    \n 7 source_age_class 30-34    \n 8 target_age_class 45-49    \n 9 source_age_class 40-44    \n10 target_age_class 30-34    \n# ℹ 190 more rows\n\n\nТеперь мы можем построить график этого преобразованного набора данных с помощью age_pyramid() как и ранее, но заменив gender на category (контакт или случай).\n\napyramid::age_pyramid(\n  data = relation_age,                               # используем модифицированный набор данных по отношениям\n  age_group = \"age_class\",                           # категориальный столбец возраста\n  split_by = \"category\") +                           # по случаям и контактам\n  scale_fill_manual(\n    values = c(\"orange\", \"purple\"),                  # уточняем цвета И подписи\n    labels = c(\"Case\", \"Contact\"))+\n  labs(\n    fill = \"Legend\",                                           # заголовок легенды\n    title = \"Age/Sex Pyramid of COVID-19 contacts and cases\")+ # заголовок графика\n  theme_minimal()                                              # простой фон\n\n\n\n\n\n\n\n\nМы также можем просмотреть другие характеристики, такие как разбивка по роду деятельности (например, в виде круговой диаграммы).\n\n# Вычищаем набор данных и считаем количество по роду деятельности\nocc_plot_data &lt;- cases %&gt;% \n  mutate(occupation = forcats::fct_explicit_na(occupation),  # делаем NA отсутствующие значения категорией\n         occupation = forcats::fct_infreq(occupation)) %&gt;%   # упорядочиваем уровни факторов в порядке частоты\n  count(occupation)                                          # получаем количество по роду деятельности\n  \n# Создаем круговую диаграмму\nggplot(data = occ_plot_data, mapping = aes(x = \"\", y = n, fill = occupation))+\n  geom_bar(width = 1, stat = \"identity\") +\n  coord_polar(\"y\", start = 0) +\n  labs(\n    fill = \"Occupation\",\n    title = \"Known occupations of COVID-19 cases\")+\n  theme_minimal() +                    \n  theme(axis.line = element_blank(),\n        axis.title = element_blank(),\n        axis.text = element_blank())\n\n\n\n\n\n\n\n\n\n\n\nКонтакты на случай\nКоличество контактов на случай может быть важной метрикой для оценки качества поиска информации о контактах и соблюдения населением мер реагирования в общественном здравоохранении.\nВ зависимости от структуры ваших данных это можно оценить с помощью набора данных, котторый содержит все случаи и контакты. В наборах данных Go.Data связи между случаями (“sources” - “источники”) и контактами (“targets” - “цели”) хранятся в наборе данных relationships.\nВ этом наборе данных каждая строка является контактом, а случай-источник указан в строке. Нет контактов, у которых были бы отношения с несколькими случаями, но если такие ситуации существуют, вам нужно принять это во внимание до построения графика (и изучить их!).\nНачнем с подсчета количества строк (контактов) на один случай-источник. Сохраняем его как датафрейм.\n\ncontacts_per_case &lt;- relationships %&gt;% \n  count(source_visualid)\n\ncontacts_per_case\n\n   source_visualid  n\n1   CASE-2020-0001 13\n2   CASE-2020-0002  5\n3   CASE-2020-0003  2\n4   CASE-2020-0004  4\n5   CASE-2020-0005  5\n6   CASE-2020-0006  3\n7   CASE-2020-0008  3\n8   CASE-2020-0009  3\n9   CASE-2020-0010  3\n10  CASE-2020-0012  3\n11  CASE-2020-0013  5\n12  CASE-2020-0014  3\n13  CASE-2020-0016  3\n14  CASE-2020-0018  4\n15  CASE-2020-0022  3\n16  CASE-2020-0023  4\n17  CASE-2020-0030  3\n18  CASE-2020-0031  3\n19  CASE-2020-0034  4\n20  CASE-2020-0036  1\n21  CASE-2020-0037  3\n22  CASE-2020-0045  3\n23            &lt;NA&gt; 17\n\n\nИспользуем geom_histogram(), чтобы построить гистограмму этих данных.\n\nggplot(data = contacts_per_case)+        # начнем с датафрейма с подсчетом, созданного выше\n  geom_histogram(mapping = aes(x = n))+  # печатаем гистограмму количества контактов на случай\n  scale_y_continuous(expand = c(0,0))+   # удаляем лишнее пространство ниже 0 на оси y\n  theme_light()+                         # упрощаем фон\n  labs(\n    title = \"Number of contacts per case\",\n    y = \"Cases\",\n    x = \"Contacts per case\"\n  )",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Отслеживание контактов</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.ru.html#мониторинг-контактов",
    "href": "new_pages/contact_tracing.ru.html#мониторинг-контактов",
    "title": "25  Отслеживание контактов",
    "section": "25.3 Мониторинг контактов",
    "text": "25.3 Мониторинг контактов\nДанные по отслеживанию контактов часто содержат данные “мониторинга”, которые документируют результаты ежедневной проверки симптомов у человека на карантине. Анализ этих данных может информировать стратегию реагирования, выявлять контакты с риском потери связи или с риском развития заболевания.\n\nВычистка данных\nЭти данные могут существовать в разных форматах. Они могут существовать в “широком” формате листа Excel с одной строкой на контакт и с одним столбцом на “день” мониторинга. См. [Поворот данных], чтобы изучить описание “длинных” и “широких” данных и то, как их поворачивать вертикально или горизонтально.\nВ нашем примере Go.Data эти данные хранятся в датафрейме followups в “длинном” формате с одной строкой на каждое мониторинговое взаимодействие. Первые 50 строк выглядят следующим образом:\n\n\n\n\n\n\nВНИМАНИЕ: Будьте осторожны с дубликатами при работе с данными мониторинга; поскольку может быть несколько ошибочных мониторинговых взаимодействий в один день для определенного контакта. Возможно, это может казаться ошибкой, а на самом деле отражает реальность - например, специалист по отслеживанию контактов мог подать форму в первой половине дня, когда не дозвонился до контакта, а затем подать вторую форму позже, когда дозвонился. Это будет зависеть от операционного контекста того, как вы хотите работать с дубликатами - просто убедитесь, что используете четкий подход. \nДавайте посмотрим, сколько у нас случаев “дублирующихся” строк:\n\nfollowups %&gt;% \n  count(contact_id, date_of_followup) %&gt;%   # получаем уникальные контакто-дни contact_days\n  filter(n &gt; 1)                             # просматриваем записи, где количество более 1  \n\n  contact_id date_of_followup n\n1       &lt;NA&gt;       2020-09-03 2\n2       &lt;NA&gt;       2020-09-04 2\n3       &lt;NA&gt;       2020-09-05 2\n\n\nВ нашем примере данных единственные данные, к которым это применимо, это те, у которых отсутствует ID! Мы можем их удалить. Но в целях демонстрации мы покажем шаги по дедупликации, чтобы было только по одному мониторинговому взаимодействию с человеком в день. См. дополнительную информацию на странице [Дедупликация]. Мы предположим, что наиболее свежая запись о взаимодействии является верной. Мы также используем эту возможность, чтобы вычистить столбец followup_number (“день” мониторинга, который должен варьироваться от 1 - 14).\n\nfollowups_clean &lt;- followups %&gt;%\n  \n  # Дедупликация\n  group_by(contact_id, date_of_followup) %&gt;%        # группируем строки по контакто-дню\n  arrange(contact_id, desc(date_of_followup)) %&gt;%   # сортируем строки по контакто-дню, по дате мониторинга (самые последние наверху)\n  slice_head() %&gt;%                                  # сохраняем только первую строку для каждого уникального идентификационного номера контакта  \n  ungroup() %&gt;% \n  \n  # Прочая вычистка\n  mutate(followup_number = replace(followup_number, followup_number &gt; 14, NA)) %&gt;% # вычищаем ошибочные данные\n  drop_na(contact_id)                               # удаляем строки с отсутствующим contact_id\n\nДля каждого мониторингового взаимодействия, у нас есть статус мониторинга (произошло ли взаимодействие, и если да, то были ли у контакта симптомы). Чтобы увидеть все значения мы можем выполнить tabyl() (из janitor) или table() (из базового R) (см. [Описательные таблицы]) по статусу мониторинга followup_status, чтобы увидеть частоту каждого результата.\nВ этом наборе данных “seen_not_ok” означает “видел, с симптомами”, а “seen_ok” означает “видел, без симптомов”.\n\nfollowups_clean %&gt;% \n  tabyl(followup_status)\n\n followup_status   n    percent\n          missed  10 0.02325581\n   not_attempted   5 0.01162791\n   not_performed 319 0.74186047\n     seen_not_ok   6 0.01395349\n         seen_ok  90 0.20930233\n\n\n\n\nПостроение графика во времени\nТак как эти данные по датам непрерывные, мы используем гистограмму, чтобы построить график с датой date_of_followup по оси x. Мы можем создать гистограмму “с накоплением”, задав аргумент fill = внутри aes(), которому мы присваиваем столбец followup_status. Потом вы можете задать заголовок легенды, используя аргумент fill = в labs().\nМы можем видеть, что контакты выявлялись волнами (что, скорее всего, отражает эпидемические волны случаев), и что выполнение мониторинга не улучшалось с течением эпидемии.\n\nggplot(data = followups_clean)+\n  geom_histogram(mapping = aes(x = date_of_followup, fill = followup_status)) +\n  scale_fill_discrete(drop = FALSE)+   # показываем все уровни фактора (followup_status) в легенде, даже если они не использованы\n  theme_classic() +\n  labs(\n    x = \"\",\n    y = \"Number of contacts\",\n    title = \"Daily Contact Followup Status\",\n    fill = \"Followup Status\",\n    subtitle = str_glue(\"Data as of {max(followups$date_of_followup, na.rm=T)}\"))   # динамический подзаголовок\n\n\n\n\n\n\n\n\nВНИМАНИЕ: Если вы готовите много графиков (например, для нескольких юрисдикций), вам нужно, чтобы легенды выглядели идентично даже при разной степени заполнения данных или разном составе. Могут быть графики, в которых присутствуют не все статусы мониторинга в данных, но вам все равно нужно, чтобы эти категории отражались в легенде. В ggplots (как выше), вы можете задать аргумент drop = FALSE в scale_fill_discrete(). В таблицах используйте tabyl(), который показывает все уровни фактора, либо если используете count() из dplyr, добавьте аргумент .drop = FALSE, чтобы включить количество для всех уровней фактора.\n\n\nЕжедневное индивидуальное отслеживание\nЕсли ваша вспышка достаточно маленькая, вы можете рассматривать каждый контакт отдельно и смотреть его статус в течение периода мониторинга. К сачатью, этот набор данных followups уже содержит столбец с “номером” дня мониторинга (1-14). Если такого столбца нет в ваших данных, вы можете его создать, рассчитав разницу между датой встречи и датой начала мониторинга для контакта.\nУдобным механизмом визуализации (если количество случаев не слишком велико) может быть тепловая диаграмма, построенная с помощью geom_tile(). См. детали на странице [Тепловая диаграмма].\n\nggplot(data = followups_clean)+\n  geom_tile(mapping = aes(x = followup_number, y = contact_id, fill = followup_status),\n            color = \"grey\")+       # серые линии сетки\n  scale_fill_manual( values = c(\"yellow\", \"grey\", \"orange\", \"darkred\", \"darkgreen\"))+\n  theme_minimal()+\n  scale_x_continuous(breaks = seq(from = 1, to = 14, by = 1))\n\n\n\n\n\n\n\n\n\n\nАнализ по группе\nВозможно эти данные по мониторингу рассматриваются на ежедневной или еженедельной основе для принятия операционных решений. Вам может потребоваться более полезная разбивка по географическим районам или по команде по отслеживанию контактов. Мы можем это сделать, скорректировав столбцы, заданные в group_by().\n\nplot_by_region &lt;- followups_clean %&gt;%                                        # начинаем с набора данных по мониторингу\n  count(admin_1_name, admin_2_name, followup_status) %&gt;%   # получаем количество по уникальному региону-статусу (создает столбец 'n' с подсчетом)\n  \n  # начинаем ggplot()\n  ggplot(                                         # начинаем ggplot\n    mapping = aes(x = reorder(admin_2_name, n),     # меняем порядок уровней фактора admin по числовым значениям в столбце 'n'\n                  y = n,                            # высоты столбцов из столбца 'n'\n                  fill = followup_status,           # столбцы с накоплением с цветом по статусу\n                  label = n))+                      # чтобы передать в geom_label()              \n  geom_col()+                                     # столбцы с накоплением, структура берется из кода выше \n  geom_text(                                      # добавляем текст, структура берется из кода выше\n    size = 3,                                         \n    position = position_stack(vjust = 0.5), \n    color = \"white\",           \n    check_overlap = TRUE,\n    fontface = \"bold\")+\n  coord_flip()+\n  labs(\n    x = \"\",\n    y = \"Number of contacts\",\n    title = \"Contact Followup Status, by Region\",\n    fill = \"Followup Status\",\n    subtitle = str_glue(\"Data as of {max(followups_clean$date_of_followup, na.rm=T)}\")) +\n  theme_classic()+                                                                      # упрощаем фон\n  facet_wrap(~admin_1_name, strip.position = \"right\", scales = \"free_y\", ncol = 1)      # добавляем фасеты \n\nplot_by_region",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Отслеживание контактов</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.ru.html#таблицы-ключевых-показателей-эффективности-kpi",
    "href": "new_pages/contact_tracing.ru.html#таблицы-ключевых-показателей-эффективности-kpi",
    "title": "25  Отслеживание контактов",
    "section": "25.4 Таблицы ключевых показателей эффективности (KPI)",
    "text": "25.4 Таблицы ключевых показателей эффективности (KPI)\nСуществует ряд разных ключевых показателей эффективности (KPI), которые можно рассчитать и отслеживать на разных уровнях дезагрегации и в разные временные периоды, чтобы осуществлять мониторинг эффективности отслеживания контактов. Как только у вас готовы расчеты и формат базовой таблицы, легко менять разные показатели KPI.\nСуществует ряд источников KPI для отслеживания контактов, например в ResolveToSaveLives.org. Самая основная часть работы - просмотреть вашу структуру данных и подумать о всех критериях включения/исключения. Ниже мы покажем несколько примеров; используя структуру метаданных Go.Data:\n\n\n\n\n\n\n\n\n\nКатегория\nИндикатор\nЧислитель Go.Data\nЗнаменатель Go.Data\n\n\n\n\nИндикатор Процесса - Скорость отслеживания контактов\n% случаев, проинтервьюированных и изолированных в течение 24 ч с момента регистрации случаев\nКОЛИЧЕСТВО case_id, ГДЕ (date_of_reporting - date_of_data_entry) &lt; 1 дня И (isolation_startdate - date_of_data_entry) &lt; 1 дня\nКОЛИЧЕСТВО case_id\n\n\nИндикатор Процесса - Скорость отслеживания контактов\n% контактов, уведомленных и отправленных на карантин в течение 24 ч после получения о них информации\nКОЛИЧЕСТВО contact_id, ГДЕ followup_status == “SEEN_NOT_OK” ИЛИ “SEEN_OK” И date_of_followup - date_of_reporting &lt; 1 дня\nКОЛИЧЕСТВО contact_id\n\n\nИндикатор Процесса - Полнота тестирования\n% новых симптоматических случаев, протестированных и проинтервьюированных в течение 3 дней с момента появления симптомов\nКОЛИЧЕСТВО case_id, ГДЕ (date_of_reporting - date_of_onset) &lt; =3 дней\nКОЛИЧЕСТВО case_id\n\n\nИндикатор Результата - Общий\n% новых случаев среди существующего списка контактов\nКОЛИЧЕСТВО case_id, ГДЕ was_contact == “TRUE”\nКОЛИЧЕСТВО case_id\n\n\n\nНиже мы пошагово рассмотрим пример упражнения с созданием красивой визуальной таблицы, чтобы отразить мониторинг контактов по административным районам. В конце мы подготовим таблицу для презентации с помощью пакета formattable (но вы можете использовать другие пакеты, например, flextable - см. [Таблицы для презентации]).\nТо, как вы создаете такую таблицу, будет зависеть от структуры ваших данных по отслеживанию контактов. На странице [Описательные таблицы] вы можете узнать, как обобщать данные, используя функции dplyr.\nМы создадим таблицу, которая будет меняться по мере изменения данных. Чтобы сделать результаты интересными, мы зададим дату отчета report_date, чтобы мы могли имитировать подготовку таблицы в определенный день (мы выбираем 10 июня 2020). Данные будут отфильтрованы по этой дате.\n\n# Устанавливаем дату отчета, чтобы имитировать подготовку отчета с данными \"по состоянию на\" эту дату\nreport_date &lt;- as.Date(\"2020-06-10\")\n\n# создаем данные мониторинга, которые отражают дату отчета.\ntable_data &lt;- followups_clean %&gt;% \n  filter(date_of_followup &lt;= report_date)\n\nТеперь на основе нашей структуры данных мы сделаем следующее:\n\nНачинаем с данных followups и обобщаем их, чтобы для каждого уникального контакта они содержали:\n\n\n\nдату последней записи (не важно, каков статус взаимодействия)\n\nдату последнего взаимодействия, где контакт “видели”\nстатус взаимодействия при последнем взаимодействии, где контакт “видели” (например, симптомы, без симптомов)\n\n\n\nСоедините эти данные с данными по контактам, которые содержат другую информацию, такую как общий статус контакта, дата контакта со случаем и т.п. Кроме того, мы рассчитаем интересующие метрики для каждого контакта, например, количество дней с момента последнего воздействия\n\nМы группируем расширенные данные по контактам по географическим регионам (admin_2_name) и рассчитываем сводную статистику по региону\n\nНаконец, мы форматируем таблицу для презентации\n\nСначала обобщим данные мониторинга, чтобы получить интересующую информацию:\n\nfollowup_info &lt;- table_data %&gt;% \n  group_by(contact_id) %&gt;% \n  summarise(\n    date_last_record   = max(date_of_followup, na.rm=T),\n    date_last_seen     = max(date_of_followup[followup_status %in% c(\"seen_ok\", \"seen_not_ok\")], na.rm=T),\n    status_last_record = followup_status[which(date_of_followup == date_last_record)]) %&gt;% \n  ungroup()\n\nВот как выглядят эти данные:\n\n\n\n\n\n\nТеперь мы добавим эту информацию к набору данных contacts и рассчитаем некоторые дополнительные столбцы.\n\ncontacts_info &lt;- followup_info %&gt;% \n  right_join(contacts, by = \"contact_id\") %&gt;% \n  mutate(\n    database_date       = max(date_last_record, na.rm=T),\n    days_since_seen     = database_date - date_last_seen,\n    days_since_exposure = database_date - date_of_last_exposure\n    )\n\nВот как выглядят эти данные. Обратите внимание на столбец contacts справа, а также новый самый правый рассчитанный столбец.\n\n\n\n\n\n\nДалее мы обобщим данные по контакту по региону, чтобы получить краткий датафрейм столбцов сводной статистики.\n\ncontacts_table &lt;- contacts_info %&gt;% \n  \n  group_by(`Admin 2` = admin_2_name) %&gt;%\n  \n  summarise(\n    `Registered contacts` = n(),\n    `Active contacts`     = sum(contact_status == \"UNDER_FOLLOW_UP\", na.rm=T),\n    `In first week`       = sum(days_since_exposure &lt; 8, na.rm=T),\n    `In second week`      = sum(days_since_exposure &gt;= 8 & days_since_exposure &lt; 15, na.rm=T),\n    `Became case`         = sum(contact_status == \"BECAME_CASE\", na.rm=T),\n    `Lost to follow up`   = sum(days_since_seen &gt;= 3, na.rm=T),\n    `Never seen`          = sum(is.na(date_last_seen)),\n    `Followed up - signs` = sum(status_last_record == \"Seen_not_ok\" & date_last_record == database_date, na.rm=T),\n    `Followed up - no signs` = sum(status_last_record == \"Seen_ok\" & date_last_record == database_date, na.rm=T),\n    `Not Followed up`     = sum(\n      (status_last_record == \"NOT_ATTEMPTED\" | status_last_record == \"NOT_PERFORMED\") &\n        date_last_record == database_date, na.rm=T)) %&gt;% \n    \n  arrange(desc(`Registered contacts`))\n\n\n\n\n\n\n\nИ теперь мы применим стилизацию из пакетов formattable и knitr, включая сноску, которая покажет дату “по состоянию на”.\n\ncontacts_table %&gt;%\n  mutate(\n    `Admin 2` = formatter(\"span\", style = ~ formattable::style(\n      color = ifelse(`Admin 2` == NA, \"red\", \"grey\"),\n      font.weight = \"bold\",font.style = \"italic\"))(`Admin 2`),\n    `Followed up - signs`= color_tile(\"white\", \"orange\")(`Followed up - signs`),\n    `Followed up - no signs`= color_tile(\"white\", \"#A0E2BD\")(`Followed up - no signs`),\n    `Became case`= color_tile(\"white\", \"grey\")(`Became case`),\n    `Lost to follow up`= color_tile(\"white\", \"grey\")(`Lost to follow up`), \n    `Never seen`= color_tile(\"white\", \"red\")(`Never seen`),\n    `Active contacts` = color_tile(\"white\", \"#81A4CE\")(`Active contacts`)\n  ) %&gt;%\n  kable(\"html\", escape = F, align =c(\"l\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\")) %&gt;%\n  kable_styling(\"hover\", full_width = FALSE) %&gt;%\n  add_header_above(c(\" \" = 3, \n                     \"Of contacts currently under follow up\" = 5,\n                     \"Status of last visit\" = 3)) %&gt;% \n  kableExtra::footnote(general = str_glue(\"Data are current to {format(report_date, '%b %d %Y')}\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOf contacts currently under follow up\n\n\nStatus of last visit\n\n\n\nAdmin 2\nRegistered contacts\nActive contacts\nIn first week\nIn second week\nBecame case\nLost to follow up\nNever seen\nFollowed up - signs\nFollowed up - no signs\nNot Followed up\n\n\n\n\nDjembe \n59\n30\n44\n0\n2\n15\n22\n0\n0\n0\n\n\nTrumpet\n3\n1\n3\n0\n0\n0\n0\n0\n0\n0\n\n\nVenu \n2\n0\n0\n0\n2\n0\n2\n0\n0\n0\n\n\nCongas \n1\n0\n0\n0\n1\n0\n1\n0\n0\n0\n\n\nCornet \n1\n0\n1\n0\n1\n0\n1\n0\n0\n0\n\n\n\nNote: \n\n\n\n\n\n\n\n\n\n\n\n\n Data are current to Jun 10 2020",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Отслеживание контактов</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.ru.html#матрица-распространения",
    "href": "new_pages/contact_tracing.ru.html#матрица-распространения",
    "title": "25  Отслеживание контактов",
    "section": "25.5 Матрица распространения",
    "text": "25.5 Матрица распространения\nКак обсуждалось на странице [Тепловые диаграммы], вы можете создать матрицу того, “кто кого заразил”, используя geom_tile().\nКогда создаются новые контакты, Go.Data хранит информацию об отношениях в конечной точке API relationships; мы можем видеть первые 50 строк этого набора данных ниже. Это означает, что мы можем создать тепловую диаграмму с относительно небольшим количеством шагов, учитывая, что каждый контакт уже соединен со случаем-источником.\n\n\n\n\n\n\nКак сделано выше для возрастной пирамиды, сравнивающей случаи и контакты, мы можем выбрать несколько переменных, которые нам нужны, и создать столбцы с категориальными группами возраста как для источников (случаев), так и целей (контактов).\n\nheatmap_ages &lt;- relationships %&gt;% \n  select(source_age, target_age) %&gt;% \n  mutate(                              # transmute похожа на mutate(), но удаляет все остальные столбцы\n    source_age_class = epikit::age_categories(source_age, breakers = seq(0, 80, 5)),\n    target_age_class = epikit::age_categories(target_age, breakers = seq(0, 80, 5))) \n\nКак описывалось ранее, мы создаем перекрестную табуляцию;\n\ncross_tab &lt;- table(\n  source_cases = heatmap_ages$source_age_class,\n  target_cases = heatmap_ages$target_age_class)\n\ncross_tab\n\n            target_cases\nsource_cases 0-4 5-9 10-14 15-19 20-24 25-29 30-34 35-39 40-44 45-49 50-54\n       0-4     0   0     0     0     0     0     0     0     0     1     0\n       5-9     0   0     1     0     0     0     0     1     0     0     0\n       10-14   0   0     0     0     0     0     0     0     0     0     0\n       15-19   0   0     0     0     0     0     0     0     0     0     0\n       20-24   1   1     0     1     2     0     2     1     0     0     0\n       25-29   1   2     0     0     0     0     0     0     0     0     0\n       30-34   0   0     0     0     0     0     0     0     1     1     0\n       35-39   0   2     0     0     0     0     0     0     0     1     0\n       40-44   0   0     0     0     1     0     2     1     0     3     1\n       45-49   1   2     2     0     0     0     3     0     1     0     3\n       50-54   1   2     1     2     0     0     1     0     0     3     4\n       55-59   0   1     0     0     1     1     2     0     0     0     0\n       60-64   0   0     0     0     0     0     0     0     0     0     0\n       65-69   0   0     0     0     0     0     0     0     0     0     0\n       70-74   0   0     0     0     0     0     0     0     0     0     0\n       75-79   0   0     0     0     0     0     0     0     0     0     0\n       80+     1   0     0     2     1     0     0     0     1     0     0\n            target_cases\nsource_cases 55-59 60-64 65-69 70-74 75-79 80+\n       0-4       1     0     0     0     0   0\n       5-9       1     0     0     0     0   0\n       10-14     0     0     0     0     0   0\n       15-19     0     0     0     0     0   0\n       20-24     1     0     0     0     0   1\n       25-29     0     0     0     0     0   0\n       30-34     1     0     0     0     0   0\n       35-39     0     0     0     0     0   0\n       40-44     1     0     0     0     1   1\n       45-49     2     1     0     0     0   1\n       50-54     1     0     1     0     0   1\n       55-59     0     0     0     0     0   0\n       60-64     0     0     0     0     0   0\n       65-69     0     0     0     0     0   0\n       70-74     0     0     0     0     0   0\n       75-79     0     0     0     0     0   0\n       80+       0     0     0     0     0   0\n\n\nконвертируйте в длинный формат с долями;\n\nlong_prop &lt;- data.frame(prop.table(cross_tab))\n\nи создайте тепловую карту для возраста.\n\nggplot(data = long_prop)+       # используем длинные данные с долями в качестве частоты\n  geom_tile(                    # визуализируем в виде плиток\n    aes(\n      x = target_cases,         # ось x - возраст случая\n      y = source_cases,     # ось y - возраст человека, который заразил\n      fill = Freq))+            # цвет плитки - столбец Freq (частота) в данных\n  scale_fill_gradient(          # скорректируйте цвет заливки плиток\n    low = \"blue\",\n    high = \"orange\")+\n  theme(axis.text.x = element_text(angle = 90))+\n  labs(                          # подписи\n    x = \"Target case age\",\n    y = \"Source case age\",\n    title = \"Who infected whom\",\n    subtitle = \"Frequency matrix of transmission events\",\n    fill = \"Proportion of all\\ntranmsission events\"     # заголовок легенды\n  )",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Отслеживание контактов</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.ru.html#ресурсы",
    "href": "new_pages/contact_tracing.ru.html#ресурсы",
    "title": "25  Отслеживание контактов",
    "section": "25.6 Ресурсы",
    "text": "25.6 Ресурсы\nhttps://github.com/WorldHealthOrganization/godata/tree/master/analytics/r-reporting\nhttps://worldhealthorganization.github.io/godata/\nhttps://community-godata.who.int/",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Отслеживание контактов</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.ru.html",
    "href": "new_pages/survey_analysis.ru.html",
    "title": "26  Анализ опросов",
    "section": "",
    "text": "26.1 Обзор\nНа этой странице мы демонстрируем использование нескольких пакетов для анализа опросов.\nБольшинство пакетов для опросов R полагаются на пакет survey для проведения взвешенного анализа. Мы используем survey, а также srvyr (надстройка для survey, позволяющая кодировать в стиле tidyverse) и gtsummary (надстройка для survey, позволяющая создавать готовые к публикации таблицы). Хотя оригинальный пакет survey не позволяет кодировать в стиле tidyverse, у него есть дополнительные преимущества в том, что он позволяет создавать взвешенные по опросу обобщенные линейные модели модели (которые будут добавлены на эту страницу позже). Мы также продемонстрируем использование функции из пакета sitrep, чтобы создать веса выборки (примечание этого пакета пока нет в CRAN, но его можно установить из github).\nБольшая часть этой страницы основана на работе, сделанной для проекта “R4Epis”; для получения деталей кода и шаблонов R-markdown см. эту страницу “R4Epis”. Некоторая часть кода на основе пакета survey основана на более ранних версиях кейсов EPIET.\nВ настоящее время на этой странице не рассматриваются вопросы расчета размера выборки или процессы выборки. Простой калькулятор размера выборки можно найти в OpenEpi. На странице Основы ГИС руководства позднее появится раздел по пространственной случайной выборке, а на этой странице позднее будет раздел по основам для построения выборки, а также расчету размера выборки.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Анализ опросов</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.ru.html#обзор",
    "href": "new_pages/survey_analysis.ru.html#обзор",
    "title": "26  Анализ опросов",
    "section": "",
    "text": "Данные опроса\nВремя наблюдения\nВеса\nОбъекты дизайна опроса\nОписательный анализ\nВзвешенные доли\nВзвешенные коэффициенты",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Анализ опросов</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.ru.html#подготовка",
    "href": "new_pages/survey_analysis.ru.html#подготовка",
    "title": "26  Анализ опросов",
    "section": "26.2 Подготовка",
    "text": "26.2 Подготовка\n\nПакеты\nДанный фрагмент кода показывает загрузку пакетов, необходимых для анализа. В данном руководстве мы фокусируемся на использовании p_load() из пакета pacman, которая устанавливает пакет, если необходимо, и загружает его для использования. Вы можете также загрузить установленные пакеты с помощью library() из базового R. См. страницу [Основы R] для получения дополнительной информации о пакетах R. Здесь мы также демонстрируем использование функции p_load_gh() из пакета pacman, чтобы установить и загрузить пакет из github, который еще не опубликован в CRAN.\n\n## загрузка пакетов из CRAN\npacman::p_load(rio,          # импорт файлов\n               here,         # поиск пути к файлу\n               tidyverse,    # управление данными + графики ggplot2\n               tsibble,      # работа с наборами данных с временными рядами\n               survey,       # для функций опровос\n               srvyr,        # надстройка dplyr для пакета survey\n               gtsummary,    # надстройка для пакета survey для создания таблиц\n               apyramid,     # пакет, предназначенный для создания возрастных пирамид\n               patchwork,    # для объединения графиков ggplots\n               ggforce       # для аллювиальных графиков/диаграмм Санкей\n               ) \n\n## загружаем пакеты из github\npacman::p_load_gh(\n     \"R4EPI/sitrep\"          # для времени наблюдения/функций взвешивания\n)\n\n\n\nЗагрузка данных\nПример набора данных, используемый в данном разделе:\n\nвыдуманные данные по исследованию смертности\nвыдуманные данные о населении по обследуемому району\nсловарь данных для выдуманных данных по исследованию смертности.\n\nЭто основано на предварительно одобренном этическим советом MSF OCA исследовании. Выдуманный набор данных был подготовлен в рамках проекта “R4Epis”. Это все основано на данных, собранных с помощью KoboToolbox, которая является программой для сбора данных на основе Open Data Kit.\nKobo позволяет вам экспортировать и собранные данные, и словарь данных для этого набора данных. Мы настоятельно это рекомендуем, так как это упрощает вычистку данных и полезно для поиска переменных/вопросов.\nСОВЕТ: Словарь данных в Kobo содержит имена переменных в столбце “name” на листе survey (опрос). Возможные значения для каждой переменной уточняются на листе choices (варианты). Во вкладке “choices” имя “name” имеет сокращенную версию и столбцы “label::english” и “label::french” с соответствующими длинными версиями. Использование функции msf_dict_survey() из пакета epidict для импорта\nфайла excel со словарем из Kobo переформатирует его, чтобы его было легко использовать для перекодирования. \nВНИМАНИЕ: Пример набора данных не совпадает с экспортом (так как в Kobo вы экспортируете разные уровни вопросов отдельно) - см. раздел данные опросов ниже, чтобы объединить разные уровни.\nИмпортируем набор данных с помощью функции import() из пакета rio. См. страницу Импорт и экспорт, где описаны разные способы импорта данных.\n\n# импортируем данные опроса\nsurvey_data &lt;- rio::import(\"survey_data.xlsx\")\n\n# импортируем словарь в R\nsurvey_dict &lt;- rio::import(\"survey_dict.xlsx\") \n\nПервые 10 строк опроса отображены ниже.\n\n\n\n\n\n\nМы также хотим импортировать данные о выборочной совокупности, чтобы мы могли создать соответствующие веса. Эти данные могут быть в разных форматах, однако мы предлагаем иметь их в формате, показанном ниже (это можно просто напечатать в excel).\n\n# импорт данныхы о населении\npopulation &lt;- rio::import(\"population.xlsx\")\n\nПервые 10 строк опроса отображены ниже.\n\n\n\n\n\n\nДля кластерных опросов вам может потребоваться добавить веса опроса на уровне кластера. Вы можете прочитать эти данные в программу, как указано выше. Альтернативно, если количество небольшое, их можно ввести в таблицу tibble, как это сделано ниже. В любом случае вам потребуется один столбец с идентификатором кластера, который совпадает с вашими данными опроса, и еще один столбец с количеством домохозяйств в каждом кластере.\n\n## определяем количество домохозяйств в каждом кластере\ncluster_counts &lt;- tibble(cluster = c(\"village_1\", \"village_2\", \"village_3\", \"village_4\", \n                                     \"village_5\", \"village_6\", \"village_7\", \"village_8\",\n                                     \"village_9\", \"village_10\"), \n                         households = c(700, 400, 600, 500, 300, \n                                        800, 700, 400, 500, 500))\n\n\n\nВычистка данных\nНиже мы проверяем, что столбец даты находится в правильном формате. Существует еще несколько способов это сделать (см. детали на странице Работа с датами), однако использование словаря для определения дат является быстрым и легким способом.\nМы также создаем переменную возрастной группы, используя функцию age_categories() из epikit - см. детали в разделе руководства Вычистка данных. Кроме того, мы создаем текстовую переменную, определяющую каждый район, в котором находятся разные кластеры.\nНаконец мы перекодируем все переменные yes/no (да/нет) в переменные TRUE/FALSE (ИСТИНА/ЛОЖЬ) - иначе их нельзя будет применить в долевых функциях survey.\n\n## выбираем имена переменной даты из словаря \nDATEVARS &lt;- survey_dict %&gt;% \n  filter(type == \"date\") %&gt;% \n  filter(name %in% names(survey_data)) %&gt;% \n  ## фильтруем, чтобы сопоставить с именами столбцов в ваших данных\n  pull(name) # выбираем переменные дат\n  \n## меняем на даты \nsurvey_data &lt;- survey_data %&gt;%\n  mutate(across(all_of(DATEVARS), as.Date))\n\n\n## добавляем тех, у кого возраст только в месяцах, к переменной года (делим на 12)\nsurvey_data &lt;- survey_data %&gt;% \n  mutate(age_years = if_else(is.na(age_years), \n                             age_months / 12, \n                             age_years))\n\n## определяем переменную возрастной группы\nsurvey_data &lt;- survey_data %&gt;% \n     mutate(age_group = age_categories(age_years, \n                                    breakers = c(0, 3, 15, 30, 45)\n                                    ))\n\n\n## создаем текстовую переменную на основе групп другой переменной \nsurvey_data &lt;- survey_data %&gt;% \n  mutate(health_district = case_when(\n    cluster_number %in% c(1:5) ~ \"district_a\", \n    TRUE ~ \"district_b\"\n  ))\n\n\n## выбираем имена переменных с да/нет (yes/no) из словаря \nYNVARS &lt;- survey_dict %&gt;% \n  filter(type == \"yn\") %&gt;% \n  filter(name %in% names(survey_data)) %&gt;% \n  ## фильтруем, чтобы сопоставить с именами столбцов ваших данных\n  pull(name) # выбираем переменные да/нет\n  \n## меняем на даты \nsurvey_data &lt;- survey_data %&gt;%\n  mutate(across(all_of(YNVARS), \n                str_detect, \n                pattern = \"yes\"))\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `across(all_of(YNVARS), str_detect, pattern = \"yes\")`.\nCaused by warning:\n! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\nSupply arguments directly to `.fns` through an anonymous function instead.\n\n  # Previously\n  across(a:b, mean, na.rm = TRUE)\n\n  # Now\n  across(a:b, \\(x) mean(x, na.rm = TRUE))",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Анализ опросов</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.ru.html#данные-опроса",
    "href": "new_pages/survey_analysis.ru.html#данные-опроса",
    "title": "26  Анализ опросов",
    "section": "26.3 Данные опроса",
    "text": "26.3 Данные опроса\nСуществует ряд разных дизайнов выборки для опроса. Здесь мы продемонстрируем код для: - стратифицированной - кластерной - стратифицированной и кластерной\nКак описано выше (в зависимости от того, как вы составите анкету), данные для каждого уровня будут экспортированы в виде отдельного набора данных из Kobo. В нашем примере есть один уровень для домохозяйств и один уровень для отдельных лиц в этих домохозяйствах.\nЭти два уровня связаны уникальным идентификатором. Для набора данных Kobo этой переменной является “_index” на уровне домохозяйства, который соответствует “_parent_index” на индивидуальном уровне. Это создаст новые строки для домохозяйства с соответствующим индивидом, см. детали в разделе руководства Соединение данных.\n\n## соединяем индивидуальные данные и домохозяйства для получения полного набора данных\nsurvey_data &lt;- left_join(survey_data_hh, \n                         survey_data_indiv,\n                         by = c(\"_index\" = \"_parent_index\"))\n\n\n## создаем уникальный идентификатор, объединяя индексы двух уровней \nsurvey_data &lt;- survey_data %&gt;% \n     mutate(uid = str_glue(\"{index}_{index_y}\"))",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Анализ опросов</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.ru.html#время-наблюдения",
    "href": "new_pages/survey_analysis.ru.html#время-наблюдения",
    "title": "26  Анализ опросов",
    "section": "26.4 Время наблюдения",
    "text": "26.4 Время наблюдения\nДля исследований смертности нам нужно знать, как долго каждый человек присутствовал в этом месте, чтобы рассчитать соответствующий коэффицент смертности для интересующего нас периода. Это важно не для всех исследований, но очень важно для исследований смертности, поскольку они часто проводятся среди мобильного или вынужденно переселенного населения.\nЧтобы это сделать, мы сначала определяем интересующий период, также известный как период оценки/памяти (т.е. время, которое участники вспоминают при ответе на вопросы). Мы можем использовать этот период, чтобы задать неподходящие даты, как отсутствующие, т.е. если смерти зарегистрированы за пределами интересующего периода.\n\n## задаем дату начала/окончания периода оценки\n## можно изменить на переменную даты из набора данных \n## (т.е. дата прибытия и дата вопросника)\nsurvey_data &lt;- survey_data %&gt;% \n  mutate(recall_start = as.Date(\"2018-01-01\"), \n         recall_end   = as.Date(\"2018-05-01\")\n  )\n\n\n# задаем неподходящие даты как NA на основе правил \n## например, прибытие до начала, отбытие после окончания\nsurvey_data &lt;- survey_data %&gt;%\n      mutate(\n           arrived_date = if_else(arrived_date &lt; recall_start, \n                                 as.Date(NA),\n                                  arrived_date),\n           birthday_date = if_else(birthday_date &lt; recall_start,\n                                  as.Date(NA),\n                                  birthday_date),\n           left_date = if_else(left_date &gt; recall_end,\n                              as.Date(NA),\n                               left_date),\n           death_date = if_else(death_date &gt; recall_end,\n                               as.Date(NA),\n                               death_date)\n           )\n\nМы можем затем использовать наши переменные даты, чтобы задать даты начала и окончания для каждого лица. Мы можем использовать функцию find_start_date() из sitrep, чтобы найти причины для дат и затем использовать их, чтобы рассчитать разницу между днями (человеко-время).\nдата начала: Самое раннее подходящее событие прибытия в периоде оценки Либо начало вашего периода оценки (которое вы определяете заранее), либо дата после начала периода оценки, если применимо (например, прибытие или рождение)\nдата окончания: Самая ранняя подходящее событие выбытия в вашем периоде оценки Либо окончание периода оценки, либо дата до окончания периода оценки, если применимо (например, отбытие, смерть)\n\n## создаем новые переменные для дат начала и окончания/причин\nsurvey_data &lt;- survey_data %&gt;% \n     ## выбираем самую раннюю дату, введенную в опрос\n     ## из рождения, прибытия в домохозяйство, прибытия в лагерь \n     find_start_date(\"birthday_date\",\n                  \"arrived_date\",\n                  period_start = \"recall_start\",\n                  period_end   = \"recall_end\",\n                  datecol      = \"startdate\",\n                  datereason   = \"startcause\" \n                 ) %&gt;%\n     ## выбираем самую раннюю дату, введенную в опрос\n     ## из отбытия из лагеря, смерти, окончания исследования\n     find_end_date(\"left_date\",\n                \"death_date\",\n                period_start = \"recall_start\",\n                period_end   = \"recall_end\",\n                datecol      = \"enddate\",\n                datereason   = \"endcause\" \n               )\n\n\n## подпишите те, которые присутствовали в начале/конце (кроме рождения/смерти)\nsurvey_data &lt;- survey_data %&gt;% \n     mutate(\n       ## заполним дату начала как начало периода оценки (для пустых полей) \n       startdate = if_else(is.na(startdate), recall_start, startdate), \n       ## задаем стартовую причину для представления в начале, если она равна периоду оценки \n       ## кроме случаев, когда она равна дате рождения \n       startcause = if_else(startdate == recall_start & startcause != \"birthday_date\",\n                              \"Present at start\", startcause), \n       ## заполняем дату окончания как окончание периода оценки (для пустых полей) \n       enddate = if_else(is.na(enddate), recall_end, enddate), \n       ## задаем причину окончания для представления в конце, если равна периоду оценки \n       ## кроме случаев, когда она равна дате смерти\n       endcause = if_else(enddate == recall_end & endcause != \"death_date\", \n                            \"Present at end\", endcause))\n\n\n## Определяем время наблюдения в днях\nsurvey_data &lt;- survey_data %&gt;% \n  mutate(obstime = as.numeric(enddate - startdate))",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Анализ опросов</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.ru.html#взвешивание",
    "href": "new_pages/survey_analysis.ru.html#взвешивание",
    "title": "26  Анализ опросов",
    "section": "26.5 Взвешивание",
    "text": "26.5 Взвешивание\nВажно отбросить ошибочные наблюдения до добавления весов в опрос. Например, если у вас есть наблюдения с отрицательным временем наблюдения, вам нужно их проверить (вы можете это сделать с помощью функции assert_positive_timespan() из пакета sitrep). Другой вопрос, если вы хотите отбросить пустые строки (например, с помощью drop_na(uid)) или удалить дубликаты (см. детали в разделе руководства [Дедупликация]). Тех, кто не дал согласие, также нужно отбросить.\nВ данном примере мы фильтруем случаи, которые мы хотим удалить, и сохраняем их в отдельном датафрейме - таким образом мы можем описать тех, кто был исключен из исследования. Затем мы используем функцию anti_join() из dplyr, чтобы удалить эти отброшенные случаи из данных опроса.\nВНИМАНИЕ: Не допускается наличие отсутствующих значений в переменной веса или в любой другой переменной, относящейся к дизайну исследования (например, возраст, пол, стратовые или кластерные переменные).\n\n## сохраняем случаи, которые вы отбросили, чтобы вы могли их описать (например, не давшие согласия, \n## или из неправильной деревни/кластера)\ndropped &lt;- survey_data %&gt;% \n  filter(!consent | is.na(startdate) | is.na(enddate) | village_name == \"other\")\n\n## используем отброшенные случаи, чтобы удалить неиспользуемые строки из набора данных опроса  \nsurvey_data &lt;- anti_join(survey_data, dropped, by = names(dropped))\n\nКак уже было сказано выше, мы демонстрируем, как добавлять веса для трех различных дизайнов исследования (стратифицированного, кластерного и стратифицированного кластерного). Для этого требуется информация об исходной популяции и/или обследованных кластерах. В данном примере мы будем использовать код стратифицированного кластера, но используйте тот вариант, который является наиболее подходящим для вашего дизайна исследования.\n\n# стратифицированный ------------------------------------------------------------------\n# создаем переменную под названием \"surv_weight_strata\"\n# содержит веса для каждого индивида - по возрастной группе, полу и медицинскому району\nsurvey_data &lt;- add_weights_strata(x = survey_data,\n                                         p = population,\n                                         surv_weight = \"surv_weight_strata\",\n                                         surv_weight_ID = \"surv_weight_ID_strata\",\n                                         age_group, sex, health_district)\n\n## кластерный ---------------------------------------------------------------------\n\n# получите количество лиц, проинтервьюированных в каждом домохозяйстве\n# добвляет переменную с подсчетом переменной индекса домохозяйства (родителя)\nsurvey_data &lt;- survey_data %&gt;%\n  add_count(index, name = \"interviewed\")\n\n\n## создаем веса для кластера\nsurvey_data &lt;- add_weights_cluster(x = survey_data,\n                                          cl = cluster_counts,\n                                          eligible = member_number,\n                                          interviewed = interviewed,\n                                          cluster_x = village_name,\n                                          cluster_cl = cluster,\n                                          household_x = index,\n                                          household_cl = households,\n                                          surv_weight = \"surv_weight_cluster\",\n                                          surv_weight_ID = \"surv_weight_ID_cluster\",\n                                          ignore_cluster = FALSE,\n                                          ignore_household = FALSE)\n\n\n# стратифицированный и кластерный ------------------------------------------------------\n# создаем вес опроса для кластера и страт\nsurvey_data &lt;- survey_data %&gt;%\n  mutate(surv_weight_cluster_strata = surv_weight_strata * surv_weight_cluster)",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Анализ опросов</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.ru.html#объекты-дизайна-опроса",
    "href": "new_pages/survey_analysis.ru.html#объекты-дизайна-опроса",
    "title": "26  Анализ опросов",
    "section": "26.6 Объекты дизайна опроса",
    "text": "26.6 Объекты дизайна опроса\nСоздаем объект исследования согласно вашему дизайну исследования. Используется таким же образом, как датафреймы для рассчета весовых долей и т.п. Убедитесь, что до этого созданы все необходимые переменные.\nСуществует 4 опции, выделите как комментарии те, которые вы не используете: - простая случайная - стратифицированная - кластерная - стратифицированная кластерная\nДля данного шаблона мы представим, что мы кластеризовали опросы по двум отдельным стратам (медицинские районы A и B). Чтобы получить общие оценки, нам нужны скомбинированные веса кластера и страт.\nКак упоминалось ранее, для этого есть два пакета. Классический пакет - survey, а также есть пакет-надстройка под названием srvyr, которые создает подходящие для tidyverse объекты и функции. Мы продемонстрируем оба варианта, но обратите внимание, что большая часть кода в этой главе будет использовать объекты на основе srvyr. Единственное исключение - пакет gtsummary принимает только объекты survey.\n\n26.6.1 Пакет Survey\nПакет survey по сути использует кодирование из базового R, поэтому невозможно использовать операторы канала (%&gt;%) или другой синтаксис dplyr. С пакетом survey мы используем функцию svydesign() для определения объекта опроса с соответствующими кластерами, весами и стратами.\nПРИМЕЧАНИЕ: нам нужно использовать тильду (~) перед переменным, поскольку пакет использует синтаксис базового R с присвоением переменных на основе формул.\n\n# простая случайная ---------------------------------------------------------------\nbase_survey_design_simple &lt;- svydesign(ids = ~1, # 1 для отсутствия кластерных ids\n                   weights = NULL,               # не добавляются веса\n                   strata = NULL,                # выборка была простой (без страт)\n                   data = survey_data            # нужно уточнить набор данных\n                  )\n\n## стратифицированная ------------------------------------------------------------------\nbase_survey_design_strata &lt;- svydesign(ids = ~1,  # 1 для отсутствия кластерных ids\n                   weights = ~surv_weight_strata, # переменная веса, созданная выше\n                   strata = ~health_district,     # выборка была стратифицирована по районам\n                   data = survey_data             # нужно уточнить набор данных\n                  )\n\n# кластерная ---------------------------------------------------------------------\nbase_survey_design_cluster &lt;- svydesign(ids = ~village_name, # ids кластера\n                   weights = ~surv_weight_cluster, # переменная веса, созданная выше\n                   strata = NULL,                 # выборка была простой (без страт)\n                   data = survey_data              # нужно уточнить набор данных\n                  )\n\n# стратифицированная кластерная ----------------------------------------------------------\nbase_survey_design &lt;- svydesign(ids = ~village_name,      # ids кластера\n                   weights = ~surv_weight_cluster_strata, # переменная веса, созданная выше\n                   strata = ~health_district,             # выборка стратифицирована по району\n                   data = survey_data                     # нужно уточнить набор данных\n                  )\n\n\n\n26.6.2 Пакет Srvyr\nС пакетом srvyr мы можем использовать функцию as_survey_design(), у которой имеются все те же аргументы, что и выше, но она допускает операторы канала (%&gt;%), и тогда нам не нужно использовать тильду (~).\n\n## простая случайная ---------------------------------------------------------------\nsurvey_design_simple &lt;- survey_data %&gt;% \n  as_survey_design(ids = 1, # 1 для отсутствия кластерных ids \n                   weights = NULL, # без добавления весов\n                   strata = NULL # выборка простая (без страт)\n                  )\n## стратифицированная ------------------------------------------------------------------\nsurvey_design_strata &lt;- survey_data %&gt;%\n  as_survey_design(ids = 1, # 1 для отсутствия кластерных ids\n                   weights = surv_weight_strata, # переменная веса, созданная выше\n                   strata = health_district # выборка была стратифицирована по району\n                  )\n## кластерная ---------------------------------------------------------------------\nsurvey_design_cluster &lt;- survey_data %&gt;%\n  as_survey_design(ids = village_name, # ids кластеров\n                   weights = surv_weight_cluster, # переменная веса, созданная выше\n                   strata = NULL # выборка простая (без страт)\n                  )\n\n## стратифицированная кластерная ----------------------------------------------------------\nsurvey_design &lt;- survey_data %&gt;%\n  as_survey_design(ids = village_name, # cluster ids\n                   weights = surv_weight_cluster_strata, # переменная веса, созданная выше\n                   strata = health_district # выборка была стратифицирована по району\n                  )",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Анализ опросов</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.ru.html#описательный-анализ",
    "href": "new_pages/survey_analysis.ru.html#описательный-анализ",
    "title": "26  Анализ опросов",
    "section": "26.7 Описательный анализ",
    "text": "26.7 Описательный анализ\nОсновы описательного анализа и визуализация рассматриваются детально в других главах руководства, поэтому мы не будем на них здесь останавливаться. Детали можно найти в главах Описательные таблицы, Статистические тесты, Таблицы для презентации, Основы ggplot and Отчеты с помощью R markdown.\nВ этом разделе мы сосредоточимся на том, как исследовать ошибки в выборке и визуализировать их. Мы также рассмотрим визуализацию потоков населения в условиях исследования с помощью аллювиальных диаграмм/диаграмм Санки.\nВ целом, следует рассмотреть возможность включения нижеследующих видов описательного анализа:\n\nИтоговое количество включенных кластеров, домохозяйств и лиц\n\nКоличество исключенных лиц и причины исключения\nМедианное (диапазон) значение домохозяйств на кластер и индивидов на домохозяйство\n\n\n26.7.1 Систематическая ошибка выборки\nСравните доли в каждой возрастной группе между вашей выборкой и исходной популяцией. Это важно для выявления возможной систематической ошибки выборки. Аналогичным образом можно повторить этот процесс, рассматривая распределение по полу.\nОбратите внимание, что эти p-значения являются лишь ориентировочными, а описательное обсуждение (или визуализация с помощью возрастных пирамид ниже) распределений в исследуемой выборке по сравнению с исходной популяцией более важна, чем сам биномиальный тест. Это связано с тем, что увеличение размера выборки чаще всего приводит к различиям, которые могут оказаться неважными после взвешивания данных.\n\n## количество и доли в исследуемой популяции\nag &lt;- survey_data %&gt;% \n  group_by(age_group) %&gt;% \n  drop_na(age_group) %&gt;% \n  tally() %&gt;% \n  mutate(proportion = n / sum(n), \n         n_total = sum(n))\n\n## количество и доли в исходной популяции\npropcount &lt;- population %&gt;% \n  group_by(age_group) %&gt;%\n    tally(population) %&gt;%\n    mutate(proportion = n / sum(n))\n\n## свяжите столбцы двух таблиц, сгруппируйте по возрасту и проведите \n## биномиальный тест, чтобы увидеть, значительно ли отличается n/итого от доли в популяции.\n  ## суффикс добавляется к тексту в конце столбцов в каждом из двух наборов данных\nleft_join(ag, propcount, by = \"age_group\", suffix = c(\"\", \"_pop\")) %&gt;%\n  group_by(age_group) %&gt;%\n  ## broom::tidy(binom.test()) создает датафрейм из биномиального теста и\n  ## добавит переменные p.value (p значение), parameter (параметр), conf.low (дов.ниж), conf.high (дов.верх), method (метод), и\n  ## альтернативы. Мы здесь используем только p.value. Вы можете включить други столбцы,\n  ## если вы хотите показать доверительные интервалы\n  mutate(binom = list(broom::tidy(binom.test(n, n_total, proportion_pop)))) %&gt;%\n  unnest(cols = c(binom)) %&gt;% # важно для расширения датафрейма биномиального теста\n  mutate(proportion_pop = proportion_pop * 100) %&gt;%\n  ## корректируем p-значенияы, чтобы скорректировать ложно-положительные \n  ## (поскольку тестируются несколько возрастных групп). Это будет что-то менять, только если у вас \n  ## много возрастных категорий\n  mutate(p.value = p.adjust(p.value, method = \"holm\")) %&gt;%\n                      \n  ## Показываем только p-значения больше 0.001 (те, которые меньше, показываем как &lt;0.001)\n  mutate(p.value = ifelse(p.value &lt; 0.001, \n                          \"&lt;0.001\", \n                          as.character(round(p.value, 3)))) %&gt;% \n  \n  ## переименовываем столбцы соответствующим образом\n  select(\n    \"Age group\" = age_group,\n    \"Study population (n)\" = n,\n    \"Study population (%)\" = proportion,\n    \"Source population (n)\" = n_pop,\n    \"Source population (%)\" = proportion_pop,\n    \"P-value\" = p.value\n  )\n\n# A tibble: 5 × 6\n# Groups:   Age group [5]\n  `Age group` `Study population (n)` `Study population (%)`\n  &lt;chr&gt;                        &lt;int&gt;                  &lt;dbl&gt;\n1 0-2                             12                 0.0256\n2 3-14                            42                 0.0896\n3 15-29                           64                 0.136 \n4 30-44                           52                 0.111 \n5 45+                            299                 0.638 \n# ℹ 3 more variables: `Source population (n)` &lt;dbl&gt;,\n#   `Source population (%)` &lt;dbl&gt;, `P-value` &lt;chr&gt;\n\n\n\n\n26.7.2 Демографические пирамиды\nДемографические (или половозрастные) пирамиды являются простым способом визуализации распределения в вашей исследуемой популяции. Также рассмотрите возможность создания описательных таблиц возраста и пола по стратам опроса. Мы продемонстрируем использование пакета apyramid, так как он допускает взвешенные доли, используя объект дизайна опроса, созданный выше. Другие опции создания демографических пирамид детально рассматриваются в этой главе руководства. Мы также используем функцию-надстройку из apyramid под названием age_pyramid(), которая сохраняет несколько строк кода для создания графика с долями.\nКак и в случае с формальным биномиальным тестом на разницу, рассмотренным выше в разделе о систематической ошибке выборки, здесь нас интересует визуализация того, существенно ли наша выборочная совокупность отличается от исходной и корректирует ли взвешивание эту разницу. Чтобы это сделать, нам нужно использовать пакет patchwork, чтобы показать наши визуализации ggplot рядом; дополнительную информацию см. в разделе по объединению графиков в главе руководства Советы по использованию ggplot. Мы будем визуализировать нашу исходную популяцию, нашу невзвешенную исследуемую популяцию и нашу взвешенную исследуемую популяцию. Вы можете также рассмотреть возможность визуализации каждой страты вашего опроса - в нашем примере это будет сделано с помощью аргумента stack_by  = \"health_district\" (см. детали в ?plot_age_pyramid).\nПРИМЕЧАНИЕ: В пирамидах оси x и y меняются местами \n\n## определяем пределы и подписи оси x ---------------------------------------------\n## (обновляем эти цифры так, чтобы они были значениям для вашего графика)\nmax_prop &lt;- 35      # выбираем самую высокую долю, которую вы хотите показать \nstep &lt;- 5           # выбираем пространство между подписями, которое вам нужно \n\n## эта часть определяет вектор, используя указанные выше цифры, с разрывами оси\nbreaks &lt;- c(\n    seq(max_prop/100 * -1, 0 - step/100, step/100), \n    0, \n    seq(0 + step / 100, max_prop/100, step/100)\n    )\n\n## эта часть определяет вектор, используя указанные выше цифры, с пределами оси\nlimits &lt;- c(max_prop/100 * -1, max_prop/100)\n\n## эта часть определяет вектор, используя указанные выше цифры, с подписями осей\nlabels &lt;-  c(\n      seq(max_prop, step, -step), \n      0, \n      seq(step, max_prop, step)\n    )\n\n\n## создаем графики отдельно  --------------------------------------------------\n\n## строим график исходной популяции \n## примечание: этот показатель должен быть рассчитан для всего населения (т.е. удаляем медицинские районы)\nsource_population &lt;- population %&gt;%\n  ## проверяем, что возраст и пол заданы как факторы\n  mutate(age_group = factor(age_group, \n                            levels = c(\"0-2\", \n                                       \"3-14\", \n                                       \"15-29\",\n                                       \"30-44\", \n                                       \"45+\")), \n         sex = factor(sex)) %&gt;% \n  group_by(age_group, sex) %&gt;% \n  ## складываем количества для каждого медицинского округа \n  summarise(population = sum(population)) %&gt;% \n  ## удаляем группирование, чтобы можно было рассчитать общую долю\n  ungroup() %&gt;% \n  mutate(proportion = population / sum(population)) %&gt;% \n  ## строим пирамиду \n  age_pyramid(\n            age_group = age_group, \n            split_by = sex, \n            count = proportion, \n            proportional = TRUE) +\n  ## показываем только подпись оси y (иначе будет повторена на всех трех графиках)\n  labs(title = \"Source population\", \n       y = \"\", \n       x = \"Age group (years)\") + \n  ## делаем ось x одинаковой для всех графиков \n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n  \n  \n## строим график выборочной совокупности без весов \nsample_population &lt;- age_pyramid(survey_data, \n                 age_group = \"age_group\", \n                 split_by = \"sex\",\n                 proportion = TRUE) + \n  ## показываем только подпись оси x (иначе будет повторена на всех трех графиках)\n  labs(title = \"Unweighted sample population\", \n       y = \"Proportion (%)\", \n       x = \"\") + \n  ## делаем ось x одинаковой для всех графиков \n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n\n\n## строим график выборочной совокупности с весами \nweighted_population &lt;- survey_design %&gt;% \n  ## убедитесь, что переменные - факторы\n  mutate(age_group = factor(age_group), \n         sex = factor(sex)) %&gt;%\n  age_pyramid(\n    age_group = \"age_group\",\n    split_by = \"sex\", \n    proportion = TRUE) +\n  ## показываем только подпись оси x (иначе будет повторена на всех трех графиках)\n  labs(title = \"Weighted sample population\", \n       y = \"\", \n       x = \"\")  + \n  ## делаем ось x одинаковой для всех графиков \n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n\n## объединяем все три графика  ----------------------------------------------------\n## комбинируем три графика друг рядом с друга, используя + \nsource_population + sample_population + weighted_population + \n  ## показываем только одну легенду и задаем тему \n  ## обратите внимание на использование & для объединения темы с plot_layout()\n  plot_layout(guides = \"collect\") & \n  theme(legend.position = \"bottom\",                    # перемещаем легенду вниз\n        legend.title = element_blank(),                # убираем заголовок\n        text = element_text(size = 18),                # меняем размер текста\n        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1) # поворачиваем текст на оси x\n       )\n\n\n\n\n\n\n\n\n\n\n26.7.3 Аллювиальный график/диаграмма Санкей\nВизуализация начальных точек и результатов для отдельных людей может быть очень полезной для получения общей картины. Вполне очевидным является их применение для мобильных популяций, Однако существует множество других применений, например, в когортах или в любой другой ситуации. где существуют переходы между состояниями индивидуумов. Эти диаграммы имеют несколько различных названий, включая аллювиальные, Санкей и параллельные множества - подробности приведены в главе руководства Диаграммы и схемы.\n\n## обобщаем данные\nflow_table &lt;- survey_data %&gt;%\n  count(startcause, endcause, sex) %&gt;%  # получаем подсчет \n  gather_set_data(x = c(\"startcause\", \"endcause\"))     # меняем формат для создания диаграммы\n\n\n## создаем график для набора данных \n  ## на оси x - причины начала и окончания\n  ## gather_set_data генерирует ID для каждой возможной комбинации\n  ## разделение по y дает возможные комбинации начала/окончания\n  ## value (значение) как n представляет в виде количества (можно также изменить на долю)\nggplot(flow_table, aes(x, id = id, split = y, value = n)) +\n  ## цвета линий по полу \n  geom_parallel_sets(aes(fill = sex), alpha = 0.5, axis.width = 0.2) +\n  ## заливка прямоугольников с подписями серым\n  geom_parallel_sets_axes(axis.width = 0.15, fill = \"grey80\", color = \"grey80\") +\n  ## меняем цвет и угол текста (необходимо корректировать)\n  geom_parallel_sets_labels(color = \"black\", angle = 0, size = 5) +\n  ## удаляем подписи осей\n  theme_void()+\n  ## перемещаем легенду вниз\n  theme(legend.position = \"bottom\")",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Анализ опросов</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.ru.html#взвешенные-доли",
    "href": "new_pages/survey_analysis.ru.html#взвешенные-доли",
    "title": "26  Анализ опросов",
    "section": "26.8 Взвешенные доли",
    "text": "26.8 Взвешенные доли\nВ этом разделе мы подробно рассмотрим, как создавать таблицы для взвешенных подсчетов и долей, с соответствующими доверительными интервалами и дизайн-эффектом. Существует четыре варианта, использующих функции из следующих пакетов: survey, srvyr, sitrep и gtsummary. Чтобы с минимальным кодированием создать таблицу в стандартном для эпидемиологии стиле,\nмы бы рекомендовали функцию sitrep - которая является надстройкой для кода srvyr; обратите внимание, однако, что ее еще нет в CRAN, и она может измениться в будущем. В противном случае наиболее стабильным в долгосрочной перспективе, скорее всего, будет код survey, а srvyr лучше всего встроится в рабочие потоки в tidyverse. Хотя у функций gtsummary есть большой потенциал, они кажутся экспериментальными и неполными на момент написания руководства.\n\n26.8.1 Пакет Survey\nМы можем использовать функцию svyciprop() из survey, чтобы получить взвешенные доли и соответствующие 95% доверительные интервалы. Соответствующий дизайн-эффект можно извлечь, используя функцию svymean() вместо svyprop(). Необходимо отметить, что, как представляется, svyprop() допускает только значения между 0 и 1 (или TRUE/FALSE - ИСТИНА/ЛОЖЬ), так что категориальные переменные не сработают.\nПРИМЕЧАНИЕ: Функции из survey также принимают объекты дизайна srvyr, но здесь мы для последовательности использовали объект дизайна survey\n\n## создаем взвешенный подсчет \nsvytable(~died, base_survey_design)\n\ndied\n     FALSE       TRUE \n1406244.43   76213.01 \n\n## создаем взвешенные доли\nsvyciprop(~died, base_survey_design, na.rm = T)\n\n              2.5% 97.5%\ndied 0.0514 0.0208  0.12\n\n## получаем дизайн-эффект \nsvymean(~died, base_survey_design, na.rm = T, deff = T) %&gt;% \n  deff()\n\ndiedFALSE  diedTRUE \n 3.755508  3.755508 \n\n\nМы можем объединить функции из survey, показанные выше, в функцию, которую мы сами определим ниже под названием svy_prop; и мы можем затем использовать эту функцию вместе с map() из пакета purrr для итерации по нескольким переменным и создания таблицы. См. главу руководства по итерациям для получения дополнительной информации о purrr.\n\n# определим функцию для расчета взвешенного количества, долей, ДИ и дизайн-эффекта\n# x - переменная в кавычках \n# design - ваш объект дизайна опроса\n\nsvy_prop &lt;- function(design, x) {\n  \n  ## поместим интересующую переменную в формулу \n  form &lt;- as.formula(paste0( \"~\" , x))\n  ## сохраним только столбец подсчета из svytable с TRUE\n  weighted_counts &lt;- svytable(form, design)[[2]]\n  ## рассчитаем доли (умножим на 100 для получения процентов)\n  weighted_props &lt;- svyciprop(form, design, na.rm = TRUE) * 100\n  ## извлекаем доверительные интервалы и умножаем, чтобы получить проценты\n  weighted_confint &lt;- confint(weighted_props) * 100\n  ## используем svymean для расчета дизайн-эффекта и сохраняем только столбец с TRUE\n  design_eff &lt;- deff(svymean(form, design, na.rm = TRUE, deff = TRUE))[[TRUE]]\n  \n  ## объединяем в один датафрейм\n  full_table &lt;- cbind(\n    \"Variable\"        = x,\n    \"Count\"           = weighted_counts,\n    \"Proportion\"      = weighted_props,\n    weighted_confint, \n    \"Design effect\"   = design_eff\n    )\n  \n  ## выдаем таблицу в виде датафрейма\n  full_table &lt;- data.frame(full_table, \n             ## удаляем имена переменных из строк (теперь отдельный столбец)\n             row.names = NULL)\n  \n  ## меняем числа на числовые\n  full_table[ , 2:6] &lt;- as.numeric(full_table[, 2:6])\n  \n  ## выдаем датафрейм\n  full_table\n}\n\n## проводим итерацию по нескольким переменным, чтобы создать таблицу \npurrr::map(\n  ## определяем интересующую переменную\n  c(\"left\", \"died\", \"arrived\"), \n  ## указываем функцию, используя аргументы для данной функции (дизайн)\n  svy_prop, design = base_survey_design) %&gt;% \n  ## преобразовываем список в один датафрейм\n  bind_rows() %&gt;% \n  ## округляем \n  mutate(across(where(is.numeric), round, digits = 1))\n\n  Variable    Count Proportion X2.5. X97.5. Design.effect\n1     left 701199.1       47.3  39.2   55.5           2.4\n2     died  76213.0        5.1   2.1   12.1           3.8\n3  arrived 761799.0       51.4  40.9   61.7           3.9\n\n\n\n\n26.8.2 Пакет Srvyr\nВ srvyr мы можем использовать синтаксис dplyr, чтобы создать таблицу. Обратите внимание, что используется функция survey_mean() и уточняется аргумент доли, а также та же функция используется для расчета дизайн-эффекта. Это происходит потому, что srvyr является надстройкой для обеих функций пакета survey svyciprop() и svymean(), которые используются в разделе выше.\nПРИМЕЧАНИЕ: Кажется, невозможно получить доли из категориальных переменных, используя и srvyr, если вам они нужны, посмотрите раздел ниже по использованию sitrep \n\n## используем объект дизайна srvyr\nsurvey_design %&gt;% \n  summarise(\n    ## получаем взвешенное количество \n    counts = survey_total(died), \n    ## получаем взвешенные доли и доверительные интервалы \n    ## умножаем на 100, чтобы получить проценты \n    props = survey_mean(died, \n                        proportion = TRUE, \n                        vartype = \"ci\") * 100, \n    ## получаем дизайн-эффект \n    deff = survey_mean(died, deff = TRUE)) %&gt;% \n  ## сохраняем только интересующие строки\n  ## (отбрасываем стандартные ошибки и повторяем расчет долей)\n  select(counts, props, props_low, props_upp, deff_deff)\n\n# A tibble: 1 × 5\n  counts props props_low props_upp deff_deff\n   &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1 76213.  5.14      2.08      12.1      3.76\n\n\nЗдесь мы также можем написать функцию для проведения итераций по нескольким переменным, используя пакет purrr. См. руководство, главу итерации для получения детальной информации о purrr.\n\n# Определяем функцию для расчета взвешенного количества, долей, ДИ и дизайн-эффекта\n# design - ваш объект дизайна опроса\n# x - переменная в кавычках \n\n\nsrvyr_prop &lt;- function(design, x) {\n  \n  summarise(\n    ## используя объект дизайна опроса\n    design, \n    ## получаем взвешенное количество \n    counts = survey_total(.data[[x]]), \n    ## получаем взвешенные доли и доверительные интервалы \n    ## умножаем на 100, чтобы получить процент \n    props = survey_mean(.data[[x]], \n                        proportion = TRUE, \n                        vartype = \"ci\") * 100, \n    ## получаем дизайн-эффект \n    deff = survey_mean(.data[[x]], deff = TRUE)) %&gt;% \n  ## добавляем имя переменной\n  mutate(variable = x) %&gt;% \n  ## сохраняем только интересующие строки\n  ## (отбрасываем стандартные ошибки и повторяем расчет долей)\n  select(variable, counts, props, props_low, props_upp, deff_deff)\n  \n}\n  \n\n## проводим итерацию по нескольким переменным, чтобы создать таблицу \npurrr::map(\n  ## определяем интересующие переменные\n  c(\"left\", \"died\", \"arrived\"), \n  ## указываем функцию, используя аргументы для этой функции (дизайн)\n  ~srvyr_prop(.x, design = survey_design)) %&gt;% \n  ## трансформируем список в один датафрейм\n  bind_rows()\n\n# A tibble: 3 × 6\n  variable  counts props props_low props_upp deff_deff\n  &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1 left     701199. 47.3      39.2       55.5      2.38\n2 died      76213.  5.14      2.08      12.1      3.76\n3 arrived  761799. 51.4      40.9       61.7      3.93\n\n\n\n\n26.8.3 Пакет Sitrep\nФункция tab_survey() из sitrep является надстройкой для srvyr, которая позволяет вам создавать взвешенные таблицы с минимальным кодом. Она также позволяет вам рассчитывать взвешенные доли для категориальных переменных.\n\n## используем объект дизайна опроса\nsurvey_design %&gt;% \n  ## передаем имена интересующих переменных без кавычек\n  tab_survey(arrived, left, died, education_level,\n             deff = TRUE,   # рассчитываем дизайн-эффект\n             pretty = TRUE  # объединяем долю и 95% ДИ\n             )\n\nWarning: removing 257 missing value(s) from `education_level`\n\n\n# A tibble: 9 × 5\n  variable        value            n  deff ci               \n  &lt;chr&gt;           &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;            \n1 arrived         TRUE       761799.  3.93 51.4% (40.9-61.7)\n2 arrived         FALSE      720658.  3.93 48.6% (38.3-59.1)\n3 left            TRUE       701199.  2.38 47.3% (39.2-55.5)\n4 left            FALSE      781258.  2.38 52.7% (44.5-60.8)\n5 died            TRUE        76213.  3.76 5.1% (2.1-12.1)  \n6 died            FALSE     1406244.  3.76 94.9% (87.9-97.9)\n7 education_level higher     171644.  4.70 42.4% (26.9-59.7)\n8 education_level primary    102609.  2.37 25.4% (16.2-37.3)\n9 education_level secondary  130201.  6.68 32.2% (16.5-53.3)\n\n\n\n\n26.8.4 Пакет Gtsummary\nВ gtsummary нет еще встроенных функций для добавления доверительных интервалов или дизайн-эффекта. Здесь мы покажем, как определить функцию для добавления доверительных интервалов, затем добавим доверительные интервалы в таблицу gtsummary, используя функцию tbl_svysummary().\n\nconfidence_intervals &lt;- function(data, variable, by, ...) {\n  \n  ## извлекаем доверительные интервалы и умножаем, чтобы получить проценты\n  props &lt;- svyciprop(as.formula(paste0( \"~\" , variable)),\n              data, na.rm = TRUE)\n  \n  ## извлекаем доверительные интервалы \n  as.numeric(confint(props) * 100) %&gt;% ## делаем числовым и умножаем для получения процентов\n    round(., digits = 1) %&gt;%           ## округляем до одного знака\n    c(.) %&gt;%                           ## извлекаем числа из матрицы\n    paste0(., collapse = \"-\")          ## объединяем в один символ\n}\n\n## используем объект дизайна пакета survey\ntbl_svysummary(base_survey_design, \n               include = c(arrived, left, died),   ## определяем переменные, которые хотим включить\n               statistic = list(everything() ~ c(\"{n} ({p}%)\"))) %&gt;% ## определяем интересующую статистику\n  add_n() %&gt;%  ## добавляем взвешенный итог \n  add_stat(fns = everything() ~ confidence_intervals) %&gt;% ## добавляем ДИ\n  ## изменяем заголовки столбцов\n  modify_header(\n    list(\n      n ~ \"**Weighted total (N)**\",\n      stat_0 ~ \"**Weighted Count**\",\n      add_stat_1 ~ \"**95%CI**\"\n    )\n    )\n\n\n\n\n\n\n\n\nCharacteristic\nWeighted total (N)\nWeighted Count1\n95%CI\n\n\n\n\narrived\n1,482,457\n761,799 (51%)\n40.9-61.7\n\n\nleft\n1,482,457\n701,199 (47%)\n39.2-55.5\n\n\ndied\n1,482,457\n76,213 (5.1%)\n2.1-12.1\n\n\n\n1 n (%)",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Анализ опросов</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.ru.html#взвешенные-коэффициенты",
    "href": "new_pages/survey_analysis.ru.html#взвешенные-коэффициенты",
    "title": "26  Анализ опросов",
    "section": "26.9 Взвешенные коэффициенты",
    "text": "26.9 Взвешенные коэффициенты\nАналогично, для взвешенных коэффициентов (например, коэффициентов смертности), вы можете использовать пакет survey или srvyr. Вы могли бы аналогичным образом написать функции (похожие на представленные выше), чтобы провести итерацию по нескольким переменным. Вы также могли бы создать функцию для gtsummary, как выше, но пока нет встроенного функционала.\n\n26.9.1 Пакет Survey\n\nratio &lt;- svyratio(~died, \n         denominator = ~obstime, \n         design = base_survey_design)\n\nci &lt;- confint(ratio)\n\ncbind(\n  ratio$ratio * 10000, \n  ci * 10000\n)\n\n      obstime    2.5 %   97.5 %\ndied 5.981922 1.194294 10.76955\n\n\n\n\n26.9.2 Пакет Srvyr\n\nsurvey_design %&gt;% \n  ## коэффициент survey ratio используется, чтобы учесть время наблюдения \n  summarise(\n    mortality = survey_ratio(\n      as.numeric(died) * 10000, \n      obstime, \n      vartype = \"ci\")\n    )\n\n# A tibble: 1 × 3\n  mortality mortality_low mortality_upp\n      &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n1      5.98         0.349          11.6",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Анализ опросов</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.ru.html#ресурсы",
    "href": "new_pages/survey_analysis.ru.html#ресурсы",
    "title": "26  Анализ опросов",
    "section": "26.10 Ресурсы",
    "text": "26.10 Ресурсы\nСтраница по статистике UCLA\nAnalyze survey data free\nПакет srvyr\nПакет gtsummary\nКейсы по опросам EPIET",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Анализ опросов</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.ru.html",
    "href": "new_pages/survival_analysis.ru.html",
    "title": "27  Анализ выживаемости",
    "section": "",
    "text": "27.1 Обзор\nАнализ выживаемости фокусируется на описании для отдельного лица или группы лиц определенной точки событий, называемой происшествие (возникновение заболевания, излечение от заболевания, смерть, рецидив после ответа на лечение…), которая происходит в период времени, называемый время происшествия (или время отслеживания в когортных/популяционных исследованиях), во время которого ведется наблюдение за лицами. Чтобы определить время происшествия, необходимо определить отправную точку (это может быть дата включения, дата постановки диагноза…).\nВ этом случае объектом вывода при анализе выживаемости является время между отправной точкой и событием. В современных медицинских исследованиях оно широко используется, например, в клинических исследованиях для оценки эффекта лечения или в онкологической эпидемиологии для оценки большого числа показателей выживаемости при раке.\nКак правило, выражается в вероятности выживания, которая является вероятностью того, что интересующее событие не возникло до длительности t.\nЦензурировуание: Цензурирование возникает в том случае, если в конце наблюдения у некоторых индивидуумов не произошло интересующее событие, и, таким образом, истинное время наступления события неизвестно. Здесь мы в основном рассматриваем правое цензурирование, но более подробную информацию о цензурировании и анализе выживаемости в целом можно найти в разделе Ресурсы.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Анализ выживаемости</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.ru.html#подготока",
    "href": "new_pages/survival_analysis.ru.html#подготока",
    "title": "27  Анализ выживаемости",
    "section": "27.2 Подготока",
    "text": "27.2 Подготока\n\nЗагрузка пакетов\nЧтобы выполнить анализ выживаемости в R, одним из наиболее часто используемых пакетов является пакет survival. Сначала мы его установим, затем загрузим его и другие пакеты, которые используются в данном разделе:\nВ данном руководстве мы фокусируемся на использовании p_load() из пакета pacman, которая устанавливает пакет, если необходимо, и загружает его для использования. Вы можете также загрузить установленные пакеты с помощью library() из базового R. См. страницу Основы R для получения дополнительной информации о пакетах R.\nНа этой странице мы рассмотрим анализ выживаемости на примере построчного списка, использованного на большинстве предыдущих страниц, который мы немного изменим, чтобы иметь надлежащие данные о выживаемости.\n\n\nИмпорт набора данных\nМы импортируем набор данных о случаях из имитированной эпидемии Эболы. Если вы хотите выполнять действия параллельно, кликните, чтобы скачать “чистый” построчный список (как файл .rds). Импортируйте данные с помощью функции import() из пакета rio (она работает с разными типами файлов, такиим как .xlsx, .csv, .rds - см. детальную информацию на странице Импорт и экспорт).\n\n# импортируем построчный список\nlinelist_case_data &lt;- rio::import(\"linelist_cleaned.rds\")\n\n\n\nУправление данными и преобразования\nЕсли говорить кратко, данные о выживаемости можно описать как имеющие следующие три характеристики:\n\nзависимая переменная или отклик - время ожидания до возникновения хорошо определенного события,\nнаблюдения цензурированы в том смысле, что для некоторых единиц интересующее событие не возникло на момент анализа данных, и\nсуществуют предикторы или независимые переменные, чей эффект на время ожидания мы хотим оценить или контролировать\n\nСледовательно, мы создаем разные переменные, необходимые для соблюдения этой структуры и выполнения анализа выживаемости.\nМы определяем:\n\nновый датафрейм linelist_surv для этого анализа\n\nинтересующее нас событие, как “смерть” (следовательно, вероятность выживания будет вероятностью того, что человек жив через определнный промежуток времени после отправной точки),\nвремя отслеживания (futime) как время от возникновения до времени исхода в днях,\nцензурированных пациентов, каак тех, кто выздоровел или по кому исход неизвестен, т.е. событие “смерть” не наблюдалось (event=0).\n\nВНИМАНИЕ: Поскольку в реальном когортном исследовании информация об отправной точке и окончании отслеживания известна, поскольку люди находятся под наблюдением, мы будем удалять наблюдения, в которых дата возникновения или дата исхода неизвестна. Также будут удалены случаи, когда дата возникновения заболевания позже даты исхода, так как они считаются ошибочными.\nСОВЕТ: Учитывая, что фильтрация по дате больше чем (&gt;) или меньше чем (&lt;) позволяет удалить строки с пропущенными значениями, применение фильтра к неправильным датам также приведет к удалению строк с пропущенными датами.\nЗатем используем case_when(), чтобы создать столбец age_cat_small, в котором будет только 3 возрастных категории.\n\n#создаем новые данные под названием linelist_surv из linelist_case_data\n\nlinelist_surv &lt;-  linelist_case_data %&gt;% \n     \n  dplyr::filter(\n       # удаляем наблюдения с неправильными или отсутствующими датами возникновения или датой исхода\n       date_outcome &gt; date_onset) %&gt;% \n  \n  dplyr::mutate(\n       # создаем переменную event (событие), которая будет равна 1, если пациент умер и 0, если было применено правое цензурирование\n       event = ifelse(is.na(outcome) | outcome == \"Recover\", 0, 1), \n    \n       # создаем переменную по времени отслеживания в днях\n       futime = as.double(date_outcome - date_onset), \n    \n       # создаем новую переменную возрастной категории только с 3 уровнями страт\n       age_cat_small = dplyr::case_when( \n            age_years &lt; 5  ~ \"0-4\",\n            age_years &gt;= 5 & age_years &lt; 20 ~ \"5-19\",\n            age_years &gt;= 20   ~ \"20+\"),\n       \n       # на предыдущем шаге переменная age_cat_small была создана как текстовая.\n       # теперь конвертируем в фактор и задаем уровни\n       # Обратите внимание, что значения NA остаются NA, а не размещаются, например, в уровень \"unknown\" (неизвестно),\n       # поскольку при следующем анализе их нужно будет убрать\n       age_cat_small = fct_relevel(age_cat_small, \"0-4\", \"5-19\", \"20+\")\n       )\n\nСОВЕТ: Мы можем верифицировать новые столбцы, которые мы создали, посмотрев суммарную статистику по futime и кросс-табуляцию между event и outcome, из которых они были созданы. Кроме этой верификации полезной привычкой будет сообщение медианного времени отслеживания при интерпретации результатов анализа выживаемости.\n\nsummary(linelist_surv$futime)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00    6.00   10.00   11.98   16.00   64.00 \n\n# кросс-табуляция новой переменной event и переменной outcome, из которой она была создана\n# чтобы проверить, что код сделал то, что нужно\nlinelist_surv %&gt;% \n  tabyl(outcome, event)\n\n outcome    0    1\n   Death    0 1952\n Recover 1547    0\n    &lt;NA&gt; 1040    0\n\n\nТеперь проведем кросс-табуляцию новой переменной age_cat_small и старого столбца age_cat, чтобы убедиться в правильности присваивания\n\nlinelist_surv %&gt;% \n  tabyl(age_cat_small, age_cat)\n\n age_cat_small 0-4 5-9 10-14 15-19 20-29 30-49 50-69 70+ NA_\n           0-4 834   0     0     0     0     0     0   0   0\n          5-19   0 852   717   575     0     0     0   0   0\n           20+   0   0     0     0   862   554    69   5   0\n          &lt;NA&gt;   0   0     0     0     0     0     0   0  71\n\n\nРассмотрим первые 10 наблюдений из данных linelist_surv, рассматривая конкретные переменные (включая те, которые только что созданы).\n\nlinelist_surv %&gt;% \n  select(case_id, age_cat_small, date_onset, date_outcome, outcome, event, futime) %&gt;% \n  head(10)\n\n   case_id age_cat_small date_onset date_outcome outcome event futime\n1   8689b7           0-4 2014-05-13   2014-05-18 Recover     0      5\n2   11f8ea           20+ 2014-05-16   2014-05-30 Recover     0     14\n3   893f25           0-4 2014-05-21   2014-05-29 Recover     0      8\n4   be99c8          5-19 2014-05-22   2014-05-24 Recover     0      2\n5   07e3e8          5-19 2014-05-27   2014-06-01 Recover     0      5\n6   369449           0-4 2014-06-02   2014-06-07   Death     1      5\n7   f393b4           20+ 2014-06-05   2014-06-18 Recover     0     13\n8   1389ca           20+ 2014-06-05   2014-06-09   Death     1      4\n9   2978ac          5-19 2014-06-06   2014-06-15   Death     1      9\n10  fc15ef          5-19 2014-06-16   2014-07-09 Recover     0     23\n\n\nМы также можем провести кросс-табуляцию столбцов age_cat_small и gender, чтобы получить дополнительную информацию о распределении этого нового столбца по полу. Мы используем tabyl() и функции adorn из janitor, как описано на странице [Описательные таблицы].\n\n\nlinelist_surv %&gt;% \n  tabyl(gender, age_cat_small, show_na = F) %&gt;% \n  adorn_totals(where = \"both\") %&gt;% \n  adorn_percentages() %&gt;% \n  adorn_pct_formatting() %&gt;% \n  adorn_ns(position = \"front\")\n\n gender         0-4          5-19           20+          Total\n      f 482 (22.4%) 1,184 (54.9%)   490 (22.7%) 2,156 (100.0%)\n      m 325 (15.0%)   880 (40.6%)   960 (44.3%) 2,165 (100.0%)\n  Total 807 (18.7%) 2,064 (47.8%) 1,450 (33.6%) 4,321 (100.0%)",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Анализ выживаемости</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.ru.html#основы-анализа-выживаемости",
    "href": "new_pages/survival_analysis.ru.html#основы-анализа-выживаемости",
    "title": "27  Анализ выживаемости",
    "section": "27.3 Основы анализа выживаемости",
    "text": "27.3 Основы анализа выживаемости\n\nПостроение объекта типа surv\nСначала мы используем Surv() из survival, чтобы построить объект выживаемости (survival) из столбцов времени отслеживания и события.\nВ результате такого шага создается объект типа Surv, объединяющий информацию о времени и о том, наблюдалось ли интересующее нас событие (смерть). Этот объект в конечном итоге будет использоваться в правой части последующих формул модели (см. документацию).\n\n# используем синтаксис Suv() для данных с правым цензурированием\nsurvobj &lt;- Surv(time = linelist_surv$futime,\n                event = linelist_surv$event)\n\n\n\n\n\n\nДля рассмотрения представим первые 10 строк данных linelist_surv, и рассмотрим только некоторые важные столбцы.\n\nlinelist_surv %&gt;% \n  select(case_id, date_onset, date_outcome, futime, outcome, event) %&gt;% \n  head(10)\n\n   case_id date_onset date_outcome futime outcome event\n1   8689b7 2014-05-13   2014-05-18      5 Recover     0\n2   11f8ea 2014-05-16   2014-05-30     14 Recover     0\n3   893f25 2014-05-21   2014-05-29      8 Recover     0\n4   be99c8 2014-05-22   2014-05-24      2 Recover     0\n5   07e3e8 2014-05-27   2014-06-01      5 Recover     0\n6   369449 2014-06-02   2014-06-07      5   Death     1\n7   f393b4 2014-06-05   2014-06-18     13 Recover     0\n8   1389ca 2014-06-05   2014-06-09      4   Death     1\n9   2978ac 2014-06-06   2014-06-15      9   Death     1\n10  fc15ef 2014-06-16   2014-07-09     23 Recover     0\n\n\nВот первые 10 элементов survobj. Они печатаются по сути как вектор времени отслеживания с “+”, который отражает, было ли проведено правое цензурирование для наблюдения. Посмотрите, как соотносятся числа выше и ниже.\n\n#печать первых 50 элементов вектора, чтобы посмотреть, как он выглядит\nhead(survobj, 10)\n\n [1]  5+ 14+  8+  2+  5+  5  13+  4   9  23+\n\n\n\n\nПроведение начального анализа\nЗатем мы начинаем наш анализ с использования функции survfit() для создания объекта survfit, который создает расчеты по умолчанию для оценок Каплана Мейера (КМ) для общей (предельной) кривой выживания, которые по факту являются ступенчатой функцией со скачками во время наблюдаемого события. Итоговый объект survfit содержит одну или более кривых выживания и создается, используя объект Surv как переменную отклика в формуле модели.\nПРИМЕЧАНИЕ: Оценка Каплана-Мейера представляет собой непараметрическую оценку максимального правдоподобия функции выживания. (см. дополнительную информацию в Ресурсах).\nСводная информауия по этому объекту survfit выдаст то, что называется таблица вероятности дожития. Для каждого временного шага отслеживания (time), когда произошло событие (в возрастающем порядке):\n\nколичество людей, находящихся в группе риска по развитию события (люди, у которых событие еще не наступило и которые не подвергались цензурированию: n.risk)\n\nте, у кого произошло событие (n.event)\n\nи из указанных выше: вероятность не развить событие (вероятность не умереть или выжить дольше определенного времени)\n\nнаконец, рассчитывается и отображается стандартная ошибка и доверительный интервал для этой вероятности\n\nМы строим оценки КМ по формуле, где объект, ранее являвшийся Surv, “survobj”, является переменной отклика. “~ 1” уточняет, что мы выполняем модель для общей выживаемости.\n\n# строим оценки КМ, используя формулу, где объект Surv \"survobj\" является переменной отклика.\n# \"~ 1\" указывает, что мы выполняем модель для общей выживаемости  \nlinelistsurv_fit &lt;-  survival::survfit(survobj ~ 1)\n\n#печать сводной информации для большей детальности\nsummary(linelistsurv_fit)\n\nCall: survfit(formula = survobj ~ 1)\n\n time n.risk n.event survival std.err lower 95% CI upper 95% CI\n    1   4539      30    0.993 0.00120        0.991        0.996\n    2   4500      69    0.978 0.00217        0.974        0.982\n    3   4394     149    0.945 0.00340        0.938        0.952\n    4   4176     194    0.901 0.00447        0.892        0.910\n    5   3899     214    0.852 0.00535        0.841        0.862\n    6   3592     210    0.802 0.00604        0.790        0.814\n    7   3223     179    0.757 0.00656        0.745        0.770\n    8   2899     167    0.714 0.00700        0.700        0.728\n    9   2593     145    0.674 0.00735        0.660        0.688\n   10   2311     109    0.642 0.00761        0.627        0.657\n   11   2081     119    0.605 0.00788        0.590        0.621\n   12   1843      89    0.576 0.00809        0.560        0.592\n   13   1608      55    0.556 0.00823        0.540        0.573\n   14   1448      43    0.540 0.00837        0.524        0.556\n   15   1296      31    0.527 0.00848        0.511        0.544\n   16   1152      48    0.505 0.00870        0.488        0.522\n   17   1002      29    0.490 0.00886        0.473        0.508\n   18    898      21    0.479 0.00900        0.462        0.497\n   19    798       7    0.475 0.00906        0.457        0.493\n   20    705       4    0.472 0.00911        0.454        0.490\n   21    626      13    0.462 0.00932        0.444        0.481\n   22    546       8    0.455 0.00948        0.437        0.474\n   23    481       5    0.451 0.00962        0.432        0.470\n   24    436       4    0.447 0.00975        0.428        0.466\n   25    378       4    0.442 0.00993        0.423        0.462\n   26    336       3    0.438 0.01010        0.419        0.458\n   27    297       1    0.436 0.01017        0.417        0.457\n   29    235       1    0.435 0.01030        0.415        0.455\n   38     73       1    0.429 0.01175        0.406        0.452\n\n\nПри использовании summary() мы можем добавить опцию times и уточнить определенное время, для которого нам нужна информация о выживаемости\n\n#печатаем сводную информацию на конкретные моменты времени\nsummary(linelistsurv_fit, times = c(5,10,20,30,60))\n\nCall: survfit(formula = survobj ~ 1)\n\n time n.risk n.event survival std.err lower 95% CI upper 95% CI\n    5   3899     656    0.852 0.00535        0.841        0.862\n   10   2311     810    0.642 0.00761        0.627        0.657\n   20    705     446    0.472 0.00911        0.454        0.490\n   30    210      39    0.435 0.01030        0.415        0.455\n   60      2       1    0.429 0.01175        0.406        0.452\n\n\nМы можем также использовать функцию print(). Аргумент print.rmean = TRUE используется, чтобы получить среднее время выживания и его стандартную ошибку (se).\nПРИМЕЧАНИЕ: Ограниченное среднее время выживания (RMST) - это специфическая мера выживаемости, которая все чаще используется в анализе выживаемости при раке и часто определяется как площадь под кривой выживания, если мы наблюдаем пациентов до ограниченного времени T (подробнее в разделе “Ресурсы”)..\n\n# печать объекта linelistsurv_fit со средним временем выживания и его стандартной ошибкой \nprint(linelistsurv_fit, print.rmean = TRUE)\n\nCall: survfit(formula = survobj ~ 1)\n\n        n events rmean* se(rmean) median 0.95LCL 0.95UCL\n[1,] 4539   1952   33.1     0.539     17      16      18\n    * restricted mean with upper limit =  64 \n\n\nСОВЕТ: Мы можем создать объект surv напрямую в функции survfit() и сохранить строку кода. Это будет выглядеть следующим образом: linelistsurv_quick &lt;-  survfit(Surv(futime, event) ~ 1, data=linelist_surv).\n\n\nСовокупный риск\nКроме функции summary() мы также можем использовать функцию str(), которая дает больше деталей о структуре объекта survfit(). Это список из 16 элементов.\nСреди этих элементов есть важный: cumhaz, который является числовым вектором. С ним можно построить график, чтобы показать совокупный моментный риск, где моментный риск - это моментнй коэффициент возникновения события (см. Ресурсы).\n\nstr(linelistsurv_fit)\n\nList of 16\n $ n        : int 4539\n $ time     : num [1:59] 1 2 3 4 5 6 7 8 9 10 ...\n $ n.risk   : num [1:59] 4539 4500 4394 4176 3899 ...\n $ n.event  : num [1:59] 30 69 149 194 214 210 179 167 145 109 ...\n $ n.censor : num [1:59] 9 37 69 83 93 159 145 139 137 121 ...\n $ surv     : num [1:59] 0.993 0.978 0.945 0.901 0.852 ...\n $ std.err  : num [1:59] 0.00121 0.00222 0.00359 0.00496 0.00628 ...\n $ cumhaz   : num [1:59] 0.00661 0.02194 0.05585 0.10231 0.15719 ...\n $ std.chaz : num [1:59] 0.00121 0.00221 0.00355 0.00487 0.00615 ...\n $ type     : chr \"right\"\n $ logse    : logi TRUE\n $ conf.int : num 0.95\n $ conf.type: chr \"log\"\n $ lower    : num [1:59] 0.991 0.974 0.938 0.892 0.841 ...\n $ upper    : num [1:59] 0.996 0.982 0.952 0.91 0.862 ...\n $ call     : language survfit(formula = survobj ~ 1)\n - attr(*, \"class\")= chr \"survfit\"\n\n\n\n\n\nПостроение кривых Каплана-Мейера\nКак только построены оценки КМ, мы можем визуализировать вероятность быть живым через определенное время, используя базовую функцию plot(), которая рисует “Кривую Каплана-Мейера”. Иными словами, кривая ниже является традиционной иллюстрацией опыта выживания в двух полных группах пациентов.\nМы можем быстро верифицировать минимум и максимум времени отслеживания на кривой.\nПростой способ интерпретации заключается в том, что в нулевой момент времени все участники еще живы, поэтому вероятность выживания равна 100%. С течением времени эта вероятность уменьшается, поскольку пациенты умирают. Доля участников, выживших после 60 дней отслеживания, составляет около 40%.\n\nplot(linelistsurv_fit, \n     xlab = \"Days of follow-up\",    # подпись оси x\n     ylab=\"Survival Probability\",   # подпись оси y\n     main= \"Overall survival curve\" # заголовок рисунка\n     )\n\n\n\n\n\n\n\n\nДоверительный интервал оценок выживаемости КМ также строится по умолчанию и может быть отменен добавлением опции conf.int = FALSE в команду plot().\nПоскольку интересующее событие - это “смерть”, построение кривой, описывающей дополнения долей выживаемости, приведет к построению кумулятивных долей смертности. Это можно сделать с помощью lines(), которая добавит информацию на существующий график.\n\n# оригинальный график\nplot(\n  linelistsurv_fit,\n  xlab = \"Days of follow-up\",       \n  ylab = \"Survival Probability\",       \n  mark.time = TRUE,              # отмечаем события на кривой: \"+\" печатается при каждом событии\n  conf.int = FALSE,              # не наносить на график доверительный интервал\n  main = \"Overall survival curve and cumulative mortality\"\n  )\n\n# рисуем дополнительную кривую к предыдущему графику\nlines(\n  linelistsurv_fit,\n  lty = 3,             # используем другой тип линии для ясности\n  fun = \"event\",       # рисуем кумулятивные события вместо выживания \n  mark.time = FALSE,\n  conf.int = FALSE\n  )\n\n# добавляем легенду на график\nlegend(\n  \"topright\",                               # положение легенды\n  legend = c(\"Survival\", \"Cum. Mortality\"), # текст легенды \n  lty = c(1, 3),                            # типы линий для использования в легенде\n  cex = .85,                                # параметры, которые задают размер текст легенды\n  bty = \"n\"                                 # тип без рамки для легенды\n  )",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Анализ выживаемости</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.ru.html#сравнение-кривых-выживаемости",
    "href": "new_pages/survival_analysis.ru.html#сравнение-кривых-выживаемости",
    "title": "27  Анализ выживаемости",
    "section": "27.4 Сравнение кривых выживаемости",
    "text": "27.4 Сравнение кривых выживаемости\nДля сравнения выживаемости в различных группах наблюдаемых нами участников или пациентов может потребоваться сначала рассмотреть соответствующие кривые выживаемости, а затем провести тесты для оценки различий между независимыми группами. Это сравнение может касаться групп по полу, возрасту, лечению, сопутствующим заболеваниям…\n\nЛогарифмический ранговый критерий\nЛогарифмический ранговый критерий является популярным тестом, который сравнивает весь опыт выживания между двумя или более независимыми группами, его можно рассматривать как тест того, являются ли кривые выживаемости идентичными (накладывающимися) или нет (нулевая гипотеза - нет разницы в выживаемости между группами). Функция survdiff() из пакета survival позволяет применить логарифмический ранговый критерий, когда мы уточняем rho = 0 (значение по умолчанию). Результаты теста дают статистику хи-квадрата и p-значение, поскольку статистика логарифмического ранга примерно распределена как статистика теста хи-квадрат.\nСначала мы попытаемся сравнить кривые выживаемости по гендерным группам. Для этого сначала попробуем визуализировать их (проверить, накладываются ли две кривые выживания друг на друга). Необходимо создать новый объект survfit с немного другой формулой. Затем будет создан объект survdiff.\nЗадав ~ gender в качестве правой стороны формулы, мы строим уже не общую выживаемость, а выживаемость по полу.\n\n# создаем новый объект survfit на основе пола\nlinelistsurv_fit_sex &lt;-  survfit(Surv(futime, event) ~ gender, data = linelist_surv)\n\nТеперь мы можем построить график кривых выживания по полу. Посмотрите на порядок уровней страты в столбце пол до определения цветов и легенды.\n\n# задаем цвета\ncol_sex &lt;- c(\"lightgreen\", \"darkgreen\")\n\n# создаем график\nplot(\n  linelistsurv_fit_sex,\n  col = col_sex,\n  xlab = \"Days of follow-up\",\n  ylab = \"Survival Probability\")\n\n# добавляем легенду\nlegend(\n  \"topright\",\n  legend = c(\"Female\",\"Male\"),\n  col = col_sex,\n  lty = 1,\n  cex = .9,\n  bty = \"n\")\n\n\n\n\n\n\n\n\nТеперь мы можем рассчитать тест разницы между кривыми выживаемости, используя survdiff()\n\n#рассчитываем тест разницы между кривыми выживаемости\nsurvival::survdiff(\n  Surv(futime, event) ~ gender, \n  data = linelist_surv\n  )\n\nCall:\nsurvival::survdiff(formula = Surv(futime, event) ~ gender, data = linelist_surv)\n\nn=4321, 218 observations deleted due to missingness.\n\n            N Observed Expected (O-E)^2/E (O-E)^2/V\ngender=f 2156      924      909     0.255     0.524\ngender=m 2165      929      944     0.245     0.524\n\n Chisq= 0.5  on 1 degrees of freedom, p= 0.5 \n\n\nМы видим, что кривая выживаемости для женщин и кривая для мужчин накладываются друг на друга, а логарифмический ранговый критерий не дает доказательств различий в выживаемости между женщинами и мужчинами.\nНекоторые другие пакеты R позволяют иллюстрировать кривые выживаемости для разных групп и тестировать разницу одновременно. Используя функцию ggsurvplot() из пакета survminer, мы также можем включить на нашу кривую напечатанные таблицы рисков для каждой группы, а также p-значение из логарифмического ранкового критерия.\nВНИМАНИЕ: функции survminer требуют, чтобы вы задавали объект выживаемости и снова задавали данные, используемын для построения объекта выживаемости. Не забудьте это сделать, иначе получите неспецифическое сообщение об ошибке. \n\nsurvminer::ggsurvplot(\n    linelistsurv_fit_sex, \n    data = linelist_surv,          # снова задаем данные, используемые для построения linelistsurv_fit_sex \n    conf.int = FALSE,              # не показывать доверительный интервал оценок КМ\n    surv.scale = \"percent\",        # представляет вероятности на оси y в %\n    break.time.by = 10,            # представляет ось времени с шагом в 10 дней\n    xlab = \"Follow-up days\",\n    ylab = \"Survival Probability\",\n    pval = T,                      # печать p-значения логарифмического рангового критерия \n    pval.coord = c(40,.91),        # печать p-значения на этих координатах графика\n    risk.table = T,                # печать таблицы рисков внизу \n    legend.title = \"Gender\",       # характеристики легенды\n    legend.labs = c(\"Female\",\"Male\"),\n    font.legend = 10, \n    palette = \"Dark2\",             # уточняем цветовую палитру \n    surv.median.line = \"hv\",       # рисуем горизонтальные и вертикальные линии по медианному выживанию\n    ggtheme = theme_light()        # упрощаем фон графика\n)\n\n\n\n\n\n\n\n\nМы можем также протестировать различия в выживаемости по источнику инфекции (источнику загрязнения).\nВ данном случае логарифмический ранговый критерий дает достаточно доказательств различий вероятности выживания при alpha= 0.005. Вероятности выживания для пациентов, которые были заражены на похоронах, выше, чем вероятности выживания пациентов, которые заразились в других местах, что указывает на преимущество в выживаемости.\n\nlinelistsurv_fit_source &lt;-  survfit(\n  Surv(futime, event) ~ source,\n  data = linelist_surv\n  )\n\n# plot\nggsurvplot( \n  linelistsurv_fit_source,\n  data = linelist_surv,\n  size = 1, linetype = \"strata\",   # line types\n  conf.int = T,\n  surv.scale = \"percent\",  \n  break.time.by = 10, \n  xlab = \"Follow-up days\",\n  ylab= \"Survival Probability\",\n  pval = T,\n  pval.coord = c(40,.91),\n  risk.table = T,\n  legend.title = \"Source of \\ninfection\",\n  legend.labs = c(\"Funeral\", \"Other\"),\n  font.legend = 10,\n  palette = c(\"#E7B800\",\"#3E606F\"),\n  surv.median.line = \"hv\", \n  ggtheme = theme_light()\n)\n\nWarning in geom_segment(aes(x = 0, y = max(y2), xend = max(x1), yend = max(y2)), : All aesthetics have length 1, but the data has 2 rows.\nℹ Did you mean to use `annotate()`?\nAll aesthetics have length 1, but the data has 2 rows.\nℹ Did you mean to use `annotate()`?\nAll aesthetics have length 1, but the data has 2 rows.\nℹ Did you mean to use `annotate()`?\nAll aesthetics have length 1, but the data has 2 rows.\nℹ Did you mean to use `annotate()`?",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Анализ выживаемости</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.ru.html#регрессия-кокса",
    "href": "new_pages/survival_analysis.ru.html#регрессия-кокса",
    "title": "27  Анализ выживаемости",
    "section": "27.5 Регрессия Кокса",
    "text": "27.5 Регрессия Кокса\nРегрессия пропорциональных рисков Кокса является одним из наиболее популярных методов регрессии для анализа выживаемости. Можно использовать и другие модели, поскольку модель Кокса требует важных допущений, которые необходимо верифицировать для правильного использования, например, допущение о пропорциональных моментных рисках: см. ссылки.\nВ регрессии пропорциональных рисков Кокса мерой эффекта является коэффициент моментных рисков (HR), который представляет собой риск происшествия (или риск смерти в нашем примере), учитывая, что участник дожил до определенного времени. Как правило, нас интересует сравнение независимых групп по отношению к их моментным рискам, и мы используем отношение моментных рисков, корторое похоже на отношение шансов в плане создания множественной логистической регрессии. Функция cox.ph() из пакета survival используется для построения этой модели. Для тестирования допущения о пропорциональных моментных рисках при построении регрессии Кокса можно использовать функцию cox.zph() из пакета survival.\nПРИМЕЧАНИЕ: Вероятность должна лежать в диапазоне от 0 до 1. Однако моментный риск представляет собой ожидаемое число событий за единицу времени.\n\nЕсли коэффициент моментного риска для предиктора близок к 1, то этот предиктор не влияет на выживаемость,\nЕсли коэффициент моментного риска менее 1, тогда предиктор является защитным (т.е. связан с улучшением выживаемости),\nА если коэффициент моментного риска больше 1, тогда предиктор связан с повышенным риском (или снижением выживаемости).\n\n\nПостроение модели Кокса\nСначала мы можем построить модель для оценки влияния возраста и пола на выживаемость. Просто напечатав модель, мы получим информацию о:\n\nоценочных коэффициентах регрессии coef, которые количественно выражают связь между предикторами и исходом,\nих экспоненциальной функции (для интерпретируемости, exp(coef)), которая создает коэффициент моментного риска,\nих стандартной ошибке se(coef),\nz-балле: на сколько стандартных ошибок расчетный коэффициент удален от 0,\nи p-значение: вероятность того, что расчетный коэффициент мог бы быть 0.\n\nФункция summary(), примененная к объекту модели Кокса даст вам больше информации, например, доверительный интервал оцененного коэффициента моментного риска и разные баллы тестов.\nЭффект первой ковариаты gender (пол) представлен в первой строке. genderm (мужской) напечатан, что указывает на то, что первый уровень страты (“f”), т.е. группа женского пола, является референтной группой для пола. Таким образом, интерпретация тестового параметра относится к мужчинам по сравнению с женщинами. p-значение указывает на отсутствие достаточных доказательств влияния пола на ожидаемый моментный риск или связи между полом и смертностью от всех причин.\nТо же отсутствие доказательств отмечается в отношении возрастной группы.\n\n#строим модель Кокса\nlinelistsurv_cox_sexage &lt;-  survival::coxph(\n              Surv(futime, event) ~ gender + age_cat_small, \n              data = linelist_surv\n              )\n\n\n#печать построенной модели\nlinelistsurv_cox_sexage\n\nCall:\nsurvival::coxph(formula = Surv(futime, event) ~ gender + age_cat_small, \n    data = linelist_surv)\n\n                      coef exp(coef) se(coef)      z     p\ngenderm           -0.03149   0.96900  0.04767 -0.661 0.509\nage_cat_small5-19  0.09400   1.09856  0.06454  1.456 0.145\nage_cat_small20+   0.05032   1.05161  0.06953  0.724 0.469\n\nLikelihood ratio test=2.8  on 3 df, p=0.4243\nn= 4321, number of events= 1853 \n   (218 observations deleted due to missingness)\n\n#сводная информация по модели\nsummary(linelistsurv_cox_sexage)\n\nCall:\nsurvival::coxph(formula = Surv(futime, event) ~ gender + age_cat_small, \n    data = linelist_surv)\n\n  n= 4321, number of events= 1853 \n   (218 observations deleted due to missingness)\n\n                      coef exp(coef) se(coef)      z Pr(&gt;|z|)\ngenderm           -0.03149   0.96900  0.04767 -0.661    0.509\nage_cat_small5-19  0.09400   1.09856  0.06454  1.456    0.145\nage_cat_small20+   0.05032   1.05161  0.06953  0.724    0.469\n\n                  exp(coef) exp(-coef) lower .95 upper .95\ngenderm               0.969     1.0320    0.8826     1.064\nage_cat_small5-19     1.099     0.9103    0.9680     1.247\nage_cat_small20+      1.052     0.9509    0.9176     1.205\n\nConcordance= 0.514  (se = 0.007 )\nLikelihood ratio test= 2.8  on 3 df,   p=0.4\nWald test            = 2.78  on 3 df,   p=0.4\nScore (logrank) test = 2.78  on 3 df,   p=0.4\n\n\nБыло интересно выполнить модель и посмотреть на результаты, но первый взгляд на то, соблюдается ли предположение о пропорциональных моментных рисках, мог бы помочь сэкономить время.\n\ntest_ph_sexage &lt;- survival::cox.zph(linelistsurv_cox_sexage)\ntest_ph_sexage\n\n              chisq df    p\ngender        0.454  1 0.50\nage_cat_small 0.838  2 0.66\nGLOBAL        1.399  3 0.71\n\n\nПРИМЕЧАНИЕ: Второй аргумент под названием method (метод) может быть задан при расчете модели Кокса, которая определяет как работать с одинаковыми результатами. По умолчанию используется “efron”, а другие опции включают “breslow” и “exact”.\nВ другой модели мы добавляем дополнительные факторы риска, такие как источник инфекции и количество дней между датой возникновения заболевания и госпитализацией. На этот раз мы сначала проверяем предположение о пропорциональном моментном риске, прежде чем двигаться дальше.\nВ этой модели мы включили непрерывный предиктор (days_onset_hosp). В этом случае мы интерпретируем оценки параметров как увеличение ожидаемого логарифма относительного моментного риска на каждую единицу увеличения предиктора при постоянстве других предикторов. Сначала мы проверим предположение о пропорциональных моментных рисках.\n\n#строим модель\nlinelistsurv_cox &lt;-  coxph(\n                        Surv(futime, event) ~ gender + age_years+ source + days_onset_hosp,\n                        data = linelist_surv\n                        )\n\n\n#тестируем модель пропорциональных рисков\nlinelistsurv_ph_test &lt;- cox.zph(linelistsurv_cox)\nlinelistsurv_ph_test\n\n                   chisq df       p\ngender           0.45062  1    0.50\nage_years        0.00199  1    0.96\nsource           1.79622  1    0.18\ndays_onset_hosp 31.66167  1 1.8e-08\nGLOBAL          34.08502  4 7.2e-07\n\n\nГрафическая верификация этого допущения может выполнена с помощью функции ggcoxzph() из пакета survminer.\n\nsurvminer::ggcoxzph(linelistsurv_ph_test)\n\n\n\n\n\n\n\n\nРезультаты моделирования свидетельствуют о наличии отрицательной связи между продолжительностью госпитализации и смертностью от всех причин. Ожидаемый риск в 0,9 раза ниже у человека, поступившего на один день позже, чем у другого, при постоянном учете пола. Или, в более простом варианте, увеличение продолжительности госпитализации на одну единицу связано с уменьшением риска смерти на 10,7% (coef *100).\nПолученные результаты свидетельствуют также о положительной связи между источником инфекции и смертностью от всех причин. То есть риск смерти (в 1,21 раза) повышается у пациентов, у которых источником инфекции были не похороны.\n\n#печатаем сводную информацию по модели\nsummary(linelistsurv_cox)\n\nCall:\ncoxph(formula = Surv(futime, event) ~ gender + age_years + source + \n    days_onset_hosp, data = linelist_surv)\n\n  n= 2772, number of events= 1180 \n   (1767 observations deleted due to missingness)\n\n                     coef exp(coef)  se(coef)      z Pr(&gt;|z|)    \ngenderm          0.004710  1.004721  0.060827  0.077   0.9383    \nage_years       -0.002249  0.997753  0.002421 -0.929   0.3528    \nsourceother      0.178393  1.195295  0.084291  2.116   0.0343 *  \ndays_onset_hosp -0.104063  0.901169  0.014245 -7.305 2.77e-13 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n                exp(coef) exp(-coef) lower .95 upper .95\ngenderm            1.0047     0.9953    0.8918    1.1319\nage_years          0.9978     1.0023    0.9930    1.0025\nsourceother        1.1953     0.8366    1.0133    1.4100\ndays_onset_hosp    0.9012     1.1097    0.8764    0.9267\n\nConcordance= 0.566  (se = 0.009 )\nLikelihood ratio test= 71.31  on 4 df,   p=1e-14\nWald test            = 59.22  on 4 df,   p=4e-12\nScore (logrank) test = 59.54  on 4 df,   p=4e-12\n\n\nМы можем верифицировать это отношение с помощью таблицы:\n\nlinelist_case_data %&gt;% \n  tabyl(days_onset_hosp, outcome) %&gt;% \n  adorn_percentages() %&gt;%  \n  adorn_pct_formatting()\n\n days_onset_hosp Death Recover   NA_\n               0 44.3%   31.4% 24.3%\n               1 46.6%   32.2% 21.2%\n               2 43.0%   32.8% 24.2%\n               3 45.0%   32.3% 22.7%\n               4 41.5%   38.3% 20.2%\n               5 40.0%   36.2% 23.8%\n               6 32.2%   48.7% 19.1%\n               7 31.8%   38.6% 29.5%\n               8 29.8%   38.6% 31.6%\n               9 30.3%   51.5% 18.2%\n              10 16.7%   58.3% 25.0%\n              11 36.4%   45.5% 18.2%\n              12 18.8%   62.5% 18.8%\n              13 10.0%   60.0% 30.0%\n              14 10.0%   50.0% 40.0%\n              15 28.6%   42.9% 28.6%\n              16 20.0%   80.0%  0.0%\n              17  0.0%  100.0%  0.0%\n              18  0.0%  100.0%  0.0%\n              22  0.0%  100.0%  0.0%\n              NA 52.7%   31.2% 16.0%\n\n\nНеобходимо рассмотреть и исследовать, почему такая связь существует в данных. Одно из возможных объяснений может заключаться в том, что пациенты, прожившие достаточно долго, чтобы быть госпитализированными позже, изначально имели менее тяжелое заболевание. Другое, возможно, более вероятное объяснение состоит в том, что, поскольку мы использовали смоделированный фальшивый набор данных, эта закономерность не отражает реальности!\n\n\n\nФорест-графики\nЗатем мы можем визуализировать результаты модели Кокса, используя практичные форест-графики с помощью функции ggforest() из пакета survminer.\n\nggforest(linelistsurv_cox, data = linelist_surv)",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Анализ выживаемости</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.ru.html#ковариаты-зависящие-от-времени-в-моделях-выживания",
    "href": "new_pages/survival_analysis.ru.html#ковариаты-зависящие-от-времени-в-моделях-выживания",
    "title": "27  Анализ выживаемости",
    "section": "27.6 Ковариаты, зависящие от времени, в моделях выживания",
    "text": "27.6 Ковариаты, зависящие от времени, в моделях выживания\nНекоторые из нижеследующих разделов были адаптированы с разрешения автора из превосходной книги Введение в анализ выживаемости в R, написанной Доктором Эмили Забор\nВ предыдущем разделе мы рассмотрели использование регрессии Кокса для изучения ассоциаций между интересующими нас ковариатами и результатами выживания. Однако эти анализы основаны на том, что ковариата измеряется на исходном уровне, то есть до начала периода отслеживания события.\nЧто произойдет, если вас интересует ковариата, которая измеряется после того, как началось время отслеживания? Или если у вас ковариата, которая может меняться со временем?\nНапример, вы работаете с клиническими данными, в которых повторяются измерения показателей больничных лабораторий, которые могут меняться с течением времени. Это является примером Ковариаты, зависящей от времени. Для решения этой задачи необходима специальная настройка, но, к счастью, модель Кокса очень гибкая, и этот тип данных также может быть смоделирован с помощью инструментов из пакета survival.\n\nНастройка ковариаты, зависящей от времени\nАнализ ковариат, зависящих от времени, в R требует создания специального набора данных. Если интересно, см. более подробную статью об этом от автора пакета survival Использование зависящих от времени ковариат и зависящих от времени коэффициентов в модели Кокса.\nДля этого используем новый набор данных из пакета SemiCompRisks под названием BMT, который включает данные о 137 пациентах после пересадки костного мозга. Переменные, на которых мы сфокусируемся:\n\nT1 - время (в днях) до смерти или последнего отслеживания\n\ndelta1 - индикатор смерти; 1-умер, 0-жив\n\nTA - время (в днях) до острой реакции трансплантат против хозяина\n\ndeltaA - индикатор острой реакции трансплантат против хозяина;\n\n1 - развилась острая реакция трансплантат против хозяина\n\n0 - никогда не было острой реакции трансплантат против хозяина\n\n\nМы загрузим этот набор данных из пакета survival, используя команду из базового R data(), которую можно использовать для загрузки данных, которые уже включены в пакет R, который загружается. Датафрейм BMT появится в рабочей среде R (environment).\n\ndata(BMT, package = \"SemiCompRisks\")\n\n\nДобавляем уникальный идентификатор пациента\nВ данных BMT нет столбца с уникальным ID, который необходим для создания такого типа набора данных, который нам нужен. Поэтому мы используем функцию rowid_to_column() из пакета tidyverse tibble для создания нового столбца с id под именем my_id (добавляет столбец в начале датафрейма с последовательными идентификаторами строк, начиная с 1). Назовем датафрейм bmt.\n\nbmt &lt;- rowid_to_column(BMT, \"my_id\")\n\nНабор данных теперь выглядит так:\n\n\n\n\n\n\n\n\nРасширяем строки по пациентам\nДалее используем функцию tmerge() с функциями-помощниками event() и tdc(), чтобы создать реструктурированный набор данных. Наша цель - реструктурировать набор данных, чтобы создать отдельную строку для каждого пациента в каждый временной интервал, когда у них отличаются значения deltaA. В этом случае у каждого пациента может быть не более двух строк в зависимости от того, развилась ли у него острая реакция “трансплантат против хозяина” за период сбора данных. Назовем наш новый показатель развития острой реакции трансплантат против хозяина agvhd.\n\ntmerge() создает длинный набор данных с несколькими временными интервалами для разных значений ковариат для каждого пациента\nevent() создает новый индикатор события для новых созданных временных интервалов\ntdc() создает столбец зависящей от времени ковариаты, agvhd, по новым созданным временным интервалам\n\n\ntd_dat &lt;- \n  tmerge(\n    data1 = bmt %&gt;% select(my_id, T1, delta1), \n    data2 = bmt %&gt;% select(my_id, T1, delta1, TA, deltaA), \n    id = my_id, \n    death = event(T1, delta1),\n    agvhd = tdc(TA)\n    )\n\nЧтобы увидеть, что это даст, давайте рассмотрим данные по первым 5 пациентам.\nИнтересующие переменные в оригинальном наборе данных выглядели так:\n\nbmt %&gt;% \n  select(my_id, T1, delta1, TA, deltaA) %&gt;% \n  filter(my_id %in% seq(1, 5))\n\n  my_id   T1 delta1   TA deltaA\n1     1 2081      0   67      1\n2     2 1602      0 1602      0\n3     3 1496      0 1496      0\n4     4 1462      0   70      1\n5     5 1433      0 1433      0\n\n\nНовый набор данных для тех же пациентов выглядит так:\n\ntd_dat %&gt;% \n  filter(my_id %in% seq(1, 5))\n\n  my_id   T1 delta1 tstart tstop death agvhd\n1     1 2081      0      0    67     0     0\n2     1 2081      0     67  2081     0     1\n3     2 1602      0      0  1602     0     0\n4     3 1496      0      0  1496     0     0\n5     4 1462      0      0    70     0     0\n6     4 1462      0     70  1462     0     1\n7     5 1433      0      0  1433     0     0\n\n\nТеперь у некоторых наших пациентов есть две строки в наборе данных, соответствующие интервалам, в которых они имеют разные значения нашей новой переменной, agvhd. Например, у Пациента 1 сейчас две строки со значением agvhd ноль с момента 0 до времени 67, и значение 1 с времени 67 до времени 2081.\n\n\n\nРегрессия Кокса с ковариатами, зависящими от времени\nТеперь, когда мы переформатировали наши данные и добавили новую зависящую от времени переменную aghvd, давайте построим простую регрессию Кокса с одной переменной. Мы можем использовать ту же функцию coxph() как ранее, нам только нужно изменить нашу функцию Surv(), чтобы уточнить время начала и окончания каждого интервала, используя аргументы time1 = и time2 =.\n\nbmt_td_model = coxph(\n  Surv(time = tstart, time2 = tstop, event = death) ~ agvhd, \n  data = td_dat\n  )\n\nsummary(bmt_td_model)\n\nCall:\ncoxph(formula = Surv(time = tstart, time2 = tstop, event = death) ~ \n    agvhd, data = td_dat)\n\n  n= 163, number of events= 80 \n\n        coef exp(coef) se(coef)    z Pr(&gt;|z|)\nagvhd 0.3351    1.3980   0.2815 1.19    0.234\n\n      exp(coef) exp(-coef) lower .95 upper .95\nagvhd     1.398     0.7153    0.8052     2.427\n\nConcordance= 0.535  (se = 0.024 )\nLikelihood ratio test= 1.33  on 1 df,   p=0.2\nWald test            = 1.42  on 1 df,   p=0.2\nScore (logrank) test = 1.43  on 1 df,   p=0.2\n\n\nОпять же, мы визуализируем результаты нашей модели Кокса, используя функцию ggforest() из пакета survminer.:\n\nggforest(bmt_td_model, data = td_dat)\n\n\n\n\n\n\n\n\nКак видно из форест-графика, доверительного интервала и значения p, в контексте нашей простой модели не наблюдается сильной связи между смертью и острой реакцией трансплантат против хозяина.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Анализ выживаемости</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.ru.html#ресурсы",
    "href": "new_pages/survival_analysis.ru.html#ресурсы",
    "title": "27  Анализ выживаемости",
    "section": "27.7 Ресурсы",
    "text": "27.7 Ресурсы\nАнализ выживаемости Часть I: Основные концепции и первый анализ\nАнализ выживаемости в R\nАнализ выживаемости в исследованиях по инфекционным заболеваниям: Описание событий во времени\nГлава по продвинутым моделям выживания от Принстона\nИспользование ковариат, зависящих от времени, в модели Кокса\nШпаргалка по анализу выживаемости в R\nШпаргалка по Survminer\nРабота по разным мерам выживаемости для данных регистров рака с предоставлением Rcode в качестве дополнительных материалов",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Анализ выживаемости</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.ru.html",
    "href": "new_pages/gis.ru.html",
    "title": "28  Основы ГИС",
    "section": "",
    "text": "28.1 Обзор\nПространственные аспекты ваших данных могут дать много полезной информации в ситуации вспышек, а также ответить на подобные вопросы:\nФокус данной страницы по ГИС - ответить на потребности прикладных эпидемиологов при реагировании на вспышки. Мы рассмотрим основные методы пространственной визуализации данных, используя пакеты tmap и ggplot2. Мы также рассмотрим некоторые основные методы управления данными и запросов с помощью пакета sf. И наконец, мы кратко затронем концепции пространственной статистики, например, пространственные отношения, пространственная автокорреляция и пространственная регрессия, используя пакет spdep.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Основы ГИС</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.ru.html#обзор",
    "href": "new_pages/gis.ru.html#обзор",
    "title": "28  Основы ГИС",
    "section": "",
    "text": "Где находятся текущие очаги заболевания?\nКак изменились очаги со временем?\nКаков доступ к медицинским организациям? Нужны ли какие-то улучшения?",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Основы ГИС</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.ru.html#ключевые-понятия",
    "href": "new_pages/gis.ru.html#ключевые-понятия",
    "title": "28  Основы ГИС",
    "section": "28.2 Ключевые понятия",
    "text": "28.2 Ключевые понятия\nНиже мы представим некоторые ключевые понятия. Для более подробного знакомства с ГИС и пространственным анализом, мы рекомендуем вам изучить один из более подробных самоучителей или курсов, указанных в разделе Ресурсы.\nГеографическая информационная система (ГИС) - ГИС - это рамка или среда для сбора, управления, анализа и визуализации пространственных данных.\n\nПрограммное обеспечение ГИС\nНекоторые популярные ГИС программы допускают взаимодействие по принципу “навести и кликнуть” для разработки карты и пространственного анализа. Эти инструменты имеют свои преимущества - не нужно учиться писать код и легко выбирать вручную и размещать иконки и параметры на карте. Вот две популярных программы:\nArcGIS - Коммерческая ГИС программа, разработанная компанией ESRI, которая очень популярна, но весьма дорогая\nQGIS - Бесплатная открытая ГИС программа, которая может делать почти все то же самое, что и ArcGIS. Вы можете скачать QGIS тут\nИспользование R как ГИС может сначала показаться сложным, поскольку вместо принципа “навести и кликнуть” используется “интерфейс командной строки” (необходимо написать код, чтобы получить желаемый результат). Однако это является серьезным преимуществом, если вам необходимо регулярно готовить одни и те же карты или создавать воспроизводимый анализ.\n\n\nПространственные данные\nДве основные формы пространственных данных, используемых в ГИС, включают в себя векторные и растровые данные:\nВекторные данные - Наиболее частый формат пространственных данных, используемых в ГИС, векторные данные состоят из геометрических характеристик вершин и путей. Векторные пространственные данные можно еще разделить на три широко используемых типа:\n\nТочки - Точка состоит из пары координат (x,y), представляющих определенное место в системе координат. Точки являются наиболее простой формой пространственных данных и могут использоваться для обозначения случая (например, дома пациента) или места (например, больницы) на карте.\nЛинии - Линия состоит из двух соединенных точек. Линии имеют определенную длину и могут использоваться для обозначения таких объектов, как дороги или реки.\nПолигоны - Полигон состоит как минимум из трех отрезков, соединенных точками. Полигоны имеют длину (т.е. периметр области), а также измеряют площадь. Полигоны могут использоваться для обозначения территории (например, деревни) или структуры (например, фактической площади больницы).\n\nРастровые данные - Альтернативный формат пространственных данных, растровые данные представляют собой матрицу ячеек (например, пикселей), каждая из которых содержит такую информацию, как высота, температура, уклон, лесной покров и т.д. Часто это аэрофотоснимки, спутниковые снимки и т.д. Растровые данные также могут использоваться в качестве “базовых карт” под векторными данными.\n\n\nВизуализация пространственных данных\nЧтобы визуально представить пространственные данные на карте, программное обеспечение ГИС требует от вас задать достаточную информацию о том, где должны быть характеристики по отношению друг к другу. Если вы используете векторные данные, что действительно так в большинстве примеров применения, эта информация, как правило, хранится в шейп-файле:\nШейп-файлы - Шейп-файл - частый формат данных для хранения “векторных” пространственных данных, состоящих из линий, точек или полигново. Один шейп-файл на самом деле является сочетанием как минимум трех файлов - .shp, .shx, и .dbf. Все эти файлы-подкомпоненты должны присутствовать в определенной директории (папке) для того, чтобы шейп-файл был читаемым. Эти связанные файлы можно сжать в ZIP папку и направить по почте, либо скачать с веб-сайта.\nШейп-файл будет содержать информацию о самих характеристиках, а также о том, где их найти на поверхности Земли. Это важно, потому что хотя Земля - шар, карты, как правило, двухмерные; решения о том, как сделать пространственные данные “плоскими” может иметь большое влияение на вид и интерпретацию полученных в результате карт.\nРеферентная система координат (РСК) - это это система координат, используемая для определения местоположения географических объектов на поверхности Земли. Она состоит из нескольких основных компонентов:\n\nСитема координат - Существует множество различных систем координат, поэтому необходимо знать, в какой системе находятся ваши координаты. Обычно используются градусы широты/долготы, но можно также использовать координаты универсальной поперечной проекции Меркатора UTM.\nЕдиницы - знайте, какие единицы используютсядля вашей системы координат (например, десятичные градусы, метры)\nОснова системы координат - Определенная смоделированная версия Земли. В течение многих лет они пересматривались, поэтому убедитесь, что слои карты используют одну и ту же основу.\nПроекция - Ссылка на математическое уравнение, которое было использовано для проецирования истинно круглой Земли на плоскую поверхность (карту).\n\nПомните, что обобщить пространственные данные можно и без использования представленных ниже картографических средств. Иногда достаточно простой таблицы по географическому признаку (например, район, страна и т.д.)!",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Основы ГИС</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.ru.html#начало-работы-с-гис",
    "href": "new_pages/gis.ru.html#начало-работы-с-гис",
    "title": "28  Основы ГИС",
    "section": "28.3 Начало работы с ГИС",
    "text": "28.3 Начало работы с ГИС\nДля создания карты необходимо иметь и продумать несколько ключевых моментов. К ним относятся:\n\nНабор данных – Это может быть формат пространственных данных (например, шейп-файлы, как отмечалось выше), а может быть и не пространственный формат (например, просто csv).\nЕсли ваш набор данных не в пространственном формате, вам также потребуется референтный набор данных. Референтные данные состоят из пространственного представления данных и соответствующих атрибутов, которые включают материал, содержащий информацию о месте расположения и адресе конкретных характеристик.\n\nЕсли вы работаете с заранее определенными географическими границами (например, административными районами), то референтные шейп-файлы часто можно свободно загрузить из государственных учреждений или организаций по обмену данными. В случае сомнений лучше всего начать с поиска в Google “шейп-файл [регионов]”\nЕсли у вас есть информация об адресе, но нет широты и долготы, вы можете использовать механизм геокодирования, чтобы получить референтные пространственные данные для ваших записей.\n\nИдея того, как вы хотите представить информацию в ваших наборах данных вашей целевой аудитории. Существует много разных типов карт и важно подумать о том, какой тип карты лучше подходит для ваших потребностей.\n\n\nТипы карт для визуализации ваших данных\nКартограмма - тип тематической карты, в которой цвета, тени или узоры используются для представления географических регионов в зависимости от значения какого-либо атрибута. Например, большее значение может быть обозначено более темным цветом, чем меньшее. Этот тип карт особенно полезен при визуализации переменной и ее изменений в определенных регионах или геополитических зонах.\n\n\n\n\n\n\n\n\n\nТепловая карта плотности случаев - разновидность тематической карты, в которой цвета используются для отображения интенсивности значения, однако для группирования данных не используются определенные регионы или геополитические границы. Этот тип карт обычно используется для отображения ‘очагов’ или зон с высокой плотностью или концентрацией точек.\n\n\n\n\n\n\n\n\n\nКарта плотности точек - тип тематической карты, на которой точками обозначаются значения атрибутов в данных. Этот тип карты лучше всего использовать для визуализации разброса данных и визуального поиска кластеров.\nКарта пропорциональных символов (карта градуированных символов) - тематическая карта, аналогичная картограмме, но вместо цвета для обозначения значения атрибута используется символ (обычно круг) по отношению к значению. Например, большее значение может быть обозначено более крупным символом, чем меньшее значение. Этот тип карты лучше всего использовать, когда необходимо визуализировать размер или количество данных по географическим регионам.\nМожно также комбинировать несколько различных типов визуализаций, чтобы показать сложные географические закономерности. Например, на приведенной ниже карте случаи (точки) окрашены в соответствии с ближайшим к ним медицинским учреждением (см. легенду). Крупные красные круги показывают участки прикрепления (охвата) для медицинской организации определенного радиуса, а яркие красные точки - случаи, находящиеся за пределами зон охвата:\n\n\n\n\n\n\n\n\n\nПримечание: Основной фокус данной страницы по ГИС основан на контексте реагирования на вспышки заболеваний на местах. Поэтому содержание страницы охватывает основные операции с пространственными данными, визуализацию и анализ.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Основы ГИС</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.ru.html#подготовка",
    "href": "new_pages/gis.ru.html#подготовка",
    "title": "28  Основы ГИС",
    "section": "28.4 Подготовка",
    "text": "28.4 Подготовка\n\nЗагрузка пакетов\nЭтот фрагмент кода показывает загрузку пакетов, необходимых для анализа. В данном руководстве мы фокусируемся на использовании p_load() из пакета pacman, которая устанавливает пакет, если необходимо, и загружает его для использования. Вы можете также загрузить установленные пакеты с помощью library() из базового R. См. страницу [Основы R] для получения дополнительной информации о пакетах R.\n\npacman::p_load(\n  rio,           # для импорта данных\n  here,          # для пути к файлу\n  tidyverse,     # для вычистки, работы с данными и построения графиков (включает пакет ggplot2)\n  sf,            # для управления пространственными данными, используя формат простых свойств (Simple Feature)\n  tmap,          # для создания простых карт, работает как для интерактивных, так и статичных карт\n  janitor,       # для вычистки имен столбцов\n  OpenStreetMap, # для добавления базовой карты OSM на карту ggplot\n  spdep          # пространственная статистика\n  ) \n\nВы можете посмотреть обзор всех пакетов, которые работают с пространственными данными в CRAN “Spatial Task View”.\n\n\nПример данных о случаях\nДля демонстрационных целей мы будем работать со случайной выборкой из 1000 случаев из имитированной эпидемии Эболы из датафрейма linelist (с точки зрения вычислений работу с меньшим количеством случаев легче отобразить в руководстве). Если вы хотите выполнять действия параллельно, кликните, чтобы скачать “чистый” построчный список (как .rds файл).\nПоскольку мы делаем случайную выборку, при самостоятельном выполнении кодов результаты могут несколько отличаться от представленных здесь.\nИмпортируем данные с помощью функции import() из пакета rio (он работает с разными типами файлов, такими как .xlsx, .csv, .rds - см. детали на странице [Импорт и экспорт]).\n\n# импорт чистого построчного списка случаев\nlinelist &lt;- import(\"linelist_cleaned.rds\")  \n\nДалее делаем случайную выборку 1000 строк, используя sample() из базового R.\n\n# генерируем 1000 случайных номеров строк из числа строк построчного списка\nsample_rows &lt;- sample(nrow(linelist), 1000)\n\n# подмножество построчного списка, чтобы сохранить только строки выборки и все столбцы\nlinelist &lt;- linelist[sample_rows,]\n\nТеперь нам нужно конвертировать этот построчный список linelist, который относится к классу датафрейм, в объект класса “sf” (пространственные свойства). Учитывая, что в построчном списке есть два столбца “lon” и “lat”, представляющих собой долготу и широту для места проживания каждого случая, это будет легко сделать.\nМы используем пакет sf (пространственные свойствуа) и его функцию st_as_sf() для создания нового объекта, который мы назовем linelist_sf. Этот новый объект, по сути, выглядит так же как и построчный список, но столбцы lon и lat были отмечены как столбцы координат и была присвоена референтная система координат при отображении точек. 4326 определяет наши координаты как основанные на всемирной геодезической системе 1984 (WGS84) - которая является стандартом для GPS координат.\n\n# создаем объект sf\nlinelist_sf &lt;- linelist %&gt;%\n     sf::st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326)\n\nВот так выглядит оригинальный датафрейм linelist. В этой демонстрации мы будем использовать только столбец date_onset и geometry (который был создан из полей широты и долготы, указанных выше, и является последним столбцом в датафрейме).\n\nDT::datatable(head(linelist_sf, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )\n\n\n\n\n\n\n\nШейп-файлы административных границ\nСьерра-Леоне: шейп-файлы административных границ\nМы заранее скачали все административные границы для Сьерра-Леоне с веб-сайта Humanitarian Data Exchange (HDX) веб-сайт тут. Альтернативно вы можете скачать их и другие примеры данных для руководства через наш пакет R, который представлен на странице [Скачивание руководствау и данных].\nТеперь мы выполним следующие действия, чтобы сохранить шейп-файл Admin Level 3 в R:\n\nИмпортируем шейп-файл\n\nВычищаем имена столбцов\n\nФильтруем строки, чтобы сохранить только интересующие районы\n\nЧтобы импортировать шейп-файл, мы используем функцию read_sf()из sf. Ей задается путь к файлу с помощью here(). - в нашем случае файл находится внутри нашего проекта R в подпапках “data”, “gis” и “shp”, а имя файла - “sle_adm3.shp” (для дополнительной информации см. страницы [Импорт и экспорт] и [Проекты R]). Вам нужно задать свой собственный путь к файлу.\nДалее мы используем clean_names() из пакета janitor, чтобы стандартизировать имена столбцов шейп-файла. Мы также используем filter(), чтобы сохранить только строки с admin2name “Western Area Urban” или “Western Area Rural”.\n\n# чистый уровень ADM3\nsle_adm3 &lt;- sle_adm3_raw %&gt;%\n  janitor::clean_names() %&gt;% # стандартизируем имена столбцов\n  filter(admin2name %in% c(\"Western Area Urban\", \"Western Area Rural\")) # фильтр, чтобы сохранить некоторые районы\n\nНиже вы видите как выглядит каждый шейп-файл после импорта и вычистки. Пролистайте вправо, чтобы увидеть столбцы с admin уровень 0 (страна), admin уровень 1, admin уровень 2, и наконец, admin уровень 3. У каждого уровня есть текстовое имя и уникальный идентификационный “pcode”. pcode увеличивается на каждом увеличивающемся уровне admin level, например, SL (Сьерра-Леоне) -&gt; SL04 (Western - западная) -&gt; SL0410 (Western Area Rural - Западный сельский район) -&gt; SL040101 (Koya Rural - Сельский район Койа).\n\n\n\n\n\n\n\n\nДанные о населении\nСьерра-Леоне: Население по ADM3\nОпять же, эти данные можно скачать с (ссылка тут) или через наш пакет R epirhandbook, как объясняется [на этой странице][Скачивание руководства и данных]. Мы используем import() для загрузки .csv файла. Мы также передаем импортированный файл в clean_names(), чтобы стандартизировать синтаксис имен столбцов.\n\n# Население по ADM3\nsle_adm3_pop &lt;- import(here(\"data\", \"gis\", \"population\", \"sle_admpop_adm3_2020.csv\")) %&gt;%\n  janitor::clean_names()\n\nВот как выглядит файл по населению. Пролистайте вправо, посмотрите, что у каждой юрисдикции есть столбец с мужским населением (male), женским населением (female), общим населением (total), а также разбивка населения по столбцам по возрастной группе.\n\n\n\n\n\n\n\n\nМедицинские организации\nСьерра-Леоне: Данные о медицинских организациях из OpenStreetMap\nОпять же, мы скачиваем места расположения медицинских организаций с HDX тут или с помощью инструкций на странице [Скачивание руководства и данных].\nМы импортируем шейп-файл с точками медицинских организацией с помощью read_sf(), также вычищаем имена столбцов, затем фильтруем, чтобы сохранить только те точки, которые отмечены как “hospital”, “clinic” или “doctors”.\n\n# Шейп-файл по медицинским организациям из OSM\nsle_hf &lt;- sf::read_sf(here(\"data\", \"gis\", \"shp\", \"sle_hf.shp\")) %&gt;% \n  janitor::clean_names() %&gt;%\n  filter(amenity %in% c(\"hospital\", \"clinic\", \"doctors\"))\n\nВот получившийся в результате датафрейм - пролистайте вправо, чтобы увидеть название организации и координаты geometry.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Основы ГИС</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.ru.html#построение-графика-координат",
    "href": "new_pages/gis.ru.html#построение-графика-координат",
    "title": "28  Основы ГИС",
    "section": "28.5 Построение графика координат",
    "text": "28.5 Построение графика координат\nСамый простой способ построить координаты X-Y (долгота/широта, точки), в случае этих случаев - нарисовать их как точки напрямую из объекта linelist_sf, который мы создали на этапе подготовки.\nПакет tmap предлагает простые возможности составления как статических (режим “график - plot”), так и интерактивных карт (режим “просмотр - view”) буквально с помощью нескольких строк кода. Синтаксис tmap похож на ggplot2 в том, что команды добавляются друг к другу +. Более подробно читайте в этой виньетке.\n\nУстанавливаем режим tmap. В этом случае используем режим графика “plot”, который создает статические результаты.\n\n\ntmap_mode(\"plot\") # выберите \"view\" или \"plot\"\n\nНиже мы показываем только точки. В tm_shape() задаются объекты linelist_sf. Затем мы добавляем точки с помощью tm_dots(), уточняяя размер и цвет. Поскольку linelist_sf является объектом sf, мы уже назначили два столбца, которые содержат координаты широты/долготы и референтную систему координат (РСК):\n\n# Только случаи (точки)\ntm_shape(linelist_sf) + tm_dots(size=0.08, col='blue')\n\n\n\n\n\n\n\n\nОтдельно точки не очень информативны. Поэтому нужно также наложить карту административных границ:\nМы снова используем tm_shape() (см. документацию), но вместо того, чтобы задать шейп-файл с точками случаев, мы задаем шейп-файл с административными границами (полигонами).\nС помощью аргумента bbox = (bbox означает “ограничительная рамка”) мы можем уточнить границы координат. Сначала мы покажем отображение карты без bbox, а затем с ним.\n\n# Только административные границы (полигоны)\ntm_shape(sle_adm3) +               # шейп-файл административных границ\n  tm_polygons(col = \"#F7F7F7\")+    # показываем полигоны светло серым\n  tm_borders(col = \"#000000\",      # показываем границы с помощью цвета и толщины линии\n             lwd = 2) +\n  tm_text(\"admin3name\")            # текст столбца для отображения для каждого полигона\n\n\n# Также как до этого, но с ограничительной рамкой\ntm_shape(sle_adm3,\n         bbox = c(-13.3, 8.43,    # угол\n                  -13.2, 8.5)) +  # угол\n  tm_polygons(col = \"#F7F7F7\") +\n  tm_borders(col = \"#000000\", lwd = 2) +\n  tm_text(\"admin3name\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nТеперь вместе точки и полигоны:\n\n# All together\ntm_shape(sle_adm3, bbox = c(-13.3, 8.43, -13.2, 8.5)) +     #\n  tm_polygons(col = \"#F7F7F7\") +\n  tm_borders(col = \"#000000\", lwd = 2) +\n  tm_text(\"admin3name\")+\ntm_shape(linelist_sf) +\n  tm_dots(size=0.08, col='blue', alpha = 0.5) +\n  tm_layout(title = \"Distribution of Ebola cases\")   # определяем заголовок карты\n\n\n\n\n\n\n\n\nХорошее сравнение опций картирования в R можно прочитать в этом посте в блоге.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Основы ГИС</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.ru.html#пространственные-соединения",
    "href": "new_pages/gis.ru.html#пространственные-соединения",
    "title": "28  Основы ГИС",
    "section": "28.6 Пространственные соединения",
    "text": "28.6 Пространственные соединения\nВы можете быть знакомы с соединением данных из одного набора данных с другим. На странице [Соединение данных] руководства обсуждается несколько методов. Пространственное соединение служит аналогичным целям, но использует в большей степени пространственные отношения. Вместо того, чтобы полагаться на общие значения в столбцах, которые должны совпадать с наблюдениями, вы можете использовать их пространственные отношения, например, если одна характеристика находится внутри другой, либо является ближайшим соседом к другому, либо находится внутри буферной зоны определенного радиуса от другого и т.п.\nПакет sf предлагает разные методы пространственного соединения. См. дополнительную документацию по методу st_join и типам пространственного соединения по этой ссылке.\n\nТочки в полигонах\nПространственное присваивание административных единиц для случаев\nЗдесь возникает интересная проблема: в построчном списке случаев не содержится никакой информации об административных единицах этих случаев. Хотя идеально было бы собрать такую информацию на этапе первоначального сбора данных, мы также можем присвоить административные единицы отдельным случаям на основе их пространственных связей (например, точка пересекается с полигоном).\nНиже мы отобразим пространственное пересечение расположения случаев (точки) с границами ADM3 (полигоны):\n\nНачинаем с построчного списка (точки)\n\nПространственное соединение с границами, установка типа соединения в “st_intersects”\n\nИспользуем select(), чтобы сохранить только некоторые новые столбцы с административными границами\n\n\nlinelist_adm &lt;- linelist_sf %&gt;%\n  \n  # соединяем файл с административными границами с построчным списком на основе пространственного пересечения\n  sf::st_join(sle_adm3, join = st_intersects)\n\nВса столбцы из sle_adms были добавлены в построчный список! У каждого случая теперь есть столбцы, указывающие административные уровни, к которым он относится. В данном примере мы хотим сохранить только два новых столбца (уровень admin 3), поэтому вы выбираем старые имена столбцов и всего два дополнительных интересующих с помощью select():\n\nlinelist_adm &lt;- linelist_sf %&gt;%\n  \n  # соединяем файл с административными границами с построчным списком на основе пространственного пересечения\n  sf::st_join(sle_adm3, join = st_intersects) %&gt;% \n  \n  # сохраняем старые имена столбцов и два новых интересующих столбца admin\n  select(names(linelist_sf), admin3name, admin3pcod)\n\nНиже в целях иллюстрирования вы можете увидеть первые 10 случаев и их юрисдикции на уровне admin 3 (ADM3), которые были присоединены на основе того, где точка пространственно пересекалась с формами полигонов.\n\n# теперь используем имена ADM3, присоединенные к каждому случаю\nlinelist_adm %&gt;% select(case_id, admin3name, admin3pcod)\n\nSimple feature collection with 1000 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -13.2698 ymin: 8.446206 xmax: -13.20636 ymax: 8.490413\nGeodetic CRS:  WGS 84\nFirst 10 features:\n     case_id admin3name admin3pcod                   geometry\n5611  c07ba2       &lt;NA&gt;       &lt;NA&gt; POINT (-13.23799 8.489879)\n2767  8afe86   West III   SL040208 POINT (-13.25158 8.458938)\n1917  bd14cc  Central I   SL040201 POINT (-13.22631 8.471497)\n1354  d0523a    West II   SL040207 POINT (-13.25656 8.483792)\n3641  811fb2   West III   SL040208 POINT (-13.26702 8.456449)\n3082  980dd5     East I   SL040203 POINT (-13.21483 8.484382)\n4035  d17dee    East II   SL040204 POINT (-13.22046 8.482752)\n2720  278880   West III   SL040208 POINT (-13.26201 8.465187)\n2630  35b238   West III   SL040208 POINT (-13.25309 8.457383)\n2764  504fa3     East I   SL040203 POINT (-13.21727 8.488745)\n\n\nТеперь мы можем описать наши случаи по административной единице - до пространственного соединения мы не могли этого сделать!\n\n# создаем новый датафрейм, содержащий количество случаев по административным единицам\ncase_adm3 &lt;- linelist_adm %&gt;%          # начинаем с построчного списка с новыми столбцами admin\n  as_tibble() %&gt;%                      # конвертируем в таблицу tibble для более удобного отображения\n  group_by(admin3pcod, admin3name) %&gt;% # группируем по административной единице по имени и pcode \n  summarise(cases = n()) %&gt;%           # обобщаем и считаем строки\n  arrange(desc(cases))                     # сортируем в порядке уменьшения\n\ncase_adm3\n\n# A tibble: 10 × 3\n# Groups:   admin3pcod [10]\n   admin3pcod admin3name     cases\n   &lt;chr&gt;      &lt;chr&gt;          &lt;int&gt;\n 1 SL040102   Mountain Rural   274\n 2 SL040208   West III         225\n 3 SL040207   West II          188\n 4 SL040204   East II          111\n 5 SL040203   East I            60\n 6 SL040201   Central I         51\n 7 SL040206   West I            45\n 8 SL040205   East III          23\n 9 SL040202   Central II        18\n10 &lt;NA&gt;       &lt;NA&gt;               5\n\n\nМы также можем создать столбчатую диаграмму количества случаев по административным единицам.\nВ этом примере мы начнем ggplot() с linelist_adm, чтобы мы могли применить функции факторов, такие как fct_infreq(), которая упорядочивает столбцы по частоте (см. советы на странице [Факторы]).\n\nggplot(\n    data = linelist_adm,                       # начинаем с построчного списка, содержащего информацию об административной единице\n    mapping = aes(\n      x = fct_rev(fct_infreq(admin3name))))+ # ось x - административные единицы, упорядоченные по частоте (в обратном порядке)\n  geom_bar()+                                # создаем столбцы, высота - количество строк\n  coord_flip()+                              # меняем местами оси X и Y, чтобы легче читать административные единицы\n  theme_classic()+                           # упрощаем фон\n  labs(                                      # заголовки и подписи\n    x = \"Admin level 3\",\n    y = \"Number of cases\",\n    title = \"Number of cases, by adminstative unit\",\n    caption = \"As determined by a spatial join, from 1000 randomly sampled cases from linelist\"\n  )\n\n\n\n\n\n\n\n\n\n\n\nБлижайшие соседи\nПоиск ближайшей медицинской организации/участка прикрепления\nМожет быть полезным узнать, где расположены медицинские организации относительно очагов заболевания.\nМы можем использовать метод соединения st_nearest_feature из функции st_join() (пакет sf), чтобы визуализировать ближайшую к отдельным случаям медицинскую организацию.\n\nМы начинаем с построчного списка с шейп-файлом linelist_sf\n\nМы пространственно соединяем с помощью sle_hf, то есть с расположениями медицинских организаций и клиник (точки)\n\n\n# Ближайшая медицинская организация к каждому случаю\nlinelist_sf_hf &lt;- linelist_sf %&gt;%                  # начинаем с шейп-файла с построчным списком  \n  st_join(sle_hf, join = st_nearest_feature) %&gt;%   # данные о ближайшей клинике соединяются с данными о случаях \n  select(case_id, osm_id, name, amenity) %&gt;%       # сохраняем интересующие столбцы, включая id, имя, тип, а также геометрию, для медицинских организаций\n  rename(\"nearest_clinic\" = \"name\")                # переименовываем для ясности\n\nНиже мы можем увидеть (первые 50 строк), что у каждого случая теперь есть данные о ближайшей клинике/больнице\n\n\n\n\n\n\nМы можем увидеть, что клиника “Den Clinic” является ближайшей медицинской организацией примерно для ~30% случаев.\n\n# Подсчет случаев по медицинской организации\nhf_catchment &lt;- linelist_sf_hf %&gt;%   # начинаем с построчного списка, включая данные о ближайшей клинике\n  as.data.frame() %&gt;%                # конвертируем из шейп-файла в датафрейм\n  count(nearest_clinic,              # считаем строки по \"имени\" (клиники)\n        name = \"case_n\") %&gt;%         # присваиваем новому столбцу с подсчетом имя \"case_n\"\n  arrange(desc(case_n))              # сортируем в порядке уменьшения\n\nhf_catchment                         # выводим на консоль\n\n                         nearest_clinic case_n\n1                            Den Clinic    358\n2       Shriners Hospitals for Children    331\n3         GINER HALL COMMUNITY HOSPITAL    176\n4                             panasonic     51\n5 Princess Christian Maternity Hospital     35\n6                     ARAB EGYPT CLINIC     23\n7                  MABELL HEALTH CENTER     15\n8                                  &lt;NA&gt;     11\n\n\nЧтобы визуализировать результаты, мы можем использовать tmap - в этот раз в интерактивном режиме для облегчения просмотра\n\ntmap_mode(\"view\")   # устанавливаем режим tmap на интерактивный  \n\n# строим визуализацию случаев и точек клиник \ntm_shape(linelist_sf_hf) +            # визуализируем случаи\n  tm_dots(size=0.08,                  # случаи окрашены по ближайшей клинике\n          col='nearest_clinic') +    \ntm_shape(sle_hf) +                    # визуализируем медицинские организации большими черными точками\n  tm_dots(size=0.3, col='black', alpha = 0.4) +      \n  tm_text(\"name\") +                   # накладываем название организации\ntm_view(set.view = c(-13.2284, 8.4699, 13), # корректируем масштаб (центр координат, приближение)\n        set.zoom.limits = c(13,14))+\ntm_layout(title = \"Cases, colored by nearest clinic\")\n\n\n\n\n\n\n\nБуферные зоны\nМы также можем изучить, сколько случаев находятся на расстоянии 2.5 км (~30 минут) ходьбы от ближайшей медицинской организации.\nПримечание: Для более точных расчетов расстояний лучше перепроецировать объект sf в соответствующую местную систему картографических проекций, например UTM (Земля проецируется на плоскую поверхность). В данном примере для простоты мы будем придерживаться географической системы координат Всемирной геодезической системы (WGS84) (Земля представлена в виде сферической/круглой поверхности, поэтому единицы измерения - десятичные градусы). Мы будем использовать общее преобразование: 1 десятичный градус = ~111 км.\nСм. дополнительную информацию о проекциях карт и системах координат в этой статье esri. В этом блоге рассказывается о разных типах проекций карт и о том, как выбирать подходящую проекцию в зависимости от интересующего района и контекста вашей карты/анализа.\nСначала, создаем круговой буфер с радиусом ~2.5 км вокруг каждой медицинской организации. Это делается с помощью функции st_buffer() из tmap. Поскольку единица карты - десятичные градусы широты/долготы, так интерпретируется “0.02”. Если ваша система координат карты в метрах, надо задавать число в метрах.\n\nsle_hf_2k &lt;- sle_hf %&gt;%\n  st_buffer(dist=0.02)       # десятичные градусы, примерно соответствующие 2.5 км \n\nНиже мы строим сами буферные зоны следующим образом:\n\ntmap_mode(\"plot\")\n# создаем круговые буферы\ntm_shape(sle_hf_2k) +\n  tm_borders(col = \"black\", lwd = 2)+\ntm_shape(sle_hf) +                    # визуализируем медицинские организации большими красными точками\n  tm_dots(size=0.3, col='black')      \n\n\n\n\n\n\n\n\n**Во-вторых, мы ищем пересечение этих буферов со случаями (точками), используя st_join() с типом соединения st_intersects*. То есть данные о буферах присоединяются к точкам, с которыми они пересекаются.\n\n# пересечение случаев с буферами\nlinelist_sf_hf_2k &lt;- linelist_sf_hf %&gt;%\n  st_join(sle_hf_2k, join = st_intersects, left = TRUE) %&gt;%\n  filter(osm_id.x==osm_id.y | is.na(osm_id.y)) %&gt;%\n  select(case_id, osm_id.x, nearest_clinic, amenity.x, osm_id.y)\n\nТеперь мы можем посчитать результаты: nrow(linelist_sf_hf_2k[is.na(linelist_sf_hf_2k$osm_id.y),]) из 1000 случаев не пересекаются ни с одним буфером (это значение отсутствует), то есть живут дальше, чем 30 минут ходьбы от ближайшей медицинской организации.\n\n# Случаи, у которых нет пересечения с буферами медицинских организаций\nlinelist_sf_hf_2k %&gt;% \n  filter(is.na(osm_id.y)) %&gt;%\n  nrow()\n\n[1] 1000\n\n\nМы можем визуализировать результаты таким образом, чтобы случаи, не пересекающиеся с буфером, отражались красным.\n\ntmap_mode(\"view\")\n\n# Сначала отобразим случаи точками\ntm_shape(linelist_sf_hf) +\n  tm_dots(size=0.08, col='nearest_clinic') +\n\n# визуализируем медицинские организации большими черными точками\ntm_shape(sle_hf) +                    \n  tm_dots(size=0.3, col='black')+   \n\n# затем наложим буферы медицинских организаций полилиниями\ntm_shape(sle_hf_2k) +\n  tm_borders(col = \"black\", lwd = 2) +\n\n  # выделим случаи, которые не попали в буферы ни одной медицинской организации\n# красными точками  \ntm_shape(linelist_sf_hf_2k %&gt;%  filter(is.na(osm_id.y))) +\n  tm_dots(size=0.1, col='red') +\ntm_view(set.view = c(-13.2284,8.4699, 13), set.zoom.limits = c(13,14))+\n\n# добавим заголовок  \ntm_layout(title = \"Cases by clinic catchment area\")\n\n\n\n\n\n\n\nДругие пространственные соединения\nАльтернативные значения для аргумента join включают (из документации)\n\nst_contains_properly\n\nst_contains\n\nst_covered_by\n\nst_covers\n\nst_crosses\n\nst_disjoint\n\nst_equals_exact\n\nst_equals\n\nst_is_within_distance\n\nst_nearest_feature\n\nst_overlaps\n\nst_touches\n\nst_within",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Основы ГИС</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.ru.html#картограммы",
    "href": "new_pages/gis.ru.html#картограммы",
    "title": "28  Основы ГИС",
    "section": "28.7 Картограммы",
    "text": "28.7 Картограммы\nКартограммы могут быть полезны для визуализации данных по заранее определенным областям, обычно административным единицам или районам здравоохранения. Например, при реагировании на вспышки заболеваний это может помочь целенаправленно распределять ресурсы для конкретных районов с высоким уровнем заболеваемости.\nТеперь, когда у нас присвоены названия административных единиц для всех случаев (см. раздел пространственные соединения выше), мы можем начать составлять карту количества случаев по району (картограмму).\nПоскольку у нас также есть данные по населению для ADM3, мы можем добавить эту информацию к таблице case_adm3, созданной ранее.\nМы начинаем с датафрейма, созданного на предыдущем шаге case_adm3, который является суммарной таблицей каждой административной единицы и количества случаев в ней.\n\nДанные по населению sle_adm3_pop присоединяются, используя левое соединение left_join() из dplyr на основе общих значений по столбцу admin3pcod для датафрейма case_adm3 и столбца adm_pcode в датафрейме sle_adm3_pop. См. страницу [Соединение данных]).\n\nselect() применяется к новому датафрейму, чтобы сохранить только нужные столбцы - total - это общее население.\n\nСлучаи на 10,000 человек рассчитываются как новый столбец с помощью mutate()\n\n\n# добавляем данные по населению и рассчитываем количество случаев на 10 тысяч человек\ncase_adm3 &lt;- case_adm3 %&gt;% \n     left_join(sle_adm3_pop,                             # добавляем столбцы из набора данных по населению\n               by = c(\"admin3pcod\" = \"adm3_pcode\")) %&gt;%  # соединяем на основе общих значений по этим двум столбцам\n     select(names(case_adm3), total) %&gt;%                 # сохраняем только важные столбцы, включая общее население\n     mutate(case_10kpop = round(cases/total * 10000, 3)) # создаем новый столбец с коэффициентом случаев на 10000, с округлением до 3 знаков после запятой\n\ncase_adm3                                                # выподим на консоль для просмотра\n\n# A tibble: 10 × 5\n# Groups:   admin3pcod [10]\n   admin3pcod admin3name     cases  total case_10kpop\n   &lt;chr&gt;      &lt;chr&gt;          &lt;int&gt;  &lt;int&gt;       &lt;dbl&gt;\n 1 SL040102   Mountain Rural   274  33993       80.6 \n 2 SL040208   West III         225 210252       10.7 \n 3 SL040207   West II          188 145109       13.0 \n 4 SL040204   East II          111  99821       11.1 \n 5 SL040203   East I            60  68284        8.79\n 6 SL040201   Central I         51  69683        7.32\n 7 SL040206   West I            45  60186        7.48\n 8 SL040205   East III          23 500134        0.46\n 9 SL040202   Central II        18  23874        7.54\n10 &lt;NA&gt;       &lt;NA&gt;               5     NA       NA   \n\n\nСоединяем эту таблицу с шейп-файлом полигонов ADM3 для картирования\n\ncase_adm3_sf &lt;- case_adm3 %&gt;%                 # начинаем со случаев и коэффициента по административной единице\n  left_join(sle_adm3, by=\"admin3pcod\") %&gt;%    # соединяем с данными шейп-файла по общему столбцу\n  select(objectid, admin3pcod,                # сохраняем только некоторые интересующие столбцы\n         admin3name = admin3name.x,           # вычищаем имя одного столбца\n         admin2name, admin1name,\n         cases, total, case_10kpop,\n         geometry) %&gt;%                        # сохраняем геометрию, чтобы можно было визуализировать полигоны\n  drop_na(objectid) %&gt;%                       # удаляем пустые строки\n  st_as_sf()                                  # конвертируем в шейп-файл\n\nСоставляем карту результатов\n\n# режим tmap\ntmap_mode(\"plot\")               # просмотр статической карты\n\n# plot polygons\ntm_shape(case_adm3_sf) + \n        tm_polygons(\"cases\") +  # цвет по столбцу количества случаев\n        tm_text(\"admin3name\")   # отображаем имя\n\n\n\n\n\n\n\n\nМы также можем составить карту коэффициента заболеваемости\n\n# Случаи на 10 тысяч человек\ntmap_mode(\"plot\")             # режим статического просмотра\n\n# plot\ntm_shape(case_adm3_sf) +                # визуализируем полигоны\n  tm_polygons(\"case_10kpop\",            # цвет по столбцу, содержащему коэффициент случаев\n              breaks=c(0, 10, 50, 100), # определяем точки перехода для цветов\n              palette = \"Purples\"       # используем фиолетовую цветовую палитру\n              ) +\n  tm_text(\"admin3name\")                 # отображаем текст",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Основы ГИС</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.ru.html#составление-карт-с-помощью-ggplot2",
    "href": "new_pages/gis.ru.html#составление-карт-с-помощью-ggplot2",
    "title": "28  Основы ГИС",
    "section": "28.8 Составление карт с помощью ggplot2",
    "text": "28.8 Составление карт с помощью ggplot2\nЕсли вы уже знакомы с применением ggplot2, вы можете использовать этот пакет для создания статических карт ваших данных. Функция geom_sf() нарисует разные объекты на основе того, какие свойства (точки, линии, полигоны) есть в ваших данных. Например, вы можете использовать geom_sf() в ggplot(), используя данные sf с геометрией полигонов для создания картограммы.\nЧтобы иллюстрировать как это работает, мы можем начать с шейп-файла полигонов ADM3, который мы использовали ранее. Вспомните, что это регионы уровня Admin 3 в Сьерра-Леоне:\n\nsle_adm3\n\nSimple feature collection with 12 features and 19 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -13.29894 ymin: 8.094272 xmax: -12.91333 ymax: 8.499809\nGeodetic CRS:  WGS 84\n# A tibble: 12 × 20\n   objectid admin3name   admin3pcod admin3ref_n admin2name admin2pcod admin1name\n *    &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;     \n 1      155 Koya Rural   SL040101   Koya Rural  Western A… SL0401     Western   \n 2      156 Mountain Ru… SL040102   Mountain R… Western A… SL0401     Western   \n 3      157 Waterloo Ru… SL040103   Waterloo R… Western A… SL0401     Western   \n 4      158 York Rural   SL040104   York Rural  Western A… SL0401     Western   \n 5      159 Central I    SL040201   Central I   Western A… SL0402     Western   \n 6      160 East I       SL040203   East I      Western A… SL0402     Western   \n 7      161 East II      SL040204   East II     Western A… SL0402     Western   \n 8      162 Central II   SL040202   Central II  Western A… SL0402     Western   \n 9      163 West III     SL040208   West III    Western A… SL0402     Western   \n10      164 West I       SL040206   West I      Western A… SL0402     Western   \n11      165 West II      SL040207   West II     Western A… SL0402     Western   \n12      167 East III     SL040205   East III    Western A… SL0402     Western   \n# ℹ 13 more variables: admin1pcod &lt;chr&gt;, admin0name &lt;chr&gt;, admin0pcod &lt;chr&gt;,\n#   date &lt;date&gt;, valid_on &lt;date&gt;, valid_to &lt;date&gt;, shape_leng &lt;dbl&gt;,\n#   shape_area &lt;dbl&gt;, rowcacode0 &lt;chr&gt;, rowcacode1 &lt;chr&gt;, rowcacode2 &lt;chr&gt;,\n#   rowcacode3 &lt;chr&gt;, geometry &lt;MULTIPOLYGON [°]&gt;\n\n\nМы можем использовать функцию left_join() из dplyr, чтобы добавить данные, которые мы хотели бы отразить на карте, к объекту шейп-файла. В данном случае мы будем использовать датафрейм case_adm3, который мы создали ранее, для обобщения количества случаев по административному региону; однако, мы можем использовать тот же подход, чтобы составить карту любых данных, сохраненных в датафрейме.\n\nsle_adm3_dat &lt;- sle_adm3 %&gt;% \n  inner_join(case_adm3, by = \"admin3pcod\") # внутреннее соединение = сохранить только если присутствует в обоих объектах данных\n\nselect(sle_adm3_dat, admin3name.x, cases) # выводим выбранные переменные на консоль\n\nSimple feature collection with 9 features and 2 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -13.29894 ymin: 8.384533 xmax: -13.12612 ymax: 8.499809\nGeodetic CRS:  WGS 84\n# A tibble: 9 × 3\n  admin3name.x   cases                                                  geometry\n  &lt;chr&gt;          &lt;int&gt;                                        &lt;MULTIPOLYGON [°]&gt;\n1 Mountain Rural   274 (((-13.21496 8.474341, -13.21479 8.474289, -13.21465 8.4…\n2 Central I         51 (((-13.22646 8.489716, -13.22648 8.48955, -13.22644 8.48…\n3 East I            60 (((-13.2129 8.494033, -13.21076 8.494026, -13.21013 8.49…\n4 East II          111 (((-13.22653 8.491883, -13.22647 8.491853, -13.22642 8.4…\n5 Central II        18 (((-13.23154 8.491768, -13.23141 8.491566, -13.23144 8.4…\n6 West III         225 (((-13.28529 8.497354, -13.28456 8.496497, -13.28403 8.4…\n7 West I            45 (((-13.24677 8.493453, -13.24669 8.493285, -13.2464 8.49…\n8 West II          188 (((-13.25698 8.485518, -13.25685 8.485501, -13.25668 8.4…\n9 East III          23 (((-13.20465 8.485758, -13.20461 8.485698, -13.20449 8.4…\n\n\nЧтобы создать столбчатую диаграмму количества случаев по регионам с помощью ggplot2, мы можем использовать geom_col() следующим образом:\n\nggplot(data=sle_adm3_dat) +\n  geom_col(aes(x=fct_reorder(admin3name.x, cases, .desc=T),   # меняем порядок на оси x по уменьшению количества случаев ('cases')\n               y=cases)) +                                  # ось y - количествос лучаев по региону\n  theme_bw() +\n  labs(                                                     # задаем текст рисунка\n    title=\"Number of cases, by administrative unit\",\n    x=\"Admin level 3\",\n    y=\"Number of cases\"\n  ) + \n  guides(x=guide_axis(angle=45))                            # подписи на оси x под углом 45 градусов, чтобы они вошли\n\n\n\n\n\n\n\n\nЕсли мы хотим использовать ggplot2 для создания картограммы количества случаев, мы используем синтаксис, похожий на функцию geom_sf():\n\nggplot(data=sle_adm3_dat) + \n  geom_sf(aes(fill=cases))    # устанавливаем заливку с изменением в зависимости от переменной количества случаев\n\n\n\n\n\n\n\n\nЗатем мы можем индивидуализировать отображение нашей карты, используя грамматику, которая применяется единообразно в ggplot2, например:\n\nggplot(data=sle_adm3_dat) +                           \n  geom_sf(aes(fill=cases)) +                        \n  scale_fill_continuous(high=\"#54278f\", low=\"#f2f0f7\") +    # изменяем градиент цветов\n  theme_bw() +\n  labs(title = \"Number of cases, by administrative unit\",   # задаем текст рисунка\n       subtitle = \"Admin level 3\"\n  )\n\n\n\n\n\n\n\n\nДля пользователй R, которые комфортно себя чувствуют при работе с ggplot2, geom_sf() предлагает простую и прямую реализацию, которая подходит для визуализации базовых карт. Чтобы узнать детали, прочитайте виньетку по geom_sf() или учебник по ggplot2.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Основы ГИС</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.ru.html#карты-основы",
    "href": "new_pages/gis.ru.html#карты-основы",
    "title": "28  Основы ГИС",
    "section": "28.9 Карты-основы",
    "text": "28.9 Карты-основы\n\nOpenStreetMap\nНиже мы опишем, как получить карту-основу для карты ggplot2, используя характеристики OpenStreetMap. Альтернативные методы включают использование ggmap, который требует бесплатной регистрации в Google (детали).\nOpenStreetMap - это совместный проект по созданию бесплатной редактируемой карты мира. Основным результатом проекта являются геолокационные данные (например, расположение городов, дорог, природных объектов, аэропортов, школ, больниц, дорог и т.д.).\nСначала мы загрузим пакет OpenStreetMap, из которого мы получим карту-основу.\nЗатем мы создаем объект map, который мы определяем, используя функцию openmap() из пакета OpenStreetMap (документация). Мы указываем следующее:\n\nupperLeft и lowerRight Две пары координат, уточняющие пределы плитки карты-основы\n\nВ данном случае мы указываем максимум и минимум из строк построчного списка, чтобы карта динамически реагировала на данные\n\n\nzoom = (если не задано, то определяется автоматически)\n\ntype = какой тип карты-основы - мы указали тут ряд возможностей и код сейчас использует первую ([1]) “osm”\n\nmergeTiles = мы выбираем TRUE (ИСТИНА), чтобы плитки карты-основы были объединены в одну\n\n\n# загружаем пакет\npacman::p_load(OpenStreetMap)\n\n# Строим карту-основу по диапазону координат долготы/широты. Выбираем тип плиток\nmap &lt;- OpenStreetMap::openmap(\n  upperLeft = c(max(linelist$lat, na.rm=T), max(linelist$lon, na.rm=T)),   # пределы плитки карты-основы\n  lowerRight = c(min(linelist$lat, na.rm=T), min(linelist$lon, na.rm=T)),\n  zoom = NULL,\n  type = c(\"osm\", \"stamen-toner\", \"stamen-terrain\", \"stamen-watercolor\", \"esri\",\"esri-topo\")[1])\n\nЕсли мы визуализируем сейчас эту карту-основу, используя autoplot.OpenStreetMap() из пакета OpenStreetMap, вы увидите, что единицы на осях не являются координатами широты/долготы. Используется другая система координат. Чтобы правильно отобразить места проживания случаев (которые отражены в виде широты/долготы), это нужно изменить.\n\nautoplot.OpenStreetMap(map)\n\n\n\n\n\n\n\n\nТаким образом, нам нужно конвертировать карту в широту/долготу с помощью функции openproj() из пакета OpenStreetMap. Мы задаем карту-основу map и также задаем Референсную систему координат (РСК), которая нам нужна. Мы это делаем с помощью текстовой последовательности “proj.4” для проекции WGS 1984, но вы можете задать РСК и другими способами. (см. эту страницу, чтобы понять, что такое последовательность proj.4)\n\n# Проекция WGS84\nmap_latlon &lt;- openproj(map, projection = \"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs\")\n\nТеперь, когда мы создаем график, мы видим на осях координаты широты и долготы. Система координат была конвертирована. Теперь случаи будут наложены верно!\n\n# Строим карту. Необходимо использовать \"autoplot\", чтобы работать с ggplot\nautoplot.OpenStreetMap(map_latlon)\n\n\n\n\n\n\n\n\nСм. дополнительную информацию в самоучителях тут и тут.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Основы ГИС</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.ru.html#контурные-карты-плотности",
    "href": "new_pages/gis.ru.html#контурные-карты-плотности",
    "title": "28  Основы ГИС",
    "section": "28.10 Контурные карты плотности",
    "text": "28.10 Контурные карты плотности\nНиже мы описываем, как получить конторную карту плотности поверх карты-основы, начиная с построчного списка (по одной строке на случай).\n\nСоздаем плитку карты-основы из OpenStreetMap, как описано выше\n\nВизуализируем случаи из linelist, используя столбцы широты и долготы\n\nКонвертируем точки в тепловую карту плотности с помощью stat_density_2d() из ggplot2,\n\nКогда у нас имеется карта-основа с координатами широты/долготы, мы можем отразить сверху нее случая, используя координаты широты/долготы их места проживания.\nНа основе функции autoplot.OpenStreetMap() для создания карты-основы, функции ggplot2 будут наложены сверху, как это сделано с помощью geom_point() ниже:\n\n# Строим карту. Необходимо использовать autoplot, чтобы работать с ggplot\nautoplot.OpenStreetMap(map_latlon)+                 # начинаем с карты-основы\n  geom_point(                                       # aдобавляем точки xy из столбцов широты и долготы построчного списка \n    data = linelist,                                \n    aes(x = lon, y = lat),\n    size = 1, \n    alpha = 0.5,\n    show.legend = FALSE) +                          # полностью убираем легенду\n  labs(x = \"Longitude\",                             # заголовки и подписи\n       y = \"Latitude\",\n       title = \"Cumulative cases\")\n\n\n\n\n\n\n\n\nКарту, созданную выше, может быть сложно интерпретировать, особенно учитывая наложение точек друг на друга. Поэтому вы можете вместо этого создать 2d карту плотности, используя функцию ggplot2 stat_density_2d(). Вы все еще используете координаты широты/долготы из построчного списка, но проводится 2D ядерная оценка плотности и результаты отображаются в виде линий контура - как на топографической карте. Прочитайте полную документацию тут.\n\n# начинаем с карты-основы\nautoplot.OpenStreetMap(map_latlon)+\n  \n  # добавляем график плотности\n  ggplot2::stat_density_2d(\n        data = linelist,\n        aes(\n          x = lon,\n          y = lat,\n          fill = ..level..,\n          alpha = ..level..),\n        bins = 10,\n        geom = \"polygon\",\n        contour_var = \"count\",\n        show.legend = F) +                          \n  \n  # уточняем цветовую шкалу\n  scale_fill_gradient(low = \"black\", high = \"red\")+\n  \n  # подписи \n  labs(x = \"Longitude\",\n       y = \"Latitude\",\n       title = \"Distribution of cumulative cases\")\n\n\n\n\n\n\n\n\n\n\nТепловая карта временных рядов\nТепловая карта плотности выше показывает кумулятивное количество случаев. Мы можем рассмотреть вспышку во времени и пространстве с помощью фасетов тепловой карты на основе месяца возникновения симптомов, который мы можем получить из построчного списка.\nМы начинаем с linelist, создаем новый столбец с годом и месяцм возникновения симптомов. Функция format() из базового R меняет отображение даты. В этом случае нам нужно “ГГГГ-ММ”.\n\n# извлекаем месяц возникновения симптомов\nlinelist &lt;- linelist %&gt;% \n  mutate(date_onset_ym = format(date_onset, \"%Y-%m\"))\n\n# Изучаем значения \ntable(linelist$date_onset_ym, useNA = \"always\")\n\n\n2014-05 2014-06 2014-07 2014-08 2014-09 2014-10 2014-11 2014-12 2015-01 2015-02 \n      8      13      42      97     191     177     122     100      73      52 \n2015-03 2015-04    &lt;NA&gt; \n     58      25      42 \n\n\nТеперь мы просто добавим фасеты с помощью ggplot2 на тепловую карту плотности. Применяем facet_wrap(), используя новый столбец как строки. Мы задаем количество столбцов фасета как 3 для ясности.\n\n# пакеты\npacman::p_load(OpenStreetMap, tidyverse)\n\n# начинаем с карты-основы\nautoplot.OpenStreetMap(map_latlon)+\n  \n  # добавляем график плотности\n  ggplot2::stat_density_2d(\n        data = linelist,\n        aes(\n          x = lon,\n          y = lat,\n          fill = ..level..,\n          alpha = ..level..),\n        bins = 10,\n        geom = \"polygon\",\n        contour_var = \"count\",\n        show.legend = F) +                          \n  \n  # уточняем цветовую шкалу\n  scale_fill_gradient(low = \"black\", high = \"red\")+\n  \n  # подписи \n  labs(x = \"Longitude\",\n       y = \"Latitude\",\n       title = \"Distribution of cumulative cases over time\")+\n  \n  # фасеты по месяцу-году возникновения симптомов\n  facet_wrap(~ date_onset_ym, ncol = 4)",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Основы ГИС</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.ru.html#пространственная-статистика",
    "href": "new_pages/gis.ru.html#пространственная-статистика",
    "title": "28  Основы ГИС",
    "section": "28.11 Пространственная статистика",
    "text": "28.11 Пространственная статистика\nНаша дискуссия в основном до сих пор фокусировалась на визуализации пространственных данных. В некоторых случаях вас также может интересовать пространственная статистика для количественного отражения пространственных отношений характеристик ваших данных. В этом разделе мы сделаем краткий обзор ключевых концепций в пространственной статистике и порекомендуем некоторые ресурсы, которые могут быть полезны для изучения, если вам нужен более подробный пространственный анализ.\n\nПространственные отношения\nПрежде чем мы сможем рассчитать пространственную статистику, нам нужно уточнить отношения между характеристиками наших данных. Существует много способов концептуализации пространственных отношений, но простой и часто применяемой моделью является Смежность - в частности, что мы ожидаем географические связи между зонами, имеющими общую границу или “соседствующими” друг с другом.\nМы можем количественно выразить отношения смежности между полигонами административных регионов в данных sle_adm3, которые мы использовали, с помощью пакета spdep. Мы уточним смежность ферзя, который означает, что регионы будут соседями, если они имеют как минимум одну общую точку на своих границах. Альтернативой будет смежность ладьи, которая требует, чтобы регионы имели совместную грань - в нашем случаи при полигонах неправильной формы различия не так важны, но в некоторых случаях выбор ферзя или ладьи может иметь большое значение.\n\nsle_nb &lt;- spdep::poly2nb(sle_adm3_dat, queen=T) # создаем соседей \nsle_adjmat &lt;- spdep::nb2mat(sle_nb)    # создаем матрицу, обобщающую отношения соседства\nsle_listw &lt;- spdep::nb2listw(sle_nb)   # создаем объект listw (список весов) -- нам он потребуется позже\n\nsle_nb\n\nNeighbour list object:\nNumber of regions: 9 \nNumber of nonzero links: 30 \nPercentage nonzero weights: 37.03704 \nAverage number of links: 3.333333 \n\nround(sle_adjmat, digits = 2)\n\n  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n1 0.00 0.20 0.00 0.20 0.00  0.2 0.00 0.20 0.20\n2 0.25 0.00 0.00 0.25 0.25  0.0 0.00 0.25 0.00\n3 0.00 0.00 0.00 0.50 0.00  0.0 0.00 0.00 0.50\n4 0.25 0.25 0.25 0.00 0.00  0.0 0.00 0.00 0.25\n5 0.00 0.33 0.00 0.00 0.00  0.0 0.33 0.33 0.00\n6 0.50 0.00 0.00 0.00 0.00  0.0 0.00 0.50 0.00\n7 0.00 0.00 0.00 0.00 0.50  0.0 0.00 0.50 0.00\n8 0.20 0.20 0.00 0.00 0.20  0.2 0.20 0.00 0.00\n9 0.33 0.00 0.33 0.33 0.00  0.0 0.00 0.00 0.00\nattr(,\"call\")\nspdep::nb2mat(neighbours = sle_nb)\n\n\nНапечатанная выше матрица показывает отношения между 9 регионами в наших данных sle_adm3. Балл 0 указывает, что два региона не являются соседями, а любое значение больше 0 указывает на отношение соседства. Значения в матрице значения в матрице шкалируются таким образом, чтобы каждый регион имел суммарный вес строки, равный 1.\nA better way to visualize these neighbor relationships is by plotting them:\n\nplot(sle_adm3_dat$geometry) +                                           # строим границы региона\n  spdep::plot.nb(sle_nb,as(sle_adm3_dat, 'Spatial'), col='grey', add=T) # добавляем отношения соседства\n\n\n\n\n\n\n\n\nМы использовали подход смежности, чтобы определить соседние полигоны; были определены соседи, которых также иногда называют соседи на основе смежности. Но это лишь один из способов выбора того, у каких регионов мы ожидаем наличия географических отношений. Одним из частых альтернативных подходов опредлеения географических отношений является соседство на основе расстояния; вкратце, это:\n\nK-ближайшие соседи - основан на расстоянии между центроидами (географически взвешенным центром каждого региона полигона), выбирает n ближайших регионов в качестве соседей. Можно также задать порог максимального расстояния. В spdep вы можете использовать knearneigh() (см. документацию).\nСоседи по пороговому расстоянию - выбирает всех соседей в пределах порога расстояния. В spdep такие отношения соседства можно определить с помощью dnearneigh() (см. документацию).\n\n\n\nПространственная автокорреляция\nЧасто цитируемый первый закон географии Тоблера гласит: “Все связано со всем остальным, но близкие вещи связаны между собой сильнее, чем далекие”. В эпидемиологии это часто означает, что риск определенного исхода для здоровья в данном регионе более схож с соседними регионами, чем с отдаленными. Эта концепция была закреплена как пространственная автокорреляция - статистическое свойство того, что географические объекты с одинаковыми значениями группируются в пространстве. Статистическая мера пространственной автокорреляции может быть использована для количественного выражения степени пространственной кластеризации ваших данных, поиска мест возникновения кластеров и определения общих закономерностей пространственной автокорреляции между разными переменными в ваших данных. В этом разделе мы сделаем обзор некоторых частых мер пространственной автокорреляции и того, как рассчитать их в R.\nI Морана - Это глобальная суммарная статистика корреляции между значением переменной в одном регионе и значениями той же переменной в соседних регионах. Обычно значение статистики I Морана находится в диапазоне от -1 до 1. Значение 0 указывает на отсутствие пространственной корреляции, в то время как значения, близкие к 1 или -1, свидетельствуют о более сильной пространственной автокорреляции (схожие значения близки друг к другу) или пространственной дисперсии (несхожие значения близки друг к другу) соответственно.\nНапример, мы рассчитаем статистику I Морана, чтобы количественно определить пространственную автокорреляцию случаев Эболы, карту которых мы составляли ранее (помните, что это подмножество случаев из датафрейма с имитированной эпидемией Эболы linelist). В пакете spdep есть функция moran.test, которая может сделать этот расчет для нас:\n\nmoran_i &lt;-spdep::moran.test(sle_adm3_dat$cases,    # числовой вектор с интересующей переменной\n                            listw=sle_listw)       # объект listw, обобщащий отношения соседства\n\nmoran_i                                            # печать результатов теста I Морана\n\n\n    Moran I test under randomisation\n\ndata:  sle_adm3_dat$cases  \nweights: sle_listw    \n\nMoran I statistic standard deviate = 1.5586, p-value = 0.05954\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n       0.20480506       -0.12500000        0.04477538 \n\n\nРезультат функции moran.test() показывает нам статистику I Морана round(moran_i$estimate[1],2). Это указывает на наличие пространственной автокорреляции в наших данных - в частности, что регионы со схожим количеством случаев Эболы, вероятно, находятся рядом друг с другом. Значение p, представленное moran.test(), генерируется путем сравнения ожидания при нулевой гипотезе отсутствия пространственной автокорреляции, и может быть использовано, если вам нужно сообщить результаты формального тестирования гипотезы.\nЛокальный I Морана - Мы можем разложить (глобальную) статистику I Морана, рассчитанную выше, чтобы определить локализованную пространственную автокорреляцию; то есть, чтобы определить конкретные кластеры данных. Эта статистика, которую иногда называют Локальным индикатором пространственной связи (LISA), обобщает степень пространственной автокорреляции вокруг каждого индивидуального региона. Она может быть полезна для выявления “горячих” и “холодных” точек на карте.\nЧтобы показать пример, мы можем рассчитать и отразить на карте Локальный I Морана для количества случаев Эбола, используемых выше, с помощью функции local_moran() из spdep:\n\n# рассчитываем локальный I Морана\nlocal_moran &lt;- spdep::localmoran(                  \n  sle_adm3_dat$cases,                              # интересующая переменная\n  listw=sle_listw                                  # объект listw с весами для соседей\n)\n\n# соединяем результаты с данными sf\nsle_adm3_dat&lt;- cbind(sle_adm3_dat, local_moran)    \n\n# строим карту\nggplot(data=sle_adm3_dat) +\n  geom_sf(aes(fill=Ii)) +\n  theme_bw() +\n  scale_fill_gradient2(low=\"#2c7bb6\", mid=\"#ffffbf\", high=\"#d7191c\",\n                       name=\"Local Moran's I\") +\n  labs(title=\"Local Moran's I statistic for Ebola cases\",\n       subtitle=\"Admin level 3 regions, Sierra Leone\")\n\n\n\n\n\n\n\n\nGetis-Ord Gi* - Еще одна статистика, которая часть используется для анализа очагов; во многом популярность этой статистики связана с ее использованием в инструменте анализа очагов (Hot Spot Analysis tool) в ArcGIS. Она основана на допущении о том, что, как правило, разница в значении переменной между соседними регионами должна следовать нормальному распределению. Она использует подход балла z-score для определения регионов, в которых значения указанной переменной значительно выше (горячие точки) или значительно ниже (холодные точки) по сравнению с соседями.\nМы можем рассчитать и построить карту статистики Gi* с помощью функции localG() из spdep:\n\n# Проводим локальный G анализ\ngetis_ord &lt;- spdep::localG(\n  sle_adm3_dat$cases,\n  sle_listw\n)\n\n# соединяем результаты с данными sf\nsle_adm3_dat$getis_ord &lt;- as.numeric(getis_ord)\n\n# строим карту\nggplot(data=sle_adm3_dat) +\n  geom_sf(aes(fill=getis_ord)) +\n  theme_bw() +\n  scale_fill_gradient2(low=\"#2c7bb6\", mid=\"#ffffbf\", high=\"#d7191c\",\n                       name=\"Gi*\") +\n  labs(title=\"Getis-Ord Gi* statistic for Ebola cases\",\n       subtitle=\"Admin level 3 regions, Sierra Leone\")\n\n\n\n\n\n\n\n\nКак видите, карта Getis-Ord Gi* выглядит несколько иначе, чем карта локального I Морана, которую я построил ранее. Это связано с тем, что методы расчета этих двух статистик несколько отличаются друг от друга; какой из них использовать, зависит от конкретного случая использования и интересующего вас вопроса исследования.\nL-тест Ли - Это статистический тест на бивариационную пространственную корреляцию. Он позволяет проверить, насколько пространственный паттерн для данной переменной x похож на пространственный паттерн другой переменной, y, которая, согласно гипотезе, пространственно связана с x.\nВ качестве примера проверим, коррелирует ли пространственная структура случаев заболевания лихорадкой Эбола, полученная в результате имитации эпидемии, с пространственной структурой численности населения. Для начала нам нужна переменная population (население) в данных sle_adm3. Мы можем использовать переменную total (итого) из датафрейма sle_adm3_pop, который мы загрузили ранее.\n\nsle_adm3_dat &lt;- sle_adm3_dat %&gt;% \n  rename(population = total)                          # переименуйте 'total' в 'population'\n\nМы можем быстро визуализировать пространственные закономерности двух переменных друг рядом с другом, чтобы посмотреть, похожи ли они:\n\ntmap_mode(\"plot\")\n\ncases_map &lt;- tm_shape(sle_adm3_dat) + tm_polygons(\"cases\") + tm_layout(main.title=\"Cases\")\npop_map &lt;- tm_shape(sle_adm3_dat) + tm_polygons(\"population\") + tm_layout(main.title=\"Population\")\n\ntmap_arrange(cases_map, pop_map, ncol=2)   # упорядочиваем по фасетам 2x1\n\n\n\n\n\n\n\n\nВизуально закономерности кажутся непохожими. Мы можем использовать функцию lee.test() из spdep, чтобы статистически протестировать, связаны ли закономерности пространственной автокорреляции в двух переменных. Статистика L будет близка к 0, если нет корреляции между закономерностями, и близка к 1, если есть сильная положительная корреляция (т.е. закономерности схожи), и близка к -1, если есть сильная отрицательная корреляция (т.е. закономерности противоположны).\n\nlee_test &lt;- spdep::lee.test(\n  x=sle_adm3_dat$cases,          # переменная 1 для сравнения\n  y=sle_adm3_dat$population,     # переменная 2 для сравнения\n  listw=sle_listw                # объект listw с весами соседей\n)\n\nlee_test\n\n\n    Lee's L statistic randomisation\n\ndata:  sle_adm3_dat$cases ,  sle_adm3_dat$population \nweights: sle_listw  \n\nLee's L statistic standard deviate = -0.978, p-value = 0.836\nalternative hypothesis: greater\nsample estimates:\nLee's L statistic       Expectation          Variance \n      -0.14660305       -0.03795658        0.01234121 \n\n\nВыходной результат выше показывает, что статистика L Ли по нашим двум переменным была round(lee_test$estimate[1],2), что указывает на слабую отрицательную корреляцию. Это подтверждает нашу визуальную оценку того, что закономерности по случаям и населению не связаны друг с другом, и предоставляет доказательства того, что пространственная закономерность случаев строго не является результатом плотности населения в районах высокого риска.\nL-статистика Ли может быть полезной для подобного рода выводов об отношениях между пространственно распределенными переменными; однако для описания природы связи между двумя переменными более детальным образом, либо для корректирования фактора смешивания, потребуются приемы пространственной регрессии. Мы их кратко описываем в следующем разделе.\n\n\nПространственная регрессия\nВозможно, вы захотите сделать статистические выводы о взаимосвязях между переменными в ваших пространственных данных. В таких случаях полезно рассмотреть приемы пространственной регрессии - то есть подходы к регрессии, явно учитывающие пространственную организацию единиц в ваших данных. Некоторые причины, по которым вам может потребоваться рассмотреть пространственные регрессионные модели вместо стандартных регрессионных моделей, таких как обобщенные линейные модели, включают следующие:\n\nСтандартные модели регрессии предполагают, что остатки независимы друг от друга. При наличии сильной пространственной автокорреляции, остатки стандартной регрессионной модели, скорее всего, также будут пространственно автокоррелированы, что нарушает данное предположение. Это может привести к проблемам с интерпретацией результатов моделирования, и в этом случае предпочтительнее использовать пространственную модель.\nВ регрессионных моделях также обычно предполагается, что эффект переменной x постоянен для всех наблюдений. В случае пространственной неоднородности, эффекты, которые мы хотим оценить, могут различаться в пространстве, и мы можем быть заинтересованы в количественной оценке этих различий. В этом случае модели пространственной регрессии обеспечивают большую гибкость при оценке и интерпретации эффектов.\n\nПодробное рассмотрение подходов к пространственной регрессии выходит за рамки данного руководства. Вместо этого в данном разделе будет представлен обзор наиболее распространенных моделей пространственной регрессии и их применения, а также даны ссылки на источники, которые могут оказаться полезными при дальнейшем изучении этой области.\nМодели пространственной ошибки - В этих моделях предполагается, что условия ошибки между пространственными единицами коррелированы, и в этом случае данные будут нарушать предположения стандартной модели наименьших квадратов. Модели пространственных ошибок также иногда называют одновременными авторегрессионными моделями (SAR). Их можно построить с помощью функции errorsarlm() из пакета spatialreg (функции пространственной регрессии, которые раньше входили в spdep).\nМодели пространственного лага - Эти модели предполагают, что на зависимую переменную для региона i влияет не только значение независимой переменной в i, но и значения этих переменных в регионах по соседству с i. Как и в моделях пространственной ошибки, модели пространственного лага иногда описывают как одновременные авторегрессионные модели (SAR). Их можно построить с помощью функции lagsarlm() из пакета spatialreg.\nПакет spdep содержит несколько полезных диагностических тестов для выбора метода наименьших квадратов, модели пространственного лага или модели пространственной ошибки. Эти тесты, называемые Диагностика методом множителей Лагранжа, могут быть использованы для определения типа пространственной зависимости в ваших данных и выбора наиболее подходящей модели. Функция lm.LMtests() может быть использована для рассчета всех тестов по методу множителей Лагранжа. Анселин (1988) также создал полезную блок-схему для принятия решения о том, какую модель пространственной регрессии использовать, исходя из результатов теста по методу множителей Лагранжа:\n\n\n\n\n\n\n\n\n\nБайесовские иерархические модели - Байсовские подходы часто применяются для некоторых приложений пространственного анализа, чаще всего для картирования заболеваний. Они также являются предпочтительными в случаях, когда у данных по случаям низкая концентрация (например, при редком исходе), либо много статистического “шума”, так как они могут использоваться для создания “сглаженных” оценок риска заболеваний, принимая во внимание базовый латентный пространственный процесс. Это может улучшить качество оценок. Они также позволяют исследователю предварительно уточнить (через выбор априорной величины) сложные закономерности пространственной автокорреляции, которые могут существовать в данных, которые могут учитывать и пространственно-зависимые, и пространственно-независимые колебания как в независимой, так и зависимой переменной. В R Байесовские иерархические модели можно построить, используя пакет CARbayes (см. виньетка) или R-INLA (см. веб-сайт и учебник). R можно также использовать для запроса во внешнюю программу для Байесовской оценки, такую как JAGS или WinBUGS.",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Основы ГИС</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.ru.html#ресурсы",
    "href": "new_pages/gis.ru.html#ресурсы",
    "title": "28  Основы ГИС",
    "section": "28.12 Ресурсы",
    "text": "28.12 Ресурсы\n\nПростые свойства (Simple Features) R и пакет sf виньетка\nПакет R tmap виньетка\nggmap: Пространственная визуализация с помощью ggplot2\nВведение в создание карт с R, обзор разных пакетов\nПространственные данные в R (курс EarthLab)\nПрикладной анализ пространственных данных в R учебник\nSpatialEpiApp - приложение Shiny, которое можно скачать как пакет R, которое позволяет вам задавать собственные данные и делать картирование, анализ кластеров и пространственную статистику.\nВведение в пространственную эконометрику в R семинар",
    "crumbs": [
      "Анализ",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Основы ГИС</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.ru.html",
    "href": "new_pages/tables_presentation.ru.html",
    "title": "29  Таблицы для презентации",
    "section": "",
    "text": "29.1 Подготовка",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Таблицы для презентации</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.ru.html#подготовка",
    "href": "new_pages/tables_presentation.ru.html#подготовка",
    "title": "29  Таблицы для презентации",
    "section": "",
    "text": "Загрузка пакетов\nУстановите и загрузите пакет flextable. В данном руководстве мы делаем акцент на p_load() из пакета pacman, которая при необходимости устанавливает пакет и загружает его для использования. Также можно загружать пакеты с помощью library() из base R. Более подробную информацию о пакетах R см. на странице Основы R.\n\npacman::p_load(\n  rio,            # импорт/экспорт\n  here,           # путь к файлу\n  flextable,      # создать таблицу HTML \n  officer,        # функция помощника для таблиц\n  tidyverse)      # управление данными, выводы и визуализация\n\n\n\nИмпорт данных\nДля начала мы импортируем очищенный построчный список случаев из смоделированной эпидемии лихорадки Эбола. Если вы хотите проследить за ходом работы, щелкните мышью, чтобы загрузить “чистый” построчный список  (в виде файла .rds). Импорт данных с помощью функции import() из пакета rio (она работает со многими типами файлов, такими как .xlsx, .csv, .rds - подробнее см. на странице Импорт и экспорт).\n\n# импорт построчного списка \nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nПервые 50 строк построчного списка отображаются ниже.\n\n\n\n\n\n\n\n\nПодготовка таблицы\nНиже приведен пример из страницы Описательные таблицы преобразования построчного списка случаев в датафрейм, содержащий сводные данные об исходах и значениях CT по больницам, со строкой “Итого” в нижней части. Результат сохраняется в формате table.\nПеред началом использования пакетаflextable необходимо создать таблицу в виде блока данных. О том, как создать датафрейм с помощью таких пакетов, как janitor и dplyr, читайте на страницах [Описательные таблицы] и [Поворот данных]. Вы должны расположить содержимое в строках и столбцах так, как вы хотите его отобразить. Затем датафрейм будет передан в flextable для его отображения с использованием цветов, заголовков, шрифтов и т.д.\nНиже приведен пример из страницы Описательные таблицы преобразования построчного списка в датафрейм, содержащий сводные данные об исходах и значениях CT по больницам, с итоговой строкой внизу. Выходные данные сохраняются в формате table.\n\ntable &lt;- linelist %&gt;% \n  \n  # Получение суммарных значений по группам исходов в больнице\n  ###############################################\n  group_by(hospital, outcome) %&gt;%                      # Сгруппировать данные\n  summarise(                                           # Создать новые сводные столбцы по интересующим показателям\n    N = n(),                                            # Количество строк в каждой группе исходов по больнице     \n    ct_value = median(ct_blood, na.rm=T)) %&gt;%           # медианное значение СТ в каждой группе\n  \n  # добавить итого\n  ############\n  bind_rows(                                           # Связать предыдущую таблицу с этой мини-таблицей итогов\n    linelist %&gt;% \n      filter(!is.na(outcome) & hospital != \"Missing\") %&gt;%\n      group_by(outcome) %&gt;%                            # Группировка только по исходам, но не по больницам    \n      summarise(\n        N = n(),                                       # Количество строк для всего набора данных     \n        ct_value = median(ct_blood, na.rm=T))) %&gt;%     # Медиана CT для всего набора данных\n  \n  # Поворот по ширине и форматирование\n  ########################\n  mutate(hospital = replace_na(hospital, \"Total\")) %&gt;% \n  pivot_wider(                                         # Поворот от длины к ширине\n    values_from = c(ct_value, N),                       # новые значения из столбцов ct и count (подсчет)\n    names_from = outcome) %&gt;%                           # новые названия столбцов взяты из исходов\n  mutate(                                              # Добавить новые столбцы\n    N_Known = N_Death + N_Recover,                               # количество с известным исходом\n    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # процент умерших (с точностью до десятичной дроби)\n    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %&gt;% # процент выздоровевших (с точностью до десятичной дроби)\n  select(                                              # Переупорядочить столбцы\n    hospital, N_Known,                                   # Вводные столбцы\n    N_Recover, Pct_Recover, ct_value_Recover,            # Столбцы выздоровевших\n    N_Death, Pct_Death, ct_value_Death)  %&gt;%             # Столбцы со смертельным исходом\n  arrange(N_Known)                                    # Расположите строки от нижней к верхней (итоговая строка внизу)\n\ntable  # печать\n\n# A tibble: 7 × 8\n# Groups:   hospital [7]\n  hospital      N_Known N_Recover Pct_Recover ct_value_Recover N_Death Pct_Death\n  &lt;chr&gt;           &lt;int&gt;     &lt;int&gt; &lt;chr&gt;                  &lt;dbl&gt;   &lt;int&gt; &lt;chr&gt;    \n1 St. Mark's M…     325       126 38.8%                     22     199 61.2%    \n2 Central Hosp…     358       165 46.1%                     22     193 53.9%    \n3 Other             685       290 42.3%                     21     395 57.7%    \n4 Military Hos…     708       309 43.6%                     22     399 56.4%    \n5 Missing          1125       514 45.7%                     21     611 54.3%    \n6 Port Hospital    1364       579 42.4%                     21     785 57.6%    \n7 Total            3440      1469 42.7%                     22    1971 57.3%    \n# ℹ 1 more variable: ct_value_Death &lt;dbl&gt;",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Таблицы для презентации</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.ru.html#базовая-таблица-flextable",
    "href": "new_pages/tables_presentation.ru.html#базовая-таблица-flextable",
    "title": "29  Таблицы для презентации",
    "section": "29.2 Базовая таблица flextable",
    "text": "29.2 Базовая таблица flextable\n\nСоздать flextable\nДля создания и управления объектами flextable мы сначала пропускаем датафрейм через функцию flextable(). Результат сохраняем под именем my_table.\n\nmy_table &lt;- flextable(table) \nmy_table\n\nhospitalN_KnownN_RecoverPct_Recoverct_value_RecoverN_DeathPct_Deathct_value_DeathSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\nПосле этого мы можем последовательно пропустить объект my_table через другие функции форматирования flextable.\nНа этой странице для наглядности мы будем сохранять таблицу на промежуточных шагах под именем my_table, добавляя понемногу функции flextable. Если вы хотите увидеть весь код от начала до конца, написанный одним блоком, посетите раздел Весь код полностью ниже.\nОбщий синтаксис каждой строки кода flextable выглядит следующим образом:\n\nfunction(table, i = X, j = X, part = \"X\"), где:\n\nФункция “function” может быть одной из множества различных функций, таких как width() для определения ширины столбцов, bg() для установки цвета фона, align() для установки выравнивания текста по центру/вправо/влево и т.д.\ntable = это название блока данных, хотя оно не обязательно, если датафрейм по каналу передается в функцию.\n\npart = указывает, к какой части таблицы применяется функция. Например, “заголовок”, “тело” или “все”.\ni = задает строку, к которой следует применить функцию, где ‘X’ - номер строки. Если строк несколько, например, с первой по третью, то можно указать: i = c(1:3). Обратите внимание, что если выбрано значение ‘body’, то первый ряд начинается из-под раздела заголовка.\nj = указывает столбец, к которому следует применить функцию, где ‘x’ - номер или название столбца. Если столбцов несколько, например, пятый и шестой, то можно указать: j = c(5,6).\n\n\nПолный список функций форматирования flextable можно найти здесь или просмотреть всю информацию, введя ?flextable.\n\n\nШирина столбца\nМы можем использовать функцию autofit(), которая красиво растягивает таблицу так, что в каждой ячейке остается только одна строка текста. Функция qflextable() является удобным сокращением для flextable() и autofit().\n\nmy_table %&gt;% autofit()\n\nhospitalN_KnownN_RecoverPct_Recoverct_value_RecoverN_DeathPct_Deathct_value_DeathSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\nОднако это не всегда уместно, особенно если в ячейках содержатся очень длинные значения, в результате чего таблица может не поместиться на странице.\nВместо этого мы можем задать ширину с помощью функции width(). Чтобы понять, какое значение ширины следует задать, нужно немного поиграть. В приведенном ниже примере мы задаем разную ширину для столбца 1, столбца 2 и столбцов с 4 по 8.\n\nmy_table &lt;- my_table %&gt;% \n  width(j=1, width = 2.7) %&gt;% \n  width(j=2, width = 1.5) %&gt;% \n  width(j=c(4,5,7,8), width = 1)\n\nmy_table\n\nhospitalN_KnownN_RecoverPct_Recoverct_value_RecoverN_DeathPct_Deathct_value_DeathSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\n\n\nЗаголовки столбцов\nМы хотим получить более четкие заголовки для облегчения интерпретации содержимого таблицы.\nДля этой таблицы мы хотим добавить второй слой заголовков, чтобы столбцы, охватывающие одни и те же подгруппы, можно было сгруппировать вместе. Для этого мы используем функцию add_header_row() с top = TRUE. Мы указываем новое название каждого столбца в values =, оставляя пустые значения \"\" для столбцов, которые, как мы знаем, будут объединены позже.\nМы также переименовываем названия заголовков в теперь уже втором заголовке в отдельной команде set_header_labels().\nНаконец, чтобы “объединить” определенные заголовки столбцов в верхнем заголовке, мы используем команду merge_at() для объединения заголовков столбцов в строке верхнего заголовка.\n\nmy_table &lt;- my_table %&gt;% \n  \n  add_header_row(\n    top = TRUE,                # Новый заголовок располагается поверх существующей строки заголовков\n    values = c(\"Hospital\",     # Значения заголовков для каждого столбца ниже\n               \"Total cases with known outcome\", \n               \"Recovered\",    # Это будет заголовок верхнего уровня для этого и двух следующих столбцов\n               \"\",\n               \"\",\n               \"Died\",         # Это будет заголовок верхнего уровня для этого и двух следующих столбцов\n               \"\",             # Оставить пустым, так как он будет объединен с \"Умершие\"\n               \"\")) %&gt;% \n    \n  set_header_labels(         # Переименование столбцов в исходной строке заголовка\n      hospital = \"\", \n      N_Known = \"\",                  \n      N_Recover = \"Total\",\n      Pct_Recover = \"% of cases\",\n      ct_value_Recover = \"Median CT values\",\n      N_Death = \"Total\",\n      Pct_Death = \"% of cases\",\n      ct_value_Death = \"Median CT values\")  %&gt;% \n  \n  merge_at(i = 1, j = 3:5, part = \"header\") %&gt;% # Горизонтальное объединение столбцов 3 - 5 в новой строке заголовка\n  merge_at(i = 1, j = 6:8, part = \"header\")     # Горизонтальное объединение столбцов 6-8 в новой строке заголовка\n\nmy_table  # print\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\n\n\nГраницы и фон\nС помощью различных функций flextable можно настроить границы, внутренние линии и т.д. Часто проще начать с удаления всех существующих границ с помощью функции border_remove().\nЗатем можно применить стандартные темы границ, передав таблицу в функции theme_box(), theme_booktabs() или theme_alafoli().\nДобавить вертикальные и горизонтальные линии можно с помощью различных функций. hline() и vline() добавляют линии в указанную строку или столбец соответственно. В каждой из них необходимо указать part= либо как “все”, либо как “тело”, либо как “заголовок”. Для вертикальных строк следует указать столбец в j =, а для горизонтальных - строку в i =. Другие функции, такие как vline_right(), vline_left(), hline_top() и hline_bottom(), добавляют линии только к внешним сторонам.\nВо всех этих функциях сам стиль линии должен быть указан в border = и должен быть результатом отдельной команды, использующей функцию fp_border() из пакета officer. Эта функция позволяет определить ширину и цвет линии. Ее можно задать над командами таблицы, как показано ниже.\n\n# определить стиль для линии границы\nborder_style = officer::fp_border(color=\"black\", width=1)\n\n# добавить линии границ в таблицу\nmy_table &lt;- my_table %&gt;% \n\n  # удалить все существующие границы\n  border_remove() %&gt;%  \n  \n  # добавить горизонтальные линии с помощью заранее заданной настройки темы\n  theme_booktabs() %&gt;% \n  \n  # добавить вертикальные линии для разделения разделов Выздоровевшие и  Умершие\n  vline(part = \"all\", j = 2, border = border_style) %&gt;%   # at column 2 \n  vline(part = \"all\", j = 5, border = border_style)       # at column 5\n\nmy_table\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\n\n\nШрифт и выравнивание\nМы выравниваем по центру все столбцы, кроме крайнего левого, с названиями больниц, используя функцию align() из flextable.\n\nmy_table &lt;- my_table %&gt;% \n   flextable::align(align = \"center\", j = c(2:8), part = \"all\") \nmy_table\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\nКроме того, мы можем увеличить размер шрифта заголовка и изменить его на полужирный. Мы также можем выделить жирным шрифтом итоговую строку.\n\nmy_table &lt;-  my_table %&gt;%  \n  fontsize(i = 1, size = 12, part = \"header\") %&gt;%   # настроить размер шрифта заголовка\n  bold(i = 1, bold = TRUE, part = \"header\") %&gt;%     # настроить полужирный шрифт заголовка\n  bold(i = 7, bold = TRUE, part = \"body\")           # скорректировать полужирный шрифт итогового ряда (ряд 7 тела таблицы)\n\nmy_table\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\nМы можем обеспечить отображение в столбцах пропорций только одного десятичного знака с помощью функции colformat_num(). Заметим, что это можно было бы сделать и на этапе управления данными с помощью функции round().\n\nmy_table &lt;- colformat_num(my_table, j = c(4,7), digits = 1)\nmy_table\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\n\n\nОбъединение ячеек\nТочно так же, как мы объединяем ячейки по горизонтали в строке заголовка, мы можем объединять ячейки по вертикали, используя функцию merge_at() и указывая строки (i) и столбцы (j). Здесь мы объединяем значения “Больница” и “Всего случаев с известным исходом” по вертикали, чтобы дать им больше места.\n\nmy_table &lt;- my_table %&gt;% \n  merge_at(i = 1:2, j = 1, part = \"header\") %&gt;% \n  merge_at(i = 1:2, j = 2, part = \"header\")\n\nmy_table\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\n\n\nЦвнт фонаr\nЧтобы отличить содержимое таблицы от заголовков, мы можем добавить дополнительное форматирование. Например, изменить цвет фона. В данном примере мы изменим цвет фона таблицы на серый.\n\nmy_table &lt;- my_table %&gt;% \n    bg(part = \"body\", bg = \"gray95\")  \n\nmy_table \n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Таблицы для презентации</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.ru.html#условное-форматирование",
    "href": "new_pages/tables_presentation.ru.html#условное-форматирование",
    "title": "29  Таблицы для презентации",
    "section": "29.3 Условное форматирование",
    "text": "29.3 Условное форматирование\nМы можем выделить все значения в столбце, которые удовлетворяют определенному правилу, например, где более 55% случаев умерли. Просто подставьте критерий в аргумент i = или j =, предваряя его тильдой ~. Ссылайтесь на столбец в блоке данных, а не на отображаемые значения заголовка.\n\nmy_table %&gt;% \n  bg(j = 7, i = ~ Pct_Death &gt;= 55, part = \"body\", bg = \"red\") \n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\nИли мы можем выделить всю строку, удовлетворяющую определенному критерию, например, интересующую нас больницу. Для этого достаточно удалить спецификацию столбца (j), чтобы критерии распространялись на все столбцы.\n\nmy_table %&gt;% \n  bg(., i= ~ hospital == \"Military Hospital\", part = \"body\", bg = \"#91c293\") \n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Таблицы для презентации</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.ru.html#tbl_pres_all",
    "href": "new_pages/tables_presentation.ru.html#tbl_pres_all",
    "title": "29  Таблицы для презентации",
    "section": "29.4 Весь код полностью",
    "text": "29.4 Весь код полностью\nНиже мы покажем весь код полностью из приведенных выше разделов.\n\nborder_style = officer::fp_border(color=\"black\", width=1)\n\npacman::p_load(\n  rio,            # импорт/экспорт\n  here,           # путь к файлу\n  flextable,      # создать таблицы HTML \n  officer,        # функции помощника для таблиц\n  tidyverse)      # управление данными, выводы и визуализация \n\ntable &lt;- linelist %&gt;% \n\n  # Получение суммарных значений по группам исходов в больнице\n  ###############################################\n  group_by(hospital, outcome) %&gt;%                      # Сгруппировать данные\n  summarise(                                           # Создание новых сводных столбцов по интересующим показателям\n    N = n(),                                            # Количество строк в каждой группе исходов по больнице     \n    ct_value = median(ct_blood, na.rm=T)) %&gt;%           # медианное значение СТ в каждой группе\n  \n  # добавить итого\n  ############\n  bind_rows(                                           # Связать предыдущую таблицу с этой мини-таблицей итогов\n    linelist %&gt;% \n      filter(!is.na(outcome) & hospital != \"Missing\") %&gt;%\n      group_by(outcome) %&gt;%                            # Группировка только по исходам, но не по больницам    \n      summarise(\n        N = n(),                                       # Количество строк для всего набора данных     \n        ct_value = median(ct_blood, na.rm=T))) %&gt;%     # Медиана CT для всего набора данных\n  \n  # Поворот по ширине и формирование\n  ########################\n  mutate(hospital = replace_na(hospital, \"Total\")) %&gt;% \n  pivot_wider(                                         # Поворот из длинной в широкую\n    values_from = c(ct_value, N),                       # новые значения из столбцов ct и count (подсчет)\n    names_from = outcome) %&gt;%                           # новые названия столбцов взяты из исходов\n  mutate(                                              # Добавить новые столбцы\n    N_Known = N_Death + N_Recover,                               # количество с известным исходом\n    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # процент умерших (с точностью до десятичной дроби)\n    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %&gt;% # процент выздоровевших (с точностью до десятичной дроби)\n  select(                                              # Переупорядочить столбцы\n    hospital, N_Known,                                   # Вводные столбцы\n    N_Recover, Pct_Recover, ct_value_Recover,            # Столбцы выздоровевших \n    N_Death, Pct_Death, ct_value_Death)  %&gt;%             # Столбцы умерших\n  arrange(N_Known) %&gt;%                                 # Расположите строки от нижней к верхней (итоговая строка внизу)\n\n  # форматирование\n  ############\n  flextable() %&gt;%              # таблица подается сверху\n  add_header_row(\n    top = TRUE,                # Новый заголовок располагается поверх существующей строки заголовков\n    values = c(\"Hospital\",     # Значения заголовков для каждого столбца ниже\n               \"Total cases with known outcome\", \n               \"Recovered\",    # Это будет заголовок верхнего уровня для этого и двух следующих столбцов\n               \"\",\n               \"\",\n               \"Died\",         # Это будет заголовок верхнего уровня для этого и двух следующих столбцов\n               \"\",             # Оставить пустым, так как он будет объединен с \"Умершими\"\n               \"\")) %&gt;% \n    set_header_labels(         # Переименовать столбцы в исходной строке заголовка\n      hospital = \"\", \n      N_Known = \"\",                  \n      N_Recover = \"Total\",\n      Pct_Recover = \"% of cases\",\n      ct_value_Recover = \"Median CT values\",\n      N_Death = \"Total\",\n      Pct_Death = \"% of cases\",\n      ct_value_Death = \"Median CT values\")  %&gt;% \n  merge_at(i = 1, j = 3:5, part = \"header\") %&gt;% # Горизонтальное объединение столбцов 3 - 5 в новую строку заголовка\n  merge_at(i = 1, j = 6:8, part = \"header\") %&gt;%  \n  border_remove() %&gt;%  \n  theme_booktabs() %&gt;% \n  vline(part = \"all\", j = 2, border = border_style) %&gt;%   # в столбце 2 \n  vline(part = \"all\", j = 5, border = border_style) %&gt;%   # в столбце 5\n  merge_at(i = 1:2, j = 1, part = \"header\") %&gt;% \n  merge_at(i = 1:2, j = 2, part = \"header\") %&gt;% \n  width(j=1, width = 2.7) %&gt;% \n  width(j=2, width = 1.5) %&gt;% \n  width(j=c(4,5,7,8), width = 1) %&gt;% \n  flextable::align(., align = \"center\", j = c(2:8), part = \"all\") %&gt;% \n  bg(., part = \"body\", bg = \"gray95\")  %&gt;% \n  bg(., j=c(1:8), i= ~ hospital == \"Military Hospital\", part = \"body\", bg = \"#91c293\") %&gt;% \n  colformat_num(., j = c(4,7), digits = 1) %&gt;%\n  bold(i = 1, bold = TRUE, part = \"header\") %&gt;% \n  bold(i = 7, bold = TRUE, part = \"body\")\n\n`summarise()` has grouped output by 'hospital'. You can override using the\n`.groups` argument.\n\ntable\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Таблицы для презентации</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.ru.html#сохранение-вашей-таблицы",
    "href": "new_pages/tables_presentation.ru.html#сохранение-вашей-таблицы",
    "title": "29  Таблицы для презентации",
    "section": "29.5 Сохранение вашей таблицы",
    "text": "29.5 Сохранение вашей таблицы\nТаблица может быть интегрирована в выходные данные различными способами.\n\nСохранить одну таблицу\nТаблицы можно экспортировать в Word, PowerPoint или HTML, а также в виде файлов изображений (PNG). Для этого воспользуйтесь одной из следующих функций:\n\nsave_as_docx()\n\nsave_as_pptx()\n\nsave_as_image()\n\nsave_as_html()\n\nНапример, ниже мы сохраняем нашу таблицу в виде документа word. Обратите внимание на синтаксис первого аргумента - вы можете просто указать имя объекта flextable, например my_table, или дать ему ” название”, как показано ниже (название - “my table”). Если название задано, то оно будет отображаться как заголовок таблицы в Word. Мы также демонстрируем код для сохранения изображения в формате PNG.\n\n# Отредактируйте `my table` так, как это необходимо для названия таблицы.  \nsave_as_docx(\"my table\" = my_table, path = \"file.docx\")\n\nsave_as_image(my_table, path = \"file.png\")\n\nОбратите внимание, что для сохранения таблицы flextable в виде изображения требуются пакеты webshot или webshot2. Изображения могут получиться с прозрачным фоном.\nЕсли вы хотите просмотреть “живую” версию flextable в формате предполагаемого документа, используйте print() и укажите в preview = одно из следующих значений. Документ будет “всплывать”, открываясь на вашем компьютере в указанной программе, но не будет сохранен. Это может быть полезно для проверки, поместится ли таблица на одной странице/слайде, или для быстрого копирования ее в другой документ, можно использовать метод печати с аргументом предпросмотра, установленным в “pptx” или “docx”.\n\nprint(my_table, preview = \"docx\") # пример документа Word\nprint(my_table, preview = \"pptx\") # пример Powerpoint\n\n\n\nПечать таблицы в R markdown\nЭта таблица может быть интегрирована в автоматизированный документ, выходной документ в R markdown, если объект таблицы вызывается в фрагменте R markdown. Это означает, что таблица может быть обновлена в рамках отчета, в котором данные могут измениться, так что цифры могут быть обновлены.\nПодробнее см. на странице Отчеты с помощью R Markdown данного руководства.",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Таблицы для презентации</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.ru.html#ресурсы",
    "href": "new_pages/tables_presentation.ru.html#ресурсы",
    "title": "29  Таблицы для презентации",
    "section": "29.6 Ресурсы",
    "text": "29.6 Ресурсы\nПолная версия книги flextable находится здесь: https://ardata-fr.github.io/flextable-book/. Сайт Github находится здесь\nРуководство по всем функциям flextable можно найти здесь\nГалерея примеров красивых таблиц flextable с кодом доступна здесь",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Таблицы для презентации</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.ru.html",
    "href": "new_pages/ggplot_basics.ru.html",
    "title": "30  Основы ggplot",
    "section": "",
    "text": "30.1 Подготовка",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Основы ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.ru.html#подготовка",
    "href": "new_pages/ggplot_basics.ru.html#подготовка",
    "title": "30  Основы ggplot",
    "section": "",
    "text": "Загрузка пакетов\nВ этом фрагменте кода показана загрузка пакетов, необходимых для проведения анализа. В данном руководстве мы делаем акцент на p_load() из pacman, которая при необходимости устанавливает пакет и загружает его для использования. Установленные пакеты можно также загрузить с помощью library() из базового R. Более подробную информацию о пакетах R см. на странице [Основы R].\n\npacman::p_load(\n  tidyverse,      # включает ggplot2 и другие средства управления данными\n  janitor,        # чистящие и сводные таблицы\n  ggforce,        # Дополнения к ggplot\n  rio,            # импорт/экспорт\n  here,           # локатор файлов\n  stringr         # работа с символами   \n)\n\n\n\nИмпорт данных\nИмпортируем набор данных случаев из смоделированной эпидемии лихорадки Эбола. Если вы хотите выполнять действия параллельно, щелкните мышью, чтобы загрузить “чистый” построчный список (в виде файла .rds). Импортируйте данные с помощью функции import() из пакета rio (она принимает множество типов файлов, таких как .xlsx, .rds, .csv - подробности см. на странице [Импорт и экспорт]).\n\nlinelist &lt;- rio::import(\"linelist_cleaned.rds\")\n\nНиже представлены первые 50 строк построчного списка. Мы сосредоточимся на непрерывных переменных age(возраст), wt_kg (вес в килограммах), ct_blood(значения CT) и days_onset_hosp (разница между датой начала заболевания и госпитализацией).\n\n\n\n\n\n\n\n\nОбщая вычистка\nПри подготовке данных к построению графиков лучше всего сделать так, чтобы они максимально соответствовали понятию стандарты “аккуратных” данных. О том, как этого добиться, рассказывается на страницах этого руководства, посвященных управлению данными, например, в разделе [Вычистка данных и ключевые функции].\nНекоторые простые способы подготовки данных для построения графиков могут включать в себя улучшение качества отображения содержимого данных, что не обязательно означает улучшение качества работы с данными. Например:\n\nЗаменить значения NA в текстовом столбце на последовательность символов “Неизвестно”.\n\nРассмотреть возможность преобразования столбца в класс фактор, чтобы его значения имели предписанные порядковые уровни\n\nВычистка некоторых столбцов с заменой “дружественных к данным” значений с подчеркиваниями и т.п. на обычный текстовый или заглавный регистр (см. [Текст и последовательности])\n\nПриведем несколько примеров этого в действии:\n\n# сделать версию отображения столбцов с более удобными названиями\nlinelist &lt;- linelist %&gt;%\n  mutate(\n    gender_disp = case_when(gender == \"m\" ~ \"Male\",        # м на Муж \n                            gender == \"f\" ~ \"Female\",      # ж на Жен,\n                            is.na(gender) ~ \"Unknown\"),    # NA на неизвестно \n    \n    outcome_disp = replace_na(outcome, \"Unknown\")          # заменить исход NA на \"неизвестно\"\n  )\n\n\n\nПоворот в длину\nС точки зрения структуры данных, для ggplot2 мы часто также хотим разворачивать данные в более длинные форматы. Подробнее об этом можно прочитать на странице [Поворот данных].\n\n\n\n\n\n\n\n\n\nНапример, мы хотим построить график данных в “широком” формате, например, для каждого случая в построчном спискеlinelist и его симптомов. Ниже мы создадим мини построчный список с названием symptoms_data, содержащий только столбцы case_id и симптомы.\n\nsymptoms_data &lt;- linelist %&gt;% \n  select(c(case_id, fever, chills, cough, aches, vomit))\n\nВот как выглядят первые 50 строк этого мини построчного списка - посмотрите, как они отформатированы “в ширину” с каждым симптомом в виде столбца:\n\n\n\n\n\n\nЕсли бы мы хотели построить график количества случаев с определенными симптомами, мы были бы ограничены тем, что каждый симптом - это отдельный столбец. Однако мы можем повернуть столбцы симптомов в более длинный формат, например, так:\n\nsymptoms_data_long &lt;- symptoms_data %&gt;%    # начать с \"мини\" построчного списка под названием symptoms_data\n  \n  pivot_longer(\n    cols = -case_id,                       # повернуть все столбцы, кроме case_id (все столбцы симптомов)\n    names_to = \"symptom_name\",             # присвоить название новому столбцу, в котором будут содержаться симптомы\n    values_to = \"symptom_is_present\") %&gt;%  # присвоить название новому столбцу, в котором будут находиться значения (да/нет)\n  \n  mutate(symptom_is_present = replace_na(symptom_is_present, \"unknown\")) # преобразовать NA в \"неизвестно\"\n\nЗдесь представлены первые 50 строк. Обратите внимание на то, что случай имеет 5 строк - по одной для каждого возможного симптома. Новые столбцы symptom_name и symptom_is_present являются результатом поворота. Заметим, что этот формат может быть не очень удобен для других операций, но полезен для построения графиков.",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Основы ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.ru.html#основы-ggplot",
    "href": "new_pages/ggplot_basics.ru.html#основы-ggplot",
    "title": "30  Основы ggplot",
    "section": "30.2 Основы ggplot",
    "text": "30.2 Основы ggplot\n“Грамматика графики” - ggplot2\nПостроение графиков с помощью ggplot2 основано на “наложении” друг на друга слоев и элементов оформления, причем каждая команда добавляется к предыдущим с помощью символа плюса (+). В результате получается многослойный графический объект, который можно сохранять, изменять, распечатывать, экспортировать и т.д.\nОбъекты ggplot могут быть очень сложными, но основной порядок слоев обычно выглядит следующим образом:\n\nНачните с базовой команды ggplot() - она “открывает” ggplot и позволяет добавлять последующие функции с помощью +. Как правило, в этой команде также указывается набор данных\n\nДобавьте слои “geom” - эти функции визуализируют данные в виде геометрии (фигуры), например, в виде гистограммы, линейного графика, диаграммы рассеяния, гистограммы (или их комбинации!). Все эти функции начинаются с префикса geom_.\n\nДобавьте элементы оформления графика, такие как метки осей, заголовок, шрифты, размеры, цветовые схемы, легенды или поворот осей.\n\nПростой пример скелетного кода приведен ниже. Пояснения к каждому компоненту будут даны в следующих разделах.\n\n# построить график данных из столбца my_data в виде красных точек\nggplot(data = my_data)+                   # использование набора данных \"my_data\"\n  geom_point(                             # добавить слой точек\n    mapping = aes(x = col1, y = col2),    # \"привязка\" столбца данных к осям\n    color = \"red\")+                       # другая спецификация для геом\n  labs()+                                 # здесь добавляются заголовки, метки осей и т.д.\n  theme()                                 # Здесь настраиваются цвет, шрифт, размер и т.д. элементов графика, не относящихся к данным (оси, заголовок и т.д.)",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Основы ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.ru.html#ggplot",
    "href": "new_pages/ggplot_basics.ru.html#ggplot",
    "title": "30  Основы ggplot",
    "section": "30.3 ggplot()",
    "text": "30.3 ggplot()\nОткрывающей командой любого графика ggplot2 является команда ggplot(). Эта команда просто создает чистый холст, на который можно добавлять слои. Она “открывает” путь для добавления последующих слоев с помощью символа +.\nОбычно команда ggplot() включает аргумент data = для построения графика. Это задает набор данных по умолчанию, который будет использоваться для последующих слоев графика.\nКоманда завершается символом + после закрывающих круглых скобок. Таким образом, команда остается “открытой”. ggplot будет выполняться/появляться только в том случае, если полная команда включает последний слой без + в конце.\n\n# Это позволит создать график, представляющий собой чистый холст\nggplot(data = linelist)",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Основы ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.ru.html#геомы",
    "href": "new_pages/ggplot_basics.ru.html#геомы",
    "title": "30  Основы ggplot",
    "section": "30.4 Геомы",
    "text": "30.4 Геомы\nЧистого холста, конечно, недостаточно - необходимо создать геометрию (фигуры) из наших данных (например, столбчатые диаграммы, гистограммы, диаграммы рассеяния, коробчатой диаграммы).\nЭто делается путем добавления слоев “геомов” к исходной команде ggplot(). Существует множество функций ggplot2, создающих “геомы”. Каждая из этих функций начинается с символа “geom_”, поэтому мы будем называть их обобщенно geom_XXXX(). В ggplot2 существует более 40 геомов и множество других, созданных поклонниками. Ознакомиться с ними можно на сайте галерея ggplot2. Ниже перечислены некоторые распространенные геомы:\n\nГистограммы - geom_histogram()\n\nСтолбчатые диаграммы - geom_bar() or geom_col() (see “Bar plot” section)\n\nБокс-диаграммы - geom_boxplot()\n\nТочки (н-р диаграммы рассеивания) - geom_point()\n\nЛинейные графики - geom_line() or geom_path()\n\nГрафики трендов - geom_smooth()\n\nНа одном графике можно отобразить один или несколько геомов. Каждый из них добавляется к предыдущим командам ggplot2 с помощью знака +, и они строятся последовательно, так что последующие геомы строятся поверх предыдущих.",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Основы ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.ru.html#ggplot_basics_mapping",
    "href": "new_pages/ggplot_basics.ru.html#ggplot_basics_mapping",
    "title": "30  Основы ggplot",
    "section": "30.5 Сопоставление данных с графиком",
    "text": "30.5 Сопоставление данных с графиком\nБольшинству функций геомов необходимо указать, что использовать для создания фигур, поэтому вы должны указать им, как сопоставить (назначить) столбцы ваших данных с компонентами графика, такими как оси, цвета фигур, размеры фигур и т.д. Для большинства геомов основными компонентами, которые должны быть сопоставлены со столбцами данных, являются ось x и (при необходимости) ось y.\nЭто ” сопоставление” происходит с помощью аргумента mapping =. Сопоставления, которые вы передаете в mapping, должны быть обернуты в функцию aes(), поэтому вы напишете что-то вроде mapping = aes(x = col1, y = col2), как показано ниже.\nНиже, в команде ggplot(), данные задаются в виде построчного списка linelist. В аргументе mapping = aes() столбец age возраст отображается на ось x, а столбец wt_kg - на ось y.\nПосле + продолжаются команды построения графика. Фигура создается с помощью функции ” геом” geom_point(). Этот геом наследует отображения из команды ggplot(), описанной выше, - он знает назначение осей и столбцов и визуализирует эти отношения в виде точек на холсте.\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+\n  geom_point()\n\n\n\n\n\n\n\n\nВ качестве другого примера можно привести следующие команды, использующие те же данные, несколько иное отображение и другой геом. Для функции geom_histogram() требуется только столбец, сопоставленный с осью x, так как ось y генерируется автоматически.\n\nggplot(data = linelist, mapping = aes(x = age))+\n  geom_histogram()\n\n\n\n\n\n\n\n\n\nЭстетика графика\nВ терминологии ggplot ““эстетика”” графика имеет специфическое значение. Она относится к визуальному свойству данных графика. Заметим, что “эстетика” здесь относится к данным, отображаемым в геомах/фигурах, а не к окружающему отображению, такому как заголовки, метки осей, цвет фона, которые можно ассоциировать со словом “эстетика” в обычном понимании. В ggplot эти детали называются “темами” и настраиваются в рамках команды theme() (см. этот раздел).\nПоэтому эстетикой объектов графика могут быть цвета, размеры, прозрачность, расположение и т.д. относительно данных на графике. Не все геомы будут иметь одинаковые эстетические возможности, но многие из них могут быть использованы большинством геомов. Вот некоторые примеры:\n\nshape = Отображение точки с помощью geom_point() в виде точки, звезды, треугольника или квадрата…\n\nfill = Внутренний цвет (например, столбчатой или коробчатой диаграммы)\n\ncolor = Внешняя линия столбца, диаграммы и т.д., или цвет точки при использовании geom_point().\n\nsize = Размер (например, толщина линии, размер точки)\n\nalpha = Прозрачность (1 = непрозрачный, 0 = невидимый)\n\nbinwidth = Ширина корзин гистограммы\n\nwidth = Ширина столбцов ” столбчатой диаграммы”\n\nlinetype = Тип линии (например, сплошная, пунктирная, точечная)\n\nЭтим эстетическим характеристикам объектов могут быть присвоены значения двумя способами:\n\nПрисвоить статическое значение (например, color = \"blue\"), которое будет применяться ко всем изображениям на графике\n\nПрисваивается одному из столбцов данных (например, color = hospital) так, что отображение каждого изображения зависит от его значения в этом столбце\n\n\n\n\nУстановить статистическое значение\nЕсли вы хотите, чтобы эстетика объекта графика была статичной, т.е. одинаковой для каждого объекта, вы пишете его назначение внутри геома, но вне любого утверждения mapping = aes(). Эти привязки могут выглядеть как size = 1 или color = \"blue\". Приведем два примера:\n\nВ первом примере в команде ggplot() задано mapping = aes(), и оси сопоставлены со столбцами возраста и веса в данных. Эстетические параметры графика color =, size = и alpha = (прозрачность) присваиваются статическим значениям. Для наглядности это сделано в функции geom_point(), так как впоследствии можно добавить другие геомы, которые будут принимать другие значения для эстетики графика.\n\nВо втором примере для гистограммы требуется только ось x, отображенная на столбец. Параметры гистограммы binwidth =, color =, fill = (внутренний цвет) и alpha = снова устанавливаются в геоме в статические значения.\n\n\n# диаграмма рассеяния\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  # задать данные и отображение осей\n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)         # задать эстетику статической точки\n\n# гистограмма\nggplot(data = linelist, mapping = aes(x = age))+       # задать данные и оси\n  geom_histogram(              # отобразить гистограмму\n    binwidth = 7,                # ширина корзин гистаграмм \n    color = \"red\",               # цвет линии корзины \n    fill = \"blue\",               # внутренний цвет корзины\n    alpha = 0.1)                 # прозрачность корзины\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nМасштабирование по значениям столбца\nАльтернативным вариантом является масштабирование эстетики объекта графика по значениям в столбце. При таком подходе отображение эстетики зависит от значения в этом столбце данных. Если значения столбца непрерывны, то и шкала отображения (легенда) для этой эстетики будет непрерывной. Если значения столбца дискретны, то в легенде будет отображаться каждое значение, а данные на графике будут выглядеть как четко “сгруппированные” (подробнее об этом читайте в разделе группирование на этой странице).\nДля этого необходимо сопоставить эстетику графика с названием столбца (не в кавычках). Это должно быть сделано *в функции mapping = aes() (примечание: в коде есть несколько мест, где можно задать это сопоставление, о чем говорится ниже).\nНиже приведены два примера.\n\nВ первом примере эстетика color = (каждой точки) сопоставлена со столбцом age - и в легенде появилась шкала! Пока просто отметим, что шкала существует - в последующих разделах мы покажем, как ее модифицировать.\n\nВо втором примере два новых эстетических свойства графика также сопоставлены столбцам (color = и Size =), в то время как эстетические свойства графика shape = и alpha = сопоставлены статическим значениям вне какой-либо функции mapping = aes().\n\n\n# диаграмма рассеяния\nggplot(data = linelist,   # задать данные\n       mapping = aes(     # сопоставление эстетических характеристик со значениями столбцов\n         x = age,           # сопоставить ось x с осью возраста            \n         y = wt_kg,         # сопоставить ось y с весом\n         color = age)\n       )+     # сопоставить цвет с возрастом\n  geom_point()         # отобразить данные в виде точек \n\n# диаграмма рассеяния\nggplot(data = linelist,   # задать данные\n       mapping = aes(     # сопоставление эстетических характеристик со значениями столбцов\n         x = age,           # сопоставить ось x с осью возраста            \n         y = wt_kg,         # сопоставить ось y с весом\n         color = age,       # сопоставить цвет с возрастом\n         size = age))+      # сопоставить размер с возрастом\n  geom_point(             # отобразить данные в виде точек\n    shape = \"diamond\",      # отображение точек в виде ромбиков\n    alpha = 0.3)            # прозрачность точек на уровне 30%\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nПримечание: Назначения осей всегда привязываются к столбцам данных (а не к статическим значениям), и это всегда делается в рамках mapping = aes().\nПри построении более сложных графиков, например, графиков с несколькими геомами, важно следить за слоями и эстетикой графиков. В приведенном ниже примере эстетика size = присваивается дважды - один раз для geom_point() и один раз для geom_smooth() - оба раза как статическое значение.\n\nggplot(data = linelist,\n       mapping = aes(           # сопоставить эстетику со столбцами\n         x = age,\n         y = wt_kg,\n         color = age_years)\n       ) + \n  geom_point(                   # добавить точки для каждой строки данных\n    size = 1,\n    alpha = 0.5) +  \n  geom_smooth(                  # добавить линию тенденции \n    method = \"lm\",              # линейным методом\n    size = 2)                   # размер (ширина строки) 2\n\n\n\n\n\n\n\n\n\n\nГде делать назначения по сопоставлению\nЭстетическое сопоставление в рамках mapping = aes() может быть записано в нескольких местах в ваших командах построения графиков и даже может быть записано более одного раза. Его можно записать в верхней команде ggplot(), и/или для каждого отдельного геома под ним. К тонкостям относятся:\n\nНазначения сопоставления, сделанные в верхней команде ggplot(), будут наследоваться по умолчанию для всех нижележащих геомов, подобно тому, как наследуются значения x = и y =.\nНазначения сопоставления, сделанные в пределах одного геома, применяются только к этому геому.\n\nАналогично, data =, указанные в верхней команде ggplot(), будут применяться по умолчанию ко всем нижележащим геомам, но можно также указать данные для каждого геома (но это сложнее).\nТаким образом, каждая из следующих команд создаст один и тот же график:\n\n# В результате выполнения этих команд будет получен один и тот же график\nggplot(data = linelist, mapping = aes(x = age))+\n  geom_histogram()\n\nggplot(data = linelist)+\n  geom_histogram(mapping = aes(x = age))\n\nggplot()+\n  geom_histogram(data = linelist, mapping = aes(x = age))\n\n\n\nГруппы\nВы можете легко сгруппировать данные и построить “график по группам”. Фактически, вы уже это сделали!\nНазначьте столбец “группирование” соответствующей эстетике графика в рамках mapping = aes(). Выше мы продемонстрировали это на примере непрерывных величин, когда присвоили точке size = столбец age. Однако это работает и для дискретных/категориальных столбцов.\nНапример, если необходимо отобразить точки по полу, то задайте mapping = aes(color = gender). При этом автоматически появляется легенда. Это назначение может быть сделано внутри команды mapping = aes() в верхней команде ggplot() (и наследоваться геомом), либо задано в отдельной команде mapping = aes() внутри геома. Оба подхода показаны ниже:\n\nggplot(data = linelist,\n       mapping = aes(x = age, y = wt_kg, color = gender))+\n  geom_point(alpha = 0.5)\n\n\n\n\n\n\n\n\n\n# Этот альтернативный код дает тот же самый график\nggplot(data = linelist,\n       mapping = aes(x = age, y = wt_kg))+\n  geom_point(\n    mapping = aes(color = gender),\n    alpha = 0.5)\n\nОбратите внимание, что в зависимости от геома для группировки данных необходимо использовать различные аргументы. Для geom_point() вы, скорее всего, будете использовать color =, shape = или `size =. В то время как для geom_bar(), скорее всего, будет использоваться fill =. Это зависит только от геома и от того, какой эстетикой графика вы хотите отразить группирование.\nДля справки - самый простой способ группирования данных - это использование только аргумента group = в mapping = aes(). Однако это само по себе не изменит ни цвета, ни заливки, ни формы. Также не будет создана легенда. Тем не менее, данные группируются, что может повлиять на отображение статистики.\nЧтобы изменить порядок групп на графике, см. страницу [советы по использованию ggplot] или страницу [Факторы]. В приведенных ниже разделах, посвященных построению непрерывных и категориальных данных, можно найти множество примеров сгруппированных графиков.",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Основы ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.ru.html#ggplot_basics_facet",
    "href": "new_pages/ggplot_basics.ru.html#ggplot_basics_facet",
    "title": "30  Основы ggplot",
    "section": "30.6 Фасеты/малые множества",
    "text": "30.6 Фасеты/малые множества\nДля разбиения одного графика на многопанельные фигуры используются фасеты или “малые множества”, причем на каждую группу данных приходится одна панель (“фасет”). Один и тот же вид графика создается несколько раз, каждый раз с использованием подгруппы одного и того же набора данных.\nРазбиение на фасеты - это функциональность, заложенная в ggplot2, поэтому легенды и оси “панелей” фасетов автоматически выравниваются. Существуют и другие пакеты, обсуждаемые на странице [советы по использованию ggplot], которые используются для объединения совершенно разных графиков (cowplot и patchwork) в один рисунок.\nРазбиение на фасеты выполняется с помощью одной из следующих функций ggplot2:\n\nfacet_wrap() Для отображения различных панелей для каждого уровня одной переменной. Примером может служить показ различных эпидемических кривых для каждой больницы в регионе. Фасеты упорядочиваются в алфавитном порядке, если только переменная не является фактором с другим порядком следования.\n\n\n\nВы можете использовать некоторые опции для определения расположения фасет, например, nrow = 1 или ncol = 1 для управления количеством строк или столбцов, в которых располагаются графики с фасетами.\n\nfacet_grid() Используется в тех случаях, когда необходимо ввести вторую переменную в схему разбиения на фасеты. Здесь каждая панель сетки показывает пересечение значений в двух столбцах. Например, эпидемические кривые для каждой комбинации больница-возрастная группа с больницами сверху (столбцы) и возрастными группами по бокам (строки).\n\n\n\nnrow и ncol не имеют значения, так как подгруппы представлены в виде сетки\n\n\nКаждая из этих функций принимает синтаксис формулы, задающей столбец (столбцы) для разбиения на фасеты. Обе принимают до двух столбцов, по одному с каждой стороны тильды ~.\n\nДля facet_wrap() чаще всего пишется только один столбец, которому предшествует тильда ~, например facet_wrap(~hospital). Однако можно написать и два столбца facet_wrap( outcome ~ hospital) - каждая уникальная комбинация будет отображаться на отдельной панели, но они не будут расположены в виде сетки. В заголовках будут отображаться комбинированные термины, и они не будут иметь специфической логики для столбцов и строк. Если задается только одна переменная разбиения на фасеты, то точка . используется в качестве заполнителя на другой стороне формулы - см. примеры кода.\nДля facet_grid() можно также указать в формуле одну или две строки (сетка rows ~ columns). Если требуется указать только один столбец, можно поставить точку . по другую сторону тильды, например, facet_grid(. ~ hospital) или facet_grid(hospital ~ .).\n\nВ фасетах может быстро оказаться слишком много информации, поэтому следует убедиться, что у вас не слишком много уровней каждой переменной, по которой вы решили построить фасет. Приведем несколько быстрых примеров с набором данных по малярии (см. [Скачивание руководства и данных]), который состоит из ежедневных подсчетов случаев заболевания малярией в учреждениях с разбивкой по возрастным группам.\nНиже мы импортируем данные и сделаем несколько быстрых модификаций для простоты:\n\n# Эти данные представляют собой ежедневные подсчеты случаев заболевания малярией с разбивкой по дням пребывания в учреждении.\nmalaria_data &lt;- import(here(\"data\", \"malaria_facility_count_data.rds\")) %&gt;%  # импорт\n  select(-submitted_date, -Province, -newid)                                 # удалить ненужные столбцы\n\nНиже приведены первые 50 строк данных по малярии. Обратите внимание на наличие столбца malaria_tot, а также столбцов для подсчетов по возрастным группам (они будут использованы во втором примере facet_grid()).\n\n\n\n\n\n\n\nfacet_wrap()\nПока остановимся на столбцах malaria_tot и District. Столбцы с возрастными показателями пока проигнорируем. Мы построим эпидемические кривые с помощью функции geom_col(), которая создает столбец для каждого дня на заданной высоте оси y, указанной в столбце malaria_tot (данные уже являются ежедневными подсчетами, поэтому мы используем geom_col() - см. раздел ” Столбчатая диаграмма” ниже).\nПри добавлении команды facet_wrap() мы указываем тильду, а затем столбец для создания фасет (в данном случае District). Вы можете поместить еще один столбец слева от тильды - это создаст по одному фасету для каждой комбинации, - но мы рекомендуем вместо этого использовать команду facet_grid(). В данном случае для каждого уникального значения District создается один фасет.\n\n# График с фасетами по районам\nggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1, fill = \"darkred\") +       # построить график данных подсчета в виде столбцов\n  theme_minimal()+                              # упростить фоновые панели\n  labs(                                         # добавить метки графика, заголовок и т.д.\n    x = \"Date of report\",\n    y = \"Malaria cases\",\n    title = \"Malaria cases by district\") +\n  facet_wrap(~District)                       # создаются фасеты\n\n\n\n\n\n\n\n\n\n\nfacet_grid()\nДля пересечения двух переменных мы можем использовать подход facet_grid(). Допустим, мы хотим пересечь District и возраст. Тогда нам необходимо выполнить некоторые преобразования данных в столбцах возраста, чтобы привести эти данные к предпочтительному для ggplot “длинному” формату. У возрастных групп есть свои собственные столбцы - мы хотим, чтобы они были в одном столбце age_group и в другом num_cases. Подробнее об этом см. на странице [Поворот данных].\n\nmalaria_age &lt;- malaria_data %&gt;%\n  select(-malaria_tot) %&gt;% \n  pivot_longer(\n    cols = c(starts_with(\"malaria_rdt_\")),  # выбрать столбцы для поворота в длину\n    names_to = \"age_group\",      # названия столбцов становятся возрастными группами\n    values_to = \"num_cases\"      # значения в один столбец (num_cases)\n  ) %&gt;%\n  mutate(\n    age_group = str_replace(age_group, \"malaria_rdt_\", \"\"),\n    age_group = forcats::fct_relevel(age_group, \"5-14\", after = 1))\n\nТеперь первые 50 строк данных выглядят следующим образом:\n\n\n\n\n\n\nПри передаче двух переменных в facet_grid() проще всего использовать формулу(например, x ~ y), где x - это строки, а y - столбцы. Вот график, использующий facet_grid() для отображения графиков для каждой комбинации столбцов age_group и District.\n\nggplot(malaria_age, aes(x = data_date, y = num_cases)) +\n  geom_col(fill = \"darkred\", width = 1) +\n  theme_minimal()+\n  labs(\n    x = \"Date of report\",\n    y = \"Malaria cases\",\n    title = \"Malaria cases by district and age group\"\n  ) +\n  facet_grid(District ~ age_group)\n\n\n\n\n\n\n\n\n\n\nСвободные или фиксированные оси\nМасштабы осей, отображаемые при делении на фасеты, по умолчанию одинаковы (фиксированы) для всех фасет. Это полезно для перекрестного сравнения, но не всегда уместно.\nПри использовании facet_wrap() или facet_grid() можно добавить scales = \"free_y\", чтобы “освободить” или отпустить оси y панелей для масштабирования в соответствии с их подмножеством данных. Это особенно полезно, если фактические значения для одной из подкатегорий невелики и тенденции трудно заметить. Вместо “free_y” можно также написать “free_x”, чтобы сделать то же самое для оси x (например, для дат), или “free” для обеих осей. Обратите внимание на то, что в facet_grid масштабы y будут одинаковыми для фасет в одной строке, а масштабы x - для фасет в одном столбце.\nПри использовании только facet_grid можно добавить space = \"free_y\" или space = \"free_x\", чтобы фактическая высота или ширина фасета взвешивалась по отношению к значениям фигур внутри нее. Это работает только в том случае, если уже применено scales = \"free\" (y или x).\n\n# Свободная ось y\nggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1, fill = \"darkred\") +       # построить график данных подсчета в виде столбцов\n  theme_minimal()+                              # упростить фоновые панели\n  labs(                                         # добавить метки графика, заголовок и т.д.\n    x = \"Date of report\",\n    y = \"Malaria cases\",\n    title = \"Malaria cases by district - 'free' x and y axes\") +\n  facet_wrap(~District, scales = \"free\")        # создаются фасеты\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nПорядок уровней факторов в фасетах\nО том, как переупорядочить уровни факторов внутри фасетов, см. этот пост.",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Основы ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.ru.html#хранение-графиков",
    "href": "new_pages/ggplot_basics.ru.html#хранение-графиков",
    "title": "30  Основы ggplot",
    "section": "30.7 Хранение графиков",
    "text": "30.7 Хранение графиков\n\nСохранение графиков\nПо умолчанию при выполнении команды ggplot() график выводится на панель Plots RStudio. Однако можно сохранить график как объект, используя оператор присваивания &lt;- и задав ему название. Тогда он не будет печататься, пока не будет запущено само название объекта. Можно также вывести его на печать, обернув название графика в print(), но это необходимо только в некоторых случаях, например, если график создается внутри цикла, используемого для печати нескольких графиков одновременно (см. страницу [Итерации, циклы и списки]).\n\n# определить график\nage_by_wt &lt;- ggplot(data = linelist, mapping = aes(x = age_years, y = wt_kg, color = age_years))+\n  geom_point(alpha = 0.1)\n\n# печать\nage_by_wt    \n\n\n\n\n\n\n\n\n\n\nИзменение сохраненных графиков\nУдобство работы с ggplot2 заключается в том, что вы можете определить график (как описано выше), а затем добавить к нему слои, начиная с его названия. При этом не нужно повторять все команды, создавшие исходный график!\nНапример, чтобы изменить график age_by_wt, который был определен выше, и включить в него вертикальную линию в возрасте 50 лет, достаточно добавить + и начать добавлять дополнительные слои к графику.\n\nage_by_wt+\n  geom_vline(xintercept = 50)\n\n\n\n\n\n\n\n\n\n\nЭкспорт графиков\nЭкспорт ggplots упрощается с помощью функции ggsave() из ggplot2. Она может работать двумя способами:\n\nУкажите имя объекта графика, затем путь к файлу и его название с расширением\n\nНапример: ggsave(my_plot, here(\"plots\", \"my_plot.png\")).\n\n\nВыполните команду, указав только путь к файлу, чтобы сохранить последний распечатанный график\n\nНапример: ggsave(here(\"plots\", \"my_plot.png\"))\n\n\nМожно экспортировать в png, pdf, jpeg, tiff, bmp, svg или в несколько других типах файлов, указав расширение файла в пути к нему.\nТакже можно указать аргументы width =, height = и units = (либо ” дюйм”, либо “см”, либо “мм”). Также можно указать dpi = с числом для разрешения графика (например, 300). Подробнее о функции можно узнать, введя ?ggsave или прочитав документацию онлайн.\nПомните, что для указания нужного пути к файлу можно использовать синтаксис here(). Более подробную информацию см. на странице [Импорт и экспорт].",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Основы ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.ru.html#метки",
    "href": "new_pages/ggplot_basics.ru.html#метки",
    "title": "30  Основы ggplot",
    "section": "30.8 Метки",
    "text": "30.8 Метки\nНаверняка вы захотите добавить или скорректировать метки графика. Это проще всего сделать в функции labs(), которая добавляется к графику с помощью + так же, как и геомы.\nВ функции labs() можно указать последовательность символов для этих аргументов:\n\nx = и y = Заголовок (метки) оси x и оси y\n\ntitle = Основной заголовок графика\n\nsubtitle = Подзаголовок графика, более мелким шрифтом под заголовком\n\ncaption = Подпись к графику, по умолчанию в правом нижнем углу\n\nВот график, который мы сделали ранее, но с более красивыми метками:\n\nage_by_wt &lt;- ggplot(\n  data = linelist,   # задать данные\n  mapping = aes(     # сопоставить эстетические характеристики со значениями столбцов\n         x = age,           # сопоставить ось x с возрастом            \n         y = wt_kg,         # сопоставить ось y с весом\n         color = age))+     # сопоставить цвет с возрастом\n  geom_point()+           # отобразить данные в виде точек\n  labs(\n    title = \"Age and weight distribution\",\n    subtitle = \"Fictional Ebola outbreak, 2014\",\n    x = \"Age in years\",\n    y = \"Weight in kilos\",\n    color = \"Age\",\n    caption = stringr::str_glue(\"Data as of {max(linelist$date_hospitalisation, na.rm=T)}\"))\n\nage_by_wt\n\n\n\n\n\n\n\n\nОбратите внимание на то, как в задании по созданию подписи мы использовали str_glue() из пакета stringr для встраивания динамического кода R в текст строки. В подписи будет отображаться дата “Данные по состоянию на:”, которая отражает максимальную дату госпитализации в построчном списке. Подробнее об этом читайте на странице [текст и последовательности].\nОтносительно указания названия легенды: Не существует единого аргумента “название легенды”, поскольку в легенде может быть несколько шкал. Внутри labs() можно написать аргумент для эстетики графика, используемой для создания легенды, и таким образом указать название. Например, выше мы назначили color = age для создания легенды. Следовательно, мы указываем color = to labs() и присваиваем легенде желаемый заголовок (“Возраст” с большой буквы). Если вы создаете легенду с помощью aes(fill = COLUMN), то в labs() вы напишете fill =, чтобы настроить заголовок этой легенды. Раздел о цветовых шкалах на странице [советы по использованию ggplot] содержит более подробную информацию о редактировании легенд, а также альтернативный подход с использованием функций scales_().",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Основы ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.ru.html#ggplot_basics_themes",
    "href": "new_pages/ggplot_basics.ru.html#ggplot_basics_themes",
    "title": "30  Основы ggplot",
    "section": "30.9 Темы",
    "text": "30.9 Темы\nОдним из преимуществ ggplot2 является возможность контроля над графиком - вы можете определить все, что угодно! Как уже говорилось выше, дизайн графика, который не связан с формами/геометриями данных, настраивается в рамках функции theme(). Например, цвет фона графика, наличие/отсутствие линий сетки, шрифт/размер/цвет/выравнивание текста (заголовки, подзаголовки, подписи, текст осей…). Эти настройки могут быть выполнены одним из двух способов:\n\nДобавить настройку полная тема theme_() для выполнения комплексных изменений - например, theme_classic(), theme_minimal(), theme_dark(), theme_light(), theme_grey(), theme_bw() и др.\n\nНастроить каждый мельчайший аспект графика индивидуально в рамках theme()\n\n\nПолные темы\nПоскольку они достаточно просты, мы продемонстрируем функции полной темы ниже и не будем описывать их здесь. Обратите внимание, что любые микрокорректировки с помощью theme() должны производиться после использования полной темы.\nЗаписывайте их с пустыми круглыми скобками.\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme classic\")+\n  theme_classic()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme bw\")+\n  theme_bw()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme minimal\")+\n  theme_minimal()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme gray\")+\n  theme_gray()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nИзменение темы\nФункция theme() может принимать большое количество аргументов, каждый из которых изменяет очень специфический аспект графика. Мы не сможем рассказать обо всех аргументах, но опишем их общий вид и покажем, как найти название нужного аргумента. Основной синтаксис выглядит следующим образом:\n\nВнутри theme() запишите название аргумента для редактируемого элемента графика, например, plot.title =.\n\nПрисвойте аргументу функцию element_().\n\nЧаще всего используется element_text(), но можно использовать и другие функции, например element_rect() для цвета фона полотна или element_blank() для удаления элементов графика\n\n\nВнутри функции element_() напишите назначения аргументов, чтобы выполнить желаемые настройки\n\nИтак, это описание было достаточно абстрактным, поэтому приведем несколько примеров.\nПриведенный ниже график выглядит довольно глупо, но он служит для того, чтобы показать разнообразие способов настройки графика.\n\nМы начинаем с графика age_by_wt, определенного чуть выше, и добавляем theme_classic().\n\nДля более детальной настройки мы добавляем theme() и включаем по одному аргументу для каждого элемента графика, который необходимо настроить.\n\nНе лишним будет организовать аргументы в логические секции. Ниже описаны лишь некоторые из них:\n\nlegend.position = уникален тем, что принимает такие простые значения, как ““низ”“,”верх”“,”лево”” и “право”“. Но обычно аргументы, связанные с текстом, требуют размещения деталей в пределах element_text().\n\nРазмер заголовка меняется с помощью element_text(size = 30)\n\nВыравнивание заголовка по горизонтали - с помощью element_text(hjust = 0) (справа налево)\n\nПодзаголовок выделяется курсивом с помощью element_text(face = \"italic\")\n\n\nage_by_wt + \n  theme_classic()+                                 # предварительно заданные настройки темы\n  theme(\n    legend.position = \"bottom\",                    # перенести легенду в нижнюю часть\n    \n    plot.title = element_text(size = 30),          # размер заголовка до 30\n    plot.caption = element_text(hjust = 0),        # надпись с выравниванием по левому краю\n    plot.subtitle = element_text(face = \"italic\"), # выделение подзаголовка курсивом\n    \n    axis.text.x = element_text(color = \"red\", size = 15, angle = 90), # корректирует только текст по оси x\n    axis.text.y = element_text(size = 15),         # корректирует только текст по оси y\n    \n    axis.title = element_text(size = 20)           # корректирует заголовки обеих осей\n    )     \n\n\n\n\n\n\n\n\nВот некоторые особенно часто встречающиеся аргументы theme(). Вы узнаете некоторые закономерности, например, добавление .x или .y для применения изменения только к одной оси.\n\n\n\n\n\n\n\nаргумент theme()\nЧто он корректирует\n\n\n\n\nplot.title = element_text()\nЗаголовок\n\n\nplot.subtitle = element_text()\nПодзаголовок\n\n\nplot.caption = element_text()\nПодпись (обводка, цвет, размер, угол, vjust, hjust…)\n\n\naxis.title = element_text()\nЗаголовки осей (как x, так и y) ( размер, обводка, угол, цвет…)\n\n\naxis.title.x = element_text()\nЗаголовок оси только по оси x ( используйте .y только для оси y)\n\n\naxis.text = element_text()\nТекст оси (как по оси x, так и по оси y)\n\n\naxis.text.x = element_text()\nТекст оси только по оси x (используйте .y только для оси y)\n\n\naxis.ticks = element_blank()\nУдаление отметок оси\n\n\naxis.line = element_line()\nЛинии оси (цвет, размер, тип линии: сплошная пунктирная и т.д.)\n\n\nstrip.text = element_text()\nТекст полосы фасета (цвет, обводка, размер, угол наклона…)\n\n\nstrip.background = element_rect()\nПолоса фасета (заливка, цвет, размер…)\n\n\n\nНо ведь аргументов тем так много! Как же их запомнить? Не волнуйтесь - запомнить их все невозможно. К счастью, есть ряд инструментов, которые вам помогут:\nСуществует документация tidyverse по вопросу изменение темы, в которой приведен полный список.\nСОВЕТ: Запустите theme_get() из ggplot2, чтобы вывести на консоль список всех 90+ аргументов theme().\nСОВЕТ: При необходимости удалить элемент графика это можно сделать и через theme(). Достаточно передать в качестве аргумента element_blank(), чтобы он полностью исчез. Для легенд задайте legend.position = \"none\"..",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Основы ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.ru.html#цвета",
    "href": "new_pages/ggplot_basics.ru.html#цвета",
    "title": "30  Основы ggplot",
    "section": "30.10 Цвета",
    "text": "30.10 Цвета\nПосмотрите этот раздел о цветовых шкалах страницы советы по использованию ggplot.",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Основы ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.ru.html#привязывание-к-ggplot2",
    "href": "new_pages/ggplot_basics.ru.html#привязывание-к-ggplot2",
    "title": "30  Основы ggplot",
    "section": "30.11 Привязывание к ggplot2",
    "text": "30.11 Привязывание к ggplot2\nПри использовании каналов для вычистки и преобразования данных можно легко передать преобразованные данные в функцию ggplot().\nКаналы, передающие набор данных от функции к функции, перейдут в + после вызова функции ggplot(). Обратите внимание на то, что в этом случае нет необходимости указывать аргумент data =, так как он автоматически определяется как передаваемый по каналу набор данных.\nВот как это может выглядеть:\n\nlinelist %&gt;%                                                     # начать с построчного списка\n  select(c(case_id, fever, chills, cough, aches, vomit)) %&gt;%     # выбрать столбцы\n  pivot_longer(                                                  # повернуть в длину\n    cols = -case_id,                                  \n    names_to = \"symptom_name\",\n    values_to = \"symptom_is_present\") %&gt;%\n  mutate(                                                        # заменить отсутствующие значения\n    symptom_is_present = replace_na(symptom_is_present, \"unknown\")) %&gt;% \n  \n  ggplot(                                                        # начать ggplot!\n    mapping = aes(x = symptom_name, fill = symptom_is_present))+\n  geom_bar(position = \"fill\", col = \"black\") +                    \n  theme_classic() +\n  labs(\n    x = \"Symptom\",\n    y = \"Symptom status (proportion)\"\n  )",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Основы ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.ru.html#построение-графика-непрерывных-данных",
    "href": "new_pages/ggplot_basics.ru.html#построение-графика-непрерывных-данных",
    "title": "30  Основы ggplot",
    "section": "30.12 Построение графика непрерывных данных",
    "text": "30.12 Построение графика непрерывных данных\nНа этой странице вы уже видели множество примеров построения графиков непрерывных данных. Здесь мы кратко обобщим их и представим несколько вариантов.\nЗдесь рассматриваются такие виды визуализации, как:\n\nГрафики для одной непрерывной переменной:\n\nГистограмма - классический график для представления распределения непрерывной переменной.\n\nКоробчатая диаграмма (также называемая “ящиком с усами”) позволяет показать 25-й, 50-й и 75-й процентили, хвостовые части распределения и выбивающиеся значения (важные ограничения).\n\nГрафик с функцией дрожания - отображение всех значений в виде точек, которые “дрожат”, так что все они (в основном) видны, даже если два из них имеют одинаковое значение.\nСкрипичный график, показывает распределение непрерывной переменной на основе симметричной ширины “скрипки”.\nГрафик Sinaplot - комбинация графиков с функцией джиттера и скрипичного графика, где отдельные точки отображаются, но в симметричной форме распределения (с помощью пакета ggforce).\n\nГрафик рассеяния для двух непрерывных переменных.\n\nТепловые графики для трех непрерывных переменных (ссылка на страницу [Тепловые графики])\n\n\nГистограммы\nГистограммы похожи на столбчатые диаграммы, но отличаются от них тем, что измеряют распределение непрерывной переменной. Пробелы между “столбиками” отсутствуют, и в geom_histogram() передается только один столбец.\nНиже приведен код для создания гистограмм, которые группируют непрерывные данные по диапазонам и отображают в виде смежных столбиков разной высоты. Для этого используется функция geom_histogram(). Разницу между geom_histogram(), geom_bar() и geom_col() см. в разделе ” Столбчатые диаграммы” на странице Основы ggplot.\nМы покажем распределение возрастов случаев. В mapping = aes() укажите, по какому столбцу вы хотите видеть распределение. Этот столбец можно отнести как к оси x, так и к оси y.\nСтроки будут распределены по “корзинам” в зависимости от их числового возраста, и эти корзины будут графически представлены в виде столбцов. Если задать число корзин с помощью параметра bins =, то точки разрыва будут равномерно распределены между минимальными и максимальными значениями гистограммы. Если bins = не задано, то будет предложено соответствующее количество корзин, и после построения графика будет выведено соответствующее сообщение:\n## `stat_bin()`, используя `bins = 30`. Подберите лучшее значение с помощью `binwidth`.\nЕсли вы не хотите указывать число корзин в bins =, то в качестве альтернативы можно указать binwidth = в единицах измерения оси. Приведем несколько примеров, демонстрирующих различные корзины и ширину корзин:\n\n# A) Обычная гистограмма\nggplot(data = linelist, aes(x = age))+  # предоставить переменную x\n  geom_histogram()+\n  labs(title = \"A) Default histogram (30 bins)\")\n\n# B) Больше корзин\nggplot(data = linelist, aes(x = age))+  # предоставить переменную x\n  geom_histogram(bins = 50)+\n  labs(title = \"B) Set to 50 bins\")\n\n# C) Меньше корзин \nggplot(data = linelist, aes(x = age))+  # предоставить переменную x\n  geom_histogram(bins = 5)+\n  labs(title = \"C) Set to 5 bins\")\n\n\n# D) Больше корзин \nggplot(data = linelist, aes(x = age))+  # предоставить переменную x\n  geom_histogram(binwidth = 1)+\n  labs(title = \"D) binwidth of 1\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nДля получения сглаженных пропорций можно использовать geom_density():\n\n# Частота с осью пропорций, сглаженных\nggplot(data = linelist, mapping = aes(x = age)) +\n  geom_density(size = 2, alpha = 0.2)+\n  labs(title = \"Proportional density\")\n\n# Сложенные частоты с осью пропорций, сглаженных\nggplot(data = linelist, mapping = aes(x = age, fill = gender)) +\n  geom_density(size = 2, alpha = 0.2, position = \"stack\")+\n  labs(title = \"'Stacked' proportional densities\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЧтобы получить гистограмму “с накоплением” (непрерывного столбца данных), можно выполнить одно из следующих действий:\n\nИспользовать geom_histogram() с аргументом fill = внутри aes() и назначением столбца группировки, или\n\nИспользовать функцию geom_freqpoly(), которая, скорее всего, будет более удобной для чтения (при этом можно задать binwidth =)\n\nЧтобы увидеть пропорции всех значений, задайте y = after_stat(density) (используйте именно этот синтаксис - он не изменен для ваших данных). Примечание: эти пропорции будут показаны для каждой группы.\n\nНиже показан каждый вариант (*обратите внимание на использование color = по сравнению с fill = в каждом случае):\n\n# Гистограмма с накоплением\nggplot(data = linelist, mapping = aes(x = age, fill = gender)) +\n  geom_histogram(binwidth = 2)+\n  labs(title = \"'Stacked' histogram\")\n\n# Частота \nggplot(data = linelist, mapping = aes(x = age, color = gender)) +\n  geom_freqpoly(binwidth = 2, size = 2)+\n  labs(title = \"Freqpoly\")\n\n# Частота с осью пропорций\nggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), color = gender)) +\n  geom_freqpoly(binwidth = 5, size = 2)+\n  labs(title = \"Proportional freqpoly\")\n\n# Частота с осью пропорций, сглаженных\nggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), fill = gender)) +\n  geom_density(size = 2, alpha = 0.2)+\n  labs(title = \"Proportional, smoothed with geom_density()\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЕсли вы хотите немного развлечься, попробуйте geom_density_ridges из пакета ggridges (виньетка здесь.\nБолее подробно о гистограммах можно прочитать на tidyverse страница geom_histogram().\n\n\nКоробчатые диаграммы\nКоробчатые диаграммы широко распространены, но имеют существенные ограничения. Они могут скрывать реальное распределение - например, бимодальное распределение. Подробнее об этом см. здесь галерея R graph и здесь статья “От данных к визуализации”. Однако они хорошо отображают интерквартильный диапазон и выпадающие значения, поэтому их можно накладывать поверх других типов графиков, которые показывают распределение более подробно.\nНиже мы напомним вам о различных компонентах коробочной диаграммы:\n\n\n\n\n\n\n\n\n\nПри использовании geom_boxplot() для создания коробчатой диаграммы обычно задается только одна ось (x или y) в рамках aes(). Указанная ось определяет, будут ли графики горизонтальными или вертикальными.\nВ большинстве геомов график для каждой группы создается путем привязки эстетики типа color = или fill = к столбцу в aes(). Однако для коробчатых диаграмм это достигается путем назначения столбца группировки на неназначенную ось (x или y). Ниже приведен код для построения коробчатой диаграммы всех значений возраста в наборе данных, а второй код - для отображения одной коробчатой диаграммы для каждого (не пропущенного) пола в наборе данных. Обратите внимание, что значения NA (“отсутствующие”) будут отображаться в виде отдельной коробчатой диаграммы, если их не удалить. В этом примере мы также установили fill для столбца outcome, чтобы каждый график был разного цвета - но это не обязательно.\n\n# A) вся коробчатая диаграмма\nggplot(data = linelist)+  \n  geom_boxplot(mapping = aes(y = age))+   # сопоставлена только ось y (не x)\n  labs(title = \"A) Overall boxplot\")\n\n# B) Коробчатая диаграмма по группам \nggplot(data = linelist, mapping = aes(y = age, x = gender, fill = gender)) + \n  geom_boxplot()+                     \n  theme(legend.position = \"none\")+   # удалить легенду (лишняя)\n  labs(title = \"B) Boxplot by gender\")      \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nКод для добавления коробчатой диаграммы к краям диаграммы рассеяния (“маргинальные” графики) приведен на странице [советы по использованию ggplot].\n\n\nСкрипичный график, графис с “дрожанием” и график sina\nНиже приведен код для построения скрипичных графиков (geom_violin) и графиков с фугкцией дрожания (geom_jitter) для отображения распределений. Вы можете указать, что заливка или цвет также определяются данными, вставив эти опции в aes().\n\n# A) График с функцией дрожания по группам\nggplot(data = linelist %&gt;% drop_na(outcome),      # удаление отсутствующих значений\n       mapping = aes(y = age,                     # Непрерывная переменная\n           x = outcome,                           # Переменная группировки\n           color = outcome))+                     # Переменная цвета\n  geom_jitter()+                                  # Создание скрипичного графика\n  labs(title = \"A) jitter plot by gender\")     \n\n\n\n# B) Скрипичный график по группам\nggplot(data = linelist %&gt;% drop_na(outcome),       # удаление отсутствующих значений\n       mapping = aes(y = age,                      # Непрерывная переменная\n           x = outcome,                            # Переменная группировки\n           fill = outcome))+                       # Переменная заливки (цвета)\n  geom_violin()+                                   # Создание скрипичного графика\n  labs(title = \"B) violin plot by gender\")    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nИх можно объединить с помощью функции geom_sina() из пакета ggforce. Функция sina строит графики точек дрожания в форме скрипичного графика. При наложении на скрипичный график (регулируя прозрачность) это может быть легче визуально интерпретировать.\n\n# A) График Sina по группам \nggplot(\n  data = linelist %&gt;% drop_na(outcome), \n  aes(y = age,           # числовая переменная\n      x = outcome)) +    # переменная группы\n  geom_violin(\n    aes(fill = outcome), # заливка (цвет фона скрипки)\n    color = \"white\",     # белый контур\n    alpha = 0.2)+        # прозрачность\n  geom_sina(\n    size=1,                # Изменение величины дрожания\n    aes(color = outcome))+ # цвет (цвет точек)\n  scale_fill_manual(       # Определить заливку для фона скрипки по смерти/выздоровлению\n    values = c(\"Death\" = \"#bf5300\", \n              \"Recover\" = \"#11118c\")) + \n  scale_color_manual(      # Определение цветов для точек по смерти/выздоровлению\n    values = c(\"Death\" = \"#bf5300\", \n              \"Recover\" = \"#11118c\")) + \n  theme_minimal() +                                # удалить серый фон\n  theme(legend.position = \"none\") +                # Удалить ненужную легенду\n  labs(title = \"B) violin and sina plot by gender, with extra formatting\")      \n\n\n\n\n\n\n\n\n\n\nДве непрерывные переменные\nИспользуя аналогичный синтаксис, функция geom_point() позволяет построить график рассеивания двух непрерывных переменных относительно друг друга. Это удобно для отображения фактических значений, а не их распределений. Базовый график рассеивания возраста и веса показан в (A). В (B) мы снова используем facet_grid(), чтобы показать связь между двумя непрерывными переменными в построчном списке.\n\n# Базовый график рассеяния веса и возраста\nggplot(data = linelist, \n       mapping = aes(y = wt_kg, x = age))+\n  geom_point() +\n  labs(title = \"A) Scatter plot of weight and age\")\n\n# График рассеивания веса и возраста в зависимости от пола и исхода болезни Эбола\nggplot(data = linelist %&gt;% drop_na(gender, outcome), # фильтр сохраняет непропущенные пол/результат\n       mapping = aes(y = wt_kg, x = age))+\n  geom_point() +\n  labs(title = \"B) Scatter plot of weight and age faceted by gender and outcome\")+\n  facet_grid(gender ~ outcome) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nТри непрерывные переменные\nС помощью аргумента fill = можно отобразить три непрерывные переменные, создав тепловой график. Цвет каждой “ячейки” будет отражать значение третьего непрерывного столбца данных. Более подробную информацию и несколько примеров см. на странице [советы по использованию ggplot] и на странице [Тепловые графики].\nСуществуют способы построения трехмерных графиков в R, но для прикладной эпидемиологии они часто трудно интерпретируемы и поэтому менее полезны для принятия решений.",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Основы ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.ru.html#построение-графиков-категориальных-данных",
    "href": "new_pages/ggplot_basics.ru.html#построение-графиков-категориальных-данных",
    "title": "30  Основы ggplot",
    "section": "30.13 Построение графиков категориальных данных",
    "text": "30.13 Построение графиков категориальных данных\nКатегориальные данные могут представлять собой символьные значения, могут быть логическими (“ИСТИНА/ЛОЖЬ”) или факторами (см. страницу [Факторы]).\n\nПодготовка\n\nСтруктура данных\nПрежде всего, необходимо понять, в каком виде существуют категориальные данные: в виде необработанных наблюдений, например, в виде построчного списка случаев, или в виде сводного или агрегированного датафрейма, содержащего подсчеты или пропорции. Состояние данных будет влиять на то, какую функцию построения графиков вы будете использовать:\n\nЕсли данные представляют собой необработанные наблюдения с одной строкой на наблюдение, то, скорее всего, будет использована функция geom_bar().\n\nЕсли данные уже агрегированы в виде подсчетов или пропорций, то, скорее всего, используется geom_col().\n\n\n\nКласс столбца и упорядочение значений\nДалее исследуйте класс столбцов, которые вы хотите построить. Мы рассматриваем hospital, сначала с помощью class() из базового R, а затем с помощью tabyl() из janitor.\n\n# Посмотрите на класс столбца больницы - мы видим, что это символ\nclass(linelist$hospital)\n\n[1] \"character\"\n\n# Рассмотрите значения и пропорции в столбце больниц\nlinelist %&gt;% \n  tabyl(hospital)\n\n                             hospital    n    percent\n                     Central Hospital  454 0.07710598\n                    Military Hospital  896 0.15217391\n                              Missing 1469 0.24949049\n                                Other  885 0.15030571\n                        Port Hospital 1762 0.29925272\n St. Mark's Maternity Hospital (SMMH)  422 0.07167120\n\n\nМы видим, что значения внутри являются символами, так как это названия больниц, и по умолчанию они упорядочены в алфавитном порядке. Имеются значения “прочие” и “отсутствующие”, которые мы предпочли бы видеть последними подкатегориями при представлении разбивки. Поэтому мы меняем этот столбец на фактор и переупорядочиваем его. Более подробно это рассматривается на странице [Факторы].\n\n# Преобразование в фактор и определение порядка уровней, чтобы \"Прочие\" и \"Отсутствующие\" были последними\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    hospital = fct_relevel(hospital, \n      \"St. Mark's Maternity Hospital (SMMH)\",\n      \"Port Hospital\", \n      \"Central Hospital\",\n      \"Military Hospital\",\n      \"Other\",\n      \"Missing\"))\n\n\nlevels(linelist$hospital)\n\n[1] \"St. Mark's Maternity Hospital (SMMH)\"\n[2] \"Port Hospital\"                       \n[3] \"Central Hospital\"                    \n[4] \"Military Hospital\"                   \n[5] \"Other\"                               \n[6] \"Missing\"                             \n\n\n\n\n\ngeom_bar()\nИспользуйте geom_bar(), если хотите, чтобы высота столбцов (или высота компонентов сложенных столбцов) отражала количество соответствующих строк в данных. Между этими столбиками будут оставаться промежутки, если только не будет настроена эстетика графика width =.\n\nУкажите только один столбец оси (обычно ось x). Если указать x и y, то будет получено сообщение Error: stat_count() can only have an x or y aesthetic..\n\nВы можете создать сложенные столбцы, добавив назначение столбца fill = внутри mapping = aes().\n\nПротивоположная ось по умолчанию будет называться ” подсчет”, поскольку она представляет собой количество строк\n\nНиже мы отнесли исходы к оси y, но с тем же успехом их можно отнести и к оси x. Если у вас есть длинные символьные значения, то иногда лучше перевернуть столбики на бок и поместить легенду внизу. Это может повлиять на порядок расположения уровней факторов - в данном случае мы меняем их местами с помощью fct_rev(), чтобы поместить отсутствующие и другие в нижнюю часть.\n\n# A) Исходы во всех случаях\nggplot(linelist %&gt;% drop_na(outcome)) + \n  geom_bar(aes(y = fct_rev(hospital)), width = 0.7) +\n  theme_minimal()+\n  labs(title = \"A) Number of cases by hospital\",\n       y = \"Hospital\")\n\n\n# B) Исходы во всех случаях с разбивкой по больницам\nggplot(linelist %&gt;% drop_na(outcome)) + \n  geom_bar(aes(y = fct_rev(hospital), fill = outcome), width = 0.7) +\n  theme_minimal()+\n  theme(legend.position = \"bottom\") +\n  labs(title = \"B) Number of recovered and dead Ebola cases, by hospital\",\n       y = \"Hospital\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngeom_col()\nИспользуйте geom_col(), если хотите, чтобы высота столбиков (или высота компонентов сложенных столбиков) отражала предварительно вычисленные значения, имеющиеся в данных. Часто это суммарные или “агрегированные” подсчеты, или пропорции.\nЗадайте в geom_col() назначение столбцов для обеих осей. Обычно столбец оси x является дискретным, а столбец оси y - числовым.\nДопустим, у нас есть набор данных outcomes:\n\n\n# A tibble: 2 × 3\n  outcome     n proportion\n  &lt;chr&gt;   &lt;int&gt;      &lt;dbl&gt;\n1 Death    1022       56.2\n2 Recover   796       43.8\n\n\nНиже приведен код с использованием geom_col для создания простых столбчатых диаграмм, отображающих распределение исходов у пациентов с лихорадкой Эбола. При использовании функции geom_col необходимо указать как x, так и y. Здесь x - категориальная переменная по оси x, а y - сгенерированный столбец пропорций proportion.\n\n# Исходы во всех случаях\nggplot(outcomes) + \n  geom_col(aes(x=outcome, y = proportion)) +\n  labs(subtitle = \"Number of recovered and dead Ebola cases\")\n\n\n\n\n\n\n\n\nДля того чтобы показать разбивку по больницам, необходимо, чтобы таблица содержала больше информации и имела “длинный” формат. Мы создаем эту таблицу с частотами комбинированных категорий outcome и hospital (советы по группировке см. на странице [Группирование данных]).\n\noutcomes2 &lt;- linelist %&gt;% \n  drop_na(outcome) %&gt;% \n  count(hospital, outcome) %&gt;%  # получить подсчеты по больницам и исходам\n  group_by(hospital) %&gt;%        # Сгруппировать таким образом, чтобы пропорции были вне общего значения по больнице \n  mutate(proportion = n/sum(n)*100) # рассчитать пропорции от общего значения по больнице\n\nhead(outcomes2) # Предварительный просмотр данных\n\n# A tibble: 6 × 4\n# Groups:   hospital [3]\n  hospital                             outcome     n proportion\n  &lt;fct&gt;                                &lt;chr&gt;   &lt;int&gt;      &lt;dbl&gt;\n1 St. Mark's Maternity Hospital (SMMH) Death     199       61.2\n2 St. Mark's Maternity Hospital (SMMH) Recover   126       38.8\n3 Port Hospital                        Death     785       57.6\n4 Port Hospital                        Recover   579       42.4\n5 Central Hospital                     Death     193       53.9\n6 Central Hospital                     Recover   165       46.1\n\n\nЗатем мы создаем ggplot с некоторым дополнительным форматированием:\n\nПереворот оси: Поменяли оси местами с помощью coord_flip(), чтобы можно было читать названия больниц.\nСтолбцы бок о бок: Добавлен аргумент position = \"dodge\", чтобы столбцы для смерти и выздоровления были представлены рядом, а не сложенными. Обратите внимание, что по умолчанию столбцы представлены в виде сложенных столбиков.\nШирина столбца: Указано значение ‘width’, поэтому столбцы будут вдвое тоньше, чем при полной возможной ширине.\nПорядок столбцов: Изменили порядок категорий на оси y так, чтобы “Другое” и “Отсутствующие” оказались внизу, с помощью scale_x_discrete(limits=rev). Обратите внимание, что мы использовали именно этот метод, а не scale_y_discrete, поскольку больница указывается в аргументе x в aes(), даже если визуально она находится на оси y. Мы делаем это потому, что Ggplot, по-видимому, представляет категории в обратном порядке, если мы не запрещаем ему это делать.\n\nДругие сведения: Добавлены метки/названия и цвета в labs и scale_fill_color соответственно.\n\n\n# Исходы во всех случаях в разбивке по больницам\nggplot(outcomes2) +  \n  geom_col(\n    mapping = aes(\n      x = proportion,                 # показать предварительно рассчитанные значения пропорций\n      y = fct_rev(hospital),          # обратный порядок уровней, чтобы отсутствующие/другие находились внизу\n      fill = outcome),                # сложенные по результатам\n    width = 0.5)+                    # более тонкие столбики (из 1)\n  theme_minimal() +                  # Минимальная тема \n  theme(legend.position = \"bottom\")+\n  labs(subtitle = \"Number of recovered and dead Ebola cases, by hospital\",\n       fill = \"Outcome\",             # заголовок легенды\n       y = \"Count\",                  # заголовок оси y\n       x = \"Hospital of admission\")+ # Заголовок оси x\n  scale_fill_manual(                 # добавление цветов вручную\n    values = c(\"Death\"= \"#3B1c8C\",\n               \"Recover\" = \"#21908D\" )) \n\n\n\n\n\n\n\n\nОбратите внимание на то, что пропорции являются бинарными, поэтому мы можем предпочесть опустить слово “выздоровление” и показать только долю умерших. Это просто для наглядности.\nПри использовании geom_col() с данными о датах (например, эпикривая из агрегированных данных) необходимо настроить аргумент width =, чтобы убрать “промежуточные” линии между столбиками. При использовании ежедневных данных задайте width = 1. Если данные еженедельные, то width = 7. Использование месяцев невозможно, поскольку каждый месяц имеет разное количество дней.\n\n\ngeom_histogram()\nГистограммы похожи на столбчатые диаграммы, но отличаются от них тем, что измеряют распределение непрерывной переменной. Пробелы между “столбиками” отсутствуют, и в geom_histogram() передается только один столбец. Существуют такие специфические для гистограмм аргументы, как bin_width = и breaks = для указания способа разбиения данных на столбцы. Дополнительную информацию можно найти в приведенном выше разделе о непрерывных данных и на странице [Эпидемические кривые].",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Основы ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.ru.html#ресурсы",
    "href": "new_pages/ggplot_basics.ru.html#ресурсы",
    "title": "30  Основы ggplot",
    "section": "30.14 Ресурсы",
    "text": "30.14 Ресурсы\nВ Интернете имеется огромное количество справочной информации, особенно по ggplot. См:\n\nшпаргалка по ggplot2\nеще одна шпаргалка\nстраница основ tidyverse ggplot\n\nпостроение графиков непрерывных переменных\nСтраницы R для науки о данных визуализация данных\nграфика для коммуникаций",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Основы ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.ru.html",
    "href": "new_pages/ggplot_tips.ru.html",
    "title": "31  Советы по использованию ggplot",
    "section": "",
    "text": "31.1 Подготовка",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Советы по использованию ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.ru.html#подготовка",
    "href": "new_pages/ggplot_tips.ru.html#подготовка",
    "title": "31  Советы по использованию ggplot",
    "section": "",
    "text": "Загрузка пакетов\nВ этом фрагменте кода показана загрузка пакетов, необходимых для проведения анализа. В данном руководстве мы делаем акцент на функции p_load() из pacman, которая при необходимости устанавливает пакет и загружает его для использования. Установленные пакеты можно также загрузить с помощью library() из базового R. Более подробную информацию о пакетах R см. на странице Основы R.\n\npacman::p_load(\n  tidyverse, # включает в себя ggplot2 и другие\n  rio, # импорт/экспорт\n  here, # локатор файлов\n  stringr, # работа с символами   \n  scales, # преобразование чисел\n  ggrepel, # грамотно расставленные метки\n  gghighlight, # выделение одной части графика\n  RColorBrewer # цветовые шкалы\n)\n\n\n\nИмпорт данных\nДля этой страницы мы импортируем набор данных случаев из смоделированной эпидемии лихорадки Эбола. Если вы хотите выполнять действия параллельно, нажмите кнопку, чтобы загрузить “чистый” построчный список (в виде файла .rds). Импортируйте данные с помощью функции import() из пакета rio (она работает со многими типами файлов, такими как .xlsx, .csv, .rds - подробности см. на странице Импорт и экспорт).\n\nlinelist &lt;- rio::import(\"linelist_cleaned.rds\")\n\nНиже отображаются первые 50 строк построчного списка.",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Советы по использованию ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.ru.html#ggplot_tips_colors",
    "href": "new_pages/ggplot_tips.ru.html#ggplot_tips_colors",
    "title": "31  Советы по использованию ggplot",
    "section": "31.2 Шкалы для цвета, заливки, осей и т.д.",
    "text": "31.2 Шкалы для цвета, заливки, осей и т.д.\nВ ggplot2, когда эстетические характеристики графических данных (например, размер, цвет, форма, заливка, ось графика) привязаны к столбцам данных, точное отображение можно настроить с помощью соответствующей команды “scale”. В этом разделе мы расскажем о некоторых распространенных способах настройки шкал.\n\n31.2.1 Цветовые схемы\nОдним из моментов, который поначалу может оказаться сложным для понимания в ggplot2, является управление цветовыми схемами. Обратите внимание на то, что в данном разделе рассматривается цвет объектов графика (геомов/фигур), таких как точки, отрезки, линии, плитки и т.д. Для настройки цвета текста, заголовков или цвета фона см. раздел Темы на странице Основы ggplot.\nДля управления “цветом” объектов графика необходимо настраивать либо эстетику color = (внешний цвет), либо эстетику fill = (внутренний цвет). Исключением из этого правила является функция geom_point(), где действительно можно управлять только color =, который управляет цветом точки (внутренним и внешним).\nПри задании цвета или заливки можно использовать названия цветов, распознаваемые R, например, \"red\" (см. полный список или введите ?colors), или конкретный шестнадцатеричный код цвета, например, \"#ff0505\".\n\n# гистограмма - \nggplot(data = linelist, mapping = aes(x = age))+       # set data and axes\n  geom_histogram(              # отобразит гистаграмму\n    binwidth = 7,                # ширина корзин\n    color = \"red\",               # цвет линии корзины\n    fill = \"lightblue\")          # внутренний цвет корзины (заливка) \n\n\n\n\n\n\n\n\nКак объясняется в разделе Основы ggplot, посвященном вопросу сопоставление данных с графиком, такие эстетические параметры, как fill = и color =, могут быть заданы как вне оператора mapping = aes(), так и внутри него. В случае внешнего оператора aes() присвоенное значение должно быть статичным (например, color = \"blue\") и будет применяться для всех данных, построенных с помощью геома. Если внутри, то эстетика должна быть сопоставлена со столбцом, например, color = hospital, и выражение будет меняться в зависимости от значения этой строки в данных. Несколько примеров:\n\n# Статический цвет для точек и для линии\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     \n  geom_point(color = \"purple\")+\n  geom_vline(xintercept = 50, color = \"orange\")+\n  labs(title = \"Static color for points and line\")\n\n# Цвет сопоставлен с непрерывным столбцом\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     \n  geom_point(mapping = aes(color = temp))+         \n  labs(title = \"Color mapped to continuous column\")\n\n# Цвет сопоставлен с дискретным столбцом\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     \n  geom_point(mapping = aes(color = gender))+         \n  labs(title = \"Color mapped to discrete column\")\n\n# столбчатая диаграмма, заливка сопоставлена с дискретным столбцом, цвет - со статическим значением\nggplot(data = linelist, mapping = aes(x = hospital))+     \n  geom_bar(mapping = aes(fill = gender), color = \"yellow\")+         \n  labs(title = \"Fill mapped to discrete column, static color\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nШкалы\nПосле сопоставления столбца с эстетикой графика (например, x =, y =, fill =, color =…) у графика появляется шкала/легенда. См. выше, что шкала может быть непрерывной, дискретной, датой и т.д. в зависимости от класса назначенного столбца. Если столбцам сопоставлено несколько эстетик, то участок будет иметь несколько шкал.\nУправлять шкалами можно с помощью соответствующей функции scales_(). Функции шкал в ggplot() состоят из трех частей, которые записываются следующим образом: scale_AESTHETIC_METHOD()..\n\nПервая часть, scale_(), является фиксированной.\n\nВторая часть, ЭСТЕТИКА, должна быть эстетикой, для которой вы хотите настроить масштаб (_fill_, _shape_, _color_, _size_, _alpha_…) - опции здесь также включают _x_ и _y_.\n\nТретья часть, МЕТОД, будет либо _discrete(), continuous(), _date(), _gradient(), либо _manual() в зависимости от класса столбца и того, как вы хотите им управлять. Существуют и другие, но эти наиболее часто используемые.\n\nУбедитесь, что вы используете правильную функцию для шкалы! В противном случае окажется, что команда изменения шкалы ничего не меняет. Если у вас несколько шкал, то для их настройки можно использовать несколько функций шкалы! Например:\n\n\nАргументы шкалы\nКаждый вид шкалы имеет свои аргументы, хотя они частично совпадают. Запросите функцию типа ?scale_color_discrete в консоли R, чтобы увидеть документацию по аргументам функции.\nДля непрерывных шкал используйте breaks = и задайте последовательность значений с помощью seq() (возьмите to =, from = и by =, как показано в примере ниже. Установите expand = c(0,0), чтобы удалить наращивание пробелов вокруг осей (это может быть использовано для любой шкалы _x_ или _y_.\nДля дискретных шкал можно настроить порядок появления уровней с помощью аргумента breaks =, а также порядок отображения значений с помощью аргумента labels =. Каждому из них присвойте символьный вектор (см. пример ниже). Также можно легко отказаться от NA, задав na.translate = FALSE.\nБолее подробно о тонкостях шкал дат рассказано на странице [Эпидемические кривые].\n\n\nРучные настройки\nОдним из наиболее полезных приемов является использование функций ” Ручной” настройки шкалы для прямого назначения цветов по своему усмотрению. Это функции с синтаксисом scale_xxx_manual() (например, scale_colour_manual() или scale_fill_manual()). Каждый из перечисленных ниже аргументов демонстрируется в приведенном ниже примере кода.\n\nНазначьте цвета значениям данных с помощью аргумента values =.\n\nЗадайте цвет для NA с помощью аргумента na.value =.\n\nИзмените то, как значения будут записаны в легенде с помощью аргумента labels =.\n\nИзмените название легенды с помощью аргумента name =. `\n\nНиже мы создадим столбчатую диаграмму и покажем, как она выглядит по умолчанию, а затем настроим три шкалы - непрерывную по оси y, дискретную по оси x и ручную настройку заливки (цвета внутреннего столбца).\n\n# Исходная ситуация - без настройки шкалы\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = outcome, fill = gender))+\n  labs(title = \"Baseline - no scale adjustments\")\n\n\n\n\n\n\n\n# НАСТРОЙКА ШКАЛЫ\nggplot(data = linelist)+\n  \n  geom_bar(mapping = aes(x = outcome, fill = gender), color = \"black\")+\n  \n  theme_minimal()+                   # упростить фон\n  \n  scale_y_continuous(                # непрерывная шкала для оси y (количество)\n    expand = c(0,0),                 # без наращивания\n    breaks = seq(from = 0,\n                 to = 3000,\n                 by = 500))+\n  \n  scale_x_discrete(                   # дискретная шкала для оси x (пол)\n    expand = c(0,0),                  # без наращивания\n    drop = FALSE,                     # показать все уровни факторов (даже если их нет в данных)\n    na.translate = FALSE,             # удалить исходы NA из графика\n    labels = c(\"Died\", \"Recovered\"))+ # Изменение отображения значений\n    \n  \n  scale_fill_manual(                  # Вручную задать заливку (внутренний цвет столбика)\n    values = c(\"m\" = \"violetred\",     # референсные значения в данных для присвоения цветов\n               \"f\" = \"aquamarine\"),\n    labels = c(\"m\" = \"Male\",          # Изменить метки в легенде (во избежание ошибок используйте присваивание \"=\")\n              \"f\" = \"Female\",\n              \"Missing\"),\n    name = \"Gender\",                  # заголовок легенды\n    na.value = \"grey\"                 # назначение цвета для отсутствующего значенияs\n  )+\n  labs(title = \"Adjustment of scales\") # Настройка заголовка легенды заливки\n\n\n\n\n\n\n\n\n\n\nШкалы непрерывных осей\nКогда данные сопоставляются с осями графика, они также могут быть настроены с помощью команд шкал. Частым примером является настройка отображения оси (например, оси y), которая сопоставлена столбцу с непрерывными данными.\nМы можем захотеть настроить разрывы или отображение значений в ggplot, используя команду scale_y_continuous(). Как отмечалось выше, с помощью аргумента breaks = можно задать последовательность значений, которые будут служить ” разрывами” вдоль шкалы. Это те значения, при которых будут отображаться числа. В качестве аргумента можно указать вектор c(), содержащий желаемые значения разрывов, либо задать обычную последовательность чисел с помощью базовой функции R seq(). Эта функция seq() принимает значения to =, from = и by =.\n\n# Исходная ситуация - без настройки шкалы\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = outcome, fill = gender))+\n  labs(title = \"Baseline - no scale adjustments\")\n\n# \nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = outcome, fill = gender))+\n  scale_y_continuous(\n    breaks = seq(\n      from = 0,\n      to = 3000,\n      by = 100)\n  )+\n  labs(title = \"Adjusted y-axis breaks\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nОтображение процентов\nЕсли исходные значения данных представляют собой пропорции, то их можно легко отобразить в виде процентов с помощью “%”, указав в команде шкалы labels = scales::percent, как показано ниже.\nАльтернативным вариантом может быть преобразование значений в символы и добавление в конце символа “%”, однако такой подход приведет к осложнениям, поскольку данные перестанут быть непрерывными числовыми значениями.\n\n# Исходные пропорции оси y\n#############################\nlinelist %&gt;%                                   # начать с построчного списка\n  group_by(hospital) %&gt;%                       # сгруппировать данные по больницамl\n  summarise(                                   # создать сводные столбцы\n    n = n(),                                     # общее количество строк в группе\n    deaths = sum(outcome == \"Death\", na.rm=T),   # количество смертельных исходов в группе\n    prop_death = deaths/n) %&gt;%                   # доля смертельных исходов в группе\n  ggplot(                                      # начать построение графика\n    mapping = aes(\n      x = hospital,\n      y = prop_death))+ \n  geom_col()+\n  theme_minimal()+\n  labs(title = \"Display y-axis original proportions\")\n\n\n\n# Отображение пропорций оси y в виде процентов\n########################################\nlinelist %&gt;%         \n  group_by(hospital) %&gt;% \n  summarise(\n    n = n(),\n    deaths = sum(outcome == \"Death\", na.rm=T),\n    prop_death = deaths/n) %&gt;% \n  ggplot(\n    mapping = aes(\n      x = hospital,\n      y = prop_death))+\n  geom_col()+\n  theme_minimal()+\n  labs(title = \"Display y-axis as percents (%)\")+\n  scale_y_continuous(\n    labels = scales::percent                    # отображать пропорции в виде процентов\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЛогарифмическая шкала\nЧтобы преобразовать непрерывную ось в логарифмическую шкалу, добавьте к команде шкалы команду trans = \"log2\". Для примера создадим датафрейм регионов с соответствующими значениями preparedness_index и кумулятивных случаев.\n\nplot_data &lt;- data.frame(\n  region = c(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\"),\n  preparedness_index = c(8.8, 7.5, 3.4, 3.6, 2.1, 7.9, 7.0, 5.6, 1.0),\n  cases_cumulative = c(15, 45, 80, 20, 21, 7, 51, 30, 1442)\n)\n\nplot_data\n\n  region preparedness_index cases_cumulative\n1      A                8.8               15\n2      B                7.5               45\n3      C                3.4               80\n4      D                3.6               20\n5      E                2.1               21\n6      F                7.9                7\n7      G                7.0               51\n8      H                5.6               30\n9      I                1.0             1442\n\n\nКумулятивное число случаев в регионе “I” значительно превышает число случаев во всех других регионах. В подобных случаях можно использовать логарифмическую шкалу для отображения оси y, чтобы читатель мог увидеть различия между регионами с меньшим числом случаев.\n\n# Исходная ось y\npreparedness_plot &lt;- ggplot(data = plot_data,  \n       mapping = aes(\n         x = preparedness_index,\n         y = cases_cumulative))+\n  geom_point(size = 2)+            # точки для каждого региона \n  geom_text(\n    mapping = aes(label = region),\n    vjust = 1.5)+                  # добавление текстовых меток\n  theme_minimal()\n\npreparedness_plot                  # печать исходного графика\n\n\n# печать с преобразованием оси y\npreparedness_plot+                   # начать с графика, сохраненного выше\n  scale_y_continuous(trans = \"log2\") # добавить преобразование для оси y\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nГрадиентные шкалы\nШкалы градиента заливки могут иметь дополнительные нюансы. Как правило, значения по умолчанию вполне приемлемы, но вы можете захотеть подкорректировать значения, отсечения и т.д.\nДля демонстрации настройки непрерывной цветовой шкалы мы воспользуемся набором данных со страницы [Отслеживание контактов], содержащим возраст случаев и их источников.\n\ncase_source_relationships &lt;- rio::import(here::here(\"data\", \"godata\", \"relationships_clean.rds\")) %&gt;% \n  select(source_age, target_age) \n\nНиже мы построим “растровый” график плотности тепловой плитки. Мы не будем подробно описывать, как это делается (см. ссылку в абзаце выше), а остановимся на том, как можно настроить цветовую шкалу. Подробнее о функции stat_density2d() ggplot2 можно прочитать здесь. Обратите внимание, что шкала fill является непрерывной.\n\ntrans_matrix &lt;- ggplot(\n    data = case_source_relationships,\n    mapping = aes(x = source_age, y = target_age))+\n  stat_density2d(\n    geom = \"raster\",\n    mapping = aes(fill = after_stat(density)),\n    contour = FALSE)+\n  theme_minimal()\n\nТеперь мы покажем некоторые вариации шкалы заливки:\n\ntrans_matrix\ntrans_matrix + scale_fill_viridis_c(option = \"plasma\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nТеперь мы покажем несколько примеров настройки точек излома шкалы:\n\nscale_fill_gradient() принимает два цвета (high/low)\n\nscale_fill_gradientn() принимает вектор цветов произвольной длины values = (промежуточные значения будут интерполированы)\n\nИспользуйте scales::rescale() для настройки расположения цветов вдоль градиента; она изменяет вектор позиций на значения от 0 до 1.\n\n\ntrans_matrix + \n  scale_fill_gradient(     # Двусторонняя градиентная шкала\n    low = \"aquamarine\",    # низкое значение\n    high = \"purple\",       # высокое значение\n    na.value = \"grey\",     # значение для NA\n    name = \"Density\")+     # Заголовок легенды\n  labs(title = \"Manually specify high/low colors\")\n\n# 3+ цвета в шкале\ntrans_matrix + \n  scale_fill_gradientn(    # 3-цветная шкала (низкий/средний/высокий уровень)\n    colors = c(\"blue\", \"yellow\",\"red\") # предоставить цвета в векторе\n  )+\n  labs(title = \"3-color scale\")\n\n# Использование функции rescale() для изменения расположения цветов по шкале\ntrans_matrix + \n  scale_fill_gradientn(    # задать любое количество цветов\n    colors = c(\"blue\", \"yellow\",\"red\", \"black\"),\n    values = scales::rescale(c(0, 0.05, 0.07, 0.10, 0.15, 0.20, 0.3, 0.5)) #позиции цветов изменяются в диапазоне от 0 до 1\n    )+\n  labs(title = \"Colors not evenly positioned\")\n\n# использование ограничений для отсечения значений, получающих цвет заливки\ntrans_matrix + \n  scale_fill_gradientn(    \n    colors = c(\"blue\", \"yellow\",\"red\"),\n    limits = c(0, 0.0002))+\n  labs(title = \"Restrict value limits, resulting in grey space\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЦветовые палитры\n\nColorbrewer и Viridis\nВ целом, если вам нужны предопределенные палитры, вы можете использовать функции scale_xxx_brewer или scale_xxx_viridis_y.\nФункции ‘brewer’ могут рисовать из палитр colorbrewer.org.\nФункции “viridis” основаны на палитрах “viridis” (с учетом особенностей зрения людей, не различающих цвета!), которые “обеспечивают цветовые карты, воспринимаемые одинаково как в цветном, так и в черно-белом варианте. Они также рассчитаны на восприятие пользователями с распространенными формами дальтонизма”. (подробнее здесь и здесь). Определите, является ли палитра дискретной, непрерывной или сгруппированной, указав это в конце функции (например, дискретная - scale_xxx_viridis_d).\nРекомендуется протестировать свой график в этом симуляторе цветовой слепоты. Если у вас красная/зеленая цветовая схема, попробуйте вместо нее использовать схему “горячий-холодный” (красно-синий), как описано здесь.\nВот пример со страницы [Основы ggplot] с использованием различных цветовых схем.\n\nsymp_plot &lt;- linelist %&gt;%                                         # начать с построчного списка\n  select(c(case_id, fever, chills, cough, aches, vomit)) %&gt;%     # выбрать столбцы\n  pivot_longer(                                                  # повернуть вдлину \n    cols = -case_id,                                  \n    names_to = \"symptom_name\",\n    values_to = \"symptom_is_present\") %&gt;%\n  mutate(                                                        # заменить отсутствующие значения\n    symptom_is_present = replace_na(symptom_is_present, \"unknown\")) %&gt;% \n  ggplot(                                                        # начать ggplot!\n    mapping = aes(x = symptom_name, fill = symptom_is_present))+\n  geom_bar(position = \"fill\", col = \"black\") +                    \n  theme_classic() +\n  theme(legend.position = \"bottom\")+\n  labs(\n    x = \"Symptom\",\n    y = \"Symptom status (proportion)\"\n  )\n\nsymp_plot  # печать с цветами по умолчанию\n\n#################################\n# печать с заданными вручную цветами\nsymp_plot +\n  scale_fill_manual(\n    values = c(\"yes\" = \"black\",         # четко определить цвета\n               \"no\" = \"white\",\n               \"unknown\" = \"grey\"),\n    breaks = c(\"yes\", \"no\", \"unknown\"), # правильно упорядочить факторы\n    name = \"\"                           # задать легенду без заголовка\n\n  ) \n\n#################################\n# печать дискретными цветами viridis\nsymp_plot +\n  scale_fill_viridis_d(\n    breaks = c(\"yes\", \"no\", \"unknown\"),\n    name = \"\"\n  )",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Советы по использованию ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.ru.html#изменение-порядка-дискретных-переменных",
    "href": "new_pages/ggplot_tips.ru.html#изменение-порядка-дискретных-переменных",
    "title": "31  Советы по использованию ggplot",
    "section": "31.3 Изменение порядка дискретных переменных",
    "text": "31.3 Изменение порядка дискретных переменных\nИзменение порядка отображения дискретных переменных часто бывает трудно понять тем, кто впервые знакомится с графиками ggplot2. Однако понять, как это сделать, несложно, если разобраться в том, как ggplot2 работает с дискретными переменными. Вообще говоря, если используется дискретная переменная, то она автоматически преобразуется в тип фактор (factor), который по умолчанию упорядочивает факторы в алфавитном порядке. Чтобы справиться с этим, необходимо просто перестроить уровни факторов в соответствии с тем порядком, в котором они должны отображаться на графике. Более подробная информация о том, как переупорядочивать объекты типа factor, приведена в разделе руководства, посвященном факторам.\nМы можем рассмотреть распространенный пример с возрастными группами - по умолчанию возрастная группа 5-9 лет будет располагаться в середине возрастных групп (в алфавитно-цифровом порядке), но мы можем переместить ее за возрастную группу 0-4 на диаграмме, переупорядочив факторы.\n\nggplot(\n  data = linelist %&gt;% drop_na(age_cat5),                         # удалить строки, в которых отсутствует age_cat5\n  mapping = aes(x = fct_relevel(age_cat5, \"5-9\", after = 1))) +  # заново задать уровень фактора\n\n  geom_bar() +\n  \n  labs(x = \"Age group\", y = \"Number of hospitalisations\",\n       title = \"Total hospitalisations by age group\") +\n  \n  theme_minimal()\n\n\n\n\n\n\n\n\n\n31.3.0.1 ggthemr\nТакже можно рассмотреть возможность использования пакета ggthemr. Вы можете загрузить этот пакет с Github, используя инструкции здесь. Он предлагает очень эстетичные палитры, однако следует учитывать, что они обычно имеют максимальное количество значений, которое может быть ограничено, если вам нужно более 7 или 8 цветов.",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Советы по использованию ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.ru.html#контурные-линии",
    "href": "new_pages/ggplot_tips.ru.html#контурные-линии",
    "title": "31  Советы по использованию ggplot",
    "section": "31.4 Контурные линии",
    "text": "31.4 Контурные линии\nКонтурные графики полезны при наличии большого количества точек, которые могут перекрывать друг друга (“наложение”). На примере исходных данных, использованных выше, снова строятся контурные графики, но более просто, с использованием stat_density2d() и stat_density2d_filled() для получения дискретных контурных уровней - как на топографической карте. Подробнее о статистике можно прочитать [здесь] (https://ggplot2.tidyverse.org/reference/geom_density_2d.html).\n\ncase_source_relationships %&gt;% \n  ggplot(aes(x = source_age, y = target_age))+\n  stat_density2d()+\n  geom_point()+\n  theme_minimal()+\n  labs(title = \"stat_density2d() + geom_point()\")\n\n\ncase_source_relationships %&gt;% \n  ggplot(aes(x = source_age, y = target_age))+\n  stat_density2d_filled()+\n  theme_minimal()+\n  labs(title = \"stat_density2d_filled()\")",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Советы по использованию ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.ru.html#предельные-распределения",
    "href": "new_pages/ggplot_tips.ru.html#предельные-распределения",
    "title": "31  Советы по использованию ggplot",
    "section": "31.5 Предельные распределения",
    "text": "31.5 Предельные распределения\nДля отображения распределений на краях графика рассеивания geom_point() можно использовать пакет ggExtra и его функцию ggMarginal(). Сохраните исходный ggplot как объект, а затем передайте его в ggMarginal(), как показано ниже. Вот основные аргументы:\n\nВы должны указать type = как ” гистограмма”, “плотность” “коробчатая диаграмма”, ” скрипичная диаграмма” или “денсиграмма”.\n\nПо умолчанию для обеих осей отображаются предельные графики. Вы можете установить margins = в значение “x” или “y”, если вам нужна только одна ось.\n\nДругие аргументы по выбору: fill = (цвет столбиков), color = (цвет линий), Size = (размер графика относительно размера полей, поэтому большее число делает предельный график меньше).\n\nВ качестве аргументов xparams = и yparams = можно указывать другие аргументы, специфичные для конкретной оси. Например, чтобы иметь различные размеры корзин гистограммы, как показано ниже.\n\nВы можете сделать так, чтобы предельные графики отражали группы (столбцы, которым присвоен color = в эстетике отображения ggplot()). В этом случае установите аргумент ggMarginal() groupColour = или groupFill = в TRUE, как показано ниже.\nПодробнее можно прочитать в разделе Эта виньетка, в галерее галерея R Graph или в документации по функции R ?ggMarginal.\n\n# Установка/загрузка ggExtra\npacman::p_load(ggExtra)\n\n# Базовая диаграмма рассеивания веса и возраста\nscatter_plot &lt;- ggplot(data = linelist)+\n  geom_point(mapping = aes(y = wt_kg, x = age)) +\n  labs(title = \"Scatter plot of weight and age\")\n\nДля добавления предельных гистограмм используйте type = \"histogram\". Опционально можно задать groupFill = TRUE для получения сложенных гистограмм.\n\n# с гистограммами\nggMarginal(\n  scatter_plot,                     # добавить предельные гистограммы\n  type = \"histogram\",               # указать гистограммы\n  fill = \"lightblue\",               # заливка столбика\n  xparams = list(binwidth = 10),    # другие параметры для предельных значений по оси x\n  yparams = list(binwidth = 5))     # другие параметры для предельных значений по оси у\n\n\n\n\n\n\n\n\nГрафик предельной плотности с группированными/цветными значениями:\n\n# График рассеивания, окрашенный по исходам\n# Столбец исходов назначается цветом в ggplot. Значение groupFill в ggMarginal установлено как TRUE.\nscatter_plot_color &lt;- ggplot(data = linelist %&gt;% drop_na(gender))+\n  geom_point(mapping = aes(y = wt_kg, x = age, color = gender)) +\n  labs(title = \"Scatter plot of weight and age\")+\n  theme(legend.position = \"bottom\")\n\nggMarginal(scatter_plot_color, type = \"density\", groupFill = TRUE)\n\n\n\n\n\n\n\n\nЗадайте аргумент size = для настройки относительного размера предельного графика. Меньшее число делает предельный график более крупным. Также можно задать color =. Ниже показан предельная коробчатая диаграмма, с демонстрацией аргумента margins =, чтобы она отображалась только на одной оси:\n\n# с коробчатой диаграммой \nggMarginal(\n  scatter_plot,\n  margins = \"x\",      # показывать только предельный график по оси x\n  type = \"boxplot\")",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Советы по использованию ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.ru.html#умное-наложение-меток",
    "href": "new_pages/ggplot_tips.ru.html#умное-наложение-меток",
    "title": "31  Советы по использованию ggplot",
    "section": "31.6 Умное наложение меток",
    "text": "31.6 Умное наложение меток\nВ ggplot2 также возможно добавление текста на графики. Однако при этом возникает заметное ограничение: текстовые метки часто смешиваются с точками данных на графике, в результате чего они выглядят неаккуратно или плохо читаются. Идеального способа решения этой проблемы в базовом пакете нет, но существует дополнение ggplot2, известное как ggrepel, которое позволяет решить эту проблему очень просто!\nПакет ggrepel предлагает две новые функции, geom_label_repel() и geom_text_repel(), которые заменяют geom_label() и geom_text(). Просто используйте эти функции вместо базовых для получения аккуратных меток. Внутри функции, как обычно, используйте эстетику aes(), но включите аргумент label =, в котором укажите имя столбца, содержащего значения, которые вы хотите отобразить (например, идентификатор пациента, или имя, и т.д.). Можно создавать более сложные метки, комбинируя столбцы и новые строки (\\n) в str_glue(), как показано ниже.\nНесколько советов:\n\nИспользуйте min.segment.length = 0, чтобы всегда рисовать сегменты линий, или min.segment.length = Inf, чтобы никогда их не рисовать\n\nДля задания размера текста используйте `size = outside of aes().\n\nИспользуйте force = для изменения степени отталкивания между метками и соответствующими им точками (по умолчанию 1)\n\nИспользуйте fill = outside of aes() для окрашивания метки по значению.\n\nВ легенде может появиться буква “a” - добавьте guides(fill = guide_legend(override.aes = aes(color = NA)))+ для ее удаления\n\n\nПодробнее об этом смотрите в этом подробном руководстве Обучение.\n\npacman::p_load(ggrepel)\n\nlinelist %&gt;%                                               # начать с построчного списка\n  group_by(hospital) %&gt;%                                   # сгруппировать по больницам\n  summarise(                                               # сформировать новый набор данных с сводными значениями по каждой больнице\n    n_cases = n(),                                           # количество случаев на одну больницу\n    delay_mean = round(mean(days_onset_hosp, na.rm=T),1),    # средняя задержка по больнице\n  ) %&gt;% \n  ggplot(mapping = aes(x = n_cases, y = delay_mean))+      # передать датафрейм в ggplot\n  geom_point(size = 2)+                                    # добавить точки\n  geom_label_repel(                                        # добавить метки точек\n    mapping = aes(\n      label = stringr::str_glue(\n        \"{hospital}\\n{n_cases} cases, {delay_mean} days\")  # как отображаются метки\n      ), \n    size = 3,                                              # размер текста в метках\n    min.segment.length = 0)+                               # показать все сегменты линии               \n  labs(                                                    # добавить метки осей\n    title = \"Mean delay to admission, by hospital\",\n    x = \"Number of cases\",\n    y = \"Mean delay (days)\")\n\n\n\n\n\n\n\n\nВы можете пометить только подмножество точек данных - используя стандартный синтаксис ggplot(), чтобы обеспечить различные data = для каждого geom слоя графика. Ниже показаны все случаи, но помечены только некоторые из них.\n\nggplot()+\n  # Все точки выделены серым цветом\n  geom_point(\n    data = linelist,                                   # все данные, представленные в этом слое\n    mapping = aes(x = ht_cm, y = wt_kg),\n    color = \"grey\",\n    alpha = 0.5)+                                              # серый и полупрозрачный\n  \n  # Few points in black\n  geom_point(\n    data = linelist %&gt;% filter(days_onset_hosp &gt; 15),  # фильтрованные данные, поступающие в этот слой\n    mapping = aes(x = ht_cm, y = wt_kg),\n    alpha = 1)+                                                # по умолчанию черный и не прозрачный\n  \n  # point labels for few points\n  geom_label_repel(\n    data = linelist %&gt;% filter(days_onset_hosp &gt; 15),  # отфильтровать данные для меток\n    mapping = aes(\n      x = ht_cm,\n      y = wt_kg,\n      fill = outcome,                                          # обозначение цвета метками в зависимости от исхода\n      label = stringr::str_glue(\"Delay: {days_onset_hosp}d\")), # метка, созданная с помощью функции str_glue()\n    min.segment.length = 0) +                                  # показать сегменты линий для всех\n  \n  # убрать букву \"a\" из внутренних полей легенды\n  guides(fill = guide_legend(override.aes = aes(color = NA)))+\n  \n  # метки осей\n  labs(\n    title = \"Cases with long delay to admission\",\n    y = \"weight (kg)\",\n    x = \"height(cm)\")",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Советы по использованию ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.ru.html#оси-времени",
    "href": "new_pages/ggplot_tips.ru.html#оси-времени",
    "title": "31  Советы по использованию ggplot",
    "section": "31.7 Оси времени",
    "text": "31.7 Оси времени\nРабота с осями времени в ggplot может показаться сложной, но она очень проста благодаря нескольким ключевым функциям. Помните, что при работе с временем или датой необходимо убедиться, что нужные переменные отформатированы как класс дата или дата-время - примеры см. на странице [Работа с датами], а также на странице [Эпидемические кривые] (раздел ggplot).\nНаиболее полезным набором функций для работы с датами в ggplot2 являются функции шкал (scale_x_date(), scale_x_datetime() и родственные им функции оси y). Эти функции позволяют определить частоту появления меток осей и способ форматирования меток осей. Чтобы узнать, как форматировать даты, обратитесь к разделу working with dates! С помощью аргументов date_breaks и date_labels можно указать, как должны выглядеть даты:\n\ndate_breaks позволяет указать, как часто происходят разрывы оси - здесь можно указать последовательность (например, \"3 месяца\" или \"2 дня\")\ndate_labels позволяет определить формат отображения дат. В эти аргументы можно передать строку формата даты (например, \"%b-%d-%Y\"):\n\n\n# построить эпидемическую кривую по дате начала заболевания, если это возможно\nggplot(linelist, aes(x = date_onset)) +\n  geom_histogram(binwidth = 7) +\n  scale_x_date(\n    # 1 разрыв каждый 1 месяц\n    date_breaks = \"1 months\",\n    # На метках должен отображаться месяц, а затем дата\n    date_labels = \"%b %d\"\n  ) +\n  theme_classic()\n\n\n\n\n\n\n\n\nОдним из простых решений для получения эффективных меток даты на оси x является присвоение аргумента labels = в scale_x_date() функции label_date_short() из пакета scales. Эта функция автоматически построит эффективные метки даты (подробнее здесь). Дополнительным преимуществом этой функции является то, что метки будут автоматически корректироваться по мере увеличения объема данных во времени: от дней, недель, месяцев и лет.\nПолный пример можно посмотреть в разделе страницы Эпидемические кривые, посвященном вопросу многоуровневые метки дат, а для справки ниже приведен краткий пример:\n\nggplot(linelist, aes(x = date_onset)) +\n  geom_histogram(binwidth = 7) +\n  scale_x_date(\n    labels = scales::label_date_short()  # автоматически эффективные метки даты\n  )+\n  theme_classic()",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Советы по использованию ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.ru.html#выделение",
    "href": "new_pages/ggplot_tips.ru.html#выделение",
    "title": "31  Советы по использованию ggplot",
    "section": "31.8 Выделение",
    "text": "31.8 Выделение\nВыделение определенных элементов на графике - полезный способ привлечь внимание к конкретному элементу переменной и одновременно предоставить информацию о дисперсии всего набора данных. Хотя это нелегко сделать в базовом ggplot2, существует внешний пакет gghighlight, который может помочь в этом. Его легко использовать в рамках синтаксиса ggplot.\nДля достижения этого эффекта пакет gghighlight использует функцию gghighlight(). Для использования этой функции необходимо задать ей логический оператор - это может привести к довольно гибким результатам, но здесь мы покажем пример распределения случаев по возрасту в нашем построчном списке, выделив их по исходу.\n\n# загрузка gghighlight\nlibrary(gghighlight)\n\n# заменить значения NA на неизвестные в переменной исхода\nlinelist &lt;- linelist %&gt;%\n  mutate(outcome = replace_na(outcome, \"Unknown\"))\n\n# построить гистограмму всех случаев по возрасту\nggplot(\n  data = linelist,\n  mapping = aes(x = age_years, fill = outcome)) +\n  geom_histogram() + \n  gghighlight::gghighlight(outcome == \"Death\")     # выделить случаи, когда пациент умер\n\n\n\n\n\n\n\n\nЭто также хорошо работает с функциями фасетирования - позволяет строить графики фасетов с выделением фоновых данных, не относящихся к фасету! Ниже приведен подсчет случаев заболевания по неделям и построение эпидемических кривых по больницам (color = и facet_wrap() установлен на столбец hospital).\n\n# построить гистограмму всех случаев по возрасту\nlinelist %&gt;% \n  count(week = lubridate::floor_date(date_hospitalisation, \"week\"),\n        hospital) %&gt;% \n  ggplot()+\n  geom_line(aes(x = week, y = n, color = hospital))+\n  theme_minimal()+\n  gghighlight::gghighlight() +                      # выделить случаи, когда пациент умер\n  facet_wrap(~hospital)                              # создавать фасеты по исходам",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Советы по использованию ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.ru.html#построение-графиков-для-нескольких-наборов-данных",
    "href": "new_pages/ggplot_tips.ru.html#построение-графиков-для-нескольких-наборов-данных",
    "title": "31  Советы по использованию ggplot",
    "section": "31.9 Построение графиков для нескольких наборов данных",
    "text": "31.9 Построение графиков для нескольких наборов данных\nОбратите внимание на то, что правильное выравнивание осей для построения графиков из нескольких наборов данных в одном графике может быть затруднено. Рассмотрим одну из следующих стратегий:\n\nОбъединить данные перед построением графика и преобразовать их в “длинный” формат со столбцом, отражающим набор данных\n\nИспользовать cowplot или аналогичный пакет для объединения двух графиков (см. ниже)",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Советы по использованию ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.ru.html#объединение-графиков",
    "href": "new_pages/ggplot_tips.ru.html#объединение-графиков",
    "title": "31  Советы по использованию ggplot",
    "section": "31.10 Объединение графиков",
    "text": "31.10 Объединение графиков\nДва пакета, которые очень полезны для объединения графиков, - это cowplot и patchwork. На этой странице мы будем рассматривать в основном cowplot, изредка используя patchwork.\nЗдесь находится онлайн введение в cowplot. Более подробную документацию по каждой функции можно прочитать здесь. Ниже мы рассмотрим несколько наиболее распространенных вариантов использования и функций.\nПакет cowplot работает в паре с ggplot2 - по сути, с его помощью вы упорядочиваете и объединяете ggplots и их легенды в составные фигуры. Он также может работать с базовыми графиками R.\n\npacman::p_load(\n  tidyverse,      # работа с данными и их визуализация\n  cowplot,        # объединение графиков\n  patchwork       # объединение графиков\n)\n\nХотя фасет (описанный на странице [Основы ggplot]) является удобным подходом к построению графиков, иногда невозможно получить желаемые результаты с помощью его относительно ограниченного подхода. В этом случае можно объединить графики, склеив их в более крупный график. Есть три известных пакета, которые отлично подходят для этого - cowplot, gridExtra и patchwork. Однако эти пакеты выполняют в основном одни и те же задачи, поэтому в данном разделе мы остановимся на cowplot.\n\nplot_grid()\nПакет cowplot имеет достаточно широкий набор функций, но наиболее простое его использование достигается с помощью plot_grid(). Фактически это способ расположить предопределенные графики в виде сетки. Мы можем рассмотреть еще один пример с набором данных по малярии - здесь мы можем построить график общего количества случаев заболевания по районам, а также показать эпидемическую кривую в динамике.\n\nmalaria_data &lt;- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\")) \n\n# столбчатая диаграмма общего количества случаев по районам\np1 &lt;- ggplot(malaria_data, aes(x = District, y = malaria_tot)) +\n  geom_bar(stat = \"identity\") +\n  labs(\n    x = \"District\",\n    y = \"Total number of cases\",\n    title = \"Total malaria cases by district\"\n  ) +\n  theme_minimal()\n\n# эпидемическая кривая во времени\np2 &lt;- ggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1) +\n  labs(\n    x = \"Date of data submission\",\n    y =  \"number of cases\"\n  ) +\n  theme_minimal()\n\ncowplot::plot_grid(p1, p2,\n                  # 1 столбец и две строки - уложенные друг на друга\n                   ncol = 1,\n                   nrow = 2,\n                   # верхний график на 2/3 выше второго\n                   rel_heights = c(2, 3))\n\n\n\n\n\n\n\n\n\n\nОбъединение легенд\nЕсли графики имеют одинаковую легенду, их объединение не представляет сложности. Достаточно использовать описанный выше подход cowplot для объединения графиков, но при этом удалить легенду одного из них (удалить дублирование).\nЕсли же графики имеют разные легенды, то необходимо использовать альтернативный подход:\n\nСоздайте и сохраните графики без легенд, используя theme(legend.position = \"none\").\n\nИзвлеките легенды из каждого графика, используя get_legend(), как показано ниже - но извлекайте легенды из графиков, видоизмененных так, чтобы они действительно показывали легенду.\n\nОбъедините легенды в панель легенд\n\nОбъединить графики и панель легенд\n\nДля демонстрации мы показываем два графика отдельно, а затем располагаем их в сетке с указанием собственных легенд (некрасивое и неэффективное использование пространства):\n\np1 &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %&gt;% \n  count(hospital, outcome) %&gt;% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+\n  scale_fill_brewer(type = \"qual\", palette = 4, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  labs(title = \"Cases by outcome\")\n\n\np2 &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %&gt;% \n  count(hospital, age_cat) %&gt;% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+\n  scale_fill_brewer(type = \"qual\", palette = 1, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  theme(axis.text.y = element_blank())+\n  labs(title = \"Cases by age\")\n\nВот как выглядят два графика при их объединении с помощью plot_grid() без объединения легенд:\n\ncowplot::plot_grid(p1, p2, rel_widths = c(0.3))\n\n\n\n\n\n\n\n\nА теперь покажем, как объединить легенды. По сути, мы определяем каждый график без легенды (theme(legend.position = \"none\")), а затем определяем легенду каждого графика отдельно, используя функцию get_legend() из cowplot. Когда мы извлекаем легенду из сохраненного графика, нам необходимо добавить + легенду обратно, включая указание размещения (““справа”“) и небольшие корректировки для выравнивания легенд и их заголовков. Затем мы объединяем легенды по вертикали, а затем объединяем два графика с объединенными легендами. Вуаля!\n\n# Определить график 1 без легенды\np1 &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %&gt;% \n  count(hospital, outcome) %&gt;% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+\n  scale_fill_brewer(type = \"qual\", palette = 4, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  theme(legend.position = \"none\")+\n  labs(title = \"Cases by outcome\")\n\n\n# Определить график 2 без легенды\np2 &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %&gt;% \n  count(hospital, age_cat) %&gt;% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+\n  scale_fill_brewer(type = \"qual\", palette = 1, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  theme(\n    legend.position = \"none\",\n    axis.text.y = element_blank(),\n    axis.title.y = element_blank()\n  )+\n  labs(title = \"Cases by age\")\n\n\n# извлечение легенды из гр1 (из гр1 + легенда)\nleg_p1 &lt;- cowplot::get_legend(p1 +\n                                theme(legend.position = \"right\",        # извлечение вертикальной легенды\n                                      legend.justification = c(0,0.5))+ # легенды должны быть выровнены\n                                labs(fill = \"Outcome\"))                 # заголовок легенды\n# извлечение легенды из гр2 (из гр2 + легенда)\nleg_p2 &lt;- cowplot::get_legend(p2 + \n                                theme(legend.position = \"right\",         # извлечение вертикальной легенды   \n                                      legend.justification = c(0,0.5))+  # легенды должны быть выровнены\n                                labs(fill = \"Age Category\"))             # заголовок легенды\n\n# создание пустого графика для выравнивания легенды\n#blank_p &lt;- patchwork::plot_spacer() + theme_void()\n\n# создание панелей легенд, которые могут располагаться одна на другой (или использовать разделитель, о котором говорилось выше)\nlegends &lt;- cowplot::plot_grid(leg_p1, leg_p2, nrow = 2, rel_heights = c(.3, .7))\n\n# объединение двух графиков и панели объединенных легенд\ncombined &lt;- cowplot::plot_grid(p1, p2, legends, ncol = 3, rel_widths = c(.4, .4, .2))\n\ncombined  # печать\n\n\n\n\n\n\n\n\nЭто решение было взято из этого сообщения с небольшим исправлением выравнивания легенд из этого сообщения.\nСОВЕТ: Интересный факт - ““cow”” в cowplot происходит от имени создателя - Claus O. Wilke.\n\n\nВставные графики\nС помощью cowplot можно вставить один график в другой. При этом следует обратить внимание на следующие моменты:\n\nОпределите основной график с помощью theme_half_open() из cowplot; возможно, будет лучше, если легенда будет располагаться сверху или снизу\n\nОпределить вставной график. Лучше всего иметь график, где легенда не нужна. Элементы темы графика можно удалить с помощью element_blank(), как показано ниже.\n\nОбъедините их, применив функцию ggdraw() к основному графику, затем добавьте draw_plot() на вставной график и укажите координаты (x и y левого нижнего угла), высоту и ширину в пропорции ко всему основному графику.\n\n\n# Определить основной график\nmain_plot &lt;- ggplot(data = linelist)+\n  geom_histogram(aes(x = date_onset, fill = hospital))+\n  scale_fill_brewer(type = \"qual\", palette = 1, na.value = \"grey\")+ \n  theme_half_open()+\n  theme(legend.position = \"bottom\")+\n  labs(title = \"Epidemic curve and outcomes by hospital\")\n\n\n# Определить вставной график\ninset_plot &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %&gt;% \n  count(hospital, outcome) %&gt;% \n  ggplot()+\n    geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+\n    scale_fill_brewer(type = \"qual\", palette = 4, na.value = \"grey\")+\n    coord_flip()+\n    theme_minimal()+\n    theme(legend.position = \"none\",\n          axis.title.y = element_blank())+\n    labs(title = \"Cases by outcome\") \n\n\n# Объединить основной график и вставной\ncowplot::ggdraw(main_plot)+\n     draw_plot(inset_plot,\n               x = .6, y = .55,    #x = .07, y = .65,\n               width = .4, height = .4)\n\n\n\n\n\n\n\n\nБолее подробно этот метод объясняется в этих двух виньетках:\nWilke lab\nдокументация по функции draw_plot()",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Советы по использованию ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.ru.html#двойные-оси",
    "href": "new_pages/ggplot_tips.ru.html#двойные-оси",
    "title": "31  Советы по использованию ggplot",
    "section": "31.11 Двойные оси",
    "text": "31.11 Двойные оси\nВторичная ось y часто является необходимым дополнением к графику ggplot2. Хотя в сообществе специалистов по визуализации данных ведутся активные споры о целесообразности таких графиков, и зачастую их не рекомендуют использовать, тем не менее они могут вам понадобиться. Ниже мы приводим один из способов их получения: использование пакета cowplot для объединения двух отдельных графиков.\nЭтот подход предполагает создание двух отдельных графиков - одного с осью y слева и другого с осью y справа. Оба графика будут использовать определенную theme_cowplot() и должны иметь одинаковую ось x. Затем в третьей команде оба графика выравниваются и накладываются друг на друга. Функциональные возможности cowplot, из которых это только одна, подробно описаны на этом сайте.\nДля демонстрации этого метода мы наложим эпидемическую кривую на линию недельного процента умерших пациентов. Мы используем этот пример, поскольку выравнивание дат по оси x является более сложной задачей, чем, например, выравнивание гистограммы с другим графиком. Следует отметить следующие моменты:\n\nПеред построением эпикривая и линия агрегируются по неделям * и * date_breaks и date_labels идентичны - это делается для того, чтобы оси x двух графиков совпадали при наложении.\n\nДля графика 2 ось y сдвигается вправо с помощью аргумента position = argument of scale_y_continuous().\n\nВ обоих графиках используется theme_cowplot().\n\nОбратите внимание, что на странице [Эпидемические кривые] есть еще один пример использования этого метода - наложение кумулятивной заболеваемости на эпикривую.\nПостроить график 1\nПо сути, это и есть эпикривая. Мы используем geom_area() только для того, чтобы продемонстрировать ее применение ( область под линией, по умолчанию)\n\npacman::p_load(cowplot)            # загрузка/установка cowplot\n\np1 &lt;- linelist %&gt;%                 # сохранить график как объект\n     count(\n       epiweek = lubridate::floor_date(date_onset, \"week\")) %&gt;% \n     ggplot()+\n          geom_area(aes(x = epiweek, y = n), fill = \"grey\")+\n          scale_x_date(\n               date_breaks = \"month\",\n               date_labels = \"%b\")+\n     theme_cowplot()+\n     labs(\n       y = \"Weekly cases\"\n     )\n\np1                                      # просмотр графика \n\n\n\n\n\n\n\n\nПостроить график 2\nПостройте второй график, на котором изобразите линию еженедельного процента случаев смерти.\n\np2 &lt;- linelist %&gt;%         # сохранить график как объект\n     group_by(\n       epiweek = lubridate::floor_date(date_onset, \"week\")) %&gt;% \n     summarise(\n       n = n(),\n       pct_death = 100*sum(outcome == \"Death\", na.rm=T) / n) %&gt;% \n     ggplot(aes(x = epiweek, y = pct_death))+\n          geom_line()+\n          scale_x_date(\n               date_breaks = \"month\",\n               date_labels = \"%b\")+\n          scale_y_continuous(\n               position = \"right\")+\n          theme_cowplot()+\n          labs(\n            x = \"Epiweek of symptom onset\",\n            y = \"Weekly percent of deaths\",\n            title = \"Weekly case incidence and percent deaths\"\n          )\n\np2     # просмотр графика \n\n\n\n\n\n\n\n\nТеперь выравниваем график с помощью функции align_plots(), задавая выравнивание по горизонтали и вертикали (“hv”, также может быть “h”, “v”, “,без выравнивания”). Выравнивание по всем осям (сверху, снизу, слева и справа) также задается функцией “tblr”. На выходе получаем список класса (2 элемента).\nЗатем мы рисуем два графика вместе, используя ggdraw() (из cowplot) и ссылаясь на две части объекта aligned_plots.\n\naligned_plots &lt;- cowplot::align_plots(p1, p2, align=\"hv\", axis=\"tblr\")         # выровнять два графика и сохранить их в виде списка\naligned_plotted &lt;- ggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])  # наложить их друг на друга и сохранить визуальный график\naligned_plotted                                                                # печать наложенных друг на друга графиков",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Советы по использованию ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.ru.html#пакеты-которые-вам-помогут",
    "href": "new_pages/ggplot_tips.ru.html#пакеты-которые-вам-помогут",
    "title": "31  Советы по использованию ggplot",
    "section": "31.12 Пакеты, которые вам помогут",
    "text": "31.12 Пакеты, которые вам помогут\nСуществует несколько очень удобных пакетов R, специально разработанных для того, чтобы помочь вам ориентироваться в ggplot2:\n\nНаведите и щелкните ggplot2 с помощью equisse.\n“Это дополнение позволяет интерактивно исследовать данные, визуализируя их с помощью пакета ggplot2. Оно позволяет строить столбчатые диаграммы, кривые, диаграммы рассеяния, гистограммы, коробчатые диаграммы и sf-объекты, а затем экспортировать график или получить код для его воспроизведения.”\nУстановите и запустите дополнение через меню RStudio или с помощью esquisse::esquisser().\nСм. Страница Github\nДокументация)",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Советы по использованию ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.ru.html#разное",
    "href": "new_pages/ggplot_tips.ru.html#разное",
    "title": "31  Советы по использованию ggplot",
    "section": "31.13 Разное",
    "text": "31.13 Разное\n\nЧисловое отображение\nВы можете отключить научную нотацию, выполнив эту команду перед построением графика.\n\noptions(scipen=999)\n\nИли примените number_format() из пакета scales к конкретному значению или столбцу, как показано ниже.\nС помощью функций из пакета scales можно легко настроить отображение чисел. Они могут быть применены к столбцам в датафрейме, но для примера показаны для отдельных чисел.\n\nscales::number(6.2e5)\n\n[1] \"620 000\"\n\nscales::number(1506800.62,  accuracy = 0.1,)\n\n[1] \"1 506 800.6\"\n\nscales::comma(1506800.62, accuracy = 0.01)\n\n[1] \"1,506,800.62\"\n\nscales::comma(1506800.62, accuracy = 0.01,  big.mark = \".\" , decimal.mark = \",\")\n\n[1] \"1.506.800,62\"\n\nscales::percent(0.1)\n\n[1] \"10%\"\n\nscales::dollar(56)\n\n[1] \"$56\"\n\nscales::scientific(100000)\n\n[1] \"1e+05\"",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Советы по использованию ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.ru.html#ресурсы",
    "href": "new_pages/ggplot_tips.ru.html#ресурсы",
    "title": "31  Советы по использованию ggplot",
    "section": "31.14 Ресурсы",
    "text": "31.14 Ресурсы\nДля вдохновления Галерея графиков ggplot\nПредставление данных Европейский центр по профилактике и контролю заболеваний Руководство по представлению данных эпиднадзора\nФасеты и наложение меток Использование меток для последовательности фасет Наложение меток\nКорректировка порядка с помощью факторов fct_reorder\nfct_inorder\nКак изменить порядок коробчатой диаграммы\nУпорядочивание переменных в ggplot2\nR для науки о данных - Факторы\nЛегенды\nНастроить порядок легенд\nПодписи Выравнивание подписей\nМетки\nggrepel\nШпаргалки\nКрасивое построение графиков с помощью ggplot2\n\n\n\n.\n\n\n\n\n\n\n.",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Советы по использованию ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.ru.html",
    "href": "new_pages/epicurves.ru.html",
    "title": "32  Эпидемические кривые",
    "section": "",
    "text": "32.1 Подготовка",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Эпидемические кривые</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.ru.html#подготовка",
    "href": "new_pages/epicurves.ru.html#подготовка",
    "title": "32  Эпидемические кривые",
    "section": "",
    "text": "Пакеты\nВ этом фрагменте кода показана загрузка пакетов, необходимых для проведения анализа. В данном руководстве мы делаем акцент на функции p_load() из pacman, которая при необходимости устанавливает пакет и загружает его для использования. Установленные пакеты можно также загрузить с помощью library() из базового R. Более подробную информацию о пакетах R см. на странице [Основы R].\n\npacman::p_load(\n  rio,          # импорт/экспорт файлов\n  here,         # относительные пути файлов \n  lubridate,    # работа с датами/эпинеделями\n  aweek,        # альтернативный пакет для работы с датами/эпидемиями\n  incidence2,   # эпидкривые данных построчного списка\n  i2extras,     # дополнение к заболеваемости2\n  stringr,      # поиск и работа с последовательностью символов\n  forcats,      # работа с факторами\n  RColorBrewer, # Цветовые палитры с сайта colorbrewer2.org\n  tidyverse     # управление данными + графика ggplot2\n) \n\n\n\nИмпорт данных\nВ данном разделе используются два примера наборов данных:\n\nПострочный список отдельных случаев из смоделированной эпидемии\n\nАгрегированные подсчеты по больницам из той же смоделированной эпидемии.\n\nНаборы данных импортируются с помощью функции import() из пакета rio. Различные способы импорта данных см. на странице [Импорт и экспорт].\nПострочный список случаев\nМы импортируем набор данных о случаях заболевания из смоделированной эпидемии лихорадки Эбола. Если вы хотите загрузить данные, чтобы проследить за ходом работы, смотрите инструкцию на странице [Скачивание руководства и данных]. Мы предполагаем, что файл находится в рабочей директории, поэтому в пути к файлу не указываются вложенные папки.\n\nlinelist &lt;- import(\"linelist_cleaned.xlsx\")\n\nНиже отображаются первые 50 строк.\n\n\n\n\n\n\nПодсчеты, агрегированные по больницам\nВ данном руководстве набор данных еженедельных агрегированных подсчетов случаев по больницам создается из построчного списка с помощью следующего кода.\n\n# Импорт данных о подсчетах R\ncount_data &lt;- linelist %&gt;% \n  group_by(hospital, date_hospitalisation) %&gt;% \n  summarize(n_cases = dplyr::n()) %&gt;% \n  filter(date_hospitalisation &gt; as.Date(\"2013-06-01\")) %&gt;% \n  ungroup()\n\nНиже отображаются первые 50 строк:\n\n\n\n\n\n\n\n\nЗадать параметры\nПри формировании отчета может потребоваться задать редактируемые параметры, например, дату, для которой данные являются актуальными (“дата данных”). Затем на объект data_date можно ссылаться в коде при применении фильтров или в динамических подписях.\n\n## установить дату отчета для отчета\n## Примечание: может быть установлено значение Sys.Date() для текущей даты\ndata_date &lt;- as.Date(\"2015-05-15\")\n\n\n\nПроверить даты\nУбедитесь, что каждый соответствующий столбец даты относится к классу Дата и имеет соответствующий диапазон значений. Для этого можно просто использовать hist() для гистограмм, или range() с na.rm=TRUE, или ggplot(), как показано ниже.\n\n# проверка диапазона дат начала заболевания\nggplot(data = linelist)+\n  geom_histogram(aes(x = date_onset))",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Эпидемические кривые</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.ru.html#эпидкривые-с-помощью-ggplot2",
    "href": "new_pages/epicurves.ru.html#эпидкривые-с-помощью-ggplot2",
    "title": "32  Эпидемические кривые",
    "section": "32.2 эпидкривые с помощью ggplot2",
    "text": "32.2 эпидкривые с помощью ggplot2\nИспользование ggplot() для построения эпидкривой позволяет добиться большей гибкости и настраиваемости, но требует больших усилий и понимания принципов работы ggplot().\nВ отличие от использования пакета incidence2, здесь необходимо вручную управлять агрегированием случаев по времени (по неделям, месяцам и т.д.) и интервалами меток на оси дат. Это требует тщательного контроля.\nВ этих примерах используется подмножество построчного списка данных - только случаи из Центральной больницы.\n\ncentral_data &lt;- linelist %&gt;% \n  filter(hospital == \"Central Hospital\")\n\nДля получения эпидкривой с помощью ggplot() необходимо три основных элемента:\n\nГистограмма, в которой случаи из построчного списка объединены в “корзины”, отличающиеся определенными точками ” излома”.\n\nШкалы для осей и их метки\n\nТемы оформления графика, включая заголовки, метки, подписи и т.д.\n\n\nУкажите корзины для случаев\nНиже мы покажем, как указать, каким образом случаи будут агрегироваться в корзины гистограммы (“столбики”). Важно понимать, что объединение случаев в корзины гистограммы не обязательно совпадает с интервалами дат, которые будут отображаться на оси x.\nДалее приведен, пожалуй, наиболее простой код для получения ежедневных и еженедельных эпидкривых.\nВо всеохватывающей команде ggplot() набор данных передается в data =. На эту основу с помощью знака + добавляется геометрия гистограммы. В команде geom_histogram() мы задаем эстетику таким образом, что столбец date_onset отображается на ось x. Также внутри geom_histogram(), но не внутри aes(), мы устанавливаем binwidth = корзины гистограммы, в днях. Если этот синтаксис ggplot2 вызывает недоумение, просмотрите страницу [Основы ggplot].\nВНИМАНИЕ: Построение недельных случаев с использованием binwidth = 7 начинает первую 7-дневную корзину с первого случая, который может быть любым днем недели! Для создания конкретных недель см. раздел ниже .\n\n# ежедневно \nggplot(data = central_data) +          # задать данные\n  geom_histogram(                      # добавить гистограмму\n    mapping = aes(x = date_onset),     # сопоставить столбец даты с осью x\n    binwidth = 1)+                     # случаи, разделенные на корзины по 1 дню \n  labs(title = \"Central Hospital - Daily\")                # заголовок\n\n# еженедельно\nggplot(data = central_data) +          # задать данные\n  geom_histogram(                      # добавить гистограмму\n      mapping = aes(x = date_onset),   # сопоставить столбец даты с осью x\n      binwidth = 7)+                   # случаи, разделенные на корзины каждые 7 дней, начиная с первого случая (!) \n  labs(title = \"Central Hospital - 7-day bins, starting at first case\") # title\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nОтметим, что первый случай в наборе данных Central Hospital имел дату возникновения симптомов:\n\nformat(min(central_data$date_onset, na.rm=T), \"%A %d %b, %Y\")\n\n[1] \"Thursday 01 May, 2014\"\n\n\nЧтобы вручную указать корзины гистограммы, не используйте аргумент binwidth =, а вместо этого передайте вектор дат в breaks =..\nСоздайте вектор дат с помощью базовой функции R seq.Date(). Эта функция принимает аргументы to =, from = и by =. Например, приведенная ниже команда возвращает даты за месяц, начиная с 15 января и заканчивая 28 июня.\n\nmonthly_breaks &lt;- seq.Date(from = as.Date(\"2014-02-01\"),\n                           to = as.Date(\"2015-07-15\"),\n                           by = \"months\")\n\nmonthly_breaks   # печать \n\n [1] \"2014-02-01\" \"2014-03-01\" \"2014-04-01\" \"2014-05-01\" \"2014-06-01\"\n [6] \"2014-07-01\" \"2014-08-01\" \"2014-09-01\" \"2014-10-01\" \"2014-11-01\"\n[11] \"2014-12-01\" \"2015-01-01\" \"2015-02-01\" \"2015-03-01\" \"2015-04-01\"\n[16] \"2015-05-01\" \"2015-06-01\" \"2015-07-01\"\n\n\nЭтот вектор может быть передан в geom_histogram() в виде breaks =:\n\n# ежемесячно \nggplot(data = central_data) +  \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    breaks = monthly_breaks)+         # обеспечить заданный вектор разрывов                    \n  labs(title = \"Monthly case bins\")   # заголовок\n\n\n\n\n\n\n\n\nПростую недельную последовательность дат можно вернуть, задав by = \"week\". Например:\n\nweekly_breaks &lt;- seq.Date(from = as.Date(\"2014-02-01\"),\n                          to = as.Date(\"2015-07-15\"),\n                          by = \"week\")\n\nАльтернативой заданию конкретных дат начала и конца является написание динамического кода, в котором недельные интервалы начинаются с понедельника, предшествующего первому случаю. Мы будем использовать эти векторы дат во всех приведенных ниже примерах.\n\n# Последовательность еженедельных дат понедельника для ЦЕНТРАЛЬНОЙ БОЛЬНИЦЫ\nweekly_breaks_central &lt;- seq.Date(\n  from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 1), # понедельник, предшествующий первому случаю\n  to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # понедельник после последнего случая\n  by   = \"week\")\n\nДавайте разберем довольно сложный код, приведенный выше:\n\nЗначение ” с” (самая ранняя дата последовательности) создается следующим образом: минимальное значение даты (min() с na.rm=TRUE) в столбце date_onset подается на floor_date() из пакета lubridate. floor_date(), установленная в значение ” неделя”, возвращает дату начала “недели” этого случая, учитывая, что день начала каждой недели - понедельник (week_start = 1).\n\nАналогично, значение ” до” (дата окончания последовательности) создается с помощью обратной функции ceiling_date() для возврата понедельника, следующего за последним случаем.\n\nАргумент ” по” функции seq.Date() может быть установлен на любое количество дней, недель или месяцев.\n\nИспользуйте week_start = 7 для недели, гачигающейся с воскресенья.\n\nПоскольку мы будем использовать эти векторы дат на протяжении всей страницы, мы также определим один из них для всей вспышки (выше приведен только для Центральной больницы).\n\n# Последовательность для всей вспышки\nweekly_breaks_all &lt;- seq.Date(\n  from = floor_date(min(linelist$date_onset, na.rm=T),   \"week\", week_start = 1), # понедельник, предшествующий первому случаю\n  to   = ceiling_date(max(linelist$date_onset, na.rm=T), \"week\", week_start = 1), # понедельник после последнего случая\n  by   = \"week\")\n\nТакие результаты seq.Date() могут быть использованы для создания разрывов между корзинами гистограммы, а также разрывов для меток даты, которые могут быть независимыми от корзин. Подробнее о метках дат читайте в последующих разделах.\nTIP: Для более простой команды ggplot() заранее сохраните разрывы между корзинами и разрывы меток даты в виде именованных векторов и просто укажите их названия в breaks =.\n\n\nПример недельной эпидкривой\nНиже приведен подробный пример кода для создания еженедельных эпидкривых для недели, начинающейся в понедельник, с выровненными столбцами, метками даты и вертикальными линиями сетки. Этот раздел предназначен для пользователя, которому код нужен быстро. Для более глубокого понимания каждого аспекта (темы, метки даты и т.д.) перейдите к последующим разделам. Примечание:\n\nРазрывы между корзинами гистограммы* задаются с помощью seq.Date(), как описано выше, чтобы начинаться в понедельник перед самым ранним случаем и заканчиваться в понедельник после последнего случая.\n\nИнтервал между метками даты задается с помощью date_breaks = в scale_x_date().\n\nИнтервал мелких вертикальных линий сетки между метками даты задается с помощью date_minor_breaks =.\n\nМы используем closed = \"left\" в geom_histogram(), чтобы обеспечить подсчет дат в правильных корзинах\n\nexpand = c(0,0) в шкалах x и y удаляет лишнее пространство по обе стороны от осей, что также обеспечивает начало отсчета меток дат с первого столбика.\n\n\n# ОБЩЕЕ ВЫРАВНИВАНИЕ НЕДЕЛИ С ПОНЕДЕЛЬНИКА\n#############################\n# Определить последовательность еженедельных разрывов\nweekly_breaks_central &lt;- seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 1), # Понедельник перед первым случаем\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # Понедельник после последнего случая\n      by   = \"week\")    # bins are 7-days \n\n\nggplot(data = central_data) + \n  \n  # построить гистограмму: указать точки разрыва между корзинами: начало - понедельник перед первым случаем, конец - понедельник после последнего случая\n  geom_histogram(\n    \n    # сопоставление эстетики \n    mapping = aes(x = date_onset),  # столбец даты сопоставлен с осью x\n    \n    # разрывы между корзинами гистограммы\n    breaks = weekly_breaks_central, # разрывы между корзинами гистограммы, заданные ранее\n      \n    closed = \"left\",  # подсчет случаев от начала точки прерывания\n    \n    # столбики\n    color = \"darkblue\",     # цвет линий вокруг столбиков\n    fill = \"lightblue\"      # цвет заливки внутри столбиков\n  )+ \n    \n  # метки оси x\n  scale_x_date(\n    expand            = c(0,0),           # удалить лишнее пространство по оси x до и после столбиков случая\n    date_breaks       = \"4 weeks\",        # метки даты и основные вертикальные линии сетки появляются каждые 3 недели понедельника\n    date_minor_breaks = \"week\",           # Незначительные вертикальные линии появляются каждую неделю понедельника\n    date_labels       = \"%a\\n%d %b\\n%Y\")+ # формат меток даты\n  \n  # ось y \n  scale_y_continuous(\n    expand = c(0,0))+             # удалить лишнее пространство по оси y ниже 0 (выровнять гистограмму вровень с осью x)\n  \n  # темы эстетики\n  theme_minimal()+                # упростить фон графика\n  \n  theme(\n    plot.caption = element_text(hjust = 0,        # надпись с левой стороны\n                                face = \"italic\"), # надпись курсивом\n    axis.title = element_text(face = \"bold\"))+    # заголовки осей выделены жирным шрифтом\n  \n  # метки, включая динамические надписи\n  labs(\n    title    = \"Weekly incidence of cases (Monday weeks)\",\n    subtitle = \"Note alignment of bars, vertical gridlines, and axis labels on Monday weeks\",\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly incident cases reported\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %&gt;% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))\n\n\n\n\n\n\n\n\n\nНедели с воскресенья\nДля получения приведенного выше графика для недель с воскресенья необходимо внести некоторые изменения, поскольку date_breaks = \"weeks\" работает только для недель с понедельника.\n\nТочки разрыва корзин гистограммы должны быть установлены на воскресенье (week_start = 7)\n\nВ функции scale_x_date() следует задать аналогичные разрывы дат breaks = и minor_breaks =, чтобы метки дат и вертикальные линии сетки выравнивались по воскресеньям.\n\nНапример, команда scale_x_date() для недель с воскресенья может выглядеть следующим образом:\n\nscale_x_date(\n    expand = c(0,0),\n    \n    # задать интервал между метками даты и основными вертикальными линиями сетки\n    breaks = seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7), # Воскресенье, предшествующее первому случаю\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # Воскресенье после последнего случая\n      by   = \"4 weeks\"),\n    \n    # задать интервал малой вертикальной линии сетки \n    minor_breaks = seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7), # Воскресенье, предшествующее первому случаю\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # Воскресенье после последнего случая\n      by   = \"week\"),\n   \n    # формат метки даты\n    #date_labels = \"%a\\n%d %b\\n%Y\")+         # день, над аббревиатурой месяца, над двузначным годом\n    label = scales::label_date_short())+ # автоматическое форматирование меток\n\n\n\n\nГруппировка/окрашивание по значению\nСтолбцы гистограммы могут быть окрашены по группам и “сложены”. Чтобы назначить столбец группировки, выполните следующие изменения. Подробности см. на странице [Основы ggplot].\n\nВнутри эстетического отображения гистограммы aes() сопоставьте название столбца с аргументами group = и fill =.\n\nУдалите любой аргумент fill =, находящийся вне aes(), так как он будет замещать тот, который находится внутри.\n\nАргументы внутри aes() будут применяться по группе, в то время как аргументы снаружи будут применяться ко всем столбикам (например, вы все еще можете захотеть использовать color = снаружи, чтобы каждый столбик имел одинаковую границу)\n\nВот как будет выглядеть команда aes() для группировки и окрашивания столбиков по полу:\n\naes(x = date_onset, group = gender, fill = gender)\n\nВ данном случае она применяется:\n\nggplot(data = linelist) +     # начать с построчного списка (много больниц)\n  \n  # построить гистограмму: указать точки разрыва корзин: начало - понедельник перед первым случаем, конец - понедельник после последнего случая\n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = hospital,       # задать группировку данных по больницам\n      fill = hospital),       # заливка столбиков (внутренний цвет) по больницам\n    \n    # Разрывы между корзинами - недели с понедельника\n    breaks = weekly_breaks_all,   # последовательность разрывов между корзинами неделей с понедельника для всей вспышки, определенная в предыдущем коде       \n    \n    closed = \"left\",          # подсчет случаев от начала точки прерывания\n\n    # Цвет вокруг столбиков\n    color = \"black\")\n\n\n\n\n\n\n\n\n\n\nНастройка цвета\n\nДля ручной настройки заливки для каждой группы используйте scale_fill_manual() (обратите внимание: scale_color_manual() отличается!).\n\nИспользуйте аргумент values = для применения вектора цветов.\n\nИспользуйте аргумент na.value =, чтобы задать цвет для значений NA.\n\nИспользуйте аргумент labels = для изменения текста элементов легенды. Для надежности задайте вектор с названием типа c(\"old\" = \"new\", \"old\" = \"new\") или скорректируйте значения в самих данных.\n\nИспользуйте аргумент name =, чтобы дать легенде соответствующее название\n\n\nДополнительные сведения о цветовых шкалах и палитрах см. на странице [Основы ggplot].\n\n\nggplot(data = linelist)+           # начать с построчного списка (много больниц)\n  \n  # построить гистограмму\n  geom_histogram(\n    mapping = aes(x = date_onset,\n        group = hospital,          # случаи, сгруппированные по больницам \n        fill = hospital),          # заливка столбиков по больницам\n    \n    # разрывы кмежду корзин \n    breaks = weekly_breaks_all,    # последовательность разрывов между корзинами неделей с понедельника для всей вспышки, определенная в предыдущем коде\n    \n    closed = \"left\",               # подсчет случаев от начала точки прерывания\n\n    # Цвет вокруг столбиков\n    color = \"black\")+              # цвет границы каждого столбика\n  \n  # ручная спецификация цвета\n  scale_fill_manual(\n    values = c(\"black\", \"orange\", \"grey\", \"beige\", \"blue\", \"brown\"),\n    labels = c(\"St. Mark's Maternity Hospital (SMMH)\" = \"St. Mark's\"),\n    name = \"Hospital\") # укажите цвета заливки (\"значения\") - внимание на порядок!\n\n\n\n\n\n\n\n\n\n\nНастройка порядка уровней\nПорядок укладки сгруппированных столбцов лучше всего настроить, отнеся столбец группировки к классу Фактор. Затем можно задать порядок уровней факторов (и их отображаемые метки). Подробности см. на странице [Факторы] или [Советы по использованию ggplot].\nПеред построением графика воспользуйтесь функцией fct_relevel() из пакета forcats, чтобы преобразовать столбец группировки в класс Фактор и вручную настроить порядок уровней, как описано на странице [Факторы].\n\n# загрузить пакет forcats для работы с факторами\npacman::p_load(forcats)\n\n# Определить новый набор данных с больницей в качестве фактора\nplot_data &lt;- linelist %&gt;% \n  mutate(hospital = fct_relevel(hospital, c(\"Missing\", \"Other\"))) # Преобразовать в фактор и установить \"Отсутствует\" и \"Другое\" в качестве верхних уровней для отображения на эпидкривой сверху\n\nlevels(plot_data$hospital) # печать уровней по порядку\n\n[1] \"Missing\"                             \n[2] \"Other\"                               \n[3] \"Central Hospital\"                    \n[4] \"Military Hospital\"                   \n[5] \"Port Hospital\"                       \n[6] \"St. Mark's Maternity Hospital (SMMH)\"\n\n\nНа приведенном ниже графике единственным отличием от предыдущего является то, что столбец hospital был объединен, как указано выше, и мы используем guides() для изменения порядка легенды, так что ““Отсутствует”” находится в нижней части легенды.\n\nggplot(plot_data) +                     # Использовать НОВЫЙ набор данных с больницей в качестве переупорядоченного фактора\n  \n  # построить гистограмму\n  geom_histogram(\n    mapping = aes(x = date_onset,\n        group = hospital,               # случаи, сгруппированные по больницам\n        fill = hospital),               # Заливка столбиков (цвет) по больницам\n    \n    breaks = weekly_breaks_all,         # последовательность разрывов между корзинами неделей с понедельника для всей вспышки, определенная в верхней части раздела ggplot\n    \n    closed = \"left\",                    # подсчет случаев от начала точки прерывания\n\n    color = \"black\")+                   # цвет границы вокруг каждого столбика\n    \n  # метки оси x\n  scale_x_date(\n    expand            = c(0,0),           # удалить лишнее пространство по оси x до и после столбиков случая\n    date_breaks       = \"3 weeks\",        # метки появляются каждые 3 недели с понедельника\n    date_minor_breaks = \"week\",           # вертикальные линии появляются каждую неделю с понедельника\n    label = scales::label_date_short()) + # удобное форматирование меток\n  \n  # ось y \n  scale_y_continuous(\n    expand = c(0,0))+                   # удалить лишнее пространство по оси y ниже 0\n  \n  # ручная спецификация цветов, внимание к порядку!\n  scale_fill_manual(\n    values = c(\"grey\", \"beige\", \"black\", \"orange\", \"blue\", \"brown\"),\n    labels = c(\"St. Mark's Maternity Hospital (SMMH)\" = \"St. Mark's\"),\n    name = \"Hospital\")+ \n  \n  # темы эстетики \n  theme_minimal()+                      # упростить фон графика\n  \n  theme(\n    plot.caption = element_text(face = \"italic\", # надпись слева курсивом\n                                hjust = 0), \n    axis.title = element_text(face = \"bold\"))+   # заголовки осей выделены жирным шрифтом\n  \n  # метки\n  labs(\n    title    = \"Weekly incidence of cases by hospital\",\n    subtitle = \"Hospital as re-ordered factor\",\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly cases\")\n\n\n\n\n\n\n\n\nСОВЕТ: Чтобы изменить порядок только легенды, добавьте следующую команду ggplot2: guides(fill = guide_legend(reverse = TRUE)).\n\n\nНастройка легенды\nПодробнее о легендах и шкалах можно прочитать на странице [Советы по использованию ggplot]. Вот несколько основных моментов:\n\nРедактирование заголовка легенды либо в функции шкалы, либо с помощью labs(fill = \"Заголовок легенды\") (если вы используете color = aesthetic, то используйте labs(color = \"\"))\n\ntheme(legend.title = element_blank()) для того, чтобы не иметь заголовка легенды\n\ntheme(legend.position = \"top\") (” низ”, “лево”, “право” или “нет” для удаления легенды)\ntheme(legend.direction = \"horizontal\") горизонтальная легенда\n`guides(fill = guide_legend(reverse = TRUE)) для обратного порядка легенды\n\n\n\nСтолбики рядом\nОтображение столбиков групп “бок о бок” (в отличие от сложенных) задается в geom_histogram() с position = \"dodge\", размещенной вне aes().\nПри наличии более двух групп значений они могут стать трудночитаемыми. Вместо этого можно использовать фасетный график (“малые множества”). Для улучшения читаемости в данном примере удалены недостающие значения пола.\n\nggplot(central_data %&gt;% drop_na(gender))+   # начать со случаев в Центральной больнице, в которых отсутствует пол\n    geom_histogram(\n        mapping = aes(\n          x = date_onset,\n          group = gender,         # случаи, сгруппированные по полу\n          fill = gender),         # столбики, заполненные по полу\n        \n        # разрывы между корзин гистограмм \n        breaks = weekly_breaks_central,   # последовательность недельных дат для вспышки в Центральной больнице - определена в верхней части раздела ggplot\n        \n        closed = \"left\",          # подсчет случаев от начала точки прерывания\n        \n        color = \"black\",          # цвет кромки столбика \n        \n        position = \"dodge\")+      # столбики бок о бок \n                      \n  \n  # метки на шкале x \n  scale_x_date(expand            = c(0,0),          # удалить лишнее пространство по оси x ниже и после столбиков случаев \n               date_breaks       = \"3 weeks\",       # метки появляются каждые 3 недели с понедельника\n               date_minor_breaks = \"week\",          # вертикальные линии появляются каждую неделю с понедельника\n               label = scales::label_date_short())+ # удобные метки даты\n  \n  # ось y \n  scale_y_continuous(expand = c(0,0))+             # удаляет лишнее пространство по оси y между нижней частью столбиков и метками\n  \n  #шкала цветов и меток легенды\n  scale_fill_manual(values = c(\"brown\", \"orange\"),  # укажите цвета заливки (\"значения\") - внимание на порядок!\n                    na.value = \"grey\" )+     \n\n  # темы эстетики \n  theme_minimal()+                                               # набор тем для упрощения графика\n  theme(plot.caption = element_text(face = \"italic\", hjust = 0), # надпись слева курсивом\n        axis.title = element_text(face = \"bold\"))+               # заголовки осей выделены жирным шрифтом\n  \n  # метки \n  labs(title    = \"Weekly incidence of cases by hospital\",\n       subtitle = \"Subtitle\",\n       fill     = \"Gender\",                                      # указать новый заголовок легенды\n       x        = \"Week of symptom onset\",\n       y        = \"Weekly incident cases reported\")\n\n\n\n\n\n\n\n\n\n\nГраницы осей\nСуществует два способа ограничения размаха значений оси.\nКак правило, предпочтительным является использование команды coord_cartesian(), которая принимает значения xlim = c(min, max) и ylim = c(min, max) (где вы указываете минимальное и максимальное значения). Это действует как ” увеличение масштаба” без фактического удаления данных, что важно для статистики и суммарных показателей.\nВ качестве альтернативы можно задать максимальное и минимальное значения даты, используя limits = c() внутри scale_x_date(). Например:\n\nscale_x_date(limits = c(as.Date(\"2014-04-01\"), NA)) # задает минимальную дату, а максимальную оставляет открытой.  \n\nАналогично, если необходимо, чтобы ось x простиралась до определенной даты (например, текущей), даже если новые случаи не были зарегистрированы, можно воспользоваться функцией:\n\nscale_x_date(limits = c(NA, Sys.Date()) # обеспечивает продление оси дат до текущей даты  \n\nВНИМАНИЕ: Будьте внимательны, задавая перерывы или границы шкалы оси y (например, от 0 до 30 на 5: seq(0, 30, 5)). Такие статические числа могут слишком резко оборвать ваш график, если данные изменятся и выйдут за предел!\n\n\nМетки/сеточные линии по оси дат\nСОВЕТ: Помните, что метки на оси дат не зависят от объединения данных в столбцы, но визуально может быть важно выровнять корзины, метки дат и вертикальные линии сетки.\nЧтобы изменить метки даты и линии сетки, используйте scale_x_date() одним из этих способов:\n\nЕсли корзины гистограммы - это дни, недели с понедельника, месяцы или годы:\n\nИспользуйте date_breaks = для задания интервала между метками и основными линиями сетки (например, “день”, “неделя”, “3 недели”, “месяц” или “год”)\nИспользуйте date_minor_breaks = для указания интервала между вертикальными линиями сетки (между метками даты).\n\nДобавьте expand = c(0,0), чтобы начать метки с первого столбца.\n\nИспользуйте date_labels = для указания формата меток даты - см. советы на странице Даты (используйте \\n для новой строки)\n\n\nЕсли корзины гистограммы представляют собой недели с воскресенья:\n\nИспользуйте breaks = и minor_breaks =, предоставляя последовательность переносов даты для каждого из них.\nВы все еще можете использовать date_labels = и expand = для форматирования, как описано выше.\n\n\nНекоторые примечания:\n\nИнструкции по созданию последовательности дат с помощью seq.Date() см. в разделе “Открытие ggplot”.\n\nСоветы по созданию меток дат см. здесь эта страница или на странице [Работа с датами].\n\n\nДемонстрация\nНиже показаны графики, на которых корзины и метки графика/линии сетки выровнены или не выровнены:\n\n# корзины 7 дней и метки понедельника \n#############################\nggplot(central_data) +\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    binwidth = 7,                 # корзины 7 дней, которые начинаются с первым случаем \n    color = \"darkblue\",\n    fill = \"lightblue\") +\n  \n  scale_x_date(\n    expand = c(0,0),                     # удалить лишнее пространство по оси x ниже и после столбиков случаев \n    date_breaks = \"3 weeks\",             # Понедельник каждые 3 недели\n    date_minor_breaks = \"week\",          # недели с понедельника \n    label = scales::label_date_short())+ # автоматическое форматирование меток\n  \n  scale_y_continuous(\n    expand = c(0,0))+              # удалить лишнее пространство под осью x, сделать все ровным \n  \n  labs(\n    title = \"MISALIGNED\",\n    subtitle = \"! CAUTION: 7-day bars start Thursdays at first case\\nDate labels and gridlines on Mondays\\nNote how ticks don't align with bars\")\n\n\n\n# корзины 7 дней +  месяцы \n#####################\nggplot(central_data) +\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    binwidth = 7,\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n  \n  scale_x_date(\n    expand = c(0,0),                     # удалить лишнее пространство по оси x ниже и после столбиков случаев \n    date_breaks = \"months\",              # 1-ый месяц \n    date_minor_breaks = \"week\",          # недели с понедельника \n    label = scales::label_date_short())+ # автоматическое форматирование меток\n  \n  scale_y_continuous(\n    expand = c(0,0))+                 # удалить лишнее пространство под осью x, сделать все ровным \n  \n  labs(\n    title = \"MISALIGNED\",\n    subtitle = \"! CAUTION: 7-day bars start Thursdays with first case\\nMajor gridlines and date labels at 1st of each month\\nMinor gridlines weekly on Mondays\\nNote uneven spacing of some gridlines and ticks unaligned with bars\")\n\n\n# ПОЛНОЕ ВЫРАВНИВАНИЕ ПО ПОНЕДЕЛЬНИКАМ: укажите вручную, что разрывы между корзинами должны приходиться на понедельник\n#################################################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # Разрыв гистограммы установлен на 7 дней, начиная с понедельника перед первым случаем\n    breaks = weekly_breaks_central,    # определены ранее на этой странице\n    \n    closed = \"left\",                   # подсчет случаев от начала точки прерывания\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),                     # удалить лишнее пространство по оси x ниже и после столбиков случаев\n    date_breaks = \"4 weeks\",             # понедельник каждые 4 недели \n    date_minor_breaks = \"week\",          # недели с понедельника \n    label = scales::label_date_short())+ # форматирование меток \n  \n  scale_y_continuous(\n    expand = c(0,0))+                  # удалить лишнее пространство под осью x, сделать все ровным\n  \n  labs(\n    title = \"ALIGNED Mondays\",\n    subtitle = \"7-day bins manually set to begin Monday before first case (28 Apr)\\nDate labels and gridlines on Mondays as well\")\n\n\n# ПОЛНОЕ ВЫРАВНИВАНИЕ ПО ПОНЕДЕЛЬНИКАМ С МЕТКАМИ МЕСЯЦЕВ:\n############################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # Разбиение гистограммы на 7 дней, начиная с понедельника перед первым случаем\n    breaks = weekly_breaks_central,    # определены ранее на этой странице\n    \n    closed = \"left\",                   # подсчет случаев от начала точки прерывания\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),                     # удалить лишнее пространство по оси x ниже и после столбиков случаев\n    date_breaks = \"months\",              # понедельник каждые 4 недели\n    date_minor_breaks = \"week\",          # недели с понедельника \n    label = scales::label_date_short())+ # форматирование меток\n  \n  scale_y_continuous(\n    expand = c(0,0))+                  # удалить лишнее пространство под осью x, сделать все ровным \n  \n  theme(panel.grid.major = element_blank())+  # Удаление основных линий сетки (приходится на 1-е число месяца)\n          \n  labs(\n    itle = \"ALIGNED Mondays with MONTHLY labels\",\n    subtitle = \"7-day bins manually set to begin Monday before first case (28 Apr)\\nDate labels on 1st of Month\\nMonthly major gridlines removed\")\n\n\n# ПОЛНОЕ ВЫРАВНИВАНИЕ ПО ВОСКРЕСЕНЬЯМ: укажите вручную разрывы корзин и метки, которые должны быть по воскресеньям\n############################################################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # Разрывы гистограммы устанавливаются на 7 дней, начиная с воскресенья перед первым случаем\n    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                      by   = \"7 days\"),\n    \n    closed = \"left\",                    # подсчет случаев от начала точки прерывания\n\n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),\n    # разрывы меток даты и основные линии сетки устанавливаются на каждые 3 недели, начиная с воскресенья перед первым случаем\n    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                      by   = \"3 weeks\"),\n    \n    # Малые линии сетки устанавливаются на еженедельное начало с воскресенья перед первым случаем\n    minor_breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                            to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                            by   = \"7 days\"),\n    \n    label = scales::label_date_short())+ # форматирование меток\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # удалить лишнее пространство под осью x, сделать все ровным \n  \n  labs(title = \"ALIGNED Sundays\",\n       subtitle = \"7-day bins manually set to begin Sunday before first case (27 Apr)\\nDate labels and gridlines manually set to Sundays as well\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nАгрегированные данные\nЗачастую вместо построчного списка используются агрегированные подсчеты по учреждениям, районам и т.д. эпидкривую можно построить с помощью ggplot(), но код будет несколько иным. В этом разделе будет использован набор данных count_data, который был импортирован ранее, в разделе подготовки данных. Этот набор данных представляет собой linelist, агрегированный до подсчетов день-больница. Ниже показаны первые 50 строк.\n\n\n\n\n\n\n\nПостроение графика ежедневных подсчетов\nПо этим дневным подсчетам мы можем построить дневную эпидкривую. Вот отличия в коде:\n\nВ эстетическом отображении aes() укажите y = в качестве столбца подсчетов (в данном случае название столбца - n_cases)\nДобавить аргумент stat = \"identity\" в geom_histogram(), который определяет, что высота столбца должна быть равна значению y =, а не количеству строк, как по умолчанию.\nДобавьте аргумент width =, чтобы избежать вертикальных белых линий между столбиками. Для ежедневных данных установите значение 1. Для недельных данных - 7. Для месячных данных белые линии являются проблемой (в каждом месяце разное количество дней) - рассмотрите возможность преобразования оси x в категориальный упорядоченный фактор (месяцы) и использования geom_col().\n\n\nggplot(data = count_data)+\n  geom_histogram(\n   mapping = aes(x = date_hospitalisation, y = n_cases),\n   stat = \"identity\",\n   width = 1)+                # Для ежедневных подсчетов задайте ширину = 1, чтобы избежать пробелов между столбиками\n  labs(\n    x = \"Date of report\", \n    y = \"Number of cases\",\n    title = \"Daily case incidence, from daily count data\")\n\n\n\n\n\n\n\n\n\n\nПостроение графика недельных подсчетов\nЕсли ваши данные уже представляют собой подсчеты случаев по неделям, то они могут выглядеть как этот набор данных (под названием count_data_weekly):\nНиже показаны первые 50 строк count_data_weekly. Видно, что подсчеты были агрегированы по неделям. Каждая неделя отображается по первому дню недели (по умолчанию это понедельник).\n\n\n\n\n\n\nТеперь постройте график так, чтобы x = столбец эпинедели. Не забудьте добавить y = столбец подсчетов в эстетическое отображение и добавить stat = \"identity\", как объяснялось выше.\n\nggplot(data = count_data_weekly)+\n  \n  geom_histogram(\n    mapping = aes(\n      x = epiweek,           # Ось x - эпинеделя (как дата класса)\n      y = n_cases_weekly,    # высота оси y в еженедельных подсчетах случаев\n      group = hospital,      # мы группируем столбики и раскрашиваем их по больницам\n      fill = hospital),\n    stat = \"identity\")+      # Это также необходимо при построении графиков по данным подсчета\n     \n  # метки для оси x \n  scale_x_date(\n    date_breaks = \"2 months\",      # метки каждые 2 месяца  \n    date_minor_breaks = \"1 month\", # линии сетки каждый месяц\n    label = scales::label_date_short())+ # форматирование меток\n     \n  # Выбор цветовой палитры (используется пакет RColorBrewer)\n  scale_fill_brewer(palette = \"Pastel2\")+ \n  \n  theme_minimal()+\n  \n  labs(\n    x = \"Week of onset\", \n    y = \"Weekly case incidence\",\n    fill = \"Hospital\",\n    title = \"Weekly case incidence, from aggregated count data by hospital\")\n\n\n\n\n\n\n\n\n\n\n\nСкользящие средние значения\nПодробное описание и несколько вариантов приведены на странице [Скользящие средние]. Ниже приведен один из вариантов расчета скользящих средних с помощью пакета slider. При таком подходе скользящее среднее вычисляется в наборе данных перед построением графика:\n\nАгрегируем данные в подсчеты по мере необходимости (“дневные”, “недельные” и т.д.) (см. страницу [Группировка данных])\n\nСоздать новый столбец для скользящего среднего, созданный с помощью функции slide_index() из пакета slider.\n\nПостроить скользящее среднее в виде geom_line() поверх (после) гистограммы эпидкривой.\n\nСмотрите полезный онлайн ресурс виньетка для пакета slider.\n\n# загрузка пакета\npacman::p_load(slider)  # slider, используемый для расчета скользящих средних\n\n# составить набор данных из дневных подсчетов и 7-дневного скользящего среднего\n#######################################################\nll_counts_7day &lt;- linelist %&gt;%    # начать с построчного списка\n  \n  ## подсчет случаев по дате\n  count(date_onset, name = \"new_cases\") %&gt;%   # назвать новый столбец с подсчетами как \"new_cases\"\n  drop_na(date_onset) %&gt;%                     # Удаление случаев с отсутствующей датой date_onset\n  \n  ## рассчитать среднее количество случаев в 7-дневном окне\n  mutate(\n    avg_7day = slider::slide_index(    # создать новый столбец\n      new_cases,                       # вычисление на основе значения в столбце new_cases\n      .i = date_onset,                 # индекс date_onset col, поэтому в окно включаются даты, не относящиеся к настоящему времени \n      .f = ~mean(.x, na.rm = TRUE),    # функция mean() с удаленными отсутствующими значениями\n      .before = 6,                     # окно - день и 6 дней до\n      .complete = FALSE),              # для работы функции unlist() на следующем шаге должно быть FALSE (неверно)\n    avg_7day = unlist(avg_7day))       # преобразование списка классов в числовые значения классов\n\n\n# график\n######\nggplot(data = ll_counts_7day) +  # начать с нового набора данных, определенного выше \n    geom_histogram(              # построение гистограммы эпидкривой\n      mapping = aes(\n        x = date_onset,          # столбец даты в качестве оси x\n        y = new_cases),          # высота - количество ежедневных новых случаев\n        stat = \"identity\",       # высота - значение y\n        fill=\"#92a8d1\",          # холодный цвет для столбиков\n        colour = \"#92a8d1\",      # тот же цвет для границы столбика\n        )+ \n    geom_line(                   # строка для скользящего среднего значения\n      mapping = aes(\n        x = date_onset,          # столбец даты для оси x\n        y = avg_7day,            # значение y задается в столбце скользящего среднего\n        lty = \"7-day \\nrolling avg\"), # название строки в легенде\n      color=\"red\",               # цвет линии \n      size = 1) +                # ширина линии\n    scale_x_date(                # шкала даты\n      date_breaks = \"1 month\",\n      label = scales::label_date_short(), # форматирование меток\n      expand = c(0,0)) +\n    scale_y_continuous(          # масштаб оси y\n      expand = c(0,0),\n      limits = c(0, NA)) +       \n    labs(\n      x=\"\",\n      y =\"Number of confirmed cases\",\n      fill = \"Legend\")+ \n    theme_minimal()+\n    theme(legend.title = element_blank())  # удаляет заголовок легенды\n\n\n\n\n\n\n\n\n\n\nФасетирование/малые множества\nКак и в случае с другими ggplots, можно создавать фасетные графики (“малые множества”). Как объясняется на странице [Советы по использованию ggplot] данного руководства, для этого можно использовать либо facet_wrap(), либо facet_grid(). Здесь мы демонстрируем использование facet_wrap(). Для эпидкривых обычно проще использовать facet_wrap(), так как, скорее всего, фасетировать нужно только один столбец.\nОбщий синтаксис - facet_wrap(rows ~ cols), где слева от тильды (~) - название столбца, который будет распределен по “строкам” фасетного графика, а справа от тильды - название столбца, который будет распределен по “столбцам” фасетного графика. Проще всего использовать одно название столбца справа от тильды: facet_wrap(~age_cat).\nСвободные оси\nВам необходимо решить, будут ли шкалы осей для каждого фасета “фиксированы” на одних и тех же размерах (по умолчанию) или “свободны” (то есть будут меняться в зависимости от данных в фасете). Это можно сделать с помощью аргумента scales = в функции facet_wrap(), указав “free_x” или “free_y”, или “free”.\nКоличество столбцов и строк фасетов\nЭто может быть задано с помощью ncol = и nrow = внутри facet_wrap()..\nПорядок панелей\nЧтобы изменить порядок вывода фасетов, измените базовый порядок уровней факторного столбца, используемого для создания фасетов.\nЭстетика\nРазмер и формат шрифта, цвет полосы и т.д. могут быть изменены с помощью функции theme() с аргументами типа:\n\nstrip.text = element_text() ( размер, цвет, шрифт, угол…)\nstrip.background = element_rect() (например, element_rect(fill=“grey”))\n\nstrip.position = (положение полосы “внизу”, “вверху”, “слева” или “справа”)\n\nМетки полоски\nМетки фасетных графиков могут быть изменены через “метки” столбца как фактора или с помощью ” маркера меток”.\nСоздайте такой маркер меток, используя функцию as_labeller() из ggplot2. Затем укажите эту метку в аргументе labeller = функции facet_wrap(), как показано ниже.\n\nmy_labels &lt;- as_labeller(c(\n     \"0-4\"   = \"Ages 0-4\",\n     \"5-9\"   = \"Ages 5-9\",\n     \"10-14\" = \"Ages 10-14\",\n     \"15-19\" = \"Ages 15-19\",\n     \"20-29\" = \"Ages 20-29\",\n     \"30-49\" = \"Ages 30-49\",\n     \"50-69\" = \"Ages 50-69\",\n     \"70+\"   = \"Over age 70\"))\n\nПример фасетного графика - фасет по столбцу age_cat.\n\n# построить график\n###########\nggplot(central_data) + \n  \n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = age_cat,\n      fill = age_cat),    # аргументы внутри aes() применяются по группам\n      \n    color = \"black\",      # Аргументы вне aes() применяются ко всем данным\n        \n    # разрывы гистограммы\n    breaks = weekly_breaks_central, # предварительно заданный вектор дат (см. ранее на этой странице)\n    closed = \"слева\" # подсчет случаев от начала точки прерывания\n    )+  \n                      \n  # метки на оси х \n  scale_x_date(\n    expand            = c(0,0),          # удалить лишнее пространство по оси x под и после столбиков случаев \n    date_breaks       = \"2 months\",      # метки появляются каждые 2 месяца\n    date_minor_breaks = \"1 month\",       # вертикальные линии появляются каждый 1 месяц \n    label = scales::label_date_short())+ # форматирование меток\n  \n  # ось y \n  scale_y_continuous(expand = c(0,0))+                       # удаляет лишнее пространство по оси y между нижней частью столбиков и метками\n  \n  # темы эстетики \n  theme_minimal()+                                           # набор тем для упрощения графика\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # надпись слева курсивом\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    strip.text = element_text(face = \"bold\", size = 10),\n    strip.background = element_rect(fill = \"grey\"))+         # заголовки осей выделены жирным шрифтом\n  \n  # создать фасеты\n  facet_wrap(\n    ~age_cat,\n    ncol = 4,\n    strip.position = \"top\",\n    labeller = my_labels)+             \n  \n  # метки\n  labs(\n    title    = \"Weekly incidence of cases, by age category\",\n    subtitle = \"Subtitle\",\n    fill     = \"Age category\",                                      # задать новый заголовок для легенды\n     x        = \"Week of symptom onset\",\n    y        = \"Weekly incident cases reported\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %&gt;% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))\n\n\n\n\n\n\n\n\nБолее подробную информацию о маркере меток здесь ссылка.\n\nВся эпидемия в фасетном фоне\nЧтобы показать общую эпидемию на фоне каждого фасета, добавьте к ggplot функцию gghighlight() с пустыми скобками. Это сделано с помощью пакета gghighlight. Обратите внимание на то, что теперь максимум по оси y во всех фасетах основывается на пике всей эпидемии. Другие примеры использования этого пакета приведены на странице [Советы по использованию ggplot].\n\nggplot(central_data) + \n  \n  # эпидкривые по группам\n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = age_cat,\n      fill = age_cat),  # аргументы внутри aes() применяются по группам\n    \n    color = \"black\",    # Аргументы вне aes() применяются ко всем данным\n    \n    # разрывы гистограммы \n    breaks = weekly_breaks_central, # предварительно заданный вектор дат (см. ранее на этой странице)\n    \n    closed = \"left\", # подсчет случаев от начала точки прерывания\n    )+     # предварительно заданный вектор дат (см. начало раздела ggplot)                \n  \n  # добавить серую эпидемию к фону каждого фасета\n  gghighlight::gghighlight()+\n  \n  # метки на оси х\n  scale_x_date(\n    expand            = c(0,0),          # удалить лишнее пространство по оси x ниже и после столбиков случаев \n    date_breaks       = \"2 months\",      # метки появляются каждые 2 месяца\n    date_minor_breaks = \"1 month\",       # вертикальные линии появляются каждый 1 месяц \n    label = scales::label_date_short())+ # форматирование меток\n  \n  # ось y \n  scale_y_continuous(expand = c(0,0))+  # удаляет лишнее пространство по оси y ниже 0\n  \n  # темы эстетики \n  theme_minimal()+                                           # набор тем для упрощения графика\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # надпись слева курсивом\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    strip.text = element_text(face = \"bold\", size = 10),\n    strip.background = element_rect(fill = \"white\"))+        # заголовки осей выделены жирным шрифтом\n  \n  # создать фасеты create facets\n  facet_wrap(\n    ~age_cat,                          # каждый график - это одно значение age_cat\n    ncol = 4,                          # количество столбцов\n    strip.position = \"top\",            # положение заголовка/полосы фасета\n    labeller = my_labels)+             # маркер меток определяется выше \n  \n  # метки\n  labs(\n    title    = \"Weekly incidence of cases, by age category\",\n    subtitle = \"Subtitle\",\n    fill     = \"Age category\",                                       # задать новый заголовок для легенды\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly incident cases reported\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %&gt;% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))\n\n\n\n\n\n\n\n\n\n\nОдин фасет с данными\nЕсли вы хотите иметь один фасет, содержащий все данные, продублируйте весь набор данных и рассматривайте дубликаты как одно фасетное значение. В этом может помочь “вспомогательная” функция CreateAllFacet(), представленная ниже (см.этот пост в блоге). При ее выполнении количество строк удваивается, и появляется новый столбец facet, в котором дублированные строки будут иметь значение ” все”, а исходные строки - исходное значение столбца фасета. Теперь остается выполнить фасет на столбце facet.\nВот вспомогательная функция. Запустите ее, чтобы она была вам доступна.\n\n# Определение вспомогательной функции\nCreateAllFacet &lt;- function(df, col){\n     df$facet &lt;- df[[col]]\n     temp &lt;- df\n     temp$facet &lt;- \"all\"\n     merged &lt;-rbind(temp, df)\n     \n     # убедиться, что значение фасета является фактором\n     merged[[col]] &lt;- as.factor(merged[[col]])\n     \n     return(merged)\n}\n\nТеперь применим вспомогательную функцию к набору данных, к столбцу age_cat:\n\n# Создать дублированный набор данных с новым столбцом \" фасет\" для отображения \"всех\" возрастных категорий в качестве другого уровня фасета\ncentral_data2 &lt;- CreateAllFacet(central_data, col = \"age_cat\") %&gt;%\n  \n  # задать уровни факторов\n  mutate(facet = fct_relevel(facet, \"all\", \"0-4\", \"5-9\",\n                             \"10-14\", \"15-19\", \"20-29\",\n                             \"30-49\", \"50-69\", \"70+\"))\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `facet = fct_relevel(...)`.\nCaused by warning:\n! 1 unknown level in `f`: 70+\n\n# проверка уровней\ntable(central_data2$facet, useNA = \"always\")\n\n\n  all   0-4   5-9 10-14 15-19 20-29 30-49 50-69  &lt;NA&gt; \n  454    84    84    82    58    73    57     7     9 \n\n\nЗаметными изменениями в команде ggplot() являются:\n\nТеперь используются данные central_data2 (в два раза больше строк, с новым столбцом ” фасет”)\nНеобходимо обновить метку, если она используется.\n\nДополнительно: для получения вертикально сложенных фасетов: столбец фасет переносится в строку уравнения и справа заменяется на “.” (facet_wrap(facet~.)), а ncol = 1. Также может потребоваться настройка ширины и высоты сохраняемого изображения графика в формате png (см. ggsave() в [Советы по использованию ggplot]).\n\n\nggplot(central_data2) + \n  \n  # фактические эпидкривые по группам\n  geom_histogram(\n        mapping = aes(\n          x = date_onset,\n          group = age_cat,\n          fill = age_cat),  # аргументы внутри aes() применяются по группам\n        color = \"black\",    # Аргументы вне aes() применяются ко всем данным\n        \n        # разрывы гистограммы\n        breaks = weekly_breaks_central, # предварительно заданный вектор дат (см. ранее на этой странице)\n        \n        closed = \"left\", # подсчет случаев от начала точки прерывания\n        )+    # предварительно заданный вектор дат (см. начало раздела ggplot)\n                     \n  # Метки на оси x\n  scale_x_date(\n    expand            = c(0,0),          # удалить лишнее пространство по оси x под и после гистограмм\n    date_breaks       = \"2 months\",      # метки появляются каждые 2 месяца\n    date_minor_breaks = \"1 month\",       # вертикальные линии появляются каждые 1 месяц \n    label = scales::label_date_short())+ # автоматическое форматирование меток\n  \n  # ось y\n  scale_y_continuous(expand = c(0,0))+  # удаляет лишнее пространство по оси y между нижней частью столбиков и метками\n  \n  # эстетические темы\n  theme_minimal()+                                           # набор тем для упрощения графика\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # надпись слева курсивом\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\")+               \n  \n  # создать фасеты\n  facet_wrap(facet~. ,                            # каждый график представляет собой одно значение фасета\n             ncol = 1)+            \n\n  # метки\n  labs(title    = \"Weekly incidence of cases, by age category\",\n       subtitle = \"Subtitle\",\n       fill     = \"Age category\",                                      # задать новый заголовок для легенды\n       x        = \"Week of symptom onset\",\n       y        = \"Weekly incident cases reported\",\n       caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %&gt;% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Эпидемические кривые</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.ru.html#предварительные-данные",
    "href": "new_pages/epicurves.ru.html#предварительные-данные",
    "title": "32  Эпидемические кривые",
    "section": "32.3 Предварительные данные",
    "text": "32.3 Предварительные данные\nСамые недавние данные, представленные на эпидкривых, часто должны быть помечены как предварительные или с учетом задержек в представлении информации. Это можно сделать, добавив вертикальную линию и/или прямоугольник за определенное количество дней. Ниже приведены два варианта:\n\nИспользуйте функцию annotate():\n\nДля линии используйте annotate(geom = \"segment\"). Укажите x, xend, y и yend. Настройте размер, тип линии (lty) и цвет.\n\nДля прямоугольника используйте annotate(geom = \"rect\"). Укажите xmin/xmax/ymin/ymax. Настройте цвет и альфу.\n\n\nСгруппируйте данные по предварительному статусу и раскрасьте эти столбики по-разному\n\nВНИМАНИЕ: Для построения прямоугольника можно попробовать geom_rect(), но регулировка прозрачности не подходит в контексте построчного списка. Данная функция накладывает один прямоугольник на каждое наблюдение/строку! Используйте либо очень низкую альфу (например, 0.01), либо другой подход. \n\nИспользование annotate()\n\nВнутри annotate(geom = \"rect\") аргументы xmin и xmax должны иметь значения класса Дата.\n\nОбратите внимание на то, что поскольку данные агрегируются в недельные столбики, а последний столбик простирается до понедельника после последней точки данных, то может показаться, что заштрихованная область охватывает 4 недели\n\nВот annotate() онлайн пример\n\n\nggplot(central_data) + \n  \n  # гистограмма\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    breaks = weekly_breaks_central,   # предопределенный вектор дат - см. верхнюю часть раздела ggplot\n    \n    closed = \"left\", # подсчет случаев от начала точки прерывания\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") +\n\n  # шкалы\n  scale_y_continuous(expand = c(0,0))+\n  scale_x_date(\n    expand = c(0,0),                     # удалить лишнее пространство по оси x под и после столбиков случая\n    date_breaks = \"1 month\",             # 1-е число месяца\n    date_minor_breaks = \"1 month\",       # 1-е число месяца\n    label = scales::label_date_short())+ # автоматическое форматирование меток\n  \n  # метки и тема\n  labs(\n    title = \"Using annotate()\\nRectangle and line showing that data from last 21-days are tentative\",\n    x = \"Week of symptom onset\",\n    y = \"Weekly case indicence\")+ \n  theme_minimal()+\n  \n  # добавить полупрозрачный красный прямоугольник к предварительным данным\n  annotate(\n    \"rect\",\n    xmin  = as.Date(max(central_data$date_onset, na.rm = T) - 21), # Примечание должно быть обернуто в as.Date()\n    xmax  = as.Date(Inf),                                          # Примечание должно быть обернуто в as.Date()\n    ymin  = 0,\n    ymax  = Inf,\n    alpha = 0.2,          # альфа легко и интуитивно настраивается с помощью функции annotate()\n    fill  = \"red\")+\n  \n  # добавьте черную вертикальную линию поверх других слоев\n  annotate(\n    \"segment\",\n    x     = max(central_data$date_onset, na.rm = T) - 21, # 21 день до получения последних данных\n    xend  = max(central_data$date_onset, na.rm = T) - 21, \n    y     = 0,         # линия начинается в точке y = 0\n    yend  = Inf,       # линия к вершине графика\n    size  = 2,         # размер линии\n    color = \"black\",\n    lty   = \"solid\")+   # Тип линии, например, \"сплошная\", \"пунктирная\"\n\n  # добавить текст в прямоугольник\n  annotate(\n    \"text\",\n    x = max(central_data$date_onset, na.rm = T) - 15,\n    y = 15,\n    label = \"Subject to reporting delays\",\n    angle = 90)\n\n\n\n\n\n\n\n\nТакую же черную вертикальную линию можно получить с помощью приведенного ниже кода, но при использовании geom_vline() теряется возможность управления высотой:\n\ngeom_vline(xintercept = max(central_data$date_onset, na.rm = T) - 21,\n           size = 2,\n           color = \"black\")\n\n\n\nЦвет столбиков\nАльтернативным подходом может быть настройка цвета или отображения самих столбиков предварительных данных. Можно создать новый столбец на этапе подготовки данных и использовать его для группировки данных таким образом, чтобы aes(fill = ) предварительных данных мог быть другого цвета или альфа, чем другие столбцы.\n\n# добавить столбец\n############\nplot_data &lt;- central_data %&gt;% \n  mutate(tentative = case_when(\n    date_onset &gt;= max(date_onset, na.rm=T) - 7 ~ \"Tentative\", # предварительно, если за последние 7 дней\n    TRUE                                       ~ \"Reliable\")) # все остальные данные надежные\n\n# график\n######\nggplot(plot_data, aes(x = date_onset, fill = tentative)) + \n  \n  # гистограмма\n  geom_histogram(\n    breaks = weekly_breaks_central,   # предопределенный вектор данных, см. верхнюю часть страницы ggplot\n    closed = \"left\", # подсчет случаев от начала точки прерывания\n    color = \"black\") +\n\n  # гкалы\n  scale_y_continuous(expand = c(0,0))+\n  scale_fill_manual(values = c(\"lightblue\", \"grey\"))+\n  scale_x_date(\n    expand = c(0,0),                     # удалить лишнее пространство по оси x под и после столбиков случая \n    date_breaks = \"3 weeks\",             # Понедельник каждые 3 недели\n    date_minor_breaks = \"week\",          # Недели с понедельника\n    label = scales::label_date_short())+ # автоматическое форматирование меток\n  \n  # метки и тема\n  labs(title = \"Show days that are tentative reporting\",\n    subtitle = \"\")+ \n  theme_minimal()+\n  theme(legend.title = element_blank())                 # удалить заголовок легенды",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Эпидемические кривые</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.ru.html#многоуровневые-метки-даты",
    "href": "new_pages/epicurves.ru.html#многоуровневые-метки-даты",
    "title": "32  Эпидемические кривые",
    "section": "32.4 Многоуровневые метки даты",
    "text": "32.4 Многоуровневые метки даты\nЕсли вам нужны многоуровневые метки даты (например, месяц и год) без дублирования нижних уровней меток, рассмотрите один из описанных ниже подходов:\nПомните - вы можете использовать такие инструменты, как \\n внутри аргументов date_labels или labels, чтобы поместить части каждой метки на новую строку ниже. Однако приведенные ниже коды помогут вам вынести годы или месяцы (например) на нижнюю строку и только один раз.\nСамый простой способ - присвоить аргумент labels = в scale_x_date() функции label_date_short() из пакета scales (внимание: не забудьте включить пустые круглые скобки (), как показано ниже). Эта функция автоматически строит эффективные метки даты (подробнее здесь). Дополнительным преимуществом этой функции является то, что метки будут автоматически подстраиваться по мере расширения данных во времени: от дней, недель, месяцев и лет.\n\nggplot(central_data) + \n  \n  # гистограмма\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    breaks = weekly_breaks_central,   # предопределенный вектор дат - см. верхнюю часть раздела ggplot\n    closed = \"left\",                  # подсчет случаев от начала точки прерывания\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n\n  # Масштаб оси y, как и раньше\n  scale_y_continuous(expand = c(0,0))+\n  \n  # Масштаб оси x задает удобные метки даты\n  scale_x_date(\n    expand = c(0,0),                      # удалить лишнее пространство по оси x под и после стобиков случая\n    labels = scales::label_date_short())+ # автоматические удобные метки с датой\n  \n  # метки и темы\n  labs(\n    title = \"Using label_date_short()\\nTo make automatic and efficient date labels\",\n    x = \"Week of symptom onset\",\n    y = \"Weekly case indicence\")+ \n  theme_minimal()\n\n\n\n\n\n\n\n\nВторой вариант - использование фасетирования. Ниже:\n\nКоличество случаев агрегировано по неделям из эстетических соображений. Подробности см. на странице эпидкривые (вкладка Агрегированные данные).\n\nВместо гистограммы используется линия geom_area(), так как подход фасетирования, описанный ниже, не очень хорошо подходит для работы с гистограммами.\n\nАгрегирование до еженедельных подсчетов\n\n# Создание набора данных о количестве случаев по неделям\n#######################################\ncentral_weekly &lt;- linelist %&gt;%\n  filter(hospital == \"Central Hospital\") %&gt;%   # фильтр построчного списка\n  mutate(week = lubridate::floor_date(date_onset, unit = \"weeks\")) %&gt;%  \n  count(week) %&gt;%                              # обобщение еженедельных данных о количестве случаев\n  drop_na(week) %&gt;%                            # удалить случаи с отсутствующей датой начала заболевания\n  complete(                                    # заполнить все недели, в которые не было зарегистрировано ни одного случая\n    week = seq.Date(\n      from = min(week),   \n      to   = max(week),\n      by   = \"week\"),\n    fill = list(n = 0))                        # преобразование новых значений NA в 0 подсчетов\n\nСоздание графиков\n\n# график без границы фасетного поля\n#################################\nggplot(central_weekly,\n       aes(x = week, y = n)) +              # установить x и y для всего графика\n  geom_line(stat = \"identity\",              # создать линию, высота линии - число подсчета\n            color = \"#69b3a2\") +            # цвет линии\n  geom_point(size=1, color=\"#69b3a2\") +     # нанести точки на еженедельные точки данных\n  geom_area(fill = \"#69b3a2\",               # заливка области под линией\n            alpha = 0.4)+                   # прозрачность заливки\n  scale_x_date(date_labels=\"%b\",            # формат метки даты показывает месяц \n               date_breaks=\"month\",         # метки с датой 1-го числа каждого месяца\n               expand=c(0,0)) +             # удаление лишнего пространства\n  scale_y_continuous(\n    expand  = c(0,0))+                      # удалить лишнее пространство под осью x\n  facet_grid(~lubridate::year(week),        # фасет по году (из столбца класса Дата)\n             space=\"free_x\",                \n             scales=\"free_x\",               # Оси x адаптируются к диапазону данных (не \"фиксируются\")\n             switch=\"x\") +                  # фасетные метки (год) в нижней части\n  theme_bw() +\n  theme(strip.placement = \"outside\",                  # размещение фасетных меток\n          strip.background = element_blank(),         # фон фасетной таблицы отсутствует\n          panel.grid.minor.x = element_blank(),          \n          panel.border = element_blank(),             # Границы у панели фасетов отсутствуют\n          panel.spacing=unit(0,\"cm\"))+                # Пространство между фасетными панелями отсутствует\n  labs(title = \"Nested year labels - points, shaded, no label border\")\n\n\n\n\n\n\n\n\nПриведенная выше техника фасетирования была адаптирована из сообщений здесь и здесь на сайте stackoverflow.com.",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Эпидемические кривые</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.ru.html#двойные-оси",
    "href": "new_pages/epicurves.ru.html#двойные-оси",
    "title": "32  Эпидемические кривые",
    "section": "32.5 Двойные оси",
    "text": "32.5 Двойные оси\nНесмотря на то, что в сообществе визуализации данных ведутся ожесточенные дискуссии о правомерности использования двойных осей, многие руководители эпидемиологических исследований по-прежнему хотят использовать эпидкривую или подобный график с процентами, наложенными на вторую ось. Более подробно этот вопрос рассматривается на странице [Советы по использованию ggplot], но ниже приведен один пример с использованием метода cowplot:\n\nСтроятся два разных графика, которые затем объединяются с помощью пакета cowplot.\n\nГрафики должны иметь совершенно одинаковую ось x (заданные границы), иначе данные и метки не будут совпадать.\n\nВ каждом из них используется theme_cowplot(), причем в одном из них ось y перенесена в правую часть графика\n\n\n#загрузка пакета\npacman::p_load(cowplot)\n\n# Построить первый график гистограммы эпидкривой\n#######################################\nplot_cases &lt;- linelist %&gt;% \n  \n  # Количество случаев в неделю\n  ggplot()+\n  \n  # построить гистограмму  \n  geom_histogram(\n    \n    mapping = aes(x = date_onset),\n    \n    # Разрывы корзины каждую неделю, начиная с понедельника перед первым случаем и заканчивая понедельником после последнего случая\n    breaks = weekly_breaks_all)+  # предварительно заданный вектор недельных дат (см. начало раздела ggplot)\n        \n  # указать начало и конец оси дат для выравнивания с другими графиками\n  scale_x_date(\n    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # минимум/максимум заданных недельных разрывов гистограммы\n  \n  # метки\n  labs(\n      y = \"Daily cases\",\n      x = \"Date of symptom onset\"\n    )+\n  theme_cowplot()\n\n\n# построить второй график процента умерших за неделю\n###########################################\nplot_deaths &lt;- linelist %&gt;%                        # начать с построчного списка\n  group_by(week = floor_date(date_onset, \"week\")) %&gt;%  # create week column\n  \n  # Суммировать, чтобы получить еженедельный процент умерших\n  summarise(n_cases = n(),\n            died = sum(outcome == \"Death\", na.rm=T),\n            pct_died = 100*died/n_cases) %&gt;% \n  \n  # начать построение графика\n  ggplot()+\n  \n  # строка еженедельного процента погибших\n  geom_line(                                # создать линию процента смертей\n    mapping = aes(x = week, y = pct_died),  # указать высоту y в качестве столбца pct_died\n    stat = \"identity\",                      # установить высоту строки равной значению в столбце pct_death, а не количеству строк (которое задано по умолчанию)\n    size = 2,\n    color = \"black\")+\n  \n  # Те же границы оси дат, что и на другом графике - идеальное выравнивание\n  scale_x_date(\n    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # минимум/максимум заданных недельных разрывов гистограммы\n  \n  \n  # регулировки по оси y\n  scale_y_continuous(                # отрегулировать ось y\n    breaks = seq(0,100, 10),         # установка интервалов разрывов по оси процентов\n    limits = c(0, 100),              # задать протяженность оси процентов\n    position = \"right\")+             # сдвинуть ось процентов вправо\n  \n  # Метка по оси Y, метка по оси X отсутствует\n  labs(x = \"\",\n       y = \"Percent deceased\")+      # метка оси процентов\n  \n  theme_cowplot()                   # добавьте это, чтобы два графика хорошо объединились\n\nТеперь используйте cowplot для наложения двух графиков. Внимание было уделено выравниванию по оси x, стороне оси y и использованию theme_cowplot().\n\naligned_plots &lt;- cowplot::align_plots(plot_cases, plot_deaths, align=\"hv\", axis=\"tblr\")\nggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Эпидемические кривые</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.ru.html#кумулятивная-заболеваемость",
    "href": "new_pages/epicurves.ru.html#кумулятивная-заболеваемость",
    "title": "32  Эпидемические кривые",
    "section": "32.6 Кумулятивная заболеваемость",
    "text": "32.6 Кумулятивная заболеваемость\nПримечание: При использовании incidence2 см. раздел о том, как можно получить кумулятивную заболеваемость с помощью простой функции. На этой странице мы рассмотрим, как рассчитать кумулятивную заболеваемость и построить ее с помощью функции ggplot().\nЕсли вы начинаете с построчного списка случаев, создайте новый столбец, содержащий суммарное количество случаев за день во вспышке, используя функцию cumsum() из базового R:\n\ncumulative_case_counts &lt;- linelist %&gt;% \n  count(date_onset) %&gt;%                # количество строк за день (возвращается в столбец \"n\")   \n  mutate(                         \n    cumulative_cases = cumsum(n)       # новый столбец суммарного количества строк на каждую дату\n    )\n\nПервые 10 строк показаны ниже:\n\n\n\n\n\n\nЗатем этот кумулятивный столбец может быть построен по отношению к date_onset с помощью функции geom_line():\n\nplot_cumulative &lt;- ggplot()+\n  geom_line(\n    data = cumulative_case_counts,\n    aes(x = date_onset, y = cumulative_cases),\n    size = 2,\n    color = \"blue\")\n\nplot_cumulative\n\n\n\n\n\n\n\n\nЕго также можно наложить на эпидкривую с двумя осями с помощью метода cowplot, описанного выше и на странице [Советы по использованию с ggplot]:\n\n#загрузка пакета\npacman::p_load(cowplot)\n\n# Построить первый график гистограммы эпидкривой\nplot_cases &lt;- ggplot()+\n  geom_histogram(          \n    data = linelist,\n    aes(x = date_onset),\n    binwidth = 1)+\n  labs(\n    y = \"Daily cases\",\n    x = \"Date of symptom onset\"\n  )+\n  theme_cowplot()\n\n# построить второй график линии кумулятивных случаев\nplot_cumulative &lt;- ggplot()+\n  geom_line(\n    data = cumulative_case_counts,\n    aes(x = date_onset, y = cumulative_cases),\n    size = 2,\n    color = \"blue\")+\n  scale_y_continuous(\n    position = \"right\")+\n  labs(x = \"\",\n       y = \"Cumulative cases\")+\n  theme_cowplot()+\n  theme(\n    axis.line.x = element_blank(),\n    axis.text.x = element_blank(),\n    axis.title.x = element_blank(),\n    axis.ticks = element_blank())\n\nТеперь используйте cowplot для наложения двух графиков. Внимание было уделено выравниванию по оси x, стороне оси y и использованию theme_cowplot().\n\naligned_plots &lt;- cowplot::align_plots(plot_cases, plot_cumulative, align=\"hv\", axis=\"tblr\")\nggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Эпидемические кривые</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.ru.html#ресурсы",
    "href": "new_pages/epicurves.ru.html#ресурсы",
    "title": "32  Эпидемические кривые",
    "section": "32.7 Ресурсы",
    "text": "32.7 Ресурсы",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Эпидемические кривые</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.ru.html",
    "href": "new_pages/age_pyramid.ru.html",
    "title": "33  Демографические пирамиды и шкалы Лайкерта",
    "section": "",
    "text": "33.1 Подготовка",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Демографические пирамиды и шкалы Лайкерта</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.ru.html#подготовка",
    "href": "new_pages/age_pyramid.ru.html#подготовка",
    "title": "33  Демографические пирамиды и шкалы Лайкерта",
    "section": "",
    "text": "Загрузка пакетов\nВ этом фрагменте кода показана загрузка пакетов, необходимых для проведения анализа. В данном руководстве мы делаем акцент на p_load() из pacman, которая при необходимости устанавливает пакет и загружает его для использования. Установленные пакеты можно также загрузить с помощью library() из базового R. Более подробную информацию о пакетах R см. на странице Основы R.\n\npacman::p_load(rio,       # для импорта данных\n               here,      # для поиска файлов\n               tidyverse, # для вычистки, обработки и построения графиков данных (включает пакет ggplot2)\n               apyramid,  # пакет, предназначенный для создания возрастных пирамид\n               janitor,   # таблицы и вычистка данных\n               stringr)   # работа с последовательностями для заголовков, подписей и т.д.\n\n\n\nИмпорт данных\nДля начала мы импортируем построчный список случаев из смоделированной эпидемии лихорадки Эбола. Если вы хотите выполнять действия параллельно, нажмите кнопку, чтобы загрузить “чистый” построчный список (в виде файла .rds). Импортируйте данные с помощью функции import() из пакета rio (она работает со многими типами файлов, такими как .xlsx, .csv, .rds - подробности см. на странице Импорт и экспорт).\n\n# импортировать построчный список\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nНиже отображаются первые 50 строк построчного списка.\n\n\n\n\n\n\n\n\nВычистка\nДля построения традиционной возрастно-половой демографической пирамиды необходимо произвести вычистку данных следующим образом:\n\nВычистке подлежит столбец “Пол”.\n\nВ зависимости от используемого метода возраст должен храниться либо как числовое значение, либо в столбце возрастные категории.\n\nЕсли используются возрастные категории, то значения столбца должны быть упорядочены, либо по умолчанию буквенно-цифровые, либо намеренно заданы путем преобразования к коэффициенту класса.\nНиже мы используем tabyl() из janitor для проверки столбцов gender и age_cat5.\n\nlinelist %&gt;% \n  tabyl(age_cat5, gender)\n\n age_cat5   f   m NA_\n      0-4 640 416  39\n      5-9 641 412  42\n    10-14 518 383  40\n    15-19 359 364  20\n    20-24 305 316  17\n    25-29 163 259  13\n    30-34 104 213   9\n    35-39  42 157   3\n    40-44  25 107   1\n    45-49   8  80   5\n    50-54   2  37   1\n    55-59   0  30   0\n    60-64   0  12   0\n    65-69   0  12   1\n    70-74   0   4   0\n    75-79   0   0   1\n    80-84   0   1   0\n      85+   0   0   0\n     &lt;NA&gt;   0   0  86\n\n\nМы также быстро строим гистограмму для столбца возраст, чтобы убедиться, что он чист и правильно классифицирован:\n\nhist(linelist$age)",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Демографические пирамиды и шкалы Лайкерта</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.ru.html#пакет-apyramid",
    "href": "new_pages/age_pyramid.ru.html#пакет-apyramid",
    "title": "33  Демографические пирамиды и шкалы Лайкерта",
    "section": "33.2 Пакет apyramid",
    "text": "33.2 Пакет apyramid\nПакет apyramid является продуктом проекта R4Epis. Подробнее об этом пакете можно прочитать здесь. Он позволяет быстро построить возрастную пирамиду. Для более сложных ситуаций см. раздел ниже использование ggplot(). Более подробно о пакете apyramid можно прочитать на его справочной странице, введя в консоли R команду ?age_pyramid.\n\nДанные построчного списка\nИспользуя вычистку данных построчного списка, мы можем создать возрастную пирамиду с помощью одной простой команды age_pyramid(). В этой команде:\n\nВ качестве аргумента data = задается датафрейм linelist.\n\nАргумент age_group = (для оси y) задается в виде названия категориального столбца возраста (в кавычках)\n\nАргумент `split_by = (для оси x) задается для столбца пол\n\n\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\")\n\n\n\n\n\n\n\n\nПирамиду можно отобразить на оси x не в виде количества, а в виде процента от всех случаев, включив proportional = TRUE.\n\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\",\n                      proportional = TRUE)\n\n\n\n\n\n\n\n\nПри использовании пакета agepyramid, если столбец split_by является бинарным (например, мужчина/женщина, или да/нет), то результат будет иметь вид пирамиды. Однако если в столбце split_by более двух значений (не считая NA), то пирамида будет выглядеть как фасетная столбчатая диаграмма с серыми полосами на “фоне”, указывающими на диапазон нефасетных данных для данной возрастной группы. При этом значения split_by = будут отображаться в виде меток в верхней части каждой фасетной панели. Например, ниже показано, что произойдет, если значению split_by = будет присвоен столбец hospital.\n\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"hospital\")  \n\n\n\n\n\n\n\n\n\nОтсутствующие значения\nСтроки с пропущенными значениями NA в столбцах split_by = или age_group =, если они кодированы как NA, не будут приводить к фасетированию, показанному выше. По умолчанию эти строки не отображаются. Однако можно указать, чтобы они отображались на соседней гистограмме и в виде отдельной возрастной группы вверху, задав na.rm = FALSE.\n\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\",\n                      na.rm = FALSE)         # показывать пациентов, у которых отсутствует возраст или пол\n\n\n\n\n\n\n\n\n\n\nПропорции, цвета и эстетика\nПо умолчанию столбики отображают подсчеты (не %), пунктирная средняя линия для каждой группы, а цвета - зеленый/пурпурный. Каждый из этих параметров может быть изменен, как показано ниже:\nКроме того, с помощью стандартного синтаксиса ggplot() “+” можно добавлять к графику дополнительные команды, такие как эстетические темы и корректировка меток:\n\napyramid::age_pyramid(\n  data = linelist,\n  age_group = \"age_cat5\",\n  split_by = \"gender\",\n  proportional = TRUE,              # показывать проценты, а не подсчеты\n  show_midpoint = FALSE,            # удалить линию середины столбика\n  #pal = c(\"orange\", \"purple\")      # здесь можно указать альтернативные цвета (но не метки)\n  )+                 \n  \n  # дополнительные команды ggplot\n  theme_minimal()+                               # упростить фон\n  scale_fill_manual(                             # указать цвета И метки\n    values = c(\"orange\", \"purple\"),              \n    labels = c(\"m\" = \"Male\", \"f\" = \"Female\"))+\n  labs(y = \"Percent of all cases\",              # обратите внимание, что labs x и y поменялись местами\n       x = \"Age categories\",                          \n       fill = \"Gender\", \n       caption = \"My data source and caption here\",\n       title = \"Title of my plot\",\n       subtitle = \"Subtitle with \\n a second line...\")+\n  theme(\n    legend.position = \"bottom\",                          # легенда к низу\n    axis.text = element_text(size = 10, face = \"bold\"),  # шрифты/размеры\n    axis.title = element_text(size = 12, face = \"bold\"))\n\n\n\n\n\n\n\n\n\n\n\nАгрегированные данные\nВ приведенных примерах предполагается, что данные представлены в виде построчного списка, каждая строка которого приходится на одно наблюдение. Если ваши данные уже агрегированы в подсчеты по возрастным категориям, вы можете использовать пакет apyramid, как показано ниже.\nДля демонстрации мы агрегируем данные построчного списка в подсчеты по возрастной категории и по полу в “широком” формате. В результате будет создано впечатление, что данные изначально представлены в виде подсчетов. Подробнее см. страницы [Группирование данных] и [Поворот данных],\n\ndemo_agg &lt;- linelist %&gt;% \n  count(age_cat5, gender, name = \"cases\") %&gt;% \n  pivot_wider(\n    id_cols = age_cat5,\n    names_from = gender,\n    values_from = cases) %&gt;% \n  rename(`missing_gender` = `NA`)\n\n…в результате чего набор данных выглядит следующим образом: со столбцами для возрастной категории, а также со столбцами для количества мужчин, количества женщин и количества отсутствующих..\n\n\n\n\n\n\nЧтобы настроить эти данные для возрастной пирамиды, мы повернем их вертикально с помощью функции pivot_longer() из dplyr. Это связано с тем, что функция ggplot() обычно предпочитает “длинные” данные, а в apyramid используется ggplot().\n\n# поворот агрегированных данных в длинный формат\ndemo_agg_long &lt;- demo_agg %&gt;% \n  pivot_longer(\n    col = c(f, m, missing_gender),            # удлинение столбцов\n    names_to = \"gender\",                # название для нового столбца категорий\n    values_to = \"counts\") %&gt;%           # название для нового столбца подсчетов\n  mutate(\n    gender = na_if(gender, \"missing_gender\")) # преобразовать \"missing_gender\" в NA\n\n\n\n\n\n\n\nЗатем с помощью аргументов split_by = и count = функции age_pyramid() указать соответствующие столбцы в данных:\n\napyramid::age_pyramid(data = demo_agg_long,\n                      age_group = \"age_cat5\",# название столбца для возрастной категории\n                      split_by = \"gender\",   # название столбца для пола\n                      count = \"counts\")      # название столбца для подсчета количества случаев\n\n\n\n\n\n\n\n\nОбратите внимание, что порядок факторов “m” и “f” отличается (пирамида перевернута). Для корректировки порядка необходимо переопределить пол в агрегированных данных как Фактор и упорядочить уровни по желанию. См. страницу [Факторы].",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Демографические пирамиды и шкалы Лайкерта</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.ru.html#demo_pyr_gg",
    "href": "new_pages/age_pyramid.ru.html#demo_pyr_gg",
    "title": "33  Демографические пирамиды и шкалы Лайкерта",
    "section": "33.3 ggplot()",
    "text": "33.3 ggplot()\nИспользование ggplot() для построения возрастной пирамиды позволяет добиться большей гибкости, но требует больших усилий и понимания принципов работы ggplot(). Кроме того, в этом случае легче случайно допустить ошибки.\nЧтобы использовать функцию ggplot() для построения демографических пирамид, необходимо создать два столбчатых графика (по одному для каждого пола), преобразовать значения на одном графике в отрицательные, а затем перевернуть оси x и y, чтобы отобразить столбчатые графики вертикально, а их основания сошлись в середине графика.\n\nПодготовка\nВ данном подходе используется числовой столбец возраста, а не категориальный столбец age_cat5. Поэтому мы проверим, действительно ли класс этого столбца является числовым.\n\nclass(linelist$age)\n\n[1] \"numeric\"\n\n\nАналогичную логику можно использовать для построения пирамиды из категориальных данных, используя geom_col() вместо geom_histogram().\n\n\n\nПостроение графика\nВо-первых, следует понимать, что для построения такой пирамиды с помощью ggplot() используется следующий подход:\n\nВнутри ggplot() создайте две гистограммы, используя числовой столбец возраста. По одной для каждого из двух значений группировки (в данном случае мужского и женского полов). Для этого данные для каждой гистограммы задаются в соответствующих командах geom_histogram(), а соответствующие фильтры применяются к linelist.\nНа одном графике будут положительные значения подсчетов, а на другом - отрицательные, что создает “пирамиду” со значением 0 в середине графика. Отрицательные значения создаются с помощью специального ggplot2 термина ..count.. и умножения на -1.\nКоманда coord_flip() переключает оси X и Y, в результате чего графики становятся вертикальными и образуют пирамиду.\nНаконец, необходимо изменить метки значений оси подсчетов таким образом, чтобы они отображались как “положительные” подсчеты на обеих сторонах пирамиды (несмотря на то, что базовые значения на одной из сторон отрицательны).\n\nНиже приводится простая версия этого варианта с использованием geom_histogram():\n\n  # начать  ggplot\n  ggplot(mapping = aes(x = age, fill = gender)) +\n  \n  # гистограмма женского пола\n  geom_histogram(data = linelist %&gt;% filter(gender == \"f\"),\n                 breaks = seq(0,85,5),\n                 colour = \"white\") +\n  \n  # гистограмма мужского пола (значения приведены к отрицательным)\n  geom_histogram(data = linelist %&gt;% filter(gender == \"m\"),\n                 breaks = seq(0,85,5),\n                 mapping = aes(y = ..count..*(-1)),\n                 colour = \"white\") +\n  \n  # перевернуть оси X и Y\n  coord_flip() +\n  \n  # настройка масштаба оси подсчета\n  scale_y_continuous(limits = c(-600, 900),\n                     breaks = seq(-600,900,100),\n                     labels = abs(seq(-600, 900, 100)))\n\n\n\n\n\n\n\n\nВНИМАНИЕ: Если задать слишком низкие границы по оси подсчетов, а столбец подсчетов превысит их, то столбец исчезнет совсем или будет искусственно укорочен! Следите за этим, если анализируете данные, которые регулярно обновляются. Во избежание этого границы оси подсчетов должны автоматически подстраиваться под данные, как показано ниже.\nВ этой простой версии можно многое изменить/дополнить, в том числе:\n\nАвтоматическая настройка масштаба оси подсчета в соответствии с вашими данными (во избежание ошибок, о которых говорится в предупреждении ниже)\n\nВручную задавать цвета и метки легенды\n\nПреобразование подсчетов в проценты.\nЧтобы преобразовать подсчеты в проценты (от общего числа), сделайте это в своих данных перед построением графика. Ниже мы получаем подсчеты по возрасту и полу, затем ungroup(), а затем mutate() для создания новых процентных столбцов. Если вам нужны проценты по полу, пропустите шаг разгруппировки.\n\n# создать набор данных с долей от общего числа\npyramid_data &lt;- linelist %&gt;%\n  count(age_cat5,\n        gender,\n        name = \"counts\") %&gt;% \n  ungroup() %&gt;%                 # разгруппировать, чтобы проценты были не по группам\n  mutate(percent = round(100*(counts / sum(counts, na.rm=T)), digits = 1), \n         percent = case_when(\n            gender == \"f\" ~ percent,\n            gender == \"m\" ~ -percent,     # преобразование мужского пола в отрицательные значения\n            TRUE          ~ NA_real_))    # значение NA должно быть также числовым\n\nВажно отметить, что мы сохраняем максимальное и минимальное значения, чтобы знать, какими должны быть границы шкалы. Они будут использованы в команде ggplot() ниже.\n\nmax_per &lt;- max(pyramid_data$percent, na.rm=T)\nmin_per &lt;- min(pyramid_data$percent, na.rm=T)\n\nmax_per\n\n[1] 10.9\n\nmin_per\n\n[1] -7.1\n\n\nНаконец, мы выполняем функцию ggplot() для процентных данных. Мы указываем scale_y_continuous() для увеличения предварительно заданных длин в каждом направлении (положительном и “отрицательном”). Мы используем floor() и ceiling() для округления десятичных дробей в соответствующую сторону (вниз или вверх) для стороны оси.\n\n# начать ggplot\n  ggplot()+  # По оси x по умолчанию указан возраст в годах;\n\n  # графа данных о случае\n  geom_col(data = pyramid_data,\n           mapping = aes(\n             x = age_cat5,\n             y = percent,\n             fill = gender),         \n           colour = \"white\")+       # белый цвет вокруг каждого столбика\n  \n  # переверните оси X и Y, чтобы пирамида стала вертикальной\n  coord_flip()+\n  \n\n  # настройка масштабов осей\n  # масштаб_x_непрерывный( разрывы = послед(0,100,5), метки = послед(0,100,5)) +\n  scale_y_continuous(\n    limits = c(min_per, max_per),\n    breaks = seq(from = floor(min_per),                # последовательность значений, по 2s\n                 to = ceiling(max_per),\n                 by = 2),\n    labels = paste0(abs(seq(from = floor(min_per),     # последовательность абсолютных значений, по 2с, с \"%\"\n                            to = ceiling(max_per),\n                            by = 2)),\n                    \"%\"))+  \n\n  # назначение цветов и меток легенды вручную\n  scale_fill_manual(\n    values = c(\"f\" = \"orange\",\n               \"m\" = \"darkgreen\"),\n    labels = c(\"Female\", \"Male\")) +\n  \n  # значения меток (помните, что X и Y теперь перевернуты)\n  labs(\n    title = \"Age and gender of cases\",\n    x = \"Age group\",\n    y = \"Percent of total\",\n    fill = NULL,\n    caption = stringr::str_glue(\"Data are from linelist \\nn = {nrow(linelist)} (age or sex missing for {sum(is.na(linelist$gender) | is.na(linelist$age_years))} cases) \\nData as of: {format(Sys.Date(), '%d %b %Y')}\")) +\n  \n  # отобразить темы\n  theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    axis.line = element_line(colour = \"black\"),\n    plot.title = element_text(hjust = 0.5), \n    plot.caption = element_text(hjust=0, size=11, face = \"italic\")\n    )\n\n\n\n\n\n\n\n\n\n\n\nСравнить с исходным уровнем\nБлагодаря гибкости функции ggplot() можно получить второй слой столбиков на заднем плане, представляющих “истинную” или ” исходную” пирамиду населения. Это может дать хорошую визуализацию для сравнения наблюдаемых и исходных данных.\nИмпортируйте и просмотрите данные о численности населения (см. страницу [Скачивание руководства и данных]):\n\n# импорт демографических данных населения\npop &lt;- rio::import(\"country_demographics.csv\")\n\n\n\n\n\n\n\nСначала несколько шагов по управлению данными:\nЗдесь мы записываем порядок возрастных категорий, которые мы хотим получить. Из-за некоторых особенностей работы функции ggplot() в данном конкретном сценарии проще всего хранить их в виде символьного вектора и использовать позже в функции построения графика.\n\n# записать правильные уровни возрастных категорий\nage_levels &lt;- c(\"0-4\",\"5-9\", \"10-14\", \"15-19\", \"20-24\",\n                \"25-29\",\"30-34\", \"35-39\", \"40-44\", \"45-49\",\n                \"50-54\", \"55-59\", \"60-64\", \"65-69\", \"70-74\",\n                \"75-79\", \"80-84\", \"85+\")\n\nОбъедините данные по населению и случаю с помощью dplyr функции bind_rows():\n\nВо-первых, убедитесь, что они имеют одинаковые названия столбцов, значения возрастных категорий и пола.\n\nПусть они имеют одинаковую структуру данных: столбцы возрастной категории, пола, количества и процента от общего числа\n\nСвяжите их вместе, один поверх другого (bind_rows())\n\n\n# создание/преобразование данных о населении с указанием процента от общей численности\n########################################################\npop_data &lt;- pop %&gt;% \n  pivot_longer(      # поворот столбцов по полу в длину\n    cols = c(m, f),\n    names_to = \"gender\",\n    values_to = \"counts\") %&gt;% \n  \n  mutate(\n    percent  = round(100*(counts / sum(counts, na.rm=T)),1),  # % от общего количества\n    percent  = case_when(                                                        \n     gender == \"f\" ~ percent,\n     gender == \"m\" ~ -percent,               # если мужской пол, перевести % в отрицательное значение\n     TRUE          ~ NA_real_))\n\nПросмотр измененного набора данных о населении\n\n\n\n\n\n\nТеперь сделаем то же самое для построчного списка случаев. Он немного отличается тем, что начинается со строк случаев, а не с подсчетов.\n\n# создать данные о случаях с разбивкой по возрасту/полу, с указанием процента от общего числа случаев\n#######################################################\ncase_data &lt;- linelist %&gt;%\n  count(age_cat5, gender, name = \"counts\") %&gt;%  # подсчеты по половозрастным группам\n  ungroup() %&gt;% \n  mutate(\n    percent = round(100*(counts / sum(counts, na.rm=T)),1),  # рассчитать % от общего количества по половозрастным группам\n    percent = case_when(                                     # перевести % в отрицательное значение, если речь идет о мужском поле\n      gender == \"f\" ~ percent,\n      gender == \"m\" ~ -percent,\n      TRUE          ~ NA_real_))\n\nПросмотр измененного набора данных по случаям\n\n\n\n\n\n\nТеперь два датафрейма объединены, расположены один поверх другого (имеют одинаковые названия столбцов). Мы можем “дать название” каждому из датафреймов и использовать аргумент .id = для создания нового столбца “data_source”, который будет указывать, из какого датафрейма взята каждая строка. Мы можем использовать этот столбец для фильтрации в ggplot().\n\n# объединить данные по случаям и данные по населению (одинаковые названия столбцов, значения age_cat и gender)\npyramid_data &lt;- bind_rows(\"cases\" = case_data, \"population\" = pop_data, .id = \"data_source\")\n\nХранить максимальное и минимальное значения процентов, используемые в функции построения для определения границ графика (и не обрывать столбики!)\n\n# Определить границы оси процентов, используемые для определения границ графика\nmax_per &lt;- max(pyramid_data$percent, na.rm=T)\nmin_per &lt;- min(pyramid_data$percent, na.rm=T)\n\nТеперь с помощью ggplot() строится график:\n\nОдна гистограмма данных о населении (более широкие, прозрачные столбики)\nОдна гистограмма данных по случаям (мелкие, более сплошные столбики)\n\n\n# начать ggplot\n##############\nggplot()+  # Ось x по умолчанию - возраст в годах;\n\n  # график данных о населении\n  geom_col(\n    data = pyramid_data %&gt;% filter(data_source == \"population\"),\n    mapping = aes(\n      x = age_cat5,\n      y = percent,\n      fill = gender),\n    colour = \"black\",                               # черный цвет вокруг столбиков\n    alpha = 0.2,                                    # более прозрачный\n    width = 1)+                                     # полная ширина\n  \n  # график данных о случае\n  geom_col(\n    data = pyramid_data %&gt;% filter(data_source == \"cases\"), \n    mapping = aes(\n      x = age_cat5,                               # возрастные категории в качестве исходной оси X\n      y = percent,                                # % по сравнению с исходной осью Y\n      fill = gender),                             # заливка столбиков по полу\n    colour = \"black\",                               # черный цвет вокруг столбиков\n    alpha = 1,                                      # непрозрачный \n    width = 0.3)+                                   # половина ширины\n  \n  # переверните оси X и Y, чтобы пирамида стала вертикальной\n  coord_flip()+\n  \n  # вручную убедиться в правильности упорядочивания оси возраст\n  scale_x_discrete(limits = age_levels)+     # определенный в фрагменте выше\n  \n  # задать ось процентов \n  scale_y_continuous(\n    limits = c(min_per, max_per),                                          #минимальное и максимальное значения, определенные выше\n    breaks = seq(floor(min_per), ceiling(max_per), by = 2),                # от min% до max% по 2 \n    labels = paste0(                                                       # для меток, соедините их вместе... \n              abs(seq(floor(min_per), ceiling(max_per), by = 2)), \"%\"))+                                                  \n\n  # назначение цветов и меток легенды вручную\n  scale_fill_manual(\n    values = c(\"f\" = \"orange\",         # присвоить цвета значениям в данных\n               \"m\" = \"darkgreen\"),\n    labels = c(\"f\" = \"Female\",\n               \"m\"= \"Male\"),      # изменение меток, отображаемых в легенде, порядка примечаний\n  ) +\n\n  # метки, заголовки, надписи графика    \n  labs(\n    title = \"Case age and gender distribution,\\nas compared to baseline population\",\n    subtitle = \"\",\n    x = \"Age category\",\n    y = \"Percent of total\",\n    fill = NULL,\n    caption = stringr::str_glue(\"Cases shown on top of country demographic baseline\\nCase data are from linelist, n = {nrow(linelist)}\\nAge or gender missing for {sum(is.na(linelist$gender) | is.na(linelist$age_years))} cases\\nCase data as of: {format(max(linelist$date_onset, na.rm=T), '%d %b %Y')}\")) +\n  \n  # дополнительные эстетические темы\n  theme(\n    legend.position = \"bottom\",                             # перемещение легенды в нижнюю часть\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    axis.line = element_line(colour = \"black\"),\n    plot.title = element_text(hjust = 0), \n    plot.caption = element_text(hjust=0, size=11, face = \"italic\"))",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Демографические пирамиды и шкалы Лайкерта</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.ru.html#шкала-лайкерта",
    "href": "new_pages/age_pyramid.ru.html#шкала-лайкерта",
    "title": "33  Демографические пирамиды и шкалы Лайкерта",
    "section": "33.4 Шкала Лайкерта",
    "text": "33.4 Шкала Лайкерта\nПриемы, используемые для построения пирамиды населения с помощью ggplot(), могут быть использованы и для построения графиков данных опроса по шкале Лайкерта.\nИмпортируйте данные (при желании см. страницу [Скачивание руководства и данных]).\n\n# импорт данных об ответах на опросник Лайкерта\nlikert_data &lt;- rio::import(\"likert_data.csv\")\n\nНачнем с данных, которые выглядят следующим образом: категориальная классификация каждого респондента (статус) и его ответы на 8 вопросов по 4-балльной шкале типа Лайкерта (“Очень плохо”, “Плохо”, “Хорошо”, “Очень хорошо”).\n\n\n\n\n\n\nВо-первых, некоторые шаги по управлению данными:\n\nПоворот данных.\n\nСоздать новый столбец direction в зависимости от того, был ли ответ в целом “положительным” или “отрицательным”\n\nУстановить порядок уровней факторов для столбца status и столбца Response.\n\nСохранить максимальное значение подсчета, чтобы границы графика были соответствующими\n\n\nmelted &lt;- likert_data %&gt;% \n  pivot_longer(\n    cols = Q1:Q8,\n    names_to = \"Question\",\n    values_to = \"Response\") %&gt;% \n  mutate(\n    \n    direction = case_when(\n      Response %in% c(\"Poor\",\"Very Poor\")  ~ \"Negative\",\n      Response %in% c(\"Good\", \"Very Good\") ~ \"Positive\",\n      TRUE                                 ~ \"Unknown\"),\n    \n    status = fct_relevel(status, \"Junior\", \"Intermediate\", \"Senior\"),\n    \n    # необходимо поменять 'Very Poor' и 'Poor', чтобы работал порядок\n    Response = fct_relevel(Response, \"Very Good\", \"Good\", \"Very Poor\", \"Poor\")) \n\n# получение наибольшего значения для границ масштаба\nmelted_max &lt;- melted %&gt;% \n  count(status, Question) %&gt;% # получить подсчеты\n  pull(n) %&gt;%                 # столбец 'n'\n  max(na.rm=T)                # получить максимальное значение\n\nТеперь построим график. Как и в случае с возрастными пирамидами, мы строим два столбчатых графика и инвертируем значения одного из них в отрицательные.\nМы используем geom_bar(), поскольку наши данные представляют собой одну строку на наблюдение, а не агрегированные подсчеты. Мы используем специальный ggplot2 термин ..count.. в одной из гистограмм для инвертирования отрицательных значений (*-1), и задаем position = \"stack\", чтобы значения складывались друг на друга.\n\n# построить график\nggplot()+\n     \n  # гистограмма \"отрицательных\" ответов \n     geom_bar(\n       data = melted %&gt;% filter(direction == \"Negative\"),\n       mapping = aes(\n         x = status,\n         y = ..count..*(-1),    # инверсия подсчетов в отрицательное значение\n         fill = Response),\n       color = \"black\",\n       closed = \"left\",\n       position = \"stack\")+\n     \n     # гистограмма \"положительных\" ответов\n     geom_bar(\n       data = melted %&gt;% filter(direction == \"Positive\"),\n       mapping = aes(\n         x = status,\n         fill = Response),\n       colour = \"black\",\n       closed = \"left\",\n       position = \"stack\")+\n     \n     # перевернуть оси X и Y\n     coord_flip()+\n  \n     # Черная вертикальная линия на отметке 0\n     geom_hline(yintercept = 0, color = \"black\", size=1)+\n     \n    # преобразование меток ко всем положительным числам\n    scale_y_continuous(\n      \n      # границы шкалы оси x\n      limits = c(-ceiling(melted_max/10)*11,    # последовательность от отрицательных к положительным по 10, края округляются до ближайших 5\n                 ceiling(melted_max/10)*10),   \n      \n      # значения масштаба по оси x\n      breaks = seq(from = -ceiling(melted_max/10)*10,\n                   to = ceiling(melted_max/10)*10,\n                   by = 10),\n      \n      # метки шкалы оси x\n      labels = abs(unique(c(seq(-ceiling(melted_max/10)*10, 0, 10),\n                            seq(0, ceiling(melted_max/10)*10, 10))))) +\n     \n    # цветовые шкалы, назначенные вручную\n    scale_fill_manual(\n      values = c(\"Very Good\"  = \"green4\", # назначает цвета\n                \"Good\"      = \"green3\",\n                \"Poor\"      = \"yellow\",\n                \"Very Poor\" = \"red3\"),\n      breaks = c(\"Very Good\", \"Good\", \"Poor\", \"Very Poor\"))+ # упорядочивает легенду\n     \n    \n     \n    # фасетировать весь график, чтобы каждый вопрос был отдельным графиком\n    facet_wrap( ~ Question, ncol = 3)+\n     \n    # метки, заголовки, надписи\n    labs(\n      title = str_glue(\"Likert-style responses\\nn = {nrow(likert_data)}\"),\n      x = \"Respondent status\",\n      y = \"Number of responses\",\n      fill = \"\")+\n\n     # отобразить корректировки \n     theme_minimal()+\n     theme(axis.text = element_text(size = 12),\n           axis.title = element_text(size = 14, face = \"bold\"),\n           strip.text = element_text(size = 14, face = \"bold\"),  # подзаголовки фасетов\n           plot.title = element_text(size = 20, face = \"bold\"),\n           panel.background = element_rect(fill = NA, color = \"black\")) # черный квадрат вокруг каждого фасета",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Демографические пирамиды и шкалы Лайкерта</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.ru.html#ресурсы",
    "href": "new_pages/age_pyramid.ru.html#ресурсы",
    "title": "33  Демографические пирамиды и шкалы Лайкерта",
    "section": "33.5 Ресурсы",
    "text": "33.5 Ресурсы\nДокументация по Apyramid",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Демографические пирамиды и шкалы Лайкерта</span>"
    ]
  },
  {
    "objectID": "new_pages/heatmaps.ru.html",
    "href": "new_pages/heatmaps.ru.html",
    "title": "34  Тепловые диаграммы",
    "section": "",
    "text": "34.1 Подготовка",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Тепловые диаграммы</span>"
    ]
  },
  {
    "objectID": "new_pages/heatmaps.ru.html#подготовка",
    "href": "new_pages/heatmaps.ru.html#подготовка",
    "title": "34  Тепловые диаграммы",
    "section": "",
    "text": "Загрузка пакетов\nВ этом фрагменте кода показана загрузка пакетов, необходимых для проведения анализа. В данном руководстве мы делаем акцент на функции p_load() из pacman, которая при необходимости устанавливает пакет и загружает его для использования. Установленные пакеты можно также загрузить с помощью library() из базового R. Более подробную информацию о пакетах R см. на странице Основы R.\n\npacman::p_load(\n  tidyverse,       # управление данными и их визуализация\n  rio,             # импорт данных \n  lubridate        # работа с датами\n  )\n\nНаборы данных\nНа этой странице для раздела Матрица передачи используется линейный список случаев моделируемой вспышки, а для раздела Отслеживание показателей - отдельный набор данных о ежедневном количестве случаев малярии по учреждениям. Они загружаются и очищаются в отдельных разделах.",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Тепловые диаграммы</span>"
    ]
  },
  {
    "objectID": "new_pages/heatmaps.ru.html#матрица-передачи",
    "href": "new_pages/heatmaps.ru.html#матрица-передачи",
    "title": "34  Тепловые диаграммы",
    "section": "34.2 Матрица передачи",
    "text": "34.2 Матрица передачи\nТепловые плитки могут быть полезны для визуализации матриц. Одним из примеров является отображение “кто заразил кого” во вспышке заболевания. При этом предполагается, что у вас есть информация о событиях передачи.\nОбратите внимание на то, что на странице [Отслеживание контактов] приведен другой пример создания матрицы контактов на основе тепловой плитки, использующий другой (возможно, более простой) набор данных, в котором возраст случаев и их источники аккуратно выровнены в одной строке датафрейма. Эти же данные используются для построения карты плотности на странице [Советы по использованию ggplot]. Приведенный ниже пример начинается с построчного списка случаев и поэтому требует значительных манипуляций с данными, прежде чем будет получен датафрейм, пригодный для построения графика. Таким образом, можно выбрать множество сценариев…\nМы начнем с построчного списка случаев моделирования эпидемии лихорадки Эбола. Если вы хотите выполнять действия параллельно, щелкните мышью, чтобы загрузить “чистый” построчный список /a&gt; (в виде файла .rds). Импортируйте данные с помощью функции import() из пакета rio (она принимает множество типов файлов, таких как .xlsx, .rds, .csv - подробности см. на странице Импорт и экспорт).\nНиже для демонстрации показаны первые 50 строк построчного списка:\n\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nВ этом построчном списке:\n\nНа каждый случай приходится одна строка, идентифицируемая по case_id.\n\nИмеется более поздний столбец infector, содержащий case_id infector, который также является случаем в построчном списке\n\n\n\n\n\n\n\n\nПодготовка данных\nЦель: Нам необходимо получить “длинный” датафрейм, содержащий одну строку для каждого возможного пути передачи от одной возрастной группы другой, с числовым столбцом, содержащим долю этой строки от всех наблюдаемых событий передачи в построчном списке.\nДля этого потребуется несколько шагов по управлению данными:\n\nСоздать датафрейм случаев\nДля начала создадим датафрейм, содержащий все случаи заболевания, их возраст и людей, которые их заразили - назовем этот датафрейм case_ages. Ниже показаны первые 50 строк.\n\ncase_ages &lt;- linelist %&gt;% \n  select(case_id, infector, age_cat) %&gt;% \n  rename(\"case_age_cat\" = \"age_cat\")\n\n\n\n\n\n\n\n\n\nСоздать датафрейм Лица, заразившие других\nДалее мы создаем датафрейм лиц, заразивших других - на данный момент он состоит из одного столбца. Это идентификаторы лиц, заразивших других, из построчного списка. Не в каждом случае известно лицо, заразившее его, поэтому мы удаляем пропущенные значения. Ниже показаны первые 50 строк.\n\ninfectors &lt;- linelist %&gt;% \n  select(infector) %&gt;% \n  drop_na(infector)\n\n\n\n\n\n\n\nДалее с помощью объединений мы получаем возраст заразивших лиц. Это не так просто, поскольку в linelist возраст заразивших лиц как таковой не указан. Мы достигаем этого результата, присоединяя случай linelist к заразившим лицам. Начнем с заразивших лиц и left_join() (добавим) к ним построчный список так, чтобы столбец id infector левой части “базового” датафрейма соединился со столбцом case_id в правом датафрейме linelist.\nТаким образом, данные из построчного списка заразивших лиц (включая возраст) добавляются к строке заразившего лица. Ниже показаны 50 первых строк.\n\ninfector_ages &lt;- infectors %&gt;%             # начать с заразившего лица\n  left_join(                               # добавить данные построчного списка к каждому заразившему лицу  \n    linelist,\n    by = c(\"infector\" = \"case_id\")) %&gt;%    # сопоставить заразившее лицо с информацией о нем как о случае\n  select(infector, age_cat) %&gt;%            # сохранять только столбцы, представляющие интерес\n  rename(\"infector_age_cat\" = \"age_cat\")   # переименовать для ясности\n\n\n\n\n\n\n\nЗатем мы объединяем случаи заболевания и их возраст с заразившим лицом и его возрастом. В каждом из этих датафреймов есть столбец infector, который и используется для объединения. Первые строки показаны ниже:\n\nages_complete &lt;- case_ages %&gt;%  \n  left_join(\n    infector_ages,\n    by = \"infector\") %&gt;%        # в каждом из них имеется столбец заразившее лицо\n  drop_na()                     # отбрасывать строки с отсутствующими данными\n\nWarning in left_join(., infector_ages, by = \"infector\"): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 1 of `x` matches multiple rows in `y`.\nℹ Row 6 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\n\n\nНиже приведена простая перекрестная табуляция подсчетов между возрастными группами случаев и тех, кто их заразил. Для наглядности добавлены метки.\n\ntable(cases = ages_complete$case_age_cat,\n      infectors = ages_complete$infector_age_cat)\n\n       infectors\ncases   0-4 5-9 10-14 15-19 20-29 30-49 50-69 70+\n  0-4   105 156   105   114   143   117    13   0\n  5-9   102 132   110   102   117    96    12   5\n  10-14 104 109    91    79   120    80    12   4\n  15-19  85 105    82    39    75    69     7   5\n  20-29 101 127   109    80   143   107    22   4\n  30-49  72  97    56    54    98    61     4   5\n  50-69   5   6    15     9     7     5     2   0\n  70+     1   0     2     0     0     0     0   0\n\n\nМы можем преобразовать эту таблицу в датафрейм с помощью data.frame() из базового R, который также автоматически преобразует ее в “длинный” формат, необходимый для работы ggplot(). Первые строки показаны ниже.\n\nlong_counts &lt;- data.frame(table(\n    cases     = ages_complete$case_age_cat,\n    infectors = ages_complete$infector_age_cat))\n\n\n\n\n\n\n\nТеперь сделаем то же самое, но применим к таблице prop.table() из базового R, чтобы вместо подсчетов получить доли от общего числа. Первые 50 строк показаны ниже.\n\nlong_prop &lt;- data.frame(prop.table(table(\n    cases = ages_complete$case_age_cat,\n    infectors = ages_complete$infector_age_cat)))\n\n\n\n\n\n\n\n\n\n\nСоздание тепловой диаграммы\nТеперь, наконец, мы можем построить тепловую диаграмму с помощью пакета ggplot2, используя функцию geom_tile(). Более подробно о шкалах цвета/заливки, в частности о функции scale_fill_gradient(), см. страницу [Советы по использованию ggplot].\n\nВ эстетике aes() функции geom_tile() задайте x и y как возраст случая и возраст заразившего лица.\n\nТакже в aes() установите аргумент fill = для столбца Freq - это значение будет преобразовано в цвет плитки\n\nУстановите цвет шкалы с помощью scale_fill_gradient() - вы можете указать высокий/низкий цвет\n\nОбратите внимание, что scale_color_gradient() отличается! В данном случае вам нужна заливка.\n\n\nПоскольку цвет задается через “заливку”, для изменения заголовка легенды можно использовать аргумент fill = в labs().\n\n\nggplot(data = long_prop)+       # использовать длинные данные, с пропорциями в качестве Freq\n  geom_tile(                    # визуализировать в виде плиток\n    aes(\n      x = cases,         # Ось x - возраст случая\n      y = infectors,     # Ось y - возраст заразившего лица\n      fill = Freq))+            # цвет плитки - это столбец Freq в данных\n  scale_fill_gradient(          # настройка цвета заливки плиток\n    low = \"blue\",\n    high = \"orange\")+\n  labs(                         # метки\n    x = \"Case age\",\n    y = \"Infector age\",\n    title = \"Who infected whom\",\n    subtitle = \"Frequency matrix of transmission events\",\n    fill = \"Proportion of all\\ntranmsission events\"     # заголовок легенды\n  )",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Тепловые диаграммы</span>"
    ]
  },
  {
    "objectID": "new_pages/heatmaps.ru.html#отчетность-по-показателям-за-период-времени",
    "href": "new_pages/heatmaps.ru.html#отчетность-по-показателям-за-период-времени",
    "title": "34  Тепловые диаграммы",
    "section": "34.3 Отчетность по показателям за период времени",
    "text": "34.3 Отчетность по показателям за период времени\nЧасто в здравоохранении одной из задач является оценка тенденций во времени для многих объектов (учреждений, юрисдикций и т.д.). Одним из способов визуализации таких тенденций во времени является тепловая диаграмма, где по оси x откладывается время, а по оси y - множество объектов.\n\nПодготовка данных\nВначале мы импортируем набор данных ежедневных отчетов по малярии из многих учреждений. Отчеты содержат дату, провинцию, район и количество заболевших малярией. Информацию о том, как загрузить эти данные, см. на странице [Скачивание руководства и данных]. Ниже приведены первые 30 строк:\n\nfacility_count_data &lt;- import(\"malaria_facility_count_data.rds\")\n\n\n\n\n\n\n\n\nАгрегирование и обобщение\nЦель данного примера - преобразовать ежедневные данные о количестве случаев заболевания малярией в учреждениях (см. предыдущую вкладку) в сводную статистику эффективности отчетности учреждений за неделю - в данном случае долю дней в неделю, когда учреждение сообщало какие-либо данные. В данном примере мы покажем данные только по Весеннему району.\nДля этого мы выполним следующие действия по управлению данными:\n\nОтфильтруйте данные соответствующим образом (по месту, дате)\n\nСоздать столбец недель с помощью функции floor_date() из пакета lubridate.\n\nЭта функция возвращает дату начала недели заданной даты, используя заданную дату начала каждой недели (например, “понедельники”)\n\n\nДанные группируются по столбцам “местоположение” и “неделя” для создания единиц анализа ” учреждение-неделя”.\n\nФункция summarise() создает новые столбцы для отражения сводной статистики по группе ” учреждение-неделя”:\n\nКоличество дней в неделю (7 - статическое значение)\n\nКоличество отчетов, полученных от учреждения за неделю (может быть больше 7!)\n\nСумма случаев малярии, зарегистрированных учреждением за неделю (просто для интереса)\n\nКоличество уникальных дней в неделе, для которых имеются данные.\n\nПроцент от 7 дней в неделе, по которым были представлены данные.\n\n\nДатафрейм соединяется с помощью right_join() с полным списком всех возможных комбинаций ” учреждение-неделя”, чтобы сделать набор данных полным. Матрица всех возможных комбинаций создается путем применения функции expand() к тем двум столбцам датафрейма, в которых он находится в данный момент в цепочке оператора (обозначается символом .). Поскольку используется right_join(), все строки в датафрейме expand() сохраняются и при необходимости добавляются в agg_weeks. Эти новые строки появляются с суммарными значениями NA (отсутствующие).\n\nНиже приводится пошаговая демонстрация:\n\n# Создание сводного набора данных за неделю\nagg_weeks &lt;- facility_count_data %&gt;% \n  \n  # отфильтровать данные по мере необходимости\n  filter(\n    District == \"Spring\",\n    data_date &lt; as.Date(\"2020-08-01\")) \n\nТеперь набор данных содержит строки nrow(agg_weeks), в то время как ранее он содержал nrow(facility_count_data).\nДалее создадим столбец week, отражающий дату начала недели для каждой записи. Для этого используется пакет lubridate и функция floor_date(), которая устанавливается в значение “неделя” и для того, чтобы недели начинались по понедельникам (1-й день недели - воскресенье будет 7-м). Верхние строки показаны ниже.\n\nagg_weeks &lt;- agg_weeks %&gt;% \n  # Создание столбца недели из data_date\n  mutate(\n    week = lubridate::floor_date(                     # создать новый столбец недель\n      data_date,                                      # столбец даты\n      unit = \"week\",                                  # задать начало недели\n      week_start = 1))                                # недели начинаются по понедельникам \n\nНовый столбец недели можно увидеть в крайней правой части датафрейма\n\n\n\n\n\n\nТеперь сгруппируем данные по учреждениям-неделям и обобщим их, чтобы получить статистику по учреждениям-неделям. Советы см. на странице [Описательные таблицы]. Сама по себе группировка не меняет датафрейм, но она влияет на то, как рассчитывается последующая сводная статистика.\nВерхние строки показаны ниже. Обратите внимание на то, как полностью изменились столбцы, чтобы отразить желаемую сводную статистику. Каждая строка отражает одно учреждение-неделю.\n\nagg_weeks &lt;- agg_weeks %&gt;%   \n\n  # Группировка по учреждениям-неделям\n  group_by(location_name, week) %&gt;%\n  \n  # Создание столбцов сводной статистики по сгруппированным данным\n  summarize(\n    n_days          = 7,                                          # 7 дней в неделю           \n    n_reports       = dplyr::n(),                                 # количество полученных отчетов в неделю (может быть &gt;7)\n    malaria_tot     = sum(malaria_tot, na.rm = T),                # общее число зарегистрированных случаев заболевания малярией\n    n_days_reported = length(unique(data_date)),                  # количество уникальных дней отчета в неделю\n    p_days_reported = round(100*(n_days_reported / n_days))) %&gt;%  # процент дней отчетности\n\n  ungroup(location_name, week)                                    # разгруппировать, чтобы функция expand() работала на следующем шаге\n\n\n\n\n\n\n\nНаконец, мы выполняем приведенную ниже команду, чтобы убедиться, что ВСЕ возможные учреждения-недели присутствуют в данных, даже если до этого они отсутствовали.\nМы используем функцию right_join() на самом себе (набор данных представлен через “.”), но при этом эта функция была расширена, чтобы включить все возможные комбинации столбцов week и location_name. См. документацию по функции expand() на странице [Поворот]. Перед выполнением этого кода набор данных содержит строки nrow(agg_weeks).\n\n# Создать датафрейм всех возможных учреждений-недель\nexpanded_weeks &lt;- agg_weeks %&gt;% \n  tidyr::expand(location_name, week)  # расширить датафрейм, включив в него все возможные комбинации учреждений-недель\n\nВот expanded_weeks с 180 строками:\n\n\n\n\n\n\nПеред выполнением кода agg_weeks содержала 107 строк.\n\n# Используйте правое соединение с расширенным списком учреждений-недель для заполнения недостающих пробелов в данных\nagg_weeks &lt;- agg_weeks %&gt;%      \n  right_join(expanded_weeks) %&gt;%                            # Убедитесь, что все возможные комбинации учреждений-недель присутствуют в данных\n  mutate(p_days_reported = replace_na(p_days_reported, 0))  # преобразование отсутствующих значений в 0                           \n\nJoining with `by = join_by(location_name, week)`\n\n\nПосле выполнения этого кода agg_weeks содержит строки nrow(agg_weeks).\n\n\n\n\nСоздание тепловой диаграммы\nДля построения ggplot() используется geom_tile() из пакета ggplot2:\n\nНедели по оси x преобразуются в даты, что позволяет использовать scale_x_date().\n\nПо оси y откладывается location_name, где отображаются названия всех учреждений.\n\nfill - это p_days_reported, результативность для данного учреждения за неделю (числовое значение)\n\nscale_fill_gradient() используется для числовой заливки, задавая цвета для высокого, низкого и NA.\n\nscale_x_date() используется для оси x, задавая метки каждые 2 недели и их формат.\n\nТемы отображения и метки могут быть настроены по мере необходимости\n\n\n\n\nБазовая тепловая диаграмма\nНиже приведена базовая тепловая диаграмма, использующая цвета, шкалы и т.д. по умолчанию. Как объяснялось выше, внутри aes() для geom_tile() необходимо указать столбец оси x, столбец оси y, и столбец для fill=. Заливка - это числовое значение, которое представляет собой цвет плитки.\n\nggplot(data = agg_weeks)+\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported))\n\n\n\n\n\n\n\n\n\n\nОчищенная диаграмма\nМы можем сделать эту диаграмму более красивой, добавив дополнительные функции ggplot2, как показано ниже. Подробности см. на странице [Советы по использованию ggplot].\n\nggplot(data = agg_weeks)+ \n  \n  # отображение данных в виде плиток\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported),      \n    color = \"white\")+                 # белые линии сетки\n  \n  scale_fill_gradient(\n    low = \"orange\",\n    high = \"darkgreen\",\n    na.value = \"grey80\")+\n  \n  # ось дат\n  scale_x_date(\n    expand = c(0,0),             # удалить лишнее пространство по бокам\n    date_breaks = \"2 weeks\",     # метки каждые 2 недели\n    date_labels = \"%d\\n%b\")+     # Формат - день за месяцем (\\n через новую строку)\n  \n  # эстетические темы\n  theme_minimal()+                                  # упростить фон\n  \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1,\"cm\"),           # высота ключа легенды\n    legend.key.width  = grid::unit(0.6,\"cm\"),         # ширина ключа легенды\n    \n    axis.text.x = element_text(size=12),              # размер текста по оси\n    axis.text.y = element_text(vjust=0.2),            # выравнивание текста по оси\n    axis.ticks = element_line(size=0.4),               \n    axis.title = element_text(size=12, face=\"bold\"),  # размер заголовка оси и полужирный шрифт\n    \n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),  # Заголовок выровнен по правому краю, крупный, полужирный\n    plot.caption = element_text(hjust = 0, face = \"italic\")  # Надпись, выровненная по правому краю и выделенная курсивом\n    )+\n  \n  # метки диаграммы\n  labs(x = \"Week\",\n       y = \"Facility name\",\n       fill = \"Reporting\\nperformance (%)\",           # Заголовок легенды, так как легенда показывает заливку\n       title = \"Percent of days per week that facility reported data\",\n       subtitle = \"District health facilities, May-July 2020\",\n       caption = \"7-day weeks beginning on Mondays.\")\n\n\n\n\n\n\n\n\n\n\n\nУпорядоченная ось y\nВ настоящее время учреждения расположены в алфавитно-цифровом порядке снизу вверх. Если вы хотите изменить порядок учреждений по оси y, переведите их в коэффициент класса и укажите порядок. Советы см. на странице [Факторы].\nПоскольку учреждений много и мы не хотим выписывать их все, попробуем другой подход - упорядочить учреждения в датафрейме и использовать полученный столбец названий в качестве порядка на уровне факторов. Ниже столбец location_name преобразуется в фактор, а порядок его уровней устанавливается в зависимости от общего количества отчетных дней, поданных учреждением за весь временной интервал.\nДля этого мы создаем датафрейм, представляющий собой общее количество отчетов по каждому объекту, расположенных в порядке возрастания. Этот вектор мы можем использовать для упорядочивания уровней фактора на графике.\n\nfacility_order &lt;- agg_weeks %&gt;% \n  group_by(location_name) %&gt;% \n  summarize(tot_reports = sum(n_days_reported, na.rm=T)) %&gt;% \n  arrange(tot_reports) # возрастающий порядок\n\nСм. датафрейм ниже:\n\n\n\n\n\n\nТеперь используйте столбец из приведенного выше датафрейма (facility_order$location_name) в качестве порядка следования уровней фактора location_name в датафрейме agg_weeks:\n\n# загрузка пакета \npacman::p_load(forcats)\n\n# создание коэффициентов и определение уровней вручную\nagg_weeks &lt;- agg_weeks %&gt;% \n  mutate(location_name = fct_relevel(\n    location_name, facility_order$location_name)\n    )\n\nА теперь данные повторно построены на графике, причем location_name является упорядоченным фактором:\n\nggplot(data = agg_weeks)+ \n  \n  # отображение данных в виде плиток\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported),      \n    color = \"white\")+                 # белые линии сетки\n  \n  scale_fill_gradient(\n    low = \"orange\",\n    high = \"darkgreen\",\n    na.value = \"grey80\")+\n  \n  # ось даты\n  scale_x_date(\n    expand = c(0,0),             # удалить лишнее пространство по бокам\n    date_breaks = \"2 weeks\",     # метки каждые 2 недели\n    date_labels = \"%d\\n%b\")+     # Формат - день за месяцем (\\n через новую строку)\n  \n  # эстетические темы\n  theme_minimal()+                                  # упростить фон\n  \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1,\"cm\"),           # высота ключа легенды\n    legend.key.width  = grid::unit(0.6,\"cm\"),         # ширина ключа легенды\n    \n    axis.text.x = element_text(size=12),              # размер текста по оси\n    axis.text.y = element_text(vjust=0.2),            # выравнивание текста по оси\n    axis.ticks = element_line(size=0.4),               \n    axis.title = element_text(size=12, face=\"bold\"),  # размер заголовка по оси и полужирный шрифт\n    \n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),  # Заголовок выровнен по правому краю, крупный, полужирный\n    plot.caption = element_text(hjust = 0, face = \"italic\")  # Надпись, выровненная по правому краю и выделенная курсивом\n    )+\n  \n  # метки диаграммы\n  labs(x = \"Week\",\n       y = \"Facility name\",\n       fill = \"Reporting\\nperformance (%)\",           # Заголовок легенды, так как легенда показывает заливку\n       title = \"Percent of days per week that facility reported data\",\n       subtitle = \"District health facilities, May-July 2020\",\n       caption = \"7-day weeks beginning on Mondays.\")\n\n\n\n\n\n\n\n\n\n\n\nОтображение значений\nПоверх плиток можно добавить слой geom_text(), чтобы отобразить фактические номера каждой плитки. Имейте в виду, что это может выглядеть не очень красиво, если у вас много маленьких плиток!\nБыл добавлен следующий код: geom_text(aes(label = p_days_reported)). Этот код добавляет текст на каждую плитку. Отображаемый текст представляет собой значение, присвоенное аргументу label =, который в данном случае был задан для того же числового столбца p_days_reported, который также используется для создания цветового градиента.\n\nggplot(data = agg_weeks)+ \n  \n  # отображение данных в виде плиток\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported),      \n    color = \"white\")+                 # белые линии сетки\n  \n  # текст\n  geom_text(\n    aes(\n      x = week,\n      y = location_name,\n      label = p_days_reported))+      # добавление текста поверх плитки\n  \n  # шкала заливки\n  scale_fill_gradient(\n    low = \"orange\",\n    high = \"darkgreen\",\n    na.value = \"grey80\")+\n  \n  # ось дат\n  scale_x_date(\n    expand = c(0,0),             # удалить лишнее пространство по бокам\n    date_breaks = \"2 weeks\",     # метки каждые 2 недели\n    date_labels = \"%d\\n%b\")+     # Формат - день за месяцем (\\n через новую строку)\n  \n  # эстетические темы\n  theme_minimal()+                                    # упростить фон\n  \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1,\"cm\"),           # высота ключа легенды\n    legend.key.width  = grid::unit(0.6,\"cm\"),         # ширина ключа легенды\n    \n    axis.text.x = element_text(size=12),              # размер текста по оси\n    axis.text.y = element_text(vjust=0.2),            # выравнивание текста по оси\n    axis.ticks = element_line(size=0.4),               \n    axis.title = element_text(size=12, face=\"bold\"),  # размер заголовка по оси и полужирный шрифт\n    \n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),  # Заголовок выровнен по правому краю, крупный, полужирный\n    plot.caption = element_text(hjust = 0, face = \"italic\")  # Надпись, выровненная по правому краю и выделенная курсивом\n    )+\n  \n  # метки диаграммы\n  labs(x = \"Week\",\n       y = \"Facility name\",\n       fill = \"Reporting\\nperformance (%)\",           # Заголовок легенды, так как легенда показывает заливку\n       title = \"Percent of days per week that facility reported data\",\n       subtitle = \"District health facilities, May-July 2020\",\n       caption = \"7-day weeks beginning on Mondays.\")",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Тепловые диаграммы</span>"
    ]
  },
  {
    "objectID": "new_pages/heatmaps.ru.html#ресурсы",
    "href": "new_pages/heatmaps.ru.html#ресурсы",
    "title": "34  Тепловые диаграммы",
    "section": "34.4 Ресурсы",
    "text": "34.4 Ресурсы\nscale_fill_gradient()\nГалерея графиков R - тепловая карта",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Тепловые диаграммы</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.ru.html",
    "href": "new_pages/diagrams.ru.html",
    "title": "35  Диаграммы и схемы",
    "section": "",
    "text": "35.1 Подготовка",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Диаграммы и схемы</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.ru.html#подготовка",
    "href": "new_pages/diagrams.ru.html#подготовка",
    "title": "35  Диаграммы и схемы",
    "section": "",
    "text": "Загрузка пакетов\nВ этом фрагменте кода показана загрузка пакетов, необходимых для проведения анализа. В данном руководстве мы делаем акцент на функции p_load() из pacman, которая при необходимости устанавливает пакет и загружает его для использования. Установленные пакеты можно также загрузить с помощью library() из базового R. Более подробную информацию о пакетах R см. на странице Основы R.\n\npacman::p_load(\n  DiagrammeR,     # для блок-схем\n  networkD3,      # Для аллювиальных диаграмм/диаграмм Санкей\n  tidyverse)      # управление данными и их визуализация\n\n\n\nИмпорт данных\nБольшая часть материалов этой страницы не требует набора данных. Однако в разделе, посвященном диаграмме Санкея, мы будем использовать построчный список случаев, полученных при моделировании эпидемии лихорадки Эбола. Если вы хотите проследить за этой частью, нажмите кнопку, чтобы загрузить “чистый” построчный список (в виде файла .rds). Импортируйте данные с помощью функции import() из пакета rio (она работает со многими типами файлов, такими как .xlsx, .csv, .rds - подробности см. на странице Импорт и экспорт).\n\n# импорт построчного списка\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nНиже отображаются первые 50 строк построчного списка.",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Диаграммы и схемы</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.ru.html#блок-схемы",
    "href": "new_pages/diagrams.ru.html#блок-схемы",
    "title": "35  Диаграммы и схемы",
    "section": "35.2 Блок-схемы",
    "text": "35.2 Блок-схемы\nДля создания графиков/диаграмм можно использовать пакет R DiagrammeR. Они могут быть статичными или динамически изменяться в зависимости от изменений в наборе данных.\nИнструменты\nФункция grViz() используется для создания диаграммы “Graphviz”. Для создания диаграммы эта функция принимает последовательность символов, содержащую инструкции. Внутри этой строки инструкции написаны на другом языке, который называется DOT - его основы достаточно легко освоить.\nБазовая структура\n\nОткройте инструкцию grViz(\").\n\nУказать направленность и название графика, раскрыть скобки, например, digraph my_flow_chart {\nОператор Graph (расположение, направление ранжирования)\n\nОператоры Nodes (создание узлов)\nОператоры Edges (задает связи между узлами)\n\nЗакрывающие инструкции }\")\n\n\nПростые примеры\nНиже приведены два простых примера\nОчень минимальный пример:\n\n# минимальный график\nDiagrammeR::grViz(\"digraph {\n  \ngraph[layout = dot, rankdir = LR]\n\na\nb\nc\n\na -&gt; b -&gt; c\n}\")\n\n\n\n\n\nПример, возможно, с более прикладным контекстом общественного здравоохранения:\n\ngrViz(\"                           # Все инструкции находятся внутри большой последовательности символов, \ndigraph surveillance_diagram {    # 'digraph' означает 'directional graph', а затем название графика,  \n  \n  # оператор графика\n  #################\n  graph [layout = dot,\n         rankdir = TB,\n         overlap = true,\n         fontsize = 10]\n  \n  # узлы\n  #######\n  node [shape = circle,           # форма = круг\n       fixedsize = true\n       width = 1.3]               # ширина кругов\n  \n  Primary                         # название узлов\n  Secondary\n  Tertiary\n\n  # ребра\n  #######\n  Primary   -&gt; Secondary [label = ' case transfer']\n  Secondary -&gt; Tertiary [label = ' case transfer']\n}\n\")\n\n\n\n\n\n\n\nСинтаксис\nБазовый синтаксис\nНазвания узлов, или выражения ребер, могут разделяться пробелами, точками с запятой или новой строкой.\nНаправление ранжирования\nГрафик может быть переориентирован для перемещения слева направо путем изменения аргумента rankdir в операторе графика. По умолчанию используется значение TB (сверху вниз), но может быть установлено значение LR (слева направо), RL или BT.\nНазвания узлов\nНазвания узлов могут состоять из одних слов, как в простом примере выше. Чтобы использовать многословные названия или специальные символы (например, круглые скобки, тире), заключите название узла в одинарные кавычки (’ ’). Возможно, проще иметь короткое название узла и назначить ему метку, как показано ниже в скобках [ ]. Если в названии узла требуется поставить новую строку, то это нужно сделать через метку - используйте \\n в метке узла в одинарных кавычках, как показано ниже.\nПодгруппы\nВнутри выражений ребер можно создавать подгруппы по обе стороны от ребра с помощью фигурных скобок ({ }). В этом случае ребро применяется ко всем узлам в скобках - это сокращение.\nРасположение\n\ndot (установить rankdir в значение TB, LR, RL, BT, )\nneato\n\ntwopi\n\ncirco\n\nУзлы - редактируемые атрибуты\n\nlabel (текст, в одинарных кавычках, если многословный)\n\nfillcolor (множество возможных цветов)\n\nfontcolor\n\nalpha (прозрачность 0-1)\n\nshape (эллипс, овал, ромб, яйцо, простой текст, точка, квадрат, треугольник)\n\nstyle\n\nsides\n\nperipheries\n\nfixedsize (h x w)\n\nheight\n\nwidth\n\ndistortion\n\npenwidth (ширина границы фигуры)\n\nx (смещение влево/вправо)\n\ny (смещение вверх/вниз)\n\nfontname\n\nfontsize\n\nicon\n\nРебра - редактируемые атрибуты.\n\narrowsize\n\narrowhead (нормальный, коробка, ворона, кривая, алмаз, точка, inv, никакой, tee, vee)\n\narrowtail\n\ndir (направление, )\n\nstyle (пунктир, …)\n\ncolor\n\nalpha\n\nheadport (текст перед стрелкой)\n\ntailport (текст за хвостом стрелки)\n\nfontname\n\nfontsize\n\nfontcolor(ширина стрелки)\n\nminlen (минимальная длина)\n\nНазвания цветов: шестнадцатеричные значения или названия цветов ‘X11’, см. подробно о X11\n\n\nСложные примеры\nПриведенный ниже пример описывает диаграмму surveillance_diagram, добавляя сложные названия узлов, сгруппированные ребра, цвета и стилистику\nDiagrammeR::grViz(\"               # Все инструкции находятся внутри большой последовательности символов\ndigraph surveillance_diagram {    # 'digraph' означает 'directional graph', после него название графика \n  \n  # выражения графика\n  #################\n  graph [layout = dot,\n         rankdir = TB,            # расположение сверху вниз\n         fontsize = 10]\n  \n\n  # узлы (круги)\n  #################\n  node [shape = circle,           # форма = круг\n       fixedsize = true\n       width = 1.3]                      \n  \n  Primary   [label = 'Primary\\nFacility'] \n  Secondary [label = 'Secondary\\nFacility'] \n  Tertiary  [label = 'Tertiary\\nFacility'] \n  SC        [label = 'Surveillance\\nCoordination',\n             fontcolor = darkgreen] \n  \n  # ребра\n  #######\n  Primary   -&gt; Secondary [label = ' case transfer',\n                          fontcolor = red,\n                          color = red]\n  Secondary -&gt; Tertiary [label = ' case transfer',\n                          fontcolor = red,\n                          color = red]\n  \n  # сгруппированные ребра\n  {Primary Secondary Tertiary} -&gt; SC [label = 'case reporting',\n                                      fontcolor = darkgreen,\n                                      color = darkgreen,\n                                      style = dashed]\n}\n\")\n\n\n\n\n\n\nКластеры подграфика\nЧтобы сгруппировать узлы в кластеры с рамками, поместите их в подграфик с одинаковым названием (subgraph name {}). Для того чтобы каждый подграфик был идентифицирован в пределах ограничительной рамки, начните название подграфика с “cluster”, как показано на 4 блоках ниже.\nDiagrammeR::grViz(\"             # Все инструкции находятся внутри большой последовательности символов\ndigraph surveillance_diagram {  # 'digraph' означает 'directional graph', после него название графика \n  \n  # выражения графика\n  #################\n  graph [layout = dot,\n         rankdir = TB,            \n         overlap = true,\n         fontsize = 10]\n  \n\n  # узлы (круги)\n  #################\n  node [shape = circle,                  # форма = круг\n       fixedsize = true\n       width = 1.3]                      # ширина кругов\n  \n  subgraph cluster_passive {\n    Primary   [label = 'Primary\\nFacility'] \n    Secondary [label = 'Secondary\\nFacility'] \n    Tertiary  [label = 'Tertiary\\nFacility'] \n    SC        [label = 'Surveillance\\nCoordination',\n               fontcolor = darkgreen] \n  }\n  \n  # узлы (квадраты)\n  ###############\n  node [shape = box,                     # форма узла\n        fontname = Helvetica]            # шрифт текста в узле\n  \n  subgraph cluster_active {\n    Active [label = 'Active\\nSurveillance'] \n    HCF_active [label = 'HCF\\nActive Search']\n  }\n  \n  subgraph cluster_EBD {\n    EBS [label = 'Event-Based\\nSurveillance (EBS)'] \n    'Social Media'\n    Radio\n  }\n  \n  subgraph cluster_CBS {\n    CBS [label = 'Community-Based\\nSurveillance (CBS)']\n    RECOs\n  }\n\n  \n  # ребра\n  #######\n  {Primary Secondary Tertiary} -&gt; SC [label = 'case reporting']\n\n  Primary   -&gt; Secondary [label = 'case transfer',\n                          fontcolor = red]\n  Secondary -&gt; Tertiary [label = 'case transfer',\n                          fontcolor = red]\n  \n  HCF_active -&gt; Active\n  \n  {'Social Media' Radio} -&gt; EBS\n  \n  RECOs -&gt; CBS\n}\n\")\n\n\n\n\n\n\n\nФормы узлов\nВ приведенном ниже примере, заимствованном из этого пособия, показаны применяемые формы узлов и сокращенное обозначение последовательных соединений ребер\n\nDiagrammeR::grViz(\"digraph {\n\ngraph [layout = dot, rankdir = LR]\n\n# определить глобальные стили узлов. При желании мы можем изменить их в блоке\nnode [shape = rectangle, style = filled, fillcolor = Linen]\n\ndata1 [label = 'Dataset 1', shape = folder, fillcolor = Beige]\ndata2 [label = 'Dataset 2', shape = folder, fillcolor = Beige]\nprocess [label =  'Process \\n Data']\nstatistical [label = 'Statistical \\n Analysis']\nresults [label= 'Results']\n\n# определения ребер с идентификаторами узлов\n{data1 data2}  -&gt; process -&gt; statistical -&gt; results\n}\")\n\n\n\n\n\n\n\nВыходные данные\nКак работать с выходными данными и сохранять их\n\nВыходные данные появляются в панели просмотра RStudio, по умолчанию в правом нижнем углу рядом с файлами, графиками, пакетами и справкой.\n\nДля экспорта можно воспользоваться командой “Сохранить как изображение” или “Скопировать в буфер обмена” из окна просмотра. График подгоняется под заданный размер.\n\n\n\nПараметризованные рисунки\nВот цитата из этого учебника: https://mikeyharper.uk/flowcharts-in-r-using-diagrammer/\n“Параметризованные рисунки: Большим преимуществом проектирования рисунков в R является то, что мы можем напрямую связать рисунки с нашим анализом, считывая значения R непосредственно в наши блок-схемы. Например, если вы создали процесс фильтрации, который удаляет значения после каждого этапа процесса, вы можете показать на рисунке количество значений, оставшихся в наборе данных после каждого этапа вашего процесса. Для этого можно использовать символ @@X непосредственно в рисунке, а затем сослаться на него в нижнем колонтитуле графика, используя [X]:, где X - уникальный числовой индекс.”\nМы рекомендуем вам ознакомиться с этим учебным пособием, если параметризация представляет для вас интерес.",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Диаграммы и схемы</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.ru.html#аллювиальные-диаграммыдиаграммы-санкей",
    "href": "new_pages/diagrams.ru.html#аллювиальные-диаграммыдиаграммы-санкей",
    "title": "35  Диаграммы и схемы",
    "section": "35.3 Аллювиальные диаграммы/диаграммы Санкей",
    "text": "35.3 Аллювиальные диаграммы/диаграммы Санкей\n\nЗагрузка пакетов\nВ этом фрагменте кода показана загрузка пакетов, необходимых для проведения анализа. В данном руководстве мы делаем акцент на функции p_load() из pacman, которая при необходимости устанавливает пакет и загружает его для использования. Установленные пакеты можно также загрузить с помощью library() из базового R. Более подробную информацию о пакетах R см. на странице [Основы R].\nМы загружаем пакет networkD3 для создания диаграммы, а также пакет tidyverse для подготовки данных.\n\npacman::p_load(\n  networkD3,\n  tidyverse)\n\n\n\nПостроение графиков из набора данных\nПостроение графика связей в наборе данных. Ниже мы продемонстрируем использование этого пакета на примере linelist. Вот [онлайн-учебник] (https://www.r-graph-gallery.com/321-introduction-to-interactive-sankey-diagram-2.html).\nНачнем с того, что получим количество случаев для каждой уникальной комбинации возрастной категории и больницы. Для наглядности мы удалили значения с отсутствующей возрастной категорией. Мы также переименовали столбцы hospital и age_cat в источник и цель соответственно. Это будут две стороны аллювиальной диаграммы.\n\n# подсчеты по больницам и возрастным категориям\nlinks &lt;- linelist %&gt;% \n  drop_na(age_cat) %&gt;% \n  select(hospital, age_cat) %&gt;%\n  count(hospital, age_cat) %&gt;% \n  rename(source = hospital,\n         target = age_cat)\n\nТеперь набор данных выглядит следующим образом:\n\n\n\n\n\n\nТеперь мы создаем датафрейм из всех узлов диаграммы по столбцу name. Он состоит из всех значений для hospital и age_cat. Обратите внимание, что перед объединением мы убеждаемся в том, что все они относятся к классу Символы. и настраиваем столбцы ID так, чтобы они были числами, а не метками:\n\n# Уникальные названия узлов\nnodes &lt;- data.frame(\n  name=c(as.character(links$source), as.character(links$target)) %&gt;% \n    unique()\n  )\n\nnodes  # печать\n\n                                   name\n1                      Central Hospital\n2                     Military Hospital\n3                               Missing\n4                                 Other\n5                         Port Hospital\n6  St. Mark's Maternity Hospital (SMMH)\n7                                   0-4\n8                                   5-9\n9                                 10-14\n10                                15-19\n11                                20-29\n12                                30-49\n13                                50-69\n14                                  70+\n\n\nДалее мы редактируем датафрейм links, который мы создали выше с помощью count(). Добавим два числовых столбца IDsource и IDtarget, которые, собственно, и будут отражать/создавать связи между узлами. В этих столбцах будут храниться номера строк (позиции) исходного и целевого узлов. Чтобы номера позиций начинались с 0 (а не с 1), из них вычитается 1.\n\n# сопоставлять с числами, а не с именами\nlinks$IDsource &lt;- match(links$source, nodes$name)-1 \nlinks$IDtarget &lt;- match(links$target, nodes$name)-1\n\nТеперь набор данных связей выглядит следующим образом:\n\n\n\n\n\n\nТеперь постройте диаграмму Санкей с помощью функции sankeyNetwork(). Подробнее о каждом аргументе можно узнать, выполнив команду ?sankeyNetwork в консоли. Обратите внимание, что если не задать iterations = 0, то порядок следования узлов может быть не таким, как ожидалось.\n\n# график\n######\np &lt;- sankeyNetwork(\n  Links = links,\n  Nodes = nodes,\n  Source = \"IDsource\",\n  Target = \"IDtarget\",\n  Value = \"n\",\n  NodeID = \"name\",\n  units = \"TWh\",\n  fontSize = 12,\n  nodeWidth = 30,\n  iterations = 0)        # обеспечить порядок расположения узлов в соответствии с данными\np\n\n\n\n\n\nПриведем пример, в котором также включен исход пациента. Обратите внимание, что на этапе подготовки данных нам необходимо подсчитать количество случаев по возрасту и больнице, а также отдельно по больнице и исходу, а затем связать все эти подсчеты вместе с помощью bind_rows().\n\n# подсчеты по больницам и возрастным категориям\nage_hosp_links &lt;- linelist %&gt;% \n  drop_na(age_cat) %&gt;% \n  select(hospital, age_cat) %&gt;%\n  count(hospital, age_cat) %&gt;% \n  rename(source = age_cat,          # переименовать\n         target = hospital)\n\nhosp_out_links &lt;- linelist %&gt;% \n    drop_na(age_cat) %&gt;% \n    select(hospital, outcome) %&gt;% \n    count(hospital, outcome) %&gt;% \n    rename(source = hospital,       # переименовать\n           target = outcome)\n\n# объединить связи\nlinks &lt;- bind_rows(age_hosp_links, hosp_out_links)\n\n# Уникальные названия узлов\nnodes &lt;- data.frame(\n  name=c(as.character(links$source), as.character(links$target)) %&gt;% \n    unique()\n  )\n\n# Создание идентификаторов\nlinks$IDsource &lt;- match(links$source, nodes$name)-1 \nlinks$IDtarget &lt;- match(links$target, nodes$name)-1\n\n# график\n######\np &lt;- sankeyNetwork(Links = links,\n                   Nodes = nodes,\n                   Source = \"IDsource\",\n                   Target = \"IDtarget\",\n                   Value = \"n\",\n                   NodeID = \"name\",\n                   units = \"TWh\",\n                   fontSize = 12,\n                   nodeWidth = 30,\n                   iterations = 0)\np\n\n\n\n\n\nhttps://www.displayr.com/sankey-diagrams-r/",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Диаграммы и схемы</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.ru.html#временная-шкала-событий",
    "href": "new_pages/diagrams.ru.html#временная-шкала-событий",
    "title": "35  Диаграммы и схемы",
    "section": "35.4 Временная шкала событий",
    "text": "35.4 Временная шкала событий\nДля создания временной шкалы, показывающей конкретные события, можно использовать пакет vistime.\nСм. виньетка\n\n# загрузка пакета\npacman::p_load(vistime,  # создать временную шкалу\n               plotly    # для интерактивной визуализации\n               )\n\nВот набор данных событий, с которого мы начинаем:\n\n\n\n\n\n\n\np &lt;- vistime(data)    # применить vistime\n\nlibrary(plotly)\n\n# шаг 1: преобразование в список\npp &lt;- plotly_build(p)\n\n# шаг 2: Размер маркера\nfor(i in 1:length(pp$x$data)){\n  if(pp$x$data[[i]]$mode == \"markers\") pp$x$data[[i]]$marker$size &lt;- 10\n}\n\n# шаг 3: размер текста\nfor(i in 1:length(pp$x$data)){\n  if(pp$x$data[[i]]$mode == \"text\") pp$x$data[[i]]$textfont$size &lt;- 10\n}\n\n\n# шаг 4: расположение текста\nfor(i in 1:length(pp$x$data)){\n  if(pp$x$data[[i]]$mode == \"text\") pp$x$data[[i]]$textposition &lt;- \"right\"\n}\n\n#печать\npp",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Диаграммы и схемы</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.ru.html#dag",
    "href": "new_pages/diagrams.ru.html#dag",
    "title": "35  Диаграммы и схемы",
    "section": "35.5 DAG",
    "text": "35.5 DAG\nВы можете построить DAG вручную, используя пакет DiagammeR и язык DOT, как описано выше.\nВ качестве альтернативы существуют такие пакеты, как ggdag и daggity.\nВведение в DAGs ggdag vignette\n[Причинно-следственные выводы с использованием dags в R].(https://www.r-bloggers.com/2019/08/causal-inference-with-dags-in-r/#:~:text=In%20a%20DAG%20all%20the,for%20drawing%20and%20analyzing%20DAGs.)",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Диаграммы и схемы</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.ru.html#ресурсы",
    "href": "new_pages/diagrams.ru.html#ресурсы",
    "title": "35  Диаграммы и схемы",
    "section": "35.6 Ресурсы",
    "text": "35.6 Ресурсы\nМногое из изложенного выше по языку DOT взято из учебника сайт.\nДругой, более подробный учебник по диаграммам\nЭта страница, посвященная вопросу диаграмма Санкей",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Диаграммы и схемы</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.ru.html",
    "href": "new_pages/combination_analysis.ru.html",
    "title": "36  Анализ комбинаций",
    "section": "",
    "text": "36.1 Подготовка",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Анализ комбинаций</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.ru.html#подготовка",
    "href": "new_pages/combination_analysis.ru.html#подготовка",
    "title": "36  Анализ комбинаций",
    "section": "",
    "text": "Загрузка пакетов\nВ этом фрагменте кода показана загрузка пакетов, необходимых для проведения анализа. В данном руководстве мы делаем акцент на функции p_load() из pacman, которая при необходимости устанавливает пакет и загружает его для использования. Установленные пакеты можно также загрузить с помощью library() из базового R. Более подробную информацию о пакетах R см. на странице Основы R.\n\npacman::p_load(\n  tidyverse,     # управление данными и их визуализация\n  UpSetR,        # специальный пакет для графиков с комбинированными данными\n  ggupset)       # специальный пакет для графиков с комбинированными данными\n\n\n\n\nИмпорт данных\nДля начала мы импортируем построчный список случаев из смоделированной эпидемии лихорадки Эбола. Если вы хотите проследить за ходом работы, нажмите кнопку, чтобы загрузить “чистый” построчный список (в виде файла .rds). Импортируйте данные с помощью функции import() из пакета rio (она работает со многими типами файлов, такими как .xlsx, .csv, .rds - подробности см. на странице Импорт и экспорт).\n\n# импортный построчный список \nlinelist_sym &lt;- import(\"linelist_cleaned.rds\")\n\nЭтот построчный список включает пять переменных “да/нет”, касающихся заявленных симптомов. Для построения графика с помощью пакета ggupset нам потребуется немного преобразовать эти переменные. Просмотрите данные (прокрутите страницу вправо, чтобы увидеть переменные симптомов).\n\n\n\n\n\n\n\n\n\nПереформатирование значений\nДля соответствия формату, ожидаемому ggupset, мы преобразуем ““да”” и “нет” в название симптома, используя case_when() из dplyr. Если “нет”, мы устанавливаем значение как пустое, так что значениями будут либо NA, либо симптом.\n\n# создать столбец с названиями симптомов, разделенных точками с запятой\nlinelist_sym_1 &lt;- linelist_sym %&gt;% \n\n  # преобразовать значения \"да\" и \"нет\" в само название симптома\n  # если старое значение \"да\", то новое - \" лихорадка\", в противном случае - значение отсутствует (NA)\nmutate(fever = ifelse(fever == \"yes\", \"fever\", NA), \n       chills = ifelse(chills == \"yes\", \"chills\", NA),\n       cough = ifelse(cough == \"yes\", \"cough\", NA),\n       aches = ifelse(aches == \"yes\", \"aches\", NA),\n       vomit = ifelse(vomit == \"yes\", \"vomit\", NA))\n\nТеперь создадим два последних столбца:\n\nКонкатенация (склеивание) всех симптомов пациента (столбец символов)\n\nПреобразуем приведенный столбец в класс список, чтобы он мог быть принят функцией ggupset для построения графика\n\nПодробнее о функции unite() из stringr см. на странице Текст и последовательности.\n\nlinelist_sym_1 &lt;- linelist_sym_1 %&gt;% \n  unite(col = \"all_symptoms\",\n        c(fever, chills, cough, aches, vomit), \n        sep = \"; \",\n        remove = TRUE,\n        na.rm = TRUE) %&gt;% \n  mutate(\n    # создать копию столбца all_symptoms, но класса \"список\" (что необходимо для использования функции ggupset() на следующем шаге)\n    all_symptoms_list = as.list(strsplit(all_symptoms, \"; \"))\n    )\n\nПросмотрите новые данные. Обратите внимание на два столбца с правой стороны - вставленные комбинированные значения и список",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Анализ комбинаций</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.ru.html#ggupset",
    "href": "new_pages/combination_analysis.ru.html#ggupset",
    "title": "36  Анализ комбинаций",
    "section": "36.2 ggupset",
    "text": "36.2 ggupset\nЗагрузка пакета\n\npacman::p_load(ggupset)\n\nСоздайте график. Мы начинаем с ggplot() и geom_bar(), но затем добавляем специальную функцию scale_x_upset() из ggupset.\n\nggplot(\n  data = linelist_sym_1,\n  mapping = aes(x = all_symptoms_list)) +\ngeom_bar() +\nscale_x_upset(\n  reverse = FALSE,\n  n_intersections = 10,\n  sets = c(\"fever\", \"chills\", \"cough\", \"aches\", \"vomit\"))+\nlabs(\n  title = \"Signs & symptoms\",\n  subtitle = \"10 most frequent combinations of signs and symptoms\",\n  caption = \"Caption here.\",\n  x = \"Symptom combination\",\n  y = \"Frequency in dataset\")\n\n\n\n\n\n\n\n\nБолее подробную информацию о ggupset можно найти онлайн или офлайн в документации к пакету на вкладке RStudio Help ?ggupset.",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Анализ комбинаций</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.ru.html#upsetr",
    "href": "new_pages/combination_analysis.ru.html#upsetr",
    "title": "36  Анализ комбинаций",
    "section": "36.3 UpSetR",
    "text": "36.3 UpSetR\nПакет UpSetR позволяет лучше настраивать график, но может быть более сложным в исполнении:\nЗагрузка пакета\n\npacman::p_load(UpSetR)\n\nВычистка данных\nМы должны преобразовать значения симптомов построчного списка к 1 / 0.\n\nlinelist_sym_2 &lt;- linelist_sym %&gt;% \n     # преобразовать значения \"да\" и \"нет\" в 1 и 0\n     mutate(fever = ifelse(fever == \"yes\", 1, 0), \n            chills = ifelse(chills == \"yes\", 1, 0),\n            cough = ifelse(cough == \"yes\", 1, 0),\n            aches = ifelse(aches == \"yes\", 1, 0),\n            vomit = ifelse(vomit == \"yes\", 1, 0))\n\nЕсли вас интересует более эффективная команда, вы можете воспользоваться функцией +(), которая преобразует в 1 и 0 на основе логического оператора. Эта команда использует функцию across() для одновременного изменения нескольких столбцов (подробнее об этом читайте в разделе Вычистка данных и ключевые функции).\n\n# Эффективное преобразование \"да\" в 1 и 0\nlinelist_sym_2 &lt;- linelist_sym %&gt;% \n  \n  # преобразовать значения \"да\" и \"нет\" в 1 и 0\n  mutate(across(c(fever, chills, cough, aches, vomit), .fns = ~+(.x == \"yes\")))\n\nТеперь постройте график с помощью пользовательской функции upset(), используя только столбцы симптомов. Вы должны указать, какие “наборы” сравнивать (названия столбцов симптомов). В качестве альтернативы можно использовать nsets = и order.by = \"freq\", чтобы показать только самые первые комбинации X.\n\n# Построить график\nlinelist_sym_2 %&gt;% \n  UpSetR::upset(\n       sets = c(\"fever\", \"chills\", \"cough\", \"aches\", \"vomit\"),\n       order.by = \"freq\",\n       sets.bar.color = c(\"blue\", \"red\", \"yellow\", \"darkgreen\", \"orange\"), # optional colors\n       empty.intersections = \"on\",\n       # nsets = 3,\n       number.angles = 0,\n       point.size = 3.5,\n       line.size = 2, \n       mainbar.y.label = \"Symptoms Combinations\",\n       sets.x.label = \"Patients with Symptom\")",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Анализ комбинаций</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.ru.html#ресурсы",
    "href": "new_pages/combination_analysis.ru.html#ресурсы",
    "title": "36  Анализ комбинаций",
    "section": "36.4 Ресурсы",
    "text": "36.4 Ресурсы\nСтраница github на UpSetR\nВерсия Shiny App - вы можете загружать свои собственные данные\n*документация - сложная для интерпретации",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Анализ комбинаций</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.ru.html",
    "href": "new_pages/transmission_chains.ru.html",
    "title": "37  Цепочки передачи",
    "section": "",
    "text": "37.1 Обзор\nОсновным инструментом для обработки, анализа и визуализации цепочек передачи и данных о контактах является пакет epicontacts, разработанный специалистами компании RECON. Попробуйте воспользоваться приведенным ниже интерактивным графиком, наводя курсор на вершины для получения дополнительной информации, перетаскивая их для перемещения и нажимая на них для выделения случаев заболевания.\nWarning in epicontacts::make_epicontacts(linelist = linelist, contacts =\ncontacts, : Cycle(s) detected in the contact network: this may be unwanted",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Цепочки передачи</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.ru.html#подготовка",
    "href": "new_pages/transmission_chains.ru.html#подготовка",
    "title": "37  Цепочки передачи",
    "section": "37.2 Подготовка",
    "text": "37.2 Подготовка\n\nЗагрузка пакетов\nСначала загрузите стандартные пакеты, необходимые для импорта и управления данными. В данном руководстве мы делаем акцент на функции p_load() из pacman, которая при необходимости устанавливает пакет и загружает его для использования. Также можно загрузить пакеты с помощью library() из базового R. Более подробную информацию о пакетах R см. на странице [Основы R].\n\npacman::p_load(\n   rio,          # Импорт файлов\n   here,         # Локатор файлов\n   tidyverse,    # Управление данными + графика ggplot2\n   remotes       # Установка пакетов из github\n)\n\nВам потребуется версия epicontacts, которая может быть установлена из github с помощью функции p_install_github() из pacman. Эту команду необходимо выполнить только ниже, а не при каждом использовании пакета (в дальнейшем можно использовать p_load() как обычно).\n\npacman::p_install_gh(\"reconhub/epicontacts@timeline\")\n\n\n\nИмпорт данных\nМы импортируем набор данных о случаях из смоделированной эпидемии лихорадки Эбола. Если вы хотите загрузить данные, чтобы проследить за ходом работы, см. инструкции на странице [Скачивание руководства и данных]. Набор данных импортируется с помощью функции import() из пакета rio. Различные способы импорта см. на странице [Импорт и экспорт].ta.\n\n# импортировать построчный список\nlinelist &lt;- import(\"linelist_cleaned.xlsx\")\n\nНиже показаны первые 50 строк построчного списка. Особый интерес представляют столбцы case_id, generation, infector и source.\n\n\n\n\n\n\n\n\nСоздание объекта epicontacts\nЗатем нам необходимо создать объект epicontacts, для которого требуется два типа данных:\n\nпострочный список, документирующий случаи, где столбцы являются переменными, а строки соответствуют уникальным случаям\nсписок ребер, определяющих связи между случаями на основе их уникальных идентификаторов (это могут быть контакты, события передачи и т.д.)\n\nПоскольку у нас уже есть построчный список, нам просто нужно создать список ребер между случаями, а точнее между их идентификаторами. Мы можем извлечь связи передачи из построчного списка, связав столбец infector со столбцом case_id. На этом этапе мы также можем добавить “свойства ребра”, под которыми мы понимаем любую переменную, описывающую связь между двумя случаями, а не сами случаи. Для примера добавим переменную location, описывающую местоположение события передачи, и переменную продолжительность, описывающую продолжительность контакта в днях.\nВ приведенном ниже коде dplyr функция transmute аналогична mutate, за исключением того, что она сохраняет только те столбцы, которые мы указали в функции. Функция drop_na отфильтрует все строки, в которых указанные столбцы имеют значение NA; в данном случае мы хотим сохранить только те строки, в которых известно заразившее лицо.\n\n## создание контактов\ncontacts &lt;- linelist %&gt;%\n  transmute(\n    infector = infector,\n    case_id = case_id,\n    location = sample(c(\"Community\", \"Nosocomial\"), n(), TRUE),\n    duration = sample.int(10, n(), TRUE)\n  ) %&gt;%\n  drop_na(infector)\n\nТеперь мы можем создать объект epicontacts с помощью функции make_epicontacts. Нам необходимо указать, какой столбец в построчном списке указывает на уникальный идентификатор случая, а также какие столбцы в контактах указывают на уникальные идентификаторы случаев, участвующих в каждой связи. Эти связи имеют направление в том смысле. что инфекция идет от заразившего лица к случаю, поэтому нам необходимо задать аргументы from и to соответственно. Поэтому мы также устанавливаем аргумент directed в значение TRUE, что повлияет на дальнейшие операции.\n\n## создание объекта epicontacts\nepic &lt;- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts,\n  id = \"case_id\",\n  from = \"infector\",\n  to = \"case_id\",\n  directed = TRUE\n)\n\nWarning in make_epicontacts(linelist = linelist, contacts = contacts, id =\n\"case_id\", : Cycle(s) detected in the contact network: this may be unwanted\n\n\nИзучив объекты epicontacts, мы видим, что столбец case_id в построчном списке был переименован в id, а столбцы case_id и infector в контактах были переименованы в столбцы from и to. Это обеспечивает последовательность в последующих операциях обработки, визуализации и анализа.\n\n## просмотр объекта epicontacts\nepic\n\n\n/// Epidemiological Contacts //\n\n  // class: epicontacts\n  // 5,888 cases in linelist; 3,800 contacts; directed \n\n  // linelist\n\n# A tibble: 5,888 × 30\n   id     generation date_infection date_onset date_hospitalisation date_outcome\n   &lt;chr&gt;       &lt;dbl&gt; &lt;date&gt;         &lt;date&gt;     &lt;date&gt;               &lt;date&gt;      \n 1 5fe599          4 2014-05-08     2014-05-13 2014-05-15           NA          \n 2 8689b7          4 NA             2014-05-13 2014-05-14           2014-05-18  \n 3 11f8ea          2 NA             2014-05-16 2014-05-18           2014-05-30  \n 4 b8812a          3 2014-05-04     2014-05-18 2014-05-20           NA          \n 5 893f25          3 2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n 6 be99c8          3 2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n 7 07e3e8          4 2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n 8 369449          4 2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n 9 f393b4          4 NA             2014-06-05 2014-06-06           2014-06-18  \n10 1389ca          4 NA             2014-06-05 2014-06-07           2014-06-09  \n# ℹ 5,878 more rows\n# ℹ 24 more variables: outcome &lt;chr&gt;, gender &lt;chr&gt;, age &lt;dbl&gt;, age_unit &lt;chr&gt;,\n#   age_years &lt;dbl&gt;, age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;, hospital &lt;chr&gt;, lon &lt;dbl&gt;,\n#   lat &lt;dbl&gt;, infector &lt;chr&gt;, source &lt;chr&gt;, wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;,\n#   ct_blood &lt;dbl&gt;, fever &lt;chr&gt;, chills &lt;chr&gt;, cough &lt;chr&gt;, aches &lt;chr&gt;,\n#   vomit &lt;chr&gt;, temp &lt;dbl&gt;, time_admission &lt;chr&gt;, bmi &lt;dbl&gt;,\n#   days_onset_hosp &lt;dbl&gt;\n\n  // contacts\n\n# A tibble: 3,800 × 4\n   from   to     location   duration\n   &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;         &lt;int&gt;\n 1 f547d6 5fe599 Nosocomial        6\n 2 f90f5f b8812a Community         6\n 3 11f8ea 893f25 Nosocomial        2\n 4 aec8ec be99c8 Community         5\n 5 893f25 07e3e8 Community         9\n 6 133ee7 369449 Community         3\n 7 996f3a 2978ac Nosocomial        3\n 8 133ee7 57a565 Nosocomial        4\n 9 37a6f6 fc15ef Nosocomial        8\n10 9f6884 2eaa9a Community         3\n# ℹ 3,790 more rows",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Цепочки передачи</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.ru.html#обработка",
    "href": "new_pages/transmission_chains.ru.html#обработка",
    "title": "37  Цепочки передачи",
    "section": "37.3 Обработка",
    "text": "37.3 Обработка\n\nПодмножество\nМетод subset() для объектов epicontacts позволяет, в частности, фильтровать сети на основе свойств построчного списка (“атрибуты узлов”) и базы данных контактов (“атрибуты ребер”). Эти значения должны быть переданы в виде списков с названиями соответствующему аргументу. Например, в приведенном ниже коде мы сохраняем в списке только те мужские случаи в построенном списке, которые имеют дату заражения в период с апреля по июль 2014 года (даты указаны в виде диапазонов), а также связи передачи, произошедшие в больнице.\n\nsub_attributes &lt;- subset(\n  epic,\n  node_attribute = list(\n    gender = \"m\",\n    date_infection = as.Date(c(\"2014-04-01\", \"2014-07-01\"))\n  ), \n  edge_attribute = list(location = \"Nosocomial\")\n)\nsub_attributes\n\n\n/// Epidemiological Contacts //\n\n  // class: epicontacts\n  // 69 cases in linelist; 1,893 contacts; directed \n\n  // linelist\n\n# A tibble: 69 × 30\n   id     generation date_infection date_onset date_hospitalisation date_outcome\n   &lt;chr&gt;       &lt;dbl&gt; &lt;date&gt;         &lt;date&gt;     &lt;date&gt;               &lt;date&gt;      \n 1 5fe599          4 2014-05-08     2014-05-13 2014-05-15           NA          \n 2 893f25          3 2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n 3 2978ac          4 2014-05-30     2014-06-06 2014-06-08           2014-06-15  \n 4 57a565          4 2014-05-28     2014-06-13 2014-06-15           NA          \n 5 fc15ef          6 2014-06-14     2014-06-16 2014-06-17           2014-07-09  \n 6 99e8fa          7 2014-06-24     2014-06-28 2014-06-29           2014-07-09  \n 7 f327be          6 2014-06-14     2014-07-12 2014-07-13           2014-07-14  \n 8 90e5fe          5 2014-06-18     2014-07-13 2014-07-14           2014-07-16  \n 9 a47529          5 2014-06-13     2014-07-17 2014-07-18           2014-07-26  \n10 da8ecb          5 2014-06-20     2014-07-18 2014-07-20           2014-08-01  \n# ℹ 59 more rows\n# ℹ 24 more variables: outcome &lt;chr&gt;, gender &lt;chr&gt;, age &lt;dbl&gt;, age_unit &lt;chr&gt;,\n#   age_years &lt;dbl&gt;, age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;, hospital &lt;chr&gt;, lon &lt;dbl&gt;,\n#   lat &lt;dbl&gt;, infector &lt;chr&gt;, source &lt;chr&gt;, wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;,\n#   ct_blood &lt;dbl&gt;, fever &lt;chr&gt;, chills &lt;chr&gt;, cough &lt;chr&gt;, aches &lt;chr&gt;,\n#   vomit &lt;chr&gt;, temp &lt;dbl&gt;, time_admission &lt;chr&gt;, bmi &lt;dbl&gt;,\n#   days_onset_hosp &lt;dbl&gt;\n\n  // contacts\n\n# A tibble: 1,893 × 4\n   from   to     location   duration\n   &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;         &lt;int&gt;\n 1 f547d6 5fe599 Nosocomial        6\n 2 11f8ea 893f25 Nosocomial        2\n 3 996f3a 2978ac Nosocomial        3\n 4 133ee7 57a565 Nosocomial        4\n 5 37a6f6 fc15ef Nosocomial        8\n 6 b799eb bc2adf Nosocomial        4\n 7 5d9e4d 8bd1e8 Nosocomial        9\n 8 beb26e 959170 Nosocomial        5\n 9 a2086d a47529 Nosocomial        9\n10 d6584f f5c142 Nosocomial        9\n# ℹ 1,883 more rows\n\n\nМы можем использовать функцию thin либо для фильтрации построчного списка, чтобы включить в него случаи которые встречаются в контактах, задав аргумент what = \" linelist\", либо отфильтровать контакты для включения случаев, найденных в построчном списке, задав аргумент what = \"contacts\". В приведенном ниже коде мы дополнительно фильтруем объект epicontacts, чтобы сохранить только связи передачи, связанные со случаями заражения мужчин в период с апреля по июль, которые мы отфильтровали выше. Мы видим, что только две известные связи соответствуют этому требованию.\n\nsub_attributes &lt;- thin(sub_attributes, what = \"contacts\")\nnrow(sub_attributes$contacts)\n\n[1] 2\n\n\nВ дополнение к подмножеству по атрибутам узлов и ребер, сети могут быть обрезаны таким образом, чтобы включать только те компоненты, которые связаны с определенными узлами. Аргумент cluster_id принимает вектор идентификаторов случаев и возвращает построчный список лиц, которые прямо или косвенно связаны с этими идентификаторами. В приведенном ниже коде мы видим, что в кластерах, содержащих 2ae019 и 2ae019, задействовано в общей сложности 13 построчных списков.\n\nsub_id &lt;- subset(epic, cluster_id = c(\"2ae019\",\"71577a\"))\nnrow(sub_id$linelist)\n\n[1] 13\n\n\nМетод subset() для объектов epicontacts также позволяет осуществлять фильтрацию по размеру кластера используя аргументы cs, cs_min и cs_max. В приведенном ниже коде мы сохраняем только случаи, связанные с кластерами, состоящими из 10 случаев и более, и видим, что 271 случай из построчного списка участвует в таких кластерах.\n\nsub_cs &lt;- subset(epic, cs_min = 10)\nnrow(sub_cs$linelist)\n\n[1] 271\n\n\n\n\nДоступ к идентификаторам\nФункция get_id() извлекает информацию об идентификаторах случаев в наборе данных и может быть определена следующим образом:\n\nlinelist: Идентификаторы в данных построчного списка\ncontacts: Идентификаторы в наборе данных о контактах (объединение “от” и ” к”)\nfrom: идентификаторы в столбце ““от”” набора данных о контактах\nto: идентификаторы в столбце “к” набора данных о контактах\nall: Идентификаторы, встречающиеся в любом месте любого из наборов данных\ncommon: Идентификаторы, которые встречаются как в наборе данных контактов, так и в построчном списке\n\nНапример, каковы первые десять идентификаторов в наборе данных контактов?\n\ncontacts_ids &lt;- get_id(epic, \"contacts\")\nhead(contacts_ids, n = 10)\n\n [1] \"f547d6\" \"f90f5f\" \"11f8ea\" \"aec8ec\" \"893f25\" \"133ee7\" \"996f3a\" \"37a6f6\"\n [9] \"9f6884\" \"4802b1\"\n\n\nСколько идентификаторов содержится в построчном списке и в контактах?\n\nlength(get_id(epic, \"common\"))\n\n[1] 4352",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Цепочки передачи</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.ru.html#визуализация",
    "href": "new_pages/transmission_chains.ru.html#визуализация",
    "title": "37  Цепочки передачи",
    "section": "37.4 Визуализация",
    "text": "37.4 Визуализация\n\nБазовое построение графиков\nВсе визуализации объектов epicontacts обрабатываются функцией plot. Сначала отфильтруем объект epicontacts, чтобы включить в него только случаи с датой начала заболевания в июне 2014 года, используя функцию subset, и включим только контакты, связанные с этими случаями, с помощью функции thin.\n\n## объект подмножества epicontacts\nsub &lt;- epic %&gt;%\n  subset(\n    node_attribute = list(date_onset = c(as.Date(c(\"2014-06-30\", \"2014-06-01\"))))\n  ) %&gt;%\n thin(\"contacts\")\n\nПосле этого мы можем построить базовый интерактивный график следующим образом:\n\n## построение объекта epicontacts\nplot(\n  sub,\n  width = 700,\n  height = 700\n)\n\n\n\n\n\nУзлы можно перемещать, перетаскивая их, наводить на них курсор, чтобы получить дополнительную информацию, и щелкать по ним мышью, выделяя связанные случаи.\nСуществует большое количество аргументов для дальнейшей модификации этого графика. Мы рассмотрим основные из них, но ознакомьтесь с документацией по функции ?vis_epicontacts (функция, вызываемая при использовании plot на объекте epicontacts), чтобы получить полное описание аргументов функции.\n\nВизуализация атрибутов узлов\nЦвет узла, форма узла и его размер могут быть сопоставлены с заданным столбцом построчного списка используя аргументы node_color, node_shape и node_size. Это аналогично синтаксису aes, который вы можете узнать из ggplot2.\nКонкретные цвета, формы и размеры узлов могут быть заданы следующим образом:\n\nЦвета через аргумент col_pal, либо предоставив список названий для указания каждого цвета вручную, как это сделано ниже, либо задав функцию палитры цветов,\nнапример, colorRampPalette(c(\"black\", \"red\", \"orange\")), которая обеспечит градиент между указанными цветами.\nФормы, передавая список с названием в аргументе shapes, указывая одну форму для каждого уникального элемента построчного списка, указанного аргументом node_shape. Доступные формы см. в разделе codeawesome.\nРазмер путем передачи диапазона размеров узлов в аргумент size_range.\n\nПриведем пример, где цвет обозначает результат, форма - пол, а размер возраст:\n\nplot(\n  sub, \n  node_color = \"outcome\",\n  node_shape = \"gender\",\n  node_size = \"age\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  shapes = c(f = \"female\", m = \"male\"),\n  size_range = c(40, 60),\n  height = 700,\n  width = 700\n)\n\n\n\n\n\n\n\nВизуализация атрибутов ребер\nЦвет, ширина и тип линии ребра могут быть привязаны к заданному столбцу в датафрейме контактов с помощью edge_color, edge_width и edge_linetype. Конкретные цвета и ширина ребер могут быть заданы следующим образом:\n\nЦвета через аргумент edge_col_pal, аналогично тому, как это делается для col_pal.\nШирины, передавая диапазон размеров узлов в аргументе width_range.\n\nПриведем пример:\n\nplot(\n  sub, \n  node_color = \"outcome\",\n  node_shape = \"gender\",\n  node_size = 'age',\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  shapes = c(f = \"female\", m = \"male\"),\n  size_range = c(40, 60),\n  edge_color = 'location',\n  edge_linetype = 'location',\n  edge_width = 'duration',\n  edge_col_pal = c(Community = \"orange\", Nosocomial = \"purple\"),\n  width_range = c(1, 3),\n  height = 700,\n  width = 700\n)\n\n\n\n\n\n\n\n\nВременная ось\nМы также можем визуализировать сеть вдоль временной оси, связав аргумент x_axis со столбцом построчного списка. В приведенном ниже примере ось x обозначает дату начала симптомов. Мы также указали аргумент arrow_size чтобы стрелки не были слишком большими, и задали label = FALSE, чтобы сделать рисунок менее загроможденным.\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n\n\n\n\n\nСуществует большое количество дополнительных аргументов, позволяющих более точно определить, как эта сеть визуализируется по временной оси, что можно проверить с помощью функции ?vis_temporal_interactive (функция, вызываемая при использовании plot на объекте epicontacts с указанной x_axis). Ниже мы рассмотрим некоторые примеры.\n\nЗадание формы дерева передачи\nСуществует две основные формы, которые может принимать дерево передачи, задаваемые с помощью аргумента network_shape. Первая - это разветвленная форма branching, как показано выше, где прямое ребро соединяет любые два узла. Это наиболее интуитивно понятное представление, однако в густонаселенной сети оно может привести к наложению ребер друг на друга Вторая форма - прямоугольник rectangle - представляет собой дерево, напоминающее филогенез Например:\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n\n\n\n\n\nКаждому узлу случая может быть присвоено уникальное вертикальное положение путем переключения аргумента position_dodge. Положение несвязанных случаев (т.е. не имеющих контактов) задается с помощью аргумента unlinked_pos.\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  position_dodge = TRUE,\n  unlinked_pos = \"bottom\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n\n\n\n\n\nПоложение родительского узла относительно дочерних узлов может быть задано с помощью аргумента parent_pos. По умолчанию родительский узел располагается в середине, однако его можно расположить снизу (parent_pos = 'bottom') или сверху (parent_pos = 'top').\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  parent_pos = \"top\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n\n\n\n\n\n\n\nСохранение графиков и рисунков\nСохранить график в виде интерактивного, самодостаточного html-файла можно с помощью функции visSave из пакета VisNetwork:\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  parent_pos = \"top\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n) %&gt;%\n  visNetwork::visSave(\"network.html\")\n\nСохранение этих исходов в виде изображения, к сожалению, не так просто и требует сохранить файл в формате html, а затем сделать скриншот этого файла с помощью пакета webshot. В приведенном ниже коде мы преобразуем сохраненный html-файл в PNG:\n\nwebshot(url = \"network.html\", file = \"network.png\")\n\n\n\n\nВременные рамки\nВ сети также можно рассматривать временные рамки, которые представлены на оси x каждого случая. Это можно сделать, например, для визуализации местоположения случая или времени до исхода. Чтобы сгенерировать временную шкалу, необходимо создать датафрейм, состоящий как минимум из трех столбцов с указанием идентификатора случая, даты начала “события” и даты окончания “события”. Можно также добавить любое количество других столбцов, которые затем можно сопоставить со свойствами узлов и ребер временной шкалы. В приведенном ниже коде мы генерируем временную шкалу, начиная с даты начала симптомов и заканчивая датой исхода, и сохраняем переменные исхода и больницы, которые мы используем для определения формы и цвета узлов. Обратите внимание, что в каждом случае может быть более одной строки/события временной шкалы на один случай, например, если случай переводится между несколькими больницами.\n\n## создание временных рамок\ntimeline &lt;- linelist %&gt;%\n  transmute(\n    id = case_id,\n    start = date_onset,\n    end = date_outcome,\n    outcome = outcome,\n    hospital = hospital\n  )\n\nЗатем мы передаем элемент временной шкалы в аргумент timeline. Мы можем сопоставить атрибуты временной шкалы цветам, формам и размерам узлов временной шкалы таким же образом, какой был определен в предыдущих разделах. за исключением того, что у нас есть два узла: начальный и конечный узел каждой временной шкалы, которые имеют отдельные аргументы. Например, tl_start_node_color определяет, какой столбец временной шкалы сопоставлен с цветом начального узла, а tl_end_node_shape определяет, какой столбец временной шкалы будет сопоставлен с формой конечного узла. Мы также можем сопоставить цвет, ширину, тип линий и метки с аргументами временной шкалы tl_edge_*.\nПодробную документацию по аргументам см. в разделе ?vis_temporal_interactive (функция, вызываемая при построении графика объекта epicontacts). для получения подробной документации по аргументам. Каждый аргумент аннотирован в приведенном ниже коде:\n\n## определение форм\nshapes &lt;- c(\n  f = \"female\",\n  m = \"male\",\n  Death = \"user-times\",\n  Recover = \"heartbeat\",\n  \"NA\" = \"question-circle\"\n)\n\n## определение цветов\ncolours &lt;- c(\n  Death = \"firebrick\",\n  Recover = \"green\",\n  \"NA\" = \"grey\"\n)\n\n## создание графика\nplot(\n  sub,\n  ## максимальная координата x к дате начала заболевания\n  x_axis = \"date_onset\",\n  ## использовать прямоугольную форму сети\n  network_shape = \"rectangle\",\n  ## сопоставить формы узлов случая со столбоцом пола \n  node_shape = \"gender\",\n  ## мы не хотим сопоставлять цвет узла с каким-либо столбцом - это важно, поскольку\n  ## значение по умолчанию сопоставляется с id узла, что приводит к нарушению цветовой схемы\n  node_color = NULL,\n  ## установить размер узла случая равным 30 (поскольку это не символ, node_size не\n  ## отображается на столбец, но вместо этого интерпретируется как фактический размер узла)\n  node_size = 30,\n  ## установить ширину связи передачи равной 4 (поскольку это не символ, ширина edge_width\n  ## не отображается на столбец, а интерпретируется как фактическая ширина ребра)\n  edge_width = 4,\n  ## предоставить объект временной шкалы\n  timeline = timeline,\n  ## сопоставить форму конечного узла со столбцом исходов в объекте временной шкалы\n  tl_end_node_shape = \"outcome\",\n  ## установить размер конечного узла равным 15 (поскольку это не символ, \n  ## аргумент не сопоставляется со столбцом, а интерпретируется как фактический\n  ## размер узла)\n  tl_end_node_size = 15,\n  ## сопоставить цвет ребра временной шкалы со столбцом больницы\n  tl_edge_color = \"hospital\",\n  ## установить ширину ребра временной шкалы равной 2 (поскольку это не символ, \n  ## аргумент не сопоставляется со столбцом, а интерпретируется как фактическая\n  ## ширина ребра)\n  tl_edge_width = 2,\n  ## сопоставить метки ребер с переменной больницы\n  tl_edge_label = \"hospital\",\n  ## задать форму для каждого атрибута узла (см. выше)\n  shapes = shapes,\n  ## задать цветовую палитру (см. выше)\n  col_pal = colours,\n  ## установить размер стрелки равным 0,5\n  arrow_size = 0.5,\n  ## использовать два столбца в легенде\n  legend_ncol = 2,\n  ## установить размер шрифта\n  font_size = 15,\n  ## определение форматирования для дат\n  date_labels = c(\"%d %b %Y\"),\n  ## не отображать метки идентификаторов ниже узлов\n  label = FALSE,\n  ## задать высоту\n  height = 1000,\n  ## задать ширину\n  width = 1200,\n  ## убедитесь, что каждый узел случая имеет уникальную координату y - это очень важно\n  ## при использовании временных шкал, иначе у вас будут перекрываться временные шкалы от\n  ## различных случаев\n  position_dodge = TRUE\n)\n\nWarning in assert_timeline(timeline, x, x_axis): 5865 timeline row(s) removed\nas ID not found in linelist or start/end date is NA",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Цепочки передачи</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.ru.html#анализ",
    "href": "new_pages/transmission_chains.ru.html#анализ",
    "title": "37  Цепочки передачи",
    "section": "37.5 Анализ",
    "text": "37.5 Анализ\n\nОбобщение\nМы можем получить общее представление о некоторых свойствах сети с помощью функции summary.\n\n## обобщить объект epicontacts\nsummary(epic)\n\n\n/// Overview //\n  // number of unique IDs in linelist: 5888\n  // number of unique IDs in contacts: 5511\n  // number of unique IDs in both: 4352\n  // number of contacts: 3800\n  // contacts with both cases in linelist: 56.868 %\n\n/// Degrees of the network //\n  // in-degree summary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.0000  0.0000  1.0000  0.5392  1.0000  1.0000 \n\n  // out-degree summary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.0000  0.0000  0.0000  0.5392  1.0000  6.0000 \n\n  // in and out degree summary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   1.000   1.000   1.078   1.000   7.000 \n\n/// Attributes //\n  // attributes in linelist:\n generation date_infection date_onset date_hospitalisation date_outcome outcome gender age age_unit age_years age_cat age_cat5 hospital lon lat infector source wt_kg ht_cm ct_blood fever chills cough aches vomit temp time_admission bmi days_onset_hosp\n\n  // attributes in contacts:\n location duration\n\n\nНапример, мы видим, что только 57% контактов имеют оба случая в построчном списке Это означает, что мы не располагаем данными построчного списка по значительному числу случаев, задействованных в этих цепочках передачи.\n\n\nПарные характеристики\nФункция get_pairwise() позволяет обрабатывать переменную(ые) в списке строк в соответствии с каждой парой в наборе данных контактов. В следующем примере из списка строк извлекается дата начала заболевания, чтобы вычислить разницу между датами начала заболевания для каждой пары. Полученное в результате этого сравнения, представляет собой серийный интервал (si).\n\nsi &lt;- get_pairwise(epic, \"date_onset\")   \nsummary(si)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00    5.00    9.00   11.01   15.00   99.00    1820 \n\ntibble(si = si) %&gt;%\n  ggplot(aes(si)) +\n  geom_histogram() +\n  labs(\n    x = \"Serial interval\",\n    y = \"Frequency\"\n  )\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\nWarning: Removed 1820 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\nФункция get_pairwise() будет интерпретировать класс столбца, используемого для сравнения и соответствующим образом корректирует свой метод сравнения значений. Для чисел и дат (как в примере si выше), функция будет вычитать значения. При применении к столбцам, имеющим символы или категориальный характер, get_pairwise() будет соединять значения. Поскольку функция также допускает произвольную обработку (см. аргумент “f”), эти дискретные комбинации могут быть легко табулированы и проанализированы.\n\nhead(get_pairwise(epic, \"gender\"), n = 10)\n\n [1] \"f -&gt; m\" NA       \"m -&gt; m\" NA       \"m -&gt; f\" \"f -&gt; f\" NA       \"f -&gt; m\"\n [9] NA       \"m -&gt; f\"\n\nget_pairwise(epic, \"gender\", f = table)\n\n           values.to\nvalues.from   f   m\n          f 464 516\n          m 510 468\n\nfisher.test(get_pairwise(epic, \"gender\", f = table))\n\n\n    Fisher's Exact Test for Count Data\n\ndata:  get_pairwise(epic, \"gender\", f = table)\np-value = 0.03758\nalternative hypothesis: true odds ratio is not equal to 1\n95 percent confidence interval:\n 0.6882761 0.9892811\nsample estimates:\nodds ratio \n 0.8252575 \n\n\nЗдесь мы видим значительную связь между цепочками передачи и полом.\n\n\nОпределение кластеров\nФункция get_clusters() может быть использована для определения связанных компонентов в объекте epicontacts. Сначала с ее помощью мы получаем датафрейм data.frame. содержащий информацию о кластерах:\n\nclust &lt;- get_clusters(epic, output = \"data.frame\")\ntable(clust$cluster_size)\n\n\n   1    2    3    4    5    6    7    8    9   10   11   12   13   14 \n1536 1680 1182  784  545  342  308  208  171  100   99   24   26   42 \n\nggplot(clust, aes(cluster_size)) +\n  geom_bar() +\n  labs(\n    x = \"Cluster size\",\n    y = \"Frequency\"\n  )\n\n\n\n\n\n\n\n\nРассмотрим наиболее крупные кластеры. Для этого мы добавляем информацию о кластере в объект epicontacts, а затем выделим в нем только самые крупные кластеры:\n\nepic &lt;- get_clusters(epic)\nmax_size &lt;- max(epic$linelist$cluster_size)\nplot(subset(epic, cs = max_size))\n\n\n\n\n\n\n\nВычисление степени\nСтепень узла соответствует количеству его ребер или связей с другими узлами. get_degree() предоставляет простой метод вычисления этого значения для сети epicontacts. Высокая степень в данном контексте указывает на человека, который контактировал со многими другими людьми. Аргумент type указывает на то, что мы хотим считать как входящие, так и исходящие степени, аргумент only_linelist указывает на то, что мы хотим вычислить только степень для случаев в построчном списке.\n\ndeg_both &lt;- get_degree(epic, type = \"both\", only_linelist = TRUE)\n\nКакие люди имеют десять наибольших контактов?\n\nhead(sort(deg_both, decreasing = TRUE), 10)\n\n916d0a 858426 6833d7 f093ea 11f8ea 3a4372 38fc71 c8c4d5 a127a7 02d8fd \n     7      6      6      6      5      5      5      5      5      5 \n\n\nКаково среднее количество контактов?\n\nmean(deg_both)\n\n[1] 1.078473",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Цепочки передачи</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.ru.html#ресурсы",
    "href": "new_pages/transmission_chains.ru.html#ресурсы",
    "title": "37  Цепочки передачи",
    "section": "37.6 Ресурсы",
    "text": "37.6 Ресурсы\nСтраница epicontacts содержит обзор функций пакета и несколько более подробных виньеток.\nСтраница github может быть использована для поднятия проблем и запросов на добавление новых возможностей.",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Цепочки передачи</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.ru.html",
    "href": "new_pages/phylogenetic_trees.ru.html",
    "title": "38  Филогенетические деревья",
    "section": "",
    "text": "38.1 Обзор\nФилогенетические деревья используются для визуализации и описания родства и эволюции организмов на основе последовательности их генетического кода.\nОни могут быть построены на основе генетических последовательностей с использованием методов, основанных на расстоянии (например, метод соседних связей), или методов, основанных на признаках (например, метод максимального правдоподобия и байесовский метод Марковской цепи Монте-Карло). Секвенирование нового поколения (NGS) стало более доступным и все шире используется в здравоохранении для описания патогенов, вызывающих инфекционные заболевания. Портативные устройства для секвенирования сокращают время обработки данных и обещают сделать их доступными для поддержки расследования вспышек в режиме реального времени. Данные NGS могут быть использованы для идентификации происхождения или источника штамма возбудителя и его распространения, а также для определения наличия генов устойчивости к противомикробным препаратам. Для визуализации генетического родства между образцами строится филогенетическое дерево.\nНа этой странице мы научимся использовать пакет ggtree, который позволяет совмещать визуализацию филогенетических деревьев с дополнительными данными об образцах в виде датафрейма. Это позволит нам наблюдать закономерности и улучшить понимание динамики вспышек.",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Филогенетические деревья</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.ru.html#подготовка",
    "href": "new_pages/phylogenetic_trees.ru.html#подготовка",
    "title": "38  Филогенетические деревья",
    "section": "38.2 Подготовка",
    "text": "38.2 Подготовка\n\nЗагрузка пакетов\nВ этом фрагменте кода показана загрузка необходимых пакетов. В данном руководстве мы делаем акцент на функции p_load() из pacman, которая при необходимости устанавливает пакет и загружает его для использования. Установленные пакеты можно также загрузить с помощью library() из базового R. Более подробную информацию о пакетах R см. на странице Основы R.\n\npacman::p_load(\n  rio,             # импорт/экспорт\n  here,            # относительные пути к файлам\n  tidyverse,       # общее управление данными и их визуализация\n  ape,             # для импорта и экспорта филогенетических файлов\n  ggtree,          # для визуализации филогенетических файлов\n  treeio,          # для визуализации филогенетических файлов\n  ggnewscale)      # для добавления дополнительных слоев цветовых схем\n\n\n\nИмпорт данных\nДанные для этой страницы можно загрузить с помощью инструкций на странице Скачивание руководства и данных.\nСуществует несколько различных форматов хранения филогенетического дерева (например, Newick, NEXUS, Phylip). Общепринятым является формат файлов Newick (.nwk), который является стандартом представления деревьев в машиночитаемом виде. Это означает, что все дерево может быть выражено в строковом формате, например “((t2:0.04,t1:0.34):0.89,(t5:0.37,(t4:0.03,t3:0.67):0.9):0.59);”, в котором перечислены все узлы и вершины и их отношение (длина ветвей) друг к другу.\nПримечание: Важно понимать, что файл филогенетического дерева сам по себе не содержит данных о секвенировании, а является лишь результатом вычисления генетических расстояний между последовательностями. Поэтому мы не можем извлечь данные секвенирования из файла дерева.\nСначала с помощью функции read.tree() из пакета ape мы импортируем файл филогенетического дерева Newick в формате .txt и сохраняем его в списочном объекте класса “phylo”. При необходимости используйте функцию here() из пакета here для указания относительного пути к файлу.\nПримечание: В данном случае дерево newick сохраняется в виде файла .txt для удобства работы и загрузки с Github.\n\ntree &lt;- ape::read.tree(\"Shigella_tree.txt\")\n\nОсмотрев наш древовидный объект, мы видим, что он содержит 299 вершин (или образцов) и 236 узлов.\n\ntree\n\n\nPhylogenetic tree with 299 tips and 236 internal nodes.\n\nTip labels:\n  SRR5006072, SRR4192106, S18BD07865, S18BD00489, S17BD08906, S17BD05939, ...\nNode labels:\n  17, 29, 100, 67, 100, 100, ...\n\nRooted; includes branch lengths.\n\n\nВо-вторых, с помощью функции import() из пакета rio мы импортируем таблицу, сохраненную в файле .csv, с дополнительной информацией для каждого секвенированного образца, такой как пол, страна происхождения и атрибуты антимикробной резистентности:\n\nsample_data &lt;- import(\"sample_data_Shigella_tree.csv\")\n\nНиже приведены первые 50 строк данных:\n\n\n\n\n\n\n\n\nВычистка и проверка\nПроизведем вычистку и проверку данных: Для того чтобы правильно распределить данные образца по филогенетическому дереву, значения в столбце Sample_ID в датафрейме sample_data должны совпадать со значениями tip.labels в файле tree:\nМы проверяем форматирование tip.labels в файле tree, просматривая первые 6 записей с помощью head() из базового R.\n\nhead(tree$tip.label) \n\n[1] \"SRR5006072\" \"SRR4192106\" \"S18BD07865\" \"S18BD00489\" \"S17BD08906\"\n[6] \"S17BD05939\"\n\n\nУбедимся также, что первым столбцом в нашем датафрейме sample_data является Sample_ID. Посмотрим названия столбцов нашего датафрейма с помощью colnames() из базового R.\n\ncolnames(sample_data)   \n\n [1] \"Sample_ID\"                  \"serotype\"                  \n [3] \"Country\"                    \"Continent\"                 \n [5] \"Travel_history\"             \"Year\"                      \n [7] \"Belgium\"                    \"Source\"                    \n [9] \"Gender\"                     \"gyrA_mutations\"            \n[11] \"macrolide_resistance_genes\" \"MIC_AZM\"                   \n[13] \"MIC_CIP\"                   \n\n\nМы смотрим на Sample_IDs в датафрейме, чтобы убедиться, что форматирование такое же, как в tip.label (например, буквы все заглавные, нет лишних подчеркиваний _ между буквами и цифрами и т.д.).\n\nhead(sample_data$Sample_ID) # мы снова проверяем только первые 6 с помощью функции head()\n\n[1] \"S17BD05944\" \"S15BD07413\" \"S18BD07247\" \"S19BD07384\" \"S18BD07338\"\n[6] \"S18BD02657\"\n\n\nМы также можем сравнить, все ли образцы присутствуют в файле tree и наоборот, сгенерировав логический вектор TRUE или FALSE в тех случаях, когда они совпадают или не совпадают. Для простоты они здесь не выводятся.\n\nsample_data$Sample_ID %in% tree$tip.label\n\ntree$tip.label %in% sample_data$Sample_ID\n\nС помощью этих векторов мы можем показать все идентификаторы образцов, которых нет на дереве (их нет).\n\nsample_data$Sample_ID[!tree$tip.label %in% sample_data$Sample_ID]\n\ncharacter(0)\n\n\nПри осмотре видно, что формат Sample_ID в датафрейме соответствует формату названий образцов в tip.labels. Для их сопоставления не обязательно сортировать их в том же порядке.\nМы готовы к работе!",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Филогенетические деревья</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.ru.html#визуализация-простого-дерева",
    "href": "new_pages/phylogenetic_trees.ru.html#визуализация-простого-дерева",
    "title": "38  Филогенетические деревья",
    "section": "38.3 Визуализация простого дерева",
    "text": "38.3 Визуализация простого дерева\n\nРазличные варианты расположения деревьев\nggtree предлагает множество различных форматов расположения, и некоторые из них могут быть более подходящими для ваших конкретных целей, чем другие. Ниже приведены несколько демонстрационных вариантов. Другие варианты см. на странице онлайн книга.\nПриведем несколько примеров расположения деревьев:\n\nggtree(tree)                                            # простое линейное дерево\nggtree(tree,  branch.length = \"none\")                   # простое линейное дерево с выровненными вершинами\nggtree(tree, layout=\"circular\")                         # простое круговое дерево\nggtree(tree, layout=\"circular\", branch.length = \"none\") # простое круглое дерево с выровненными вершинами\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nПростое дерево плюс данные образца\nОператор %&lt;+% используется для подключения датафрейма sample_data к файлу tree. Наиболее простой аннотацией дерева является добавление названий образцов в вершинах, а также раскрашивание точек вершин и, при желании, ветвей:\nПриведем пример кругового дерева:\n\nggtree(tree, layout = \"circular\", branch.length = 'none') %&lt;+% sample_data + # %&lt;+% добавляет в дерево датафрейм с данными образца\n  aes(color = Belgium)+                       # раскрашивает ветви в соответствии с переменной в датафрейме\n  scale_color_manual(\n    name = \"Sample Origin\",                      # название вашей цветовой схемы (будет отображаться в легенде в таком виде)\n    breaks = c(\"Yes\", \"No\"),                     # различные варианты в вашей переменной\n    labels = c(\"NRCSS Belgium\", \"Other\"),        # название различных вариантов в легенде позволяет их форматировать \n    values = c(\"blue\", \"black\"),                  # цвет, который вы хотите присвоить переменной \n    na.value = \"black\") +                        # значения NA также окрашиваются в черный цвет\n  new_scale_color()+                             # позволяет добавить дополнительную цветовую схему для другой переменной\n    geom_tippoint(\n      mapping = aes(color = Continent),          # цвет вершины по континенту. Вы можете изменить форму, добавив \"shape = \"\n      size = 1.5)+                               # определить размер точки в вершине\n  scale_color_brewer(\n    name = \"Continent\",                    # название вашей цветовой схемы (будет отображаться в легенде в таком виде)\n    palette = \"Set1\",                      # выбираем набор цветов, входящих в комплект пакета brewer\n    na.value = \"grey\") +                    # для значений NA выбираем серый цвет\n  geom_tiplab(                             # добавляет название образца к вершине его ветви \n    color = 'black',                       # (добавьте столько текстовых строк, сколько хотите, с помощью + , но может потребоваться корректировка значения смещения, чтобы расположить их рядом друг с другом)\n    offset = 1,\n    size = 1,\n    geom = \"text\",\n    align = TRUE)+    \n  ggtitle(\"Phylogenetic tree of Shigella sonnei\")+       # название графика\n  theme(\n    axis.title.x = element_blank(), # удаляет заголовок оси x\n    axis.title.y = element_blank(), # удаляет заголовок оси y\n    legend.title = element_text(    # определяет размер и формат шрифта заголовка легенды\n      face = \"bold\",\n      size = 12),   \n    legend.text=element_text(       # определяет размер и формат шрифта текста легенды\n      face = \"bold\",\n      size = 10),  \n    plot.title = element_text(      # определяет размер и формат шрифта заголовка графика\n      size = 12,\n      face = \"bold\"),  \n    legend.position = \"bottom\",     # определяет расположение легенды\n    legend.box = \"vertical\",        # определяет расположение легенды\n    legend.margin = margin())   \n\n\n\n\n\n\n\n\nВы можете экспортировать свой древовидный график с помощью функции ggsave(), как и любой другой объект ggplot. В этом случае ggsave() сохраняет последнее полученное изображение в файл по указанному вами пути. Помните, что вы можете использовать here() и относительные пути к файлам, чтобы легко сохранять изображения во вложенных папках и т.д.\n\nggsave(\"example_tree_circular_1.png\", width = 12, height = 14)",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Филогенетические деревья</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.ru.html#работа-с-деревьями",
    "href": "new_pages/phylogenetic_trees.ru.html#работа-с-деревьями",
    "title": "38  Филогенетические деревья",
    "section": "38.4 Работа с деревьями",
    "text": "38.4 Работа с деревьями\nИногда у вас может быть очень большое филогенетическое дерево, а вас интересует только одна его часть. Например, если вы составили дерево, включающее исторические или международные образцы, чтобы получить общее представление о том, как ваш набор данных может вписаться в общую картину. Но затем, чтобы более детально изучить свои данные, вы хотите просмотреть только эту часть большого дерева.\nПоскольку файл филогенетического дерева является лишь результатом анализа данных секвенирования, мы не можем манипулировать порядком расположения узлов и ветвей в самом файле. Они уже были определены в ходе предыдущего анализа из исходных данных NGS. Однако мы можем увеличивать, скрывать и даже создавать подмножества частей дерева.\n\nУвеличить масштаб\nЕсли вы не хотите “резать” дерево, а только внимательно изучить его часть, то можно увеличить масштаб для просмотра конкретной части.\nСначала мы построим график всего дерева в линейном формате и добавим числовые метки к каждому узлу дерева.\n\np &lt;- ggtree(tree,) %&lt;+% sample_data +\n  geom_tiplab(size = 1.5) +                # ставит метки на верхушки всех ветвей с названием образца в файле дерева\n  geom_text2(\n    mapping = aes(subset = !isTip,\n                  label = node),\n    size = 5,\n    color = \"darkred\",\n    hjust = 1,\n    vjust = 1)                            # ставит метки на все узлы дерева\n\np  # печать\n\n\n\n\n\n\n\n\nЧтобы приблизить конкретную ветвь (уходящую вправо), используйте viewClade() для объекта ggtree p и задайте номер узла, чтобы посмотреть поближе:\n\nviewClade(p, node = 452)\n\n\n\n\n\n\n\n\n\n\nСвернуть ветви\nОднако мы можем проигнорировать эту ветвь и свернуть ее в том же узле (узел № 452) с помощью collapse(). Это дерево определяется как p_collapsed.\n\np_collapsed &lt;- collapse(p, node = 452)\np_collapsed\n\n\n\n\n\n\n\n\nДля наглядности при выводе p_collapsed мы добавляем geom_point2() (синий ромб) в узел свернутой ветви.\n\np_collapsed + \ngeom_point2(aes(subset = (node == 452)),  # мы присваиваем символ свернутому узлу\n            size = 5,                     # определить размер символа\n            shape = 23,                   # определить форму символа\n            fill = \"steelblue\")           # определить цвет символа\n\n\n\n\n\n\n\n\n\n\nПодмножество дерева\nЕсли мы хотим сделать более постоянное изменение и создать новое, уменьшенное дерево для работы, то мы можем создать подмножество его части с помощью tree_subset(). Затем его можно сохранить как новый файл дерева newick или файл .txt.\nСначала мы просматриваем узлы дерева и метки вершин, чтобы решить, какую часть дерева нужно подмножить.\n\nggtree(\n  tree,\n  branch.length = 'none',\n  layout = 'circular') %&lt;+% sample_data +               # добавляем данные  образца с помощью оператора %&lt;+%\n  geom_tiplab(size = 1)+                                # пометить верхушки всех ветвей названием образца в файле дерева\n  geom_text2(\n    mapping = aes(subset = !isTip, label = node),\n    size = 3,\n    color = \"darkred\") +                                # помечает все узлы дерева\n theme(\n   legend.position = \"none\",                            # удаляет легенду полностью\n   axis.title.x = element_blank(),\n   axis.title.y = element_blank(),\n   plot.title = element_text(size = 12, face=\"bold\"))\n\n\n\n\n\n\n\n\nТеперь, допустим, мы решили сделать подмножество дерева в узле 528 (сохранить только вершины в этой ветви после узла 528) и сохраняем его как новый объект sub_tree1:\n\nsub_tree1 &lt;- tree_subset(\n  tree,\n  node = 528)                                            # мы создаем подмножество дерева в узле 528\n\nРассмотрим подмножество дерева 1:\n\nggtree(sub_tree1) +\n  geom_tiplab(size = 3) +\n  ggtitle(\"Subset tree 1\")\n\n\n\n\n\n\n\n\nВы также можете создать подмножество на основе одного конкретного образца, указав, сколько “предыдущих” узлов вы хотите включить. Давайте выполним подмножество той же части дерева на основе образца, в данном случае S17BD07692, вернувшись на 9 узлов назад, и сохраним его как новый объект sub_tree2:\n\nsub_tree2 &lt;- tree_subset(\n  tree,\n  \"S17BD07692\",\n  levels_back = 9) # Количество уровней назад определяет, на сколько узлов назад от вершины образца вы хотите вернуться\n\nРассмотрим подмножество дерева 2:\n\nggtree(sub_tree2) +\n  geom_tiplab(size =3)  +\n  ggtitle(\"Subset tree 2\")\n\n\n\n\n\n\n\n\nВы также можете сохранить свое новое дерево либо в виде типа Newick, либо в виде текстового файла с помощью функции write.tree() из пакета ape:\n\n# для сохранения в формате .nwk\nape::write.tree(sub_tree2, file='data/phylo/Shigella_subtree_2.nwk')\n\n# для сохранения в формате .txt\nape::write.tree(sub_tree2, file='data/phylo/Shigella_subtree_2.txt')\n\n\n\nПоворот узлов в дереве\nКак уже говорилось, мы не можем изменить порядок расположения вершин или узлов в дереве, поскольку это основано на их генетическом родстве и не поддается визуальным манипуляциям. Но мы можем завернуть ветви вокруг узлов, если это облегчит нам визуализацию.\nСначала мы построим наше новое дерево подмножеств 2 с метками узлов, чтобы выбрать узел, с которым мы хотим работать, и сохранить его в объекте ggtree plot p.\n\np &lt;- ggtree(sub_tree2) +  \n  geom_tiplab(size = 4) +\n  geom_text2(aes(subset=!isTip, label=node), # ставит метки на все узлы дерева\n             size = 5,\n             color = \"darkred\", \n             hjust = 1, \n             vjust = 1) \np\n\n\n\n\n\n\n\n\nЗатем мы можем управлять узлами, применяя ggtree::rotate() или ggtree::flip(): Примечание: чтобы проиллюстрировать, с какими узлами мы работаем, сначала применим функцию geom_hilight() из ggtree для выделения образцов в интересующих нас узлах и сохраним этот объект ggtree plot в новом объекте p1.\n\np1 &lt;- p + geom_hilight(  # Выделяет узел 39 синим цветом, \"extend =\" позволяет определить длину цветового блока\n  node = 39,\n  fill = \"steelblue\",\n  extend = 0.0017) +  \ngeom_hilight(            # выделяет узел 37 желтым цветом\n  node = 37,\n  fill = \"yellow\",\n  extend = 0.0017) +               \nggtitle(\"Original tree\")\n\n\np1 # печать\n\n\n\n\n\n\n\n\nТеперь мы можем повернуть узел 37 в объекте p1 так, чтобы образцы на узле 38 переместились в верхнюю часть. Повернутое дерево мы сохраняем в новом объекте p2.\n\np2 &lt;- ggtree::rotate(p1, 37) + \n      ggtitle(\"Rotated Node 37\")\n\n\np2   # печать\n\n\n\n\n\n\n\n\nИли мы можем использовать команду flip для поворота узла 36 в объекте p1 и переключения узла 37 в верхнюю часть, а узла 39 - в нижнюю. Перевернутое дерево мы сохраняем в новом объекте p3.\n\np3 &lt;-  flip(p1, 39, 37) +\n      ggtitle(\"Rotated Node 36\")\n\n\np3   # печать\n\n\n\n\n\n\n\n\n\n\nПример поддерева с аннотацией к образцу данных\nДопустим, мы исследуем кластер случаев с клональным размножением, произошедших в 2017 и 2018 годах в узле 39 нашего поддерева. Мы добавляем год выделения штамма, а также историю поездок и цвет по странам, чтобы увидеть происхождение других близкородственных штаммов:\n\nggtree(sub_tree2) %&lt;+% sample_data +     # мы используем оператор %&lt;+% для ссылки на sample_data\n  geom_tiplab(                          # ставит метки на верхушках всех ветвей с названием образца в файле дерева\n    size = 2.5,\n    offset = 0.001,\n    align = TRUE) + \n  theme_tree2()+\n  xlim(0, 0.015)+                       # задать границы оси x нашего дерева\n  geom_tippoint(aes(color=Country),     # окрасить точку вершины в цвет континента\n                size = 1.5)+ \n  scale_color_brewer(\n    name = \"Country\", \n    palette = \"Set1\", \n    na.value = \"grey\")+\n  geom_tiplab(                          # добавить год выделения в качестве текстовой метки на вершинах\n    aes(label = Year),\n    color = 'blue',\n    offset = 0.0045,\n    size = 3,\n    linetype = \"blank\" ,\n    geom = \"text\",\n    align = TRUE)+ \n  geom_tiplab(                          # добавить историю путешествий в виде текстовой надписи в вершинах, выделить красным цветом\n    aes(label = Travel_history),\n    color = 'red',\n    offset = 0.006,\n    size = 3,\n    linetype = \"blank\",\n    geom = \"text\",\n    align = TRUE)+ \n  ggtitle(\"Phylogenetic tree of Belgian S. sonnei strains with travel history\")+  # добавить название графика\n  xlab(\"genetic distance (0.001 = 4 nucleotides difference)\")+                    # добавить метку на ось x \n  theme(\n    axis.title.x = element_text(size = 10),\n    axis.title.y = element_blank(),\n    legend.title = element_text(face = \"bold\", size = 12),\n    legend.text = element_text(face = \"bold\", size = 10),\n    plot.title = element_text(size = 12, face = \"bold\"))\n\n\n\n\n\n\n\n\nНаши наблюдения указывают на завоз штаммов из Азии, которые затем в течение многих лет циркулировали в Бельгии и, по-видимому, стали причиной нашей последней вспышки.",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Филогенетические деревья</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.ru.html#более-сложные-деревья-добавление-тепловых-карт-данных-образца",
    "href": "new_pages/phylogenetic_trees.ru.html#более-сложные-деревья-добавление-тепловых-карт-данных-образца",
    "title": "38  Филогенетические деревья",
    "section": "Более сложные деревья: добавление тепловых карт данных образца",
    "text": "Более сложные деревья: добавление тепловых карт данных образца\nМы можем добавить более сложную информацию, например, категориальное присутствие генов устойчивости к противомикробным препаратам и числовые значения фактически измеренной устойчивости к противомикробным препаратам в виде тепловой карты, используя функцию ggtree::gheatmap().\nСначала нам необходимо построить график нашего дерева (он может быть как линейным, так и круговым) и сохранить его в новом объекте ggtree plot p: Мы будем использовать поддерево из части 3).\n\np &lt;- ggtree(sub_tree2, branch.length='none', layout='circular') %&lt;+% sample_data +\n  geom_tiplab(size =3) + \n theme(\n   legend.position = \"none\",\n    axis.title.x = element_blank(),\n    axis.title.y = element_blank(),\n    plot.title = element_text(\n      size = 12,\n      face = \"bold\",\n      hjust = 0.5,\n      vjust = -15))\np\n\n\n\n\n\n\n\n\nВо-вторых, мы подготавливаем данные. Чтобы визуализировать различные переменные с помощью новых цветовых схем, мы подставляем в наш датафрейм нужную переменную. Важно добавить Sample_ID в названия строк, иначе не удастся сопоставить данные с деревом tip.labels:\nВ нашем примере мы хотим рассмотреть пол и мутации, которые могут вызвать устойчивость к ципрофлоксацину, важному антибиотику первой линии, используемому для лечения инфекций Шигеллы.\nМы создаем датафрейм для пола:\n\ngender &lt;- data.frame(\"gender\" = sample_data[,c(\"Gender\")])\nrownames(gender) &lt;- sample_data$Sample_ID\n\nМы создаем датафрейм для мутаций в гене gyrA, которые обуславливают устойчивость к ципрофлоксацину:\n\ncipR &lt;- data.frame(\"cipR\" = sample_data[,c(\"gyrA_mutations\")])\nrownames(cipR) &lt;- sample_data$Sample_ID\n\nМы создаем датафрейм для измеренной минимальной ингибирующей концентрации (МИК) ципрофлоксацина, полученной из лаборатории:\n\nMIC_Cip &lt;- data.frame(\"mic_cip\" = sample_data[,c(\"MIC_CIP\")])\nrownames(MIC_Cip) &lt;- sample_data$Sample_ID\n\nМы создаем первый график, добавляя к филогенетическому дереву бинарную тепловую карту для пола и сохраняя ее в новом объекте ggtree plot h1:\n\nh1 &lt;-  gheatmap(p, gender,                                 # мы добавляем слой тепловой карты датафрейма \"Пол\" на наш древовидный график\n                offset = 10,                               # смещение сдвигает тепловую карту вправо,\n                width = 0.10,                              # ширина определяет ширину столбца тепловой карты,\n                color = NULL,                              # цвет определяет границы столбцов тепловой карты\n         colnames = FALSE) +                               # скрывает названия столбцов тепловой карты\n  scale_fill_manual(name = \"Gender\",                       # определить цветовую схему и легенду для пола\n                    values = c(\"#00d1b1\", \"purple\"),\n                    breaks = c(\"Male\", \"Female\"),\n                    labels = c(\"Male\", \"Female\")) +\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\nh1\n\n\n\n\n\n\n\n\nЗатем мы добавляем информацию о мутациях в гене gyrA, которые обуславливают устойчивость к ципрофлоксацину:\nПримечание: наличие хромосомных точечных мутаций в данных WGS было предварительно определено с помощью инструмента PointFinder, разработанного Занкари и др. (см. ссылку в разделе “Дополнительная литература”).\nСначала мы присваиваем новую цветовую схему существующему объекту графика h1 и сохраняем ее в новом объекте h2. Это позволит нам определять и изменять цвета для второй переменной на тепловой карте.\n\nh2 &lt;- h1 + new_scale_fill() \n\nЗатем мы добавляем второй слой тепловой карты к h2 и сохраняем объединенные графики в новом объекте h3:\n\nh3 &lt;- gheatmap(h2, cipR,         # добавлена вторая строка тепловой карты, описывающая мутации устойчивости к ципрофлоксацину\n               offset = 12, \n               width = 0.10, \n               colnames = FALSE) +\n  scale_fill_manual(name = \"Ciprofloxacin resistance \\n conferring mutation\",\n                    values = c(\"#fe9698\",\"#ea0c92\"),\n                    breaks = c( \"gyrA D87Y\", \"gyrA S83L\"),\n                    labels = c( \"gyrA d87y\", \"gyrA s83l\")) +\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())+\n  guides(fill = guide_legend(nrow = 2,byrow = TRUE))\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\nh3\n\n\n\n\n\n\n\n\nМы повторяем описанный выше процесс, сначала добавляя новый слой цветовой шкалы к существующему объекту h3, а затем добавляя непрерывные данные о минимальной ингибирующей концентрации (МИК) ципрофлоксацина для каждого штамма к полученному объекту h4, чтобы получить конечный объект h5:\n\n# Сначала мы добавляем новую цветовую схему:\nh4 &lt;- h3 + new_scale_fill()\n\n# затем мы объединяем их в новый график:\nh5 &lt;- gheatmap(h4, MIC_Cip,  \n               offset = 14, \n               width = 0.10,\n                colnames = FALSE)+\n  scale_fill_continuous(name = \"MIC for Ciprofloxacin\",  # здесь мы определяем градиентную цветовую схему для непрерывной переменной МИК\n                      low = \"yellow\", high = \"red\",\n                      breaks = c(0, 0.50, 1.00),\n                      na.value = \"white\") +\n   guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\nh5\n\n\n\n\n\n\n\n\nАналогичное упражнение мы можем проделать и для линейного дерева:\n\np &lt;- ggtree(sub_tree2) %&lt;+% sample_data +\n  geom_tiplab(size = 3) + # подписывает кончики\n  theme_tree2()+\n  xlab(\"genetic distance (0.001 = 4 nucleotides difference)\")+\n  xlim(0, 0.015)+\n theme(legend.position = \"none\",\n      axis.title.y = element_blank(),\n      plot.title = element_text(size = 12, \n                                face = \"bold\",\n                                hjust = 0.5,\n                                vjust = -15))\np\n\n\n\n\n\n\n\n\nСначала мы добавляем пол:\n\nh1 &lt;-  gheatmap(p, gender, \n                offset = 0.003,\n                width = 0.1, \n                color=\"black\", \n         colnames = FALSE)+\n  scale_fill_manual(name = \"Gender\",\n                    values = c(\"#00d1b1\", \"purple\"),\n                    breaks = c(\"Male\", \"Female\"),\n                    labels = c(\"Male\", \"Female\"))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\nh1\n\n\n\n\n\n\n\n\nЗатем мы добавляем мутации устойчивости к ципрофлоксацину после добавления еще одного слоя цветовой схемы:\n\nh2 &lt;- h1 + new_scale_fill()\nh3 &lt;- gheatmap(h2, cipR,   \n               offset = 0.004, \n               width = 0.1,\n               color = \"black\",\n                colnames = FALSE)+\n  scale_fill_manual(name = \"Ciprofloxacin resistance \\n conferring mutation\",\n                    values = c(\"#fe9698\",\"#ea0c92\"),\n                    breaks = c( \"gyrA D87Y\", \"gyrA S83L\"),\n                    labels = c( \"gyrA d87y\", \"gyrA s83l\"))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())+\n  guides(fill = guide_legend(nrow = 2,byrow = TRUE))\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\n h3\n\n\n\n\n\n\n\n\nЗатем добавляем минимальную ингибирующую концентрацию, определенную лабораторией (МИК):\n\nh4 &lt;- h3 + new_scale_fill()\nh5 &lt;- gheatmap(h4, MIC_Cip, \n               offset = 0.005,  \n               width = 0.1,\n               color = \"black\", \n                colnames = FALSE)+\n  scale_fill_continuous(name = \"MIC for Ciprofloxacin\",\n                      low = \"yellow\", high = \"red\",\n                      breaks = c(0,0.50,1.00),\n                      na.value = \"white\")+\n   guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 10),\n        legend.text = element_text(size = 8),\n        legend.box = \"horizontal\", legend.margin = margin())+\n  guides(shape = guide_legend(override.aes = list(size = 2)))\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\nh5",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Филогенетические деревья</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.ru.html#ресурсы",
    "href": "new_pages/phylogenetic_trees.ru.html#ресурсы",
    "title": "38  Филогенетические деревья",
    "section": "38.5 Ресурсы",
    "text": "38.5 Ресурсы\nhttp://hydrodictyon.eeb.uconn.edu/eebedia/index.php/Ggtree# Clade_Colors https://bioconductor.riken.jp/packages/3.2/bioc/vignettes/ggtree/inst/doc/treeManipulation.html https://guangchuangyu.github.io/ggtree-book/chapter-ggtree.html https://bioconductor.riken.jp/packages/3.8/bioc/vignettes/ggtree/inst/doc/treeManipulation.html\nEa Занкари, Роза Аллесё, Катрин Г Йонсен, Лина М Кавако, Оле Лунд, Франк М Аареструп, PointFinder: новый веб-инструмент для выявления на основе WGS устойчивости к противомикробным препаратам, связанной с хромосомными точечными мутациями у бактериальных патогенов, Journal of Antimicrobial Chemotherapy, Volume 72, Issue 10, October 2017, Pages 2764-2768, https://doi.org/10.1093/jac/dkx217",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Филогенетические деревья</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.ru.html",
    "href": "new_pages/interactive_plots.ru.html",
    "title": "39  Интерактивные графики",
    "section": "",
    "text": "39.1 Подготовка",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Интерактивные графики</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.ru.html#подготовка",
    "href": "new_pages/interactive_plots.ru.html#подготовка",
    "title": "39  Интерактивные графики",
    "section": "",
    "text": "Загрузка пакетов\nВ этом фрагменте кода показана загрузка пакетов, необходимых для проведения анализа. В данном руководстве мы делаем акцент на функции p_load() из pacman, которая при необходимости устанавливает пакет и загружает его для использования. Установленные пакеты можно также загрузить с помощью library() из базового R. Более подробную информацию о пакетах R см. на странице [Основы R].\n\npacman::p_load(\n  rio,       # импорт/экспорт\n  here,      # пути к файлам\n  lubridate, # работа с датами\n  plotly,    # интерактивные графики\n  scales,    # быстрые проценты\n  tidyverse  # управление данными и их визуализация\n  ) \n\n\n\nНачните с ggplot()\nНа этой странице мы предполагаем, что вы начинаете с графика ggplot(), который вы хотите преобразовать в интерактивный. На этой странице мы построим несколько таких графиков, используя случай построчного списка, используемый на многих страницах данного руководства.\n\n\nИмпорт данных\nДля начала мы импортируем построчный список случаев из смоделированной эпидемии лихорадки Эбола. Если вы хотите выполнять действия параллельно, нажмите кнопку, чтобы загрузить “чистый” построчный список (в виде файла .rds). Импортируйте данные с помощью функции import() из пакета rio (она работает со многими типами файлов, такими как .xlsx, .csv, .rds - подробности см. на странице [Импорт и экспорт]).\n\n# импорт построчного списка  \nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nНиже отображаются первые 50 строк построчного списка.",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Интерактивные графики</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.ru.html#построение-графика-с-ggplotly",
    "href": "new_pages/interactive_plots.ru.html#построение-графика-с-ggplotly",
    "title": "39  Интерактивные графики",
    "section": "39.2 построение графика с ggplotly()",
    "text": "39.2 построение графика с ggplotly()\nФункция ggplotly() из пакета plotly позволяет легко преобразовать ggplot() в интерактивный формат. Просто сохраните свой ggplot(), а затем передайте его функции ggplotly().\nНиже мы построим простую линию, отражающую долю смертей в течение недели:\nНачнем с создания сводного набора данных по каждой эпидемиологической неделе и проценту известных случаев смерти.\n\nweekly_deaths &lt;- linelist %&gt;%\n  group_by(epiweek = floor_date(date_onset, \"week\")) %&gt;%  # создание и группировка данных по столбцу эпинедели\n  summarise(                                              # создание новый сводный датафрейм:\n    n_known_outcome = sum(!is.na(outcome), na.rm=T),      # количество случаев в группе с известным исходом\n    n_death  = sum(outcome == \"Death\", na.rm=T),          # количество случаев смерти в каждой группе\n    pct_death = 100*(n_death / n_known_outcome)           # процент случаев с известным исходом, умерших\n  )\n\nЗдесь представлены первые 50 строк набора данных weekly_deaths.\n\n\n\n\n\n\nЗатем строим график с помощью ggplot2, используя geom_line().\n\ndeaths_plot &lt;- ggplot(data = weekly_deaths)+            # начать с данных о смертности за неделю\n  geom_line(mapping = aes(x = epiweek, y = pct_death))  # построить линию \n\ndeaths_plot   # печать\n\n\n\n\n\n\n\n\nМы можем сделать этот график интерактивным, просто передав его в ggplotly(), как показано ниже. При наведении курсора мыши на линию отображаются значения x и y. График можно увеличить и перетащить. Кроме того, в правом верхнем углу графика можно увидеть значки. По порядку они позволяют:\n\nЗагрузить текущий вид в виде изображения PNG.\n\nУвеличить масштаб с помощью окна выбора\n\n” Панорамировать” или перемещаться по графику, щелкая и перетаскивая его.\n\nУвеличить, уменьшить масштаб или вернуться к масштабу по умолчанию\n\nСбросить оси к значениям по умолчанию\n\nВключить/выключить “линии всплесков”, которые представляют собой пунктирные линии от интерактивной точки, распространяющиеся на оси x и y.\n\nНастроить отображение данных при отсутствии наведения курсора на линию\n\n\ndeaths_plot %&gt;% plotly::ggplotly()\n\n\n\n\n\nСгруппированные данные можно использовать и с помощью ggplotly(). Ниже построена недельная эпидкривая, сгруппированная по исходам. Сложенные столбики являются интерактивными. Попробуйте щелкнуть на различных элементах в легенде (они будут появляться/исчезать).\n\n# Построить эпидемическую кривую с пакетом incidence2\np &lt;- incidence2::incidence(\n  linelist,\n  date_index = date_onset,\n  interval = \"weeks\",\n  groups = outcome) %&gt;% plot(fill = outcome)\n\n\n# Построить интерактивные графики  \np %&gt;% plotly::ggplotly()",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Интерактивные графики</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.ru.html#изменения",
    "href": "new_pages/interactive_plots.ru.html#изменения",
    "title": "39  Интерактивные графики",
    "section": "39.3 Изменения",
    "text": "39.3 Изменения\n\nРазмер файла\nПри экспорте HTML, сгенерированного в R Markdown (как в этом случае!), вы хотите сделать график как можно меньше по размеру данных (в большинстве случаев без негативных побочных эффектов). Для этого достаточно передать интерактивный график в partial_bundle(), также из plotly.\n\np &lt;- p %&gt;% \n  plotly::ggplotly() %&gt;%\n  plotly::partial_bundle()\n\n\n\nКнопки\nНекоторые кнопки стандартного plotly являются лишними и могут отвлекать внимание, поэтому их можно удалить. Для этого достаточно передать результат по каналу в config() из plotly и указать, какие кнопки необходимо удалить. В приведенном ниже примере мы заранее задаем названия удаляемых кнопок и указываем их в аргументе modeBarButtonsToRemove =. Мы также задаем displaylogo = FALSE, чтобы удалить логотип plotly.\n\n## Эти кнопки отвлекают внимание, поэтому мы хотим их убрать\nplotly_buttons_remove &lt;- list('zoom2d','pan2d','lasso2d', 'select2d','zoomIn2d',\n                              'zoomOut2d','autoScale2d','hoverClosestCartesian',\n                              'toggleSpikelines','hoverCompareCartesian')\n\np &lt;- p %&gt;%          # Повторное построение интерактивного графика без этих кнопок\n  plotly::config(displaylogo = FALSE, modeBarButtonsToRemove = plotly_buttons_remove)",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Интерактивные графики</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.ru.html#тепловые-плитки",
    "href": "new_pages/interactive_plots.ru.html#тепловые-плитки",
    "title": "39  Интерактивные графики",
    "section": "39.4 Тепловые плитки",
    "text": "39.4 Тепловые плитки\nПрактически любой график ggplot() можно сделать интерактивным, в том числе и тепловые графики. На странице [Тепловые графики] вы можете прочитать о том, как сделать приведенный ниже график, который отображает долю дней в неделю, когда определенные учреждения предоставляли данные в свою провинцию.\nПриведем код, хотя подробно описывать его здесь не будем.\n\n# импорт данных\nfacility_count_data &lt;- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\"))\n\n# агрегирование данных в \"Недели\" для района Spring\nagg_weeks &lt;- facility_count_data %&gt;% \n  filter(District == \"Spring\",\n         data_date &lt; as.Date(\"2020-08-01\")) %&gt;% \n  mutate(week = aweek::date2week(\n    data_date,\n    start_date = \"Monday\",\n    floor_day = TRUE,\n    factor = TRUE)) %&gt;% \n  group_by(location_name, week, .drop = F) %&gt;%\n  summarise(\n    n_days          = 7,\n    n_reports       = n(),\n    malaria_tot     = sum(malaria_tot, na.rm = T),\n    n_days_reported = length(unique(data_date)),\n    p_days_reported = round(100*(n_days_reported / n_days))) %&gt;% \n  ungroup(location_name, week) %&gt;% \n  right_join(tidyr::expand(., week, location_name)) %&gt;% \n  mutate(week = aweek::week2date(week))\n\n# создать график\nmetrics_plot &lt;- ggplot(agg_weeks,\n       aes(x = week,\n           y = location_name,\n           fill = p_days_reported))+\n  geom_tile(colour=\"white\")+\n  scale_fill_gradient(low = \"orange\", high = \"darkgreen\", na.value = \"grey80\")+\n  scale_x_date(expand = c(0,0),\n               date_breaks = \"2 weeks\",\n               date_labels = \"%d\\n%b\")+\n  theme_minimal()+ \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1,\"cm\"),\n    legend.key.width  = grid::unit(0.6,\"cm\"),\n    axis.text.x = element_text(size=12),\n    axis.text.y = element_text(vjust=0.2),\n    axis.ticks = element_line(size=0.4),\n    axis.title = element_text(size=12, face=\"bold\"),\n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),\n    plot.caption = element_text(hjust = 0, face = \"italic\")\n    )+\n  labs(x = \"Week\",\n       y = \"Facility name\",\n       fill = \"Reporting\\nperformance (%)\",\n       title = \"Percent of days per week that facility reported data\",\n       subtitle = \"District health facilities, April-May 2019\",\n       caption = \"7-day weeks beginning on Mondays.\")\n\nmetrics_plot # печать\n\n\n\n\n\n\n\n\nНиже мы сделаем его интерактивным и модифицируем для простых кнопок и размера файла.\n\nmetrics_plot %&gt;% \n  plotly::ggplotly() %&gt;% \n  plotly::partial_bundle() %&gt;% \n  plotly::config(displaylogo = FALSE, modeBarButtonsToRemove = plotly_buttons_remove)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n.  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n–&gt;",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Интерактивные графики</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.ru.html#ресурсы",
    "href": "new_pages/interactive_plots.ru.html#ресурсы",
    "title": "39  Интерактивные графики",
    "section": "39.5 Ресурсы",
    "text": "39.5 Ресурсы\nPlotly предназначен не только для R, но также хорошо работает с Python (и вообще с любым языком науки о данных, поскольку построен на JavaScript). Подробнее об этом можно прочитать на сайте plotly",
    "crumbs": [
      "Визуализация данных",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Интерактивные графики</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.ru.html",
    "href": "new_pages/rmarkdown.ru.html",
    "title": "40  Отчеты с помощью R Markdown",
    "section": "",
    "text": "40.1 Подготовка\nОбщая информация по R Markdown\nОбъясним некоторые необходимые концепции и пакеты:\nВ целом, процесс, который осуществляется фоново (вам не нужно знать все эти шаги!) включает в себя передачу файла .Rmd в knitr, который выполняет фрагменты кода и создает новый файл .md (markdown), который включает в себя код R и выводимые данные. Файл .md затем обрабатывается в pandoc, чтобы создать итоговый продукт: документ Microsoft Word, файл HTML, документ powerpoint, pdf, и т.п.\n(источник: https://rmarkdown.rstudio.com/authoring_quick_tour.html):\nУстановка\nЧтобы создать выходной продукт в R Markdown, вам нужно установить следующее:\npacman::p_load(tinytex)     # устанавливаем пакет tinytex\ntinytex::install_tinytex()  # команда R для установки программы TinyTeX",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Отчеты с помощью R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.ru.html#подготовка",
    "href": "new_pages/rmarkdown.ru.html#подготовка",
    "title": "40  Отчеты с помощью R Markdown",
    "section": "",
    "text": "Markdown - это “язык”, который позволяет вам писать документ, используя простой текст, который можно конвертировать в html и другие форматы. Он не специфичен для R. Файлы, записанные с помощью разметки Markdown имеют расширение ‘.md’.\nR Markdown: это вариант markdown, который специфичен для R - он позволяет вам писать документ, используя разметку, чтобы создать текст и интегрировать код R и отображать его выходные данные. Файлы R Markdown имеют расширение ‘.Rmd’.\n\nrmarkdown - пакет: Он используется R, чтобы превратить файл .Rmd в желаемые выходные данные. Его фокус заключается в конвертации синтаксиса разметки (текста), поэтому нам нужны еще…\nknitr: Этот пакет R прочитает фрагменты кода, выполнит их и “свяжет” их с документом. Так можно включить таблицы и графики рядом с текстом.\nPandoc: Наконец, pandoc собственно конвертирует выходные данные в word/pdf/powerpoint и т.п. Это также отдельная от R программа, но она устанавливается автоматически вместе с RStudio.\n\n\n\n\n\n\n\nПакет rmarkdown (knitr также установится автоматически)\n\nPandoc, который должен был установиться вместе с RStudio. Если вы не используете RStudio, вы можете скачать Pandoc тут: http://pandoc.org.\nЕсли вы хотите сгенерировать выходной продукт в формате PDF (это чуть сложнее), вам нужно будет установить LaTeX. Для пользователей R Markdown, которые не устанавливали LaTeX ранее, мы рекомендуем установить TinyTeX (https://yihui.name/tinytex/). Вы можете использовать следующие команды:",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Отчеты с помощью R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.ru.html#начало-работы",
    "href": "new_pages/rmarkdown.ru.html#начало-работы",
    "title": "40  Отчеты с помощью R Markdown",
    "section": "40.2 Начало работы",
    "text": "40.2 Начало работы\n\nУстановка пакета rmarkdown R\nУстановите пакет R rmarkdown. В этом руководстве мы подчеркиваем использование p_load() из pacman, которая устанавливает пакет, если необходимо, и загружает его для использования. Вы можете также загрузить установленные пакеты с помощью library() из базового R. См. страницу Основы R для получения дополнительной информации о пакетах R.\n\npacman::p_load(rmarkdown)\n\n\n\nСоздание нового файла Rmd\nВ RStudio откройте новый файл R markdown, начав с ‘File’ (файл), затем ‘New file’ (новый файл), затем ‘R markdown…’.\n\n\n\n\n\n\n\n\n\nR Studio даст вам некоторые опции выходных данных на выбор. В примере ниже мы выбираем “HTML”, поскольку мы хотим создать документ html. Заголовок и имена авторов не столь важны. Если в этих опциях нет того типа выходного документа, который вам нужен, не волнуйтесь - вы можете выбрать любой вариант и потом изменить его в скрипте.\n\n\n\n\n\n\n\n\n\nЭто позволит открыть новый скрипт .Rmd.\n\n\nВажно знать\nРабочая директория\nРабочая директория файла markdown - то, где сохраняется сам файл Rmd. Например, если R проект находится внутри ~/Documents/projectX, а сам файл Rmd - в подпапке ~/Documents/projectX/markdownfiles/markdown.Rmd, код read.csv(“data.csv”) внутри файла markdown будет искать csv файл в папке markdownfiles, а не в корневой папке проекта, где обычно осуществляют поиск скрипты в рамках проектов.\nЧтобы сослаться на файлы в ином расположении, вам нужно либо использовать полный путь к файлу, либо пакет here. Пакет here задает рабочую директорию в корневой папкет проекта R, что детально объясняется на страницах Проекты R и Импорт и экспорт. Например, чтобы импортировать файл под названием “data.csv” из папки projectX, код будет выглядеть так: import(here(“data.csv”)).\nОбратите внимание, что в скриптах R Markdown не рекомендуется использовать setwd() – она будет применяться только к фрагменту кода, в котором она записана.\nРабота на сетевых дисках или на компьютере\nПоскольку R Markdown может столкнуться с проблемами pandoc при работе с общего сетевого диска, рекомендуется, чтобы ваша папка была на локальной машине, то есьт в проекте в папке “Мои документы”. Если вы используте Git (очень рекомендуется!), это будет вам знакомо. Для получения дополнительной информации см. страницы R на сетевых дисках и Ошибки и справка.",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Отчеты с помощью R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.ru.html#компоненты-r-markdown",
    "href": "new_pages/rmarkdown.ru.html#компоненты-r-markdown",
    "title": "40  Отчеты с помощью R Markdown",
    "section": "40.3 Компоненты R Markdown",
    "text": "40.3 Компоненты R Markdown\nДокумент R Markdown можно редактировать в RStudio как и стандартный скрипт R. Когда вы начинаете новый скрипт R Markdown, RStudio попробует помочь, показав шаблон, который объясняет разные разделы скрипта R Markdown.\nНиже вы видите то окно, которое появляется, когда вы начинаете новый скрипт Rmd, с помощью которого хотите создать выходной продукт в html (как мы определили в предыдущем разделе).\n\n\n\n\n\n\n\n\n\nКак вы можете видеть, существует три основных компонента файла Rmd: YAML, текст Markdown, и фрагменты кода R\nОни создадут и станут вашим выходным документом. См. схему ниже:\n\n\n\n\n\n\n\n\n\n\nМетаданные YAML\nИх называют ‘метаданные YAML’ или просто ‘YAML’, находятся в верхней части документа R Markdown. Этот раздел скрипта укажет вашему файлу Rmd, какого типа выходной результат создать, предпочтения в форматировании, а также другие метаданные, например, название документа, автор и дата. Существуют и другие способы применения, не упомянутые здесь (но на них есть отсылка в ‘Подготовка выходных результатов’). Обратите внимание, что важны отступы; tab не допускается, а пробелы - можно.\nЭтот раздел должен начинаться со строчки, содержащей три дефиса --- и должен закрываться строкой, содержащей три дефиса ---. Параметры YAML указываются в парах key:value. Размещение двоеточий в YAML очень важно - пары key:value разделяются двоеточиями (не знаки равно!).\nYAML должны начинаться с метаданных для документа. Порядок этих первичных параметров YAML (без отступов) не важен. Например:\ntitle: \"My document\"\nauthor: \"Me\"\ndate: \"2024-05-10\"\nВы можете использовать код R в значениях YAML, написав его как in-line code (в начале r внутри обратных одинарных кавычек), но также в кавычках (см. пример выше в строке date:).\nНа изображении выще, поскольку мы кликнули, что выходным результатом по умолчанию будет файл html, мы можем увидеть, что в YAML написано output: html_document. Однако мы также можем изменить этот пункт на powerpoint_presentation, word_document или даже pdf_document.\n\n\nТекст\nЭто текстовая часть вашего документа, включая заголовки и подзаголовки. Она записана языком разметки “markdown”, который используется в разных программах.\nНиже приведены основные способы написания текста. См. более подробную документацию в “шпаргалке” по R Markdown на веб-сайте RStudio.\n\nНовые строки\nУникально для R Markdown, чтобы начать новую строку, введите *два пробела** в конце предыдущей строки, затем нажмите Enter/Return.\n\n\nРегистр\nПоставьте вокруг текста следующие знаки, чтобы изменить его отображение.\n\nНижние подчеркивания (_text_) или одна звездочка (*text*) для курсива\nДвойная звездочка (**текст**) для жирного текста\nОбратные одинарные кавычки (text) для отображения текста как кода\n\nСобственно вид шрифта можно установить, использовав конкретные шаблоны (задаются в метаданных YAML; см. примеры).\n\n\nЦвет\nНе существует простого механизма изменения цвета текста в R Markdown. Как вариант, ЕСЛИ вы на выходе получаете файл HTML, то можно добавить строку HTML в текст markdown. HTML код ниже напечатает строку текста жирным красным шрифтом.\n&lt;span style=\"color: red;\"&gt;**_ВНИМАНИЕ:_** Это предупреждение.&lt;/span&gt;  \nВНИМАНИЕ: Это предупреждение.\n\n\nЗаголовки и подзаголовки\nСимвол решетки в текстовой части скрипта R Markdown создает заголовок. Это отличается от фрагментов кода R в скрипте, где решетка используется для комментария/аннотации/де-активации.\nРазные уровни заголовка создаются с помощью разного количества символов решетки в начале новой строки. Один знак решетки - основной заголовок. Два знака решетки - заголовок второго уровня. Заголовки третьего и четвертого уровня можно создать с помощью увеличения количества знаков решетки.\n# Заголовок первого уровня\n\n## Заголовок второго уровня  \n\n### Заголовок третьего уровня\n\n\nМаркированные списки\nИспользуйте звездочки (*), чтобы создать маркированные списки. Завершите предыдущее предложение, введите два пробела, дважды нажмите Enter/Return, затем начинайте маркированный список. Включите пробел между звездочкой и текстом этого пункта списка. После каждого пункта списка введите два пробела, затем нажмите Enter/Return. Подпункты маркированного списка работают так же, но с отступом. Числа работают также, но вместо звездочки, пишите 1), 2), и т.п. Ниже пример того, как может выглядеть текст скрипта R Markdown.\nВот мой маркированный список (после этого двоеточия два пробела):  \n\n* Пункт 1 (после него два пробела и Enter/Return)  \n* Пункт 2 (после него два пробела и Enter/Return)  \n  * Подпункт 1 (после него два пробела и Enter/Return)  \n  * Подпункт 2 (после него два пробела и Enter/Return)  \n  \n\n\nВыделение текста в комментарий\nВы можете выделить текст R Markdown в комментарий также как вы используете “#”, чтобы выделить строку кода R во фрагменте кода R в комментарий. Просто выделите текст и нажмите Ctrl+Shift+c (Cmd+Shift+c для Mac). Текст будет окружен стрелками и станет зеленым. Его не будет видно в выходном результате.\n\n\n\n\n\n\n\n\n\n\n\n\nФрагменты кода\nРазделы скрипта, которые посвящены выполнению кода R, называют “фрагментами кода”. Здесь вы загружаете пакеты, импортируете данные и проводите уперавление данными и визуализацию. У вас может быть много фрагментов кода, они помогают вам организовать свой код R по частям, между которыми может быть текст. Необходимо отметить: Эти ‘фрагменты’ будут иметь чуть другой цвет фона по сравнению с текстовой частью документа.\nКаждый фрагмент начинается со строки с тремя обратными одинарными кавычками и фигурными скобками, которые содержат параметры для фрагмента ({ }). Фрагмент оканчивается еще тремя обратными одинарными кавычками.\nВы можете создать новый фрагмент, напечатав его самостоятельно, используя горячие клавиши “Ctrl + Alt + i” (или Cmd + Shift + r в Mac), либо кликную зеленую иконку ‘insert a new code chunk’ (вставить новый фрагмент кода) в верхней части редактора скрипта.\nНекоторые комментарии по содержимому фигурных скобок { }:\n\nОни начинаются с ‘r’, чтобы указать, что название используемого во фрагменте языка - R\nПосле r опционально вы можете написать “имя” фрагмента – оно не является обязательным, но может помочь организовать вашу работу. Обратите внимание, что если вы задаете имена фрагментам, вы должны ВСЕГДА использовать уникальные имена, иначе при обработке R будет выдавать предупреждения.\n\nФигурные скобки могут включать другие опции, записанные как tag=value, например:\n\neval = FALSE не выполнять код R\n\necho = FALSE не печатать исходный код фрагмента R в выходном документе\n\nwarning = FALSE не печатать предупреждения, выдаваемые кодом R\n\nmessage = FALSE не печатать сообщения, созданные кодом R\n\ninclude = TRUE/FALSE (ПРАВДА или ЛОЖЬ), включать ли выходные данные фрагмента (например, графики) в документе\nout.width = и out.height = - задает стиль out.width = \"75%\"\n\nfig.align = \"center\" корректирует, как рисунок выровнен на странице\n\nfig.show='hold', если ваш фрагмент печатает несколько рисунков и вы их хотите напечатать рядом друг с другом (вместе с out.width = c(\"33%\", \"67%\"). Можно также задать как fig.show='asis', чтобы показать их под тем кодом, который их генерирует, 'hide' чтобы спрятать, либо 'animate' для объединения нескольких в анимацию.\n\nзаголовок фрагмента должен быть записан в одну строку\n\nСтарайтесь избегать точек, нижних подчеркиваний и пробелов. Используйте вместо этого дефисы ( - ), если вам нужен разделитель.\n\nБолее детально об опциях knitr можно прочитать тут.\nНекоторые вышеуказанные опции можно задать по принципу “наведи и кликни”, используя кнопки настройки в верхней правой части фрагмента. Здесь вы можете уточнить, какие части фрагмента вы хотите включить в готовый документ, в частности, код, выходные данные и предупреждения. Это будет выглядеть как записанные предпочтения внутри фигурных скобок, например, echo=FALSE, если вы хотите уточнить, что надо ‘показыватьт только выходной результат’.\n\n\n\n\n\n\n\n\n\nТакже в верхней части каждого фрагмента есть две стрелки, которые полезны, чтобы выполнить код внутри фрагмента, либо весь код в предыдущих фрагментах. Наведите на них, чтобы увидеть, что они делают.\nЧтобы применить глобальные опции ко всем фрагментам скрипта, вы можете это задать в самом первом фрагменте кода R. Например, чтобы только выходные данные были показаны для каждого фрагмента кода, а не сам код, вы можете включить следующую команду во фрагмент кода R:\n\nknitr::opts_chunk$set(echo = FALSE) \n\n\nКод R внутри текста\nВы также можете включить минимальный код R внутри обратных одинарных кавычек. Внутри одинарных обратных кавычек начните код с “r” и пробела, чтобы RStudio знал, что нужно оценивать код как код R. См. пример ниже.\nПример ниже показывает несколько уровней заголовков, маркированный список и использует код R для текущей даты (Sys.Date()), чтобы превратить ее в печатную дату.\n\n\n\n\n\n\n\n\n\nПриведенный пример является простым (отображение текущей даты), но с помощью того же синтаксиса можно отобразить значения, созданные более сложным кодом R (например, вычислить минимум, медиану, максимум для столбца). Также можно интегрировать в сценарий R-объекты или значения, созданные ранее в фрагментах R-кода.\nВ качестве примера скрипт ниже показывает долю случаев в возрасте младше 18 лет, используя функции tidyverse, и создает объекты less18, total, и less18prop. Это динамическое значение вставляется в последующий текст. Посмотрим, как это выглядит при связывании в документ word.\n\n\n\n\n\n\n\n\n\n\n\n\nРисунки\nВы можете включить рисунки в R Markdown одним из двух способов:\n\n![](\"path/to/image.png\")  \n\nЕсли указанный выше способ не работает, попробуйте использовать knitr::include_graphics()\n\nknitr::include_graphics(\"path/to/image.png\")\n\n(помните, путь к файлу можно записать, используя пакет here)\n\nknitr::include_graphics(here::here(\"path\", \"to\", \"image.png\"))\n\n\n\nТаблицы\nСоздавайте таблицы, используя дефисы ( - ) и вертикальные черточки ( | ). Количество дефисов до/между столбцами создает количество пробелов в ячейке до того, как начнется оборачивание текста.\nСтолбец 1 |Столбец  2 |Столбец 3\n----------|-----------|--------\nЯчейка A  |Ячейка B   |Ячейка C\nЯчейка D  |Ячейка E   |Ячейка F\nУказанный выше код создаст ту таблицу, которую вы видите ниже:\n\n\n\nСтолбец 1\nСтолбец 2\nСтолбец 3\n\n\n\n\nЯчейка A\nЯчейка B\nЯчейка C\n\n\nЯчейка D\nЯчейка E\nЯчейка F\n\n\n\n\n\nразделы по вкладкам\nДля результатов в виде HTML, вы можете организовать разделы по “вкладкам”. Просто добавьте .tabset в фигурные скобки { }, которые размещаются после заголовка. Любые подзаголовки под этим заголовком (до появления другого заголовка того же уровня) будут отображаться как вкладки, между которыми пользователей может переключаться. Дополнительную информацию читайте тут\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nВы можете добавить дополнительную опцию .tabset-pills после .tabset, чтобы у вкладок был “комбинированный” вид. Помните, что при рассмотрении выходных результатов в HTML с вкладками, функция поиска Ctrl+f будет искать только по “активной” вкладке, а не по скрытым вкладкам.",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Отчеты с помощью R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.ru.html#структура-файла",
    "href": "new_pages/rmarkdown.ru.html#структура-файла",
    "title": "40  Отчеты с помощью R Markdown",
    "section": "40.4 Структура файла",
    "text": "40.4 Структура файла\nСуществует несколько способов структурировать ваш R Markdown и связанные с ним скрипты R. У каждого есть свои преимущества и недостатки:\n\nАвтономный R Markdown - все, что нужно для отчета, импортируется или создается внутри R Markdown\n\nПолучение данных из других файлов - Вы можете выполнить внешние скрипты R с помощью команды source() и использовать их выходные результаты в Rmd\n\nДочерние скрипты - альтернативный механизм для source()\n\n\nИспользовать “файл выполнения” - Выполнять команды в скрипте R до построения R\n\n\nАвтономный Rmd\nДля относительно простого отчета вы можете организовать свой скрипт R Markdown таким образом, чтобы он был “автономным” и не требовал других внешних скриптов.\nВсе, что необходимо для выполнения R Markdown, импортируется или создается в Rmd-файле, включая все фрагменты кода и загрузку пакетов. Такой “автономный” подход уместен, когда не требуется большой обработки данных (например, приводится чистый или полу-чистый файл данных) и формирование R Markdown не займет много времени.\nВ этом сценарии логичной организацией скрипта R Markdown может быть следующей:\n\nЗадаются глобальные опции knitr\n\nЗагрузка пакет\n\nИмпорт данных\n\nОбработка данных\n\nПодготовка выходных данных (таблицы, графики и т.п.)\n\nСохранение выходных данных, если нужно(.csv, .png, и т.п.)\n\n\nПолучение данных из других файлов\nОдним из вариантов “автономного” подхода является использование фрагментов кода R Markdown в качестве “источника” (выполнения) других скриптов R. Это может сделать ваш сценарий R Markdown менее загроможденным, более простым и удобным для организации. Это также может помочь, если необходимо вывести итоговые цифры в начале отчета. При таком подходе конечный скрипт R Markdown просто объединяет предварительно обработанные результаты в документ.\nОдин из способов это сделать - задать скрипты R (путь к файлу и имя с разрешением) в команду базового R source().\n\nsource(\"your-script.R\", local = knitr::knit_global())\n# или sys.source(\"your-script.R\", envir = knitr::knit_global())\n\nОбратите внимание, что при использовании source() внутри R Markdown, внешние файлы будут все еще выполняться в ходе формирования файла Rmd. Следовательно, каждый скрипт выполняется каждый раз, когда вы формируете отчет. Таким образом, наличие команд source() внутри R Markdown не ускоряет время выполнения, и не особо помогает с дебаггингом, так как созданные ошибки все еще будут напечатаны при подготовке R Markdown.\nАльтернативой является использование опции child = knitr. НЕОХОДИМО ОБЪЯСНИТЬ ПОДРОБНЕЕ\nВы должны знать о разных средах R. Объекты, созданные внутри среды, не обязательно будут доступны для среды R Markdown.\n\n\n\nФайл выполнения\nЭтот подход требует использования скрипта R, который содержит команду(ы) render() для предварительной обработки объектов, которые передаются в R markdown.\nНапример, вы можете загрузить пакеты, загрузить и вычистить данные и даже создать интересующие графики до функции render(). Эти шаги могут выполняться как в скрипте R, так и в других скриптах. Если эти команды выполняются в одной и той же сессии RStudio, а объекты сохраняются в среде, то их можно вызывать в содержимом Rmd. Тогда сам R markdown будет использоваться только на последнем этапе - для создания выходных данных со всеми предварительно обработанными объектами. Так гораздо проще отладить работу, если что-то пойдет не так.\nЭтот подход полезен по следующим причинам:\n\nБолее информативные сообщения об ошибках - эти сообщения будут сгенерированы в скрипте R, а не в R Markdown. Ошибки R Markdown, как правило, сообщают, в каком фрагменте кода есть проблема, но не говорят - в какой строке.\n\nЕсли применимо, вы можете выполнить длинные шаги обработки до использования команды render() - они будут выполнены только один раз.\n\nВ примере ниже мы отделили скрипт R, в котором мы предварительно обрабатываем объект data в среде R (Environment) и затем сформируем “create_output.Rmd”, используя render().\n\ndata &lt;- import(\"datafile.csv\") %&gt;%       # Загружаем данные и сохраняем в рабочую среду\n  select(age, hospital, weight)          # выбираем ограниченное количество столбцов\n\nrmarkdown::render(input = \"create_output.Rmd\")   # Создаем файл Rmd\n\n\n\nСтруктура папок\nРабочий поток также учитывает общую структуру папок, например, нужна папка ‘output’ для созданных документов и рисунков, папки ‘data’ или ‘inputs’ для вычищенных данных. Здесь мы не будем углубляться в детали, но проверьте страницу Структурирование рутинных отчетов.",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Отчеты с помощью R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.ru.html#создание-документа",
    "href": "new_pages/rmarkdown.ru.html#создание-документа",
    "title": "40  Отчеты с помощью R Markdown",
    "section": "40.5 Создание документа",
    "text": "40.5 Создание документа\nВы можете создать документ следующим образом:\n\nВручную, нажав кнопку “Knit” наверху редактора скриптов RStudio (быстро и легко)\n\nВыполнить команду render() (выполняется за пределами скрипта R Markdown)\n\n\nВариант 1: кнопка “Knit”\nКогда у вас открыт файл Rmd, нажмите иконку/кнопку ‘Knit’ наверху файла.\nR Studio покажет прогресс во вкладке ‘R Markdown’ возле консоли R. Документ автоматически откроется после завершения выполнения.\nДокумент будет сохранен в той же папке, что и ваш скрипт R markdown, и с тем же именем файла (кроме расширения). Это, конечно, не идеально для контроля версий (он будет перезаписываться каждый раз при формировании, если вы не переместите его вручную), поскольку вам, возможно, потребуется переименовывать файл самостоятельно (например, добавлять дату).\nЭто “горячая кнопка” RStudio для функции render() из rmarkdown. Этот подход совместим только с автономным R markdown, где существуют все необходимые компоненты, либо они могут быть запрошены в рамках файла.\n\n\n\n\n\n\n\n\n\n\n\nВариант 2: команда render()\nЕще один способ создать выходные данные R Markdown - выполнить функцию render() (из пакета rmarkdown). Вы должны исполнить эту команду за пределами скрипта R Markdown - либо в отдельном R script (часто называется “файл выполнения”), либо как отдельную команду в консоли R.\n\nrmarkdown::render(input = \"my_report.Rmd\")\n\nКак и с “knit”, настройки по умолчанию сохранят выходной результат в ту же папку, что скрипт Rmd, с тем же именем файла (кроме расширения файла). Например, “my_report.Rmd” при формировании создаст “my_report.docx”, если вы его формируете как документ word. Однако используя render() у вас есть опция использования разных настроек. render() может принимать аргументы, включая:\n\noutput_format = Это формат выходных данных для конвертации в (например, \"html_document\", \"pdf_document\", \"word_document\", либо \"all\"). Вы можете также указать это в YAML внутри скрипта R Markdown.\n\noutput_file = Это название выходного файла (и путь к файлу). Его можно создать через такие функции R, как here() или str_glue() как показано ниже.\n\noutput_dir = Это выходная директория (папка) для сохранения файла. Это позволяет вам выбрать другую альтернативу, кроме директории, в которую сохраняется файл Rmd.\n\noutput_options = Вы можете задать список опций, которые будут превалировать над теми, которые записаны в YAML скрипта (например, )\noutput_yaml = Вы можете задать путь к файлу .yml, который содержит спецификации YAML\n\nparams = См. раздел по параметрам ниже\n\nСм. полный список тут\n\nВ качестве одного примера, чтобы улучшить контроль версий, следующая команда сохранит выходной файл в подпапке ‘outputs’ с текущей датой в имени файла. Чтобы создать имя файла, используется функция str_glue() из пакета stringr, которая ‘склеивает’ статические последовательности (написанные простым текстом) с динамическим кодом R (записанным в фигурных скобках). Например, если сегодня 10 апреля 2021, имя файла ниже будет “Report_2021-04-10.docx”. См. дополнительную информацию по str_glue() на странице Текст и последовательности.\n\nrmarkdown::render(\n  input = \"create_output.Rmd\",\n  output_file = stringr::str_glue(\"outputs/Report_{Sys.Date()}.docx\")) \n\nПо мере того как файл формируется, на консоли RStudio будет показан прогресс формирвоания до 100%, а в итоговом сообщении будет написано, что формирование завершено.\n\n\nВариант 3: пакет reportfactory\nПакет R reportfactory предлагает альтернативный метод организации и формирования отчетов R Markdown, адаптированный для ситуаций, когда вам надо регулярно повторять формирование отчета (например, ежедневно, еженедельно…). Он облегчает формирование нескольких файлов R Markdown и организацию их выходных данных. По сути, он создает “фабрику”, из которой вы можете выполнить отчеты R Markdown, получить папки для выходных данных с автоматическими метками даты и времени, а также “легко” контролировать версии.\nБолее подробно о данном потоке работ читайте на странице Структурирование рутинных отчетов.",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Отчеты с помощью R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.ru.html#параметризированные-отчеты",
    "href": "new_pages/rmarkdown.ru.html#параметризированные-отчеты",
    "title": "40  Отчеты с помощью R Markdown",
    "section": "40.6 Параметризированные отчеты",
    "text": "40.6 Параметризированные отчеты\nВы можете использовать параметризацию, чтобы сделать отчеты динамичными, чтобы их можно было выполнять с конкретными настройками (например, с конкретной датой или местом, либо с определенными вариантами формирования). Ниже мы фокусируемся на основных моментах, но имеется детальная информация онлайн о параметризированных отчетах.\nИспользуя построчный список по Эболе в качестве примера, представим, что нам нужно выдавать стандартный отчет по эпиднадзору для каждой больницы каждый день. Мы покажем, как это можно сделать с использованием параметров.\nВажно: динамические отчеты также возможны без официальной структуры параметров (без params:), используя простые объекты R в соседнем скрипте R. Это объясняется в конце данного раздела.\n\nУстановка параметров\nУ вас есть несколько вариантов уточнения значений параметров для выходных результатов R Markdown.\n\nВариант 1: Задать параметры внутри YAML\nРедактируйте YAML, чтобы включить опцию params:, с утверждениями с отступом для каждого параметра, который вы хотите определить. В этом примере мы создаем параметры date (дата) и hospital (больница), для которых мы задаем значения. Эти значения будут меняться каждый раз, когда выполняется отчет. Если вы используете кнопку “Knit” для создания выходного результата, у параметров будут значения по умолчанию. Аналогично, если вы используете render(), у параметров будут эти значения по умолчанию, если в команде render() не указано иное.\n---\ntitle: Surveillance report\noutput: html_document\nparams:\n date: 2021-04-10\n hospital: Central Hospital\n---\nФоново значения этих параметров содержатся в списке только для чтения под названием params. Таким образом, вы можете вставить значения параметров в код R как вы это делаете с другим объектом/значением R в своей рабочей среде. Просто напечатайте params$, после чего укажите имя параметра. Например, params$hospital для представления названия больницы (“Central Hospital” по умолчанию).\nОбратите внимание, что параметры могут также содержать значения true (истина) или false (ложь), поэтому они могут быть включены в ваши опции knitr для фрагмента R. Например, вы можете задать {r, eval=params$run} вместо {r, eval=FALSE}, и теперь то, будет ли выполняться фрагмент будет зависеть от значения параметра run:.\nОбратите внимание, что параметры, которые являются датами, будут введены как последовательность. Например, чтобы params$date интерпретировался в коде R, его скорее всего нужно обернуть в as.Date() либо аналогичную функцию, чтобы конвертировать в класс Дата.\n\n\nВариант 2: задать параметры внутри render()\nКак было указано выше, альтернативой использованию кнопки “Knit” для создания выходных результатов является выполнение функции render() из отдельного скрипта. В последнем случае вы можете уточнить параметры, которые должны использоваться при формировании, в аргументе params = в render().\nОбратите внимание, что любые значения параметров, заданные тут, будут записаны поверх значений по умолчанию, если они записаны внутри YAML. Мы пишем значения в кавычках, так как в таком случае их следует определять как текстовые значения/последовательности.\nКоманда ниже формирует “surveillance_report.Rmd”, уточняет имя и папку для динамического файла-результата, а также задает список list() двух параметров и их значений в аргумент params =.\n\nrmarkdown::render(\n  input = \"surveillance_report.Rmd\",  \n  output_file = stringr::str_glue(\"outputs/Report_{Sys.Date()}.docx\"),\n  params = list(date = \"2021-04-10\", hospital  = \"Central Hospital\"))\n\n\n\nВариант 3: задать параметры, используя графический интерфейс пользователя\nДля большей интерактивности вы можете также использовать графический интерфейс пользователя, чтобы вручную установить значения параметров. Чтобы это сделать, мы можем кликнуть на выпадающее меню рядом с кнопкой ‘Knit’ и выбрать ‘Knit with parameters’.\nПоявится всплывающее окно, позволяющее вам впечатать значения для параметров, которые устанавливаются в YAML документа.\n\n\n\n\n\n\n\n\n\nВы можете добиться того же самого с помощью команды render(), указав params = \"ask\", как показано ниже.\n\nrmarkdown::render(\n  input = \"surveillance_report.Rmd\",  \n  output_file = stringr::str_glue(\"outputs/Report_{Sys.Date()}.docx\"),\n  params = “ask”)\n\nОднако при вводе значений в это всплывающее окно возможны ошибки и опечатки. Возможно, вы предпочтете добавить ограничения на значения, которые можно вводить через выпадающие меню. Это можно сделать, добавив в YAML несколько спецификаций для ввода каждого параметра params:.\n\nlabel: заголовок для конкретного выпадающего меню\n\nvalue: значение по умолчанию (стартовое)\n\ninput: установить select для выпадающего меню\n\nchoices: дать допустимые значения в выпадающем меню\n\nНиже эти спецификации записываются для параметра hospital.\n---\ntitle: Surveillance report\noutput: html_document\nparams:\n date: 2021-04-10\n hospital: \n  label: “Town:”\n  value: Central Hospital\n  input: select\n  choices: [Central Hospital, Military Hospital, Port Hospital, St. Mark's Maternity Hospital (SMMH)]\n---\nПри формировании (с помощью кнопки ‘knit with parameters’ или render()), во всплывающем окне будут выпадающие опции, из которых вы сможете выбрать.\n\n\n\n\n\n\n\n\n\n\n\n\nПараметризованный пример\nСледующий код создает параметры date (дата) и hospital (больница), которые используются в R Markdown как params$date и params$hospital, соответственно.\nПосмотрите, как в получившемся в результате выходоном отчете данные отфильтрованы до конкретной больницы, а заголовок графика относится к правильной больнице и дате. Мы используем здесь файл “linelist_cleaned.rds”, но было бы особенно хорошо, если в самом построчном списке также был бы штамп даты, чтобы сопоставить его с параметризованной датой.\n\n\n\n\n\n\n\n\n\nФормирование выдаст итоговый выходной результат со шрифтом и макетом по умолчанию.\n\n\n\n\n\n\n\n\n\n\n\nПараметризация без params\nЕсли вы формируете файл R Markdown с помощью render() из отдельного скрипта, вы можете создать действие параметризации без использования функционала params:.\nНапример, в скрипте R, который содержит команду render(), вы можете просто задать hospital и date как два объекта R (значения) до команды render(). В R Markdown вам не нужен раздел params: в YAML, и мы будем ссылаться на объект date, а не params$date, и hospital, а не params$hospital.\n\n# Это скрипт R, который сделан отдельно от R Markdown\n\n# определяем объекты R\nhospital &lt;- \"Central Hospital\"\ndate &lt;- \"2021-04-10\"\n\n# Формируем R markdown\nrmarkdown::render(input = \"create_output.Rmd\") \n\nЕсли вы следуете этому подходу, вы не сможете использовать “knit with parameters”, использовать графический интерфейс пользователя или включать опции формирования (knitting) внутри параметров. Однако это облегчит код, что может иметь свои преимущества.",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Отчеты с помощью R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.ru.html#зацикливаение-отчетов",
    "href": "new_pages/rmarkdown.ru.html#зацикливаение-отчетов",
    "title": "40  Отчеты с помощью R Markdown",
    "section": "40.7 Зацикливаение отчетов",
    "text": "40.7 Зацикливаение отчетов\nНам может потребоваться выполнить отчет несколько раз, варьируя входные параметры, чтобы создавать отчет для каждой юрисдикции/единицы. Это можно сделать с помощью инструментов итерации, которые детально изучаются на странице [Итерации, циклы и списки]. Опции включают пакет purrr, либо использования циклов for, как объясняется ниже.\nНиже мы используем простой цикл for для создания отчета по эпиднадзору для всех интересующих больниц. Это делается с помощью одной команды (вместо изменения параметров больницы по одной вручную). Команда по формированию отчетов должна существовать в отдельном скрипте вне отчета Rmd. Этот скрипт будет также содержать определенные объекты для “прохождения цикла” - сегодняшнюю дату, а также вектор названий больниц, по которым должны пройти циклы.\n\nhospitals &lt;- c(\"Central Hospital\",\n                \"Military Hospital\", \n                \"Port Hospital\",\n                \"St. Mark's Maternity Hospital (SMMH)\") \n\nМы задаем эти значения по одному в команду render(), используя цикл, который выполняет команду один раз для каждого значения в векторе hospitals. Буква i представляет индексную позицию (от 1 до 4) больницы, которая в настоящий момент используется в этой итерации, так чтобы hospital_list[1] стал “Central Hospital”. Эта информация предоставляется в двух местах в команде render():\n\nв имя файла, чтобы имя файла первой итерации, если он создается 10 апреля 2021 года, было “Report_Central Hospital_2021-04-10.docx”, сохранялось в подпапке ‘output’ рабочей директории.\n\nв params =, чтобы Rmd использовал имя больницы на внутреннем уровне, когда вызывается значение params$hospital (например, чтобы отфильтровать набор данных только до конкретных больниц). В этом примере создается 4 файла - по одному для каждой больницы.\n\n\nfor(i in 1:length(hospitals)){\n  rmarkdown::render(\n    input = \"surveillance_report.Rmd\",\n    output_file = str_glue(\"output/Report_{hospitals[i]}_{Sys.Date()}.docx\"),\n    params = list(hospital  = hospitals[i]))\n}",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Отчеты с помощью R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.ru.html#шаблоны",
    "href": "new_pages/rmarkdown.ru.html#шаблоны",
    "title": "40  Отчеты с помощью R Markdown",
    "section": "40.8 Шаблоны",
    "text": "40.8 Шаблоны\nИспользуя шаблонный документ, содержащий любое желаемое форматирование, можно настроить эстетику внешнего вида выходного Rmd-файла. Например, можно создать файл MS Word или Powerpoint, содержащий страницы/слайды с нужными размерами, водяными знаками, фоном и шрифтами.\n\nДокументы Word\nЧтобы создать шаблон, создаем новый документ word (или используем существующий выходной результат с подходящим форматированием) и редактируем шрифты, задав их в Стиле. В Стиле, заголовок 1, 2 и 3 относятся к разным уровням заголовков markdown (# Header 1, ## Header 2 и ### Header 3 соответственно). Правой кнопкой мыши кликните на стиль и кликните ‘изменить’, чтобы изменить форматирование шрифта и абзаца (например, вы можете ввести разрывы страниц перед определенным стилем, что поможет с наличием пространства). Другие аспекты документа word, такие как границы, размер страницы, заголовки и т.п. можно менять как в обычном документе word, в котором вы напрямую работаете.\n\n\n\n\n\n\n\n\n\n\n\nДокументы Powerpoint\nКак и выше, создаем новую презентацию или используем существующий файл powerpoint с нужным форматированием. Для дополнительного редактирования кликните на ‘Вид’ и ‘Образец слайдов’. Оттуда вы можете менять вид ‘мастер’ слайда, редактируя форматирование текста в текстовых полях, а также фон/размер страницы для всей страницы.\n\n\n\n\n\n\n\n\n\nК сожалению редактировать файлы powerpoint можно менее гибким образом:\n\nЗаголовок первого уровня (# Header 1) автоматически станет заголовком нового слайда,\nТекст ## Заголовка 2 не будет отображен как подзаголовок, а будет текстом внутри основного текстового поля слайда (если вы только не найдете способ манипуляции с образцом слайдов).\nПолученные выходные графики и таблицы автоматически перейдут на новые слайды. Вам нужно будет их объединять, например, с помощью функции patchwork по комбинированию ggplots, чтобы они отображались на одной странице. См. этот пост в блоге об использовании пакета patchwork для размещения нескольких картинок на одном слайде.\n\nСм. пакет officer, который является инструментом для более глубокой работы с презентациями powerpoint.\n\n\nИнтеграция шаблонов в YAML\nКак только шаблон подготовлен, его детали можно добавить в YAML в Rmd под строкой ‘output’ и под указанием типа документа (который сам переходит на отдельную строку). Обратите внимание, что для шаблонов слайдов powerpoint можно использовать reference_doc.\nПроще всего сохранить шаблон в той же папке, где находится файл Rmd (как в примере ниже), или внутри подпапки в ней.\n---\ntitle: Surveillance report\noutput: \n word_document:\n  reference_docx: \"template.docx\"\nparams:\n date: 2021-04-10\n hospital: Central Hospital\ntemplate:\n \n---\n\n\nФорматирование файлов HTML\nФайлы HTML не используют шаблоны, но могут содержать конфигурацию стилей внутри YAML. HTML - интерактивные документы, они особенно гибкие. Здесь мы разберем некоторые основные опции.\n\nОглавление: Мы можем добавить оглавление с помощью toc: true ниже, и также уточнить, что оно остается видимым (“плавает”), когда вы пролистываете, с помощью toc_float: true.\nТемы: Мы можем сослаться на некоторые предварительно разработанные темы, которые мы получаем из библиотеки тем Bootswatch. В примере ниже мы используем cerulean (синюю). Другие варианты включают: journal, flatly, darkly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex и yeti.\nВыделение: Эта конфигурация меняет вид выделенного текста (например, кода во фрагментах, которые показаны). Поддерживаемые стили включают default, tango, pygments, kate, monochrome, espresso, zenburn, haddock, breezedark, и textmate.\n\nВот пример того, как интегрировать указанные выше опции в YAML.\n---\ntitle: \"HTML example\"\noutput:\n  html_document:\n    toc: true\n    toc_float: true\n    theme: cerulean\n    highlight: kate\n    \n---\nНиже приведены два примера выходных результатов в HTML, у обоих из которых плавающее оглавление, но разные темы и стили выделения:",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Отчеты с помощью R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.ru.html#динамическое-содержимое",
    "href": "new_pages/rmarkdown.ru.html#динамическое-содержимое",
    "title": "40  Отчеты с помощью R Markdown",
    "section": "40.9 Динамическое содержимое",
    "text": "40.9 Динамическое содержимое\nВ выходном результате в формате HTML ваше содержимое отчета может быть динамичным. Ниже приведены некоторые примеры:\n\nТаблицы\nВ отчете в формате HTML вы можете печатать датафрейм/таблицы tibble таким образом, что содержимое будет динамическим с фильтрами и полосами прокрутки. Существует несколько пакетов, которые дают такие возможности.\nЧтобы это сделать с помощью пакета DT, как это сделано в данном руководстве, вы можете вставить фрагмент кода следующим образом:\n\n\n\n\n\n\n\n\n\nФункция datatable() напечатает заданный датафрейм как динамическую таблицу для читателя. Вы можете установить rownames = FALSE, чтобы упростить дальнюю левую сторону таблицы. filter = \"top\" создает фильтр над каждым столбцом. В аргументе option() задайте список других спецификаций. Ниже мы включаем две: pageLength = 5 устанавливает количество видимых строк на уровне 5 (остальные строки можно увидеть, перейдя по стрелкам на следующую страницу), а scrollX=TRUE активирует полосу прокрутки внизу таблицы (для столбцов, которые уходят вправо).\nЕсли у вас очень большой набор данных, рассмотрите возможность показать только топ X строк, обернув датафрейм в head().\n\n\nHTML виджеты\nВиджеты HTML для R - особый класс пакетов R, который позволяет увеличить интерактивность с помощью использования библиотек JavaScript. Вы можете их интегрировать в выходной HTML файл R Markdown.\nНекоторые частые примеры виджетов включают:\n\nPlotly (используется в данном руководстве на этой странице и странице Интерактивные графики)\nvisNetwork (используется на странице руководства Цепочки распространения)\n\nLeaflet (используется на странице руководства Основы ГИС)\n\ndygraphs (полезен для интерактивного отображения данных временных рядов)\n\nDT (datatable()) (используется, чтобы показать динамические таблицы с фильтром, сортировкой и т.п.)\n\nФункцию ggplotly() из plotly особенно легко использовать. См. страницу Интерактивные графики.",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Отчеты с помощью R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.ru.html#ресурсы",
    "href": "new_pages/rmarkdown.ru.html#ресурсы",
    "title": "40  Отчеты с помощью R Markdown",
    "section": "40.10 Ресурсы",
    "text": "40.10 Ресурсы\nДополнительная информация:\n\nhttps://bookdown.org/yihui/rmarkdown/\nhttps://rmarkdown.rstudio.com/articles_intro.html\n\nХорошее объяснение markdown в сравнении с knitr в сравнении с Rmarkdown есть тут: https://stackoverflow.com/questions/40563479/relationship-between-r-markdown-knitr-pandoc-and-bookdown",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Отчеты с помощью R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.ru.html",
    "href": "new_pages/reportfactory.ru.html",
    "title": "41  Структурирование рутинных отчетов",
    "section": "",
    "text": "41.1 Подготовка",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Структурирование рутинных отчетов</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.ru.html#подготовка",
    "href": "new_pages/reportfactory.ru.html#подготовка",
    "title": "41  Структурирование рутинных отчетов",
    "section": "",
    "text": "Загрузка пакетов\nВнутри RStudio установите последнюю версию пакета reportfactory с Github.\nВы это можете сделать с помощью пакета pacman с p_load_current_gh(), которая принудительно устанавливает самую последнюю версию с Github. Задайте текстовую цепочку “reconverse/reportfactory”, которая уточняет организацию Github (reconverse) и репозиторий (reportfactory). Вы можете также использовать install_github() из пакета remotes в качестве альтернативы.\n\n# Устанавливаем и загружаем самую последнюю версию пакета из Github\npacman::p_load_current_gh(\"reconverse/reportfactory\")\n#remotes::install_github(\"reconverse/reportfactory\") # альтернатива",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Структурирование рутинных отчетов</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.ru.html#новая-фабрика",
    "href": "new_pages/reportfactory.ru.html#новая-фабрика",
    "title": "41  Структурирование рутинных отчетов",
    "section": "41.2 Новая фабрика",
    "text": "41.2 Новая фабрика\nЧтобы создать новую фабрику, выполните функцию new_factory(). Это создаст новую автономную папку проекта R. По умолчанию:\n\nФабрика будет добавлена в вашу рабочую директорию\nИмя фактора проекта R будет называться “new_factory.Rproj”\n\nВаша сессия RStudio “перейдет” в этот проект R\n\n\n# Это создаст фабрику в рабочей директории\nnew_factory()\n\nЕсли вы посмотрите внутрь фабрики, вы можете увидеть, что подпапки и некоторые файлы были созданы автоматически.\n\n\n\n\n\n\n\n\n\n\nПапка report_sources будет содержать ваши скрипты, которые создают ваши отчеты\n\nПапка outputs будет содержать выходные данные отчета (например, HTML, Word, PDF, и т.п.)\n\nПапка scripts может быть использована для хранения других скриптов R (например, которые вызывают ваши скрипты Rmd)\n\nПапка data может быть использована для хранения ваших данных (включены подпапки “raw” (сырые) и “clean” (чистые))\n\nФайл .here, чтобы вы могли использовать пакет here, чтобы вызывать файлы из подпапок по отношению к этой корневой папке (см. детали на странице проекты R)\n\nФайл gitignore был создан, чтобы связать ваш проект R с репозиторием Github (см. Контроль версий и совместная работа с помощью Github)\n\nПустой файл README, если вы используете репозиторий Github\n\nВНИМАНИЕ: в зависимости от настроек вашего компьютера, могут существовать такие файлы как “.here”, но будут невидимыми.\nНиже представлены несколько настроек из настроек по умолчанию, которые вы, возможно, откорректируете внутри new_factory():\n\nfactory = - Задайте имя для папки фабрики (по умолчанию “new_factory”)\n\npath = - Укажите путь к файлу для новой фабрики (по умолчанию - рабочая директория)\n\nreport_sources = Задайте альтернативное имя для подпапки, в которой будут содержаться скрипты R Markdown (по умолчанию “report_sources”)\n\noutputs = Задайте альтернативное имя для папки, в которой содержатся выходные результаты отчетов (по умолчанию “outputs”)\n\nСм. ?new_factory, где вы можете найти полный список аргументов.\nКогда вы создаете новую фабрику, ваша сессия R переводится в новый проект R, поэтому нужно снова загрузить пакет reportfactory.\n\npacman::p_load(reportfactory)\n\nТеперь вы можете выполнить команду factory_overview(), чтобы увидеть внутреннюю структуру (все папки и файлы) фабрики.\n\nfactory_overview()            # печать обзора на консоли фабрики\n\nСледующее “дерево” папок и файлов фабрики печатается в консоли R. Обратите внимание, что в папке “data” есть подпапки для “сырых” и “чистых” данных, а также примеры CSV данных. Также есть файл “example_report.Rmd” в папке “report_sources”.",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Структурирование рутинных отчетов</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.ru.html#создание-отчета",
    "href": "new_pages/reportfactory.ru.html#создание-отчета",
    "title": "41  Структурирование рутинных отчетов",
    "section": "41.3 Создание отчета",
    "text": "41.3 Создание отчета\nИзнутри проекта фабрики R создайте отчет R Markdown, как вы это обычно делаете, и сохраните его в папку “report_sources”. См. страницу R Markdown для инструкций. В качестве примера мы добавили следующее к фабрике:\n\nНовый скрипт R markdown под названием “daily_sitrep.Rmd”, сохраненный в папку “report_sources”\n\nДанные для отчета (“linelist_cleaned.rds”), сохраненные в подпапку “clean” внутри папки “data”\n\nИспользуя factory_overview(), мы можем видеть наш R Markdown в папке “report_sources” и файл с данными в папке “clean” (чистые данные) (выделено):\n\n\n\n\n\n\n\n\n\nНиже вы видите снимок экрана начала R Markdown “daily_sitrep.Rmd”. Вы можете видеть, что формат выходных данных установлен как HTML, через заголовок YAML output: html_document.\n\n\n\n\n\n\n\n\n\nВ этом простом скрипте есть команды для:\n\nзагрузки нужных пакетов\n\nимпорта данных построчного списка, используя путь к файлу из пакета here (более детально читайте на странице [Импорт и экспорт])\n\n\nlinelist &lt;- import(here(\"data\", \"clean\", \"linelist_cleaned.rds\"))\n\n\nПечати суммарной таблицы случаев, экспорта с помощью export() в виде файла .csv\n\nПечати эпидкривой и ее экспорта с помощью ggsave() в виде файла .png\n\nВы можете изучить список отчетов R Markdown в папке “report_sources” с помощью следующей команды:\n\nlist_reports()",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Структурирование рутинных отчетов</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.ru.html#компиляция",
    "href": "new_pages/reportfactory.ru.html#компиляция",
    "title": "41  Структурирование рутинных отчетов",
    "section": "41.4 Компиляция",
    "text": "41.4 Компиляция\nВ фабрике отчетов, “компиляция” отчета R Markdown означает, что скрипт .Rmd будет выполнен и будет создан выходной результат (как указано в скриптах YAML, например, HTML, Word, PDF, и т.п.).\nФабрика автоматически создаст папку с меткой даты и времени для выходных результатов в папке “outputs”.\nВ этой папке будет сохранен сам отчет и все экспортированные файлы, созданные скриптом (например, csv, png, xlsx). Кроме того, в эту папку будет сохранен сам скрипт Rmd, так что у вас будет запись о данной версии скрипта.\nЭто отличается от обычного поведения R Markdown, сформированного с помощь “knit”, который сохраняет выходные данные в месте сохранения скрипта Rmd. Это поведение по умолчанию может привести к папке с большим количеством хаотично расположенных папок. Фабрика нацелена на улучшение организации, если вы часто повторяете отчеты.\n\nКомпиляция по имени\nВы можете компилировать конкретный отчет, выполнив compile_reports() и задав имя скрипта Rmd (без расширения .Rmd) в reports =. Для простоты вы можете пропустить reports = и просто написать имя R Markdown в кавычках, как ниже.\n\n\n\n\n\n\n\n\n\nЭта команда будет компилировать только отчет “daily_sitrep.Rmd”, сохраняя отчет HTML, а таблица .csv и эпидкривая .png экспортируется в подпапку с маркировкой даты и времени, конкретную для отчета, внутри папки “outputs”.\nОбратите внимание, что если вы решите задать расширение .Rmd, вам нужно правильно напечатать расширение, так как оно сохраняется в имени файла (.rmd vs. .Rmd).\nТакже обратите внимание, когда вы проводите компиляцию, вы можете увидеть, что несколько файлов временно появятся в папке “report_sources” - но они скоро исчезнут, так как они будут перенесены в правильную папку “outputs”.\n\n\nКомпиляция по номеру\nВы также можете указать скрипт Rmd для компиляции, указав номер или вектор номеров в reports =. Номера будут соответствовать порядку, в котором отчеты появляются, когда вы выполняете list_reports().\n\n# Компиляция второго и четвертого Rmd в папку \"report_sources\"\ncompile_reports(reports = c(2, 4))\n\n\n\nКомпилировать все\nВы можете компилировать все отчеты R Markdown в папке “report_sources”, установив аргумент reports = как TRUE (ИСТИНА).\n\n\n\n\n\n\n\n\n\n\n\nКомпилировать из подпапки\nВы можете добавить подпапки в папку “report_sources”. чтобы выполнить отчет R Markdown из подпапки, просто укажите имя папки в subfolder =. Ниже приведен пример кода для компиляции отчета Rmd, который находится в подпапке “report_sources”.\n\ncompile_reports(\n     reports = \"summary_for_partners.Rmd\",\n     subfolder = \"for_partners\")\n\nВы можете компилировать отчеты Rmd внутри подпапки, задав имя подпапки в reports =, со слэшем на конце, как показано ниже.\n\ncompile_reports(reports = \"for_partners/\")\n\n\n\nПараметризация\nКак указано на странице [Отчеты с помощью R Markdown], вы можете выполнить отчеты с указанными параметрами. Вы можете передать эти параметры как список в compile_reports() через аргумент params =. Например, в этом выдуманном отчете в отчеты R Markdown задается три параметра.\n\ncompile_reports(\n  reports = \"daily_sitrep.Rmd\",\n  params = list(most_recent_data = TRUE,\n                region = \"NORTHERN\",\n                rates_denominator = 10000),\n  subfolder = \"regional\"\n)\n\n\n\nИспользование “файла выполнения”\nЕсли вам надо выполнить несколько отчетов, рассмотрите возможность создания скрипта R, который содержит все команды compile_reports(). Пользователь может просто выполнить все команды в этом скрипте R и все отчеты будут компилированы. Вы можете сохранить этот “файл выполнения” в папке “scripts”.",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Структурирование рутинных отчетов</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.ru.html#выходные-данныые",
    "href": "new_pages/reportfactory.ru.html#выходные-данныые",
    "title": "41  Структурирование рутинных отчетов",
    "section": "41.5 Выходные данныые",
    "text": "41.5 Выходные данныые\nПосле того, как мы компилировали отчеты несколько раз, папка “outputs” может выглядеть так (выделение добавлено для наглядности):\n\n\n\n\n\n\n\n\n\n\nВнутри “outputs” созданы подпапки для каждого отчета Rmd\n\nВ них созданы дополнительные подпапки для каждой уникальной компиляции\n\nЭти папки имеют маркировку даты и времени (“2021-04-23_T11-07-36” что означает 23 апреля 2021 в 11:07:36)\n\nВы можете редактировать формат штампа даты/времени. См. ?compile_reports\n\nВнутри каждой компилированной папки с датой/временем созраняется выходной отчет (например, HTML, PDF, Word), а также скрипт Rmd (контроль версий!) и другие экспортированные файлы (например, table.csv, epidemic_curve.png)\n\nВот вид внутри одной из папки с маркировкой даты/времени для ежедневного ситуационного отчета “daily_sitrep”. Путь к файлу для наглядности выделен желтым.\n\n\n\n\n\n\n\n\n\nНаконец, ниже приведен снимок экрана с выходными данными в формате HTML.\n\n\n\n\n\n\n\n\n\nВы можете использовать list_outputs(), чтобы рассмотреть список выходных результатов.",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Структурирование рутинных отчетов</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.ru.html#разное",
    "href": "new_pages/reportfactory.ru.html#разное",
    "title": "41  Структурирование рутинных отчетов",
    "section": "41.6 Разное",
    "text": "41.6 Разное\n\nKnit\nВы все еще можете сформировать ваши отчеты R Markdown, нажав кнопку “Knit”, если хотите. Если вы это сделаете, по умолчанию выходные данные появятся в папке, где сохранен Rmd - в папке “report_sources”. В предыдущих версиях reportfactory, наличие файлов не в формате Rmd в “report_sources” мешало компилированию, но теперь это не так. Вы можете выполнить compile_reports() и ошибок не будет.\n\n\nСкрипты\nМы призываем вас использовать папку “scripts” для хранения “файлов выполнения” или скриптов .R, к которым обращаются ваши скрипты .Rmd. См. страницу [R Markdown][Отчеты с помощью R Markdown], где есть советы о том, как структурировать ваш код по нескольким файлам.\n\n\nДополнительно\n\nВ reportfactory вы можете использовать функцию list_deps(), чтобы указать список всех пакетов, которые нужны для всех отчетов во всей фабрике.\nВ разработке находится дополнительный пакет под названием rfextras, который предлагает дополнительные функции-помощники, которые помогут вам в построение отчетов, например:\n\nload_scripts() - обращается к/загружает все скрипты .R в указанной папке (по умолчанию папка “scripts”)\n\nfind_latest() - находит последние версии файла (например, последний набор данных)",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Структурирование рутинных отчетов</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.ru.html#ресурсы",
    "href": "new_pages/reportfactory.ru.html#ресурсы",
    "title": "41  Структурирование рутинных отчетов",
    "section": "41.7 Ресурсы",
    "text": "41.7 Ресурсы\nСм. пакет reportfactory на странице Github\nСм. пакет rfextras на странице Github",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Структурирование рутинных отчетов</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.ru.html",
    "href": "new_pages/flexdashboard.ru.html",
    "title": "42  Информационные панели с R Markdown",
    "section": "",
    "text": "42.1 Подготовка",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Информационные панели с R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.ru.html#подготовка",
    "href": "new_pages/flexdashboard.ru.html#подготовка",
    "title": "42  Информационные панели с R Markdown",
    "section": "",
    "text": "Загрузка пакета\nВ данном руководстве мы подчеркиваем использование p_load() из пакета pacman, которая устанавливает подход, если необходимо, и загружает его для использования. Вы можете также установить пакеты с помощью library() из базового R. См. страницу [Основы R] для получения дополнительной информации о пакетах R.\n\npacman::p_load(\n  rio,             # импорт/экспорт данных     \n  here,            # путь к файлу\n  tidyverse,       # управление данными и визуализация\n  flexdashboard,   # версии отчетов R Markdown виде информационных панелей\n  shiny,           # интерактивные рисунки\n  plotly           # интерактивные рисунки\n)\n\n\n\nИмпорт данных\nМы импортируем набор данных о случаях из имитированной эпидемии Эболы. Если вы хотите выполнять действия параллельно, кликните, чтобы скачать “чистый” построчный список (в виде .rds файла). Импортируйте данные с помощью функции import() из пакета rio (она работает с разными файлами, такими как .xlsx, .csv, .rds - см. детали на странице [Импорт и экспорт]).\n\n# импортируем построчный список\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nПервые 50 строк построчного списка отображены ниже.",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Информационные панели с R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.ru.html#создание-нового-r-markdown",
    "href": "new_pages/flexdashboard.ru.html#создание-нового-r-markdown",
    "title": "42  Информационные панели с R Markdown",
    "section": "42.2 Создание нового R Markdown",
    "text": "42.2 Создание нового R Markdown\nПосле того, как вы установили пакет, создайте новый файл R Markdown, кликнув на File &gt; New file &gt; R Markdown.\n\n\n\n\n\n\n\n\n\nВ открывшемся окне выберите “From Template” (из шаблона) и выберите шаблон “Flex Dashboard”. Затем вас попросят дать название документу. В примере для этой страницы мы назовем R Markdown “outbreak_dashboard.Rmd”.",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Информационные панели с R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.ru.html#скрипт",
    "href": "new_pages/flexdashboard.ru.html#скрипт",
    "title": "42  Информационные панели с R Markdown",
    "section": "42.3 Скрипт",
    "text": "42.3 Скрипт\nСкрипт - это скрипт R Markdown, поэтому в нем будут те же компоненты и структура, как описано на странице [Отчеты с помощью R Markdown]. Мы кратко вернемся к этому вопросу и подчеркнем отличия от других форматов выходных результатов R Markdown.\n\nYAML\nВ верхней части скрипта есть заголовок “YAML”. Он начинается с трех дефисов --- и закрываться тоже должен тремя дефисами ---. Параметры YAML указаны в парах key:value (ключ:значение). Отступ и размещение двоеточий в YAML очень важно - пары key:value отделяются двоеточием (а не знаком равно!).\nYAML должен начинаться с метаданных для документа. Порядок этих первичных параметров YAML (без отступов) не важен. Например:\n\ntitle: \"My document\"\nauthor: \"Me\"\ndate: \"`r Sys.Date()`\"\n\nВы можете использовать код R в значениях YAML, разместив его как код в строке (перед которым есть r внутри одинарных обратных кавычек), но еще и в кавычках (см. выше в пункте Date).\nТребуемый параметр YAML - output:, который уточняет тип файла, который должен быть создан (например, html_document, pdf_document, word_document, либо powerpoint_presentation). Для flexdashboard значение этого параметра чуть запутывает - оно должно быть установлено как output:flexdashboard::flex_dashboard. Обратите внимание на одинарное и двойное двоеточие и нижнее подчеркивание. За этим выходным параметром YAML часто идет дополнительное двоеточие и суб-параметры с отступом (см. параметры orientation: и vertical_layout: ниже).\n\ntitle: \"My dashboard\"\nauthor: \"Me\"\ndate: \"`r Sys.Date()`\"\noutput:\n  flexdashboard::flex_dashboard:\n    orientation: rows\n    vertical_layout: scroll\n\nКак показано выше, отступы (2 пробела) используются для суб-параметров. В таком случае, не забывайте поставить дополнительное двоеточие после первичных, например key:value:.\nЕсли возможно, логические значения следует показывать в YAML строчными буквами (true, false, null). Если двоеточие входит в ваше значение (например, в заголовке), разместите значение в кавычках. См. примеры в разделах ниже.\n\n\nФрагменты кода\nВ скрипте R Markdown может содержаться несколько “фрагментов” кода - это области скрипта, где вы можете записать несколько строк кода R, они функционируют как мини скрипты R.\nФрагменты кода создаются с помощью трех обратных одинарных кавычек и фигурных скобок, в которых внутри напечатана строчная “r”. Фрагмент закрывается тремя обратными одинарными кавычками. Вы можете создать новый фрагмент, напечатав его самостоятельно, используя горячие клавиши “Ctrl + Alt + i” (или Cmd + Shift + r для Mac), либо кликнув на зеленую иконку ‘insert a new code chunk’ (вставить новый фрагмент кода) наверху редактора скрипта. Многие примеры приведены ниже.\n\n\nТекстовая часть\nЗа пределами “фрагментов” кода R вы можете писать текстовую часть. Как указано на странице [Отчеты с помощью R Markdown], вы можете превратить текст в курсив, поставив вокруг него одну звездочку (*), либо сделать его жирным, окружив двумя звездочками (**). Помните, что маркированные и нумерованные списки чувствительны к новым строкам, отступам и окончанию строки двумя пробелами.\nВы можете также вставить код R в строке текста, как описано на странице [Отчеты с помощью R Markdown], окружив код обратными одинарными кавычками и начав команду с “r”: ` 1+1`(см. пример с датами выше).\n\n\nЗаголовки\nРазные уровни заголовков можно создать с разным количеством символов решетка, как описано на странице [Отчеты с помощью R Markdown].\nВ flexdashboard первичный заголовок (#) создает “страницу” информационной панели. Заголовки второго уровня (##) создают столбец или строку в зависимости от параметра ориентация orientation: (см. детали ниже). Заголовки третьего уровня (###) создают панели для графиков, рисунков, таблиц, текста и т.п.\n# Заголовок первого уровня(страница)\n\n## Заголовок второго уровня (строка или столбец)  \n\n### Заголовок третьего уровня (панель для графиков, рисунков и т.п.)",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Информационные панели с R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.ru.html#атрибуты-раздела",
    "href": "new_pages/flexdashboard.ru.html#атрибуты-раздела",
    "title": "42  Информационные панели с R Markdown",
    "section": "42.4 Атрибуты раздела",
    "text": "42.4 Атрибуты раздела\nВ обычном R markdown вы можете уточнить атрибуты, которые будут применены к частям вашей информационной панели, включив опции key=value после заголовка в фигурных скобках { }. Например, в обычном отчете R Markdown в HTML вы можете организовать подзаголовки по вкладкам с помощью ## My heading {.tabset}.\nОбратите внимание, что эти атрибуты пишутся после заголовка в текстовой части скрипта. Они отличаются от опций knitr, вставляемых внутри в верхней части фрагментов кода R, например, out.height =.\nАтрибуты раздела, специфичные для flexdashboard, включают:\n\n{data-orientation=} Установите на rows (строки) или columns (столбцы). Если на вашей информационной панели несколько страниц, добавьте этот атрибут к каждой странице, чтобы указать ориентацию (дополнительно объясняется в разделе макет).\n\n{data-width=} и {data-height=} устанавливает относительный размер графиков, столбцов, строк, находящихся в одной плоскости (горизонтальной или вертикальной). Абсолютные размеры скорректированы так, чтобы наилучшим образом заполняют пространство или дисплей устройства благодаря flexbox.\n\nВысота графиков тоже зависит от того, зададите ли вы параметр YAML как vertical_layout: fill или vertical_layout: scroll. Если установить на scroll (пролистывание), высота рисунка будет отражать традиционную опцию fig.height = во фрагменте кода R.\n\nСм. полную документацию по размерам на веб-сайте flexdashboard\n\n\n{.hidden} Используйте, чтобы исключить конкретную страницу из панели навигации\n\n{data-navbar=} Используйте для заголовка на уровне страницы, чтобы разместить его внутри выпадающего меню навигационной панели. Задайте имя (в кавычках) выпадающего меню. См. пример ниже.",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Информационные панели с R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.ru.html#layout",
    "href": "new_pages/flexdashboard.ru.html#layout",
    "title": "42  Информационные панели с R Markdown",
    "section": "42.5 Макет",
    "text": "42.5 Макет\nСкорректируйте макет вашей информационной панели следующим образом:\n\nВсе страницы, столбцы/строки и графики с заголовками R Markdown (например, #, ##, или ###)\n\nСкорректируйте параметр YAML ориентация orientation: на rows (строки) или columns (столбцы)\n\nУточните, заполняет ли макет браузер или допускается пролистывание\n\nДобавьте вкладки в заголовок конкретного раздела\n\n\nСтраницы\nЗаголовки первого уровня (#) в R Markdown будут представлять “страницы” информационной панели. По умолчанию страницы появятся в навигационной панели наверху информационной панели.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nВы можете сгруппировать страницы в “меню” внутри навигационной панели, добавив атрибут {data-navmenu=} к заголовку страницы. Будьте осторожны - не включайте пробелы вокруг знака равно, иначе не сработает!\n\n\n\n\n\n\n\n\n\nВот что создаст скрипт:\n\n\n\n\n\n\n\n\n\nВы можете также конвертировать страницу или столбец в “боковую панель” слева стандартной информационной панели, добавив атрибут {.sidebar}. Она может содержать текст (просматриваемый с любой страницы), либо если вы интегрировали интерактивность shiny, она может содержать полезные контроли, вводимые пользователем, например слайдеры или выпадающие меню.\n\n\n\n\n\n\n\n\n\nВот что создаст скрипт:\n\n\n\n\n\n\n\n\n\n\n\nОриентация\nЗадайте ориентацию orientation: параметр yaml, который указывает, как следует интерпретировать заголовки второго уровня (##) в R Markdown - либо как столбцы orientation: columns, либо как orientation: rows.\nЗаголовки второго уровня (##) будут интерпретироваться как новые столбцы или строки на основе этой настройки orientation.\nЕсли вы установите orientation: columns, заголовки второго уровня будут создавать новые столбцы информационной панели. На информационной панели ниже имеется одна страница, содержащая два столбца, итого три панели. Вы можете откорректироваьт эту относительную ширину столбцов с помощью {data-width=}, как показано ниже.\n\n\n\n\n\n\n\n\n\nВот что создаст скрипт:\n\n\n\n\n\n\n\n\n\nЕсли вы установите orientation: rows, заголовки второго уровня будут создавать новые строки, а не столбцы. Ниже находится тот же скрипт, что и выше, но с orientation: rows, так что заголовки второго уровня создают строки, а не столбцы. Вы можеет скорректировать относительную высоту строк с помощью {data-height=}, как показано ниже.\n\n\n\n\n\n\n\n\n\nВот что создаст скрипт:\n\n\n\n\n\n\n\n\n\nЕсли на вашей информационной панели несколько страниц, вы можете определить ориентацию каждой конкретной страницы, добавив атрибут {data-orientation=} в заголовок каждой страницы (уточните без кавычек rows или columns).\n\n\nВкладки\nВы можете разделить содержимое на вкладки с помощью атрибута {.tabset}, как в других выходных HTML в R Markdown.\nПросто добавьте этот атрибут после нужного заголовка. Подзаголовки под этим заголовком будут отображены как вкладки. Например, в примере скрипта ниже столбец 2 справа (##) модифицирован так, чтобы эпидемическая кривая и панели таблиц (###) отображены во вкладках.\nВы можете сделать то же самое со строками, если вы выбрали ориентацию строк.\n\n\n\n\n\n\n\n\n\nВот что создаст скрипт:",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Информационные панели с R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.ru.html#добавление-содержимого",
    "href": "new_pages/flexdashboard.ru.html#добавление-содержимого",
    "title": "42  Информационные панели с R Markdown",
    "section": "42.6 Добавление содержимого",
    "text": "42.6 Добавление содержимого\nДавайое начнем строить информационную панель. На нашей простой информационной панели будет 1 страница, 2 столбца и 4 панели. Мы построим панели по элементам для демонстрации.\nВы можете легко включить стандартные выходные результаты R, такие как текст, ggplots и таблицы (см. страницу [Таблицы для презентации]). Просто закодируйте их внутри фрагмента кода R, как вы бы это делали в любом другом скрипте R Markdown.\nПримечание: вы можете скачать законченный скрипт Rmd и выходной результат создания информационной панели в HTML - см. страницу [Скачивание руководства и данных].\n\nТекст\nВы можете напечатать в Markdown текст и включить код в строке, как в любом другом выходном файле R Markdown. См. дополнительную информацию на странице [Отчеты с помощью R Markdown].\nНа этой информационной панели мы включваем сводную текстовую панель, которая включает динамический текст, показывающий последние данные по госпитализациям и количеству случаев, зарегистрированных во вспышке.\n\n\nТаблицы\nВы можете включить фрагменты кода R, который печает такие выходные данные, как таблицы. Но выходные данные будут лучше выглядеть и реагировать на размер окна, если вы используете функцию kable() из пакета knitr, чтобы отобразить ваши таблицы. Функции flextable могут создать таблицы, которые сокращены/обрезаны.\nНапример, ниже мы передаем linelist() через команду count(), чтобы создать суммарную таблицу случаев по больнице. В конечном итоге таблица передается в knitr::kable() и результатом будет полоса прокрутки справа. Вы можете больше прочитать об индивидуализации ваших таблиц с помощью kable() или kableExtra тут.\n\n\n\n\n\n\n\n\n\nВот что создаст скрипт:\n\n\n\n\n\n\n\n\n\nЕсли вы хотите показать динамическую таблицу, которая позволяет пользователю фильтровать, сортировать и/или кликать через “страницы” датафрейма, используйте пакет DT и его функцию datatable(), как в коде ниже.\nПример кода ниже показывает, что печатается датафрейм linelist. Вы можете задать rownames = FALSE, чтобы сэкономить горизонтальное пространство, и filter = \"top\", чтобы поставить фильтры в верхней части каждого столбца. Список других спецификаций можно задать в options =. Ниже мы установим pageLength =, чтобы были видны 5 строк и scrollX =, чтобы пользователь мог использовать полосу прокрутки внизу для горизонтального прокручивания. Аргумент class = 'white-space: nowrap' позволит убедиться, что каждая строка занимает одну линию (не несколько). Вы можете почитать о других возможных аргументах и значениях тут, либо введя ?datatable\n\nDT::datatable(linelist, \n              rownames = FALSE, \n              options = list(pageLength = 5, scrollX = TRUE), \n              class = 'white-space: nowrap' )\n\n\n\nГрафики\nВы можете распечатать графики на панели информационной панели, как вы это делаете в скрипте R. В нашем примере мы используем пакет incidence2 для создания “эпидкривой” по возрастной группе с помощью двух простых команд (см. страницу [Эпидемические кривые]). Однако, вы можете использовать ggplot() и печатать график тем же образом.\n\n\n\n\n\n\n\n\n\nВот что создаст скрипт:\n\n\n\n\n\n\n\n\n\n\n\nИнтерактивные графики\nВы можете также передать стандартный ggplot или другой объект графика в ggplotly() из пакета plotly (см. страницу Интерактивные графики). Это позволит сделать ваш график интерактивным, даст пользователю возможность приближать его, наводить на значение каждой точки данных (в данном случае количество случаев в неделю и возрастная группа на кривой).\n\nage_outbreak &lt;- incidence(linelist, date_onset, \"week\", groups = age_cat)\nplot(age_outbreak, fill = age_cat, col_pal = muted, title = \"\") %&gt;% \n  plotly::ggplotly()\n\nВот как это выглядит на информационной панели (gif). Этот интерактивный потенциал все еще будет работать, даже если вы отправите информационную панель по почте как статический файл (не онлайн или на сервере).\n\n\n\n\n\n\n\n\n\n\n\nВиджеты HTML\nВиджеты HTML для R - специальный класс пакетов R, который повышает интерактивность с помощью использования библиотек JavaScript. Вы можете интегрировать их в выходные результаты R Markdown (например, как flexdashboard) и в информационные панели Shiny.\nНекоторые частые примеры этих виджетов:\n\nPlotly (используется на этой странице руководства и на странице Интерактивные графики)\nvisNetwork (используется в данном руководстве на странице [Цепочки распространения])\n\nLeaflet (используется в данном руководстве на странице [Основы GIS])\n\ndygraphs (полезен для интерактивной демонстрации данных временных рядов)\n\nDT (datatable()) (используется, чтобы показать динамические таблицы с фильтром, сортировкой и т.п.)\n\nНиже мы демонстрируем добавление к информационной панели цепочки распространения для эпидемии, которая использует visNetwork. Скрипт показывает только новый код, добавляемый к разделу “Column 2” (Столбец 2) скрипта R Markdown. Вы можете найти код на странице руководства [Цепочки распространения].\n\n\n\n\n\n\n\n\n\nВот что создаст скрипт:",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Информационные панели с R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.ru.html#организация-кода",
    "href": "new_pages/flexdashboard.ru.html#организация-кода",
    "title": "42  Информационные панели с R Markdown",
    "section": "42.7 Организация кода",
    "text": "42.7 Организация кода\nВы можете решить заложитоь весь код внутри скрипта R Markdown flexdashboard. Альтернативно, чтобы получить более чистый и краткий скрипт информационной панели, вы можете вызывать код/рисунки, которые размещены или созданы во внешних скриптах R. Это более подробно описывается на странице [Отчеты с помощью R Markdown].",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Информационные панели с R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.ru.html#shiny",
    "href": "new_pages/flexdashboard.ru.html#shiny",
    "title": "42  Информационные панели с R Markdown",
    "section": "42.8 Shiny",
    "text": "42.8 Shiny\nИнтеграция пакета R shiny может сделать ваши информационные панели еще более реагирующими на действия пользователя. Например, вы можете дать пользователю возможность выбрать юрисдикцию или диапазонтдат и позволить панелям реагировать на этот выбор (например, фильтровать отображаемые данные). Чтобы встроить реагирование shiny в flexdashboard, вам нужно внести всего несколько изменений в ваш скрипт flexdashboard R Markdown.\nВы можете использовать shiny, чтобы создать приложения/информационные панели без flexdashboard. Страница руководства [Информационные панели с Shiny] делает обзор этого подхода, включая образцы синтаксиса shiny, структуру файлов приложения, а также опции предоставления доступа/публикации (включая опцию на бесплатном сервере). Этот синтаксис и общие советы работают и в контексте flexdashboard.\nИнтеграфиц shiny в flexdashboard однако является фундаментальным изменением вашего flexdashboard. Он больше не будет выдавать выходной результат в HTML, который вы можете отправить по электронной почте и который любой может открыть и просмотреть. Вместо этого, это уже будет “приложением”. Вместо кнопки “Knit” в верхней части скрипта появится иконка “Run document” (выполнить документ), которая откроет интерактивную панель локально на вашем компьютере.\nЧтобы поделиться вашей информационной панелью вы теперь должны будете:\n\nОтправить скрипт Rmd пользователю, он должен будет открыть R на своем компьютере, выполнить приложение или\n\nПриложение/информационная панель размещается на сервере, доступном пользователю\n\nТаким образом существуют преимущества в интеграции shiny, но есть и сложности. Если предоставление панели по электронной почте является для вас приоритетом и вам не нужны возможности shiny, реагирующие на запросы пользователей, рассмотрите возможность снижения интерактивности, предлагаемой ggplotly(), как показано выше.\nНиже мы приводим очень простой пример использования того же файла “outbreak_dashboard.Rmd”, что и выше. Детальная документация по интеграции Shiny в flexdashboard доступна онлайн тут.\n\nНастройки\nВключите функционал shiny в flexdashboard, добавив параметр YAML runtime: shiny на том же уровне отступа, что и output:, как ниже:\n---\ntitle: \"Outbreak dashboard (Shiny demo)\"\noutput: \n  flexdashboard::flex_dashboard:\n    orientation: columns\n    vertical_layout: fill\nruntime: shiny\n---\nТакже удобно включать “боковую панель”, где будут содержаться входные виджеты shiny, которые будут собирать информацию от пользователя. Как объяснялось выше, создайте столбец и укажите опцию {.sidebar}, чтобы создать боковую панель слева. Вы можете добавить текст и фрагменты R, содержащие входные команды shiny input внутри этого столбца.\nЕсли ваше приложение/информационная панель размещены на сервере и могут иметь несколько пользователей одновременно, назовите первый фрагмент кода R global. Включите команды по импорту/загрузке ваших данных в этот фрагмент. Этот специально именованный фрагмент теперь будет восприниматься по-другому, и данные, импортированные в нем, импортируются только один раз (а не постоянно) и доступны всем пользователям. Это улучшит скорость запуска приложения.\n\n\nОтработанный пример\nЗдесь мы адаптируем скрипт flexdashboard “outbreak_dashboard.Rmd” для включения shiny. Мы добавим функционал для пользователя по выбору больницы из выпадающего меню, а также сделаем так, чтобы эпидемическая кривая отражала только случаи из этой больницы с динамическим заголовком графика. Мы сделаем следующее:\n\nДобавляем runtime: shiny в YAML\n\nПереименовываем установочный фрагмент в global\n\nРассмотрите возможность создания боковой панели, содержащей:\n\nКод для создания вектора уникальных имен больниц\n\nКоманду selectInput() (выпадающее меню shiny) с выбором имен больниц. Выбор сохраняется как hospital_choice, на который можно ссылаться в более позднем коде как input$hospital_choice\n\n\nКод эпидемической кривой (столбец 2) обернут в renderPlot({ }), включая:\n\nФильтр по набору данных, ограничивая столбец hospital до текущего значения input$hospital_choice\n\nДинамический заголовок графика, который включает input$hospital_choice\n\n\nОбратите внимание, что любой код, ссылающийся на значение input$, должен быть внутри функции render({}) (чтобы быть реагирующим).\nВот верхняя часть скрипта, включая YAML, глобальный фрагмент и боковую панель:\n\n\n\n\n\n\n\n\n\nВот столбец 2, с реагирующим графиком эпидкривой:\n\n\n\n\n\n\n\n\n\nВот информационная панель:\n\n\n\n\n\n\n\n\n\n\n\nДругие примеры\nЧтобы прочитать пример, связанный с здравоохранением, в flexdashboard, используя интерактив shiny и виджет карт leaflet, см. эту главу онлайн книги Геопространственные медицинские данные: моделирование и визуализация с R-INLA и Shiny.",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Информационные панели с R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.ru.html#предоставление-доступа",
    "href": "new_pages/flexdashboard.ru.html#предоставление-доступа",
    "title": "42  Информационные панели с R Markdown",
    "section": "42.9 Предоставление доступа",
    "text": "42.9 Предоставление доступа\nИнформационные панели, которые не содержат элементы Shiny, будут выданы как файл HTML (.html), который можно отправить по электронной почте (если позволяет размер). Это полезно, так как вы можете скинуть отчет в виде “информационной панели” и не создавать сервер для размещения его, как вебсайта.\nЕсли вы интегрировали shiny, вы не сможете отправить выходные данные по электронной почте, но вы можете направить сам скрипт пользователю R, либо сможете разместить информационную панель на сервер, как указано выше.",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Информационные панели с R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.ru.html#ресурсы",
    "href": "new_pages/flexdashboard.ru.html#ресурсы",
    "title": "42  Информационные панели с R Markdown",
    "section": "42.10 Ресурсы",
    "text": "42.10 Ресурсы\nЗамечательные самоучители, из которых мы брали информацию, для этой страницы можно найти ниже. Если вы их изучите, вы, скорее всего, за час сможете создать свою информационную панель.\nhttps://bookdown.org/yihui/rmarkdown/dashboards.html\nhttps://rmarkdown.rstudio.com/flexdashboard/\nhttps://rmarkdown.rstudio.com/flexdashboard/using.html\nhttps://rmarkdown.rstudio.com/flexdashboard/examples.html",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Информационные панели с R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.ru.html",
    "href": "new_pages/shiny_basics.ru.html",
    "title": "43  Информационные панели с Shiny",
    "section": "",
    "text": "43.1 Подготовка",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Информационные панели с Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.ru.html#подготовка",
    "href": "new_pages/shiny_basics.ru.html#подготовка",
    "title": "43  Информационные панели с Shiny",
    "section": "",
    "text": "Загрузка пакетов\nВ данном руководстве мы подчеркиваем использование p_load() из pacman, который устанавливает пакет, если необходимо, и загружает его для использования. Вы можете также загрузить установленные пакеты с помощью library() из базового R. См. страницу Основы R для получения дополнительной информации о пакетах R.\nНачнем с установки пакета R shiny:\n\npacman::p_load(\"shiny\")\n\n\n\nИмпорт данных\nЕсли вы хотите выполнять действия параллельно на этой странице, см. этот раздел в Скачивание руководства и данных. Есть ссылки для скачивания скриптов R и файлов с данными, которые создают итоговое приложение Shiny.\nЕсли вы попытаетесь восстановить приложение, используя эти файлы, обратите внимание на структуру папок проекта R, которая создается в ходе демонстрации (например, папки “data” и “funcs”).",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Информационные панели с Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.ru.html#структура-приложения-shiny",
    "href": "new_pages/shiny_basics.ru.html#структура-приложения-shiny",
    "title": "43  Информационные панели с Shiny",
    "section": "43.2 Структура приложения shiny",
    "text": "43.2 Структура приложения shiny\n\nБазовая структура файлов\nЧтобы разобраться в shiny, нам сначала нужно понять, как работает структура файлов приложения! Мы должны создать совершенно новую директорию перед началом. Это можно упростить, выбрав New project (новый проект) в Rstudio, затем выбрав Shiny Web Application (веб-приложение Shiny). Это позволит создать базовую структуру приложения shiny для вас.\nпри открытии этого проекта вы заметите, что уже присутствует файл .R под названием app.R. Очень важно, чтобы у нас была одна из двух основных структур файла:\n\nОдин файл под названием app.R, или\n\nДва файла, один под названием ui.R и другой под названием server.R\n\nНа этой странице мы используем сначала первый подход с наличием одного файла под названием app.R. Вот пример скрипта:\n\n# пример app.R\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n\n    # Название приложения\n    titlePanel(\"My app\"),\n\n    # Боковая панель с виджетом ввода данных\n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(\"input_1\")\n        ),\n\n        # Показать график \n        mainPanel(\n           plotOutput(\"my_plot\")\n        )\n    )\n)\n\n# Задаем логику сервера, требуемую для рисования гистограммы\nserver &lt;- function(input, output) {\n     \n     plot_1 &lt;- reactive({\n          plot_func(param = input_1)\n     })\n     \n    output$my_plot &lt;- renderPlot({\n       plot_1()\n    })\n}\n\n\n# Выполняем приложение \nshinyApp(ui = ui, server = server)\n\nЕсли вы откроете этот файл, вы заметите, что определено два объекта - один под названием ui, а другой - server. Эти объекты должны быть определены в каждом приложении shiny и являются центральными для структуры самого приложения! На самом деле, единственной разницей между двумя структурами файлов, описанных выше, является то, в структуре 1, и ui и server задаются в одном файле, а в структуре 2 они определяются в разных файлах. Примечание: мы можем также (и нам следует, если у нас более крупное приложение) иметь другие файлы .R в нашепй структуре, которые мы можем вызывать с помощью source() в приложении.\n\n\nServer (сервер) и ui (пользовательский интерфейс)\nНам нужно понять, что делают объекты server и ui. Если говорить простыми словами, эти два объекта взаимодействуют друг с другом, когда пользователь взаимодействует с приложением shiny.\nЭлемент UI приложения shiny, по сути, является кодом R, который создает HTML интерфейс. Это значит все, что отображается в пользовательском интерфейсе (UI) приложения. Это, как правило, включает:\n\n“Виджеты” - выпадающие меню, поля для галочек, окна прокрутки и т.п., с которыми может взаимодействовать пользователь\nГрафики, таблицы и т.п. - выходные данные, которые генерирует код R\nНавигационные аспекты приложения - вкладки, панели и т.п.\nОбщий текст, гиперссылки и т.п.\nHTML и CSS элементы (будут рассмотрены позже)\n\nНаиболее важной вещью, которую нужно понять про UI, является то, что он получает ввод от пользователя и отображает выходные данные от сервера. В ui никогда не выполняется активный код - все изменения, которые мы видим в UI, передаются через сервер (плюс минус). Поэтому мы создаем графики, проводим скачивание и т.п. на сервере.\nНа сервере приложения shiny выполняется весь код после запуска приложения. То, как это работает, может немного запутать. Функция сервера, по сути, реагирует на взаимодействие пользователя с UI, и в качестве отклика выполняет фрагменты кода. Если что-то меняется на сервере, это передается на ui, где можно увидеть изменения. Что важно, код на сервере исполняется не-последовательно (или по крайней мере лучше так думать). по сути, когда ввод через ui влияет на фрагмент кода на сервере, он будет выполнен автоматически, выходные данные будут подготовлены и отображены.\nСейчас это все звучит очень абстрактно, но мы углубимся в некоторые примеры, чтобы получить представление о том, как это работает.\n\n\nПрежде чем вы начнете строить приложение\nПрежде чем вы начнете строить приложение, очень полезно знать - что вы хотите построить. Поскольку ваш пользовательский интерфейс будет написан в коде, вы не сможете представить себе, что именно вы создаете, если только не стремитесь к чему-то конкретному. По этой причине очень полезно посмотреть множество примеров блестящих приложений, чтобы получить представление о том, что можно создать, а еще лучше, если вы сможете заглянуть в исходный код этих приложений! Отличными ресурсами для этого являются:\n\nГалерея приложений Rstudio\n\nКак только вы получите представление о том, что возможно, полезно также наметить, как вы хотите, чтобы выглядело ваше приложение, - это можно сделать на бумаге или в любой программе для рисования (PowerPoint, MS paint и т.д.). Для первого приложения полезно начать с простого! Нет ничего постыдного в том, чтобы использовать найденный в Интернете код хорошего приложения в качестве шаблона для своей работы - это гораздо проще, чем создавать что-то с нуля!",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Информационные панели с Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.ru.html#построение-пользовательского-интерфейса-ui",
    "href": "new_pages/shiny_basics.ru.html#построение-пользовательского-интерфейса-ui",
    "title": "43  Информационные панели с Shiny",
    "section": "43.3 Построение пользовательского интерфейса (UI)",
    "text": "43.3 Построение пользовательского интерфейса (UI)\nПри создании приложения проще сначала поработать над пользовательским интерфейсом, чтобы видеть, что мы делаем, и не рисковать тем, что приложение не будет работать из-за ошибок сервера. Как уже говорилось, при работе над пользовательским интерфейсом часто полезно использовать шаблон. Существует ряд стандартных макетов, которые можно использовать в shiny, доступных из базового пакета shiny, но стоит отметить, что есть и ряд расширений пакета, таких как shinydashboard. Мы используем для начала пример базового shiny.\nПользовательский интерфейс UI, как правило, определяется как серия вложенных функций в следующем порядке:\n\nФункция, определяющая общий макет (самая простая - fluidPage(), но есть и другие)\nПанели внутри макета, такие как:\n\nбоковая панель (sidebarPanel())\n“основная” панель (mainPanel())\nвкладка (tabPanel())\nобщий “столбец” (column())\n\nВиджеты и выходные данные - они могут предоставлять входные данные на сервер (виджеты) или выходные данные с сервера (выходы)\n\nВиджеты, как правило, стилизуются как xxxInput() например, selectInput()\nВыходные данные, как правило, стилизуются как xxxOutput() например, plotOutput()\n\n\nСтоит еще раз подчеркнуть, что эти данные не могут быть легко визуализированы в абстрактном виде, поэтому лучше обратиться к примеру! Давайте рассмотрим возможность создания базового приложения, визуализирующего данные о количестве малярийных учреждений по районам. Эти данные содержат множество различных параметров, поэтому было бы здорово, если бы конечный пользователь мог применить некоторые фильтры, чтобы увидеть данные по возрастным группам/районам так, как он считает нужным! Для начала мы можем использовать очень простой блестящий макет - макет боковой панели. Это макет, в котором виджеты располагаются в боковой панели слева, а график - справа.\nДавайте спланируем наше приложение - мы можем начать с селектора, который позволяет нам выбрать, для какого района мы хотим визуализировать данные, а еще один позволит визуализировать возрастную группу, которая нам интересна. Мы будем использовать эти фильтры, чтобы показать эпидкривую, которая отображает эти параметры. Для этого нам нужно:\n\nДва выпадающих меню, которые позволяют нам выбрать, какой район и возрастная группа нам нужны.\nОбласть, где мы можем показать полученную в результате эпидкривую.\n\nЭто может выглядеть следующим образом:\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # селектор района\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = c(\n                   \"All\",\n                   \"Spring\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selected = \"All\",\n              multiple = TRUE\n         ),\n         # селектор возрастной группы\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         )\n\n    ),\n\n    mainPanel(\n      # эпидкривая здесь\n      plotOutput(\"malaria_epicurve\")\n    )\n    \n  )\n)\n\nКогда выполняется app.R с указанным выше кодом UI (без активного кода в серверной части (server) app.R) макет выглядит вот так - обратите внимание, что не будет графика, если нет сервера, который его сформирует, но наши вводы работают!\n\n\n\n\n\n\n\n\n\nЭто отличная возможность обсудить то, как работают виджеты - обратите внимание, что каждый виджет принимает inputId, label и ряд других опций в зависимости от типа виджета. Этот inputId очень важен - есть два идентификационных номера (ID), которые используются для передачи информации от пользовательского интерфейса на сервер. Поэтому они должны быть уникальны. Вы должны постараться назвать их понятно и специфично для того взаимодействия, которое они осуществляют, особенно в больших приложениях.\nВы должны внимательно прочитать подробные детали о работе каждого виджета в документации. Виджете передают конкретные типы данных на сервер в зависимости от типа виджета, это необходимо хорошо понимать. Например, selectInput() передает буквенный тип на сервер:\n\nЕсли мы выберем Spring для этого виджета, он передаст объект \"Spring\" на сервер.\nЕсли мы выберем два пункта из выпадающего меню, они будут переданы как текстовый вектор (например, c(\"Spring\", \"Bolo\")).\n\nДругие виджеты передают другие типы объектов на сервер! Например:\n\nnumericInput() передаст объект числового типа на сервер\ncheckboxInput() передаст объект логического типа на сервер (TRUE или FALSE)\n\nТакже следует отметить именованный вектор, который мы использовали для данных о возрасте. Для многих виджетов используется именованный вектор, так как варианты будут отображаться как имена вектора в виде выводих вариантов, но они передают выбранное значение из вектора серверу. Т.е., человек может выбрать “15+” из выпадающего меню и UI передаст на сервер \"malaria_rdt_15\" - что является именем столбца, который нам нужен!\nСуществует множество виджетов, с помощью которых можно выполнять различные действия в приложении. Виджеты также позволяют загружать файлы в приложение и выгружать результаты. Есть также несколько отличных расширений shiny, которые дают доступ к большему количеству виджетов, чем базовый shiny - пакет shinyWidgets является замечательным примером этого. Чтобы изучить некоторые примеры, см. следующие ссылки:\n\nбазовая галерея виджетов shiny\nгалерея shinyWidgets",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Информационные панели с Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.ru.html#загрузка-данных-в-приложение",
    "href": "new_pages/shiny_basics.ru.html#загрузка-данных-в-приложение",
    "title": "43  Информационные панели с Shiny",
    "section": "43.4 Загрузка данных в приложение",
    "text": "43.4 Загрузка данных в приложение\nСледующим шагом в разработке нашего приложения является запуск сервера. Для этого нам необходимо получить некоторые данные в нашем приложении и определить все вычисления, которые мы собираемся выполнять. Блестящее приложение не так просто отладить, поскольку часто неясно, откуда берутся ошибки, поэтому идеальным вариантом будет заставить работать весь наш код обработки данных и визуализации до того, как мы начнем создавать сам сервер.\nИтак, если мы хотим сделать приложение, которое будет показывать эпидкривые, изменяющиеся в зависимости от ввода пользователя, то нам следует подумать о том, какой код нам потребуется для запуска этого приложения в обычном скрипте на R. Нам потребуется:\n\nзагрузить пакеты\nзагрузить данные\nпреобразовать данные\nразработать функцию для визуализации данных в зависимости от ввода пользователя\n\nЭтот перечень достаточно простой и не должен вызывать сложностей при реализации. Теперь важно подумать, какие части процесса должны быть выполнены только один раз, а какие части нужно выполнять в ответ за пользовательский ввод. Это происходит потому, что приложения shiny, как правило, выполняют некоторый код до запуска, что делается только один раз. Для быстроты работы нашего приложения будет полезно перенести как можно больше кода в этот раздел. Например, нам нужно загрузить данные/пакеты и выполнить основные преобразования только один раз, Поэтому мы можем разместить этот код за пределами сервера. Это означает, что единственное, что будет делать сервер - выполнять код для визуализации данных. Давайте разработаем все эти компоненты сначала в скрипте. Однако поскольку мы визуализируем данные с помощью функции, мы также можем разместить код для функции за пределами сервера, чтобы наша функция была в среде, когда приложение запускается!\nСначала загрузим наши данные. Поскольку мы работаем с новым проектом и хотим сделать его чистым, мы можем создать новую директорию под названием data и добавить туда наши данные о малярии. Мы можем запустить приведенный ниже код в тестовом скрипте, который впоследствии удалим, когда очистим структуру нашего приложения.\n\npacman::p_load(\"tidyverse\", \"lubridate\")\n\n# прочитываем данные\nmalaria_data &lt;- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\")) %&gt;% \n  as_tibble()\n\nprint(malaria_data)\n\n# A tibble: 3,038 × 10\n   location_name data_date  submitted_date Province District `malaria_rdt_0-4`\n   &lt;chr&gt;         &lt;date&gt;     &lt;date&gt;         &lt;chr&gt;    &lt;chr&gt;                &lt;int&gt;\n 1 Facility 1    2020-08-11 2020-08-12     North    Spring                  11\n 2 Facility 2    2020-08-11 2020-08-12     North    Bolo                    11\n 3 Facility 3    2020-08-11 2020-08-12     North    Dingo                    8\n 4 Facility 4    2020-08-11 2020-08-12     North    Bolo                    16\n 5 Facility 5    2020-08-11 2020-08-12     North    Bolo                     9\n 6 Facility 6    2020-08-11 2020-08-12     North    Dingo                    3\n 7 Facility 6    2020-08-10 2020-08-12     North    Dingo                    4\n 8 Facility 5    2020-08-10 2020-08-12     North    Bolo                    15\n 9 Facility 5    2020-08-09 2020-08-12     North    Bolo                    11\n10 Facility 5    2020-08-08 2020-08-12     North    Bolo                    19\n# ℹ 3,028 more rows\n# ℹ 4 more variables: `malaria_rdt_5-14` &lt;int&gt;, malaria_rdt_15 &lt;int&gt;,\n#   malaria_tot &lt;int&gt;, newid &lt;int&gt;\n\n\nРаботать с этими данными будет проще, если мы будем использовать аккуратные стандарты данных, поэтому нам также следует преобразовать их в более длинный формат, где возрастная группа - это столбец, а случаи - другой столбец. Мы это легко можем сделать с помощью принципов, которые были рассмотрены на странице [Поворот данных].\n\nmalaria_data &lt;- malaria_data %&gt;%\n  select(-newid) %&gt;%\n  pivot_longer(cols = starts_with(\"malaria_\"), names_to = \"age_group\", values_to = \"cases_reported\")\n\nprint(malaria_data)\n\n# A tibble: 12,152 × 7\n   location_name data_date  submitted_date Province District age_group       \n   &lt;chr&gt;         &lt;date&gt;     &lt;date&gt;         &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;           \n 1 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_rdt_0-4 \n 2 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_rdt_5-14\n 3 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_rdt_15  \n 4 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_tot     \n 5 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_rdt_0-4 \n 6 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_rdt_5-14\n 7 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_rdt_15  \n 8 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_tot     \n 9 Facility 3    2020-08-11 2020-08-12     North    Dingo    malaria_rdt_0-4 \n10 Facility 3    2020-08-11 2020-08-12     North    Dingo    malaria_rdt_5-14\n# ℹ 12,142 more rows\n# ℹ 1 more variable: cases_reported &lt;int&gt;\n\n\nНа этом мы закончили подготовку данных! Это вычеркивает пункты 1, 2 и 3 из списка того, что необходимо разработать для “тестового R-скрипта”. Последней и самой сложной задачей будет построение функции для получения эпидкривой по заданным пользователем параметрам. Как уже говорилось, тем кто изучает shiny сначала настоятельно рекомендуется изучить раздел по функциональному программированию ([Написание функций]), чтобы понять, как это работает!\nПри определении функции может возникнуть трудность с выбором параметров, которые мы хотим включить в нее. При функциональном программировании с помощью shiny каждый релевантный параметр, как правило, имеет виджет, связанный с ним, поэтому думать об этом обычно довольно просто! Например, в нашем текущем приложении мы хотим иметь возможность фильтровать по районам, и для этого у нас есть виджет, поэтому мы можем добавить параметр district, чтобы отразить это. У нас нет функционала в приложении для фильтра по медицинским организациям (пока), поэтому нам нет необходимости добавлять их как параметр. Давайте начнем с создания функции с тремя параметрами:\n\nКлючевой набор данных\nВыбранный район\nВыбранная возрастная группа\n\n\nplot_epicurve &lt;- function(data, district = \"All\", agegroup = \"malaria_tot\") {\n  \n  if (!(\"All\" %in% district)) {\n    data &lt;- data %&gt;%\n      filter(District %in% district)\n    \n    plot_title_district &lt;- stringr::str_glue(\"{paste0(district, collapse = ', ')} districts\")\n    \n  } else {\n    \n    plot_title_district &lt;- \"all districts\"\n    \n  }\n  \n  # если нет оставшихся данных, выдать NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  data &lt;- data %&gt;%\n    filter(age_group == agegroup)\n  \n  \n  # если нет оставшихся данных, выдать NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  if (agegroup == \"malaria_tot\") {\n      agegroup_title &lt;- \"All ages\"\n  } else {\n    agegroup_title &lt;- stringr::str_glue(\"{str_remove(agegroup, 'malaria_rdt')} years\")\n  }\n  \n  \n  ggplot(data, aes(x = data_date, y = cases_reported)) +\n    geom_col(width = 1, fill = \"darkred\") +\n    theme_minimal() +\n    labs(\n      x = \"date\",\n      y = \"number of cases\",\n      title = stringr::str_glue(\"Malaria cases - {plot_title_district}\"),\n      subtitle = agegroup_title\n    )\n  \n  \n  \n}\n\nМы не будем подробно останавливаться на этой функции, поскольку ее работа достаточно проста. Однако следует отметить, что при обработке ошибок мы выдаем NULL, когда в противном случае была бы выдана ошибка. Это связано с тем, что если сервер shiny создает объект NULL вместо объекта графика, ничего не отобразится в пользовательском интерфейсе! Это очень важно, поскольку в противном случае ошибки часто приводят к остановке работы приложения.\nСледует также отметить использование оператора %in% при оценке ввода района district. Как упомянуто выше, он может быть задан как текстовый вектор с несколькими значениями, поэтому использование %in% даст большую гибкость, чем, например, ==.\nДавайте протестируем нашу функцию!\n\nplot_epicurve(malaria_data, district = \"Bolo\", agegroup = \"malaria_rdt_0-4\")\n\n\n\n\n\n\n\n\nЕсли наша функция работает, нам надо понять, как это все будет встроено в наше приложение shiny. Мы упоминали концепцию кода предзапуска ранее, но давайте рассмотрим, как его включить в структуру нашего приложения. Это можно сделать двумя способами!\n\nразместить код в файле app.R в начале скрипта (выше UI), или\n\nсоздать новый файл в директории приложения под названием global.R, и разместить код предзапуска в этом файле.\n\nСтоит отметить, что обычно, особенно в больших приложениях, проще использовать вторую файловую структуру, так как она позволяет разделить файловую структуру простым способом. Давайте теперь полностью разработаем этот скрипт global.R. Вот как он может выглядеть:\n\n# скрипт global.R\n\npacman::p_load(\"tidyverse\", \"lubridate\", \"shiny\")\n\n# прочитываем данные\nmalaria_data &lt;- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\")) %&gt;% \n  as_tibble()\n\n# вычищаем данные и поворачиваем вертикально\nmalaria_data &lt;- malaria_data %&gt;%\n  select(-newid) %&gt;%\n  pivot_longer(cols = starts_with(\"malaria_\"), names_to = \"age_group\", values_to = \"cases_reported\")\n\n\n# определяем построение функций\nplot_epicurve &lt;- function(data, district = \"All\", agegroup = \"malaria_tot\") {\n  \n  # создаем заголовок графика\n  if (!(\"All\" %in% district)) {            \n    data &lt;- data %&gt;%\n      filter(District %in% district)\n    \n    plot_title_district &lt;- stringr::str_glue(\"{paste0(district, collapse = ', ')} districts\")\n    \n  } else {\n    \n    plot_title_district &lt;- \"all districts\"\n    \n  }\n  \n  # если нет оставшихся данных, выдать NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  # фильтр по возрастной группе\n  data &lt;- data %&gt;%\n    filter(age_group == agegroup)\n  \n  \n  # если нет оставшихся данных, выдать NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  if (agegroup == \"malaria_tot\") {\n      agegroup_title &lt;- \"All ages\"\n  } else {\n    agegroup_title &lt;- stringr::str_glue(\"{str_remove(agegroup, 'malaria_rdt')} years\")\n  }\n  \n  \n  ggplot(data, aes(x = data_date, y = cases_reported)) +\n    geom_col(width = 1, fill = \"darkred\") +\n    theme_minimal() +\n    labs(\n      x = \"date\",\n      y = \"number of cases\",\n      title = stringr::str_glue(\"Malaria cases - {plot_title_district}\"),\n      subtitle = agegroup_title\n    )\n  \n  \n  \n}\n\nВсе легко! Замечательное свойство shiny в том, что оно может понять, для чего нужны файлы с именами app.R, server.R, ui.R, и global.R, поэтому нет необходимости каждый раз их связывать между собой с помощью кода. Поэтому просто если у нас есть этот код в global.R в директории, он будет выполнен до запуска приложения!.\nСледует также отметить, что для улучшения организации нашего приложения было бы полезно перенести функцию построения в отдельный файл - это будет особенно полезно при увеличении размера приложений. Чтобы это сделать, мы можем создать еще одну директорию под названием funcs и разместить эту функцию как файл под названием plot_epicurve.R. Мы затем можем прочитать эту функцию с помощью следующей команды в global.R\n\nsource(here(\"funcs\", \"plot_epicurve.R\"), local = TRUE)\n\nОбратите внимание, что нужно всегда уточнять local = TRUE в приложениях shiny, поскольку это влияет на вызов, если приложение будет опубликовано на сервере.",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Информационные панели с Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.ru.html#разработка-сервера-приложения",
    "href": "new_pages/shiny_basics.ru.html#разработка-сервера-приложения",
    "title": "43  Информационные панели с Shiny",
    "section": "43.5 Разработка сервера приложения",
    "text": "43.5 Разработка сервера приложения\nТеперь, когда у нас есть большая часть кода, нам осталось разработать наш сервер. Это последняя часть нашего приложения, и, вероятно, самая сложная для понимания. Сервер представляет собой большую функцию R, но полезно представить его как серию более мелких функций или задач, которые может выполнять приложение. Важно понимать, что эти функции не выполняются в линейном порядке. Они выполняются в определенном порядке, но это не обязательно понимать в начале работы с shiny. На самом базовом уровне эти задачи или функции активизируются при изменении пользовательского ввода, который влияет на них, кроме случаев, когда разработчик задал для них другое поведение. Опять же, это все весьма абстрактно, но сначала давайте разберем три базовых типа объектов shiny.\n\nРеагирующие источники - это еще один термин для пользовательских вводов. Сервер shiny имеет доступ к выходным данным из UI через виджеты, которые мы запрограммировали. Каждый раз, когда меняются значения в них, это передается на сервер.\nРеагирующие проводники - это объекты, которые существуют только внутри сервера shiny. Нам они не нужны для простых приложений, но они создают объекты, которые могут быть видны только внутри сервера и используются в других операциях. Они, как правило, зависят от реагирующих источниках.\nКонечные точки - это выходные данные, которые передаются от сервера на пользовательский интерфейс (UI). В нашем примере это будет эпидкривая, которую мы создаем.\n\nПомня об этом давайте построим наш сервер шаг за шагом. Мы покажем снова наш код UI для справки:\n\nui &lt;- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # селектор района\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = c(\n                   \"All\",\n                   \"Spring\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selected = \"All\",\n              multiple = TRUE\n         ),\n         # селектор возрастной группы\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         )\n\n    ),\n\n    mainPanel(\n      # эпидкривая сюда\n      plotOutput(\"malaria_epicurve\")\n    )\n    \n  )\n)\n\nИз этого кода UI у нас есть:\n\nдва входа:\n\nСелектор района (с inputId select_district)\nСелектор возрастной группы (с inputId select_agegroup)\n\nодин выход:\n\nЭпидкривая (с outputId malaria_epicurve)\n\n\nКак указывалось ранее эти уникальные имена, которые мы присвоили входам и выходам. Они должны быть уникальными и использоваться для передачи информации между ui и сервером. На нашем сервере мы получаем доступ к нашим входам через синтез input$inputID, а выходы передаются в ui через синтаксис output$output_name. Давайте рассмотрим пример, потому что иначе это сложно понять!\n\nserver &lt;- function(input, output, session) {\n  \n  output$malaria_epicurve &lt;- renderPlot(\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  )\n  \n}\n\nСервер для такого простого приложения на самом деле довольно прост! Вы заметите, что сервер представляет собой функцию с тремя параметрами - input, output и session - пока это не столь важно понимать, но важно придерживаться этой настройки! На нашем сервере у нас только одна задача - сформировать график на основе функции, которую мы создали раньше и входов с сервера. Обратите внимание, что имена объектов входа и вывода совершенно точно совпадают с теми, которые указаны в ui.\nЧтобы понять основы того, как сервер реагирует на вводимые пользователем данные, следует отметить, что вывод будет знать (через базовый пакет), когда изменяются вводимые данные, и повторно запускать эту функцию для создания графика каждый раз, когда они изменяются. Обратите внимание, что мы также используем функцию renderPlot() - это одна из семейства функций, относящихся к определенному классу и передающих эти объекты на вывод ui. Существует ряд функций, которые ведут себя аналогичным образом, но необходимо убедиться, что используемая функция соответствует классу объекта, который вы передаете в ui! Например:\n\nrenderText() - направляет текст в ui\nrenderDataTable - направляет интерактивную таблицу в ui.\n\nПомните, что они также должны соответствовать функции вывода, используемой в ui - так что renderPlot() идет в паре с plotOutput(), а renderText() - с textOutput().\nИтак, мы наконец-то создали работающее приложение! Мы можем запустить его, нажав кнопку Run App в правом верхнем углу окна скрипта в Rstudio. Следует отметить, что можно выбрать запуск приложения в браузере по умолчанию (а не в Rstudio), что более точно отразит то, как приложение будет выглядеть для других пользователей.\n\n\n\n\n\n\n\n\n\nЛюбопытно отметить, что в консоли R написано так, будто приложение “слушает! Вот это реагирование!",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Информационные панели с Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.ru.html#добавление-функционала",
    "href": "new_pages/shiny_basics.ru.html#добавление-функционала",
    "title": "43  Информационные панели с Shiny",
    "section": "43.6 Добавление функционала",
    "text": "43.6 Добавление функционала\nНа данный момент у нас есть работающее приложение, но его функциональность очень мала. Кроме того, мы еще и не коснулись всего, на что способен shiny, так что нам еще многое предстоит узнать! Давайте продолжим развивать наше приложение, добавляя в него дополнительные возможности. Неплохо было бы добавить следующие вещи:\n\nНекоторый пояснительный текст\nКнопку скачивания для нашего графика - это даст пользователю возможность использовать высококачественную версию изображения, которое генерирует приложение\nСелектор медицинских организаций\nЕще одну страницу информационной панели - это может показать таблицу наших данных.\n\nМы добавим много нового, но с помощью этого мы сможем узнать о множестве различных функций shiny. О shiny можно узнать очень многое (оно может быть очень продвинутым, но есть надежда, что после того, как пользователи получат представление о том, как его использовать, они смогут более комфортно использовать и внешние источники обучения).\n\nДобавление статического текста\nСначала поговорим о добавлении статического текста в наше приложение shiny. Добавление текста в наше приложение очень просто, если иметь базовое представление о нем. Поскольку статический текст не изменяется в приложении shiny (если вы хотите, чтобы он изменялся, вы можете использовать функции рендеринга текста на сервере!), весь статический текст в shiny обычно добавляется в ui приложения. Мы не будем останавливаться на этом подробно, но вы можете добавить в свой ui множество различных элементов (и даже пользовательских), взаимодействуя с R и HTML и css.\nHTML и css - языки, которые явно вовлечены в дизайн интерфейса пользователя. Нам не обязательно в этом хорошо разбираться, но HTML создает объекты в UI (как текстовое поле или таблица), а css, как правило, используется для изменения стиля и эстетики этих объектов. У Shiny есть доступ к широкому спектру тэгов HTML - они присутствуют для объектов, которые ведут себя определенным образом, например, заголовки, абзацы текста, переносы строк, таблицы и т.д. Мы можем использовать некоторые из этих примеров следующим образом:\n\nh1() - это тэг заголовка, который автоматически увеличит размер вложенного текста, а также изменит настройки по умолчанию в отношении начертания шрифта, цвета и т.д. (в зависимости от общей тематики приложения). Вы можете получить доступ к все меньшим и меньшим подзаголовкам с помощью h2() до h6(). Применение выглядит следующим образом:\n\nh1(\"my header - section 1\")\n\np() - это тэг абзаца, который сделает вложенный текст похожим на текст в теле текста. Этот текст будет автоматически обернут и будет иметь относительно небольшой размер (например, колонтитулы могут быть меньше). Использование выглядит следующим образом:\n\np(\"This is a larger body of text where I am explaining the function of my app\")\n\ntags$b() и tags$i() - используются для создания жирного шрифта tags$b() и курсива tags$i() применительно к тексту, который в них заключен!\ntags$ul(), tags$ol() и tags$li() - это тэги, используемые для создания списков. Их используют в синтаксисе ниже, они позволяют пользователю создать либо упорядоченный список (tags$ol(); т.е. нумерованный), либо неупорядоченный список (tags$ul(), т.е. маркированный список). tags$li() используется для обозначения пунктов в списке вне зависимости от типа используемого списка. например:\n\n\ntags$ol(\n  \n  tags$li(\"Item 1\"),\n  \n  tags$li(\"Item 2\"),\n  \n  tags$li(\"Item 3\")\n  \n)\n\n\nbr() и hr() - эти тэги создают разрывы линий и горизонтальные линии (с разрывом), соответственно. Используйте их, чтобы разделить разделы вашего приложения и текста! There is no need to pass any items to these tags (parentheses can remain empty).\ndiv() - это общий тэг, который может содержать что угодно, и может быть назван как угодно. Как только вы добьетесь прогресса в дизайне ui, вы можете использовать его для компартментализации вашего пользовательского интерфейса (ui), задавать отдельным разделам конкретные стили, а также создавать взаимодействие между сервером и элементами UI. Мы не будем углубляться в это, но об этом стоит знать!\n\nОбратите внимание, что к каждому из этих объектов можно получить доступ через tags$... или для некоторых просто через функцию. По факту это одно и то же, но может быть полезно использовать стиль tags$..., если вы хотите показывать все более конкретно и случайно не записать что-то поверх функции. Это не исчерпывающий список всех имеющихся тэгов. Полный лист тэгов, доступных в shiny, есть тут, и многие можно использовать путем вставки HTML напрямую в ваш ui!\nЕсли вы чувствуете уверенность, вы можете добавить любые элементы стилизации css в ваши тэги HTML с помощью аргумента style в любом из них. Мы не будем углубляться в то, как это работает, но один из советов для тестирования эстетических изменений пользовательского интерфейса - использовать режим HTML-инспектора в chrome (в вашем shiny-приложении, которое вы запускаете в браузере) и самостоятельно редактировать стиль объектов!\nДавайте добавим текст в приложение\n\nui &lt;- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         h4(\"Options\"),\n         # селектор района\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = c(\n                   \"All\",\n                   \"Spring\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selected = \"All\",\n              multiple = TRUE\n         ),\n         # селектор возрастной группы\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         ),\n    ),\n\n    mainPanel(\n      # эпидкривая здесь\n      plotOutput(\"malaria_epicurve\"),\n      br(),\n      hr(),\n      p(\"Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:\"),\n    tags$ul(\n      tags$li(tags$b(\"location_name\"), \" - the facility that the data were collected at\"),\n      tags$li(tags$b(\"data_date\"), \" - the date the data were collected at\"),\n      tags$li(tags$b(\"submitted_daate\"), \" - the date the data were submitted at\"),\n      tags$li(tags$b(\"Province\"), \" - the province the data were collected at (all 'North' for this dataset)\"),\n      tags$li(tags$b(\"District\"), \" - the district the data were collected at\"),\n      tags$li(tags$b(\"age_group\"), \" - the age group the data were collected for (0-5, 5-14, 15+, and all ages)\"),\n      tags$li(tags$b(\"cases_reported\"), \" - the number of cases reported for the facility/age group on the given date\")\n    )\n    \n  )\n)\n)\n\n\n\n\n\n\n\n\n\n\n\n\nДобавление ссылки\nЧтобы добавить ссылку на веб-сайт, используйте tags$a() со ссылкой и отобразите текст, как показано ниже. Чтобы был отдельный абзац, поместите внутри p(). Чтобы сделать ссылку из нескольких слов предложения, разбейте приложения на части и используйте для гипертекстовой части tags$a(). Чтобы убедиться, что ссылка откроется в новом окне браузера, добавьте target = \"_blank\" в качестве аргумента.\n\ntags$a(href = \"www.epiRhandbook.com\", \"Visit our website!\")\n\n\n\nДобавление кнопки скачивания\nПерейдем ко второй из трех функций. Кнопка загрузки - это довольно распространенная вещь, которую можно добавить в приложение, и сделать ее довольно просто. Нам нужно добавить еще один виджет в наш ui и добавить еще один выход на наш сервер для подключения к нему. Мы таже можем ввести реагирующие проводники в этом примере!\nСначала обновим наш ui - это легко, поскольку у shiny есть виджет под названием downloadButton() - давайте зададим для него inputId и подпись.\n\nui &lt;- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # селектор района\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = c(\n                   \"All\",\n                   \"Spring\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selected = \"All\",\n              multiple = FALSE\n         ),\n         # селектор возрастной группы\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         ),\n         # горизонтальная линия\n         hr(),\n         downloadButton(\n           outputId = \"download_epicurve\",\n           label = \"Download plot\"\n         )\n\n    ),\n\n    mainPanel(\n      # эпидкривая сюда\n      plotOutput(\"malaria_epicurve\"),\n      br(),\n      hr(),\n      p(\"Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:\"),\n      tags$ul(\n        tags$li(tags$b(\"location_name\"), \" - the facility that the data were collected at\"),\n        tags$li(tags$b(\"data_date\"), \" - the date the data were collected at\"),\n        tags$li(tags$b(\"submitted_daate\"), \" - the date the data were submitted at\"),\n        tags$li(tags$b(\"Province\"), \" - the province the data were collected at (all 'North' for this dataset)\"),\n        tags$li(tags$b(\"District\"), \" - the district the data were collected at\"),\n        tags$li(tags$b(\"age_group\"), \" - the age group the data were collected for (0-5, 5-14, 15+, and all ages)\"),\n        tags$li(tags$b(\"cases_reported\"), \" - the number of cases reported for the facility/age group on the given date\")\n      )\n      \n    )\n    \n  )\n)\n\nОбратите внимание, что мы также добавили тэг hr() - он добавляет горизонтальную линию, разделяющую виджеты контроля от виджетов скачивания. Это еще один из тэгов HTML, которые мы обсуждали выше.\nТеперь, когда готов наш ui, нам нужно добавить серверный компонент. Скачивания выполняются на сервере с помощью функции downloadHandler(). Аналогично нашему графику, нам нужно прикрепить ее к выходу, который имеет тот же inputId, что и кнопка загрузки. Эта функция принимает два аргумента - filename и content - оба этих аргумента являются функциями. Как вы могли догадаться, filename используется, чтобы уточнить имя скачиваемого файла, а content используется для уточнения того, что нужно скачать. content содержит функцию, которую можно использовать для локального сохранения данных - так, если вы загружаете файл csv, вы можете использовать rio::export(). Поскольку мы скачиваем график, мы будем использовать ggplot2::ggsave(). Давайте посмотрим, как нам это запрограммировать (мы пока еще не добавляем это на сервер).\n\nserver &lt;- function(input, output, session) {\n  \n  output$malaria_epicurve &lt;- renderPlot(\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  )\n  \n  output$download_epicurve &lt;- downloadHandler(\n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n}\n\nОбратите внимание, что функция content всегда принимает аргумент file, который мы размещаем там, где указывается имя выходного файла. Вы можете также заметить, что мы здесь повторям код - мы используем функцию plot_epicurve() дважды на этом сервере, один раз для скачивания и один - для изображения, которое отображается в приложении. Хотя это не сильно влияет на производительность, это означает, что код для генерации этого графика придется запускать, когда пользователь меняет виджеты, указывающие район и возрастную группу, а также снова, когда вы хотите скачать график. В больших приложениях неоптимальные решения, подобные этому, будут все больше и больше замедлять работу, поэтому полезно узнать, как сделать наше приложение более эффективным в этом смысле. Что было бы более логично, так это иметь возможность запускать код для эпидкривой при изменении районов/возрастных групп, и использовать его для функций renderPlot() и downloadHandler(). Вот зачем нужны реагирующие проводники!\nРеагирующие проводники - объекты, которые создаются на сервере shiny реагирующим образом, но они не идут в выходные данные - они просто используются другими частями сервера. Существует ряд разных типов реагирующих проводников, но мы разберем два основных.\n1.reactive() - это наиболее простой реагирующий проводник - он будет реагировать, когда любые входы внутри него меняются (то есть наши виджеты групп района/возраста)\n2. eventReactive()- это реагирующий проводник, который работает так же, как reactive(), но еще пользователь может задать, какие входные данные заставляют его выдавать результат. Это полезно, если реагирующий проводник требует большого времени обработки, но более подробно мы объясним позже.\nДавайте рассмотрим два примера:\n\nmalaria_plot_r &lt;- reactive({\n  \n  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  \n})\n\n\n# выполняется только при изменении селектора районов!\nmalaria_plot_er &lt;- eventReactive(input$select_district, {\n  \n  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  \n})\n\nКогда мы используем eventReactive(), мы можем уточнить, какие входные данные вызовут выполнение этого фрагмента кода - это пока нам не очень полезно, поэтому пока мы это пропустим. Обратите внимание, что несколько входов нужно указывать с помощью c()\nДавайте посмотрим, как интегрировать это в наш код сервера:\n\nserver &lt;- function(input, output, session) {\n  \n  malaria_plot &lt;- reactive({\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  })\n  \n  \n  \n  output$malaria_epicurve &lt;- renderPlot(\n    malaria_plot()\n  )\n  \n  output$download_epicurve &lt;- downloadHandler(\n    \n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             malaria_plot(),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n}\n\nВидно, что мы просто обращаемся к выводу реагирующей функции, который мы определили в функциях загрузки и создания графика. Следует отметить один момент, который часто ставит людей в тупик: необходимо использовать выходы реагирующих проводников так, как если бы они были функциями - то есть нужно добавлять пустые скобки в конце них (т.е. malaria_plot() будет правильным, а malaria_plot - нет). Теперь, когда мы добавили это решение, наше приложение стало немного аккуратнее, быстрее и легче поддается изменениям, поскольку весь наш код, выполняющий функцию для эпидкривой, находится в одном месте.\n\n\n\n\n\n\n\n\n\n\n\nДобавление селектора медицинских организаций\nПерейдем к следующему элементу - селектору для конкретных организаций. Мы внедрим в нашу функцию еще один параметр, чтобы иметь возможность передавать его в качестве аргумента из нашего кода. Сначала посмотрим, как это сделать - он работает по тем же принципам, что и другие параметры, которые мы задали. Обновим и протестируем нашу функцию.\n\nplot_epicurve &lt;- function(data, district = \"All\", agegroup = \"malaria_tot\", facility = \"All\") {\n  \n  if (!(\"All\" %in% district)) {\n    data &lt;- data %&gt;%\n      filter(District %in% district)\n    \n    plot_title_district &lt;- stringr::str_glue(\"{paste0(district, collapse = ', ')} districts\")\n    \n  } else {\n    \n    plot_title_district &lt;- \"all districts\"\n    \n  }\n  \n  # если нет оставшихся данных, выдать NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  data &lt;- data %&gt;%\n    filter(age_group == agegroup)\n  \n  \n  # если нет оставшихся данных, выдать NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  if (agegroup == \"malaria_tot\") {\n      agegroup_title &lt;- \"All ages\"\n  } else {\n    agegroup_title &lt;- stringr::str_glue(\"{str_remove(agegroup, 'malaria_rdt')} years\")\n  }\n  \n    if (!(\"All\" %in% facility)) {\n    data &lt;- data %&gt;%\n      filter(location_name == facility)\n    \n    plot_title_facility &lt;- facility\n    \n  } else {\n    \n    plot_title_facility &lt;- \"all facilities\"\n    \n  }\n  \n  # если нет оставшихся данных, выдать NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n\n  \n  \n  ggplot(data, aes(x = data_date, y = cases_reported)) +\n    geom_col(width = 1, fill = \"darkred\") +\n    theme_minimal() +\n    labs(\n      x = \"date\",\n      y = \"number of cases\",\n      title = stringr::str_glue(\"Malaria cases - {plot_title_district}; {plot_title_facility}\"),\n      subtitle = agegroup_title\n    )\n  \n  \n  \n}\n\nдавайте протестируем:\n\nplot_epicurve(malaria_data, district = \"Spring\", agegroup = \"malaria_rdt_0-4\", facility = \"Facility 1\")\n\n\n\n\n\n\n\n\nПри наличии всех учреждений в наших данных не очень понятно, какие учреждения соответствуют тем или иным районам, и конечный пользователь тоже этого не знает. Это может сделать работу с приложением довольно неудобной. По этой причине мы должны сделать так, чтобы варианты объектов в пользовательском интерфейсе динамически менялись при смене района - таким образом, одно фильтрует другое! Поскольку у нас так много переменных, которые мы используем в опциях, мы также можем захотеть сгенерировать некоторые опции для пользовательского интерфейса в файле global.R из данных. Например, мы можем добавить этот фрагмент кода в global.R после того, как мы прочитали наши данные:\n\nall_districts &lt;- c(\"All\", unique(malaria_data$District))\n\n# датафрейм имен местности по районам\nfacility_list &lt;- malaria_data %&gt;%\n  group_by(location_name, District) %&gt;%\n  summarise() %&gt;% \n  ungroup()\n\nДавайте взглянем на них:\n\nall_districts\n\n[1] \"All\"     \"Spring\"  \"Bolo\"    \"Dingo\"   \"Barnard\"\n\n\n\nfacility_list\n\n# A tibble: 65 × 2\n   location_name District\n   &lt;chr&gt;         &lt;chr&gt;   \n 1 Facility 1    Spring  \n 2 Facility 10   Bolo    \n 3 Facility 11   Spring  \n 4 Facility 12   Dingo   \n 5 Facility 13   Bolo    \n 6 Facility 14   Dingo   \n 7 Facility 15   Barnard \n 8 Facility 16   Barnard \n 9 Facility 17   Barnard \n10 Facility 18   Bolo    \n# ℹ 55 more rows\n\n\nМы можем передать эти новые переменные в ui без проблем, поскольку они глобально видимы и серверу, и ui! Давайте обновим UI:\n\nui &lt;- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # селектор района\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = all_districts,\n              selected = \"All\",\n              multiple = FALSE\n         ),\n         # селектор возрастной группы\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         ),\n         # селектор организации\n         selectInput(\n           inputId = \"select_facility\",\n           label = \"Select Facility\",\n           choices = c(\"All\", facility_list$location_name),\n           selected = \"All\"\n         ),\n         \n         # горизонтальная линия\n         hr(),\n         downloadButton(\n           outputId = \"download_epicurve\",\n           label = \"Download plot\"\n         )\n\n    ),\n\n    mainPanel(\n      # эпидкривая сюда\n      plotOutput(\"malaria_epicurve\"),\n      br(),\n      hr(),\n      p(\"Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:\"),\n      tags$ul(\n        tags$li(tags$b(\"location_name\"), \" - the facility that the data were collected at\"),\n        tags$li(tags$b(\"data_date\"), \" - the date the data were collected at\"),\n        tags$li(tags$b(\"submitted_daate\"), \" - the date the data were submitted at\"),\n        tags$li(tags$b(\"Province\"), \" - the province the data were collected at (all 'North' for this dataset)\"),\n        tags$li(tags$b(\"District\"), \" - the district the data were collected at\"),\n        tags$li(tags$b(\"age_group\"), \" - the age group the data were collected for (0-5, 5-14, 15+, and all ages)\"),\n        tags$li(tags$b(\"cases_reported\"), \" - the number of cases reported for the facility/age group on the given date\")\n      )\n      \n    )\n    \n  )\n)\n\nОбратите внимание, что теперь мы передаем переменные для выбора вместо того, чтобы жестко кодировать их в ui! Это также может сделать наш код более компактным! Наконец, нам нужно будет обновить сервер. Обновить нашу функцию для включения новых входных данных несложно (достаточно передать их в качестве аргумента новому параметру), но не стоит забывать, что мы также хотим, чтобы пользовательский интерфейс динамически обновлялся, когда пользователь меняет выбранный район. Важно понимать, что мы можем изменить параметры и поведение виджетов, когда приложение запущено, но это надо сделать на сервере. Нам нужно разобраться в новом способе вывода на сервер, чтобы это сделать.\nФункции, в которых нам нужно для этого разобраться, называются функции наблюдателя, они похожи на реагирующие функции в том, как они себя ведут. Но есть одно ключевое отличие:\n\nРеагирующие функции не влияют на выходные данные напрямую и создают объекты, которые можно увидеть в других местах сервера\nФункции наблюдателя могут повлиять на выходные данные с сервера, но через побочные эффекты других функций. (Они могут быть использованы и для других целей, но это их основная практическая функция)\n\nАналогично реагирующим функциям существует два типа функций наблюдателя, они делятся по той же логике, по которой делятся реагирующие функции:\n\nobserve() - эта функция выполняется, когда меняются любые входы внутри нее\nobserveEvent() - эта функция выполняется, когда меняется заданный пользователем вход\n\nНам также нужно понять функции shiny, которые обновляют виджеты. Их достаточно просто выполнять - сначала они берут объект session из функции сервера (это пока не обязательно понимать), а затем inputId функции, которую нужно менять. Мы затем передаем новые версии всех параметров, которые уже взяты selectInput() - они будут автоматически обновлены в виджете.\nРассмотрим отдельный пример того, как мы можем использовать это в нашем сервере. Когда пользователь меняет район, мы хотим отфильтровать нашу таблицу объектов по району и обновить варианты так, чтобы они отражали только те, которые доступны в этом районе (и опцию для всех учреждений)\n\nobserve({\n  \n  if (input$select_district == \"All\") {\n    new_choices &lt;- facility_list$location_name\n  } else {\n    new_choices &lt;- facility_list %&gt;%\n      filter(District == input$select_district) %&gt;%\n      pull(location_name)\n  }\n  \n  new_choices &lt;- c(\"All\", new_choices)\n  \n  updateSelectInput(session, inputId = \"select_facility\",\n                    choices = new_choices)\n  \n})\n\nИ все! Мы можем это добавить на наш сервер и такое поведение теперь сработает Вот как должен выглядеть наш новый сервер:\n\nserver &lt;- function(input, output, session) {\n  \n  malaria_plot &lt;- reactive({\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)\n  })\n  \n  \n  \n  observe({\n    \n    if (input$select_district == \"All\") {\n      new_choices &lt;- facility_list$location_name\n    } else {\n      new_choices &lt;- facility_list %&gt;%\n        filter(District == input$select_district) %&gt;%\n        pull(location_name)\n    }\n    \n    new_choices &lt;- c(\"All\", new_choices)\n    \n    updateSelectInput(session, inputId = \"select_facility\",\n                      choices = new_choices)\n    \n  })\n  \n  \n  output$malaria_epicurve &lt;- renderPlot(\n    malaria_plot()\n  )\n  \n  output$download_epicurve &lt;- downloadHandler(\n    \n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             malaria_plot(),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n  \n  \n}\n\n\n\n\n\n\n\n\n\n\n\n\nДобавление еще одной вкладки с таблицей\nТеперь перейдем к последнему компоненту, который мы хотим добавить в наше приложение. Мы хотим разделить наш пользовательский интерфейс на две вкладки, одна из которых будет содержать интерактивную таблицу, в которой пользователь сможет увидеть данные, на основе которых он строит эпидемическую кривую. Для этого мы можем использовать упакованные элементы ui, которые идут в комплекте с shiny, относящимися к вкладкам. На базовом уровне мы можем заключить большую часть нашей основной панели в такую общую структуру:\n\n# ... вся остальная часть ui\n\nmainPanel(\n  \n  tabsetPanel(\n    type = \"tabs\",\n    tabPanel(\n      \"Epidemic Curves\",\n      ...\n    ),\n    tabPanel(\n      \"Data\",\n      ...\n    )\n  )\n)\n\nПрименим это к нашему ui. Нам также нужно использовать здесь пакет DT - это замечательный пакет для создания интерактивных таблиц из существующих данных. Мы видим, как он используется для DT::datatableOutput() в этом примере.\n\nui &lt;- fluidPage(\n     \n     titlePanel(\"Malaria facility visualisation app\"),\n     \n     sidebarLayout(\n          \n          sidebarPanel(\n               # селектор района\n               selectInput(\n                    inputId = \"select_district\",\n                    label = \"Select district\",\n                    choices = all_districts,\n                    selected = \"All\",\n                    multiple = FALSE\n               ),\n               # селектор возрастной группы\n               selectInput(\n                    inputId = \"select_agegroup\",\n                    label = \"Select age group\",\n                    choices = c(\n                         \"All ages\" = \"malaria_tot\",\n                         \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                         \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                         \"15+ yrs\" = \"malaria_rdt_15\"\n                    ), \n                    selected = \"All\",\n                    multiple = FALSE\n               ),\n               # селектор организации\n               selectInput(\n                    inputId = \"select_facility\",\n                    label = \"Select Facility\",\n                    choices = c(\"All\", facility_list$location_name),\n                    selected = \"All\"\n               ),\n               \n               # горизонтальная линия\n               hr(),\n               downloadButton(\n                    outputId = \"download_epicurve\",\n                    label = \"Download plot\"\n               )\n               \n          ),\n          \n          mainPanel(\n               tabsetPanel(\n                    type = \"tabs\",\n                    tabPanel(\n                         \"Epidemic Curves\",\n                         plotOutput(\"malaria_epicurve\")\n                    ),\n                    tabPanel(\n                         \"Data\",\n                         DT::dataTableOutput(\"raw_data\")\n                    )\n               ),\n               br(),\n               hr(),\n               p(\"Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:\"),\n               tags$ul(\n                    tags$li(tags$b(\"location_name\"), \" - the facility that the data were collected at\"),\n                    tags$li(tags$b(\"data_date\"), \" - the date the data were collected at\"),\n                    tags$li(tags$b(\"submitted_daate\"), \" - the date the data were submitted at\"),\n                    tags$li(tags$b(\"Province\"), \" - the province the data were collected at (all 'North' for this dataset)\"),\n                    tags$li(tags$b(\"District\"), \" - the district the data were collected at\"),\n                    tags$li(tags$b(\"age_group\"), \" - the age group the data were collected for (0-5, 5-14, 15+, and all ages)\"),\n                    tags$li(tags$b(\"cases_reported\"), \" - the number of cases reported for the facility/age group on the given date\")\n               )\n               \n               \n          )\n     )\n)\n\nТеперь наше приложение структурировано по вкладкам! Давайте внесем необходимые правки на сервере. Поскольку нам не нужны манипуляции с набором данных до его обработки, все будет очень просто - мы просто обрабатываем набор данных malaria_data через DT::renderDT() в ui!\n\nserver &lt;- function(input, output, session) {\n  \n  malaria_plot &lt;- reactive({\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)\n  })\n  \n  \n  \n  observe({\n    \n    if (input$select_district == \"All\") {\n      new_choices &lt;- facility_list$location_name\n    } else {\n      new_choices &lt;- facility_list %&gt;%\n        filter(District == input$select_district) %&gt;%\n        pull(location_name)\n    }\n    \n    new_choices &lt;- c(\"All\", new_choices)\n    \n    updateSelectInput(session, inputId = \"select_facility\",\n                      choices = new_choices)\n    \n  })\n  \n  \n  output$malaria_epicurve &lt;- renderPlot(\n    malaria_plot()\n  )\n  \n  output$download_epicurve &lt;- downloadHandler(\n    \n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             malaria_plot(),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n  # обработка таблицы данных в ui\n  output$raw_data &lt;- DT::renderDT(\n    malaria_data\n  )\n  \n  \n}",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Информационные панели с Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.ru.html#предоставление-доступа-к-приложениям-shiny",
    "href": "new_pages/shiny_basics.ru.html#предоставление-доступа-к-приложениям-shiny",
    "title": "43  Информационные панели с Shiny",
    "section": "43.7 Предоставление доступа к приложениям shiny",
    "text": "43.7 Предоставление доступа к приложениям shiny\nТеперь, когда вы разработали свое приложение, вы наверняка хотите поделиться им с другими - ведь это главное преимущество shiny! Для этого можно поделиться кодом напрямую, а можно опубликовать его на сервере. Если мы поделимся кодом, другие смогут увидеть то, что вы сделали, и использовать это, но это сводит на нет одно из главных преимуществ shiny - оно может устранить необходимость для конечных пользователей пользоваться R. По этой причине, если вы делитесь своим приложением с пользователями, не имеющими опыта работы с R, гораздо проще поделиться приложением, опубликованным на сервере.\nЕсли вы предпочитаете поделиться кодом, вы должны создать файл .zip file с приложением, а еще лучше опубликовать ваше приложение на github и добавить совместно работающих людей. См. дополнительную информацию в разделе по github.\nОднако если мы публикуем приложение в Интернете, то нам необходимо проделать немного больше работы. В конечном итоге мы хотим, чтобы доступ к вашему приложению можно было получить по URL-адресу в Интернете, чтобы другие пользователи могли быстро и легко получить доступ к нему. К сожалению, чтобы опубликовать приложение на сервере, необходимо иметь доступ к серверу, на котором оно будет опубликовано! Для этого существует несколько вариантов хостинга:\n\nshinyapps.io: Это самое простое место для публикации приложений shiny, поскольку оно требует наименьшего объема работ по настройке и имеет несколько бесплатных, но ограниченных лицензий.\nRStudio Connect: это гораздо более мощная версия R-сервера, которая может выполнять множество операций, включая публикацию приложений shiny. Однако он сложнее в использовании и не рекомендуется для начинающих пользователей.\n\nВ этом документе мы используем shinyapps.io, поскольку он проще для новых пользователей. Для начала можно создать бесплатную учетную запись - при необходимости предлагаются различные тарифные планы для серверных линий. Чем больше пользователей вы планируете иметь, тем дороже может быть ваш тарифный план, поэтому учитывайте этот момент. Если вы хотите создать что-то для небольшого круга пользователей, бесплатная лицензия может быть вполне подходящей, но для публичного приложения может потребоваться больше лицензий.\nПрежде всего мы должны убедиться, что наше приложение пригодно для публикации на сервере. В приложении необходимо перезапустить сессию R и убедиться, что оно запускается без дополнительного кода. Это важно, поскольку приложение, требующее загрузки пакетов или чтения данных, не определенных в коде приложения, не будет работать на сервере. Также обратите внимание, что в приложении не должно быть конкретных путей к файлам - они все будут недействительны в условиях сервера - использование пакета here очень хорошо решает эту проблему. Наконец, если вы читаете данные из источника, который требует авторизации пользователя, например, с сервера вашей организации, как правило, это не будет работать на сервере. Вам нужно будет поговорить с вашим ИТ департаментом, чтобы решить, как включить сервер shiny в белый список.\nрегистрация учетной записи\nКак только у вас будет учетная запись, вы можете найти на страницу токенов в Accounts. Здесь вам нужно добавить новый токен - он будет использован для размещения вашего приложения.\nОтсюда следует, что url вашей учетной записи будет отражать название вашего приложения - так что если ваше приложение называется my_app, в url будет записано xxx.io/my_app/. Внимательно выбирайте название вашего приложения! Теперь, когда все готово, нажмите кнопку разместить - в случае успеха приложение будет запущено на выбранном вами веб-url!\nчто-то о создании приложений в документах?",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Информационные панели с Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.ru.html#дополнительное-чтение",
    "href": "new_pages/shiny_basics.ru.html#дополнительное-чтение",
    "title": "43  Информационные панели с Shiny",
    "section": "43.8 Дополнительное чтение",
    "text": "43.8 Дополнительное чтение\nДо сих пор мы рассмотрели множество аспектов работы с shiny и лишь слегка коснулись того, что предлагает shiny. Хотя это руководство служит введением, для полного понимания shiny необходимо узнать еще много нового. Вам следует начать создавать приложения и постепенно добавлять все больше и больше функциональности.",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Информационные панели с Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.ru.html#рекомендованные-пакеты-для-расширения",
    "href": "new_pages/shiny_basics.ru.html#рекомендованные-пакеты-для-расширения",
    "title": "43  Информационные панели с Shiny",
    "section": "43.9 Рекомендованные пакеты для расширения",
    "text": "43.9 Рекомендованные пакеты для расширения\nНиже представлена подборка высококачественных расширений для shiny, которые помогут вам получить гораздо больше пользы от shiny. Список не в порядке приоритетности:\n\nshinyWidgets - этот пакет даст вам гораздо больше виджетов, которые вы можете использовать в приложении. Выполните shinyWidgets::shinyWidgetsGallery(), чтобы увидеть перечень доступных в этом пакете виджетов. См. примеры тут\nshinyjs - Это отличный пакет, позволяющий значительно расширить возможности shiny с помощью ряда javascript. Возможности применения этого пакета варьируются от очень простых до весьма продвинутых, но для начала лучше использовать его для простых манипуляций с интерфейсом, таких как скрытие/показ элементов или включение/выключение кнопок. Детали см. тут\nshinydashboard - Этот пакет значительно расширяет возможности использования пользовательского интерфейса в shiny, в частности, позволяет создавать сложные информационные панели с различными вариантами компоновки. См. подробнее тут\nshinydashboardPlus - дает еще больше свойств в структуре shinydashboard! См. детали тут\nshinythemes - изменения в схеме css по умолчанию для вашего приложения shiny с широким спектров предварительно настроенных шаблонов! См. детали тут\n\nСуществует также ряд пакетов, которые могут быть использованы для создания интерактивных выводов, совместимых с shiny.\n\nDT является наполовину интегрированным в базовый-shiny, но предоставляет отличный набор функций для создания интерактивных таблиц.\nplotly - это пакет для создания интерактивных графиков, которыми пользователь может манипулировать в приложении. Вы можете также конвертировать ваш график в интерактивные версии с помощью plotly::ggplotly()! В качестве альтернатив также замечательно подходят dygraphs и highcharter.",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Информационные панели с Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.ru.html#рекомендованные-источники",
    "href": "new_pages/shiny_basics.ru.html#рекомендованные-источники",
    "title": "43  Информационные панели с Shiny",
    "section": "43.10 Рекомендованные источники",
    "text": "43.10 Рекомендованные источники",
    "crumbs": [
      "Отчеты и информационные панели",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Информационные панели с Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.ru.html",
    "href": "new_pages/writing_functions.ru.html",
    "title": "44  Написание функций",
    "section": "",
    "text": "44.1 Подготовка",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Написание функций</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.ru.html#подготовка",
    "href": "new_pages/writing_functions.ru.html#подготовка",
    "title": "44  Написание функций",
    "section": "",
    "text": "Загрузка пакетов\nДанный фрагмент кода показывает загрузку пакетов, требуемых для анализа. В данном руководстве мы подчеркиваем использование p_load() из pacman, которая устанавливает пакет, если необходимо, и загружает его для использования. Вы можете также загрузить установленные пакеты с помощью library() из базового R. См. дополнительную информацию о пакетах R на странице Основы R.\n\n\nИмпорт данных\nМы импортируем набор данных о случаях из имитированной эпидемии Эболы. Если вы хотите скачать данные, чтобы выполнять шаги параллельно, см. инструкции на странице Скачивание руководства и данных. Набор данных импортируется с помощью функции import() из пакета rio. См. страницу Импорт и экспорт, где приводятся разные способы импорта данных.\nМы также используем в последней части этой страницы некоторые данные по гриппу H7N9 2013 года.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Написание функций</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.ru.html#функции",
    "href": "new_pages/writing_functions.ru.html#функции",
    "title": "44  Написание функций",
    "section": "44.2 Функции",
    "text": "44.2 Функции\nФункции полезны в программировании, так как позволяют сделать код проще для понимания, короче и менее подверженным ошибкам (при условии отсутствия ошибок в самой функции).\nЕсли вы дошли до этого руководства, значит, вы столкнулись с бесконечным количеством функций, поскольку в R каждая операция - это вызов функции, +, for, if, [, $, { …. Например x + y - это то же самое, что'+'(x, y)\nR - один из тех языков, которые предлагают наибольшие возможности для работы с функциями и предоставляют пользователю достаточно инструментов для их легкого написания. Мы не должны думать о функциях как о фиксированных на вершине или в конце цепочки программирования, R предлагает возможность использовать их как векторы и даже использовать их внутри других функций, списков…\nСуществует много очень продвинутых ресурсов по функциональному программированию, и мы приведем здесь лишь краткие практические примеры, которые помогут вам начать знакомство с функциональным программированием. Для более подробного ознакомления с функциональным программированием мы предлагаем вам посетить ссылки на источники.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Написание функций</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.ru.html#зачем-использовать-функцию",
    "href": "new_pages/writing_functions.ru.html#зачем-использовать-функцию",
    "title": "44  Написание функций",
    "section": "44.3 Зачем использовать функцию?",
    "text": "44.3 Зачем использовать функцию?\nПрежде чем ответить на этот вопрос, важно отметить, что вы уже получили советы по написанию своих первых функций на языке R на странице [Итерации, циклы и списки] данного руководства. На самом деле, использование “if/else” и циклов часто является ключевой частью многих наших функций, поскольку они позволяют легким образом расширить применение нашего кода, чтобы допускать несколько условий или проводить итерацию кода для повторяющихся задач.\n\nЯ повторяю несколько раз один и тот же блок кода, чтобы применить его к другой переменной или данным?\nИзбавление от него существенно сократит общий код и ускорит его выполнение?\nВозможно ли, что написанный мною код используется снова, но с другим значением во многих местах кода?\n\nЕсли ответ на один из предыдущих вопросов “ДА”, то, скорее всего, необходимо написать функцию",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Написание функций</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.ru.html#как-r-строит-функции",
    "href": "new_pages/writing_functions.ru.html#как-r-строит-функции",
    "title": "44  Написание функций",
    "section": "44.4 Как R строит функции?",
    "text": "44.4 Как R строит функции?\nФункции в R имеют три основных компонента:\n\nformals() - это список аргументов, которые контролируют то, как мы можем вызвать функцию\nbody() - код внутри функции, т.е. внутри квадратных скобок или после круглых скобок, смотря как мы его запишем\n\nи,\n\nenvironment(), который помогает найти переменные функции и определяет, как функция находит значение.\n\nКак только вы создали свою функцию, вы можете верифицировать каждый из этих компонентов, вызвав соответствующую функцию.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Написание функций</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.ru.html#базовый-синтаксис-и-структура",
    "href": "new_pages/writing_functions.ru.html#базовый-синтаксис-и-структура",
    "title": "44  Написание функций",
    "section": "44.5 Базовый синтаксис и структура",
    "text": "44.5 Базовый синтаксис и структура\n\nФункцию необходимо правильно назвать, чтобы ее работа была понятна сразу после прочтения ее имени. Собственно, так уже сделано в большинстве базовых архитектур R. Такие функции, как mean(), print(), summary() имеют очень понятные имена\nФункции потребуются аргументы, такие как данные, с которыми нужно работать, и другие объекты, которые могут быть статическими значениями, среди прочих опций\nИ, наконец, функция выдает результат, исходя из своей основной задачи и переданных ей аргументов. Обычно мы используем встроенные функции, такие как print(), return()… для создания выходных данных. Выходными данными могут быть логическое значение, число, текст, датафрейм…по сути, любой объект R.\n\nВот так выглядит состав функции:\n\nfunction_name &lt;- function(argument_1, argument_2, argument_3){\n  \n           function_task\n  \n           return(output)\n}\n\nМы можем создать нашу первую функцию, которую назовем contain_covid19().\n\ncontain_covid19 &lt;- function(barrier_gest, wear_mask, get_vaccine){\n  \n                            if(barrier_gest == \"yes\" & wear_mask == \"yes\" & get_vaccine == \"yes\" ) \n       \n                            return(\"success\")\n  \n  else(\"please make sure all are yes, this pandemic has to end!\")\n}\n\nМы можем затем верифицировать компоненты нашей новой созданной функции.\n\nformals(contain_covid19)\n\n$barrier_gest\n\n\n$wear_mask\n\n\n$get_vaccine\n\nbody(contain_covid19)\n\n{\n    if (barrier_gest == \"yes\" & wear_mask == \"yes\" & get_vaccine == \n        \"yes\") \n        return(\"success\")\n    else (\"please make sure all are yes, this pandemic has to end!\")\n}\n\nenvironment(contain_covid19)\n\n&lt;environment: R_GlobalEnv&gt;\n\n\nТеперь мы протестируем нашу функцию. Для вызова написанной нами функции необходимо использовать ее так же, как и все функции R, т.е. написать имя функции и добавить необходимые аргументы.\n\ncontain_covid19(barrier_gest = \"yes\", wear_mask = \"yes\", get_vaccine = \"yes\")\n\n[1] \"success\"\n\n\nДля надежности мы можем еще раз написать имя каждого аргумента. Но и без их указания код должен работать, поскольку R имеет в памяти расположение каждого аргумента. Поэтому, если значения аргументов расположены в правильном порядке, можно не писать имена аргументов при вызове функций.\n\ncontain_covid19(\"yes\", \"yes\", \"yes\")\n\n[1] \"success\"\n\n\nДалее посмотрим, что произойдет, если одно из значений \"no\" (нет) или не \"yes\" (да).\n\ncontain_covid19(barrier_gest = \"yes\", wear_mask = \"yes\", get_vaccine = \"no\")\n\n[1] \"please make sure all are yes, this pandemic has to end!\"\n\n\nЕсли мы зададим аргумент, который не распознан, мы получим ошибку:\n\ncontain_covid19(barrier_gest = \"sometimes\", wear_mask = \"yes\", get_vaccine = \"no\")\n\nError in contain_covid19(barrier_gest = \"sometimes\", wear_mask = \"yes\",  :    could not find function \"contain_covid19\"\nПРИМЕЧАНИЕ: Некоторые функции (в большинстве случаев очень короткие и простые) могут не требовать имени и могут использоваться напрямую в строке кода или внутри другой функции для выполнения быстрых задач. Их называют анонимные функции .\nНапример, ниже приведена первая анонимная функция, которая сохраняет только текстовые переменные в наборе данных.\n\nlinelist %&gt;% \n  dplyr::slice_head(n=10) %&gt;%  #эквивалентно функции из базового R \"head\", возвращает первые n наблюдений набора данных\n  select(function(x) is.character(x)) \n\n\n\n\n\n\n\nЗатем еще одна функция, которая выбирает каждое второе наблюдение из нашего набора данных (это может быть актуально, когда мы имеем продольные данные с большим количеством записей на пациента, например, после упорядочивания по дате или посещению). В этом случае подходящей функцией вне dplyr будет function (x) (x%%2 == 0), чтобы применить к вектору, содержащему все номера строк.\n\nlinelist %&gt;%   \n   slice_head(n=20) %&gt;% \n   tibble::rownames_to_column() %&gt;% # добавляем индексы каждого наблюдения как имена строк, чтобы четко видеть итоговый выбор\n   filter(row_number() %%2 == 0)\n\n\n\n\n\n\n\nВозможный код в базовом R для той же задачи может выглядеть так:\n\nlinelist_firstobs &lt;- head(linelist, 20)\n\nlinelist_firstobs[base::Filter(function(x) (x%%2 == 0), seq(nrow(linelist_firstobs))),]\n\n\n\n\n\n\n\nВНИМАНИЕ: Хотя использование функций действительно может помочь нам в работе с кодом, тем не менее написание некоторых функций или исправление одной из них, если она не была тщательно продумана, написана адекватно и в результате возвращает ошибки, может занять много времени. Поэтому часто рекомендуется сначала написать код на языке R, убедиться, что он выполняет то, что мы задумали, а затем преобразовать его в функцию, состоящую из трех основных компонентов, перечисленных выше.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Написание функций</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.ru.html#примеры",
    "href": "new_pages/writing_functions.ru.html#примеры",
    "title": "44  Написание функций",
    "section": "44.6 Примеры",
    "text": "44.6 Примеры\n\nВыдача таблиц долей для нескольких столбцов\nДа, во многих пакетах уже есть хорошие функции, позволяющие очень просто и красиво обобщать информацию. Но мы все же попробуем сделать свои собственные, в рамках наших первых шагов по освоению написания функций.\nВ этом примере мы хотим показать, как написание простой функции позволяет избежать многократного копирования одного и того же кода.\n\nproptab_multiple &lt;- function(my_data, var_to_tab){\n  \n  #печать имен каждой интересующей переменной перед табуляцией\n  print(var_to_tab)\n\n  with(my_data,\n       rbind( #связать результаты двух следующих функций по строкам\n        #табуляция интересующей переменной: дает только числа\n          table(my_data[[var_to_tab]], useNA = \"no\"),\n          #расчет долей для каждой интересующей переменной и округление значения до 2 знаков после запятой\n         round(prop.table(table(my_data[[var_to_tab]]))*100,2)\n         )\n       )\n}\n\n\nproptab_multiple(linelist, \"gender\")\n\n[1] \"gender\"\n\n\n           f       m\n[1,] 2807.00 2803.00\n[2,]   50.04   49.96\n\nproptab_multiple(linelist, \"age_cat\")\n\n[1] \"age_cat\"\n\n\n         0-4     5-9  10-14  15-19   20-29 30-49 50-69 70+\n[1,] 1095.00 1095.00 941.00 743.00 1073.00   754 95.00 6.0\n[2,]   18.87   18.87  16.22  12.81   18.49    13  1.64 0.1\n\nproptab_multiple(linelist, \"outcome\")\n\n[1] \"outcome\"\n\n\n       Death Recover\n[1,] 2582.00 1983.00\n[2,]   56.56   43.44\n\n\nСОВЕТ: Как было показано выше, очень важно комментировать свои функции так же, как это делается при общем программировании. Следует помнить, что цель функции - сделать код легко читаемым, более коротким и эффективным. Тогда можно понять, что делает функция, просто прочитав ее название, а более подробную информацию можно получить, прочитав комментарии.\nВторой вариант - использовать эту функцию внутри другой в цикле, чтобы провести процесс сразу:\n\nfor(var_to_tab in c(\"gender\",\"age_cat\",  \"outcome\")){\n  \n  print(proptab_multiple(linelist, var_to_tab))\n  \n}\n\n[1] \"gender\"\n           f       m\n[1,] 2807.00 2803.00\n[2,]   50.04   49.96\n[1] \"age_cat\"\n         0-4     5-9  10-14  15-19   20-29 30-49 50-69 70+\n[1,] 1095.00 1095.00 941.00 743.00 1073.00   754 95.00 6.0\n[2,]   18.87   18.87  16.22  12.81   18.49    13  1.64 0.1\n[1] \"outcome\"\n       Death Recover\n[1,] 2582.00 1983.00\n[2,]   56.56   43.44\n\n\nБолее простой способ - использование “apply” из базового R вместо “цикла for”, как выражено ниже:\nСОВЕТ: R часто определяется как функциональный язык программирования, и почти каждый раз, когда вы запускаете строку кода, вы используете некоторые встроенные функции. Хорошей привычкой для более комфортного написания функций является частое внутреннее рассмотрение того, как построены основные функции, которые вы используете ежедневно. Вы можете выбрать имя функции и затем использовать горячие клавиши Ctrl+F2 или fn+F2 или Cmd+F2 (в зависимости от вашего компьютера) .",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Написание функций</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.ru.html#использование-purrr-написание-функций-которые-могут-применяться-итеративно",
    "href": "new_pages/writing_functions.ru.html#использование-purrr-написание-функций-которые-могут-применяться-итеративно",
    "title": "44  Написание функций",
    "section": "44.7 Использование purrr: написание функций, которые могут применяться итеративно",
    "text": "44.7 Использование purrr: написание функций, которые могут применяться итеративно\n\nМодификация класса нескольких столбцов в наборе данных\nПредставим, что нужно поменять множество текстовых переменных в оригинальных данных linelist на класс “фактор” для анализа и построения графиков. Вместо того, чтобы повторять один шаг несколько раз, мы можем использовать lapply(), чтобы применить это преобразование ко всем нужным переменным в одной строке кода.\nВНИМАНИЕ: lapply() выдает список, поэтому может потребовать дополнительной модификации в качестве последнего шага.\nТот же шаг можно сделать с помощью функции map_if() из пакета purrr\n\nlinelist_factor2 &lt;- linelist %&gt;%\n  purrr::map_if(is.character, as.factor)\n\n\nlinelist_factor2 %&gt;%\n        glimpse()\n\nList of 30\n $ case_id             : Factor w/ 5888 levels \"00031d\",\"00086d\",..: 2134 3022 396 4203 3084 4347 179 1241 5594 430 ...\n $ generation          : num [1:5888] 4 4 2 3 3 3 4 4 4 4 ...\n $ date_infection      : Date[1:5888], format: \"2014-05-08\" NA ...\n $ date_onset          : Date[1:5888], format: \"2014-05-13\" \"2014-05-13\" ...\n $ date_hospitalisation: Date[1:5888], format: \"2014-05-15\" \"2014-05-14\" ...\n $ date_outcome        : Date[1:5888], format: NA \"2014-05-18\" ...\n $ outcome             : Factor w/ 2 levels \"Death\",\"Recover\": NA 2 2 NA 2 2 2 1 2 1 ...\n $ gender              : Factor w/ 2 levels \"f\",\"m\": 2 1 2 1 2 1 1 1 2 1 ...\n $ age                 : num [1:5888] 2 3 56 18 3 16 16 0 61 27 ...\n $ age_unit            : Factor w/ 2 levels \"months\",\"years\": 2 2 2 2 2 2 2 2 2 2 ...\n $ age_years           : num [1:5888] 2 3 56 18 3 16 16 0 61 27 ...\n $ age_cat             : Factor w/ 8 levels \"0-4\",\"5-9\",\"10-14\",..: 1 1 7 4 1 4 4 1 7 5 ...\n $ age_cat5            : Factor w/ 18 levels \"0-4\",\"5-9\",\"10-14\",..: 1 1 12 4 1 4 4 1 13 6 ...\n $ hospital            : Factor w/ 6 levels \"Central Hospital\",..: 4 3 6 5 2 5 3 3 3 3 ...\n $ lon                 : num [1:5888] -13.2 -13.2 -13.2 -13.2 -13.2 ...\n $ lat                 : num [1:5888] 8.47 8.45 8.46 8.48 8.46 ...\n $ infector            : Factor w/ 2697 levels \"00031d\",\"002e6c\",..: 2594 NA NA 2635 180 1799 1407 195 NA NA ...\n $ source              : Factor w/ 2 levels \"funeral\",\"other\": 2 NA NA 2 2 2 2 2 NA NA ...\n $ wt_kg               : num [1:5888] 27 25 91 41 36 56 47 0 86 69 ...\n $ ht_cm               : num [1:5888] 48 59 238 135 71 116 87 11 226 174 ...\n $ ct_blood            : num [1:5888] 22 22 21 23 23 21 21 22 22 22 ...\n $ fever               : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n $ chills              : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n $ cough               : Factor w/ 2 levels \"no\",\"yes\": 2 NA NA 1 2 2 NA 2 2 2 ...\n $ aches               : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n $ vomit               : Factor w/ 2 levels \"no\",\"yes\": 2 NA NA 1 2 2 NA 2 2 1 ...\n $ temp                : num [1:5888] 36.8 36.9 36.9 36.8 36.9 37.6 37.3 37 36.4 35.9 ...\n $ time_admission      : Factor w/ 1072 levels \"00:10\",\"00:29\",..: NA 308 746 415 514 589 609 297 409 387 ...\n $ bmi                 : num [1:5888] 117.2 71.8 16.1 22.5 71.4 ...\n $ days_onset_hosp     : num [1:5888] 2 1 2 2 1 1 2 1 1 2 ...\n\n\n\n\nИтеративное создание графиков для разных уровней переменной\nЗдесь мы построим круговую диаграмму, чтобы посмотреть распределение исходов пациентов в Китае во время вспышки заболевания H7N9 для каждой провинции. Вместо того чтобы повторять код для каждой из них, мы просто применим созданную нами функцию.\n\n#уточнение опций для использования в highchart\noptions(highcharter.theme =   highcharter::hc_theme_smpl(tooltip = list(valueDecimals = 2)))\n\n\n#создаем функцию под названием \"chart_outcome_province\", которая берет в качестве аргумента набор данных и название провинции, по которой строится график распределения исходов.\n\nchart_outcome_province &lt;- function(data_used, prov){\n  \n  tab_prov &lt;- data_used %&gt;% \n    filter(province == prov,\n           !is.na(outcome))%&gt;% \n    group_by(outcome) %&gt;% \n    count() %&gt;%\n    adorn_totals(where = \"row\") %&gt;% \n    adorn_percentages(denominator = \"col\", )%&gt;%\n    mutate(\n        perc_outcome= round(n*100,2))\n  \n  \n  tab_prov %&gt;%\n    filter(outcome != \"Total\") %&gt;% \n  highcharter::hchart(\n    \"pie\", hcaes(x = outcome, y = perc_outcome),\n    name = paste0(\"Distibution of the outcome in:\", prov)\n    )\n  \n}\n\nchart_outcome_province(flu_china, \"Shanghai\")\n\n\n\n\nchart_outcome_province(flu_china,\"Zhejiang\")\n\n\n\n\nchart_outcome_province(flu_china,\"Jiangsu\")\n\n\n\n\n\n\n\nИтеративное создание таблиц для разных уровней переменной\nЗдесь мы создадим три показателя, которые сведем в таблицу, и хотим получить эту таблицу для каждой из провинций. Наши показатели - это задержка между началом заболевания и госпитализацией, процент выздоровления и средний возраст больных.\n\nindic_1 &lt;- flu_china %&gt;% \n  group_by(province) %&gt;% \n  mutate(\n    date_hosp= strptime(date_of_hospitalisation, format = \"%m/%d/%Y\"),\n    date_ons= strptime(date_of_onset, format = \"%m/%d/%Y\"), \n    delay_onset_hosp= as.numeric(date_hosp - date_ons)/86400,\n    mean_delay_onset_hosp = round(mean(delay_onset_hosp, na.rm=TRUE ), 0)) %&gt;%\n  select(province, mean_delay_onset_hosp)  %&gt;% \n  distinct()\n     \n\nindic_2 &lt;-  flu_china %&gt;% \n            filter(!is.na(outcome)) %&gt;% \n            group_by(province, outcome) %&gt;% \n            count() %&gt;%\n            pivot_wider(names_from = outcome, values_from = n) %&gt;% \n    adorn_totals(where = \"col\") %&gt;% \n    mutate(\n        perc_recovery= round((Recover/Total)*100,2))%&gt;% \n  select(province, perc_recovery)\n    \n    \n    \nindic_3 &lt;-  flu_china %&gt;% \n            group_by(province) %&gt;% \n            mutate(\n                    median_age_cases = median(as.numeric(age), na.rm = TRUE)\n            ) %&gt;% \n  select(province, median_age_cases)  %&gt;% \n  distinct()\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `median_age_cases = median(as.numeric(age), na.rm = TRUE)`.\nℹ In group 11: `province = \"Shanghai\"`.\nCaused by warning in `median()`:\n! NAs introduced by coercion\n\n#соединяем три набора данных с индикаторами\n\ntable_indic_all &lt;- indic_1 %&gt;% \n  dplyr::left_join(indic_2, by = \"province\") %&gt;% \n        left_join(indic_3, by = \"province\")\n\n\n#печатаем индикаторы в виде таблицы flextable\n\n\nprint_indic_prov &lt;-  function(table_used, prov){\n  \n  #сначала немного преобразовываем датафрейм для легкости печати\n  indic_prov &lt;- table_used %&gt;%\n    filter(province==prov) %&gt;%\n    pivot_longer(names_to = \"Indicateurs\", cols = 2:4) %&gt;% \n   mutate( indic_label = factor(Indicateurs,\n   levels= c(\"mean_delay_onset_hosp\",\"perc_recovery\",\"median_age_cases\"),\n   labels=c(\"Mean delay onset-hosp\",\"Percentage of recovery\", \"Median age of the cases\"))\n   ) %&gt;% \n    ungroup(province) %&gt;% \n    select(indic_label, value)\n  \n\n    tab_print &lt;- flextable(indic_prov)  %&gt;%\n    theme_vanilla() %&gt;% \n    flextable::fontsize(part = \"body\", size = 10) \n    \n    \n     tab_print &lt;- tab_print %&gt;% \n                  autofit()   %&gt;%\n                  set_header_labels( \n                indic_label= \"Indicateurs\", value= \"Estimation\") %&gt;%\n    flextable::bg( bg = \"darkblue\", part = \"header\") %&gt;%\n    flextable::bold(part = \"header\") %&gt;%\n    flextable::color(color = \"white\", part = \"header\") %&gt;% \n    add_header_lines(values = paste0(\"Indicateurs pour la province de: \", prov)) %&gt;% \nbold(part = \"header\")\n \n tab_print &lt;- set_formatter_type(tab_print,\n   fmt_double = \"%.2f\",\n   na_str = \"-\")\n\ntab_print \n    \n}\n\n\n\n\nprint_indic_prov(table_indic_all, \"Shanghai\")\n\nIndicateurs pour la province de: ShanghaiIndicateursEstimationMean delay onset-hosp4.0Percentage of recovery46.7Median age of the cases67.0\n\nprint_indic_prov(table_indic_all, \"Jiangsu\")\n\nIndicateurs pour la province de: JiangsuIndicateursEstimationMean delay onset-hosp6.0Percentage of recovery71.4Median age of the cases55.0",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Написание функций</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.ru.html#советы-и-наилучшие-практики-для-хорошо-работающих-функций",
    "href": "new_pages/writing_functions.ru.html#советы-и-наилучшие-практики-для-хорошо-работающих-функций",
    "title": "44  Написание функций",
    "section": "44.8 Советы и наилучшие практики для хорошо работающих функций",
    "text": "44.8 Советы и наилучшие практики для хорошо работающих функций\nФункциональное программирование призвано облегчить код и упростить его чтение. Оно не должно приводить к обратному. Приведенные ниже советы помогут вам получить чистый и легко читаемый код.\n\nИменование и синтаксис\n\nИзбегайте использования символов, которые легко могли бы быть уже заняты другими функциями, уже существующими в вашей среде\nРекомендуется, чтобы имя функции было коротким и понятным для другого читателя\nПредпочтительно использовать глаголы в качестве имени функции и существительные для имен аргументов.\n\n\n\nИмена столбцов и оценка принципов аккуратности\nЕсли вы хотите знать, как ссылаться на имена столбцов, которые заданы в ваш код в виде аргументов, прочитайте это руководство по программированию tidyverse. Среди рассматриваемых тем - оценка на предмет аккуратности и использование embrace { } “двойных фигурных скобок”\nНапример, вот краткий шаблон кода со страницы самоучителя, приведенного выше:\n\nvar_summary &lt;- function(data, var) {\n  data %&gt;%\n    summarise(n = n(), min = min({{ var }}), max = max({{ var }}))\n}\nmtcars %&gt;% \n  group_by(cyl) %&gt;% \n  var_summary(mpg)\n\n\n\nТестирование и работа с ошибками\nЧем сложнее задача функции, тем выше вероятность возникновения ошибок. Поэтому иногда необходимо добавить некоторую верификацию внутри функции, чтобы быстро понять, откуда взялась ошибка, и найти способ ее устранения.\n\nБолее чем рекомендуется ввести проверку на предмет отсутствия одного из аргументов с помощью missing(argument). Эта простая проверка выдаст значение “TRUE” (ИСТИНА) или “FALSE” (ЛОЖЬ).\n\n\ncontain_covid19_missing &lt;- function(barrier_gest, wear_mask, get_vaccine){\n  \n  if (missing(barrier_gest)) (print(\"please provide arg1\"))\n  if (missing(wear_mask)) print(\"please provide arg2\")\n  if (missing(get_vaccine)) print(\"please provide arg3\")\n\n\n  if (!barrier_gest == \"yes\" | wear_mask ==\"yes\" | get_vaccine == \"yes\" ) \n       \n       return (\"you can do better\")\n  \n  else(\"please make sure all are yes, this pandemic has to end!\")\n}\n\n\ncontain_covid19_missing(get_vaccine = \"yes\")\n\n[1] \"please provide arg1\"\n[1] \"please provide arg2\"\n\n\nError in contain_covid19_missing(get_vaccine = \"yes\"): argument \"barrier_gest\" is missing, with no default\n\n\n\nДля других обнаружимых ошибок используйте stop().\n\n\ncontain_covid19_stop &lt;- function(barrier_gest, wear_mask, get_vaccine){\n  \n  if(!is.character(barrier_gest)) (stop(\"arg1 should be a character, please enter the value with `yes`, `no` or `sometimes\"))\n  \n  if (barrier_gest == \"yes\" & wear_mask ==\"yes\" & get_vaccine == \"yes\" ) \n       \n       return (\"success\")\n  \n  else(\"please make sure all are yes, this pandemic has to end!\")\n}\n\n\ncontain_covid19_stop(barrier_gest=1, wear_mask=\"yes\", get_vaccine = \"no\")\n\nError in contain_covid19_stop(barrier_gest = 1, wear_mask = \"yes\", get_vaccine = \"no\"): arg1 should be a character, please enter the value with `yes`, `no` or `sometimes\n\n\n\nКак мы видим, при выполнении большинства встроенных функций в определенных условиях могут появляться сообщения и предупреждения. Мы можем интегрировать их в наши написанные функции с помощью функций message() и warning().\nМы можем обрабатывать ошибки и с помощью функции safely(), которая принимает в качестве аргумента одну функцию и выполняет ее безопасным образом. Фактически функция будет выполняться без остановки, если встретит ошибку. safely() выдает в качестве выходного результата список с двумя объектами, которые являются результатами, а ошибка “пропускается”.\n\nМы можем верифицировать первую, выполнив mean() в качестве функции, затем выполняем safely().\n\nmap(linelist, mean)\n\n$case_id\n[1] NA\n\n$generation\n[1] 16.56165\n\n$date_infection\n[1] NA\n\n$date_onset\n[1] NA\n\n$date_hospitalisation\n[1] \"2014-11-03\"\n\n$date_outcome\n[1] NA\n\n$outcome\n[1] NA\n\n$gender\n[1] NA\n\n$age\n[1] NA\n\n$age_unit\n[1] NA\n\n$age_years\n[1] NA\n\n$age_cat\n[1] NA\n\n$age_cat5\n[1] NA\n\n$hospital\n[1] NA\n\n$lon\n[1] -13.23381\n\n$lat\n[1] 8.469638\n\n$infector\n[1] NA\n\n$source\n[1] NA\n\n$wt_kg\n[1] 52.64487\n\n$ht_cm\n[1] 124.9633\n\n$ct_blood\n[1] 21.20686\n\n$fever\n[1] NA\n\n$chills\n[1] NA\n\n$cough\n[1] NA\n\n$aches\n[1] NA\n\n$vomit\n[1] NA\n\n$temp\n[1] NA\n\n$time_admission\n[1] NA\n\n$bmi\n[1] 46.89023\n\n$days_onset_hosp\n[1] NA\n\n\n\nsafe_mean &lt;- safely(mean)\nlinelist %&gt;% \n  map(safe_mean)\n\n$case_id\n$case_id$result\n[1] NA\n\n$case_id$error\nNULL\n\n\n$generation\n$generation$result\n[1] 16.56165\n\n$generation$error\nNULL\n\n\n$date_infection\n$date_infection$result\n[1] NA\n\n$date_infection$error\nNULL\n\n\n$date_onset\n$date_onset$result\n[1] NA\n\n$date_onset$error\nNULL\n\n\n$date_hospitalisation\n$date_hospitalisation$result\n[1] \"2014-11-03\"\n\n$date_hospitalisation$error\nNULL\n\n\n$date_outcome\n$date_outcome$result\n[1] NA\n\n$date_outcome$error\nNULL\n\n\n$outcome\n$outcome$result\n[1] NA\n\n$outcome$error\nNULL\n\n\n$gender\n$gender$result\n[1] NA\n\n$gender$error\nNULL\n\n\n$age\n$age$result\n[1] NA\n\n$age$error\nNULL\n\n\n$age_unit\n$age_unit$result\n[1] NA\n\n$age_unit$error\nNULL\n\n\n$age_years\n$age_years$result\n[1] NA\n\n$age_years$error\nNULL\n\n\n$age_cat\n$age_cat$result\n[1] NA\n\n$age_cat$error\nNULL\n\n\n$age_cat5\n$age_cat5$result\n[1] NA\n\n$age_cat5$error\nNULL\n\n\n$hospital\n$hospital$result\n[1] NA\n\n$hospital$error\nNULL\n\n\n$lon\n$lon$result\n[1] -13.23381\n\n$lon$error\nNULL\n\n\n$lat\n$lat$result\n[1] 8.469638\n\n$lat$error\nNULL\n\n\n$infector\n$infector$result\n[1] NA\n\n$infector$error\nNULL\n\n\n$source\n$source$result\n[1] NA\n\n$source$error\nNULL\n\n\n$wt_kg\n$wt_kg$result\n[1] 52.64487\n\n$wt_kg$error\nNULL\n\n\n$ht_cm\n$ht_cm$result\n[1] 124.9633\n\n$ht_cm$error\nNULL\n\n\n$ct_blood\n$ct_blood$result\n[1] 21.20686\n\n$ct_blood$error\nNULL\n\n\n$fever\n$fever$result\n[1] NA\n\n$fever$error\nNULL\n\n\n$chills\n$chills$result\n[1] NA\n\n$chills$error\nNULL\n\n\n$cough\n$cough$result\n[1] NA\n\n$cough$error\nNULL\n\n\n$aches\n$aches$result\n[1] NA\n\n$aches$error\nNULL\n\n\n$vomit\n$vomit$result\n[1] NA\n\n$vomit$error\nNULL\n\n\n$temp\n$temp$result\n[1] NA\n\n$temp$error\nNULL\n\n\n$time_admission\n$time_admission$result\n[1] NA\n\n$time_admission$error\nNULL\n\n\n$bmi\n$bmi$result\n[1] 46.89023\n\n$bmi$error\nNULL\n\n\n$days_onset_hosp\n$days_onset_hosp$result\n[1] NA\n\n$days_onset_hosp$error\nNULL\n\n\nКак говорилось ранее, подробное комментирование наших кодов является хорошим способом документирования нашей работы.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Написание функций</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.ru.html#ресурсы",
    "href": "new_pages/writing_functions.ru.html#ресурсы",
    "title": "44  Написание функций",
    "section": "44.9 Ресурсы",
    "text": "44.9 Ресурсы\nR для науки о данных ссылка\nШпаргалка по продвинутому программированию R\nШпаргалка по пакету purr\nВидео-выступление Хэдли Викхэма на конференции ACM: радость функционального программирования (как работает map_dbl)",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Написание функций</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.ru.html",
    "href": "new_pages/directories.ru.html",
    "title": "45  Взаимодействие директорий",
    "section": "",
    "text": "45.1 Подготовка",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Взаимодействие директорий</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.ru.html#подготовка",
    "href": "new_pages/directories.ru.html#подготовка",
    "title": "45  Взаимодействие директорий",
    "section": "",
    "text": "пакет fs\nПакет fs - это пакет tidyverse, который способствует взаимодействиям директорий, улучшая некоторые базовые функции R. В разделах ниже мы часто будем использовать функции из fs.\n\npacman::p_load(\n  fs,             # взаимодействия файлов/директорий\n  rio,            # импорт/экспорт\n  here,           # относительные пути к файлам\n  tidyverse)      # управление данными и визуализация\n\n\n\nПечать директории в виде дерева дендрограмм\nИспользуем функцию dir_tree() из fs.\nЗадайте путь к папке в path = и определите, хотите ли вы показать только один уровень (recurse = FALSE) или все файлы на всех суб-уровнях (recurse = TRUE). Ниже мы используем here() в качестве сокращения для проекта R и уточняем подпапку “data”, которая содержит все данные, используемые для этого руководства по R. Мы задаем отображение всех файлов в “data” и подпапках (например, “cache”, “epidemic models”, “population”, “shp” и “weather”).\n\nfs::dir_tree(path = here(\"data\"), recurse = TRUE)\n\nC:/Users/ngulu864/AppData/Local/Temp/Rtmp8MqjVI/file26d82ccdef/data\n├── africa_countries.geo.json\n├── cache\n│   └── epidemic_models\n│       ├── 2015-04-30\n│       │   ├── estimated_reported_cases_samples.rds\n│       │   ├── estimate_samples.rds\n│       │   ├── latest_date.rds\n│       │   ├── reported_cases.rds\n│       │   ├── summarised_estimated_reported_cases.rds\n│       │   ├── summarised_estimates.rds\n│       │   └── summary.rds\n│       ├── epinow_res.rds\n│       ├── epinow_res_small.rds\n│       ├── generation_time.rds\n│       └── incubation_period.rds\n├── case_linelists\n│   ├── cleaning_dict.csv\n│   ├── fluH7N9_China_2013.csv\n│   ├── linelist_cleaned.rds\n│   ├── linelist_cleaned.xlsx\n│   └── linelist_raw.xlsx\n├── country_demographics.csv\n├── covid_example_data\n│   ├── covid_example_data.xlsx\n│   └── covid_shapefile\n│       ├── FultonCountyZipCodes.cpg\n│       ├── FultonCountyZipCodes.dbf\n│       ├── FultonCountyZipCodes.prj\n│       ├── FultonCountyZipCodes.sbn\n│       ├── FultonCountyZipCodes.sbx\n│       ├── FultonCountyZipCodes.shp\n│       ├── FultonCountyZipCodes.shp.xml\n│       └── FultonCountyZipCodes.shx\n├── covid_incidence.csv\n├── covid_incidence_map.R\n├── district_count_data.xlsx\n├── example\n│   ├── Central Hospital.csv\n│   ├── district_weekly_count_data.xlsx\n│   ├── fluH7N9_China_2013.csv\n│   ├── hospital_linelists.xlsx\n│   ├── linelists\n│   │   ├── 20201007linelist.csv\n│   │   ├── case_linelist20201006.csv\n│   │   ├── case_linelist_2020-10-02.csv\n│   │   ├── case_linelist_2020-10-03.csv\n│   │   ├── case_linelist_2020-10-04.csv\n│   │   ├── case_linelist_2020-10-05.csv\n│   │   └── case_linelist_2020-10-08.xlsx\n│   ├── Military Hospital.csv\n│   ├── Missing.csv\n│   ├── Other.csv\n│   ├── Port Hospital.csv\n│   └── St. Mark's Maternity Hospital (SMMH).csv\n├── facility_count_data.rds\n├── flexdashboard\n│   ├── outbreak_dashboard.html\n│   ├── outbreak_dashboard.Rmd\n│   ├── outbreak_dashboard_shiny.Rmd\n│   ├── outbreak_dashboard_test.html\n│   └── outbreak_dashboard_test.Rmd\n├── fluH7N9_China_2013.csv\n├── gis\n│   ├── africa_countries.geo.json\n│   ├── covid_incidence.csv\n│   ├── covid_incidence_map.R\n│   ├── linelist_cleaned_with_adm3.rds\n│   ├── population\n│   │   ├── sle_admpop_adm3_2020.csv\n│   │   └── sle_population_statistics_sierraleone_2020.xlsx\n│   └── shp\n│       ├── README.txt\n│       ├── sle_adm3.CPG\n│       ├── sle_adm3.dbf\n│       ├── sle_adm3.prj\n│       ├── sle_adm3.sbn\n│       ├── sle_adm3.sbx\n│       ├── sle_adm3.shp\n│       ├── sle_adm3.shp.xml\n│       ├── sle_adm3.shx\n│       ├── sle_hf.CPG\n│       ├── sle_hf.dbf\n│       ├── sle_hf.prj\n│       ├── sle_hf.sbn\n│       ├── sle_hf.sbx\n│       ├── sle_hf.shp\n│       └── sle_hf.shx\n├── godata\n│   ├── cases_clean.rds\n│   ├── contacts_clean.rds\n│   ├── followups_clean.rds\n│   └── relationships_clean.rds\n├── likert_data.csv\n├── linelist_cleaned.rds\n├── linelist_cleaned.xlsx\n├── linelist_raw.xlsx\n├── make_evd_dataset-DESKTOP-JIEUMMI.R\n├── make_evd_dataset.R\n├── malaria_app\n│   ├── app.R\n│   ├── data\n│   │   └── facility_count_data.rds\n│   ├── funcs\n│   │   └── plot_epicurve.R\n│   ├── global.R\n│   ├── malaria_app.Rproj\n│   ├── server.R\n│   └── ui.R\n├── malaria_facility_count_data.rds\n├── phylo\n│   ├── sample_data_Shigella_tree.csv\n│   ├── Shigella_subtree_2.nwk\n│   ├── Shigella_subtree_2.txt\n│   └── Shigella_tree.txt\n├── rmarkdown\n│   ├── outbreak_report.docx\n│   ├── outbreak_report.html\n│   ├── outbreak_report.pdf\n│   ├── outbreak_report.pptx\n│   ├── outbreak_report.Rmd\n│   ├── report_tabbed_example.html\n│   └── report_tabbed_example.Rmd\n├── standardization\n│   ├── country_demographics.csv\n│   ├── country_demographics_2.csv\n│   ├── deaths_countryA.csv\n│   ├── deaths_countryB.csv\n│   └── world_standard_population_by_sex.csv\n├── surveys\n│   ├── population.xlsx\n│   ├── survey_data.xlsx\n│   └── survey_dict.xlsx\n└── time_series\n    ├── campylobacter_germany.xlsx\n    └── weather\n        ├── germany_weather2002.nc\n        ├── germany_weather2003.nc\n        ├── germany_weather2004.nc\n        ├── germany_weather2005.nc\n        ├── germany_weather2006.nc\n        ├── germany_weather2007.nc\n        ├── germany_weather2008.nc\n        ├── germany_weather2009.nc\n        ├── germany_weather2010.nc\n        └── germany_weather2011.nc",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Взаимодействие директорий</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.ru.html#список-файлов-в-директории",
    "href": "new_pages/directories.ru.html#список-файлов-в-директории",
    "title": "45  Взаимодействие директорий",
    "section": "45.2 Список файлов в директории",
    "text": "45.2 Список файлов в директории\nЧтобы указать только имена файлов в директории, вы можете использовать dir() из базового R. Например, эта команда создает список имен файлов из подпапки “population” в папке “data” проекта R. Относительный путь к файлу задается, используя here() (о которой вы можете больше прочитать на странице Импорт и экспорт).\n\n# file names\ndir(here(\"data\", \"gis\", \"population\"))\n\n[1] \"sle_admpop_adm3_2020.csv\"                       \n[2] \"sle_population_statistics_sierraleone_2020.xlsx\"\n\n\nЧтобы указать полные пути к файлам для файлов директории, вы можете использовать dir_ls() из fs. Альтернативой в базовом R является list.files().\n\n# file paths\ndir_ls(here(\"data\", \"gis\", \"population\"))\n\nC:/Users/ngulu864/AppData/Local/Temp/Rtmp8MqjVI/file26d82ccdef/data/gis/population/sle_admpop_adm3_2020.csv\nC:/Users/ngulu864/AppData/Local/Temp/Rtmp8MqjVI/file26d82ccdef/data/gis/population/sle_population_statistics_sierraleone_2020.xlsx\n\n\nЧтобы получить всю информацию о метаданных для каждого файла в директории, (например, путь, дата изменения и т.п.) вы можете использовать dir_info() из fs.\nЭто может быть особенно полезным, если вы хотите извлечь время последнего изменения из файла, например, если вы хотите импортировать наиболее последнюю версию файла. Для примера см. страницу Импорт и экспорт.\n\n# file info\ndir_info(here(\"data\", \"gis\", \"population\"))\n\nВот выдан датафрейм. Пролистайте вправо, чтобы увидеть все столбцы.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Взаимодействие директорий</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.ru.html#информация-о-файле",
    "href": "new_pages/directories.ru.html#информация-о-файле",
    "title": "45  Взаимодействие директорий",
    "section": "45.3 Информация о файле",
    "text": "45.3 Информация о файле\nЧтобы извлечь информацию о метаданных о конкретном файле, вы можете использовать file_info() из fs (или file.info() из базового R).\n\nfile_info(here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))\n\n\n\n\n\n\n\nЗдесь мы используем $, чтобы индексировать результат и выдать только значение времени изменения modification_time.\n\nfile_info(here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))$modification_time\n\n[1] \"2024-02-18 14:56:16 CET\"",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Взаимодействие директорий</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.ru.html#проверка-существования",
    "href": "new_pages/directories.ru.html#проверка-существования",
    "title": "45  Взаимодействие директорий",
    "section": "45.4 Проверка существования",
    "text": "45.4 Проверка существования\n\nОбъекты R\nВы можете использовать exists() из базового R, чтобы проверить, существует ли объект R внутри R (задайте имя объекта в кавычках).\n\nexists(\"linelist\")\n\n[1] FALSE\n\n\nОбратите внимание, что некоторые базовые пакеты R используют общие имена объектов, такие как “data” фоново, они будут отражены как TRUE (ИСТИНА), если не уточнить inherit = FALSE. Это одна из причин, почему не стоит называть ваш набор данных “data”.\n\nexists(\"data\")\n\n[1] TRUE\n\nexists(\"data\", inherit = FALSE)\n\n[1] FALSE\n\n\nЕсли вы пишите функцию, вам следует использовать missing() из базового R, чтобы проверить наличие аргумента вместо exists().\n\n\nДиректории\nЧтобы проверить, существует ли директория, задайте путь к файлу (и имя файла) в is_dir() из fs. Пролистайте вправо, чтобы увидеть, что напечатано TRUE.\n\nis_dir(here(\"data\"))\n\nC:/Users/ngulu864/AppData/Local/Temp/Rtmp8MqjVI/file26d82ccdef/data \n                                                               TRUE \n\n\nАльтернативой будет file.exists() из базового R.\n\n\nФайлы\nЧтобы проверить, существует ли конкретный файл, используйте is_file() из fs. Пролистайте вправо, чтобы увидеть, что напечатано TRUE.\n\nis_file(here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))\n\nC:/Users/ngulu864/AppData/Local/Temp/Rtmp8MqjVI/file26d82ccdef/data/case_linelists/linelist_cleaned.rds \n                                                                                                   TRUE \n\n\nАльтернативой из базового R будет file.exists().",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Взаимодействие директорий</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.ru.html#создание",
    "href": "new_pages/directories.ru.html#создание",
    "title": "45  Взаимодействие директорий",
    "section": "45.5 Создание",
    "text": "45.5 Создание\n\nДиректории\nЧтобы создать новую директорию (папку), вы можете использовать dir_create() из fs. Если директория уже существует, она не будет перезаписана сверу, и не будет выдаваться ошибка.\n\ndir_create(here(\"data\", \"test\"))\n\nАльтернативой является dir.create() из базового R, которая выдаст ошибку, если директория уже существует. Наоборот, dir_create() в этом сценарии не выдаст никаких сообщений.\n\n\nФайлы\nвы можете создать (пустой) файл с помощью file_create() из fs. Если файл уже существует, он не будет перезаписан или изменен.\n\nfile_create(here(\"data\", \"test.rds\"))\n\nАльтернативой из базового R является file.create(). Но если файл уже существует, эта опция его обрезан. Если вы используете file_create(), файл останется неизменным.\n\n\nСоздание, если не существует\nВ РАЗРАБОТКЕ",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Взаимодействие директорий</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.ru.html#удаление",
    "href": "new_pages/directories.ru.html#удаление",
    "title": "45  Взаимодействие директорий",
    "section": "45.6 Удаление",
    "text": "45.6 Удаление\n\nОбъекты R\nИспользуйте rm() из базового R, чтобы удалить объект R.\n\n\nДиректории\nИспользуйте dir_delete() из fs.\n\n\nФайлы\nВы можете удалить файлы с помощью file_delete() из fs.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Взаимодействие директорий</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.ru.html#выполнение-других-файлов",
    "href": "new_pages/directories.ru.html#выполнение-других-файлов",
    "title": "45  Взаимодействие директорий",
    "section": "45.7 Выполнение других файлов",
    "text": "45.7 Выполнение других файлов\n\nsource()\nЧтобы выполнить один скрипт R из другого скрипта R, вы можете использовать команду source() (из базового R).\n\nsource(here(\"scripts\", \"cleaning_scripts\", \"clean_testing_data.R\"))\n\nЭто эквивалентно просмотру приведенного выше скрипта R и нажатию кнопки “Source” в правом верхнем углу скрипта. Это приведет к выполнению скрипта, но сделает это незаметно (без вывода на консоль R), если это не предусмотрено специально. См. страницу [Интерактивная консоль], где есть примеры использования source() для взаимодействия с пользователем через консоль R в режиме вопросов и ответов.\n\n\n\n\n\n\n\n\n\n\n\nrender()\nrender() - вариация source(), наиболее часто используемая для скриптов R markdown. Вы задаете input =, который является файлом R markdown, а также output_format = (как правило, “html_document”, “pdf_document”, “word_document”, ““)\nСм. дополнительные детали на странице Отчеты с помощью R Markdown. Также см. документацию по render() тут или введя ?render.\n\n\nВыполнение файлов в директории\nВы можете создать цикл for и использовать его для source() для каждого файла в директории, указанного в dir().\n\nfor(script in dir(here(\"scripts\"), pattern = \".R$\")) {   # для каждого имени скрипта в папке проекта R \"scripts\" (с расширением .R)\n  source(here(\"scripts\", script))                        # запрос файла с соответствующим именем, который существует в папке скриптов\n}\n\nЕсли вы хотите выполнить только определенные скрипты, вы можете определить их по имени следующим образом:\n\nscripts_to_run &lt;- c(\n     \"epicurves.R\",\n     \"demographic_tables.R\",\n     \"survival_curves.R\"\n)\n\nfor(script in scripts_to_run) {\n  source(here(\"scripts\", script))\n}\n\nВот сравнение функций fs и базового R.\n\n\nИмпорт файлов в директорию\nПо вопросам импорта и экспорта отдельных файлов см. страницу [Импорт и экспорт].\nТакже см. на странице [Импорт и экспорт] методы автоматического импорта наиболее свежего файла на основе даты в имени файла или с помощью рассмотрения мета-данных файла.\nСм. страницу [Итерации, циклы и списки] для примера с пакетом purrr, демонстрирующего:\n\nРазделение датафрейма и сохранение его как нескольких файлов CSV\n\nРазделения датафрейма и сохранения каждой части как отдельного листа в рабочей книге Excel\n\nИмпорта нескольких файлов CSV и объединения их в один датафрейм\n\nИмпорта рабочей книги Excel с несколькими листами и объединения их в один датафрейм",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Взаимодействие директорий</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.ru.html#базовый-r",
    "href": "new_pages/directories.ru.html#базовый-r",
    "title": "45  Взаимодействие директорий",
    "section": "45.8 базовый R",
    "text": "45.8 базовый R\nСм. функции ниже list.files() и dir(), которые проводят те же операции создания списка файлов в указанной директории. Вы можете задать ignore.case = или конкретную последовательность, которую надо найти.\n\nlist.files(path = here(\"data\"))\n\nlist.files(path = here(\"data\"), pattern = \".csv\")\n# dir(path = here(\"data\"), pattern = \".csv\")\n\nlist.files(path = here(\"data\"), pattern = \"evd\", ignore.case = TRUE)\n\nЕсли файл в настоящее время “открыт”, он будет отображаться в вашей папкой с тильдой в начале, например, “~$hospital_linelists.xlsx”.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Взаимодействие директорий</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.ru.html#ресурсы",
    "href": "new_pages/directories.ru.html#ресурсы",
    "title": "45  Взаимодействие директорий",
    "section": "45.9 Ресурсы",
    "text": "45.9 Ресурсы\nhttps://cran.r-project.org/web/packages/fs/vignettes/function-comparisons.html",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Взаимодействие директорий</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.ru.html",
    "href": "new_pages/collaboration.ru.html",
    "title": "46  Контроль версий и совместная работа с помощью Git и Github",
    "section": "",
    "text": "46.1 Что такое Git?\nGit - это программа контроля версий, которая позволяет отслеживать изменения в папке. Ее можно использовать, как опцию “запись исправлений” в Word, LibreOffice или Google docs, но для всех типов файлов. Это одна из наиболее полезных и используемых опций для контроля версий.\nПочему я о нем никогда не слышал? - В то время как люди, занимающиеся разработкой, регулярно учатся использовать программное обеспечение для контроля версий (Git, Mercurial, Subversion и др.), мало кто из нас, занимающихся количественными дисциплинами, получает такие навыки. Соответственно, большинство эпидемиологов никогда не слышали об этом в ходе своих исследований и вынуждены осваивать его на ходу.\nПодождите, я слышал о Github, это то же самое? - Не совсем, но вы часто используете их вместе, мы вам покажем, как. Вкратце:\nТак что вы можете использовать клиент/интерфейс Github Desktop, который использует Git фоново для управления своими файлами, как локально на своем компьютере, так и удаленно на сервере Github.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Контроль версий и совместная работа с помощью Git и Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.ru.html#что-такое-git",
    "href": "new_pages/collaboration.ru.html#что-такое-git",
    "title": "46  Контроль версий и совместная работа с помощью Git и Github",
    "section": "",
    "text": "Git - система контроля версий, ПО. Вы можете его использовать локально на своем компьютере или синхронизировать папку с хостинговым веб-сайтом. По умолчанию используется терминал, чтобы дать Git инструкции в командной строке.\nВы можете использовать Git клиент/интерфейс, чтобы избежать командной строки и выполнить те же действия (как минимум, самые простые и частые).\nЕсли вы хтите хранить свою папку на хостинговом веб-сайте для совместной работы, вы можете создать аккаунт в Github, Gitlab, Bitbucket или прочих.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Контроль версий и совместная работа с помощью Git и Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.ru.html#зачем-использовать-комбинацию-git-и-github",
    "href": "new_pages/collaboration.ru.html#зачем-использовать-комбинацию-git-и-github",
    "title": "46  Контроль версий и совместная работа с помощью Git и Github",
    "section": "46.2 Зачем использовать комбинацию Git и Github?",
    "text": "46.2 Зачем использовать комбинацию Git и Github?\nИспользование Git способствует:\n\nАрхивированию документированных версий с постепенными изменениями, чтобы вы могли легко вернуться к предыдущему состоянию\nналичию параллельных ветвей, т.е. разработке/“рабочих” версий со структурированными способами интегрировать изменения после просмотра\n\nЭто может быть сделано локально на вашем компьютере, даже если вы не работаете совместно с другими людьми. Например, бывало ли, что вы:\n\nсожалели об удалении раздела кода, поняв через несколько месяцев, что он вам нужен?\nвозвращались к проекту, который был приостановлен, и пытались вспомнить, внесли ли вы сложные модификации в одну из моделей?\nимели файл model_1.R и еще один файл model_1_test.R и файл model_1_not_working.R, чтобы что-то попробовать?\nимели файл report.Rmd, файл report_full.Rmd, файл report_true_final.Rmd, файл report_final_20210304.Rmd, файл report_final_20210402.Rmd и ругали себя за навыки архивирования?\n\nGit поможет во всех этих случаях, его стоит изучить.\nОднако он становится еще более важным при использовании в сочетании с онлайн репозиторием, таким как Github, чтобы поддерживать совместные проекты. Это способствует:\n\nСовместной работе: другие могут рассматривать, комментировать, принимать/отклонять изменения\nПредоставление доступа к вашему коду, данным, выходным данным и обратной связи от общественности (или в закрытом режиме с вашей командой)\n\nи позволяет избежать ситуаций:\n\n“Упс, я забыл отправить последнюю версию, и теперь вам нужно переделывать двухдневную работу над этим новым файлом”\nМина, Генри и Умар одновременно работали над одним скриптом и необходимо вручную объединить их изменения\nДва человека пытаются изменить один и тот же файл в Dropbox и Sharepoint и при этом возникает ошибка синхронизации.\n\n\nЭто звучит сложно, я не программист\nЭто может быть сложно. Примеры продвинутого использования могут пугать. Однако, как и в случае с R, или даже Excel, вам не обязательно быть экспертом, чтобы пользоваться преимуществами этого инструмента. Узнав небольшое количество фукнций и понятий, вы сможете отслеживать свои изменения, синхронизировать файлы в онлайн репозитории и совместно работать со своими коллегами в краткие сроки.\nИз-за сложности обучения чрезвычайные ситуации могут быть не самым лучшим временем для изучения этих инструментов. Однако обучение можно проводить поэтапно. Как только вы освоите несколько понятий, ваш рабочий процесс может стать достаточно эффективным и быстрым. Если вы не работаете над проектом, где совместная работа с людьми через Git является абсолютно необходимой, то это будет хорошим временем, чтобы научиться им пользоваться самостоятельно, прежде чем погружаться в совместную работу.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Контроль версий и совместная работа с помощью Git и Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.ru.html#настройка",
    "href": "new_pages/collaboration.ru.html#настройка",
    "title": "46  Контроль версий и совместная работа с помощью Git и Github",
    "section": "46.3 Настройка",
    "text": "46.3 Настройка\n\nУстановка Git\nGit - движок, работающий фоном на вашем компьютере, который отслеживает изменения, ветки (версии), слияния и отката. Вы должны сначала установить Git с https://git-scm.com/downloads.\n\n\nУстановка интерфейса (опционально, но рекомендовано)\nGit имеет свой собственный язык команд, которые могут быть напечатаны в терминал командной строки. Однако существует много клиентов/интерфейсов для не-разработчиков при каждодневном использовании, поэтому вам редко придется взаимодействовать с Git напрямую, и интерфейс, как правило, дает хорошие инструменты визуализации для модификаций файла или веток.\nСуществует много опций для всех ОС, от более удобных для новичков до более сложных. Хорошие опции для новичков включают панель RStudio Git и Github Desktop, которые мы продемонстрируем в этой главе. Промежуточные (более мощные, но более сложные) опции включают Source Tree, Gitkracken, Smart Git и другие.\nКраткое объяснение клиентов Git.\nПримечание: Поскольку интерфейсы фактически все используют Git внутри, вы можете попробовать несколько из них, переключаться с одного на другой в конкретном проекте, использовать консоль для выполнения действий, которые не поддерживает ваш интерфейс, или даже выполнить любое количество действий в режиме онлайн на Github.\nКак указано ниже, вам может иногда потребоваться писать команды Git в терминале, таком как панель терминала RStudio (terminal) (вкладка рядом с консолью R), либо в терминале Git Bash.\n\n\nУчетная запись Github\nСоздайте бесплатную учетную запись на github.com.\nВам может быть предложено создать двухфакторную аутентификацию с приложением на вашем телефоне. Подробнее читайте в Github документы справки.\nЕсли вы используете Github Desktop, вы можете ввести свои учетные данные Gitub после установки, выполнив следующие шаги. Если вы этого не сделаете сейчас, учетные данные будут запрошены позже, когда вы попытаетесь клонировать проект с Github.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Контроль версий и совместная работа с помощью Git и Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.ru.html#словарь-концепции-и-базовые-функции",
    "href": "new_pages/collaboration.ru.html#словарь-концепции-и-базовые-функции",
    "title": "46  Контроль версий и совместная работа с помощью Git и Github",
    "section": "46.4 Словарь, концепции и базовые функции",
    "text": "46.4 Словарь, концепции и базовые функции\nКак и при изучении R, необходимо запомнить некоторые понятия, чтобы разобраться в Git. Вот необходимые для начала основы / интерактивный самоучитель. В следующих разделах мы покажем, как использовать интерфейсы , но полезно знать понятия и термины, чтобы построить умственную модель, так как вам она будет нужна при использовании интерфейсов.\n\nРепозиторий\nGit репозиторий (“repo”) - папка, которая содержит все подпапки и файлы для вашего проекта (data, code, images, и т.п.) и истории их изменения. Когда вы начинаете отслеживать изменения в репозитории с помощью него, Git создаст скрытую папку, которая содержит информацию по отслеживанию. Типичный репозиторий Git - ваша папка проекта R (см. страницу руководства Проекты R).\nМы покажем вам, как создать (инициировать) репозиторий Git из Github, Github Desktop или Rstudio в следующих разделах.\n\n\nCommit (коммит)\ncommit - это образ проекта на определенный момент времени. Когда вы вносите изменение в проект, вам нужно сделать commit, чтобы отслеживать изменения (дельта), внесенные в ваши файлы. Например, если вы изменили несколько строк кода и обновили соответствующий набор данных. Как только ваши изменения будут сохранены, вы их можете объединить в новый “коммит”.\nУ каждого коммит будет уникальный ID (хэш). В целях контроля версий, вы можете откатить свой проект на основе коммита, поэтому лучше, чтобы коммиты были относительно небольшими и последовательными. Вы также прикрепляете краткое описание изменений, называемое “сообщение коммит”.\nИндексированные изменения? Индексировать изменения - добавить их в зону подготовки для следующего коммита. Идея заключается в том, что вы можете детально решить, какие изменения включить в определенный коммит. Например, если вы работали над спецификацией модели в одном скрипте, а потом над рисунком - в другом, будет иметь смысл сделать два разных коммита (будет проще, если вы захотите откатить изменения на рисунке, но не в модели).\n\n\nВетви\nВетвь представляет собой независимую линию изменений в репозитории, параллельную, альтернативную версию файлов проекта.\nВетви полезны, чтобы протестировать изменения до того, как они будут включены в основную ветвь, которая, как правило, является основной/финальной/“активной” версией вашего проекта. Когда вы закончите экспериментировать над ветвью, вы можете привнести изменения в вашу основную ветвь, проведя слияние, либо можете удалить ее, если изменения не были успешными.\nПримечание: вам не обязательно совместно работать с другими людьми, чтобы иметь ветви, также не обязателен удаленный онлайн репозиторий.\n\n\nЛокальные и удаленные репозитории\nКлонировать - это создать копию репозитория Git в другом месте.\nНапример, вы можете клонировать онлайн репозиторий из Github локально на свой компьютер, либо начать с локального репозитория и клонировать его онлайн на Github.\nКогда вы клонировали репозиторий, файлы проекта существуют в двух местах:\n\nЛОКАЛЬНЫЙ репозиторий физически на вашем компьютере. Это то, где вы вносите реальные изменения в файл/код.\nУДАЛЕННЫЙ, онлайн репозиторий: версии ваших файлов проекта в репозитории Github (или на другом веб хостинге).\n\nЧтобы синхронизировать эти репозитории, мы будем использовать больше функций. На самом деле, в отличие от Sharepoint, Dropbox или других синхронизирующих программ, Git не обновляет автоматически ваш локальный репозиторий на основе того, что имеется онлайн или наоборот. Вы можете выбирать, когда и как синхронизировать.\n\ngit fetch скачивает новые изменения из удаленного репозитория, но не меняет ваш локальный репозиторий. Представьте себе, что это просто проверка состояния удаленного репозитория.\ngit pull скачивает новые изменения из удаленного репозитория и обновляет ваш местный репозиторий.\nКогда вы сделали один или несколько коммитов локально, вы можете использовать git push, чтобы передать коммиты на удаленный репозиторий. Это отправит ваши изменения в Github, чтобы другие люди могли их увидеть и скачать, если хотят.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Контроль версий и совместная работа с помощью Git и Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.ru.html#начало-работы-создание-нового-репозитория",
    "href": "new_pages/collaboration.ru.html#начало-работы-создание-нового-репозитория",
    "title": "46  Контроль версий и совместная работа с помощью Git и Github",
    "section": "46.5 Начало работы: создание нового репозитория",
    "text": "46.5 Начало работы: создание нового репозитория\nСуществует много способов создать новые репозитории. Вы можете это сделать с консоли, с Github, либо из интерфейса.\nДва общих подхода к началу работы:\n\nСоздать новый проект R из существующего или нового репозитория Github (предпочтительно для новичков), либо\nСоздать репозиторий Github для существующего проекта R\n\n\nСтартовые файлы\nКогда вы создаете новый репозиторий, вы можете опционально создать все из указанных ниже файлов, либо вы можете их добавить в репозиторий позднее. Как правило, они будут находиться в “корневой” папке репозитория.\n\nфайл README - файл, который человек может прочитать, чтобы понять, зачем существует ваш проект, и что еще нужно знать, чтобы использовать его. Сначала он будет пустым, но вам следует его потом заполнить.\nФайл .gitignore - текстовый файл, где каждая строка будет содержать папки или файлы, которые Git следует игнорировать (не отслеживать изменения). Более подробно прочитать и рассмотреть примеры можно тут.\nВы можете выбрать лицензию для вашей работы, чтобы другие люди знали, при каких условиях они могут использовать или воспроизводить вашу работу. Более подробную информацию см. на Creative Commons licenses.\n\n\n\nСоздание нового репозитория в Github\nЧтобы создать новый репозиторий, зайдите в Github и найдите зеленую кнопку для создания нового репозитория. Этот пока пустой репозиторий можно клонировать локально на ваш компьютер (см. следующий раздел).\n\n\n\n\n\n\n\n\n\nВам нужно выбрать, ходите ли вы, чтобы ваш репозиторий был публичным (видимым всем в интернете), либо закрытым (только видимым людям с разрешением). Это будет иметь важные последствия, если ваши данные чувствительные. Если ваш репозиторий закрытый, вы столкнетесь с некоторыми квотами в некоторых продвинутых особых обстоятельствах, например, если вы используете действия Github, чтобы автоматически выполнять ваш код в облаке.\n\n\nКлонирование из репозитория Github\nВы можете клонировать существующий репозиторий Github, чтобы создать новый локальный проект R на вашем компьютере.\nРепозиторий Github может быть уже существующим, в нем может быть содержимое, либо это может быть пустой репозиторий, который вы только что создали. В последнем случае, вы по сути создаете репозиторий Github и локальный проект R одновременно (см. инструкции выше).\nПримечание: если у вас нет права редактирования репозитория Github, можно сначала сделать ответвление репозитория в свой профиль, а затем продолжить другие действия. Ответвление объясняется в конце данной главы, но мы рекомендуем вам сначала прочитать другие разделы.\nШаг 1: Зайдите в репозиторий Github, кликните на зеленую кнопку “Code” и скопируйте HTTPS clone URL (см. картинку ниже)\n\n\n\n\n\n\n\n\n\nСледующий щаг можно выполнить в любом интерфейсе. Мы это проиллюстрируем с помощью Rstudio и Github desktop.\n\nВ Rstudio\nв RStudio начните новый проект R, кликнув на File &gt; New Project &gt; Version Control &gt; Git\n\nКогда выйдет вопрос про адрес репозитория “Repository URL”, вставьте HTTPS URL из Github\n\nПрисвойте проекту R короткое информативное имя\n\nВыберите, где проект R будет сохранен локально\n\nОтметьте поле “Open in new session” (открыть в новой сессии) и кликните “Create project” (создать проект)\n\nВы сейчас находитесь в новом локальном проекте RStudio, который является клоном репозитория Github. Этот локальный проект и репозиторий Github теперь связаны.\n\n\nВ Github Desktop\n\nКликните на File &gt; Clone a repository\nВыберите вкладку URL\nВставьте HTTPS URL из Github в первое поле\nВыберите папку, в которой вы хотите иметь местный репозиторий\nКликните “CLONE” (клонировать)\n\n\n\n\n\n\n\n\n\n\n\n\n\nНовый репозиторий Github из существующего проекта R\nАльтернативный сценарий - у вас есть существующий проект R с содержимым и вы хотите создать для него репозиторий Github.\n\nСоздайте новый пустой репозиторий Github для проекта (см. инструкции выше)\n\nКлонируйте этот репозиторий локально (см. инструкции HTTPS выше)\n\nКопируйте все содержимое из ранее существовавшего проекта R (коды, данные и т.п.) в новый, пустой, местный репозиторий (например, используйте копировать и вставить).\n\nОткройте свой новый проект в RStudio, зайдите в панель Git. Новые файлы должны регистрироваться как изменения файлорв, теперь они отслеживаются Git. Следовательно, вы можете собирать эти изменения для коммит и передавать их на Github. После передачи репозиторий в Github отразит все файлы.\n\nСм. раздел рабочий поток в Github ниже для получения информации об этом процессе.\n\n\nКак это теперь выглядит?\n\nВ RStudio\nКак только вы клонировали репозиторий Github в новый проект R, вы теперь увидите в RStudio вкладку “Git”. Эта вкладка появится в той же панели RStudio, что и рабочая среда R (Environment):\n\n\n\n\n\n\n\n\n\nОбратите внимание на кнопки, обведенные на изображении выше, поскольку на них мы будем ссылаться позднее (слева направо):\n\nКнопка коммит сохраненные изменения файла в локальной ветви (это откроет новое окно)\nСиняя стрелка скачать (обновить локальную версию ветви и получить любые изменения, сделанные в удаленной/Github версии этой ветви)\nЗеленая стрелка выгрузить (отправить коммиты/изменения локальной версии ветви в удаленную/Github версию этой ветви)\nВкладка Git в RStudio\nКнопка для создания НОВОЙ ветви, используя ту локальную ветвь, которая отображена справа в качестве базовой. Почти всегда требуется ветвь от основной ветви (после того, как вы сначала нажмете скачать для обновления основной ветви)\nВетвь, в которой вы работаете в настоящее время\nИзменения, которые вы внесли в код или другие файлы, появятся ниже\n\n\n\nВ Github Desktop\nGithub Desktop - независимое приложение, которое позволяет вам управлять всеми вашими репозиториями. Когда вы его открываете, интерфейс позволяет вам выбирать репозиторий, над которым вы хотите работать, а затем проводить основные действия Git в нем.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Контроль версий и совместная работа с помощью Git и Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.ru.html#рабочий-поток-git-github",
    "href": "new_pages/collaboration.ru.html#рабочий-поток-git-github",
    "title": "46  Контроль версий и совместная работа с помощью Git и Github",
    "section": "46.6 Рабочий поток Git + Github",
    "text": "46.6 Рабочий поток Git + Github\n\nОбзор процесса\nКак только вы завершили настройку (описана выше), у вас будет репозиторий Github, который связан (клонирован) с локальным проектом R. Основная ветвь (созданная по умолчанию) - это так называемая “активная” версия всех файлов. Когда вы хотите внести изменения, хорошей практикой будет создать новую ветвь из основной ветви (похоже на “Сделать копию”). Это типичный рабочий поток в Git, поскольку ветвь создать легко и быстро.\nТипичный рабочий поток выглядит следующим образом:\n\nУбедитесь, что ваш локальный репозиторий обновлен, если нет - обновите\nЗайдите в ветвь, над которой вы до этого работали, либо создайте новую ветвь, чтобы что-либо попробовать\nРаботайте над файлами локально на своем компьютере, сделайте один или несколько коммитов в этой ветви\nОбновите удаленную версию ветви, чтобы внести свои изменения (выгрузите)\nКогда вы удовлетворены своей ветвью, вы можете объединить онлайн версию рабочей ветви в онлайн “основную” ветвь, чтобы перенести изменения.\n\nДругие члены команды могут делать то же самое со своими ветвями, либо вномить коммиты в вашу рабочую ветвь.\nМы разберем указанный выше процесс более подробно чуть ниже. Вот схема, которую мы разработали - она в формате двухвходовой таблицы, чтобы помочь эпидемиологам разобраться.\n\n\n\n\n\n\n\n\n\nВот еще одна схема.\nПримечание: до недавних пор использовался термин “мастер” ветвь, но сейчас ее называют “основная” ветвь.\n\n\n\n\n\n\n\n\n\nИзображение источник",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Контроль версий и совместная работа с помощью Git и Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.ru.html#создание-новой-ветви",
    "href": "new_pages/collaboration.ru.html#создание-новой-ветви",
    "title": "46  Контроль версий и совместная работа с помощью Git и Github",
    "section": "46.7 Создание новой ветви",
    "text": "46.7 Создание новой ветви\nКогда вы выбираете ветвь для работы, Git перезапускает вашу рабочую директорию на ту, которой она была при последнем использовании этой ветви.\n\nВ Rstudio на панели Git\nУбедитесь, что вы находитесь в “основной” ветви, затем кликните на фиолетовую иконку для создания новой ветви (см. рисунок ниже).\n\nВас попросят назвать свою ветвь описательным именем из одного слова (можно использовать нижнее подчеркивание, если нужно).\nВы увидите, что локально вы все еще в том же проекте R, но вы уже не работаете в “основной” ветви.\nКак только новая ветвь будет создана, она также отразится как ветвь на веб-сайте Github\n\nВы можете визуализировать ветви на панели Git в Rstudio, кликнув на “History” (история)\n\n\n\n\n\n\n\n\n\n\n\nВ Github Desktop\nПроцесс очень похож, вас попросят задать ветви имя. Потом будет предложение “Publish you branch to Github” (опубликовать вашу ветвь), чтобы новая ветвь появилась также и в удаленном репозитории.\n\n\n\n\n\n\n\n\n\n\n\nВ консоли\nФоново происходит следующее, вы создаете новую ветвь с помощью git branch, затем переходите на ветвь с помощью git checkout (т.е. говорите Git, что следующий коммит будет тут). Из вашего репозитория git:\n\ngit branch my-new-branch  # Создаем ветвь new branch\ngit checkout my-new-branch # Переходим к ветви\ngit checkout -b my-new-branch # Оба сразу (сокращение)\n\nДля дополнительной информации об использовании консоли, см. раздел команды для Git в конце.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Контроль версий и совместная работа с помощью Git и Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.ru.html#сохраняем-изменения-commit",
    "href": "new_pages/collaboration.ru.html#сохраняем-изменения-commit",
    "title": "46  Контроль версий и совместная работа с помощью Git и Github",
    "section": "46.8 Сохраняем изменения (Commit)",
    "text": "46.8 Сохраняем изменения (Commit)\nТеперь вы можете редактировать код, добавлять новые файлы, обновлять наборы данных и т.п.\nКаждое изменение отслеживается, как только соответствующий файл будет сохранен. Измененные файлы будут появляться во вкладке RStudio Git, в Github Desktop, либо через использование команды git status в терминале (см. ниже).\nКогда вы вносите значительные изменения (например, добавляете или обновляете раздел кода), сделайте паузу и выполните коммит изменений. Представьте себе коммит, как “партию” изменений, объединенных общей целью. Вы всегда можете продолжить пересматривать файл после того, как сделали коммит изменений.\nСоветы по коммит: как правило, лучше делать мелкий коммит, который легко откатить, если возникнет проблема, чтобы одновременно сделать коммит по модификациям, объединенным общей целью. Чтобы этого добиться, нужно часто выполнять коммит. В начале вы будете забывать часто нажимать коммит, но потом это войдет в привычку.\n\nВ Rstudio\nПример ниже показывает, что с момента последнего коммит, скрипт R Markdown “collaboration.Rmd” изменился, и было добавлено несколько изображений PNG.\n\n\n\n\n\n\n\n\n\nВы возможно задаетесь вопросом, что представляют собой желтые, синие, зеленые и красные квадраты рядом с именами файловю Вот снимок экрана шпаргалки RStudio, которая объясняет их значений. Обратите внимание, что изменения с желтым “?” все еще можно подготовить к коммит, сделать коммит и выгрузить.\n\n\n\n\n\n\n\n\n\n\nНажмите кнопку “Commit” на вкладке Git, которая откроет новое окно (см. ниже)\nКликните на имя файла в верхнем левом поле\nПосмотрите изменения, которые вы внесли в этот файл (ниже выделено зеленым или красным)\n“Подготовьте” файл, который включает все изменения для коммит. Это можно сделать, отметив поле рядом с именем файла. Альтернативно вы можете выделить несколько имен файлов и потом кликнуть “Stage” (подготовить)\nНапишите сообщение для коммит, которое будет коротким, но описательным (обязательно)\nНажмите кнопку “Commit” (коммит). Появится всплывающее окно, показывающее сообщение о выполнении или ошибке.\n\nТеперь вы можете сделать больше изменений и коммитов столько раз, сколько хотите\n\n\n\n\n\n\n\n\n\n\n\nВ Github Desktop\nВы можете увидеть список файлов, которые были изменены, слева. Если вы выберете текстовый файл, вы увидите краткую информацию о модификациях, которые были сделаны, на правой панели (просмотр не сработает для более сложных файлов, таких как .docs или .xlsx).\nЧтобы подготовить изменения к коммит, просто отметьте маленькое поле рядом с именем файла. Когда вы выберете файлы, которые вы хотите добавить к коммит, задайте имя для коммит, опционально также описание и затем кликните кнопку commit (коммит).\n\n\n\n\n\n\n\n\n\n\n\nВ консоли\nДве функции, работающие фоново, включают git add для выбора/подготовки файлов и git commit, чтобы сделать коммит.\n\ngit status # См. изменения \n\ngit add new_pages/collaboration.Rmd  # выбираем файл для коммит (= подготовка к изменениям)\n\ngit commit -m \"Describe commit from Github Desktop\" # коммит изменений с сообщением\n\ngit log  # просмотр информации по предыдущим коммитам\n\n\n\nВнесение изменений в предыдущий коммит\nЧто происходит, если вы делаете коммит для изменений, продолжаете работать и понимаете, что внесли изменения, которые должны были “относиться” к прошлым коммитам (на ваш взгляд). Не бойтесь! Вы можете приложить эти изменения к предыдущему коммиту.\nВ Rstudio это должно быть достаточно очевидно, там есть поле “Amend previous commit” (внести изменения в предыдущий коммит) на той же строке. что и кнопка COMMIT.\nПо какой-то причине, такой функционал не был внедрен в Github Desktop, но существует (концептуально странный, но легкий) выход. Если вы сделали коммит, но еще не выгрузили ваши изменения, прямо под кнопкой “UNDO” (ОТМЕНИТЬ), появится кнопка COMMIT (КОММИТ). Кликните на нее и она откатит ваш коммит (но сохранит ваши подготовленные файлы и сообщение коммит). Сохраните ваши изменения, добавьте новые файлы в коммит, если необходимо, и снова нажмите коммит.\nВ консоли:\n\ngit add [YOUR FILES] # подготовка новых изменений\n\ngit commit --amend  # внесение изменений в прошлый коммит\n\ngit commit --amend -m \"An updated commit message\"  # внесение изменений в прошлый коммит И обновление сообщения для коммит\n\nПримечание: подумайте, прежде чем изменять коммиты, которые уже опубликованы в общем доступе для совместно работающих людей.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Контроль версий и совместная работа с помощью Git и Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.ru.html#скачивание-и-выгрузка-изменений-на-github",
    "href": "new_pages/collaboration.ru.html#скачивание-и-выгрузка-изменений-на-github",
    "title": "46  Контроль версий и совместная работа с помощью Git и Github",
    "section": "46.9 Скачивание и выгрузка изменений на Github",
    "text": "46.9 Скачивание и выгрузка изменений на Github\n“Сначала PULL (скачиваем), потом PUSH (выгружаем)”\nХорошей практикой будет получить и скачать до начала работы над проектом, чтобы обновить версию ветви на локальном компьютере, с изменениями, которые были внесены в удаленную/Github версию.\nСКАЧИВАЙТЕ часто. Не забывайте. Сначала скачивайте, потом выгружайте.\nКогда вносятся ваши изменения и вы делаете коммит, если вы довольны\nсостоянием вашего проекта, вы можете выгрузить ваши коммиты на удаленную/Github версию своей ветви.\nПовторяйте этот процесс при работе в репозитории.\nПримечание: гораздо легче откатить изменения, для которых был сделан коммит, но которые не были выгружены (т.е. все еще хранятся локально), чем откатить изменения, которые были переданы в удаленный репозиторий (и их уже кто-то скачал), поэтому лучше выгружать их, когда вы закончили внесение изменений в ту задачу, над которой вы работаете.\n\nВ Rstudio\nСКАЧАТЬ - сначала нажмите иконку скачать “Pull” (стрелка вниз), которая получает и скачивает одновременно.\nВЫГРУЗИТЬ - Кликните зеленую иконку “Pull” (стрелка вверх). Вас могут попросить ввести свое имя пользователя и пароль Github. Первый раз, когда вас запросят, может потребоваться ввести две командных строки Git в Terminal:\n\ngit config –global user.email “you@example.com” (your Github email address), и\n\ngit config –global user.name “Your Github username”\n\nЧтобы больше узнать о том, как вводить эти команды, см. раздел по командам Git ниже.\nСОВЕТ: У вас слишком часто запрашивается пароль? См. главы 10 и 11 данного самоучителя, чтобы подключить репозиторий, используя ключ SSH (более сложно).\n\n\nВ Github Desktop\nКликните на кнопку “Fetch origin” (получить исходник), если есть новые коммиты в удаленном репозитории.\n\n\n\n\n\n\n\n\n\nЕсли Git найдет новые коммиты в удаленном репозитории, кнопка изменится на кнопку “Pull” (скачать). Поскольку та же кнопка используется для скачивания и выгрузки, вы не можете выгрузить изменения, пока их не скачали.\n\n\n\n\n\n\n\n\n\nВы можете зайти во вкладку “History” (история) (рядом со вкладкой “Changes” (изменения)), чтобы увидеть все коммиты (ваши и чужие). Это хороший способ познакомиться с тем, что сделали другие люди, совместно работающие с вами. Вы можете прочитать сообщение коммит, описание - если есть, и сравнить код двух файлов, используя вкладку diff.\n\n\n\n\n\n\n\n\n\nКак только удаленные изменения были скачены и как минимум одно локальное изменение прошло коммит, вы можете сделать выгрузку, нажав на ту же кнопку.\n\n\n\n\n\n\n\n\n\n\n\nКонсоль\nНеудивительно, что команды тут также fetch (получить), pull (скачать) и push (выгрузить).\n\ngit fetch  # есть ли новые коммиты в удаленной директории?\ngit pull   # скачать удаленные коммиты в свою локальную ветвь\ngit push   # выгрузить локальные коммиты этой ветви в удаленную ветвь\n\n\n\nЯ хочу скачать, но у меня есть локальная работа\nЭто может иногда случиться: вы внесли какие-то изменения в местном репозитории, но в удаленном репозитории есть коммиты, которые вы не скачали.\nGit откажется скачивать, поскольку это может привести к записи поверх ваших изменений. Есть несколько стратегий для сохранения своих изменений, хорошо описанных в Happy Git with R, две из них включают: - коммит ваших изменений, получение удаленных изменений, скачивание, разрешение конфликтов, если необходимо (см. раздел ниже), и выгрузите все онлайн - используйте stash для своих изменений, что по сути позволяет отложить их в сторонку, скачать, вытащить из хранилища (восстановить), затем сделать коммит, устранить конфликты и выгрузить.\nЕсли файлы, к которым относятся удаленные изменения, и изменения в файлах на локальном компьютере\nне пересекаются, Git может устранить конфликты автоматически.\nВ Github Desktop это можно сделать с помощью кнопок. Чтобы сделать stash, зайдите в Branch &gt; Stash all changes.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Контроль версий и совместная работа с помощью Git и Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.ru.html#присоединение-ветви-к-основной",
    "href": "new_pages/collaboration.ru.html#присоединение-ветви-к-основной",
    "title": "46  Контроль версий и совместная работа с помощью Git и Github",
    "section": "46.10 Присоединение ветви к основной",
    "text": "46.10 Присоединение ветви к основной\nЕсли вы закончили вносить изменения, то можете начать процесс слияния этих изменений с основной веткой. В зависимости от ситуации, это может быть быстрым процессом, а может потребоваться тщательная проверка и утверждение с участием членов команды.\n\nЛокально в Github Desktop\nМожно произвести объединение ветвей локально, используя Github Desktop. Во-первых, зайдите (к выдаче) ветви, которая будет получателем коммит, иными словами, ветви, которую вы хотите обновить. Затем зайдите в меню Branch &gt; Merge into current branch и кликните. Поле позволит вам выбрать ветку, из которой вы хотите импортировать.\n\n\n\n\n\n\n\n\n\n\n\nВ консоли\nСначала перейдите на ветвь, которая будет получателем изменений. Это обычно мастер ветвь, но это может быть и другая ветвь. Затем проведите слияние рабочей ветви с мастер.\n\ngit checkout master  # вернитесь в мастер (или в ветвь, в которую хотите перенести свою)\ngit merge this_fancy_new_branch\n\nЭта страница показывает более продвинутый пример разделения на ветви, и немного объясняет, что происходит фоново.\n\n\nВ Github: подача запросов на скачивание\nХотя вполне возможно объединить две ветви локально, или не ставя никого в известность, слияние может обсуждаться или исследоваться несколькими людьми до интеграции в основную ветку. Чтобы помочь в этом процесс, Github предлагает некоторые возможности обсуждения слияния: запросы на скачивание.\nЗапрос на скачивание (“PR”) - запрос на присоединение одной ветви к другой (иными словами, запрос на то, что ваша рабочая ветвь будет присоединена к “основной” ветви). Запрос на скачивание как правило требует несколько коммитов. Запрос на скачивание, как правило, начинает процесс обсуждения и обзора, прежде чем он будет принят и ветвь будет присоединена. Например, вы можете прочитать обсуждения запросов на скачивание в github dplyr.\nВы можете подать запрос на скачивание (PR) напрямуюна сайте (как показано ниже) или с Github Desktop.\n\nЗайдите в репозиторий Github (онлайн)\nПросмотрите вкладку “Pull Requests” (запросы на скачивание) и кликните на кнопку “New pull request” (новый запрос на скачивание)\nВыберите из выпадающего меню, чтобы объединить вашу ветвь с основной\nНапишите детальный комментарий к запросу на скачивание и кликните “Create Pull Request”.\n\nНа изображении ниже “лес” ветвей был выбран для объединения в “основную” ветвь:\n\n\n\n\n\n\n\n\n\nТеперь вы должны увидеть запрос на скачивание (пример изображения ниже):\n\nИзучите вкладку “Files changed” (измененные файлы), чтобы увидеть, как изменится “основная” ветвь, если ветви были объединены.\n\nСправа вы можете запросить обзор у членов вашей команды, отметив их Github ID. Если хотите, вы можете задать настройки репозитория, чтобы запросить утверждающего человека обзор, чтобы присоединить к основной ветви.\n\nКак только запрос на скачивание одобрен, кнопка “Merge pull request” (присоединить запрос на скачивание) станет активной. Кликните на нее.\n\nПосле завершения удалите вашу ветвь, как объясняется ниже.\n\n\n\n\n\n\n\n\n\n\n\n\nРазрешение конфликтов\nЕсли два человека модифицировали одну и ту же строку одновременно, возникает конфликт объединения. Опять же, Git отказывается принимать решение о том, какую версию сохранить, ео помогает вам найти конфликт. НЕ ПАНИКУЙТЕ. В большем количестве случаев его легко решить.\nНапример, в Github:\n\n\n\n\n\n\n\n\n\nПосле объединения возникшего конфликта, откройте файл в любимом редакторе. Конфликт будет указан серией знаков:\n\n\n\n\n\n\n\n\n\nТекст между &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD и ======= идет из вашего локального репозитория, а текст между ======= и &gt;&gt;&gt;&gt;&gt;&gt;&gt; - из другой ветви (которая может быть исходной, мастер или любой выбранной вами ветвью).\nВам нужно решить, какую версию кода вы предпочитаете (или даже записать третью, включая изменения с обеих сторон, если необходимо), удалите все остальное и удалите все отметки, добавленные Git (&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD, =======, &gt;&gt;&gt;&gt;&gt;&gt;&gt; origin/master/your_branch_name).\nЗатем сохраните файл, подготовьте и сделайте коммит: это коммит, который делает объединенные версии “официальными”. Не забудьте их потом выгрузить.\nЧем чаще вы и другие совместно работающие люди скачиваете и выгружаете, тем меньше будет конфликт.\nПримечание: Если вам удобно пользоваться консолью, есть более продвинутые опции слияния (например, игнорирование пустого пространства, приоритетность одного из авторов и т.п.).\n\n\nУдаление вашей ветви\nКак только ветвь объединена в мастер файл и больше не нужна, вы можете ее удалить.\n\n46.10.0.1 Github + Rstudio\nПерейдите в репозиторий на Github и нажмите кнопку для просмотра всех ветвей (рядом с выпадающим меню выбора ветвей). Теперь найдите свою ветку и нажмите на значок корзины рядом с ней. Более подробно об удалении ветви см. тут.\nУбедитесь, что вы также удалили ветвь локально на своем компьютере. Это не будет сделано автоматически.\n\nИз RStudio убедитесь, что вы находитесь в основной ветви\nпереключитесь на печать команд Git в терминале RStudio (“Terminal” - вкладка рядом с консолью R), и напечатайте: git branch -d branch_name, где “branch_name” - это имя ветви, которую нужно удалить\nОбновите вашу вкладку Git и ветвь должна исчезнуть\n\n\n\n46.10.0.2 В Github Desktop\nПросто выделите ветвь, которую вы хотите удалить, и зайдите в меню Branch &gt; Delete.\n\n\n\nРазветвлечнеие\nВы можете разветвить проект, если вы хотите принять участие в его разработке, но у вас нет на это прав, либо если вы хотите модифицировать его для личного использования. Краткое описание разветвления можно найти тут.\nВ Github кликните на кнопку “Fork”:\n\n\n\n\n\n\n\n\n\nЭто клонирует оригинальный репозиторий, но в вашем профиле. Теперь есть две версии репозитория на Github: оригинальная, которую вы не можете менять, и клонированная версия в вашем профиле.\nЗатем вы можете клонировать вашу версию онлайн репозитория локально на своем компьютере, используя любой из методов, описанных в предыдущих разделах. Затем вы можете создать новую ветвь, внести изменения, сделать коммит и выгрузить в ваш удаленный репозиторий.\nКак только вы удовлетворены результатом, вы можете создать запрос на скачивание с Github или Github Desktop, чтобы начать разговор с владельцами/сопровождающими оригинального репозитория.\nЧто если вам нужны более свежие коммиты с официального репозитория?\nПредставьте, что кто-то внесет критические модификации в официальный репозиторий, который вы хотите включить в свою клонированную версию. Возможно синхронизировать ваше разветвление с официальным репозиторием. Это требует использования терминала, но это не слишком сложно. В основном, вам нужно запомнить, что: - upstream = официальный репозиторий, который вы не могли модифицировать - origin = ваша версия репозитория в вашем профиле Github\nВы можете прочитать этот самоучитель или выоплнить следующее:\nВо-первых, напечатайте в своем терминале Git (внутри вашего репозитория):\n\ngit remote -v\n\nЕсли вы еще не провели конфигурацию upstream-репозитория, вы должны увидеть две строки, начиная с origin. Они показывают удаленный репозиторий, который выполняет fetch и push. Помните, что origin - привычное имя вашей версии репозитория на Github. Например:\n\n\n\n\n\n\n\n\n\nТеперь добавьте новый удаленный репозиторий:\n\ngit remote add upstream https://github.com/appliedepi/epirhandbook_eng.git\n\nЗдесь адрес - это адрес, который генерирует Github, когда вы клонируете репозиторий (см. раздел клонирование).Теперь у вас будет 4 удаленных указателя:\n\n\n\n\n\n\n\n\n\nТеперь, когда готова настройка, когда вы хотите получить изменения из репозитория оригинала (upstream), вам нужно только зайти (checkout) в ветвь, которую вы хотите обновить, и напечатать:\n\ngit fetch upstream # получить новые коммиты из удаленного репозитория\ngit checkout the_branch_you_want_to_update\ngit merge upstream/the_branch_you_want_to_update  # объединение ветви upstream с вашей ветвью\ngit push # обновление вашей собственной версии удаленного репозитория\n\nЕсли есть конфликты, вам нужно будет их решить, как объяснялось в разделе Устранение конфликтов.\nРезюме: разветвление - клонирование, но на стороне сервера Github. Остальные действия типичны для действий при совместной работе над проектом (клонирование, выгрузка, скачивание, коммит, объединение, подача запросов на скачивание…).\nПримечание: хотя разветвление - концепция, а не команда Git, оно также существует на других веб-хостах, например Bitbucket.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Контроль версий и совместная работа с помощью Git и Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.ru.html#что-мы-узнали",
    "href": "new_pages/collaboration.ru.html#что-мы-узнали",
    "title": "46  Контроль версий и совместная работа с помощью Git и Github",
    "section": "46.11 Что мы узнали",
    "text": "46.11 Что мы узнали\nМы узнали, как:\n\nнастраивать Git для отслеживания модификаций в ваших папках,\n\nсвязывать ваш местный репозиторий с удаленным онлайн репозиторием,\n\nпроводить коммит изменений,\n\nсинхронизировать ваш локальный и удаленный репозиторий.\n\nВсе это должно позволить вам начать работать и будет достаточно для ваших потребностей, как эпидемиологов. Как правило, мы не используем продвинутые функции разработчиков.\nОднако знайте, что если вам нужно будет пойти дальше, Git предлагает больше возможностей для упрощения историй коммитов, откатов одного или нескольких коммитов, выбора коммитов и т.п. Что-то может звучать как волшебство, но когда вы узнали основы, потом будет легче продолжать работу.\nОбратите внимание, что хотя панели Git в Rstudio и Github Desktop хороши для начинающих/ повседневного использования в нашей работе, они не предлагают интерфейса для промежуточных/продвинутых функций Git. Некоторые более полные интерфейсы позволяют вам делать больше с функционалом “навести и кликнуть” (как правило за счет более сложного макета).\nПомните, что поскольку вы можете использовать любой инструмент в любой момент для отслеживания своего репозитория, вы можете легко установить интерфейс, чтобы его попробовать, либо чтобы выполнить менее частые сложные задачи, при этом предпочитая более простой интерфейс все остальное время (например, использовать Github Desktop большую часть времени и переключаться на SourceTree или Gitbash для конкретных задач).",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Контроль версий и совместная работа с помощью Git и Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.ru.html#git",
    "href": "new_pages/collaboration.ru.html#git",
    "title": "46  Контроль версий и совместная работа с помощью Git и Github",
    "section": "46.12 Команды Git",
    "text": "46.12 Команды Git\n\nРекомендуемое обучение\nЧтобы узнать команды Git в интерактивном самоучителе, см. этот сайт.\n\n\nГде вводить команды\nВы вводите команды в оболочке Git.\nВариант 1 Вы можете открыть новый терминал в RStudio. Это вкладка рядом с консолью R. Если вы не можете напечатать текст в ней, кликните на выпадающее меню ниже “Terminal” и выберите “New terminal” (новый терминал). Напечатайте команды в мигающем пространстве перед знаком доллара “$”.\n\n\n\n\n\n\n\n\n\nВариант 2 Вы можете также открыть оболочку (терминал для ввода команд), кликнув синюю иконку с “шестеренками” во вкладке Git (рядом с рабочей средой RStudio). Выберите “Shell” (оболочка) из выпадающего меню. Откроется новое окно, где вы можете напечатать команды после знака доллара “$”.\nВариант 3 Правой кнопкой мыши кликните “Git Bash here”, что открое тот же тип терминала, либо откройте Git Bash из вашего списка приложений. Дополнительная информация о Git Bash, удобная для новичков, о том, как найти его и некоторых командах, которые вам понадобятся.\n\n\nПримеры команд\nНиже мы представляем несколько часто используемых команд git. Когда вы их используете, помните, какая ветвь активна (взята), так как это изменит действие!\nВ командах ниже,  представляет собой имя ветви.  представляет собой хэш ID для конкретного коммит.  представляет число. Не печатайте символы &lt; или &gt;.\n\n\n\n\n\n\n\nКоманда Git\nДействие\n\n\n\n\ngit branch &lt;name&gt;\nСоздать новую ветвь с именем &lt;имя&gt;\n\n\ngit checkout &lt;name&gt;\nПереключить текущую ветвь на &lt;имя&gt;\n\n\ngit checkout -b &lt;name&gt;\nКраткая команда для создания новой ветви и переключения на нее\n\n\ngit status\nСм. неотслеженные изменения\n\n\ngit add &lt;file&gt;\nПодготовить файл к коммит\n\n\ngit commit -m &lt;message&gt;\nКоммит подготовленных изменений в текущей ветви с сообщением\n\n\ngit fetch\nПолучить коммиты из удаленного репозитория\n\n\ngit pull\nСкачать коммиты из удаленного репозитория в текущую ветвь\n\n\ngit push\nВыгрузить локальные коммиты в удаленную директорию\n\n\ngit switch\nАльтернатива для git checkout, которая вводится в Git\n\n\ngit merge &lt;name&gt;\nСлияние ветви &lt;имя&gt; в текущую ветвь\n\n\ngit rebase &lt;name&gt;\nПриложить коммиты из текущей ветви к ветви &lt;имя&gt;",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Контроль версий и совместная работа с помощью Git и Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.ru.html#ресурсы",
    "href": "new_pages/collaboration.ru.html#ресурсы",
    "title": "46  Контроль версий и совместная работа с помощью Git и Github",
    "section": "46.13 Ресурсы",
    "text": "46.13 Ресурсы\nБольшая часть информации для данной страницы была всзята с этого веб-сайта “Happy Git with R”, созданного Дженни Браян. Там есть очень полезный раздел, который поможет найти и устранить частые ошибки в Git и R.\nДокументация и руководство по началу работы с Github.com.\nRStudio шпаргалка “IDE”, которая включает советы по Git в RStudio.\nhttps://ohi-science.org/news/github-going-back-in-time\nКоманды Git для начинающих\nинтерактивный самоучитель для изучения команд Git.\nhttps://www.freecodecamp.org/news/an-introduction-to-git-for-absolute-beginners-86fa1d32ff71/: хорошо подходит для изучения основ отслеживания изменений в одной папке на вашем компьютере.\nХорошая схема, чтобы понять ветви: https://speakerdeck.com/alicebartlett/git-for-humans\nСамоучители по базовым и продвинутым темам\nhttps://tutorialzine.com/2016/06/learn-git-in-30-minutes\nhttps://dzone.com/articles/git-tutorial-commands-and-operations-in-git https://swcarpentry.github.io/git-novice/ (short course) https://rsjakob.gitbooks.io/git/content/chapter1.html\nКнига Pro Git считается официальной справочной информацией. Хотя некоторые главы нормальные, она немного техническая. Она является хорошим ресурсом, когда вы уже немного пользовались Git и хотите узнать более конкретно, что происходит, и пойти дальше.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Контроль версий и совместная работа с помощью Git и Github</span>"
    ]
  },
  {
    "objectID": "new_pages/errors.ru.html",
    "href": "new_pages/errors.ru.html",
    "title": "47  Частые ошибки",
    "section": "",
    "text": "47.1 Интерпретация сообщений об ошибках\nОшибки в R иногда могут быть загадочными, поэтому Google - ваш друг. Сделайте поиск по сообщению об ошибке и букве “R”, поищите свежие посты в StackExchange.com, stackoverflow.com, community.rstudio.com, twitter (#rstats), а также на других форумах, испольуземых программистами, чтобы обмениваться вопросами и ответами. Попробуйте найти свежие посты, которые решают похожие проблемы.\nЕсли после тщательных поисков вы не можете найти ответ на свою проблему, попробуйте создать воспроизводимых пример (“reprex”) и разместить вопрос сами. См. страницу Получение помощи с советами о том, как создавать и размещать воспроизводимый пример на форумах.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Частые ошибки</span>"
    ]
  },
  {
    "objectID": "new_pages/errors.ru.html#частые-ошибки",
    "href": "new_pages/errors.ru.html#частые-ошибки",
    "title": "47  Частые ошибки",
    "section": "47.2 Частые ошибки",
    "text": "47.2 Частые ошибки\nНиже мы приводим некоторые распространенные ошибки и возможные объяснения/решения. Некоторые из них заимствованы у Ноама Росса, который проанализировал наиболее часто встречающиеся сообщения на форуме Stack Overflow об ошибках R (см. анализ тут)\n\nОпечатки\nError: unexpected symbol in:\n\"  geom_histogram(stat = \"identity\")+\n  tidyquant::geom_ma(n=7, size = 2, color = \"red\" lty\"\nЕсли вы видите ошибку “unexpected symbol” (неожиданный символ), проверьте отсутствующие запятые\n\n\nОшибки пакетов\ncould not find function \"x\"...\nЭто, скорее всего, означает, что вы напечатали имя функции неправильно, либо забыли установить или загрузить пакет\nError in select(data, var) : unused argument (var)\nВы думаете, что вы используете dplyr::select(), но функция select() была замаскированаMASS::select() - уточните dplyr:: или переупорядочите ваши зугрузки пакетов, чтобы dplyr был после всех остальных.\nДругие частые ошибки маскирования: plyr::summarise() и stats::filter(). Попробуйте использовать пакет conflicted.\nError in install.packages : ERROR: failed to lock directory ‘C:\\Users\\Name\\Documents\\R\\win-library\\4.0’ for modifying\nTry removing ‘C:\\Users\\Name\\Documents\\R\\win-library\\4.0/00LOCK’\nЕсли у вас будет ошибка, где говорится, что нужно удалить файл “00LOCK”, зайдите в библиотеку “R” в директории компьютера (например, R/win-library/) и найдите папку под названием “00LOCK”. Удалите вручную и попробуйте снова установить пакет. Предыдущий процесс установки, скорее всего, был прерван, что привело к этому.\n\n\nОшибки объекта\nNo such file or directory:\nЕсли вы видите такую ошибку при попытке экспорта или импорта: проверьте написание файла или пути к файлу, если путь содержит слэши, убедитесь, что это прямые слэши /, а не обратные \\. Также убедитесь, что вы использовали правильное расширение файла (например, .csv, .xlsx).\nobject 'x' not found \nЭто означает, что объект, на который вы ссылаетесь, не существует. Может код выше не был правильно выполнен?\nError in 'x': subscript out of bounds\nЭто означает, что вы попытались получить к чему-то доступ (к элементу вектора или списку), которого там не было.\n\n\nОшибки синтаксиса функций\n# ran recode without re-stating the x variable in mutate(x = recode(x, OLD = NEW)\nError: Problem with `mutate()` input `hospital`.\nx argument \".x\" is missing, with no default\ni Input `hospital` is `recode(...)`.\nОшибка выше (argument .x is missing, with no default) является частой для функции mutate(), если вы задаете такую функцию, как recode() или replace_na(), где она ожидает, что вы в качестве первого аргумента зададите имя столбца. Это легко забыть.\n\n\nОшибки логики\nError in if\nЭто скорее всего означает, что утверждение “если” (if) было применено к чему-то, что не является TRUE или FALSE (ИСТИНОЙ или ЛОЖЬЮ).\n\n\nОшибки фактора\n#Tried to add a value (\"Missing\") to a factor (with replace_na operating on a factor)\nProblem with `mutate()` input `age_cat`.\ni invalid factor level, NA generated\ni Input `age_cat` is `replace_na(age_cat, \"Missing\")`.invalid factor level, NA generated\nЕсли вы видите эту ошибку о недопустимых уровнях факторов, то, скорее всего, у вас есть столбец класса Фактор (который содержит предопределенные уровни) и вы пытались добавить в него новое значение. Перед добавлением нового значения преобразуйте его в текстовый класс.\n\n\nОшибки построения графика\nError: Insufficient values in manual scale. 3 needed but only 2 provided. ggplot() scale_fill_manual() values = c(“orange”, “purple”) … insufficient for number of factor levels … consider whether NA is now a factor level…\nCan't add x object\nНаверное, у вас лишний + в конце команды ggplot, который вам нужно удалить.\n\n\nОшибки R Markdown\nЕсли в сообщении об ошибке написано что-то похожее на Error in options[[sprintf(\"fig.%s\", i)]], проверьте, что опции knitr в верхней части каждого фрагмента кода правильно используют out.width = или out.height = а не fig.width= и fig.height=.\n\n\nРазное\nПосмотрите, может вы изменили порядок глагольных функций dplyr и не заменили оператор канала в середине, либо не удалили оператор канала в конце.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Частые ошибки</span>"
    ]
  },
  {
    "objectID": "new_pages/errors.ru.html#ресурсы",
    "href": "new_pages/errors.ru.html#ресурсы",
    "title": "47  Частые ошибки",
    "section": "47.3 Ресурсы",
    "text": "47.3 Ресурсы\nЕсть еще один пост в блоге, где перечислены распространенные ошибки в программировании в R, с которыми сталкиваются новички",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Частые ошибки</span>"
    ]
  },
  {
    "objectID": "new_pages/help.ru.html",
    "href": "new_pages/help.ru.html",
    "title": "48  Получение помощи",
    "section": "",
    "text": "48.1 Проблемы с Github\nКод многих пакетов R и проектов размещен на сайте Github.com. Вы можете связаться напрямую с авторами через веб-сайт, разместив “Проблему”.\nБолее подробно читайте о том, как хранить свою работу в Github на странице Совместная работа с Github.\nВ Github каждый проект содержится внутри репозитория. В каждом репозитории содержится код, данные, выходные результаты, документация справки и т.п. Также существует способ коммуникации с авторами, который называется “Issues” (проблемы).\nСм. ниже страницу Github по пакету incidence2 (используется для создания эпидемических кривых). Вы можете увидеть, что вкладка “Issues” выделена желтым. Вы видите, что есть 5 открытых проблем.\nПерейдя на вкладку Issues, вы увидите открытые проблемы. Просмотрите их, чтобы убедиться, что ваша проблема уже не рассматривается. Вы можете открыть новую проблему, нажав зеленую кнопку справа. Для этого вам потребуется учетная запись Github.\nВ своей проблеме следуйте приведенным ниже инструкциям и приведите минимальный, воспроизводимый пример. И, пожалуйста, будьте вежливы! Большинство людей, разрабатывающих пакеты и проекты на языке R, делают это в свободное время (как, например, это руководство!).\nЧтобы ознакомиться с более подробными материалами по работе с проблемами в собственном репозитории Github, ознакомьтесь с Github документацией по проблемам.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Получение помощи</span>"
    ]
  },
  {
    "objectID": "new_pages/help.ru.html#воспроизводимый-пример",
    "href": "new_pages/help.ru.html#воспроизводимый-пример",
    "title": "48  Получение помощи",
    "section": "48.2 Воспроизводимый пример",
    "text": "48.2 Воспроизводимый пример\nПредоставление воспроизводимого примера (“reprex”) - ключевой момент в получении помощи при написании сообщения на форуме или в проблеме на Github. Люди хотят помочь вам, но вы должны дать им пример, с которым они могут работать на своем компьютере. Пример должен:\n\nдемонстрировать проблему, с которой вы столкнулись\n\nбыть минимальным в том плане, чтобы он включал только данные и код, требуемые для воспроизведения вашей проблемы\n\nбыть воспроизводимым, чтобы все объекты (например, данные), вызов пакетов (например, library() или p_load()) были включены\n\nТакже будьте уверены, что вы не размещаете чувствительные данные в reprex! Вы можете создать примеры датафреймов, либо использовать один из датафреймов, встроенных в R (введите data(), чтобы открыть список этих наборов данных).\n\nПакет reprex\nПакет reprex может помочь вам в создании воспроизводимого примера:\n\nreprex устанавливается вместе с tidyverse, поэтому загрузить любой из двух пакетов\n\n\n# установите/загрузите tidyverse (который включает reprex)\npacman::p_load(tidyverse)\n\n\nНачните скрипт R, который создает вашу проблему пошагово, начиная с загрузки пакетов и данных.\n\n\n# загрузите пакеты\npacman::p_load(\n     tidyverse,  # управление данными и визуализация\n     outbreaks)  # наборы данных с примерами вспышек\n\n# построчный список для эпидемии гриппа\noutbreak_raw &lt;- outbreaks::fluH7N9_china_2013  # извлекаем набор данных из пакета outbreaks\n\n# вычищаем набор данных\noutbreak &lt;- outbreak_raw %&gt;% \n     mutate(across(contains(\"date\"), as.Date))\n\n# Строим график эпидемии\n\nggplot(data = outbreak)+\n     geom_histogram(\n          mapping = aes(x = date_of_onset),\n          binwidth = 7\n     )+\n  scale_x_date(\n    date_format = \"%d %m\"\n  )\n\nКопируем весь код в буфер обмена, затем выполняем следующую команду:\n\nreprex::reprex()\n\nВ панели RStudio Viewer появится HTML-вывод. Он будет содержать весь ваш код, а также предупреждения, ошибки и графики. Этот вывод также копируется в буфер обмена, поэтому его можно сразу поместить в проблему на Github или в сообщение на форуме.\n\n\n\n\n\n\n\n\n\n\nЕсли вы задали session_info = TRUE будет включен выходной результат sessioninfo::session_info() с версиями вашего R и пакета R\n\nВы можете задать рабочую директорию в wd =\n\nВы можете более подробно прочитать об этих аргументах и возможных вариациях в документации или введя ?reprex\n\nВ примере выше команда ggplot() не была выполнена, поскольку date_format = неверный - он должен быть date_labels =.\n\n\nМинимальные данные\nПомощники должны иметь возможность использовать ваши данные - в идеале они должны быть способны их создать с помощью кода.\nЧтобы создать минимальный набор данных, попробуйте анонимизировать и использовать только подмножество наблюдений.\nВ РАЗРАБОТКЕ - вы можете также использовать функцию dput(), чтобы создать минимальный набор данных.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Получение помощи</span>"
    ]
  },
  {
    "objectID": "new_pages/help.ru.html#пост-на-форуме",
    "href": "new_pages/help.ru.html#пост-на-форуме",
    "title": "48  Получение помощи",
    "section": "48.3 Пост на форуме",
    "text": "48.3 Пост на форуме\nПрочитайте большое количество постов на форуме. Попробуйте понять, какие посты написаны хорошо, а какие - нет.\n\nВо-первых, решите, задавать ли вообще вопрос. Вы тщательно изучили форумы, попробовали разные слова для поиска, может быть ваш вопрос уже был задан?\nДайте своему вопросу информативный заголовок (а не “Помогите! Не работает”).\nНапишите свой вопрос:\n\n\nПредставьте свою ситуацию и проблему\n\nДайте ссылки на посты с похожими проблемами и объясните, почему они не отвечают на ваш вопрос\n\nВключите необходимую информацию, чтобы помочь кому-то, кто не знаком с контекстом вашей работы\n\nДайте минимальный воспроизводимый пример с информацией о вашей сессии R\n\nИспользуйте правильную орфографию, грамматику, пунктуацию, разбейте свой вопрос на абзацы, чтобы его было легче читать\n\n\nСледите за размещенным вопросом и отвечайте на любые просьбы о разъяснении. Будьте вежливы и любезны - часто люди, отвечающие на вопросы, добровольно тратят свое время, чтобы помочь вам. Если у вас есть дополнительный вопрос, подумайте, стоит ли его опубликовать отдельно.\nОтметьте вопрос отвеченным, если вы получите ответ, который удовлетворяет изначальному запросу. Это помогает другим быстрее узнать решение.\n\nПрочитайте эти посты о том, как задавать хороший вопрос в Кодексе поведения Stack overflow.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Получение помощи</span>"
    ]
  },
  {
    "objectID": "new_pages/help.ru.html#ресурсы",
    "href": "new_pages/help.ru.html#ресурсы",
    "title": "48  Получение помощи",
    "section": "48.4 Ресурсы",
    "text": "48.4 Ресурсы\nСтраница Tidyverse о том, как получить помощь!\nСоветы по созданию минимального набора данных\nДокументация по функции dput",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Получение помощи</span>"
    ]
  },
  {
    "objectID": "new_pages/network_drives.ru.html",
    "href": "new_pages/network_drives.ru.html",
    "title": "49  R на сетевых дисках",
    "section": "",
    "text": "49.1 Обзор\nИспользование R на сетевых или “корпоративных” общих дисках может представлять дополнительные трудности. На этой странице приведены подходы, типичные ошибки и рекомендации по их устранению, полученные из нашего опыта работы с такими проблемами. В том числе приведены советы для особо деликатных ситуаций, связанных с R Markdown.\nИспользование R на сетевых дисках: общие принципы",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>R на сетевых дисках</span>"
    ]
  },
  {
    "objectID": "new_pages/network_drives.ru.html#обзор",
    "href": "new_pages/network_drives.ru.html#обзор",
    "title": "49  R на сетевых дисках",
    "section": "",
    "text": "Вы должны получить доступ администратора к своему компьютеру. Настройте RStudio так, чтобы она запускалась от имени администратора.\n\nПо возможности сохраняйте пакеты в библиотеку на диске с буквенным обозначением (например, “C:”). Используйте библиотеку пакетов, путь к которой начинается с “\\\" минимальным образом.\n\nПакет rmarkdown не должен быть в библиотеке пакета “\\\", поскольку тогда он не сможет подключиться к TinyTex или Pandoc.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>R на сетевых дисках</span>"
    ]
  },
  {
    "objectID": "new_pages/network_drives.ru.html#rstudio-от-имени-администратора",
    "href": "new_pages/network_drives.ru.html#rstudio-от-имени-администратора",
    "title": "49  R на сетевых дисках",
    "section": "49.2 RStudio от имени администратора",
    "text": "49.2 RStudio от имени администратора\nЧтобы открыть RStudio, щелкните на значке RStudio правой кнопкой мыши. В зависимости от типа машины может появиться опция “Запуск от имени администратора”. В противном случае может появиться возможность выбрать пункт “Свойства” (тогда должно появиться окно с опцией “Совместимость”, в котором можно установить флажок “Запуск от имени администратора”).",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>R на сетевых дисках</span>"
    ]
  },
  {
    "objectID": "new_pages/network_drives.ru.html#полезные-команды",
    "href": "new_pages/network_drives.ru.html#полезные-команды",
    "title": "49  R на сетевых дисках",
    "section": "49.3 Полезные команды",
    "text": "49.3 Полезные команды\nНиже представлены некоторые полезные команды для поиска и устранения проблем при использовании R на сетевых дисках.\nВы можете выдать путь(и) к библиотекам пакетов, которые использует R. Они будут перечислены в том порядке, в котором R использует их для установки/загрузки/поиска пакетов. Таким образом, если вы хотите, чтобы R использовал другую библиотеку по умолчанию, вы можете изменить порядок следования этих путей (см. ниже).\n\n# поиск библиотек\n.libPaths()                   # ваши пути к библиотекам, указанные в порядке установки/поиска R \n                              # Примечание: все библиотеки будут перечислены, но для установки для некоторых (например, C:), вам \n                              # может потребоваться запуск RStudio от лица администратора (они не появятся в \n                              # выпадающем меню библиотеки установки пакетов) \n\nВы можете захотеть изменить порядок следования библиотек пакета, используемых R. Например, если R выбирает местоположение библиотеки, начинающееся с “\\\", и то, которое начинается с буквы, например,”D:“. Вы можете скорректировать порядок .libPaths() с помощью следующего кода.\n\n# смена порядка библиотек\n# это может повлиять на приоритетность для R поиска пакета. Например, вы можете захотеть, чтобы библиотека C: указывалась первой\nmyPaths &lt;- .libPaths() # получаем пути\nmyPaths &lt;- c(myPaths[2], myPaths[1]) # меняем их\n.libPaths(myPaths) # повторно присваиваем\n\nЕсли у вас возникли трудности с подключением R Markdown к Pandoc, начните с этого кода, чтобы выяснить, где, по мнению RStudio, находится ваша установка Pandoc.\n\n# Находим Pandoc\nSys.getenv(\"RSTUDIO_PANDOC\")  # Найдите, где RStudio считает, что находится ваша установка Pandoc\n\nЕсли вы хотите увидеть, из какой библиотеки загружается пакет, попробуйте выполнить следующий код:\n\n# поиск пакета\n# дает первое расположение пакета (обратите внимание на порядок ваших библиотек)\nfind.package(\"rmarkdown\", lib.loc = NULL, quiet = FALSE, verbose = getOption(\"verbose\"))",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>R на сетевых дисках</span>"
    ]
  },
  {
    "objectID": "new_pages/network_drives.ru.html#поиск-и-устранение-распространенных-проблем",
    "href": "new_pages/network_drives.ru.html#поиск-и-устранение-распространенных-проблем",
    "title": "49  R на сетевых дисках",
    "section": "49.4 Поиск и устранение распространенных проблем",
    "text": "49.4 Поиск и устранение распространенных проблем\n“Failed to compile…tex in rmarkdown” (Не получилось компилировать…tex в rmarkdown)\n\nПроверьте установку TinyTex, либо установите TinyTex в C:. См. страницу Основы R для информации о том, как установить TinyTex.\n\n\n# проверка/установка tinytex в C:\ntinytex::install_tinytex()\ntinytex:::is_tinytex() # должна выдать TRUE (обратите внимание на три двоеточия)\n\nInternet routines cannot be loaded (Интернет-программы не могут быть загружены)\nНапример, Error in tools::startDynamicHelp() : internet routines cannot be loaded\n\nПопробуйте выбрать 32-битную версию из RStudio через Tools/Global Options (инструменты/глобальные опции).\n\nпримечание: если 32-битная версия не появляется в меню, убедитесь, что вы не используете RStudio v1.2.\n\n\nАльтернативно попробуйте удалить R и переустановить его с другой версией (32 бита вместо 64)\n\nC: library does not appear as an option when I try to install packages manually (C: библиотека не отображается в качестве опции при попытке установить пакеты вручную)\n\nЗапустите RStudio от лица администратора, тогда появится эта опция\n\nЧтобы настроить RStudio так, чтобы она всегда запускалась от лица администратора (что полезно, если вы используете Rproject, где вы не кликаете на иконку RStudio для открытия)… кликните правой кнопкой на иконку Rstudio\n\nНа рисунке ниже показано, как можно вручную выбрать библиотеку для установки пакета. Это окно появляется при открытии панели Packages RStudio и нажатии кнопки “Install” (установить).\n\n\n\n\n\n\n\n\n\nОшибка Pandoc 1\nЕсли вы видите “pandoc error 1” при формировании скриптов R Markdowns на сетевых дисках:\n\nИз нескольких мест расположения библиотеки первым должно быть указано то, которое имеет буквенное обозначение (см. коды выше)\n\nПриведенное выше решение работало при формировании на локальном диске, но при сетевом подключении к Интернету\n\nСм. дополнительные советы тут: https://ciser.cornell.edu/rmarkdown-knit-to-html-word-pdf/\n\nОшибка Pandoc 83\nОшибка выглядит подобным образом: can't find file...rmarkdown...lua.... Это означает, что программа не смогла найти этот файл.\nСм. https://stackoverflow.com/questions/58830927/rmarkdown-unable-to-locate-lua-filter-when-knitting-to-word\nВозможности:\n\nПакет Rmarkdown не установлен\n\nПакет Rmarkdown не может быть найден\n\nПроблема с правами администратора.\n\nВозможно, R не может найти файл пакета rmarkdown, поэтому проверьте, в какой библиотеке находится пакет rmarkdown (см. код выше). Если пакет установлен в недоступную библиотеку (например, начинается с “\\\\”), попробуйте вручную переместить его в C: или другую библиотеку с именованным диском. Следует помнить, что пакет rmarkdown должен иметь возможность подключения к установке TinyTex, поэтому он не может находиться в библиотеке на сетевом диске.\nОшибка Pandoc 61\nНапример: Error: pandoc document conversion failed with error 61 или Could not fetch...\n\nПопробуйте запустить RStudio от имени администратора (щелкните правой кнопкой мыши на значке, выберите запуск от имени администратора, см. инструкции выше)\n\nТакже посмотрите, можно ли переместить конкретный пакет, с которым не удалось связаться, в библиотеку C:.\n\nОшибка LaTex (см. ниже)\nОшибка подобная: ! Package pdftex.def Error: File 'cict_qm2_2020-06-29_files/figure-latex/unnamed-chunk-5-1.png' not found: using draft setting. или Error: LaTeX failed to compile file_name.tex.\n\nСм. https://yihui.org/tinytex/r/#debugging для советов по дебаггингу.\n\nСм. file_name.log для дополнительной информации\n\nОшибка Pandoc 127\nЭто может быть проблема с RAM (памятью). Перезапустите вашу сессию R и попробуйте снова.\nПодключение (маппинг) сетевых дисков\nПодключение сетевого диска может быть сопряжено с риском. Прежде чем приступать к этому, проконсультируйтесь с ИТ-отделом.\nСовет, взятый из этой дискуссии на форуме:\nКак открыть файл “через подключенный сетевой диск”?\n\nВо-первых, необходимо знать местоположение сети, к которой вы пытаетесь получить доступ.\n\nДалее в файловом менеджере Windows нужно щелкнуть правой кнопкой мыши на правой панели “Этот компьютер” и выбрать пункт “Подключить сетевой диск”.\n\nПройдите через диалог, чтобы определить ранее указанное сетевое расположение как диск с буквенным обозначением.\n\nТеперь у вас есть два способа добраться до открываемого файла. Использование пути по букве диска должно работать.\n\nОшибка в install.packages()\nЕсли у вас появится ошибка, где упоминается директория “lock”, например: Error in install.packages : ERROR: failed to lock directory...\nЗагляните в вашу библиотеку пакетов и вы увидите папку, имя которой начинается с “00LOCK”. Попробуйте выполнить следующие советы:\n\nВручную удалите директорию папки “00LOCK” из библиотеки пакетов. Попробуйте снова установить пакет.\n\nВы можете попробовать команду pacman::p_unlock() (вы можете также ввести эту команду вRprofile, чтобы она выполнялась каждый раз при открытии проекта). Затем попробуйте снова установить пакет. Это может потребовать нескольких попыток.\n\nПопробуйте запустить RStudio в режиме администратора, затем попробуйте установить пакеты по одному.\n\nЕсли ничего не помогло, установите пакет в другую библиотеку или папку (например, Temp), затем вручную скопируйте папку пакета в нужную библиотеку.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>R на сетевых дисках</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.ru.html",
    "href": "new_pages/data_table.ru.html",
    "title": "50  Таблица данных",
    "section": "",
    "text": "50.1 Введение в таблицы данных\nТаблица данных - это двумерная структура данных, подобная датафрейму, позволяющая выполнять сложные операции группирования. Синтаксис data.table построен таким образом, что операции могут выполняться для строк, столбцов и групп.\nСтруктура - DT[i, j, by], разделенная на 3 части; аргументы i, j и by. Аргумент i позволяет взять подмножество требуемых строк, аргумент j позволяет работать со столбцами, а аргумент by позволяет работать со столбцами по группам.\nНа этой странице мы рассмотрим следующие темы:",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Таблица данных</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.ru.html#введение-в-таблицы-данных",
    "href": "new_pages/data_table.ru.html#введение-в-таблицы-данных",
    "title": "50  Таблица данных",
    "section": "",
    "text": "Импорт данных и использование fread() и fwrite()\nВыбор и фильтрация строк, используя аргумент i\nИспользование функций-помощников %like%, %chin%, %between%\nВыбор и расчет по столбцам, используя аргумент j\nРасчет по группам, используя аргумент by\nДобавление и обновление данных в таблицах данных с помощью :=",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Таблица данных</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.ru.html#загрузка-пакетов-и-импорт-данных",
    "href": "new_pages/data_table.ru.html#загрузка-пакетов-и-импорт-данных",
    "title": "50  Таблица данных",
    "section": "50.2 Загрузка пакетов и импорт данных",
    "text": "50.2 Загрузка пакетов и импорт данных\n\nЗагрузка пакетов\nИспользуя функцию p_load() из pacman, мы загружаем (и устанавливаем при необходимости) пакеты, требуемые для данного анализа.\n\npacman::p_load(\n  rio,        # импорт данных\n  data.table, # группирование и вычистка данных\n  tidyverse,  # позволяет использовать функцию оператора канала (%&gt;%) в этой главе\n  here \n  ) \n\n\n\nИмпорт данных\nНа данной странице мы рассмотрим некоторые ключевые функции data.table, используя построчный список, на который мы ссылались в других главах этого руководства.\nМы импортируем набор данных о случаях из смоделированной эпидемии лихорадки Эбола. Если вы хотите загрузить данные, чтобы выполнять действия параллельно, см. инструкции в разделе Скачивание руководства и данных. Набор данных импортируется с помощью функции import() из пакета rio. См. страницу Импорт и экспорт, где приведены разные способы импорта данных. С этого момента мы будем использовать data.table(), чтобы конвертировать датафрейм в таблицу данных.\n\nlinelist &lt;- rio::import(here(\"data\", \"linelist_cleaned.xlsx\")) %&gt;% data.table()\n\nФункция fread() используется напрямую для импорта обычных файлов с разделителями, таких как файлы .csv, напрямую в формат таблицы данных. Эта функция и ее парная функция, fwrite(), используемая для записи таблиц данных в виде обычных файлов с разделителями, являются очень быстрыми и вычислительно эффективными вариантами для больших баз данных.\nПервыу 20 строк linelist:\nКоманды базового R, такие как dim(), которые используются для датафреймов, могут также использоваться для таблиц данных\n\ndim(linelist) #дает количество строк и столбцов в таблице данных\n\n[1] 5888   30",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Таблица данных</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.ru.html#аргумент-i-выбор-и-фильтрация-строк",
    "href": "new_pages/data_table.ru.html#аргумент-i-выбор-и-фильтрация-строк",
    "title": "50  Таблица данных",
    "section": "50.3 Аргумент i: выбор и фильтрация строк",
    "text": "50.3 Аргумент i: выбор и фильтрация строк\nВспоминая структуру DT[i, j, by], мы можем фильтровать строки, используя либо номера строк, либо логические выражения. Аргумент i является первым, поэтому можно использовать синтаксис DT[i] или DT[i,].\nВ первом примере извлекаются первые 5 строк таблицы данных, во втором примере подмножество случаев 18 лет и старше, в третьем примере подмножество случаев 18 лет и старше, но не диагностированных в Central Hospital:\n\nlinelist[1:5] #выдает с 1й по 5ю строки\nlinelist[age &gt;= 18] #подмножество случаев, равных или старше 18 лет\nlinelist[age &gt;= 18 & hospital != \"Central Hospital\"] #подмножество случаев, равных или старше 18 лет, но не диагностированных в Central Hospital\n\nИспользование .N в аргументе i означает общее количество строк в таблице данных. Это может быть использовано для подмножества по номерам строк:\n\nlinelist[.N] #выдает последнюю строку\nlinelist[15:.N] #выдает с 15й по последнюю строки\n\n\nИспользование функций-помощников для фильтра\nВ таблице данных используются вспомогательные функции, которые упрощают выделение подмножества строк. Функция %like% испольузется, чтобы сопоставить набор символов в столбце, %chin% используется для сопоставления по конкретному знаку, а функция-помощник %between% используется, чтобы сопоставить числовые столбцы с заранее указанным диапазоном.\nВ следующем примере мы: * фильтруем строки, где в переменной больницы есть “Hospital” * фильтруем строки, где исход “Recover” (выздоровел) или “Death” (смерть) * фильтруем строки в возрастном диапазоне 40-60\n\nlinelist[hospital %like% \"Hospital\"] #фильтруем строки, где в переменной больницы есть “Hospital”\nlinelist[outcome %chin% c(\"Recover\", \"Death\")] #фильтруем строки, где исход “Recover” (выздоровел) или “Death” (смерть)\nlinelist[age %between% c(40, 60)] #фильтруем строки в возрастном диапазоне 40-60\n\n#%between% должен принять вектор длины 2, а %chin% может принять векторы длины &gt;= 1",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Таблица данных</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.ru.html#аргумент-j-выбор-и-расчет-по-столбцам",
    "href": "new_pages/data_table.ru.html#аргумент-j-выбор-и-расчет-по-столбцам",
    "title": "50  Таблица данных",
    "section": "50.4 Аргумент j: выбор и расчет по столбцам",
    "text": "50.4 Аргумент j: выбор и расчет по столбцам\nИспользуя структуру DT[i, j, by], мы можем выбирать столбцы с помощью чисел или имен. Аргумент j является вторым, поэтому используется синтаксис DT[, j]. Для облегчения вычислений над аргументом j столбец оборачивается с помощью либо list(), либо .().\n\nВыбор столбцов\nПервый пример извлекает первый, третий и пятый столбцы таблицы данных, второй пример выбирает все столбцы, кроме столбцов рост, вес и пол. В третьем примере используется обертка .(), чтобы выбрать столбцы case_id и outcome.\n\nlinelist[ , c(1,3,5)]\nlinelist[ , -c(\"gender\", \"age\", \"wt_kg\", \"ht_cm\")]\nlinelist[ , list(case_id, outcome)] #linelist[ , .(case_id, outcome)] работает столь же хорошо\n\n\n\nРасчет по столбцам\nКомбинируя аргументы i и j, можно фильтровать строки и вычислять по столбцам. Использование .N в аргументе j также представляет общее количество строк в таблице данных и может быть полезно для возврата количества строк после фильтрации строк.\nВ следующем примере мы: * Считаем количества случаев пребывания в стационаре более 7 дней * Считаем средний возраст больных, умерших в military hospital * Считаем стандартное отклонение, медиану, средний возраст пациентов, выздоровевших в central hospital\n\nlinelist[days_onset_hosp &gt; 7 , .N]\n\n[1] 189\n\nlinelist[hospital %like% \"Military\" & outcome %chin% \"Death\", .(mean(age, na.rm = T))] #na.rm = T удаляет значения N/A\n\n        V1\n     &lt;num&gt;\n1: 15.9084\n\nlinelist[hospital == \"Central Hospital\" & outcome == \"Recover\", \n                 .(mean_age = mean(age, na.rm = T),\n                   median_age = median(age, na.rm = T),\n                   sd_age = sd(age, na.rm = T))] #Этот синтаксис не использует функции-помощники, но работает так же хорошо\n\n   mean_age median_age   sd_age\n      &lt;num&gt;      &lt;num&gt;    &lt;num&gt;\n1: 16.85185         14 12.93857\n\n\nПомните, что использование обертки .() в аргументе j упрощает расчет, выдает таблицу данных и позволяет именовать столбцы.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Таблица данных</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.ru.html#аргумент-by-расчет-по-группам",
    "href": "new_pages/data_table.ru.html#аргумент-by-расчет-по-группам",
    "title": "50  Таблица данных",
    "section": "50.5 Аргумент by: расчет по группам",
    "text": "50.5 Аргумент by: расчет по группам\nАргумент by - третий аргумент в структуре DT[i, j, by]. Аргумент by принимает и синтаксис текстового вектора, и list() или .(). Использование синтаксиса .() в аргументе by позволяет на ходу переименовывать столбцы.\nВ следующем примере мы: * группируем количество случаев по больнице * в случаях 18 лет и старше, рассчитываем средний рост и вес случаев по полу и в зависимости от того, они выздоровели или умерли * в случаях госпитализации, продолжавшейся более 7 дней, подсчитывается количество случаев в зависимости от месяца госпитализации и больницы, в которую они были госпитализированы\n\nlinelist[, .N, .(hospital)] #количество случаев по больнице\n\n                               hospital     N\n                                 &lt;char&gt; &lt;int&gt;\n1:                                Other   885\n2:                              Missing  1469\n3: St. Mark's Maternity Hospital (SMMH)   422\n4:                        Port Hospital  1762\n5:                    Military Hospital   896\n6:                     Central Hospital   454\n\nlinelist[age &gt; 18, .(mean_wt = mean(wt_kg, na.rm = T),\n                             mean_ht = mean(ht_cm, na.rm = T)), .(gender, outcome)] #NA представляют категории, где данные отсутствуют\n\n   gender outcome  mean_wt  mean_ht\n   &lt;char&gt;  &lt;char&gt;    &lt;num&gt;    &lt;num&gt;\n1:      m Recover 71.90227 178.1977\n2:      f   Death 63.27273 159.9448\n3:      m   Death 71.61770 175.4726\n4:      f    &lt;NA&gt; 64.49375 162.7875\n5:      m    &lt;NA&gt; 72.65505 176.9686\n6:      f Recover 62.86498 159.2996\n7:   &lt;NA&gt; Recover 67.21429 175.2143\n8:   &lt;NA&gt;   Death 69.16667 170.7917\n9:   &lt;NA&gt;    &lt;NA&gt; 70.25000 175.5000\n\nlinelist[days_onset_hosp &gt; 7, .N, .(month = month(date_hospitalisation), hospital)]\n\n    month                             hospital     N\n    &lt;num&gt;                               &lt;char&gt; &lt;int&gt;\n 1:     5                    Military Hospital     3\n 2:     6                        Port Hospital     4\n 3:     7                        Port Hospital     8\n 4:     8 St. Mark's Maternity Hospital (SMMH)     5\n 5:     8                    Military Hospital     9\n 6:     8                                Other    10\n 7:     8                        Port Hospital    10\n 8:     9                        Port Hospital    28\n 9:     9                              Missing    27\n10:     9                     Central Hospital    10\n11:     9 St. Mark's Maternity Hospital (SMMH)     6\n12:    10                              Missing     2\n13:    10                    Military Hospital     3\n14:     3                        Port Hospital     1\n15:     4                    Military Hospital     1\n16:     5                                Other     2\n17:     5                     Central Hospital     1\n18:     5                              Missing     1\n19:     6                              Missing     7\n20:     6 St. Mark's Maternity Hospital (SMMH)     2\n21:     6                    Military Hospital     1\n22:     7                    Military Hospital     3\n23:     7                                Other     1\n24:     7                              Missing     2\n25:     7 St. Mark's Maternity Hospital (SMMH)     1\n26:     8                     Central Hospital     2\n27:     8                              Missing     6\n28:     9                                Other     9\n29:     9                    Military Hospital    11\n30:    10                        Port Hospital     3\n31:    10                                Other     4\n32:    10 St. Mark's Maternity Hospital (SMMH)     1\n33:    10                     Central Hospital     1\n34:    11                              Missing     2\n35:    11                        Port Hospital     1\n36:    12                        Port Hospital     1\n    month                             hospital     N\n\n\nData.table также позволяет связывать выражения в цепочку следующим образом:\n\nlinelist[, .N, .(hospital)][order(-N)][1:3] #1-я выбирает все случаи по больницам, 2-я упорядочивает случаи в порядке убывания, 3-я выделяет 3 больницы с наибольшим количеством случаев\n\n            hospital     N\n              &lt;char&gt; &lt;int&gt;\n1:     Port Hospital  1762\n2:           Missing  1469\n3: Military Hospital   896\n\n\nВ этих примерах мы исходим из того, что строка в таблице данных равна новому случаю, поэтому для представления количества строк в таблице данных можно использовать .N. Другой полезной функцией для представления количества уникальных случаев является uniqueN(), которая выдает количество уникальных значений при заданных входных данных. Это показано ниже:\n\nlinelist[, .(uniqueN(gender))] #помните .() в аргументе j выдаст таблицу данных\n\n      V1\n   &lt;int&gt;\n1:     3\n\n\nОтветом будет 3, так как уникальные значения в столбце пол - это m, f и N/A. Сравните с функцией базового R unique(), которая выдает все уникальные значения в заданных входных данных:\n\nlinelist[, .(unique(gender))]\n\n       V1\n   &lt;char&gt;\n1:      m\n2:      f\n3:   &lt;NA&gt;\n\n\nЧтобы найти количество уникальных случаев в заданном месяце, мы напишем следующее:\n\nlinelist[, .(uniqueN(case_id)), .(month = month(date_hospitalisation))]\n\n    month    V1\n    &lt;num&gt; &lt;int&gt;\n 1:     5    62\n 2:     6   100\n 3:     7   198\n 4:     8   509\n 5:     9  1170\n 6:    10  1228\n 7:    11   813\n 8:    12   576\n 9:     1   434\n10:     2   310\n11:     3   290\n12:     4   198",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Таблица данных</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.ru.html#добавление-и-обновление-таблиц-данных",
    "href": "new_pages/data_table.ru.html#добавление-и-обновление-таблиц-данных",
    "title": "50  Таблица данных",
    "section": "50.6 Добавление и обновление таблиц данных",
    "text": "50.6 Добавление и обновление таблиц данных\nОператор := используется, чтобы добавить или обновить данные в таблице данных. Добавление столбцов в вашу таблицу данных можно сделать следующим образом:\n\nlinelist[, adult := age &gt;= 18] #добавляет один столбец\nlinelist[, c(\"child\", \"wt_lbs\") := .(age &lt; 18, wt_kg*2.204)] #для добавления нескольких столбцов требуется синтаксис c(\"\") и list() или .()\nlinelist[, `:=` (bmi_in_range = (bmi &gt; 16 & bmi &lt; 40),\n                         no_infector_source_data = is.na(infector) | is.na(source))] #этот метод использует := в качестве функционального оператора `:=`\nlinelist[, adult := NULL] #удаляет столбец\n\nДальнейшие сложные агрегации выходят за рамки этой вводной главы, но идея состоит в том, чтобы предоставить популярную и жизнеспособную альтернативу dplyr для группирования и вычистки данных. Пакет data.table является замечательным пакетом, который позволяет использовать удобный и читаемый код.",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Таблица данных</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.ru.html#ресурсы",
    "href": "new_pages/data_table.ru.html#ресурсы",
    "title": "50  Таблица данных",
    "section": "50.7 Ресурсы",
    "text": "50.7 Ресурсы\nВот некоторые полезные ресурсы для информации: * https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html * https://github.com/Rdatatable/data.table * https://s3.amazonaws.com/assets.datacamp.com/img/blog/data+table+cheat+sheet.pdf * https://www.machinelearningplus.com/data-manipulation/datatable-in-r-complete-guide/ * https://www.datacamp.com/community/tutorials/data-table-r-tutorial\nВы можете выполнить любую резюмирующую функцию для группированных данных; см. шпаргалку для получения дополнительной информации: https://s3.amazonaws.com/assets.datacamp.com/blog_assets/datatable_Cheat_Sheet_R.pdf",
    "crumbs": [
      "Разное",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Таблица данных</span>"
    ]
  }
]