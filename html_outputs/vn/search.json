[
  {
    "objectID": "index.vn.html",
    "href": "index.vn.html",
    "title": "Cẩm nang dịch tễ học với R",
    "section": "",
    "text": "Chào mừng",
    "crumbs": [
      "Chào mừng"
    ]
  },
  {
    "objectID": "index.vn.html#phân-tích-dữ-liệu-dịch-tễ-học-và-y-tế-công-cộng-với-r",
    "href": "index.vn.html#phân-tích-dữ-liệu-dịch-tễ-học-và-y-tế-công-cộng-với-r",
    "title": "Cẩm nang dịch tễ học với R",
    "section": "Phân tích dữ liệu dịch tễ học và y tế công cộng với R",
    "text": "Phân tích dữ liệu dịch tễ học và y tế công cộng với R\nSử dụng: Sổ tay này đã được sử dụng trên 1 triệu lần bởi 450,000 người trên toàn thế giới.\nMục tiêu: Là một tài liệu tham khảo R một cách nhanh chóng (trực tuyến và ngoại tuyến), cung cấp các ví dụ tập trung vào nhiệm vụ giải quyết các vấn đề dịch tễ học phổ biến.\nBạn mới bắt đầu học R? Thử trải nghiệm các học phần tương tác miễn phí hoặc khóa học trực tuyến nền tảng về R của chúng tôi, đã được sử dụng bởi US CDC, WHO, 75+ tổ chức y tế khác, và các Chương trình đào tạo dịch tễ học thực địa (FETP) trên toàn thế giới.\nNgôn ngữ: Tiếng Anh (English), Tiếng Việt, Tiếng Pháp (Français), Tiếng Tây Ban Nha (Español), Tiếng Nhật (日本), Tiếng Thổ Nhĩ Kỳ (Türkçe), Tiếng Bồ Đào Nha (Português), Tiếng Nga (Русский)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\nĐược viết bởi các nhà dịch tễ học, dành cho các nhà dịch tễ học\nApplied Epi là một tổ chức phi lợi nhuận của các nhà dịch tễ học thực địa từ khắp mọi nơi trên thế giới. Chúng tôi dành thời gian rảnh rỗi của mình để viết và cung cấp tài liệu này cho cộng đồng. Mọi lời động viên khuyến khích và phản hồi của bạn đều được chúng tôi chào đón:\n\nTruy cập website của chúng tôi và ghi danh vào danh sách liên lạc\n\ncontact@appliedepi.org, tweet @appliedepi, hoặc LinkedIn\n\nGửi các vấn đề cho chúng tôi tại Github repository\nCác góp ý liên quan tới bản dịch, vui lòng liên hệ Trưởng nhóm dịch\n\nChúng tôi cũng cung cấp các khóa học trực tuyến với đội ngũ giảng viên giàu kinh nghiệm đến từ khắp mọi nơi trên thế giới. Hãy liên hệ với chúng tôi nếu bạn cần sự hỗ trợ.",
    "crumbs": [
      "Chào mừng"
    ]
  },
  {
    "objectID": "index.vn.html#sổ-tay-này-được-sử-dụng-như-thế-nào",
    "href": "index.vn.html#sổ-tay-này-được-sử-dụng-như-thế-nào",
    "title": "Cẩm nang dịch tễ học với R",
    "section": "Sổ tay này được sử dụng như thế nào",
    "text": "Sổ tay này được sử dụng như thế nào\n\nTruy cập các trang trong phần Mục lục, hoặc sử dụng ô tìm kiếm\nNhấn biểu tượng “copy” để sao chép code\n\nKết hợp theo dõi cùng với các bộ dữ liệu minh họa\n\nXem phần “Tài nguyên” trong từng chương để tìm thêm tài liệu\n\nPhiên bản ngoại tuyến\nXem hướng dẫn tại trang Tải sách và dữ liệu.",
    "crumbs": [
      "Chào mừng"
    ]
  },
  {
    "objectID": "index.vn.html#lời-cảm-ơn",
    "href": "index.vn.html#lời-cảm-ơn",
    "title": "Cẩm nang dịch tễ học với R",
    "section": "Lời cảm ơn",
    "text": "Lời cảm ơn\nSổ tay này được tạo ra bởi sự hợp tác của các nhà dịch tễ học từ khắp nơi trên thế giới, đúc kết kinh nghiệm cùng với các tổ chức khác bao gồm các cơ quan y tế địa phương, tiểu bang, tỉnh và quốc gia, Tổ chức Y tế Thế giới (WHO), Tổ chức Bác sỹ không biên giới (MSF), hệ thống các bệnh viện, và các đơn vị nghiên cứu.\nSổ tay này không phải là sản phẩm đã được phê duyệt của bất kỳ tổ chức cụ thể nào. Mặc dù chúng tôi cố gắng đảm bảo tính chính xác, nhưng chúng tôi không chịu trách nhiệm về nội dung trong cuốn sách này.\n\nNhững người đóng góp\nChủ biên: Neale Batra\nNhóm tác giả: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonathan Polonsky, Yurie Izawa, Chris Bailey, Daniel Molling, Isha Berry, Emma Buajitti, Mathilde Mousset, Sara Hollis, Wen Lin\nNhóm dịch giả: Nguyễn Thanh Lương, Võ Hữu Thuận, Nguyễn Trung Thành, Vũ Thu Hà, Hồ Hoàng Dung\nNhóm phản biện: Pat Keating, Amrish Baidjoe, Annick Lenglet, Margot Charette, Danielly Xavier, Marie-Amélie Degail Chabrat, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Kate Kelsey, Berhe Etsay, John Rossow, Mackenzie Zendt, James Wright, Laura Haskins, Flavio Finger, Tim Taylor, Jae Hyoung Tim Lee, Brianna Bradley, Wayne Enanoria, Manual Albela Miranda, Molly Mantus, Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao Muianga\nHình minh họa: Calder Fong\n\n\n\n\n\n\nTài trợ và hỗ trợ\nSổ tay này là sản phẩm chủ yếu được hình thành từ các nỗ lực tình nguyện hàng nghìn giờ để tạo ra.\nNó cũng nhận được một phần tài trợ thông qua kinh phí hỗ trợ trợ xây dựng năng lực khẩn cấp COVID-19 từ TEPHINET, mạng lưới toàn cầu của các Chương trình Đào tạo Dịch tễ học Thực địa (FETPs).\nCác hỗ trợ hành chính được cung cấp bởi mạng lưới cựu sinh EPIET (EAN), với lời cảm ơn đặc biệt tới Annika Wendland. EPIET là Chương trình đào tạo Dịch tễ học can thiệp tại Châu Âu.\nĐặc biệt gửi lời cảm ơn tới Trung tâm Điều hành Amsterdam (OCA) của Tổ chức Bác sỹ không biên giới (MSF) cho những sự hỗ trợ của họ trong quá trình phát triển cuốn sổ tay này.\nẤn phẩm này được hỗ trợ bởi Hợp đồng Hợp tác số NU2GGH001873, được tài trợ bởi Trung tâm Kiểm soát và Phòng ngừa Dịch bệnh thông qua TEPHINET, một chương trình của Lực lượng đặc nhiệm về sức khỏe toàn cầu. Nội dung của sổ tay hoàn toàn do tác giả chịu trách nhiệm và đại diện cho quan điểm chính thức của Trung tâm Kiểm soát và Phòng ngừa Dịch bệnh, Bộ Y tế và Dịch vụ Nhân sinh, Lực lượng Đặc nhiệm về Sức khỏe Toàn cầu, hoặc TEPHINET\n\n\nCảm hứng\nRất nhiều các hướng dẫn và tóm tắt cung cấp kiến thức sử dụng để phát triển nội dung sổ tay này được tham khảo trong các trang nội dung tương ứng.\nMột cách tổng quát hơn, các nguồn sau đây đã truyền nguồn cảm hứng cho cuốn sổ tay này:\nThe “R4Epis” project (một sự hợp tác giữa MSF và RECON)\nR Epidemics Consortium (RECON)\nR for Data Science book (R4DS)\nbookdown: Authoring Books and Technical Documents with R Markdown\nNetlify để lưu trữ trang web này",
    "crumbs": [
      "Chào mừng"
    ]
  },
  {
    "objectID": "index.vn.html#điều-khoản-sử-dụng-và-đóng-góp",
    "href": "index.vn.html#điều-khoản-sử-dụng-và-đóng-góp",
    "title": "Cẩm nang dịch tễ học với R",
    "section": "Điều khoản sử dụng và đóng góp",
    "text": "Điều khoản sử dụng và đóng góp\n\nGiấy phép\nSổ tay này được cấp phép theo Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\nChúng tôi khuyến khích các khóa học và các chương trình đào tạo dịch tễ sử dụng cuốn sổ tay này cho sinh viên của mình. Nếu bạn có thắc mắc về mục đích sử dụng của mình, hãy gửi email tới epiRhandbook@gmail.com.\n\n\nTrích dẫn\nNeale Batra và cộng sự, Cẩm nang Dịch tễ học với R. \n\n\nĐóng góp\nNếu bạn muốn đóng góp nội dung, vui lòng liên hệ với chúng tôi thông qua Github hoặc email. Chúng tôi đang triển khai lịch trình cập nhật cho cuốn sách cũng như xây dựng hướng dẫn dành cho cộng tác viên.\nXin lưu ý rằng dự án epiRhandbook được phát hành cùng với bộ Quy tắc ứng xử của cộng tác viên. Bằng cách đóng góp cho dự án này, bạn đồng ý tuân theo các điều khoản của nó.",
    "crumbs": [
      "Chào mừng"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.vn.html",
    "href": "new_pages/editorial_style.vn.html",
    "title": "1  Biên tập và ghi chú kỹ thuật",
    "section": "",
    "text": "1.1 Cách tiếp cận và phong cách\nĐộc giả tiềm năng của cuốn sách này là rất lớn, bao gồm những người hoàn toàn mới đối với R, và cả những người dùng R có kinh nghiệm đang tìm kiếm cho mình các phương pháp và mẹo hay nhất. Vì vậy, cuốn sách cần phải vừa dễ tiếp cận vừa ngắn gọn. Do đó, cách tiếp cận của chúng tôi là cung cấp lượng văn bản giải thích vừa đủ để một người mới sử dụng R cũng có thể áp dụng code và hiểu code đang làm gì.\nMột vài điểm lưu ý:",
    "crumbs": [
      "Về cuốn sách này",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Biên tập và ghi chú kỹ thuật</span>"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.vn.html#cách-tiếp-cận-và-phong-cách",
    "href": "new_pages/editorial_style.vn.html#cách-tiếp-cận-và-phong-cách",
    "title": "1  Biên tập và ghi chú kỹ thuật",
    "section": "",
    "text": "Đây là cuốn sách tham khảo về code đi kèm với những ví dụ tương đối ngắn gọn - không phải một cuốn sách giáo khoa về R hay khoa học dữ liệu\n\nĐây là một cuốn sổ tay về R sử dụng trong dịch tễ học ứng dụng - không phải là một hướng dẫn về các phương pháp của dịch tễ học ứng dụng\n\nCuốn sách dự kiến sẽ luôn được thay đổi và cập nhập do các R packages tối ưu cho một nhiệm vụ luôn được thay đổi thường xuyên, vì vậy chúng tôi hoan nghênh những thảo luận về những điều được nhấn mạnh trong cuốn sách này\n\n\nR packages\nQuá nhiều lựa chọn\nMột trong những khía cạnh thách thức nhất của việc học R là bạn biết package nào được sử dụng trong trường hợp nào. Việc vật lộn với một công việc mà chỉ sau này bạn nhận ra là có một package R giúp bạn thực hiện tất cả những điều đó trong một dòng lệnh là điều không hề hiếm gặp!\nTrong sổ tay này, chúng tôi cố gắng cung cấp cho bạn ít nhất hai cách để hoàn thành công việc: một phương pháp đã thử và đúng (có thể là base R hoặc tidyverse) và một R package đặc biệt được thiết kế riêng cho mục đích đó. Chúng tôi muốn bạn có một số tùy chọn trong trường hợp bạn không thể tải xuống một package nhất định hoặc package đó không hoạt động với bạn.\nKhi lựa chọn package để làm việc, chúng tôi ưu tiên các R package và phương pháp tiếp cận đã được cộng đồng thử nghiệm và hiệu chỉnh, giảm thiểu số lượng package được sử dụng trong một phiên làm việc điển hình, bao gồm sự ổn định (không thay đổi thường xuyên) và giúp hoàn thành nhiệm vụ một cách đơn giản và gọn gàng\nCuốn sách này ưu tiện các package và câu lệnh từ thư viện tidyverse. Tidyverse là một tuyển tập các R package được thiết kế dành riêng cho khoa học dữ liệu, trong đó các package này chia sẻ nền tảng ngữ pháp và cấu trúc dữ liệu chung. Tất cả các package từ thư viện tidyverse có thể được cài đặt hoặc gọi thông qua thư viện tidyverse. Đọc thêm tại tidyverse website.\nKhi thích hợp, chúng tôi cũng cung cấp các tùy chọn code sử dụng base R - là các packages và hàm có sẵn của R khi cài đặt. Điều này là do chúng tôi nhận thấy rằng một số độc giả của cuốn sách này có thể không có Internet tốt để tải xuống các package bổ sung.\nLiên kết các hàm và packages một cách rõ ràng\nTrong các hướng dẫn về R thường rất khó chịu khi một hàm được hiển thị trong code, nhưng bạn không biết hàm đó đến từ package nào! Chúng tôi cố gắng tránh tình trạng này.\nTrong các đoạn văn bản trần thuật, tên các package được viết in đậm (ví dụ: dplyr) và các hàm được viết như sau: mutate(). Chúng tôi cố gắng nói rõ ràng về một hàm đến từ package nào, bằng cách tham chiếu package đó trong đoạn văn bản gần đó hoặc nhấn mạnh package đó một cách rõ ràng trong đoạn code như sau: dplyr::mutate(). Điều này nhìn có vẻ thừa thãi, nhưng chúng tôi làm điều đó là có mục đích.\nTham khảo thêm chương R cơ bản để hiểu thêm về package và hàm.\n\n\nPhong cách viết code\nTrong sổ tay này, chúng tôi thường viết theo phong cách “thêm dòng mới”, điều này làm cho code trông có vẻ “dài hơn”. Chúng tôi làm vậy vì một vài lý do sau đây:\n\nChúng tôi có thể viết các giải thích bằng # bên cạnh mỗi phần nhỏ của code\n\nNhìn chung, code dài hơn (theo chiều dọc) thì dễ đọc hơn\n\nNó cũng dễ đọc hơn trong một diện tích màn hình hẹp (không cần kéo thanh điều hướng trái phải)\n\nTừ việc thụt lề, có thể dễ dàng hơn để biết arguments nào thuộc về hàm nào\n\nKết quả là, code lẽ ra sẽ được viết trông như thế này:\n\nlinelist %&gt;% \n  group_by(hospital) %&gt;%  # group rows by hospital\n  slice_max(date, n = 1, with_ties = F) # if there's a tie (of date), take the first row\n\n…bây giờ sẽ được viết như thế này:\n\nlinelist %&gt;% \n  group_by(hospital) %&gt;% # group rows by hospital\n  slice_max(\n    date,                # keep row per group with maximum date value \n    n = 1,               # keep only the single highest row \n    with_ties = F)       # if there's a tie (of date), take the first row\n\nCode R thường không bị ảnh hưởng bởi thêm các dòng mới hoặc thụt lề. Khi viết code, nếu bạn xuống dòng ngay sau dấu phẩy thì R sẽ tự động thụt lề cho bạn.\nChúng tôi cũng sử dụng rất nhiều những khoảng cách (ví dụ n = 1 thay vì n=1) vì nó giúp dễ đọc hơn. Hãy văn minh với những người đang đọc code của bạn!\n\n\nDanh pháp\nTrong sổ tay này, chúng tôi thường đề cập đến “cột” và “hàng” thay vì dùng “biến” và “quan sát”. Như đã giải thích trong phần sơ lược về “tidy data”, hầu hết các bộ dữ liệu thống kê dịch tễ học bao gồm các hàng, cột và giá trị theo cấu trúc\nBiến số chứa các giá trị đo lường của cùng một thuộc tính (như nhóm tuổi, kết cục hoặc ngày khởi phát). Các quan sát bao gồm tất cả các giá trị được đo trên cùng một đơn vị (ví dụ: người, địa điểm hoặc mẫu phòng thí nghiệm). Vì vậy, những khía cạnh này có thể khó được định nghĩa một cách cụ thể.\nTrong một bộ dữ liệu “tidy”, mỗi cột là một biến số, mỗi hàng là một quan sát và mỗi ô là một giá trị duy nhất. Tuy nhiên, bạn có thể gặp một số bộ dữ liệu không phù hợp với quy luật này - bộ dữ liệu định dạng “ngang” có thể có một biến số được chia thành nhiều cột (xem ví dụ trong chương Pivoting dữ liệu). Tương tự như vậy, các quan sát có thể được trải thành nhiều hàng.\nPhần lớn cuốn sách này tập trung vào quản lý và biến đổi dữ liệu, vì vậy việc đề cập đến cấu trúc dữ liệu cụ thể của các hàng và cột sẽ liên quan hơn là đề cập tới các khái niệm trừu tượng như các quan sát và biến. Các trường hợp ngoại lệ chủ yếu xảy ra trong các chương về phân tích dữ liệu, ở đó chúng tôi đề cập nhiều hơn đến các biến số và quan sát.\n\n\nLưu ý\nDưới đây là một vài lưu ý bạn có thể gặp trong cuốn sách:\nGHI CHÚ: Đây là ghi chú\nMẸO: Đây là mẹo.\nCẨN TRỌNG: Đây là ghi chú cẩn trọng.\nNGUY HIỂM: Đây là một cảnh báo.",
    "crumbs": [
      "Về cuốn sách này",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Biên tập và ghi chú kỹ thuật</span>"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.vn.html#quyết-định-biên-tập",
    "href": "new_pages/editorial_style.vn.html#quyết-định-biên-tập",
    "title": "1  Biên tập và ghi chú kỹ thuật",
    "section": "1.2 Quyết định biên tập",
    "text": "1.2 Quyết định biên tập\nDưới đây, chúng tôi ghi lại các quyết định biên tập quan trọng về việc lựa chọn package và hàm. Nếu bạn không đồng ý hoặc muốn đưa ra một công cụ mới để xem xét, vui lòng tham gia/bắt đầu cuộc thảo luận trên Trang Github của chúng tôi.\nBảng các package, hàm, và các quyết định biên tập khác\n\n\n\n\n\n\n\n\n\n\nChủ đề\nCân nhắc\nLựa chọn\nLý do ngắn gọn\n\n\n\n\n\nPhương pháp code chung\ntidyverse, data.table, base\ntidyverse, với 1 chương về data.table, các giải pháp thay thế từ base R cho người đọc không có internet | tidyverse dễ đọc, phổ biến, được dạy nhiều nhất\n\n\nGọi Package\nlibrary(),install.packages(), require(), pacman\npacman\nRút ngắn và đơn giản hóa code cho hầu hết các trường hợp cài đặt / tải nhiều package\n\n\n\nNhập và xuất\nrio, và các package khác\nrio\nDễ dàng cho nhiều kiểu file\n\n\n\nNhóm để tổng hợp thống kê\ndplyr group_by(), stats aggregate()\ndplyr group_by()\nThống nhất với tidyverse\n\n\n\nPivoting\ntidyr (các hàm pivot), reshape2 (melt/cast), tidyr (spread/gather)\ntidyr (các hàm pivot)\nreshape2 đã nghỉ hưu tidyr sử dụng các hàm pivot ở phiên bản v1.0.0\n\n\n\nLàm sạch tên cột\nlinelist, janitor\njanitor\nHợp nhất các package được nhắc đến\n\n\n\nEpiweeks\nlubridate, aweek, tsibble, zoo\nthông thường là lubridate ,các package khác tùy trường hợp cụ thể | lubridate dễ đọc, có tính nhất quán, và triển vọng bảo trì gói |\n\n\nNhãn ggplot\nlabs(), ggtitle()/ylab()/xlab()\nlabs()\ntất cả các nhãn ở một nơi, đơn giản\n\n\n\nChuyển sang factor\nfactor(), forcats\nforcats\ncác hàm khác nhau của nó cũng chuyển đổi thành factor trong cùng một lệnh\n\n\n\nĐường cong dịch bệnh\nincidence, ggplot2, EpiCurve\nincidence2 thì nhanh, ggplot2 thì chi tiết\ntùy theo\n\n\n\nSự kết hợp\npaste(), paste0(), str_glue(), glue()\nstr_glue()\nNhiều cú pháp đơn giản hơn hàm paste; nằm bên trong stringr",
    "crumbs": [
      "Về cuốn sách này",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Biên tập và ghi chú kỹ thuật</span>"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.vn.html#các-bản-sửa-đổi-chính",
    "href": "new_pages/editorial_style.vn.html#các-bản-sửa-đổi-chính",
    "title": "1  Biên tập và ghi chú kỹ thuật",
    "section": "1.3 Các bản sửa đổi chính",
    "text": "1.3 Các bản sửa đổi chính\n\n\n\nNgày\nThay đổi chính\n\n\n\n\n10 Tháng Năm 2021\nPhát hành phiên bản 1.0.0",
    "crumbs": [
      "Về cuốn sách này",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Biên tập và ghi chú kỹ thuật</span>"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.vn.html#thông-tin-phiên-làm-việc-r-rstudio-packages",
    "href": "new_pages/editorial_style.vn.html#thông-tin-phiên-làm-việc-r-rstudio-packages",
    "title": "1  Biên tập và ghi chú kỹ thuật",
    "section": "1.4 Thông tin phiên làm việc (R, RStudio, packages)",
    "text": "1.4 Thông tin phiên làm việc (R, RStudio, packages)\nDưới đây là thông tin về các phiên bản của các R package, RStudio và R được sử dụng trong quá trình rendering cuốn sách này.\n\nsessioninfo::session_info()\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31 ucrt)\n os       Windows 11 x64 (build 22621)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       Europe/Stockholm\n date     2024-05-10\n pandoc   3.1.11 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n cli           3.6.2   2023-12-11 [2] CRAN (R 4.3.2)\n digest        0.6.35  2024-03-11 [1] CRAN (R 4.3.3)\n evaluate      0.23    2023-11-01 [2] CRAN (R 4.3.2)\n fastmap       1.1.1   2023-02-24 [2] CRAN (R 4.3.2)\n htmltools     0.5.8   2024-03-25 [1] CRAN (R 4.3.3)\n htmlwidgets   1.6.4   2023-12-06 [2] CRAN (R 4.3.2)\n jsonlite      1.8.8   2023-12-04 [2] CRAN (R 4.3.2)\n knitr         1.45    2023-10-30 [2] CRAN (R 4.3.2)\n rlang         1.1.3   2024-01-10 [2] CRAN (R 4.3.2)\n rmarkdown     2.26    2024-03-05 [1] CRAN (R 4.3.3)\n rstudioapi    0.15.0  2023-07-07 [2] CRAN (R 4.3.2)\n sessioninfo   1.2.2   2021-12-06 [2] CRAN (R 4.3.2)\n xfun          0.43    2024-03-25 [1] CRAN (R 4.3.3)\n\n [1] C:/Users/ngulu864/AppData/Local/R/win-library/4.3\n [2] C:/Program Files/R/R-4.3.2/library\n\n──────────────────────────────────────────────────────────────────────────────",
    "crumbs": [
      "Về cuốn sách này",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Biên tập và ghi chú kỹ thuật</span>"
    ]
  },
  {
    "objectID": "new_pages/data_used.vn.html",
    "href": "new_pages/data_used.vn.html",
    "title": "2  Tải sách và dữ liệu",
    "section": "",
    "text": "2.1 Tải sách ngoại tuyến\nBạn có thể tải xuống phiên bản ngoại tuyến của sổ tay này dưới dạng tệp HTML để có thể xem trong trình duyệt web của mình ngay cả khi bạn không có kết nối internet. Nếu bạn đang cân nhắc việc sử dụng ngoại tuyến Sổ tay Epi R, dưới đây là một số điều bạn cần cân nhắc:\nCó hai cách bạn có thể tải xuống sổ tay:",
    "crumbs": [
      "Về cuốn sách này",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Tải sách và dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/data_used.vn.html#tải-sách-ngoại-tuyến",
    "href": "new_pages/data_used.vn.html#tải-sách-ngoại-tuyến",
    "title": "2  Tải sách và dữ liệu",
    "section": "",
    "text": "Khi bạn mở tệp, có thể mất một đến hai phút để tải các hình ảnh và mục lục\n\nPhiên bản ngoại tuyến có bố cục hơi khác so với phiên bản trực tuyến - là một trang rất dài với Mục lục ở phía bên trái. Để tìm kiếm các cụm từ cụ thể, hãy sử dụng Ctrl + F (Cmd-f)\n\nXem chương Package đề xuất để hỗ trợ bạn cài đặt các R package thích hợp trước khi bạn mất kết nối internet\n\nCài đặt package epirhandbook của chúng tôi trong đó chứa tất cả các dữ liệu minh họa (quy trình cài đặt được mô tả bên dưới)\n\n\n\nSử dụng link download\nĐể truy cập nhanh, nháy phải chuột vào link này và lựa chọn “Save link as”.\nNếu trên máy Mac, hãy sử dụng Cmd + Nhấp chuột. Nếu trên điện thoại di động, hãy bấm và giữ liên kết và chọn “Save link”. Sổ tay sẽ tải xuống thiết bị của bạn. Nếu trên màn hình xuất hiện mã HTML gốc, hãy đảm bảo bạn đã làm đúng theo các hướng dẫn bên trên hoặc thử Phương án 2.\n\n\nSử dụng package của chúng tôi\nChúng tôi cung cấp một R package có tên là epirhandbook. Nó bao gồm một hàm có tên download_book() giúp bạn tải xuống sổ tay này từ kho Github của chúng tôi vào máy tính của bạn.\nPackage này cũng chứa hàm get_data() giúp tải xuống toàn bộ các dữ liệu minh họa vào máy tính của bạn.\nChạy dòng code sau để cài đặt package epirhandbook từ Github repository appliedepi. Đây không phải là package thuộc CRAN, do đó cần sử dụng hàm đặc biệt p_install_gh() để cài đặt nó từ Github.\n\n# install the latest version of the Epi R Handbook package\npacman::p_install_gh(\"appliedepi/epirhandbook\")\n\nBây giờ, bạn gọi package để sử dụng cho phiên làm việc R hiện tại:\n\n# load the package for use\npacman::p_load(epirhandbook)\n\nTiếp theo, bạn chạy hàm download_book() (phần trong ngoặc bỏ trống) để tải sổ tay vào máy tính của bạn. Nếu bạn sử dụng RStudio, một cửa sổ sẽ xuất hiện cho phép bạn lựa chọn thư mục lưu trữ.\n\n# download the offline handbook to your computer\ndownload_book()",
    "crumbs": [
      "Về cuốn sách này",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Tải sách và dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/data_used.vn.html#tải-dữ-liệu-xuống-để-tiện-theo-dõi",
    "href": "new_pages/data_used.vn.html#tải-dữ-liệu-xuống-để-tiện-theo-dõi",
    "title": "2  Tải sách và dữ liệu",
    "section": "2.2 Tải dữ liệu xuống để tiện theo dõi",
    "text": "2.2 Tải dữ liệu xuống để tiện theo dõi\nĐể “tiện theo dõi” cùng với sổ tay này, bạn có thể tải xuống các bộ dữ liệu minh họa và các kết quả.\n\nSử dụng package của chúng tôi\nCách dễ nhất để tải xuống tất cả dữ liệu là cài đặt package epirhandbook của chúng tôi. Nó chứa hàm get_data() giúp lưu toàn bộ dữ liệu minh họa vào một thư mục bạn chọn trên máy tính của mình.\nĐể cài đặt package epirhandbook, bạn chạy theo code dưới đây. Lưu ý là package này không từ CRAN, do đó cần sử dụng hàm p_install_gh() để cài đặt. Thông tin đầu vào sẽ được chuyển tới trang Github của chúng tôi (“appliedepi”) và package epirhandbook.\n\n# install the latest version of the Epi R Handbook package\npacman::p_install_gh(\"appliedepi/epirhandbook\")\n\nBây giờ, bạn gọi package để sử dụng cho phiên làm việc hiện tại:\n\n# load the package for use\npacman::p_load(epirhandbook)\n\nTiếp theo, sử dụng hàm get_data() trong package để tải dữ liệu minh họa và máy tính của bạn. Chạy hàm get_data(\"all\") để tải toàn bộ dữ liệu minh họa, hoặc bạn có thể nêu tên một tệp cụ thể và phần mở rộng bên trong dấu ngoặc kép để tải một tệp duy nhất.\nDữ liệu sẽ được tải xuống cùng với package và bạn đơn giản chỉ cần lưu nó vào một thư mục trên máy tính của bạn. Một cửa sổ sẽ xuất hiện, cho phép bạn chọn vị trí lưu thư mục. Chúng tôi khuyên bạn nên tạo một thư mục mới tên là “data” vì có khoảng 30 tệp (bao gồm các bộ dữ liệu minh họa và kết quả).\n\n# download all the example data into a folder on your computer\nget_data(\"all\")\n\n# download only the linelist example data into a folder on your computer\nget_data(file = \"linelist_cleaned.rds\")\n\n\n# download a specific file into a folder on your computer\nget_data(\"linelist_cleaned.rds\")\n\nKhi bạn dùng hàm get_data() để lưu tệp dữ liệu vào máy tính của mình, bạn sẽ vẫn cần nhập dữ liệu vào R. Xem chương Nhập xuất dữ liệu để biết thêm chi tiết.\nNếu bạn muốn, bạn có thể xem toàn bộ dữ liệu sử dụng trong cuốn sách này ở thư mục “dữ liệu” trong kho Github của chúng tôi.\n\n\nTải từng thứ một\nTùy chọn này liên quan đến việc tải xuống từng tệp dữ liệu từ kho lưu trữ Github của chúng tôi thông qua liên kết hoặc lệnh R dành riêng cho từng tệp. Một số loại tệp cho phép nút tải xuống, trong khi những loại khác có thể được tải xuống thông qua lệnh R.\n\nDữ liệu linelist\nĐây là số liệu bùng phát Ebola giả định, được nhóm tác giả cẩm nang mở rộng từ bộ dữ liệu thực hành ebola_sim trong package outbreaks.\n\nBấm để tải xuống dữ liệu “thô” linelist (.xlsx). Bộ dữ liệu “thô” là một trang tính Excel với dữ liệu lộn xộn. Sử dụng số liệu này trong chương Làm sạch số liệu và các hàm quan trọng.\nBấm để tải xuống dữ liệu “đã làm sạch” linelist (.rds). Sử dụng tệp này cho tất cả các chương khác trong sổ tay có sử dụng bộ dữ liệu linelist. Tệp mở rộng .rds là một kiểu file của R có khả năng lưu trữ các thông tin cột. Điều này đảm bảo bạn sẽ có ít việc phải làm khi làm sạch số liệu sau khi nhập số liệu vào R.\n\nCác tệp liên quan khác:\n\nBấm để tải xuống dữ liệu “đã làm sạch” linelist dưới dạng tệp Excel\nMột phần của chương làm sạch sử dụng “từ điển làm sạch” (tệp .csv). Bạn có thể tải nó trực tiếp vào R bằng cách chạy các lệnh sau:\n\n\npacman::p_load(rio) # install/load the rio package\n\n# import the file directly from Github\ncleaning_dict &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/cleaning_dict.csv\")\n\n\n\nDữ liệu số trường hợp sốt rét\nĐây là số liệu giả định về số lượng trường hợp sốt rét theo nhóm tuổi, cơ sở điều trị và ngày. Tệp mở rộng .rds là một kiểu file của R có khả năng lưu trữ các thông tin cột. Điều này đảm bảo bạn sẽ có ít việc phải làm khi làm sạch số liệu sau khi nhập số liệu vào R.\n Bấm để tải file dữ liệu sốt rét (.rds file) \n\n\nDữ liệu thang đo Likert\nĐây là dữ liệu giả định từ một cuộc khảo sát sử dụng thang đo Likert, được sử dụng trong chương Tháp dân số và thang đo Likert. Bạn có thể tải những dữ liệu này trực tiếp vào R bằng cách chạy các lệnh sau:\n\npacman::p_load(rio) # install/load the rio package\n\n# import the file directly from Github\nlikert_data &lt;- import(\"https://raw.githubusercontent.com/nsbatra/Epi_R_handbook/master/data/likert_data.csv\")\n\n\n\nFlexdashboard\nDưới đây là các liên kết đến tệp được dùng trong chương Dashboards với R Markdown:\n\nĐể tải xuống R Markdown dashboard về một đợt bùng phát dịch, bấm phải chuột vào link này (Cmd+click đối với Mac) và chọn “Save link as”.\n\nĐể tải xuống HTML dashboard, bấm phải chuột vào link này (Cmd+click đối với Mac) và chọn “Save link as”.\n\n\n\nTruy vết tiếp xúc\nChương Truy vết tiếp xúc trình bày phân tích dữ liệu truy vết tiếp xúc, sử dụng dữ liệu minh họa từ Go.Data. Dữ liệu được sử dụng trong chương này có thể được tải xuống dưới dạng tệp .rds bằng cách bấm vào các liên kết sau:\n Bấm để tải xuống dữ liệu điều tra trường hợp (.rds file) \n Bấm để tải xuống dữ liệu ghi nhận tiếp xúc (.rds file) \n Bấm để tải xuống dữ liệu theo dõi liên hệ (.rds file) \nLƯU Ý: Dữ liệu truy vết tiếp xúc có cấu trúc từ phần mềm khác (ví dụ: KoBo, DHIS2 Tracker, CommCare) có thể sẽ khác. Nếu bạn muốn đóng góp dữ liệu hoặc nội dung mẫu thay thế cho trang này, vui lòng liên hệ chúng tôi.\nMẸO: Nếu bạn đang triển khai Go.Data và muốn kết nối với API phiên bản của bạn, vui lòng xem chương Nhập xuất dữ liệu (mục API) và Go.Data Cộng đồng thực hành.\n\n\nGIS\nShapefiles có nhiều tệp thành phần phụ, mỗi tệp có một phần mở rộng tệp khác nhau. Một tệp sẽ có phần mở rộng “.shp”, nhưng những tệp khác có thể là “.dbf”, “.prj”, v.v.\nChương GIS cơ bản cung cấp các liên kết đến trang web Humanitarian Data Exchange, nơi bạn có thể tải xuống trực tiếp các shapefiles dưới dạng tệp nén.\nVí dụ, dữ liệu phân bố của các cơ sở y tế có thể được tải xuống tại đây. Bạn tải tệp “hotosm_sierra_leone_health_facilities_points_shp.zip”. Sau khi được lưu vào máy tính của bạn, hãy “giải nén” thư mục. Bạn sẽ thấy một số tệp có các phần mở rộng khác nhau (ví dụ: “.shp”, “.prj”, “.shx”) - tất cả những tệp này phải được lưu vào cùng một thư mục trên máy tính của bạn. Sau đó, để nhập vào R, hãy cung cấp đường dẫn đến tệp và tên của tệp “.shp” bằng hàm st_read() từ package sf (đã được mô tả trong chương GIS cơ bản).\nNếu bạn làm theo Cách 1 để tải xuống tất cả dữ liệu minh họa (thông qua package epirhandbook của chúng tôi), tất cả các shapefiles đã được bao gồm.\nNgoài ra, bạn có thể tải xuống các shapefiles từ thư mục “data” trên trang R Handbook Github (xem thư mục con “gis”). Tuy nhiên, cần lưu ý rằng bạn sẽ phải tải từng tệp con xuống máy tính của mình. Trong Github, nhấp vào từng tệp riêng lẻ và tải chúng xuống bằng cách nhấp vào nút “Download”. Xem hình minh họa dưới đây, bạn có thể thấy shapefile “sl_adm3” bao gồm nhiều tệp con như thế nào - và mỗi tệp đều cần được tải xuống từ Github.\n\n\n\n\n\n\n\n\n\n\n\nCây phả hệ\nXem chương Cây phả hệ. Tệp có tên Newick về cây phả hệ được xây dựng từ việc giải trình tự toàn bộ bộ gen của 299 mẫu Shigella sonnei và dữ liệu mẫu tương ứng (được chuyển đổi thành tệp văn bản). Các mẫu và kết quả từ nước Bỉ được cung cấp thông qua Trung tâm tham khảo quốc gia về Salmonella và Shigella (NRC Bỉ) trong phạm vi dự án do EUPHEM Fellow của ECDC thực hiện, và cũng sẽ được xuất bản dưới dạng bản thảo. Dữ liệu quốc tế được cung cấp công khai trên cơ sở dữ liệu công cộng (ncbi) và đã được xuất bản trước đó.\n\nĐể tải xuống file cây phả hệ “Shigella_tree.txt”, nhấn chuột phải vào link này (Cmd+click đối với Mac) và chọn “Save link as”.\n\nĐể tải xuống file “sample_data_Shigella_tree.csv” với thông tin bổ sung cho từng mẫu, nhấn chuột phải vào link này (Cmd+click đối với Mac) và chọn “Save link as”.\n\nĐể xem subset-tree mới được tạo, nhấn chuột phải vào link này (Cmd+click đối với Mac) và chọn “Save link as”. Tệp .txt sẽ được tải xuống máy tính của bạn.\n\nSau đó bạn có thể nhập tệp .txt files bằng hàm read.tree() từ ape package, như đã được trình bày trong chương này.\n\nape::read.tree(\"Shigella_tree.txt\")\n\n\n\nChuẩn hóa\nXem trong chương Tỷ lệ chuẩn hóa. Bạn có thể tải dữ liệu trực tiếp từ kho lưu trữ Github của chúng tôi trên internet vào phiên làm việc R của bạn bằng các lệnh sau :\n\n# install/load the rio package\npacman::p_load(rio) \n\n##############\n# Country A\n##############\n# import demographics for country A directly from Github\nA_demo &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics.csv\")\n\n# import deaths for country A directly from Github\nA_deaths &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryA.csv\")\n\n##############\n# Country B\n##############\n# import demographics for country B directly from Github\nB_demo &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics_2.csv\")\n\n# import deaths for country B directly from Github\nB_deaths &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryB.csv\")\n\n\n###############\n# Reference Pop\n###############\n# import demographics for country B directly from Github\nstandard_pop_data &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/world_standard_population_by_sex.csv\")\n\n\n\nChuỗi thời gian và phát hiện ổ dịch\nXem trong chương Chuỗi thời gian và phát hiện ổ dịch. Chúng tôi sử dụng các trường hợp campylobacter được báo cáo ở Đức từ 2002-2011, có sẵn từ package surveillance của R. (lưu ý. tập dữ liệu này đã được điều chỉnh từ bản gốc, trong đó 3 tháng dữ liệu cuối năm 2011 đã bị xóa để dùng với mục đích minh họa)\n Bấm để tải xuống dữ liệu Campylobacter ở Đức (.xlsx) \nChúng tôi cũng sử dụng dữ liệu khí hậu ở Đức từ 2002-2011 (nhiệt độ tính bằng độ C và lượng mưa tính bằng milimet). Dữ liệu được tải xuống từ tập dữ liệu phân tích vệ tinh Copernicus của EU bằng cách sử dụng package ecmwfr . Bạn sẽ cần tải xuống tất cả những thứ này và nhập chúng vào R bằng hàm stars::read_stars() như đã được giải thích trong chương chuỗi thời gian.\n Bấm để tải dữ liệu thời tiết ở Đức 2002 (.nc file) \n Bấm để tải dữ liệu thời tiết ở Đức 2003 (.nc file) \n Bấm để tải dữ liệu thời tiết ở Đức 2004 (.nc file) \n Bấm để tải dữ liệu thời tiết ở Đức 2005 (.nc file) \n Bấm để tải dữ liệu thời tiết ở Đức 2006 (.nc file) \n Bấm để tải dữ liệu thời tiết ở Đức 2007 (.nc file) \n Bấm để tải dữ liệu thời tiết ở Đức 2008 (.nc file) \n Bấm để tải dữ liệu thời tiết ở Đức 2009 (.nc file) \n Bấm để tải dữ liệu thời tiết ở Đức 2010 (.nc file) \n Bấm để tải dữ liệu thời tiết ở Đức 2011 (.nc file) \n\n\nPhân tích sống còn\nĐối với chương phân tích sống còn, chúng tôi sử dụng dữ liệu khảo sát tử vong giả định dựa trên mẫu khảo sát của MSF OCA. Dữ liệu giả định này là một phần của Dự án “R4Epis”.\n Bấm để tài xuống dữ liệu khảo sát giả định (.xlsx) \n Bấm để tài xuống từ điển dữ liệu khảo sát giả định (.xlsx) \n Bấm để tài xuống dữ liệu khảo sát quần thể giả định (.xlsx) \n\n\nShiny\nChương Dashboards với Shiny trình diễn việc xây dựng một ứng dụng đơn giản để hiển thị dữ liệu bệnh sốt rét.\nĐể tải xuống các tệp R dùng để tạo thành ứng dụng Shiny:\nBạn có thể  bấm vào đây để tải xuống tệp app.R trong đó chứa code của cả UI và Server của ứng dụng Shiny.\nBạn có thể  bấm vào đây để tải tệp facility_count_data.rds có chứa dữ liệu sốt rét cho ứng dụng Shiny. Lưu ý rằng bạn có thể cần phải lưu trữ nó trong thư mục “data” để các đường dẫn tệp here () hoạt động chính xác.\nBạn có thể  bấm vào đây để tải tệp global.R mà sẽ được chạy trước khi mở ứng dụng, như đã được giải thích trong chương.\nBạn có thể  bấm vào đây để tải tệp plot_epicurve.R có nguồn từ tệp global.R. Lưu ý rằng bạn có thể cần phải lưu trữ nó trong thư mục “funcs” để các đường dẫn tệp here () hoạt động chính xác.",
    "crumbs": [
      "Về cuốn sách này",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Tải sách và dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.vn.html",
    "href": "new_pages/basics.vn.html",
    "title": "3  R Cơ bản",
    "section": "",
    "text": "3.1 Tại sao sử dụng R?\nNhư đã được công bố trên trang web dự án R, R là một ngôn ngữ và môi trường lập trình cho tính toán và đồ họa thống kê. Nó rất linh hoạt, có khả năng mở rộng và hướng tới cộng đồng.\nChi phí\nR được sử dụng miễn phí! Có sự tồn tại mạnh mẽ về đạo đức trong cộng đồng người sử dụng nguồn tài nguyên mở và miễn phí.\nKhả năng tái lập\nThực hiện quản lý và phân tích dữ liệu của bạn thông qua một ngôn ngữ lập trình (so sánh với Excel hoặc công cụ khác mà thao tác chính là nhấp chuột/thao tác thủ công) giúp nâng cao khả năng tái lập, giúp phát hiện lỗi dễ dàng hơn và giảm bớt khối lượng công việc của bạn.\nCộng đồng\nR có cộng đồng người dùng khổng lồ và có tính hợp tác. Các package và công cụ mới nhằm giải quyết các vấn đề thực tế được phát triển hàng ngày và được kiểm tra bởi cộng đồng người dùng. Ví dụ, R-Ladies là một tổ chức toàn cầu có sứ mệnh thúc đẩy sự đa dạng giới trong cộng đồng R và là một trong những tổ chức người dùng R lớn nhất. Thậm chí có thể có một phần của nhóm này đang ở gần bạn!",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R Cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.vn.html#các-thuật-ngữ-chính",
    "href": "new_pages/basics.vn.html#các-thuật-ngữ-chính",
    "title": "3  R Cơ bản",
    "section": "3.2 Các thuật ngữ chính",
    "text": "3.2 Các thuật ngữ chính\nRStudio - RStudio là Giao diện đồ họa người dùng (GUI) giúp sử dụng R dễ dàng hơn. Đọc thêm trong mục RStudio.\nĐối tượng - Bao gồm mọi thứ bạn lưu trữ trong R - bộ dữ liệu, biến, danh sách tên làng, quy mô dân số, thậm chí cả các kết quả đầu ra như đồ thị - là các đối tượng được gán tên và có thể được tham chiếu trong các lệnh sau này. Đọc thêm trong mục Đối tượng.\nHàm - Mỗi hàm là một code hoạt động mà chấp nhận dữ liệu đầu vào và trả về kết quả đầu ra đã được biến đổi. Đọc thêm trong mục Các hàm.\nPackages - Mỗi package R là một gói câu lệnh có khả năng chia sẻ. Đọc thêm trong mục Packages.\nScripts - Mỗi script là một tệp tài liệu chứa các lệnh của bạn. Đọc thêm trong mục Scripts",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R Cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.vn.html#learning",
    "href": "new_pages/basics.vn.html#learning",
    "title": "3  R Cơ bản",
    "section": "3.3 Tài nguyên học liệu",
    "text": "3.3 Tài nguyên học liệu\n\nTài nguyên trong RStudio\nTài liệu trợ giúp\nTìm kiếm tab “Help” của RStudio về tài liệu liên quan đến package R và các hàm cụ thể. Tab này nằm trong cửa sổ chứa các tab Files, Plots và Packages (thường ở cửa sổ phía dưới bên phải). Như một lối tắt, bạn cũng có thể nhập tên của một package hoặc câu lệnh vào R Console sau dấu hỏi chấm và không bao gồm dấu ngoặc đơn để mở trang trợ giúp liên quan.\nVí dụ: ?filter hoặc ?diagrammeR.\nCác hướng dẫn có sự tương tác\nR có thể được học thông qua một số tương tác trong RStudio.\nRStudio cung cấp một cửa sổ Tutorial được hỗ trợ bởi package learnr. Chỉ cần cài đặt package này và mở hướng dẫn qua tab “Tutorial” trong cửa sổ RStudio phía trên bên phải (cũng chứa các tab Environment và History).\nPackage swirl cung cấp các nội dung học tương tác trong R Console. Cài đặt và tải package này, rồi chạy lệnh swirl() (dấu ngoặc đơn trống) trong R Console. Bạn sẽ thấy các thông báo xuất hiện trong cửa sổ Console. Phản hồi bằng cách nhập vào Console. Nó sẽ hướng dẫn bạn qua một nội dung học do bạn lựa chọn.\n\n\nCheatsheets\nCó rất nhiều “cheatsheets” PDF có sẵn trên trang web của RStudio, ví dụ như:\n\nFactors với package forcats\n\nNgày và thời gian với package lubridate\n\nChuỗi với package stringr\n\nCác vòng lặp với package purrr\n\nNhập dữ liệu\n\nCheatsheet biến đổi dữ liệu với package dplyr\n\nR Markdown (để tạo các tài liệu như PDF, Word, Powerpoint…)\n\nShiny (để xây dựng các ứng dụng web tương tác)\n\nTrực quan hóa dữ liệu với package ggplot2\n\nBản đồ (GIS)\n\nPackage leaflet (bản đồ tương tác)\n\nPython với R (package reticulate)\n\nĐây là tài nguyên R trực tuyến dành riêng cho Người dùng Excel\n\n\nTwitter\nR có một cộng đồng twitter sôi động, nơi bạn có thể tìm hiểu các mẹo, lối tắt và tin tức - hãy theo dõi các tài khoản sau:\n\nTheo dõi chúng tôi: @epiRhandbook\n\nR Function A Day @rfuntionaday là một nguồn tài nguyên tuyệt vời\nR for Data Science @rstats4ds\n\nRStudio @RStudio\n\nRStudio Tips @rstudiotips\n\nR-Bloggers @Rbloggers\n\nR-ladies @RLadiesGlobal\n\nHadley Wickham @hadleywickham\n\nCũng như:\n#epitwitter và #rstats\n\n\nNguồn tài nguyên trực tuyến miễn phí\nCuốn sách R for Data Science (R dành cho Khoa học Dữ liệu) của Garrett Grolemund và Hadley Wickham\nTrang web của dự án R4Epis nhằm mục đích “phát triển các công cụ làm sạch, phân tích và báo cáo dữ liệu được chuẩn hóa dùng trong các trường hợp bùng phát dịch phổ biến và các cuộc điều tra dựa trên dân số mà sẽ được tiến hành trong các ứng phó khẩn cấp của Tổ chức Bác sỹ không biên giới” Bạn có thể tìm thấy tài liệu đào tạo cơ bản về R, các mẫu báo cáo RMarkdown và khảo sát về các đợt bùng phát dịch, cũng như các hướng dẫn để giúp bạn thiết lập chúng.\n\n\nCác ngôn ngữ khác ngoài Tiếng Anh\nTài liệu RStudio bằng tiếng Tây Ban Nha\nGiới thiệu cơ bản về R (tiếng Pháp)",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R Cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.vn.html#cài-đặt",
    "href": "new_pages/basics.vn.html#cài-đặt",
    "title": "3  R Cơ bản",
    "section": "3.4 Cài đặt",
    "text": "3.4 Cài đặt\n\nR và RStudio\nLàm thế nào để cài đặt R\nTruy cập vào trang web https://www.r-project.org/ và tải phiên bản mới nhất của R phù hợp với máy tính của bạn.\nLàm thế nào để cài đặt RStudio\nTruy cập vào trang web https://rstudio.com/products/rstudio/download/ và tải phiên bản Desktop mới nhất của RStudio phù hợp với máy tính của bạn.\nQuyền truy cập\nLưu ý rằng bạn nên cài đặt R và RStudio vào một ổ đĩa mà bạn có quyền đọc và ghi lại. Nếu không, khả năng cài đặt các package R (thường xuyên xảy ra) của bạn sẽ bị ảnh hưởng. Nếu bạn gặp sự cố, hãy thử mở RStudio bằng cách nhấp chuột phải vào biểu tượng và chọn “Run as administrator”. Các mẹo khác có thể được tìm thấy trong chương R trên ổ cứng mạng.\nLàm thế nào để cập nhật R và RStudio\nPhiên bản R của bạn được in ra R Console khi khởi động. Bạn cũng có thể chạy lệnh sessionInfo().\nĐể cập nhật R, truy cập đến trang web được nhắc đến ở trên và cài đặt lại R. Ngoài ra, bạn có thể sử dụng package installr (trên Windows) bằng cách chạy câu lệnh installr::updateR(). Thao tác này sẽ mở ra các hộp thoại giúp bạn tải xuống phiên bản R mới nhất và cập nhật các package của bạn lên phiên bản R mới. Có thể tìm thấy thêm chi tiết trong tài liệu installr .\nLưu ý rằng phiên bản R cũ sẽ vẫn tồn tại trong máy tính của bạn. Bạn có thể tạm thời chạy phiên bản cũ hơn (“installation” cũ hơn) của R bằng cách nhấp vào “Tools” -&gt; “Global Options” trong RStudio và chọn một phiên bản R. Điều này có thể hữu ích nếu bạn muốn sử dụng một package chưa được cập nhật để hoạt động trên phiên bản R mới nhất.\nĐể cập nhật RStudio, truy cập đến trang web được nhắc đến ở trên và cài đặt lại RStudio. Một tùy chọn khác là nhấp vào “Help” -&gt; “Check for Updates” trong RStudio, nhưng điều này có thể dẫn đến việc không hiển thị các bản cập nhật mới nhất.\nĐể xem phiên bản R, RStudio hoặc package nào đã được sử dụng khi viết Sổ tay này, hãy xem chương Biên tập và ghi chú kỹ thuật.\n\n\nNhững phần mềm khác bạn có thể cần cài đặt\n\nTinyTeX (để biên dịch tài liệu RMarkdown sang PDF)\n\nPandoc (để biên dịch tài liệu RMarkdown)\n\nRTools (để xây dựng các package cho R)\n\nphantomjs (để lưu ảnh tĩnh của mạng động, chẳng hạn như chuỗi lây truyền)\n\n\nTinyTex\nTinyTex là một bản phân phối LaTeX tùy chỉnh, hữu ích khi tạo các tệp PDF từ R.\nTruy cập https://yihui.org/tinytex/ để tìm hiểu thêm thông tin.\nĐể cài đặt TinyTex từ R:\n\ninstall.packages('tinytex')\ntinytex::install_tinytex()\n# to uninstall TinyTeX, run tinytex::uninstall_tinytex()\n\n\n\nPandoc\nPandoc là một công cụ chuyển đổi văn bản, một phần mềm tách biệt với R. Nó đi kèm với RStudio và không cần phải tải xuống. Nó hỗ trợ quá trình chuyển đổi văn bản từ Rmarkdown sang các định dạng như .pdf và có bổ sung thêm một số tính năng phức tạp.\n\n\nRTools\nRTools là một phần mềm được sử dụng để xây dựng package cho R\nCài đặt từ trang web: https://cran.r-project.org/bin/windows/Rtools/\n\n\nphantomjs\nPhần mềm này thường được sử dụng để chụp “chụp ảnh màn hình” trang web. Ví dụ khi bạn tạo một chuỗi lây truyền với package epicontacts, một tệp HTML có thể tương tác và chuyển động được tạo ra. Nếu bạn muốn có hình ảnh tĩnh, sử dụng package webshot để tự động hóa quá trình này. Việc này sẽ yêu cầu chương trình bên ngoài “phantomjs”. Bạn có thể cài đặt phantomjs thông qua package webshot bằng lệnh webshot::install_phantomjs().",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R Cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.vn.html#rstudio",
    "href": "new_pages/basics.vn.html#rstudio",
    "title": "3  R Cơ bản",
    "section": "3.5 RStudio",
    "text": "3.5 RStudio\n\nLàm quen\nĐầu tiên, mở RStudio. Biểu tượng của chúng có sự tương đồng, hãy chắc chắn bạn đang mở RStudio chứ không phải R.\nĐể RStudio hoạt động bạn cũng cần phải cài đặt R trên máy tính (xem hướng dẫn cài đặt ở bên trên).\nRStudio là một giao diện người dùng (GUI) giúp sử dụng R dễ dàng hơn. Bạn có thể coi R như một động cơ đang đảm đương công việc chính của một phương tiện và RStudio là phần thân của phương tiện (với ghế ngồi, các phụ kiện,…) giúp bạn sử dụng động cơ tiến về phía trước. Bạn có thể xem toàn bộ cheatsheet giao diện người dùng của RStudio (PDF) tại đây\nRStudio mặc định hiển thị bốn cửa sổ hình chữ nhật.\n\n\n\n\n\n\n\n\n\nMẸO: Nếu RStudio của bạn chỉ hiển thị một cửa sổ bên trái thì đó là do bạn chưa mở scripts nào.\nCửa sổ mã nguồn\nCửa sổ này, mặc định hiển thị phía trên bên trái, là một khoảng trống để chỉnh sửa, chạy và lưu các scripts của bạn. Script chứa các lệnh mà bạn muốn chạy. Cửa sổ này cũng có thể hiển thị thông tin dữ liệu (data frames).\nĐối với người dùng Stata, cửa sổ này tương tự với các cửa sổ Do-file và Data Editor.\nCửa sổ R Console\nR Console, mặc định ở cửa sổ bên trái hoặc phía dưới bên trái của RStudio, là ngôi nhà của “động cơ” R. Đây là nơi các lệnh thực sự được chạy, các kết quả đầu ra không phải là đồ họa và các thông báo lỗi/cảnh báo sẽ xuất hiện. Bạn có thể nhập và chạy các lệnh trực tiếp trong R Console, nhưng sẽ sớm nhận ra các lệnh này không được lưu như khi chạy lệnh từ một script.\nNếu bạn đã quen thuộc với Stata, R Console giống như cửa sổ Command Window và Results Window.\nCửa sổ Environment\nCửa sổ này, mặc định ở phía trên bên phải, thường được sử dụng để xem tóm tắt ngắn gọn về các đối tượng itrong R Environment ở phiên hiện tại. Các đối tượng này có thể bao gồm các tập dữ liệu đã được nhập, chỉnh sửa hoặc tạo mới, các tham số bạn đã xác định (ví dụ: một tuần dịch tễ cụ thể để phân tích), vectơ hoặc các danh sách bạn đã xác định trong quá trình phân tích (ví dụ: tên các vùng). Bạn có thể nhấp vào mũi tên bên cạnh tên của data frames để xem các biến số của nó.\nCửa sổ này gần giống với cửa sổ Variables Manager trong Stata.\nCửa sổ này cũng chứa History - nơi mà bạn có thể xem các lệnh đã làm trước đó. Nó cũng có một tab “Tutorial” - là nơi mà bạn có thể hoàn thành các hướng dẫn tương tác với R nếu bạn đã cài đặt package learnr. Nó cũng chứa một tab “Connections” cho phép các kết nối bên ngoài và có thể có cửa sổ “Git” nếu bạn chọn giao diện với Github.\nCửa sổ Plots, Viewer, Packages, và Help\nCửa sổ phía dưới bên phải bao gồm một số tab quan trọng. Các đồ họa chính điển hình bao gồm bản đồ sẽ được hiển thị trong Cửa sổ Plot. Các kết quả đầu ra tương tác hoặc HTML sẽ được hiển thị trong cửa sổ Viewer. Cửa sổ File là một trình duyệt có thể được sử dụng để mở hoặc xóa tệp. Cửa sổ Packages cho phép bạn xem, cài đặt, cập nhật, xóa, tải/dỡ các package R và xem bạn có phiên bản package nào. Để tìm hiểu thêm về các package hãy xem mục packages bên dưới.\nCửa sổ này chứa các nội dung tương đương với các cửa sổ Plots Manager và Project Manager trong Stata.\n\n\nCác cài đặt của RStudio\nThay đổi các cài đặt và giao diện của RStudio trong thanh menu thả xuống Tools, bằng cách chọn Global Options. Ở đó, bạn có thể thay đổi cài đặt mặc định, bao gồm cả màu giao diện/nền.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKhởi động lại\nNếu R của bạn bị treo, bạn có thể khởi động lại R bằng cách di chuột đến menu Session và nhấp vào “Restart R”. Thao tác này giúp tránh rắc rối khi đóng và mở RStudio. Mọi thứ trong môi trường R của bạn sẽ bị xóa khi thực hiện thao tác này.\n\n\nCác phím tắt\nDưới đây là một vài phím tắt rất hữu dụng. Tất cả các phím tắt cho Windows, Max và Linux nằm ở chương 2 cheatsheet giao diện người dùng của RStudio.\n\n\n\n\n\n\n\n\nWindows/Linux\nMac\nHành động\n\n\n\n\nEsc\nEsc\nNgắt lệnh hiện tại (hữu ích nếu bạn vô tình chạy một lệnh chưa hoàn chỉnh và không thể thoát khỏi việc nhìn thấy “+” trong R console)\n\n\nCtrl+s\nCmd+s\nLưu (script)\n\n\nTab\nTab\nTự động điền\n\n\nCtrl + Enter\nCmd + Enter\nChạy (các) dòng/phần code đang được chọn\n\n\nCtrl + Shift + C\nCmd + Shift + c\nBình luận/bỏ bình luận các dòng được đánh dấu\n\n\nAlt + -\nOption + -\nChèn &lt;-\n\n\nCtrl + Shift + m\nCmd + Shift + m\nChèn %&gt;%\n\n\nCtrl + l\nCmd + l\nDọn dẹp R console\n\n\nCtrl + Alt + b\nCmd + Option + b\nChạy từ đầu đến dòng hiện tại\n\n\nCtrl + Alt + t\nCmd + Option + t\nChạy code chunk hiện tại (R Markdown)\n\n\nCtrl + Alt + i\nCmd + Shift + r\nChèn code chunk (vào R Markdown)\n\n\nCtrl + Alt + c\nCmd + Option + c\nChạy code chunk hiện tại (R Markdown)\n\n\nup/down arrows in R console\nTương tự\nChuyển đổi qua các lệnh đã chạy gần đây\n\n\nShift + up/down arrows in script\nTương tự\nChọn nhiều dòng code\n\n\nCtrl + f\nCmd + f\nTìm và thay thế trong script hiện tại\n\n\nCtrl + Shift + f\nCmd + Shift + f\nTìm trong các tệp (tìm/thay thế trên nhiều script)\n\n\nAlt + l\nCmd + Option + l\nThu gọn code đã chọn\n\n\nShift + Alt + l\nCmd + Shift + Option+l\nMở rộng code đã chọn\n\n\n\nMẸO: Sử dụng phím Tab của bạn khi nhập để sử dụng chức năng tự động hoàn thành của RStudio. Điều này có thể giúp ngăn ngừa các lỗi chính tả. Nhấn Tab trong khi nhập để hiện ra menu thả xuống gồm các hàm và đối tượng có thể có, dựa trên những gì bạn đã nhập.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R Cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.vn.html#functions",
    "href": "new_pages/basics.vn.html#functions",
    "title": "3  R Cơ bản",
    "section": "3.6 Hàm",
    "text": "3.6 Hàm\nCác hàm là phần cốt lõi của việc sử dụng R. Hàm là cách bạn thực hiện các tác vụ và hoạt động. Nhiều hàm được cài đặt sẵn với R, nhiều hàm khác sẵn sàng để tải xuống trong các packages (giải thích trong phần packages), và bạn thậm chí có thể viết các hàm tùy chỉnh của riêng mình!\nPhần khái niệm cơ bản của hàm giải thích:\n\nThế nào là một hàm và cách mà chúng hoạt động\n\nThế nào là đối số của hàm\n\nLàm cách nào để nhận được sự trợ giúp khi tìm hiểu một hàm\n\nLưu ý nhanh về cú pháp: Trong cuốn sổ tay này, các hàm được viết dưới dạng code văn bản với dấu mở ngoặc đơn như sau: filter(). Như đã giải thích trong phần packages, các hàm được tải xuống có sẵn trong các packages. Trong sổ tay này, tên các package được in đậm, ví dụ như dplyr. Đôi khi trong code ví dụ, bạn có thể thấy tên hàm được liên kết rõ ràng với tên package của chính hàm đó bằng hai dấu hai chấm (::) như thế này: dplyr::filter(). Mục đích của việc liên kết này sẽ được giải thích trong phần package.\n\n\nCác hàm cơ bản\nMột hàm giống như một cỗ máy nhận các dữ liệu đầu vào, thực hiện một số thao tác với dữ liệu đó và sản xuất kết quả đầu ra. Kết quả đầu ra như thế nào phụ thuộc vào hàm mà bạn sử dụng.\nCác hàm thường hoạt động dựa trên các đối tượng được đặt trong dấu ngoặc đơn của hàm. Ví dụ, hàm sqrt() tính căn bậc hai của một số:\n\nsqrt(49)\n\n[1] 7\n\n\nĐối tượng được dùng cho một hàm cũng có thể là một cột trong tập dữ liệu (xem phần Đối tượng để biết chi tiết về tất cả các loại đối tượng). Vì R có thể lưu trữ nhiều tập dữ liệu, bạn sẽ cần xác định cả tập dữ liệu và cột. Một cách để làm điều này là sử dụng ký hiệu $ để liên kết tên của tập dữ liệu và tên của cột (dataset$column). Trong ví dụ dưới đây, hàm summary() được áp dụng cho cột age trong tập dữ liệu linelist, và kết quả đầu ra là bản tóm tắt các giá trị số và giá trị missing của cột.\n\n# Print summary statistics of column 'age' in the dataset 'linelist'\nsummary(linelist$age)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00    6.00   13.00   16.07   23.00   84.00      86 \n\n\nLƯU Ý: Đằng sau một hàm là hệ thống code bổ sung phức tạp đã được gói gọn cho người dùng thành một lệnh đơn giản.\n\n\n\nHàm với nhiều đối số\nCác hàm thường yêu cầu một số dữ liệu đầu vào, được gọi là đối số, đặt trong dấu ngoặc đơn của hàm, thường được phân tách bằng dấu phẩy.\n\nMột vài đối số là bắt buộc để hàm hoạt động chính xác, những đối số khác là tùy chọn\n\nNhững đối số tùy chọn có thiết lập mặc định\n\nCác đối số có thể nhận ký tự, số, logic (TRUE / FALSE) và các dữ liệu đầu vào khác\n\nDưới đây là một hàm giả định thú vị, được gọi là oven_bake(), là ví dụ về một hàm điển hình. Hàm này nhận một đối tượng đầu vào (ví dụ: một tập dữ liệu, hoặc trong ví dụ này là “bột”) và thực hiện các hoạt động được xác định bởi các đối số bổ sung (minutes = and temperature =). Kết quả đầu ra có thể được in ra cửa sổ console hoặc được lưu dưới dạng một đối tượng bằng cách sử dụng toán tử gán &lt;-.\n\n\n\n\n\n\n\n\n\nTrong một ví dụ thực tế hơn, hàm age_pyramid() dưới đây tạo một biểu đồ tháp tuổi dựa trên nhóm tuổi đã xác định và cột phân tách nhị phân, ví dụ như giới tính. Hàm được cung cấp bởi ba đối số trong dấu ngoặc đơn và được phân tách nhau bằng dấu phẩy. Các giá trị được cung cấp cho các đối số thiết lập linelist là dataframe được sử dụng, age_cat5 là cột để đếm và giới tính là cột nhị phân để sử dụng chia kim tự tháp theo màu.\n\n# Create an age pyramid\nage_pyramid(data = linelist, age_group = \"age_cat5\", split_by = \"gender\")\n\n\n\n\n\n\n\n\nLệnh trên có thể được viết tương tự như bên dưới, theo cách dài hơn với một dòng mới cho mỗi đối số. Phong cách này có thể dễ đọc và dễ viết “bình luận” hơn với # để giải thích từng phần (bình luận mở rộng là một thực hành tốt!). Để chạy lệnh dài hơn này, bạn có thể bôi đen toàn bộ lệnh và nhấp vào “Run” hoặc chỉ cần đặt con trỏ vào dòng đầu tiên rồi nhấn đồng thời phím Ctrl và phím Enter.\n\n# Create an age pyramid\nage_pyramid(\n  data = linelist,        # use case linelist\n  age_group = \"age_cat5\", # provide age group column\n  split_by = \"gender\"     # use gender column for two sides of pyramid\n  )\n\n\n\n\n\n\n\n\nKhông cần xác định nửa đầu của phép gán đối số (ví dụ: data =) nếu các đối số được viết theo một thứ tự cụ thể (được chỉ định trong tài liệu của hàm). Đoạn code dưới đây tạo ra cùng một kim tự tháp như ở trên, bởi vì hàm kì vọng thứ tự đối số là: data frame, biến age_group, biến split_by.\n\n# This command will produce the exact same graphic as above\nage_pyramid(linelist, \"age_cat5\", \"gender\")\n\nMột lệnh age_pyramid() phức tạp hơn có thể bao gồm các đối số tùy chọn để:\n\nHiển thị tỷ lệ thay vì số lượng (đặt proportional = TRUE khi giá trị mặc định là FALSE)\n\nChỉ định hai màu để sử dụng (pal = là viết tắt của “bảng màu” và được cung cấp với một vectơ gồm hai tên màu. Xem chương đối tượng để biết cách hàm c() tạo ra một vectơ)\n\nLƯU Ý: Đối với các đối số mà bạn xác định với cả hai phần của đối số (ví dụ: proportional = TRUE), thứ tự của chúng trong tất cả các đối số không quan trọng.\n\nage_pyramid(\n  linelist,                    # use case linelist\n  \"age_cat5\",                  # age group column\n  \"gender\",                    # split by gender\n  proportional = TRUE,         # percents instead of counts\n  pal = c(\"orange\", \"purple\")  # colors\n  )\n\n\n\n\n\n\n\n\n\n\n\nViết hàm\nR là một ngôn ngữ được định hướng xung quanh hàm, vì thế bạn nên cảm thấy được trao quyền để tự viết các hàm của riêng mình. Việc tạo ra hàm mang đến một vài lợi thế:\n\nTạo điều kiện thuận lợi cho lập trình mô-đun - tách code thành các phần độc lập và có thể quản lý\n\nThay thế việc copy-and-paste lặp đi lặp lại, điều mà có thể dễ xảy ra lỗi\n\nĐặt tên dễ nhớ cho các đoạn code\n\nCách viết một hàm được trình bày cụ thể trong chương Viết hàm.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R Cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.vn.html#packages",
    "href": "new_pages/basics.vn.html#packages",
    "title": "3  R Cơ bản",
    "section": "3.7 Packages",
    "text": "3.7 Packages\nPackages chứa các hàm.\nMột package trong phần mềm R là một gói code và các tài liệu hướng dẫn có thể chia sẻ được chứa các hàm được định nghĩa trước. Cộng đồng người dùng phần mềm R luôn phát triển những package giúp giải quyết các vấn đề cụ thể, điều này có thể sẽ giúp bạn trong công việc của mình! Bạn sẽ có thể cần cài đặt và sử dụng hàng trăm package trong quá trình sử dụng phần mềm R.\nKhi cài đặt, R đã có sẵn các package và hàm “cơ bản” giúp thực hiện các nhiệm vụ đơn giản. Nhưng nhiều người dùng R tạo ra các hàm chuyên biệt, được cộng đồng R kiểm chứng và bạn có thể tải xuống dưới dạng package để sử dụng theo cách của riêng mình. Trong sách này, tên package được viết in đậm. Một trong những khía cạnh thách thức hơn cả của R đó là thường có nhiều hàm hoặc package để lựa chọn nhằm hoàn thành một nhiệm vụ nhất định.\n\nCài đặt và Gọi\nCác hàm được chứa trong packages có thể được tải (“cài đặt”) về máy tính của bạn từ internet. Khi một package được tải xuống, package đó sẽ được lưu trữ trong “thư viện” của bạn. Sau đó, bạn có thể truy cập các hàm mà nó chứa trong phiên làm việc hiện tại trên R của bạn bằng cách “Gọi” package.\nHãy coi R là thư viện cá nhân của bạn: Khi bạn tải xuống một package, thư viện của bạn nhận được một cuốn sách mới gồm các hàm, nhưng mỗi lần bạn muốn sử dụng một hàm trong cuốn sách đó, bạn phải mượn (“gọi”) cuốn sách đó từ thư viện của mình.\nTóm lại: để sử dụng các hàm có sẵn trong package R, phải thực hiện 2 bước:\n\nPackage phải được cài đặt (một lần), và\n\nPackage phải được gọi (trong mỗi phiên làm việc của R)\n\n\nThư viện của bạn\n“Thư viện” của bạn thực ra là một thư mục trên máy tính của bạn, bao gồm các thư mục chứa các package đã được cài đặt. Hãy tìm nơi R được cài đặt trong máy tính của bạn và tìm kiếm một thư mục có tên “win-library”. Ví dụ: R\\win-library\\4.0 (4.0 là phiên bản R - bạn sẽ có các thư viện khác nhau tùy theo phiên bản R mà bạn đã tải xuống).\nBạn có thể in ra đường dẫn tệp đến thư viện của mình bằng cách gõ lệnh .libPaths() (dấu ngoặc bỏ trống). Điều này trở nên đặc biệt quan trọng nếu làm việc với R trên ổ cứng mạng.\n\n\nCài đặt từ CRAN\nThông thường, người dùng R tải các package xuống từ CRAN. CRAN (Comprehensive R Archive Network - Mạng lưu trữ R toàn diện) là một kho công cộng trực tuyến gồm các package R đã được xuất bản bởi các thành viên cộng đồng R.\nBạn có cần lo lắng về vi-rút và bảo mật khi tải xuống một package từ CRAN? Đọc bài viết sau để hiểm thêm về chủ đề này.\n\n\nLàm thế nào để cài đặt và gọi\nTrong sách này, chúng tôi khuyên bạn nên sử dụng package pacman (viết tắt của “package manager”). Nó cung cấp một hàm thuận tiện p_load() mà sẽ cài đặt một package nếu cần và gọi nó để sử dụng trong phiên làm việc hiện tại.\nCú pháp khá đơn giản. Chỉ cần liệt kê tên của các package trong dấu ngoặc đơn của hàm p_load() và phân tách chúng bằng dấu phẩy. Lệnh dưới đây sẽ cài đặt các package sau rio, tidyverse, và here nếu chúng chưa được cài đặt và sẽ gọi chúng ra để sử dụng. Điều này làm cho cách tiếp cận p_load() trở nên thuận tiện và ngắn gọn nếu chia sẻ scripts với người khác. Lưu ý rằng tên package có phân biệt chữ hoa chữ thường.\n\n# Install (if necessary) and load packages for use\npacman::p_load(rio, tidyverse, here)\n\nLưu ý rằng chúng ta đã sử dụng cú pháp pacman::p_load() để viết rõ ràng tên package (pacman) trước tên hàm (p_load()), được nối với nhau bằng hai dấu hai chấm ::. Cú pháp này tiện dụng vì nó cũng gọi package pacman (giả sử package này đã được cài đặt).\nNgoài ra còn có các hàm base R thay thế mà bạn sẽ gặp thường xuyên. Hàm base R để cài đặt một package là install.packages(). Tên của package muốn cài đặt phải được đặt trong dấu ngoặc đơn bên trong dấu ngoặc kép. Nếu bạn muốn cài đặt nhiều package trong một lệnh, chúng phải được liệt kê trong một vectơ dạng ký tự c().\nLưu ý: lệnh này cài đặt một package, nhưng không gọi nó ra để sử dụng trong phiên làm việc hiện tại.\n\n# install a single package with base R\ninstall.packages(\"tidyverse\")\n\n# install multiple packages with base R\ninstall.packages(c(\"tidyverse\", \"rio\", \"here\"))\n\nViệc cài đặt cũng có thể được thực hiện bằng cách chọn và nhấp chuột vào cửa sổ RStudio “Package” và chọn “Install”, sau đó tìm kiếm tên package mong muốn cài đặt.\nHàm base R để gọi một package ra sử dụng (sau khi nó đã được cài đặt) là library(). Hàm này chỉ có thể gọi một package tại một thời điểm (cách khác của lệnh p_load()). Bạn có thể nhập tên package có hoặc không có dấu ngoặc kép.\n\n# load packages for use, with base R\nlibrary(tidyverse)\nlibrary(rio)\nlibrary(here)\n\nĐể kiểm tra xem một package đã được cài đặt và/hoặc đã được gọi hay chưa, bạn có thể xem Cửa số Package trong RStudio. Nếu package được cài đặt, nó sẽ hiển thị ở đó với số phiên bản. Nếu checkbox của nó được đánh dấu nghĩa là nó đã được gọi cho phiên làm việc hiện tại.\nCài đặt từ Github\nĐôi khi, bạn cần cài đặt một package chưa có sẵn từ CRAN. Hoặc có lẽ package đã có sẵn trên CRAN nhưng bạn muốn phiên bản mới hơn với các tính năng mới chưa được cung cấp trong phiên bản cũ. Chúng thường được lưu trữ trên trang web github.com trong một “kho lưu trữ (repository)” code công khai và miễn phí. Đọc thêm về Github trong chương [Version control với Git và Github].\nĐể download packages R từ Github, bạn có thể dụng hàm p_load_gh() từ pacman, hàm này sẽ cài đặt package nếu cần và gọi nó để sử dụng cho phiên làm việc R hiện tại. Cách khác để cài đặt bao gồm sử dụng package remotes hoặc devtools. Đọc thêm về các hàm của pacman tại Tài liệu về package.\nĐể cài đặt từ Github, bạn phải cung cấp thêm các thông tin sau:\n\nGithub ID của chủ sở hữu\nTên của repository chứa package\n\n(Tùy chọn) Tên của “nhánh” (phiên bản phát triển cụ thể) mà bạn muốn tải xuống\n\nTrong các ví dụ dưới đây, từ đầu tiên trong dấu ngoặc kép là Github ID của chủ sở hữu kho lưu trữ, sau dấu gạch chéo là tên của kho lưu trữ (tên của package).\n\n# install/load the epicontacts package from its Github repository\np_load_gh(\"reconhub/epicontacts\")\n\nNếu bạn muốn cài đặt từ một “nhánh” (phiên bản) khác với nhánh chính, hãy thêm tên nhánh sau dấu “@”, được đặt phía sau tên kho lưu trữ.\n\n# install the \"timeline\" branch of the epicontacts package from Github\np_load_gh(\"reconhub/epicontacts@timeline\")\n\nNếu không có sự khác biệt giữa phiên bản Github và phiên bản trên máy tính của bạn, bạn không cần thực hiện thao tác này. Thay vào đó, bạn có thể “buộc” phải cài đặt lại bằng cách sử dụng p_load_current_gh() với đối số update = TRUE. Đọc thêm về pacman tại Minh họa trực tuyến\nCài đặt từ ZIP hoặc TAR\nBạn có thể cài đặt package từ một URL:\n\npackageurl &lt;- \"https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz\"\ninstall.packages(packageurl, repos=NULL, type=\"source\")\n\nHoặc, tải xuống máy tính của bạn dưới dạng tệp nén:\nCách 1: sử dụng lệnh install_local() từ package remotes\n\nremotes::install_local(\"~/Downloads/dplyr-master.zip\")\n\nCách 2: sử dụng lệnh install.packages() của base R, cung cấp đường dẫn tệp đến tệp ZIP và thiết lập type = \"source và repos = NULL.\n\ninstall.packages(\"~/Downloads/dplyr-master.zip\", repos=NULL, type=\"source\")\n\n\n\n\nCú pháp code\nĐể tăng sự tường minh trong cuốn sách này, các hàm đôi khi sẽ được đặt sau tên package của chúng bằng cách sử dụng ký hiệu :: theo cách sau: package_name::function_name()\nKhi một package được gọi cho một phiên làm việc, việc làm này là không cần thiết. Bạn chỉ cần sử dụng function_name(). Tuy nhiên, việc viết tên package sẽ hữu ích khi một tên hàm phổ biến và có thể tồn tại trong nhiều package (ví dụ: plot()). Việc viết tên package sẽ giúp gọi package trong trường hợp nó chưa được gọi ra.\n\n# This command uses the package \"rio\" and its function \"import()\" to import a dataset\nlinelist &lt;- rio::import(\"linelist.xlsx\", which = \"Sheet1\")\n\n\n\nTrợ giúp về hàm\nĐể đọc thêm thông tin về một hàm, bạn có thể tìm kiếm hàm đó trong cửa sổ Help của RStudio nằm ở góc dưới bên phải. Hoặc bạn cũng có thể chạy một lệnh chẳng hạn như ?thefunctionname (đặt tên của hàm sau dấu chấm hỏi) và trang Trợ giúp sẽ xuất hiện trong cửa sổ Help. Cuối cùng, hãy thử tìm kiếm trên internet.\n\n\nCập nhật packages\nBạn có thể cập nhật các packages bằng cách cài đặt lại chúng. Bạn cũng có thể bấm vào nút “Update” màu xanh lá cây trong cửa sổ packages của RStudio để xem packages nào có phiên bản mới để cài đặt. Lưu ý rằng code cũ của bạn có thể cần được cập nhật nếu có một bản sửa đổi lớn về cách hoạt động của một hàm!\n\n\nXóa packages\nSử dụng p_delete() từ pacman, hoặc remove.packages() từ base R. Ngoài ra, hãy tìm thư mục chứa thư viện của bạn và xóa thư mục theo cách thủ công.\n\n\nSự phụ thuộc\nCác packages thường phụ thuộc vào các packages khác để hoạt động. Chúng được gọi là sự phụ thuộc. Nếu một package không cài đặt được, thì package phụ thuộc vào nó có khả năng cũng không thể cài đặt được.\nXem sự phụ thuộc của một package với lệnh p_depends(), và xem package nào phụ thuộc vào nó với p_depends_reverse()\n\n\nHàm bị che giấu\nKhông có gì lạ nếu hai hoặc nhiều packages chứa cùng một tên hàm. Ví dụ: packages dplyr có hàm filter(), nhưng package stats cũng vậy. Hàm filter() mặc định phụ thuộc vào thứ tự các package này được gọi lên trong phiên làm việc R - packages được gọi ra sau sẽ là mặc định cho hàm filter().\nBạn có thể kiểm tra thứ tự của chúng trong cửa sổ Environment của R Studio - nhấp vào menu thả xuống “Global Environment” và xem thứ tự của các packages. Các hàm thuộc các packages ở vị trí thấp hơn trong danh sách thả xuống đó sẽ che giấu các hàm cùng tên trong các packages xuất hiện ở vị trí bên trên trong danh sách thả xuống. Khi bạn vừa gọi một package, R sẽ cảnh báo bạn trong bảng điều khiển nếu xảy ra hiện tượng này, nhưng điều này rất hay bị bỏ quên.\n\n\n\n\n\n\n\n\n\nDưới đây là những cách bạn có thể sửa lỗi hàm bị che giấu:\n\nGhi rõ tên package trong lệnh. Ví dụ, sử dụng dplyr::filter()\n\nSắp xếp lại thứ tự mà các package được tải (ví dụ trong p_load()), và bắt đầu một phiên làm việc R mới\n\n\n\nGỡ package\nĐể gỡ (detach) một package, hãy sử dụng lệnh dưới đây, với tên package chính xác và chỉ có một dấu hai chấm. Lưu ý rằng điều này có thể không giải quyết được việc hàm bị che giấu.\n\ndetach(package:PACKAGE_NAME_HERE, unload=TRUE)\n\n\n\nCài đặt phiên bản cũ hơn\nXem hướng dẫn này để cài đặt phiên bản cũ hơn của một package cụ thể.\n\n\nPackages đề xuất\nXem chương Package đề xuất để biết danh sách các packages thường được sử dụng trong dịch tễ học.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R Cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.vn.html#scripts",
    "href": "new_pages/basics.vn.html#scripts",
    "title": "3  R Cơ bản",
    "section": "3.8 Scripts",
    "text": "3.8 Scripts\nScripts là một phần cơ bản của lập trình. Chúng là các tài liệu chứa các câu lệnh của bạn (ví dụ: các hàm để tạo và chỉnh sửa bộ số liệu, các hàm để in các biểu đồ trực quan hóa số liệu, v.v.). Bạn có thể lưu một scripts và chạy lại sau này. Có nhiều lợi ích để lưu trữ và chạy các lệnh của bạn từ một scripts (so với nhập “từng lệnh” vào R console):\n\nTiện dụng - bạn có thể chia sẻ công việc của mình với người khác bằng cách gửi cho họ các tập lệnh của bạn\n\nKhả năng tái lập - để bạn và những người khác biết chính xác những gì bạn đã làm\n\nKiểm soát phiên bản - để bạn có thể theo dõi các thay đổi do chính bạn hoặc đồng nghiệp thực hiện\n\nDễ dàng nhận xét/chú thích - để giải thích cho đồng nghiệp của bạn những gì bạn đã làm\n\n\nBình luận\nKhi viết script, bạn có thể thêm các chú thích (“bình luận”) xung quanh code R của bạn. Bình luận là cần thiết để giải thích cho chính bạn và những người đọc khác hiểu những gì bạn đang làm. Bạn có thể thêm bình luận bằng cách nhập dấu thăng (#) và viết bình luận của bạn sau đó. Nội dung bình luận sẽ xuất hiện với màu khác với code R.\nBất kỳ code nào được viết sau dấu # sẽ không được chạy. Do đó, đặt dấu # trước dòng code cũng là một cách hữu ích để tạm thời vô hiệu hóa một dòng code (“comment out”) nếu bạn không muốn xóa nó). Bạn có thể comment out/in nhiều dòng cùng một lúc bằng cách bôi đen chúng và nhấn Ctrl + Shift + c (Cmd + Shift + c trong Mac).\n\n# A comment can be on a line by itself\n# import data\nlinelist &lt;- import(\"linelist_raw.xlsx\") %&gt;%   # a comment can also come after code\n# filter(age &gt; 50)                          # It can also be used to deactivate / remove a line of code\n  count()\n\n\nBình luận những gì bạn đang làm và tại sao bạn làm như vậy.\n\nChia code của bạn thành các phần hợp lý\n\nKèm theo code của bạn với mô tả từng bước về những gì đang được thực hiện (ví dụ: các bước được đánh số)\n\n\n\nPhong cách viết code\nPhong cách viết code của bạn rất quan trọng - đặc biệt là khi làm việc theo nhóm. Chúng tôi khuyên bạn nên tuân theo hướng dẫn phong cách viết code tidyverse . Bên cạnh đó còn có các packages khác như styler và lintr để giúp bạn tuân theo phong cách này.\nMột vài điểm rất cơ bản để làm cho code của bạn dễ dàng đọc được đối với người khác:\n* Khi đặt tên cho các đối tượng, chỉ sử dụng các chữ cái viết thường, số và dấu gạch dưới _, ví dụ: my_data\n* Thường xuyên sử dụng dấu cách, bao gồm cả xung quanh các toán tử, ví dụ: n = 1 và age_new &lt;- age_old + 3\n\n\nVí dụ về Script\nDưới đây là một ví dụ về một đoạn ngắn R script. Hãy nhớ rằng, bạn càng giải thích ngắn gọn lệnh code của mình trong phần bình luận, thì đồng nghiệp của bạn sẽ càng thích bạn!\n\n\n\n\n\n\n\n\n\n\n\n\nR markdown\nR markdown là một dạng của R script và có khả năng xuất thành các tệp đầu ra (PDF, Word, HTML, Powerpoint, v.v.). Đây là những công cụ vô cùng hữu ích và linh hoạt thường được sử dụng để tạo các báo cáo tự động. Ngay cả trang web và cuốn sách này cũng được viết bằng R markdown!\nBạn cần biết rằng những người mới bắt đầu dùng R cũng có thể sử dụng R Markdown - do đó đừng sợ! Để tìm hiểu thêm, hãy xem chương Báo cáo với R Markdown trong cuốn sách này.\n\n\n\nR notebooks\nKhông có sự khác biệt trong cách viết giữa R markdown và R notebook. Tuy nhiên, việc thực thi của hai loại file này hơi khác nhau một chút. Xem trang Web này để biết thêm chi tiết.\n\n\n\nShiny\nShiny apps/websites được chứa trong một script có tên app.R. Tệp này có ba thành phần:\n\nGiao diện người dùng (ui)\n\nMột hàm máy chú\n\nMột lệng gọi hàm shinyApp\n\nXem thêm trong cuốn sách này tại chương Dashboards với Shiny, hoặc hướng dẫn trực tuyến này: Shiny tutorial\nTrước đây, tệp bên trên được chia thành 2 tệp con (ui.R và server.R)\n\n\nThu gọn Code\nBạn có thể thu gọn các đoạn code để làm cho script của bạn dễ đọc hơn.\nĐể làm điều này, hãy tạo tiêu đề văn bản bằng dấu thăng #, viết tiêu đề của bạn và thêm vào phía sau nó ít nhất hoặc là 4 dấu gạch ngang (-), dấu thăng (#) hoặc dấu bằng (=). Ngay sau đó, một mũi tên nhỏ sẽ xuất bên cạnh ở bên phải số thự tự của dòng lệnh. Bạn có thể nhấp vào mũi tên này và phần code bên dưới sẽ được thu gọn cho đến trước tiêu đề tiếp theo và một mũi tên hai chiều xuất hiện ở đây.\nĐể mở rộng lại đoạn code đã thu gọn, hãy nhấp lại vào mũi tên hoặc biểu tượng mũi tên hai chiều. Ngoài ra còn có thể sử dụng thêm các phím tắt như đã được giải thích trong mục RStudio của chương này.\nBằng cách tạo tiêu đề bằng #, bạn cũng sẽ kích hoạt Mục lục ở cuối tập lệnh của mình (xem bên dưới) mà bạn có thể sử dụng để điều hướng tập lệnh của mình. Bạn có thể tạo tiêu đề phụ bằng cách thêm các ký hiệu #, ví dụ: # # cho tiêu đề chính, ## fcho tiêu đề thứ hai, và ### cho tiêu đề thứ ba.\nDưới đây là hai phiên bản của một ví dụ cho script. Ở bên trái là bản gốc với các tiêu đề được chú thích. Ở bên phải, bốn dấu gạch ngang đã được viết sau mỗi tiêu đề, làm cho chúng có thể thu gọn được. Hai trong số chúng đã được thu gọn và bạn có thể thấy Mục lục ở dưới cùng hiện hiển thị từng phần.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCác phần code khác mặc định đủ điều kiện để thu gọn bao gồm các phần “nằm giữa” hai dấu ngoặc nhọn { }, chẳng hạn như định nghĩa hàm hoặc các khối điều kiện (câu lệnh if else). Bạn có thể đọc thêm về cách thu gọn code tại trang của Rstudio.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R Cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.vn.html#thư-mục-làm-việc",
    "href": "new_pages/basics.vn.html#thư-mục-làm-việc",
    "title": "3  R Cơ bản",
    "section": "3.9 Thư mục làm việc",
    "text": "3.9 Thư mục làm việc\nThư mục làm việc là vị trí thư mục gốc được R sử dụng cho công việc của bạn - nơi R tìm kiếm và lưu các tệp theo mặc định. Mặc định là, R sẽ lưu các tệp mới và xuất tệp vào vị trí này, đồng thời sẽ tìm kiếm các tệp để nhập dữ liệu (ví dụ: bộ dữ liệu) tại đây.\nThư mục làm việc xuất hiện bằng dòng chữ màu xám ở phía trên cửa sổ Rstudio Console. Bạn cũng có thể in thư mục làm việc hiện tại bằng cách chạy lệnh getwd() (để trống dấu ngoặc đơn).\n\n\n\n\n\n\n\n\n\n\nGợi ý cách tiếp cận\nXem thêm tại chương Dự án R để biết chi tiết về gợi ý các cách tiếp cận của chúng tôi trong việc quản lý thư mục làm việc của bạn.\nMột cách phổ biến, hiệu quả và không gặp sự cố khi quản lý thư mục làm việc và đường dẫn tệp là kết hợp 3 yếu tố này trong một quy trình làm việc với Dự án R có định hướng :\n\nMột dự án R để lưu trữ tất cả tệp của bạn (xem chương [Dự án R])\n\nPackage here để định vị tệp (xem chương Nhập xuất dữ liệu)\n\nPackge rio để nhập/xuất tệp (xem chương Nhập xuất dữ liệu)\n\n\n\n\nThiết lập bằng lệnh\nCho tới gần đây, nhiều người học R đã được dạy để bắt đầu script của họ bằng lệnh setwd(). Hãy thay đổi thói quen đó bằng cách sử dụng Dự án R và đọc thêm tài liệu sau để hiểu lý do không nên sử dụng setwd(). Một cách ngắn gọn là, công việc của bạn chỉ thực hiện được trên máy tính của bạn, các đường dẫn tệp được sử dụng để nhập và xuất tệp trở nên “dễ lỗi” và điều này cản trở nghiêm trọng đến việc cộng tác và sử dụng code của bạn trên bất kỳ máy tính nào khác. Bạn có những lựa chọn khác dễ dàng hơn!\nNhư đã nói ở trên, mặc dù chúng tôi không khuyến nghị phương pháp này trong hầu hết các trường hợp, bạn vẫn có thể sử dụng lệnh setwd() với đường dẫn tệp thư mục mong muốn trong dấu ngoặc kép, ví dụ:\n\nsetwd(\"C:/Documents/R Files/My analysis\")\n\nNGUY HIỂM: thiết lập một thư mục làm việc với setwd() có thể dẫn đến “lỗi” nếu đường dẫn tệp dành riêng cho một máy tính. Thay vào đó, hãy sử dụng đường dẫn tệp liên quan đến thư mục gốc Dự án R (với package here).\n\n\n\nThiết lập thủ công\nĐể thiết lập thư mục làm việc một cách thủ công (trỏ và nhấp tương đương với setwd()), hãy chọn mục Session trên thanh công cụ và chọn “Set Working Directory”, sau đó chọn “Choose Directory”. Chú ý: nếu sử dụng phương pháp này, bạn sẽ phải thực hiện việc này theo cách thủ công mỗi khi mở RStudio.\n\n\n\nThiết lập bên trong một dự án R\nNếu bạn đang mở một dự án R, thư mục làm việc sẽ mặc định là thư mục gốc của dự án R có chứa tệp “.rproj”. Điều này sẽ áp dụng nếu bạn mở RStudio bằng cách nhấp vào mở R Project (tệp có phần mở rộng “.rproj”).\n\n\n\nThư mục làm việc với R markdown\nTrong script ở R markdown, thư mục làm việc mặc định là thư mục chứa tệp R markdown (.Rmd). Nếu sử dụng dự án R và package here, điều này sẽ không được áp dụng. Để biết thư mục làm việc là gì, sử dụng lệnh here() như đã được giải thích tại chương Dự án R.\nNếu bạn muốn thay đổi thư mục làm việc của một tệp độc lập ở R markdown (không phải ở dự án R), nếu bạn sử dụng setwd() điều này sẽ chỉ áp dụng chỉ cho đoạn code đó. Để thực hiện thay đổi cho tất cả các đoạn code trong R markdown, hãy điều chỉnh ở bước thiết lập để thêm tham số root.dir =, như bên dưới:\n\nknitr::opts_knit$set(root.dir = 'desired/directorypath')\n\nCách này dễ hơn nhiều so với chỉ sử dụng R markdown bên trong một dự án R và sử dụng package here.\n\n\n\nCung cấp đường dẫn tệp\nCó lẽ điều khiến những người mới bắt đầu với R cảm thấy nản nhất (ít nhất là với người dùng máy tính Windows) đó là gõ đường dẫn tệp để nhập xuất dữ liệu. Chúng tôi có giải thích cặn kẽ về cách tạo đường dẫn tệp đầu vào tốt nhất trong chương Nhập xuất dữ liệu, nhưng dưới đây là một số điểm chính:\nĐường dẫn tệp bị lỗi\nDưới đây là ví dụ về đường dẫn tệp “tuyệt đối” hoặc “địa chỉ đầy đủ”. Chúng có thể bị lỗi nếu được sử dụng bởi một máy tính khác. Một ngoại lệ là nếu bạn đang sử dụng ổ đĩa chia sẻ/mạng.\nC:/Users/Name/Document/Analytic Software/R/Projects/Analysis2019/data/March2019.csv  \nĐường dẫn với dấu gạch chéo\nNếu nhập đường dẫn tệp, hãy lưu ý hướng của các dấu gạch chéo. Sử dụng dấu gạch chéo xuôi (/) để tách các thành phần (“data/provincial.csv”). Đối với người dùng Windows, cách mặc định mà đường dẫn tệp được hiển thị là dấu gạch chéo ngược (\\) - vì vậy bạn sẽ cần phải thay đổi hướng của mỗi dấu gạch chéo. Nếu bạn sử dụng package here được miêu tả ở Dự án R thì dấu gạch chéo không còn là vấn đề với bạn nữa.\nĐường dẫn tệp tương đối\nNói chung, chúng tôi khuyên bạn nên cung cấp các đường dẫn tệp theo cách “tương đối” - nghĩa là, đường dẫn liên quan đến thư mục gốc Dự án R của bạn. Bạn có thể thực hiện việc này bằng cách sử dụng package here như được giải thích trong chương Dự án R. Một đường dẫn tệp tương đối sẽ trông như thế này:\n\n# Import csv linelist from the data/linelist/clean/ sub-folders of an R project\nlinelist &lt;- import(here(\"data\", \"clean\", \"linelists\", \"marin_country.csv\"))\n\nNgay cả khi sử dụng đường dẫn tệp tương đối trong dự án R, bạn vẫn có thể sử dụng đường dẫn tuyệt đối để nhập/xuất dữ liệu ở bên ngoài dự án R của bạn.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R Cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.vn.html#objects",
    "href": "new_pages/basics.vn.html#objects",
    "title": "3  R Cơ bản",
    "section": "3.10 Đối tượng",
    "text": "3.10 Đối tượng\nMọi thứ trong R đều là một đối tượng, và R là một ngôn ngữ “lập trình hướng đối tượng”. Các phần dưới đây sẽ giải thích:\n\nCách tạo ra các đối tượng (&lt;-)\nCác loại đối tượng (ví dụ: data frames, vectors..)\n\nCách truy cập các tập con của đối tượng (ví dụ: các biến số trong một bộ dữ liệu)\n\nCác loại đối tượng (ví dụ: numeric, logical, integer, double, character, factor)\n\n\n\nMọi thứ đều là một đối tượng\nPhần này được dựa theo sách R4Epis project.\nMọi thứ bạn lưu trữ trong R - bao gồm bộ dữ liệu, biến số, danh sách tên làng, tổng số dân, thậm chí cả kết quả đầu ra như biểu đồ - đều là các đối tượng, được gán tên và có thể được tham chiếu trong các lệnh sau đó.\nMột đối tượng tồn tại khi bạn đã gán giá trị cho nó (xem phần gán bên dưới). Khi nó được gán một giá trị, đối tượng sẽ xuất hiện trong cửa sổ Environment (xem cửa sổ phía trên bên phải của RStudio). Sau đó, nó có thể được sử dụng, thao tác, thay đổi và định nghĩa lại.\n\n\n\nĐịnh nghĩa một đối tượng (&lt;-)\nTạo ra một đối tượng bằng cách gán cho chúng một giá trị bằng toán tử &lt;-.\nBạn có thể nghĩ về toán tử gán &lt;- tương đương với từ “được định nghĩa là”. Các lệnh gán thường tuân theo một trật tự quy định:\ntên đối tượng &lt;- giá trị của đối tượng (hoặc quy trình / tính toán tạo ra giá trị)\nVí dụ: bạn muốn ghi nhận một báo cáo tuần dịch tễ học hiện tại dưới dạng một đối tượng để tham chiếu tới code của bạn sau này. Trong ví dụ này, đối tượng current_week được tạo khi nó được gán giá trị \"2018-W10\" (dấu ngoặc kép sẽ quy định đây là giá trị dạng chữ). Đối tượng current_week sẽ xuất hiện trong cửa sổ RStudio Environment (phía trên bên phải) và có thể được tham chiếu tới các lệnh sau này.\nXem các lệnh R và kết quả của chúng như dưới đây.\n\ncurrent_week &lt;- \"2018-W10\"   # this command creates the object current_week by assigning it a value\ncurrent_week                 # this command prints the current value of current_week object in the console\n\n[1] \"2018-W10\"\n\n\nCHÚ Ý: Lưu ý rằng số [1] trong kết quả ở R console đơn giản là chỉ ra rằng bạn đang xem mục đầu tiên của đầu ra\nTHẬN TRỌNG: Giá trị của một đối tượng có thể bị ghi đè bất kỳ lúc nào bằng cách chạy lệnh gán để định nghĩa lại giá trị của nó. Do đó, thứ tự của các lệnh được chạy rất quan trọng.\nLệnh sau sẽ định nghĩa lại giá trị của đối tượng current_week:\n\ncurrent_week &lt;- \"2018-W51\"   # assigns a NEW value to the object current_week\ncurrent_week                 # prints the current value of current_week in the console\n\n[1] \"2018-W51\"\n\n\nDấu bằng =\nBạn cũng sẽ thấy các dấu bằng trong R code:\n\nHai dấu bằng == giữa hai đối tượng hoặc giá trị dùng để đặt một câu hỏi logic: “cái này có bằng cái kia không?”.\n\nBạn cũng sẽ thấy các dấu bằng trong các hàm được sử dụng để xác định giá trị của các đối số của hàm (đọc thêm ở các phần bên dưới), ví dụ: max(age, na.rm = TRUE).\n\nBạn có thể sử dụng một dấu bằng = thay cho dấu &lt;- để tạo và định nghĩa các đối tượng, nhưng điều này không được khuyến khích. Bạn có thể đọc về lý do tại sao điều này không được khuyến khích ở đây.\n\nBộ dữ liệu\nBộ dữ liệu (datasets) cũng là một đối tượng (thường là một “dataframes”) và phải được gán tên khi chúng được nhập. Trong đoạn mã dưới đây, đối tượng linelist được tạo và gán giá trị từ tệp CSV, tệp này được nhập bằng package rio và hàm import() của package này.\n\n# linelist is created and assigned the value of the imported CSV file\nlinelist &lt;- import(\"my_linelist.csv\")\n\nBạn có thể đọc thêm về nhập và xuất dữ liệu trong chương Nhập xuất dữ liệu.\nTHẬN TRỌNG: Lưu ý nhanh về cách đặt tên đối tượng:\n\nTên đối tượng không được chứa dấu cách, nhưng bạn nên sử dụng dấu gạch dưới (_) hoặc dấu chấm (.) thay vì dấu cách.\n\nTên đối tượng phân biệt chữ hoa và chữ thường (nghĩa là Dataset_A khác với dataset_A).\nTên đối tượng phải bắt đầu bằng chữ cái (không được bắt đầu bằng số như 1, 2 hoặc 3).\n\nKết quả đầu ra\nCác kết quả đầu ra như bảng và biểu đồ cung cấp một ví dụ về cách các kết quả đầu ra có thể được lưu dưới dạng đối tượng hoặc chỉ được in ra mà không cần lưu. Ví dụ, một bảng chéo giữa giới tính và biến kết cục được tạo ra bởi hàm table() trong base R, có thể được in trực tiếp vào R console (mà không cần lưu).\n\n# printed to R console only\ntable(linelist$gender, linelist$outcome)\n\n   \n    Death Recover\n  f  1227     953\n  m  1228     950\n\n\nNhưng bảng này cũng có thể được lưu dưới dạng một đối tượng được đặt tên. Sau đó, bạn có thể in nó ra.\n\n# save\ngen_out_table &lt;- table(linelist$gender, linelist$outcome)\n\n# print\ngen_out_table\n\n   \n    Death Recover\n  f  1227     953\n  m  1228     950\n\n\nCột\nCác cột trong tập dữ liệu cũng là các đối tượng và có thể được định nghĩa, ghi đè và tạo như được mô tả bên dưới trong phần Cột.\nBạn có thể sử dụng toán tử gán từ base R để tạo một cột mới. Dưới đây, cột mới bmi (Body Mass Index) được tạo, và giá trị mới ứng với mỗi hàng là kết quả của một phép toán trên giá trị của các hàng trong cột wt_kg và cột ht_cm.\n\n# create new \"bmi\" column using base R syntax\nlinelist$bmi &lt;- linelist$wt_kg / (linelist$ht_cm/100)^2\n\nTuy nhiên, trong cuốn sách này, chúng tôi tập trung vào một cách tiếp cận khác để định nghĩa cột, sử dụng hàm mutate() trong package dplyr và piping với toán tử pipe (%&gt;%). Cú pháp dễ đọc hơn và có những ưu điểm khác đã được giải thích trong cuốn sách này ở chương Làm sạch số liệu và các hàm quan trọng. Bạn có thể đọc thêm về piping trong phần Piping phía bên dưới.\n\n# create new \"bmi\" column using dplyr syntax\nlinelist &lt;- linelist %&gt;% \n  mutate(bmi = wt_kg / (ht_cm/100)^2)\n\n\n\n\n3.10.1 Cấu trúc đối tượng\nCác đối tượng có thể là một phần dữ liệu đơn lẻ (ví dụ: my_number &lt;- 24), hoặc chúng có thể bao gồm dữ liệu có cấu trúc.\nHình ảnh dưới đây được tham khảo từ hướng dẫn R trực tuyến này. Nó cho thấy một số cấu trúc dữ liệu phổ biến và tên của chúng. Hình ảnh này không bao gồm dữ liệu không gian. Bạn có thể xem thêm về dữ liệu không gian tại chương GIS cơ bản.\n\n\n\n\n\n\n\n\n\nTrong dịch tễ học (và đặc biệt là dịch tễ học thực địa), bạn sẽ thường xuyên phải tiếp xúc với data frames và vectors:\n\n\n\n\n\n\n\n\nCấu trúc thường gặp\nGiái thích\nVí dụ\n\n\n\n\nVectors\nMột vùng chứa cho một chuỗi các đối tượng đơn lẻ, tất cả đều thuộc cùng một loại (e.g. số, chữ).\n“Biến” (Cột) trong dữ liệu là vectors (ví dụ: cột age_years).\n\n\nData Frames\nVectors (ví dụ: các cột) được liên kết với nhau mà tất cả đều có cùng số hàng.\n`linelist` là một data frame.\n\n\n\nLưu ý rằng để tạo một vectơ “độc lập” (mà không phải là một phần của data frame), hàm c() được sử dụng để kết hợp các phần tử khác nhau. Ví dụ: nếu tạo một vectơ màu sắc thang màu của biểu đồ: vector_of_colors &lt;- c(\"blue\", \"red2\", \"orange\", \"grey\")\n\n\n\nKiểu đối tượng\nTất cả các đối tượng được lưu trữ trong R đều có một kiểu dữ liệu cho biết cách nó được xử lý. Có nhiều kiểu đối tượng, nhưng những kiểu phổ biến bao gồm:\n\n\n\n4 Kiểu\nKý tự\n5 Giải thích\nLà các chữ/từ/câu được đặt “trong dấu ngoặc kép”. Đối tượng kiểu ký tự thì không thể tính toán\n6 Ví dụ\n“Những ký tự nằm trong dấu ngoặc kép”\n\n\n\n\n\n\n\n\n\nSố nguyên\nCác số nguyên (không có phần thập phân)\n-5, 14, hoặc 2000\n\n\n\nSố thực\nBao gồm các số nguyên và có thể bao gồm phần thập phân. Nếu trong dấu ngoặc kép, chúng sẽ được coi là dạng ký tự\n23.1 hoặc 14\n\n\n\nDanh mục\nĐây là các vector có trật tự xác định hoặc các giá trị có nhiều danh mục\nBiến số của tình trạng kinh tế với các giá trị theo tứ tự\n\n\n\nNgày tháng\nKhi R được thông báo rằng một dữ liệu ở dạng ngày tháng R, những dữ liệu này có thể được thao tác và hiển thị theo những cách đặc biệt. Xem thêm về biến ngày tháng tại chương Làm việc với ngày tháng. | 2018-04-12 hoặc 15/3/1954 hoặc Wed 4 Jan 1980\n\n\n\n\nLogic\nGiá trị của biến chỉ có thể là hai giá trị đặc biệt sau TRUE hoặc FALSE (lưu ý đây không phải là “TRUE” và”FALSE” trong dấu ngoặc kép)\nTRUE hoặc FALSE\n\n\n\ndata.frame\nMột data.frame trong R lưu trữ một tập dữ liệu điển hình. Data.frame bao gồm các vector (cột) dữ liệu được liên kết với nhau, tất cả chúng đều có cùng một số lượng quan sát (hàng).\nTập dữ liệu mẫu AJS có tên là linelist_rawchứa 68 biến với 300 quan sát (mỗi hàng)\n\n\n\ntibble\ntibbles là một dạng khác của data.frame, sự khác biệt chính là tibble in đẹp hơn trong R console (hiển thị 10 hàng đầu tiên và chỉ các cột vừa với màn hình)\ndata frame, danh sách, hoặc ma trận có thể chuyển đổi thành tibble bằng hàm as_tibble()\n\n\n\nDanh sách\nMột danh sách giống như một vector, nhưng chứa các đối tượng có kiểu khác nhau\nMột danh sách có thể chứa một số duy nhất, một data.frame, một vector và thậm chí một danh sách khác bên trong nó!\n\n\n\n\nBạn có thể kiểm tra kiểu của một đối tượng bằng cách cung cấp tên của nó tới hàm class(). Lưu ý: bạn có thể tham chiếu một cột cụ thể trong tập dữ liệu bằng cách sử dụng ký hiệu $ để phân tách tên của tập dữ liệu và tên của cột.\n\nclass(linelist)         # class should be a data frame or tibble\n\n[1] \"data.frame\"\n\nclass(linelist$age)     # class should be numeric\n\n[1] \"numeric\"\n\nclass(linelist$gender)  # class should be character\n\n[1] \"character\"\n\n\nĐôi khi, một cột sẽ được tự động chuyển đổi thành một kiểu khác bởi R. Hãy coi chừng điều này! Ví dụ: nếu bạn có một vectơ hoặc cột kiểu số, nhưng nếu có bất kỳ một giá trị dạng ký tự nào xuất hiện trong cột thì toàn bộ cột sẽ thay đổi thành kiểu ký tự.\n\nnum_vector &lt;- c(1,2,3,4,5) # define vector as all numbers\nclass(num_vector)          # vector is numeric class\n\n[1] \"numeric\"\n\nnum_vector[3] &lt;- \"three\"   # convert the third element to a character\nclass(num_vector)          # vector is now character class\n\n[1] \"character\"\n\n\nMột ví dụ phổ biến của điều này là khi thao tác với một bộ dữ liệu để tạo bảng - nếu bạn tạo một hàng tính tổng và cố gắng dán /gắn phần trăm với số trong cùng một ô (ví dụ: 23 (40%)), toàn bộ cột dạng số ở trên sẽ chuyển đổi thành ký tự và không còn có thể được sử dụng cho các phép tính toán học nữa.\nĐôi khi, bạn sẽ cần chuyển đổi các đối tượng hoặc cột sang một loại khác.\n\n\n\n7 Hàm\nas.character()\n8 Chức năng\nChuyển sang kiểu ký tự\n\n\n\n\n\n\n\n\nas.numeric()\nChuyển sang kiểu số\n\n\n\nas.integer()\nChuyển sang kiểu số nguyên\n\n\n\nas.Date()\nChuyển sang kiểu ngày tháng - Chú ý: Xem mục Ngày tháng để biết thêm chi tiết\n\n\n\nfactor()\nChuyển sang kiểu danh mục- Chú ý: nếu muốn định nghĩa lại thứ tự của các giá trị trong biến factor thì cần thêm các đối số bổ sung\n\n\n\n\nTương tự như vậy, một số hàm base R có thể kiểm tra xem một đối tượng CÓ thuộc của một kiểu dữ liệu cụ thể nào hay không, chẳng hạn như is.numeric(), is.character(), is.double(), is.factor(), is.integer()\nBạn có thể tham khảo một tài liệu trực tuyến về các kiểu và cấu trúc dữ liệu trong R tại đây.\n\n\n\nCột / Biến số ($)\nMột cột trong data frame về mặt kỹ thuật là một “vector” (xem bảng ở trên) - bao gồm một chuỗi các giá trị cùng loại (ký tự, số, lôgic, v.v.).\nMột vectơ có thể tồn tại độc lập với một data frame, ví dụ: vectơ tên cột mà bạn muốn đưa vào làm biến giải thích trong mô hình. Để tạo một vectơ “độc lập”, hãy sử dụng hàm c() như dưới đây:\n\n# define the stand-alone vector of character values\nexplanatory_vars &lt;- c(\"gender\", \"fever\", \"chills\", \"cough\", \"aches\", \"vomit\")\n\n# print the values in this named vector\nexplanatory_vars\n\n[1] \"gender\" \"fever\"  \"chills\" \"cough\"  \"aches\"  \"vomit\" \n\n\nCác cột trong data frame cũng là vectơ và có thể được gọi, tham chiếu, trích xuất hoặc tạo bằng ký hiệu $. Ký hiệu $ kết nối tên của cột với tên của data frame tương ứng. Trong cuốn sách này, chúng tôi cố gắng sử dụng từ “cột” thay vì “biến số”.\n\n# Retrieve the length of the vector age_years\nlength(linelist$age) # (age is a column in the linelist data frame)\n\nBằng cách nhập tên của một dataframe, theo sau bởi ký tự $, bạn sẽ thấy menu gợi ý của tất cả các tên cột trong dataframe. Bạn có thể di chuyển giữa các cột bằng phím mũi tên, chọn cột bằng phím Enter để tránh lỗi chính tả!\n\n\n\n\n\n\n\n\n\nMẸO NÂNG CAO: Một số đối tượng phức tạp hơn (ví dụ: một danh sách hoặc đối tượng epicontacts) có thể có nhiều cấp độ có thể được truy cập thông qua nhiều ký tự đô la. Ví dụ: epicontacts$linelist$date_onset\n\n\n\nTruy cập / indexing đối tượng bằng dấu ngoặc vuông ([ ])\nKhi cần xem một phần của đối tượng, còn được gọi là “indexing”, bạn có thể sử dụng dấu ngoặc vuông [ ]. Sử dụng $ trên dataframe để truy cập một cột cũng là một kiểu indexing.\n\nmy_vector &lt;- c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\")  # define the vector\nmy_vector[5]                                  # print the 5th element\n\n[1] \"e\"\n\n\nDấu ngoặc vuông cũng hoạt động để xem các phần cụ thể trong kết quả đầu ra, chẳng hạn như đầu ra của hàm summary():\n\n# All of the summary\nsummary(linelist$age)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00    6.00   13.00   16.07   23.00   84.00      86 \n\n# Just the second element of the summary, with name (using only single brackets)\nsummary(linelist$age)[2]\n\n1st Qu. \n      6 \n\n# Just the second element, without name (using double brackets)\nsummary(linelist$age)[[2]]\n\n[1] 6\n\n# Extract an element by name, without showing the name\nsummary(linelist$age)[[\"Median\"]]\n\n[1] 13\n\n\nDấu ngoặc vuông cũng hoạt động trên data frames để xem các hàng và cột cụ thể. Bạn có thể thực hiện việc này bằng cú pháp dataframe[rows, columns]:\n\n# View a specific row (2) from dataset, with all columns (don't forget the comma!)\nlinelist[2,]\n\n# View all rows, but just one column\nlinelist[, \"date_onset\"]\n\n# View values from row 2 and columns 5 through 10\nlinelist[2, 5:10] \n\n# View values from row 2 and columns 5 through 10 and 18\nlinelist[2, c(5:10, 18)] \n\n# View rows 2 through 20, and specific columns\nlinelist[2:20, c(\"date_onset\", \"outcome\", \"age\")]\n\n# View rows and columns based on criteria\n# *** Note the dataframe must still be named in the criteria!\nlinelist[linelist$age &gt; 25 , c(\"date_onset\", \"outcome\", \"age\")]\n\n# Use View() to see the outputs in the RStudio Viewer pane (easier to read) \n# *** Note the capital \"V\" in View() function\nView(linelist[2:20, \"date_onset\"])\n\n# Save as a new object\nnew_table &lt;- linelist[2:20, c(\"date_onset\")] \n\nLưu ý rằng bạn cũng có thể indexing hàng / cột trong một data frames và tibbles bằng cách sử dụng cú pháp của package dplyr (hàm filter() đối với hàng, và select() đối với cột). Đọc thêm về các hàm quan trọng này trong chương Làm sạch số liệu và các hàm quan trọng.\nĐể lọc dựa trên “số thứ tự hàng”, bạn có thể sử dụng hàm row_number()trong package dplyr với dấu ngoặc đơn mở như một phần của biểu thức lọc logic. Thường thì bạn sẽ sử dụng toán tử %in% và một khoảng giá trị số như một phần của câu lệnh logic đó, như được trình bày dưới đây. Để xem N hàng đầu tiên, bạn cũng có thể sử dụng hàm head() của package dplyr.\n\n# View first 100 rows\nlinelist %&gt;% head(100)\n\n# Show row 5 only\nlinelist %&gt;% filter(row_number() == 5)\n\n# View rows 2 through 20, and three specific columns (note no quotes necessary on column names)\nlinelist %&gt;% filter(row_number() %in% 2:20) %&gt;% select(date_onset, outcome, age)\n\nKhi indexing một đối tượng chứa một danh sách bằng một dấu ngoặc vuông sẽ luôn trả về kiểu danh sách, ngay cả khi chỉ một đối tượng được trả về . Tuy nhiên, hai dấu ngoặc vuông có thể được sử dụng để truy cập một phần tử đơn lẻ đối và trả về một kiểu không phải là một danh sách.\nDấu ngoặc vuông cũng có thể được viết sau nhau, như được minh họa bên dưới.\nBạn có thể xem một giải thích trực quan về việc indexing với ví dụ về hộp lắc hạt tiêu tại đây, rất hài hước và hữu ích.\n\n# define demo list\nmy_list &lt;- list(\n  # First element in the list is a character vector\n  hospitals = c(\"Central\", \"Empire\", \"Santa Anna\"),\n  \n  # second element in the list is a data frame of addresses\n  addresses   = data.frame(\n    street = c(\"145 Medical Way\", \"1048 Brown Ave\", \"999 El Camino\"),\n    city   = c(\"Andover\", \"Hamilton\", \"El Paso\")\n    )\n  )\n\nĐây là cách mà một danh sách được in trong R console. Có hai phần tử được đặt tên:\n\nhospitals, một vector chứa ký tự\n\naddresses, một data frame chứa các địa chỉ\n\n\nmy_list\n\n$hospitals\n[1] \"Central\"    \"Empire\"     \"Santa Anna\"\n\n$addresses\n           street     city\n1 145 Medical Way  Andover\n2  1048 Brown Ave Hamilton\n3   999 El Camino  El Paso\n\n\nDưới đây là các phương pháp indexing mà bạn có thể sử dụng:\n\nmy_list[1] # this returns the element in class \"list\" - the element name is still displayed\n\n$hospitals\n[1] \"Central\"    \"Empire\"     \"Santa Anna\"\n\nmy_list[[1]] # this returns only the (unnamed) character vector\n\n[1] \"Central\"    \"Empire\"     \"Santa Anna\"\n\nmy_list[[\"hospitals\"]] # you can also index by name of the list element\n\n[1] \"Central\"    \"Empire\"     \"Santa Anna\"\n\nmy_list[[1]][3] # this returns the third element of the \"hospitals\" character vector\n\n[1] \"Santa Anna\"\n\nmy_list[[2]][1] # This returns the first column (\"street\") of the address data frame\n\n           street\n1 145 Medical Way\n2  1048 Brown Ave\n3   999 El Camino\n\n\n\n\n\nXóa đối tượng\nBạn có thể xóa từng đối tượng riêng lẻ khỏi cửa sổ R environment bằng cách để tên của đối tượng cần xóa vào trong hàm rm() (không có dấu ngoặc kép):\n\nrm(object_name)\n\nBạn có thể xóa tất cả các đối tượng (xóa không gian làm việc của bạn) bằng cách chạy:\n\nrm(list = ls(all = TRUE))",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R Cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.vn.html#piping",
    "href": "new_pages/basics.vn.html#piping",
    "title": "3  R Cơ bản",
    "section": "8.1 Piping (%>%)",
    "text": "8.1 Piping (%&gt;%)\nHai cách tiếp cận chung để làm việc với các đối tượng là:\n\nPipes/tidyverse - pipes chuyển một đối tượng từ hàm này sang hàm khác - tập trung vào hành động chứ không phải đối tượng\n\nXác định đối tượng trung gian - một đối tượng được xác định lại nhiều lần - tập trung vào đối tượng\n\n\n\nPipes\nGiải thích một cách đơn giản, toán tử pipe (%&gt;%) nhận dữ liệu đầu ra trung gian từ một hàm và chuyển tiếp sang hàm tiếp theo.\nHiểu đơn giản thì pipe nghĩa là “tiếp tục”. Nhiều hàm có thể được liên kết với nhau bằng toán tử %&gt;%.\n\nPiping nhấn mạnh một chuỗi các hành động, không phải đối tượng mà các hành động đang áp dụng\n\nPipes được áp dụng tốt nhất khi một chuỗi hành động phải được thực hiện trên một đối tượng\n\nPipes đến từ package magrittr, và đã tự động được thêm vào packages dplyr và tidyverse\nPipes làm cho code gọn hơn, dễ đọc hơn và trực quan hơn\n\nĐọc thêm về cách tiếp cận này trong package tidyverse tại đây Hướng dẫn\nĐây là một ví dụ mô phỏng, ẩn dụ việc phân tích dữ liệu sử dụng các hàm như là các quy trình “nướng bánh”.\n\n# A fake example of how to bake a cake using piping syntax\n\ncake &lt;- flour %&gt;%       # to define cake, start with flour, and then...\n  add(eggs) %&gt;%   # add eggs\n  add(oil) %&gt;%    # add oil\n  add(water) %&gt;%  # add water\n  mix_together(         # mix together\n    utensil = spoon,\n    minutes = 2) %&gt;%    \n  bake(degrees = 350,   # bake\n       system = \"fahrenheit\",\n       minutes = 35) %&gt;%  \n  let_cool()            # let it cool down\n\nĐây là một link khác mô tả công dụng của pipe.\nPiping không phải là một hàm trong base R. Để sử dụng piping, package magrittr phải được cài đặt và gọi ra trong mỗi phiên làm việc (điều này thường được thực hiện bằng cách gọi package tidyverse hoặc dplyr). Bạn có thể đọc thêm về piping trong tài liệu magrittr.\nLưu ý rằng cũng giống như các hàm R khác, các pipes có thể được sử dụng để hiển thị kết quả hoặc lưu lại một đối tượng, tùy thuộc vào việc toán tử gán &lt;- có được thực hiện hay không. Xem hai ví dụ dưới đây:\n\n# Create or overwrite object, defining as aggregate counts by age category (not printed)\nlinelist_summary &lt;- linelist %&gt;% \n  count(age_cat)\n\n\n# Print the table of counts in the console, but don't save it\nlinelist %&gt;% \n  count(age_cat)\n\n  age_cat    n\n1     0-4 1095\n2     5-9 1095\n3   10-14  941\n4   15-19  743\n5   20-29 1073\n6   30-49  754\n7   50-69   95\n8     70+    6\n9    &lt;NA&gt;   86\n\n\n%&lt;&gt;%\n\nĐây là một “assignment pipe (pipe dùng để gán)” từ package magrittr, package này sẽ pipe một đối tượng theo chiều tiến lên và cũng tái định nghĩa lại đối tượng. Đối tượng cần đứng đầu trong chuỗi pipe. Nó nhanh hơn sử dụng pipe thông thường. Hai lệnh dưới đây là tương đương với nhau:\n\nlinelist &lt;- linelist %&gt;%\n  filter(age &gt; 50)\n\nlinelist %&lt;&gt;% filter(age &gt; 50)\n\n\n\n\nĐịnh nghĩa đối tượng trung gian\nCách tiếp cận này dùng để thay đổi đối tượng/dataframes sẽ phát huy hiệu quả nếu:\n\nBạn cần thao tác trên nhiều đối tượng\n\nCác bước trung gian có ý nghĩa cụ thể và xứng đáng tạo các tên đối tượng riêng biệt\n\nCác nguy cơ:\n\nTạo đối tượng mới cho mỗi bước có nghĩa là bạn sẽ tạo thêm rất nhiều đối tượng. Nếu bạn sử dụng không cẩn thận, bạn có thể dễ dàng bị nhầm lẫn!\n\nĐặt thêm nhiều tên cho nhiều đối tượng có thể gây nhầm lẫn\n\nNếu có lỗi thì không dễ để phát hiện\n\nĐặt tên cho từng đối tượng trung gian hoặc ghi đè lên đối tượng gốc hoặc kết hợp tất cả hàm với nhau đều đi kèm với những rủi ro.\nDưới đây vẫn là ví dụ mô phỏng quy trình làm “bánh” tương tự như trên, nhưng sử dụng phong cách này:\n\n# a fake example of how to bake a cake using this method (defining intermediate objects)\nbatter_1 &lt;- left_join(flour, eggs)\nbatter_2 &lt;- left_join(batter_1, oil)\nbatter_3 &lt;- left_join(batter_2, water)\n\nbatter_4 &lt;- mix_together(object = batter_3, utensil = spoon, minutes = 2)\n\ncake &lt;- bake(batter_4, degrees = 350, system = \"fahrenheit\", minutes = 35)\n\ncake &lt;- let_cool(cake)\n\nKết hợp tất cả các hàm với nhau - câu lệnh rất khó đọc:\n\n# an example of combining/nesting mutliple functions together - difficult to read\ncake &lt;- let_cool(bake(mix_together(batter_3, utensil = spoon, minutes = 2), degrees = 350, system = \"fahrenheit\", minutes = 35))",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R Cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.vn.html#operators",
    "href": "new_pages/basics.vn.html#operators",
    "title": "3  R Cơ bản",
    "section": "8.2 Các toán tử và hàm chính",
    "text": "8.2 Các toán tử và hàm chính\nMục này sẽ trình bày chi tiết các toán tử trong R, chẳng hạn như :\n\nToán tử định nghĩa\n\nToán tử quan hệ (nhỏ hơn, bằng nhau..)\n\nToán tử logic (và, hoặc..)\n\nXử lý missing\n\nCác toán tử và hàm toán học (+/-, &gt;, sum(), median(), …)\n\nToán tử %in%\n\n\n\nToán tử gán\n&lt;-\nToán tử gán cơ bản trong R là &lt;-. Chẳng hạn như object_name &lt;- value.\nToán tử gán này cũng có thể được viết là =. Chúng tôi khuyên bạn nên sử dụng &lt;-.\nBạn nên sử dụng dấu cách trong khi viết code với toán tử gán để dễ đọc hơn.\n&lt;&lt;-\nKhi Viết hàm, hoặc khi sử dụng R với scipt nguồn, thì bạn có thể cần sử dụng toán tử gán này &lt;&lt;- (từ base R). Toán tử này được sử dụng để định nghĩa một đối tượng trong một hàm lồng trong một hàm khác. Xem thêm tại nguồn tham khảo online này.\n%&lt;&gt;%\nĐây là một “pipe gán” từ package magrittr, package này sẽ gán một đối tượng theo chiều tiến lên và cũng định nghĩa lại đối tượng. Pipe gán phải là toán tử đầu tiên trong chuỗi pipe code. Đây là cách viết ngắn gọn, như được trình bày dưới đây là hai ví dụ tương đương với nhau:\n\nlinelist &lt;- linelist %&gt;% \n  mutate(age_months = age_years * 12)\n\nĐoạn code bên trên tương đương với code dưới đây:\n\nlinelist %&lt;&gt;% mutate(age_months = age_years * 12)\n\n%&lt;+%\nToán tử này được sử dụng dể thêm dữ liệu vào Cây phả hệ với package ggtree. Xem thêm chương Cây phả hệ hoặc Sách online này.\n\n\n\nToán tử quan hệ và logic\nToán tử quan hệ so sánh các giá trị và thường được sử dụng khi định nghĩa các biến mới và tập con của bộ dữ liệu. Dưới đây là các toán tử quan hệ phổ biến trong R:\n\n\n\n9 Ý nghĩa\nBằng\n10 Toán tử\n==\n11 Ví dụ\n\"A\" == \"a\"\n12 Kết quả đầu ra của ví dụ\nFALSE (vì R phân biệt chữ hoa chữ thường) Lưu ý rằng == (hai dấu bằng) khác với = (một dấu bằng), một dấu bằng hoạt động tương tự với toán tử gán &lt;-\n\n\n\n\n\n\n\n\n\n\nKhông bằng\n!=\n2 != 0\nTRUE\n\n\n\nLớn hơn\n&gt;\n4 &gt; 2\nTRUE\n\n\n\nNhỏ hơn\n&lt;\n4 &lt; 2\nFALSE\n\n\n\nLớn hơn hoặc bằng\n&gt;=\n6 &gt;= 4\nTRUE\n\n\n\nNhỏ hơn hoặc bằng\n&lt;=\n6 &lt;= 4\nFALSE\n\n\n\nGiá trị bị missing\nis.na()\nis.na(7)\nFALSE (Xem thêm chương Dữ liệu Missing)\n\n\n\nGiá trị không missing\n!is.na()\n!is.na(7)\nTRUE\n\n\n\n\nCác toán tử logic, chẳng hạn như AND và OR, thường được sử dụng để kết nối các quan hệ và tạo ra các điều kiện phức tạp hơn. Các biểu thức phức tạp có thể yêu cầu dấu ngoặc đơn () để phân nhóm và thứ tự áp dụng.\n\n\n\n\n\n\n\nÝ nghĩa\nToán tử\n\n\n\n\nAND\n&\n\n\nOR\n| (thanh dọc)\n\n\nDấu ngoặc đơn\n( ) Được sử dụng để nhóm các tiêu chí lại với nhau và làm rõ thứ tự hoạt động\n\n\n\nVí dụ: chúng ta có một số liệu có tên linelist với hai biến mà chúng tôi muốn sử dụng để minh họa, hep_e_rdt: kết quả xét nghiệm và other_cases_in_hh: những trường hợp khác trong gia đình. Lệnh dưới đây sử dụng hàm case_when() để tạo biến mới case_def như sau:\n\nlinelist_cleaned &lt;- linelist %&gt;%\n  mutate(case_def = case_when(\n    is.na(rdt_result) & is.na(other_case_in_home)            ~ NA_character_,\n    rdt_result == \"Positive\"                                 ~ \"Confirmed\",\n    rdt_result != \"Positive\" & other_cases_in_home == \"Yes\"  ~ \"Probable\",\n    TRUE                                                     ~ \"Suspected\"\n  ))\n\n\n\n\n\n\n\n\nĐiều kiện trong ví dụ ở trên\nGiá trị kết quả trong biến mới “case_def”\n\n\n\n\nNếu giá trị của biến rdt_result và other_cases_in_home bị missing\nNA (missing)\n\n\nNếu giá trị trong rdt_result là “Positive”\n“Confirmed”\n\n\nNếu giá trị trong rdt_result KHÔNG phải là “Positive” VÀ giá trị trong other_cases_in_home là “Yes”\n“Probable”\n\n\nNếu một trong các tiêu chí trên không được đáp ứng\n“Suspected”\n\n\n\nLưu ý rằng R có phân biệt chữ hoa chữ thường, vì vậy “Positive” khác với “positive”…\n\n\n\nGiá trị Missing\nTrong R, giá trị missing được biểu diễn bằng giá trị đặc biệt NA (giá trị “dành riêng cho missing”) (chữ N và A viết hoa - không nằm trong dấu ngoặc kép). Nếu dữ liệu bạn nhập vào R bị missing theo cách khác (ví dụ: 99, “Missing”, or .), bạn có thể sẽ cần phải mã hóa lại các giá trị đó thành NA. Cách thực hiện việc này được đề cập trong chương Nhập xuất dữ liệu.\nĐể kiểm tra xem một giá trị có phải là NA hay không, sử dụng hàm đặc biệt is.na(), kết quả sẽ trả về TRUE hoặc FALSE.\n\nrdt_result &lt;- c(\"Positive\", \"Suspected\", \"Positive\", NA)   # two positive cases, one suspected, and one unknown\nis.na(rdt_result)  # Tests whether the value of rdt_result is NA\n\n[1] FALSE FALSE FALSE  TRUE\n\n\nĐọc thêm về missing, vô hạn, NULL, và các giá trị không thể trong chương Dữ liệu Missing. Tìm hiểu thêm cách chuyển đổi các giá trị bị missing khi nhập dữ liệu trong chương Nhập xuất dữ liệu.\n\n\n\nToán học và thống kê\nTất cả các toán tử và hàm trong chương này đều có sẵn bằng cách sử dụng base R.\n\nToán tử toán học\nChúng thường được sử dụng để thực hiện phép cộng, phép chia, để tạo cột mới, v.v. Dưới đây là các toán tử toán học phổ biến trong R. Việc bạn có đặt dấu cách xung quanh các toán tử hay không là không quan trọng.\n\n\n\nMục đích\nVí dụ trong R\n\n\n\n\nphép cộng\n2 + 3\n\n\nphép trừ\n2 - 3\n\n\nphép nhân\n2 * 3\n\n\nphép chia\n30 / 5\n\n\nsố mũ\n2^3\n\n\nthứ tự hoạt động\n( )\n\n\n\n\n\nCác hàm toán học\n\n\n\nMục tiêu\nHàm\n\n\n\n\nlàm tròn\nround(x, digits = n)\n\n\nlàm tròn\njanitor::round_half_up(x, digits = n)\n\n\nlàm tròn lên\nceiling(x)\n\n\nlàm tròn xuống\nfloor(x)\n\n\ngiá trị tuyệt đối\nabs(x)\n\n\ncăn bậc hai\nsqrt(x)\n\n\nsố mũ\nexponent(x)\n\n\nlogarit tự nhiên\nlog(x)\n\n\nlogarit cơ số 10\nlog10(x)\n\n\nlogarit cơ số 2\nlog2(x)\n\n\n\nlưu ý: sử dụng hàm round() và digits = để xác định số chữ số thập phân được hiển thị. Sử dụng hàm signif() để làm tròn đến số chữ số nhất định.\n\n\nKý hiệu khoa học\nKhả năng ký hiệu khoa học được sử dụng phụ thuộc vào giá trị của scipen.\nTừ tài liệu hướng dẫn của ?options: scipen được áp dụng khi quyết định in các giá trị số theo ký hiệu cố định hoặc hàm mũ. Giá trị dương thuộc về ký hiệu cố định còn giá trị âm thuộc về ký hiệu khoa học: ký hiệu cố định sẽ luôn được ưu tiên trừ khi có nhiều chữ số ‘scipen’.\nNếu như có rất nhiều số bé cần hiển thị (vd: số 0), mặc định tính năng này sẽ “được bật”. Để “tắt” tính năng ký hiệu khoa học trong phiên làm việc của bạn, hãy thiết lập nó với một số rất lớn, ví dụ:\n\n# turn off scientific notation\noptions(scipen=999)\n\n\n\nLàm tròn\nNGUY HIỂM: Hàm round() sử dụng “cách làm tròn của ngân hàng” nghĩa là chỉ làm tròn với số .5 nếu số được làm tròn lên là số chẵn. Sử dụng hàm round_half_up() từ package janitor để thống nhất cách làm tròn với giá trị .5. Xem thêm giải thích sau đây\n\n# use the appropriate rounding function for your work\nround(c(2.5, 3.5))\n\n[1] 2 4\n\njanitor::round_half_up(c(2.5, 3.5))\n\n[1] 3 4\n\n\n\n\nCác hàm thống kê\nCẨN TRỌNG: Các hàm sau đây sẽ mặc định bao gồm cả giá trị missing khi tính toán. Giá trị missing sẽ trả về kết quả đầu ra chứa NA, trừ khi đối số na.rm = TRUE được xác định khi viết hàm. Nó cũng có thể viết ngắn gọn thành na.rm = T.\n\n\n\nMục đích\nHàm\n\n\n\n\ntrung bình\nmean(x, na.rm=T)\n\n\ntrung vị\nmedian(x, na.rm=T)\n\n\nđộ lệch chuẩn\nsd(x, na.rm=T)\n\n\nphân vị*\nquantile(x, probs)\n\n\ntổng\nsum(x, na.rm=T)\n\n\ngiá trị nhỏ nhất\nmin(x, na.rm=T)\n\n\ngiá trị lớn nhất\nmax(x, na.rm=T)\n\n\nkhoảng giá trị số\nrange(x, na.rm=T)\n\n\ntóm tắt**\nsummary(x)\n\n\n\nNotes:\n\n*quantile(): x là vectơ số cần khảo sát, và probs = là một vectơ số với các xác suất nằm giữa 0 và 1.0, ví dụ c(0.5, 0.8, 0.85)\n**summary(): trả về tóm tắt một vectơ số bao gồm giá trị trung bình, trung vị, và các khoảng phân vị thường gặp\n\nNGUY HIỂM: Nếu cung cấp một vectơ số cho một trong các hàm trên, hãy đảm bảo các số được đặt trong hàm c() .\n\n# If supplying raw numbers to a function, wrap them in c()\nmean(1, 6, 12, 10, 5, 0)    # !!! INCORRECT !!!  \n\n[1] 1\n\nmean(c(1, 6, 12, 10, 5, 0)) # CORRECT\n\n[1] 5.666667\n\n\n\n\nMột số hàm hữu ích khác\n\n\n\n\n\n\n\n\nMục đích\nHàm\nVí dụ\n\n\n\n\nTạo chuỗi số liên tục\nseq(from, to, by)\nseq(1, 10, 2)\n\n\nlặp x, n lần\nrep(x, ntimes)\nrep(1:3, 2) or rep(c(\"a\", \"b\", \"c\"), 3)\n\n\nchia nhỏ một vectơ số\ncut(x, n)\ncut(linelist$age, 5)\n\n\nlấy một mẫu ngẫu nhiên\nsample(x, size)\nsample(linelist$id, size = 5, replace = TRUE)\n\n\n\n\n\n\n\n%in%\nMột toán tử rất hữu ích để nhanh chóng tìm kiếm xem một giá trị có nằm trong một vectơ hoặc một dataframe hay không.\n\nmy_vector &lt;- c(\"a\", \"b\", \"c\", \"d\")\n\n\n\"a\" %in% my_vector\n\n[1] TRUE\n\n\"h\" %in% my_vector\n\n[1] FALSE\n\n\nĐể truy vấn một giá trị không %in% một vectơ, hãy đặt dấu chấm than (!) phía trước biểu thức logic:\n\n# to negate, put an exclamation in front\n!\"a\" %in% my_vector\n\n[1] FALSE\n\n!\"h\" %in% my_vector\n\n[1] TRUE\n\n\n%in% sẽ rất hữu dụng khi dùng hàm case_when() của package dplyr. Bạn có thể định nghĩa một vectơ trước đó, sau đó tham chiếu đến nó. ví dụ:\n\naffirmative &lt;- c(\"1\", \"Yes\", \"YES\", \"yes\", \"y\", \"Y\", \"oui\", \"Oui\", \"Si\")\n\nlinelist &lt;- linelist %&gt;% \n  mutate(child_hospitaled = case_when(\n    hospitalized %in% affirmative & age &lt; 18 ~ \"Hospitalized Child\",\n    TRUE                                      ~ \"Not\"))\n\nLưu ý: Nếu bạn muốn phát hiện một phần của chuỗi, có lẽ việc sử dụng hàm str_detect() từ package stringr, sẽ không chấp nhận một vectơ ký tự kiểu như c(\"1\", \"Yes\", \"yes\", \"y\"). Thay vào đó, nó cần được cung cấp dưới dạng một biểu thức chính quy - một chuối cô đọng với thanh dọc cho phép so sánh OR, chẳng hạn như “1|Yes|yes|y”. Ví dụ, str_detect(hospitalized, \"1|Yes|yes|y\"). Xem thêm chương Ký tự và chuỗi để biết thêm chi tiết.\nBạn có thể chuyển đổi một vectơ ký tự thành một biểu thức chính quy được đặt tên bằng lệnh này:\n\naffirmative &lt;- c(\"1\", \"Yes\", \"YES\", \"yes\", \"y\", \"Y\", \"oui\", \"Oui\", \"Si\")\naffirmative\n\n[1] \"1\"   \"Yes\" \"YES\" \"yes\" \"y\"   \"Y\"   \"oui\" \"Oui\" \"Si\" \n\n# condense to \naffirmative_str_search &lt;- paste0(affirmative, collapse = \"|\")  # option with base R\naffirmative_str_search &lt;- str_c(affirmative, collapse = \"|\")   # option with stringr package\n\naffirmative_str_search\n\n[1] \"1|Yes|YES|yes|y|Y|oui|Oui|Si\"",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R Cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.vn.html#lỗi-và-cảnh-báo",
    "href": "new_pages/basics.vn.html#lỗi-và-cảnh-báo",
    "title": "3  R Cơ bản",
    "section": "12.1 Lỗi và cảnh báo",
    "text": "12.1 Lỗi và cảnh báo\nPhần này giải thích:\n\nSự khác biệt giữa lỗi và cảnh báo\n\nMẹo cú pháp chung để viết code R\n\nTrợ giúp viết code\n\nCác lỗi thường gặp và cảnh báo cũng như mẹo khắc phục sự cố có thể được tìm thấy trong chương Các lỗi thường gặp.\n\n\nLỗi và Cảnh báo\nKhi một lệnh được thực thi, cửa sổ R Console có thể hiển thị cho bạn cảnh báo hoặc thông báo lỗi bằng văn bản màu đỏ.\n\nMột cảnh báo nghĩa là R đã hoàn thành lệnh của bạn, nhưng phải thực hiện các bước bổ sung hoặc tạo ra kết quả bất thường mà bạn cần lưu ý.\nMột lỗi nghĩa là R không thể hoàn thành lệnh của bạn.\n\nTìm manh mối:\n\nThông báo lỗi/cảnh báo thường sẽ bao gồm số dòng xảy ra sự cố.\nNếu một đối tượng “không xác định được (is unknown)” hoặc “không tìm thấy (not found)”, có lẽ bạn đã viết sai chính tả, quên gọi một package bằng hàm library(), hoặc quên chạy lại tập lệnh của bạn sau khi thực hiện các thay đổi.\n\nNếu vẫn thất bại, hãy sao chép thông báo lỗi vào Google cùng với một số từ khóa chính - rất có thể ai đó cũng đã gặp lỗi này rồi!\n\n\n\nMẹo cú pháp chung\nMột số điều cần nhớ khi viết lệnh trong R, để tránh lỗi và cảnh báo:\n\nLuôn đóng dấu ngoặc đơn - mẹo: đếm số lần mở dấu ngoặc đơn “(” và đóng dấu ngoặc đơn “)” cho mỗi đoạn mã\nTránh để khoảng trắng trong tên cột và đối tượng. Thay vào đó, hãy sử dụng dấu gạch dưới (_) hoặc dấu chấm (.)\nTheo dõi và nhớ tách các đối số của hàm bằng dấu phẩy\nR phân biệt chữ hoa và chữ thường, nghĩa là Variable_A khác với variable_A\n\n\n\n\nTrợ giúp viết code\nBất kỳ tập lệnh nào (RMarkdown hoặc những cái khác) sẽ cung cấp manh mối khi bạn mắc lỗi. Ví dụ: nếu bạn quên viết dấu phẩy ở vị trí cần thiết hoặc quên đóng dấu ngoặc đơn, RStudio sẽ treo cờ trên dòng đó, ở phía bên trái của script, để cảnh báo bạn.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R Cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.vn.html",
    "href": "new_pages/transition_to_R.vn.html",
    "title": "4  Chuyển đổi sang R",
    "section": "",
    "text": "4.1 Từ Excel\nChuyển đổi từ Excel trực tiếp sang R hoàn toàn là mục tiêu có thể đạt được. Nó dường như có vẻ khó khăn, nhưng bạn có thể làm được!\nSự thật là một người có kỹ năng Excel tốt có thể thực hiện các thao tác nâng cao chỉ trong Excel - ngay cả khi sử dụng các công cụ tạo script như VBA. Excel được sử dụng trên toàn thế giới và là một công cụ cần thiết cho một nhà dịch tễ học. Tuy nhiên, kết hợp nó với R có thể cải thiện và mở rộng đáng kể quy trình công việc của bạn.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chuyển đổi sang R</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.vn.html#từ-excel",
    "href": "new_pages/transition_to_R.vn.html#từ-excel",
    "title": "4  Chuyển đổi sang R",
    "section": "",
    "text": "Lợi ích\nBạn sẽ thấy rằng việc sử dụng R mang lại những lợi ích to lớn trong việc tiết kiệm thời gian, giúp phân tích nhất quán và chính xác hơn, có khả năng tái lập, khả năng chia sẻ và sửa lỗi nhanh hơn. Giống như bất kỳ phần mềm mới nào, bạn phải đầu tư một “đường cong” thời gian học tập để trở nên quen thuộc. Bạn sẽ được mở ra những kĩ năng mới trên một phạm vi rộng đáng kể với R.\nExcel là một phần mềm phổ biến mà người dùng mới bắt đầu có thể dễ dàng sử dụng để tạo ra các phân tích và sơ đồ hóa đơn giản với các thao tác “trỏ và nhấp”. Trong khi đó, có thể mất vài tuần để trở nên quen thuộc với các chức năng và giao diện của R. Tuy nhiên, R đã phát triển trong những năm gần đây để trở nên thân thiện hơn với người mới bắt đầu.\nNhiều quy trình làm việc của Excel phụ thuộc vào trí nhớ và sự lặp lại - do đó, có nhiều khả năng xảy ra lỗi. Hơn nữa, nhìn chung, việc làm sạch dữ liệu, phương pháp phân tích và các phương trình được sử dụng đều bị ẩn đi trong trang tính. Có thể cần đến một khoảng thời gian đáng kể để những người mới bắt đầu hiểu trang tính Excel đang làm gì và cách khắc phục sự cố. Với R, tất cả các bước được viết rõ ràng trong script và có thể dễ dàng xem, chỉnh sửa, sửa lỗi và áp dụng cho các bộ dữ liệu khác.\nĐể bắt đầu chuyển đổi từ Excel sang R, bạn phải điều chỉnh tư duy của mình theo một số hướng quan trọng:\n\n\nTidy data\nSử dụng “tidy” data để máy có thể đọc được thay vì dữ liệu lộn xộn “con người có thể đọc được”. Dưới đây là ba yêu cầu chính đối với “tidy” data”, đã được giải thích trong hướng dẫn này về “tidy” data trong R:\n\nMỗi biến số nằm trên một cột\nMỗi quan sát phải nằm trên một hàng\nMỗi giá trị phải có ô riêng\n\nĐối với người dùng Excel - hãy nghĩ đến vai trò của “bảng” Excel trong việc chuẩn hóa dữ liệu và làm cho định dạng trở nên dễ đoán hơn.\nMột ví dụ về “tidy” data là trường hợp bộ dữ liệu linelist được sử dụng trong cuốn sổ tay này - mỗi biến được chứa trong một cột, mỗi quan sát (mỗi trường hợp) có hàng riêng và mọi giá trị chỉ nằm trong một ô. Dưới đây, bạn có thể xem 50 hàng đầu tiên của bộ dữ liệu linelist:\n\n\n\n\n\n\nNguyên nhân chính khiến người dùng gặp phải tình trạng non-tidy data là do nhiều bảng tính Excel được thiết kế để ưu tiên con người dễ đọc chứ không phải máy móc/phần mềm dễ đọc.\nĐể giúp bạn thấy sự khác biệt, dưới đây là một số ví dụ mô phỏng về non-tidy data mà ưu tiên khả năng đọc của con người hơn khả năng đọc của máy:\n\n\n\n\n\n\n\n\n\nVấn đề: Trong bảng tính ở trên, một số ô đã được ghép với nhau - khiến chúng trở nên khó đọc bởi R. Hàng nào nên được coi là “tiêu đề” không rõ ràng. Từ điển dựa trên màu sắc nằm ở phía bên phải và các giá trị ô được biểu thị bằng màu sắc - điều này cũng không dễ dàng được giải thích bởi R (cũng như những người bị mù màu!). Hơn nữa, các phần thông tin khác nhau được kết hợp thành một ô (nhiều tổ chức đối tác hoạt động trong cùng một khu hoặc trạng thái “TBC” trong cùng ô với “Partner D”).\n\n\n\n\n\n\n\n\n\nVấn đề: Trong bảng tính ở trên, có rất nhiều hàng và cột trống trong bộ dữ liệu - điều này sẽ gây phiền toái khi làm sạch trong R. Hơn nữa, tọa độ GPS được trải rộng trên hai hàng cho một trung tâm điều trị nhất định. Một lưu ý nhỏ - tọa độ GPS có hai định dạng khác nhau!\nCác bộ dữ liệu “tidy” có thể không đọc được bằng mắt người, nhưng chúng giúp việc làm sạch và phân tích dữ liệu dễ dàng hơn rất nhiều! Tidy data có thể được lưu trữ ở nhiều định dạng khác nhau, chẳng hạn như dạng “dọc” hoặc “ngang”“(xem chương về Xoay trục dữ liệu), tuy nhiên các nguyên tắc trên vẫn được tuân thủ.\n\n\nHàm\nTừ “hàm (function)” trong R có thể mới, nhưng khái niệm này cũng tồn tại trong Excel dưới dạng công thức (formulas). Công thức trong Excel cũng yêu cầu cú pháp chính xác (ví dụ: vị trí của dấu chấm phẩy và dấu ngoặc đơn). Tất cả những gì bạn cần làm là tìm hiểu một vài hàm mới và cách chúng hoạt động cùng nhau trong R.\n\n\nScript\nThay vì nhấp vào các biểu tượng và kéo các ô, bạn sẽ viết mọi bước và quy trình thành một “script”. Người dùng Excel có thể quen thuộc với “VBA macros”, thứ mà cũng sử dụng cách tiếp cận script.\nR script bao gồm các hướng dẫn từng bước. Điều này cho phép bất kỳ đồng nghiệp nào cũng có thể đọc script và dễ dàng xem các bước bạn đã thực hiện. Điều này cũng giúp loại bỏ lỗi hoặc các tính toán không chính xác. Xem phần R cơ bản về script để có thêm các ví dụ.\nDưới đây là một ví dụ của một R script:\n\n\n\n\n\n\n\n\n\n\n\nTài liệu liên quan đến chuyển đổi từ Excel-sang-R\nDưới đây là một vài đường link hướng dẫn giúp bạn chuyển đổi sang R từ Excel:\n\nR vs. Excel\n\nCác khóa RStudio trong R cho người dùng Excel\n\n\n\nTương tác giữa R và Excel\nR có khả năng mạnh trong việc nhập các Excel workbook, làm việc với dữ liệu, xuất/lưu tệp Excel và làm việc với các sắc thái của các trang tính Excel.\nĐúng là một số định dạng Excel có tính thẩm mỹ hơn có thể bị mất trong quá trình chuyển đổi (ví dụ: chữ nghiêng, chữ nằm ngang, v.v.). Nếu quy trình công việc của bạn yêu cầu chuyển tài liệu qua lại giữa R và Excel trong khi vẫn giữ nguyên định dạng Excel ban đầu, hãy thử các package như openxlsx.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chuyển đổi sang R</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.vn.html#từ-stata",
    "href": "new_pages/transition_to_R.vn.html#từ-stata",
    "title": "4  Chuyển đổi sang R",
    "section": "4.2 Từ Stata",
    "text": "4.2 Từ Stata\nChuyển đến R từ Stata\nNhiều nhà dịch tễ học được dạy cách sử dụng Stata ngay từ đầu, và có vẻ khó khăn khi chuyển sang R. Tuy nhiên, nếu bạn là một người dùng quen Stata thì việc chuyển sang R chắc chắn sẽ dễ quản lý hơn bạn nghĩ. Mặc dù có một số khác biệt chính giữa Stata và R về cách tạo và sửa đổi dữ liệu, cũng như cách triển khai các chức năng phân tích – sau khi tìm hiểu những khác biệt chính này, bạn sẽ có thể chuyển đổi các kỹ năng của mình.\nDưới đây là một số cách chuyển đổi chính giữa Stata và R, điều mà có thể hữu ích khi bạn xem lại hướng dẫn này.\nNhững lưu ý chung\n\n\n\n5 STATA\nBạn chỉ có thể xem và thao tác với một bộ dữ liệu tại một thời điểm\n6 R\nBạn có thể xem và thao tác với nhiều bộ dữ liệu cùng một lúc, do đó, bạn sẽ thường xuyên phải xác định bộ dữ liệu của mình trong code\n\n\n\n\n\n\n\n\nCộng đồng trực tuyến có sẵn trên https://www.statalist.org/\nCộng đồng trực tuyến có sẵn trên RStudio, StackOverFlow và R-bloggers\n\n\n\nThao tác trỏ và nhấp chuột như một tùy chọn\nThao tác trỏ và nhấp chuột được giảm tối thiểu\n\n\n\nTrợ giúp cho các lệnh có sẵn trong help [command]\nTrợ giúp có sẵn trong [function]? hoặc tìm kiếm trong cửa sổ Help\n\n\n\nBình luận code sử dụng * hoặc /// hoặc /* VĂN BẢN */\nBình luận code sử dụng #\n\n\n\nHầu hết tất cả các lệnh đều được tích hợp sẵn trong Stata. Các lệnh mới do người dùng viết có thể được cài đặt như file ado sử dụng ssc install [package]\nR được cài đặt sẵn các lệnh cơ bản, nhưng quá trình sử dụng thông thường cần cài đặt các package khác từ CRAN (xem chương R cơ bản)\n\n\n\nPhân tích thường được viết trong do file\nPhân tích được viết trong R script ở cửa sổ chính của RStudio. Các script của R markdown là một giải pháp thay thế.\n\n\n\n\nThư mục làm việc\n\n\n\n7 STATA\nThư mục làm việc bao gồm các đường dẫn tuyệt đối (Ví dụ: “C:/usename/documents/projects/data/”)\n\nR | =============================================================================================================================================================+ Thư mục làm việc có thể là đường dẫn tuyệt đối hoặc tương đối đến thư mục gốc của dự án bằng cách sử dụng package here (xem chương Nhập xuất dữ liệu)\n\n\n\n\n\n\n\n\nXem thư mục làm việc hiện tại với pwd\nSử dụng getwd() hoặc here() (nếu sử dụng package here), với dấu ngoặc đơn trống\n\n\n\nCài đặt thư mục làm việc với cd “folder location”\nSử dụng setwd(“folder location”) hoặc set_here(\"folder location) (nếu sử dụng package here)\n\n\n\n\nNhập và xem dữ liệu\n\n\n\n8 STATA\nCác lệnh cụ thể cho mỗi loại tệp\nR | =================================================================================================================================================================================================================+ Sử dụng import() từ package rio cho hầu hết tất cả các loại tệp. Các chức năng cụ thể tồn tại dưới dạng lựa chọn thay thế (xem chương Nhập xuất dữ liệu)\n\n\n\n\n\n\n\n\nĐọc file csv được thực hiện bằng cách sử dụng import delimited “filename.csv”\nSử dụng import(\"filename.csv\")\n\n\n\nĐọc file xslx được thực hiện bằng cách sử dụng import excel “filename.xlsx”\nSử dụng import(\"filename.xlsx\")\n\n\n\nDuyệt dữ liệu của bạn trong một cửa sổ mới bằng lệnh browse\nXem bộ dữ liệu trong cửa sổ nguồn RStudio sử dụng View(dataset). Bạn cần xác định tên bộ dữ liệu của mình cho hàm trong R vì nhiều bộ dữ liệu có thể được mở cùng một lúc. Lưu ý viết hoa “V” trong hàm này\n\n\n\nCó cái nhìn tổng quan hơn về bộ dữ liệu của bạn bằng cách sử dụng summarize, lệnh này cung cấp tên biến và các thông tin cơ bản của bộ dữ liệu\nCó cái nhìn tổng quan hơn về bộ dữ liệu của bạn bằng cách sử dụng summary(dataset)\n\n\n\n\nThao tác dữ liệu cơ bản\n\n\n\n9 STATA\nCác cột của bộ dữ liệu thường được gọi là “các biến (variables)”\n10 R\nThường được gọi là “các cột (columns)” hoặc thỉnh thoảng là “các véctơ (vectors)” hoặc “các biến (variables)”\n\n\n\n\n\n\n\n\nKhông cần xác định bộ dữ liệu\nTrong mỗi lệnh dưới đây, bạn cần xác định bộ dữ liệu - xem ví dụ trong chương Làm sạch số liệu và các hàm quan trọng\n\n\n\nCác biến mới được tạo bằng lệnh generate varname =\nTạo các biến mới bằng cách sử dụng lệnh mutate(varname = ). Xem chương Làm sạch số liệu và các hàm quan trọng để biết tất cả chi tiết về câu lệnh dplyr bên dưới\n\n\n\nCác biến được đổi tên bằng cách sử dụng rename old_name new_name\nCác cột có thể được đổi tên bằng cách sử dụng lệnh rename(new_name = old_name)\n\n\n\nCác biến được lược bỏ sử dụng drop varname\nCó thể lược bỏ các cột bằng cách sử dụng lệnh select() với tên cột trong ngoặc đơn sau dấu trừ\n\n\n\nCác biến factor có thể được gán nhãn bằng cách sử dụng một loạt lệnh như label define\nViệc gán nhãn các giá trị có thể được thực hiện bằng cách chuyển đổi cột thành nhóm Factor và chỉ định thứ bậc. Xem chương Factors. Tên cột thường không được gán nhãn như trong Stata. |\n\n\n\n\nPhân tích mô tả\n\n\n\n11 STATA\nĐếm số lượng bảng của một biến sử dụng tab varname\nR | ======================================================================================================================================================================================================+ Cung cấp bộ dữ liệu và tên cột cho table() ví dụ như table(dataset$colname). Ngoài ra, có thể sử dụng lệnh count(varname) từ package dplyr, đã được giải thích trong chương Nhóm dữ liệu\n\n\n\n\n\n\n\n\nLập bảng chéo của hai biến trong bảng 2x2 được thực hiện bằng tab varname1 varname2\nSử dụng table(dataset$varname1, dataset$varname2 hoặc count(varname1, varname2)\n\n\n\n\nMặc dù danh sách này cung cấp một cái nhìn tổng quan về những điều cơ bản trong việc chuyển các lệnh Stata sang R, nhưng nó vẫn chưa đầy đủ. Bạn có thể quan tâm tới nhiều nguồn tài nguyên tuyệt vời khác dành cho người dùng Stata chuyển sang R:\n\nhttps://dss.princeton.edu/training/RStata.pdf\nhttps://clanfear.github.io/Stata_R_Equivalency/docs/r_stata_commands.html\nhttp://r4stats.com/books/r4stata/",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chuyển đổi sang R</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.vn.html#từ-sas",
    "href": "new_pages/transition_to_R.vn.html#từ-sas",
    "title": "4  Chuyển đổi sang R",
    "section": "11.1 Từ SAS",
    "text": "11.1 Từ SAS\nChuyển từ SAS sang R\nSAS thường được sử dụng tại các cơ quan y tế công cộng và các lĩnh vực nghiên cứu học thuật. Mặc dù chuyển đổi sang một ngôn ngữ mới hiếm khi là một quá trình đơn giản, nhưng hiểu được những điểm khác biệt chính giữa SAS và R có thể giúp bạn bắt đầu chuyển hướng ngôn ngữ mới bằng ngôn ngữ mẹ đẻ của mình. Dưới đây là phác thảo các bước chuyển đổi chính trong quản lý dữ liệu và phân tích mô tả giữa SAS và R.\nNhững lưu ý chung\n\n\n\n12 SAS\nCộng đồng trực tuyến có sẵn trên SAS Customer Support\n13 R\nCộng đồng trực tuyến có sẵn trên RStudio, StackOverFlow và R-bloggers\n\n\n\n\n\n\n\n\nTrợ giúp cho các lệnh có sẵn trong help [command]\nTrợ giúp có sẵn trong [function]? hoặc tìm kiếm trong cửa sổ Help\n\n\n\nBình luận code sử dụng * VĂN BẢN ; hoặc /* VĂN BẢN */\nBình luận code sử dụng #\n\n\n\nHầu hết tất cả các lệnh đều được tích hợp sẵn. Người dùng có thể viết lệnh mới bằng cách sử dụng SAS macro, SAS/IML, SAS Component Language (SCL) và mới đây nhất là, được thực hiện bằng Proc Fcmp và Proc Proto\nR được cài đặt sẵn các lệnh **cơ bản**, nhưng quá trình sử dụng thông thường cần cài đặt các package khác từ CRAN (xem chương R cơ bản)\n\n\n\nPhân tích thường được viết trong chương trình SAS ở cửa sổ Editor.\nPhân tích được viết trong R script trong cửa sổ chính của RStudio. Các script của R markdown là một giải pháp thay thế.\n\n\n\n\nThư mục làm việc\n\n\n\n14 SAS\nThư mục làm việc có thể là đường dẫn tuyệt đối hoặc tương đối đến thư mục gốc của dự án bằng cách sử dụng %let rootdir=/root path; %include “&rootdir/subfoldername/filename”\nR | =============================================================================================================================================================+ Thư mục làm việc có thể là đường dẫn tuyệt đối hoặc tương đối đến thư mục gốc của dự án bằng cách sử dụng package here (xem chương Nhập xuất dữ liệu)\n\n\n\n\n\n\n\n\nXem thư mục làm việc hiện tại với %put %sysfunc(getoption(work));\nSử dụng getwd() hoặc here() (nếu sử dụng package here), với dấu ngoặc đơn trống\n\n\n\nCài đặt thư mục làm việc với libname “folder location”\nSử dụng setwd(“folder location”) hoặc set_here(\"folder location) (nếu sử dụng package here)\n\n\n\n\nNhập và xem dữ liệu\n\n\n\n15 SAS\nSử dụng lệnh Proc Import hoặc sử dụng lệnh Data Step Infile\nR | =============================================================================================================================================================================================================+ Sử dụng import() từ package rio cho hầu hết tất cả các loại tệp. Các chức năng cụ thể tồn tại dưới dạng lựa chọn thay thế (xem chương Nhập xuất dữ liệu)\n\n\n\n\n\n\n\n\nĐọc file csv được thực hiện bằng cách sử dụng Proc Import datafile=”filename.csv” out=work.filename dbms=CSV; run; HOẶC sử dụng Data Step Infile statement\nSử dụng import(\"filename.csv\")\n\n\n\nĐọc các tệp xslx được thực hiện bằng cách sử dụng Proc Import datafile=”filename.xlsx” out=work.filename dbms=xlsx; run; HOẶC sử dụng Data Step Infile statement\nSử dụng import(\"filename.xlsx\")\n\n\n\nDuyệt bộ dữ liệu của bạn trong cửa sổ mới bằng cách mở cửa sổ Explorer và chọn thư viện và tập dữ liệu mong muốn.\nXem bộ dữ liệu trong cửa sổ nguồn RStudio sử dụng View(dataset). Bạn cần xác định tên bộ dữ liệu của mình cho hàm trong R vì nhiều bộ dữ liệu có thể được mở cùng một lúc. Lưu ý viết hóa “V” trong hàm này |\n\n\n\n\nThao tác dữ liệu cơ bản\n\n\n\n16 SAS\nCác cột của bộ dữ liệu thường được gọi là “các biến (variables)”\n17 R\nThường được gọi là “các cột (columns)” hoặc thỉnh thoảng là “các véctơ (vectors)” hoặc “các biến (variables)”\n\n\n\n\n\n\n\n\nKhông cần thao tác đặc biệt để tạo ra một biến. Các biến mới được tạo đơn giản bằng cách nhập tên biến mới, theo sau là dấu bằng, sau đó là biểu thức cho giá trị\nTạo các biến mới bằng cách sử dụng hàm mutate(varname = ). Xem chương Làm sạch số liệu và các hàm quan trọng để biết tất cả chi tiết về câu lệnh dplyr bên dưới\n\n\n\nCác biến được đổi tên bằng cách sử dụng rename *old_name=new_name*\nCác cột có thể được đổi tên bằng cách sử dụng ệnh rename(new_name = old_name)\n\n\n\nCác biến được giữ bằng cách sử dụng **keep**=varname\nCác cột có thể được chọn bằng cách sử dụng lệnh select() với tên cột trong ngoặc đơn\n\n\n\nCác biến được lược bỏ sử dụng **drop**=varname\nCó thể lược bỏ các cột bằng cách sử dụng lệnh select() với tên cột trong ngoặc đơn sau dấu trừ\n\n\n\nCác biến Factor có thể được gán nhãn trong Data Step bằng cách sử dụng lệnh Label\nViệc gán nhãn các giá trị có thể được thực hiện bằng cách chuyển đổi cột thành nhóm Factor và chỉ định thứ bậc. Xem chương Factors. Tên cột thường không được gán nhãn. |\n\n\n\nCác bản ghi được chọn bằng cách sử dụng lệnh Where hoặc If trong Data Step. Nhiều điều kiện lựa chọn được phân tách bằng lệnh “and”.\nCác bản ghi được chọn bằng cách sử dụng lệnh filter() với nhiều điều kiện lựa chọn được phân tách bằng toán tử AND (&) hoặc dấu phẩy\n\n\n\nBộ dữ liệu được hợp nhất bằng cách sử dụng lệnh Merge trong Data Step. Các bộ dữ liệu được hợp nhất cần phải được sắp xếp trước bằng cách sử dụng thao tác Proc Sort.\nPackage dplyr cung cấp một số chức năng để hợp nhất các tập dữ liệu. Xem chi tiết trong chương [Nối dữ liệu].\n\n\n\n\nPhân tích mô tả\n\n\n\n18 SAS\nCó cái nhìn tổng quan hơn về bộ dữ liệu của bạn bằng cách sử dụng thao tác Proc Summary, thao tác mà cung cấp tên biến và các thống kê mô tả\n19 R\nCó cái nhìn tổng quan hơn về bộ dữ liệu của bạn bằng cách sử dụng summary(dataset) hoặc skim(dataset) từ package skimr package\n\n\n\n\n\n\n\n\nĐếm số lượng bảng của một biến sử dụng proc freq data=Dataset; Tables varname; Run;\nXem chương Bảng mô tả. Các tùy chọn trong số tất cả các tùy chọn khác bao gồm table() từ base R và tabyl() từ package janitor. Lưu ý rằng bạn sẽ cần xác định bộ dữ liệu và tên cột vì R chứa nhiều tập dữ liệu. |\n\n\n\nLập bảng chéo của hai biến trong bảng 2x2 được thực hiện bằng proc freq data=Dataset; Tables rowvar*colvar; Run;\nMột lần nữa, bạn có thể sử dụng table(), tabyl() hoặc những cách khác đã được mô tả trong chương Bảng mô tả.\n\n\n\n\nMột số tài nguyên hữu ích:\nR for SAS and SPSS Users (2011)\nSAS and R, Second Edition (2014)",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chuyển đổi sang R</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.vn.html#khả-năng-tương-tác-dữ-liệu",
    "href": "new_pages/transition_to_R.vn.html#khả-năng-tương-tác-dữ-liệu",
    "title": "4  Chuyển đổi sang R",
    "section": "19.1 Khả năng tương tác dữ liệu",
    "text": "19.1 Khả năng tương tác dữ liệu\nXem chương Nhập xuất dữ liệu để biết chi tiết về cách R package rio có thể nhập và xuất các file như file STATA .dta, file SAS .xpt và .sas7bdat, file SPSS .por và .sav và nhiều file khác.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chuyển đổi sang R</span>"
    ]
  },
  {
    "objectID": "new_pages/packages_suggested.vn.html",
    "href": "new_pages/packages_suggested.vn.html",
    "title": "5  Package đề xuất",
    "section": "",
    "text": "5.1 Packages từ CRAN\n##########################################\n# List of useful epidemiology R packages #\n##########################################\n\n# This script uses the p_load() function from pacman R package, \n# which installs if package is absent, and loads for use if already installed\n\n\n# Ensures the package \"pacman\" is installed\nif (!require(\"pacman\")) install.packages(\"pacman\")\n\n\n# Packages available from CRAN\n##############################\npacman::p_load(\n     \n     # learning R\n     ############\n     learnr,   # interactive tutorials in RStudio Tutorial pane\n     swirl,    # interactive tutorials in R console\n        \n     # project and file management\n     #############################\n     here,     # file paths relative to R project root folder\n     rio,      # import/export of many types of data\n     openxlsx, # import/export of multi-sheet Excel workbooks \n     \n     # package install and management\n     ################################\n     pacman,   # package install/load\n     renv,     # managing versions of packages when working in collaborative groups\n     remotes,  # install from github\n     \n     # General data management\n     #########################\n     tidyverse,    # includes many packages for tidy data wrangling and presentation\n          #dplyr,      # data management\n          #tidyr,      # data management\n          #ggplot2,    # data visualization\n          #stringr,    # work with strings and characters\n          #forcats,    # work with factors \n          #lubridate,  # work with dates\n          #purrr       # iteration and working with lists\n     linelist,     # cleaning linelists\n     naniar,       # assessing missing data\n     \n     # statistics  \n     ############\n     janitor,      # tables and data cleaning\n     gtsummary,    # making descriptive and statistical tables\n     rstatix,      # quickly run statistical tests and summaries\n     broom,        # tidy up results from regressions\n     lmtest,       # likelihood-ratio tests\n     easystats,\n          # parameters, # alternative to tidy up results from regressions\n          # see,        # alternative to visualise forest plots \n     \n     # epidemic modeling\n     ###################\n     epicontacts,  # Analysing transmission networks\n     EpiNow2,      # Rt estimation\n     EpiEstim,     # Rt estimation\n     projections,  # Incidence projections\n     incidence2,   # Make epicurves and handle incidence data\n     i2extras,     # Extra functions for the incidence2 package\n     epitrix,      # Useful epi functions\n     distcrete,    # Discrete delay distributions\n     \n     \n     # plots - general\n     #################\n     #ggplot2,         # included in tidyverse\n     cowplot,          # combining plots  \n     # patchwork,      # combining plots (alternative)     \n     RColorBrewer,     # color scales\n     ggnewscale,       # to add additional layers of color schemes\n\n     \n     # plots - specific types\n     ########################\n     DiagrammeR,       # diagrams using DOT language\n     incidence2,       # epidemic curves\n     gghighlight,      # highlight a subset\n     ggrepel,          # smart labels\n     plotly,           # interactive graphics\n     gganimate,        # animated graphics \n\n     \n     # gis\n     ######\n     sf,               # to manage spatial data using a Simple Feature format\n     tmap,             # to produce simple maps, works for both interactive and static maps\n     OpenStreetMap,    # to add OSM basemap in ggplot map\n     spdep,            # spatial statistics \n     \n     # routine reports\n     #################\n     rmarkdown,        # produce PDFs, Word Documents, Powerpoints, and HTML files\n     reportfactory,    # auto-organization of R Markdown outputs\n     officer,          # powerpoints\n     \n     # dashboards\n     ############\n     flexdashboard,    # convert an R Markdown script into a dashboard\n     shiny,            # interactive web apps\n     \n     # tables for presentation\n     #########################\n     knitr,            # R Markdown report generation and html tables\n     flextable,        # HTML tables\n     #DT,              # HTML tables (alternative)\n     #gt,              # HTML tables (alternative)\n     #huxtable,        # HTML tables (alternative) \n     \n     # phylogenetics\n     ###############\n     ggtree,           # visualization and annotation of trees\n     ape,              # analysis of phylogenetics and evolution\n     treeio            # to visualize phylogenetic files\n \n)",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Package đề xuất</span>"
    ]
  },
  {
    "objectID": "new_pages/packages_suggested.vn.html#packages-từ-github",
    "href": "new_pages/packages_suggested.vn.html#packages-từ-github",
    "title": "5  Package đề xuất",
    "section": "5.2 Packages từ Github",
    "text": "5.2 Packages từ Github\nDưới đây là các lệnh giúp cài đặt trực tiếp packages từ kho lưu trữ trên Github.\n\nPhiên bản phát triển của epicontacts có khả năng tạo cây lây nhiễm với trục x tạm thời\n\nPackage epirhandbook chứa tất cả các dữ liệu minh họa cho sổ tay này và có thể được sử dụng để tải xuống phiên bản ngoại tuyến của sổ tay.\n\n\n# Packages to download from Github (not available on CRAN)\n##########################################################\n\n# Development version of epicontacts (for transmission chains with a time x-axis)\npacman::p_install_gh(\"reconhub/epicontacts@timeline\")\n\n# The package for this handbook, which includes all the example data  \npacman::p_install_gh(\"appliedepi/epirhandbook\")",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Package đề xuất</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.vn.html",
    "href": "new_pages/r_projects.vn.html",
    "title": "6  Dự án R",
    "section": "",
    "text": "6.1 Gợi ý sử dụng\nMột cách phổ biến, hiệu quả và ít rắc rối để sử dụng R là sự kết hợp của 3 thành tố này. Mỗi dự án công việc cụ thể sẽ được lưu trữ trong một dự án R. Từng thành tố được mô tả như dưới đây.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dự án R</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.vn.html#gợi-ý-sử-dụng",
    "href": "new_pages/r_projects.vn.html#gợi-ý-sử-dụng",
    "title": "6  Dự án R",
    "section": "",
    "text": "Một Dự án R\n\nMột môi trường làm việc khép kín với các thư mục bao gồm dữ liệu, tập lệnh, các kết quả đầu ra, v.v.\n\n\nPackage here dành cho các đường dẫn tương đối\n\nĐường dẫn tệp được ghi một cách tương đối dẫn đến thư mục gốc của dự án R - xem chương Nhập xuất dữ liệu để biết thêm chi tiết\n\n\nPackage rio để nhập/xuất\n\nimport() và export() giúp giải quyết tất cả các tệp với phần mở rộng khác nhau (ví dụ: .csv, .xlsx, .png)",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dự án R</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.vn.html#tạo-một-dự-án-r",
    "href": "new_pages/r_projects.vn.html#tạo-một-dự-án-r",
    "title": "6  Dự án R",
    "section": "6.2 Tạo một dự án R",
    "text": "6.2 Tạo một dự án R\nĐể tạo một dự án R, hãy chọn “New Project” từ menu File.\n\nNếu bạn muốn tạo một thư mục mới cho dự án, hãy chọn “New directory” và cho biết nơi bạn muốn nó được tạo.\n\nNếu bạn muốn tạo dự án trong một thư mục có sẵn, hãy chọn “Existing directory” và trỏ tới đường dẫn thư mục đó.\n\nNếu bạn muốn tạo một bản sao từ kho lưu trữ Github, hãy chọn tùy chọn thứ ba “Version Control” và sau đó chọn “Git”. Xem chương Version control với Git và Github để biết thêm chi tiết.\n\n\n\n\n\n\n\n\n\n\nDự án R bạn tạo ra sẽ có dạng một thư mục chứa tệp .Rproj. Tệp này có thể đóng vai trò là một lối tắt mà bạn sẽ mở dự án của mình. Bạn cũng có thể mở một dự án bằng cách chọn “Open Project” từ menu File. Ngoài ra, ở phía trên bên phải trên của RStudio, bạn sẽ thấy biểu tượng dự án R và menu thả xuống gồm các dự án R có sẵn.\nĐể thoát khỏi một dự án R, hãy mở một dự án mới hoặc đóng dự án (File - Close Project).\n\nDi chuyển giữa các dự án\nĐể di chuyển giữa các dự án, hãy bấm vào biểu tượng dự án R và menu thả xuống ở phía trên cùng bên phải của RStudio. Bạn sẽ thấy các tùy chọn Close Project, Open Project và danh sách các dự án gần đây.\n\n\n\n\n\n\n\n\n\n\n\nThiết lập\nThông thường, mỗi khi bạn khởi động RStudio nên là một “clean slate - khởi đầu mới” - nghĩa là với không gian làm việc hiện tại không được giữ nguyên so với phiên làm việc trước đó. Điều này có nghĩa là các đối tượng và kết quả của bạn sẽ không tồn tại giữa các phiên làm việc (bạn phải tạo lại chúng bằng cách chạy lại scripts của mình). Điều này là tốt, vì nó sẽ buộc bạn phải viết các đoạn code tốt hơn và tránh được lỗi về lâu dài.\nĐể thiết lập RStudio có một “khởi đầu mới” mỗi khi khởi động:\n\nChọn “Project Options” từ menu Tools.\n\nTrong tab “General”, thiết lập RStudio to không khôi phục .RData vào môi trường làm việc của bạn mỗi khi khởi động, và cũng không lưu môi trường làm việc vào tệp .RData khi kết thúc.\n\n\n\nTổ chức\nThông thường sẽ có các thư mục con trong dự án của bạn. Hãy cân nhắc đặt tên các thư mục như “data”, “scripts”, “figures”, “presentations”. Bạn có thể thêm các thư mục theo cách thông thường mà bạn sẽ thêm một thư mục mới cho máy tính của mình. Ngoài ra, hãy xem chương Tương tác với thư mục làm việc để tìm hiểu cách tạo thư mục mới bằng lệnh R.\n\n\nKiểm soát phiên bản\nHãy cân nhắc sử dụng một hệ thống kiểm soát phiên bản. Nó có thể là một cái gì đó đơn giản như có ngày tháng trên tên của các scripts (ví dụ: “transmission_analysis_2020-10-03.R”) và một thư mục “lưu trữ”. Bạn cũng có thể thêm các đoạn văn bản tiêu đề nhận xét ở đầu mỗi scripts bao gồm các thông tin như mô tả, thẻ, tác giả và nhật ký thay đổi.\nMột phương pháp phức tạp hơn đó là việc sử dụng Github hoặc một nền tảng tương tự để kiểm soát phiên bản. Xem chương Version control với Git và Github.\nMột mẹo là bạn có thể tìm kiếm trong toàn bộ dự án hoặc thư mục bằng cách sử dụng công cụ “Find in Files” (Edit menu)). Công cụ này có thể tìm kiếm và thậm chí thay thế các chuỗi trên nhiều tệp.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dự án R</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.vn.html#các-ví-dụ",
    "href": "new_pages/r_projects.vn.html#các-ví-dụ",
    "title": "6  Dự án R",
    "section": "6.3 Các ví dụ",
    "text": "6.3 Các ví dụ\nDưới đây là một vài ví dụ về cách nhập/xuất/lưu trữ sử dụng lệnh here() from within an R projct. bên trong một dự án R. Đọc thêm về package here trong chương Nhập xuất dữ liệu.\nNhập linelist_raw.xlsx từ thư mục “data” trong dự án R của bạn\n\nlinelist &lt;- import(here(\"data\", \"linelist_raw.xlsx\"))\n\nXuất đối tượng linelist thành tệp “my_linelist.rds” vào thư mục “clean” nằm trong thư mục “data” trong dự án R của bạn.\n\nexport(linelist, here(\"data\",\"clean\", \"my_linelist.rds\"))\n\nLưu biểu đồ được in gần đây nhất thành tệp “epicurve_2021-02-15.png” nằm trong thư mục “epicurves” của thư mục “outputs” trong dự án R của bạn.\n\nggsave(here(\"outputs\", \"epicurves\", \"epicurve_2021-02-15.png\"))",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dự án R</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.vn.html#nguồn",
    "href": "new_pages/r_projects.vn.html#nguồn",
    "title": "6  Dự án R",
    "section": "6.4 Nguồn",
    "text": "6.4 Nguồn\nTrang web của RStudio về việc sử dụng các dự án R",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Dự án R</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html",
    "href": "new_pages/importing.vn.html",
    "title": "7  Nhập xuất dữ liệu",
    "section": "",
    "text": "7.1 Tổng quan\nKhi bạn nhập một “dataset (bộ dữ liệu)” vào R, bạn thường cần tạo ra một đối tượng data frame mới trong môi trường R và định nghĩa nó là tệp được nhập (ví dụ: Excel, CSV, TSV, RDS), từ trong các thư mục của bạn tại một đường dẫn/địa chỉ tệp nhất định.\nBạn có thể nhập/xuất nhiều loại tệp, bao gồm cả những tệp được tạo bởi các chương trình thống kê khác (SAS, STATA, SPSS). Bạn cũng có thể kết nối với các cơ sở dữ liệu liên quan.\nR thậm chí còn có các định dạng dữ liệu riêng:",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#tổng-quan",
    "href": "new_pages/importing.vn.html#tổng-quan",
    "title": "7  Nhập xuất dữ liệu",
    "section": "",
    "text": "Một tệp RDS (.rds) lưu trữ một đối tượng R đơn lẻ, chẳng hạn như một data frame. Chúng hữu ích trong việc lưu trữ dữ liệu đã được làm sạch, vì chúng giữ lại kiểu dữ liệu cho các cột R. Đọc thêm trong mục này.\n\nMột tệp RData (.Rdata) có thể được sử dụng để lưu trữ nhiều đối tượng hoặc thậm chí là một không gian làm việc trong R hoàn chỉnh. Đọc thêm trong mục này.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#package-rio",
    "href": "new_pages/importing.vn.html#package-rio",
    "title": "7  Nhập xuất dữ liệu",
    "section": "7.2 Package rio",
    "text": "7.2 Package rio\nPackage R chúng tôi gợi ý là: rio. Tên “rio” là chữ viết tắt của “R I/O” (dữ liệu đầu vào (input)/kết quả đầu ra (output)).\nHàm import() và export() có thể xử lý nhiều loại tệp khác nhau (ví dụ: .xlsx, .csv, .rds, .tsv). Khi bạn cung cấp đường dẫn tệp đến một trong các hàm này (bao gồm cả đuôi file mở rộng như “.csv”), rio sẽ đọc phần mở rộng và sử dụng đúng công cụ để nhập hoặc xuất tệp.\nGiải pháp thay thế cho việc sử dụng rio là sử dụng các hàm từ nhiều package khác, mỗi package cụ thể cho một loại tệp. Ví dụ như, read.csv() (base R), read.xlsx() (package openxlsx) và write_csv() (package readr), v.v… Những lựa chọn thay thế này có thể khó nhớ, trong khi sử dụng import() và export() từ rio rất dễ dàng.\nCác hàm import() và export() của rio sử dụng package và lệnh phù hợp cho một tệp nhất định, dựa trên phần mở rộng của tệp đó. Xem phần cuối của chương này để xem bảng đầy đủ về các package/hàm rio sử dụng trong nền. Hàm này cũng có thể được sử dụng để nhập các tệp STATA, SAS và SPSS trong hàng tá các loại tệp khác.\nNhập/xuất shapefiles đòi hỏi sử dụng các package khác, được mô tả cụ thể trong chương GIS cơ bản.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#here",
    "href": "new_pages/importing.vn.html#here",
    "title": "7  Nhập xuất dữ liệu",
    "section": "7.3 Package here",
    "text": "7.3 Package here\nPackage here và hàm here() của nó giúp R dễ dàng biết nơi tìm và lưu tệp của bạn - về bản chất, nó xây dựng đường dẫn tệp.\nĐược sử dụng cùng với dự án R, here cho phép bạn mô tả vị trí các tệp trong dự án R của bạn trong thư mục gốc (root directory) của dự án R (thư mục cấp cao nhất). Điều này hữu ích khi dự án R có thể được chia sẻ hoặc truy cập bởi nhiều người dùng/máy tính. Package này ngăn ngừa sự phức tạp do các đường dẫn tệp là duy nhất trên các máy tính khác nhau (ví dụ: \"C:/Users/Laura/Documents...\") bằng cách “khởi động (starting)” đường dẫn tệp ở thư mục chung cho tất cả người dùng (dự án R gốc).\nĐây là cách here() làm việc trong một dự án R:\n\nKhi package here được tải lần đầu tiên trong dự án R, nó đặt một tệp nhỏ có tên là “.here” trong thư mục gốc dự án R của bạn như là một “điểm chuẩn” hoặc “mỏ neo”\n\nTrong script của bạn, để tham chiếu một tệp trong các thư mục con của dự án R, bạn sử dụng hàm here() để tạo đường dẫn tệp liên quan đến thư mục gốc (anchor)\nĐể tạo đường dẫn tệp, viết tên các thư mục bên ngoài thư mục gốc, trong dấu ngoặc kép, được phân tách bằng dấu phẩy, cuối cùng kết thúc bằng tên và phần mở rộng của tệp như được trình bày dưới đây\n\nCác đường dẫn tệp here() có thể được sử dụng cả để nhập và xuất dữ liệu\n\nVí dụ, dưới đây, một đường dẫn tệp được tạo bởi hàm here() đang được cung cấp cho hàm import()\n\nlinelist &lt;- import(here(\"data\", \"linelists\", \"ebola_linelist.xlsx\"))\n\nLệnh here(\"data\", \"linelists\", \"ebola_linelist.xlsx\") trên thực tế đang cung cấp đường dẫn tệp đầy đủ mà là duy nhất cho máy tính của người dùng:\n\"C:/Users/Laura/Documents/my_R_project/data/linelists/ebola_linelist.xlsx\"\nƯu điểm là lệnh here() được R sử dụng có thể chạy thành công trên bất kỳ máy tính nào truy cập vào dự án R.\nMẸO: Nếu bạn không chắc gốc “.here” được đặt ở đâu, hãy chạy lệnh here() với dấu ngoặc đơn trống.\nĐọc thêm về package here tại đường dẫn này.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#đường-dẫn-tệp",
    "href": "new_pages/importing.vn.html#đường-dẫn-tệp",
    "title": "7  Nhập xuất dữ liệu",
    "section": "7.4 Đường dẫn tệp",
    "text": "7.4 Đường dẫn tệp\nKhi nhập hoặc xuất dữ liệu, bạn phải cung cấp một đường dẫn tệp. Bạn có thể thực hiện thao tác này bằng một trong ba cách sau:\n\nKhuyên dùng: cung cấp một đường dẫn tệp “tương đối” bằng package here\n\nCung cấp đường dẫn tệp “đầy đủ” / “tuyệt đối”\n\nChọn tệp theo cách thủ công\n\n\nĐường dẫn tệp “tương đối”\nTrong R, đường dẫn tệp “tương đối” bao gồm đường dẫn tệp mà liên quan đến phần gốc của dự án R. Chúng cho phép nhiều đường dẫn tệp đơn giản hơn có thể làm việc trên nhiều máy tính khác nhau (ví dụ: nếu dự án R nằm trên bộ nhớ dùng chung hoặc được gửi qua thư điện tử). Như đã được mô tả ở trên, đường dẫn tệp tương đối được tạo ra dễ dàng bằng cách sử dụng package here.\nDưới đây là một ví dụ về đường dẫn tệp tương đối được tạo bằng package here(). Chúng tôi giả sử công việc nằm trong một dự án R có chứa một thư mục con “data” và bên trong nó là thư mục con “linelists”, trong đó có tệp .xlsx được quan tâm.\n\nlinelist &lt;- import(here(\"data\", \"linelists\", \"ebola_linelist.xlsx\"))\n\n\n\nĐường dẫn tệp “tuyệt đối”\nĐường dẫn tệp tuyệt đối hay “đầy đủ” có thể được cung cấp cho các hàm như import() nhưng chúng “dễ đứt gãy” bởi vì chúng là duy nhất đối với các máy tính của những người dùng khác nhau, và do đó không được khuyến khích sử dụng.\nDưới đây là một ví dụ về đường dẫn tệp tuyệt đối, trong máy tính của Laura có một thư mục “analysis”, tiếp theo là thư mục con “data” và bên trong là thư mục con “linelists”, trong đó có tệp .xlsx được quan tâm.\n\nlinelist &lt;- import(\"C:/Users/Laura/Documents/analysis/data/linelists/ebola_linelist.xlsx\")\n\nMột vài điều cần lưu ý về đường dẫn tệp tuyệt đối:\n\nTránh sử dụng đường dẫn tệp tuyệt đối vì chúng sẽ bị đứt gãy nếu script được chạy trên một máy tính khác\nSử dụng dấu gạch chéo tiến (/), như trong ví dụ trên (lưu ý: đây KHÔNG phải là kiểu mặc định đối với đường dẫn tệp trong Windows)\n\nĐường dẫn tệp bắt đầu với hai dấu gạch chéo (ví dụ: “//…”) sẽ có khả năng không được R nhận ra và tạo ra lỗi. Hãy cân nhắc chuyển công việc của bạn sang ổ đĩa “có tên” hoặc “có chữ” bắt đầu bằng một chữ cái (ví dụ: “J:” hoặc “C:”). Xem chương về Tương tác với thư mục làm việc để biết thêm chi tiết về vấn đề này.\n\nMột tình huống mà đường dẫn tệp tuyệt đối có thể thích hợp là khi bạn muốn nhập một tệp từ bộ nhớ dùng chung có cùng đường dẫn tệp đầy đủ cho tất cả người dùng.\nMẸO: Để nhanh chóng chuyển đổi tất cả \\ thành /, hãy bôi đen đoạn code cần chuyển, sử dụng Ctrl + F (trong Windows) và tích vào tùy chọn “In selection”, sau đó sử dụng chức năng thay thế (replace) để chuyển đổi chúng.\n\n\n\nChọn tệp theo cách thủ công\nBạn có thể nhập dữ liệu theo cách thủ công thông qua một trong các phương pháp sau:\n\nTừ cửa sổ Environment trong RStudio, nhấp vào “Import Dataset” và chọn loại dữ liệu\nNhấp vào File / Import Dataset / (chọn loại dữ liệu)\n\nĐể lựa chọn thủ công bằng code, hãy sử dụng lệnh file.choose() trong base R (để trống dấu ngoặc đơn) để kích hoạt sự xuất hiện của một cửa sổ pop-up cho phép người dùng chọn tệp theo cách thủ công từ máy tính của họ. Ví dụ:\n\n\n# Manual selection of a file. When this command is run, a POP-UP window will appear. \n# The file path selected will be supplied to the import() command.\n\nmy_data &lt;- import(file.choose())\n\nMẸO: Cửa sổ pop-up có thể xuất hiện SAU cửa sổ RStudio của bạn.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#nhập-dữ-liệu",
    "href": "new_pages/importing.vn.html#nhập-dữ-liệu",
    "title": "7  Nhập xuất dữ liệu",
    "section": "7.5 Nhập dữ liệu",
    "text": "7.5 Nhập dữ liệu\nSử dụng lệnh import() để nhập một bộ dữ liệu khá đơn giản. Chỉ cần cung cấp đường dẫn của tệp (bao gồm tên và phần mở rộng của tệp) trong dấu ngoặc kép. Nếu sử dụng hàm here() để xây dựng đường dẫn tệp, hãy làm theo hướng dẫn ở bên trên. Dưới đây là một vài ví dụ:\nNhập một tệp csv nằm trong “thư mục làm việc (working directory)” của bạn hoặc trong thư mục gốc của dự án R:\n\nlinelist &lt;- import(\"linelist_cleaned.csv\")\n\nNhập sheet đầu tiên của Excel workbook, được đặt trong thư mục con “data” và “linelists” của dự án R (đường dẫn tệp được tạo bằng hàm here()):\n\nlinelist &lt;- import(here(\"data\", \"linelists\", \"linelist_cleaned.xlsx\"))\n\nNhập một data frame (một tệp .rds ) sử dụng đường dẫn tệp tuyệt đối:\n\nlinelist &lt;- import(\"C:/Users/Laura/Documents/tuberculosis/data/linelists/linelist_cleaned.rds\")\n\n\nTrang tính Excel cụ thể\nTheo mặc định, nếu bạn cung cấp một Excel workbook (.xlsx) để nhập bằng hàm import(), trang tính đầu tiên của workbook sẽ được nhập. Nếu bạn muốn nhập một trang tính cụ thể, hãy cụ thể tên trang tính vào đối số which =. Ví dụ:\n\nmy_data &lt;- import(\"my_excel_file.xlsx\", which = \"Sheetname\")\n\nNếu sử dụng hàm here() để cung cấp một đường dẫn tương đối đến hàm import(), bạn vẫn có thể chỉ ra một trang tính cụ thể bằng cách thêm đối số which = sau dấu đóng ngoặc của hàm here().\n\n# Demonstration: importing a specific Excel sheet when using relative pathways with the 'here' package\nlinelist_raw &lt;- import(here(\"data\", \"linelist.xlsx\"), which = \"Sheet1\")`  \n\nĐể xuất một data frame từ R sang một trang tính Excel và phần còn lại của Excel workbook không thay đổi, bạn sẽ phải nhập, chỉnh sửa và xuất với một package thay thế chuyên biệt cho mục đích này, chẳng hạn như openxlsx. Xem thêm thông tin trong chương về Tương tác với thư mục làm việc hoặc tại trang github này.\nNếu Excel workbook của bạn có phần mở rộng là .xlsb (định dạng nhị phân của Excel workbook) bạn có thể sẽ không nhập được bằng package rio. Hãy cân nhắc lưu lại tệp dưới dạng .xlsx hoặc sử dụng một package như readxlsb, là package được xây dựng cho kiểu tệp này.\n\n\n\nGiá trị missing\nBạn có thể muốn xác định (các) giá trị nào trong bộ dữ liệu của mình nên được coi là missing. Như đã giải thích trong chương về Dữ liệu missing, giá trị cho dữ liệu missing trong R là NA, nhưng có thể bộ dữ liệu bạn muốn nhập vào sử dụng giá trị 99, “Missing” hoặc chỉ là khoảng trống ký tự ““.\nSử dụng đối số na = để (nhập) import() và cung cấp (các) giá trị trong dấu ngoặc kép (ngay cả khi chúng là các số). Bạn có thể chỉ định nhiều giá trị bằng cách gộp chúng trong một vectơ, bằng cách sử dụng c() như được trình bày dưới đây.\nTại đây, giá trị “99” trong bộ dữ liệu đã nhập được coi là missing và được chuyển đổi thành NA trong R.\n\nlinelist &lt;- import(here(\"data\", \"my_linelist.xlsx\"), na = \"99\")\n\nCòn ở đây, bất kỳ giá trị nào là “Missing”, “” (ô trống) hoặc ” ” (khoảng trắng) trong bộ dữ liệu đã nhập đều được chuyển đổi thành NA trong R.\n\nlinelist &lt;- import(here(\"data\", \"my_linelist.csv\"), na = c(\"Missing\", \"\", \" \"))\n\n\n\n\nBỏ qua một số hàng\nĐôi khi, bạn có thể không muốn nhập một hàng dữ liệu. Bạn có thể thực hiện thao tác này với đối số skip = nếu sử dụng hàm import() từ package rio trên tệp .xlsx hoặc .csv. Cung cấp số hàng bạn muốn bỏ qua.\n\nlinelist_raw &lt;- import(\"linelist_raw.xlsx\", skip = 1)  # does not import header row\n\nKhông may là hàm skip = chỉ chấp nhận một giá trị số nguyên, không chấp nhận một khoảng (ví dụ: “2:10” sẽ không hoạt động). Để bỏ qua việc nhập các hàng cụ thể không liên tiếp từ trên cùng, hãy cân nhắc nhập nhiều lần và sử dụng hàm bind_rows() từ dplyr. Hãy xem ví dụ dưới đây về việc chỉ bỏ qua hàng thứ 2.\n\n\nQuản lý hàng tiêu đề thứ hai\nĐôi khi, dữ liệu của bạn có thể có hàng thứ hai, với chức năng như là “từ điển dữ liệu” như hình dưới đây. Trường hợp này có thể xảy ra vấn đề vì nó có thể dẫn đến việc tất cả các cột được nhập vào dưới dạng kiểu “ký tự (character)”.\nDưới đây là một ví dụ về kiểu bộ dữ liệu này (với hàng đầu tiên là từ điển dữ liệu).\n\n\n\n\n\n\n\n\nXóa hàng tiêu đề thứ hai\nĐể bỏ hàng tiêu đề thứ hai, bạn có thể sẽ cần nhập dữ liệu hai lần.\n\nNhập dữ liệu vào để lấy tên các cột chính xác\n\nNhập lại dữ liệu, bỏ qua hai hàng đầu tiên (hàng tiêu đề và hàng thứ hai)\n\nLiên kết dataframe đã xóa bỏ 2 hàng đầu tiên với tên cột chính xác ở bước 1\n\nĐối số chính xác được sử dụng để liên kết các tên cột tùy thuộc vào loại tệp dữ liệu (.csv, .tsv, .xlsx, v.v.). Điều này là do rio sử dụng các hàm khác nhau cho các loại tệp khác nhau (xem bảng ở trên).\nĐối với tệp Excel: (col_names =)\n\n# import first time; store the column names\nlinelist_raw_names &lt;- import(\"linelist_raw.xlsx\") %&gt;% names()  # save true column names\n\n# import second time; skip row 2, and assign column names to argument col_names =\nlinelist_raw &lt;- import(\"linelist_raw.xlsx\",\n                       skip = 2,\n                       col_names = linelist_raw_names\n                       ) \n\nĐối với tệp CSV: (col.names =)\n\n# import first time; sotre column names\nlinelist_raw_names &lt;- import(\"linelist_raw.csv\") %&gt;% names() # save true column names\n\n# note argument for csv files is 'col.names = '\nlinelist_raw &lt;- import(\"linelist_raw.csv\",\n                       skip = 2,\n                       col.names = linelist_raw_names\n                       ) \n\nTùy chọn sao lưu - thay đổi tên cột dưới dạng một lệnh riêng biệt\n\n# assign/overwrite headers using the base 'colnames()' function\ncolnames(linelist_raw) &lt;- linelist_raw_names\n\n\nTạo từ điển dữ liệu\nThông tin thêm! Nếu bạn có hàng thứ hai là từ điển dữ liệu, bạn có thể dễ dàng tạo từ điển dữ liệu thích hợp từ nó. Mẹo này được tham khảo từ bài đăng này.\n\ndict &lt;- linelist_2headers %&gt;%             # begin: linelist with dictionary as first row\n  head(1) %&gt;%                             # keep only column names and first dictionary row                \n  pivot_longer(cols = everything(),       # pivot all columns to long format\n               names_to = \"Column\",       # assign new column names\n               values_to = \"Description\")\n\n\n\n\n\n\n\n\n\nKết hợp hai hàng tiêu đề\nTrong một số trường hợp khi bộ dữ liệu thô của bạn có hai hàng tiêu đề (hoặc cụ thể hơn, hàng dữ liệu thứ 2 là tiêu đề phụ), bạn có thể sẽ muốn “kết hợp” chúng hoặc thêm các giá trị trong hàng tiêu đề thứ hai vào hàng tiêu đề đầu tiên.\nLệnh dưới đây sẽ xác định tên cột của data frame là sự kết hợp (dán với nhau) của các tiêu đề (đúng) đầu tiên với giá trị ngay bên dưới (trong hàng đầu tiên).\n\nnames(my_data) &lt;- paste(names(my_data), my_data[1, ], sep = \"_\")\n\n\n\n\n\nTrang tính Google\nBạn có thể nhập dữ liệu từ một trang tính Google trực tuyến với package googlesheet4 và bằng cách xác thực quyền truy cập của bạn vào trang tính.\n\npacman::p_load(\"googlesheets4\")\n\nDưới đây là một trang tính Google minh họa được nhập và lưu. Lệnh này có thể yêu cầu xác thực tài khoản Google của bạn. Làm theo lời nhắc và cửa sổ bật lên trong trình duyệt Internet của bạn để cấp cho các package Tidyverse API quyền chỉnh sửa, tạo và xóa trang tính của bạn trong Google Drive.\nTrang tính dưới đây “có thể được xem bởi bất kỳ ai có liên kết” và bạn có thể thử nhập trang tính đó.\n\nGsheets_demo &lt;- read_sheet(\"https://docs.google.com/spreadsheets/d/1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY/edit#gid=0\")\n\nTrang tính cũng có thể được nhập chỉ bằng ID của sheet, một phần ngắn hơn của URL:\n\nGsheets_demo &lt;- read_sheet(\"1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY\")\n\nMột package khác, googledrive cung cấp các hàm hữu ích để viết, chỉnh sửa và xóa các trang tính Google. Ví dụ: các hàm được sử dụng gs4_create() và sheet_write() đều được tìm thấy trong package này.\nDưới đây là một số hướng dẫn trực tuyến hữu ích khác:\nhướng dẫn nhập Google sheet cơ bản\nhướng dẫn chi tiết hơn\ntương tác giữa googlesheets4 và tidyverse",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#nhập-xuất-tách-kết-hợp---nhiều-tệp",
    "href": "new_pages/importing.vn.html#nhập-xuất-tách-kết-hợp---nhiều-tệp",
    "title": "7  Nhập xuất dữ liệu",
    "section": "7.6 Nhập, xuất, tách, kết hợp - nhiều tệp",
    "text": "7.6 Nhập, xuất, tách, kết hợp - nhiều tệp\nXem chương về Lặp, vòng lặp, và danh sách để biết ví dụ về cách nhập và kết hợp nhiều tệp hoặc nhiều Excel workbook. Chương này cũng có các ví dụ về cách chia một data frame thành các phần và xuất từng phần riêng biệt hoặc dưới dạng các trang tính được đặt tên trong một Excel workbook.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#import_github",
    "href": "new_pages/importing.vn.html#import_github",
    "title": "7  Nhập xuất dữ liệu",
    "section": "7.7 Nhập từ Github",
    "text": "7.7 Nhập từ Github\nNhập dữ liệu trực tiếp từ Github vào R có thể rất dễ dàng hoặc có thể yêu cầu một vài bước - tùy thuộc vào loại tệp. Dưới đây là một số cách tiếp cận:\n\nTệp CSV\nCó thể dễ dàng nhập tệp .csv trực tiếp từ Github vào R bằng lệnh R.\n\nĐi tới repo Github, tìm tệp quan tâm và nhấp vào tệp đó\n\nNhấp vào nút “Raw” (sau đó bạn sẽ thấy dữ liệu csv “thô”, như được hiển thị bên dưới)\n\nSao chép URL (địa chỉ web)\n\nĐặt URL trong dấu ngoặc kép trong lệnh R import()\n\n\n\n\n\n\n\n\n\n\n\n\nTệp XLSX\nBạn có thể không xem được dữ liệu “Thô” cho một số tệp (ví dụ: .xlsx, .rds, .nwk, .shp)\n\nĐi tới repo Github, tìm tệp quan tâm và nhấp vào tệp đó\n\nNhấp vào nút “Download”, như được hiển thị bên dưới\n\nLưu tệp trên máy tính của bạn và nhập tệp đó vào R\n\n\n\n\n\n\n\n\n\n\n\n\nShapefiles\nCác Shapefiles có nhiều tệp thành phần phụ, mỗi tệp có một phần mở rộng khác nhau. Một tệp sẽ có phần mở rộng “.shp”, nhưng những tệp khác có thể là “.dbf”, “.prj”, v.v. Để tải xuống shapefiles từ Github, bạn sẽ cần tải xuống từng tệp thành phần phụ riêng lẻ và lưu chúng trong cùng một thư mục trên máy tính của bạn. Trong Github, nhấp vào từng tệp riêng lẻ và tải chúng xuống bằng cách nhấp vào nút “Download”.\nMột khi được lưu vào máy tính, bạn có thể nhập định dạng tệp như được trình bày trong chương GIS cơ bản bằng cách sử dụng hàm st_read() từ package sf. Bạn chỉ cần cung cấp đường dẫn tệp và tên của tệp “.shp” - miễn là các tệp liên quan khác nằm trong cùng một thư mục trên máy tính của bạn.\nDưới đây, bạn có thể thấy shapefiles tên “sl_adm3” bao gồm nhiều tệp như thế nào - mỗi tệp phải được tải xuống từ Github.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#nhập-dữ-liệu-thủ-công",
    "href": "new_pages/importing.vn.html#nhập-dữ-liệu-thủ-công",
    "title": "7  Nhập xuất dữ liệu",
    "section": "7.8 Nhập dữ liệu thủ công",
    "text": "7.8 Nhập dữ liệu thủ công\n\nNhập theo hàng\nSử dụng hàm tribble của package tibble từ tidyverse (tài liệu tham khảo trực tuyến).\nLưu ý cách tiêu đề cột bắt đầu bằng dấu ngã (~). Cũng lưu ý rằng mỗi cột chỉ được chứa một nhóm dữ liệu (ký tự, số, v.v.). Bạn có thể sử dụng các tab, khoảng cách và hàng mới để làm cho việc nhập dữ liệu trực quan và dễ đọc hơn. Khoảng trắng không quan trọng giữa các giá trị, nhưng mỗi hàng được biểu thị bằng một dòng code mới. Ví dụ:\n\n# create the dataset manually by row\nmanual_entry_rows &lt;- tibble::tribble(\n  ~colA, ~colB,\n  \"a\",   1,\n  \"b\",   2,\n  \"c\",   3\n  )\n\nVà giờ chúng ta hiển thị bộ dữ liệu mới:\n\n\n\n\n\n\n\n\nNhập theo cột\nVì data frame bao gồm các vectơ (cột dọc), cách tiếp cận cơ bản để tạo data frame thủ công trong R yêu cầu bạn phải tạo từng cột và sau đó liên kết chúng lại với nhau. Điều này có thể phản trực quan trong dịch tễ học, vì chúng ta thường nghĩ về dữ liệu của mình theo hàng (như trên).\n\n# define each vector (vertical column) separately, each with its own name\nPatientID &lt;- c(235, 452, 778, 111)\nTreatment &lt;- c(\"Yes\", \"No\", \"Yes\", \"Yes\")\nDeath     &lt;- c(1, 0, 1, 0)\n\nCHÚ Ý: Tất cả các vectơ phải có cùng độ dài (cùng số giá trị).\nCác vectơ sau đó có thể được liên kết với nhau bằng cách sử dụng lệnh data.frame():\n\n# combine the columns into a data frame, by referencing the vector names\nmanual_entry_cols &lt;- data.frame(PatientID, Treatment, Death)\n\nVà giờ chúng ta hiển thị bộ dữ liệu mới:\n\n\n\n\n\n\n\n\nDán từ clipboard\nNếu bạn sao chép dữ liệu từ nơi khác và có nó trong clipboard (bộ nhớ tạm), bạn có thể thử một trong hai cách dưới đây:\nTừ package clipr, bạn có thể sử dụng hàm read_clip_tbl() để nhập dưới dạng data frame hoặc chỉ cần hàm read_clip() để nhập dưới dạng một vectơ ký tự. Trong cả hai trường hợp, hãy để trống dấu ngoặc đơn.\n\nlinelist &lt;- clipr::read_clip_tbl()  # imports current clipboard as data frame\nlinelist &lt;- clipr::read_clip()      # imports as character vector\n\nBạn cũng có thể dễ dàng xuất sang clipboard của hệ thống bằng clipr. Xem mục bên dưới về Xuất dữ liệu.\nNgoài ra, bạn có thể sử dụng lệnh read.table() từ base R với file = \"clipboard\") để nhập dưới dạng data frame:\n\ndf_from_clipboard &lt;- read.table(\n  file = \"clipboard\",  # specify this as \"clipboard\"\n  sep = \"t\",           # separator could be tab, or commas, etc.\n  header=TRUE)         # if there is a header row",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#nhập-tệp-gần-đây-nhất",
    "href": "new_pages/importing.vn.html#nhập-tệp-gần-đây-nhất",
    "title": "7  Nhập xuất dữ liệu",
    "section": "7.9 Nhập tệp gần đây nhất",
    "text": "7.9 Nhập tệp gần đây nhất\nThường thì bạn có thể nhận được các bản cập nhật hàng ngày cho bộ dữ liệu của mình. Trong trường hợp này, bạn sẽ muốn viết code mà nhập tệp gần đây nhất. Dưới đây, chúng tôi trình bày hai cách để tiếp cận điều này:\n\nChọn tệp dựa trên ngày trong tên tệp\n\nChọn tệp dựa trên metadata (siêu dữ liệu - là dạng dữ liệu mô tả thông tin chi tiết về dữ liệu) của tệp (lần sửa đổi cuối cùng)\n\n\nNgày trong tên tệp\nCách tiếp cận này dựa trên ba cơ sở:\n\nBạn tin tưởng ngày tháng trong tên tệp\n\nNgày tháng ở dạng số và thường xuất hiện ở cùng một định dạng (ví dụ: năm rồi tháng rồi ngày)\n\nKhông có số nào khác trong tên tệp\n\nChúng tôi sẽ giải thích từng bước và sau đó cho bạn thấy cách chúng được kết hợp ở phần cuối.\nĐầu tiên, sử dụng dir() từ base R để chỉ trích xuất tên tệp cho mỗi tệp trong thư mục quan tâm. Xem chương về Tương tác với thư mục làm việc để biết thêm chi tiết về dir(). Trong ví dụ này, thư mục quan tâm là thư mục “linelists” trong thư mục “example” chứa trong thư mục “data” của dự án R.\n\nlinelist_filenames &lt;- dir(here(\"data\", \"example\", \"linelists\")) # get file names from folder\nlinelist_filenames                                              # print\n\n[1] \"20201007linelist.csv\"          \"case_linelist_2020-10-02.csv\" \n[3] \"case_linelist_2020-10-03.csv\"  \"case_linelist_2020-10-04.csv\" \n[5] \"case_linelist_2020-10-05.csv\"  \"case_linelist_2020-10-08.xlsx\"\n[7] \"case_linelist20201006.csv\"    \n\n\nMột khi bạn có vectơ chứa các tên này, bạn có thể trích xuất ngày với chúng bằng cách áp dụng hàm str_extract() từ stringr với việc sử dụng biểu thức chính quy sau đây. Nó giúp trích xuất bất kỳ số nào trong tên tệp (bao gồm bất kỳ ký tự nào khác ở giữa như dấu gạch ngang hoặc dấu gạch chéo). Bạn có thể đọc thêm về stringr trong chương Ký tự và chuỗi.\n\nlinelist_dates_raw &lt;- stringr::str_extract(linelist_filenames, \"[0-9].*[0-9]\") # extract numbers and any characters in between\nlinelist_dates_raw  # print\n\n[1] \"20201007\"   \"2020-10-02\" \"2020-10-03\" \"2020-10-04\" \"2020-10-05\"\n[6] \"2020-10-08\" \"20201006\"  \n\n\nGiả sử ngày thường được viết theo cùng một định dạng ngày (ví dụ: Năm rồi Tháng rồi Ngày) và năm có 4 chữ số, bạn có thể sử dụng các hàm chuyển đổi linh hoạt của lubridate (ymd(), dmy(), or mdy()) để chuyển đổi chúng thành ngày. Đối với các hàm này, dấu gạch ngang, dấu cách hoặc dấu gạch chéo không quan trọng, quan trọng chỉ là thứ tự của các số. Đọc thêm trong chương Làm việc với ngày tháng.\n\nlinelist_dates_clean &lt;- lubridate::ymd(linelist_dates_raw)\nlinelist_dates_clean\n\n[1] \"2020-10-07\" \"2020-10-02\" \"2020-10-03\" \"2020-10-04\" \"2020-10-05\"\n[6] \"2020-10-08\" \"2020-10-06\"\n\n\nSau đó, hàm base R which.max() có thể được sử dụng để trả về vị trí chỉ mục (ví dụ: 1, 2, 3,…) của giá trị ngày lớn nhất. Tệp mới nhất được xác định chính xác là tệp thứ 6 - “case_linelist_2020-10-08.xlsx”.\n\nindex_latest_file &lt;- which.max(linelist_dates_clean)\nindex_latest_file\n\n[1] 6\n\n\nNếu chúng ta tổng hợp tất cả các lệnh này, code hoàn chỉnh có thể trông giống như bên dưới. Lưu ý rằng dấu . ở dòng cuối cùng thay thế cho đối tượng được truyền vào hàm trước đó. Tại thời điểm đó, giá trị chỉ đơn giản là số 6. Giá trị này được đặt trong dấu ngoặc kép để trích xuất phần tử thứ 6 của vectơ tên tệp được tạo bởi dir().\n\n# load packages\npacman::p_load(\n  tidyverse,         # data management\n  stringr,           # work with strings/characters\n  lubridate,         # work with dates\n  rio,               # import / export\n  here,              # relative file paths\n  fs)                # directory interactions\n\n# extract the file name of latest file\nlatest_file &lt;- dir(here(\"data\", \"example\", \"linelists\")) %&gt;%  # file names from \"linelists\" sub-folder          \n  str_extract(\"[0-9].*[0-9]\") %&gt;%                  # pull out dates (numbers)\n  ymd() %&gt;%                                        # convert numbers to dates (assuming year-month-day format)\n  which.max() %&gt;%                                  # get index of max date (latest file)\n  dir(here(\"data\", \"example\", \"linelists\"))[[.]]              # return the filename of latest linelist\n\nlatest_file  # print name of latest file\n\n[1] \"case_linelist_2020-10-08.xlsx\"\n\n\nBây giờ bạn có thể sử dụng tên này để hoàn thiện đường dẫn tệp tương đối, với hàm here():\n\nhere(\"data\", \"example\", \"linelists\", latest_file) \n\nVà bây giờ bạn có thể nhập tệp mới nhất:\n\n# import\nimport(here(\"data\", \"example\", \"linelists\", latest_file)) # import \n\n\n\nSử dụng thông tin tệp\nNếu tệp của bạn không có ngày trong tên của chúng (hoặc bạn không tin tưởng vào những ngày đó), bạn có thể thử trích xuất ngày sửa đổi cuối cùng từ siêu dữ liệu tệp. Sử dụng các hàm từ package fs để kiểm tra thông tin siêu dữ liệu cho từng tệp, bao gồm thời gian sửa đổi cuối cùng và đường dẫn tệp.\nDưới đây, chúng tôi cung cấp thư mục quan tâm tới hàm dir_info() của package fs. Trong trường hợp này, thư mục quan tâm nằm trong dự án R trong thư mục “data”, thư mục con “example” và thư mục con thư mục này “linelists”. Kết quả là một data frame với một dòng cho mỗi tệp và các cột cho modification_time, path, v.v. Bạn có thể xem ví dụ trực quan về điều này trong chương về Tương tác với thư mục làm việc.\nChúng ta có thể sắp xếp data frame này của các tệp theo cột với modification_time, và sau đó chỉ giữ lại hàng trên cùng/mới nhất (tệp) với head()của base R. Sau đó, chúng ta có thể trích xuất đường dẫn tệp của tệp mới nhất này chỉ với hàm pull() của dplyr trên path cột. Cuối cùng, chúng ta có thể chuyển đường dẫn tệp này đến import(). Tệp đã nhập được lưu dưới dạng latest_file.\n\nlatest_file &lt;- dir_info(here(\"data\", \"example\", \"linelists\")) %&gt;%  # collect file info on all files in directory\n  arrange(desc(modification_time)) %&gt;%      # sort by modification time\n  head(1) %&gt;%                               # keep only the top (latest) file\n  pull(path) %&gt;%                            # extract only the file path\n  import()                                  # import the file",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#import_api",
    "href": "new_pages/importing.vn.html#import_api",
    "title": "7  Nhập xuất dữ liệu",
    "section": "7.10 API",
    "text": "7.10 API\nMột “Giao diện lập trình tự động (Automated Programming Interface)” (API) có thể được sử dụng để yêu cầu trực tiếp dữ liệu từ một trang web. API là một tập hợp các quy tắc cho phép một ứng dụng phần mềm tương tác với một ứng dụng phần mềm khác. Khách hàng (bạn) gửi một “yêu cầu (request)” và nhận được một “phản hồi (response)” có chứa nội dung. Các package R httr và jsonlite có thể hỗ trợ quá trình này.\nMỗi trang web hỗ trợ API sẽ có tài liệu và chi tiết cụ thể riêng để làm quen. Một số trang web công khai API và cho phép có thể được truy cập bởi bất kỳ ai. Những nền tảng khác, chẳng hạn như nền tảng có ID người dùng và thông tin đăng nhập, yêu cầu xác thực để truy cập dữ liệu của họ.\nKhông cần phải nói, để nhập dữ liệu qua API thì cần phải có kết nối internet. Chúng tôi sẽ đưa ra các ví dụ ngắn gọn về việc sử dụng API để nhập dữ liệu và liên kết bạn với các tài nguyên khác.\nLưu ý: Hãy nhớ lại rằng dữ liệu có thể được đăng trên một trang web không có API, điều này có thể dễ dàng truy xuất hơn. Ví dụ: một tệp CSV đã đăng có thể được truy cập chỉ bằng cách cung cấp URL của trang web để import() như được mô tả trong mục nhập từ Github.\n\nHTTP request\nTrao đổi API thường được thực hiện thông qua một HTTP request. HTTP là Giao thức truyền siêu văn bản (Hypertext Transfer Protocol) và là định dạng cơ bản của giao thức yêu cầu (request)/phản hồi (response) giữa máy khách và máy chủ. Đầu vào và đầu ra chính xác có thể khác nhau tùy thuộc vào loại API nhưng quy trình là giống nhau - “Request” (thường là HTTP request) từ người dùng, thường chứa một truy vấn, theo sau là “Response”, chứa thông tin trạng thái về request và có thể là nội dung được yêu cầu.\nDưới đây là một số thành phần của một HTTP request:\n\nURL của điểm cuối API\n\n“Method (Phương thức)” (hoặc “Verb (Động từ)”)\n\nCác tiêu đề\n\nPhần thân\n\nHTTP request “method” là hành động bạn muốn thực hiện. Hai phương thức HTTP phổ biến nhất là GET và POST nhưng những phương thức khác có thể bao gồm PUT, DELETE, PATCH, v.v. Khi nhập dữ liệu vào R, rất có thể bạn sẽ sử dụng GET.\nSau request của bạn, máy tính của bạn sẽ nhận được “phản hồi” ở định dạng tương tự như những gì bạn đã gửi, bao gồm URL, trạng thái HTTP (Trạng thái 200 là thứ bạn muốn!), loại tệp, kích thước và nội dung mong muốn. Sau đó, bạn sẽ cần phân tích cú pháp phản hồi này và biến nó thành một data frame khả thi trong môi trường R của bạn.\n\n\nPackage\nPackage httr hoạt động tốt để xử lý các yêu cầu HTTP trong R. Nó đòi hỏi ít kiến thức về API Web và có thể được sử dụng bởi những người ít quen thuộc với thuật ngữ phát triển phần mềm. Ngoài ra, nếu phản hồi HTTP là .json, bạn có thể sử dụng jsonlite để phân tích cú pháp phản hồi.\n\n# load packages\npacman::p_load(httr, jsonlite, tidyverse)\n\n\n\nDữ liệu công khai\nDưới đây là một ví dụ về một HTTP request, được mượn từ một hướng dẫn từ Phòng thí nghiệm Dữ liệu Trafford. Trang web này chứa một số tài nguyên khác để tìm hiểu và các bài tập về API.\nTình huống: Chúng ta muốn nhập một danh sách các cửa hàng thức ăn nhanh ở thành phố Trafford, Vương quốc Anh. Dữ liệu có thể được truy cập từ API của Cơ quan Tiêu chuẩn Thực phẩm, cơ quan cung cấp dữ liệu xếp hạng vệ sinh thực phẩm cho Vương quốc Anh.\nDưới đây là các thông số cho yêu cầu của chúng tôi:\n\nPhương thức HTTP: GET\n\nURL của điểm cuối API: http://api.ratings.food.gov.uk/Establishments\n\nCác thông số đã chọn: tên, địa chỉ, kinh độ, vĩ độ, businessTypeId, ratingKey, localAuthorityId\n\nCác tiêu đề: “x-api-version”, 2\n\n(Các) Định dạng dữ liệu: JSON, XML\n\nTài liệu: http://api.ratings.food.gov.uk/help\n\nR code sẽ như sau:\n\n# prepare the request\npath &lt;- \"http://api.ratings.food.gov.uk/Establishments\"\nrequest &lt;- GET(url = path,\n             query = list(\n               localAuthorityId = 188,\n               BusinessTypeId = 7844,\n               pageNumber = 1,\n               pageSize = 5000),\n             add_headers(\"x-api-version\" = \"2\"))\n\n# check for any server error (\"200\" is good!)\nrequest$status_code\n\n# submit the request, parse the response, and convert to a data frame\nresponse &lt;- content(request, as = \"text\", encoding = \"UTF-8\") %&gt;%\n  fromJSON(flatten = TRUE) %&gt;%\n  pluck(\"establishments\") %&gt;%\n  as_tibble()\n\nBây giờ bạn có thể làm sạch và sử dụng data frame có tên response, với mỗi hàng là một cơ sở thức ăn nhanh.\n\n\nYêu cầu xác thực\nMột số API yêu cầu xác thực - để bạn chứng minh mình là ai và có thể truy cập vào dữ liệu bị hạn chế. Để nhập những dữ liệu này, trước tiên bạn có thể cần sử dụng phương thức POST để cung cấp tên người dùng, mật khẩu hoặc code. Điều này sẽ trả về một mã thông báo truy cập, có thể được sử dụng cho các yêu cầu phương thức GET tiếp theo để truy xuất dữ liệu mong muốn.\nDưới đây là một ví dụ về truy vấn dữ liệu từ Go.Data, một công cụ điều tra ổ dịch. Go.Data sử dụng một API cho tất cả các tương tác giữa giao diện người dùng web và các ứng dụng điện thoại thông minh được sử dụng để thu thập dữ liệu. Go.Data được sử dụng trên khắp thế giới. Bởi vì dữ liệu các vụ dịch là nhạy cảm và bạn nên là người duy nhất có thể truy cập vào dữ liệu vụ dịch của mình, nên việc xác thực là bắt buộc.\nDưới đây là một số code R mẫu sử dụng httr và jsonlite để kết nối với API Go.Data để nhập dữ liệu liên hệ truy vết từ vụ dịch của bạn.\n\n# set credentials for authorization\nurl &lt;- \"https://godatasampleURL.int/\"           # valid Go.Data instance url\nusername &lt;- \"username\"                          # valid Go.Data username \npassword &lt;- \"password\"                          # valid Go,Data password \noutbreak_id &lt;- \"xxxxxx-xxxx-xxxx-xxxx-xxxxxxx\"  # valid Go.Data outbreak ID\n\n# get access token\nurl_request &lt;- paste0(url,\"api/oauth/token?access_token=123\") # define base URL request\n\n# prepare request\nresponse &lt;- POST(\n  url = url_request,  \n  body = list(\n    username = username,    # use saved username/password from above to authorize                               \n    password = password),                                       \n    encode = \"json\")\n\n# execute request and parse response\ncontent &lt;-\n  content(response, as = \"text\") %&gt;%\n  fromJSON(flatten = TRUE) %&gt;%          # flatten nested JSON\n  glimpse()\n\n# Save access token from response\naccess_token &lt;- content$access_token    # save access token to allow subsequent API calls below\n\n# import outbreak contacts\n# Use the access token \nresponse_contacts &lt;- GET(\n  paste0(url,\"api/outbreaks/\",outbreak_id,\"/contacts\"),          # GET request\n  add_headers(\n    Authorization = paste(\"Bearer\", access_token, sep = \" \")))\n\njson_contacts &lt;- content(response_contacts, as = \"text\")         # convert to text JSON\n\ncontacts &lt;- as_tibble(fromJSON(json_contacts, flatten = TRUE))   # flatten JSON to tibble\n\nCẨN TRỌNG: Nếu bạn đang nhập một lượng lớn dữ liệu từ một API yêu cầu xác thực, nó có thể hết thời gian chờ. Để tránh điều này, hãy truy xuất lại access_token trước mỗi yêu cầu API GET và thử sử dụng các bộ lọc hoặc giới hạn trong truy vấn.\nMẸO: Lệnh fromJSON() từ package jsonlite không hoàn toàn không - lồng ghép vào lần đầu tiên nó được chạy, vì vậy bạn vẫn có thể có danh sách các hàng trong phần kết quả của mình. Bạn sẽ cần phải bỏ lồng ghép thêm cho một số biến nhất định; tùy thuộc vào cách .json của bạn được lồng ghép vào nhau. Để xem thêm thông tin về điều này, hãy xem tài liệu về package jsonlite, chẳng hạn như flatten() function.\nĐể biết thêm chi tiết, hãy xem tài liệu trên LoopBack Explorer, chương Truy vết tiếp xúc hoặc các mẹo API trên Go.Data Github repository\nBạn có thể đọc thêm về httr trong gói lệnh here\nPhần này cũng đã được trình bày trong hướng dẫn này và hướng dẫn này.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#xuất-dữ-liệu",
    "href": "new_pages/importing.vn.html#xuất-dữ-liệu",
    "title": "7  Nhập xuất dữ liệu",
    "section": "7.11 Xuất dữ liệu",
    "text": "7.11 Xuất dữ liệu\n\nVới package rio\nVới rio, bạn có thể sử dụng lệnh export() theo cách tương tự với import(). Đầu tiên, cung cấp tên của đối tượng R bạn muốn lưu (ví dụ: linelist), sau đó trong dấu ngoặc kép đặt đường dẫn tệp nơi bạn muốn lưu tệp, bao gồm tên tệp mong muốn và phần mở rộng tệp. Ví dụ:\nThao tác này lưu data frame linelist dưới dạng một Excel workbook vào thư mục làm việc/thư mục gốc của dự án R:\n\nexport(linelist, \"my_linelist.xlsx\") # will save to working directory\n\nBạn có thể lưu cùng một data frame dưới dạng tệp csv bằng cách thay đổi phần mở rộng. Ví dụ, chúng tôi cũng lưu nó vào một đường dẫn tệp được tạo bằng here():\n\nexport(linelist, here(\"data\", \"clean\", \"my_linelist.csv\"))\n\n\n\nTới clipboard\nĐể xuất khung dữ liệu sang “clipboard” của máy tính (để sau đó dán vào một phần mềm khác như Excel, Google Spreadsheets, v.v.), bạn có thể sử dụng write_clip() từ package clipr.\n\n# export the linelist data frame to your system's clipboard\nclipr::write_clip(linelist)",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#import_rds",
    "href": "new_pages/importing.vn.html#import_rds",
    "title": "7  Nhập xuất dữ liệu",
    "section": "7.12 Tệp RDS",
    "text": "7.12 Tệp RDS\nGiống như .csv, .xlsx, v.v., bạn cũng có thể xuất/lưu các R data frame dưới dạng tệp .rds. Đây là định dạng tệp dành riêng cho R và rất hữu ích nếu bạn biết mình sẽ làm việc lại với dữ liệu đã xuất trong R.\nCác nhóm của cột được lưu trữ, vì vậy bạn không cần phải làm sạch lại khi chúng được nhập (với Excel hoặc thậm chí là tệp CSV, điều này có thể khiến bạn đau đầu!). Nó cũng là một tệp nhỏ hơn, hữu ích cho việc xuất và nhập nếu bộ dữ liệu của bạn lớn.\nVí dụ: nếu bạn làm việc trong nhóm Dịch tễ học và cần gửi tệp cho nhóm GIS để lập bản đồ và họ cũng sử dụng R, chỉ cần gửi tệp .rds cho họ! Sau đó, tất cả các nhóm cột được giữ lại và có ít việc phải xử lý hơn.\n\nexport(linelist, here(\"data\", \"clean\", \"my_linelist.rds\"))",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#import_rdata",
    "href": "new_pages/importing.vn.html#import_rdata",
    "title": "7  Nhập xuất dữ liệu",
    "section": "7.13 Tệp và danh sách Rdata",
    "text": "7.13 Tệp và danh sách Rdata\nTệp .Rdata có thể lưu trữ nhiều đối tượng R - ví dụ: nhiều data frame, kết quả mô hình, danh sách, v.v. Điều này có thể rất hữu ích để hợp nhất hoặc chia sẻ nhiều dữ liệu của bạn cho một dự án nhất định.\nTrong ví dụ dưới đây, nhiều đối tượng R được lưu trữ trong tệp “my_objects.Rdata” đã xuất:\n\nrio::export(my_list, my_dataframe, my_vector, \"my_objects.Rdata\")\n\nLưu ý: nếu bạn đang thử nhập một danh sách, hãy sử dụng import_list() từ rio để nhập nó với cấu trúc và nội dung gốc hoàn chỉnh.\n\nrio::import_list(\"my_list.Rdata\")",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#lưu-biểu-đồ",
    "href": "new_pages/importing.vn.html#lưu-biểu-đồ",
    "title": "7  Nhập xuất dữ liệu",
    "section": "7.14 Lưu biểu đồ",
    "text": "7.14 Lưu biểu đồ\nHướng dẫn về cách lưu các biểu đồ, chẳng hạn như các biểu đồ được tạo bởi ggplot(), được thảo luận sâu trong chương ggplot cơ bản.\nTóm lại, chạy lệnh ggsave(\"my_plot_filepath_and_name.png\") sau khi in biểu đồ của bạn. Bạn có thể cung cấp một đối tượng biểu đồ đã lưu cho đối số plot = hoặc chỉ cần xác định đường dẫn tệp đích (với phần mở rộng tệp) để lưu biểu đồ được hiển thị gần đây nhất. Bạn cũng có thể kiểm soát width =, height =, units = và dpi =.\nCách để lưu đồ thị mạng lưới (network graph), chẳng hạn như cây lây nhiễm, được đề cập trong chương Chuỗi lây nhiễm.",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.vn.html#tài-nguyên-học-liệu",
    "href": "new_pages/importing.vn.html#tài-nguyên-học-liệu",
    "title": "7  Nhập xuất dữ liệu",
    "section": "7.15 Tài nguyên học liệu",
    "text": "7.15 Tài nguyên học liệu\nR Data Import/Export Manual\nR 4 Data Science chapter on data import\nggsave() documentation\nDưới đây là một bảng, lấy từ rio vignette trực tuyến. Đối với mỗi loại dữ liệu, nó hiển thị: phần mở rộng tệp dự kiến, package rio sử dụng để nhập hoặc xuất dữ liệu và trả lời chức năng này có được bao gồm trong phiên bản rio được cài đặt mặc định hay không.\n\n\n\n\n\n\n\n\n\n\nĐịnh dạng\nPhần mở rộng điển hình\nPackage nhập\nPackage xuất\nĐược cài đặt theo mặc định\n\n\n\n\nDữ liệu được phân tách bằng-dấu phẩy\n.csv\ndata.table fread()\ndata.table\nCó\n\n\nDữ liệu được phân tách bằng-dấu gạch\n.psv\ndata.table fread()\ndata.table\nCó\n\n\nDữ liệu được phân tách bằng-tab\n.tsv\ndata.table fread()\ndata.table\nCó\n\n\nSAS\n.sas7bdat\nhaven\nhaven\nCó\n\n\nSPSS\n.sav\nhaven\nhaven\nCó\n\n\nStata\n.dta\nhaven\nhaven\nCó\n\n\nSAS\nXPORT\n.xpt\nhaven\nhaven\n\n\nSPSS Portable\n.por\nhaven\n\nCó\n\n\nExcel\n.xls\nreadxl\n\nCó\n\n\nExcel\n.xlsx\nreadxl\nopenxlsx\nCó\n\n\nCú pháp R\n.R\nbase\nbase\nCó\n\n\nĐối tượng R được lưu\n.RData, .rda\nbase\nbase\nCó\n\n\nĐối tượng R được nối tiếp\n.rds\nbase\nbase\nCó\n\n\nEpiinfo\n.rec\nforeign\n\nCó\n\n\nMinitab\n.mtp\nforeign\n\nCó\n\n\nSystat\n.syd\nforeign\n\nCó\n\n\n“XBASE”\ndatabase files\n.dbf\nforeign\nforeign\n\n\nĐịnh dạng tệp Weka Attribute-Relation\n.arff\nforeign\nforeign\nCó\n\n\nĐịnh dạng trao đổi dữ liệu\n.dif\nutils\n\nCó\n\n\nDữ liệu Fortran\nno recognized extension\nutils\n\nCó\n\n\nĐịnh dạng dữ liệu Fixed-width\n.fwf\nutils\nutils\nCó\n\n\nDữ liệu gzip được phân tách bằng-dấu phẩy\n.csv.gz\nutils\nutils\nCó\n\n\nCSVY (Tiêu đề siêu dữ liệu CSV + YAML)\n.csvy\ncsvy\ncsvy\nKhông\n\n\nEViews\n.wf1\nhexView\n\nKhông\n\n\nĐịnh dạng trao đổi Feather giữa R/Python\n.feather\nfeather\nfeather\nKhông\n\n\nFast Storage\n.fst\nfst\nfst\nKhông\n\n\nJSON\n.json\njsonlite\njsonlite\nKhông\n\n\nMatlab\n.mat\nrmatio\nrmatio\nKhông\n\n\nOpenDocument Spreadsheet\n.ods\nreadODS\nreadODS\nKhông\n\n\nBảng HTML\n.html\nxml2\nxml2\nKhông\n\n\nTài liệu XML cạn\n.xml\nxml2\nxml2\nKhông\n\n\nYAML\n.yml\nyaml\nyaml\nKhông\n\n\nclipboard mặc định là tsv | | clipr | clipr | Không |",
    "crumbs": [
      "Nhập môn về R",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Nhập xuất dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html",
    "href": "new_pages/cleaning.vn.html",
    "title": "8  Làm sạch số liệu và các hàm quan trọng",
    "section": "",
    "text": "Các hàm quan trọng\nChương sách này nhấn mạnh việc sử dụng các hàm từ hệ sinh thái của package tidyverse. Các hàm thiết yếu trong package này được liệt kê dưới đây.\nPhần lớn các hàm được liệt kê bên dưới thuộc về package dplyr (tên package được viết đầy đủ là “data frame-plier, cung cấp các hàm quan trọng để giải quyết các thách thức trong thao tác xử lý dữ liệu . dplyr là một phần trong hệ sinh thái của package tidyverse (bao gồm các package khác như ggplot2, tidyr, stringr, tibble, purrr, magrittr, và forcats).\nNếu bạn muốn so sánh các hàm này với các câu lệnh trong Stata hoặc SAS, hãy xem chương Chuyển đổi sang R.\nBạn cũng có thể bắt gặp một giải pháp quản lý dữ liệu khác được cung cấp bởi package data.table trong R với các toán tử như := và toán tử dấu ngoặc vuông [ ]. Cách tiếp cận và cú pháp này được giải thích ngắn gọn trong chương Data Table.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#quy-trình-làm-sạch",
    "href": "new_pages/cleaning.vn.html#quy-trình-làm-sạch",
    "title": "8  Làm sạch số liệu và các hàm quan trọng",
    "section": "8.1 Quy trình làm sạch",
    "text": "8.1 Quy trình làm sạch\nChương này tiến hành các bước làm sạch điển hình, bằng cách thêm các hàm xử lý dữ liệu theo trình tự vào một chuỗi các câu lệnh (được gọi là cleaning pipeline).\nTrong phân tích dịch tễ học và xử lý dữ liệu, các bước làm sạch thường được thực hiện tuần tự, liên kết với nhau. Trong R, việc này thường được thực hiện dưới dạng một “pipeline - đường ống” làm sạch, trong đó bộ dữ liệu gốc được chuyển tiếp hoặc “dẫn” từ bước làm sạch này sang bước làm sạch khác.\nCác chuỗi như vậy sử dụng các hàm dạng “verb” trong package dplyr và toán tử pipe %&gt;% trong package magrittr. Chuỗi làm sạch bắt đầu từ dữ liệu “gốc (”linelist_raw.xlsx”) và kết thúc bằng bộ dữ liệu “sạch” trên R (linelist) có thể được sử dụng, lưu, xuất, v.v.\nTrong quy trình làm sạch dữ liệu, thứ tự của các bước là quan trọng. Các bước làm sạch có thể bao gồm:\n\nNhập dữ liệu\nLàm sạch hoặc đổi tên cột\nLoại bỏ trùng lặp\nTạo và chuyển đổi cột (ví dụ: mã hóa lại hoặc chuẩn hóa các giá trị)\nLọc hoặc thêm hàng",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#gọi-package",
    "href": "new_pages/cleaning.vn.html#gọi-package",
    "title": "8  Làm sạch số liệu và các hàm quan trọng",
    "section": "8.2 Gọi package",
    "text": "8.2 Gọi package\nĐoạn code này trình bày cách gọi các package cần thiết cho phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, cài đặt package nếu cần và gọi package ra để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm library() sẵn có trong base R. Xem chương R cơ bản để biết thêm thông tin về các package trong R.\n\npacman::p_load(\n  rio,        # importing data  \n  here,       # relative file pathways  \n  janitor,    # data cleaning and tables\n  lubridate,  # working with dates\n  epikit,     # age_categories() function\n  tidyverse   # data management and visualization\n)",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#nhập-dữ-liệu",
    "href": "new_pages/cleaning.vn.html#nhập-dữ-liệu",
    "title": "8  Làm sạch số liệu và các hàm quan trọng",
    "section": "8.3 Nhập dữ liệu",
    "text": "8.3 Nhập dữ liệu\n\nNhập\nỞ đây, chúng ta sẽ nhập dữ liệu gốc từ file Excel bằng cách sử dụng hàm import() từ package rio. Package rio có thể xử lý linh hoạt nhiều loại tệp tin (ví dụ: .xlsx, .csv, .tsv, .rds). Xem thêm chương Nhập xuất dữ liệu để biết thêm thông tin và mẹo về các tình huống bất thường (ví dụ: loại bỏ hàng, thiết lập giá trị trống, nạp trang tính Google, v.v.).\nNếu bạn muốn hiểu rõ hơn, hãy tải xuống tệp dữ liệu linelist “gốc (với file dạng .xlsx).\nNếu bộ dữ liệu của bạn quá lớn và mất nhiều thời gian để nhập, sẽ hữu ích khi bạn đặt lệnh nhập dữ liệu riêng biệt với chuỗi làm sạch và dữ liệu “gốc sẽ được lưu thành một tệp riêng biệt. Việc này cũng cho phép dễ dàng so sánh giữa phiên bản gốc và phiên bản đã làm sạch.\nDưới đây, chúng ta nạp một tệp Excel thô và lưu nó dưới dạng dataframe linelist_raw. Chúng tôi giả định rằng tệp này nằm trong thư mục làm việc của bạn hoặc thư mục gốc của dự án R và vì vậy không có thư mục con nào được chỉ định trong đường dẫn tệp.\n\nlinelist_raw &lt;- import(\"linelist_raw.xlsx\")\n\nBạn có thể xem 50 hàng đầu tiên của bộ dữ liệu bên dưới. Lưu ý: hàm head(n) trong base R cho phép bạn chỉ xem n hàng đầu tiên trong R console.\n\n\n\n\n\n\n\n\nĐánh giá\nBạn có thể sử dụng hàm skim() từ package skimr để có cái nhìn tổng quan về toàn bộ bộ dữ liệu (xem chương Bảng mô tả để biết thêm thông tin). Các cột được tóm tắt theo phân lớp/định dạng như ký tự và số. Lưu ý: “POSIXct” là một loại phân lớp ngày thô (xem chương Làm việc với ngày tháng.\n\nskimr::skim(linelist_raw)\n\n\n\n\nData summary\n\n\nName\nlinelist_raw\n\n\nNumber of rows\n6611\n\n\nNumber of columns\n28\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n17\n\n\nnumeric\n8\n\n\nPOSIXct\n3\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\ncase_id\n137\n0.98\n6\n6\n0\n5888\n0\n\n\ndate onset\n293\n0.96\n10\n10\n0\n580\n0\n\n\noutcome\n1500\n0.77\n5\n7\n0\n2\n0\n\n\ngender\n324\n0.95\n1\n1\n0\n2\n0\n\n\nhospital\n1512\n0.77\n5\n36\n0\n13\n0\n\n\ninfector\n2323\n0.65\n6\n6\n0\n2697\n0\n\n\nsource\n2323\n0.65\n5\n7\n0\n2\n0\n\n\nage\n107\n0.98\n1\n2\n0\n75\n0\n\n\nage_unit\n7\n1.00\n5\n6\n0\n2\n0\n\n\nfever\n258\n0.96\n2\n3\n0\n2\n0\n\n\nchills\n258\n0.96\n2\n3\n0\n2\n0\n\n\ncough\n258\n0.96\n2\n3\n0\n2\n0\n\n\naches\n258\n0.96\n2\n3\n0\n2\n0\n\n\nvomit\n258\n0.96\n2\n3\n0\n2\n0\n\n\ntime_admission\n844\n0.87\n5\n5\n0\n1091\n0\n\n\nmerged_header\n0\n1.00\n1\n1\n0\n1\n0\n\n\n…28\n0\n1.00\n1\n1\n0\n1\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\n\n\n\n\ngeneration\n7\n1.00\n16.60\n5.71\n0.00\n13.00\n16.00\n20.00\n37.00\n\n\nlon\n7\n1.00\n-13.23\n0.02\n-13.27\n-13.25\n-13.23\n-13.22\n-13.21\n\n\nlat\n7\n1.00\n8.47\n0.01\n8.45\n8.46\n8.47\n8.48\n8.49\n\n\nrow_num\n0\n1.00\n3240.91\n1857.83\n1.00\n1647.50\n3241.00\n4836.50\n6481.00\n\n\nwt_kg\n7\n1.00\n52.69\n18.59\n-11.00\n41.00\n54.00\n66.00\n111.00\n\n\nht_cm\n7\n1.00\n125.25\n49.57\n4.00\n91.00\n130.00\n159.00\n295.00\n\n\nct_blood\n7\n1.00\n21.26\n1.67\n16.00\n20.00\n22.00\n22.00\n26.00\n\n\ntemp\n158\n0.98\n38.60\n0.95\n35.20\n38.30\n38.80\n39.20\n40.80\n\n\n\nVariable type: POSIXct\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nmedian\nn_unique\n\n\n\n\ninfection date\n2322\n0.65\n2012-04-09\n2015-04-27\n2014-10-04\n538\n\n\nhosp date\n7\n1.00\n2012-04-20\n2015-04-30\n2014-10-15\n570\n\n\ndate_of_outcome\n1068\n0.84\n2012-05-14\n2015-06-04\n2014-10-26\n575",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#tên-cột",
    "href": "new_pages/cleaning.vn.html#tên-cột",
    "title": "8  Làm sạch số liệu và các hàm quan trọng",
    "section": "8.4 Tên cột",
    "text": "8.4 Tên cột\nTrong R, tên cột là “tiêu đề” hoặc giá trị “trên đỉnh” của một cột. Chúng được sử dụng để tham chiếu đến các cột trong đoạn code và đóng vai trò như một nhãn mặc định trong các bảng biểu.\nCác phần mềm thống kê khác như SAS và STATA sử dụng “nhãn” là tên cột phiên bản dài hơn khi in, cùng tồn tại song song với tên cột. Mặc dù R cung cấp tính năng thêm nhãn của cột vào dữ liệu, nhưng điều này hầu hết không được nhấn mạnh trong thực tế. Để đặt tên cột “dễ nhìn” cho các bảng biểu, người ta thường điều chỉnh hiển thị của chúng trong các lệnh vẽ biểu đồ để tạo ra kết quả (ví dụ: tiêu đề trục hoặc chú giải của một biểu đồ hoặc tiêu đề cột trong bảng - xem thêm mục scales trong chương Các mẹo với ggplot và chương Trình bày bảng). Nếu bạn muốn gán nhãn cột trong dữ liệu, hãy đọc thêm tài liệu trực tuyến tại đây và tại đây.\nVì tên cột trong R được sử dụng rất thường xuyên, vì vậy chúng phải có cú pháp “sạch”. Chúng tôi đề xuất những tiêu chí sau:\n\nTên ngắn\nKhông có khoảng trắng (thay thế bằng dấu gạch dưới_)\nKhông có ký tự lạ (&, #, &lt;, &gt;, …)\nThống nhất cách định danh (vd: toàn bộ tên cột ngày như date_onset, date_report, date_death…)\n\nTên các cột trong linelist_raw được in bên dưới bằng cách sử dụng hàm names() từ base R. Ban đầu chúng ta có thể thấy rằng:\n\nMột số tên chứa khoảng trắng (vd: infection date)\nMột số mẫu tên khác nhau được sử dụng cho biến ngày (date onset và infection date)\nPhải có một tiêu đề được hợp nhất ở hai cột cuối cùng trong tệp .xlsx. Chúng tôi biết điều này vì tên của hai cột được hợp nhất (“merge_header”) được R gán cho cột đầu tiên và cột thứ hai được gán tên giữ chỗ “… 28” (vì lúc đó nó trống và là cột thứ 28).\n\n\nnames(linelist_raw)\n\n [1] \"case_id\"         \"generation\"      \"infection date\"  \"date onset\"     \n [5] \"hosp date\"       \"date_of_outcome\" \"outcome\"         \"gender\"         \n [9] \"hospital\"        \"lon\"             \"lat\"             \"infector\"       \n[13] \"source\"          \"age\"             \"age_unit\"        \"row_num\"        \n[17] \"wt_kg\"           \"ht_cm\"           \"ct_blood\"        \"fever\"          \n[21] \"chills\"          \"cough\"           \"aches\"           \"vomit\"          \n[25] \"temp\"            \"time_admission\"  \"merged_header\"   \"...28\"          \n\n\nCHÚ Ý: Để tham chiếu tên một cột có chứa khoảng trắng, hãy bao quanh tên cột bằng dấu huyền, ví dụ: linelist$` '\\x60infection date\\x60'`. Lưu ý là trên bàn phím, dấu huyền (`) được phân biệt với dấu ngoặc đơn (’).\n\nLàm sạch tự động\nHàm clean_names() từ package janitor chuẩn hóa tên cột và biến chúng thành duy nhất bằng cách thực hiện như sau:\n\nChuyển đổi tất cả các tên cột thành chỉ bao gồm dấu gạch dưới, số và chữ cái\nCác ký tự có dấu được chuyển ngữ sang dạng ASCII (ví dụ: o tiếng Đức với âm sắc trở thành “o”, “enye” tiếng Tây Ban Nha trở thành “n”)\nTùy chọn viết hoa cho tên cột mới có thể được chỉ định bằng cách sử dụng đối số case = (mặc định là “snake”, các lựa chọn thay thế bao gồm “sentence”, “title”, “small_camel”…)\nBạn có thể chỉ định các tên thay thế cụ thể bằng cách cung cấp một vectơ tới đố số replace = (ví dụ: replace = c(onset = \"date_of_onset\"))\nĐây là một hướng dẫn trực tuyến\n\nSau đây, quy trình làm sạch bắt đầu bằng cách sử dụng hàm clean_names() trên bộ dữ liệu linelist thô.\n\n# pipe the raw dataset through the function clean_names(), assign result as \"linelist\"  \nlinelist &lt;- linelist_raw %&gt;% \n  janitor::clean_names()\n\n# see the new column names\nnames(linelist)\n\n [1] \"case_id\"         \"generation\"      \"infection_date\"  \"date_onset\"     \n [5] \"hosp_date\"       \"date_of_outcome\" \"outcome\"         \"gender\"         \n [9] \"hospital\"        \"lon\"             \"lat\"             \"infector\"       \n[13] \"source\"          \"age\"             \"age_unit\"        \"row_num\"        \n[17] \"wt_kg\"           \"ht_cm\"           \"ct_blood\"        \"fever\"          \n[21] \"chills\"          \"cough\"           \"aches\"           \"vomit\"          \n[25] \"temp\"            \"time_admission\"  \"merged_header\"   \"x28\"            \n\n\nLƯU Ý: Tên cột cuối cùng “… 28” đã được đổi thành “x28”.\n\n\nLàm sạch tên cột thủ công\nViệc đặt tên lại các cột theo cách thủ công thường là cần thiết, ngay cả sau bước chuẩn hóa ở trên. Dưới đây, việc đổi tên được thực hiện bằng cách sử dụng hàm rename() từ package dplyr, như một phần của quy trình. rename() sử dụng cú pháp NEW = OLD - tên cột mới được đặt trước tên cột cũ.\nDưới đây, một lệnh đổi tên được thêm vào quy trình làm sạch. Các khoảng trắng đã được thêm vào một cách chọn lọc để căn chỉnh code dễ đọc hơn.\n\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # standardize column name syntax\n    janitor::clean_names() %&gt;% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome)\n\nBây giờ bạn có thể thấy rằng tên các cột đã được thay đổi:\n\n\n [1] \"case_id\"              \"generation\"           \"date_infection\"      \n [4] \"date_onset\"           \"date_hospitalisation\" \"date_outcome\"        \n [7] \"outcome\"              \"gender\"               \"hospital\"            \n[10] \"lon\"                  \"lat\"                  \"infector\"            \n[13] \"source\"               \"age\"                  \"age_unit\"            \n[16] \"row_num\"              \"wt_kg\"                \"ht_cm\"               \n[19] \"ct_blood\"             \"fever\"                \"chills\"              \n[22] \"cough\"                \"aches\"                \"vomit\"               \n[25] \"temp\"                 \"time_admission\"       \"merged_header\"       \n[28] \"x28\"                 \n\n\n\nThay đối tên cột theo vị trí\nBạn cũng có thể đổi tên theo vị trí cột, thay vì tên cột, ví dụ:\n\nrename(newNameForFirstColumn  = 1,\n       newNameForSecondColumn = 2)\n\n\n\nĐổi tên bằng hàm select() và summarise()\nNhư một lối tắt, bạn cũng có thể đổi tên các cột bằng hàm select() và summarise() thuộc package dplyr. Hàm select() được sử dụng để chỉ giữ một số cột nhất định (sẽ được đề cập sau trong chương này). Hàm summarise() được đề cập trong các chương Nhóm dữ liệu và Bảng mô tả. Các hàm này cũng sử dụng định dạng new_name = old_name. Đây là một ví dụ:\n\nlinelist_raw %&gt;% \n  select(# NEW name             # OLD name\n         date_infection       = `infection date`,    # rename and KEEP ONLY these columns\n         date_hospitalisation = `hosp date`)\n\n\n\n\nCác thách thức khác\n\nCột trống tên trên file Excel\nR không thể nhận diện các cột trong bộ dữ liệu mà không có tên cột (tiêu đề). Vì vậy, nếu bạn nhập một bộ dữ liệu Excel có dữ liệu nhưng không có tiêu đề cột, R sẽ điền vào các tiêu đề đó mặc định như “… 1” hoặc “… 2”. Phần số đại diện cho số cột (ví dụ: nếu cột thứ 4 trong bộ dữ liệu không có tiêu đề, thì R sẽ mặc định đặt tên là “… 4”).\nBạn có thể làm sạch các tên cột này theo cách thủ công bằng cách tham chiếu số vị trí của chúng (xem ví dụ ở trên) hoặc tên được chỉ định của chúng (linelist_raw$...1).\n\n\nHợp nhất tên cột và ô Excel\nCác ô được hợp nhất trong file Excel là một sự cố thường xảy ra khi nhận dữ liệu. Như đã giải thích trong chương Chuyển đổi sang R, các ô được hợp nhất có thể dễ nhìn cho con người đọc dữ liệu, nhưng không phải là “cấu trúc dữ liệu cơ bản” và gây ra nhiều vấn đề cho máy khi nhận diện dữ liệu. R không thể chứa các ô đã hợp nhất.\nNhắc nhở người nhập liệu rằng dữ liệu có thể đọc được bởi con người không giống với dữ liệu mà máy có thể đọc được. Hãy cố gắng đào tạo người dùng về các nguyên tắc về dữ liệu tidy. Nếu có thể, hãy cố gắng thay đổi quy trình để dữ liệu có định dạng gọn gàng hơn mà không hợp nhất các ô.\n\nMỗi biến phải là một cột riêng biệt\nMỗi quan sát phải là một dòng riêng biệt\nMỗi giá trị phải là một ô riêng biệt\n\nKhi sử dụng hàm import() của package rio, giá trị trong một ô đã hợp nhất sẽ được gán cho ô đầu tiên và các ô tiếp theo sẽ trống.\nMột giải pháp để xử lý các ô đã hợp nhất là nạp dữ liệu bằng hàm readWorkbook() từ package openxlsx. Thiết lập đối số fillMergedCells = TRUE. Điều này cho phép giá trị trong ô hợp nhất được tham chiếu cho tất cả các ô nằm trong phạm vi hợp nhất.\n\nlinelist_raw &lt;- openxlsx::readWorkbook(\"linelist_raw.xlsx\", fillMergedCells = TRUE)\n\nNGUY HIỂM: Nếu các tên cột được hợp nhất với readWorkbook(), có thể sẽ trả về tên cột trùng lặp, mà bạn sẽ cần phải sửa một cách thủ công - R không làm việc được với các tên cột trùng lặp! Bạn có thể đặt lại tên cho chúng bằng cách tham chiếu vị trí của chúng (ví dụ: cột 5), như được giải thích trong mục làm sạch tên cột thủ công.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#chọn-hoặc-đổi-vị-trí-cột",
    "href": "new_pages/cleaning.vn.html#chọn-hoặc-đổi-vị-trí-cột",
    "title": "8  Làm sạch số liệu và các hàm quan trọng",
    "section": "8.5 Chọn hoặc đổi vị trí cột",
    "text": "8.5 Chọn hoặc đổi vị trí cột\nSử dụng hàm select() từ package dplyr để chọn các cột bạn muốn giữ lại và sắp xếp lại thứ tự của chúng trong bộ dữ liệu.\nCẨN TRỌNG: Trong các ví dụ dưới đây, bộ dữ liệu linelist được điều chỉnh với hàm select() và được hiển thị, nhưng không được lưu. Việc này được sử dụng phục vụ mục đích mô tả. Tên cột đã sửa đổi được in ra bằng cách chuyển tiếp bộ dữ liệu tới hàm names().\nDưới đây là TẤT CẢ các tên cột trong bộ dữ liệu linelist tại thời điểm làm sạch:\n\nnames(linelist)\n\n [1] \"case_id\"              \"generation\"           \"date_infection\"      \n [4] \"date_onset\"           \"date_hospitalisation\" \"date_outcome\"        \n [7] \"outcome\"              \"gender\"               \"hospital\"            \n[10] \"lon\"                  \"lat\"                  \"infector\"            \n[13] \"source\"               \"age\"                  \"age_unit\"            \n[16] \"row_num\"              \"wt_kg\"                \"ht_cm\"               \n[19] \"ct_blood\"             \"fever\"                \"chills\"              \n[22] \"cough\"                \"aches\"                \"vomit\"               \n[25] \"temp\"                 \"time_admission\"       \"merged_header\"       \n[28] \"x28\"                 \n\n\n\nGiữ cột\nGiữ lại những cột mong muốn\nViết tên cột cần giữ trong hàm select(), không có dấu ngoặc kép. Kết quả trả về sẽ xuất hiện trong bộ dữ liệu theo thứ tự mà bạn cung cấp. Lưu ý rằng nếu bạn chỉ định một cột không tồn tại, R sẽ báo lỗi (xem cách sử dụng hàm any_of() bên dưới nếu bạn không muốn gặp lỗi trong trường hợp này).\n\n# linelist dataset is piped through select() command, and names() prints just the column names\nlinelist %&gt;% \n  select(case_id, date_onset, date_hospitalisation, fever) %&gt;% \n  names()  # display the column names\n\n[1] \"case_id\"              \"date_onset\"           \"date_hospitalisation\"\n[4] \"fever\"               \n\n\n\n\nHàm trợ giúp “tidyselect”\nCác hàm trợ giúp này được xây dựng để giúp bạn dễ dàng chỉ định các cột cần giữ, loại bỏ hoặc chuyển đổi. Chúng nằm trong package tidyselect, thuộc hệ sinh thái tidyverse và làm cơ sở cho cách chọn cột trong các hàm dplyr.\nVí dụ: nếu bạn muốn sắp xếp lại các cột, hàm everything() là một hàm hữu ích để biểu thị “tất cả các cột khác chưa được đề cập”. Lệnh dưới đây di chuyển các cột date_onset và date_hospitalisation lên cột đầu tiên (bên trái) của bộ dữ liệu, nhưng vẫn giữ tất cả các cột khác sau đó. Lưu ý rằng hàm everything() được viết bằng dấu ngoặc đơn trống:\n\n# move date_onset and date_hospitalisation to beginning\nlinelist %&gt;% \n  select(date_onset, date_hospitalisation, everything()) %&gt;% \n  names()\n\n [1] \"date_onset\"           \"date_hospitalisation\" \"case_id\"             \n [4] \"generation\"           \"date_infection\"       \"date_outcome\"        \n [7] \"outcome\"              \"gender\"               \"hospital\"            \n[10] \"lon\"                  \"lat\"                  \"infector\"            \n[13] \"source\"               \"age\"                  \"age_unit\"            \n[16] \"row_num\"              \"wt_kg\"                \"ht_cm\"               \n[19] \"ct_blood\"             \"fever\"                \"chills\"              \n[22] \"cough\"                \"aches\"                \"vomit\"               \n[25] \"temp\"                 \"time_admission\"       \"merged_header\"       \n[28] \"x28\"                 \n\n\nDưới đây là các hàm trợ giúp “tidyselect” khác cũng hoạt động trong các hàm dplyr như select(), across(), và summarise():\n\neverything() - tất cả các cột khác chưa được đề cập\nlast_col() - cột cuối cùng\nwhere() - áp dụng một hàm cho tất cả các cột và chọn những cột trả về giá trị TRUE\ncontains() - cột chứa một chuỗi ký tự\n\nVí dụ: select(contains(\"time\"))\n\nstarts_with() - khớp với các tiền tố được chỉ định\n\nVí dụ: select(starts_with(\"date_\"))\n\nends_with() - khớp với các hậu tố được chỉ định\n\nVí dụ: select(ends_with(\"_post\"))\n\nmatches() - để áp dụng một mệnh đề chính quy (regex)\n\nVí dụ: select(matches(\"[pt]al\"))\n\nnum_range() - một khoảng số học như x01, x02, x03\nany_of() - khớp NẾU cột tồn tại nhưng không báo lỗi nếu không tìm thấy\n\nVí dụ: select(any_of(date_onset, date_death, cardiac_arrest))\n\n\nNgoài ra, sử dụng các toán tử bình thường như c() để liệt kê danh sách cột, hoặc : cho các cột liên tiếp, ! cho đối lập, & cho VÀ, và | cho HOẶC.\nSử dụng where() để cụ thể tiêu chí logic cho các cột. Nếu đưa một hàm vào trong where(), hãy nhớ không bao gồm dấu ngoặc đơn trống của hàm đó. Câu lệnh bên dưới chọn các cột kiểu Số.\n\n# select columns that are class Numeric\nlinelist %&gt;% \n  select(where(is.numeric)) %&gt;% \n  names()\n\n[1] \"generation\" \"lon\"        \"lat\"        \"row_num\"    \"wt_kg\"     \n[6] \"ht_cm\"      \"ct_blood\"   \"temp\"      \n\n\nSử dụng contains() để chọn các cột trong đó tên cột chứa một chuỗi ký tự được chỉ định. ends_with() và starts_with() cung cấp thêm các lựa chọn khác nhau.\n\n# select columns containing certain characters\nlinelist %&gt;% \n  select(contains(\"date\")) %&gt;% \n  names()\n\n[1] \"date_infection\"       \"date_onset\"           \"date_hospitalisation\"\n[4] \"date_outcome\"        \n\n\nHàm matches() hoạt động tương tự như hàm contains() nhưng có thể được cung cấp một biểu thức chính quy (xem chương Ký tự và chuỗi), chẳng hạn như nhiều chuỗi được phân tách bằng toán tự OR trong dấu ngoặc đơn:\n\n# searched for multiple character matches\nlinelist %&gt;% \n  select(matches(\"onset|hosp|fev\")) %&gt;%   # note the OR symbol \"|\"\n  names()\n\n[1] \"date_onset\"           \"date_hospitalisation\" \"hospital\"            \n[4] \"fever\"               \n\n\nCẨN TRỌNG: Nếu tên cột mà bạn đưa ra không tồn tại trong dữ liệu, máy có thể báo lỗi và dừng code của bạn. Cân nhắc sử dụng hàm any_of() để trích dẫn các cột có thể hoặc không thể tồn tại, đặc biệt hữu ích trong các lựa chọn loại trừ (loại bỏ).\nChỉ có một trong các cột này tồn tại, nhưng không có lỗi được báo và code sẽ tiếp tục các bước trong quy trình làm sạch.\n\nlinelist %&gt;% \n  select(any_of(c(\"date_onset\", \"village_origin\", \"village_detection\", \"village_residence\", \"village_travel\"))) %&gt;% \n  names()\n\n[1] \"date_onset\"\n\n\n\n\nXóa cột\nChỉ ra cột nào cần loại bỏ bằng cách đặt biểu tượng dấu trừ “-” ở phía trước tên cột (ví dụ: select(-outcome)) hoặc một vectơ tên các cột (như bên dưới). Tất cả các cột khác sẽ được giữ nguyên.\n\nlinelist %&gt;% \n  select(-c(date_onset, fever:vomit)) %&gt;% # remove date_onset and all columns from fever to vomit\n  names()\n\n [1] \"case_id\"              \"generation\"           \"date_infection\"      \n [4] \"date_hospitalisation\" \"date_outcome\"         \"outcome\"             \n [7] \"gender\"               \"hospital\"             \"lon\"                 \n[10] \"lat\"                  \"infector\"             \"source\"              \n[13] \"age\"                  \"age_unit\"             \"row_num\"             \n[16] \"wt_kg\"                \"ht_cm\"                \"ct_blood\"            \n[19] \"temp\"                 \"time_admission\"       \"merged_header\"       \n[22] \"x28\"                 \n\n\nBạn cũng có thể xóa một cột bằng cú pháp trong base R, bằng cách định nghĩa nó là NULL. Ví dụ:\n\nlinelist$date_onset &lt;- NULL   # deletes column with base R syntax \n\n\n\nHoạt động độc lập\nselect() cũng có thể được sử dụng như một lệnh độc lập (không bắt buộc trong chuỗi các bước làm sạch). Trong trường hợp này, đối số đầu tiên trong bộ dữ liệu gốc sẽ được tham chiếu.\n\n# Create a new linelist with id and age-related columns\nlinelist_age &lt;- select(linelist, case_id, contains(\"age\"))\n\n# display the column names\nnames(linelist_age)\n\n[1] \"case_id\"  \"age\"      \"age_unit\"\n\n\n\nThêm vào quy trình làm sạch\nTrong bộ dữ liệu linelist_raw, có một vài cột chúng ta không cần: row_num, merged_header, và x28. Chúng ta xóa chúng bằng lệnh select() trong chuỗi các bước làm sạch như sau:\n\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # standardize column name syntax\n    janitor::clean_names() %&gt;% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    #####################################################\n\n    # remove column\n    select(-c(row_num, merged_header, x28))",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#loại-bỏ-trùng-lặp",
    "href": "new_pages/cleaning.vn.html#loại-bỏ-trùng-lặp",
    "title": "8  Làm sạch số liệu và các hàm quan trọng",
    "section": "8.6 Loại bỏ trùng lặp",
    "text": "8.6 Loại bỏ trùng lặp\nXem chương Loại bỏ trùng lặp để biết các tùy chọn mở rộng về cách loại bỏ dữ liệu trùng lặp. Chỉ một ví dụ rất đơn giản về cách loại bỏ hàng trùng lặp được trình bày ở chương này.\nPackage dplyr cung cấp hàm distinct(). Hàm này kiểm tra tất cả các hàng và rút gọn bộ dữ liệu cho chỉ còn các hàng là duy nhất. Nghĩa là, nó loại bỏ 100% các hàng trùng lặp.\nKhi đánh giá các hàng trùng lặp, hàm này sẽ thực hiện trên các cột được chỉ định - mặc định nó sẽ xem xét tất cả các cột. Như trình bày trong chương loại bỏ trùng lặp, bạn có thể điều chỉnh phạm vi cột để việc khảo sát tính duy nhất của các hàng sẽ chỉ được đánh giá trong phạm vi một số cột nhất định.\nTrong ví dụ đơn giản này, chúng ta chỉ cần thêm câu lệnh trống distinct() vào chuỗi các bước làm sạch. Điều này đảm bảo không có hàng nào là bản sao 100% của các hàng khác (được đánh giá trên tất cả các cột).\nChúng ta bắt đầu với nrow(linelist) hàng trong bộ linelist.\n\nlinelist &lt;- linelist %&gt;% \n  distinct()\n\nSau khi loại bỏ trùng lặp, thì bộ dữ liệu mới có nrow(linelist) hàng. Bất kỳ hàng nào bị xóa cũng có thể là 100% bản sao của các hàng khác.\nDưới đây, lệnh distinct() được thêm vào quy trình làm sạch:\n\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # standardize column name syntax\n    janitor::clean_names() %&gt;% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    #####################################################\n    \n    # de-duplicate\n    distinct()",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#tạo-và-biến-đổi-cột",
    "href": "new_pages/cleaning.vn.html#tạo-và-biến-đổi-cột",
    "title": "8  Làm sạch số liệu và các hàm quan trọng",
    "section": "8.7 Tạo và biến đổi cột",
    "text": "8.7 Tạo và biến đổi cột\nChúng tôi khuyến khích sử dụng hàm mutate() trong package dplyr để thêm một cột mới hoặc để sửa đổi một cột sẵn có.\nDưới đây là một ví dụ về tạo cột mới với hàm mutate(). Cú pháp là: mutate(new_column_name = value or transformation)\nTrong Stata, điều này tương tự như lệnh generate, nhưng hàm mutate() trong R còn có thể được sử dụng để điều chỉnh cột đã tồn tại.\n\nTạo cột mới\nTính năng cơ bản nhất của hàm mutate() là để tạo một cột mới, có thể thấy trong ví dụ dưới đây. Nó tạo một cột mới new_col trong đó giá trị trong mỗi hàng đều là 10.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(new_col = 10)\n\nBạn cũng có thể tham chiếu các giá trị trong các cột khác, để thực hiện phép tính toán. Dưới đây, cột mới bmi được tạo để tính chỉ số khối cơ thể (BMI) cho mỗi trường hợp - như được tính bằng công thức BMI = kg/m^2, sử dụng cột ht_cm và cột wt_kg.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(bmi = wt_kg / (ht_cm/100)^2)\n\nNếu tạo nhiều cột mới, hãy tách riêng từng cột bằng dấu phẩy và dòng mới. Dưới đây là các ví dụ về tạo các cột mới, bao gồm một cột mà chứa các giá trị từ các cột khác được kết hợp bằng hàm str_glue() từ package stringr (xem chương Ký tự và chuỗi).\n\nnew_col_demo &lt;- linelist %&gt;%                       \n  mutate(\n    new_var_dup    = case_id,             # new column = duplicate/copy another existing column\n    new_var_static = 7,                   # new column = all values the same\n    new_var_static = new_var_static + 5,  # you can overwrite a column, and it can be a calculation using other variables\n    new_var_paste  = stringr::str_glue(\"{hospital} on ({date_hospitalisation})\") # new column = pasting together values from other columns\n    ) %&gt;% \n  select(case_id, hospital, date_hospitalisation, contains(\"new\"))        # show only new columns, for demonstration purposes\n\nKiểm tra các cột mới. Đối với mục tiêu minh họa, chỉ các cột mới và các cột được sử dụng để tạo cột mới được hiển thị:\n\n\n\n\n\n\nMẸO: Một biến thể của hàm mutate() là hàm transmute(). Hàm này thêm một cột mới giống như mutate(), nhưng cũng bỏ/xóa tất cả các cột khác mà bạn không đề cập trong dấu ngoặc đơn của hàm.\n\n# HIDDEN FROM READER\n# removes new demo columns created above\n# linelist &lt;- linelist %&gt;% \n#   select(-contains(\"new_var\"))\n\n\n\nĐịnh dạng lại kiểu dữ liệu của cột\nMột số hàm sẽ không chạy được trên các cột chứa giá trị là ngày tháng, số hoặc giá trị logic (TRUE/FALSE) nếu chúng không được định nghĩa chính xác. Có sự khác biệt giữa giá trị “2” của kiểu dữ liệu dạng ký tự và giá trị 2 của kiểu dữ liệu dạng số!\nCó nhiều cách để thiết lập kiểu dữ liệu cho cột khi nhập dữ liệu, nhưng chúng thường phức tạp. Xem chương R cơ bản về kiểu dữ liệu để tìm hiểu thêm về cách chuyển đổi kiểu dữ liệu đối tượng và cột.\nĐầu tiên, hãy kiểm tra các cột quan trọng để xem chúng đã đúng định dạng chính xác chưa. Chúng ta có thể thực hiện điều này bằng hàm skim().\nVí dụ, ở đây kiểu dữ liệu của cột age là dạng ký tự. Để thực hiện các phân tích định lượng, chúng ta cần những giá trị số này được định dạng là dạng số!\n\nclass(linelist$age)\n\n[1] \"character\"\n\n\nTương tự kiểu dữ liệu của cột date_onset cũng là ký tự! Để thực hiện phân tích, những cột ngày này phải được định dạng là dạng ngày tháng!\n\nclass(linelist$date_onset)\n\n[1] \"character\"\n\n\nĐể giải quyết vấn đề này, hãy sử dụng hàm mutate() để định dạng và chuyển đổi lại kiểu dữ liệu cho một cột. Chúng ta giữ nguyên cột đó và định dạng lại sang một kiểu khác. Dưới đây là một ví dụ cơ bản, thực hiện định dạng lại cột age dưới dạng số:\n\nlinelist &lt;- linelist %&gt;% \n  mutate(age = as.numeric(age))\n\nTheo cách tương tự, bạn có thể sử dụng hàm as.character() và hàm as.logical(). Để chuyển đổi sang kiểu danh mục, bạn có thể sử dụng hàm factor() từ base R hoặc hàm as_factor() từ package forcats. Đọc thêm ở chương Factors.\nBạn phải cẩn thận khi định dạng lại cột sang kiểu Ngày, các giải thích chi tiết hơn được đề cập ở chương Làm việc với ngày tháng. Thông thường, tất cả các giá trị ngày ban đầu phải ở cùng một định dạng cần chuyển đổi để có thể sử dụng (ví dụ: “MM/DD/YYYY” hoặc “DD MM YYYY”). Sau khi chuyển đổi thành thành kiểu Ngày, hãy kiểm tra dữ liệu của bạn để xác nhận rằng mỗi giá trị đã được chuyển đổi chính xác.\n\n\nDữ liệu được nhóm\nNếu bộ dữ liệu của bạn đã được nhóm (xem chương Nhóm dữ liệu), hàm mutate() có thể hoạt động khác so với khi bộ dữ liệu không được nhóm. Bất kỳ hàm tổng hợp nào, như mean(), median(), max(), v.v. sẽ tính theo nhóm, không phải theo tất cả các hàng.\n\n# age normalized to mean of ALL rows\nlinelist %&gt;% \n  mutate(age_norm = age / mean(age, na.rm=T))\n\n# age normalized to mean of hospital group\nlinelist %&gt;% \n  group_by(hospital) %&gt;% \n  mutate(age_norm = age / mean(age, na.rm=T))\n\nĐọc thêm về cách sử dụng hàm mutate() trên các bộ dữ liệu được nhóm ở tài liệu về mutate trong package tidyverse.\n\n\nBiến đổi nhiều cột\nThông thường, để viết mã ngắn gọn, bạn muốn áp dụng cùng một biến đổi trên nhiều cột cùng một lúc. Một cách biến đổi có thể được áp dụng trên nhiều cột cùng một lúc bằng cách sử dụng hàm across() từ package dplyr (cũng trong package tidyverse). Hàm across() có thể được sử dụng với bất kỳ hàm nào trong packe dplyr, nhưng thường được sử dụng với hàm select(), mutate(), filter(), hoặc summarise(). Xem cách sử dụng hàm summarise() trong chương Bảng mô tả.\nChỉ định các cột bằng đối số .cols = và các hàm được sử dụng bằng .fns =. Bất kỳ đối số bổ sung nào để cung cấp cho hàm .fns đều có thể được bao gồm sau dấu phẩy, vẫn nằm trong hàm across().\n\nLựa chọn cột với hàm across()\nChỉ định các cột tới đối số .cols =. Bạn có thể đặt tên cho chúng một cách riêng lẻ hoặc sử dụng các hàm trợ giúp “tidyselect”. Cụ thể hàm tới đối số .fns =. Lưu ý rằng cách sử dụng hàm được trình bày bên dưới, hàm được viết mà không có dấu ngoặc đơn ().\nỞ đây, phép biến đổi as.character() được áp dụng cho tên cột cụ thể trong hàm across().\n\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))\n\nCác hàm trợ giúp “tidyselect” có sẵn để hỗ trợ bạn trong việc chỉ định các cột. Chúng được trình bày chi tiết ở trên trong mục Chọn và sắp xếp thứ tự cột, bao gồm: everything(), last_col(), where(), starts_with(), ends_with(), contains(), matches(), num_range() và any_of().\nĐây là một ví dụ về cách thay đổi tất cả các cột thành phân lớp dạng ký tự:\n\n#to change all columns to character class\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = everything(), .fns = as.character))\n\nChuyển đổi tất cả các cột thành dạng ký tự có tên chứa chuỗi ký tự “date” (lưu ý vị trí của dấu phẩy và dấu ngoặc đơn):\n\n#to change all columns to character class\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = contains(\"date\"), .fns = as.character))\n\nDưới đây, một ví dụ về việc thay đổi các cột hiện là phân lớp POSIXct (một kiểu dữ liệu ngày tháng thô hiển thị mốc thời gian) - hay nói cách khác, khi hàm is.POSIXct() đánh giá là TRUE. Sau đó, chúng ta muốn áp dụng hàm as.Date() cho các cột này để chuyển đổi chúng thành kiểu Ngày thông thường.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = where(is.POSIXct), .fns = as.Date))\n\n\nLưu ý rằng trong hàm across(), chúng tôi cũng sử dụng hàm where() tương tự như hàm is.POSIXct được đánh giá là TRUE hoặc FALSE.\n\nLưu ý rằng hàm is.POSIXct() là từ package lubridate. Các hàm “is” tương tự khác như is.character(), is.numeric(), và is.logical() thì thuộc base R\n\n\n\nHàm across()\nBạn có thể đọc tài liệu với hàm ?across để biết chi tiết về cách sử dụng hàm across(). Một vài điểm tóm tắt: có một số cách để chỉ định (các) hàm để thực hiện trên một cột và bạn thậm chí có thể tự chỉ định các hàm riêng của mình:\n\nBạn có thể cung cấp tên hàm đứng một mình (ví dụ: mean hoặc as.character)\n\nBạn có thể cung cấp hàm theo phong cách purrr (ví dụ: ~ mean(.x, na.rm = TRUE)) (xem chương Lặp, vòng lặp, và danh sách)\n\nBạn có thể chỉ định nhiều hàm bằng cách cung cấp danh sách (ví dụ: list(mean = mean, n_miss = ~ sum(is.na(.x))).\nNếu bạn cung cấp nhiều hàm, nhiều cột được chuyển đổi sẽ được trả về dựa trên mỗi cột ban đầu, với các tên duy nhất theo định dạng col_fn. Bạn có thể điều chỉnh cách đặt tên các cột mới với đối số .names = bằng cách sử dụng cú pháp glue (xem chương Ký tự và chuỗi) trong đó {.col} và {.fn} được viết tắt cho cột và hàm đầu vào.\n\nDưới đây là một số tài nguyên trực tuyến về cách sử dụng hàm across(): creator Hadley Wickham’s thoughts/rationale\n\n\n\nHàm coalesce()\nHàm dplyr này tìm giá trị không bị thiếu đầu tiên tại mỗi vị trí. Nó “điền vào” các giá trị còn thiếu với giá trị có sẵn đầu tiên theo thứ tự bạn chỉ định.\nĐây là một ví dụ ngoài phạm vi của bộ dữ liệu: Giả sử bạn có hai vectơ, một vectơ chứa thông tin về làng nơi bệnh nhân được phát hiện và một vectơ chứa thông tin làng nơi bệnh nhân cư trú . Bạn có thể sử dụng hàm coalesce() để chọn giá trị không bị thiếu đầu tiên cho mỗi biến số:\n\nvillage_detection &lt;- c(\"a\", \"b\", NA,  NA)\nvillage_residence &lt;- c(\"a\", \"c\", \"a\", \"d\")\n\nvillage &lt;- coalesce(village_detection, village_residence)\nvillage    # print\n\n[1] \"a\" \"b\" \"a\" \"d\"\n\n\nĐiều này hoạt động tương tự nếu bạn cung cấp các cột trong bộ dữ liệu: đối với mỗi hàng, hàm sẽ gán giá trị cột mới với giá trị không bị thiếu đầu tiên trong các cột bạn đã cung cấp (theo thứ tự được cung cấp).\n\nlinelist &lt;- linelist %&gt;% \n  mutate(village = coalesce(village_detection, village_residence))\n\nĐây là một ví dụ về thao tác “theo hàng (row-wise)”. Để biết các phép tính theo hàng phức tạp hơn, hãy xem chương bên dưới về Tính toán theo hàng.\n\n\nToán lũy tích\nNếu bạn muốn một cột thể hiện tổng tích lũy/trung bình/tối thiểu/tối đa, v.v. như đánh giá các hàng của bộ dữ liệu cho đến thời điểm đó, hãy sử dụng các hàm sau:\ncumsum() trả về tổng tích lũy, như được hiển thị bên dưới:\n\nsum(c(2,4,15,10))     # returns only one number\n\n[1] 31\n\ncumsum(c(2,4,15,10))  # returns the cumulative sum at each step\n\n[1]  2  6 21 31\n\n\nĐiều này có thể được sử dụng trong bộ dữ liệu khi tạo một cột mới. Ví dụ: để tính toán số ca lũy tích mỗi ngày trong một đợt bùng dịch, hãy xem xét đoạn code như sau:\n\ncumulative_case_counts &lt;- linelist %&gt;%  # begin with case linelist\n  count(date_onset) %&gt;%                 # count of rows per day, as column 'n'   \n  mutate(cumulative_cases = cumsum(n))  # new column, of the cumulative sum at each row\n\nDưới đây là 10 hàng đầu tiên:\n\nhead(cumulative_case_counts, 10)\n\n   date_onset n cumulative_cases\n1  2012-04-15 1                1\n2  2012-05-05 1                2\n3  2012-05-08 1                3\n4  2012-05-31 1                4\n5  2012-06-02 1                5\n6  2012-06-07 1                6\n7  2012-06-14 1                7\n8  2012-06-21 1                8\n9  2012-06-24 1                9\n10 2012-06-25 1               10\n\n\nXem chương Đường cong dịch bệnh để biết cách lập biểu đồ các trường hợp mới mắc tích lũy với epicurve.\nXem thêm:\ncumsum(), cummean(), cummin(), cummax(), cumany(), cumall()\n\n\nSử dụng base R\nĐể định nghĩa một cột mới (hoặc tái định nghĩa lại một cột) bằng cách sử dụng base R, hãy viết tên của bộ dữ liệu, được liên kết với $, vào tên cột mới (hoặc cột được sửa đổi). Sử dụng toán tử gán &lt;- để xác định (các) giá trị mới. Hãy nhớ rằng khi sử dụng base R, bạn phải chỉ định tên bộ dữ liệu trước tên cột (ví dụ: dataframe$column). Đây là một ví dụ về cách tạo cột bmi bằng cách sử dụng base R:\n\nlinelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)\n\n\n\nThêm vào chuỗi làm sạch\nCode dưới đây minh hoạt cách thêm một cột mới vào chuỗi làm sạch và định dạng lại kiểu dữ liệu của biến.\n\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # standardize column name syntax\n    janitor::clean_names() %&gt;% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # de-duplicate\n    distinct() %&gt;% \n  \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    ###################################################\n    # add new column\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %&gt;% \n  \n    # convert class of columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age))",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#mã-hóa-lại-giá-trị",
    "href": "new_pages/cleaning.vn.html#mã-hóa-lại-giá-trị",
    "title": "8  Làm sạch số liệu và các hàm quan trọng",
    "section": "8.8 Mã hóa lại giá trị",
    "text": "8.8 Mã hóa lại giá trị\nDưới đây là một số tình huống mà bạn cần mã hóa lại (thay đổi) các giá trị:\n\nđể chỉnh sửa một giá trị cụ thể (ví dụ: một ngày có năm hoặc định dạng không chính xác)\nđể hợp nhất các giá trị được viết sai chính tả\nđể tạo một cột chứa giá trị phân loại mới\nđể tạo một cột chứa danh mục số mới (ví dụ: danh mục độ tuổi)\n\n\nGiá trị cụ thể\nĐể thay đổi các giá trị theo cách thủ công, bạn có thể sử dụng hàm recode() bên trong hàm mutate().\nHãy tưởng tượng có một ngày không bình thường trong dữ liệu (ví dụ: “2014-14-15”): bạn có thể sửa ngày theo cách thủ công trong dữ liệu gốc hoặc, bạn có thể ghi thay đổi trong chuỗi các bước làm sạch thông qua mutate() và recode(). Cách thứ hai sẽ rõ ràng hơn và có thể được tái lập lại cho bất kỳ ai khác muốn hiểu hoặc lặp lại phân tích của bạn.\n\n# fix incorrect values                   # old value       # new value\nlinelist &lt;- linelist %&gt;% \n  mutate(date_onset = recode(date_onset, \"2014-14-15\" = \"2014-04-15\"))\n\nDòng mutate() ở trên có thể được đọc là: “biến đổi cột date_onset bằng với cột date_onset sau khi được mã hóa lại để GIÁ TRỊ CŨ được đổi thành GIÁ TRỊ MỚI”. Lưu ý rằng cú pháp (CŨ = MỚI) này của hàm recode() ngược lại với hầu hết các cú pháp trong R (mới = cũ). Cộng đồng phát triển R đang làm việc để sửa đổi điều này.\nSau đây là một ví dụ khác về việc mã hóa lại nhiều giá trị trong một cột.\nTrong bộ dữ liệu linelist, các giá trị trong cột “hospital” phải được làm sạch. Có một số cách viết khác nhau và nhiều giá trị bị thiếu.\n\ntable(linelist$hospital, useNA = \"always\")  # print table of all unique values, including missing  \n\n\n                     Central Hopital                     Central Hospital \n                                  11                                  457 \n                          Hospital A                           Hospital B \n                                 290                                  289 \n                    Military Hopital                    Military Hospital \n                                  32                                  798 \n                    Mitylira Hopital                    Mitylira Hospital \n                                   1                                   79 \n                               Other                         Port Hopital \n                                 907                                   48 \n                       Port Hospital St. Mark's Maternity Hospital (SMMH) \n                                1756                                  417 \n  St. Marks Maternity Hopital (SMMH)                                 &lt;NA&gt; \n                                  11                                 1512 \n\n\nLệnh recode() bên dưới tái định nghĩa lại cột “hospital” theo cột hiện tại “hospital”, nhưng với các thay đổi mã hóa được chỉ định. Đừng quên dấu phẩy sau mỗi dòng mã hóa lại!\n\nlinelist &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital,\n                     # for reference: OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      ))\n\nBây giờ chúng ta thấy các cách viết trong cột hospital đã được sửa chữa và hợp nhất:\n\ntable(linelist$hospital, useNA = \"always\")\n\n\n                    Central Hospital                           Hospital A \n                                 468                                  290 \n                          Hospital B                    Military Hospital \n                                 289                                  910 \n                               Other                        Port Hospital \n                                 907                                 1804 \nSt. Mark's Maternity Hospital (SMMH)                                 &lt;NA&gt; \n                                 428                                 1512 \n\n\nMẸO: Số lượng khoảng trắng trước và sau dấu bằng không quan trọng. Hãy làm cho code của bạn dễ đọc hơn bằng cách căn chỉnh dấu = cho tất cả hoặc hầu hết các hàng. Ngoài ra, hãy cân nhắc thêm hàng bình luận để làm rõ cho người đọc biết bên nào CŨ và bên nào MỚI.\nMẸO: Đôi khi tồn tại một giá trị ký tự trống trong bộ dữ liệu (không được nhận dạng là giá trị missing của R - NA). Bạn có thể tham chiếu giá trị này bằng hai dấu ngoặc kép không có khoảng trắng ở giữa (““).\n\n\nTheo logic\nDưới đây, chúng ta trình bày cách mã hóa lại các giá trị trong một cột bằng cách sử dụng logic và điều kiện:\n\nSử dụng hàm replace(), ifelse() và if_else() cho logic đơn giản\nSử dụng hàm case_when() cho logic phức tạp\n\n\n\nLogic đơn giản\n\nreplace()\nĐể mã hóa lại với các tiêu chí logic đơn giản, bạn có thể sử dụng hàm replace() bên trong hàm mutate(). replace() là một hàm từ base R. Sử dụng một điều kiện logic để cụ thể các hàng cần thay đổi. Cú pháp chung là:\nmutate(col_to_change = replace(col_to_change, criteria for rows, new value)).\nMột tình huống phổ biến để sử dụng replace() là chỉ thay đổi một giá trị trong một hàng, bằng cách sử dụng định danh hàng duy nhất. Dưới đây, giới tính được thay đổi thành “Female” trong hàng mà cột case_id có giá trị là “2195”.\n\n# Example: change gender of one specific observation to \"Female\" \nlinelist &lt;- linelist %&gt;% \n  mutate(gender = replace(gender, case_id == \"2195\", \"Female\"))\n\nLệnh tương tự sử dụng cú pháp trong base R và dấu ngoặc vuông [] ở bên dưới. Nó có nội dung là “Thay đổi giá trị của cột gender trong bộ dữ liệu linelist (đối với các hàng mà cột case_id của linelist có giá trị ‘2195’) thành ‘Female’”.\n\nlinelist$gender[linelist$case_id == \"2195\"] &lt;- \"Female\"\n\n\n\nifelse() và if_else()\nMột cách khác áp dụng cho logic đơn giản là hàm ifelse() và hàm tương tự là if_else(). Tuy nhiên, trong hầu hết các trường hợp để mã hóa lại, cách rõ ràng hơn là sử dụng hàm case_when() (chi tiết bên dưới). Câu lệnh “if else” này là các phiên bản đơn giản hóa của câu lệnh lập trình if và else. Cú pháp chung là:\nifelse(condition, value to return if condition evaluates to TRUE, value to return if condition evaluates to FALSE)\nDưới đây, cột source_known được định nghĩa. Giá trị của nó trong một hàng được đặt thành “known” nếu giá trị của hàng trong cột source không bị thiếu. Nếu thiếu giá trị trong cột source, thì giá trị trong source_known được đặt thành “unknown”.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(source_known = ifelse(!is.na(source), \"known\", \"unknown\"))\n\nif_else() là một phiên bản đặc biệt từ package dplyr để xử lý ngày tháng. Lưu ý rằng nếu giá trị ‘true’ là một ngày thì giá trị ‘false’ cũng phải đủ điều kiện là một ngày, do đó sử dụng giá trị đặc biệt NA_real_ thay vì chỉ NA.\n\n# Create a date of death column, which is NA if patient has not died.\nlinelist &lt;- linelist %&gt;% \n  mutate(date_death = if_else(outcome == \"Death\", date_outcome, NA_real_))\n\nTránh lồng ghép nhiều lệnh ifelse với nhau… thay vào đó hãy sử dụng case_when()! case_when() dễ đọc hơn và bạn sẽ mắc ít lỗi hơn.\n\n\n\n\n\n\n\n\n\nNgoài phạm vi của bộ dữ liệu, nếu bạn muốn một đối tượng được sử dụng trong code của mình chuyển đổi giá trị của nó, hãy xem xét sử dụng hàm switch() từ base R.\n\n\n\nLogic phức tạp\nSử dụng case_when() của package dplyr nếu bạn đang mã hóa lại thành nhiều nhóm mới hoặc nếu bạn cần sử dụng các câu lệnh logic phức tạp để mã hóa lại các giá trị. Hàm này đánh giá mọi hàng trong bộ dữ liệu, đánh giá xem các hàng có đáp ứng các tiêu chí đã chỉ định hay không và chỉ định giá trị mới chính xác.\nCâu lệnh case_when() bao gồm hai cấu phần là Bên tay Phải (RHS) và Bên tay Trái (LHS) được phân tách bằng “dấu ngã” ~. Các tiêu chí logic nằm ở phía bên trái và các giá trị tương ứng nằm ở phía bên phải của mỗi mệnh đề. Các mệnh đề được phân tách bằng dấu phẩy.\nVí dụ: chúng tôi sử dụng cột age và age_unit để tạo cột age_years:\n\nlinelist &lt;- linelist %&gt;% \n  mutate(age_years = case_when(\n            age_unit == \"years\"  ~ age,       # if unit is years\n            age_unit == \"months\" ~ age/12,    # if unit is months, divide age by 12\n            is.na(age_unit)      ~ age,       # if age unit is missing, assume years\n            TRUE                 ~ NA_real_)) # any other circumstance, assign NA (missing)\n\nKhi mỗi hàng trong dữ liệu được đánh giá, các tiêu chí được áp dụng/đánh giá theo thứ tự đã viết trong case_when() - từ trên xuống dưới. Nếu tiêu chí đánh giá đầu tiên trả kết quả là TRUE cho một hàng nhất định, giá trị Bên tay phải sẽ được gán và các tiêu chí còn lại sẽ không được kiểm tra cho hàng đó. Vì vậy, tốt nhất là bạn nên viết các tiêu chí đánh giá cụ thể nhất lên đầu, theo sau bởi các tiêu chí chung hơn. Các dòng không đáp ứng bất kỳ tiêu chí nào sẽ được gán giá trị NA.\nĐôi khi, bạn muốn gán một giá trị cụ thể cho biến mới mà không thỏa mãn bất kỳ tiêu chí nào, hãy đặt TRUE ở phía bên trái của tiêu chí đánh giá cuối cùng. Phía bên phải của mệnh đề này có thể được gán một giá trị như “kiểm tra tôi! (check me)” hoặc missing.\nDưới đấy là một ví dụ khác sử dụng case_when() để tạo cột mới phân loại tình trạng bệnh nhân, dựa theo định nghĩa ca bệnh là đã xác định hoặc nghi ngờ:\n\nlinelist &lt;- linelist %&gt;% \n     mutate(case_status = case_when(\n          \n          # if patient had lab test and it is positive,\n          # then they are marked as a confirmed case \n          ct_blood &lt; 20                   ~ \"Confirmed\",\n          \n          # given that a patient does not have a positive lab result,\n          # if patient has a \"source\" (epidemiological link) AND has fever, \n          # then they are marked as a suspect case\n          !is.na(source) & fever == \"yes\" ~ \"Suspect\",\n          \n          # any other patient not addressed above \n          # is marked for follow up\n          TRUE                            ~ \"To investigate\"))\n\nNGUY HIỂM: Các giá trị ở phía bên phải đều phải cùng một phần lớp - số, ký tự, ngày tháng, lôgic, v.v. Để gán giá trị thiếu (NA), bạn có thể cần sử dụng các biến thể đặc biệt của NA như NA_character_, NA_real_ (cho số hoặc POSIX) và as.Date(NA). Đọc thêm trong chương Làm việc với ngày tháng.\n\n\nGiá trị missing\nDưới đây là các hàm đặc biệt để xử lý các giá trị bị thiếu trong khi làm sạch dữ liệu.\nXem chương về Dữ liệu Missing để biết thêm các mẹo chi tiết về xác định và xử lý các giá trị bị thiếu. Ví dụ, hàm is.na() kiểm tra một cách logic sự thiếu giá trị.\nreplace_na()\nĐể thay đổi các giá trị bị thiếu (NA) thành một giá trị cụ thể, chẳng hạn như “Missing”, hãy sử dụng hàm replace_na() trong hàm mutate() trong package dplyr. Lưu ý rằng điều này được sử dụng theo cách tương tự như hàm recode ở trên - tên của biến phải được lặp lại trong replace_na().\n\nlinelist &lt;- linelist %&gt;% \n  mutate(hospital = replace_na(hospital, \"Missing\"))\n\nfct_explicit_na()\nĐây là một hàm từ package forcats. Package forcats xử lý các cột dạng Factor. Factor là cách của R để xử lý các giá trị có thứ tự như c(\"First\", \"Second\", \"Third\") hoặc để thiết lập thứ tự cho các giá trị (ví dụ: bệnh viện) xuất hiện trong bảng và biểu đồ. Xem chương Factors.\nNếu dữ liệu của bạn là kiểu Factor và bạn đang cố gắng chuyển giá trị NA thành “Missing” bằng cách sử dụng hàm replace_na(), bạn sẽ gặp lỗi này: invalid factor level, NA generated. Bạn đã cố gắng thêm “Missing” làm giá trị, trong khi nó đã không được xác định là một thứ bậc trong cột Factor, và câu lệnh bị từ chối.\nCách dễ nhất để giải quyết vấn đề này là sử dụng hàm forcats fct_explicit_na() để chuyển đổi một cột thành kiểu Factor và chuyển đổi các giá trị NA thành ký tự “(Missing)”.\n\nlinelist %&gt;% \n  mutate(hospital = fct_explicit_na(hospital))\n\nMột giải pháp thay thế chậm hơn sẽ là thêm thứ bậc cho cột Factor bằng cách sử dụng hàm fct_expand() và sau đó chuyển đổi các giá trị bị thiếu.\nna_if()\nĐể chuyển đổi một giá trị cụ thể thành NA, hãy sử dụng hàm na_if() trong package dplyr. Hàm này thực hiện thao tác ngược lại với hàm replace_na(). Trong ví dụ bên dưới, bất kỳ giá trị nào bị “Missing” trong cột hospital đều được chuyển đổi thành NA.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(hospital = na_if(hospital, \"Missing\"))\n\nLưu ý: na_if() không thể sử dụng cho điều kiện logic (ví dụ: “all values &gt; 99”) - hãy sử dụng replace() hoặc case_when() cho điều này:\n\n# Convert temperatures above 40 to NA \nlinelist &lt;- linelist %&gt;% \n  mutate(temp = replace(temp, temp &gt; 40, NA))\n\n# Convert onset dates earlier than 1 Jan 2000 to missing\nlinelist &lt;- linelist %&gt;% \n  mutate(date_onset = replace(date_onset, date_onset &gt; as.Date(\"2000-01-01\"), NA))\n\n\n\nTừ điển làm sạch\nSử dụng package matchmaker trong R và hàm match_df() để làm sạch bộ dữ liệu bằng từ điển làm sạch.\n\nTạo từ điển làm sạch với 3 cột:\n\nCột “từ” (giá trị không chính xác)\n\nCột “tới” (giá trị chính xác)\n\nMột cột chỉ định cột cho các thay đổi sẽ được áp dụng (hoặc “.global” để áp dụng cho tất cả các cột)\n\n\nLưu ý: các mục từ điển .global sẽ bị ghi đè bởi các mục từ điển theo cột cụ thể.\n\n\n\n\n\n\n\n\n\n\nNạp tệp từ điển vào R. Ví dụ này có thể được tải xuống theo hướng dẫn trong chương Tải sách và dữ liệu.\n\n\ncleaning_dict &lt;- import(\"cleaning_dict.csv\")\n\n\nChuyển bộ dữ liệu linelist ban đầu đến hàm match_df(), xác định dictionary = là bộ dữ liệu từ điển làm sạch. Đối số from = dùng để chỉ định cột trong từ điển tham chiếu chứa các giá trị “cũ”, đối số by = dùng để chỉ định cột trong từ điển tham chiếu chứa các giá trị “mới” tương ứng và cột thứ ba liệt kê cột thực hiện thay đổi. Sử dụng .global trong đối số by = để áp dụng thay đổi trên tất cả các cột. Cột từ điển thứ tư order có thể được sử dụng để chỉ định thức bậc của các giá trị mới.\n\nBạn có thể đọc thêm về hàm ở package documentation bằng cách chạy ?match_df. Lưu ý rằng hàm này có thể mất nhiều thời gian để chạy trên dữ liệu lớn.\n\nlinelist &lt;- linelist %&gt;% \n  matchmaker::match_df(\n          dictionary = cleaning_dict,  # name of your dictionary\n          from = \"from\",               # column with values to be replaced (default is col 1)\n          to = \"to\",                   # column with final values (default is col 2)\n          by = \"col\"                   # column with column names (default is col 3)\n  )\n\nBây giờ, hãy cuộn sang bên phải để xem các giá trị đã thay đổi như thế nào - đặc biệt là gender (chữ thường thành chữ hoa) và tất cả các cột triệu chứng đã được chuyển từ có/không thành 1/0.\n\n\n\n\n\n\nLưu ý rằng tên cột của bạn trong từ điển làm sạch phải tương ứng với tên tại thời điểm trong script làm sạch của bạn. Xem tài liệu tham khảo trực tuyến về package linelist để biết thêm chi tiết.\n\nThêm vào chuỗi làm sạch\nDưới đây, một số cột mới và biến đổi cột được thêm vào chuỗi các bước làm sạch.\n\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # standardize column name syntax\n    janitor::clean_names() %&gt;% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # de-duplicate\n    distinct() %&gt;% \n  \n    # add column\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %&gt;%     \n\n    # convert class of columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %&gt;% \n    \n    # add column: delay to hospitalisation\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %&gt;% \n    \n   # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n   ###################################################\n\n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %&gt;% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %&gt;% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_))",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#num_cats",
    "href": "new_pages/cleaning.vn.html#num_cats",
    "title": "8  Làm sạch số liệu và các hàm quan trọng",
    "section": "8.9 Biến danh mục số",
    "text": "8.9 Biến danh mục số\nỞ đây chúng tôi mô tả một số cách tiếp cận đặc biệt để tạo cột dạng danh mục từ các cột dạng số. Các ví dụ phổ biến bao gồm danh mục độ tuổi, nhóm giá trị trong phòng thí nghiệm, v.v. Ở đây chúng ta sẽ thảo luận:\n\nage_categories(), từ package epikit\n\ncut(), từ base R\n\ncase_when()\n\nChia khoảng phân vị với quantile() and ntile()\n\n\nĐánh giá phân phối\nTrong ví dụ này, chúng tôi sẽ tạo một cột age_cat bằng cách sử dụng cột age_years.\n\n#check the class of the linelist variable age\nclass(linelist$age_years)\n\n[1] \"numeric\"\n\n\nTrước tiên, hãy kiểm tra phân phối dữ liệu của bạn để đưa ra các điểm cắt thích hợp. Xem chương ggplot cơ bản.\n\n# examine the distribution\nhist(linelist$age_years)\n\n\n\n\n\n\n\n\n\nsummary(linelist$age_years, na.rm=T)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00    6.00   13.00   16.04   23.00   84.00     107 \n\n\nCẨN TRỌNG: Đôi khi, các biến số sẽ được nhập vào dưới dạng kiểu “ký tự”. Điều này xảy ra nếu có các ký tự không phải số trong một số giá trị, ví dụ: có bản ghi nhập “2 tháng” cho biến tuổi hoặc (tùy thuộc vào cài đặt ngôn ngữ R của bạn) nếu dấu phẩy được sử dụng cho số thập phân (ví dụ: “4,5”nghĩa là bốn năm rưỡi).\n\n\n\nage_categories()\nVới package epikit, bạn có thể sử dụng hàm age_categories() để dễ dàng phân loại và gắn nhãn các cột dạng số (lưu ý: hàm này cũng có thể được áp dụng cho các biến ngoài biến tuổi). Như một “phần thưởng”, cột trả về tự động là một cột dạng factor có thứ tự.\nDưới đây là các yêu cầu đầu vào:\n\nMột vectơ (cột) dạng số\n\nĐối sốc breakers = - cung cấp một vectơ dạng số của các điểm cắt cho các phân nhóm mới.\n\nĐầu tiên, ví dụ đơn giản nhất:\n\n# Simple example\n################\npacman::p_load(epikit)                    # load package\n\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = age_categories(             # create new column\n      age_years,                            # numeric column to make groups from\n      breakers = c(0, 5, 10, 15, 20,        # break points\n                   30, 40, 50, 60, 70)))\n\n# show table\ntable(linelist$age_cat, useNA = \"always\")\n\n\n  0-4   5-9 10-14 15-19 20-29 30-39 40-49 50-59 60-69   70+  &lt;NA&gt; \n 1227  1223  1048   827  1216   597   251    78    27     7   107 \n\n\nCác giá trị cắt bạn chỉ định mặc định là các giới hạn thấp hơn - nghĩa là chúng được đưa vào nhóm “cao hơn”/các nhóm “mở” ở phía dưới/bên trái. Như trình bày dưới đây, bạn có thể thêm 1 vào mỗi giá trị cắt để đạt được các nhóm mà được “mở” ở trên cùng/bên phải.\n\n# Include upper ends for the same categories\n############################################\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      breakers = c(0, 6, 11, 16, 21, 31, 41, 51, 61, 71)))\n\n# show table\ntable(linelist$age_cat, useNA = \"always\")\n\n\n  0-5  6-10 11-15 16-20 21-30 31-40 41-50 51-60 61-70   71+  &lt;NA&gt; \n 1469  1195  1040   770  1149   547   231    70    24     6   107 \n\n\nBạn có thể điều chỉnh cách hiển thị nhãn bằng separator =. Giá trị mặc định là “-”\nBạn có thể điều chỉnh cách xử lý các số ở hàng đầu, với đối số ceiling =. Thiết lập mức giới hạn cắt trên với ceiling = TRUE. Trong cách sử dụng này, giá trị cắt cao nhất được cung cấp là “ceiling” và danh mục “XX+” không được tạo. Bất kỳ giá trị nào trên giá trị cắt cao nhất (hoặc upper =, nếu được xác định) đều được phân loại là NA. Dưới đây là một ví dụ với ceiling = TRUE, do đó không có danh mục nào là XX + và các giá trị trên 70 (giá trị cắt cao nhất) được chỉ định là NA.\n\n# With ceiling set to TRUE\n##########################\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70),\n      ceiling = TRUE)) # 70 is ceiling, all above become NA\n\n# show table\ntable(linelist$age_cat, useNA = \"always\")\n\n\n  0-4   5-9 10-14 15-19 20-29 30-39 40-49 50-59 60-70  &lt;NA&gt; \n 1227  1223  1048   827  1216   597   251    78    28   113 \n\n\nNgoài ra, thay vì dùng breakers =, bạn có thể sử dụng hàm lower =, upper =, và by =:\n\nlower = Mức giới hạn thấp nhất bạn muốn xem xét - mặc định là 0\n\nupper = Mức giới hạn cao nhất bạn muốn xem xét\n\nby = Khoảng cách “năm” giữa các nhóm\n\n\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      lower = 0,\n      upper = 100,\n      by = 10))\n\n# show table\ntable(linelist$age_cat, useNA = \"always\")\n\n\n  0-9 10-19 20-29 30-39 40-49 50-59 60-69 70-79 80-89 90-99  100+  &lt;NA&gt; \n 2450  1875  1216   597   251    78    27     6     1     0     0   107 \n\n\nXem thêm trang trợ giúp của hàm để biết thêm chi tiết (nhập ?age_categories trong R console).\n\n\n\ncut()\nHàm cut() trong base R là một thay thế cho hàm age_categories(), nhưng tôi nghĩ bạn sẽ thấy lý do tại sao hàm age_categories() được phát triển để đơn giản hóa quá trình này. Một số khác biệt đáng chú ý với hàm age_categories() là:\n\nBạn không cần cài đặt/gọi package khác\n\nBạn có thể chỉ định xem các nhóm được mở/đóng ở bên phải/bên trái\n\nBạn cần phải cung cấp nhãn chính xác\n\nNếu bạn muốn 0 được thêm vào trong nhóm thấp nhất, bạn cần phải cụ thể điều này\n\nCú pháp cơ bản trong cut() trước tiên là cung cấp cột dạng số cần xử lý (age_years), sau đó là đối số break, một vectơ dạng số c() bao gồm các điểm cắt. Sử dụng cut(), kết quả trả về là cột kiểu factor có thứ tự.\nMặc định, việc phân loại xảy ra sao cho phía bên phải/phía trên là “mở” và có tính dung nạp (và phía bên trái/phía dưới là “đóng” hoặc tách biệt). Cách vận hành của hàm này ngược lại với hàm age_categories(). Các nhãn mặc định sử dụng ký hiệu “(A,B]”, có nghĩa là A không được bao gồm nhưng B thì có. Đảo ngược hành động này bằng cách cung cấp đối số right = TRUE.\nDo đó, theo mặc định, các giá trị “0” bị loại trừ khỏi nhóm thấp nhất và được phân loại là NA! Giá trị “0” có thể là trẻ sơ sinh được mã hóa là 0 tuổi, vì vậy hãy thật thận trọng! Để thay đổi điều này, hãy thêm argument include.lowest = TRUE để mọi giá trị “0” sẽ được đưa vào nhóm thấp nhất. Nhãn được tạo tự động cho danh mục thấp nhất sau đó sẽ là “[A],B]”. Lưu ý rằng nếu bạn thêm include.lowest = TRUE và right = TRUE, hành động này bây giờ sẽ áp dụng cho điểm cắt giá trị cao nhất và phân loại, không phải điểm thấp nhất.\nBạn có thể cung cấp một vectơ nhãn tùy chỉnh bằng cách sử dụng argument labels =. Vì chúng được viết theo cách thủ công, hãy rất cẩn thận để đảm bảo chúng chính xác! Kiểm tra bằng cách lập bảng chéo, như được mô tả bên dưới.\nDưới đây là một ví dụ về hàm cut() được áp dụng cho biến age_years để tạo biến age_cat mới:\n\n# Create new variable, by cutting the numeric age variable\n# lower break is excluded but upper break is included in each category\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = cut(\n      age_years,\n      breaks = c(0, 5, 10, 15, 20,\n                 30, 50, 70, 100),\n      include.lowest = TRUE         # include 0 in lowest group\n      ))\n\n# tabulate the number of observations per group\ntable(linelist$age_cat, useNA = \"always\")\n\n\n   [0,5]   (5,10]  (10,15]  (15,20]  (20,30]  (30,50]  (50,70] (70,100] \n    1469     1195     1040      770     1149      778       94        6 \n    &lt;NA&gt; \n     107 \n\n\nKiểm tra đoạn code của bạn!!! Hãy chắc chắn rằng mỗi giá trị độ tuổi đã được chỉ định đúng danh mục bằng cách lập bảng chéo giữa các cột số và danh mục. Kiểm tra việc gán các giá trị ranh giới (ví dụ: 15, nếu các danh mục lân cận là 10-15 và 16-20).\n\n# Cross tabulation of the numeric and category columns. \ntable(\"Numeric Values\" = linelist$age_years,   # names specified in table for clarity.\n      \"Categories\"     = linelist$age_cat,\n      useNA = \"always\")                        # don't forget to examine NA values\n\n                    Categories\nNumeric Values       [0,5] (5,10] (10,15] (15,20] (20,30] (30,50] (50,70]\n  0                    136      0       0       0       0       0       0\n  0.0833333333333333     1      0       0       0       0       0       0\n  0.25                   2      0       0       0       0       0       0\n  0.333333333333333      6      0       0       0       0       0       0\n  0.416666666666667      1      0       0       0       0       0       0\n  0.5                    6      0       0       0       0       0       0\n  0.583333333333333      3      0       0       0       0       0       0\n  0.666666666666667      3      0       0       0       0       0       0\n  0.75                   3      0       0       0       0       0       0\n  0.833333333333333      1      0       0       0       0       0       0\n  0.916666666666667      1      0       0       0       0       0       0\n  1                    275      0       0       0       0       0       0\n  1.5                    2      0       0       0       0       0       0\n  2                    308      0       0       0       0       0       0\n  3                    246      0       0       0       0       0       0\n  4                    233      0       0       0       0       0       0\n  5                    242      0       0       0       0       0       0\n  6                      0    241       0       0       0       0       0\n  7                      0    256       0       0       0       0       0\n  8                      0    239       0       0       0       0       0\n  9                      0    245       0       0       0       0       0\n  10                     0    214       0       0       0       0       0\n  11                     0      0     220       0       0       0       0\n  12                     0      0     224       0       0       0       0\n  13                     0      0     191       0       0       0       0\n  14                     0      0     199       0       0       0       0\n  15                     0      0     206       0       0       0       0\n  16                     0      0       0     186       0       0       0\n  17                     0      0       0     164       0       0       0\n  18                     0      0       0     141       0       0       0\n  19                     0      0       0     130       0       0       0\n  20                     0      0       0     149       0       0       0\n  21                     0      0       0       0     158       0       0\n  22                     0      0       0       0     149       0       0\n  23                     0      0       0       0     125       0       0\n  24                     0      0       0       0     144       0       0\n  25                     0      0       0       0     107       0       0\n  26                     0      0       0       0     100       0       0\n  27                     0      0       0       0     117       0       0\n  28                     0      0       0       0      85       0       0\n  29                     0      0       0       0      82       0       0\n  30                     0      0       0       0      82       0       0\n  31                     0      0       0       0       0      68       0\n  32                     0      0       0       0       0      84       0\n  33                     0      0       0       0       0      78       0\n  34                     0      0       0       0       0      58       0\n  35                     0      0       0       0       0      58       0\n  36                     0      0       0       0       0      33       0\n  37                     0      0       0       0       0      46       0\n  38                     0      0       0       0       0      45       0\n  39                     0      0       0       0       0      45       0\n  40                     0      0       0       0       0      32       0\n  41                     0      0       0       0       0      34       0\n  42                     0      0       0       0       0      26       0\n  43                     0      0       0       0       0      31       0\n  44                     0      0       0       0       0      24       0\n  45                     0      0       0       0       0      27       0\n  46                     0      0       0       0       0      25       0\n  47                     0      0       0       0       0      16       0\n  48                     0      0       0       0       0      21       0\n  49                     0      0       0       0       0      15       0\n  50                     0      0       0       0       0      12       0\n  51                     0      0       0       0       0       0      13\n  52                     0      0       0       0       0       0       7\n  53                     0      0       0       0       0       0       4\n  54                     0      0       0       0       0       0       6\n  55                     0      0       0       0       0       0       9\n  56                     0      0       0       0       0       0       7\n  57                     0      0       0       0       0       0       9\n  58                     0      0       0       0       0       0       6\n  59                     0      0       0       0       0       0       5\n  60                     0      0       0       0       0       0       4\n  61                     0      0       0       0       0       0       2\n  62                     0      0       0       0       0       0       1\n  63                     0      0       0       0       0       0       5\n  64                     0      0       0       0       0       0       1\n  65                     0      0       0       0       0       0       5\n  66                     0      0       0       0       0       0       3\n  67                     0      0       0       0       0       0       2\n  68                     0      0       0       0       0       0       1\n  69                     0      0       0       0       0       0       3\n  70                     0      0       0       0       0       0       1\n  72                     0      0       0       0       0       0       0\n  73                     0      0       0       0       0       0       0\n  76                     0      0       0       0       0       0       0\n  84                     0      0       0       0       0       0       0\n  &lt;NA&gt;                   0      0       0       0       0       0       0\n                    Categories\nNumeric Values       (70,100] &lt;NA&gt;\n  0                         0    0\n  0.0833333333333333        0    0\n  0.25                      0    0\n  0.333333333333333         0    0\n  0.416666666666667         0    0\n  0.5                       0    0\n  0.583333333333333         0    0\n  0.666666666666667         0    0\n  0.75                      0    0\n  0.833333333333333         0    0\n  0.916666666666667         0    0\n  1                         0    0\n  1.5                       0    0\n  2                         0    0\n  3                         0    0\n  4                         0    0\n  5                         0    0\n  6                         0    0\n  7                         0    0\n  8                         0    0\n  9                         0    0\n  10                        0    0\n  11                        0    0\n  12                        0    0\n  13                        0    0\n  14                        0    0\n  15                        0    0\n  16                        0    0\n  17                        0    0\n  18                        0    0\n  19                        0    0\n  20                        0    0\n  21                        0    0\n  22                        0    0\n  23                        0    0\n  24                        0    0\n  25                        0    0\n  26                        0    0\n  27                        0    0\n  28                        0    0\n  29                        0    0\n  30                        0    0\n  31                        0    0\n  32                        0    0\n  33                        0    0\n  34                        0    0\n  35                        0    0\n  36                        0    0\n  37                        0    0\n  38                        0    0\n  39                        0    0\n  40                        0    0\n  41                        0    0\n  42                        0    0\n  43                        0    0\n  44                        0    0\n  45                        0    0\n  46                        0    0\n  47                        0    0\n  48                        0    0\n  49                        0    0\n  50                        0    0\n  51                        0    0\n  52                        0    0\n  53                        0    0\n  54                        0    0\n  55                        0    0\n  56                        0    0\n  57                        0    0\n  58                        0    0\n  59                        0    0\n  60                        0    0\n  61                        0    0\n  62                        0    0\n  63                        0    0\n  64                        0    0\n  65                        0    0\n  66                        0    0\n  67                        0    0\n  68                        0    0\n  69                        0    0\n  70                        0    0\n  72                        1    0\n  73                        3    0\n  76                        1    0\n  84                        1    0\n  &lt;NA&gt;                      0  107\n\n\nGán nhãn giá trị NA\nBạn có thể muốn gán nhãn cho các giá trị NA chẳng hạn như “Missing”. Bởi vì cột mới có kiểu Factor (số giá trị bị hạn chế), bạn không thể chỉ đơn giản thay đổi nó bằng replace_na(), vì giá trị này sẽ không được chấp nhận. Thay vào đó, hãy sử dụng hàm fct_explicit_na() từ package forcats như được giải thích trong chương Factors.\n\nlinelist &lt;- linelist %&gt;% \n  \n  # cut() creates age_cat, automatically of class Factor      \n  mutate(age_cat = cut(\n    age_years,\n    breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          \n    right = FALSE,\n    include.lowest = TRUE,        \n    labels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\", \"20-29\", \"30-49\", \"50-69\", \"70-100\")),\n         \n    # make missing values explicit\n    age_cat = fct_explicit_na(\n      age_cat,\n      na_level = \"Missing age\")  # you can specify the label\n  )    \n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `age_cat = fct_explicit_na(age_cat, na_level = \"Missing age\")`.\nCaused by warning:\n! `fct_explicit_na()` was deprecated in forcats 1.0.0.\nℹ Please use `fct_na_value_to_level()` instead.\n\n# table to view counts\ntable(linelist$age_cat, useNA = \"always\")\n\n\n        0-4         5-9       10-14       15-19       20-29       30-49 \n       1227        1223        1048         827        1216         848 \n      50-69      70-100 Missing age        &lt;NA&gt; \n        105           7         107           0 \n\n\nTạo nhanh điểm cắt và dán nhãn\nĐể nhanh chóng tạo điểm cắt và gắn nhãn vectơ, hãy thực hành như bên dưới. Xem chương R cơ bản về hàm seq() và rep().\n\n# Make break points from 0 to 90 by 5\nage_seq = seq(from = 0, to = 90, by = 5)\nage_seq\n\n# Make labels for the above categories, assuming default cut() settings\nage_labels = paste0(age_seq + 1, \"-\", age_seq + 5)\nage_labels\n\n# check that both vectors are the same length\nlength(age_seq) == length(age_labels)\n\nĐọc thêm về hàm cut() trong trang Trợ giúp của hàm bằng cách nhập ?cut trong R console.\n\n\nChia khoảng phân vị\nTheo cách hiểu thông thường, “phân vị” hoặc “phần trăm” thường đề cập đến một giá trị dưới ngưỡng tỷ lệ đang được đề cập. Ví dụ: phân vị thứ thứ 95 của biến độ tuổi trong linelist sẽ là các độ tuổi dưới 95% độ tuổi.\nTuy nhiên, trong cách nói thông thường, “tứ phân vị” và “thập phân vị” cũng có thể đề cập đến phân nhóm dữ liệu được chia đều thành 4 hoặc 10 nhóm (lưu ý sẽ có thêm một điểm cắt so với số nhóm).\nĐể nhận biết điểm cắt của khoảng phân vị, bạn có thể sử dụng hàm quantile() từ package stats trong base R. Bạn cung cấp một vectơ số (ví dụ: một cột trong bộ dữ liệu) và vectơ các giá trị xác suất số từ 0 đến 1. Các điểm cắt được trả về dưới dạng một vectơ số. Đọc thêm chi tiết các phương pháp thống kê bằng cách nhập ?quantile.\n\nNếu vectơ số đầu vào của bạn có bất kỳ giá trị nào bị thiếu, tốt nhất nên thiết lập na.rm = TRUE\n\nThiết lậpnames = FALSE để lấy một vectơ số chưa được đặt tên\n\n\nquantile(linelist$age_years,               # specify numeric vector to work on\n  probs = c(0, .25, .50, .75, .90, .95),   # specify the percentiles you want\n  na.rm = TRUE)                            # ignore missing values \n\n 0% 25% 50% 75% 90% 95% \n  0   6  13  23  33  41 \n\n\nBạn có thể sử dụng kết quả của quantile() làm điểm cắt trong age_categories() hoặc cut(). Dưới đây, chúng ta tạo một cột deciles mới bằng cách sử dụng hàm cut() trong đó các dấu ngắt được xác định bằng cách sử dụng hàm quantiles() trên cột age_years. Sau đó, chúng ta hiển thị kết quả bằng hàm tabyl() từ package janitor để bạn có thể xem tỷ lệ phần trăm (xem chương Bảng mô tả). Lưu ý rằng chúng không chính xác là 10% trong mỗi nhóm.\n\nlinelist %&gt;%                                # begin with linelist\n  mutate(deciles = cut(age_years,           # create new column decile as cut() on column age_years\n    breaks = quantile(                      # define cut breaks using quantile()\n      age_years,                               # operate on age_years\n      probs = seq(0, 1, by = 0.1),             # 0.0 to 1.0 by 0.1\n      na.rm = TRUE),                           # ignore missing values\n    include.lowest = TRUE)) %&gt;%             # for cut() include age 0\n  janitor::tabyl(deciles)                   # pipe to table to display\n\n deciles   n    percent valid_percent\n   [0,2] 748 0.11319613    0.11505922\n   (2,5] 721 0.10911017    0.11090601\n   (5,7] 497 0.07521186    0.07644978\n  (7,10] 698 0.10562954    0.10736810\n (10,13] 635 0.09609564    0.09767728\n (13,17] 755 0.11425545    0.11613598\n (17,21] 578 0.08746973    0.08890940\n (21,26] 625 0.09458232    0.09613906\n (26,33] 596 0.09019370    0.09167820\n (33,84] 648 0.09806295    0.09967697\n    &lt;NA&gt; 107 0.01619249            NA\n\n\n\n\nNhóm có khoảng đều\nMột công cụ khác để tạo nhóm dạng số là hàm ntile() trong package dplyr, cố gắng chia dữ liệu của bạn thành n nhóm có khoảng cách đều - nhưng lưu ý rằng không giống như với quantile(), cùng một giá trị có thể xuất hiện trong nhiều nhóm. Cung cấp vectơ số và sau đó là số lượng nhóm. Các giá trị trong cột mới được tạo chỉ là nhóm “số” (ví dụ: 1 đến 10), không phải phạm vi giá trị như khi sử dụng hàm cut().\n\n# make groups with ntile()\nntile_data &lt;- linelist %&gt;% \n  mutate(even_groups = ntile(age_years, 10))\n\n# make table of counts and proportions by group\nntile_table &lt;- ntile_data %&gt;% \n  janitor::tabyl(even_groups)\n  \n# attach min/max values to demonstrate ranges\nntile_ranges &lt;- ntile_data %&gt;% \n  group_by(even_groups) %&gt;% \n  summarise(\n    min = min(age_years, na.rm=T),\n    max = max(age_years, na.rm=T)\n  )\n\nWarning: There were 2 warnings in `summarise()`.\nThe first warning was:\nℹ In argument: `min = min(age_years, na.rm = T)`.\nℹ In group 11: `even_groups = NA`.\nCaused by warning in `min()`:\n! no non-missing arguments to min; returning Inf\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\n# combine and print - note that values are present in multiple groups\nleft_join(ntile_table, ntile_ranges, by = \"even_groups\")\n\n even_groups   n    percent valid_percent min  max\n           1 651 0.09851695    0.10013844   0    2\n           2 650 0.09836562    0.09998462   2    5\n           3 650 0.09836562    0.09998462   5    7\n           4 650 0.09836562    0.09998462   7   10\n           5 650 0.09836562    0.09998462  10   13\n           6 650 0.09836562    0.09998462  13   17\n           7 650 0.09836562    0.09998462  17   21\n           8 650 0.09836562    0.09998462  21   26\n           9 650 0.09836562    0.09998462  26   33\n          10 650 0.09836562    0.09998462  33   84\n          NA 107 0.01619249            NA Inf -Inf\n\n\n\n\n\ncase_when()\nCó thể sử dụng hàm case_when() từ dplyr để tạo biến danh mục từ cột số, tuy nhiên điều này được thực hiện dễ dàng hơn với hàm age_categories() từ epikit hoặc cut() vì chúng sẽ tự động tạo ra một biến factor có thứ tự.\nNếu sử dụng case_when(), vui lòng xem lại cách sử dụng thích hợp như đã mô tả trước đó trong mục Mã hóa lại giá trị. Cũng lưu ý rằng tất cả các giá trị bên tay phải phải thuộc cùng một kiểu. Do đó, nếu bạn muốn giá trị NA ở phía bên phải, bạn nên viết “Missing” hoặc sử dụng giá trị NA đặc biệt là NA_character_.\n\n\nThêm vào chuỗi làm sạch\nDưới đây, code để tạo hai cột phân loại tuổi được thêm vào chuỗi các bước làm sạch:\n\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # standardize column name syntax\n    janitor::clean_names() %&gt;% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # de-duplicate\n    distinct() %&gt;% \n\n    # add column\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %&gt;%     \n\n    # convert class of columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %&gt;% \n    \n    # add column: delay to hospitalisation\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %&gt;% \n    \n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %&gt;% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %&gt;% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age)) %&gt;%\n  \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    ###################################################   \n    mutate(\n          # age categories: custom\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # age categories: 0 to 85 by 5s\n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#thêm-hàng",
    "href": "new_pages/cleaning.vn.html#thêm-hàng",
    "title": "8  Làm sạch số liệu và các hàm quan trọng",
    "section": "8.10 Thêm hàng",
    "text": "8.10 Thêm hàng\n\nThêm từng hàng một\nViệc thêm từng hàng một theo cách thủ công là rất nhàm chán nhưng có thể được thực hiện với hàm add_row() từ package dplyr. Hãy nhớ rằng mỗi cột chỉ được chứa các giá trị của một phân lớp (ký tự, số, lôgic, v.v.). Vì vậy, khi thêm một hàng cần chú ý tới điều này.\n\nlinelist &lt;- linelist %&gt;% \n  add_row(row_num = 666,\n          case_id = \"abc\",\n          generation = 4,\n          `infection date` = as.Date(\"2020-10-10\"),\n          .before = 2)\n\nSử dụng .before và .after. để cụ thể vị trí của hàng bạn muốn thêm. .before = 3 sẽ cho phép hàng mới được thêm trước hàng thứ 3 hiện tại. Mặc định thì hàng sẽ được thêm vào dòng cuối cùng. Các cột không được chỉ định sẽ được để trống (NA).\nSố thứ tự hàng mới có thể trông lạ (“… 23”) nhưng số thứ tự hàng trong các hàng tồn tại trước đó đã thay đổi. Vì vậy, nếu sử dụng lệnh hai lần, hãy kiểm tra/thử việc chèn một cách cẩn thận.\nNếu một phân lớp bạn cung cấp không hoạt động, bạn sẽ thấy báo lỗi như sau:\nError: Can't combine ..1$infection date &lt;date&gt; and ..2$infection date &lt;character&gt;.\n(khi chèn một hàng có giá trị ngày tháng, hãy nhớ đặt thông tin as.Date() ví dụ như as.Date(\"2020-10-10\")).\n\n\nNối các hàng\nĐể kết hợp các bộ dữ liệu với nhau bằng cách liên kết các hàng của một bộ dữ liệu này với phần cuối bộ dữ liệu khác, bạn có thể sử dụng hàm bind_rows() từ dplyr. Điều này được giải thích chi tiết hơn trong chương Nối dữ liệu.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#lọc-hàng",
    "href": "new_pages/cleaning.vn.html#lọc-hàng",
    "title": "8  Làm sạch số liệu và các hàm quan trọng",
    "section": "8.11 Lọc hàng",
    "text": "8.11 Lọc hàng\nBước làm sạch điển hình sau khi bạn đã làm sạch các cột và các giá trị được mã hóa lại đó là lọc bộ dữ liệu cho các hàng cụ thể bằng cách sử dụng hàm filter() trong package dplyr.\nTrong hàm filter(), hãy cụ thể điều kiện logic phải là giá trị TRUE cho một hàng được giữ trong bộ dữ liệu. Dưới đây chúng tôi trình bày cách lọc hàng dựa trên điều kiện logic đơn giản và phức tạp.\n\n\nLọc đơn giản\nVí dụ đơn giản này định nghĩa lại bộ dữ liệu linelist, đã lọc các hàng để đáp ứng điều kiện logic. Chỉ những hàng mà câu lệnh logic trong dấu ngoặc đơn đánh giá là TRUE mới được giữ lại.\nTrong ví dụ này, câu lệnh logic là gender == \"f\", được hỏi liệu giá trị trong cột gender có bằng “f” (phân biệt chữ hoa chữ thường) hay không.\nTrước khi bộ lọc được áp dụng, số hàng trong linelist là nrow(linelist).\n\nlinelist &lt;- linelist %&gt;% \n  filter(gender == \"f\")   # keep only rows where gender is equal to \"f\"\n\nSau khi bộ lọc được áp dụng, số hàng trong linelist là linelist %&gt;% filter(gender == \"f\") %&gt;% nrow().\n\n\nLọc bỏ các giá trị missing\nMột điều khá phổ biến là bạn muốn lọc bỏ các hàng có giá trị missing. Hãy bỏ qua cách lọc cổ điển filter(!is.na(column) & !is.na(column)) và thay vào đó, hãy sử dụng hàm drop_na() trong package tidyr được xây dựng để tùy chỉnh cho mục đích này. Nếu chạy với dấu ngoặc trống, nó sẽ loại bỏ các hàng có bất kỳ giá trị nào bị missing. Ngoài ra, bạn có thể cung cấp tên của các cột cụ thể sẽ được đánh giá về mức độ missing hoặc sử dụng các hàm trợ giúp “tidyselect” như được mô tả ở trên.\n\nlinelist %&gt;% \n  drop_na(case_id, age_years)  # drop rows with missing values for case_id or age_years\n\nXem chương về Dữ liệu Missing để biết nhiều kỹ thuật phân tích và quản lý dữ liệu missing.\n\n\nLọc bằng số thứ tự của hàng\nTrong một data frame hoặc tibble, mỗi hàng thường sẽ có một “số thứ tự” (khi xem trong R Viewer) xuất hiện ở bên trái của cột đầu tiên. Bản thân nó không phải là một cột trong dữ liệu, nhưng nó có thể được sử dụng trong câu lệnh filter().\nĐể lọc dựa trên “số thứ tự của hàng”, bạn có thể sử dụng hàm dplyr row_number() với “dấu ngoặc đơn mở” như một phần của câu lệnh lọc logic. Thường thì bạn sẽ sử dụng toán tử %in% và một dãy số như một phần của câu lệnh logic đó, như được trình bày bên dưới. Để xem N hàng đầu tiên, bạn cũng có thể sử dụng hàm đặc biệt head() trong package dplyr.\n\n# View first 100 rows\nlinelist %&gt;% head(100)     # or use tail() to see the n last rows\n\n# Show row 5 only\nlinelist %&gt;% filter(row_number() == 5)\n\n# View rows 2 through 20, and three specific columns\nlinelist %&gt;% filter(row_number() %in% 2:20) %&gt;% select(date_onset, outcome, age)\n\nBạn cũng có thể chuyển đổi số thứ tự hàng thành cột bằng cách sử dụng hàm tibble rownames_to_column() (không viết bất kỳ ký tự nào trong dấu ngoặc đơn).\n\n\n\nLọc phức tạp\nCác câu lệnh logic phức tạp hơn có thể được xây dựng bằng cách sử dụng các toán tử ngoặc đơn ( ), HOẶC |, PHỦ ĐỊNH !, %in%, và VÀ &. Dưới đây là một ví dụ:\nLưu ý: Bạn có thể sử dụng ! trước một mệnh đề logic để phủ định nó. Ví dụ, !is.na(column) trả về giá trị TRUE nếu cột đó không bị thiếu giá trị. Tương tự như vậy !column %in% c(\"a\", \"b\", \"c\") trả về kết quả là TRUE nếu giá trị cột không có trong vectơ.\n\nKiểm tra dữ liệu\nDưới đây là một dòng lệnh đơn giản để tạo biểu đồ các ngày bắt đầu. Chúng ta thấy rằng có một đợt bùng phát nhỏ thứ hai từ năm 2012-2013 cũng được bao gồm trong tập bộ dữ liệu gốc này. Trong các phân tích, chúng ta muốn xóa các bản ghi từ đợt bùng phát sớm.\n\nhist(linelist$date_onset, breaks = 50)\n\n\n\n\n\n\n\n\n\n\nCách lọc và xử lý các giá trị số và ngày bị missing\nChúng ta có thể chỉ lọc theo date_onset đến những hàng sau tháng 6 năm 2013 không? Lưu ý! Việc áp dụng code filter(date_onset &gt; as.Date(\"2013-06-01\"))) sẽ xóa bất kỳ hàng nào trong đợt dịch sau đó có ngày bắt đầu bị thiếu!\nNGUY HIỂM: Việc lọc với điều kiện lớn hơn (&gt;) hoặc nhỏ hơn (&lt;) một ngày hoặc số có thể loại bỏ bất kỳ hàng nào có giá trị bị thiếu (NA)! Điều này là do NA được coi là giá trị lớn hoặc nhỏ vô hạn.\n(Xem chương Làm việc với ngày tháng để biết thêm thông tin về cách xử lý với ngày tháng và package lubridate)\n\n\nThiết kế bộ lọc\nLập một bảng chéo để đảm bảo rằng chúng ta chỉ loại bỏ các hàng cần loại bỏ:\n\ntable(Hospital  = linelist$hospital,                     # hospital name\n      YearOnset = lubridate::year(linelist$date_onset),  # year of date_onset\n      useNA     = \"always\")                              # show missing values\n\n                                      YearOnset\nHospital                               2012 2013 2014 2015 &lt;NA&gt;\n  Central Hospital                        0    0  351   99   18\n  Hospital A                            229   46    0    0   15\n  Hospital B                            227   47    0    0   15\n  Military Hospital                       0    0  676  200   34\n  Missing                                 0    0 1117  318   77\n  Other                                   0    0  684  177   46\n  Port Hospital                           9    1 1372  347   75\n  St. Mark's Maternity Hospital (SMMH)    0    0  322   93   13\n  &lt;NA&gt;                                    0    0    0    0    0\n\n\nLiệu chúng ta có thể lọc theo tiêu chí nào khác để loại bỏ đợt bùng phát đầu tiên (trong năm 2012 & 2013) khỏi bộ dữ liệu? Chúng ta thấy rằng:\n\nVụ dịch đầu tiên năm 2012 & 2013 xảy ra tại Hospital A, Hospital B, tại Port Hospital cũng có 10 trường hợp mắc.\n\nHospital A & B không có ca bệnh nào trong đợt dịch thứ hai, nhưng Port Hospital thì có.\n\nChúng ta muốn loại bỏ:\n\nCác dòng nrow(linelist %&gt;% filter(hospital %in% c(\"Hospital A\", \"Hospital B\") | date_onset &lt; as.Date(\"2013-06-01\"))) bắt đầu vào năm 2012 và 2013 tại Hospital A, B hoặc Port Hospital:\n\nLoại trừ các hàng nrow(linelist %&gt;% filter(date_onset &lt; as.Date(\"2013-06-01\"))) bắt đầu vào năm 2012 và 2013\nLoại trừ các hàng nrow(linelist %&gt;% filter(hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset))) từ Hospital A và B với các giá trị ngày bị thiếu\n\nKhông loại bỏ các dòng khác nrow(linelist %&gt;% filter(!hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset))) bị thiếu ngày bắt đầu.\n\n\nChúng ta bắt đầu với linelist bằng câu lệnh nrow(linelist). Đây là toàn bộ câu lệnh lọc của chúng ta:\n\nlinelist &lt;- linelist %&gt;% \n  # keep rows where onset is after 1 June 2013 OR where onset is missing and it was a hospital OTHER than Hospital A or B\n  filter(date_onset &gt; as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))\n\nnrow(linelist)\n\n[1] 6019\n\n\nKhi chúng ta lập lại bảng chéo, chúng ta thấy rằng Hospital A & B bị loại bỏ hoàn toàn, và 10 trường hợp của Port Hospital từ năm 2012 & 2013 bị loại bỏ và tất cả các giá trị khác đều tương tự - đúng như ý chúng ta muốn.\n\ntable(Hospital  = linelist$hospital,                     # hospital name\n      YearOnset = lubridate::year(linelist$date_onset),  # year of date_onset\n      useNA     = \"always\")                              # show missing values\n\n                                      YearOnset\nHospital                               2014 2015 &lt;NA&gt;\n  Central Hospital                      351   99   18\n  Military Hospital                     676  200   34\n  Missing                              1117  318   77\n  Other                                 684  177   46\n  Port Hospital                        1372  347   75\n  St. Mark's Maternity Hospital (SMMH)  322   93   13\n  &lt;NA&gt;                                    0    0    0\n\n\nNhiều biểu thức có thể được bao hàm trong một lệnh lọc (được phân tách bằng dấu phẩy) hoặc bạn luôn có thể viết chúng riêng biệt và nối tiếp nhau trong chuỗi các bước làm sạch để rõ ràng hơn.\nGhi chú: một số độc giả có thể nhận thấy rằng sẽ dễ dàng hơn nếu chỉ lọc theo date_hospitalisation vì nó hoàn chỉnh 100% mà không có giá trị nào bị thiếu. Đây là sự thật. Nhưng date_onset được sử dụng cho mục đích thể hiện sự phức tạp của việc lọc.\n\n\n\nĐộc lập\nViệc lọc cũng có thể được thực hiện như một lệnh độc lập (không phải là một phần của chuỗi các bước làm sạch). Giống như các hàm dplyr khác, trong trường hợp này, đối số đầu tiên phải chính là bộ dữ liệu.\n\n# dataframe &lt;- filter(dataframe, condition(s) for rows to keep)\n\nlinelist &lt;- filter(linelist, !is.na(case_id))\n\nBạn cũng có thể sử dụng base R để chia nhỏ dữ liệu bằng cách sử dụng dấu ngoặc đểm tham chiếu tới [hàng, cột] mà bạn muốn giữ lại.\n\n# dataframe &lt;- dataframe[row conditions, column conditions] (blank means keep all)\n\nlinelist &lt;- linelist[!is.na(case_id), ]\n\n\n\nXem nhanh các bản ghi\nThường thì bạn muốn xem nhanh một vài bản ghi, chỉ cho một vài cột. Hàm View() trong base R sẽ hiển thị một khung dữ liệu để xem trong RStudio.\nXem linelist trong RStudio:\n\nView(linelist)\n\nDưới đây là hai ví dụ về việc xem các ô cụ thể (hàng cụ thể và cột cụ thể):\nVới hàm filter() và select() trong dplyr:\nVới hàm View(), chuyển tiếp bộ dữ liệu đến hàm filter() để giữ các hàng nhất định và sau đó select() để giữ các cột nhất định. Ví dụ, để xem xét ngày khởi phát và nhập viện của 3 trường hợp cụ thể:\n\nView(linelist %&gt;%\n       filter(case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\")) %&gt;%\n       select(date_onset, date_hospitalisation))\n\nBạn có thể đạt được điều tương tự với cú pháp trong base R, sử dụng dấu ngoặc [ ] cho tập hợp con bạn muốn xem.\n\nView(linelist[linelist$case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\"), c(\"date_onset\", \"date_hospitalisation\")])\n\n\nThêm vào chuỗi làm sạch\n\n# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)\n##################################################################################\n\n# begin cleaning pipe chain\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # standardize column name syntax\n    janitor::clean_names() %&gt;% \n    \n    # manually re-name columns\n           # NEW name             # OLD name\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # remove column\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # de-duplicate\n    distinct() %&gt;% \n\n    # add column\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %&gt;%     \n\n    # convert class of columns\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %&gt;% \n    \n    # add column: delay to hospitalisation\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %&gt;% \n    \n    # clean values of hospital column\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %&gt;% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %&gt;% \n\n    # create age_years column (from age and age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age)) %&gt;%\n  \n    mutate(\n          # age categories: custom\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # age categories: 0 to 85 by 5s\n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5))) %&gt;% \n    \n    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED\n    ###################################################\n    filter(\n          # keep only rows where case_id is not missing\n          !is.na(case_id),  \n          \n          # also filter to keep only the second outbreak\n          date_onset &gt; as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#tính-toán-theo-hàng",
    "href": "new_pages/cleaning.vn.html#tính-toán-theo-hàng",
    "title": "8  Làm sạch số liệu và các hàm quan trọng",
    "section": "8.12 Tính toán theo hàng",
    "text": "8.12 Tính toán theo hàng\nNếu bạn muốn thực hiện một phép tính trong một hàng, bạn có thể sử dụng hàm rowwise() từ dplyr. Xem chi tiết tại row-wise calculations.\nVí dụ: code này sử dụng hàm rowwise() và sau đó tạo một cột mới là tổng số cột triệu chứng được chứa giá trị “có”, cho mỗi hàng trong linelist. Các cột được cụ thể trong hàm sum() theo tên trong vectơ c(). Hàm rowwise() về cơ bản là một hình thức group_by() đặc biệt, vì vậy tốt nhất bạn nên sử dụng ungroup() khi bạn hoàn tất (trong chương Nhóm dữ liệu).\n\nlinelist %&gt;%\n  rowwise() %&gt;%\n  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == \"yes\")) %&gt;% \n  ungroup() %&gt;% \n  select(fever, chills, cough, aches, vomit, num_symptoms) # for display\n\n# A tibble: 5,888 × 6\n   fever chills cough aches vomit num_symptoms\n   &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;        &lt;int&gt;\n 1 no    no     yes   no    yes              2\n 2 &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;            NA\n 3 &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;            NA\n 4 no    no     no    no    no               0\n 5 no    no     yes   no    yes              2\n 6 no    no     yes   no    yes              2\n 7 &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;            NA\n 8 no    no     yes   no    yes              2\n 9 no    no     yes   no    yes              2\n10 no    no     yes   no    no               1\n# ℹ 5,878 more rows\n\n\nKhi bạn chỉ định cột để đánh giá, bạn có thể muốn sử dụng các hàm trợ giúp “tidyselect” như được mô tả trong mục select() của chương này. Bạn chỉ cần thực hiện một điều chỉnh (vì bạn đang không sử dụng chúng bên trong một hàm của dplyr như select() hoặc summarise()).\nĐặt tiêu chí đặc tả cột trong hàm dplyr là c_across(). Điều này là do hàm c_across (tài liệu) được thiết kế để hoạt động cụ thể với hàm rowwise(). Ví dụ, như đoạn code sau:\n\nÁp dụng rowwise() nên bước tiếp theo (sum()) được áp dụng trong mỗi hàng (không tính tổng toàn bộ các cột)\n\nTạo cột mới num_NA_dates, được xác định cho mỗi hàng là số cột (có tên chứa “ngày tháng”) mà is.na() trả về giá trị TRUE (nghĩa là chúng bị thiếu dữ liệu)\n\nungroup() để loại bỏ ảnh hưởng của rowwise() cho các bước tiếp theo\n\n\nlinelist %&gt;%\n  rowwise() %&gt;%\n  mutate(num_NA_dates = sum(is.na(c_across(contains(\"date\"))))) %&gt;% \n  ungroup() %&gt;% \n  select(num_NA_dates, contains(\"date\")) # for display\n\n# A tibble: 5,888 × 5\n   num_NA_dates date_infection date_onset date_hospitalisation date_outcome\n          &lt;int&gt; &lt;date&gt;         &lt;date&gt;     &lt;date&gt;               &lt;date&gt;      \n 1            1 2014-05-08     2014-05-13 2014-05-15           NA          \n 2            1 NA             2014-05-13 2014-05-14           2014-05-18  \n 3            1 NA             2014-05-16 2014-05-18           2014-05-30  \n 4            1 2014-05-04     2014-05-18 2014-05-20           NA          \n 5            0 2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n 6            0 2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n 7            0 2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n 8            0 2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n 9            1 NA             2014-06-05 2014-06-06           2014-06-18  \n10            1 NA             2014-06-05 2014-06-07           2014-06-09  \n# ℹ 5,878 more rows\n\n\nBạn cũng có thể cung cấp các hàm khác, chẳng hạn như max() để lấy ngày mới nhất hoặc gần đây nhất cho mỗi hàng:\n\nlinelist %&gt;%\n  rowwise() %&gt;%\n  mutate(latest_date = max(c_across(contains(\"date\")), na.rm=T)) %&gt;% \n  ungroup() %&gt;% \n  select(latest_date, contains(\"date\"))  # for display\n\n# A tibble: 5,888 × 5\n   latest_date date_infection date_onset date_hospitalisation date_outcome\n   &lt;date&gt;      &lt;date&gt;         &lt;date&gt;     &lt;date&gt;               &lt;date&gt;      \n 1 2014-05-15  2014-05-08     2014-05-13 2014-05-15           NA          \n 2 2014-05-18  NA             2014-05-13 2014-05-14           2014-05-18  \n 3 2014-05-30  NA             2014-05-16 2014-05-18           2014-05-30  \n 4 2014-05-20  2014-05-04     2014-05-18 2014-05-20           NA          \n 5 2014-05-29  2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n 6 2014-05-24  2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n 7 2014-06-01  2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n 8 2014-06-07  2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n 9 2014-06-18  NA             2014-06-05 2014-06-06           2014-06-18  \n10 2014-06-09  NA             2014-06-05 2014-06-07           2014-06-09  \n# ℹ 5,878 more rows",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.vn.html#sắp-xếp",
    "href": "new_pages/cleaning.vn.html#sắp-xếp",
    "title": "8  Làm sạch số liệu và các hàm quan trọng",
    "section": "8.13 Sắp xếp",
    "text": "8.13 Sắp xếp\nSử dụng hàm dplyr arrange() để sắp xếp thứ tự các hàng theo giá trị cột.\nĐơn giản hãy liệt kê các cột theo thứ tự mà chúng cần được sắp xếp. Thêm .by_group = TRUE nếu bạn muốn việc sắp xếp xảy ra trước bất kỳ hành động nhóm dữ liệu nào được áp dụng trong dữ liệu (xem chương Nhóm dữ liệu).\nMặc định, cột sẽ được sắp xếp theo thứ tự “tăng dần” (áp dụng cho cột số và cả cột ký tự). Bạn có thể sắp xếp một biến theo thứ tự “giảm dần” bằng cách đặt tên biến trong hàm desc().\nViệc sắp xếp dữ liệu với hàm arrange() đặc biệt hữu ích khi Trình bày bảng, sử dụng hàm slice() để lấy các hàng “trên cùng” trên mỗi nhóm hoặc thiết lập thứ tự danh mục theo thứ tự xuất hiện.\nVí dụ: để sắp xếp các hàng trong linelist theo hospital, sau đó theo date_onset thứ tự giảm dần, chúng ta sẽ thực hiện như sau:\n\nlinelist %&gt;% \n   arrange(hospital, desc(date_onset))",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Làm sạch số liệu và các hàm quan trọng</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.vn.html",
    "href": "new_pages/dates.vn.html",
    "title": "9  Làm việc với ngày tháng",
    "section": "",
    "text": "9.1 Chuẩn bị",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Làm việc với ngày tháng</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.vn.html#chuẩn-bị",
    "href": "new_pages/dates.vn.html#chuẩn-bị",
    "title": "9  Làm việc với ngày tháng",
    "section": "",
    "text": "Gọi packages\nĐoạn code này hiển thị tải các package cần thiết để sử dụng. Trong tài liệu này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, mà có thể cài đặt package nếu cần thiết và gọi package để sử dụng. Bạn cũng có thể gọi và cài đặt package với hàm library() từ base R. Xem chương R cơ bản để biết thêm thông tin về các package trong R.\n\n# Checks if package is installed, installs if necessary, and loads package for current session\n\npacman::p_load(\n  lubridate,  # general package for handling and converting dates  \n  parsedate,   # has function to \"guess\" messy dates\n  aweek,      # another option for converting dates to weeks, and weeks to dates\n  zoo,        # additional date/time functions\n  tidyverse,  # data management and visualization  \n  here,       # file management\n  rio)        # data import/export\n\n\n\nNhập dữ liệu\nChúng ta sẽ nhập bộ dữ liệu với các ca bệnh từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn tải xuống dữ liệu để thực hành theo từng bước, hãy xem hướng dẫn ở chương Tải sách và dữ liệu. Chúng ta giả định rằng tệp dữ liệu đã nằm trong thư mục làm việc của bạn nên bạn không cần chỉ định thư mục con trong đường dẫn này.\n\nlinelist &lt;- import(\"linelist_cleaned.xlsx\")",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Làm việc với ngày tháng</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.vn.html#ngày-hiện-tại",
    "href": "new_pages/dates.vn.html#ngày-hiện-tại",
    "title": "9  Làm việc với ngày tháng",
    "section": "9.2 Ngày hiện tại",
    "text": "9.2 Ngày hiện tại\nBạn có thể lấy ngày “hệ thống” hiện tại hoặc ngày giờ hệ thống của máy tính bằng cách thực hiện như sau với base R.\n\n# get the system date - this is a DATE class\nSys.Date()\n\n[1] \"2024-05-10\"\n\n# get the system time - this is a DATETIME class\nSys.time()\n\n[1] \"2024-05-10 05:12:33 CEST\"\n\n\nVới package lubridate, chúng cũng có thể trả về giá trị tương ứng với hàm today() và now(). Hàm date() sẽ trả về giá trị ngày và giờ hiện tại với ngày trong tuần và tháng.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Làm việc với ngày tháng</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.vn.html#chuyển-đổi-sang-ngày",
    "href": "new_pages/dates.vn.html#chuyển-đổi-sang-ngày",
    "title": "9  Làm việc với ngày tháng",
    "section": "9.3 Chuyển đổi sang Ngày",
    "text": "9.3 Chuyển đổi sang Ngày\nSau khi nạp tập dữ liệu vào R, giá trị cột ngày có thể trông giống như “1989/12/30”, “05/06/2014” hoặc “13 Jan 2020”. Trong những trường hợp này, R có thể vẫn coi các giá trị trong cột có định dạng ký tự. R cần được hướng dẫn rằng các giá trị này là ngày… và định dạng của ngày là gì (phần nào là Ngày, phần nào là tháng, phần nào là Năm, v.v.).\nSau khi hướng dẫn, R chuyển đổi các giá trị này thành kiểu Ngày. Trong nền, R sẽ lưu trữ ngày tháng dưới dạng số (số ngày tính từ ngày “gốc” ngày 1 tháng 1 năm 1970). Bạn sẽ không phải làm việc với định dạng ngày-số thường xuyên, tuy nhiên điều này cho phép R coi ngày là các biến liên tục và cho phép các hoạt động đặc biệt như tính toán khoảng cách giữa các ngày.\nMặc định, các giá trị của phân lớp Ngày trong R được hiển thị là YYYY-MM-DD. Sau chương này chúng ta sẽ thảo luận về cách thay đổi cách hiển thị giá trị ngày tháng.\nDưới đây, chúng tôi trình bày hai cách để chuyển đổi một cột từ dạng ký tự sang kiểu Ngày tiêu chuẩn.\nMẸO: Bạn có thể kiểm tra kiểu ngày hiện tại của cột bằng hàm class() trong base R, ví dụ như class(linelist$date_onset).\n\nbase R\nas.Date() là hàm chuẩn của base R để chuyển đổi một đối tượng hoặc cột thành kiểu Ngày (lưu ý viết hoa chữ “D”).\nSử dụng hàm as.Date() yêu cầu:\n\nBạn làm rõ định dạng hiện tại của ngày ở dạng văn bản gốc hoặc ngày gốc nếu biến ngày được cung cấp dưới dạng số (xem mục ngày tháng trong Excel)\n\nNếu hàm được áp dụng trên cột dạng văn bản, tất cả các giá trị ngày phải có cùng một định dạng chính xác (nếu không như vậy, hãy thử hàm parse_date() từ package parsedate)\n\nTrước tiên, hãy kiểm tra kiểu của cột với hàm class() trong base R. Nếu bạn không chắc chắn hoặc phân vân về kiểu dữ liệu của cột (vd: bạn thấy “POSIXct”, v.v.) dễ dàng nhất là chuyển đổi cột thành kiểu văn bản với hàm as.character(), và sau đó chuyển đổi nó thành kiểu Ngày.\nThứ hai, trong hàm as.Date(), sử dụng đối số format = để cho R biết định dạng hiện tại của các cấu phần trong biến ngày - những ký tự nào đề cập đến tháng, ngày và năm và cách chúng được phân tách. Nếu các giá trị của bạn đã ở một trong các định dạng ngày chuẩn của R (“YYYY-MM-DD” hoặc “YYYY/MM/DD”) thì đối số format = là không cần thiết.\nĐể format =, hãy cung cấp một chuỗi ký tự (trong dấu ngoặc kép) đại diện cho định dạng ngày hiện tại bằng cách sử dụng các chữ viết tắt đặc biệt “strptime” dưới đây. Ví dụ: nếu ngày ký tự của bạn hiện ở định dạng “DD / MM / YYYY”, như “24/04/1968”, bạn hãy sử dụng đối số format = \"%d/%m/%Y\" để chuyển đổi các giá trị này. Đặt định dạng trong dấu ngoặc kép là cần thiết. Và đừng quên bất kỳ dấu gạch chéo hoặc dấu gạch ngang nào!\n\n# Convert to class date\nlinelist &lt;- linelist %&gt;% \n  mutate(date_onset = as.Date(date_of_onset, format = \"%d/%m/%Y\"))\n\nHầu hết các từ viết tắt của “strptime” được liệt kê dưới đây. Bạn có thể xem danh sách đầy đủ bằng cách chạy lệnh ?strptime.\n%d = Thứ tự ngày trong tháng (5, 17, 28, v.v.)\n%j = Thứ tự ngày trong năm (theo lịch Julian, ngày từ 001-366)\n%a = Ngày trong tuần viết tắt (Mon, Tue, Wed, v.v.)\n%A = Ngày trong tuần viết đầy đủ (Monday, Tuesday, v.v.) %w = Thứ tự ngày trong tuần (0-6, Chủ Nhật là 0)\n%u = Thứ tự ngày trong tuần (1-7, Thứ hai là 1)\n%W = Thứ tự của tuần trong năm (00-53, Thứ Hai là đầu tuần)\n%U = Thứ tự của tuần trong năm (01-53, Chủ Nhật là ngày bắt đầu tuần)\n%m = Thứ tự của tháng trong năm (vd: 01, 02, 03, 04)\n%b = Tháng viết tắt (Jan, Feb, v.v.)\n%B = Tháng viết đầy đủ (January, February, v.v.)\n%y = năm 2 chữ số (vd: 89)\n%Y = năm 4 chữ số (vd: 1989)\n%H = giờ (đồng hồ 24h)\n%M = phút\n%S = giây %z = offset from GMT\n%Z = Múi giờ (dạng ký tự)\nMẸO: Đối số format = của hàm as.Date() sẽ không cho R biết định dạng ngày theo cách bạn muốn, nhưng hơn hết nó giúp xác định thành phần ngày trong cột trước khi bạn chạy dòng lệnh.\nMẸO: Hãy chắc chắn rằng đối số format = bạn có sử dụng các ký tự ngăn cách ngày tháng (vd: /, -, hoặc khoảng trắng) trong cột ngày hiện tại của bạn.\nKhi các giá trị nằm trong phân lớp Ngày tiêu chuẩn, R sẽ mặc định hiển thị chúng ở định dạng chuẩn, đó là YYYY-MM-DD.\n\n\nlubridate\nViệc chuyển đổi các đối tượng dạng tự thành Ngày tháng có thể được thực hiện dễ dàng hơn bằng cách sử dụng package lubridate. Đây là một package thuộc hệ sinh thái tidyverse được thiết kế để giúp làm việc với ngày và giờ đơn giản và nhất quán hơn so với base R. Vì những lý do này, package lubridate thường được coi là package tiêu chuẩn vàng cho ngày và giờ và được khuyến khích sử dụng bất cứ khi nào làm việc với chúng.\nPackage lubridate cung cấp một số hàm trợ giúp khác nhau được thiết kế để chuyển đổi các đối tượng dạng ký tự thành ngày tháng một cách trực quan và dễ dàng hơn là định dạng bằng hàm as.Date(). Các hàm này dành riêng cho định dạng ngày tháng, nhưng cho phép nhiều kiểu dấu phân tách và từ đồng nghĩa của ngày tháng (vd: 01 so với Jan so với January) - chúng được đặt tên theo chữ viết tắt của các định dạng ngày.\n\n# install/load lubridate \npacman::p_load(lubridate)\n\nHàm ymd() có thể chuyển đổi linh hoạt các giá trị ngày được cung cấp dưới dạng năm, sau đó là tháng, và ngày.\n\n# read date in year-month-day format\nymd(\"2020-10-11\")\n\n[1] \"2020-10-11\"\n\nymd(\"20201011\")\n\n[1] \"2020-10-11\"\n\n\nHàm mdy() có thể chuyển đổi linh hoạt các giá trị ngày được cung cấp dưới dạng tháng, ngày, và năm.\n\n# read date in month-day-year format\nmdy(\"10/11/2020\")\n\n[1] \"2020-10-11\"\n\nmdy(\"Oct 11 20\")\n\n[1] \"2020-10-11\"\n\n\nHàm dmy() có thể chuyển đổi linh hoạt các giá trị ngày được cung cấp dưới dạng ngày, tháng, và năm.\n\n# read date in day-month-year format\ndmy(\"11 10 2020\")\n\n[1] \"2020-10-11\"\n\ndmy(\"11 October 2020\")\n\n[1] \"2020-10-11\"\n\n\n\n\n\n\nNếu sử dụng piping, việc chuyển đổi cột dạng ký tự thành ngày tháng với lubridate có thể trông như thế này:\n\nlinelist &lt;- linelist %&gt;%\n  mutate(date_onset = lubridate::dmy(date_onset))\n\nSau khi hoàn tất, bạn có thể chạy hàm class() để xác minh lại kiểu dữ liệu của cột\n\n# Check the class of the column\nclass(linelist$date_onset)  \n\nKhi các giá trị nằm trong phân lớp Ngày tiêu chuẩn, R sẽ mặc định hiển thị chúng ở định dạng chuẩn, đó là YYYY-MM-DD.\nLưu ý rằng các hàm trên sử dụng tốt nhất với thông tin về năm có 4 chữ số. Thông tin về năm có 2 chữ số có thể tạo ra các kết quả không mong muốn, bởi vì lubridate sẽ cố gắng đoán và lấy thông tin về thế kỷ.\nĐể chuyển đổi thông tin về năm 2 chữ số thành 4 chữ số (tất cả trong cùng một thế kỷ), bạn có thể chuyển thành dạng ký tự và sau đó kết hợp các chữ số hiện có với một tiền tố sử dụng hàm str_glue() từ package stringr (xem chương Ký tự và chuỗi). Sau đó chuyển đổi sang dạng ngày.\n\ntwo_digit_years &lt;- c(\"15\", \"15\", \"16\", \"17\")\nstr_glue(\"20{two_digit_years}\")\n\n2015\n2015\n2016\n2017\n\n\n\n\nKết hợp các cột\nBạn có thể sử dụng các hàm make_date() và make_datetime() trong package lubridate để kết hợp nhiều cột dạng số thành một cột ngày. Ví dụ: nếu bạn có các cột kiểu số như onset_day, onset_month, và onset_year trong data frame linelist:\n\nlinelist &lt;- linelist %&gt;% \n  mutate(onset_date = make_date(year = onset_year, month = onset_month, day = onset_day))",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Làm việc với ngày tháng</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.vn.html#ngày-tháng-trong-excel",
    "href": "new_pages/dates.vn.html#ngày-tháng-trong-excel",
    "title": "9  Làm việc với ngày tháng",
    "section": "9.4 Ngày tháng trong Excel",
    "text": "9.4 Ngày tháng trong Excel\nVề cơ bản, hầu hết phần mềm lưu trữ thông tin ngày tháng dưới dạng số. R lưu trữ ngày bắt đầu từ ngày 1 tháng 1 năm 1970. Do đó, nếu bạn chạy hàm as.numeric(as.Date(\"1970-01-01)), bạn sẽ nhận được kết quả là 0.\nMicrosoft Excel lưu trữ ngày tháng có nguồn gốc là ngày 30 tháng 12 năm 1899 (hệ điều hành Windows) hoặc ngày 1 tháng 1 năm 1904 (hệ điều hành Mac), tùy thuộc vào hệ điều hành của bạn. Xem hướng dẫn của Microsoft để biết thêm thông tin.\nNgày trong Excel thường nạp vào R dưới dạng các giá trị số thay vì dưới dạng ký tự. Nếu tập dữ liệu bạn đã nhập từ Excel hiển thị ngày tháng dưới dạng số hoặc ký tự như “41369”… hãy sử dụng hàm as.Date() (hoặc hàm as_date() của lubridate) để chuyển đổi, nhưng thay vì cung cấp một “định dạng” như trên, hãy cung cấp ngày gốc trên Excel tới đối số origin =.\nĐiều này sẽ không hoạt động nếu ngày Excel được lưu trữ trong R dưới dạng một kiểu ký tự, vì vậy hãy đảm bảo rằng các số được lữu trữ ở kiểu Số!\nLƯU Ý: Bạn nên cung cấp định dạng ngày ở định dạng mặc định của R (“YYYY-MM-DD”).\n\n# An example of providing the Excel 'origin date' when converting Excel number dates\ndata_cleaned &lt;- data %&gt;% \n  mutate(date_onset = as.numeric(date_onset)) %&gt;%   # ensure class is numeric\n  mutate(date_onset = as.Date(date_onset, origin = \"1899-12-30\")) # convert to date using Excel origin",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Làm việc với ngày tháng</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.vn.html#ngày-lộn-xộn",
    "href": "new_pages/dates.vn.html#ngày-lộn-xộn",
    "title": "9  Làm việc với ngày tháng",
    "section": "9.5 Ngày lộn xộn",
    "text": "9.5 Ngày lộn xộn\nHàm guess_dates() từ package linelist cố gắng nhận diện một cột ngày tháng “lộn xộn” chứa ngày tháng ở nhiều định dạng khác nhau và chuyển đổi ngày tháng sang định dạng chuẩn. Bạn có thể đọc thêm tài liệu trực tuyến về guess_dates(). Nếu hàm guess_dates() chưa có trên CRAN của R phiên bản 4.0.2, hãy thử cài đặt theo cách sau pacman::p_load_gh(\"reconhub/linelist\").\nVí dụ: hàm guess_dates sẽ nhận diện một vectơ gồm các ngày chứa ký tự như sau “03 Jan 2018”, “07/03/1982”, và “08/20/85” và chuyển đổi chúng thành định dạng Ngày tiêu chuẩn như: 2018-01-03, 1982-03-07, và 1985-08-20.\n\nparsedate::parse_date(c(\"03 Jan 2018\",\n                        \"07/03/1982\",\n                        \"08/20/85\"))\n\n[1] \"2018-01-03 UTC\" \"1982-07-03 UTC\" \"1985-08-20 UTC\"\n\n\nMột số tùy chọn đối số cho hàm guess_dates() mà bạn có thể đưa vào là:\n\nerror_tolerance - Tỷ lệ thông tin nhập không thể được xác định là ngày được chấp nhận (mặc định là 0,1 hoặc 10%)\nlast_date - ngày hợp lệ cuối cùng (mặc định là ngày hiện tại)\n\nfirst_date - ngày hợp lệ đầu tiên. Giá trị mặc định là năm mươi năm trước last_date.\n\n\n# An example using guess_dates on the column dater_onset\nlinelist &lt;- linelist %&gt;%                 # the dataset is called linelist\n  mutate(date_onset = parse_date(date_onset)",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Làm việc với ngày tháng</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.vn.html#làm-việc-với-kiểu-dữ-liệu-ngày-giờ",
    "href": "new_pages/dates.vn.html#làm-việc-với-kiểu-dữ-liệu-ngày-giờ",
    "title": "9  Làm việc với ngày tháng",
    "section": "9.6 Làm việc với kiểu dữ liệu ngày-giờ",
    "text": "9.6 Làm việc với kiểu dữ liệu ngày-giờ\nNhư đã đề cập ở trước, R cũng hỗ trợ kiểu dữ liệu datetime - là một cột chứa thông tin ngày và giờ. Bởi vì với kiểu dữ liệu Date, chúng cần được chuyển đổi từ các đối tượng kiểu character thành kiểu datetime.\n\nChuyển đổi ngày giờ\nMột đối tượng datetime được định dạng phần ngày trước, sau đó là phần thời gian - ví dụ: 01 Jan 2020, 16:30. Cũng như ngày, có nhiều cách có thể được định dạng và có nhiều cấp độ chính xác (giờ, phút, giây) có thể sử dụng.\nThật may mắn, các hàm hỗ trợ trong lubridate cũng tồn tại để giúp chuyển đổi thông tin dạng chuỗi này thành các đối tượng dạng datetime. Các hàm này là phần mở rộng của các hàm ngày, với hàm _h (chỉ cung cấp giờ), hàm _hm (cung cấp giờ và phút), hoặc hàm _hms (cung cấp giờ, phút và giây) được thêm vào cuối cùng (vd: dmy_hms()). Chúng có thể được sử dụng như sau:\nChuyển đổi datetime chỉ có giờ thành đối tượng datetime\n\nymd_h(\"2020-01-01 16hrs\")\n\n[1] \"2020-01-01 16:00:00 UTC\"\n\nymd_h(\"2020-01-01 4PM\")\n\n[1] \"2020-01-01 16:00:00 UTC\"\n\n\nChuyển đổi datetime với giờ và phút thành đối tượng datetime\n\ndmy_hm(\"01 January 2020 16:20\")\n\n[1] \"2020-01-01 16:20:00 UTC\"\n\n\nChuyển đổi datetime với giờ, phút và giây sang đối tượng datetime\n\nmdy_hms(\"01 January 2020, 16:20:40\")\n\n[1] \"2020-01-20 16:20:40 UTC\"\n\n\nBạn có thể cung cấp múi giờ nhưng nó bị bỏ qua. Xem các phần sau trong chương này về múi giờ.\n\nmdy_hms(\"01 January 2020, 16:20:40 PST\")\n\n[1] \"2020-01-20 16:20:40 UTC\"\n\n\nKhi làm việc với một data frame, các cột ngày và giờ có thể được kết hợp để tạo cột ngày-giờ bằng cách sử dụng hàm str_glue() từ package stringr và các hàm của package lubridate. Xem chương Ký tự và chuỗi để biết thêm chi tiết về stringr.\nTrong ví dụ này, bộ dữ liệu linelist có một cột ở định dạng “giờ:phút”. Để chuyển đổi thành ngày giờ, chúng tôi làm theo một số bước:\n\nTạo một cột thời gian nhập viện “sạch” với các giá trị bị thiếu được điền bằng trung vị cột. Chúng ta làm điều này bởi vì lubridate sẽ không hoạt động trên các giá trị missing. Kết hợp nó với cột date_hospitalisation, sau đó sử dụng hàm ymd_hm() để chuyển đổi.\n\n\n# packages\npacman::p_load(tidyverse, lubridate, stringr)\n\n# time_admission is a column in hours:minutes\nlinelist &lt;- linelist %&gt;%\n  \n  # when time of admission is not given, assign the median admission time\n  mutate(\n    time_admission_clean = ifelse(\n      is.na(time_admission),         # if time is missing\n      median(time_admission),        # assign the median\n      time_admission                 # if not missing keep as is\n  ) %&gt;%\n  \n    # use str_glue() to combine date and time columns to create one character column\n    # and then use ymd_hm() to convert it to datetime\n  mutate(\n    date_time_of_admission = str_glue(\"{date_hospitalisation} {time_admission_clean}\") %&gt;% \n      ymd_hm()\n  )\n\n\n\nChỉ chuyển đổi thời gian\nNếu dữ liệu của bạn chỉ chứa thời gian dạng ký tự (giờ và phút), bạn có thể chuyển đổi và thao tác chúng bằng cách sử dụng hàm strptime() từ base R. Ví dụ: để phân biệt sự khác biệt giữa hai loại thời gian này:\n\n# raw character times\ntime1 &lt;- \"13:45\" \ntime2 &lt;- \"15:20\"\n\n# Times converted to a datetime class\ntime1_clean &lt;- strptime(time1, format = \"%H:%M\")\ntime2_clean &lt;- strptime(time2, format = \"%H:%M\")\n\n# Difference is of class \"difftime\" by default, here converted to numeric hours \nas.numeric(time2_clean - time1_clean)   # difference in hours\n\n[1] 1.583333\n\n\nTuy nhiên, lưu ý rằng nếu không có giá trị ngày được cung cấp, phần mềm sẽ giả định là ngày hôm nay. Để kết hợp chuỗi ngày và giờ với nhau, hãy thử cách sử dụng stringr đã được nói ở phần bên trên. Đọc thêm về strptime() tại đây.\nĐể chuyển đổi các số có một chữ số thành hai chữ số (ví dụ: để “độn thêm” giờ hoặc phút với các số 0 ở đầu để đạt được 2 chữ số), hãy xem phần “Độ dài chuỗi ký tự” trong chương Ký tự và chuỗi.\n\n\nThời gian chính xác\nBạn có thể trích xuất các phần tử của thời gian với các hàm hour(), minute(), hoặc second() từ lubridate.\nĐây là một ví dụ về trích xuất giờ và sau đó phân loại theo từng phần trong ngày. Chúng ta bắt đầu với cột time_admission, có kiểu ký tự ở định dạng “HH:MM”. Đầu tiên, hàm strptime() được sử dụng như mô tả ở trên để chuyển đổi các ký tự thành kiểu ngày giờ. Sau đó, giờ được trích xuất với hàm hour(), trả về một số từ 0-24. Cuối cùng, cột time_period được tạo bằng cách sử dụng logic với hàm case_when() để phân loại các dòng thành các buổi Sáng / Chiều / Tối / Đêm dựa trên giờ được nhập liệu.\n\nlinelist &lt;- linelist %&gt;%\n  mutate(hour_admit = hour(strptime(time_admission, format = \"%H:%M\"))) %&gt;%\n  mutate(time_period = case_when(\n    hour_admit &gt; 06 & hour_admit &lt; 12 ~ \"Morning\",\n    hour_admit &gt;= 12 & hour_admit &lt; 17 ~ \"Afternoon\",\n    hour_admit &gt;= 17 & hour_admit &lt; 21 ~ \"Evening\",\n    hour_admit &gt;=21 | hour_admit &lt;= 6 ~ \"Night\"))\n\nĐể tìm hiểu thêm về hàm case_when(), hãy xem chương Làm sạch số liệu và các hàm quan trọng.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Làm việc với ngày tháng</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.vn.html#làm-việc-với-ngày",
    "href": "new_pages/dates.vn.html#làm-việc-với-ngày",
    "title": "9  Làm việc với ngày tháng",
    "section": "9.7 Làm việc với ngày",
    "text": "9.7 Làm việc với ngày\nlubridate cũng có thể được sử dụng cho nhiều chức năng khác, chẳng hạn như trích xuất các phần tử của ngày/ngày-giờ, tính toán ngày dạng số học, hoặc tính toán khoảng cách giữa ngày với ngày\nỞ đây chúng tôi tạo ra một ngày mẫu để sử dụng cho các ví dụ:\n\n# create object of class Date\nexample_date &lt;- ymd(\"2020-03-01\")\n\n\nTrích xuất các cấu phần của ngày\nBạn có thể trích xuất các cấu phần phổ biến như tháng, ngày, ngày trong tuần:\n\nmonth(example_date)  # month number\n\n[1] 3\n\nday(example_date)    # day (number) of the month\n\n[1] 1\n\nwday(example_date)   # day number of the week (1-7)\n\n[1] 1\n\n\nBạn cũng có thể trích xuất các cấu phần thời gian từ một đối tượng hoặc cột có kiểu datetime. Điều này có thể hữu ích nếu bạn muốn xem phân phối của thời gian nhập viện.\n\nexample_datetime &lt;- ymd_hm(\"2020-03-01 14:45\")\n\nhour(example_datetime)     # extract hour\nminute(example_datetime)   # extract minute\nsecond(example_datetime)   # extract second\n\nCó một số tùy chọn để trích xuất tuần. Xem thêm ở mục tuần Dịch tễ học bên dưới.\nLưu ý rằng nếu bạn đang tìm cách hiển thị ngày theo một cách nhất định (ví dụ: “Jan 2020” hoặc “Thursday 20 March” hoặc “Week 20, 1977”), bạn có thể thực hiện điều này linh hoạt hơn như được mô tả trong mục Hiển thị ngày.\n\n\nTính toán ngày\nBạn có thể thêm số ngày hoặc tuần nhất định bằng cách sử dụng các hàm tương ứng từ package lubridate.\n\n# add 3 days to this date\nexample_date + days(3)\n\n[1] \"2020-03-04\"\n\n# add 7 weeks and subtract two days from this date\nexample_date + weeks(7) - days(2)\n\n[1] \"2020-04-17\"\n\n\n\n\nKhoảng ngày\nSự khác biệt giữa các ngày có thể được tính bằng:\n\nĐảm bảo cả hai trường ngày đều thuộc phân lớp ngày tiêu chuẩn\n\nSử dụng phép trừ để trả về khoảng chênh lệch “difftime” giữa hai ngày\n\nNếu cần thiết, hãy chuyển đổi kết quả thành phân lớp dạng số để thực hiện các phép tính toán học tiếp theo\n\nDưới đây là khoảng thời gian giữa hai ngày được tính toán và hiển thị. Bạn có thể tìm các khoảng thời gian bằng cách sử dụng ký hiệu trừ “minus” trên các giá trị dạng Ngày tiêu chuẩn. Tuy nhiên, lưu ý rằng phân lớp của giá trị trả về là “difftime” như được hiển thị bên dưới và phải được chuyển đổi thành dạng số.\n\n# find the interval between this date and Feb 20 2020 \noutput &lt;- example_date - ymd(\"2020-02-20\")\noutput    # print\n\nTime difference of 10 days\n\nclass(output)\n\n[1] \"difftime\"\n\n\nĐể thực hiện các thao tác tiếp theo trên “difftime”, hãy chuyển nó thành dạng số với hàm as.numeric().\nTất cả điều này có thể được kết hợp với nhau để xử lý dữ liệu - ví dụ:\n\npacman::p_load(lubridate, tidyverse)   # load packages\n\nlinelist &lt;- linelist %&gt;%\n  \n  # convert date of onset from character to date objects by specifying dmy format\n  mutate(date_onset = dmy(date_onset),\n         date_hospitalisation = dmy(date_hospitalisation)) %&gt;%\n  \n  # filter out all cases without onset in march\n  filter(month(date_onset) == 3) %&gt;%\n    \n  # find the difference in days between onset and hospitalisation\n  mutate(days_onset_to_hosp = date_hospitalisation - date_of_onset)\n\nTrong bối cảnh của bộ dữ liệu, nếu thiếu một trong hai giá trị ngày ở trên, thì thao tác này sẽ không thực hiện thành công. Điều này sẽ tạo ra một kết quả là NA thay vì là một giá trị số. Khi sử dụng các cột này để tính toán, hãy chắc chắn rằng bạn thiết lập đối số na.rm = là TRUE. Ví dụ:\n\n# calculate the median number of days to hospitalisation for all cases where data are available\nmedian(linelist_delay$days_onset_to_hosp, na.rm = T)",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Làm việc với ngày tháng</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.vn.html#hiển-thị-ngày",
    "href": "new_pages/dates.vn.html#hiển-thị-ngày",
    "title": "9  Làm việc với ngày tháng",
    "section": "9.8 Hiển thị ngày",
    "text": "9.8 Hiển thị ngày\nMột khi ngày tháng đã được định dạng đúng kiểu, bạn thường muốn chúng hiển thị theo nhiều cách khác nhau, ví dụ: hiển thị là “Monday 05 January” thay vì “2018-01-05”. Bạn cũng có thể muốn điều chỉnh hiển thị để nhóm các dòng theo các yếu tố ngày - ví dụ: nhóm theo tháng-năm.\n\nformat()\nĐiều chỉnh hiển thị ngày với hàm format() từ base R. Hàm này chấp nhận một chuỗi ký tự (trong dấu ngoặc kép) xác định rõ định dạng đầu ra mong muốn bằng chữ viết tắt “%” strptime (cú pháp tương tự như được sử dụng trong hàm as.Date()). Dưới đây là các từ viết tắt phổ biến.\nLưu ý: việc sử dụng hàm format() sẽ chuyển đổi các giá trị thành kiểu ký tự, vì vậy điều này thường được sử dụng ở cuối phân tích hoặc chỉ cho mục đích hiển thị! Bạn có thể xem danh sách đầy đủ bằng cách chạy lệnh ?strptime.\n%d = Thứ tự ngày trong tháng (5, 17, 28, v.v.)\n%j = Thứ tự ngày trong năm (theo lịch Julian, ngày từ 001-366)\n%a = Ngày trong tuần viết tắt (Mon, Tue, Wed, v.v.)\n%A = Ngày trong tuần viết đầy đủ (Monday, Tuesday, v.v.) %w = Thứ tự ngày trong tuần (0-6, Chủ Nhật là 0)\n%u = Thứ tự ngày trong tuần (1-7, Thứ hai là 1)\n%W = Thứ tự của tuần trong năm (00-53, Thứ Hai là đầu tuần)\n%U = Thứ tự của tuần trong năm (01-53, Chủ Nhật là ngày bắt đầu tuần)\n%m = Thứ tự của tháng trong năm (vd: 01, 02, 03, 04)\n%b = Tháng viết tắt (Jan, Feb, v.v.)\n%B = Tháng viết đầy đủ (January, February, v.v.)\n%y = năm 2 chữ số (vd: 89)\n%Y = năm 4 chữ số (vd: 1989)\n%H = giờ (đồng hồ 24h)\n%M = phút\n%S = giây %z = offset from GMT\n%Z = Múi giờ (dạng ký tự)\nVí dụ về định dạng ngày hôm nay:\n\n# today's date, with formatting\nformat(Sys.Date(), format = \"%d %B %Y\")\n\n[1] \"10 May 2024\"\n\n# easy way to get full date and time (default formatting)\ndate()\n\n[1] \"Fri May 10 05:12:35 2024\"\n\n# formatted combined date, time, and time zone using str_glue() function\nstr_glue(\"{format(Sys.Date(), format = '%A, %B %d %Y, %z  %Z, ')}{format(Sys.time(), format = '%H:%M:%S')}\")\n\nFriday, May 10 2024, +0000  UTC, 05:12:35\n\n# Using format to display weeks\nformat(Sys.Date(), \"%Y Week %W\")\n\n[1] \"2024 Week 19\"\n\n\nLưu ý rằng nếu sử dụng hàm str_glue(), hãy lưu ý rằng các nội dung lẽ ra nên để trong dấu ngoặc kép thì bạn chỉ nên sử dụng dấu ngoặc đơn (như trên).\n\n\nTháng-Năm\nĐể chuyển đổi cột Ngày sang định dạng Tháng-năm, chúng tôi khuyên bạn nên sử dụng hàm as.yearmon() từ package zoo. Nó giúp chuyển đổi từ định dạng ngày thành định dạng “yearmon” và giữ lại thứ tự thích hợp. Ngược lại, sử dụng hàm format(column, \"%Y %B\") sẽ chuyển đổi giá trị thành kiểu Ký tự và sẽ sắp xếp các giá trị theo thứ tự bảng chữ cái (không chính xác).\nDưới đây, một cột yearmonth mới được tạo ra từ cột date_onset, sử dụng hàm as.yearmon(). Thứ tự mặc định (đúng) của các giá trị kết quả được hiển thị trong bảng.\n\n# create new column \ntest_zoo &lt;- linelist %&gt;% \n     mutate(yearmonth = zoo::as.yearmon(date_onset))\n\n# print table\ntable(test_zoo$yearmon)\n\n\nApr 2014 May 2014 Jun 2014 Jul 2014 Aug 2014 Sep 2014 Oct 2014 Nov 2014 \n       7       64      100      226      528     1070     1112      763 \nDec 2014 Jan 2015 Feb 2015 Mar 2015 Apr 2015 \n     562      431      306      277      186 \n\n\nNgược lại, bạn có thể thấy sử dụng hàm format() chỉ có thể giúp đạt được định dạng hiển thị mong muốn, nhưng sẽ không có thứ tự chính xác.\n\n# create new column\ntest_format &lt;- linelist %&gt;% \n     mutate(yearmonth = format(date_onset, \"%b %Y\"))\n\n# print table\ntable(test_format$yearmon)\n\n\nApr 2014 Apr 2015 Aug 2014 Dec 2014 Feb 2015 Jan 2015 Jul 2014 Jun 2014 \n       7      186      528      562      306      431      226      100 \nMar 2015 May 2014 Nov 2014 Oct 2014 Sep 2014 \n     277       64      763     1112     1070 \n\n\nLưu ý: nếu bạn đang làm việc với hàm ggplot() và chỉ muốn điều chỉnh chỉ hiển thị ngày, bạn chỉ cần cung cấp định dạng strptime là đủ tới đối số date_labels = của hàm scale_x_date() - bạn có thể sử dụng \"%b %Y\" hoặc \"%Y %b\". Xem thêm chương Các mẹo với ggplot.\nPackage zoo cũng cung cấp hàm as.yearqtr(), và bạn có thể sử dụng hàm scale_x_yearmon() khi sử dụng hàm ggplot().",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Làm việc với ngày tháng</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.vn.html#dates_epi_wks",
    "href": "new_pages/dates.vn.html#dates_epi_wks",
    "title": "9  Làm việc với ngày tháng",
    "section": "9.9 Tuần dịch tễ học",
    "text": "9.9 Tuần dịch tễ học\n\nlubridate\nXem chương Nhóm dữ liệu để biết thêm các ví dụ mở rộng về nhóm dữ liệu theo ngày. Dưới đây chúng tôi mô tả ngắn gọn cách nhóm dữ liệu theo tuần.\nThông thường, chúng tôi khuyên bạn nên sử dụng hàm floor_date() từ package lubridate, với đối số unit = \"week\". Điều này làm tròn ngày cần xử lý thành ngày “bắt đầu” của tuần, như được xác định bởi đối số week_start =. Ngày bắt đầu của tuần mặc định là 1 (đối với Thứ Hai) nhưng bạn có thể chỉ định bất kỳ ngày nào trong tuần làm ngày bắt đầu (ví dụ: 7 đối với Chủ Nhật). Hàm floor_date() rất linh hoạt và có thể sử dụng để làm tròn xuống các đơn vị thời gian khác bằng cách thiết lập đối số unit = bằng “giây”, “phút”, “giờ”, “ngày”, “tháng”, hoặc “năm”.\nGiá trị trả về là ngày bắt đầu trong tuần, với kiểu dữ liệu Ngày. Kiểu dữ liệu này rất hữu ích khi vẽ biểu đồ, vì nó sẽ dễ dàng sử dụng và sắp xếp chính xác trong hàm ggplot().\nNếu bạn chỉ quan tâm đến việc điều chỉnh ngày để hiển thị theo tuần trong biểu đồ, hãy xem mục Hiển thị ngày trong chương này. Ví dụ: khi vẽ đồ thị một đường cong dịch tễ, bạn có thể định dạng hiển thị ngày bằng cách sử dụng cú pháp strptime “%”. Ví dụ, sử dụng “%Y-%W” hoặc “%Y-%U” để trả về giá trị năm và số tuần (tương ứng với bắt đầu tuần vào ngày thứ Hai hoặc Chủ nhật).\n\n\nĐếm theo tuần\nXem chương Nhóm dữ liệu để được giải thích kỹ hơn về cách nhóm dữ liệu với hàm count(), group_by(), và summarise(). Dưới đây là một ví dụ ngắn gọn.\n\nTạo cột ‘tuần’ mới với hàm mutate(), sử dụng hàm floor_date() với đối số unit = \"week\"\n\nĐếm số lượng dòng (quan sát) mỗi tuần với hàm count(); lọc ra bất kỳ trường hợp nào bị thiếu ngày\n\nKết thúc với hàm complete() từ package tidyr để đảm bảo rằng tất cả các tuần đều xuất hiện trong dữ liệu - ngay cả những tuần không có dòng/ quan sát nào. Theo mặc định, giá trị đếm cho bất kỳ hàng “mới” nào sẽ là NA, nhưng bạn có thể đặt chúng bằng 0 với đối số fill =, mà điều này kỳ vọng cho một danh sách tên (bên dưới, n là tên của cột đếm).\n\n\n# Make aggregated dataset of weekly case counts\nweekly_counts &lt;- linelist %&gt;% \n  drop_na(date_onset) %&gt;%             # remove cases missing onset date\n  mutate(weekly_cases = floor_date(   # make new column, week of onset\n    date_onset,\n    unit = \"week\")) %&gt;%            \n  count(weekly_cases) %&gt;%           # group data by week and count rows per group (creates column 'n')\n  tidyr::complete(                  # ensure all weeks are present, even those with no cases reported\n    weekly_cases = seq.Date(          # re-define the \"weekly_cases\" column as a complete sequence,\n      from = min(weekly_cases),       # from the minimum date\n      to = max(weekly_cases),         # to the maxiumum date\n      by = \"week\"),                   # by weeks\n    fill = list(n = 0))             # fill-in NAs in the n counts column with 0\n\nĐây là các hàng đầu tiên của kết quả bộ dữ liệu:\n\n\n\n\n\n\n\n\nCác thay thế cho tuần dịch tễ học\nLưu ý là package lubridate cũng có các hàm week(), epiweek(), và isoweek(), mỗi hàm có ngày bắt đầu khác nhau một chút và các sắc thái khác nhau. Mặc dù nói chung, hàm floor_date() là tất cả những gì bạn cần. Đọc thêm về các hàm này bằng cách gõ ?week ở cửa sổ console hoặc đọc tài liệu tại đây.\nBạn có thể cân nhắc sử dụng package aweek để thiết lập tuần dịch tễ học. Bạn có thể đọc thêm về nó ở trang web của RECON. Nó có các hàm date2week() và week2date() trong đó bạn có thể đặt ngày bắt đầu tuần với week_start = \"Monday\". Package này là dễ sử dụng nhất nếu bạn muốn hiển thị “tuần” theo kiểu đầu ra (vd: “2020-W12”). Một ưu điểm khác của aweek là khi áp dụng hàm date2week() cho cột ngày, cột trả về (định dạng tuần) sẽ tự động thuộc kiểu Factor và bao gồm các cấp độ cho tất cả các tuần trong khoảng thời gian (điều này tránh thêm bước complete() được mô tả ở trên). Tuy nhiên, aweek không có chức năng làm tròn ngày thành các đơn vị thời gian khác như tháng, năm, v.v.\nMột giải pháp thay thế khác cho chuỗi thời gian cũng hoạt động tốt để hiển thị định dạng “tuần” (“2020 W12”) là hàm yearweek() từ package tsibble, như được minh họa trong chương Chuỗi thời gian và phát hiện ổ dịch.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Làm việc với ngày tháng</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.vn.html#chuyển-đổi-múi-ngày-giờ",
    "href": "new_pages/dates.vn.html#chuyển-đổi-múi-ngày-giờ",
    "title": "9  Làm việc với ngày tháng",
    "section": "9.10 Chuyển đổi múi ngày giờ",
    "text": "9.10 Chuyển đổi múi ngày giờ\nKhi dữ liệu hiển thị ở các múi giờ khác nhau, điều quan trọng là phải chuẩn hóa dữ liệu này thành một múi giờ thống nhất. Điều này có thể gây ra một thách thức lớn hơn nữa, vì thành phần múi giờ của dữ liệu phải được mã hóa theo cách thủ công trong hầu hết các trường hợp.\nTrong R, mỗi đối tượng datetime có một cấu phần múi giờ. Mặc định, tất cả các đối tượng datetime sẽ mang múi giờ địa phương của máy tính đang sử dụng - điều này thường đặc trưng cho một vị trí chứ không phải tự đặt tên cho múi giờ đó, vì múi giờ thường sẽ thay đổi ở các vị trí phụ thuộc vào thời gian chiếu sáng. Không thể bù trừ chính xác cho các múi giờ mà không có cấu phần thời gian trong biến ngày, vì mốc trong cột ngày đại diện không thể được quy cho một thời gian cụ thể và do đó không thể tính toán hợp lý sự chuyển đổi thời gian bằng giờ\nĐể xử lý múi giờ, có một số hàm trợ giúp trong lubridate có thể được sử dụng để thay đổi múi giờ của đối tượng datetime từ múi giờ địa phương sang các múi giờ khác. Múi giờ được đặt bằng cách gán múi giờ cơ sở dữ liệu tz hợp lệ cho đối tượng datetime. Bạn có thể tìm thấy danh sách những thứ này tại đây - nếu vị trí bạn đang sử dụng dữ liệu không có trong danh sách này, các múi giờ của thành phố lớn lân cận có thể được sử dụng thay thế.\nhttps://en.wikipedia.org/wiki/List_of_tz_database_time_zones\n\n# assign the current time to a column\ntime_now &lt;- Sys.time()\ntime_now\n\n[1] \"2024-05-10 05:12:35 CEST\"\n\n# use with_tz() to assign a new timezone to the column, while CHANGING the clock time\ntime_london_real &lt;- with_tz(time_now, \"Europe/London\")\n\n# use force_tz() to assign a new timezone to the column, while KEEPING the clock time\ntime_london_local &lt;- force_tz(time_now, \"Europe/London\")\n\n\n# note that as long as the computer that was used to run this code is NOT set to London time,\n# there will be a difference in the times \n# (the number of hours difference from the computers time zone to london)\ntime_london_real - time_london_local\n\nTime difference of -1 hours\n\n\nĐiều này có vẻ trừu tượng và thường không cần thiết nếu người dùng không làm việc trên các múi giờ.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Làm việc với ngày tháng</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.vn.html#phép-toán-về-khoảng-thời-gian",
    "href": "new_pages/dates.vn.html#phép-toán-về-khoảng-thời-gian",
    "title": "9  Làm việc với ngày tháng",
    "section": "9.11 Phép toán về khoảng thời gian",
    "text": "9.11 Phép toán về khoảng thời gian\nlead() và lag() là các hàm thuộc package dplyr giúp tìm các giá trị trước đó (lagged) hoặc tiếp theo (leading) trong một vectơ - thường là vectơ số hoặc ngày. Điều này rất hữu ích khi thực hiện các phép tính về sự thay đổi / chênh lệch giữa các đơn vị thời gian.\nGiả sử bạn muốn tính toán sự khác biệt trong trường hợp giữa tuần hiện tại và tuần trước đó. Dữ liệu ban đầu được cung cấp theo số lượng hàng tuần như dưới đây.\n\n\n\n\n\n\nKhi sử dụng hàm lag() hoặc lead(), thứ tự của các dòng trong khung dữ liệu là rất quan trọng! - chú ý xem ngày/số của bạn tăng dần hay giảm dần\nĐầu tiên, tạo một cột mới chứa giá trị của tuần trước đó (lagged).\n\nKiểm soát số lượng đơn vị trước/sau với n = (phải là số nguyên không âm)\n\nSử dụng default = để xác định giá trị được đặt trong các dòng không tồn tại (vd: hàng đầu tiên không có giá trị lagged). Mặc định, nó là NA.\n\nSử dụng order_by = TRUE nếu các dòng không được sắp xếp theo cột tham chiếu\n\n\ncounts &lt;- counts %&gt;% \n  mutate(cases_prev_wk = lag(cases_wk, n = 1))\n\n\n\n\n\n\n\nTiếp theo, tạo một cột mới khác biệt với hai cột đang tham chiếu:\n\ncounts &lt;- counts %&gt;% \n  mutate(cases_prev_wk = lag(cases_wk, n = 1),\n         case_diff = cases_wk - cases_prev_wk)\n\n\n\n\n\n\n\nBạn có thể đọc thêm về hàm lead() và lag() trong tài liệu này hoặc gõ ?lag vào cửa sổ console.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Làm việc với ngày tháng</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.vn.html#nguồn",
    "href": "new_pages/dates.vn.html#nguồn",
    "title": "9  Làm việc với ngày tháng",
    "section": "9.12 Nguồn",
    "text": "9.12 Nguồn\nlubridate tidyverse page\nlubridate RStudio cheatsheet\nR for Data Science page on dates and times\nOnline tutorial Date formats",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Làm việc với ngày tháng</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.vn.html",
    "href": "new_pages/characters_strings.vn.html",
    "title": "10  Ký tự và chuỗi",
    "section": "",
    "text": "10.1 Chuẩn bị",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Ký tự và chuỗi</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.vn.html#chuẩn-bị",
    "href": "new_pages/characters_strings.vn.html#chuẩn-bị",
    "title": "10  Ký tự và chuỗi",
    "section": "",
    "text": "Gọi packages\nCài đặt hoặc gọi package stringr và các packages tidyverse khác.\n\n# install/load packages\npacman::p_load(\n  stringr,    # many functions for handling strings\n  tidyverse,  # for optional data manipulation\n  tools)      # alternative for converting to title case\n\n\n\nNhập dữ liệu\nĐể bắt đầu, chúng ta nhập bộ dữ liệu có tên linelist đã làm sạch bao gồm các trường hợp từ vụ dịch Ebola mô phỏng. Để tiện theo dõi, bấm để tải dữ liệu linelist “đã được làm sạch”  (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương Nhập xuất dữ liệu để biết thêm chi tiết).\n\n# import case linelist \nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\n50 hàng đầu tiên của bộ dữ liệu linelist được hiển thị bên dưới.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Ký tự và chuỗi</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.vn.html#hợp-nhất-tách-và-sắp-xếp",
    "href": "new_pages/characters_strings.vn.html#hợp-nhất-tách-và-sắp-xếp",
    "title": "10  Ký tự và chuỗi",
    "section": "10.2 Hợp nhất, tách, và sắp xếp",
    "text": "10.2 Hợp nhất, tách, và sắp xếp\nChương này bao gồm:\n\nSử dụng hàm str_c(), str_glue(), và unite() để ghép nối ký tự\nSử dụng hàm str_order() để sắp xếp ký tự\nSử dụng hàm str_split() và separate() để phân tách ký tự\n\n\nKết hợp các chuỗi ký tự\nĐể kết hợp hoặc nối nhiều chuỗi ký tự thành một chuỗi ký tự, chúng tôi khuyên bạn nên sử dụng hàm str_c từ stringr. Nếu bạn có các giá trị ký tự riêng biệt để kết hợp, đơn giản chỉ cần cung cấp chúng dưới dạng đối số, được phân tách bằng dấu phẩy.\n\nstr_c(\"String1\", \"String2\", \"String3\")\n\n[1] \"String1String2String3\"\n\n\nĐối số sep = chèn một giá dạng trị ký tự vào giữa mỗi đối số ký tự bạn cung cấp (ví dụ: chèn dấu phẩy, dấu cách hoặc dòng mới \"\\n\")\n\nstr_c(\"String1\", \"String2\", \"String3\", sep = \", \")\n\n[1] \"String1, String2, String3\"\n\n\nĐối số collapse = có liên quan nếu bạn đang nhập nhiều vectơ làm đối số cho hàm str_c(). Nó được sử dụng để tách các phần tử của một vectơ kết quả, sao cho vectơ kết quả chỉ là một phần tử chứa ký tự dài.\nVí dụ dưới đây cho thấy sự kết hợp của hai vectơ thành một (tên và họ). Một ví dụ tương tự khác có thể là các phạm vi địa chính và số lượng trường hợp. Trong ví dụ này:\n\nGiá trị sep = xuất hiện giữa từng họ và tên\nGiá trị collapse = xuất hiện giữa tên từng người\n\n\nfirst_names &lt;- c(\"abdul\", \"fahruk\", \"janice\") \nlast_names  &lt;- c(\"hussein\", \"akinleye\", \"okeke\")\n\n# sep displays between the respective input strings, while collapse displays between the elements produced\nstr_c(first_names, last_names, sep = \" \", collapse = \";  \")\n\n[1] \"abdul hussein;  fahruk akinleye;  janice okeke\"\n\n\nLưu ý: Tùy thuộc vào trường hợp hiển thị mong muốn, khi in một chuỗi kết hợp như vậy với các dòng mới, bạn có thể cần phải đặt toàn bộ cụm từ trong hàm cat() để các dòng mới được in đúng cách:\n\n# For newlines to print correctly, the phrase may need to be wrapped in cat()\ncat(str_c(first_names, last_names, sep = \" \", collapse = \";\\n\"))\n\nabdul hussein;\nfahruk akinleye;\njanice okeke\n\n\n\n\nChuỗi động\nSử dụng hàm str_glue() để chèn đoạn code động của R vào chuỗi ký tự. Đây là một hàm hữu dụng để tạo tiêu đề biểu đồ động, như được mô tả dưới đây:\n\nTất cả nội dung nằm giữa dấu ngoặc kép str_glue(\"\")\n\nBất kỳ đoạn code động hoặc tham chiếu nào đến các giá trị được xác định trước đều được đặt trong dấu ngoặc nhọn {}, bên trong dấu ngoặc kép. Có thể có nhiều dấu ngoặc nhọn trong cùng một câu lệnh str_glue().\n\nĐể hiển thị dấu ngoặc kép “, hãy sử dụng dấu ngoặc đơn bên trong dấu ngoặc kép (ví dụ: khi cung cấp định dạng ngày - xem ví dụ bên dưới)\nMẹo: Bạn có thể sử dụng \\n để bắt buộc xuống một dòng mới\n\nMẹo: Bạn có thể sử dụng hàm format() để điều chỉnh hiển thị ngày và sử dụng hàm Sys.Date() để hiển thị ngày hiện tại.\n\nMột ví dụ đơn giản về tiêu đề biểu đồ động:\n\nstr_glue(\"Data include {nrow(linelist)} cases and are current to {format(Sys.Date(), '%d %b %Y')}.\")\n\nData include 5888 cases and are current to 10 May 2024.\n\n\nMột định dạng thay thế là sử dụng trình giữ chỗ (placeholder) bên trong dấu ngoặc kép và chỉ định chúng trong các đối số ở phía sau trong hàm str_glue() như bên dưới. Việc này sẽ làm tăng tính tường minh cho code nếu phần văn bản dài.\n\nstr_glue(\"Linelist as of {current_date}.\\nLast case hospitalized on {last_hospital}.\\n{n_missing_onset} cases are missing date of onset and not shown\",\n         current_date = format(Sys.Date(), '%d %b %Y'),\n         last_hospital = format(as.Date(max(linelist$date_hospitalisation, na.rm=T)), '%d %b %Y'),\n         n_missing_onset = nrow(linelist %&gt;% filter(is.na(date_onset)))\n         )\n\nLinelist as of 10 May 2024.\nLast case hospitalized on 30 Apr 2015.\n256 cases are missing date of onset and not shown\n\n\nKéo từ bộ dữ liệu\nĐôi khi, sẽ rất hữu ích khi lấy dữ liệu từ một bộ dữ liệu và dán chúng lại với nhau theo trình tự. Dưới đây là một ví dụ về bộ dữ liệu. Chúng ta sẽ sử dụng cách này để có một phát biểu tóm tắt về các khu vực pháp lý, cũng như số ca mắc mới và tổng số ca.\n\n# make case data frame\ncase_table &lt;- data.frame(\n  zone        = c(\"Zone 1\", \"Zone 2\", \"Zone 3\", \"Zone 4\", \"Zone 5\"),\n  new_cases   = c(3, 0, 7, 0, 15),\n  total_cases = c(40, 4, 25, 10, 103)\n  )\n\n\n\n\n\n\n\nSử dụng hàm str_glue_data(), được thiết kế để lấy dữ liệu từ các quan sát của bộ dữ liệu:\n\ncase_table %&gt;% \n  str_glue_data(\"{zone}: {new_cases} ({total_cases} total cases)\")\n\nZone 1: 3 (40 total cases)\nZone 2: 0 (4 total cases)\nZone 3: 7 (25 total cases)\nZone 4: 0 (10 total cases)\nZone 5: 15 (103 total cases)\n\n\nKết hợp các chuỗi ký tự trên các dòng\nNếu bạn đang cố gắng để “gộp” các giá trị trong một cột của bộ dữ liệu, ví dụ: kết hợp các giá trị từ nhiều hàng thành một hàng bằng cách gắn chúng với nhau cùng ký tự phân cách, hãy xem thêm ở chương Loại bỏ trùng lặp mục “gộp” các giá trị.\nMột bộ dữ liệu thành một dòng\nBạn có thể tạo ra dãy thông tin chỉ trong một dòng bằng cách sử dụng lệnh str_c() (cụ thể tên bộ dữ liệu và tên cột), đồng thời cung cấp các đối số sep = và collapse =.\n\nstr_c(case_table$zone, case_table$new_cases, sep = \" = \", collapse = \";  \")\n\n[1] \"Zone 1 = 3;  Zone 2 = 0;  Zone 3 = 7;  Zone 4 = 0;  Zone 5 = 15\"\n\n\nBạn có thể thêm đoạn tiền tố “New Cases:” vào đầu dòng thông tin bằng cách đặt trong hàm str_c() (nếu “New Cases:” nằm trong hàm str_c() ban đầu thì nó sẽ xuất hiện nhiều lần).\n\nstr_c(\"New Cases: \", str_c(case_table$zone, case_table$new_cases, sep = \" = \", collapse = \";  \"))\n\n[1] \"New Cases: Zone 1 = 3;  Zone 2 = 0;  Zone 3 = 7;  Zone 4 = 0;  Zone 5 = 15\"\n\n\n\n\nHợp nhất các cột\nTrong bộ dữ liệu, việc tập hợp các giá trị dạng ký tự từ nhiều cột lại với nhau có thể thực hiện bằng cách dùng hàm unite() từ package tidyr. Tính năng này ngược lại với hàm separate().\nĐầu tiên, cần tên của cột mới. Sau đó, cần tên của các cột mà bạn muốn hợp nhất.\n\nMặc định, dấu ngăn cách được sử dụng trong cột hợp nhất là dấu gạch dưới _, nhưng có thể được thay đổi bằng đối số sep =.\n\nremove = loại bỏ các cột ban đầu ra khỏi bộ dữ liệu (mặc định là TRUE)\n\nna.rm = loại bỏ các giá trị bị thiếu trong khi hợp nhất (mặc định là FALSE)\n\nDưới đây, chúng tôi xác định một bộ dữ liệu ngắn để minh họa:\n\ndf &lt;- data.frame(\n  case_ID = c(1:6),\n  symptoms  = c(\"jaundice, fever, chills\",     # patient 1\n                \"chills, aches, pains\",        # patient 2 \n                \"fever\",                       # patient 3\n                \"vomiting, diarrhoea\",         # patient 4\n                \"bleeding from gums, fever\",   # patient 5\n                \"rapid pulse, headache\"),      # patient 6\n  outcome = c(\"Recover\", \"Death\", \"Death\", \"Recover\", \"Recover\", \"Recover\"))\n\n\ndf_split &lt;- separate(df, symptoms, into = c(\"sym_1\", \"sym_2\", \"sym_3\"), extra = \"merge\")\n\nWarning: Expected 3 pieces. Missing pieces filled with `NA` in 2 rows [3, 4].\n\n\nĐây là bộ dữ liệu mẫu:\n\n\n\n\n\n\nDưới đây, chúng tôi hợp nhất ba cột triệu chứng:\n\ndf_split %&gt;% \n  unite(\n    col = \"all_symptoms\",         # name of the new united column\n    c(\"sym_1\", \"sym_2\", \"sym_3\"), # columns to unite\n    sep = \", \",                   # separator to use in united column\n    remove = TRUE,                # if TRUE, removes input cols from the data frame\n    na.rm = TRUE                  # if TRUE, missing values are removed before uniting\n  )\n\n  case_ID                all_symptoms outcome\n1       1     jaundice, fever, chills Recover\n2       2        chills, aches, pains   Death\n3       3                       fever   Death\n4       4         vomiting, diarrhoea Recover\n5       5 bleeding, from, gums, fever Recover\n6       6      rapid, pulse, headache Recover\n\n\n\n\n\nTách chuỗi\nĐể tách một chuỗi ký tự dựa trên một quy luật, hãy sử dụng hàm str_split(). Hàm này đánh giá (các) chuỗi ký tự và trả về danh sách list các vectơ ký tự chứa các giá trị mới được tách.\nVí dụ đơn giản dưới đây đánh giá một chuỗi ký tự và chia nó thành ba phần. Mặc định, hàm trả về một đối tượng kiểu danh sách list với một phần tử (một vectơ ký tự) cho mỗi chuỗi được cung cấp ban đầu. Nếu simplify = TRUE nó trả về một ma trận ký tự.\nTrong ví dụ này, một chuỗi ký tự được cung cấp và hàm trả về một danh sách có một phần tử - một vectơ ký tự chứa ba giá trị.\n\nstr_split(string = \"jaundice, fever, chills\",\n          pattern = \",\")\n\n[[1]]\n[1] \"jaundice\" \" fever\"   \" chills\" \n\n\nNếu kết quả được lưu, thì bạn có thể truy cập giá trị phân chia thứ n bằng cú pháp dấu ngoặc vuông. Để truy cập vào một giá trị cụ thể, bạn có thể sử dụng cú pháp như sau: the_returned_object[[1]][2], sẽ truy cập giá trị thứ hai từ chuỗi ký tự được đánh giá thứ nhất (“fever”). Xem thêm ở chương R Cơ bản để biết thêm chi tiết về cách truy vấn các phần tử.\n\npt1_symptoms &lt;- str_split(\"jaundice, fever, chills\", \",\")\n\npt1_symptoms[[1]][2]  # extracts 2nd value from 1st (and only) element of the list\n\n[1] \" fever\"\n\n\nNếu nhiều chuỗi ký tự được sử dụng trong hàm str_split(), sẽ có nhiều hơn một phần tử trong danh sách trả về.\n\nsymptoms &lt;- c(\"jaundice, fever, chills\",     # patient 1\n              \"chills, aches, pains\",        # patient 2 \n              \"fever\",                       # patient 3\n              \"vomiting, diarrhoea\",         # patient 4\n              \"bleeding from gums, fever\",   # patient 5\n              \"rapid pulse, headache\")       # patient 6\n\nstr_split(symptoms, \",\")                     # split each patient's symptoms\n\n[[1]]\n[1] \"jaundice\" \" fever\"   \" chills\" \n\n[[2]]\n[1] \"chills\" \" aches\" \" pains\"\n\n[[3]]\n[1] \"fever\"\n\n[[4]]\n[1] \"vomiting\"   \" diarrhoea\"\n\n[[5]]\n[1] \"bleeding from gums\" \" fever\"            \n\n[[6]]\n[1] \"rapid pulse\" \" headache\"  \n\n\nThay vào đó, để trả về “ma trận chuỗi ký tự”, có thể sẽ hữu ích nếu tạo cột trong bộ dữ liệu, đặt đối số simplify = TRUE như trình bày dưới đây:\n\nstr_split(symptoms, \",\", simplify = TRUE)\n\n     [,1]                 [,2]         [,3]     \n[1,] \"jaundice\"           \" fever\"     \" chills\"\n[2,] \"chills\"             \" aches\"     \" pains\" \n[3,] \"fever\"              \"\"           \"\"       \n[4,] \"vomiting\"           \" diarrhoea\" \"\"       \n[5,] \"bleeding from gums\" \" fever\"     \"\"       \n[6,] \"rapid pulse\"        \" headache\"  \"\"       \n\n\nBạn cũng có thể điều chỉnh số phần tách ra với đối số n =. Ví dụ dưới đây giới hạn số phần tách ra là 2. Bất kỳ dấu phẩy nào khác vẫn sẽ nằm trong giá trị thứ hai.\n\nstr_split(symptoms, \",\", simplify = TRUE, n = 2)\n\n     [,1]                 [,2]            \n[1,] \"jaundice\"           \" fever, chills\"\n[2,] \"chills\"             \" aches, pains\" \n[3,] \"fever\"              \"\"              \n[4,] \"vomiting\"           \" diarrhoea\"    \n[5,] \"bleeding from gums\" \" fever\"        \n[6,] \"rapid pulse\"        \" headache\"     \n\n\nLưu ý - các kết quả tương tự có thể đạt được với hàm str_split_fixed(), trong đó bạn không dùng đối số simplify mà thay vào đó phải chỉ định số cột (n).\n\nstr_split_fixed(symptoms, \",\", n = 2)\n\n\n\nTách cột\nNếu bạn đang cố gắng chia tách cột trong bộ dữ liệu, cách tốt nhất là sử dụng hàm separate() từ package dplyr. Nó được sử dụng để chia một cột ký tự thành các cột khác nhau.\nGiả sử chúng ta có một bộ dữ liệu đơn giản df (được xác định và hợp nhất trong unite section) chứa một cột case_ID , một cột dạng ký tự có nhiều triệu chứng và một cột outcome. Mục tiêu của chúng ta là tách cột symptoms thành nhiều cột - mỗi cột chứa một triệu chứng.\n\n\n\n\n\n\nGiả sử dữ liệu được đưa vào hàm separate(), trước tiên hãy chọn ra cột sẽ được phân tách. Sau đó, cung cấp thông tin tới đối số into = dưới dạng vectơ c( ) có chứa tên các cột mới, như được trình bày dưới đây.\n\nDấu phân cách trong sep = có thể là một ký tự hoặc một số (được hiểu là vị trí ký tự cần tách)\nMặc định là remove = FALSE, xóa cột đầu vào ban ban đầu\nMặc định là convert = FALSE, các ký tự “NA” sẽ thành NA\n\nextra = kiểm soát điều gì sẽ xảy ra nếu có nhiều giá trị được tạo bởi sự phân tách nhiều hơn các cột mới được đặt tên.\n\nextra = \"warn\" có nghĩa là bạn sẽ thấy một cảnh báo nhưng nó sẽ loại bỏ các giá trị thừa (mặc định là vậy)\n\nextra = \"drop\" có nghĩa là các giá trị thừa sẽ bị loại bỏ mà không có cảnh báo\nextra = \"merge\" sẽ chỉ phân tách thành số cột mới được liệt kê trong into - thiết lập này sẽ bảo toàn tất cả dữ liệu của bạn\n\n\nDưới đây là một ví dụ về extra = \"merge\" - không có dữ liệu nào bị mất. Hai cột mới được xác định nhưng bất kỳ triệu chứng thứ ba nào sẽ quy về trong cột mới thứ hai:\n\n# third symptoms combined into second new column\ndf %&gt;% \n  separate(symptoms, into = c(\"sym_1\", \"sym_2\"), sep=\",\", extra = \"merge\")\n\nWarning: Expected 2 pieces. Missing pieces filled with `NA` in 1 rows [3].\n\n\n  case_ID              sym_1          sym_2 outcome\n1       1           jaundice  fever, chills Recover\n2       2             chills   aches, pains   Death\n3       3              fever           &lt;NA&gt;   Death\n4       4           vomiting      diarrhoea Recover\n5       5 bleeding from gums          fever Recover\n6       6        rapid pulse       headache Recover\n\n\nKhi sử dụng lệnh extra = \"drop\" mặc định như bên dưới, một cảnh báo sẽ được đưa ra nhưng triệu chứng thứ ba bị mất:\n\n# third symptoms are lost\ndf %&gt;% \n  separate(symptoms, into = c(\"sym_1\", \"sym_2\"), sep=\",\")\n\nWarning: Expected 2 pieces. Additional pieces discarded in 2 rows [1, 2].\n\n\nWarning: Expected 2 pieces. Missing pieces filled with `NA` in 1 rows [3].\n\n\n  case_ID              sym_1      sym_2 outcome\n1       1           jaundice      fever Recover\n2       2             chills      aches   Death\n3       3              fever       &lt;NA&gt;   Death\n4       4           vomiting  diarrhoea Recover\n5       5 bleeding from gums      fever Recover\n6       6        rapid pulse   headache Recover\n\n\nCẨN TRỌNG: Nếu bạn không cung cấp đủ giá trị into cho các cột mới, dữ liệu của bạn có thể bị cắt bớt .\n\n\nSắp xếp theo thứ tự bảng chữ cái\nMột số chuỗi ký tự có thể được sắp xếp theo thứ tự bảng chữ cái. Hàm str_order() trả về thứ tự của các phần tử, trong khi hàm str_sort() trả về các chuỗi theo thứ tự đó.\n\n# strings\nhealth_zones &lt;- c(\"Alba\", \"Takota\", \"Delta\")\n\n# return the alphabetical order\nstr_order(health_zones)\n\n[1] 1 3 2\n\n# return the strings in alphabetical order\nstr_sort(health_zones)\n\n[1] \"Alba\"   \"Delta\"  \"Takota\"\n\n\nĐể sử dụng một bảng chữ cái khác, hãy thêm đối số locale =. Xem danh sách đầy đủ các locales bằng cách gõ stringi::stri_locale_list() trong cửa sổ R console.\n\n\nCác hàm base R\nCác hàm phổ biến của base R là paste() và paste0() nối các vectơ sau khi chuyển đổi tất cả các cấu phần thành ký tự. Chúng hoạt động tương tự như str_c() nhưng cú pháp được cho là phức tạp hơn - đó là trong ngoặc thì mỗi phần được phân tách bằng một dấu phẩy. Các cấu phần là ký tự dạng văn bản (trong dấu ngoặc kép) hoặc các đối tượng được xác định trước (không có dấu ngoặc kép). Ví dụ:\n\nn_beds &lt;- 10\nn_masks &lt;- 20\n\npaste0(\"Regional hospital needs \", n_beds, \" beds and \", n_masks, \" masks.\")\n\n[1] \"Regional hospital needs 10 beds and 20 masks.\"\n\n\nĐối số sep = và collapse = có thể được cụ thể. Hàm paste() chỉ đơn giản dán paste0() vớ đối số mặc định sep = \" \" (một khoảng trắng).",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Ký tự và chuỗi</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.vn.html#làm-sạch-và-chuẩn-hóa",
    "href": "new_pages/characters_strings.vn.html#làm-sạch-và-chuẩn-hóa",
    "title": "10  Ký tự và chuỗi",
    "section": "10.3 Làm sạch và chuẩn hóa",
    "text": "10.3 Làm sạch và chuẩn hóa\n\n\nThay đổi chữ hoa/chữ thường\nThông thường thì người ta cần phải thay đổi cách viết thường/viết hoa của một giá trị dạng chuỗi ký tự, ví dụ như tên địa danh. Hãy sử dụng hàm str_to_upper(), str_to_lower(), và str_to_title() từ stringr, như dưới đây:\n\nstr_to_upper(\"California\")\n\n[1] \"CALIFORNIA\"\n\nstr_to_lower(\"California\")\n\n[1] \"california\"\n\n\nSử dụng base R, bạn cũng có thể thực hiện điều trên với hàm toupper(), tolower().\nĐịnh dạng tiêu đề\nBiến đổi chuỗi ký tự sao cho mỗi từ được viết hoa có thể thực hiện được với hàm str_to_title():\n\nstr_to_title(\"go to the US state of california \")\n\n[1] \"Go To The Us State Of California \"\n\n\nSử dụng hàm toTitleCase() từ package tools để chuyển đổi nhiều kiểu viết in hoa hơn (các từ như “to”, “the” và “of” không cần viết hoa).\n\ntools::toTitleCase(\"This is the US state of california\")\n\n[1] \"This is the US State of California\"\n\n\nBạn cũng có thể sử dụng hàm str_to_sentence(), chỉ viết hoa chữ cái đầu tiên của chuỗi ký tự.\n\nstr_to_sentence(\"the patient must be transported\")\n\n[1] \"The patient must be transported\"\n\n\n\n\nĐộ dài chuỗi ký tự\nSử dụng hàm str_pad() để thêm các ký tự vào một chuỗi, với độ dài tối thiểu. Mặc định, khoảng trắng sẽ được thêm vào, nhưng bạn cũng có thể chèn các ký tự khác bằng cách sử dụng đối số pad =.\n\n# ICD codes of differing length\nICD_codes &lt;- c(\"R10.13\",\n               \"R10.819\",\n               \"R17\")\n\n# ICD codes padded to 7 characters on the right side\nstr_pad(ICD_codes, 7, \"right\")\n\n[1] \"R10.13 \" \"R10.819\" \"R17    \"\n\n# Pad with periods instead of spaces\nstr_pad(ICD_codes, 7, \"right\", pad = \".\")\n\n[1] \"R10.13.\" \"R10.819\" \"R17....\"\n\n\nVí dụ: để chèn thêm số bằng các số 0 ở đầu (chẳng hạn như giờ hoặc phút), bạn có thể chèn số có độ dài tối thiểu là 2 với pad = \"0\".\n\n# Add leading zeros to two digits (e.g. for times minutes/hours)\nstr_pad(\"4\", 2, pad = \"0\") \n\n[1] \"04\"\n\n# example using a numeric column named \"hours\"\n# hours &lt;- str_pad(hours, 2, pad = \"0\")\n\n\n\nCắt chuỗi ký tự\nHàm str_trunc() thiết lập độ dài tối đa cho mỗi chuỗi ký tự. Nếu một chuỗi vượt quá độ dài này, nó sẽ bị xén (rút ngắn) và kết thúc bằng một dấu ba chấm (…) ám chỉ rằng chuỗi đó chưa hiển thị hết các ký tự. Lưu ý rằng dấu ba chấm được tính toán phụ thuộc vào độ dài. Các ký tự dấu ba chấm có thể được thay đổi bằng đối số ellipsis =. Đối số tùy chọn side = làm rõ vị trí mà dấu ba chấm sẽ xuất hiện trong chuỗi bị cắt ngắn (bên “trái”, “phải” hoặc “giữa”).\n\noriginal &lt;- \"Symptom onset on 4/3/2020 with vomiting\"\nstr_trunc(original, 10, \"center\")\n\n[1] \"Symp...ing\"\n\n\n\n\nChuẩn hóa độ dài\nSử dụng hàm str_trunc() để thiết lập độ dài tối đa, sau đó sử dụng hàm str_pad() để tăng thêm độ dài cho các chuỗi rất ngắn sao cho bằng độ dài tiêu chuẩn. Trong ví dụ dưới đây, độ dài tối đa là 6 (một ký tự bị cắt giảm), và sau đó một giá trị rất ngắn được đệm thêm để đạt được độ dài chuỗi là 6.\n\n# ICD codes of differing length\nICD_codes   &lt;- c(\"R10.13\",\n                 \"R10.819\",\n                 \"R17\")\n\n# truncate to maximum length of 6\nICD_codes_2 &lt;- str_trunc(ICD_codes, 6)\nICD_codes_2\n\n[1] \"R10.13\" \"R10...\" \"R17\"   \n\n# expand to minimum length of 6\nICD_codes_3 &lt;- str_pad(ICD_codes_2, 6, \"right\")\nICD_codes_3\n\n[1] \"R10.13\" \"R10...\" \"R17   \"\n\n\n\n\nXóa khoảng trắng đầu/cuối\nSử dụng hàm str_trim() để xóa khoảng trắng, dòng mới (\\n) hoặc tabs (\\t) ở các phía của chuỗi đầu vào. Thêm \"right\" \"left\", hoặc \"both\" vào lệnh để xác định phía nào cần cắt (ví dụ: str_trim(x, \"right\").\n\n# ID numbers with excess spaces on right\nIDs &lt;- c(\"provA_1852  \", # two excess spaces\n         \"provA_2345\",   # zero excess spaces\n         \"provA_9460 \")  # one excess space\n\n# IDs trimmed to remove excess spaces on right side only\nstr_trim(IDs)\n\n[1] \"provA_1852\" \"provA_2345\" \"provA_9460\"\n\n\n\n\nXóa khoảng trắng lặp lại phía trong\nSử dụng hàm str_squish() để loại bỏ các khoảng trắng lặp lại bên trong một chuỗi. Ví dụ, để chuyển đổi khoảng trắng lặp thành khoảng trắng đơn. Điều này cũng sẽ loại bỏ dấu cách, dòng mới hoặc tab ở phía bên ngoài chuỗi như giống như hàm str_trim().\n\n# original contains excess spaces within string\nstr_squish(\"  Pt requires   IV saline\\n\") \n\n[1] \"Pt requires IV saline\"\n\n\nGõ ?str_trim, ?str_pad vào cửa sổ R console để biết thêm chi tiết.\n\n\nGói lại thành đoạn văn bản\nSử dụng hàm str_wrap() để gói một đoạn văn bản dài không có cấu trúc thành một đoạn văn có cấu trúc với độ dài các dòng là cố định. Cần xác định độ dài lý tưởng cho mỗi dòng và áp dụng một thuật toán để chèn thêm dòng mới (\\n) vào trong đoạn văn bản, như ví dụ bên dưới.\n\npt_course &lt;- \"Symptom onset 1/4/2020 vomiting chills fever. Pt saw traditional healer in home village on 2/4/2020. On 5/4/2020 pt symptoms worsened and was admitted to Lumta clinic. Sample was taken and pt was transported to regional hospital on 6/4/2020. Pt died at regional hospital on 7/4/2020.\"\n\nstr_wrap(pt_course, 40)\n\n[1] \"Symptom onset 1/4/2020 vomiting chills\\nfever. Pt saw traditional healer in\\nhome village on 2/4/2020. On 5/4/2020\\npt symptoms worsened and was admitted\\nto Lumta clinic. Sample was taken and pt\\nwas transported to regional hospital on\\n6/4/2020. Pt died at regional hospital\\non 7/4/2020.\"\n\n\nHàm cat() trong base R có thể xử lý toàn bộ câu lệnh trên để trả kết quả, hiển thị các dòng mới được thêm vào.\n\ncat(str_wrap(pt_course, 40))\n\nSymptom onset 1/4/2020 vomiting chills\nfever. Pt saw traditional healer in\nhome village on 2/4/2020. On 5/4/2020\npt symptoms worsened and was admitted\nto Lumta clinic. Sample was taken and pt\nwas transported to regional hospital on\n6/4/2020. Pt died at regional hospital\non 7/4/2020.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Ký tự và chuỗi</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.vn.html#xử-lý-theo-vị-trí",
    "href": "new_pages/characters_strings.vn.html#xử-lý-theo-vị-trí",
    "title": "10  Ký tự và chuỗi",
    "section": "10.4 Xử lý theo vị trí",
    "text": "10.4 Xử lý theo vị trí\n\nTách chuỗi theo vị trí ký tự\nSử dụng hàm str_sub() để trả về một phần của chuỗi. Hàm chứa 3 đối số chính là:\n\ncác vector ký tự\n\nvị trí bắt đầu\n\nvị trí kết thúc\n\nMột vài lưu ý về số thứ tự vị trí:\n\nNếu số thứ tự vị trí là số dương, vị trí được xử lý bắt đầu từ vị trí cuối cùng bên trái của chuỗi.\n\nNếu số thứ tự vị trí là số âm, vị trí được xử lý bắt đầu từ vị trí cuối cùng bên phải của chuỗi.\n\nSố thứ tự vị trí được bao gồm.\n\nCác vị trí vượt quá chuỗi sẽ bị cắt bớt (loại bỏ).\n\nDưới đây là một số ví dụ được áp dụng cho chuỗi ký tự “pneumonia”:\n\n# start and end third from left (3rd letter from left)\nstr_sub(\"pneumonia\", 3, 3)\n\n[1] \"e\"\n\n# 0 is not present\nstr_sub(\"pneumonia\", 0, 0)\n\n[1] \"\"\n\n# 6th from left, to the 1st from right\nstr_sub(\"pneumonia\", 6, -1)\n\n[1] \"onia\"\n\n# 5th from right, to the 2nd from right\nstr_sub(\"pneumonia\", -5, -2)\n\n[1] \"moni\"\n\n# 4th from left to a position outside the string\nstr_sub(\"pneumonia\", 4, 15)\n\n[1] \"umonia\"\n\n\n\n\nTách theo vị trí từ\nĐể tách ‘từ’ thứ n, hãy sử dụng hàm word() cũng thuộc package stringr. Đầu tiên, xác định (các) chuỗi ký tự, sau đó là vị trí từ đầu tiên cần trích xuất và vị trí từ cuối cùng để trích xuất.\nMặc định, dấu phân cách giữa các ‘từ’ được giả định là khoảng trắng, trừ khi được chỉ định cách khác bằng đối số sep = (ví dụ: sep = \"_\" khi các từ được phân tách bằng dấu gạch dưới)\n\n# strings to evaluate\nchief_complaints &lt;- c(\"I just got out of the hospital 2 days ago, but still can barely breathe.\",\n                      \"My stomach hurts\",\n                      \"Severe ear pain\")\n\n# extract 1st to 3rd words of each string\nword(chief_complaints, start = 1, end = 3, sep = \" \")\n\n[1] \"I just got\"       \"My stomach hurts\" \"Severe ear pain\" \n\n\n\n\nThay thế theo vị trí ký tự\nHàm str_sub() được ghép nối với toán tử gán (&lt;-) có thể được sử dụng để sửa đổi một phần của chuỗi ký tự:\n\nword &lt;- \"pneumonia\"\n\n# convert the third and fourth characters to X \nstr_sub(word, 3, 4) &lt;- \"XX\"\n\n# print\nword\n\n[1] \"pnXXmonia\"\n\n\nMột ví dụ áp dụng cho nhiều chuỗi (ví dụ: một cột). Lưu ý sự mở rộng về độ dài của từ “HIV”.\n\nwords &lt;- c(\"pneumonia\", \"tubercolosis\", \"HIV\")\n\n# convert the third and fourth characters to X \nstr_sub(words, 3, 4) &lt;- \"XX\"\n\nwords\n\n[1] \"pnXXmonia\"    \"tuXXrcolosis\" \"HIXX\"        \n\n\n\n\nĐánh giá độ dài chuỗi\n\nstr_length(\"abc\")\n\n[1] 3\n\n\nNgoài ra, có thể sử dụng hàm nchar() từ base R",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Ký tự và chuỗi</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.vn.html#quy-luật-chuỗi",
    "href": "new_pages/characters_strings.vn.html#quy-luật-chuỗi",
    "title": "10  Ký tự và chuỗi",
    "section": "10.5 Quy luật chuỗi",
    "text": "10.5 Quy luật chuỗi\nNhiều hàm stringr được sử dụng để nhận diện, định vị, trích xuất, khớp, thay thế và phân tách dựa trên một pattern - quy luật được chỉ định. .\n\n\nNhận diện quy luật\nSử dụng hàm str_detect() như bên dưới để phát hiện sự hiện diện/sự vắng mặt của một quy luật trong chuỗi. Đầu tiên, hãy cung cấp cho chuỗi hoặc vectơ cần tìm tới hàm (string =), sau đó là quy luật tìm kiếm (pattern =). Lưu ý rằng theo mặc định thì tìm kiếm phân biệt chữ hoa chữ thường!\n\nstr_detect(string = \"primary school teacher\", pattern = \"teach\")\n\n[1] TRUE\n\n\nĐối số negate = có thể được bao gồm và đặt thành TRUE nếu bạn muốn tìm một quy luật KHÔNG xuất hiện.\n\nstr_detect(string = \"primary school teacher\", pattern = \"teach\", negate = TRUE)\n\n[1] FALSE\n\n\nĐể bỏ qua chữ hoa / chữ thường, hãy đặt pattern trong hàm regex(), và bên trong hàm regex() hãy thêm đối số ignore_case = TRUE (hoặc viết tắt là T).\n\nstr_detect(string = \"Teacher\", pattern = regex(\"teach\", ignore_case = T))\n\n[1] TRUE\n\n\nKhi hàm str_detect() được áp dụng cho một vectơ ký tự hoặc một cột trong bộ dữ liệu, nó sẽ trả về giá trị TRUE hoặc FALSE cho mỗi giá trị.\n\n# a vector/column of occupations \noccupations &lt;- c(\"field laborer\",\n                 \"university professor\",\n                 \"primary school teacher & tutor\",\n                 \"tutor\",\n                 \"nurse at regional hospital\",\n                 \"lineworker at Amberdeen Fish Factory\",\n                 \"physican\",\n                 \"cardiologist\",\n                 \"office worker\",\n                 \"food service\")\n\n# Detect presence of pattern \"teach\" in each string - output is vector of TRUE/FALSE\nstr_detect(occupations, \"teach\")\n\n [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nNếu bạn cần đếm giá trị TRUE, chỉ cần đơn giản tính tổng bằng hàm sum() kết quả đầu ra. Nó sẽ đếm số lượng giá trị TRUE.\n\nsum(str_detect(occupations, \"teach\"))\n\n[1] 1\n\n\nĐể tìm kiếm bao gồm nhiều cụm từ, hãy nhóm chúng bằng ký tự OR (|) bên trong đối số pattern = như được trình bày dưới đây:\n\nsum(str_detect(string = occupations, pattern = \"teach|professor|tutor\"))\n\n[1] 3\n\n\nNếu bạn cần xây dựng một danh sách dài gồm các cụm từ cần tìm kiếm, bạn có thể kết hợp chúng bằng cách sử dụng hàm str_c() và sep = |, sau đó chỉ định nó là một đối tượng dạng ký tự, và sau đó tham chiếu vector một cách ngắn gọn hơn. Ví dụ dưới đây bao gồm các cụm từ tìm kiếm bao gồm các nghề nghiệp có thể sử dụng cho các nhà cung cấp dịch vụ y tế tuyến đầu.\n\n# search terms\noccupation_med_frontline &lt;- str_c(\"medical\", \"medicine\", \"hcw\", \"healthcare\", \"home care\", \"home health\",\n                                \"surgeon\", \"doctor\", \"doc\", \"physician\", \"surgery\", \"peds\", \"pediatrician\",\n                               \"intensivist\", \"cardiologist\", \"coroner\", \"nurse\", \"nursing\", \"rn\", \"lpn\",\n                               \"cna\", \"pa\", \"physician assistant\", \"mental health\",\n                               \"emergency department technician\", \"resp therapist\", \"respiratory\",\n                                \"phlebotomist\", \"pharmacy\", \"pharmacist\", \"hospital\", \"snf\", \"rehabilitation\",\n                               \"rehab\", \"activity\", \"elderly\", \"subacute\", \"sub acute\",\n                                \"clinic\", \"post acute\", \"therapist\", \"extended care\",\n                                \"dental\", \"dential\", \"dentist\", sep = \"|\")\n\noccupation_med_frontline\n\n[1] \"medical|medicine|hcw|healthcare|home care|home health|surgeon|doctor|doc|physician|surgery|peds|pediatrician|intensivist|cardiologist|coroner|nurse|nursing|rn|lpn|cna|pa|physician assistant|mental health|emergency department technician|resp therapist|respiratory|phlebotomist|pharmacy|pharmacist|hospital|snf|rehabilitation|rehab|activity|elderly|subacute|sub acute|clinic|post acute|therapist|extended care|dental|dential|dentist\"\n\n\nLệnh này trả về số lượng nghề nghiệp mà chứa bất kỳ một trong các cụm từ tìm kiếm dành cho nhà cung cấp dịch vụ y tế tuyến đầu (occupation_med_frontline):\n\nsum(str_detect(string = occupations, pattern = occupation_med_frontline))\n\n[1] 2\n\n\nCác hàm tìm kiếm chuỗi trong Base R\nHàm grepl() trong base R hoạt động tương tự như hàm str_detect(), trong đó nó tìm kiếm các kết quả phù hợp với một quy luật và trả về một vectơ logic. Cú pháp cơ bản đó là grepl(pattern, strings_to_search, ignore.case = FALSE, ...). Một ưu điểm đó là đối số ignore.case dễ viết hơn (không cần có sự tham gia của hàm regex()).\nTương tự như vậy, các hàm sub() và gsub() của base R hoạt động tương tự như hàm str_replace(). Cú pháp cơ bản đó là: gsub(pattern, replacement, strings_to_search, ignore.case = FALSE). sub() sẽ thay thế trường hợp đầu tiên của pattern, trong khi gsub() sẽ thay thế tất cả các trường hợp của pattern.\n\nChuyển đổi dấu phẩy thành dấu chấm\nSau đây là một ví dụ về việc sử dụng hàm gsub() để chuyển đổi dấu phẩy thành dấu chấm trong một vectơ dạng số. Điều này có thể hữu ích nếu dữ liệu của bạn bắt nguồn từ nhiều nơi trên thế giới ngoài Hoa Kỳ hoặc Vương quốc Anh.\nHàm gsub() ở bên trong đầu tiên hoạt động trên đối tượng lengths để chuyển đổi bất kỳ dấu chấm nào thành không có khoảng trắng ““. Ký tự dấu chấm”.” phải được “đi liền” với hai dấu gạch chéo để biểu thị một dấu chấm, bởi vì “.” trong biểu thức chính quy có nghĩa là “bất kỳ ký tự nào”. Sau đó, kết quả (chỉ có dấu phẩy) được chuyển tiếp đến hàm gsub() bên ngoài trong đó dấu phẩy được thay thế bằng dấu chấm.\n\nlengths &lt;- c(\"2.454,56\", \"1,2\", \"6.096,5\")\n\nas.numeric(gsub(pattern = \",\",                # find commas     \n                replacement = \".\",            # replace with periods\n                x = gsub(\"\\\\.\", \"\", lengths)  # vector with other periods removed (periods escaped)\n                )\n           )                                  # convert outcome to numeric\n\n\n\n\nThay thế toàn bộ\nSử dụng hàm str_replace_all() như là một công cụ “find and replace (tìm kiếm và thay thế)”. Đầu tiên, cung cấp các chuỗi ký tự sẽ được đánh giá tới đối số string =, sau đó là quy luật sẽ được thay thế vào đối số pattern =, và sau đó là giá trị thay thế vào replacement =. Ví dụ dưới đây thay thế tất cả các trường hợp “dead” bằng “deceased”. Lưu ý, phân biệt chữ hoa chữ thường.\n\noutcome &lt;- c(\"Karl: dead\",\n            \"Samantha: dead\",\n            \"Marco: not dead\")\n\nstr_replace_all(string = outcome, pattern = \"dead\", replacement = \"deceased\")\n\n[1] \"Karl: deceased\"      \"Samantha: deceased\"  \"Marco: not deceased\"\n\n\nLưu ý:\n\nĐể thay thế một pattern cho NA, sử dụng hàm str_replace_na().\n\nHàm str_replace() thay thế duy nhất trường hợp đầu tiên của pattern trong mỗi chuỗi ký tự.\n\n\n\n\nNhận diện logic\nBên trong hàm case_when()\nstr_detect() thường được sử dụng trong hàm case_when() (từ dplyr). Hãy coi occupations là một cột trong bộ linelist. Hàm mutate() dưới đây tạo một cột mới gọi là is_educator bằng cách sử dụng logic có điều kiện bởi case_when(). Xem thêm ở chương về làm sạch dữ liệu để hiểu hơn về hàm case_when().\n\ndf &lt;- df %&gt;% \n  mutate(is_educator = case_when(\n    # term search within occupation, not case sensitive\n    str_detect(occupations,\n               regex(\"teach|prof|tutor|university\",\n                     ignore_case = TRUE))              ~ \"Educator\",\n    # all others\n    TRUE                                               ~ \"Not an educator\"))\n\nXin nhắc lại, điều quan trọng là phải thêm tiêu chí loại trừ vào điều kiện logic (negate = F):\n\ndf &lt;- df %&gt;% \n  # value in new column is_educator is based on conditional logic\n  mutate(is_educator = case_when(\n    \n    # occupation column must meet 2 criteria to be assigned \"Educator\":\n    # it must have a search term AND NOT any exclusion term\n    \n    # Must have a search term\n    str_detect(occupations,\n               regex(\"teach|prof|tutor|university\", ignore_case = T)) &              \n    \n    # AND must NOT have an exclusion term\n    str_detect(occupations,\n               regex(\"admin\", ignore_case = T),\n               negate = TRUE                        ~ \"Educator\"\n    \n    # All rows not meeting above criteria\n    TRUE                                            ~ \"Not an educator\"))\n\n\n\n\nĐịnh vị vị trí pattern\nĐể xác định vị trí đầu tiên của một pattern, hãy sử dụng hàm str_locate(). Nó xuất ra vị trí bắt đầu và kết thúc.\n\nstr_locate(\"I wish\", \"sh\")\n\n     start end\n[1,]     5   6\n\n\nGiống như các hàm str khác, có một phiên bản “_all” (str_locate_all()) sẽ trả về vị trí của tất cả các phiên bản của pattern trong mỗi chuỗi. Kết quả này xuất ra dưới dạng danh sách list.\n\nphrases &lt;- c(\"I wish\", \"I hope\", \"he hopes\", \"He hopes\")\n\nstr_locate(phrases, \"h\" )     # position of *first* instance of the pattern\n\n     start end\n[1,]     6   6\n[2,]     3   3\n[3,]     1   1\n[4,]     4   4\n\nstr_locate_all(phrases, \"h\" ) # position of *every* instance of the pattern\n\n[[1]]\n     start end\n[1,]     6   6\n\n[[2]]\n     start end\n[1,]     3   3\n\n[[3]]\n     start end\n[1,]     1   1\n[2,]     4   4\n\n[[4]]\n     start end\n[1,]     4   4\n\n\n\n\n\nTrích xuất kết quả ghép cặp\nstr_extract_all() trả về các patterns được matching, sẽ hữu dụng nhất khi bạn cung cấp một vài patterns thông qua điều kiện “OR”. Ví dụ: tìm trong vectơ chuỗi nghề nghiệp (xem tab trước) các từ “teach”, “prof” hoặc “tutor”.\nstr_extract_all() trả về một danh sách list chứa tất cả các kết quả ghép cặp cho mỗi chuỗi được đánh giá. Xem dưới đây ta thấy occupation 3 có hai pattern được tìm thấy.\n\nstr_extract_all(occupations, \"teach|prof|tutor\")\n\n[[1]]\ncharacter(0)\n\n[[2]]\n[1] \"prof\"\n\n[[3]]\n[1] \"teach\" \"tutor\"\n\n[[4]]\n[1] \"tutor\"\n\n[[5]]\ncharacter(0)\n\n[[6]]\ncharacter(0)\n\n[[7]]\ncharacter(0)\n\n[[8]]\ncharacter(0)\n\n[[9]]\ncharacter(0)\n\n[[10]]\ncharacter(0)\n\n\nstr_extract() chỉ trích xuất kết quả ghép cặp đầu tiên trong mỗi chuỗi được xem xét, tạo ra một vectơ ký tự với một phần tử cho mỗi chuỗi được xem xét. Nó trả về giá trị NA khi không có giá trị nào được tìm thấy. Các giá trị NA có thể được loại bỏ bằng cách đặt vectơ trả về trong hàm na.exclude(). Lưu ý đoạn khớp nối thứ hai của occupation 3 không được hiển thị.\n\nstr_extract(occupations, \"teach|prof|tutor\")\n\n [1] NA      \"prof\"  \"teach\" \"tutor\" NA      NA      NA      NA      NA     \n[10] NA     \n\n\n\n\n\nTập hợp con và số lượng\nBao gồm hàm str_subset() và str_count().\nstr_subset() trả về các giá trị thực có chứa pattern:\n\nstr_subset(occupations, \"teach|prof|tutor\")\n\n[1] \"university professor\"           \"primary school teacher & tutor\"\n[3] \"tutor\"                         \n\n\nstr_count() trả về một vectơ số: số lần một cụm từ tìm kiếm xuất hiện trong mỗi giá trị được xem xét.\n\nstr_count(occupations, regex(\"teach|prof|tutor\", ignore_case = TRUE))\n\n [1] 0 1 2 1 0 0 0 0 0 0\n\n\n\n\n\nNhóm Regex\nĐANG ĐƯỢC XÂY DỰNG",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Ký tự và chuỗi</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.vn.html#các-ký-tự-đặc-biệt",
    "href": "new_pages/characters_strings.vn.html#các-ký-tự-đặc-biệt",
    "title": "10  Ký tự và chuỗi",
    "section": "10.6 Các ký tự đặc biệt",
    "text": "10.6 Các ký tự đặc biệt\nDấu gạch chéo ngược \\ để bỏ qua\nDấu gạch chéo ngược \\ được sử dụng “để bỏ qua” nghĩa của ký tự tiếp theo. Bằng cách này, dấu gạch chéo ngược có thể được sử dụng để hiển thị dấu ngoặc kép bên trong các dấu ngoặc kép khác (\\\") - dấu ngoặc kép ở giữa sẽ không “phá vỡ” các dấu ngoặc kép xung quanh.\nLưu ý - do đó, nếu bạn muốn hiển thị một dấu gạch chéo ngược, bạn phải ngắt nghĩa của nó bằng một dấu gạch chéo ngược khác. Vì vậy, bạn phải viết hai dấu gạch chéo ngược \\\\ để chỉ hiển thị một.\nCác ký tự đặc biệt\n\n\n\n\n\n\n\nKý tự đặc biệt\nÝ nghĩa\n\n\n\n\n\"\\\\\"\nDấu gạch chéo ngược\n\n\n\"\\n\"\nmột dòng mới\n\n\n\"\\\"\"\ndấu ngoặc kép trong dấu ngoặc kép\n\n\n'\\''\ndấu ngoặc đơn trong dấu ngoặc đơn\n\n\n\"\\“| grave accent”| carriage return“| tab”| vertical tab“`\nbackspace\n\n\n\nGõ ?\"'\" trong cửa sổ R Console để hiển thị danh sách đầy đủ các ký tự đặc biệt (nó sẽ xuất hiện trong cửa sổ Help của RStudio).",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Ký tự và chuỗi</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.vn.html#biểu-thức-chính-quy-regex",
    "href": "new_pages/characters_strings.vn.html#biểu-thức-chính-quy-regex",
    "title": "10  Ký tự và chuỗi",
    "section": "10.7 Biểu thức chính quy (regex)",
    "text": "10.7 Biểu thức chính quy (regex)",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Ký tự và chuỗi</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.vn.html#regex-và-các-ký-tự-đặc-biệt",
    "href": "new_pages/characters_strings.vn.html#regex-và-các-ký-tự-đặc-biệt",
    "title": "10  Ký tự và chuỗi",
    "section": "10.8 Regex và các ký tự đặc biệt",
    "text": "10.8 Regex và các ký tự đặc biệt\nBiểu thức chính quy, hoặc “regex”, là một ngôn ngữ ngắn gọn để mô tả các patterns trong chuỗi ký tự. Nếu bạn không quen với nó, một biểu thức chính quy có thể trông giống như một ngôn ngữ ngoài hành tinh. Ở đây chúng tôi cố lột tả ngôn ngữ này dễ hiểu hơn\nPhần lớn nội dung mục này được tham khảo từ hướng dẫn này và cheatsheet này. Chúng tôi tóm tắt một cách chọn lọc ở đây khi biết rằng cuốn ebook này có thể được xem bởi những người không có quyền truy cập internet để có thể xem các hướng dẫn khác.\nMột biểu thức chính quy thường được áp dụng để trích xuất các pattern cụ thể từ văn bản “không có cấu trúc” - ví dụ: ghi chú y tế, khiếu nại, tiền sử bệnh tật hoặc các cột văn bản khác trong bộ dữ liệu.\nCó bốn công cụ cơ bản mà người ta có thể sử dụng để tạo một biểu thức chính quy cơ bản:\n\nBộ ký tự\n\nSiêu ký tự\n\nBộ định lượng\n\nNhóm\n\nBộ ký tự\nBộ ký tự, là một cách thể hiện các tùy chọn liệt kê phù hợp với ký tự gốc, trong dấu ngoặc. Vì vậy, mọi kết quả khớp sẽ được đánh dấu nếu tìm thấy bất kỳ ký tự nào trong dấu ngoặc trong chuỗi. Ví dụ, để tìm các nguyên âm, người ta có thể sử dụng bộ ký tự này: “[aeiou]”. Một số bộ ký tự phổ biến khác là:\n\n\n\nBộ ký tự\nGhép cặp\n\n\n\n\n\"[A-Z]\"\nbất kỳ ký tự viết hoa đơn lẻ nào\n\n\n\"[a-z]\"\nbất kỳ ký tự viết thường đơn lẻ nào\n\n\n\"[0-9]\"\nbất kỳ số nào\n\n\n[:alnum:]\nbất kỳ ký tự chữ và số nào\n\n\n[:digit:]\nbất kỳ chữ số nào\n\n\n[:alpha:]\nbất kỳ ký tự nào (viết hoa hoặc viết thường)\n\n\n[:upper:]\nbất kỳ ký tự viết hoa nào\n\n\n[:lower:]\nbất kỳ ký tự viết thường nào\n\n\n\nCác bộ ký tự có thể được kết hợp trong một dấu ngoặc vuông (không có khoảng trắng!), chẳng hạn như \"[A-Za-z]\" (bất kỳ chữ cái viết hoa hoặc viết thường nào), hoặc một ví dụ khác \"[t-z0-5]\" (từ t viết thường đến z HOẶC số 0 đến 5).\nSiêu ký tự\nCác siêu ký tự là cách viết tắt của các bộ ký tự. Một số điều quan trọng được liệt kê dưới đây:\n\n\n\nSiêu ký tự\nÝ nghĩa\n\n\n\n\n\"\\\\s\"\nkhoảng trắng đơn\n\n\n\"\\\\w\"\nbất kỳ ký tự chữ hoặc số đơn lẻ nào (A-Z, a-z, or 0-9)\n\n\n\"\\\\d\"\nbất kỳ chữ số đơn lẻ nào (0-9)\n\n\n\nBộ định lượng\nThông thường, bạn không muốn tìm kiếm kết quả phù hợp chỉ trên một ký tự. Bộ định lượng cho phép bạn chỉ định độ dài của các chữ cái/số để cho phép ghép nối.\nBộ định lượng là các số được viết trong dấu ngoặc nhọn { } sau ký tự mà chúng đang định lượng, ví dụ:\n\n\"A{2}\" sẽ trả về trường hợp hai chữ cái A viết hoa.\n\n\"A{2,4}\" sẽ trả về các trường hợp từ hai đến bốn chữ cái A viết hoa (không đặt dấu cách!).\n\n\"A{2,}\" sẽ trả về các trường hợp từ hai hoặc nhiều hơn chữ cái A viết hoa.\n\n\"A+\" sẽ trả về các trường hợp từ một hoặc nhiều hơn chữ cái A viết hoa (nhóm được mở rộng cho đến khi gặp một ký tự khác).\n\nBắt đầu bằng dấu hoa thị * để trả về không hoặc nhiều hơn kết quả phù hợp (hữu ích nếu bạn không chắc chắn pattern có sẵn)\n\nSử dụng ký hiệu dấu cộng + như một bộ định lượng, việc khớp sẽ xảy ra cho tới khi gặp ký tự khác. Ví dụ, biểu thứ này sẽ trả về tất cả các từ (ký tự alpha: \"[A-Za-z]+\"\n\n# test string for quantifiers\ntest &lt;- \"A-AA-AAA-AAAA\"\n\nKhi bộ định lượng {2} được sử dụng, chỉ các cặp chữ A liên tiếp được trả về. Hai cặp được xác định trong AAAA.\n\nstr_extract_all(test, \"A{2}\")\n\n[[1]]\n[1] \"AA\" \"AA\" \"AA\" \"AA\"\n\n\nKhi bộ định lượng {2,4} được sử dụng, các nhóm chữ A liên tiếp có độ dài từ hai đến bốn được trả về.\n\nstr_extract_all(test, \"A{2,4}\")\n\n[[1]]\n[1] \"AA\"   \"AAA\"  \"AAAA\"\n\n\nVới bộ định lượng +, các nhóm của một hoặc nhiều hơn được trả về:\n\nstr_extract_all(test, \"A+\")\n\n[[1]]\n[1] \"A\"    \"AA\"   \"AAA\"  \"AAAA\"\n\n\nVị trí tương đối\nNhững biểu thức dưới đây yêu cầu cho những thứ đứng trước hoặc theo sau một mẫu. Ví dụ, để trích xuất câu, “two numbers that are followed by a period” (\"\"). (?&lt;=\\.)\\s(?=[A-Z])\n\nstr_extract_all(test, \"\")\n\n[[1]]\n [1] \"A\" \"-\" \"A\" \"A\" \"-\" \"A\" \"A\" \"A\" \"-\" \"A\" \"A\" \"A\" \"A\"\n\n\n\n\n\nBiểu thức vị trí\nKhớp với\n\n\n\n\n\"(?&lt;=b)a\"\n“a” bị đứng trước bởi “b”\n\n\n\"(?&lt;!b)a\"\n“a” KHÔNG bị đứng trước bởi “b”\n\n\n\"a(?=b)\"\n“a” được theo sau bởi “b”\n\n\n\"a(?!b)\"\n“a” KHÔNG được theo sau bởi “b”\n\n\n\nNhóm\nViệc bắt các nhóm trong biểu thức chính quy là một cách để kết quả trả về có tổ chức hơn khi trích xuất.\nVí dụ về Regex\nDưới đây là một văn bản tự do sử dụng làm ví dụ. Chúng ta sẽ cố gắng trích xuất thông tin hữu ích từ nó bằng cách sử dụng cụm từ tìm kiếm theo biểu thức chính quy.\n\npt_note &lt;- \"Patient arrived at Broward Hospital emergency ward at 18:00 on 6/12/2005. Patient presented with radiating abdominal pain from LR quadrant. Patient skin was pale, cool, and clammy. Patient temperature was 99.8 degrees farinheit. Patient pulse rate was 100 bpm and thready. Respiratory rate was 29 per minute.\"\n\nBiểu thức sau đây khớp với tất cả các từ (bất kỳ ký tự nào cho đến khi gặp thứ không phải ký tự, chẳng hạn như dấu cách):\n\nstr_extract_all(pt_note, \"[A-Za-z]+\")\n\n[[1]]\n [1] \"Patient\"     \"arrived\"     \"at\"          \"Broward\"     \"Hospital\"   \n [6] \"emergency\"   \"ward\"        \"at\"          \"on\"          \"Patient\"    \n[11] \"presented\"   \"with\"        \"radiating\"   \"abdominal\"   \"pain\"       \n[16] \"from\"        \"LR\"          \"quadrant\"    \"Patient\"     \"skin\"       \n[21] \"was\"         \"pale\"        \"cool\"        \"and\"         \"clammy\"     \n[26] \"Patient\"     \"temperature\" \"was\"         \"degrees\"     \"farinheit\"  \n[31] \"Patient\"     \"pulse\"       \"rate\"        \"was\"         \"bpm\"        \n[36] \"and\"         \"thready\"     \"Respiratory\" \"rate\"        \"was\"        \n[41] \"per\"         \"minute\"     \n\n\nBiểu thức \"[0-9]{1,2}\" khớp với các số liên tiếp có độ dài 1 hoặc 2 chữ số. Nó cũng có thể được viết là \"\\\\d{1,2}\", hoặc \"[:digit:]{1,2}\".\n\nstr_extract_all(pt_note, \"[0-9]{1,2}\")\n\n[[1]]\n [1] \"18\" \"00\" \"6\"  \"12\" \"20\" \"05\" \"99\" \"8\"  \"10\" \"0\"  \"29\"\n\n\n\n\n\n\nBạn có thể xem danh sách hữu ích về các biểu thức regex và các mẹo trên trang 2 của cheatsheet này\nBạn cũng có thể xem tutorial này.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Ký tự và chuỗi</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.vn.html#nguồn",
    "href": "new_pages/characters_strings.vn.html#nguồn",
    "title": "10  Ký tự và chuỗi",
    "section": "10.9 Nguồn",
    "text": "10.9 Nguồn\nBạn có thể tìm thấy trang tham khảo cho các hàm stringr tại đây\nMột vignette về stringr có thể được tìm thấy tại đây",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Ký tự và chuỗi</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.vn.html",
    "href": "new_pages/factors.vn.html",
    "title": "11  Kiểu dữ liệu danh mục - Factors",
    "section": "",
    "text": "11.1 Chuẩn bị",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Kiểu dữ liệu danh mục - Factors</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.vn.html#chuẩn-bị",
    "href": "new_pages/factors.vn.html#chuẩn-bị",
    "title": "11  Kiểu dữ liệu danh mục - Factors",
    "section": "",
    "text": "Gọi packages\nĐoạn code dưới đây hiển thị cách gọi các package cần thiết cho việc phân tích. Trong sách này, chúng tôi nhấn mạnh đến việc sử dụng hàm p_load() từ package pacman, giúp cài đặt package nếu nó chưa được cài và gọi nó ra cho phiên làm việc. Bạn cũng có thể gọi các package đã được cài đặt bằng hàm library() từ base R. Xem chương R cơ bản để biết thêm thông tin về các package trong R.\n\npacman::p_load(\n  rio,           # import/export\n  here,          # filepaths\n  lubridate,     # working with dates\n  forcats,       # factors\n  aweek,         # create epiweeks with automatic factor levels\n  janitor,       # tables\n  tidyverse      # data mgmt and viz\n  )\n\n\n\nNhập dữ liệu\nChúng ta sẽ nhập bộ dữ liệu về các trường hợp từ một vụ dịch Ebola mô phỏng. Để tiện muốn theo dõi, bấm để tải bộ dữ liệu linelist “đã được làm sạch” (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm import() từ package rio (hàm có thể áp dụng với nhiều loại dữ liệu như .xlsx, .rds, .csv - Xem chương Nhập xuất dữ liệu để biết thêm chi tiết).\n\n# import your dataset\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\n\n\nThêm biến danh mục mới\nTrong chương này, chúng tôi sẽ minh họa một trường hợp thường gặp, đó là tạo ra một biến danh mục mới.\nLưu ý rằng khi bạn chuyển đổi một cột dạng số thành dạng factor, bạn sẽ không thể thực hiện các tính toán thống kê đối với dữ liệu dạng số trên cột đó nữa.\n\nTạo biến\nChúng ta sẽ sử dụng một biến có sẵn, tên là days_onset_hosp (số ngày, tính từ khi bắt đầu có triệu chứng cho đến khi nhập viện) và tạo một biến mới có tên delay_cat bằng cách phân loại các giá trị trong mỗi hàng của biến có sẵn đó thành một số nhóm khác nhau. Chúng ta sẽ thực hiện việc này bằng hàm case_when() trong package dplyr, hàm này sẽ giúp áp dụng tuần tự các tiêu chí logic (phía bên phải) cho mỗi giá trị của biễn có sẵn và trả về giá trị bên trái tương ứng ở biến mới delay_cat. Đọc thêm về case_when() tại chương Làm sạch số liệu và các hàm quan trọng.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(delay_cat = case_when(\n    # criteria                                   # new value if TRUE\n    days_onset_hosp &lt; 2                        ~ \"&lt;2 days\",\n    days_onset_hosp &gt;= 2 & days_onset_hosp &lt; 5 ~ \"2-5 days\",\n    days_onset_hosp &gt;= 5                       ~ \"&gt;5 days\",\n    is.na(days_onset_hosp)                     ~ NA_character_,\n    TRUE                                       ~ \"Check me\"))  \n\n\n\nThứ tự mặc định của các giá trị\nKhi sử dụng hàm case_when(), biến mới delay_cat tạo ra sẽ là một biến danh mục với kiểu dữ liệu là ký tự - chưa phải là một factor. Do đó, trong bảng tần suất dưới đây, chúng ta thấy rằng các giá trị xuất hiện theo thứ tự mặc định của bảng chữ cái, điều này không có nhiều ý nghĩa trực quan:\n\ntable(linelist$delay_cat, useNA = \"always\")\n\n\n &lt;2 days  &gt;5 days 2-5 days     &lt;NA&gt; \n    2990      602     2040      256 \n\n\nTương tự như vậy, nếu chúng ta tạo biểu đồ cột, các giá trị cũng xuất hiện theo thứ tự này trên trục x (xem chương ggplot cơ bản để hiểu thêm về package ggplot2 - package giúp trực quan hóa dữ liệu phổ biến nhất trong R).\n\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = delay_cat))",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Kiểu dữ liệu danh mục - Factors</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.vn.html#định-nghĩa-dữ-liệu-sang-kiểu-factor",
    "href": "new_pages/factors.vn.html#định-nghĩa-dữ-liệu-sang-kiểu-factor",
    "title": "11  Kiểu dữ liệu danh mục - Factors",
    "section": "11.2 Định nghĩa dữ liệu sang kiểu factor",
    "text": "11.2 Định nghĩa dữ liệu sang kiểu factor\nĐể chuyển đổi một biến dạng ký tự hoặc dạng số sang dạng factor, bạn có thể sử dụng bất kỳ hàm nào trong package forcats (nhiều hàm được nêu chi tiết tại mục dưới đây). Các biến sẽ chuyển đổi sang dạng factor và sau đó cũng thực hiện hoặc sắp xếp theo một thứ tự nhất định của các levels - ví dụ: hàm fct_relevel() cho phép bạn chỉ định thứ tự levels theo cách thủ công. Hàm as_factor() chỉ đơn giản là chuyển đổi biến sang dạng factor mà không có thêm bất kỳ chức năng nào khác.\nHàm factor() trong base R chuyển đổi một biến thành factor và cho phép bạn tự sắp xếp thứ tự của các nhóm giá trị, dưới dạng một vectơ ký tự của đối số levels =.\nDưới đây, chúng tôi sử dụng hàm mutate() và hàm fct_relevel() để chuyển đối biến có sẵn delay_cat từ dạng ký tự sang dạng factor. Biến delay_cat đã được tạo ở phần Chuẩn bị bên trên.\n\nlinelist &lt;- linelist %&gt;%\n  mutate(delay_cat = fct_relevel(delay_cat))\n\nCác “giá trị” duy nhất trong biến số được gọi là các “thứ bậc” của biến factor. Các thứ bậc này được sắp xếp theo một trật tự nhất định và có thể được in ra bằng hàm levels() từ base R, hoặc bạn có thể xem nó bằng một bảng đếm thông qua hàm table()từ base R, hoặc hàm tabyl() từ package janitor. Trật tự này sẽ được hiển thị theo thứ tự của bảng chữ cái. Lưu ý rằng NA không được xem là một thứ bậc trong factor.\n\nlevels(linelist$delay_cat)\n\n[1] \"&lt;2 days\"  \"&gt;5 days\"  \"2-5 days\"\n\n\nHàm fct_relevel() có thêm chức năng cho phép bạn có thể tự sắp xếp trật tự của các thứ bậc trong factor. Đơn giản, bạn chỉ cần viết các thứ bậc theo thứ tự bạn muốn, để chúng trong dấu ngoặc kép, được phân tách bằng dấu phẩy, như được hiển thị bên dưới. Lưu ý rằng chính tả phải khớp chính xác với tên các thứ bậc. Nếu bạn muốn tạo các thứ bậc không tồn tại trong dữ liệu, hãy sử dụng hàm fct_expand().\n\nlinelist &lt;- linelist %&gt;%\n  mutate(delay_cat = fct_relevel(delay_cat, \"&lt;2 days\", \"2-5 days\", \"&gt;5 days\"))\n\nBây giờ chúng ta có thể thấy rằng các thứ bậc đã được sắp xếp theo một thứ tự hợp lý.\n\nlevels(linelist$delay_cat)\n\n[1] \"&lt;2 days\"  \"2-5 days\" \"&gt;5 days\" \n\n\nBây giờ trật tự các cột trong biểu đồ cũng trực quan hơn.\n\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = delay_cat))",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Kiểu dữ liệu danh mục - Factors</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.vn.html#thêm-hoặc-xóa-thứ-bậc",
    "href": "new_pages/factors.vn.html#thêm-hoặc-xóa-thứ-bậc",
    "title": "11  Kiểu dữ liệu danh mục - Factors",
    "section": "11.3 Thêm hoặc xóa thứ bậc",
    "text": "11.3 Thêm hoặc xóa thứ bậc\n\nThêm thứ bậc\nNếu bạn cần thêm thứ bậc trong factor, bạn có thể sử dụng hàm fct_expand(). Bạn chỉ cần viết tên biến và theo sau là tên các thứ bậc mới (phân tách bằng dấu phẩy). Bằng cách lập bảng, chúng ta có thể thấy các thứ bậc mới xuất hiện và chưa nhận giá trị nào. Bạn có thể sử dụng hàm table() trong base R, hoặc hàm tabyl() trong package janitor:\n\nlinelist %&gt;% \n  mutate(delay_cat = fct_expand(delay_cat, \"Not admitted to hospital\", \"Transfer to other jurisdiction\")) %&gt;% \n  tabyl(delay_cat)   # print table\n\n                      delay_cat    n    percent valid_percent\n                        &lt;2 days 2990 0.50781250     0.5308949\n                       2-5 days 2040 0.34646739     0.3622159\n                        &gt;5 days  602 0.10224185     0.1068892\n       Not admitted to hospital    0 0.00000000     0.0000000\n Transfer to other jurisdiction    0 0.00000000     0.0000000\n                           &lt;NA&gt;  256 0.04347826            NA\n\n\nLưu ý: Package forcats có thể dễ dàng thêm các giá trị missing (NA) như là một thứ bậc. Bạn có thể xem thêm tại mục Giá trị Missing dưới đây.\n\n\nXóa thứ bậc\nNếu bạn sử dụng hàm fct_drop(), các thứ bậc “không được sử dụng” và không có quan sát nào sẽ bị loại bỏ khỏi factors. Thứ bậc mà chúng ta đã thêm ở trên (“Not admitted to a hospital”) có tồn tại nhưng thực tế không có dòng nào chứa giá trị này. Vì vậy, chúng sẽ bị loại bỏ khỏi biến factor của chúng ta bằng cách sử dụng hàm fct_drop() như sau:\n\nlinelist %&gt;% \n  mutate(delay_cat = fct_drop(delay_cat)) %&gt;% \n  tabyl(delay_cat)\n\n delay_cat    n    percent valid_percent\n   &lt;2 days 2990 0.50781250     0.5308949\n  2-5 days 2040 0.34646739     0.3622159\n   &gt;5 days  602 0.10224185     0.1068892\n      &lt;NA&gt;  256 0.04347826            NA",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Kiểu dữ liệu danh mục - Factors</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.vn.html#fct_adjust",
    "href": "new_pages/factors.vn.html#fct_adjust",
    "title": "11  Kiểu dữ liệu danh mục - Factors",
    "section": "11.4 Thay đổi trật tự của các thứ bậc",
    "text": "11.4 Thay đổi trật tự của các thứ bậc\nPackage forcats cung cấp các hàm hữu ích để dễ dàng thay đổi trật tự của các thứ bậc trong một biến kiểu factor (sau khi một biến số được định nghĩa là một factor):\nCác hàm trong package này có thể được áp dụng cho biến dạng factor trong hai trường hợp dưới đây:\n\nĐối với cột trong một data frame, thông thường, việc thay đổi sẽ được giữ nguyên cho các lần sử dụng dữ liệu tiếp theo\nTrong một biểu đồ, sự thay đổi trật tự chỉ được áp dụng cho biểu đồ đó\n\n\nThay đổi thủ công\nHàm này được sử dụng để thay đổi trật tự của các thứ bậc trong một biến dạng factor theo cách thủ công. Nếu hàm này được sử dụng trên một biến dạng khác, không phải factor, hàm sẽ giúp chuyển biến đó sang dạng factor trước.\nTrong dấu ngoặc đơn trước tiên điền tên của biến factor, sau đó điền:\n\nTất cả các thứ bậc trong biến factor mà bạn mong muốn thay đổi trật tự (dưới dạng vector ký tự c()), hoặc\nChỉ một giá trị thứ bậc với vị trí tương ứng mong muốn, sử dụng đối số after =\n\nDưới đây là một ví dụ về chuyển biến delay_cat thành dạng factor (mặc dù biến này đã ở dạng Factor rồi) và sắp xếp lại các thứ bậc theo thứ tự mong muốn.\n\n# re-define level order\nlinelist &lt;- linelist %&gt;% \n  mutate(delay_cat = fct_relevel(delay_cat, c(\"&lt;2 days\", \"2-5 days\", \"&gt;5 days\")))\n\nNếu bạn chỉ muốn chỉ định vị trí cho một thứ bậc, bạn có thể dùng hàm fct_relevel() và sử dụng đối số after = để chỉ định một giá trị thứ bậc với vị trí tương ứng mong muốn. Ví dụ: lệnh dưới đây chuyển thứ bậc “&lt;2 days” sang vị trí thứ hai:\n\n# re-define level order\nlinelist %&gt;% \n  mutate(delay_cat = fct_relevel(delay_cat, \"&lt;2 days\", after = 1)) %&gt;% \n  tabyl(delay_cat)\n\n\n\nĐối với biểu đồ\nCác lệnh trong package forcats có thể được sử dụng để thay đổi trật tự của biến trong data frame hoặc trong biểu đồ. Bằng cách sử dụng các lệnh để “gói” tên biến vào trong các lệnh vẽ biểu đồ của package ggplot(), bạn có thể dảo ngược/thay đổi một trật tự có sẵn của biến. Sự thay đổi này chỉ áp dụng trong biểu đồ đang vẽ.\nDưới đây, hai biểu đồ đều được vẽ bởi hàm ggplot() (xem thêm tại chương ggplot cơ bản). Trong biểu đồ đầu tiên, biến delay_cat được vẽ trên trục x của biểu đồ với thứ tự các thứ bậc là mặc định trong dữ liệu linelist. Trong biểu đồ thứ hai, biến được đặt trong bởi hàm fct_relevel() và trật tự của các thứ bậc đã được sắp xếp lại.\n\n# Alpha-numeric default order - no adjustment within ggplot\nggplot(data = linelist)+\n    geom_bar(mapping = aes(x = delay_cat))\n\n# Factor level order adjusted within ggplot\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = fct_relevel(delay_cat, c(\"&lt;2 days\", \"2-5 days\", \"&gt;5 days\"))))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLưu ý rằng, ở biểu đồ thứ hai, tiêu đề mặc định của trục x được hiện khá phức tạp - bạn có thể sử tiêu đề này bằng đối số labs() trong ggplot2.\n\n\nĐảo ngược thứ tự\nBạn sẽ thường xuyên cần đảo ngược trật tự của các thứ bậc trong một biến. Đơn giản, bạn chỉ cần thêm tên biến vào bên trong hàm fct_rev().\nLưu ý rằng, nếu bạn chỉ muốn đảo ngược thứ tự trong một biểu đồ chứ không phải thứ tự của biến đó, bạn có thể thực hiện điều đó với hàm guides() (Xem thêm tại chương Các mẹo với ggplot).\n\n\nTheo tần suất\nĐể sắp xếp trật tự các thứ bậc theo tần suất mà nó xuất hiện trong dữ liệu, hãy sử dụng hàm fct_infreq(). Tất cả các giá trị mising (NA) sẽ tự động được đưa xuống cuối, trừ khi chúng được chuyển sang một thứ bậc khác (xem thêm ở mục này). Bạn có thể đảo ngược trật tự bằng cách thêm hàm fct_rev() vào câu lệnh.\nHàm này có thể được sử dụng trong ggplot(), như hình bên dưới.\n\n# ordered by frequency\nggplot(data = linelist, aes(x = fct_infreq(delay_cat)))+\n  geom_bar()+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Ordered by frequency\")\n\n# reversed frequency\nggplot(data = linelist, aes(x = fct_rev(fct_infreq(delay_cat))))+\n  geom_bar()+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Reverse of order by frequency\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTheo sự xuất hiện\nSử dụng hàm fct_inorder() để thiết lập thứ bậc tương tự với thứ tự xuất hiện của các giá trị trong dữ liệu, bắt đầu từ hàng đầu tiên. Điều này có thể hữu ích nếu trước đó bạn đã cẩn thận sắp xếp dữ liệu trong data frame bằng hàm arrange(), sau đó sử dụng điều này để đặt trật tự các thứ bậc của biến facror.\n\n\nTheo thống kê tóm tắt của một cột khác\nBạn có thể sử dụng hàm fct_reorder() để sắp xếp các thứ bậc của một biến theo thống kê tóm tắt của một biến khác. Về mặt trực quan, điều này có cho kết quả là các biểu đồ như ý bạn, có các cột/điểm lên hoặc xuống theo một chiều trong toàn bộ biểu đồ.\nTrong các ví dụ bên dưới, trục x là delay_cat, và trục y là ct_blood (giá trị ngưỡng chu kỳ). Biểu đồ hộp (Box plot) hiển thị phân bố của giá trị CT theo nhóm delay_cat. Chúng ta cần sắp xếp các hộp theo thứ tự tăng dần của giá trị trung vị CT của nhóm.\nTrong ví dụ đầu tiên bên dưới, các thứ bậc được sắp xếp một cách mặc định. Bạn có thể thấy các chiều cao của hộp bị lộn xộn và không theo bất kỳ thứ tự cụ thể nào. Trong ví dụ thứ hai, cột delay_cat (được sắp xếp theo trục x) đã được viết lệnh với hàm fct_reorder(), cột ct_blood được đưa ra làm đối số thứ hai và “trung vị” được đưa ra làm đối số thứ ba (bạn cũng có thể sử dụng “max”, “mean”, “min”, v.v.). Do đó, thứ tự các thứ bậc của biến delay_cat bây giờ sẽ phản ánh các giá trị trung vị CT tăng dần theo nhóm delay_cat. Điều này được trình bày trong biểu đồ thứ hai - các hộp đã được sắp xếp lại theo chiều tăng dần. Lưu ý giá trị missing NA sẽ luôn xuất hiện ở cuối, trừ khi được chuyển đổi thành một thứ bậc khác.\n\n# boxplots ordered by original factor levels\nggplot(data = linelist)+\n  geom_boxplot(\n    aes(x = delay_cat,\n        y = ct_blood, \n        fill = delay_cat))+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Ordered by original alpha-numeric levels\")+\n  theme_classic()+\n  theme(legend.position = \"none\")\n\n\n# boxplots ordered by median CT value\nggplot(data = linelist)+\n  geom_boxplot(\n    aes(x = fct_reorder(delay_cat, ct_blood, \"median\"),\n        y = ct_blood,\n        fill = delay_cat))+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Ordered by median CT value in group\")+\n  theme_classic()+\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLưu ý trong ví dụ bên trên không có bước nào được yêu cầu cần thực hiện trước khi gọi hàm ggplot() - việc nhóm và tính toán đều được thực hiện bên trong hàm ggplot.\n\n\nTheo giá trị cuối\nSử dụng hàm fct_reorder2() cho biểu đồ đường theo nhóm. Hàm sẽ sắp xếp thứ tự xuất hiện các nhóm (bao gồm cả phần chú giải) dọc theo biểu đồ. Nói về mặt kỹ thuật, nó “sắp xếp theo các giá trị y tương ứng với các giá trị x lớn nhất.”\nVí dụ, nếu bạn có các dòng hiển thị số lượng trường hợp theo bệnh viện và thời gian, bạn có thể áp dụng hàm fct_reorder2() cho đối số color = trong aes(), sao cho thứ tự của các bệnh viện xuất hiện trong phần chú giải tương đương với thứ tự xuất hiện của các đường trong biểu đồ. Đọc thêm trong tài liệu trực tuyến sau đây.\n\nepidemic_data &lt;- linelist %&gt;%         # begin with the linelist   \n    filter(date_onset &lt; as.Date(\"2014-09-21\")) %&gt;%    # cut-off date, for visual clarity\n    count(                                            # get case counts per week and by hospital\n      epiweek = lubridate::floor_date(date_onset, \"week\"),  \n      hospital                                            \n    ) \n  \nggplot(data = epidemic_data)+                       # start plot\n  geom_line(                                        # make lines\n    aes(\n      x = epiweek,                                  # x-axis epiweek\n      y = n,                                        # height is number of cases per week\n      color = fct_reorder2(hospital, epiweek, n)))+ # data grouped and colored by hospital, with factor order by height at end of plot\n  labs(title = \"Factor levels (and legend display) by line height at end of plot\",\n       color = \"Hospital\")                          # change legend title",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Kiểu dữ liệu danh mục - Factors</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.vn.html#fct_missing",
    "href": "new_pages/factors.vn.html#fct_missing",
    "title": "11  Kiểu dữ liệu danh mục - Factors",
    "section": "11.5 Giá trị Missing",
    "text": "11.5 Giá trị Missing\nNếu có giá trị missing NA trong biến factor của bạn, bạn có thể dễ dàng chuyển đổi chúng thành một thứ bậc được đặt tên với hàm fct_explicit_na(). Giá trị missing NA được chuyển đổi thành “(Missing)” mặc định sẽ được xếp cuối cùng. Bạn có thể điều chỉnh tên thứ bậc bằng đối số na_level =.\nVí dụ dưới đây được thực hiện trên biến delay_cat và một bảng được in bằngtabyl()với các giá trị missing NA được chuyển thành “Missing delay”.\n\nlinelist %&gt;% \n  mutate(delay_cat = fct_explicit_na(delay_cat, na_level = \"Missing delay\")) %&gt;% \n  tabyl(delay_cat)\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `delay_cat = fct_explicit_na(delay_cat, na_level = \"Missing\n  delay\")`.\nCaused by warning:\n! `fct_explicit_na()` was deprecated in forcats 1.0.0.\nℹ Please use `fct_na_value_to_level()` instead.\n\n\n     delay_cat    n    percent\n      2-5 days 2040 0.34646739\n       &lt;2 days 2990 0.50781250\n       &gt;5 days  602 0.10224185\n Missing delay  256 0.04347826",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Kiểu dữ liệu danh mục - Factors</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.vn.html#kết-hợp-các-thứ-bậc-trong-kiểu-dữ-liệu-factor",
    "href": "new_pages/factors.vn.html#kết-hợp-các-thứ-bậc-trong-kiểu-dữ-liệu-factor",
    "title": "11  Kiểu dữ liệu danh mục - Factors",
    "section": "11.6 Kết hợp các thứ bậc trong kiểu dữ liệu factor",
    "text": "11.6 Kết hợp các thứ bậc trong kiểu dữ liệu factor\n\nKết hợp thủ công\nBạn có thể điều chỉnh cách hiển thị của các thứ bậc theo cách thủ công với hàm fct_recode(). Điều này giống như hàm recode() trong package dplyr (xem thêm tại chương Làm sạch số liệu và các hàm quan trọng), nhưng nó cho phép tạo các thứ bậc mới. Nếu bạn đơn giản chỉ sử dụng hàm recode(), các giá trị được mã hóa mới sẽ bị từ chối trừ khi chúng đã được đặt ở thứ bậc cho phép.\nCông cụ này cũng có thể được sử dụng để “nhóm” các thứ bậc trong factor, bằng cách gán cho nhiều thứ bậc cùng một giá trị được mã hóa lại. Bạn cần cẩn thận để không bị mất thông tin! Hãy cân nhắc thực hiện hành động này trên một cột mới (không ghi đè lên cột hiện tại).\nHàm fct_recode() có cú pháp khác với hàm recode(). Hàm recode() sử dụng câu lệnh OLD = NEW, trong khi hàm fct_recode() sửu dụng câu lệnh NEW = OLD.\nNhững thứ bậc sẵn có của biến delay_cat như sau:\n\nlevels(linelist$delay_cat)\n\n[1] \"&lt;2 days\"  \"2-5 days\" \"&gt;5 days\" \n\n\nĐể tạo một thứ bậc mới, bạn sử dụng câu lệnh sau fct_recode(column, \"new\" = \"old\", \"new\" = \"old\", \"new\" = \"old\") và in ra như sau:\n\nlinelist %&gt;% \n  mutate(delay_cat = fct_recode(\n    delay_cat,\n    \"Less than 2 days\" = \"&lt;2 days\",\n    \"2 to 5 days\"      = \"2-5 days\",\n    \"More than 5 days\" = \"&gt;5 days\")) %&gt;% \n  tabyl(delay_cat)\n\n        delay_cat    n    percent valid_percent\n Less than 2 days 2990 0.50781250     0.5308949\n      2 to 5 days 2040 0.34646739     0.3622159\n More than 5 days  602 0.10224185     0.1068892\n             &lt;NA&gt;  256 0.04347826            NA\n\n\nỞ đây các thứ bậc cũ được kết hợp theo cách thủ công với fct_recode(). Lưu ý rằng không có lỗi phát sinh khi tạo thứ bậc mới “Less tham 5 days”.\n\nlinelist %&gt;% \n  mutate(delay_cat = fct_recode(\n    delay_cat,\n    \"Less than 5 days\" = \"&lt;2 days\",\n    \"Less than 5 days\" = \"2-5 days\",\n    \"More than 5 days\" = \"&gt;5 days\")) %&gt;% \n  tabyl(delay_cat)\n\n        delay_cat    n    percent valid_percent\n Less than 5 days 5030 0.85427989     0.8931108\n More than 5 days  602 0.10224185     0.1068892\n             &lt;NA&gt;  256 0.04347826            NA\n\n\n\n\nRút gọn thành nhóm “Khác”\nBạn có thể sử dụng hàm fct_other() để gán các thứ bậc của một cột dạng factor thành một thứ bậc mới “Other”. Dưới đây, tất cả các thứ bậc trong biến hospital, ngoại trừ “Port Hospital” và “Central Hospital”, được gộp chung thành “Other”. Bạn có thể cung cấp một vectơ để giữ keep =, hoặc loại bỏ drop =. Bạn có thể thay đổi cách hiển thị của thứ bậc “Other” bằng hàm other_level =.\n\nlinelist %&gt;%    \n  mutate(hospital = fct_other(                      # adjust levels\n    hospital,\n    keep = c(\"Port Hospital\", \"Central Hospital\"),  # keep these separate\n    other_level = \"Other Hospital\")) %&gt;%            # All others as \"Other Hospital\"\n  tabyl(hospital)                                   # print table\n\n         hospital    n    percent\n Central Hospital  454 0.07710598\n    Port Hospital 1762 0.29925272\n   Other Hospital 3672 0.62364130\n\n\n\n\nRút gọn theo tần suất\nBạn có thể tự động kết hợp các thứ bậc trong biến factor có tần suất ít nhất bằng cách sử dụng hàm fct_lump().\nĐể “gộp” nhiều giá trị tần suất thấp lại thành một nhóm khác “Other”, hãy thực hiện một trong các thao tác sau:\n\nĐặt n = là số nhóm bạn muốn giữ. n thứ bậc có tần suất nhiều nhất sẽ được giữ nguyên và tất cả các cấp độ khác sẽ kết hợp thành nhóm “Other”.\nĐặt prop = là ngưỡng tỷ lệ cho các thứ bậc bạn muốn giữ ở trên. Tất cả các giá trị khác sẽ kết hợp thành nhóm “Other”.\n\nBạn có thể thay đổi cách hiển thị của thứ bậc “Other” bằng hàm other_level =. Dưới đây, tất cả các giá trị ngoài hai bệnh viện phổ biến nhất đều được kết hợp thành nhóm “Other Hospital”.\n\nlinelist %&gt;%    \n  mutate(hospital = fct_lump(                      # adjust levels\n    hospital,\n    n = 2,                                          # keep top 2 levels\n    other_level = \"Other Hospital\")) %&gt;%            # all others as \"Other Hospital\"\n  tabyl(hospital)                                   # print table\n\n       hospital    n   percent\n        Missing 1469 0.2494905\n  Port Hospital 1762 0.2992527\n Other Hospital 2657 0.4512568",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Kiểu dữ liệu danh mục - Factors</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.vn.html#hiển-thị-tất-cả-thứ-bậc",
    "href": "new_pages/factors.vn.html#hiển-thị-tất-cả-thứ-bậc",
    "title": "11  Kiểu dữ liệu danh mục - Factors",
    "section": "11.7 Hiển thị tất cả thứ bậc",
    "text": "11.7 Hiển thị tất cả thứ bậc\nMột lợi ích của việc sử dụng factors là chuẩn hóa sự xuất hiện của các chú thích trong biểu đồ và bảng, bất kể giá trị nào thực sự có trong tập dữ liệu.\nNếu bạn đang chuẩn bị nhiều bảng biểu (ví dụ: cho nhiều khu vực pháp lý), bạn sẽ muốn các chú giải và bảng xuất hiện giống hệt nhau ngay cả với các mức độ hoàn thành dữ liệu hoặc thành phần dữ liệu khác nhau.\n\nTrong biểu đồ\nTrong hàm vẽ biểu đồ ggplot (), chỉ cần thêm đối số drop = FALSE trong hàm liên quan scale_xxxx(). Tất cả các thứ bậc trong biến factor sẽ được hiển thị, bất kể chúng có trong dữ liệu hay không. Nếu các thứ bậc trong biến factor của bạn được hiển thị bằng cách sử dụng fill =, thì trong scale_fill_discrete (), bạn cần thêm drop = FALSE, như được trình bày bên dưới. Nếu các thứ bậc trong biến factor của bạn được hiển thị với x = (đến trục x) color = hoặc size =, bạn sẽ cung cấp chúng tới scale_color_discrete() hoặc scale_size_discrete().\nVí dụ này là một biểu đồ cột chồng của nhóm tuổi, theo bệnh viện. Việc thêm scale_fill_discrete (drop = FALSE) đảm bảo rằng tất cả các nhóm tuổi đều xuất hiện trong chú giải, ngay cả khi không có trong dữ liệu.\n\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = hospital, fill = age_cat)) +\n  scale_fill_discrete(drop = FALSE)+                        # show all age groups in the legend, even those not present\n  labs(\n    title = \"All age groups will appear in legend, even if not present in data\")\n\n\n\n\n\n\n\n\n\n\nTrong bảng\nCả hàm table() trong base R và hàm tabyl() trong package janitor đều sẽ hiển thị tất cả các thứ bậc trong factor (ngay cả các thứ bậc không sử dụng).\nNếu bạn sử dụng hàm count() hoặc summarise() từ package dplyr để tạo bảng, hãy thêm đối số .drop = FALSE để hiển thị số lượng cho tất cả các thứ bậc trong factor ngay cả các thứ bậc không sử dụng.\nĐọc thêm tại chương Bảng mô tả,hoặc tại các link sau scale_discrete documentation, hoặc count() documentation. Bạn có thể tìm các ví dụ khác tại chương Truy vết tiếp xúc.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Kiểu dữ liệu danh mục - Factors</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.vn.html#tuần-dịch-tễ",
    "href": "new_pages/factors.vn.html#tuần-dịch-tễ",
    "title": "11  Kiểu dữ liệu danh mục - Factors",
    "section": "11.8 Tuần dịch tễ",
    "text": "11.8 Tuần dịch tễ\nVui lòng xem phần thảo luận đầy đủ về cách tạo các tuần dịch tễ trong chương Nhóm dữ liệu.\nVui lòng xem chương Làm việc với ngày tháng để biết các mẹo về cách tạo và định dạng các tuần dịch tễ học.\n\nTuần dịch tễ trong biểu đồ\nNếu mục tiêu của bạn là tạo các tuần dịch tễ học để hiển thị trong một biểu đồ, bạn có thể thực hiện việc này đơn giản với hàm floor_date() trong package lubridate, như được giải thích trong chương Nhóm dữ liệu. Các giá trị trả về sẽ thuộc loại Ngày tháng với định dạng YYYY-MM-DD. Nếu bạn sử dụng cột này trong một biểu đồ, ngày tháng sẽ tự nhiên được sắp xếp chính xác và bạn không cần phải lo lắng về thứ bậc hoặc chuyển đổi sang dạng factor. Xem biểu đồ histogram trong hàm ggplot() về các ngày khởi phát bên dưới.\nTrong cách tiếp cận này, bạn có thể điều chỉnh việc hiển thị của ngày tháng trên trục với scale_x_date(). Xem thêm tại trang Đường cong dịch bệnh để biết thêm thông tin. Bạn có thể chỉ định định dạng hiển thị date_labels = cho đối số scale_x_date(). Sử dụng “% Y” để đại diện cho năm có 4 chữ số và “% W” hoặc “% U” để đại diện cho số tuần (các tuần thứ Hai hoặc Chủ Nhật tương ứng).\n\nlinelist %&gt;% \n  mutate(epiweek_date = floor_date(date_onset, \"week\")) %&gt;%  # create week column\n  ggplot()+                                                  # begin ggplot\n  geom_histogram(mapping = aes(x = epiweek_date))+           # histogram of date of onset\n  scale_x_date(date_labels = \"%Y-W%W\")                       # adjust disply of dates to be YYYY-WWw\n\n\n\n\n\n\n\n\n\n\nTuần dịch tễ trong dữ liệu\nTuy nhiên, nếu mục đích của bạn với biến factor không phải để lập biểu đồ, bạn có thể tiếp cận theo một trong hai cách:\n\nĐể kiểm soát tốt việc hiển thị, hãy chuyển đổi cột lubridate tuần dịch tễ (YYYY-MM-DD) sang định dạng hiển thị mong muốn (YYYY-WWw) trong chính data frame, rồi chuyển đổi nó thành dạng factor.\n\nĐầu tiên, sử dụng hàm format() từ base R để chuyển đổi hiển thị ngày từ hiển thị YYYY-MM-DD sang hiển thị YYYY-Www (xem thêm tại chương Làm việc với ngày tháng). Trong quá trình này, kiểu của biến số sẽ được chuyển đổi thành ký tự. Sau đó, chuyển đổi từ kiểu ký tự sang kiểu Factor với hàm factor().\n\nlinelist &lt;- linelist %&gt;% \n  mutate(epiweek_date = floor_date(date_onset, \"week\"),       # create epiweeks (YYYY-MM-DD)\n         epiweek_formatted = format(epiweek_date, \"%Y-W%W\"),  # Convert to display (YYYY-WWw)\n         epiweek_formatted = factor(epiweek_formatted))       # Convert to factor\n\n# Display levels\nlevels(linelist$epiweek_formatted)\n\n [1] \"2014-W13\" \"2014-W14\" \"2014-W15\" \"2014-W16\" \"2014-W17\" \"2014-W18\"\n [7] \"2014-W19\" \"2014-W20\" \"2014-W21\" \"2014-W22\" \"2014-W23\" \"2014-W24\"\n[13] \"2014-W25\" \"2014-W26\" \"2014-W27\" \"2014-W28\" \"2014-W29\" \"2014-W30\"\n[19] \"2014-W31\" \"2014-W32\" \"2014-W33\" \"2014-W34\" \"2014-W35\" \"2014-W36\"\n[25] \"2014-W37\" \"2014-W38\" \"2014-W39\" \"2014-W40\" \"2014-W41\" \"2014-W42\"\n[31] \"2014-W43\" \"2014-W44\" \"2014-W45\" \"2014-W46\" \"2014-W47\" \"2014-W48\"\n[37] \"2014-W49\" \"2014-W50\" \"2014-W51\" \"2015-W00\" \"2015-W01\" \"2015-W02\"\n[43] \"2015-W03\" \"2015-W04\" \"2015-W05\" \"2015-W06\" \"2015-W07\" \"2015-W08\"\n[49] \"2015-W09\" \"2015-W10\" \"2015-W11\" \"2015-W12\" \"2015-W13\" \"2015-W14\"\n[55] \"2015-W15\" \"2015-W16\"\n\n\nNguy hiểm: Nếu bạn đặt các tuần trước các năm (“Www-YYYY”) (“%W-%Y”), thứ tự các thứ bậc sẽ sắp xếp mặc định theo bảng chữ cái và điều này là không chính xác (ví dụ: 01-2015 sẽ là trước 35-2014). Bạn có thể cần phải điều chỉnh thứ tự theo cách thủ công, đây sẽ là một quá trình dài khó khăn .\n\nĐể hiển thị nhanh theo mặc định, sử dụng hàm date2week() trong package aweek. Bạn có thể đặt ngày theo hàm week_start =, và nếu bạn đặt đối số factor = TRUE thì cột đầu ra là một factor có thứ tự. Factor sẽ bao gồm các thứ bậc cho tất cả các tuần có thể có trong khoảng thời gian - ngay cả khi không có trường hợp nào xuất hiện trong tuần đó.\n\n\ndf &lt;- linelist %&gt;% \n  mutate(epiweek = date2week(date_onset, week_start = \"Monday\", factor = TRUE))\n\nlevels(df$epiweek)\n\nXem chương Làm việc với ngày tháng để biết thêm thông tin về package aweek. Nó cũng cung cấp thông tin về hàm đảo ngược week2date().",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Kiểu dữ liệu danh mục - Factors</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.vn.html#nguồn-tham-khảo",
    "href": "new_pages/factors.vn.html#nguồn-tham-khảo",
    "title": "11  Kiểu dữ liệu danh mục - Factors",
    "section": "11.9 Nguồn tham khảo",
    "text": "11.9 Nguồn tham khảo\nR trong Khoa học dữ liệu, chương factors\naweek package vignette",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Kiểu dữ liệu danh mục - Factors</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.vn.html",
    "href": "new_pages/pivoting.vn.html",
    "title": "12  Xoay trục dữ liệu",
    "section": "",
    "text": "12.1 Chuẩn bị",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Xoay trục dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.vn.html#chuẩn-bị",
    "href": "new_pages/pivoting.vn.html#chuẩn-bị",
    "title": "12  Xoay trục dữ liệu",
    "section": "",
    "text": "Gọi package\nĐoạn code này hiển thị cách gọi các package cần thiết cho phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm p_load() từ pacman, cài đặt package nếu cần và gọi ra để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm library() từ base R. Xem chương R cơ bản để biết thêm thông tin về các package trong R.\n\npacman::p_load(\n  rio,          # File import\n  here,         # File locator\n  kableExtra,   # Build and manipulate complex tables\n  tidyverse)    # data management + ggplot2 graphics\n\n\n\nNhập dữ liệu\n\n\nDữ liệu số trường hợp sốt rét\nTrong chương này, chúng ta sẽ sử dụng một bộ dữ liệu giả định về các trường hợp ghi nhận sốt rét hàng ngày, theo cơ sở y tế và nhóm tuổi. Để tiện theo dõi, bấm vào đây để tải tệp tin (tệp .rds). Nhập dữ liệu bằng hàm import() từ package rio (xử lý nhiều loại tệp tin như .xlsx; .csv; .rds - Xem chương Nhập xuất dữ liệu để biết thêm chi tiết).\n\n# Import data\ncount_data &lt;- import(\"malaria_facility_count_data.rds\")\n\nDưới đây là 50 hàng đầu tiên được hiển thị.\n\n\n\n\n\n\n\n\nBộ dữ liệu các trường hợp linelist\nTrong phần cuối của chương này, chúng ta cũng sẽ sử dụng tập dữ liệu mô phỏng về các trường hợp từ một vụ dịch Ebola. Để tiện theo dõi, bấm vào đây để tải bộ dữ liệu linelist “đã làm sạch” (tệp .rds). Nạp dữ liệu bằng hàm import() từ package rio (package này chấp nhận nhiều loại tệp tin dạng .xlsx; .csv; .rds - Xem chương Nhập xuất dữ liệu để biết thêm chi tiết).\n\n# import your dataset\nlinelist &lt;- import(\"linelist_cleaned.xlsx\")",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Xoay trục dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.vn.html#định-dạng-dữ-liệu-từ-ngang-sang-dọc",
    "href": "new_pages/pivoting.vn.html#định-dạng-dữ-liệu-từ-ngang-sang-dọc",
    "title": "12  Xoay trục dữ liệu",
    "section": "12.2 Định dạng dữ liệu từ “ngang-sang-dọc”",
    "text": "12.2 Định dạng dữ liệu từ “ngang-sang-dọc”\n\n\n\n\n\n\n\n\n\n\n\nĐịnh dạng “ngang”\nDữ liệu thường được nhập và lưu trữ ở định dạng “ngang” - nghĩa là các đặc điểm hoặc phản hồi của chủ thể được lưu trữ trong một hàng duy nhất. Mặc dù điều này có thể hữu ích cho việc hiển thị, tuy nhiên chưa phải là lý tưởng cho một số phân tích.\nChúng ta hãy lấy bộ dữ liệu count_data đã nhắc đến trong phần Chuẩn bị ở trên để làm ví dụ. Bạn có thể thấy rằng mỗi hàng đại diện cho một “cơ sở y tế-ngày (facility-day)”. Số lượng trường hợp thực tế (các cột ngoài cùng bên phải) được lưu trữ ở định dạng “ngang”, nghĩa là thông tin cho mọi nhóm tuổi trong một cơ sở y tế-ngày nhất định được lưu trữ trong một hàng.\n\n\n\n\n\n\nMỗi quan sát trong bộ dữ liệu này đề cập đến số lượng ca sốt rét tại một trong 65 cơ sở y tế vào một ngày cụ thể, trong khoảng từ count_data$data_date %&gt;% min() đến count_data$data_date %&gt;% max(). Các cơ sở này nằm ở một tỉnh Province (North) và bốn quận District (Spring, Bolo, Dingo và Barnard). Bộ dữ liệu cung cấp số lượng tổng thể của các ca bệnh sốt rét, cũng như số lượng cụ thể theo độ tuổi ở mỗi nhóm trong ba nhóm tuổi - &lt;4 tuổi, 5-14 tuổi và từ 15 tuổi trở lên.\nDữ liệu “ngang” như vậy không tuân theo tiêu chuẩn “dữ liệu gọn gàng”, bởi vì tiêu đề cột không thực sự đại diện cho “biến” - chúng đại diện cho các giá trị của biến giả định là “nhóm tuổi” .\nĐịnh dạng kiểu này có thể hữu ích để trình bày thông tin trong bảng hoặc để nhập dữ liệu (ví dụ: trong Excel) từ các biểu mẫu báo cáo ca bệnh (CRFs). Tuy nhiên, trong quá trình phân tích, những dữ liệu này thường phải được chuyển đổi sang định dạng “dọc” để phù hợp hơn với các tiêu chuẩn về “dữ liệu gọn gàng”. Package vẽ biểu đồ ggplot2 trong R nói riêng hoạt động tốt nhất khi dữ liệu ở định dạng “dọc”.\nTrực quan hóa tổng số lượng ca sốt rét theo thời gian không gây khó khăn gì với dữ liệu ở định dạng hiện tại:\n\nggplot(count_data) +\n  geom_col(aes(x = data_date, y = malaria_tot), width = 1)\n\n\n\n\n\n\n\n\nTuy nhiên, điều gì sẽ xảy ra nếu chúng ta muốn hiển thị các đóng góp một cách tương đối của từng nhóm tuổi vào tổng số này? Trong trường hợp này, chúng ta cần đảm bảo rằng biến quan tâm (nhóm tuổi), xuất hiện trong bộ dữ liệu trong một cột duy nhất có thể được chuyển tiếp tới đối số aes() “mapping aesthetics” trong {ggplot2}.\n\n\n\npivot_longer()\nHàm pivot_longer() trong tidyr giúp biến đổi dữ liệu thành định dạng “dọc”. tidyr là một package con trong hệ sinh thái tidyverse của R.\nHàm này chấp nhận sử dụng nhiều cột cùng thực hiện biến đổi (cụ thể với cols =). Do đó, nó chỉ có thể hoạt động trên một phần của bộ dữ liệu. Điều này rất hữu ích cho bộ dữ liệu về sốt rét, vì chúng ta chỉ muốn xoay trục các cột số ca bệnh.\nTrong quá trình này, kết quả trả về hai cột “mới” - một cột có các danh mục (tên cột cũ) và một cột chứa các giá trị tương ứng (ví dụ: số lượng ca bệnh). Bạn có thể chấp nhận tên mặc định của cột mới hoặc có thể tùy chỉnh bằng names_to = và values_to =, tương ứng.\nHãy cùng xem hàm pivot_longer() hoạt động như thế nào …\n\n\nXoay trục tiêu chuẩn\nChúng ta muốn sử dụng hàm pivot_longer() trong package tidyr để chuyển đổi dữ liệu từ “ngang” sang định dạng “dọc”. Cụ thể, để chuyển đổi bốn cột dạng số có dữ liệu về số lượng ca sốt rét thành hai cột mới: một cột chứa nhóm tuổi và một cột chứa các giá trị tương ứng.\n\ndf_long &lt;- count_data %&gt;% \n  pivot_longer(\n    cols = c(`malaria_rdt_0-4`, `malaria_rdt_5-14`, `malaria_rdt_15`, `malaria_tot`)\n  )\n\ndf_long\n\nLưu ý rằng bộ dữ liệu mới được tạo (df_long) có nhiều hàng hơn (12.152 so với 3.038); bộ dữ liệu đã trở nên “dài hơn”. Trên thực tế, bộ dữ liệu đã dài hơn gấp bốn lần, bởi vì mỗi hàng trong tập dữ liệu ban đầu hiện đại diện cho bốn hàng trong df_long, một hàng cho mỗi quan sát số lượng ca sốt rét (&lt;4 tuổi, 5-14 tuổi, 15+ tuổi và tổng số).\nNgoài việc dài hơn, bộ dữ liệu mới có ít cột hơn (8 so với 10), vì dữ liệu trước đây được lưu trữ trong bốn cột (những cột bắt đầu bằng tiền tố malaria_), hiện được lưu trữ chỉ trong hai cột.\nVì tên của bốn cột này đều bắt đầu bằng tiền tố malaria_, chúng ta có thể sử dụng hàm “tidyselect” starts_with() để đạt được kết quả tương tự (xem chương Làm sạch số liệu và các hàm quan trọng để biết thêm về các hàm trợ giúp này).\n\n# provide column with a tidyselect helper function\ncount_data %&gt;% \n  pivot_longer(\n    cols = starts_with(\"malaria_\")\n  )\n\n# A tibble: 12,152 × 8\n   location_name data_date  submitted_date Province District newid name    value\n   &lt;chr&gt;         &lt;date&gt;     &lt;date&gt;         &lt;chr&gt;    &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;   &lt;int&gt;\n 1 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malari…    11\n 2 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malari…    12\n 3 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malari…    23\n 4 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malari…    46\n 5 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malari…    11\n 6 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malari…    10\n 7 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malari…     5\n 8 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malari…    26\n 9 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malari…     8\n10 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malari…     5\n# ℹ 12,142 more rows\n\n\nhoặc sử dụng vị trí cột:\n\n# provide columns by position\ncount_data %&gt;% \n  pivot_longer(\n    cols = 6:9\n  )\n\nhoặc sử dụng khoảng tên cột:\n\n# provide range of consecutive columns\ncount_data %&gt;% \n  pivot_longer(\n    cols = `malaria_rdt_0-4`:malaria_tot\n  )\n\nHai cột mới này được đặt tên mặc định là name và value, nhưng chúng ta có thể ghi đè các giá trị mặc định này để cung cấp tên cột có ý nghĩa hơn, có thể giúp ghi nhớ dễ dàng đặc điểm các giá trị được lưu trữ bên trong, bằng cách sử dụng các đối số names_to và values_to. Hãy sử dụng tên age_group và counts:\n\ndf_long &lt;- \n  count_data %&gt;% \n  pivot_longer(\n    cols = starts_with(\"malaria_\"),\n    names_to = \"age_group\",\n    values_to = \"counts\"\n  )\n\ndf_long\n\n# A tibble: 12,152 × 8\n   location_name data_date  submitted_date Province District newid age_group    \n   &lt;chr&gt;         &lt;date&gt;     &lt;date&gt;         &lt;chr&gt;    &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;        \n 1 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_…\n 2 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_…\n 3 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_…\n 4 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_tot  \n 5 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_…\n 6 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_…\n 7 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_…\n 8 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_tot  \n 9 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malaria_rdt_…\n10 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malaria_rdt_…\n# ℹ 12,142 more rows\n# ℹ 1 more variable: counts &lt;int&gt;\n\n\nBây giờ chúng ta có thể chuyển tiếp bộ dữ liệu mới này tới {ggplot2}, và định vị cột mới count với trục y và cột mới age_group tới độ số fill = (màu bên trong cột). Việc này giúp hiển thị số lượng ca bệnh sốt rét trong một biểu đồ cột chồng, theo nhóm tuổi:\n\nggplot(data = df_long) +\n  geom_col(\n    mapping = aes(x = data_date, y = counts, fill = age_group),\n    width = 1\n  )\n\n\n\n\n\n\n\n\nKiểm tra biểu đồ mới này và so sánh với biểu đồ chúng ta đã tạo trước đó - hãy xem điều gì đã xảy ra?\nChúng ta đã gặp phải một vấn đề phổ biến khi tổng hợp dữ liệu giám sát - chúng ta cũng đã gộp tổng số từ cột malaria_tot, vì vậy độ lớn của mỗi thanh trong biểu đồ cao gấp đôi so với bình thường.\nChúng ta có thể xử lý vấn đề này theo một số cách. Chúng ta có thể đơn giản lọc bỏ tổng số này ra khỏi bộ dữ liệu trước khi chuyển tới ggplot():\n\ndf_long %&gt;% \n  filter(age_group != \"malaria_tot\") %&gt;% \n  ggplot() +\n  geom_col(\n    aes(x = data_date, y = counts, fill = age_group),\n    width = 1\n  )\n\n\n\n\n\n\n\n\nNgoài ra, chúng ta có thể đã loại bỏ biến này khi chúng ta chạy lệnh pivot_longer(), bằng cách đó có thể giữ biến đó trong bộ dữ liệu như một biến riêng biệt. Hãy xem cách mà giá trị của biến này “mở rộng” để lấp đầy các hàng mới.\n\ncount_data %&gt;% \n  pivot_longer(\n    cols = `malaria_rdt_0-4`:malaria_rdt_15,   # does not include the totals column\n    names_to = \"age_group\",\n    values_to = \"counts\"\n  )\n\n# A tibble: 9,114 × 9\n   location_name data_date  submitted_date Province District malaria_tot newid\n   &lt;chr&gt;         &lt;date&gt;     &lt;date&gt;         &lt;chr&gt;    &lt;chr&gt;          &lt;int&gt; &lt;int&gt;\n 1 Facility 1    2020-08-11 2020-08-12     North    Spring            46     1\n 2 Facility 1    2020-08-11 2020-08-12     North    Spring            46     1\n 3 Facility 1    2020-08-11 2020-08-12     North    Spring            46     1\n 4 Facility 2    2020-08-11 2020-08-12     North    Bolo              26     2\n 5 Facility 2    2020-08-11 2020-08-12     North    Bolo              26     2\n 6 Facility 2    2020-08-11 2020-08-12     North    Bolo              26     2\n 7 Facility 3    2020-08-11 2020-08-12     North    Dingo             18     3\n 8 Facility 3    2020-08-11 2020-08-12     North    Dingo             18     3\n 9 Facility 3    2020-08-11 2020-08-12     North    Dingo             18     3\n10 Facility 4    2020-08-11 2020-08-12     North    Bolo              49     4\n# ℹ 9,104 more rows\n# ℹ 2 more variables: age_group &lt;chr&gt;, counts &lt;int&gt;\n\n\n\n\nXoay trục dữ liệu trên nhiều định dạng cột\nVí dụ trên hoạt động ổn trong các trường hợp mà tất cả các cột bạn muốn “xoay trục dọc” đều thuộc cùng một phân lớp, định dạng (ký tự, số, lôgic, …).\nTuy nhiên, sẽ có nhiều trường hợp, với tư cách là một nhà dịch tễ học thực địa, bạn sẽ làm việc với dữ liệu được chuẩn bị bởi những người không phải là chuyên gia và tuân theo những logic không chuẩn của riêng họ - như Hadley Wickham đã lưu ý (trích dẫn từ Tolstoy) trong bài báo của ông ấy về nguyên tắc của dữ liệu gọn gàng: “Các bộ dữ liệu sạch đều giống nhau nhưng mọi bộ dữ liệu lộn xộn đều lộn xộn theo cách riêng của nó.”\nMột vấn đề đặc biệt phổ biến mà bạn sẽ gặp phải là nhu cầu xoay trục các cột chứa các phân lớp dữ liệu khác nhau. Việc xoay trục này sẽ dẫn đến việc lưu trữ các kiểu định dạng dữ liệu khác nhau này trong cùng một cột duy nhất, và đây không phải là một kịch bản tốt. Có nhiều cách tiếp cận khác nhau mà người ta có thể thực hiện để loại bỏ sự hỗn độn này, nhưng có một bước quan trọng bạn có thể thực hiện bằng cách sử dụng hàm pivot_longer() để tránh tạo ra tình huống như vậy.\nHãy thực hiện một tình huống trong đó có một loạt các quan sát ở các sự kiện thời gian khác nhau cho từng danh mục trong số ba danh mục A, B và C. Ví dụ về các danh mục đó có thể là từng cá nhân (ví dụ: các mối liên hệ của một trường hợp Ebola được theo dõi mỗi ngày trong 21 ngày) hoặc các trạm y tế thôn bản vùng sâu, vùng xa được theo dõi mỗi năm một lần để đảm bảo chúng vẫn được duy trì hoạt động. Hãy sử dụng ví dụ theo dõi mối liên hệ. Hãy tưởng tượng rằng dữ liệu sẽ được lưu trữ như sau:\n\n\n\n\n\n\nCó thể thấy, dữ liệu hơi phức tạp. Mỗi hàng lưu trữ thông tin về một danh mục, nhưng với chuỗi thời gian chạy ngày càng xa về bên phải khi thời gian tịnh tiến. Hơn nữa, các cột dạng phân loại xen kẽ giữa các giá trị ngày tháng và giá trị ký tự.\nMột ví dụ đặc biệt tồi tệ mà tác giả này gặp phải liên quan đến dữ liệu giám sát dịch tả, trong đó 8 cột quan sát mới được thêm vào mỗi ngày trong suốt 4 năm. Mất hơn 10 phút trên máy tính xách tay của tôi chỉ để mở tệp tin Excel lưu trữ những dữ liệu này!\nĐể làm việc với những dữ liệu này, chúng ta cần chuyển đổi bộ dữ liệu sang định dạng dọc, nhưng vẫn giữ sự riêng biệt giữa cột date và cột character (trạng thái), cho mỗi quan sát cho mỗi danh mục. Nếu không, chúng ta có thể thu về một sự hỗn hợp các loại biến trong một cột duy nhất (một sự “ngỡ ngàng vô định” khi nhắc đến quản lý dữ liệu và dữ liệu sạch):\n\ndf %&gt;% \n  pivot_longer(\n    cols = -id,\n    names_to = c(\"observation\")\n  )\n\n# A tibble: 18 × 3\n   id    observation value     \n   &lt;chr&gt; &lt;chr&gt;       &lt;chr&gt;     \n 1 A     obs1_date   2021-04-23\n 2 A     obs1_status Healthy   \n 3 A     obs2_date   2021-04-24\n 4 A     obs2_status Healthy   \n 5 A     obs3_date   2021-04-25\n 6 A     obs3_status Unwell    \n 7 B     obs1_date   2021-04-23\n 8 B     obs1_status Healthy   \n 9 B     obs2_date   2021-04-24\n10 B     obs2_status Healthy   \n11 B     obs3_date   2021-04-25\n12 B     obs3_status Healthy   \n13 C     obs1_date   2021-04-23\n14 C     obs1_status Missing   \n15 C     obs2_date   2021-04-24\n16 C     obs2_status Healthy   \n17 C     obs3_date   2021-04-25\n18 C     obs3_status Healthy   \n\n\nỞ trên, trục xoay của chúng ta đã hợp nhất giá trị ngày và giá trị ký tự trong cùng một cột giá trị duy nhất. R sẽ hoạt động bằng cách chuyển toàn bộ cột thành định dạng ký tự, và các định dạng liên quan đến giá trị ngày sẽ không còn.\nĐể ngăn chặn tình trạng này, chúng ta có thể tận dụng cấu trúc cú pháp của các tên cột ban đầu. Có một cấu trúc đặt tên phổ biến, với số quan sát, dấu gạch dưới và sau đó là “trạng thái” hoặc “ngày-tháng”. Chúng ta có thể tận dụng cú pháp này để giữ lại hai kiểu dữ liệu này trong các cột riêng biệt sau khi xoay trục.\nChúng ta thực hiện như sau:\n\nCung cấp một vectơ dạng ký tự cho đối số names_to =, với mục thứ hai là (\".value\"). Thuật ngữ đặc biệt này chỉ ra rằng các cột được xoay trục sẽ được phân chia dựa trên ký tự trong tên của chúng …\n\nBạn cũng cần cung cấp ký tự “phân tách” cho đối số names_sep =. Trong trường hợp này, đó là dấu gạch dưới “_”.\n\nDo đó, việc đặt tên và tách cột mới được dựa trên dấu gạch dưới trong các tên biến hiện có.\n\ndf_long &lt;- \n  df %&gt;% \n  pivot_longer(\n    cols = -id,\n    names_to = c(\"observation\", \".value\"),\n    names_sep = \"_\"\n  )\n\ndf_long\n\n# A tibble: 9 × 4\n  id    observation date       status \n  &lt;chr&gt; &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;  \n1 A     obs1        2021-04-23 Healthy\n2 A     obs2        2021-04-24 Healthy\n3 A     obs3        2021-04-25 Unwell \n4 B     obs1        2021-04-23 Healthy\n5 B     obs2        2021-04-24 Healthy\n6 B     obs3        2021-04-25 Healthy\n7 C     obs1        2021-04-23 Missing\n8 C     obs2        2021-04-24 Healthy\n9 C     obs3        2021-04-25 Healthy\n\n\nHoàn thiện:\nLưu ý rằng cột date hiện đang ở dạng ký tự - chúng ta có thể dễ dàng chuyển đổi cột này thành dạng ngày thích hợp bằng cách sử dụng hàm mutate() và as_date() được mô tả trong chương Làm việc với ngày tháng.\nChúng ta cũng có thể muốn chuyển đổi cột observation sang định dạng numeric bằng cách bỏ tiền tố “obs” và chuyển đổi thành số. Chúng ta có thể thực hiện với hàm str_remove_all() từ package stringr (xem chương Ký tự và chuỗi).\n\ndf_long &lt;- \n  df_long %&gt;% \n  mutate(\n    date = date %&gt;% lubridate::as_date(),\n    observation = \n      observation %&gt;% \n      str_remove_all(\"obs\") %&gt;% \n      as.numeric()\n  )\n\ndf_long\n\n# A tibble: 9 × 4\n  id    observation date       status \n  &lt;chr&gt;       &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;  \n1 A               1 2021-04-23 Healthy\n2 A               2 2021-04-24 Healthy\n3 A               3 2021-04-25 Unwell \n4 B               1 2021-04-23 Healthy\n5 B               2 2021-04-24 Healthy\n6 B               3 2021-04-25 Healthy\n7 C               1 2021-04-23 Missing\n8 C               2 2021-04-24 Healthy\n9 C               3 2021-04-25 Healthy\n\n\nVà bây giờ, chúng ta có thể bắt đầu làm việc với dữ liệu ở định dạng này, ví dụ: bằng cách vẽ biểu đồ mô tả dạng lưới-nhiệt:\n\nggplot(data = df_long, mapping = aes(x = date, y = id, fill = status)) +\n  geom_tile(colour = \"black\") +\n  scale_fill_manual(\n    values = \n      c(\"Healthy\" = \"lightgreen\", \n        \"Unwell\" = \"red\", \n        \"Missing\" = \"orange\")\n  )",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Xoay trục dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.vn.html#dọc-thành-ngang",
    "href": "new_pages/pivoting.vn.html#dọc-thành-ngang",
    "title": "12  Xoay trục dữ liệu",
    "section": "12.3 Dọc-thành-ngang",
    "text": "12.3 Dọc-thành-ngang\n\n\n\n\n\n\n\n\n\nTrong một số trường hợp, chúng ta có thể muốn chuyển đổi bộ dữ liệu sang định dạng ngang. Đối với điều này, chúng ta có thể sử dụng hàm pivot_wider().\nTình huống phổ biến là khi chúng ta muốn chuyển đổi kết quả phân tích thành một định dạng dễ hiểu hơn cho người đọc (chẳng hạn như trong chương [Trình bày bảng]). Thông thường, điều này bao gồm việc chuyển đổi một bộ dữ liệu trong đó thông tin chủ thể được trải rộng trên nhiều hàng, sau đó được thống nhất thành một định dạng mà thông tin được lưu trữ trên một hàng duy nhất.\n\nDữ liệu\nTrong chương này, chúng ta sẽ sử dụng bộ dữ liệu ca bệnh linelist (xem mục Chuẩn bị), với mỗi trường hợp nằm trên một hàng.\nDưới đây là 50 hàng đầu tiên:\n\n\n\n\n\n\nGiả sử rằng chúng ta muốn biết số lượng cá thể ở các nhóm tuổi khác nhau, theo giới tính:\n\ndf_wide &lt;- \n  linelist %&gt;% \n  count(age_cat, gender)\n\ndf_wide\n\n   age_cat gender   n\n1      0-4      f 640\n2      0-4      m 416\n3      0-4   &lt;NA&gt;  39\n4      5-9      f 641\n5      5-9      m 412\n6      5-9   &lt;NA&gt;  42\n7    10-14      f 518\n8    10-14      m 383\n9    10-14   &lt;NA&gt;  40\n10   15-19      f 359\n11   15-19      m 364\n12   15-19   &lt;NA&gt;  20\n13   20-29      f 468\n14   20-29      m 575\n15   20-29   &lt;NA&gt;  30\n16   30-49      f 179\n17   30-49      m 557\n18   30-49   &lt;NA&gt;  18\n19   50-69      f   2\n20   50-69      m  91\n21   50-69   &lt;NA&gt;   2\n22     70+      m   5\n23     70+   &lt;NA&gt;   1\n24    &lt;NA&gt;   &lt;NA&gt;  86\n\n\nĐiều này cho chúng ta một bộ dữ liệu dạng dọc, rất tốt để trực quan hóa trong ggplot2, nhưng không lý tưởng để trình bày bảng:\n\nggplot(df_wide) +\n  geom_col(aes(x = age_cat, y = n, fill = gender))\n\n\n\n\n\n\n\n\n\n\nXoay trục ngang\nDo đó, chúng ta có thể sử dụng hàm pivot_wider() để chuyển đổi dữ liệu sang định dạng tốt hơn để đưa vào các bảng trong báo cáo.\nĐối số names_from chỉ định cột mà từ đó tạo ra tên cột mới, trong khi đối số values_from chỉ định cột mà từ đó nhận các giá trị để điền. Đối số id_cols = là tùy chọn, nhưng nó có thể được chứa một vectơ tên các cột không xoay trục và do đó sẽ xác định từng hàng.\n\ntable_wide &lt;- \n  df_wide %&gt;% \n  pivot_wider(\n    id_cols = age_cat,\n    names_from = gender,\n    values_from = n\n  )\n\ntable_wide\n\n# A tibble: 9 × 4\n  age_cat     f     m  `NA`\n  &lt;fct&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n1 0-4       640   416    39\n2 5-9       641   412    42\n3 10-14     518   383    40\n4 15-19     359   364    20\n5 20-29     468   575    30\n6 30-49     179   557    18\n7 50-69       2    91     2\n8 70+        NA     5     1\n9 &lt;NA&gt;       NA    NA    86\n\n\nBảng này thân thiện với người đọc hơn nhiều và có thể thêm vào báo cáo của chúng ta. Bạn có thể chuyển đổi thành một bảng tuyệt vời với một số package bao gồm flextable và knitr. Quá trình này được trình bày chi tiết trong chương Trình bày bảng.\n\ntable_wide %&gt;% \n  janitor::adorn_totals(c(\"row\", \"col\")) %&gt;% # adds row and column totals\n  knitr::kable() %&gt;% \n  kableExtra::row_spec(row = 10, bold = TRUE) %&gt;% \n  kableExtra::column_spec(column = 5, bold = TRUE) \n\n\n\n\n\nage_cat\nf\nm\nNA\nTotal\n\n\n\n\n0-4\n640\n416\n39\n1095\n\n\n5-9\n641\n412\n42\n1095\n\n\n10-14\n518\n383\n40\n941\n\n\n15-19\n359\n364\n20\n743\n\n\n20-29\n468\n575\n30\n1073\n\n\n30-49\n179\n557\n18\n754\n\n\n50-69\n2\n91\n2\n95\n\n\n70+\nNA\n5\n1\n6\n\n\nNA\nNA\nNA\n86\n86\n\n\nTotal\n2807\n2803\n278\n5888",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Xoay trục dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.vn.html#điền",
    "href": "new_pages/pivoting.vn.html#điền",
    "title": "12  Xoay trục dữ liệu",
    "section": "12.4 Điền",
    "text": "12.4 Điền\nTrong một số tình huống sau khi pivot, và phổ biến hơn là sau khi bind, chúng ta sẽ để lại một số ô trống mà chúng ta sẽ muốn lấp đầy.\n\n\nDữ liệu\nVí dụ: lấy hai bộ dữ liệu, mỗi bộ dữ liệu có các quan sát về các đại lượng đo lường, tên của cơ sở y tế và số ca bệnh tại thời điểm đó. Tuy nhiên, bộ dữ liệu thứ hai cũng có biến Year.\n\ndf1 &lt;- \n  tibble::tribble(\n       ~Measurement, ~Facility, ~Cases,\n                  1,  \"Hosp 1\",     66,\n                  2,  \"Hosp 1\",     26,\n                  3,  \"Hosp 1\",      8,\n                  1,  \"Hosp 2\",     71,\n                  2,  \"Hosp 2\",     62,\n                  3,  \"Hosp 2\",     70,\n                  1,  \"Hosp 3\",     47,\n                  2,  \"Hosp 3\",     70,\n                  3,  \"Hosp 3\",     38,\n       )\n\ndf1 \n\n# A tibble: 9 × 3\n  Measurement Facility Cases\n        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;\n1           1 Hosp 1      66\n2           2 Hosp 1      26\n3           3 Hosp 1       8\n4           1 Hosp 2      71\n5           2 Hosp 2      62\n6           3 Hosp 2      70\n7           1 Hosp 3      47\n8           2 Hosp 3      70\n9           3 Hosp 3      38\n\ndf2 &lt;- \n  tibble::tribble(\n    ~Year, ~Measurement, ~Facility, ~Cases,\n     2000,            1,  \"Hosp 4\",     82,\n     2001,            2,  \"Hosp 4\",     87,\n     2002,            3,  \"Hosp 4\",     46\n  )\n\ndf2\n\n# A tibble: 3 × 4\n   Year Measurement Facility Cases\n  &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;\n1  2000           1 Hosp 4      82\n2  2001           2 Hosp 4      87\n3  2002           3 Hosp 4      46\n\n\nKhi chúng ta thực hiện lệnh bind_rows() để nối hai bộ dữ liệu với nhau, biến Year được điền NA cho những hàng không có thông tin trước đó (ví dụ là bộ dữ liệu đầu tiên):\n\ndf_combined &lt;- \n  bind_rows(df1, df2) %&gt;% \n  arrange(Measurement, Facility)\n\ndf_combined\n\n# A tibble: 12 × 4\n   Measurement Facility Cases  Year\n         &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1           1 Hosp 1      66    NA\n 2           1 Hosp 2      71    NA\n 3           1 Hosp 3      47    NA\n 4           1 Hosp 4      82  2000\n 5           2 Hosp 1      26    NA\n 6           2 Hosp 2      62    NA\n 7           2 Hosp 3      70    NA\n 8           2 Hosp 4      87  2001\n 9           3 Hosp 1       8    NA\n10           3 Hosp 2      70    NA\n11           3 Hosp 3      38    NA\n12           3 Hosp 4      46  2002\n\n\n\n\n\nfill()\nTrong trường hợp này, Year là một biến hữu ích cần để thêm vào bộ số liệu, đặc biệt nếu chúng ta muốn tìm hiểu các xu hướng theo thời gian. Do đó, chúng ta sử dụng hàm fill() để điền vào các ô trống đó, bằng cách chỉ định cột và hướng cần điền (trong trường hợp này là hướng từ dưới lên trên):\n\ndf_combined %&gt;% \n  fill(Year, .direction = \"up\")\n\n# A tibble: 12 × 4\n   Measurement Facility Cases  Year\n         &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1           1 Hosp 1      66  2000\n 2           1 Hosp 2      71  2000\n 3           1 Hosp 3      47  2000\n 4           1 Hosp 4      82  2000\n 5           2 Hosp 1      26  2001\n 6           2 Hosp 2      62  2001\n 7           2 Hosp 3      70  2001\n 8           2 Hosp 4      87  2001\n 9           3 Hosp 1       8  2002\n10           3 Hosp 2      70  2002\n11           3 Hosp 3      38  2002\n12           3 Hosp 4      46  2002\n\n\nNgoài ra, chúng ta có thể sắp xếp lại dữ liệu để chúng ta cần điền theo hướng từ trên xuống dưới:\n\ndf_combined &lt;- \n  df_combined %&gt;% \n  arrange(Measurement, desc(Facility))\n\ndf_combined\n\n# A tibble: 12 × 4\n   Measurement Facility Cases  Year\n         &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1           1 Hosp 4      82  2000\n 2           1 Hosp 3      47    NA\n 3           1 Hosp 2      71    NA\n 4           1 Hosp 1      66    NA\n 5           2 Hosp 4      87  2001\n 6           2 Hosp 3      70    NA\n 7           2 Hosp 2      62    NA\n 8           2 Hosp 1      26    NA\n 9           3 Hosp 4      46  2002\n10           3 Hosp 3      38    NA\n11           3 Hosp 2      70    NA\n12           3 Hosp 1       8    NA\n\ndf_combined &lt;- \n  df_combined %&gt;% \n  fill(Year, .direction = \"down\")\n\ndf_combined\n\n# A tibble: 12 × 4\n   Measurement Facility Cases  Year\n         &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1           1 Hosp 4      82  2000\n 2           1 Hosp 3      47  2000\n 3           1 Hosp 2      71  2000\n 4           1 Hosp 1      66  2000\n 5           2 Hosp 4      87  2001\n 6           2 Hosp 3      70  2001\n 7           2 Hosp 2      62  2001\n 8           2 Hosp 1      26  2001\n 9           3 Hosp 4      46  2002\n10           3 Hosp 3      38  2002\n11           3 Hosp 2      70  2002\n12           3 Hosp 1       8  2002\n\n\nBây giờ chúng ta có một bộ dữ liệu sạch để vẽ biểu đồ:\n\nggplot(df_combined) +\n  aes(Year, Cases, fill = Facility) +\n  geom_col()\n\n\n\n\n\n\n\n\nNhưng ít hữu ích cho việc trình bày bảng, vì vậy hãy thực hành chuyển đổi bộ dữ liệu dọc-chưa làm sạch này thành một bộ dữ liệu ngang-sạch:\n\ndf_combined %&gt;% \n  pivot_wider(\n    id_cols = c(Measurement, Facility),\n    names_from = \"Year\",\n    values_from = \"Cases\"\n  ) %&gt;% \n  arrange(Facility) %&gt;% \n  janitor::adorn_totals(c(\"row\", \"col\")) %&gt;% \n  knitr::kable() %&gt;% \n  kableExtra::row_spec(row = 5, bold = TRUE) %&gt;% \n  kableExtra::column_spec(column = 5, bold = TRUE) \n\n\n\n\n\nMeasurement\nFacility\n2000\n2001\n2002\nTotal\n\n\n\n\n1\nHosp 1\n66\nNA\nNA\n66\n\n\n2\nHosp 1\nNA\n26\nNA\n26\n\n\n3\nHosp 1\nNA\nNA\n8\n8\n\n\n1\nHosp 2\n71\nNA\nNA\n71\n\n\n2\nHosp 2\nNA\n62\nNA\n62\n\n\n3\nHosp 2\nNA\nNA\n70\n70\n\n\n1\nHosp 3\n47\nNA\nNA\n47\n\n\n2\nHosp 3\nNA\n70\nNA\n70\n\n\n3\nHosp 3\nNA\nNA\n38\n38\n\n\n1\nHosp 4\n82\nNA\nNA\n82\n\n\n2\nHosp 4\nNA\n87\nNA\n87\n\n\n3\nHosp 4\nNA\nNA\n46\n46\n\n\nTotal\n-\n266\n245\n162\n673\n\n\n\n\n\n\n\n\nChú ý: Trong trường hợp này, chúng ta cần chỉ định chỉ bao gồm ba biến Facility, Year, và Cases vì biến bổ sung Measurement sẽ khiến khó khăn hơn khi tạo bảng:\n\ndf_combined %&gt;% \n  pivot_wider(\n    names_from = \"Year\",\n    values_from = \"Cases\"\n  ) %&gt;% \n  knitr::kable()\n\n\n\n\nMeasurement\nFacility\n2000\n2001\n2002\n\n\n\n\n1\nHosp 4\n82\nNA\nNA\n\n\n1\nHosp 3\n47\nNA\nNA\n\n\n1\nHosp 2\n71\nNA\nNA\n\n\n1\nHosp 1\n66\nNA\nNA\n\n\n2\nHosp 4\nNA\n87\nNA\n\n\n2\nHosp 3\nNA\n70\nNA\n\n\n2\nHosp 2\nNA\n62\nNA\n\n\n2\nHosp 1\nNA\n26\nNA\n\n\n3\nHosp 4\nNA\nNA\n46\n\n\n3\nHosp 3\nNA\nNA\n38\n\n\n3\nHosp 2\nNA\nNA\n70\n\n\n3\nHosp 1\nNA\nNA\n8",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Xoay trục dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.vn.html#tài-liệu-tham-khảo",
    "href": "new_pages/pivoting.vn.html#tài-liệu-tham-khảo",
    "title": "12  Xoay trục dữ liệu",
    "section": "12.5 Tài liệu tham khảo",
    "text": "12.5 Tài liệu tham khảo\nĐây là một hướng dẫn bổ ích",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Xoay trục dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.vn.html",
    "href": "new_pages/grouping.vn.html",
    "title": "13  Nhóm dữ liệu",
    "section": "",
    "text": "13.1 Chuẩn bị",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Nhóm dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.vn.html#chuẩn-bị",
    "href": "new_pages/grouping.vn.html#chuẩn-bị",
    "title": "13  Nhóm dữ liệu",
    "section": "",
    "text": "Gọi package\nĐoạn code này hiển thị cách gọi các package cần thiết cho phân tích. Trong cuốn này, chúng ta nhấn mạnh đến hàm p_load() từ package pacman, sẽ cài đặt packahe nếu cần và gọi để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm library() từ base R. Xem chương R cơ bản để biết thêm thông tin về các package trong R.\n\npacman::p_load(\n  rio,       # to import data\n  here,      # to locate files\n  tidyverse, # to clean, handle, and plot the data (includes dplyr)\n  janitor)   # adding total rows and columns\n\n\n\nNhập dữ liệu\nChúng ta nhập bộ dữ liệu về các trường hợp mô phỏng từ một vụ dịch Ebola. Nếu bạn muốn cùng thực hành, bấm vào đây để tải bộ liệu linelist “sạch” (tệp .rds). Bộ dữ liệu được nhập bằng hàm import() từ package rio. Xem chương Nhập xuất dữ liệu để biết các cách nhập dữ liệu khác nhau.\n\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\n50 hàng đầu tiên của bộ số liệu linelist:",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Nhóm dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.vn.html#nhóm",
    "href": "new_pages/grouping.vn.html#nhóm",
    "title": "13  Nhóm dữ liệu",
    "section": "13.2 Nhóm",
    "text": "13.2 Nhóm\nHàm group_by() từ dplyr nhóm các hàng theo các giá trị duy nhất trong cột chỉ định. Nếu nhiều cột được chỉ định, các hàng được nhóm theo sự tổ hợp các giá trị thành giá trị duy nhất từ các cột. Mỗi giá trị duy nhất (hoặc tổ hợp các giá trị) tạo thành một nhóm. Những thay đổi sau đó đối với bộ dữ liệu hoặc các phép tính có thể thực hiện tùy theo đặc điểm của mỗi nhóm.\nVí dụ: lệnh bên dưới truy vấn bộ số liệu linelist và nhóm các hàng theo giá trị duy nhất trong cột outcome, lưu kết quả đầu ra dưới dạng bộ dữ liệu mới có tên ll_by_outcome. (Các) cột được nhóm được đặt bên trong dấu ngoặc đơn của hàm group_by().\n\nll_by_outcome &lt;- linelist %&gt;% \n  group_by(outcome)\n\nLưu ý rằng không có thay đổi dễ nhận thấy nào đối với bộ dữ liệu sau khi chạy lệnh group_by(), cho đến khi phối hợp thêm một số hàm từ dplyr khác như mutate(), summarise(), hoặc arrange() trong bộ dữ liệu “đã được nhóm”.\nTuy nhiên, bạn có thể “xem” các nhóm bằng cách in bộ dữ liệu. Khi bạn in một bộ dữ liệu được nhóm, bạn sẽ thấy nó đã được chuyển đổi thành một đối tượng dạng tibble, mà khi được in ra, sẽ hiển thị những nhóm nào đã được áp dụng và có bao nhiêu nhóm - được viết ngay phía trên hàng tiêu đề.\n\n# print to see which groups are active\nll_by_outcome\n\n# A tibble: 5,888 × 30\n# Groups:   outcome [3]\n   case_id generation date_infection date_onset date_hospitalisation\n   &lt;chr&gt;        &lt;dbl&gt; &lt;date&gt;         &lt;date&gt;     &lt;date&gt;              \n 1 5fe599           4 2014-05-08     2014-05-13 2014-05-15          \n 2 8689b7           4 NA             2014-05-13 2014-05-14          \n 3 11f8ea           2 NA             2014-05-16 2014-05-18          \n 4 b8812a           3 2014-05-04     2014-05-18 2014-05-20          \n 5 893f25           3 2014-05-18     2014-05-21 2014-05-22          \n 6 be99c8           3 2014-05-03     2014-05-22 2014-05-23          \n 7 07e3e8           4 2014-05-22     2014-05-27 2014-05-29          \n 8 369449           4 2014-05-28     2014-06-02 2014-06-03          \n 9 f393b4           4 NA             2014-06-05 2014-06-06          \n10 1389ca           4 NA             2014-06-05 2014-06-07          \n# ℹ 5,878 more rows\n# ℹ 25 more variables: date_outcome &lt;date&gt;, outcome &lt;chr&gt;, gender &lt;chr&gt;,\n#   age &lt;dbl&gt;, age_unit &lt;chr&gt;, age_years &lt;dbl&gt;, age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;,\n#   hospital &lt;chr&gt;, lon &lt;dbl&gt;, lat &lt;dbl&gt;, infector &lt;chr&gt;, source &lt;chr&gt;,\n#   wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;, ct_blood &lt;dbl&gt;, fever &lt;chr&gt;, chills &lt;chr&gt;,\n#   cough &lt;chr&gt;, aches &lt;chr&gt;, vomit &lt;chr&gt;, temp &lt;dbl&gt;, time_admission &lt;chr&gt;,\n#   bmi &lt;dbl&gt;, days_onset_hosp &lt;dbl&gt;\n\n\n\nNhóm duy nhất\nCác nhóm được tạo phản ánh từng tổ hợp giá trị duy nhất dọc theo các cột được sử dụng để nhóm.\nĐể xem các nhóm và số hàng trong mỗi nhóm, hãy chuyển tiếp dữ liệu được nhóm đến hàm tally(). Nếu chỉ cần xem các nhóm duy nhất mà không cần số lượng, bạn có thể sử dụng hàm group_keys().\nDưới đây là ba giá trị duy nhất trong cột được nhóm là outcome: “Death”, “Recover”, và NA. Ta thấy rằng đã có nrow(linelist %&gt;% filter(outcome == \"Death\")) tử vong, nrow(linelist %&gt;% filter(outcome == \"Recover\")) hồi phục, và nrow(linelist %&gt;% filter(is.na(outcome))) không có outcome nào được ghi nhận.\n\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  tally()\n\n# A tibble: 3 × 2\n  outcome     n\n  &lt;chr&gt;   &lt;int&gt;\n1 Death    2582\n2 Recover  1983\n3 &lt;NA&gt;     1323\n\n\nBạn có thể nhóm nhiều hơn một cột. Dưới đây, bộ dữ liệu được nhóm theo outcome và gender, sau đó được đánh số. Lưu ý cách mỗi kết hợp duy nhất của outcome và gender được tổ hợp thành nhóm riêng - bao gồm cả các giá trị bị thiếu ở một trong hai cột.\n\nlinelist %&gt;% \n  group_by(outcome, gender) %&gt;% \n  tally()\n\n# A tibble: 9 × 3\n# Groups:   outcome [3]\n  outcome gender     n\n  &lt;chr&gt;   &lt;chr&gt;  &lt;int&gt;\n1 Death   f       1227\n2 Death   m       1228\n3 Death   &lt;NA&gt;     127\n4 Recover f        953\n5 Recover m        950\n6 Recover &lt;NA&gt;      80\n7 &lt;NA&gt;    f        627\n8 &lt;NA&gt;    m        625\n9 &lt;NA&gt;    &lt;NA&gt;      71\n\n\n\n\nCột mới\nBạn cũng có thể tạo một cột mới dùng để nhóm trong câu lệnh group_by(). Điều này tương đương với việc sử dụng hàm mutate() trước khi sử dụng hàm group_by(). Để tạo cột nhanh, cách này có thể hữu ích, nhưng để rõ ràng hơn trong code của bạn, hãy cân nhắc cách tạo cột này ở bước mutate() và sau đó chuyển tiếp đến hàm group_by().\n\n# group dat based on a binary column created *within* the group_by() command\nlinelist %&gt;% \n  group_by(\n    age_class = ifelse(age &gt;= 18, \"adult\", \"child\")) %&gt;% \n  tally(sort = T)\n\n# A tibble: 3 × 2\n  age_class     n\n  &lt;chr&gt;     &lt;int&gt;\n1 child      3618\n2 adult      2184\n3 &lt;NA&gt;         86\n\n\n\n\nThêm/bỏ cột được nhóm\nMặc định, nếu bạn chạy lệnh group_by() trên dữ liệu đã được nhóm, các nhóm cũ sẽ bị xóa và (các) nhóm mới sẽ được áp dụng. Nếu bạn muốn thêm nhóm mới vào nhóm hiện có, hãy thêm đối số .add = TRUE.\n\n# Grouped by outcome\nby_outcome &lt;- linelist %&gt;% \n  group_by(outcome)\n\n# Add grouping by gender in addition\nby_outcome_gender &lt;- by_outcome %&gt;% \n  group_by(gender, .add = TRUE)",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Nhóm dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.vn.html#giữ-tất-cả-các-nhóm",
    "href": "new_pages/grouping.vn.html#giữ-tất-cả-các-nhóm",
    "title": "13  Nhóm dữ liệu",
    "section": "13.3 Giữ tất cả các nhóm",
    "text": "13.3 Giữ tất cả các nhóm\nNếu bạn nhóm trên một cột dạng factor, có thể có các thứ bậc của factor mà không có trong dữ liệu. Nếu bạn nhóm trên cột này, mặc định, những thứ bậc không có trong dữ liệu đó sẽ bị loại bỏ và không thuộc dạng nhóm. Để thay đổi điều này để tất cả các thứ bậc xuất hiện dưới dạng nhóm (ngay cả khi không có trong dữ liệu), đặt .drop = FALSE trong lệnh group_by().",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Nhóm dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.vn.html#loại-bỏ-nhóm",
    "href": "new_pages/grouping.vn.html#loại-bỏ-nhóm",
    "title": "13  Nhóm dữ liệu",
    "section": "13.4 Loại bỏ nhóm",
    "text": "13.4 Loại bỏ nhóm\nDữ liệu đã được nhóm sẽ vẫn được nhóm cho đến khi hủy nhóm bởi lệnh ungroup(). Nếu bạn quên hủy nhóm, nó có thể gây ra tính toán không chính xác! Dưới đây là ví dụ về việc loại bỏ tất cả các nhóm:\n\nlinelist %&gt;% \n  group_by(outcome, gender) %&gt;% \n  tally() %&gt;% \n  ungroup()\n\nBạn cũng có thể loại bỏ nhóm với các cột cụ thể, bằng cách đặt tên cột bên trong lệnh ungroup().\n\nlinelist %&gt;% \n  group_by(outcome, gender) %&gt;% \n  tally() %&gt;% \n  ungroup(gender) # remove the grouping by gender, leave grouping by outcome\n\nGHI CHÚ: Hàm count() tự động hủy nhóm dữ liệu sau khi đếm.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Nhóm dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.vn.html#group_summarise",
    "href": "new_pages/grouping.vn.html#group_summarise",
    "title": "13  Nhóm dữ liệu",
    "section": "13.5 Tổng hợp",
    "text": "13.5 Tổng hợp\nXem package dplyr trong chương Bảng mô tả để biết mô tả chi tiết về cách tạo bảng tổng hợp với hàm summarise(). Ở đây chúng ta giải quyết ngắn gọn cách hoạt động thay đổi khi áp dụng cho dữ liệu được nhóm.\nHàm dplyr summarise() (hoặc summarize()) lấy một data frame và chuyển nó thành một data frame tổng hợp mới, với các cột chứa thông tin các giá trị thống kê do bạn xác định. Trên bộ dữ liệu chưa nhóm, các tổng hợp thống kê sẽ được tính toán từ tất cả các hàng. Việc áp dụng hàm summarise() vào dữ liệu được nhóm sẽ tổng hợp những giá trị thống kê cho từng nhóm.\nCú pháp của hàm summarise() là bạn cung cấp tên của (các) cột tổng hợp mới, một dấu bằng và sau đó là một hàm thống kê để áp dụng cho dữ liệu, như được trình bày bên dưới. Ví dụ: min(), max(), median(), hoặc sd(). Trong hàm thống kê, hãy liệt kê cột sẽ được áp dụng và bất kỳ đối số nào có liên quan (ví dụ: na.rm = TRUE). Bạn có thể sử dụng hàm sum() để đếm số hàng đáp ứng tiêu chí logic (với dấu bằng kép ==).\nDưới đây là một ví dụ về hàm summarise() được áp dụng mà không có dữ liệu được nhóm. Các giá trị thống kê trả về được tạo ra từ toàn bộ bộ dữ liệu.\n\n# summary statistics on ungrouped linelist\nlinelist %&gt;% \n  summarise(\n    n_cases  = n(),\n    mean_age = mean(age_years, na.rm=T),\n    max_age  = max(age_years, na.rm=T),\n    min_age  = min(age_years, na.rm=T),\n    n_males  = sum(gender == \"m\", na.rm=T))\n\n  n_cases mean_age max_age min_age n_males\n1    5888 16.01831      84       0    2803\n\n\nNgược lại, bên dưới là câu lệnh summarise() tương tự được áp dụng cho dữ liệu được nhóm. Các số liệu thống kê được tính toán cho từng nhóm kết quả. Lưu ý cách các cột dùng để nhóm sẽ chuyển sang data frame mới.\n\n# summary statistics on grouped linelist\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  summarise(\n    n_cases  = n(),\n    mean_age = mean(age_years, na.rm=T),\n    max_age  = max(age_years, na.rm=T),\n    min_age  = min(age_years, na.rm=T),\n    n_males    = sum(gender == \"m\", na.rm=T))\n\n# A tibble: 3 × 6\n  outcome n_cases mean_age max_age min_age n_males\n  &lt;chr&gt;     &lt;int&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;int&gt;\n1 Death      2582     15.9      76       0    1228\n2 Recover    1983     16.1      84       0     950\n3 &lt;NA&gt;       1323     16.2      69       0     625\n\n\nMẸO: Hàm tổng hợp hoạt động với cả cách viết của kiểu Anh và Mỹ - summarise() và summarize() đều chỉ định cùng cùng một hàm.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Nhóm dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.vn.html#counts-và-tallies",
    "href": "new_pages/grouping.vn.html#counts-và-tallies",
    "title": "13  Nhóm dữ liệu",
    "section": "13.6 Counts và tallies",
    "text": "13.6 Counts và tallies\ncount() và tally() đều cung cấp tính năng tương tự nhưng thực chất là khác nhau. Đọc thêm về sự khác biệt giữa tally() và count() tại đây.\n\ntally()\ntally() là viết tắt của summarise(n = n()) và không nhóm dữ liệu. Do đó, để có thể kiểm đếm theo nhóm, nó phải theo sau lệnh group_by(). Bạn có thể thêm sort = TRUE để xem các nhóm lớn nhất trước tiên.\n\nlinelist %&gt;% \n  tally()\n\n     n\n1 5888\n\n\n\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  tally(sort = TRUE)\n\n# A tibble: 3 × 2\n  outcome     n\n  &lt;chr&gt;   &lt;int&gt;\n1 Death    2582\n2 Recover  1983\n3 &lt;NA&gt;     1323\n\n\n\n\ncount()\nNgược lại, hàm count() hoạt động như sau:\n\nÁp dụng group_by() trên (các) cột đã chỉ định\n\nÁp dụng summarise() và trả về cột n với số lượng dòng mỗi nhóm\n\nÁp dụng ungroup()\n\n\nlinelist %&gt;% \n  count(outcome)\n\n  outcome    n\n1   Death 2582\n2 Recover 1983\n3    &lt;NA&gt; 1323\n\n\nCũng giống như với hàm group_by(), bạn có thể tạo một cột mới trong lệnh count():\n\nlinelist %&gt;% \n  count(age_class = ifelse(age &gt;= 18, \"adult\", \"child\"), sort = T)\n\n  age_class    n\n1     child 3618\n2     adult 2184\n3      &lt;NA&gt;   86\n\n\ncount() có thể được sử dụng nhiều lần, với tính năng “cuộn lên”. Ví dụ: để tổng hợp số lượng bệnh viện hiện có cho mỗi giới tính, hãy chạy lệnh như sau. Lưu ý, tên của cột cuối cùng đã được thay đổi từ tên mặc định là “n” để cho rõ ràng (với name  =).\n\nlinelist %&gt;% \n  # produce counts by unique outcome-gender groups\n  count(gender, hospital) %&gt;% \n  # gather rows by gender (3) and count number of hospitals per gender (6)\n  count(gender, name = \"hospitals per gender\" ) \n\n  gender hospitals per gender\n1      f                    6\n2      m                    6\n3   &lt;NA&gt;                    6\n\n\n\n\nThêm giá trị đếm\nNgược lại với count() và summarise(), bạn có thể sử dụng add_count() để thêm một cột mới n với số lượng hàng cho mỗi nhóm trong khi vẫn giữ lại tất cả các cột khác trong dữ liệu.\nĐiều này có nghĩa là số lượng của nhóm, trong cột mới n, sẽ được in ra trong mỗi hàng của nhóm. Với mục đích minh họa, chúng tôi thêm cột này và sau đó sắp xếp lại các cột để dễ xem hơn. Xem mục bên dưới về bộ lọc theo kích thước nhóm để biết một ví dụ khác.\n\nlinelist %&gt;% \n  as_tibble() %&gt;%                   # convert to tibble for nicer printing \n  add_count(hospital) %&gt;%           # add column n with counts by hospital\n  select(hospital, n, everything()) # re-arrange for demo purposes\n\n# A tibble: 5,888 × 31\n   hospital                       n case_id generation date_infection date_onset\n   &lt;chr&gt;                      &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt; &lt;date&gt;         &lt;date&gt;    \n 1 Other                        885 5fe599           4 2014-05-08     2014-05-13\n 2 Missing                     1469 8689b7           4 NA             2014-05-13\n 3 St. Mark's Maternity Hosp…   422 11f8ea           2 NA             2014-05-16\n 4 Port Hospital               1762 b8812a           3 2014-05-04     2014-05-18\n 5 Military Hospital            896 893f25           3 2014-05-18     2014-05-21\n 6 Port Hospital               1762 be99c8           3 2014-05-03     2014-05-22\n 7 Missing                     1469 07e3e8           4 2014-05-22     2014-05-27\n 8 Missing                     1469 369449           4 2014-05-28     2014-06-02\n 9 Missing                     1469 f393b4           4 NA             2014-06-05\n10 Missing                     1469 1389ca           4 NA             2014-06-05\n# ℹ 5,878 more rows\n# ℹ 25 more variables: date_hospitalisation &lt;date&gt;, date_outcome &lt;date&gt;,\n#   outcome &lt;chr&gt;, gender &lt;chr&gt;, age &lt;dbl&gt;, age_unit &lt;chr&gt;, age_years &lt;dbl&gt;,\n#   age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;, lon &lt;dbl&gt;, lat &lt;dbl&gt;, infector &lt;chr&gt;,\n#   source &lt;chr&gt;, wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;, ct_blood &lt;dbl&gt;, fever &lt;chr&gt;,\n#   chills &lt;chr&gt;, cough &lt;chr&gt;, aches &lt;chr&gt;, vomit &lt;chr&gt;, temp &lt;dbl&gt;,\n#   time_admission &lt;chr&gt;, bmi &lt;dbl&gt;, days_onset_hosp &lt;dbl&gt;\n\n\n\n\nThêm giá trị tổng\nĐể dễ dàng thêm tổng các hàng hoặc cột sau khi sử dụng tally() hoặc count(), hãy xem mục janitor trong chương Bảng mô tả. Package này cung cấp các hàm như adorn_totals() và adorn_percentages() để thêm tổng và chuyển đổi sang hiển thị tỷ lệ phần trăm. Dưới đây là một ví dụ ngắn gọn:\n\nlinelist %&gt;%                                  # case linelist\n  tabyl(age_cat, gender) %&gt;%                  # cross-tabulate counts of two columns\n  adorn_totals(where = \"row\") %&gt;%             # add a total row\n  adorn_percentages(denominator = \"col\") %&gt;%  # convert to proportions with column denominator\n  adorn_pct_formatting() %&gt;%                  # convert proportions to percents\n  adorn_ns(position = \"front\") %&gt;%            # display as: \"count (percent)\"\n  adorn_title(                                # adjust titles\n    row_name = \"Age Category\",\n    col_name = \"Gender\")\n\n                      Gender                            \n Age Category              f              m          NA_\n          0-4   640  (22.8%)   416  (14.8%)  39  (14.0%)\n          5-9   641  (22.8%)   412  (14.7%)  42  (15.1%)\n        10-14   518  (18.5%)   383  (13.7%)  40  (14.4%)\n        15-19   359  (12.8%)   364  (13.0%)  20   (7.2%)\n        20-29   468  (16.7%)   575  (20.5%)  30  (10.8%)\n        30-49   179   (6.4%)   557  (19.9%)  18   (6.5%)\n        50-69     2   (0.1%)    91   (3.2%)   2   (0.7%)\n          70+     0   (0.0%)     5   (0.2%)   1   (0.4%)\n         &lt;NA&gt;     0   (0.0%)     0   (0.0%)  86  (30.9%)\n        Total 2,807 (100.0%) 2,803 (100.0%) 278 (100.0%)\n\n\nĐể thêm các hàng tổng phức tạp hơn bao gồm các thống kê tổng hợp khác, hãy xem mục sau trong chương Bảng mô tả.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Nhóm dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.vn.html#nhóm-theo-ngày",
    "href": "new_pages/grouping.vn.html#nhóm-theo-ngày",
    "title": "13  Nhóm dữ liệu",
    "section": "13.7 Nhóm theo ngày",
    "text": "13.7 Nhóm theo ngày\nKhi nhóm dữ liệu theo ngày, bạn phải có (hoặc tạo) một cột cho đơn vị ngày quan tâm - ví dụ: “ngày”, “tuần dịch tễ”, “tháng”, v.v. Bạn có thể tạo cột này bằng cách sử dụng floor_date() từ lubridate, như được giải thích trong phần Tuần dịch tễ học trong chương Làm việc với ngày tháng. Khi bạn có cột này, bạn có thể sử dụng count() từ dplyr để nhóm các hàng theo các giá trị ngày duy nhất đó và thu về giá trị số lượng tổng hợp.\nMột bước bổ sung phổ biến cho các tình huống với ngày/tháng, là “điền vào” bất kỳ ngày nào trong chuỗi ngày không có trong dữ liệu. Sử dụng complete() từ tidyr để chuỗi ngày tổng hợp được hoàn chỉnh bao gồm tất cả các đơn vị ngày có thể có trong phạm vi. Nếu không có bước này, một tuần không có trường hợp nào được báo cáo có thể không xuất hiện trong dữ liệu của bạn!\nTrong complete(), bạn xác định lại cột ngày của mình dưới dạng một chuỗi ngày seq.Date() từ giá trị nhỏ nhất đến giá trị lớn nhất - do đó mà ngày/tháng được mở rộng. Mặc định, giá trị số lượng trong bất kỳ hàng “mở rộng” mới nào sẽ là NA. Bạn có thể đặt chúng thành 0 bằng cách sử dụng argument fill = của hàm complete(), trong đó yêu cầu một danh sách được đặt tên (nếu cột số lượng của bạn được đặt tên là n, hãy thêm fill = list(n = 0)). Xem ?complete để biết chi tiết và xem ví dụ trong chương Làm việc với ngày tháng.\n\nCác trường hợp trong linelist theo ngày\nDưới đây là một ví dụ về nhóm các trường hợp theo ngày mà không sử dụng complete(). Lưu ý các hàng đầu tiên bỏ qua các ngày mà không có trường hợp nào.\n\ndaily_counts &lt;- linelist %&gt;% \n  drop_na(date_onset) %&gt;%        # remove that were missing date_onset\n  count(date_onset)              # count number of rows per unique date\n\n\n\n\n\n\n\nDưới đây, chúng ta thêm lệnh complete() để đảm bảo mỗi ngày trong phạm vi đều được hiển thị.\n\ndaily_counts &lt;- linelist %&gt;% \n  drop_na(date_onset) %&gt;%                 # remove case missing date_onset\n  count(date_onset) %&gt;%                   # count number of rows per unique date\n  complete(                               # ensure all days appear even if no cases\n    date_onset = seq.Date(                # re-define date colume as daily sequence of dates\n      from = min(date_onset, na.rm=T), \n      to = max(date_onset, na.rm=T),\n      by = \"day\"),\n    fill = list(n = 0))                   # set new filled-in rows to display 0 in column n (not NA as default) \n\n\n\n\n\n\n\n\n\nCác trường hợp trong linelist theo tuần\nNguyên tắc tương tự có thể được áp dụng cho tuần. Đầu tiên, hãy tạo một cột mới các trường hợp theo tuần bằng cách sử dụng floor_date() với unit = \"week\". Sau đó, sử dụng count() như trên để đạt được số lượng ca hàng tuần. Kết thúc bằng hàm complete() để đảm bảo rằng tất cả các tuần đều được hiển thị, ngay cả khi chúng không chứa ca nào.\n\n# Make dataset of weekly case counts\nweekly_counts &lt;- linelist %&gt;% \n  drop_na(date_onset) %&gt;%                 # remove cases missing date_onset\n  mutate(week = lubridate::floor_date(date_onset, unit = \"week\")) %&gt;%  # new column of week of onset\n  count(week) %&gt;%                         # group data by week and count rows per group\n  complete(                               # ensure all days appear even if no cases\n    week = seq.Date(                      # re-define date colume as daily sequence of dates\n      from = min(week, na.rm=T), \n      to = max(week, na.rm=T),\n      by = \"week\"),\n    fill = list(n = 0))                   # set new filled-in rows to display 0 in column n (not NA as default) \n\nĐây là 50 hàng đầu tiên của bộ dữ liệu khi trả kết quả:\n\n\n\n\n\n\n\n\nCác trường hợp trong linelist theo tháng\nĐể tổng hợp các trường hợp theo tháng, hãy sử dụng lại floor_date() từ package lubridate, nhưng với argument unit = \"months\". Điều này làm tròn xuống các ngày thành ngày đầu tiên của tháng. Đầu ra sẽ là định dạng ngày. Lưu ý rằng trong bước complete(), chúng ta cũng sử dụng by = \"months\".\n\n# Make dataset of monthly case counts\nmonthly_counts &lt;- linelist %&gt;% \n  drop_na(date_onset) %&gt;% \n  mutate(month = lubridate::floor_date(date_onset, unit = \"months\")) %&gt;%  # new column, 1st of month of onset\n  count(month) %&gt;%                          # count cases by month\n  complete(\n    month = seq.Date(\n      min(month, na.rm=T),     # include all months with no cases reported\n      max(month, na.rm=T),\n      by=\"month\"),\n    fill = list(n = 0))\n\n\n\n\n\n\n\n\n\nSố lượng đếm hàng ngày theo tuần\nĐể tổng hợp số lượng hàng ngày thành số lượng hàng tuần, hãy sử dụng floor_date() như trên. Tuy nhiên, hãy sử dụng group_by() và summarize() thay vì count() bởi vì chúng ta cần tính tổng sum() số lượng trường hợp hàng ngày thay vì chỉ đếm số hàng mỗi tuần.\n\n\nSố lượng đếm hàng ngày theo tuần\nĐể tổng hợp số lượng hàng ngày thành số lượng hàng tháng, hãy sử dụng floor_date() với unit = \"month\" như trên. Tuy nhiên, hãy sử dụng group_by() và summarize() thay vì count() bởi vì chúng ta cần tính tổng sum() số lượng trường hợp hàng ngày thay vì chỉ đếm số hàng mỗi tháng.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Nhóm dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.vn.html#sắp-xếp-dữ-liệu-đã-nhóm",
    "href": "new_pages/grouping.vn.html#sắp-xếp-dữ-liệu-đã-nhóm",
    "title": "13  Nhóm dữ liệu",
    "section": "13.8 Sắp xếp dữ liệu đã nhóm",
    "text": "13.8 Sắp xếp dữ liệu đã nhóm\nSử dụng hàm dplyr arrange() để sắp xếp các hàng trong bộ dữ liệu tương tự khi dữ liệu được nhóm lại, trừ khi bạn thiết lập đối số .by_group =TRUE. Trong trường hợp này, các hàng được sắp xếp thứ tự đầu tiên theo các cột nhóm và sau đó theo bất kỳ cột nào khác mà bạn chỉ định để arrange().",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Nhóm dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.vn.html#lọc-trên-nhóm-dữ-liệu-đã-nhóm",
    "href": "new_pages/grouping.vn.html#lọc-trên-nhóm-dữ-liệu-đã-nhóm",
    "title": "13  Nhóm dữ liệu",
    "section": "13.9 Lọc trên nhóm dữ liệu đã nhóm",
    "text": "13.9 Lọc trên nhóm dữ liệu đã nhóm\n\nfilter()\nKhi được áp dụng cùng với các hàm đánh giá bộ dữ liệu (như max(), min(), mean()), các hàm này sẽ được áp dụng cho các nhóm. Ví dụ: nếu bạn muốn lọc và giữ các hàng có bệnh nhân trên độ tuổi trung vị, hàm này sẽ áp dụng cho mỗi nhóm - lọc để giữ các hàng trên độ tuổi trung bình của nhóm.\n\n\nCắt hàng theo nhóm\nHàm dplyr slice(), mà lọc hàng dựa trên vị trí trong dữ liệu, cũng có thể được áp dụng cho mỗi nhóm. Hãy nhớ sắp xếp dữ liệu trong mỗi nhóm để có được “lát cắt” mong muốn.\nVí dụ: chỉ lấy 5 lần nhập viện gần nhất từ mỗi bệnh viện:\n\nNhóm bộ số liệu linelist theo cột hospital\n\nSắp xếp bản ghi từ gần nhất đến xa nhất theo date_hospitalisation trong mỗi nhóm bệnh viện\n\nCắt để lấy 5 hàng đầu tiên từ mỗi bệnh viện\n\n\nlinelist %&gt;%\n  group_by(hospital) %&gt;%\n  arrange(hospital, date_hospitalisation) %&gt;%\n  slice_head(n = 5) %&gt;% \n  arrange(hospital) %&gt;%                            # for display\n  select(case_id, hospital, date_hospitalisation)  # for display\n\n# A tibble: 30 × 3\n# Groups:   hospital [6]\n   case_id hospital          date_hospitalisation\n   &lt;chr&gt;   &lt;chr&gt;             &lt;date&gt;              \n 1 20b688  Central Hospital  2014-05-06          \n 2 d58402  Central Hospital  2014-05-10          \n 3 b8f2fd  Central Hospital  2014-05-13          \n 4 acf422  Central Hospital  2014-05-28          \n 5 275cc7  Central Hospital  2014-05-28          \n 6 d1fafd  Military Hospital 2014-04-17          \n 7 974bc1  Military Hospital 2014-05-13          \n 8 6a9004  Military Hospital 2014-05-13          \n 9 09e386  Military Hospital 2014-05-14          \n10 865581  Military Hospital 2014-05-15          \n# ℹ 20 more rows\n\n\nslice_head() - chọn n hàng từ trên xuống dưới\nslice_tail() - chọn n hàng từ dưới lên trên\nslice_sample() - chọn ngẫu nhiên n dòng\nslice_min() - chọn n dòng với giá trị cao nhất trong cột order_by =, sử dụng with_ties = TRUE để giữ mối liên hệ\nslice_max() - chọn n dòng với giá trị thấp nhất trong cột order_by =,sử dụng with_ties = TRUE để giữ mối liên hệ\nXem chương Loại bỏ trùng lặp để tham khảo thêm ví dụ và chi tiết về hàm slice().\n\n\nLọc theo quy mô nhóm\nHàm add_count() thêm một cột n vào dữ liệu gốc cho biết số hàng trong nhóm của hàng đó.\nNhư trình bày bên dưới, add_count() được áp dụng cho cột hospital, vì vậy các giá trị trong cột mới n phản ánh số hàng trong nhóm bệnh viện của hàng đó. Lưu ý cách các giá trị trong cột n được lặp lại. Trong ví dụ dưới đây, tên cột n có thể được thay đổi bằng cách sử dụng đối số name = trong add_count(). Với mục đích diễn giải, chúng ta sắp xếp lại các cột với select().\n\nlinelist %&gt;% \n  as_tibble() %&gt;% \n  add_count(hospital) %&gt;%          # add \"number of rows admitted to same hospital as this row\" \n  select(hospital, n, everything())\n\n# A tibble: 5,888 × 31\n   hospital                       n case_id generation date_infection date_onset\n   &lt;chr&gt;                      &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt; &lt;date&gt;         &lt;date&gt;    \n 1 Other                        885 5fe599           4 2014-05-08     2014-05-13\n 2 Missing                     1469 8689b7           4 NA             2014-05-13\n 3 St. Mark's Maternity Hosp…   422 11f8ea           2 NA             2014-05-16\n 4 Port Hospital               1762 b8812a           3 2014-05-04     2014-05-18\n 5 Military Hospital            896 893f25           3 2014-05-18     2014-05-21\n 6 Port Hospital               1762 be99c8           3 2014-05-03     2014-05-22\n 7 Missing                     1469 07e3e8           4 2014-05-22     2014-05-27\n 8 Missing                     1469 369449           4 2014-05-28     2014-06-02\n 9 Missing                     1469 f393b4           4 NA             2014-06-05\n10 Missing                     1469 1389ca           4 NA             2014-06-05\n# ℹ 5,878 more rows\n# ℹ 25 more variables: date_hospitalisation &lt;date&gt;, date_outcome &lt;date&gt;,\n#   outcome &lt;chr&gt;, gender &lt;chr&gt;, age &lt;dbl&gt;, age_unit &lt;chr&gt;, age_years &lt;dbl&gt;,\n#   age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;, lon &lt;dbl&gt;, lat &lt;dbl&gt;, infector &lt;chr&gt;,\n#   source &lt;chr&gt;, wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;, ct_blood &lt;dbl&gt;, fever &lt;chr&gt;,\n#   chills &lt;chr&gt;, cough &lt;chr&gt;, aches &lt;chr&gt;, vomit &lt;chr&gt;, temp &lt;dbl&gt;,\n#   time_admission &lt;chr&gt;, bmi &lt;dbl&gt;, days_onset_hosp &lt;dbl&gt;\n\n\nSau đó, nó trở nên dễ dàng để lọc các hàng trường hợp nhập viện tại một bệnh viện “nhỏ”, chẳng hạn như một bệnh viện tiếp nhận ít hơn 500 bệnh nhân:\n\nlinelist %&gt;% \n  add_count(hospital) %&gt;% \n  filter(n &lt; 500)",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Nhóm dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.vn.html#tạo-cột-mới-trên-dữ-liệu-được-nhóm",
    "href": "new_pages/grouping.vn.html#tạo-cột-mới-trên-dữ-liệu-được-nhóm",
    "title": "13  Nhóm dữ liệu",
    "section": "13.10 Tạo cột mới trên dữ liệu được nhóm",
    "text": "13.10 Tạo cột mới trên dữ liệu được nhóm\nĐể giữ lại tất cả các cột và hàng (không tổng hợp) và thêm một cột mới chứa thống kê theo nhóm, hãy sử dụng hàm mutate() sau group_by() thay vì summarise().\nĐiều này hữu ích nếu bạn muốn nhóm thống kê trong bộ dữ liệu gốc với tất cả các cột khác được hiển thị - ví dụ: cho các phép tính so sánh một hàng với nhóm của nó.\nVí dụ: code dưới đây tính toán sự khác biệt giữa thời gian trễ nhập viện của một hàng và thời gian chậm trễ trung vị đối với bệnh viện đó. Các bước lần lượt là:\n\nNhóm dữ liệu theo bệnh viện\n\nSử dụng cột days_onset_hosp (nhập viện trễ) để tạo một cột mới chứa giá trị trễ trung bình tại bệnh viện của hàng đó\n\nTính toán sự khác biệt giữa hai cột\n\nChúng ta chỉ lựa chọn select() những cột cần hiển thị, cho mục đích diễn giải.\n\nlinelist %&gt;% \n  # group data by hospital (no change to linelist yet)\n  group_by(hospital) %&gt;% \n  \n  # new columns\n  mutate(\n    # mean days to admission per hospital (rounded to 1 decimal)\n    group_delay_admit = round(mean(days_onset_hosp, na.rm=T), 1),\n    \n    # difference between row's delay and mean delay at their hospital (rounded to 1 decimal)\n    diff_to_group     = round(days_onset_hosp - group_delay_admit, 1)) %&gt;%\n  \n  # select certain rows only - for demonstration/viewing purposes\n  select(case_id, hospital, days_onset_hosp, group_delay_admit, diff_to_group)\n\n# A tibble: 5,888 × 5\n# Groups:   hospital [6]\n   case_id hospital              days_onset_hosp group_delay_admit diff_to_group\n   &lt;chr&gt;   &lt;chr&gt;                           &lt;dbl&gt;             &lt;dbl&gt;         &lt;dbl&gt;\n 1 5fe599  Other                               2               2             0  \n 2 8689b7  Missing                             1               2.1          -1.1\n 3 11f8ea  St. Mark's Maternity…               2               2.1          -0.1\n 4 b8812a  Port Hospital                       2               2.1          -0.1\n 5 893f25  Military Hospital                   1               2.1          -1.1\n 6 be99c8  Port Hospital                       1               2.1          -1.1\n 7 07e3e8  Missing                             2               2.1          -0.1\n 8 369449  Missing                             1               2.1          -1.1\n 9 f393b4  Missing                             1               2.1          -1.1\n10 1389ca  Missing                             2               2.1          -0.1\n# ℹ 5,878 more rows",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Nhóm dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.vn.html#chọn-trên-dữ-liệu-được-nhóm",
    "href": "new_pages/grouping.vn.html#chọn-trên-dữ-liệu-được-nhóm",
    "title": "13  Nhóm dữ liệu",
    "section": "13.11 Chọn trên dữ liệu được nhóm",
    "text": "13.11 Chọn trên dữ liệu được nhóm\nHàm select() hoạt động trên dữ liệu được nhóm, nhưng các cột được nhóm luôn được bao gồm (ngay cả khi không được đề cập trong select()). Nếu bạn không muốn nhóm các cột này, trước tiên hãy bỏ nhóm bằng hàm ungroup().",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Nhóm dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.vn.html#tài-nguyên-học-liệu",
    "href": "new_pages/grouping.vn.html#tài-nguyên-học-liệu",
    "title": "13  Nhóm dữ liệu",
    "section": "13.12 Tài nguyên học liệu",
    "text": "13.12 Tài nguyên học liệu\nDưới đây là một số tài nguyên hữu ích cung cấp thêm thông tin:\nBạn có thể thực hiện bất kỳ hàm tổng hợp nào trên dữ liệu được nhóm; xem RStudio cheat sheet về biến đổi dữ liệu\nTrang Data Carpentry của dplyr\nChương tham khảo hệ sinh thái tidyverse về group_by() và grouping\nTrang này về Thao tác dữ liệu\nTổng hợp có điều kiện với dplyr",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Nhóm dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.vn.html",
    "href": "new_pages/joining_matching.vn.html",
    "title": "14  Nối dữ liệu",
    "section": "",
    "text": "14.1 Chuẩn bị",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Nối dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.vn.html#chuẩn-bị",
    "href": "new_pages/joining_matching.vn.html#chuẩn-bị",
    "title": "14  Nối dữ liệu",
    "section": "",
    "text": "Gọi package\nĐoạn code này hiển thị những package cần gọi cho các phân tích. Trong sổ tay này, chúng ta nhấn mạnh đến hàm p_load() từ pacman, hàm sẽ cài đặt package nếu cần và gọi nó ra để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm library() từ base R. Xem chương R cơ bản để có thêm thông tin về các R package.\n\npacman::p_load(\n  rio,            # import and export\n  here,           # locate files \n  tidyverse,      # data management and visualisation\n  RecordLinkage,  # probabilistic matches\n  fastLink        # probabilistic matches\n)\n\n\n\nNhập dữ liệu\nĐể bắt đầu, chúng ta nhập các trường hợp trong linelist đã được làm sạch từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn theo dõi, bấm để tải xuống linelist “đã được làm sạch” (tệp .rds). Nhập dữ liệu với hàm import() từ package rio (hàm này xử lý nhiều loại tệp như .xlsx, .csv, .rds - Xem chương Nhập xuất dữ liệu để biết thêm chi tiết).\n\n# import case linelist \nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\n50 hàng đầu tiên của linelist được hiển thị dưới đây.\n\n\n\n\n\n\n\n\n\nBộ dữ liệu mẫu\nTrong phần nối dữ liệu dưới đây, chúng ta sẽ sử dụng các bộ dữ liệu sau:\n\nMột phiên bản “thu nhỏ” của bộ dữ liệu linelist, chỉ chứa các cột case_id, date_onset, hospital và chỉ 10 hàng đầu tiên\n\nMột data frame riêng biệt có tên hosp_info, chứa thêm thông tin chi tiết của từng bệnh viện\n\nTrong phần ghép theo xác suất, chúng ta sẽ sử dụng hai bộ dữ liệu nhỏ khác nhau. Code để tạo các bộ dữ liệu này được đưa ra trong phần đó.\n\nDữ liệu linelist “thu nhỏ”\nDưới đây là bộ dữ liệu linelist thu nhỏ, bao gồm 10 hàng và chỉ chứa các cột case_id, date_onset và hospital.\n\nlinelist_mini &lt;- linelist %&gt;%                 # start with original linelist\n  select(case_id, date_onset, hospital) %&gt;%   # select columns\n  head(10)                                    # only take the first 10 rows\n\n\n\n\n\n\n\n\n\nData frame thông tin bệnh viện\nDưới đây là code để tạo một data frame riêng biệt với thông tin bổ sung của bảy bệnh viện (số lượng người dân có thể tiếp cận và mức độ chăm sóc hiện có). Lưu ý rằng tên “Bệnh viện Quân đội (Military Hospital)” thuộc về hai bệnh viện khác nhau - một bệnh viện cấp 1 phục vụ 10000 cư dân và một bệnh viện cấp hai phục vụ 40500 cư dân.\n\n# Make the hospital information data frame\nhosp_info = data.frame(\n  hosp_name     = c(\"central hospital\", \"military\", \"military\", \"port\", \"St. Mark's\", \"ignace\", \"sisters\"),\n  catchment_pop = c(1950280, 40500, 10000, 50280, 12000, 5000, 4200),\n  level         = c(\"Tertiary\", \"Secondary\", \"Primary\", \"Secondary\", \"Secondary\", \"Primary\", \"Primary\")\n)\n\nĐây là data frame này:\n\n\n\n\n\n\n\n\n\n\nLàm sạch trước\nCác phương pháp nối truyền thống (không theo xác suất) phân biệt chữ hoa, chữ thường và yêu cầu khớp các ký tự chính xác giữa các giá trị trong hai data frame. Để minh họa một số bước làm sạch mà bạn có thể cần làm trước khi bắt đầu nối, chúng ta sẽ làm sạch và căn chỉnh bộ dữ liệu linelist_mini và hosp_info ngay bây giờ.\nXác định điểm khác biệt\nChúng ta cần các giá trị của cột hosp_name trong data frame hosp_info để khớp với các giá trị của cột hospital trong data frame linelist_mini.\nDưới đây là các giá trị trong data frame linelist_mini, được in bằng hàm unique()trong base R:\n\nunique(linelist_mini$hospital)\n\n[1] \"Other\"                               \n[2] \"Missing\"                             \n[3] \"St. Mark's Maternity Hospital (SMMH)\"\n[4] \"Port Hospital\"                       \n[5] \"Military Hospital\"                   \n\n\nvà đây là các giá trị trong data frame hosp_info:\n\nunique(hosp_info$hosp_name)\n\n[1] \"central hospital\" \"military\"         \"port\"             \"St. Mark's\"      \n[5] \"ignace\"           \"sisters\"         \n\n\nBạn có thể thấy rằng mặc dù một số bệnh viện tồn tại trong cả hai data frame, nhưng có nhiều điểm khác biệt về chính tả.\nCăn chỉnh giá trị\nChúng ta bắt đầu bằng cách làm sạch các giá trị trong data frame hosp_info. Như đã được giải thích trong chương Làm sạch số liệu và các hàm quan trọng, chúng ta có thể code lại các giá trị với tiêu chí logic bằng cách sử dụng hàm case_when() của dplyr. Đối với bốn bệnh viện tồn tại trong cả hai data frame, chúng ta thay đổi các giá trị để phù hợp với các giá trị trong linelist_mini. Các bệnh viện khác chúng ta để nguyên giá trị (TRUE ~ hosp_name).\nCẨN TRỌNG: Thông thường khi làm sạch, chúng ta nên tạo một cột mới (ví dụ: hosp_name_clean), nhưng để dễ dàng giải thích, chúng ta hiển thị các thay đổi trên cột cũ\n\nhosp_info &lt;- hosp_info %&gt;% \n  mutate(\n    hosp_name = case_when(\n      # criteria                         # new value\n      hosp_name == \"military\"          ~ \"Military Hospital\",\n      hosp_name == \"port\"              ~ \"Port Hospital\",\n      hosp_name == \"St. Mark's\"        ~ \"St. Mark's Maternity Hospital (SMMH)\",\n      hosp_name == \"central hospital\"  ~ \"Central Hospital\",\n      TRUE                             ~ hosp_name\n      )\n    )\n\nTên bệnh viện xuất hiện trong cả hai data frame đều được căn chỉnh. Có hai bệnh viện trong dữ liệu hosp_info không có trong linelist_mini - chúng ta sẽ giải quyết những trường hợp này sau, trong phần nối dữ liệu.\n\nunique(hosp_info$hosp_name)\n\n[1] \"Central Hospital\"                    \n[2] \"Military Hospital\"                   \n[3] \"Port Hospital\"                       \n[4] \"St. Mark's Maternity Hospital (SMMH)\"\n[5] \"ignace\"                              \n[6] \"sisters\"                             \n\n\nTrước một phép nối, việc chuyển đổi một cột thành tất cả chữ thường hoặc tất cả chữ hoa thường dễ dàng nhất. Nếu bạn cần chuyển đổi tất cả các giá trị trong một cột thành CHỮ HOA hoặc chữ thường, hãy sử dụng mutate() và đặt cột bên trong một trong những hàm từ package stringr, như ã được trình bày trong chương Ký tự và chuỗi.\nstr_to_upper()\nstr_to_upper()\nstr_to_title()",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Nối dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.vn.html#nối-bằng-dplyr",
    "href": "new_pages/joining_matching.vn.html#nối-bằng-dplyr",
    "title": "14  Nối dữ liệu",
    "section": "14.2 Nối bằng dplyr",
    "text": "14.2 Nối bằng dplyr\nPackage dplyr cung cấp một số hàm nối khác nhau. dplyr là một package thuộc hệ sinh thái tidyverse. Các hàm nối này được mô tả ở bên dưới, trong các trường hợp sử dụng đơn giản.\nRất cảm ơn https://github.com/gadenbuie vì những tấm ảnh động bổ ích!\n\n\nCú pháp chung\nCác lệnh nối có thể được chạy dưới dạng các lệnh độc lập để nối hai data frame thành một đối tượng mới, hoặc chúng có thể được sử dụng trong một chuỗi pipe (%&gt;%) để hợp nhất một data frame vào một data frame khác khi nó đang được làm sạch hoặc chỉnh sửa.\nTrong ví dụ dưới đây, hàm left_join() được sử dụng như một lệnh độc lập để tạo một data frame joined_data mới. Các dữ liệu đầu vào là data frame 1 và 2 (df1 và df2). Data frame đầu tiên được liệt kê là data frame cơ sở và data frame thứ hai được liệt kê là data frame sẽ nối với data frame thứ nhất.\nĐối số thứ ba by = là nơi bạn xác định các cột trong mỗi data frame mà sẽ được sử dụng để căn chỉnh các hàng trong hai data frame. Nếu tên của các cột này khác nhau, hãy đặt chúng trong một vectơ c() như được trình bày dưới đây, nơi mà các hàng được khớp trên cơ sở các giá trị chung giữa cột ID trong df1 và cột identifier trong df2.\n\n# Join based on common values between column \"ID\" (first data frame) and column \"identifier\" (second data frame)\njoined_data &lt;- left_join(df1, df2, by = c(\"ID\" = \"identifier\"))\n\nNếu các cột by trong cả hai data frame có cùng tên, bạn chỉ cần cung cấp tên này, đặt trong dấu ngoặc kép.\n\n# Joint based on common values in column \"ID\" in both data frames\njoined_data &lt;- left_join(df1, df2, by = \"ID\")\n\nNếu bạn đang nối các data frame dựa trên các giá trị chung của nhiều trường, hãy liệt kê các trường này trong vectơ c(). Ví dụ dưới đây nối các hàng nếu các giá trị trong ba cột trong mỗi bộ dữ liệu căn chỉnh chính xác.\n\n# join based on same first name, last name, and age\njoined_data &lt;- left_join(df1, df2, by = c(\"name\" = \"firstname\", \"surname\" = \"lastname\", \"Age\" = \"age\"))\n\nCác lệnh nối cũng có thể được chạy trong một chuỗi pipe. Điều này sẽ thực hiện sửa đổi data frame trong chuỗi pipe.\nTrong ví dụ dưới đây, df1 được đưa qua các pipe, df2 được nối vào đó và vì thế df1 được chỉnh sửa và xác định lại.\n\ndf1 &lt;- df1 %&gt;%\n  filter(date_onset &lt; as.Date(\"2020-03-05\")) %&gt;% # miscellaneous cleaning \n  left_join(df2, by = c(\"ID\" = \"identifier\"))    # join df2 to df1\n\nCẨN TRỌNG: Nối dựa trên những trường hợp cụ thể! Do đó, rất hữu ích khi chuyển đổi tất cả các giá trị thành chữ thường hoặc chữ hoa trước khi nối. Xem thêm chương về ký tự/chuỗi.\n\n\n\nNối trái và phải\nNối trái hoặc phải thường được sử dụng để thêm thông tin vào data frame - thông tin mới chỉ được thêm vào các hàng đã tồn tại trong data frame cơ sở. Đây là những phép nối phổ biến trong hoạt động dịch tễ học vì chúng được sử dụng để thêm thông tin từ một bộ dữ liệu vào một bộ dữ liệu khác.\nKhi sử dụng các phép nối này, thứ tự viết của các data frame trong lệnh rất quan trọng*.\n\nTrong phép nối trái, data frame đầu tiên được viết là data frame cơ sở\n\nTrong phép nối phải, data frame thứ hai được viết là data frame cơ sở\n\nTất cả các hàng của data frame cơ sở được giữ lại. Thông tin trong data frame (thứ cấp) khác được kết hợp với data frame cơ sở chỉ khi có sự trùng khớp của (các) cột định danh. Ngoài ra:\n\nCác hàng trong data frame thứ cấp không khớp sẽ bị loại bỏ.\n\nNếu có nhiều hàng cơ sở khớp với một hàng trong data frame thứ cấp (nhiều-khớp-một), thông tin phụ sẽ được thêm vào mỗi hàng cơ sở được khớp.\n\nNếu một hàng cơ sở khớp với nhiều hàng trong data frame thứ cấp (một-khớp-nhiều), tất cả các kết hợp sẽ được đưa ra, nghĩa là các hàng mới có thể được thêm vào data frame trả về của bạn!\n\nSau đây là các ví dụ động về phép nối trái và phải (nguồn ảnh)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVí dụ\nDưới đây là kết quả đầu ra của phép nối trái left_join() của bộ dữ liệu hosp_info (data frame thứ cấp, xem tại đây) vào linelist_mini (data frame cơ sở, xem tại đây). linelist_mini gốc có nrow(linelist_mini) hàng. linelist_mini đã chỉnh sửa được hiển thị. Lưu ý những điều dưới đây:\n\nHai cột mới catchment_pop và level đã được thêm vào bên trái của linelist_mini\n\nTất cả các hàng gốc của data frame cơ sở linelist_mini đều được giữ lại\n\nBất kỳ hàng gốc nào của linelist_mini cho “Military Hospital” đều bị trùng lặp vì nó khớp với hai hàng trong data frame thứ cấp, do đó cả hai sự kết hợp đều được trả về\n\nCột định danh kết hợp của bộ dữ liệu thứ cấp (hosp_name) đã biến mất vì nó thừa so với cột định danh trong bộ dữ liệu chính (hospital)\n\nKhi một hàng cơ sở không khớp với bất kỳ hàng thứ cấp nào (ví dụ: khi hospital là “Other” hoặc “Missing”), NA (trống) sẽ điền vào các cột từ data frame thứ cấp\n\nCác hàng trong data frame thứ cấp không khớp với data frame cơ sở (bệnh viện “sisters” và “ignace”) đã bị loại bỏ\n\n\nlinelist_mini %&gt;% \n  left_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))\n\n\n\nWarning in left_join(., hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 5 of `x` matches multiple rows in `y`.\nℹ Row 4 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\n\n“Tôi nên sử dụng phép nối phải hay phép nối trái?”\nĐể trả lời câu hỏi trên, hãy tự hỏi “data frame nào nên giữ lại tất cả các hàng của nó?” - hãy sử dụng cái này làm data frame cơ sở. Phép nối trái giữ tất cả các hàng trong data frame đầu tiên được viết trong lệnh, trong khi phép nối phải giữ tất cả các hàng trong data frame thứ hai.\nHai lệnh bên dưới đạt cùng một kết quả đầu ra - 10 hàng hosp_info được nối vào bộ dữ liệu cơ sở linelist_mini, tuy nhiên chúng sử dụng các phép nối khác nhau. Kết quả là thứ tự cột sẽ khác nhau dựa trên việc hosp_info đến từ bên phải (trong phép nối bên trái) hay đến từ bên trái (trong phép nối bên phải). Thứ tự của các hàng cũng có thể thay đổi tương ứng. Nhưng cả hai hệ quả này đều có thể được giải quyết bằng cách sử dụng select() để sắp xếp lại các cột hoặc arrange() để sắp xếp các hàng.\n\n# The two commands below achieve the same data, but with differently ordered rows and columns\nleft_join(linelist_mini, hosp_info, by = c(\"hospital\" = \"hosp_name\"))\nright_join(hosp_info, linelist_mini, by = c(\"hosp_name\" = \"hospital\"))\n\nĐây là kết quả nối hosp_info vào linelist_mini qua phép nối trái (các cột mới đến từ bên phải)\n\n\nWarning in left_join(linelist_mini, hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 5 of `x` matches multiple rows in `y`.\nℹ Row 4 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\nĐây là kết quả nối hosp_info vào linelist_mini qua phép nối phải (các cột mới đến từ bên trái)\n\n\nWarning in right_join(hosp_info, linelist_mini, by = c(hosp_name = \"hospital\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 4 of `x` matches multiple rows in `y`.\nℹ Row 5 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\nNgoài ra, hãy xem xét liệu trường hợp-đang sử dụng của bạn có nằm trong một chuỗi pipe (%&gt;%) hay không. Nếu bộ dữ liệu nằm trong pipe là đường cơ sở, bạn có thể sẽ sử dụng một phép nối trái để thêm dữ liệu vào đó.\n\n\n\n\nNối hoàn toàn\nNối hoàn toàn là phép nối bao hàm nhất trong tất cả các phép nối - nó trả về tất cả các hàng từ cả hai data frame.\nNếu có bất kỳ hàng nào chỉ hiện diện duy nhất trong một data frame (khi không tìm thấy hàng nào phù hợp), data frame sẽ bao gồm các hàng đó và trở nên dài hơn. Các giá trị missing NA được sử dụng để điền-vào bất kỳ khoảng trống nào đã tạo. Khi bạn nối, hãy kiểm tra số cột và số hàng cẩn thận để khắc phục lỗi về phân biệt chữ hoa với chữ thường và đảm bảo các kết quả khớp ký tự chính xác.\nData frame “cơ sở” là data frame được viết đầu tiên trong lệnh. Việc điều chỉnh data frame này sẽ không ảnh hưởng đến những bản ghi nào được trả về bởi phép nối, nhưng nó có thể ảnh hưởng đến thứ tự cột kết quả, thứ tự hàng và cột định danh nào được giữ lại.\n\n\n\n\n\n\n\n\n\nVí dụ động về một phép nối hoàn toàn (nguồn ảnh)\nVí dụ\nDưới đây kết quả đầu ra của phép nối hoàn toàn full_join() của hosp_info (ban đầu là nrow(hosp_info), xem tại đây) vào linelist_mini (ban đầu là nrow(linelist_mini), xem tại đây). Lưu ý những điều dưới đây:\n\nTất cả các hàng cơ sở đều được giữ nguyên (linelist_mini)\n\nCác hàng trong data frame thứ cấp không khớp với data frame cơ sở được giữ lại (“ignace” và “sisters”), với các giá trị trong các cột cơ sở tương ứng case_id và onset điền-vào các giá trị missing\n\nTương tự, các hàng trong data frame cơ sở không khớp với hàng trong data frame thứ cấp (“Other” và “Missing”) được giữ lại, với các cột phụ catchment_pop và level điền-vào các giá trị missing\n\nTrong trường hợp khớp một-với-một hoặc nhiều-với-một (ví dụ: các hàng của “Military Hospital”), tất cả các kết hợp có thể có được trả về (kéo dài thêm data frame cuối cùng)\n\nChỉ cột định danh từ data frame cơ sở được giữ lại (hospital)\n\n\nlinelist_mini %&gt;% \n  full_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))\n\n\n\nWarning in full_join(., hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 5 of `x` matches multiple rows in `y`.\nℹ Row 4 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\n\n\n\nNối bên trong\nNối bên trong là phép nối hạn chế nhất trong tất cả các phép nối - nó chỉ trả về các hàng có kết quả khớp trên cả hai data frame.\nĐiều này có nghĩa là số hàng trong data frame cơ sở có thể thực sự giảm xuống. Việc điều chỉnh data frame nào là “cơ sở” (được viết đầu tiên trong hàm) sẽ không ảnh hưởng đến hàng nào được trả về, nhưng nó sẽ ảnh hưởng đến thứ tự cột, thứ tự hàng và cột định danh nào được giữ lại.\n\n\n\n\n\n\n\n\n\nVí dụ động về một phép nối bên trong (nguồn ảnh)\nVí dụ\nDưới đây kết quả đầu ra việc nối inner_join() của linelist_mini (cơ sở) với hosp_info (thứ cấp). Lưu ý những điều dưới đây:\n\nCác hàng cơ sở không khớp với dữ liệu thứ cấp sẽ bị xóa (các hàng mà hospital nhận giá trị “Missing” hoặc “Other”)\n\nTương tự, các hàng từ data frame thứ cấp không khớp trong data frame cơ sở sẽ bị xóa (các hàng mà hosp_name nhận giá trị “sisters” hoặc “ignace”)\n\nChỉ cột định danh từ data frame cơ sở được giữ lại (hospital)\n\n\nlinelist_mini %&gt;% \n  inner_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))\n\n\n\nWarning in inner_join(., hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 5 of `x` matches multiple rows in `y`.\nℹ Row 4 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\n\n\n\nNối một phần\nNối một phần là một “phép nối chọn lọc” mà sử dụng bộ dữ liệu khác không nhằm để thêm hàng hay cột, mà để lọc dữ liệu.\nPhép nối-một phần giữ lại tất cả các quan sát trong data frame cơ sở mà có sự trùng khớp với data frame thứ cấp (nhưng không thêm cột mới cũng như không sao chép bất kỳ hàng nào cho các dữ liệu khớp). Đọc thêm về những phép nối “chọn lọc” này tại đây.\n\n\n\n\n\n\n\n\n\nVí dụ động về phép nối một phần (nguồn ảnh)\nNhư một ví dụ, code dưới đây trả về các hàng từ data frame hosp_info mà khớp với linelist_mini theo tên bệnh viện.\n\nhosp_info %&gt;% \n  semi_join(linelist_mini, by = c(\"hosp_name\" = \"hospital\"))\n\n                             hosp_name catchment_pop     level\n1                    Military Hospital         40500 Secondary\n2                    Military Hospital         10000   Primary\n3                        Port Hospital         50280 Secondary\n4 St. Mark's Maternity Hospital (SMMH)         12000 Secondary\n\n\n\n\n\nAnti join\nAnti join là một “phép nối chọn lọc” khác trả về các hàng trong data frame cơ sở không khớp với data frame thứ cấp.\nĐọc thêm về những phép nối “chọn lọc” này tại đây.\nCác tình huống phổ biến của anti join bao gồm xác định các bản ghi không tồn tại trong một data frame khác, khắc phục lỗi chính tả trong một phép nối (xem xét các bản ghi đáng lẽ sẽ khớp) và kiểm tra các bản ghi đã bị loại trừ sau một phép nối khác.\nNhư với right_join() và left_join(), quan trọng là data frame cơ sở (được liệt kê đầu tiên). Các hàng được trả về chỉ từ data frame cơ sở. Lưu ý trong ảnh động bên dưới, hàng trong data frame thứ cấp (hàng 4 màu tím) không được trả về mặc dù nó không khớp với hàng cơ sở.\n\n\n\n\n\n\n\n\n\nVí dụ động về anti join (nguồn ảnh)\n\nVí dụ anti_join() đơn giản\nMột ví dụ đơn giản, hãy tìm bệnh viện trong hosp_info mà không tồn tại trong linelist_mini. chúng ta liệt kê hosp_info trước, như một data frame cơ sở. Các bệnh viện không có trong linelist_mini sẽ được trả về.\n\nhosp_info %&gt;% \n  anti_join(linelist_mini, by = c(\"hosp_name\" = \"hospital\"))\n\n\n\n\n\n\n\n\n\nVí dụ anti_join() phức tạp\nMột ví dụ khác, giả sử chúng ta đã chạy một inner_join() giữa linelist_mini và hosp_info. Lệnh này chỉ trả về một tập con các bản ghi của linelist_mini gốc, vì một số bản ghi không có trong hosp_info.\n\nlinelist_mini %&gt;% \n  inner_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))\n\n\n\nWarning in inner_join(., hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 5 of `x` matches multiple rows in `y`.\nℹ Row 4 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\nĐể xem lại các bản ghi linelist_mini đã bị loại trừ trong phép nối bên trong, chúng ta có thể chạy một phép nối anti-join với cùng thiết lập (linelist_mini là data frame cơ sở).\n\nlinelist_mini %&gt;% \n  anti_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))\n\n\n\n\n\n\n\nĐể xem các bản ghi hosp_info đã bị loại trừ trong phép nối bên trong, chúng ta cũng có thể chạy một phép nối anti-join với hosp_info là data frame cơ sở.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Nối dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.vn.html#khớp-theo-xác-suất",
    "href": "new_pages/joining_matching.vn.html#khớp-theo-xác-suất",
    "title": "14  Nối dữ liệu",
    "section": "14.3 Khớp theo xác suất",
    "text": "14.3 Khớp theo xác suất\nNếu bạn không có thông tin định danh duy nhất chung trên các bộ dữ liệu để nối, hãy xem xét sử dụng thuật toán khớp theo xác suất. Phương pháp này sẽ tìm thấy các bản ghi khớp với nhau dựa trên sự tương đồng (ví dụ: khoảng cách chuỗi Jaro-Winkler hoặc khoảng cách số). Dưới đây là một ví dụ đơn giản sử dụng package fastLink.\nGọi package\n\npacman::p_load(\n  tidyverse,      # data manipulation and visualization\n  fastLink        # record matching\n  )\n\nDưới đây là hai bộ dữ liệu mẫu nhỏ mà chúng ta sẽ sử dụng để giải thích phương pháp khớp theo xác suất (cases và test_results):\nĐây là code được sử dụng để tạo bộ dữ liệu:\n\n# make datasets\n\ncases &lt;- tribble(\n  ~gender, ~first,      ~middle,     ~last,        ~yr,   ~mon, ~day, ~district,\n  \"M\",     \"Amir\",      NA,          \"Khan\",       1989,  11,   22,   \"River\",\n  \"M\",     \"Anthony\",   \"B.\",        \"Smith\",      1970, 09, 19,      \"River\", \n  \"F\",     \"Marialisa\", \"Contreras\", \"Rodrigues\",  1972, 04, 15,      \"River\",\n  \"F\",     \"Elizabeth\", \"Casteel\",   \"Chase\",      1954, 03, 03,      \"City\",\n  \"M\",     \"Jose\",      \"Sanchez\",   \"Lopez\",      1996, 01, 06,      \"City\",\n  \"F\",     \"Cassidy\",   \"Jones\",      \"Davis\",     1980, 07, 20,      \"City\",\n  \"M\",     \"Michael\",   \"Murphy\",     \"O'Calaghan\",1969, 04, 12,      \"Rural\", \n  \"M\",     \"Oliver\",    \"Laurent\",    \"De Bordow\" , 1971, 02, 04,     \"River\",\n  \"F\",      \"Blessing\",  NA,          \"Adebayo\",   1955,  02, 14,     \"Rural\"\n)\n\nresults &lt;- tribble(\n  ~gender,  ~first,     ~middle,     ~last,          ~yr, ~mon, ~day, ~district, ~result,\n  \"M\",      \"Amir\",     NA,          \"Khan\",         1989, 11,   22,  \"River\", \"positive\",\n  \"M\",      \"Tony\",   \"B\",         \"Smith\",          1970, 09,   19,  \"River\", \"positive\",\n  \"F\",      \"Maria\",    \"Contreras\", \"Rodriguez\",    1972, 04,   15,  \"Cty\",   \"negative\",\n  \"F\",      \"Betty\",    \"Castel\",   \"Chase\",        1954,  03,   30,  \"City\",  \"positive\",\n  \"F\",      \"Andrea\",   NA,          \"Kumaraswamy\",  2001, 01,   05,  \"Rural\", \"positive\",      \n  \"F\",      \"Caroline\", NA,          \"Wang\",         1988, 12,   11,  \"Rural\", \"negative\",\n  \"F\",      \"Trang\",    NA,          \"Nguyen\",       1981, 06,   10,  \"Rural\", \"positive\",\n  \"M\",      \"Olivier\" , \"Laurent\",   \"De Bordeaux\",  NA,   NA,   NA,  \"River\", \"positive\",\n  \"M\",      \"Mike\",     \"Murphy\",    \"O'Callaghan\",  1969, 04,   12,  \"Rural\", \"negative\",\n  \"F\",      \"Cassidy\",  \"Jones\",     \"Davis\",        1980, 07,   02,  \"City\",  \"positive\",\n  \"M\",      \"Mohammad\", NA,          \"Ali\",          1942, 01,   17,  \"City\",  \"negative\",\n  NA,       \"Jose\",     \"Sanchez\",   \"Lopez\",        1995, 01,   06,  \"City\",  \"negative\",\n  \"M\",      \"Abubakar\", NA,          \"Abullahi\",     1960, 01,   01,  \"River\", \"positive\",\n  \"F\",      \"Maria\",    \"Salinas\",   \"Contreras\",    1955, 03,   03,  \"River\", \"positive\"\n  )\n\nBộ dữ liệu cases có 9 bản ghi của những bệnh nhân đang chờ kết quả xét nghiệm.\n\n\n\n\n\n\nBộ dữ liệu test_results có 14 bản ghi và chứa cột result, cột mà chúng ta muốn thêm vào các bản ghi trong cases dựa trên các bản ghi khớp theo xác xuất.\n\n\n\n\n\n\n\nKhớp theo xác suất\nHàm fastLink() từ package fastLink có thể được sử dụng để áp dụng một thuật toán so khớp. Đây là thông tin cơ bản. Bạn có thể đọc chi tiết thêm bằng cách nhập ?fastLink trong console của mình.\n\nXác định hai data frame để so sánh với các đối số dfA = và dfB =\n\nTrong varnames = cung cấp tất cả các tên cột được sử dụng để khớp. Tất cả tên cột phải tồn tại trong cả hai dfA và dfB.\n\nTrong stringdist.match = cung cấp các cột từ những cột trong varnames được đánh giá trên chuỗi “distance”.\n\nTrong numeric.match = cung cấp các cột từ những cột trong varnames được đánh giá trên khoảng.\n\nCác giá trị missing sẽ bị bỏ qua\n\nTheo mặc định, mỗi hàng từ một trong hai data frame sẽ được khớp với nhiều nhất một hàng trong data frame còn lại. Nếu bạn muốn xem tất cả các kết quả khớp được đánh giá, hãy đặt dedupe.matches = FALSE. Việc loại bỏ trùng lặp được thực hiện bằng giải pháp gán tuyến tính của Winkler.\n\nMẹo: tách một cột ngày thành ba cột số riêng biệt bằng cách sử dụng day(), month() và year() từ package lubridate\nNgưỡng mặc định cho các kết quả khớp là 0,94 (threshold.match =) nhưng bạn có thể điều chỉnh nó cao hơn hoặc thấp hơn. Nếu bạn xác định ngưỡng, hãy cân nhắc việc ngưỡng cao hơn có thể mang lại nhiều âm tính giả hơn (các hàng không khớp sẽ thực sự khớp) và tương tự như vậy, ngưỡng thấp hơn có thể mang lại nhiều kết quả dương tính giả hơn.\nDưới đây, dữ liệu được đối sánh trên khoảng cách chuỗi trên các cột tên (name) và quận (district), cũng như khoảng cách số cho ngày (day), tháng month), năm sinh (year). Ngưỡng đối sánh với xác suất là 95% được thiết lập.\n\nfl_output &lt;- fastLink::fastLink(\n  dfA = cases,\n  dfB = results,\n  varnames = c(\"gender\", \"first\", \"middle\", \"last\", \"yr\", \"mon\", \"day\", \"district\"),\n  stringdist.match = c(\"first\", \"middle\", \"last\", \"district\"),\n  numeric.match = c(\"yr\", \"mon\", \"day\"),\n  threshold.match = 0.95)\n\n\n==================== \nfastLink(): Fast Probabilistic Record Linkage\n==================== \n\nIf you set return.all to FALSE, you will not be able to calculate a confusion table as a summary statistic.\nCalculating matches for each variable.\nGetting counts for parameter estimation.\n    Parallelizing calculation using OpenMP. 1 threads out of 8 are used.\nRunning the EM algorithm.\nGetting the indices of estimated matches.\n    Parallelizing calculation using OpenMP. 1 threads out of 8 are used.\nDeduping the estimated matches.\nGetting the match patterns for each estimated match.\n\n\nXem lại các kết quả khớp\nchúng ta đã định nghĩa đối tượng được trả về từ fastLink() là fl_output. Nó thuộc nhóm list, và nó thực sự chứa một số data frame bên trong nó, mô tả chi tiết kết quả của việc so khớp. Một trong những data frame này là matches, chứa các kết quả khớp có nhiều khả năng nhất giữa cases và results. Bạn có thể truy cập data frame “khớp” này với fl_output$matches. Dưới đây, nó được lưu dưới dạng my_matches để tiện cho việc truy cập sau này.\nKhi my_matches được in, bạn sẽ thấy hai vectơ cột: các cặp số/chỉ số hàng (còn được gọi là “tên hàng (rownames)”) trong cases (“inds.a”) và trong results (“inds.b”) đại diện cho các kết quả khớp phù hợp nhất. Nếu số hàng từ data frame bị thiếu, có nghĩa là không tìm thấy kết quả khớp nào trong data frame khác ở ngưỡng đối sánh đã chỉ định.\n\n# print matches\nmy_matches &lt;- fl_output$matches\nmy_matches\n\n  inds.a inds.b\n1      1      1\n2      2      2\n3      3      3\n4      4      4\n5      8      8\n6      7      9\n7      6     10\n8      5     12\n\n\nNhững điều cần lưu ý:\n\nCác kết quả trùng khớp đã xảy ra mặc dù có sự khác biệt nhỏ về cách viết tên cũng như ngày sinh:\n\n“Tony B. Smith” khớp với “Anthony B Smith”\n\n“Maria Rodriguez” khớp với “Marialisa Rodrigues”\n\n“Betty Chase” khớp với “Elizabeth Chase”\n\n“Olivier Laurent De Bordeaux” khớp với “Oliver Laurent De Bordow” (ngày sinh missing bị bỏ qua)\n\n\nMột hàng trong cases (đối với “Blessing Adebayo”, hàng 9) không có kết quả khớp tốt trong results, vì vậy nó không tồn tại my_matches.\n\nNối dựa trên việc khớp theo xác suất\nĐể sử dụng các kết quả khớp này nhằm nối results vào cases, chiến lược là:\n\nSử dụng left_join() để nối my_matches vào cases (khớp tên hàng (rowname) trong cases với “inds.a” trong my_matches)\n\nSau đó sử dụng left_join() khác để nối results vào cases (khớp với “inds.b” mới có được trong cases với rowname trong results)\n\nTrước khi nối, chúng ta nên làm sạch ba data frame:\n\nCả dfA và dfB nên có số hàng của chúng (“rowname”) được chuyển đổi thành một cột thích hợp.\n\nCả hai cột trong my_matches đều được chuyển đổi thành nhóm ký tự, vì vậy chúng có thể được nối với ký tự rownames\n\n\n# Clean data prior to joining\n#############################\n\n# convert cases rownames to a column \ncases_clean &lt;- cases %&gt;% rownames_to_column()\n\n# convert test_results rownames to a column\nresults_clean &lt;- results %&gt;% rownames_to_column()  \n\n# convert all columns in matches dataset to character, so they can be joined to the rownames\nmatches_clean &lt;- my_matches %&gt;%\n  mutate(across(everything(), as.character))\n\n\n\n# Join matches to dfA, then add dfB\n###################################\n# column \"inds.b\" is added to dfA\ncomplete &lt;- left_join(cases_clean, matches_clean, by = c(\"rowname\" = \"inds.a\"))\n\n# column(s) from dfB are added \ncomplete &lt;- left_join(complete, results_clean, by = c(\"inds.b\" = \"rowname\"))\n\nNhư được trình bày bằng cách sử dụng code trên, data frame kết quả complete sẽ chứa tất cả các cột từ cả cases và results. Nhiều cột sẽ được thêm vào bằng các hậu tố “.x” và “.y”, vì nếu không, tên cột sẽ bị trùng lặp.\n\n\n\n\n\n\nNgoài ra, để chỉ lấy 9 bản ghi “gốc” trong cases với (các) cột mới từ results, hãy sử dụng select() trên results trước khi nối, để nó chỉ chứa rownames và cột mà bạn muốn thêm vào cases (ví dụ: cột result).\n\ncases_clean &lt;- cases %&gt;% rownames_to_column()\n\nresults_clean &lt;- results %&gt;%\n  rownames_to_column() %&gt;% \n  select(rowname, result)    # select only certain columns \n\nmatches_clean &lt;- my_matches %&gt;%\n  mutate(across(everything(), as.character))\n\n# joins\ncomplete &lt;- left_join(cases_clean, matches_clean, by = c(\"rowname\" = \"inds.a\"))\ncomplete &lt;- left_join(complete, results_clean, by = c(\"inds.b\" = \"rowname\"))\n\n\n\n\n\n\n\nNếu bạn chỉ muốn lấy một trong hai bộ dữ liệu cho các hàng khớp, bạn có thể sử dụng code bên dưới:\n\ncases_matched &lt;- cases[my_matches$inds.a,]  # Rows in cases that matched to a row in results\nresults_matched &lt;- results[my_matches$inds.b,]  # Rows in results that matched to a row in cases\n\nHoặc, để chỉ xem các hàng không khớp::\n\ncases_not_matched &lt;- cases[!rownames(cases) %in% my_matches$inds.a,]  # Rows in cases that did NOT match to a row in results\nresults_not_matched &lt;- results[!rownames(results) %in% my_matches$inds.b,]  # Rows in results that did NOT match to a row in cases\n\n\n\nLoại bỏ trùng lặp theo xác suất\nKhớp theo xác suất cũng có thể được sử dụng để loại bỏ trùng lặp trong một bộ dữ liệu. Xem chương về Loại bỏ trùng lặp để biết các phương pháp loại bỏ trùng lặp khác.\nỞ đây chúng ta đã bắt đầu với bộ dữ liệu cases, nhưng bây giờ đang được gọi là cases_dup, vì nó có 2 hàng bổ sung mà có thể là bản trùng lặp của các hàng trước đó: Xem “Tony” với “Anthony”, và “Marialisa Rodrigues” với “Maria Rodriguez”.\n\n\n\n\n\n\nChạy fastLink() giống nhu trước, nhưng so sánh data frame cases_dup với chính nó. Khai hai data frames được cung cấp giống hệt nhau, hàm sẽ giả định rằng bạn muốn loại bỏ trùng lặp. Lưu ý rằng chúng ta không chỉ định stringdist.match = hoặc numeric.match = như chúng ta đã làm trước đây.\n\n## Run fastLink on the same dataset\ndedupe_output &lt;- fastLink(\n  dfA = cases_dup,\n  dfB = cases_dup,\n  varnames = c(\"gender\", \"first\", \"middle\", \"last\", \"yr\", \"mon\", \"day\", \"district\")\n)\n\n\n==================== \nfastLink(): Fast Probabilistic Record Linkage\n==================== \n\nIf you set return.all to FALSE, you will not be able to calculate a confusion table as a summary statistic.\ndfA and dfB are identical, assuming deduplication of a single data set.\nSetting return.all to FALSE.\n\nCalculating matches for each variable.\nGetting counts for parameter estimation.\n    Parallelizing calculation using OpenMP. 1 threads out of 8 are used.\nRunning the EM algorithm.\nGetting the indices of estimated matches.\n    Parallelizing calculation using OpenMP. 1 threads out of 8 are used.\nCalculating the posterior for each pair of matched observations.\nGetting the match patterns for each estimated match.\n\n\nBây giờ, bạn có thể xem xét các bản trùng lặp có thể xảy ra với getMatches(). Cung cấp data frame dưới dạng cả dfA = và dfB =, đồng thời cung cấp kết quả đầu ra của hàm fastLink() là fl.out =. fl.out = phải thuộc nhóm fastLink.dedupe, hay nói cách khác, là kết quả của fastLink().\n\n## Run getMatches()\ncases_dedupe &lt;- getMatches(\n  dfA = cases_dup,\n  dfB = cases_dup,\n  fl.out = dedupe_output)\n\nXem cột ngoài cùng bên phải, cột cho biết ID trùng lặp - hai hàng cuối cùng được xác định có thể là trùng lặp ở hàng 2 và 3.\n\n\n\n\n\n\nĐể trả về số hàng của những hàng có khả năng trùng lặp, bạn có thể đếm số hàng trên mỗi giá trị duy nhất trong cột dedupe.ids, sau đó lọc để chỉ giữ lại những hàng có nhiều hơn một hàng. Trong trường hợp này, nó để lại hàng 2 và 3.\n\ncases_dedupe %&gt;% \n  count(dedupe.ids) %&gt;% \n  filter(n &gt; 1)\n\n  dedupe.ids n\n1          2 2\n2          3 2\n\n\nĐể kiểm tra toàn bộ các hàng có khả năng trùng lặp, hãy đặt số hàng trong lệnh này:\n\n# displays row 2 and all likely duplicates of it\ncases_dedupe[cases_dedupe$dedupe.ids == 2,]   \n\n   gender   first middle  last   yr mon day district dedupe.ids\n2       M Anthony     B. Smith 1970   9  19    River          2\n10      M    Tony     B. Smith 1970   9  19    River          2",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Nối dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.vn.html#gắn-vào-và-căn-chỉnh",
    "href": "new_pages/joining_matching.vn.html#gắn-vào-và-căn-chỉnh",
    "title": "14  Nối dữ liệu",
    "section": "14.4 Gắn vào và căn chỉnh",
    "text": "14.4 Gắn vào và căn chỉnh\nMột phương pháp khác để kết hợp hai data frame là “ràng buộc” chúng với nhau. Bạn cũng có thể coi đây là hàng hoặc cột được “gắn vào” hoặc “thêm”.\nPhần này cũng sẽ thảo luận về cách “căn chỉnh” thứ tự các hàng của một data frame với thứ tự các hàng trong data frame khác. Chủ đề này được thảo luận dưới đây trong phần về Gắn các cột.\n\nGắn các hàng\nĐể gắn các hàng của một data frame này với phần cuối của một data frame khác, hãy sử dụng bind_rows() từ dplyr. Hàm này có tính dung nạp, vì vậy bất kỳ cột nào có trong một trong hai data frame sẽ được đưa vào kết quả đầu ra. Một số lưu ý:\n\nKhông giống như row.bind() của phiên bản base R, bind_rows() của dplyr không yêu cầu thứ tự của các cột phải giống nhau trong cả hai data frame. Miễn là các tên cột được viết giống nhau, nó sẽ căn chỉnh chúng một cách chính xác.\n\nBạn có thể tùy chọn xác định đối số .id =. Cung cấp một tên cột ký tự. Điều này sẽ tạo ra một cột mới dùng để xác định mỗi hàng ban đầu đến từ data frame nào.\n\nBạn có thể sử dụngbind_rows() trên một list các data frame có cấu trúc tương tự để kết hợp chúng thành một. Xem ví dụ trong chương Lặp, vòng lặp và danh sách về việc nhập nhiều linelist với purrr.\n\nMột ví dụ phổ biến về row binding là gắn một hàng “tổng (total)” vào một bảng mô tả được tạo bằng hàm summarise() của dplyr. Dưới đây, chúng ta tạo một bảng đếm số trường hợp và giá trị CT trung bình theo bệnh viện với một hàng tổng.\nHàm summarise() được sử dụng trên dữ liệu đã nhóm theo bệnh viện để trả về một data frame tóm tắt theo bệnh viện. Nhưng hàm summarise() không tự động tạo ra hàng “tổng”, vì vậy chúng ta tạo ra nó bằng cách tổng hợp lại dữ liệu, nhưng với dữ liệu không bị nhóm theo bệnh viện. Điều này tạo ra một data frame thứ hai chỉ gồm một hàng. Sau đó, chúng ta có thể liên kết các data frame này với nhau để có được bảng cuối cùng.\nXem các ví dụ hoạt động khác tương tự như thế này trong chương Bảng mô tả và Trình bày bảng.\n\n# Create core table\n###################\nhosp_summary &lt;- linelist %&gt;% \n  group_by(hospital) %&gt;%                        # Group data by hospital\n  summarise(                                    # Create new summary columns of indicators of interest\n    cases = n(),                                  # Number of rows per hospital-outcome group     \n    ct_value_med = median(ct_blood, na.rm=T))     # median CT value per group\n\nĐây là data frame hosp_summary:\n\n\n\n\n\n\nTạo một data frame với thống kê “tổng” (không bị nhóm theo bệnh viện). Điều này sẽ trả về chỉ một hàng.\n\n# create totals\n###############\ntotals &lt;- linelist %&gt;% \n  summarise(\n    cases = n(),                               # Number of rows for whole dataset     \n    ct_value_med = median(ct_blood, na.rm=T))  # Median CT for whole dataset\n\nVà dưới đây là data frame totals. Lưu ý cách mà chỉ tạo ra hai cột. Những cột này cũng nằm trong hosp_summary, nhưng có một cột trong hosp_summary mà không nằm trong totals (hospital).\n\n\n\n\n\n\nBây giờ chúng ta có thể gắn các hàng với nhau bằng bind_rows().\n\n# Bind data frames together\ncombined &lt;- bind_rows(hosp_summary, totals)\n\nBây giờ chúng ta có thể xem kết quả. Xem cách mà trong hàng cuối cùng, giá trị NA trống được điền vào cột trong hospital mà không có trong hosp_summary. Như đã giải thích trong chương Trình bày bảng, bạn có thể “điền” vào ô này với “Tổng” bằng cách sử dụng replace_na().\n\n\n\n\n\n\n\n\nGắn các cột\nCó một hàm dplyr tuơng tự là bind_cols(), hàm mà bạn có thể sử dụng để kết hợp hai data frame theo chiều ngang. Lưu ý rằng các hàng được khớp với nhau theo vị trí (khác với phép nối ở trên) - ví dụ: hàng thứ 12 trong mỗi data frame sẽ được căn chỉnh.\nVí dụ, chúng ta liên kết một số bảng tóm tắt với nhau. Để làm điều này, chúng ta cũng trình bày cách sắp xếp lại thứ tự của các hàng trong một data frame để khớp với thứ tự hàng trong một data frame khác, với match().\nỞ đây chúng ta định nghĩa case_info là một data frame tóm tắt về các trường hợp trong linelist theo bệnh viện, với số trường hợp và số ca tử vong.\n\n# Case information\ncase_info &lt;- linelist %&gt;% \n  group_by(hospital) %&gt;% \n  summarise(\n    cases = n(),\n    deaths = sum(outcome == \"Death\", na.rm=T)\n  )\n\n\n\n\n\n\n\nVà giả sử rằng đây là một data frame contact_fu khác chứa thông tin về phần trăm số liên hệ bị phơi nhiễm được điều tra và “theo dõi”, lại một lần nữa bởi bệnh viện.\n\ncontact_fu &lt;- data.frame(\n  hospital = c(\"St. Mark's Maternity Hospital (SMMH)\", \"Military Hospital\", \"Missing\", \"Central Hospital\", \"Port Hospital\", \"Other\"),\n  investigated = c(\"80%\", \"82%\", NA, \"78%\", \"64%\", \"55%\"),\n  per_fu = c(\"60%\", \"25%\", NA, \"20%\", \"75%\", \"80%\")\n)\n\n\n\n\n\n\n\nLưu ý rằng các bệnh viện đều như nhau, nhưng theo thứ tự khác nhau trong mỗi data frame. Giải pháp đơn giản nhất là sử dụng left_join() trên cột hospital, nhưng bạn cũng có thể sử dụng bind_cols() với một bước bổ sung.\n\nSử dụng match() để sắp xếp thứ tự\nDo thứ tự hàng khác nhau, một lệnh bind_cols() đơn giản sẽ dẫn đến khớp sai dữ liệu. Để khắc phục điều này, chúng ta có thể sử dụng hàm match() trong base R để căn chỉnh các hàng của data frame theo thứ tự giống với thứ tự trong data frame khác. Chúng ta giả định đối với phương pháp này rằng không có giá trị trùng lặp nào trong cả hai data frame.\nKhi chúng ta sử dụng match(), với cú pháp là match(TARGET ORDER VECTOR, DATA FRAME COLUMN TO CHANGE), trong đó đối số đầu tiên là thứ tự mong muốn (hoặc là một vectơ độc lập, hoặc trong trường hợp này là một cột trong data frame), và đối số thứ hai là cột data frame trong data frame mà sẽ được sắp xếp lại. Kết quả đầu ra của match() sẽ là một vectơ số đại diện cho thứ tự vị trí chính xác. Bạn có thể đọc thêm với ?match.\n\nmatch(case_info$hospital, contact_fu$hospital)\n\n[1] 4 2 3 6 5 1\n\n\nBạn có thể sử dụng vectơ số này để sắp xếp lại thứ tự data frame - đặt nó trong tập con của dấu ngoặc [ ] trước dấu phẩy. Đọc thêm về cú pháp tập con của dấu ngoặc base R trong chương R cơ bản. Lệnh bên dưới tạo ra một data frame mới, được định nghĩa là data frame cũ mà trong đó các hàng được sắp xếp theo thứ tự trong vectơ số ở trên.\n\ncontact_fu_aligned &lt;- contact_fu[match(case_info$hospital, contact_fu$hospital),]\n\n\n\n\n\n\n\nBây giờ chúng ta có thể gắn các cột data frame với nhau, với thứ tự hàng chính xác. Lưu ý rằng một số cột bị trùng lặp và sẽ yêu cầu làm sạch bằng rename(). Đọc thêm về bind_rows() tại đây.\n\nbind_cols(case_info, contact_fu)\n\nNew names:\n• `hospital` -&gt; `hospital...1`\n• `hospital` -&gt; `hospital...4`\n\n\n# A tibble: 6 × 6\n  hospital...1                     cases deaths hospital...4 investigated per_fu\n  &lt;chr&gt;                            &lt;int&gt;  &lt;int&gt; &lt;chr&gt;        &lt;chr&gt;        &lt;chr&gt; \n1 Central Hospital                   454    193 St. Mark's … 80%          60%   \n2 Military Hospital                  896    399 Military Ho… 82%          25%   \n3 Missing                           1469    611 Missing      &lt;NA&gt;         &lt;NA&gt;  \n4 Other                              885    395 Central Hos… 78%          20%   \n5 Port Hospital                     1762    785 Port Hospit… 64%          75%   \n6 St. Mark's Maternity Hospital (…   422    199 Other        55%          80%   \n\n\nMột hàm trong base R thay thế cho bind_cols là cbind(), hàm này hoạt động tương tự với bind_cols.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Nối dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.vn.html#tài-nguyên-học-liệu",
    "href": "new_pages/joining_matching.vn.html#tài-nguyên-học-liệu",
    "title": "14  Nối dữ liệu",
    "section": "14.5 Tài nguyên học liệu",
    "text": "14.5 Tài nguyên học liệu\ntidyverse page on joins\nR for Data Science page on relational data\ntidyverse page on dplyr về ràng buộc dữ liệu\nĐặc trưng của fastLink tại trang Github package\nXuất bản mô tả phương pháp luận của fastLink\nXuất bản mô tả package RecordLinkage",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Nối dữ liệu</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.vn.html",
    "href": "new_pages/deduplication.vn.html",
    "title": "15  Loại bỏ trùng lặp",
    "section": "",
    "text": "15.1 Chuẩn bị",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Loại bỏ trùng lặp</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.vn.html#chuẩn-bị",
    "href": "new_pages/deduplication.vn.html#chuẩn-bị",
    "title": "15  Loại bỏ trùng lặp",
    "section": "",
    "text": "Gọi package\nĐoạn code này hiển thị những package cần tải cho các phân tích. Trong sổ tay này, chúng tôi nhấn mạnh đến hàm p_load() từ pacman, hàm sẽ cài đặt package nếu cần và gọi nó ra để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với library() từ base R. Xem chương R cơ bản để có thêm thông tin về các R package.\n\npacman::p_load(\n  tidyverse,   # deduplication, grouping, and slicing functions\n  janitor,     # function for reviewing duplicates\n  stringr)      # for string searches, can be used in \"rolling-up\" values\n\n\n\nNhập dữ liệu\nĐể minh họa, chúng tôi sẽ sử dụng một bộ dữ liệu mẫu được tạo bằng code R bên dưới.\nDữ liệu là các bản ghi về những cuộc gọi truy vết COVID-19, bao gồm những cuộc gọi truy vết với các liên hệ và với các trường hợp. Các cột bao gồm recordID (mã bản ghi) (do máy tính tạo), personID (mã người truy vết), name (tên), date (ngày) truy vết, time (thời gian) truy vết, purpose (mục đích) truy vết (phỏng vấn một trường hợp hoặc một liên hệ) và symptoms_ever (liệu người được truy vết đã từng được báo cáo có triệu chứng hay không).\nĐây là code để tạo bộ dữ liệu obs:\n\nobs &lt;- data.frame(\n  recordID  = c(1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18),\n  personID  = c(1,1,2,2,3,2,4,5,6,7,2,1,3,3,4,5,5,7,8),\n  name      = c(\"adam\", \"adam\", \"amrish\", \"amrish\", \"mariah\", \"amrish\", \"nikhil\", \"brian\", \"smita\", \"raquel\", \"amrish\",\n                \"adam\", \"mariah\", \"mariah\", \"nikhil\", \"brian\", \"brian\", \"raquel\", \"natalie\"),\n  date      = c(\"1/1/2020\", \"1/1/2020\", \"2/1/2020\", \"2/1/2020\", \"5/1/2020\", \"5/1/2020\", \"5/1/2020\", \"5/1/2020\", \"5/1/2020\",\"5/1/2020\", \"2/1/2020\",\n                \"5/1/2020\", \"6/1/2020\", \"6/1/2020\", \"6/1/2020\", \"6/1/2020\", \"7/1/2020\", \"7/1/2020\", \"7/1/2020\"),\n  time      = c(\"09:00\", \"09:00\", \"14:20\", \"14:20\", \"12:00\", \"16:10\", \"13:01\", \"15:20\", \"14:20\", \"12:30\", \"10:24\",\n                \"09:40\", \"07:25\", \"08:32\", \"15:36\", \"15:31\", \"07:59\", \"11:13\", \"17:12\"),\n  encounter = c(1,1,1,1,1,3,1,1,1,1,2,\n                2,2,3,2,2,3,2,1),\n  purpose   = c(\"contact\", \"contact\", \"contact\", \"contact\", \"case\", \"case\", \"contact\", \"contact\", \"contact\", \"contact\", \"contact\",\n                \"case\", \"contact\", \"contact\", \"contact\", \"contact\", \"case\", \"contact\", \"case\"),\n  symptoms_ever = c(NA, NA, \"No\", \"No\", \"No\", \"Yes\", \"Yes\", \"No\", \"Yes\", NA, \"Yes\",\n                    \"No\", \"No\", \"No\", \"Yes\", \"Yes\", \"No\",\"No\", \"No\")) %&gt;% \n  mutate(date = as.Date(date, format = \"%d/%m/%Y\"))\n\n\nĐây là data frame\nSử dụng bộ lọc của các box ở trên cùng để xem lại các cuộc gọi truy vết theo từng người.\n\n\n\n\n\n\nMột số điều cần lưu ý khi bạn xem xét dữ liệu:\n\nHai bản ghi đầu tiên hoàn toàn 100% là trùng lặp, bao gồm cả recordID (hẳn là một lỗi máy tính!)\n\nHai hàng thứ hai trùng lặp trong tất cả các cột ngoại trừ recordID\n\nMột vài cá nhân có nhiều cuộc gọi truy vết, vào những ngày, giờ khác nhau, được tính là những liên hệ và/hoặc những trường hợp\n\nỞ mỗi cuộc gọi truy vết, người được truy vết được hỏi đã từng mắc các triệu chứng chưa và một số thông tin này bị missing.\n\nVà đây là bản tóm tắt nhanh về những người truy vết và mục đích các cuộc gọi truy vết của họ, sử dụng hàm tabyl() từ janitor:\n\nobs %&gt;% \n  tabyl(name, purpose)\n\n    name case contact\n    adam    1       2\n  amrish    1       3\n   brian    1       2\n  mariah    1       2\n natalie    1       0\n  nikhil    0       2\n  raquel    0       2\n   smita    0       1",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Loại bỏ trùng lặp</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.vn.html#loại-bỏ-trùng-lặp",
    "href": "new_pages/deduplication.vn.html#loại-bỏ-trùng-lặp",
    "title": "15  Loại bỏ trùng lặp",
    "section": "15.2 Loại bỏ trùng lặp",
    "text": "15.2 Loại bỏ trùng lặp\nPhần này mô tả cách xem xét và loại bỏ các hàng trùng lặp trong data frame. Đồng thời cũng chỉ ra cách xử lý các phần tử trùng lặp trong một vectơ.\n\n\nKiểm tra hàng trùng lặp\nĐể nhanh chóng xem lại các hàng có trùng lặp, bạn có thể sử dụng get_dupes() từ package janitor. Theo mặc định, tất cả các cột được xem xét khi đánh giá trùng lặp - các hàng được hàm trả về là trùng lặp 100% nếu xét đến các giá trị trong tất cả các cột.\nTrong data frame obs, hai hàng đầu tiên trùng lặp 100% - chúng có cùng giá trị trong tất cả các cột (bao gồm cả cột recordID, vốn được cho là duy nhất - hẳn là một số trục trặc máy tính). Data frame được trả về tự động bao gồm một cột mới dupe_count ở phía bên phải, hiển thị số hàng có sự kết hợp của các giá trị trùng lặp đó.\n\n# 100% duplicates across all columns\nobs %&gt;% \n  janitor::get_dupes()\n\n\n\n\n\n\n\nXem dữ liệu gốc\nTuy nhiên, nếu chúng ta chọn bỏ qua recordID, thì hàng thứ 3 và thứ 4 cũng là bản trùng lặp của nhau. Nghĩa là chúng có cùng giá trị trong tất cả các cột ngoại trừ recordID. Bạn có thể xác định các cột cụ thể bị bỏ qua trong hàm bằng ký hiệu - (dấu trừ).\n\n# Duplicates when column recordID is not considered\nobs %&gt;% \n  janitor::get_dupes(-recordID)         # if multiple columns, wrap them in c()\n\n\n\n\n\n\n\nBạn cũng có thể xác định rõ các cột cần xem xét. Dưới đây, chỉ các hàng có cùng giá trị trong cột name và purpose được trả về. Lưu ý rằng “amrish” hiện có dupe_count bằng 3 cho thấy ba cuộc gọi truy vết “liên hệ” của anh ta.\nCuộn sang trái để xem thêm hàng\n\n# duplicates based on name and purpose columns ONLY\nobs %&gt;% \n  janitor::get_dupes(name, purpose)\n\n\n\n\n\n\n\nXem dữ liệu gốc.\nXem ?get_dupes để biết thêm chi tiết hoặc xem tài liệu tham khảo trực tuyến này\n\n\n\nChỉ giữ lại các hàng duy nhất\nĐể chỉ giữ lại các hàng duy nhất của một data frame, hãy sử dụng distinct() từ dplyr (đã được giải thích trong chương Làm sạch số liệu và các hàm quan trọng). Các hàng trùng lặp sẽ bị loại bỏ sao cho chỉ giữ lại hàng đầu tiên trong số các hàng đó. Theo mặc định, hàng “đầu tiên” có nghĩa là hàng có rownumber cao nhất (thứ tự của các hàng từ trên-xuống-dưới). Chỉ các hàng duy nhất được giữ lại.\nTrong ví dụ dưới đây, chúng tôi chạy lệnh distinct() sao cho cột recordID bị loại trừ khỏi việc xem xét - do đó hai hàng trùng lặp sẽ bị loại bỏ. Hàng đầu tiên (đối với “adam”) bị trùng lặp 100% và đã bị loại bỏ. Bên cạnh đó, hàng 3 (cho “amrish”) là một bản bị trùng lặp trong tất cả các cột ngoại trừ recordID (đang không được xét) và do đó cũng bị loại bỏ. Bộ dữ liệu obs bây giờ có số dòng là nrow(obs)-2, không phải là nrow(obs)).\nCuộn sang trái để xem toàn bộ data frame\n\n# added to a chain of pipes (e.g. data cleaning)\nobs %&gt;% \n  distinct(across(-recordID), # reduces data frame to only unique rows (keeps first one of any duplicates)\n           .keep_all = TRUE) \n\n# if outside pipes, include the data as first argument \n# distinct(obs)\n\n\n\n\n\n\n\nCHÚ Ý: Nếu sử dụng distinct() trên nhóm dữ liệu, hàm sẽ áp dụng cho từng nhóm.\nLoại bỏ trùng lặp dựa trên cột cụ thể\nBạn cũng có thể xác định các cột cơ sở để loại bỏ trùng lặp. Theo cách này, loại bỏ trùng lặp chỉ áp dụng cho các hàng trùng lặp trong các cột được chỉ định. Trừ khi bạn đặt .keep_all = TRUE, tất cả các cột không được đề cập sẽ bị loại bỏ.\nTrong ví dụ dưới đây, loại bỏ trùng lặp chỉ áp dụng cho các hàng có giá trị giống nhau trong các cột name và purpose. Do đó, “brian” chỉ có 2 hàng thay vì 3 - cuộc gọi truy vết “liên hệ” đầu tiên và cuộc gọi truy vết “trường hợp” duy nhất của anh ta. Để điều chỉnh sao cho cuộc gọi truy vết mới nhất của brian đối với từng mục đích được lưu giữ, hãy xem mục Cắt theo nhóm.\nCuộn sang trái để xem toàn bộ data frame\n\n# added to a chain of pipes (e.g. data cleaning)\nobs %&gt;% \n  distinct(name, purpose, .keep_all = TRUE) %&gt;%  # keep rows unique by name and purpose, retain all columns\n  arrange(name)                                  # arrange for easier viewing\n\n\n\n\n\n\n\nXem dữ liệu gốc.\n\n\n\nLoại bỏ phần tử trùng lặp trong một vectơ\nHàm duplicated() từ base R sẽ đánh giá một vectơ (cột) và trả về một vectơ logic có cùng độ dài (TRUE/FALSE). Lần đầu tiên một giá trị xuất hiện, nó sẽ trả về giá trị FALSE (không phải là một bản trùng lặp) và những lần tiếp theo giá trị đó xuất hiện, nó sẽ trả về giá trị TRUE. Lưu ý giá trị NA được xử lý giống như bất kỳ giá trị nào khác.\n\nx &lt;- c(1, 1, 2, NA, NA, 4, 5, 4, 4, 1, 2)\nduplicated(x)\n\n [1] FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n\n\nĐể chỉ trả về các phần tử bị trùng lặp, bạn có thể sử dụng dấu ngoặc để đặt vectơ gốc:\n\nx[duplicated(x)]\n\n[1]  1 NA  4  4  1  2\n\n\nĐể chỉ trả về các phần tử duy nhất, hãy sử dụng hàm unique() từ base R. Để loại bỏ các NA khỏi kết quả đầu ra, hãy lồng na.omit() trong unique().\n\nunique(x)           # alternatively, use x[!duplicated(x)]\n\n[1]  1  2 NA  4  5\n\nunique(na.omit(x))  # remove NAs \n\n[1] 1 2 4 5\n\n\n\n\n\nSử dụng base R\nĐể trả về các hàng trùng lặp\nTrong base R, bạn cũng có thể xem những hàng nào là trùng lặp 100% trong data frame df bằng lệnh duplicated(df) (trả về một vectơ logic của các hàng).\nDo đó, bạn cũng có thể sử dụng tập con cơ sở [ ] trên data frame để xem các hàng trùng lặp với df[duplicated(df),] (đừng quên dấu phẩy, điều đó có nghĩa là bạn muốn xem tất cả các cột!).\nĐể trả về các hàng duy nhất\nXem các ghi chú ở trên. Để xem các hàng duy nhất, bạn thêm dấu phủ định logic ! ở trước hàm duplicated():\ndf[!duplicated(df),]\nĐể trả về các hàng trùng lặp chỉ với một số cột nhất định\nĐặt df nằm trong dấu ngoặc đơn hàm duplicated(), hàm này sẽ chỉ hoạt động trên một số cột nhất định của df.\nĐể xác định các cột, hãy cung cấp số thứ tự hoặc tên cột sau dấu phẩy (nhớ rằng đặt tất cả những thông tin này trong hàm duplicated()).\nHãy chắc chắn đặt dấu phẩy , bên ngoài và sau hàm duplicated()!\nVí dụ: Để chỉ đánh giá các cột từ 2 đến 5 cho các bản trùng lặp: df[!duplicated(df[, 2:5]),]\nĐể chỉ đánh giá các cột name và purpose cho các bản trùng lặp: df[!duplicated(df[, c(\"name\", \"purpose)]),]",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Loại bỏ trùng lặp</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.vn.html#cắt-dòng",
    "href": "new_pages/deduplication.vn.html#cắt-dòng",
    "title": "15  Loại bỏ trùng lặp",
    "section": "15.3 Cắt dòng",
    "text": "15.3 Cắt dòng\n“Cắt” một data frame nhằm áp dụng bộ lọc trên các hàng theo số/vị trí hàng. Điều này trở nên đặc biệt hữu ích nếu bạn có nhiều hàng cho mỗi nhóm chức năng (ví dụ: mỗi “người”) và bạn chỉ muốn giữ một hoặc một số hàng trong số đó.\nHàm slice() cơ bản chấp nhận các số và trả về các hàng ở những vị trí đó. Nếu các số được cung cấp là số dương, chỉ có chúng được trả về. Nếu là số âm, những hàng đó không được trả về. Tất cả các số đều phải là số dương hoặc đều là số âm.\n\nobs %&gt;% slice(4)  # return the 4th row\n\n  recordID personID   name       date  time encounter purpose symptoms_ever\n1        3        2 amrish 2020-01-02 14:20         1 contact            No\n\n\n\nobs %&gt;% slice(c(2,4))  # return rows 2 and 4\n\n  recordID personID   name       date  time encounter purpose symptoms_ever\n1        1        1   adam 2020-01-01 09:00         1 contact          &lt;NA&gt;\n2        3        2 amrish 2020-01-02 14:20         1 contact            No\n\n#obs %&gt;% slice(c(2:4))  # return rows 2 through 4\n\nXem dữ liệu gốc.\nCó một số biến thể: Chúng phải được cung cấp với một cột và một số hàng để trả về (tới n =).\n\nslice_min() và slice_max() chỉ giữ (các) hàng có (các) giá trị nhỏ nhất hoặc lớn nhất của cột được chỉ định. Hàm này cũng hoạt động để trả về “tối thiểu” và “tối đa” của các biến factor có thứ tự.\n\nslice_head() và slice_tail() - chỉ giữ (các) hàng đầu tiên hoặc cuối cùng.\n\nslice_sample() - chỉ giữ một mẫu ngẫu nhiên của các hàng.\n\n\nobs %&gt;% slice_max(encounter, n = 1)  # return rows with the largest encounter number\n\n  recordID personID   name       date  time encounter purpose symptoms_ever\n1        5        2 amrish 2020-01-05 16:10         3    case           Yes\n2       13        3 mariah 2020-01-06 08:32         3 contact            No\n3       16        5  brian 2020-01-07 07:59         3    case            No\n\n\nSử dụng đối số n = hoặc prop = để xác định số lượng hoặc tỷ lệ hàng cần giữ. Nếu không sử dụng hàm trong chuỗi pipe, trước tiên hãy cung cấp đối số dữ liệu (ví dụ: slice(data, n = 2)). Xem ?slice để biết thêm thông tin.\nCác đối số khác:\n.order_by = được sử dụng trong slice_min() và slice_max(), sắp xếp thứ tự theo một cột trước khi cắt.\nwith_ties = TRUE theo mặc định, nghĩa là các ràng buộc bị giữ lại.\n.preserve = FALSE theo mặc định. Nếu TRUE thì cấu trúc nhóm được tính toán lại sau khi cắt.\nweight_by = Tùy chọn, cột dữ liệu kiểu số được tính theo trọng số (số lớn hơn có nhiều khả năng được lấy mẫu hơn). Đồng thời replace = cho việc lấy mẫu liệu có được thực hiện mà có/không có sự thay thế.\nMẸO: Khi sử dụng slice_max() và slice_min(), hãy chắc chắn bạn cụ thể/ghi n = (ví dụ: n = 2, không chỉ 2). Nếu không, bạn có thể gặp lỗi Error:…is not empty.\nLƯU Ý: Bạn có thể gặp hàm top_n(), hàm mà đã bị thay thế bởi các hàm slice.\n\n\nCắt theo nhóm\nCác hàm slice_*() có thể rất hữu ích nếu được áp dụng cho một data frame được nhóm lại vì thao tác cắt được thực hiện trên từng nhóm riêng biệt. Sử dụng hàm group_by() kết hợp với slice() nhằm nhóm dữ liệu để lấy một lát cắt từ mỗi nhóm.\nĐiều này rất hữu ích cho việc loại bỏ trùng lặp nếu bạn có nhiều hàng cho mỗi người nhưng chỉ muốn giữ một trong số chúng. Trước tiên, bạn sử dụng group_by() với các cột chính mà giống nhau cho mỗi người, sau đó sử dụng một hàm slice trên một cột, điều này sẽ khác nhau giữa các hàng được nhóm.\nTrong ví dụ dưới đây, để chỉ giữ lại cuộc gọi truy vết mới nhất theo mỗi người, chúng ta nhóm các hàng theo cột name và sau đó sử dụng slice_max() với n = 1 trên cột date. Hãy lưu ý! Để áp dụng một hàm như slice_max() vào dates (ngày tháng), cột ngày tháng phải thuộc nhóm Date.\nTheo mặc định, “các ràng buộc” (ví dụ: cùng ngày trong trường hợp này) được giữ lại và chúng tôi sẽ vẫn nhận được nhiều hàng cho một số người (ví dụ: adam). Để tránh tình huống này, chúng tôi đặt with_ties = FALSE. Chúng tôi sẽ chỉ nhận lại một hàng cho mỗi người.\nCHÚ Ý: Nếu sử dụng arrange(), xác định .by_group = TRUE để sắp xếp dữ liệu trong mỗi nhóm.\nTHẬN TRỌNG: Nếu with_ties = FALSE, hàng đầu tiên có ràng buộc được giữ lại. Điều này có thể là sự nhầm lẫn. Hãy xem trường hợp của Mariah, cô ấy có hai cuộc gọi truy vết vào ngày gần nhất (ngày 06/01) và cuộc gọi truy vết đầu tiên (sớm nhất) được giữ lại. Rất có thể, chúng ta muốn giữ lại cuộc gọi truy vết muộn hơn của cô ấy vào ngày đó. Xem cách “phá vỡ” những ràng buộc này trong ví dụ tiếp theo.\n\nobs %&gt;% \n  group_by(name) %&gt;%       # group the rows by 'name'\n  slice_max(date,          # keep row per group with maximum date value \n            n = 1,         # keep only the single highest row \n            with_ties = F) # if there's a tie (of date), take the first row\n\n\n\n\n\n\n\nVí dụ ở trên, chúng ta có thể thấy rằng chỉ hàng của Amrish vào ngày 05/01 được giữ lại và chỉ hàng của Brian vào ngày 07/01 được giữ lại. Xem dữ lịệu gốc.\nPhá vỡ “ràng buộc”\nNhiều câu lệnh cắt (slice) có thể được chạy để “phá vỡ các ràng buộc”. Trong trường hợp này, nếu một người có nhiều cuộc gọi truy vết vào ngày gần nhất, cuộc gọi truy vết với thời gian gần nhất sẽ được giữ lại (lubridate::hm() được sử dụng để chuyển đổi ký tự thời gian thành một lớp thời gian có thể sắp xếp).\nLưu ý rằng bây giờ, một hàng được giữ cho “Mariah” vào ngày 06/01 là cuộc gọi truy vết thứ 3 từ 08:32, không phải cuộc gọi truy vết thứ 2 lúc 07:25.\n\n# Example of multiple slice statements to \"break ties\"\nobs %&gt;%\n  group_by(name) %&gt;%\n  \n  # FIRST - slice by latest date\n  slice_max(date, n = 1, with_ties = TRUE) %&gt;% \n  \n  # SECOND - if there is a tie, select row with latest time; ties prohibited\n  slice_max(lubridate::hm(time), n = 1, with_ties = FALSE)\n\n\n\n\n\n\n\nTrong ví dụ trên, cũng có thể cắt theo số lần encounter, nhưng chúng tôi đã hiển thị cách cắt theo date và time cho mục đích ví dụ.\nMẸO: Để sử dụng slice_max() hoặc slice_min() trên một cột “kí tự”, hãy biến đối nó thành một lớp yếu tố được sắp xếp theo thứ tự!\nXem dữ liệu gốc.\n\n\n\nGiữ lại tất cả nhưng đánh dấu các dòng\nNếu bạn muốn giữ lại tất cả các bản ghi nhưng chỉ đánh dấu một số để phân tích, hãy cân nhắc cách tiếp cận hai bước sử dụng một số recordID/encounter duy nhất:\n\nGiảm/cắt data frame gốc thành chỉ bao gồm các hàng cho phân tích. Lưu/giữ lại data frame đã được thu gọn này.\n\nTrong data frame gốc, hãy đánh dấu các hàng là thích hợp với case_when(), dựa trên việc liệu mã định danh duy nhất của những bản ghi này (recordID trong ví dụ này) có trong data frame thu gọn hay không.\n\n\n# 1. Define data frame of rows to keep for analysis\nobs_keep &lt;- obs %&gt;%\n  group_by(name) %&gt;%\n  slice_max(encounter, n = 1, with_ties = FALSE) # keep only latest encounter per person\n\n\n# 2. Mark original data frame\nobs_marked &lt;- obs %&gt;%\n\n  # make new dup_record column\n  mutate(dup_record = case_when(\n    \n    # if record is in obs_keep data frame\n    recordID %in% obs_keep$recordID ~ \"For analysis\", \n    \n    # all else marked as \"Ignore\" for analysis purposes\n    TRUE                            ~ \"Ignore\"))\n\n# print\nobs_marked\n\n   recordID personID    name       date  time encounter purpose symptoms_ever\n1         1        1    adam 2020-01-01 09:00         1 contact          &lt;NA&gt;\n2         1        1    adam 2020-01-01 09:00         1 contact          &lt;NA&gt;\n3         2        2  amrish 2020-01-02 14:20         1 contact            No\n4         3        2  amrish 2020-01-02 14:20         1 contact            No\n5         4        3  mariah 2020-01-05 12:00         1    case            No\n6         5        2  amrish 2020-01-05 16:10         3    case           Yes\n7         6        4  nikhil 2020-01-05 13:01         1 contact           Yes\n8         7        5   brian 2020-01-05 15:20         1 contact            No\n9         8        6   smita 2020-01-05 14:20         1 contact           Yes\n10        9        7  raquel 2020-01-05 12:30         1 contact          &lt;NA&gt;\n11       10        2  amrish 2020-01-02 10:24         2 contact           Yes\n12       11        1    adam 2020-01-05 09:40         2    case            No\n13       12        3  mariah 2020-01-06 07:25         2 contact            No\n14       13        3  mariah 2020-01-06 08:32         3 contact            No\n15       14        4  nikhil 2020-01-06 15:36         2 contact           Yes\n16       15        5   brian 2020-01-06 15:31         2 contact           Yes\n17       16        5   brian 2020-01-07 07:59         3    case            No\n18       17        7  raquel 2020-01-07 11:13         2 contact            No\n19       18        8 natalie 2020-01-07 17:12         1    case            No\n     dup_record\n1        Ignore\n2        Ignore\n3        Ignore\n4        Ignore\n5        Ignore\n6  For analysis\n7        Ignore\n8        Ignore\n9  For analysis\n10       Ignore\n11       Ignore\n12 For analysis\n13       Ignore\n14 For analysis\n15 For analysis\n16       Ignore\n17 For analysis\n18 For analysis\n19 For analysis\n\n\n\n\n\n\n\n\nXem dữ liệu gốc.\n\n\n\nTính toán độ hoàn chỉnh của hàng\nTạo một cột chứa số liệu về độ hoàn chỉnh (không bị thiếu) của hàng. Điều này có thể hữu ích khi quyết định ưu tiên hàng nào hơn hàng nào khi loại bỏ trùng lặp/cắt.\nTrong ví dụ này, các cột “chính” mà bạn muốn đo lường mức độ hoàn chỉnh được lưu trong một vectơ tên cột.\nSau đó, cột mới key_completeness được tạo bằng hàm mutate(). Giá trị mới của mỗi hàng được xác định dưới dạng phân số được tính toán bằng: số giá trị không bị thiếu trong hàng đó trong số các cột chính, chia cho số cột chính.\nĐiều này cần thêm hàm rowSums() từ base R. Data frame sử dụng được đại diện bởi dấu ., tức là tham chiếu đến data frame nguồn trong một chuỗi pipe (trong trường hợp này, nó sẽ được tách thành tập con với dấu ngoặc vuông []).\nCuộn sang phải để xem các hàng khác\n\n# create a \"key variable completeness\" column\n# this is a *proportion* of the columns designated as \"key_cols\" that have non-missing values\n\nkey_cols = c(\"personID\", \"name\", \"symptoms_ever\")\n\nobs %&gt;% \n  mutate(key_completeness = rowSums(!is.na(.[,key_cols]))/length(key_cols)) \n\n\n\n\n\n\n\nXem dữ liệu gốc.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Loại bỏ trùng lặp</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.vn.html#str_rollup",
    "href": "new_pages/deduplication.vn.html#str_rollup",
    "title": "15  Loại bỏ trùng lặp",
    "section": "15.4 Gộp các giá trị",
    "text": "15.4 Gộp các giá trị\nPhần này miêu tả:\n\nCách “gộp (roll-up)” các giá trị từ nhiều hàng chỉ thành một hàng, với một số biến thể\n\nKhi bạn có các giá trị “đã được gộp”, cách để ghi đè/ưu tiên các giá trị trong mỗi ô\n\nTab này sử dụng bộ dữ liệu mẫu từ tab Chuẩn bị.\n\n\nGộp các giá trị thành một hàng\nCode ví dụ bên dưới sử dụng group_by() và summarise() để nhóm các hàng theo từng người, rồi dán (paste) tất cả các giá trị duy nhất trong các hàng được nhóm lại với nhau. Do đó, bạn nhận được một hàng tóm tắt cho mỗi người. Một số lưu ý:\n\nMột hậu tố được thêm vào tất cả các cột mới (“_roll” trong ví dụ này)\n\nNếu bạn chỉ muốn hiển thị các giá trị duy nhất trên mỗi ô, thì hãy đặt na.omit() trong unique()\n\nna.omit() loại bỏ các giá trị NA, nhưng nếu đây là điều không mong muốn, nó có thể bị loại bỏ bởi paste0(.x)…\n\n\n# \"Roll-up\" values into one row per group (per \"personID\") \ncases_rolled &lt;- obs %&gt;% \n  \n  # create groups by name\n  group_by(personID) %&gt;% \n  \n  # order the rows within each group (e.g. by date)\n  arrange(date, .by_group = TRUE) %&gt;% \n  \n  # For each column, paste together all values within the grouped rows, separated by \";\"\n  summarise(\n    across(everything(),                           # apply to all columns\n           ~paste0(na.omit(.x), collapse = \"; \"))) # function is defined which combines non-NA values\n\nKết quả là một hàng cho mỗi nhóm (ID), với các mục đã nhập được sắp xếp theo ngày và được dán cùng nhau. Cuộn sang trái để xem các hàng khác\n\n\n\n\n\n\nXem dữ liệu gốc.\nBiến thể này chỉ hiển thị các giá trị duy nhất:\n\n# Variation - show unique values only \ncases_rolled &lt;- obs %&gt;% \n  group_by(personID) %&gt;% \n  arrange(date, .by_group = TRUE) %&gt;% \n  summarise(\n    across(everything(),                                   # apply to all columns\n           ~paste0(unique(na.omit(.x)), collapse = \"; \"))) # function is defined which combines unique non-NA values\n\n\n\n\n\n\n\nBiến thể này thêm hậu tố vào mỗi cột.\nTrong trường hợp này, “_roll” được dùng để biểu thị rằng nó đã được gộp:\n\n# Variation - suffix added to column names \ncases_rolled &lt;- obs %&gt;% \n  group_by(personID) %&gt;% \n  arrange(date, .by_group = TRUE) %&gt;% \n  summarise(\n    across(everything(),                \n           list(roll = ~paste0(na.omit(.x), collapse = \"; \")))) # _roll is appended to column names\n\n\n\n\n\n\n\n\n\n\nGhi đè các giá trị/hệ thống phân cấp\nSau đó, nếu bạn muốn đánh giá tất cả các giá trị đã gộp và chỉ giữ một giá trị cụ thể (ví dụ: giá trị “tốt nhất (best)” hoặc “tối đa (maximum)”), bạn có thể sử dụng hàm mutate() trên các cột mong muốn, để triển khai các điều kiện rẽ nhánh với case_when() và str_detect() từ package stringr để tìm kiếm tuần tự các mẫu chuỗi và ghi đè nội dung ô.\n\n# CLEAN CASES\n#############\ncases_clean &lt;- cases_rolled %&gt;% \n    \n    # clean Yes-No-Unknown vars: replace text with \"highest\" value present in the string\n    mutate(across(c(contains(\"symptoms_ever\")),                     # operates on specified columns (Y/N/U)\n             list(mod = ~case_when(                                 # adds suffix \"_mod\" to new cols; implements case_when()\n               \n               str_detect(.x, \"Yes\")       ~ \"Yes\",                 # if \"Yes\" is detected, then cell value converts to yes\n               str_detect(.x, \"No\")        ~ \"No\",                  # then, if \"No\" is detected, then cell value converts to no\n               str_detect(.x, \"Unknown\")   ~ \"Unknown\",             # then, if \"Unknown\" is detected, then cell value converts to Unknown\n               TRUE                        ~ as.character(.x)))),   # then, if anything else if it kept as is\n      .keep = \"unused\")                                             # old columns removed, leaving only _mod columns\n\nBây giờ bạn có thể thấy trong cột symptoms_ever rằng nếu người đó TỪNG trả lời “Yes” với các triệu chứng, thì chỉ “Yes” được hiển thị.\n\n\n\n\n\n\nXem dữ liệu gốc.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Loại bỏ trùng lặp</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.vn.html#loại-bỏ-trùng-lặp-theo-xác-suất",
    "href": "new_pages/deduplication.vn.html#loại-bỏ-trùng-lặp-theo-xác-suất",
    "title": "15  Loại bỏ trùng lặp",
    "section": "15.5 Loại bỏ trùng lặp theo xác suất",
    "text": "15.5 Loại bỏ trùng lặp theo xác suất\nĐôi khi, bạn có thể muốn xác định các bản trùng lặp “có khả năng xảy ra” dựa trên sự tương đồng (ví dụ: chuỗi “distance (khoảng cách)”) trên một số cột như name (tên), age (tuổi), sex (giới tính), date of birth (ngày sinh), v.v. Bạn có thể áp dụng thuật toán so khớp theo xác suất để xác định các bản trùng lặp có khả năng xảy ra.\nXem chương Nối dữ liệu để được giải thích về phương pháp này. Mục So sánh theo xác suất chứa một ví dụ về việc áp dụng các thuật toán này để so sánh một data frame với chính nó, do đó thực hiện loại bỏ trùng lặp theo xác suất.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Loại bỏ trùng lặp</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.vn.html#tài-nguyên-học-liệu",
    "href": "new_pages/deduplication.vn.html#tài-nguyên-học-liệu",
    "title": "15  Loại bỏ trùng lặp",
    "section": "15.6 Tài nguyên học liệu",
    "text": "15.6 Tài nguyên học liệu\nPhần lớn thông tin trong chương này được điều chỉnh từ các tài nguyên và vignette trực tuyến sau:\ndatanovia\ndplyr tidyverse reference\ncran janitor vignette",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Loại bỏ trùng lặp</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.vn.html",
    "href": "new_pages/iteration.vn.html",
    "title": "16  Lặp, vòng lặp, và danh sách",
    "section": "",
    "text": "16.1 Chuẩn bị",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Lặp, vòng lặp, và danh sách</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.vn.html#chuẩn-bị",
    "href": "new_pages/iteration.vn.html#chuẩn-bị",
    "title": "16  Lặp, vòng lặp, và danh sách",
    "section": "",
    "text": "Gọi packages\nĐoạn code này hiển thị cách gọi các packages cần thiết cho phần phân tích. Trong sổ tay này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, cài đặt package nếu cần và gọi nó ra để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm library() từ base R. Xem chương R cơ bản để biết thêm thông tin về packages R.\n\npacman::p_load(\n     rio,         # import/export\n     here,        # file locator\n     purrr,       # iteration\n     grates,      # scales in ggplot\n     tidyverse    # data management and visualization\n)\n\n\n\nNhập dữ liệu\nChúng tôi nhập dataset về các trường hợp từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn làm theo, hãy nhấp để tải xuống linelist “sạch” (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - Xem chương Nhập xuất dữ liệu để biết chi tiết).\n\n# import the linelist\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\n50 hàng đầu tiên của linelist được hiển thị bên dưới.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Lặp, vòng lặp, và danh sách</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.vn.html#vòng-lặp-for",
    "href": "new_pages/iteration.vn.html#vòng-lặp-for",
    "title": "16  Lặp, vòng lặp, và danh sách",
    "section": "16.2 vòng lặp for",
    "text": "16.2 vòng lặp for\n\nvòng lặp for trong R\nVòng lặp for không được nhấn mạnh trong R, nhưng phổ biến trong các ngôn ngữ lập trình khác. Khi mới bắt đầu, chúng có thể hữu ích để học và thực hành vì chúng dễ “khám phá”, “gỡ lỗi” hơn và nắm bắt chính xác những gì đang xảy ra cho mỗi lần lặp, đặc biệt là khi bạn chưa cảm thấy thoải mái khi viết các hàm của riêng mình.\nBạn có thể chuyển nhanh qua phần vòng lặp for tới phần lặp với các hàm được tạo với purrr (xem phần bên dưới).\n\n\nCấu phần cốt lõi\nMột vòng lặp for có ba phần cốt lõi:\n\nChuỗi các phần tử cần lặp lại\nCác thao tác để tiến hành cho mỗi phần tử trong chuỗi\n\nVùng chứa cho kết quả (tùy chọn)\n\nCú pháp cơ bản là: for (phần tử trong chuỗi) {các thao tác thực hiện với phần tử}. Lưu ý dấu ngoặc đơn và dấu ngoặc nhọn. Kết quả có thể được in ra console hoặc được lưu trữ trong một đối tượng vùng chứa.\nDưới đây là một ví dụ đơn giản về vòng lặp for.\n\nfor (num in c(1,2,3,4,5)) {  # the SEQUENCE is defined (numbers 1 to 5) and loop is opened with \"{\"\n  print(num + 2)             # The OPERATIONS (add two to each sequence number and print)\n}                            # The loop is closed with \"}\"                            \n\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n\n                             # There is no \"container\" in this example\n\n\n\nChuỗi\nĐây là phần “for” của vòng lặp for - các thao tác sẽ chạy “cho (for)” từng phần tử trong chuỗi. Chuỗi có thể là một loạt các giá trị (ví dụ: tên của khu vực pháp lý, bệnh, tên cột, phần tử danh sách, v.v.) hoặc nó có thể là một chuỗi các số liên tiếp (ví dụ: 1,2,3,4,5). Mỗi cách tiếp cận được mô tả dưới đây có các tiện ích riêng của chúng.\nCấu trúc cơ bản của biểu thức chuỗi là item in vector.\n\nBạn có thể viết bất kỳ ký tự hoặc từ nào thay cho “item” (ví dụ: “i”, “num”, “hosp”, “district”, v.v.). Giá trị của “item” này thay đổi theo từng lần lặp lại của vòng lặp, tiếp tục qua từng giá trị trong vector.\n\nVector có thể là các giá trị ký tự, tên cột hoặc có thể là một chuỗi số - đây là những giá trị sẽ thay đổi theo mỗi lần lặp. Bạn có thể sử dụng chúng trong các thao tác vòng lặp for bằng cách sử dụng thuật ngữ “item”.\n\nVí dụ: chuỗi giá trị ký tự\nTrong ví dụ này, một vòng lặp được thực hiện cho mỗi giá trị được xác định trước trong một vector ký tự của tên bệnh viện.\n\n# make vector of the hospital names\nhospital_names &lt;- unique(linelist$hospital)\nhospital_names # print\n\n[1] \"Other\"                               \n[2] \"Missing\"                             \n[3] \"St. Mark's Maternity Hospital (SMMH)\"\n[4] \"Port Hospital\"                       \n[5] \"Military Hospital\"                   \n[6] \"Central Hospital\"                    \n\n\nChúng tôi đã chọn thuật ngữ hosp để đại diện cho các giá trị từ vector hospital_names. Đối với lần lặp đầu tiên của vòng lặp, giá trị của hosp sẽ là hospital_names[[1]]. Đối với vòng lặp thứ hai, nó sẽ là hospital_names[[2]]. Và cứ như thế…\n\n# a 'for loop' with character sequence\n\nfor (hosp in hospital_names){       # sequence\n  \n       # OPERATIONS HERE\n  }\n\nVí dụ: chuỗi tên cột\nĐây là một biến thể của chuỗi ký tự ở trên, trong đó tên của một đối tượng R hiện có được trích xuất và trở thành vector. Ví dụ, tên cột của dataframe. Trong code hoạt động của vòng lặp for, tên cột có thể được sử dụng để lập chỉ mục (tập hợp con) dataframe ban đầu của chúng.\nDưới đây, chuỗi là names() (tên cột) của dataframe linelist. Tên “item” của chúng ta là col, sẽ đại diện cho từng tên cột khi các vòng lặp diễn ra.\nVới ví dụ này, chúng tôi bao gồm code thao tác bên trong vòng lặp for, được chạy cho mọi giá trị trong chuỗi. Trong code này, các giá trị trình tự (tên cột) được sử dụng để chỉ mục (tập hợp con) từng phần tử một trong linelist. Như đã dạy trong chương R cơ bản, dấu ngoặc vuông kép [[]] được sử dụng cho tập hợp con. Cột kết quả được chuyển đến is.na(), sau đó đến sum() để tạo ra số giá trị trong cột bị thiếu. Kết quả được in ra console - một số cho mỗi cột.\nMột lưu ý về lập chỉ mục với tên cột - bất cứ khi nào tham chiếu đến chính cột đó, đừng chỉ viết “col”! col chỉ đại diện cho tên cột ký tự! Để tham chiếu đến toàn bộ cột, bạn phải sử dụng tên cột dưới dạng chỉ mục trên linelist thông qua linelist[[col]].\n\nfor (col in names(linelist)){        # loop runs for each column in linelist; column name represented by \"col\" \n  \n  # Example operations code - print number of missing values in column\n  print(sum(is.na(linelist[[col]])))  # linelist is indexed by current value of \"col\"\n     \n}\n\n[1] 0\n[1] 0\n[1] 2087\n[1] 256\n[1] 0\n[1] 936\n[1] 1323\n[1] 278\n[1] 86\n[1] 0\n[1] 86\n[1] 86\n[1] 86\n[1] 0\n[1] 0\n[1] 0\n[1] 2088\n[1] 2088\n[1] 0\n[1] 0\n[1] 0\n[1] 249\n[1] 249\n[1] 249\n[1] 249\n[1] 249\n[1] 149\n[1] 765\n[1] 0\n[1] 256\n\n\nDãy số\nTheo cách tiếp cận này, dãy số là một chuỗi các số liên tiếp. Do đó, giá trị của “item” không phải là giá trị ký tự (ví dụ: “Central Hospital” hoặc “date_onset”) mà là một số. Điều này rất hữu ích cho việc lặp qua các dataframes, vì bạn có thể sử dụng số “item” bên trong vòng lặp for để lập chỉ mục dataframe theo số hàng.\nVí dụ: giả sử bạn muốn lặp qua mọi hàng trong dataframe của mình và trích xuất thông tin nhất định. “Item” của bạn sẽ là số hàng số. Thông thường, “item” trong trường hợp này được viết là i.\nQuá trình vòng lặp for có thể được giải thích bằng lời là “đối với mọi mục trong chuỗi số từ 1 đến tổng số hàng trong dataframe của tôi, hãy thực hiện X”. Đối với lần lặp đầu tiên của vòng lặp, giá trị của “item” i sẽ là 1. Đối với lần lặp thứ hai,i sẽ là 2, v.v.\nĐây là hình thức của chuỗi trong code: for (i in 1:nrow(linelist)) {OPERATIONS CODE} trong đó i đại diện cho “item”và 1:nrow(linelist) tạo ra một chuỗi liên tiếp số từ 1 đến số hàng trong linelist.\n\nfor (i in 1:nrow(linelist)) {  # use on a data frame\n  # OPERATIONS HERE\n}  \n\nNếu bạn muốn chuỗi là số, nhưng bạn đang bắt đầu từ một vector (không phải dataframe), hãy sử dụng hàm tắt seq_along() để trả về một dãy số cho mỗi phần tử trong vector. Ví dụ: for (i in seq_along(hospital_names) {OPERATIONS CODE}.\nĐoạn code dưới đây thực sự trả về các số, sẽ trở thành giá trị của i trong vòng lặp tương ứng của chúng.\n\nseq_along(hospital_names)  # use on a named vector\n\n[1] 1 2 3 4 5 6\n\n\nMột lợi thế của việc sử dụng các số trong chuỗi là cũng dễ dàng sử dụng số i để lập chỉ mục vùng chứa lưu trữ các kết quả đầu ra của vòng lặp. Có một ví dụ về điều này trong phần Thao tác bên dưới.\n\n\nCác thao tác\nĐây là code trong dấu ngoặc nhọn {} của vòng lặp for. Bạn muốn code này chạy cho từng “item” trong chuỗi. Do đó, hãy thận trọng với mọi phần code của bạn thay đổi bởi “item” đều được mã hóa chính xác để nó thực sự thay đổi! Ví dụ. nhớ sử dụng [[ ]] để lập chỉ mục.\nTrong ví dụ dưới đây, chúng tôi lặp lại từng hàng trong linelist. Giá trị gender và age của mỗi hàng được dán lại với nhau và được lưu trữ trong vector ký tự vùng chứa cases_demographics. Lưu ý cách chúng tôi cũng sử dụng lập chỉ mục [[i]] để lưu đầu ra của vòng lặp vào vị trí chính xác trong vector “container”.\n\n# create container to store results - a character vector\ncases_demographics &lt;- vector(mode = \"character\", length = nrow(linelist))\n\n# the for loop\nfor (i in 1:nrow(linelist)){\n  \n  # OPERATIONS\n  # extract values from linelist for row i, using brackets for indexing\n  row_gender  &lt;- linelist$gender[[i]]\n  row_age     &lt;- linelist$age_years[[i]]    # don't forget to index!\n     \n  # combine gender-age and store in container vector at indexed location\n  cases_demographics[[i]] &lt;- str_c(row_gender, row_age, sep = \",\") \n\n}  # end for loop\n\n\n# display first 10 rows of container\nhead(cases_demographics, 10)\n\n [1] \"m,2\"  \"f,3\"  \"m,56\" \"f,18\" \"m,3\"  \"f,16\" \"f,16\" \"f,0\"  \"m,61\" \"f,27\"\n\n\n\n\nVùng chứa\nĐôi khi kết quả của vòng lặp for của bạn sẽ được in ra console hoặc cửa sổ RStudio Plots. Lần khác, bạn sẽ muốn lưu trữ các kết quả đầu ra trong một “vùng chứa” để sử dụng sau này. Một vùng chứa như vậy có thể là một vector, một data frame hoặc thậm chí là một danh sách.\nHiệu quả nhất là tạo vùng chứa cho các kết quả thậm chí trước khi bắt đầu vòng lặp for. Trong thực tế, điều này có nghĩa là tạo một vector, data frame hoặc danh sách trống. Chúng có thể được tạo bằng các hàm vector() cho vectors hoặc danh sách, hoặc với matrix() và data.frame() cho một data frame.\nVector trống\nSử dụng vector() và chỉ định mode = dựa trên lớp phân loại dự kiến của các đối tượng mà bạn sẽ chèn - “double” (để giữ số), “ký tự” hoặc “logic”. Bạn cũng nên đặt trước length =. Đây phải là độ dài chuỗi vòng lặp for của bạn.\nGiả sử bạn muốn lưu trữ thời gian nhập viện trễ trung bình cho mỗi bệnh viện. Bạn sẽ sử dụng “double” và đặt độ dài là số đầu ra dự kiến (số bệnh viện duy nhất trong data set).\n\ndelays &lt;- vector(\n  mode = \"double\",                            # we expect to store numbers\n  length = length(unique(linelist$hospital))) # the number of unique hospitals in the dataset\n\nData frame trống\nBạn có thể tạo một data frame trống bằng cách chỉ định số hàng và cột như sau:\n\ndelays &lt;- data.frame(matrix(ncol = 2, nrow = 3))\n\nDanh sách trống\nBạn có thể muốn lưu trữ một số biểu đồ được tạo bởi vòng lặp for trong danh sách. Một danh sách giống như vector, nhưng chứa các đối tượng R khác bên trong nó có thể thuộc các lớp khác nhau. Các phần tử trong danh sách có thể là một số, một dataframe, một vector và thậm chí là một danh sách khác.\nBạn thực sự khởi tạo một danh sách trống bằng cách sử dụng cùng một lệnh vector() như trên, nhưng với mode = \"list\". Chỉ định độ dài như bạn muốn.\n\nplots &lt;- vector(mode = \"list\", length = 16)\n\n\n\nIn\nLưu ý rằng để in từ bên trong vòng lặp for, bạn có thể sẽ cần phải đưa hàm print() vào.\nTrong ví dụ dưới đây, chuỗi là một vector ký tự rõ ràng, được sử dụng để đặt linelist con theo bệnh viện. Kết quả không được lưu trữ trong vùng chứa mà được in ra console với hàm print().\n\nfor (hosp in hospital_names){ \n     hospital_cases &lt;- linelist %&gt;% filter(hospital == hosp)\n     print(nrow(hospital_cases))\n}\n\n[1] 885\n[1] 1469\n[1] 422\n[1] 1762\n[1] 896\n[1] 454\n\n\n\n\nKiểm tra vòng lặp for\nĐể kiểm tra vòng lặp của mình, bạn có thể chạy lệnh để gán tạm thời “item”, chẳng hạn như i &lt;- 10 hoặc hosp &lt;- \"Central Hospital\". Thực hiện việc này bên ngoài vòng lặp và sau đó chỉ chạy code thao tác của bạn (code trong dấu ngoặc nhọn) để xem liệu kết quả mong đợi có được tạo ra hay không.\n\n\nLặp lại biểu đồ\nĐể đặt tất cả ba thành phần lại với nhau (vùng chứa, trình tự và thao tác), chúng ta hãy cố gắng vẽ biểu đồ đường cong dịch bệnh cho mỗi bệnh viện (xem chương Đường cong dịch bệnh).\nChúng tôi có thể tạo ra một đường cong dịch bệnh đẹp về tất cả các trường hợp theo giới tính bằng cách sử dụng package incidence2 như bên dưới:\n\n# create 'incidence' object\noutbreak &lt;- incidence2::incidence(   \n     x = linelist,                   # dataframe - complete linelist\n     date_index = \"date_onset\",      # date column\n     interval = \"week\",              # aggregate counts weekly\n     groups = \"gender\")              # group values by gender\n     #na_as_group = TRUE)            # missing gender is own group\n\n# plot epi curve\nggplot(outbreak,                     # incidence object name\n        aes(x = date_index,          # aesthetics and axes\n            y = count, \n            fill = gender),          # Fill colour of bars by gender\n       color = \"black\"               # Contour colour of bars\n       ) +  \n     geom_col() + \n     facet_wrap(~gender) +\n     theme_bw() + \n     labs(title = \"Outbreak of all cases\", #title\n          x = \"Counts\", \n          y = \"Date\", \n          fill = \"Gender\", \n          color = \"Gender\")\n\n\n\n\n\n\n\n\nĐể tạo ra một biểu đồ riêng cho từng trường hợp của bệnh viện, chúng ta có thể đặt code đường cong dịch bệnh này trong vòng lặp for.\nĐầu tiên, chúng tôi lưu một vector được đặt tên duy nhất của các tên bệnh viện, hospital_names. Vòng lặp for sẽ chạy một lần cho mỗi tên sau: for (hosp in hospital_names). Mỗi lần lặp lại của vòng lặp for, tên bệnh viện hiện tại từ vector sẽ được biểu diễn dưới dạng hosp để sử dụng trong vòng lặp.\nTrong các thao tác vòng lặp, bạn có thể viết code R như bình thường, nhưng cần biết rằng giá trị của “item” (hosp trong trường hợp này) sẽ thay đổi. Trong vòng lặp này:\n\nMột filter() được áp dụng cho linelist, sao cho cột hospital phải bằng giá trị hiện tại của hosp\n\nĐối tượng tỷ lệ mắc được tạo trên linelist đã lọc\n\nBiểu đồ cho bệnh viện hiện tại được tạo, với tiêu đề tự động điều chỉnh sử dụng hosp\n\nBiểu đồ cho bệnh viện hiện tại được lưu tạm thời và sau đó được in\n\nSau đó, vòng lặp di chuyển tiếp để lặp lại với bệnh viện tiếp theo trong hospital_names\n\n\n# make vector of the hospital names\nhospital_names &lt;- unique(linelist$hospital)\n\n# for each name (\"hosp\") in hospital_names, create and print the epi curve\nfor (hosp in hospital_names) {\n     \n     # create incidence object specific to the current hospital\n     outbreak_hosp &lt;- incidence2::incidence(\n          x = linelist %&gt;% filter(hospital == hosp),   # linelist is filtered to the current hospital\n          date_index = \"date_onset\",\n          interval = \"week\", \n          groups = \"gender\"\n          #na_as_group = TRUE\n     )\n     \n     # Create and save the plot. Title automatically adjusts to the current hospital\n      plot_hosp &lt;- ggplot(outbreak_hosp, # incidence object name\n                         aes(x = date_index, #axes\n                             y = count, \n                             fill = gender), # fill colour by gender\n                         color = \"black\"      # colour of bar contour\n                         ) +  \n          geom_col() + \n          facet_wrap(~gender) +\n          theme_bw() + \n          labs(title = stringr::str_glue(\"Epidemic of cases admitted to {hosp}\"), #title\n               x = \"Counts\", \n               y = \"Date\", \n               fill = \"Gender\", \n               color = \"Gender\")\n     \n     # With older versions of R, remove the # before na_as_group and use this plot command instead.\n    # plot_hosp &lt;- plot(\n#       outbreak_hosp,\n#       fill = \"gender\",\n#       color = \"black\",\n#       title = stringr::str_glue(\"Epidemic of cases admitted to {hosp}\")\n#     )\n     \n     # print the plot for hospitals\n     print(plot_hosp)\n     \n} # end the for loop when it has been run for every hospital in hospital_names \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTheo dõi tiến trình của một vòng lặp\nMột vòng lặp có nhiều lần lặp có thể chạy trong nhiều phút hoặc thậm chí hàng giờ. Do đó, có thể hữu ích khi in tiến trình ra R console. Câu lệnh if dưới đây có thể được đặt trong các thao tác vòng lặp để in mỗi số thứ 100. Chỉ cần điều chỉnh nó để i là “item” trong vòng lặp của bạn.\n\n# loop with code to print progress every 100 iterations\nfor (i in seq_len(nrow(linelist))){\n\n  # print progress\n  if(i %% 100==0){    # The %% operator is the remainder\n    print(i)\n\n}",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Lặp, vòng lặp, và danh sách</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.vn.html#iter_purrr",
    "href": "new_pages/iteration.vn.html#iter_purrr",
    "title": "16  Lặp, vòng lặp, và danh sách",
    "section": "16.3 purrr và các danh sách",
    "text": "16.3 purrr và các danh sách\nMột cách tiếp cận khác đối với các thao tác lặp là package purrr - nó là phương pháp tidyverse để lặp lại.\nNếu bạn phải thực hiện cùng một tác vụ nhiều lần, có lẽ bạn nên tạo một giải pháp tổng thể có thể sử dụng trên nhiều đầu vào. Ví dụ: tạo các biểu đồ cho nhiều khu vực pháp lý, hoặc nhập và kết hợp nhiều tệp.\nNgoài ra còn có một số lợi thế khác đối với purrr - bạn có thể sử dụng nó với các pipes %&gt;%, nó xử lý lỗi tốt hơn vòng lặp for bình thường, và có cú pháp khá rõ ràng và đơn giản! Nếu bạn đang sử dụng vòng lặp for, bạn có thể tạo vòng lặp rõ ràng và ngắn gọn hơn với purrr!\nHãy nhớ rằng purrr là một công cụ lập trình theo hàm. Có nghĩa là, các thao tác lặp đi lặp lại được gói gọn trong các hàm. Xem chương Viết hàm để tìm hiểu cách viết hàm của riêng bạn.\npurrr cũng gần như hoàn toàn dựa trên danh sách và vectors - vì vậy hãy nghĩ về nó như là áp dụng một hàm cho mỗi phần tử của danh sách/vector đó!\n\nTải packages\npurrr là một phần của tidyverse, vì vậy không cần cài đặt/tải một package riêng biệt.\n\npacman::p_load(\n     rio,            # import/export\n     here,           # relative filepaths\n     tidyverse,      # data mgmt and viz\n     writexl,        # write Excel file with multiple sheets\n     readxl          # import Excel with multiple sheets\n)\n\n\n\nmap()\nMột hàm cốt lõi của purrr là map(), hàm này “maps” (áp dụng) một hàm cho từng phần tử đầu vào của danh sách/vector bạn cung cấp.\nCú pháp cơ bản là map(.x = SEQUENCE, .f = HÀM, CÁC ĐỐI SỐ KHÁC). Chi tiết hơn như sau:\n\n.x = là các đầu vào mà hàm .f sẽ được áp dụng lặp đi lặp lại - ví dụ: vector của tên các khu vực pháp lý, các cột trong data frame hoặc danh sách các data frame\n\n.f = là hàm áp dụng cho từng phần tử của đầu vào .x - nó có thể là một hàm như print() đã tồn tại hoặc một hàm tùy chỉnh mà bạn xác định. Hàm thường được viết sau dấu ngã ~ (chi tiết bên dưới).\n\nThêm một số lưu ý về cú pháp:\n\nNếu hàm không cần chỉ định thêm đối số, nó có thể được viết không có dấu ngoặc đơn và không có dấu ngã (ví dụ: .f = mean). Để cung cấp các đối số sẽ có cùng giá trị cho mỗi lần lặp, hãy cung cấp chúng trong map() nhưng bên ngoài đối số .f =, chẳng hạn như na.rm = T trong map(.x = my_list, .f = mean, na.rm=T).\n\nBạn có thể sử dụng .x (hoặc đơn giản là .) bên trong hàm .f = làm trình giữ chỗ cho giá trị .x của lần lặp đó\n\nSử dụng cú pháp dấu ngã (~) để kiểm soát hàm nhiều hơn - viết hàm như bình thường với dấu ngoặc đơn, chẳng hạn như: map(.x = my_list, .f = ~mean(., na.rm = T)). Sử dụng cú pháp này đặc biệt nếu giá trị của một đối số sẽ thay đổi mỗi lần lặp lại hoặc nếu nó là chính giá trị .x (xem ví dụ bên dưới)\n\n** Đầu ra của việc sử dụng map() là một danh sách** - một danh sách là một lớp đối tượng giống như một vector nhưng các phần tử của nó có thể thuộc các lớp khác nhau. Vì vậy, một danh sách được tạo bởi map() có thể chứa nhiều data frames, hoặc nhiều vector, nhiều giá trị đơn lẻ, hoặc thậm chí nhiều danh sách! Có các phiên bản thay thế của map() được giải thích bên dưới, tạo ra các loại kết quả khác (ví dụ: map_dfr() để tạo data frame, map_chr() để tạo vectors ký tự và map_dbl() để tạo vectors số).\n\nVí dụ - nhập và kết hợp các trang tính Excel\nHãy biểu diễn với một công việc thường gặp của nhà dịch tễ học: - Bạn muốn nhập một Excel workbook với dữ liệu trường hợp bệnh, nhưng dữ liệu được chia thành các trang tính có tên khác nhau trong workbook. Làm cách nào để bạn nhập và kết hợp các trang tính vào một data frame một cách hiệu quả?\nGiả sử chúng tôi được gửi Excel workbook bên dưới. Mỗi trang tính chứa các trường hợp từ một bệnh viện nhất định.\n\n\n\n\n\n\n\n\n\nĐây là một cách tiếp cận sử dụng map():\n\nmap() hàm import() để nó chạy qua mỗi trang tính Excel\n\nKết hợp các data frames đã nhập thành một bằng cách sử dụng bind_rows()\n\nTrong khi đó, hãy giữ nguyên tên trang tính ban đầu cho mỗi hàng, lưu trữ thông tin này trong một cột mới trong data frame cuối cùng\n\nĐầu tiên, chúng ta cần trích xuất tên trang tính và lưu chúng. Chúng tôi cung cấp đường dẫn tệp của Excel workbook tới hàm excel_sheets() từ package readxl, sẽ trích xuất tên trang tính. Chúng tôi lưu trữ chúng trong một vector ký tự được gọi là sheet_names.\n\nsheet_names &lt;- readxl::excel_sheets(\"hospital_linelists.xlsx\")\n\nĐây là các tên trang tính:\n\nsheet_names\n\n[1] \"Central Hospital\"              \"Military Hospital\"            \n[3] \"Missing\"                       \"Other\"                        \n[5] \"Port Hospital\"                 \"St. Mark's Maternity Hospital\"\n\n\nBây giờ chúng ta có tên của vector này, map() có thể cung cấp từng cái một cho hàm import(). Trong ví dụ này, sheet_names là .x và import() là hàm .f.\nNhớ lại từ chương Nhập và xuất dữ liệu, khi sử dụng trên Excel workbooks, import() có thể chấp nhận đối số which = để chỉ định trang tính để nhập. Trong hàm import() của .f, chúng tôi cung cấp which = .x, giá trị của nó sẽ thay đổi theo mỗi lần lặp thông qua vector sheet_names - đầu tiên là “Central Hospital”, sau đó là “Military Hospital”, v.v.\nLưu ý - bởi vì chúng tôi đã sử dụng map(), dữ liệu trong mỗi trang tính Excel sẽ được lưu thành một data frame riêng biệt trong danh sách. Chúng tôi muốn mỗi phần tử danh sách này (data frames) có một tên, vì vậy trước khi chuyển sheet_names đến map(), chúng tôi chuyển nó qua set_names() từ purrr, điều này đảm bảo rằng mỗi phần tử danh sách nhận được tên thích hợp.\nChúng tôi lưu danh sách đầu ra dưới dạng combined.\n\ncombined &lt;- sheet_names %&gt;% \n  purrr::set_names() %&gt;% \n  map(.f = ~import(\"hospital_linelists.xlsx\", which = .x))\n\nKhi kiểm tra đầu ra, chúng ta thấy rằng dữ liệu từ mỗi trang tính Excel được lưu trong danh sách với một tên. Điều này là tốt, nhưng chúng ta chưa kết thúc ở đây.\n\n\n\n\n\n\n\n\n\nCuối cùng, chúng tôi sử dụng hàm bind_rows() (từ dplyr) chấp nhận danh sách các data frames có cấu trúc tương tự và kết hợp chúng thành một data frame. Để tạo một cột mới từ phần tử danh sách tên, chúng tôi sử dụng đối số .id = và cung cấp cho nó tên mong muốn cho cột mới.\nDưới đây là toàn bộ chuỗi lệnh:\n\nsheet_names &lt;- readxl::excel_sheets(\"hospital_linelists.xlsx\")  # extract sheet names\n \ncombined &lt;- sheet_names %&gt;%                                     # begin with sheet names\n  purrr::set_names() %&gt;%                                        # set their names\n  map(.f = ~import(\"hospital_linelists.xlsx\", which = .x)) %&gt;%  # iterate, import, save in list\n  bind_rows(.id = \"origin_sheet\") # combine list of data frames, preserving origin in new column  \n\nVà bây giờ chúng ta có một data frame với một cột chứa trang tính ban đầu!\n\n\n\n\n\n\n\n\n\nCó những biến thể của map() mà bạn nên biết. Ví dụ: map_dfr() trả về data frame, không phải danh sách. Vì vậy, chúng ta có thể đã sử dụng nó cho tác vụ ở trên và không cần phải ràng buộc các hàng. Nhưng sau đó chúng ta sẽ không thể nắm bắt được trường hợp nào đến từ trang tính nào (bệnh viện).\nCác biến thể khác bao gồm map_chr(), map_dbl(). Đây là những hàm rất hữu ích vì hai lý do. Trước hết, chúng tự động chuyển đổi đầu ra của một hàm lặp thành một vector (không phải danh sách). Thứ hai, chúng có thể kiểm soát rõ ràng lớp mà dữ liệu quay trở lại - bạn đảm bảo rằng dữ liệu của bạn quay trở lại dưới dạng vector ký tự với map_chr(), hoặc vector số với map_dbl(). Hãy quay lại những hàm này sau trong phần sau!\nCác hàm map_at() và map_if() cũng rất hữu ích để lặp lại - chúng cho phép bạn chỉ định phần tử nào của danh sách nên lặp lại! Chúng hoạt động đơn giản bằng cách áp dụng một vector gồm các chỉ mục/tên (với map_at()) hoặc một phép kiểm tra logic (với map_if()).\nVí dụ, chúng tôi không muốn đọc trang tính đầu tiên chứa dữ liệu của bệnh viện. Chúng tôi sử dụng map_at() thay vì map() và chỉ định đối số .at = thành c(-1) có nghĩa là không sử dụng phần tử đầu tiên của .x. Ngoài ra, bạn có thể cung cấp một vector gồm các số dương hoặc tên cho .at = để chỉ định phần tử nào sẽ sử dụng.\n\nsheet_names &lt;- readxl::excel_sheets(\"hospital_linelists.xlsx\")\n\ncombined &lt;- sheet_names %&gt;% \n     purrr::set_names() %&gt;% \n     # exclude the first sheet\n     map_at(.f = ~import( \"hospital_linelists.xlsx\", which = .x),\n            .at = c(-1))\n\nLưu ý rằng tên trang tính đầu tiên sẽ vẫn xuất hiện như một phần tử của danh sách đầu ra - nhưng nó chỉ là một tên ký tự đơn lẻ (không phải là một data frame). Bạn sẽ cần phải loại bỏ phần tử này trước khi liên kết các hàng. Chúng tôi sẽ trình bày cách xóa và sửa đổi các phần tử danh sách trong phần sau.\n\n\n\nTách và xuất bộ dữ liệu\nDưới đây, chúng tôi đưa ra một ví dụ về cách tách bộ dữ liệu thành các phần và sau đó sử dụng phép lặp map() để xuất từng phần dưới dạng trang tính Excel riêng biệt hoặc dưới dạng tệp CSV riêng biệt.\n\nTách bộ dữ liệu\nGiả sử chúng ta có toàn bộ trường hợp linelist làm data frame và bây giờ chúng ta muốn tạo một linelist riêng biệt cho từng bệnh viện và xuất từng trường hợp dưới dạng tệp CSV riêng biệt. Dưới đây, chúng tôi thực hiện các bước sau:\nSử dụng group_split() (từ dplyr) để tách data frame linelist theo các giá trị duy nhất trong cột hospital. Đầu ra là một danh sách chứa một data frame cho mỗi tập hợp con của bệnh viện.\n\nlinelist_split &lt;- linelist %&gt;% \n     group_split(hospital)\n\nChúng ta có thể chạy View(linelist_split) và thấy rằng danh sách này chứa 6 data frames (“tibbles”), mỗi khung đại diện cho các trường hợp từ một bệnh viện.\n\n\n\n\n\n\n\n\n\nTuy nhiên, lưu ý rằng các data frames trong danh sách không có tên theo mặc định! Chúng tôi muốn mỗi người có một tên và sau đó sử dụng tên đó khi lưu tệp CSV.\nMột cách tiếp cận để trích xuất các tên là sử dụng pull() (từ dplyr) để trích xuất cột hospital từ mỗi data frame trong danh sách. Sau đó, để an toàn, chúng tôi chuyển đổi các giá trị thành ký tự và sau đó sử dụng unique() để lấy tên cho data frame cụ thể đó. Tất cả các bước này được áp dụng cho từng data frame thông qua map().\n\nnames(linelist_split) &lt;- linelist_split %&gt;%   # Assign to names of listed data frames \n     # Extract the names by doing the following to each data frame: \n     map(.f = ~pull(.x, hospital)) %&gt;%        # Pull out hospital column\n     map(.f = ~as.character(.x)) %&gt;%          # Convert to character, just in case\n     map(.f = ~unique(.x))                    # Take the unique hospital name\n\nBây giờ chúng ta có thể thấy rằng mỗi phần tử trong danh sách đều có một tên. Những tên này có thể được truy cập thông qua names(linelist_split).\n\n\n\n\n\n\n\n\n\n\nnames(linelist_split)\n\n[1] \"Central Hospital\"                    \n[2] \"Military Hospital\"                   \n[3] \"Missing\"                             \n[4] \"Other\"                               \n[5] \"Port Hospital\"                       \n[6] \"St. Mark's Maternity Hospital (SMMH)\"\n\n\n\nNhiều hơn một cột group_split()\nNếu bạn muốn chia linelist theo nhiều hơn một nhóm cột, chẳng hạn như để tạo tập hợp con linelist theo giao điểm của bệnh viện VÀ giới tính, bạn sẽ cần một cách tiếp cận khác để đặt tên cho các phần tử danh sách. Điều này liên quan đến việc thu thập các “nhóm chính (group keys)” duy nhất bằng cách sử dụng group_keys() từ dplyr - chúng được trả về dưới dạng một data frame. Sau đó, bạn có thể kết hợp các nhóm chính thành các giá trị với unite() như được hiển thị bên dưới và gán các tên tập nhóm này cho linelist_split.\n\n# split linelist by unique hospital-gender combinations\nlinelist_split &lt;- linelist %&gt;% \n     group_split(hospital, gender)\n\n# extract group_keys() as a dataframe\ngroupings &lt;- linelist %&gt;% \n     group_by(hospital, gender) %&gt;%       \n     group_keys()\n\ngroupings      # show unique groupings \n\n# A tibble: 18 × 2\n   hospital                             gender\n   &lt;chr&gt;                                &lt;chr&gt; \n 1 Central Hospital                     f     \n 2 Central Hospital                     m     \n 3 Central Hospital                     &lt;NA&gt;  \n 4 Military Hospital                    f     \n 5 Military Hospital                    m     \n 6 Military Hospital                    &lt;NA&gt;  \n 7 Missing                              f     \n 8 Missing                              m     \n 9 Missing                              &lt;NA&gt;  \n10 Other                                f     \n11 Other                                m     \n12 Other                                &lt;NA&gt;  \n13 Port Hospital                        f     \n14 Port Hospital                        m     \n15 Port Hospital                        &lt;NA&gt;  \n16 St. Mark's Maternity Hospital (SMMH) f     \n17 St. Mark's Maternity Hospital (SMMH) m     \n18 St. Mark's Maternity Hospital (SMMH) &lt;NA&gt;  \n\n\nBây giờ chúng ta kết hợp các nhóm với nhau, được phân tách bằng dấu gạch ngang và gán chúng làm tên của các phần tử danh sách trong linelist_split. Thao tác này sẽ mất thêm vài dòng khi chúng ta thay thế NA bằng “Missing”, sử dụng unite() từ dplyr để kết hợp các giá trị cột với nhau (phân tách bằng dấu gạch ngang), sau đó chuyển đổi thành vector không tên để nó có thể được dùng làm tên của linelist_split.\n\n# Combine into one name value \nnames(linelist_split) &lt;- groupings %&gt;% \n     mutate(across(everything(), replace_na, \"Missing\")) %&gt;%  # replace NA with \"Missing\" in all columns\n     unite(\"combined\", sep = \"-\") %&gt;%                         # Unite all column values into one\n     setNames(NULL) %&gt;% \n     as_vector() %&gt;% \n     as.list()\n\n\n\n\nXuất dưới dạng trang tính Excel\nĐể xuất linelists bệnh viện dưới dạng Excel workbook với một linelist trên mỗi trang tính, chúng tôi chỉ có thể cung cấp danh sách có tên linelist_split cho hàm write_xlsx() từ package writexl. Điều này có khả năng lưu một Excel workbook với nhiều trang tính. Tên phần tử danh sách được tự động áp dụng làm tên trang tính.\n\nlinelist_split %&gt;% \n     writexl::write_xlsx(path = here(\"data\", \"hospital_linelists.xlsx\"))\n\nBây giờ bạn có thể mở tệp Excel và thấy rằng mỗi bệnh viện có một trang tính riêng.\n\n\n\n\n\n\n\n\n\n\n\nXuất dưới dạng tệp CSV\nĐây là lệnh phức tạp hơn một chút, nhưng bạn cũng có thể xuất từng linelist dành riêng cho bệnh viện dưới dạng tệp CSV riêng biệt, với tên tệp dành riêng cho bệnh viện.\nMột lần nữa, chúng tôi sử dụng map(): chúng tôi lấy vector của tên phần tử danh sách (được hiển thị ở trên) và sử dụng map() để lặp lại chúng, áp dụng export() (từ package rio, xem chương Nhập và xuất dữ liệu) trên data frame với danh sách linelist_split có tên đó. Chúng tôi cũng sử dụng tên để tạo một tên tệp duy nhất. Đây là các bước thực hiện:\n\nChúng ta bắt đầu với vector tên kí tự, được chuyển tới map() dưới dạng .x\n\nHàm .f là export(), hàm này yêu cầu một data frame và một đường dẫn tệp để ghi vào\n\nĐầu vào .x (tên bệnh viện) được sử dụng trong .f để trích xuất/lập chỉ mục phần tử cụ thể đó của danh sách linelist_split. Điều này làm cho mỗi lần chỉ một data frame được cung cấp cho export().\n\nVí dụ: khi map() lặp lại cho “Military Hospital”, thì linelist_split[[.x]] sẽ là linelist_split[[\"Military Hospital\"]], do đó trả về phần tử thứ hai của linelist_split - đó là tất cả các trường hợp từ Military Hospital.\n\nĐường dẫn tệp được cung cấp cho export() là động thông qua việc sử dụng str_glue() (xem chương Ký tự và chuỗi):\n\nhere() được sử dụng để lấy cơ sở của đường dẫn tệp và chỉ định thư mục “data” (lưu ý dấu nháy đơn để không làm gián đoạn dấu ngoặc kép str_glue())\n\n\nSau đó là dấu gạch chéo /, rồi lại .x in tên bệnh viện hiện tại để làm cho tệp có thể nhận dạng được\n\nCuối cùng là phần mở rộng “.csv” mà export() sử dụng để tạo tệp CSV\n\n\nnames(linelist_split) %&gt;%\n     map(.f = ~export(linelist_split[[.x]], file = str_glue(\"{here('data')}/{.x}.csv\")))\n\nBây giờ bạn có thể thấy rằng mỗi tệp được lưu trong thư mục “data” của Dự án R “Epi_R_handbook”!\n\n\n\n\n\n\n\n\n\n\n\n\nHàm tùy chỉnh\nBạn có thể muốn tạo một hàm của riêng mình để đưa vào map().\nGiả sử chúng ta muốn tạo đường cong dịch bệnh cho từng trường hợp của bệnh viện. Để thực hiện việc này với purrr, hàm .f của chúng ta có thể là ggplot() và các phần mở rộng bằng + như bình thường. Vì đầu ra của map() luôn là một danh sách nên các biểu đồ được lưu trữ trong một danh sách. Bởi vì chúng là các biểu đồ, chúng có thể được trích xuất và vẽ bằng hàm ggarrange() từ package ggpubr (documentation).\n\n# load package for plotting elements from list\npacman::p_load(ggpubr)\n\n# map across the vector of 6 hospital \"names\" (created earlier)\n# use the ggplot function specified\n# output is a list with 6 ggplots\n\nhospital_names &lt;- unique(linelist$hospital)\n\nmy_plots &lt;- map(\n  .x = hospital_names,\n  .f = ~ggplot(data = linelist %&gt;% filter(hospital == .x)) +\n                geom_histogram(aes(x = date_onset)) +\n                labs(title = .x)\n)\n\n# print the ggplots (they are stored in a list)\nggarrange(plotlist = my_plots, ncol = 2, nrow = 3)\n\n\n\n\n\n\n\n\nNếu code map() này trông quá lộn xộn, bạn có thể đạt được kết quả tương tự bằng cách lưu lệnh ggplot() cụ thể của mình dưới dạng một hàm tùy chỉnh do người dùng xác định, ví dụ, chúng ta có thể đặt tên nó là make_epicurve(). Hàm này sau đó được sử dụng trong map(). .x sẽ được thay thế lặp lại bằng tên bệnh viện và được sử dụng làm hosp_name trong hàm make_epicurve(). Xem chương về Viết hàm.\n\n# Create function\nmake_epicurve &lt;- function(hosp_name){\n  \n  ggplot(data = linelist %&gt;% filter(hospital == hosp_name)) +\n    geom_histogram(aes(x = date_onset)) +\n    theme_classic()+\n    labs(title = hosp_name)\n  \n}\n\n\n# mapping\nmy_plots &lt;- map(hospital_names, ~make_epicurve(hosp_name = .x))\n\n# print the ggplots (they are stored in a list)\nggarrange(plotlist = my_plots, ncol = 2, nrow = 3)\n\n\n\nÁp dụng một hàm qua nhiều cột\nMột trường hợp sử dụng phổ biến khác là áp dụng một hàm trên nhiều cột. Dưới đây, chúng tôi map() hàm t.test() qua các cột số trong data frame linelist, so sánh các giá trị số theo giới tính.\nNhớ lại từ chương về Các kiểm định thống kê cơ bản rằng t.test() có thể nhận đầu vào ở định dạng công thức, chẳng hạn như t.test(numeric column ~ binary column). Trong ví dụ này, chúng tôi làm như sau:\n\nCác cột số được chọn từ linelist - những cột này trở thành đầu vào .x cho map()\n\nHàm t.test() được cung cấp dưới dạng hàm .f, được áp dụng cho mỗi cột số\n\nTrong dấu ngoặc đơn của t.test():\n\ndấu ~ đầu tiên đứng trước .f mà map() sẽ lặp qua.x\n\n.x đại diện cho cột hiện tại được cung cấp cho hàm t.test()\n\ndấu ~ thứ hai là một phần của phương trình t-test được mô tả ở trên\n\nhàm t.test() yêu cầu một cột nhị phân ở phía bên phải của phương trình. Chúng tôi đưa vector linelist$gender một cách độc lập và có ý nghĩa thống kê (lưu ý rằng nó không được bao gồm trong select()).\n\n\nmap() trả về một danh sách, vì vậy đầu ra là một danh sách các kết quả t-test - một danh sách phần tử cho mỗi cột số được phân tích.\n\n# Results are saved as a list\nt.test_results &lt;- linelist %&gt;% \n  select(age, wt_kg, ht_cm, ct_blood, temp) %&gt;%  # keep only some numeric columns to map across\n  map(.f = ~t.test(.x ~ linelist$gender))        # t.test function, with equation NUMERIC ~ CATEGORICAL\n\nĐây là danh sách t.test_results trông như thế nào khi được mở (Cửa sổ Viewer) trong RStudio. Chúng tôi đã đánh dấu các phần quan trọng đối với các ví dụ trong trang này.\n\nỞ trên cùng, bạn có thể thấy toàn bộ danh sách được đặt tên là t.test_results và có năm phần tử. Năm phần tử đó được đặt tên là age, wt_km, ht_cm, ct_blood, temp theo mỗi biến được sử dụng trong t-test với gender từ linelist.\n\nMỗi phần tử trong số năm phần tử đó đều là danh sách, với các phần tử bên trong chúng, chẳng hạn như p.value và conf.int. Một số phần tử như p.value là các số đơn lẻ, trong khi một số phần tử như estimate bao gồm hai hoặc nhiều phần tử (mean in group f và mean in group m).\n\n\n\n\n\n\n\n\n\n\nLưu ý: Hãy nhớ rằng nếu bạn chỉ muốn áp dụng một hàm cho một số cột nhất định trong data frame, bạn cũng có thể chỉ cần sử dụng mutate() và across(), như được giải thích trong chương Làm sạch số liệu và các hàm quan trọng. Dưới đây là một ví dụ về việc áp dụng as.character() cho chỉ các cột “age”. Lưu ý vị trí của dấu ngoặc đơn và dấu phẩy.\n\n# convert columns with column name containing \"age\" to class Character\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = contains(\"age\"), .fns = as.character))  \n\n\n\nTrích xuất từ danh sách\nKhi map() tạo ra một đầu ra của lớp danh sách, chúng ta sẽ dành một chút thời gian thảo luận về cách trích xuất dữ liệu từ danh sách bằng cách sử dụng các hàm purrr đi kèm. Để minh họa điều này, chúng tôi sẽ sử dụng danh sách t.test_results từ phần trước. Đây là danh sách gồm 5 danh sách - mỗi danh sách trong số 5 danh sách chứa kết quả của t-test giữa một cột từ data frame linelist và cột nhị phân gender của nó. Xem hình ảnh trong phần trên để có hình ảnh về cấu trúc danh sách.\n\nTên của các phần tử\nĐể trích xuất tên của chính các phần tử, chỉ cần sử dụng names() từ base R. Trong trường hợp này, chúng tôi sử dụng names() trên t.test_results để trả về tên của mỗi danh sách con, là tên của 5 biến đã thực hiện t-tests.\n\nnames(t.test_results)\n\n[1] \"age\"      \"wt_kg\"    \"ht_cm\"    \"ct_blood\" \"temp\"    \n\n\n\n\nCác phần tử theo tên hoặc vị trí\nĐể trích xuất các phần tử danh sách theo tên hoặc theo vị trí, bạn có thể sử dụng dấu ngoặc [[ ]] như được mô tả trong chương R cơ bản. Dưới đây chúng tôi sử dụng dấu ngoặc kép để lập chỉ mục danh sách t.tests_results và hiển thị phần tử đầu tiên là kết quả của t-test trên age.\n\nt.test_results[[1]] # first element by position\n\n\n    Welch Two Sample t-test\n\ndata:  .x by linelist$gender\nt = -21.3, df = 4902.9, p-value &lt; 2.2e-16\nalternative hypothesis: true difference in means between group f and group m is not equal to 0\n95 percent confidence interval:\n -7.544409 -6.272675\nsample estimates:\nmean in group f mean in group m \n       12.66085        19.56939 \n\nt.test_results[[1]][\"p.value\"] # return element named \"p.value\" from first element  \n\n$p.value\n[1] 2.350374e-96\n\n\nTuy nhiên, dưới đây chúng tôi sẽ trình bày việc sử dụng các hàm map() và pluck() của purrr đơn giản và linh hoạt để đạt được kết quả tương tự.\n\n\npluck()\npluck() kéo ra các phần tử theo tên hoặc theo vị trí. Ví dụ - để trích xuất kết quả t-test cho độ tuổi, bạn có thể sử dụng pluck() như thế này:\n\nt.test_results %&gt;% \n  pluck(\"age\")        # alternatively, use pluck(1)\n\n\n    Welch Two Sample t-test\n\ndata:  .x by linelist$gender\nt = -21.3, df = 4902.9, p-value &lt; 2.2e-16\nalternative hypothesis: true difference in means between group f and group m is not equal to 0\n95 percent confidence interval:\n -7.544409 -6.272675\nsample estimates:\nmean in group f mean in group m \n       12.66085        19.56939 \n\n\nLập chỉ mục các cấp độ sâu hơn bằng cách chỉ định các cấp độ cao hơn bằng dấu phẩy. Dưới đây trích xuất phần tử có tên “p.value” từ danh sách age trong danh sách t.test_results. Bạn cũng có thể sử dụng số thay vì tên ký tự.\n\nt.test_results %&gt;% \n  pluck(\"age\", \"p.value\")\n\n[1] 2.350374e-96\n\n\nBạn có thể trích xuất các phần tử bên trong như vậy từ tất cả các phần tử cấp một bằng cách sử dụng map() để chạy hàm pluck() trên từng phần tử cấp một. Ví dụ, đoạn mã dưới đây trích xuất các phần tử “p.value” từ tất cả các danh sách trong t.test_results. Danh sách các kết quả t-test là .x được lặp qua,pluck() là hàm .f đang được lặp và giá trị “p-value” được cung cấp cho hàm.\n\nt.test_results %&gt;%\n  map(pluck, \"p.value\")   # return every p-value\n\n$age\n[1] 2.350374e-96\n\n$wt_kg\n[1] 2.664367e-182\n\n$ht_cm\n[1] 3.515713e-144\n\n$ct_blood\n[1] 0.4473498\n\n$temp\n[1] 0.5735923\n\n\nMột cách thay thế khác là map() viết tắt tên phần tử trong dấu ngoặc kép và nó sẽ ngắt nó ra. Nếu bạn sử dụng map(), đầu ra sẽ là một danh sách, trong khi nếu bạn sử dụng map_chr() thì nó sẽ là một vectơ ký tự được đặt tên và nếu bạn sử dụng map_dbl() nó sẽ là một vector số được đặt tên.\n\nt.test_results %&gt;% \n  map_dbl(\"p.value\")   # return p-values as a named numeric vector\n\n          age         wt_kg         ht_cm      ct_blood          temp \n 2.350374e-96 2.664367e-182 3.515713e-144  4.473498e-01  5.735923e-01 \n\n\nBạn có thể đọc thêm về pluck() trong tài liệu về purrr. Nó có một hàm tương tự là chuck() sẽ trả về lỗi thay vì NULL nếu một phần tử không tồn tại.\n\n\n\nChuyển đổi danh sách thành data frame\nĐây là một nội dung phức tạp - hãy xem phần Tài nguyên học liệu để có các hướng dẫn đầy đủ hơn. Tuy nhiên, chúng tôi sẽ minh họa việc chuyển đổi danh sách các kết quả t-test thành một data frame. Chúng tôi sẽ tạo một data frame với các cột cho biến, p-value của nó và giá trị trung bình từ hai nhóm (nam và nữ).\nDưới đây là một số phương pháp và hàm mới sẽ được sử dụng:\n\nHàm tibble() sẽ được sử dụng để tạo một tibble (giống như một data frame)\n\nChúng tôi bao quanh hàm tibble() bằng dấu ngoặc nhọn { } để ngăn toàn bộ t.test_results được lưu trữ dưới dạng cột nhỏ đầu tiên\n\n\nTrong tibble(), mỗi cột được tạo một cách rõ ràng, tương tự như cú pháp của mutate():\n\nDấu . đại diện cho t.test_results\n\nĐể tạo một cột với các tên biến t-test (tên của mỗi phần tử danh sách), chúng tôi sử dụng names() như đã mô tả ở trên\n\nĐể tạo một cột với các p-values, chúng tôi sử dụng map_dbl() như được mô tả ở trên để kéo các phần tử p.value và chuyển đổi chúng thành một vector số\n\n\n\nt.test_results %&gt;% {\n  tibble(\n    variables = names(.),\n    p         = map_dbl(., \"p.value\"))\n  }\n\n# A tibble: 5 × 2\n  variables         p\n  &lt;chr&gt;         &lt;dbl&gt;\n1 age       2.35e- 96\n2 wt_kg     2.66e-182\n3 ht_cm     3.52e-144\n4 ct_blood  4.47e-  1\n5 temp      5.74e-  1\n\n\nNhưng bây giờ hãy thêm các cột chứa trung bình cho mỗi nhóm (nam và nữ).\nChúng tôi sẽ cần trích xuất phần tử estimate, nhưng điều này thực sự chứa hai phần tử bên trong nó (mean in group f và mean in group m). Vì vậy, nó không thể được đơn giản hóa thành một vector với map_chr() hoặc map_dbl(). Thay vào đó, chúng tôi sử dụng map(), được sử dụng trong tibble(), sẽ tạo một cột lớp danh sách trong tibble! Vâng, điều này là có thể!\n\nt.test_results %&gt;% \n  {tibble(\n    variables = names(.),\n    p = map_dbl(., \"p.value\"),\n    means = map(., \"estimate\"))}\n\n# A tibble: 5 × 3\n  variables         p means       \n  &lt;chr&gt;         &lt;dbl&gt; &lt;named list&gt;\n1 age       2.35e- 96 &lt;dbl [2]&gt;   \n2 wt_kg     2.66e-182 &lt;dbl [2]&gt;   \n3 ht_cm     3.52e-144 &lt;dbl [2]&gt;   \n4 ct_blood  4.47e-  1 &lt;dbl [2]&gt;   \n5 temp      5.74e-  1 &lt;dbl [2]&gt;   \n\n\nSau khi bạn có cột danh sách này, có một số hàm tidyr (một phần của tidyverse) giúp bạn “gỡ rối” hoặc “gỡ bỏ” các cột “danh sách lồng nhau” này. Đọc thêm về chúng tại đây hoặc bằng cách chạy vignette(\"rectangle\"). Tóm lại:\n\nunnest_wider() - đưa mỗi phần tử của mỗi danh sách cột một cột riêng của nó\n\nunnest_longer() - đưa mỗi phần tử của mỗi danh sách cột một hàng riêng của nó\n\nhoist() - hoạt động giống như unnest_wider() nhưng bạn chỉ định phần tử nào cần gỡ bỏ\n\nDưới đây, chúng tôi chuyển tibble sang unnest_wider() để chỉ định cột means của tibble (là một danh sách lồng nhau). Kết quả là means được thay thế bằng hai cột mới, mỗi cột phản ánh hai phần tử trước đó trong mỗi ô means.\n\nt.test_results %&gt;% \n  {tibble(\n    variables = names(.),\n    p = map_dbl(., \"p.value\"),\n    means = map(., \"estimate\")\n    )} %&gt;% \n  unnest_wider(means)\n\n# A tibble: 5 × 4\n  variables         p `mean in group f` `mean in group m`\n  &lt;chr&gt;         &lt;dbl&gt;             &lt;dbl&gt;             &lt;dbl&gt;\n1 age       2.35e- 96              12.7              19.6\n2 wt_kg     2.66e-182              45.8              59.6\n3 ht_cm     3.52e-144             109.              142. \n4 ct_blood  4.47e-  1              21.2              21.2\n5 temp      5.74e-  1              38.6              38.6\n\n\n\n\nLoại bỏ, giữ lại và thu gọn danh sách\nVì làm việc với purrr nên thường liên quan đến danh sách, chúng ta sẽ khám phá ngắn gọn một số hàm purrr để sửa đổi danh sách. Xem phần Tài nguyên học liệu để có hướng dẫn đầy đủ hơn về các hàm purrr.\n\nlist_modify() có nhiều cách sử dụng, một trong số đó có thể là xóa một phần tử danh sách\n\nkeep() giữ lại các phần tử được chỉ định cho .p = hoặc trong đó một hàm được cung cấp cho .p = đánh giá là TRUE\n\ndiscard() loại bỏ các phần tử được chỉ định cho .p hoặc trong đó một hàm được cung cấp cho .p = đánh giá là TRUE\n\ncompact() loại bỏ tất cả các phần tử trống\n\nDưới đây là một số ví dụ sử dụng danh sách combined được tạo trong phần trên về sử dụng map() để nhập và kết hợp nhiều tệp (nó chứa 6 trường hợp linelist thuộc data frames):\nCác phần tử có thể được xóa bằng tên với list_modify() và đặt tên bằng NULL.\n\ncombined %&gt;% \n  list_modify(\"Central Hospital\" = NULL)   # remove list element by name\n\nBạn cũng có thể loại bỏ các phần tử theo tiêu chí, bằng cách cung cấp phương trình “định trước” cho .p = (một phương trình đánh giá là TRUE hoặc FALSE). Đặt dấu ngã ~ trước hàm và sử dụng .x để đại diện cho phần tử danh sách. Sử dụng keep(), các phần tử danh sách đánh giá là TRUE sẽ được giữ lại. Ngược lại, nếu sử dụng discard(), các phần tử danh sách đánh giá là TRUE sẽ bị loại bỏ.\n\n# keep only list elements with more than 500 rows\ncombined %&gt;% \n  keep(.p = ~nrow(.x) &gt; 500)  \n\nTrong ví dụ dưới đây, các phần tử danh sách bị loại bỏ nếu lớp của chúng không phải là data frames.\n\n# Discard list elements that are not data frames\ncombined %&gt;% \n  discard(.p = ~class(.x) != \"data.frame\")\n\nHàm định trước của bạn cũng có thể tham chiếu các phần tử/cột trong mỗi mục danh sách. Ví dụ, bên dưới, liệt kê các phần tử có giá trị trung bình của cột ct_blood trên 25 sẽ bị loại bỏ.\n\n# keep only list elements where ct_blood column mean is over 25\ncombined %&gt;% \n  discard(.p = ~mean(.x$ct_blood) &gt; 25)  \n\nLệnh này sẽ xóa tất cả các phần tử danh sách trống:\n\n# Remove all empty list elements\ncombined %&gt;% \n  compact()\n\n\n\npmap()\nPHẦN NÀY ĐANG ĐƯỢC XÂY DỰNG",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Lặp, vòng lặp, và danh sách</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.vn.html#các-hàm-apply",
    "href": "new_pages/iteration.vn.html#các-hàm-apply",
    "title": "16  Lặp, vòng lặp, và danh sách",
    "section": "16.4 Các hàm apply",
    "text": "16.4 Các hàm apply\nNhóm hàm “apply” là một hàm R base thay thế cho purrr với các thao tác lặp lại. Bạn có thể đọc thêm về chúng tại đây.",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Lặp, vòng lặp, và danh sách</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.vn.html#tài-nguyên-học-liệu",
    "href": "new_pages/iteration.vn.html#tài-nguyên-học-liệu",
    "title": "16  Lặp, vòng lặp, và danh sách",
    "section": "16.5 Tài nguyên học liệu",
    "text": "16.5 Tài nguyên học liệu\nfor loops with Data Carpentry\nThe R for Data Science page on iteration\nVignette on write/read Excel files\nA purrr tutorial by jennybc\nAnother purrr tutorial by Rebecca Barter\nA purrr tutorial on map, pmap, and imap\npurrr cheatsheet\npurrr tips and tricks\nkeep and discard",
    "crumbs": [
      "Quản lý dữ liệu",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Lặp, vòng lặp, và danh sách</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.vn.html",
    "href": "new_pages/tables_descriptive.vn.html",
    "title": "17  Bảng mô tả",
    "section": "",
    "text": "17.1 Chuẩn bị",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Bảng mô tả</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.vn.html#chuẩn-bị",
    "href": "new_pages/tables_descriptive.vn.html#chuẩn-bị",
    "title": "17  Bảng mô tả",
    "section": "",
    "text": "Gọi packages\nĐoạn code này hiển thị việc gọi các packages cần thiết cho các phân tích. Trong sổ tay này, chúng tôi nhấn mạnh đến lệnh p_load() từ pacman, giúp cài đặt các package nếu cần và gọi chúng để sử dụng. Bạn cũng có thể gọi các package đã được cài đặt với library() từ base R. Xem chương R cơ bản để biết thêm thông tin về các package của R.\n\npacman::p_load(\n  rio,          # File import\n  here,         # File locator\n  skimr,        # get overview of data\n  tidyverse,    # data management + ggplot2 graphics \n  gtsummary,    # summary statistics and tests\n  rstatix,      # summary statistics and statistical tests\n  janitor,      # adding totals and percents to tables\n  scales,       # easily convert proportions to percents  \n  flextable     # converting tables to pretty images\n  )\n\n\n\nNhập dữ liệu\nChúng ta sẽ nhập bộ dữ liệu về các trường hợp từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn theo dõi, bấm để tải xuống dữ liệu linelist “đã làm sạch” (as .rds file). Nhập dữ liệu của bạn bằng hàm import() từ package rio (chấp nhận nhiều loại tệp như .xlsx, .rds, .csv - xem thêm chi tiết tại chương Nhập xuất dữ liệu).\n\n# import the linelist\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\n50 hàng đầu tiên của linelist được hiển thị như dưới đây.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Bảng mô tả</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.vn.html#duyệt-dữ-liệu",
    "href": "new_pages/tables_descriptive.vn.html#duyệt-dữ-liệu",
    "title": "17  Bảng mô tả",
    "section": "17.2 Duyệt dữ liệu",
    "text": "17.2 Duyệt dữ liệu\n\nskimr package\nKhi sử dụng package skimr package, bạn có thể có được cái nhìn tổng quan chi tiết và đẹp về mặt thẩm mỹ của từng biến trong tập dữ liệu của mình. Đọc thêm về skimr tại trang github của nhà phát triển.\nDưới đây, hàm skim() được áp dụng cho toàn bộ data frame linelist giúp bạn có cái nhìn tổng quan về data frame và tóm tắt của tất cả các cột (theo lớp).\n\n## get information about each variable in a dataset \nskim(linelist)\n\n\n\n\nData summary\n\n\nName\nlinelist\n\n\nNumber of rows\n5888\n\n\nNumber of columns\n30\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n13\n\n\nDate\n4\n\n\nfactor\n2\n\n\nnumeric\n11\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\ncase_id\n0\n1.00\n6\n6\n0\n5888\n0\n\n\noutcome\n1323\n0.78\n5\n7\n0\n2\n0\n\n\ngender\n278\n0.95\n1\n1\n0\n2\n0\n\n\nage_unit\n0\n1.00\n5\n6\n0\n2\n0\n\n\nhospital\n0\n1.00\n5\n36\n0\n6\n0\n\n\ninfector\n2088\n0.65\n6\n6\n0\n2697\n0\n\n\nsource\n2088\n0.65\n5\n7\n0\n2\n0\n\n\nfever\n249\n0.96\n2\n3\n0\n2\n0\n\n\nchills\n249\n0.96\n2\n3\n0\n2\n0\n\n\ncough\n249\n0.96\n2\n3\n0\n2\n0\n\n\naches\n249\n0.96\n2\n3\n0\n2\n0\n\n\nvomit\n249\n0.96\n2\n3\n0\n2\n0\n\n\ntime_admission\n765\n0.87\n5\n5\n0\n1072\n0\n\n\n\nVariable type: Date\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nmedian\nn_unique\n\n\n\n\ndate_infection\n2087\n0.65\n2014-03-19\n2015-04-27\n2014-10-11\n359\n\n\ndate_onset\n256\n0.96\n2014-04-07\n2015-04-30\n2014-10-23\n367\n\n\ndate_hospitalisation\n0\n1.00\n2014-04-17\n2015-04-30\n2014-10-23\n363\n\n\ndate_outcome\n936\n0.84\n2014-04-19\n2015-06-04\n2014-11-01\n371\n\n\n\nVariable type: factor\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nordered\nn_unique\ntop_counts\n\n\n\n\nage_cat\n86\n0.99\nFALSE\n8\n0-4: 1095, 5-9: 1095, 20-: 1073, 10-: 941\n\n\nage_cat5\n86\n0.99\nFALSE\n17\n0-4: 1095, 5-9: 1095, 10-: 941, 15-: 743\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\n\n\n\n\ngeneration\n0\n1.00\n16.56\n5.79\n0.00\n13.00\n16.00\n20.00\n37.00\n\n\nage\n86\n0.99\n16.07\n12.62\n0.00\n6.00\n13.00\n23.00\n84.00\n\n\nage_years\n86\n0.99\n16.02\n12.64\n0.00\n6.00\n13.00\n23.00\n84.00\n\n\nlon\n0\n1.00\n-13.23\n0.02\n-13.27\n-13.25\n-13.23\n-13.22\n-13.21\n\n\nlat\n0\n1.00\n8.47\n0.01\n8.45\n8.46\n8.47\n8.48\n8.49\n\n\nwt_kg\n0\n1.00\n52.64\n18.58\n-11.00\n41.00\n54.00\n66.00\n111.00\n\n\nht_cm\n0\n1.00\n124.96\n49.52\n4.00\n91.00\n129.00\n159.00\n295.00\n\n\nct_blood\n0\n1.00\n21.21\n1.69\n16.00\n20.00\n22.00\n22.00\n26.00\n\n\ntemp\n149\n0.97\n38.56\n0.98\n35.20\n38.20\n38.80\n39.20\n40.80\n\n\nbmi\n0\n1.00\n46.89\n55.39\n-1200.00\n24.56\n32.12\n50.01\n1250.00\n\n\ndays_onset_hosp\n256\n0.96\n2.06\n2.26\n0.00\n1.00\n1.00\n3.00\n22.00\n\n\n\n\n\nBạn cũng có thể sử dụng hàm summary() từ base R, để lấy thông tin về toàn bộ tập dữ liệu, nhưng kết quả đầu ra có thể khó đọc hơn so với sử dụng skimr. Do đó, kết quả không được hiển thị bên dưới để tiết kiệm không gian trang.\n\n## get information about each column in a dataset \nsummary(linelist)\n\n\n\nThống kê tóm tắt\nBạn có thể sử dụng các hàm base R để trả về thống kê tóm tắt trên một cột dữ liệu dạng số. Bạn có thể trả về hầu hết các thống kê tóm tắt hữu ích cho một cột dạng số bằng cách sử dụng hàm summary(), như dưới đây. Lưu ý rằng tên data frame cũng phải được xác định như hình dưới đây.\n\nsummary(linelist$age_years)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00    6.00   13.00   16.02   23.00   84.00      86 \n\n\nBạn có thể truy cập và lưu một phần cụ thể của nó bằng dấu ngoặc vuông [ ]:\n\nsummary(linelist$age_years)[[2]]            # return only the 2nd element\n\n[1] 6\n\n# equivalent, alternative to above by element name\n# summary(linelist$age_years)[[\"1st Qu.\"]]  \n\nBạn có thể trả về các thống kê riêng lẻ với các hàm base R như max(), min(), median(), mean(), quantile(), sd(), và range(). Xem chương R cơ bản để có danh sách đầy đủ.\nTHẬN TRỌNG: Nếu dữ liệu của bạn chứa các giá trị missing, R muốn bạn biết điều này và do đó sẽ trả về NA trừ khi bạn chỉ định cho các hàm toán học ở trên mà bạn muốn R bỏ qua các giá trị bị thiếu, thông qua đối số na.rm = TRUE.\nBạn có thể sử dụng hàm get_summary_stats() từ package rstatix để trả về thống kê tóm tắt ở định dạng data frame. Điều này có thể hữu ích cho việc thực hiện các hoạt động tiếp theo hoặc vẽ biểu đồ trên các con số. Xem chương Các kiểm định thống kê cơ bản để biết thêm chi tiết về package rstatix và các hàm của nó.\n\nlinelist %&gt;% \n  get_summary_stats(\n    age, wt_kg, ht_cm, ct_blood, temp,  # columns to calculate for\n    type = \"common\")                    # summary stats to return\n\n# A tibble: 5 × 10\n  variable     n   min   max median   iqr  mean     sd    se    ci\n  &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 age       5802   0    84     13      17  16.1 12.6   0.166 0.325\n2 wt_kg     5888 -11   111     54      25  52.6 18.6   0.242 0.475\n3 ht_cm     5888   4   295    129      68 125.  49.5   0.645 1.26 \n4 ct_blood  5888  16    26     22       2  21.2  1.69  0.022 0.043\n5 temp      5739  35.2  40.8   38.8     1  38.6  0.977 0.013 0.025",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Bảng mô tả</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.vn.html#tbl_janitor",
    "href": "new_pages/tables_descriptive.vn.html#tbl_janitor",
    "title": "17  Bảng mô tả",
    "section": "17.3 janitor package",
    "text": "17.3 janitor package\nPackage janitor cung cấp hàm tabyl() giúp tạo ra các bảng đơn và bảng chéo, có thể được “tô điểm” hoặc sửa đổi bằng các hàm trợ giúp để hiển thị phần trăm, tỷ lệ, số đếm, v.v.\nSau đây, chúng ta sẽ pipe linelist data frame tới các hàm của janitor và in kết quả. Nếu muốn, bạn cũng có thể lưu các bảng kết quả bằng toán tử gán &lt;-.\n\ntabyl đơn giản\nCách sử dụng mặc định của hàm tabyl() trên một cột cụ thể tạo ra các giá trị duy nhất, số lượng và “phần trăm” (tỷ lệ thực tế) theo cột. Tỷ lệ có thể có nhiều chữ số thập phân. Bạn có thể điều chỉnh số lượng số thập phân với hàm adorn_rounding() như được mô tả bên dưới.\n\nlinelist %&gt;% tabyl(age_cat)\n\n age_cat    n     percent valid_percent\n     0-4 1095 0.185971467   0.188728025\n     5-9 1095 0.185971467   0.188728025\n   10-14  941 0.159816576   0.162185453\n   15-19  743 0.126188859   0.128059290\n   20-29 1073 0.182235054   0.184936229\n   30-49  754 0.128057065   0.129955188\n   50-69   95 0.016134511   0.016373664\n     70+    6 0.001019022   0.001034126\n    &lt;NA&gt;   86 0.014605978            NA\n\n\nNhư bạn có thể thấy ở trên, các giá trị missing sẽ được hiển thị trong một hàng có nhãn &lt;NA&gt;. Bạn có thể ngăn điều này bằng cách thêm show_na = FALSE. Nếu không có giá trị missing, hàng này sẽ không xuất hiện. Nếu có giá trị missing, tất cả các tỷ lệ sẽ được trình bày dưới dạng thô (mẫu số bao gồm cả NA) và “hợp lý” (mẫu số không bao gồm NA).\nNếu giá trị cột là dạng Factor và chỉ một vài level nhất định có trong dữ liệu của bạn, thì tất cả các level sẽ vẫn xuất hiện trong bảng. Bạn có thể loại bỏ tính năng này bằng cách thêm show_missing_levels = FALSE. Đọc thêm trong chương Factors.\n\n\nBảng chéo\nBảng chéo được tạo bằng cách thêm một hoặc nhiều cột vào hàm tabyl(). Lưu ý rằng bây giờ chỉ có số lượng được hiện thị - tỷ lệ và phần trăm có thể được thêm vào bằng các bước bổ sung sẽ được trình bày bên dưới.\n\nlinelist %&gt;% tabyl(age_cat, gender)\n\n age_cat   f   m NA_\n     0-4 640 416  39\n     5-9 641 412  42\n   10-14 518 383  40\n   15-19 359 364  20\n   20-29 468 575  30\n   30-49 179 557  18\n   50-69   2  91   2\n     70+   0   5   1\n    &lt;NA&gt;   0   0  86\n\n\n\n\n“Tô điểm” cho tabyl\nSử dụng các hàm “tô điểm” của janitor để thêm tổng hoặc chuyển đổi thành tỷ lệ, phần trăm hoặc điều chỉnh hiển thị. Thông thường, bạn sẽ pipe tabyl thông qua một số hàm này..\n\n\n\n\n\n\n\nHàm\nĐầu ra\n\n\n\n\nadorn_totals()\nThêm tổng (where = “row”, “col”, or “both”). Đặt name = cho “Tổng”.\n\n\nadorn_percentages()\nChuyển đổi số lượng thành tỷ lệ, với denominator = “row”, “col”, hoặc “all”\n\n\nadorn_pct_formatting()\nChuyển đổi tỷ lệ thành tỷ lệ phần trăm. Chỉ rõ digits =. Loại bỏ ký hiệu “%” bằng affix_sign = FALSE.\n\n\nadorn_rounding()\nLàm tròn tỷ lệ bằng digits =. Để làm tròn tỷ lệ phần trăm, sử dụng hàm adorn_pct_formatting() với digits =.\n\n\nadorn_ns()\nThêm số lượng vào bảng tỷ lệ hoặc phần trăm. Chỉ định position = “rear” để hiện thị số lượng trong ngoặc đơn, hoặc “front” để đặt phần trăm vào trong ngoặc đơn.\n\n\nadorn_title()\nThêm tiều đề thông qua đối số row_name = và/hoặc col_name =\n\n\n\nHãy cẩn trọng về thứ tự bạn áp dụng các hàm trên. Dưới đây là một số ví dụ.\nBảng một chiều đơn giản với phần trăm thay vì tỷ lệ mặc định.\n\nlinelist %&gt;%               # case linelist\n  tabyl(age_cat) %&gt;%       # tabulate counts and proportions by age category\n  adorn_pct_formatting()   # convert proportions to percents\n\n age_cat    n percent valid_percent\n     0-4 1095   18.6%         18.9%\n     5-9 1095   18.6%         18.9%\n   10-14  941   16.0%         16.2%\n   15-19  743   12.6%         12.8%\n   20-29 1073   18.2%         18.5%\n   30-49  754   12.8%         13.0%\n   50-69   95    1.6%          1.6%\n     70+    6    0.1%          0.1%\n    &lt;NA&gt;   86    1.5%             -\n\n\nBảng chéo với tổng hàng và phần trăm hàng.\n\nlinelist %&gt;%                                  \n  tabyl(age_cat, gender) %&gt;%                  # counts by age and gender\n  adorn_totals(where = \"row\") %&gt;%             # add total row\n  adorn_percentages(denominator = \"row\") %&gt;%  # convert counts to proportions\n  adorn_pct_formatting(digits = 1)            # convert proportions to percents\n\n age_cat     f     m    NA_\n     0-4 58.4% 38.0%   3.6%\n     5-9 58.5% 37.6%   3.8%\n   10-14 55.0% 40.7%   4.3%\n   15-19 48.3% 49.0%   2.7%\n   20-29 43.6% 53.6%   2.8%\n   30-49 23.7% 73.9%   2.4%\n   50-69  2.1% 95.8%   2.1%\n     70+  0.0% 83.3%  16.7%\n    &lt;NA&gt;  0.0%  0.0% 100.0%\n   Total 47.7% 47.6%   4.7%\n\n\nBảng chéo được điều chỉnh để cả số lượng và phần trăm đều được hiển thị.\n\nlinelist %&gt;%                                  # case linelist\n  tabyl(age_cat, gender) %&gt;%                  # cross-tabulate counts\n  adorn_totals(where = \"row\") %&gt;%             # add a total row\n  adorn_percentages(denominator = \"col\") %&gt;%  # convert to proportions\n  adorn_pct_formatting() %&gt;%                  # convert to percents\n  adorn_ns(position = \"front\") %&gt;%            # display as: \"count (percent)\"\n  adorn_title(                                # adjust titles\n    row_name = \"Age Category\",\n    col_name = \"Gender\")\n\n                      Gender                            \n Age Category              f              m          NA_\n          0-4   640  (22.8%)   416  (14.8%)  39  (14.0%)\n          5-9   641  (22.8%)   412  (14.7%)  42  (15.1%)\n        10-14   518  (18.5%)   383  (13.7%)  40  (14.4%)\n        15-19   359  (12.8%)   364  (13.0%)  20   (7.2%)\n        20-29   468  (16.7%)   575  (20.5%)  30  (10.8%)\n        30-49   179   (6.4%)   557  (19.9%)  18   (6.5%)\n        50-69     2   (0.1%)    91   (3.2%)   2   (0.7%)\n          70+     0   (0.0%)     5   (0.2%)   1   (0.4%)\n         &lt;NA&gt;     0   (0.0%)     0   (0.0%)  86  (30.9%)\n        Total 2,807 (100.0%) 2,803 (100.0%) 278 (100.0%)\n\n\n\n\nIn với tabyl\nTheo mặc định, lệnh tabyl sẽ in kết quả thô vào R console của bạn.\nNgoài ra, bạn có thể chuyển tabyl sang flextable hoặc package tương tự để in dưới dạng hình ảnh “đẹp” trong RStudio Viewer, có thể được xuất dưới dạng .png, .jpeg, .html, v.v. Điều này đã được thảo luận trong chương Trình bày bảng . Lưu ý rằng nếu in theo cách này và sử dụng adorn_titles(), bạn cần thêm vào placement = \"combined\".\n\nlinelist %&gt;%\n  tabyl(age_cat, gender) %&gt;% \n  adorn_totals(where = \"col\") %&gt;% \n  adorn_percentages(denominator = \"col\") %&gt;% \n  adorn_pct_formatting() %&gt;% \n  adorn_ns(position = \"front\") %&gt;% \n  adorn_title(\n    row_name = \"Age Category\",\n    col_name = \"Gender\",\n    placement = \"combined\") %&gt;% # this is necessary to print as image\n  flextable::flextable() %&gt;%    # convert to pretty image\n  flextable::autofit()          # format to one line per row \n\nAge Category/GenderfmNA_Total0-4640 (22.8%)416 (14.8%)39 (14.0%)1,095 (18.6%)5-9641 (22.8%)412 (14.7%)42 (15.1%)1,095 (18.6%)10-14518 (18.5%)383 (13.7%)40 (14.4%)941 (16.0%)15-19359 (12.8%)364 (13.0%)20  (7.2%)743 (12.6%)20-29468 (16.7%)575 (20.5%)30 (10.8%)1,073 (18.2%)30-49179  (6.4%)557 (19.9%)18  (6.5%)754 (12.8%)50-692  (0.1%)91  (3.2%)2  (0.7%)95  (1.6%)70+0  (0.0%)5  (0.2%)1  (0.4%)6  (0.1%)0  (0.0%)0  (0.0%)86 (30.9%)86  (1.5%)\n\n\n\n\nSử dụng trên các bảng khác\nBạn có thể sử dụng các hàmadorn_*() của janitor lên các bảng khác, chẳng hạn các bảng được tạo bởi hàm summarise() và count() của dplyr, hoặc table() từ base R. Đơn giản chỉ cần pipe bảng đến hàm mong muốn của package janitor. Ví dụ:\n\nlinelist %&gt;% \n  count(hospital) %&gt;%   # dplyr function\n  adorn_totals()        # janitor function\n\n                             hospital    n\n                     Central Hospital  454\n                    Military Hospital  896\n                              Missing 1469\n                                Other  885\n                        Port Hospital 1762\n St. Mark's Maternity Hospital (SMMH)  422\n                                Total 5888\n\n\n\n\nLưu với tabyl\nNếu bạn muốn chuyển đổi bảng thành một hình ảnh “đẹp” với package flextable, bạn có thể lưu nó bằng các hàm như save_as_html(), save_as_word(), save_as_ppt(), và save_as_image() từ package flextable (sẽ được bàn luận kỹ hơn ở chương Trình bày bảng). Ví dụ dưới đây, bảng được lưu lại dưới dạng tệp Word, và có khả năng chỉnh sửa được.\n\nlinelist %&gt;%\n  tabyl(age_cat, gender) %&gt;% \n  adorn_totals(where = \"col\") %&gt;% \n  adorn_percentages(denominator = \"col\") %&gt;% \n  adorn_pct_formatting() %&gt;% \n  adorn_ns(position = \"front\") %&gt;% \n  adorn_title(\n    row_name = \"Age Category\",\n    col_name = \"Gender\",\n    placement = \"combined\") %&gt;% \n  flextable::flextable() %&gt;%                     # convert to image\n  flextable::autofit() %&gt;%                       # ensure only one line per row\n  flextable::save_as_docx(path = \"tabyl.docx\")   # save as Word document to filepath\n\n\n\n\n\n\n\n\n\n\n\n\nThống kê\nBạn có thể áp dụng các kiểm định thống kê bằng tabyls, ví dụ như chisq.test() hoặc fisher.test() từ package stats, như được trình bày dưới đây. Chú ý là giá trị missing không được cho phép vì vậy chúng được loại bỏ khỏi tabyl bằng tùy chọn show_na = FALSE.\n\nage_by_outcome &lt;- linelist %&gt;% \n  tabyl(age_cat, outcome, show_na = FALSE) \n\nchisq.test(age_by_outcome)\n\n\n    Pearson's Chi-squared test\n\ndata:  age_by_outcome\nX-squared = 6.4931, df = 7, p-value = 0.4835\n\n\nXem chương Các kiểm định thống kê cơ bản để có thêm code và các mẹo liên quan đến thống kê.\n\n\nCác mẹo khác\n\nThêm đối số na.rm = TRUE để loại bỏ các giá trị missing.\n\nNếu áp dụng bất kỳ hàm trợ giúp adorn_*() nào cho các bảng không được tạo bởi tabyl(), bạn có thể chỉ định (các) cột cụ thể để áp dụng chúng chẳng hạn như adorn_percentage(,,,c(cases,deaths)) (chỉ định chúng cho đối số không tên thứ 4). Thay vào đó, hãy cân nhắc sử dụng hàm summarise().\n\nBạn có thể tìm đọc thêm ở janitor page và tabyl vignette.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Bảng mô tả</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.vn.html#dplyr-package",
    "href": "new_pages/tables_descriptive.vn.html#dplyr-package",
    "title": "17  Bảng mô tả",
    "section": "17.4 dplyr package",
    "text": "17.4 dplyr package\ndplyr là một phần của package tidyverse và là một công cụ quản lý dữ liệu rất phổ biến. Tạo bảng với các hàm của dplyr như summarise() và count() là một cách tiếp cận hữu ích để tính toán các tóm tắt thống kê, tổng hợp theo nhóm, hoặc chuyển bảng tới ggplot().\nsummarise() tạo một data frame tổng hợp mới. Nếu dữ liệu được tách nhóm, nó sẽ trả về data frame có một hàng với thống kê tóm tắt được chỉ định cho toàn bộ data frame. Nếu dữ liệu được nhóm lại, data frames sẽ có một hàng cho từng nhóm (xem chương Nhóm dữ liệu).\nBên trong dấu ngoặc đơn của hàm summarise(), bạn sẽ cung cấp tên của từng cột cần tổng hợp mới, theo sau là dấu bằng và một hàm thống kê để áp dụng.\nMẸO: Hàm summarise hoạt động được với cả cách viết Anh-Anh và Anh-Mỹ (summarise() và summarize()).\n\nLấy số lượng\nHàm đơn giản nhất để áp dụng cùng với hàm summarise() là n(). Để trống dấu ngoặc đơn để đếm số hàng.\n\nlinelist %&gt;%                 # begin with linelist\n  summarise(n_rows = n())    # return new summary dataframe with column n_rows\n\n  n_rows\n1   5888\n\n\nĐiều này sẽ thú vị hơn nếu chúng ta đã nhóm dữ liệu trước đó.\n\nlinelist %&gt;% \n  group_by(age_cat) %&gt;%     # group data by unique values in column age_cat\n  summarise(n_rows = n())   # return number of rows *per group*\n\n# A tibble: 9 × 2\n  age_cat n_rows\n  &lt;fct&gt;    &lt;int&gt;\n1 0-4       1095\n2 5-9       1095\n3 10-14      941\n4 15-19      743\n5 20-29     1073\n6 30-49      754\n7 50-69       95\n8 70+          6\n9 &lt;NA&gt;        86\n\n\nLệnh trên có thể được rút ngắn bằng cách sử dụng hàmcount() thay thế. count() làm những việc sau:\n\nNhóm dữ liệu theo các cột được cung cấp cho nó\n\nTổng hợp chúng với n() (tạo cột n)\n\nTách nhóm dữ liệu\n\n\nlinelist %&gt;% \n  count(age_cat)\n\n  age_cat    n\n1     0-4 1095\n2     5-9 1095\n3   10-14  941\n4   15-19  743\n5   20-29 1073\n6   30-49  754\n7   50-69   95\n8     70+    6\n9    &lt;NA&gt;   86\n\n\nBạn có thể thay đổi tên của cột đếm từ mặc định là n thành một cái gì đó cụ thể chẳng hạn như name =.\nTạo bảng đếm cho hai hoặc nhiều cột sẽ vẫn trả về địng dạng “dọc”, với số lượng ở cột n. Xem chương Pivoting dữ liệu để hiểu thêm về định dạng dữ liệu “dọc” và “ngang”.\n\nlinelist %&gt;% \n  count(age_cat, outcome)\n\n   age_cat outcome   n\n1      0-4   Death 471\n2      0-4 Recover 364\n3      0-4    &lt;NA&gt; 260\n4      5-9   Death 476\n5      5-9 Recover 391\n6      5-9    &lt;NA&gt; 228\n7    10-14   Death 438\n8    10-14 Recover 303\n9    10-14    &lt;NA&gt; 200\n10   15-19   Death 323\n11   15-19 Recover 251\n12   15-19    &lt;NA&gt; 169\n13   20-29   Death 477\n14   20-29 Recover 367\n15   20-29    &lt;NA&gt; 229\n16   30-49   Death 329\n17   30-49 Recover 238\n18   30-49    &lt;NA&gt; 187\n19   50-69   Death  33\n20   50-69 Recover  38\n21   50-69    &lt;NA&gt;  24\n22     70+   Death   3\n23     70+ Recover   3\n24    &lt;NA&gt;   Death  32\n25    &lt;NA&gt; Recover  28\n26    &lt;NA&gt;    &lt;NA&gt;  26\n\n\n\n\nHiện tất cả các cấp độ\nNếu bạn tạo bảng cho một cột có kiểu dữ liệu là factor, bạn có thể chắc chắng rằng tất cả các cấp độ được trình bày (không chỉ các cấp có giá trị trong dữ liệu) bằng cách thêm .drop = FALSE vào lệnh summarise() hoặc count().\nKỹ thuật này rất hữu ích để chuẩn hóa các bảng/biểu đồ của bạn. Ví dụ: nếu bạn đang tạo số liệu cho nhiều nhóm con, hoặc liên tục tạo số liệu cho các báo cáo thường quy. Trong các trường hợp này, sự hiện diện của các giá trị trong dữ liệu có thể dao động, nhưng bạn có thể xác định các mức không đổi.\nXem chương Factors để có nhiều thông tin hơn.\n\n\nTỷ lệ\nTỷ lệ có thể được thêm vào bằng cách piping bảng tới hàm mutate() để tạo một cột mới. Định nghĩa cột mới là thương của số quan sát của từng yếu tố (mặc định là n) và tổng số quan sát sum() của cột (sẽ trả về giá trị là một tỷ lệ).\nLưu ý trong trường hợp này, sum() trong lệnh mutate() sẽ trả về giá trị của toàn bộ cột n để dùng làm mẫu số của tỷ lệ. Như đã được giải thích trong chương Nhóm dữ liệu, nếu sum() được sử dụng với dữ liệu đã được nhóm (vd: nếu hàm mutate() được theo ngay phía sai hàm group_by()), nó sẽ trả về kết quả tổng hợp theo nhóm. Như đã nếu ở trên, count() hoàn thành nhiệm vụ của mình bằng cách tách nhóm. Vì vậy, trong trường hợp này chúng ta sẽ lấy toàn bộ tỷ lệ của cột.\nĐể dễ dàng hiển thị phần trăm, bạn có thể đưa tỷ lệ vào trong hàm percent() từ package scales (lưu ý là điều nãy sẽ chuyển kết quả thành dạng ký tự (character)).\n\nage_summary &lt;- linelist %&gt;% \n  count(age_cat) %&gt;%                     # group and count by gender (produces \"n\" column)\n  mutate(                                # create percent of column - note the denominator\n    percent = scales::percent(n / sum(n))) \n\n# print\nage_summary\n\n  age_cat    n percent\n1     0-4 1095  18.60%\n2     5-9 1095  18.60%\n3   10-14  941  15.98%\n4   15-19  743  12.62%\n5   20-29 1073  18.22%\n6   30-49  754  12.81%\n7   50-69   95   1.61%\n8     70+    6   0.10%\n9    &lt;NA&gt;   86   1.46%\n\n\nDưới đây là phương pháp tính tỷ lệ trong nhóm. Nó dựa trên các cấp độ nhóm dữ liệu khác nhau được áp dụng và loại bỏ một cách có chọn lọc. Đầu tiên, dữ liệu được nhóm theo outcome thông qua hàm group_by(). Sau đó, hàm count() được áp dụng. Hàm này sẽ tiếp tục nhóm dữ liệu phân theo age_cat và trả vế số lượng theo từng tổ hợp outcome-age-cat. Quan trọng là - khi nó kết thúc quy trình của mình, hàm count() sẽ tách nhóm theo age_cat, nên nhóm dữ liệu duy nhất còn lại là nhóm ban đầu theo outcome. Do đó, bước cuối cùng để tính toán tỷ lệ (mẫu số là sum(n)) vẫn được nhóm theo outcome.\n\nage_by_outcome &lt;- linelist %&gt;%                  # begin with linelist\n  group_by(outcome) %&gt;%                         # group by outcome \n  count(age_cat) %&gt;%                            # group and count by age_cat, and then remove age_cat grouping\n  mutate(percent = scales::percent(n / sum(n))) # calculate percent - note the denominator is by outcome group\n\n\n\n\n\n\n\n\n\nVẽ biểu đồ\nĐể hiển thị kết quả từ một bảng “dài” như trên thì vẽ biểu đồ bằng hàm ggplot() tương đối trực quan. Dữ liệu một cách tự nhiên có định dạng “dọc”, nên tương thích với ggplot() một cách tự nhiên. Xem thêm các ví dụ ở chương ggplot cơ bản và Các mẹo với ggplot.\n\nlinelist %&gt;%                      # begin with linelist\n  count(age_cat, outcome) %&gt;%     # group and tabulate counts by two columns\n  ggplot()+                       # pass new data frame to ggplot\n    geom_col(                     # create bar plot\n      mapping = aes(   \n        x = outcome,              # map outcome to x-axis\n        fill = age_cat,           # map age_cat to the fill\n        y = n))                   # map the counts column `n` to the height\n\n\n\n\n\n\n\n\n\n\nTổng hợp thống kê\nMột điểm mạnh của dplyr và summarise() là khả năng trả về các bảng tổng hợp thống kê nâng cao hơn như median(), mean(), max(), min(), sd() (độ lệch chuẩn), và phân vị. Bạn cũng có thể sử dụng sum() để trả vể số lượng dòng thỏa mãn một điều kiện logic nào đó. Như trên, các kết quả đầu ra này có thể được tạo cho toàn bộ data frame hoặc theo nhóm.\nCú pháp là tương tự- bên trong dấu ngoặc hàm summarise() bạn cung cấp tên của từng cột tổng hợp được theo sau bởi dâu bằng và hàm thống kê được áp dụng. Trong hàm thống kê, cung cấp (các) cột sẽ được tính toán và bất kỳ các đối số có liên quan (vd: na.rm = TRUE cho tất cả các hàm toán học).\nBạn cũng có thể sử dụng hàm sum() để trả vể số lượng dòng thỏa mãn một điều kiện logic cụ thể. Biểu thức điều kiện sẽ được đếm nếu nó được đánh giá là TRUE. Ví dụ:\n\nsum(age_years &lt; 18, na.rm=T)\n\nsum(gender == \"male\", na.rm=T)\n\nsum(response %in% c(\"Likely\", \"Very Likely\"))\n\nDưới đây, bộ dữ liệu linelist được tổng hợp để mô tả những ngày trì hoãn từ khi bắt đầu có triệu chứng đến khi nhập viện (cột days_onset_hosp), phân theo bệnh viện.\n\nsummary_table &lt;- linelist %&gt;%                                        # begin with linelist, save out as new object\n  group_by(hospital) %&gt;%                                             # group all calculations by hospital\n  summarise(                                                         # only the below summary columns will be returned\n    cases       = n(),                                                # number of rows per group\n    delay_max   = max(days_onset_hosp, na.rm = T),                    # max delay\n    delay_mean  = round(mean(days_onset_hosp, na.rm=T), digits = 1),  # mean delay, rounded\n    delay_sd    = round(sd(days_onset_hosp, na.rm = T), digits = 1),  # standard deviation of delays, rounded\n    delay_3     = sum(days_onset_hosp &gt;= 3, na.rm = T),               # number of rows with delay of 3 or more days\n    pct_delay_3 = scales::percent(delay_3 / cases)                    # convert previously-defined delay column to percent \n  )\n\nsummary_table  # print\n\n# A tibble: 6 × 7\n  hospital               cases delay_max delay_mean delay_sd delay_3 pct_delay_3\n  &lt;chr&gt;                  &lt;int&gt;     &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;   &lt;int&gt; &lt;chr&gt;      \n1 Central Hospital         454        12        1.9      1.9     108 24%        \n2 Military Hospital        896        15        2.1      2.4     253 28%        \n3 Missing                 1469        22        2.1      2.3     399 27%        \n4 Other                    885        18        2        2.2     234 26%        \n5 Port Hospital           1762        16        2.1      2.2     470 27%        \n6 St. Mark's Maternity …   422        18        2.1      2.3     116 27%        \n\n\nMột vài mẹp:\n\nSử dụng sum() với một biểu thức logic để “đếm” các dòng đáp ứng các tiêu chí nhất định (==)\n\nLưu ý cách sử dụng của na.rm = TRUE bên trong biểu thức toán học như là sum(), nếu không NA sẽ được trả lại nếu dữ liệu có giá trị missing\n\nSử dụng hàm percent() từ package scales để dễ dàng chuyển đổi tỷ lệ phần trăm\n\nThiết lập accuracy = bằng 0.1 hoặc 0.01 để đảm bảo kết quả hiển thị 1 hoặc 2 chữ số thập phân sau dấ phẩy\n\n\nSử dụng hàm round() từ base R để chỉ định số thập phân\n\nĐể tính toán các thống kê này trên toàn bộ tập dữ liệu, sử dụng summarise() và không có group_by()\n\nBạn có thể tạo các cột cho các mục đích tính toán sau này (ví dụ: mẫu số) mà thậm chí bạn bỏ ra khỏi data frame của mình với hàm select().\n\n\n\nThống kê có điều kiện\nBạn có thể sẽ muốn trả về các thống kê có điều kiện - vd: số hàng tối đa đáp ứng các tiêu chí nhất định. Điều này có thể thực hiện được bằng cáhc subsetting cột bằng dấu ngoặc vuông [ ]. Ví dụ dưới đây trả về nhiệt độ tối đa cho những bệnh nhân được phân loại là có hoặc không bị sốt. Tuy nhiên hãy lưu ý - có thể thích hợp hơn nếu thêm một cột khác vào hàm group_by() và pivot_wider() (như được minh họa dưới đây).\n\nlinelist %&gt;% \n  group_by(hospital) %&gt;% \n  summarise(\n    max_temp_fvr = max(temp[fever == \"yes\"], na.rm = T),\n    max_temp_no = max(temp[fever == \"no\"], na.rm = T)\n  )\n\n# A tibble: 6 × 3\n  hospital                             max_temp_fvr max_temp_no\n  &lt;chr&gt;                                       &lt;dbl&gt;       &lt;dbl&gt;\n1 Central Hospital                             40.4        38  \n2 Military Hospital                            40.5        38  \n3 Missing                                      40.6        38  \n4 Other                                        40.8        37.9\n5 Port Hospital                                40.6        38  \n6 St. Mark's Maternity Hospital (SMMH)         40.6        37.9\n\n\n\n\nGắn với nhau\nHàm str_glue() từ package stringr rất hữu ích để kết hợp các giá trị từ một số cột thành một cột mới. Trong trường hợp này nó được sử dụng sau hàm summarise().\nTrong chương Ký tự và chuỗi, có nhiều lựa chọn khác nhau để kết hợp các cột được thảo luận, bao gồm cả unite(), và paste0(). Trong trường hợp sử dụng này, chúng tôi ủng hộ str_glue() bởi vì nó linh hoạt hơn unite() và có cú pháp đơn giẩn hơn paste0().\nDưới đây, data frame summary_table (được tạo bên trên) được biến đổi để kết hợp cột delay_mean và delay_sd, định dạng dấu ngoặc đơn được thêm vào cột mới, và các cột cũ tương ứng của chúng bị xóa.\nSau đó, để làm cho bảng dễ nhìn hơn, tổng hàng được thêm vào bằng hàm adorn_totals() từ janitor (bỏ qua các cột không phải số). Cuối cùng, chúng tôi sử dụng hàm select() từ dplyr để sắp xếp và đặt tên lại cho các cột.\nBây giờ bạn có thể chuyển kết quả tới flextable và in chúng thành bảng trong Word, .png, .jpeg, .html, Powerpoint, RMarkdown, v.v.! (xem chương Trình bày bảng).\n\nsummary_table %&gt;% \n  mutate(delay = str_glue(\"{delay_mean} ({delay_sd})\")) %&gt;%  # combine and format other values\n  select(-c(delay_mean, delay_sd)) %&gt;%                       # remove two old columns   \n  adorn_totals(where = \"row\") %&gt;%                            # add total row\n  select(                                                    # order and rename cols\n    \"Hospital Name\"   = hospital,\n    \"Cases\"           = cases,\n    \"Max delay\"       = delay_max,\n    \"Mean (sd)\"       = delay,\n    \"Delay 3+ days\"   = delay_3,\n    \"% delay 3+ days\" = pct_delay_3\n    )\n\n                        Hospital Name Cases Max delay Mean (sd) Delay 3+ days\n                     Central Hospital   454        12 1.9 (1.9)           108\n                    Military Hospital   896        15 2.1 (2.4)           253\n                              Missing  1469        22 2.1 (2.3)           399\n                                Other   885        18   2 (2.2)           234\n                        Port Hospital  1762        16 2.1 (2.2)           470\n St. Mark's Maternity Hospital (SMMH)   422        18 2.1 (2.3)           116\n                                Total  5888       101         -          1580\n % delay 3+ days\n             24%\n             28%\n             27%\n             26%\n             27%\n             27%\n               -\n\n\n\nBách phân vị\nBách phân vị và tứ phân vị trong dplyr xứng đáng được đề cập tới. Để trả về tứ phân vị, sử dụng quantile() với các giá trị mặc định hoặc chỉ rõ giá trị bạn muốn bằng đối số probs =.\n\n# get default percentile values of age (0%, 25%, 50%, 75%, 100%)\nlinelist %&gt;% \n  summarise(age_percentiles = quantile(age_years, na.rm = TRUE))\n\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\nℹ Please use `reframe()` instead.\nℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n\n\n  age_percentiles\n1               0\n2               6\n3              13\n4              23\n5              84\n\n# get manually-specified percentile values of age (5%, 50%, 75%, 98%)\nlinelist %&gt;% \n  summarise(\n    age_percentiles = quantile(\n      age_years,\n      probs = c(.05, 0.5, 0.75, 0.98), \n      na.rm=TRUE)\n    )\n\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\nℹ Please use `reframe()` instead.\nℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n\n\n  age_percentiles\n1               1\n2              13\n3              23\n4              48\n\n\nNếu bạn muốn trả về phân vị theo nhóm, bạn có thể gặp phải các kết quả đầu ra dài và ít hữu ích hơn nếu bạn chỉ cần thêm cột vào group_by(). Thay vào đó, hãy thử cách tiếp cận này - tạo một cột cho mỗi mức phân vị mong muốn.\n\n# get manually-specified percentile values of age (5%, 50%, 75%, 98%)\nlinelist %&gt;% \n  group_by(hospital) %&gt;% \n  summarise(\n    p05 = quantile(age_years, probs = 0.05, na.rm=T),\n    p50 = quantile(age_years, probs = 0.5, na.rm=T),\n    p75 = quantile(age_years, probs = 0.75, na.rm=T),\n    p98 = quantile(age_years, probs = 0.98, na.rm=T)\n    )\n\n# A tibble: 6 × 5\n  hospital                               p05   p50   p75   p98\n  &lt;chr&gt;                                &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Central Hospital                         1    12    21  48  \n2 Military Hospital                        1    13    24  45  \n3 Missing                                  1    13    23  48.2\n4 Other                                    1    13    23  50  \n5 Port Hospital                            1    14    24  49  \n6 St. Mark's Maternity Hospital (SMMH)     2    12    22  50.2\n\n\nMặc dù dplyr summarise() chắc chắn cung cấp khả năng kiểm soát tốt hơn, bạn có thể thấy rằng tất cả các thống kê tổng hợp mà bạn cần có thể được tạo ra với hàm get_summary_stat() từ package rstatix. Nếu thực hiện trên dữ liệu đã được nhóm, nó sẽ trả về các phân vị 0%, 25%, 50%, 75%, và 100%. If applied to ungrouped data, you can specify the percentiles with probs = c(.05, .5, .75, .98).\n\nlinelist %&gt;% \n  group_by(hospital) %&gt;% \n  rstatix::get_summary_stats(age, type = \"quantile\")\n\n# A tibble: 6 × 8\n  hospital                         variable     n  `0%` `25%` `50%` `75%` `100%`\n  &lt;chr&gt;                            &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1 Central Hospital                 age        445     0     6    12    21     58\n2 Military Hospital                age        884     0     6    14    24     72\n3 Missing                          age       1441     0     6    13    23     76\n4 Other                            age        873     0     6    13    23     69\n5 Port Hospital                    age       1739     0     6    14    24     68\n6 St. Mark's Maternity Hospital (… age        420     0     7    12    22     84\n\n\n\nlinelist %&gt;% \n  rstatix::get_summary_stats(age, type = \"quantile\")\n\n# A tibble: 1 × 7\n  variable     n  `0%` `25%` `50%` `75%` `100%`\n  &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1 age       5802     0     6    13    23     84\n\n\n\n\n\nTóm tắt dữ liệu tổng hợp\nNếu bạn bắt đầu với dữ liệu tổng hợp (aggregated data), sử dụng n() để trả về số lượng các dòng, không phải là tổng của các số lượng được đếm. Để lấy tổng, sử dụng sum() trên cột của dữ liệu đếm.\nVí dụ, giả sử bạn đang bắt đầu với data frame đếm số lượng như bên dưới, gọi là linelist_agg - nó hiển thị ở định dạng “dọc”, các trường hợp được tính theo outcome và giới tính.\nSau đây chúng ta sẽ tạo data frame minh hoạt số trường hợp của linelist được đếm theo outcome và gender (các giá trị missing được loại bỏ để rõ ràng).\n\nlinelist_agg &lt;- linelist %&gt;% \n  drop_na(gender, outcome) %&gt;% \n  count(outcome, gender)\n\nlinelist_agg\n\n  outcome gender    n\n1   Death      f 1227\n2   Death      m 1228\n3 Recover      f  953\n4 Recover      m  950\n\n\nĐể tính tổng số lượng (trong cột n) theo nhóm bạn có thể sử dụng hàm summarise() nhưng đặt cột mới bằng sum(n, na.rm=T). Để thêm phần tử điều kiện vào phép toán tổng, bạn có thể sử dụng cú pháp dấu ngoặc vuông tập hợp con [ ] trên cột đếm.\n\nlinelist_agg %&gt;% \n  group_by(outcome) %&gt;% \n  summarise(\n    total_cases  = sum(n, na.rm=T),\n    male_cases   = sum(n[gender == \"m\"], na.rm=T),\n    female_cases = sum(n[gender == \"f\"], na.rm=T))\n\n# A tibble: 2 × 4\n  outcome total_cases male_cases female_cases\n  &lt;chr&gt;         &lt;int&gt;      &lt;int&gt;        &lt;int&gt;\n1 Death          2455       1228         1227\n2 Recover        1903        950          953\n\n\n\n\nacross() trên nhiều cột\nBạn có thể sử dụng summarise() trên nhiều cột bằng hàm across(). Điều này làm cho mọi thứ dễ dàng hơn khi bạn muốn tính toán các thống kê giống nhau cho nhiều cột. Đặt across() bên trong summarise() và chỉ rõ những điều sau:\n\n.cols = tên cột viết dưới dạng vector c() hoặc sử dụng các hàm trợ giúp chọn cột “tidyselect” (được giải thích bên dưới)\n\n.fns = hàm thực hiện (không có dấu ngoặc) - bạn có thể đưa nhiều hàm vào thông qua list()\n\nVí dụ dưới đây, mean() được áp dụng cho các cột dữ liệu dạng số. Một vectơ tên của các cột được gán cho .cols = và hàm duy nhất mean được xác định (không có dấu ngoặc) cho .fns =. Bất kỳ đối số bổ sung nào cho hàm (vd: na.rm=TRUE) được cung cấp phía sau .fns =, ngăn cách bởi dấu phẩy.\nCó thể khó để hiểu được thứ tự của dấu ngoặc đơn và dấu phẩy chính xác khi sử dụng across(). Hãy nhớ là bên trong hàm across() bạn phải bao gồm các cột, các hàm, và tất cả những đối số cần thiết cho các hàm.\n\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm),  # columns\n                   .fns = mean,                               # function\n                   na.rm=T))                                  # extra arguments\n\nWarning: There was 1 warning in `summarise()`.\nℹ In argument: `across(...)`.\nℹ In group 1: `outcome = \"Death\"`.\nCaused by warning:\n! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\nSupply arguments directly to `.fns` through an anonymous function instead.\n\n  # Previously\n  across(a:b, mean, na.rm = TRUE)\n\n  # Now\n  across(a:b, \\(x) mean(x, na.rm = TRUE))\n\n\n# A tibble: 3 × 5\n  outcome age_years  temp wt_kg ht_cm\n  &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Death        15.9  38.6  52.6  125.\n2 Recover      16.1  38.6  52.5  125.\n3 &lt;NA&gt;         16.2  38.6  53.0  125.\n\n\nNhiều hàm có thể được chạy cùng một lúc. Dưới đây hàm mean và sd được cung cấp cho .fns = bên trong một list(). Bạn có cơ hội cung cấp tên ký tự (vd: “mean” và “sd”) để thêm vào tên các cột mới.\n\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm), # columns\n                   .fns = list(\"mean\" = mean, \"sd\" = sd),    # multiple functions \n                   na.rm=T))                                 # extra arguments\n\n# A tibble: 3 × 9\n  outcome age_years_mean age_years_sd temp_mean temp_sd wt_kg_mean wt_kg_sd\n  &lt;chr&gt;            &lt;dbl&gt;        &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;\n1 Death             15.9         12.3      38.6   0.962       52.6     18.4\n2 Recover           16.1         13.0      38.6   0.997       52.5     18.6\n3 &lt;NA&gt;              16.2         12.8      38.6   0.976       53.0     18.9\n# ℹ 2 more variables: ht_cm_mean &lt;dbl&gt;, ht_cm_sd &lt;dbl&gt;\n\n\nDưới đây là danh sách các hàm trợ giúp “tidyselect” bạn có thể cung cấp cho .cols = để lựa chọn cột:\n\neverything() - tất cả các cột khác không được đề cập\n\nlast_col() - cột cuối cùng\n\nwhere() - áp dụng một hàm cho tất cả các cột và chọn những cột trả về giá trị TRUE\n\nstarts_with() - khớp với một tiền tố được chỉ định. Ví dụ: starts_with(\"date\")\nends_with() - khớp với một hậu tố được chỉ định. Ví dụ: ends_with(\"_end\")\n\ncontains() - cột chứa một chuỗi ký tự. Ví dụ: contains(\"time\")\nmatches() - áp dụng một biểu thức chính quy (regex). Ví dụ: contains(\"[pt]al\")\n\nnum_range() - khoảng giá trị số\nany_of() - khớp nếu cột được đặt tên. Hữu ích nếu tên có thể không tồn tại. Ví dụ: any_of(date_onset, date_death, cardiac_arrest)\n\nVí dụ, để trả về giá trị trung bình của tất cả các cột dạng số, sử dụng where() và thêm vào hàm is.numeric() (không có dấu ngoặc). Tất cả những thứ này vẫn được đặt trong hàm across().\n\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  summarise(across(\n    .cols = where(is.numeric),  # all numeric columns in the data frame\n    .fns = mean,\n    na.rm=T))\n\n# A tibble: 3 × 12\n  outcome generation   age age_years   lon   lat wt_kg ht_cm ct_blood  temp\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;\n1 Death         16.7  15.9      15.9 -13.2  8.47  52.6  125.     21.3  38.6\n2 Recover       16.4  16.2      16.1 -13.2  8.47  52.5  125.     21.1  38.6\n3 &lt;NA&gt;          16.5  16.3      16.2 -13.2  8.47  53.0  125.     21.2  38.6\n# ℹ 2 more variables: bmi &lt;dbl&gt;, days_onset_hosp &lt;dbl&gt;\n\n\n\n\nXoay trục ngang (Pivot wider)\nNếu bạn thích bảng của mình ở định dạng “rộng”, bạn có thể biến đổi nó sử dụng hàm tidyr pivot_wider(). Bạn có thể sẽ cần đặt lại tên cho các cột bằng rename(). Để tìm hiểu thêm, vui lòng xem chương Pivoting dữ liệu.\nVí dụ sau đây bắt đầu bằng một bảng “dài” age_by_outcome từ mục Tỷ lệ. Để dễ hình dung, chúng ta tạo lại bảng và in ra:\n\nage_by_outcome &lt;- linelist %&gt;%                  # begin with linelist\n  group_by(outcome) %&gt;%                         # group by outcome \n  count(age_cat) %&gt;%                            # group and count by age_cat, and then remove age_cat grouping\n  mutate(percent = scales::percent(n / sum(n))) # calculate percent - note the denominator is by outcome group\n\n\n\n\n\n\n\nĐể xoay trục ngang, chúng ta tạo các cột mới từ các giá trị trong cột hiện có age_cat (bằng cách đặt names_from = age_cat). Chúng ta cũng chỉ định rằng các giá trị bảng mới sẽ đến từ cột hiện có n, với values_from = n. Các cột không được đề cập trong lệnh pivoting (outcome) sẽ không thay đổi ở phía ngoài cùng bên trái.\n\nage_by_outcome %&gt;% \n  select(-percent) %&gt;%   # keep only counts for simplicity\n  pivot_wider(names_from = age_cat, values_from = n)  \n\n# A tibble: 3 × 10\n# Groups:   outcome [3]\n  outcome `0-4` `5-9` `10-14` `15-19` `20-29` `30-49` `50-69` `70+`  `NA`\n  &lt;chr&gt;   &lt;int&gt; &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n1 Death     471   476     438     323     477     329      33     3    32\n2 Recover   364   391     303     251     367     238      38     3    28\n3 &lt;NA&gt;      260   228     200     169     229     187      24    NA    26\n\n\n\n\nTổng các hàng\nKhi hàm summarise() vận hành trên dữ liệu đã được nhóm, nó không tính “tổng” một cách tự động. Sau đây là hai cách tiếp cận giúp bạn thêm tổng hàng:\n\njanitor’s adorn_totals()\nNếu bảng của bạn chỉ chứa duy nhất số lượng hoặc tỷ lệ/tỷ lệ phần trăm có thể được tổng hợp thành một tổng, thì bạn có thể tính tổng sử dụng hàm adorn_totals() của package janitor như đã được mô tả bên trên. Lưu ý là hàm này chỉ có thể tính tổng của các cột định dạng là số - nếu bạn muốn tính các loại tổng khác, vui lòng xem cách tiếp cận tiếp theo bằng dplyr.\nDưới đây, bộ dữ liệu linelist được nhóm theo giới và tóm tắt thành một bảng mô tả số trường hợp có outcome đã biết, tử vong và phục hồi. Piping bảng tới hàm adorn_totals() để thêm tổng các hàng ở hàng dưới cùng thể hiện giá trị tổng của từng cột. Các hàm adorn_*() khác điều chỉnh cách kết quả được hiển thị như được comment trong phần code.\n\nlinelist %&gt;% \n  group_by(gender) %&gt;%\n  summarise(\n    known_outcome = sum(!is.na(outcome)),           # Number of rows in group where outcome is not missing\n    n_death  = sum(outcome == \"Death\", na.rm=T),    # Number of rows in group where outcome is Death\n    n_recover = sum(outcome == \"Recover\", na.rm=T), # Number of rows in group where outcome is Recovered\n  ) %&gt;% \n  adorn_totals() %&gt;%                                # Adorn total row (sums of each numeric column)\n  adorn_percentages(\"col\") %&gt;%                      # Get column proportions\n  adorn_pct_formatting() %&gt;%                        # Convert proportions to percents\n  adorn_ns(position = \"front\")                      # display % and counts (with counts in front)\n\n gender  known_outcome        n_death      n_recover\n      f 2,180  (47.8%) 1,227  (47.5%)   953  (48.1%)\n      m 2,178  (47.7%) 1,228  (47.6%)   950  (47.9%)\n   &lt;NA&gt;   207   (4.5%)   127   (4.9%)    80   (4.0%)\n  Total 4,565 (100.0%) 2,582 (100.0%) 1,983 (100.0%)\n\n\n\n\nsummarise() trên dữ liệu “tổng” rồi sau đó bind_rows()\nNếu bảng của bạn chứa các phép tính thống kế chẳng hạn như median(), mean(), v.v, thì cách tiếp cận dùng hàm adorn_totals() bên trên sẽ không đủ. Thay vào đó, để có được thống kê tóm tắt cho toàn bộ tập dữ liệu, bạn phải tính toán chúng bằng lệnh summarise() một cách độc lập sau đó gắn các kết quả này với bảng tổng hợp theo nhóm ban đầu. Để làm điều này, bạn có thể sử dụng hàm bind_rows() từ dplyr như được mô tả trong chương Nối dữ liệu. Dưới đây là một ví dụ:\nBạn có thể tạo bảng tổng hợp của outcome theo bệnh viện với group_by() và summarise() như sau:\n\nby_hospital &lt;- linelist %&gt;% \n  filter(!is.na(outcome) & hospital != \"Missing\") %&gt;%  # Remove cases with missing outcome or hospital\n  group_by(hospital, outcome) %&gt;%                      # Group data\n  summarise(                                           # Create new summary columns of indicators of interest\n    N = n(),                                            # Number of rows per hospital-outcome group     \n    ct_value = median(ct_blood, na.rm=T))               # median CT value per group\n  \nby_hospital # print table\n\n# A tibble: 10 × 4\n# Groups:   hospital [5]\n   hospital                             outcome     N ct_value\n   &lt;chr&gt;                                &lt;chr&gt;   &lt;int&gt;    &lt;dbl&gt;\n 1 Central Hospital                     Death     193       22\n 2 Central Hospital                     Recover   165       22\n 3 Military Hospital                    Death     399       21\n 4 Military Hospital                    Recover   309       22\n 5 Other                                Death     395       22\n 6 Other                                Recover   290       21\n 7 Port Hospital                        Death     785       22\n 8 Port Hospital                        Recover   579       21\n 9 St. Mark's Maternity Hospital (SMMH) Death     199       22\n10 St. Mark's Maternity Hospital (SMMH) Recover   126       22\n\n\nĐể tính tổng, vẫn sử dụng hàm summarise() nhưng chỉ nhóm dữ liệu theo outcome (không theo bệnh viện), như dưới đây:\n\ntotals &lt;- linelist %&gt;% \n      filter(!is.na(outcome) & hospital != \"Missing\") %&gt;%\n      group_by(outcome) %&gt;%                            # Grouped only by outcome, not by hospital    \n      summarise(\n        N = n(),                                       # These statistics are now by outcome only     \n        ct_value = median(ct_blood, na.rm=T))\n\ntotals # print table\n\n# A tibble: 2 × 3\n  outcome     N ct_value\n  &lt;chr&gt;   &lt;int&gt;    &lt;dbl&gt;\n1 Death    1971       22\n2 Recover  1469       22\n\n\nBây giờ chúng ta có thể nối hai data frames này lại với nhau. Lưu ý là bảng by_hospital có 4 cột trong khi đó bảng kết quả totals có 3 cột. Bằng việc sử dụng bind_rows(), các cột được kết hợp theo tên, và bất kỳ khoảng trống nào sẽ được điền vào bằng giá trị NA (ví dụ ở cột hospital là các giá trị cho hai hàng totals mới). Sau khi gắn các hàng, chúng ta chuyển các khoảng trống đó thành “Tổng” bằng cách sử dụng replace_na() (xem chương Làm sạch số liệu và các hàm quan trọng).\n\ntable_long &lt;- bind_rows(by_hospital, totals) %&gt;% \n  mutate(hospital = replace_na(hospital, \"Total\"))\n\nĐây là bảng mới với các hàng “Tổng” ở các hàng dưới cùng của bảng.\n\n\n\n\n\n\nBảng này đang có định dạng “dài”, có thể là những gì bạn muốn. Tuy nhiên, bạn có thể xoay bảng này rộng hơn theo chiều ngang để dễ đọc. Xem thêm ở phần Xoay trục ngang (Pivot wider) bên trên, và chương Xoay trục dữ liệu. Bạn cũng có thêm nhiều cột nữa, và sắp xếp chúng một cách đẹp mắt. Phần code được trình bày bên dưới.\n\ntable_long %&gt;% \n  \n  # Pivot wider and format\n  ########################\n  mutate(hospital = replace_na(hospital, \"Total\")) %&gt;% \n  pivot_wider(                                         # Pivot from long to wide\n    values_from = c(ct_value, N),                       # new values are from ct and count columns\n    names_from = outcome) %&gt;%                           # new column names are from outcomes\n  mutate(                                              # Add new columns\n    N_Known = N_Death + N_Recover,                               # number with known outcome\n    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # percent cases who died (to 1 decimal)\n    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %&gt;% # percent who recovered (to 1 decimal)\n  select(                                              # Re-order columns\n    hospital, N_Known,                                   # Intro columns\n    N_Recover, Pct_Recover, ct_value_Recover,            # Recovered columns\n    N_Death, Pct_Death, ct_value_Death)  %&gt;%             # Death columns\n  arrange(N_Known)                                  # Arrange rows from lowest to highest (Total row at bottom)\n\n# A tibble: 6 × 8\n# Groups:   hospital [6]\n  hospital      N_Known N_Recover Pct_Recover ct_value_Recover N_Death Pct_Death\n  &lt;chr&gt;           &lt;int&gt;     &lt;int&gt; &lt;chr&gt;                  &lt;dbl&gt;   &lt;int&gt; &lt;chr&gt;    \n1 St. Mark's M…     325       126 38.8%                     22     199 61.2%    \n2 Central Hosp…     358       165 46.1%                     22     193 53.9%    \n3 Other             685       290 42.3%                     21     395 57.7%    \n4 Military Hos…     708       309 43.6%                     22     399 56.4%    \n5 Port Hospital    1364       579 42.4%                     21     785 57.6%    \n6 Total            3440      1469 42.7%                     22    1971 57.3%    \n# ℹ 1 more variable: ct_value_Death &lt;dbl&gt;\n\n\nTiếp đó bạn có thể in bảng kết quả dưới dạng một bức ảnh đẹp - sau đây là output được in bằng flextable. Bạn có thể đọc chuyên sâu hơn về ví dụ này và cách tạo được bảng “đẹp” tương tự thế này trong chương Trình bày bảng.\n\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Bảng mô tả</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.vn.html#tbl_gt",
    "href": "new_pages/tables_descriptive.vn.html#tbl_gt",
    "title": "17  Bảng mô tả",
    "section": "17.5 gtsummary package",
    "text": "17.5 gtsummary package\nNếu bạn muốn in các thống kê tóm tắt của mình dưới dạng đồ họa đẹp mắt, sẵn sàng xuất bản, bạn có thể sử dụng package gtsummary và hàm của nó tbl_summary(). Phần code ban đầu có thể trông phức tạp một chút, nhưng kết quả đầu ra trông rất đẹp và in ra Viewer panel của RStudio dưới dạng một ảnh HTML. Đọc bản tóm tắt ở đây.\nBạn cũng có thể thêm kết quả của các kiểm định thống kê vào các bảng của gtsummary. Quy trình này được trình bày ở mục gtsummary trong chương Các kiểm định thống kê cơ bản.\nĐể giới thiệu về tbl_summary(), trước tiên chúng ta sẽ chỉ ra các quy trình cơ bản nhất, giúp bạn thực sự tạo ra một bảng lớn và đẹp. Sau đó, chúng ta sẽ tìm hiểu chi tiết hơn về cách thực hiện các điều chỉnh và các bảng được thiết kế sẵn.\n\nBảng tổng hợp\nCách làm việc mặc định của tbl_summary() khá kinh ngạc - nó lấy các cột bạn cung cấp và tạo một bảng tóm tắt chỉ trong một lệnh. Hàm in ra số liệu thống kê phù hợp với lớp cột: trung vị và khoảng tứ phân vị (IQR) cho các cột số, và số lượng (%) cho các cột danh mục. Giá trị missing được chuyển đổi thành “Unknown”. Chú thích được thêm vào cuối bảng để giải thích các phép tính thống kê, trong khi tổng N được hiển thị ở trên cùng.\n\nlinelist %&gt;% \n  select(age_years, gender, outcome, fever, temp, hospital) %&gt;%  # keep only the columns of interest\n  tbl_summary()                                                  # default\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nN = 5,8881\n\n\n\n\nage_years\n13 (6, 23)\n\n\n    Unknown\n86\n\n\ngender\n\n\n\n\n    f\n2,807 (50%)\n\n\n    m\n2,803 (50%)\n\n\n    Unknown\n278\n\n\noutcome\n\n\n\n\n    Death\n2,582 (57%)\n\n\n    Recover\n1,983 (43%)\n\n\n    Unknown\n1,323\n\n\nfever\n4,549 (81%)\n\n\n    Unknown\n249\n\n\ntemp\n38.80 (38.20, 39.20)\n\n\n    Unknown\n149\n\n\nhospital\n\n\n\n\n    Central Hospital\n454 (7.7%)\n\n\n    Military Hospital\n896 (15%)\n\n\n    Missing\n1,469 (25%)\n\n\n    Other\n885 (15%)\n\n\n    Port Hospital\n1,762 (30%)\n\n\n    St. Mark's Maternity Hospital (SMMH)\n422 (7.2%)\n\n\n\n1 Median (IQR); n (%)\n\n\n\n\n\n\n\n\n\n\n\nCác điều chỉnh\nBây giờ chúng tôi sẽ giải thích cách hoạt động của hàm và cách điều chỉnh. Các đối số chính được trình bày chi tiết bên dưới:\nby =\nBạn có thể phân tầng bảng của mình theo một cột (ví dụ theo outcome), để tạo thành bảng 2 chiều.\nstatistic =\nSử dụng phương trình để chỉ định thống kê nào sẽ được hiển thị và cách hiển thị chúng. Có hai vế của phương trình, được ngăn cách bởi dấu ~. Ở vế phải, trong dấu ngoặc kép, là hiển thị phép toán thống kê mong muốn, và ở vế trái là các cột mà phép thống kê đó sẽ áp dụng.\n\nVế phải của phương trình sử dụng cú pháp của hàm str_glue() từ stringr (xem Ký tự và chuỗi), với chuỗi hiển thị mong muốn trong dấu ngoặc kép và các phép toán thống kê trong dấu ngoặc nhọn. Bạn có thể thêm các phép thống kê như là “n” (số lượng), “N” (mẫu số), “mean”, “median”, “sd”, “max”, “min”, phân vị “p##” như là “p25”, hoặc phần trăm của một tổng như là “p”. Xem ?tbl_summary để biết thêm chi tiết.\n\nĐối với phía bên trái của phương trình, bạn có thể chỉ định các cột theo tên (ví dụ: age hoặc c(age, gender)) hoặc sử dụng các hàm trợ giúp như all_continuous(), all_categorical(), contains(), starts_with(), v.v.\n\nMột ví dụ đơn giản về phương trình statistic = có thể tham khảo ở bên dưới, để chỉ in giá trị trung bình của cột age_years:\n\nlinelist %&gt;% \n  select(age_years) %&gt;%         # keep only columns of interest \n  tbl_summary(                  # create summary table\n    statistic = age_years ~ \"{mean}\") # print mean of age\n\n\n\n\n\n\n\n\nCharacteristic\nN = 5,8881\n\n\n\n\nage_years\n16\n\n\n    Unknown\n86\n\n\n\n1 Mean\n\n\n\n\n\n\n\n\n\nMột phương trình phức tạp hơn một chút có thể như\"({min}, {max})\", kết hợp các giá trị max và min trong dấu ngoặc đơn và được phân tách bằng dấu phẩy:\n\nlinelist %&gt;% \n  select(age_years) %&gt;%                       # keep only columns of interest \n  tbl_summary(                                # create summary table\n    statistic = age_years ~ \"({min}, {max})\") # print min and max of age\n\n\n\n\n\n\n\n\nCharacteristic\nN = 5,8881\n\n\n\n\nage_years\n(0, 84)\n\n\n    Unknown\n86\n\n\n\n1 (Range)\n\n\n\n\n\n\n\n\n\nBạn cũng có thể phân biệt cú pháp cho các cột hoặc loại cột riêng biệt. Trong ví dụ phức tạp hơn bên dưới, giá trị được cung cấp cho statistc = là một danh sách chỉ ra rằng đối với tất cả các cột dạng số thì bảng sẽ in ra giá trị trung bình và độ lệch chuẩn bên trong ngoặc, trong khi các cột dạng danh sách thì sẽ in ra n, mẫu số, và phần trăm.\ndigits =\nĐiều chỉnh các chữ số và làm tròn. Theo tùy chọn, điều này có thể được chỉ định chỉ dành cho các cột dạng số liên tục (như bên dưới).\nlabel =\nĐiều chỉnh cách hiển thị tên cột. Cung cấp tên cột và nhãn mong muốn của nó được phân tách bằng dấu ngã. Theo mặc định thì tên cột được hiển thị.\nmissing_text =\nĐiều chỉnh cách giá trị missing được hiển thị. Mặc định hiển thị là “Unknown”.\ntype =\nSử dụng để điều chỉnh số lượng cấp độ của thống kê được hiển thị Cú pháp tương tự như statistic = trong đó bạn cung cấp một phương trình với các cột ở bên trái và một giá trị ở bên phải. Hai trường hợp phổ biến bao gồm:\n\ntype = all_categorical() ~ \"categorical\" Buộc các cột nhị phân (ví dụ: fever có/không) hiển thị tất cả các cấp độ thay vì chỉ hiện thị hàng “có”\n\ntype = all_continuous() ~ \"continuous2\" Cho phép các kết quả thống kê được trình bày theo nhiều dòng cho mỗi biến, như được trình bày trong phần sau\n\nTrong ví dụ dưới đây, mỗi đối số này được sử dụng để điều chỉnh bảng ban đầu:\n\nlinelist %&gt;% \n  select(age_years, gender, outcome, fever, temp, hospital) %&gt;% # keep only columns of interest\n  tbl_summary(     \n    by = outcome,                                               # stratify entire table by outcome\n    statistic = list(all_continuous() ~ \"{mean} ({sd})\",        # stats and format for continuous columns\n                     all_categorical() ~ \"{n} / {N} ({p}%)\"),   # stats and format for categorical columns\n    digits = all_continuous() ~ 1,                              # rounding for continuous columns\n    type   = all_categorical() ~ \"categorical\",                 # force all categorical levels to display\n    label  = list(                                              # display labels for column names\n      outcome   ~ \"Outcome\",                           \n      age_years ~ \"Age (years)\",\n      gender    ~ \"Gender\",\n      temp      ~ \"Temperature\",\n      hospital  ~ \"Hospital\"),\n    missing_text = \"Missing\"                                    # how missing values should display\n  )\n\n1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nDeath, N = 2,5821\nRecover, N = 1,9831\n\n\n\n\nAge (years)\n15.9 (12.3)\n16.1 (13.0)\n\n\n    Missing\n32\n28\n\n\nGender\n\n\n\n\n\n\n    f\n1,227 / 2,455 (50%)\n953 / 1,903 (50%)\n\n\n    m\n1,228 / 2,455 (50%)\n950 / 1,903 (50%)\n\n\n    Missing\n127\n80\n\n\nfever\n\n\n\n\n\n\n    no\n458 / 2,460 (19%)\n361 / 1,904 (19%)\n\n\n    yes\n2,002 / 2,460 (81%)\n1,543 / 1,904 (81%)\n\n\n    Missing\n122\n79\n\n\nTemperature\n38.6 (1.0)\n38.6 (1.0)\n\n\n    Missing\n60\n55\n\n\nHospital\n\n\n\n\n\n\n    Central Hospital\n193 / 2,582 (7.5%)\n165 / 1,983 (8.3%)\n\n\n    Military Hospital\n399 / 2,582 (15%)\n309 / 1,983 (16%)\n\n\n    Missing\n611 / 2,582 (24%)\n514 / 1,983 (26%)\n\n\n    Other\n395 / 2,582 (15%)\n290 / 1,983 (15%)\n\n\n    Port Hospital\n785 / 2,582 (30%)\n579 / 1,983 (29%)\n\n\n    St. Mark's Maternity Hospital (SMMH)\n199 / 2,582 (7.7%)\n126 / 1,983 (6.4%)\n\n\n\n1 Mean (SD); n / N (%)\n\n\n\n\n\n\n\n\n\n\n\nThống kê nhiều dòng cho các biến liên tục\nNếu bạn muốn in nhiều dòng thống kê cho các biến liên tục, bạn có thể thiết lập type = thành “continuous2”. Bạn có thể kết hợp tất cả các yếu tố được hiển thị trước đó trong một bảng bằng cách chọn thống kê bạn muốn hiển thị. Để làm điều này, bạn cần cho hàm biết rằng bạn muốn khôi phục bảng bằng cách nhập type là “continuous2”. Số lượng các giá trị missing được hiển thị là “Unknown”.\n\nlinelist %&gt;% \n  select(age_years, temp) %&gt;%                      # keep only columns of interest\n  tbl_summary(                                     # create summary table\n    type = all_continuous() ~ \"continuous2\",       # indicate that you want to print multiple statistics \n    statistic = all_continuous() ~ c(\n      \"{mean} ({sd})\",                             # line 1: mean and SD\n      \"{median} ({p25}, {p75})\",                   # line 2: median and IQR\n      \"{min}, {max}\")                              # line 3: min and max\n    )\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nN = 5,888\n\n\n\n\nage_years\n\n\n\n\n    Mean (SD)\n16 (13)\n\n\n    Median (IQR)\n13 (6, 23)\n\n\n    Range\n0, 84\n\n\n    Unknown\n86\n\n\ntemp\n\n\n\n\n    Mean (SD)\n38.56 (0.98)\n\n\n    Median (IQR)\n38.80 (38.20, 39.20)\n\n\n    Range\n35.20, 40.80\n\n\n    Unknown\n149\n\n\n\n\n\n\n\n\nCó nhiều cách khác để chỉnh sửa các bảng này, bao gồm thêm giá trị p, chỉnh sửa màu sắc và tiêu đề, v.v. Các phần này được đề cập trong tài liệu trợ giúp đính kèm (nhập ?tbl_summary trong cửa sổ Console), và một số được đề cập trong chương Các kiểm định thống kê cơ bản.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Bảng mô tả</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.vn.html#base-r",
    "href": "new_pages/tables_descriptive.vn.html#base-r",
    "title": "17  Bảng mô tả",
    "section": "17.6 base R",
    "text": "17.6 base R\nBạn có thể sử dụng hàm table() để tạo bảng đơn và bảng chéo các cột. Không giống như các cách ở trên, bạn phải chỉ định data frame mỗi khi bạn tham chiếu đến tên cột, như được trình bày dưới đây.\nTHẬN TRỌNG: Giá trị NA (missing) sẽ không sẽ không được lập bảng trừ khi bạn bao gồm đối số useNA = \"always\" (cũng có thể được đặt thành “no” hoặc “ifany”).\nMẸO: Bạn có thể sử dụng %$% từ package magrittr để loại bỏ việc lặp lại các data frame trong các hàm base. Chẳng hạn, ví dụ bên dưới có thể được viết lại thành linelist %$% table(outcome, useNA = \"always\")\n\ntable(linelist$outcome, useNA = \"always\")\n\n\n  Death Recover    &lt;NA&gt; \n   2582    1983    1323 \n\n\nCó thể lập bảng chéo từ nhiều cột bằng cách liệt kê chúng nối tiếp nhau, phân tách bằng dấu phẩy. Hoặc là, bạn có thể gán cho mỗi cột một “tên” như Outcome = linelist$outcome.\n\nage_by_outcome &lt;- table(linelist$age_cat, linelist$outcome, useNA = \"always\") # save table as object\nage_by_outcome   # print table\n\n       \n        Death Recover &lt;NA&gt;\n  0-4     471     364  260\n  5-9     476     391  228\n  10-14   438     303  200\n  15-19   323     251  169\n  20-29   477     367  229\n  30-49   329     238  187\n  50-69    33      38   24\n  70+       3       3    0\n  &lt;NA&gt;     32      28   26\n\n\n\nTỷ lệ\nĐể trả về tỷ lệ, hãy chuyển bảng trên vào hàm prop.table(). Sử dụng đối số margins = để chỉ định xem bạn muốn tỷ lệ của hàng (1), của cột (2) hay của toàn bảng (3). Để dễ nhìn, chúng ta pipe bảng trên vào hàm round() của base R, chỉ định 2 chữ số sau dấu phẩy.\n\n# get proportions of table defined above, by rows, rounded\nprop.table(age_by_outcome, 1) %&gt;% round(2)\n\n       \n        Death Recover &lt;NA&gt;\n  0-4    0.43    0.33 0.24\n  5-9    0.43    0.36 0.21\n  10-14  0.47    0.32 0.21\n  15-19  0.43    0.34 0.23\n  20-29  0.44    0.34 0.21\n  30-49  0.44    0.32 0.25\n  50-69  0.35    0.40 0.25\n  70+    0.50    0.50 0.00\n  &lt;NA&gt;   0.37    0.33 0.30\n\n\n\n\nTổng\nĐể thêm tổng hàng và tổng cột, hãy chuyển bảng vào hàm addmargins(). Cách này hoạt động cho cả số lượng và tỷ lệ.\n\naddmargins(age_by_outcome)\n\n       \n        Death Recover &lt;NA&gt;  Sum\n  0-4     471     364  260 1095\n  5-9     476     391  228 1095\n  10-14   438     303  200  941\n  15-19   323     251  169  743\n  20-29   477     367  229 1073\n  30-49   329     238  187  754\n  50-69    33      38   24   95\n  70+       3       3    0    6\n  &lt;NA&gt;     32      28   26   86\n  Sum    2582    1983 1323 5888\n\n\n\n\nChuyển đổi thành data frame\nChuyển đổi trực tiếp một đối tượng dạng table() sang một data frame không phải là một đường thẳng. Cách tiếp cận được trình bày như dưới đây:\n\nTạo một bảng, mà không sử dụng useNA = \"always\". Thay vào đó chuyển giá trị NA thành “(Missing)” với hàm fct_explicit_na() của package forcats.\n\nThêm tổng (tùy chọn) bằng cách piping tới addmargins()\n\nPipe tới hàm as.data.frame.matrix() của base R\n\nPipe bảng trên vào hàm rownames_to_column() của package tibble, ghi rõ tên cho cột đầu tiên\n\nIn, Xem hoặc xuất bảng như mong muốn. Trong ví dụ này, chúng ta sử dụng hàm flextable() từ package flextable như đã được mô tả trong chương Trình bày bảng Kết quả sẽ được in ra cửa sổ RStudio viewer dưới dạng một hình ảnh HTML đẹp.\n\n\ntable(fct_explicit_na(linelist$age_cat), fct_explicit_na(linelist$outcome)) %&gt;% \n  addmargins() %&gt;% \n  as.data.frame.matrix() %&gt;% \n  tibble::rownames_to_column(var = \"Age Category\") %&gt;% \n  flextable::flextable()\n\nAge CategoryDeathRecover(Missing)Sum0-44713642601,0955-94763912281,09510-1443830320094115-1932325116974320-294773672291,07330-4932923818775450-693338249570+3306(Missing)32282686Sum2,5821,9831,3235,888",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Bảng mô tả</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.vn.html#nguồn",
    "href": "new_pages/tables_descriptive.vn.html#nguồn",
    "title": "17  Bảng mô tả",
    "section": "17.7 Nguồn",
    "text": "17.7 Nguồn\nPhần lớn thông tin trong chương này được tham khảo từ các nguồn và bản tóm tắt trực tuyến dưới đây:\ngtsummary\ndplyr",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Bảng mô tả</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.vn.html",
    "href": "new_pages/stat_tests.vn.html",
    "title": "18  Các kiểm định thống kê cơ bản",
    "section": "",
    "text": "18.1 Các bước chuẩn bị",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Các kiểm định thống kê cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.vn.html#các-bước-chuẩn-bị",
    "href": "new_pages/stat_tests.vn.html#các-bước-chuẩn-bị",
    "title": "18  Các kiểm định thống kê cơ bản",
    "section": "",
    "text": "Gọi các packages\nĐoạn code này hiển thị việc gọi các package cần thiết cho phân tích. Trong cuốn sổ tay này, chúng tôi nhấn mạnh đến hàm p_load() trong package pacman, cài đặt gói lệnh nếu cần thiết và gọi chúng ra để sử dụng. Các package đã cài đặt cũng có thể được gọi ra bằng library() từ base R. Xem thêm thông tin các package của R trong chương R cơ bản.\n\npacman::p_load(\n  rio,          # File import\n  here,         # File locator\n  skimr,        # get overview of data\n  tidyverse,    # data management + ggplot2 graphics, \n  gtsummary,    # summary statistics and tests\n  rstatix,      # statistics\n  corrr,        # correlation analayis for numeric variables\n  janitor,      # adding totals and percents to tables\n  flextable     # converting tables to HTML\n  )\n\n\n\nNhập số liệu\nChúng ta nhập bộ số liệu của các ca bệnh về một vụ dịch Ebola mô phỏng. Để tiện theo dõi, bấm để tải bộ số liệu linelist “đã được làm sạch” (as .rds file). Nhập số liệu bằng hàm import() từ package rio package (nó chấp nhận nhiều loại tập tin như .xlsx, .rds, .csv - xem thêm chương Nhập xuất dữ liệu để biết thêm chi tiết).\n\n# import the linelist\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\n50 hàng đầu tiên của bộ dữ liệu linelist được hiển thị như dưới đây.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Các kiểm định thống kê cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.vn.html#các-kiểm-định-trong-base-r",
    "href": "new_pages/stat_tests.vn.html#các-kiểm-định-trong-base-r",
    "title": "18  Các kiểm định thống kê cơ bản",
    "section": "18.2 Các kiểm định trong base R",
    "text": "18.2 Các kiểm định trong base R\nCác lệnh trong base R functions to conduct statistical tests. có thể được sử dụng để thực hiện các kiểm định thống kê. Các câu lệnh tương đối đơn giản và kết quả sẽ hiển thị trong bảng điều khiển R Console. Tuy nhiên, kết quả đầu ra thường dưới dạng liệt kê, vì thế sẽ khó thao tác hơn nếu muốn sử dụng kết quả trong các thao tác tiếp theo.\n\nKiểm định t\nMột kiểm định t, hay còn được gọi là “Student’s t-Test”, thường được sử dụng để xác định có sự khác biệt có ý nghĩa thống kê giữa giá trị trung bình của hai nhóm. Bên dưới là cú pháp để thực hiện kiểm định này tùy thuộc vào các cột có trong cùng một data frame hay không.\nCú pháp 1: Đây là cú pháp khi cột của biến liên tục và phân loại nằm trong cùng một data frame. Đặt biến liên tục bên trái và biến phân loại bên phải của phương trình. Ghi rõ bộ số liệu sau data =. Các tùy chọn khác như số liệu bắt cặp, viết thêm paired = TRUE, khoảng tin cậy, viết thêm conf.level = (mặc định là 0.95), và giả thuyết thay thế alternative = (hai đuôi - “two.sided”, hoặc một đuôi nhỏ hơn hay lớn hơn - “less”, or “greater”). Gõ ?t.test để biết thêm chi tiết.\n\n## compare mean age by outcome group with a t-test\nt.test(age_years ~ gender, data = linelist)\n\n\n    Welch Two Sample t-test\n\ndata:  age_years by gender\nt = -21.344, df = 4902.3, p-value &lt; 2.2e-16\nalternative hypothesis: true difference in means between group f and group m is not equal to 0\n95 percent confidence interval:\n -7.571920 -6.297975\nsample estimates:\nmean in group f mean in group m \n       12.60207        19.53701 \n\n\nCú pháp 2: Đây là cú pháp khi so sánh hai véc tơ dạng số. Ví dụ như hai cột nằm trong hai bộ số liệu khác nhau.\n\nt.test(df1$age_years, df2$age_years)\n\nKiểm định t cũng được sử dụng để xác định có sự khác biệt có ý nghĩa thống kê giữa giá trị trung bình của mẫu với một số giá trị cụ thể. Đây là phép kiểm định t cho một mẫu với trung bình quần thể giả thuyết/đã biết như mu =:\n\nt.test(linelist$age_years, mu = 45)\n\n\n\nKiểm định Shapiro-Wilk\nKiểm định Shapiro-Wilk có thể được sử để xác định xem một mẫu có phân bố bình thường/phân bố chuản hay không (một giả định của nhiều kiểm định khác, ví dụ như kiểm định t). Tuy nhiên, phép kiểm định này chỉ có thể được sử dụng cho một mẫu có từ 3 đến 5000 quan sát. Đối với cỡ mẫu lớn hơn, nên sử dụng biểu đồ quantile-quantile plot.\n\nshapiro.test(linelist$age_years)\n\n\n\nKiểm định tổng thứ hạng Wilcoxon\nKiểm định tổng thứ hạng Wilcoxon, hay còn gọi là kiểm định Mann–Whitney U, thường được sử dụng để giúp xác định xem hai mẫu có cùng phân bố hay không khi quần thể của chúng không có phân bố chuẩn hoặc có phương sai không bằng nhau.\n\n## compare age distribution by outcome group with a wilcox test\nwilcox.test(age_years ~ outcome, data = linelist)\n\n\n    Wilcoxon rank sum test with continuity correction\n\ndata:  age_years by outcome\nW = 2501868, p-value = 0.8308\nalternative hypothesis: true location shift is not equal to 0\n\n\n\n\nKiểm định Kruskal-Wallis\nKiểm định Kruskal-Wallis là một phần mở rộng của kiểm định tổng thứ hạng Wilcoxon mà có thể được sử dụng để kiểm định sự khác biệt trong phân bố của nhiều hơn hai mẫu. Khi có hai mẫu được sử dụng, nó cho kết quả giống như của kiểm định tổng thứ hạng Wilcoxon.\n\n## compare age distribution by outcome group with a kruskal-wallis test\nkruskal.test(age_years ~ outcome, linelist)\n\n\n    Kruskal-Wallis rank sum test\n\ndata:  age_years by outcome\nKruskal-Wallis chi-squared = 0.045675, df = 1, p-value = 0.8308\n\n\n\n\nKiểm định Chi bình phương\nKiểm định Chi bình phương của Pearson được sử dụng trong kiểm tra sự khác biệt có ý nghĩa thống kê giữa các biến phân loại.\n\n## compare the proportions in each group with a chi-squared test\nchisq.test(linelist$gender, linelist$outcome)\n\n\n    Pearson's Chi-squared test with Yates' continuity correction\n\ndata:  linelist$gender and linelist$outcome\nX-squared = 0.0011841, df = 1, p-value = 0.9725",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Các kiểm định thống kê cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.vn.html#rstatix-package",
    "href": "new_pages/stat_tests.vn.html#rstatix-package",
    "title": "18  Các kiểm định thống kê cơ bản",
    "section": "18.3 rstatix package",
    "text": "18.3 rstatix package\nPackage rstatix cho phép thực hiện các kiểm định thống kê và truy xuất kết quả “dễ sử dụng cho các tính toán tiếp theo”. Có nghĩa là kết quả xuất tự động thành một data frame để có thể thực hiện các thao tác tiếp theo. Nó cũng dễ dàng để nhóm dữ liệu mà sẽ được chuyền vào các hàm, ở đó các thống kê được thực hiện cho từng nhóm.\n\nTóm tắt thống kê\nHàm get_summary_stats() là một cách thực hiện tóm tắt thống kê nhanh. Chỉ cần đưa bộ số liệu và chỉ định các cột muốn phân tích vào hàm này. Nếu không có cột nào được cụ thể, tóm tắt thống kê sẽ tính toán cho tất cả các cột.\nTóm tắt thống kê đầy đủ sẽ cho kết quả mặc định như sau: số quan sát (n), giá trị nhỏ nhất, giá trị lớn nhất, trung vị, giá trị tứ phân vị thứ nhất (25%), giá trị tứ phân vị thứ ba (75%), khoảng tứ phân vị, độ lệch tuyệt đối của trung vị (mad), trung bình, độ lệch chuẩn, sai số chuẩn và khoảng tin cậy của trung bình.\n\nlinelist %&gt;%\n  rstatix::get_summary_stats(age, temp)\n\n# A tibble: 2 × 13\n  variable     n   min   max median    q1    q3   iqr    mad  mean     sd    se\n  &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 age       5802   0    84     13     6    23      17 11.9    16.1 12.6   0.166\n2 temp      5739  35.2  40.8   38.8  38.2  39.2     1  0.741  38.6  0.977 0.013\n# ℹ 1 more variable: ci &lt;dbl&gt;\n\n\nCó thể tóm tắt một số giá trị thống kê bằng cách cung cấp một trong số các giá trị sau đến type =: “full”, “common”, “robust”, “five_number”, “mean_sd”, “mean_se”, “mean_ci”, “median_iqr”, “median_mad”, “quantile”, “mean”, “median”, “min”, “max”.\nNó cũng có thể được sử dụng để nhóm số liệu, sao cho một hàng được trả về cho mỗi biến nhóm:\n\nlinelist %&gt;%\n  group_by(hospital) %&gt;%\n  rstatix::get_summary_stats(age, temp, type = \"common\")\n\n# A tibble: 12 × 11\n   hospital     variable     n   min   max median   iqr  mean     sd    se    ci\n   &lt;chr&gt;        &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 Central Hos… age        445   0    58     12    15    15.7 12.5   0.591 1.16 \n 2 Central Hos… temp       450  35.2  40.4   38.8   1    38.5  0.964 0.045 0.089\n 3 Military Ho… age        884   0    72     14    18    16.1 12.4   0.417 0.818\n 4 Military Ho… temp       873  35.3  40.5   38.8   1    38.6  0.952 0.032 0.063\n 5 Missing      age       1441   0    76     13    17    16.0 12.9   0.339 0.665\n 6 Missing      temp      1431  35.8  40.6   38.9   1    38.6  0.97  0.026 0.05 \n 7 Other        age        873   0    69     13    17    16.0 12.5   0.422 0.828\n 8 Other        temp       862  35.7  40.8   38.8   1.1  38.5  1.01  0.034 0.067\n 9 Port Hospit… age       1739   0    68     14    18    16.3 12.7   0.305 0.598\n10 Port Hospit… temp      1713  35.5  40.6   38.8   1.1  38.6  0.981 0.024 0.046\n11 St. Mark's … age        420   0    84     12    15    15.7 12.4   0.606 1.19 \n12 St. Mark's … temp       410  35.9  40.6   38.8   1.1  38.5  0.983 0.049 0.095\n\n\nBạn cũng có thể sử dụng rstatix để thực hiện các kiểm định thống kê:\n\n\nKiểm định t\nUSử dụng cú pháp để chỉ định cột biến liên tục và cột biến phân loại:\n\nlinelist %&gt;% \n  t_test(age_years ~ gender)\n\n# A tibble: 1 × 10\n  .y.   group1 group2    n1    n2 statistic    df        p    p.adj p.adj.signif\n* &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;int&gt; &lt;int&gt;     &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;       \n1 age_… f      m       2807  2803     -21.3 4902. 9.89e-97 9.89e-97 ****        \n\n\nHoặc sử dụng ~ 1 và ghi rõ mu = cho kiểm định t một mẫu. Cú pháp này có thể sử dụng để thực hiện cho nhóm.\n\nlinelist %&gt;% \n  t_test(age_years ~ 1, mu = 30)\n\n# A tibble: 1 × 7\n  .y.       group1 group2         n statistic    df     p\n* &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;      &lt;int&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 age_years 1      null model  5802     -84.2  5801     0\n\n\nNếu có thể, các kiểm định thống kê có thể thực hiện theo nhóm, như được trình bày bên dưới.\n\nlinelist %&gt;% \n  group_by(gender) %&gt;% \n  t_test(age_years ~ 1, mu = 18)\n\n# A tibble: 3 × 8\n  gender .y.       group1 group2         n statistic    df         p\n* &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;      &lt;int&gt;     &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;\n1 f      age_years 1      null model  2807    -29.8   2806 7.52e-170\n2 m      age_years 1      null model  2803      5.70  2802 1.34e-  8\n3 &lt;NA&gt;   age_years 1      null model   192     -3.80   191 1.96e-  4\n\n\n\n\nKiểm định Shapiro-Wilk\nNhư đã đề cập bên trên, cỡ mẫu phải nằm trong khoảng từ 3 đến 5000.\n\nlinelist %&gt;% \n  head(500) %&gt;%            # first 500 rows of case linelist, for example only\n  shapiro_test(age_years)\n\n# A tibble: 1 × 3\n  variable  statistic        p\n  &lt;chr&gt;         &lt;dbl&gt;    &lt;dbl&gt;\n1 age_years     0.917 6.67e-16\n\n\n\n\nKiểm định tổng thứ hạng Wilcoxon\n\nlinelist %&gt;% \n  wilcox_test(age_years ~ gender)\n\n# A tibble: 1 × 9\n  .y.       group1 group2    n1    n2 statistic        p    p.adj p.adj.signif\n* &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;  &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;       \n1 age_years f      m       2807  2803   2829274 3.47e-74 3.47e-74 ****        \n\n\n\n\nKiểm định Kruskal-Wallis\nCũng được biết như kiểm định Mann-Whitney U.\n\nlinelist %&gt;% \n  kruskal_test(age_years ~ outcome)\n\n# A tibble: 1 × 6\n  .y.           n statistic    df     p method        \n* &lt;chr&gt;     &lt;int&gt;     &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;         \n1 age_years  5888    0.0457     1 0.831 Kruskal-Wallis\n\n\n\n\nKiểm định Chi bình phương\nHàm kiểm định Chi bình phương chấp nhận một bảng, vì vậy đầu tiên là tạo một bảng chéo. Có nhiều cách để tạo một bảng chéo (xem chương Bảng mô tả) nhưng ở đây chúng ta sử dụng hàm tabyl() từ janitor avà bỏ cột ngoài cùng bên trái của nhãn giá trị trước khi đưa vào hàm chisq_test().\n\nlinelist %&gt;% \n  tabyl(gender, outcome) %&gt;% \n  select(-1) %&gt;% \n  chisq_test()\n\n# A tibble: 1 × 6\n      n statistic     p    df method          p.signif\n* &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt;           &lt;chr&gt;   \n1  5888      3.53 0.473     4 Chi-square test ns      \n\n\nCó rất nhiều hàm và kiểm định thống kê có thể được thực hiện bằng các hàm trong package rstatix. Đọc các tài liệu về rstatix online ở đây hoặc gõ ?rstatix.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Các kiểm định thống kê cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.vn.html#stats_gt",
    "href": "new_pages/stat_tests.vn.html#stats_gt",
    "title": "18  Các kiểm định thống kê cơ bản",
    "section": "18.4 gtsummary package",
    "text": "18.4 gtsummary package\nSử dụng package gtsummary nếu bạn đang muốn thêm kết quả của một kiểm định thống kê vào một bảng đẹp được tạo ra bằng package này (như đã được mô tả trong phần gtsummary của chương Bảng mô tả).\nKhi thực hiện các kiểm định so sánh bằng hàm tbl_summary, dùng thêm hàm add_p để đưa cột giá trị p và kiểm định được sử dụng vào bảng. Có thể xuất nhiều giá trị p mà được hiệu chỉnh cho nhiều kiểm định bằng cách dùng thêm hàm add_q. Gõ lệnh ?tbl_summary để biết thêm chi tiết.\n\nKiểm định Chi bình phương\nĐược sử dụng để so sánh các tỷ lệ của một biến phân loại trong hai nhóm. Kiểm định thống kê mặc định cho biến phân loại trong hàm add_p() là kiểm định Chi bình phương về tính độc lập với hiệu chỉnh liên tục, nhưng nếu có bất kỳ giá trị kỳ vọng nào nhỏ hơn 5 thì kiểm định chính xác của Fisher sẽ được sử dụng.\n\nlinelist %&gt;% \n  select(gender, outcome) %&gt;%    # keep variables of interest\n  tbl_summary(by = outcome) %&gt;%  # produce summary table and specify grouping variable\n  add_p()                        # specify what test to perform\n\n1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nDeath, N = 2,5821\nRecover, N = 1,9831\np-value2\n\n\n\n\ngender\n\n\n\n\n&gt;0.9\n\n\n    f\n1,227 (50%)\n953 (50%)\n\n\n\n\n    m\n1,228 (50%)\n950 (50%)\n\n\n\n\n    Unknown\n127\n80\n\n\n\n\n\n1 n (%)\n\n\n2 Pearson’s Chi-squared test\n\n\n\n\n\n\n\n\n\n\n\nKiểm định t\nĐược sử dụng để so sánh sự khác biệt về trung bình của một biến trung bình trong hai nhóm. Ví dụ như so sánh tuổi trung bình với kết cục của bệnh nhân.\n\nlinelist %&gt;% \n  select(age_years, outcome) %&gt;%             # keep variables of interest\n  tbl_summary(                               # produce summary table\n    statistic = age_years ~ \"{mean} ({sd})\", # specify what statistics to show\n    by = outcome) %&gt;%                        # specify the grouping variable\n  add_p(age_years ~ \"t.test\")                # specify what tests to perform\n\n1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nDeath, N = 2,5821\nRecover, N = 1,9831\np-value2\n\n\n\n\nage_years\n16 (12)\n16 (13)\n0.6\n\n\n    Unknown\n32\n28\n\n\n\n\n\n1 Mean (SD)\n\n\n2 Welch Two Sample t-test\n\n\n\n\n\n\n\n\n\n\n\nKiểm định tổng thứ hạng Wilcoxon\nĐược dùng để so sánh sự phân bố của một biến liên tục trong hai nhóm. Kiểm định mặc định là kiểm định tổng thứ hang Wilcoxon và trung vị (khoảng tứ phân vị IQR) khi so sánh hai nhóm. Tuy nhiên, đối với số liệu không có phân bố chuẩn hoặc so sánh nhiều nhóm, kiểm định Kruskal-wallis là kiểm định thích hợp hơn.\n\nlinelist %&gt;% \n  select(age_years, outcome) %&gt;%                       # keep variables of interest\n  tbl_summary(                                         # produce summary table\n    statistic = age_years ~ \"{median} ({p25}, {p75})\", # specify what statistic to show (this is default so could remove)\n    by = outcome) %&gt;%                                  # specify the grouping variable\n  add_p(age_years ~ \"wilcox.test\")                     # specify what test to perform (default so could leave brackets empty)\n\n1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nDeath, N = 2,5821\nRecover, N = 1,9831\np-value2\n\n\n\n\nage_years\n13 (6, 23)\n13 (6, 23)\n0.8\n\n\n    Unknown\n32\n28\n\n\n\n\n\n1 Median (IQR)\n\n\n2 Wilcoxon rank sum test\n\n\n\n\n\n\n\n\n\n\n\nKiểm định Kruskal-wallis\nĐược sử dụng để so sánh sự phân bố của một biến liên tục trong hai hay nhiều nhóm, bất kể số liệu có phân bố chuẩn hay không.\n\nlinelist %&gt;% \n  select(age_years, outcome) %&gt;%                       # keep variables of interest\n  tbl_summary(                                         # produce summary table\n    statistic = age_years ~ \"{median} ({p25}, {p75})\", # specify what statistic to show (default, so could remove)\n    by = outcome) %&gt;%                                  # specify the grouping variable\n  add_p(age_years ~ \"kruskal.test\")                    # specify what test to perform\n\n1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nDeath, N = 2,5821\nRecover, N = 1,9831\np-value2\n\n\n\n\nage_years\n13 (6, 23)\n13 (6, 23)\n0.8\n\n\n    Unknown\n32\n28\n\n\n\n\n\n1 Median (IQR)\n\n\n2 Kruskal-Wallis rank sum test",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Các kiểm định thống kê cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.vn.html#tương-quan",
    "href": "new_pages/stat_tests.vn.html#tương-quan",
    "title": "18  Các kiểm định thống kê cơ bản",
    "section": "18.5 Tương quan",
    "text": "18.5 Tương quan\nMối tương quan giữa các biến định lượng có thể được kiển bằng cách sử dụng lệnh corrr từ package tidyverse. Lệnh này cũng cho phép tính các hệ số tương quan bằng phương pháp Pearson, Kendall hoặc Spearman. Gói lệnh này tạo ra một bảng kết quả và cũng có chức năng tự động vẽ các giá trị.\n\ncorrelation_tab &lt;- linelist %&gt;% \n  select(generation, age, ct_blood, days_onset_hosp, wt_kg, ht_cm) %&gt;%   # keep numeric variables of interest\n  correlate()      # create correlation table (using default pearson)\n\ncorrelation_tab    # print\n\n# A tibble: 6 × 7\n  term            generation      age ct_blood days_onset_hosp    wt_kg    ht_cm\n  &lt;chr&gt;                &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;           &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n1 generation        NA       -2.22e-2  0.179         -0.288    -0.0302  -0.00942\n2 age               -0.0222  NA        0.00849       -0.000635  0.833    0.877  \n3 ct_blood           0.179    8.49e-3 NA             -0.600    -0.00636  0.0181 \n4 days_onset_hosp   -0.288   -6.35e-4 -0.600         NA         0.0153  -0.00953\n5 wt_kg             -0.0302   8.33e-1 -0.00636        0.0153   NA        0.884  \n6 ht_cm             -0.00942  8.77e-1  0.0181        -0.00953   0.884   NA      \n\n## remove duplicate entries (the table above is mirrored) \ncorrelation_tab &lt;- correlation_tab %&gt;% \n  shave()\n\n## view correlation table \ncorrelation_tab\n\n# A tibble: 6 × 7\n  term            generation       age ct_blood days_onset_hosp  wt_kg ht_cm\n  &lt;chr&gt;                &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;           &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 generation        NA       NA        NA              NA       NA        NA\n2 age               -0.0222  NA        NA              NA       NA        NA\n3 ct_blood           0.179    0.00849  NA              NA       NA        NA\n4 days_onset_hosp   -0.288   -0.000635 -0.600          NA       NA        NA\n5 wt_kg             -0.0302   0.833    -0.00636         0.0153  NA        NA\n6 ht_cm             -0.00942  0.877     0.0181         -0.00953  0.884    NA\n\n## plot correlations \nrplot(correlation_tab)",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Các kiểm định thống kê cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.vn.html#nguồn",
    "href": "new_pages/stat_tests.vn.html#nguồn",
    "title": "18  Các kiểm định thống kê cơ bản",
    "section": "18.6 Nguồn",
    "text": "18.6 Nguồn\nPhần lớn thông tin trong phần này được phỏng theo các nguồn sau:\ngtsummary dplyr corrr sthda correlation",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Các kiểm định thống kê cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.vn.html",
    "href": "new_pages/regression.vn.html",
    "title": "19  Hồi quy đơn và đa biến",
    "section": "",
    "text": "19.1 Chuẩn bị",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Hồi quy đơn và đa biến</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.vn.html#chuẩn-bị",
    "href": "new_pages/regression.vn.html#chuẩn-bị",
    "title": "19  Hồi quy đơn và đa biến",
    "section": "",
    "text": "Gọi packages\nĐoạn mã này hiển thị cách tải các gói lệnh cần thiết cho phân tích. Trong cuốn sổ tay này, chúng tôi nhấn mạnh hàm p_load() thuộc package pacman, giúp cài đặt package khi cần thiết và gọi nó ra để sử dụng. Có thể gọi các package đã cài đặt bằng hàm library() trong base R. Xem thêm thông tin về các package của R trong chương R cơ bản.\n\npacman::p_load(\n  rio,          # File import\n  here,         # File locator\n  tidyverse,    # data management + ggplot2 graphics, \n  stringr,      # manipulate text strings \n  purrr,        # loop over objects in a tidy way\n  gtsummary,    # summary statistics and tests \n  broom,        # tidy up results from regressions\n  lmtest,       # likelihood-ratio tests\n  parameters,   # alternative to tidy up results from regressions\n  see          # alternative to visualise forest plots\n  )\n\n\n\nNhập số liệu\nChúng tôi nhập bộ số liệu của các ca bệnh được mô phỏng từ một vụ dịch Ebola. Để tiện làm theo, bấm để tải số liệu linelist “đã được làm sạch” (dưới dạng tệp .rds ). Nhập số liệu này bằng hàm import() trong package rio (nó chấp nhận nhiều loại tập tin như .xlsx, .rds, .csv – xem chi tiết trong chương Nhập xuất dữ liệu).\n\n# import the linelist\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nBên dưới là hiển thị của 50 hàng đầu tiên của bộ số liệu linelist.\n\n\n\n\n\n\n\n\nLàm sạch số liệu\n\nLưu trữ các biến giải thích\nTên của các biến giải thích sẽ được lưu trữ dưới dạng một véc tơ ký tự. Véc tơ này sẽ được đề cập về sau.\n\n## define variables of interest \nexplanatory_vars &lt;- c(\"gender\", \"fever\", \"chills\", \"cough\", \"aches\", \"vomit\")\n\n\n\nChuyển đổi sang số 1 và số 0\nSau đây, giá trị của các biến giải thích được chuyển đổi từ “có”/“không”, “nam”/“nữ” và “chết”/“sống” thành 1 / 0, để hợp với các đặc tính của mô hình hồi quy logistic. TĐể thực hiện việc này một cách hiệu quả, sử dụng hàm across() từ dplyr để chuyển đổi nhiều biến cùng một lúc. Để áp dụng cho mỗi biến, dùng hàm case_when() (cũng trong package dplyr) để chuyển đổi các giá trị cụ thể thành 1 và 0. Xem các mục về across() và case_when() trong chương Làm sạch số liệu và các hàm quan trọng).\nChú ý: dấu “.” bên dưới đại diện cho cột`````đang được xử lý trong hàmacross()` tại thời điểm đó.\n\n## convert dichotomous variables to 0/1 \nlinelist &lt;- linelist %&gt;%  \n  mutate(across(                                      \n    .cols = all_of(c(explanatory_vars, \"outcome\")),  ## for each column listed and \"outcome\"\n    .fns = ~case_when(                              \n      . %in% c(\"m\", \"yes\", \"Death\")   ~ 1,           ## recode male, yes and death to 1\n      . %in% c(\"f\", \"no\",  \"Recover\") ~ 0,           ## female, no and recover to 0\n      TRUE                            ~ NA_real_)    ## otherwise set to missing\n    )\n  )\n\n\n\nLoại bỏ các hàng có giá trị missing\nĐể bỏ các hàng có giá trị missing, dùng hàm drop_na() trong package tidyr. Tuy nhiên, chúng ta chỉ muốn thực hiện điều này cho các hàng có giá trị missing đối với các cột đang được quan tâm.\nTrước hết, chúng ta phải đảm bảo rằng vectơ explanatory_vars bao gồm các biến age (age có thể tạo ra một lỗi trong thao tác của hàm case_when() trước đó, mà chỉ dành cho biến nhị phân). Sau đó chúng ta pipe bộ dữ liệu linelist tới hàm drop_na() để bỏ các hàng có giá trị missing cho biến outcome hoặc bất kỳ biển giải thích explanatory_vars nào.\nTrước khi thực hiện các lệnh này, kiểm tra số hàng trong bộ số liệu linelist bằng hàm nrow(linelist).\n\n## add in age_category to the explanatory vars \nexplanatory_vars &lt;- c(explanatory_vars, \"age_cat\")\n\n## drop rows with missing information for variables of interest \nlinelist &lt;- linelist %&gt;% \n  drop_na(any_of(c(\"outcome\", explanatory_vars)))\n\nKiểm tra số hàng còn lại của linelist bằng hàm nrow(linelist).",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Hồi quy đơn và đa biến</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.vn.html#phân-tích-đơn-biến",
    "href": "new_pages/regression.vn.html#phân-tích-đơn-biến",
    "title": "19  Hồi quy đơn và đa biến",
    "section": "19.2 Phân tích đơn biến",
    "text": "19.2 Phân tích đơn biến\nCũng giống như chương Bảng mô tả, chúng ta cần xác định packahe nào trong R mà chúng ta muốn sử dụng. Chúng tôi trình bày hai chọn lựa để thực hiện các phân tích đơn biến:\n\nDùng hàm có sẵn trong base để in nhanh kết quả ra console. Sử dụng package broom để làm gọn kết quả.\n\nDùng package gtsummary để lập mô hình và nhận các kết quả đầu ra sẵn sàng để công bố\n\n\n\nbase R\n\nHồi quy tuyến tính\nHàm lm() trong base cho phép thực hiện hồi quy tuyến tính để đánh giá mối quan hệ giữa biến đầu ra dạng số (numeric) và các biến giải thích mà được giả định là có mối quan hệ tuyến tính.\nCung cấp phương trình dưới dạng công thức với tên của biến đầu ra và các biến giải thích được phân tách bằng dấu ngã ~. Bên cạnh đó, chỉ rõ bộ số liệu nào được sử dụng với data =. Kết quả của mô hình được định nghĩa dưới dạng đối tượng của R để sử dụng về sau.\n\nlm_results &lt;- lm(ht_cm ~ age, data = linelist)\n\nSau đó tóm tắt kết quả của mô hình bằng hàm summary() để xem các hệ số (ước tính), P-value, phần dư và các đo lường khác.\n\nsummary(lm_results)\n\n\nCall:\nlm(formula = ht_cm ~ age, data = linelist)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-128.579  -15.854    1.177   15.887  175.483 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  69.9051     0.5979   116.9   &lt;2e-16 ***\nage           3.4354     0.0293   117.2   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 23.75 on 4165 degrees of freedom\nMultiple R-squared:  0.7675,    Adjusted R-squared:  0.7674 \nF-statistic: 1.375e+04 on 1 and 4165 DF,  p-value: &lt; 2.2e-16\n\n\nNgoài ra, có thể dùng hàm tidy() trong package broom để xuất kết quả vào trong một bảng. Kết quả bên dưới cho chúng ta biết khi tăng thêm một tuổi thì chiều cao tăng 3,5 cm và mối quan hệ này có ý nghĩa thống kê.\n\ntidy(lm_results)\n\n# A tibble: 2 × 5\n  term        estimate std.error statistic p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;\n1 (Intercept)    69.9     0.598       117.       0\n2 age             3.44    0.0293      117.       0\n\n\nSau đó, có thể sử dụng kết quả hồi quy này để đưa vào ggplot. Để thực hiện điều này, trước tiên chúng ta đưa các giá trị quan sát và đường thẳng hồi quy (fitted line) vào một data frame bằng cách dùng hàm augment() trong package broom.\n\n## pull the regression points and observed data in to one dataset\npoints &lt;- augment(lm_results)\n\n## plot the data using age as the x-axis \nggplot(points, aes(x = age)) + \n  ## add points for height \n  geom_point(aes(y = ht_cm)) + \n  ## add your regression line \n  geom_line(aes(y = .fitted), colour = \"red\")\n\n\n\n\n\n\n\n\nBạn cũng có thể vẽ đường hồi quy tuyến tính đơn bằng package ggplot thông qua hàm geom_smooth().\n\n## add your data to a plot \n ggplot(linelist, aes(x = age, y = ht_cm)) + \n  ## show points\n  geom_point() + \n  ## add a linear regression \n  geom_smooth(method = \"lm\", se = FALSE)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nXem thêm các hướng dẫn chi tiết trong mục Nguồn ở cuối chương này.\n\n\nHồi quy Logistic\nHàm glm() trong package stats (một phần của base R) được sử dụng để fit (chọn mô hình dự đoán tối ưu dựa trên số liệu quan sát) đối với Mô hình Tuyến tính Tổng quát (GLM).\nglm() có thể được sử dụng cho cả hồi quy logistic đơn biến và đa biến (ví dụ như để tính tỷ số chênh OR). Sau đây là những thành phần chính của hàm:\n\n# arguments for glm()\nglm(formula, family, data, weights, subset, ...)\n\n\nformula = Mô hình được cung cấp cho glm() dưới dạng một phương trình với biến kết cục ở bên trái và biến giải thích ở bên phải dấu ngã ~.\n\nfamily = Xác định loại mô hình sẽ thực hiện. Đối với hồi quy logistic, sử dụng family = \"binomial\", đối với hồi quy poisson sử dụng family = \"poisson\". Các ví dụ khác được trình bày trong bảng bên dưới.\n\ndata = Cụ thể bộ số liệu\n\nNếu cần, có thể cụ thể hàm liên kết bằng cú pháp family = familytype(link = \"linkfunction\")). Bạn có thể tìm đọc thêm về các họ hồi quy khác và các tùy chọn đối số như là weights = và subset = bằng cách gõ (?glm).\n\n\n\nHọ\nHàm liên kết mặc định\n\n\n\n\n\"binomial\"\n(link = \"logit\")\n\n\n\"gaussian\"\n(link = \"identity\")\n\n\n\"Gamma\"\n(link = \"inverse\")\n\n\n\"inverse.gaussian\"\n(link = \"1/mu^2\")\n\n\n\"poisson\"\n(link = \"log\")\n\n\n\"quasi\"\n(link = \"identity\", variance = \"constant\")\n\n\n\"quasibinomial\"\n(link = \"logit\")\n\n\n\"quasipoisson\"\n(link = \"log\")\n\n\n\nKhi thực hiện glm() , phổ biến nhất là lưu kết quả dưới dạng một đối tượng của R được đặt tên. Sau đó, có thể xuất kết quả ra console bằng cách sử dụng hàm summary() như được trình bày bên dưới, hoặc thực hiện các thao tác khác từ kết quả (ví dụ như lấy lũy thừa).\nNếu cần thực hiện một hồi quy nhị thức âm, có thể sử dụng package MASS. Hàn glm.nb() uses cũng sử dụng cùng cú pháp như glm(). Để xem qua các hồi quy khác, xem trên trang thống kê của UCLA.\n\n\nPhân tích đơn biến sử dụng glm()\nTrong ví dụ này, chúng tôi đánh giá mối liên quan giữa nhóm tuổi và biến kết cục tử vong (được mã hóa là 1 trong phần chuẩn bị). Bên dưới là một mô hình đơn biến của biến kết cục outcome theo age_cat. Chúng tôi lưu kết quả đầu ra được đặt tên là model và sau đó in kết quả đến console bằng hàm summary(). Lưu ý, các ước tính được tạo ra là các giá trị lôgarít của tỷ số chênh (log odds) và giá trị tham chiếu là giá trị đầu tiên của biến age_cat (“0-4”).\n\nmodel &lt;- glm(outcome ~ age_cat, family = \"binomial\", data = linelist)\nsummary(model)\n\n\nCall:\nglm(formula = outcome ~ age_cat, family = \"binomial\", data = linelist)\n\nCoefficients:\n              Estimate Std. Error z value Pr(&gt;|z|)   \n(Intercept)   0.233738   0.072805   3.210  0.00133 **\nage_cat5-9   -0.062898   0.101733  -0.618  0.53640   \nage_cat10-14  0.138204   0.107186   1.289  0.19726   \nage_cat15-19 -0.005565   0.113343  -0.049  0.96084   \nage_cat20-29  0.027511   0.102133   0.269  0.78765   \nage_cat30-49  0.063764   0.113771   0.560  0.57517   \nage_cat50-69 -0.387889   0.259240  -1.496  0.13459   \nage_cat70+   -0.639203   0.915770  -0.698  0.48518   \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 5712.4  on 4166  degrees of freedom\nResidual deviance: 5705.1  on 4159  degrees of freedom\nAIC: 5721.1\n\nNumber of Fisher Scoring iterations: 4\n\n\nĐể thay đổi giá trị tham chiếu của một biến Factor và chuyển giá trị mong muốn lên vị trí đầu tiên, dùng hàm fct_relevel() (xem chương Factors). Ở ví dụ bên dưới, chúng tôi lấy biến age_cat và đặt nhóm tuổi “20-29” làm giá trị tham chiếu trước khi chuyển số liệu đã sửa đổi vào hàm glm().\n\nlinelist %&gt;% \n  mutate(age_cat = fct_relevel(age_cat, \"20-29\", after = 0)) %&gt;% \n  glm(formula = outcome ~ age_cat, family = \"binomial\") %&gt;% \n  summary()\n\n\nCall:\nglm(formula = outcome ~ age_cat, family = \"binomial\", data = .)\n\nCoefficients:\n             Estimate Std. Error z value Pr(&gt;|z|)    \n(Intercept)   0.26125    0.07163   3.647 0.000265 ***\nage_cat0-4   -0.02751    0.10213  -0.269 0.787652    \nage_cat5-9   -0.09041    0.10090  -0.896 0.370220    \nage_cat10-14  0.11069    0.10639   1.040 0.298133    \nage_cat15-19 -0.03308    0.11259  -0.294 0.768934    \nage_cat30-49  0.03625    0.11302   0.321 0.748390    \nage_cat50-69 -0.41540    0.25891  -1.604 0.108625    \nage_cat70+   -0.66671    0.91568  -0.728 0.466546    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 5712.4  on 4166  degrees of freedom\nResidual deviance: 5705.1  on 4159  degrees of freedom\nAIC: 5721.1\n\nNumber of Fisher Scoring iterations: 4\n\n\n\n\nIn kết quả\nĐối với hầu hết các mục đích sử dụng, kết quả đầu ra cần phải có một số sửa đổi. Hàm làm gọn tidy() trong package broom có những tiện lợi để hiển thị kết quả của mô hình.\nỞ đây, chúng tôi trình bày cách để kết hợp các kết quả đầu ra của mô hình vào trong một bảng.\n\nLấy lũy thừa logarit của ước lượng tỉ số chênh OR và khoảng tin cậy bằng cách đưa mô hình vào hàm tidy() và thiết lập lũy thừa exponentiate = TRUE và conf.int = TRUE.\n\n\nmodel &lt;- glm(outcome ~ age_cat, family = \"binomial\", data = linelist) %&gt;% \n  tidy(exponentiate = TRUE, conf.int = TRUE) %&gt;%        # exponentiate and produce CIs\n  mutate(across(where(is.numeric), round, digits = 2))  # round all numeric columns\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `across(where(is.numeric), round, digits = 2)`.\nCaused by warning:\n! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\nSupply arguments directly to `.fns` through an anonymous function instead.\n\n  # Previously\n  across(a:b, mean, na.rm = TRUE)\n\n  # Now\n  across(a:b, \\(x) mean(x, na.rm = TRUE))\n\n\nBên dưới là bảng kết quả đầu ra của model:\n\n\n\n\n\n\n\nKết hợp các kết quả của mô hình vào trong một bảng đếm. Dưới đây, chúng tôi tạo một bảng đếm bằng hàm tabyl() từ package janitor, như được đề cập trong chương Bảng mô tả.\n\n\ncounts_table &lt;- linelist %&gt;% \n  janitor::tabyl(age_cat, outcome)\n\n\n\n\n\n\n\n\n\n\n\nĐây là cách mà bảng counts_table được hiển thị:\n\n\n\n\n\n\nBây giờ chúng ta có thể nối bảng counts_table và kết quả của mô hình model lại với nhau theo chiều ngang bằng hàm nối cột bind_cols() (dplyr). Hãy nhớ rằng đối với hàm bind_cols() các hàng trong hai cấu trúc dữ liệu trên phải được căn chỉnh hoàn hảo. Trong đoạn code này, bởi vì chúng ta đang thực hiện một chuỗi các thuật toán pipe, chúng ta sử dụng dấu . để đại diện cho đối tượng được nối trong bảng đếm counts_table khi chúng tôi nối nó với kết quả mô hình model. Để kết thúc quy trình này, chúng ta sử dụng hàm select() để chọn các cột mong muốn và thứ tự của nó, và cuối cùng áp dụng hàm round() trong base R để làm tròn với hai chữ số thập phân cho tất cả các cột.\n\ncombined &lt;- counts_table %&gt;%           # begin with table of counts\n  bind_cols(., model) %&gt;%              # combine with the outputs of the regression \n  select(term, 2:3, estimate,          # select and re-order cols\n         conf.low, conf.high, p.value) %&gt;% \n  mutate(across(where(is.numeric), round, digits = 2)) ## round to 2 decimal places\n\nĐây là hiển thị của cấu trúc đã được kết hợp, nó được xuất gọn gẽ dưới dạng một hình bằng thông qua một hàm trong package flextable. Chương Trình bày bảng giải thích cách tùy chỉnh các bảng như vậy bằng flextable, hoặc có thể sử dụng các gói lệnh khác như knitr hoặc GT.\n\ncombined &lt;- combined %&gt;% \n  flextable::qflextable()\n\n\n\nVòng lặp cho nhiều mô hình đơn biến\nSau đây chúng tôi trình bày một phương pháp sử dụng glm() và tidy() để có một cách tiếp cận đơn giản hơn, xem thêm ở phần gtsummary.\nĐể thực hiện các mô hình cho một số biến giải thích và cho ra các tỷ số chênh trong phân tích đơn biến (nghĩa là không có kiểm soát lẫn nhau), chúng ta có thể sử dụng các cách tiếp cận dưới đây. Sử dụng hàm str_c() từ package stringr để tạo ra các công thức cho phân tích đơn biến (xem chương Ký tự và chuỗi), thực hiện hàm glm() cho mỗi công thức, chuyển mỗi kết quả đầu ra của glm() đến hàm tidy() và cuối cùng thu gọn lại tất các kết quả đầu ra của mô hình bằng hàm nối dòng bind_rows() từ tidyr. Phương pháp này sử dụng hàm map() từ package purrr để lặp - xem chương Lặp, vòng lặp và danh sách để biết thêm thông tin về công cụ này.\n\nTạo một véctơ tên các cột của biến giải thích. Chúng ta đã tạo biến này explanatory_vars trong phần chuẩn bị của chương này.\nSử dụng hàm str_c() để tạo các công thức chuỗi với biến kết cục outcome ở bên trái và tên một cột của véctơ explanatory_vars ở bên phải. Dấu chấm . trong hàm này thay thế cho tên cột trong véctơ explanatory_vars.\n\n\nexplanatory_vars %&gt;% str_c(\"outcome ~ \", .)\n\n[1] \"outcome ~ gender\"  \"outcome ~ fever\"   \"outcome ~ chills\" \n[4] \"outcome ~ cough\"   \"outcome ~ aches\"   \"outcome ~ vomit\"  \n[7] \"outcome ~ age_cat\"\n\n\n\nĐưa các công thức chuỗi này vào hàm map() và đặt ~glm() làm hàm áp dụng cho mỗi đầu vào. Bên trong hàm glm(), thiết lập công thức hồi quy as.formula(.x) trong đó .x sẽ được thay thế bằng các công thức chuỗi đã được tạo bên trên. Hàm map() sẽ lặp từng công thức chuỗi và thực hiện hồi quy cho từng công thức.\nKết quả đầu ra của hàm map() đầu tiên sẽ được chuyển đến hàm map() thứ hai mà sử dụng hàm tidy() để làm gọn các kết quả đầu ra.\nCuối cùng, kết quả đầu ra của hàm map() thứ hai (một danh sách các data frames đã được làm gọn) được tóm tắt bằng hàm nối dòng bind_rows(), kết quả cho ra một data frame với tất cả các kết quả đơn biến.\n\n\nmodels &lt;- explanatory_vars %&gt;%       # begin with variables of interest\n  str_c(\"outcome ~ \", .) %&gt;%         # combine each variable into formula (\"outcome ~ variable of interest\")\n  \n  # iterate through each univariate formula\n  map(                               \n    .f = ~glm(                       # pass the formulas one-by-one to glm()\n      formula = as.formula(.x),      # within glm(), the string formula is .x\n      family = \"binomial\",           # specify type of glm (logistic)\n      data = linelist)) %&gt;%          # dataset\n  \n  # tidy up each of the glm regression outputs from above\n  map(\n    .f = ~tidy(\n      .x, \n      exponentiate = TRUE,           # exponentiate \n      conf.int = TRUE)) %&gt;%          # return confidence intervals\n  \n  # collapse the list of regression outputs in to one data frame\n  bind_rows() %&gt;% \n  \n  # round all numeric columns\n  mutate(across(where(is.numeric), round, digits = 2))\n\nLúc này, kết quả xuất ra của models dài hơn bởi vì kết quả bây giờ bao gồm các kết quả đầu ra của một số hồi quy đơn biến. Nhấp nút tiếp theo để xem tất cả các hàng của model.\n\n\n\n\n\n\nNhư lúc trước, chúng ta có thể tạo một bảng đếm từ bộ số liệu linelist cho mỗi biến giải thích, gắn chúng với models, và tạo ra một bảng đẹp. Chúng ta bắt đầu với các biến giải thích này, và lặp lại các biến này thông qua hàm map(). Chúng ta lặp lại qua một hàm do người dùng tạo ra mà liên quan đến việc tạo ra một bảng đếm bằng cách dùng các hàm trong package dplyr Sau đó, kết quả được kết nối trình tự với kết quả của mô hình models.\n\n## for each explanatory variable\nuniv_tab_base &lt;- explanatory_vars %&gt;% \n  map(.f = \n    ~{linelist %&gt;%                ## begin with linelist\n        group_by(outcome) %&gt;%     ## group data set by outcome\n        count(.data[[.x]]) %&gt;%    ## produce counts for variable of interest\n        pivot_wider(              ## spread to wide format (as in cross-tabulation)\n          names_from = outcome,\n          values_from = n) %&gt;% \n        drop_na(.data[[.x]]) %&gt;%         ## drop rows with missings\n        rename(\"variable\" = .x) %&gt;%      ## change variable of interest column to \"variable\"\n        mutate(variable = as.character(variable))} ## convert to character, else non-dichotomous (categorical) variables come out as factor and cant be merged\n      ) %&gt;% \n  \n  ## collapse the list of count outputs in to one data frame\n  bind_rows() %&gt;% \n  \n  ## merge with the outputs of the regression \n  bind_cols(., models) %&gt;% \n  \n  ## only keep columns interested in \n  select(term, 2:3, estimate, conf.low, conf.high, p.value) %&gt;% \n  \n  ## round decimal places\n  mutate(across(where(is.numeric), round, digits = 2))\n\nBên dưới là cấu trúc số liệu kết nối được tạo ra. Xem chương Trình bày bảng để có thêm ý tưởng về cách chuyển đổi bảng số liệu này thành một bảng đẹp trên HTML (ví dụ như với package flextable).\n\n\n\n\n\n\n\n\n\n\ngtsummary package\nSau đây chúng tôi sẽ trình bày cách sử dụng hàm tbl_uvregression() từ package gtsummary. Cũng giống như trong chương Bảng mô tả, các hàm trong gtsummary thực hiện tốt các thống kê và xuất ra các kết quả khá chuyên nghiệp. Hàm này xuất ra một bảng kết quả của hồi quy đơn biến.\nChúng ta chỉ chọn các cột cần thiết từ bộ số liệu linelist (ecác biến giải thích và biến kết cục) và pipe chúng vào hàm tbl_uvregression(). Chúng ta sẽ thực hiện hồi quy đơn biến cho mỗi cột như được xác định trong véctơ explanatory_vars trong mục Chuẩn bị (gender, fever, chills, cough, aches, vomit, và age_cat).\nTrong hàm này, chúng ta cung cấp thêm phương pháp thực hiện method = là glm (không có dấu ngoặc kép), biến kết cục y = cột kết quả (biến outcome), cụ thể method.args = mà chúng ta muốn thực hiện hồi quy logistic qua family = binomial, và lấy lũy thừa của kết quả.\nKết quả đầu ra dưới dạng HTML và chứa cột đếm\n\nuniv_tab &lt;- linelist %&gt;% \n  dplyr::select(explanatory_vars, outcome) %&gt;% ## select variables of interest\n\n  tbl_uvregression(                         ## produce univariate table\n    method = glm,                           ## define regression want to run (generalised linear model)\n    y = outcome,                            ## define outcome variable\n    method.args = list(family = binomial),  ## define what type of glm want to run (logistic)\n    exponentiate = TRUE                     ## exponentiate to produce odds ratios (rather than log odds)\n  )\n\n## view univariate results table \nuniv_tab\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nN\nOR1\n95% CI1\np-value\n\n\n\n\ngender\n4,167\n1.00\n0.88, 1.13\n&gt;0.9\n\n\nfever\n4,167\n1.00\n0.85, 1.17\n&gt;0.9\n\n\nchills\n4,167\n1.03\n0.89, 1.21\n0.7\n\n\ncough\n4,167\n1.15\n0.97, 1.37\n0.11\n\n\naches\n4,167\n0.93\n0.76, 1.14\n0.5\n\n\nvomit\n4,167\n1.09\n0.96, 1.23\n0.2\n\n\nage_cat\n4,167\n\n\n\n\n\n\n\n\n    0-4\n\n\n—\n—\n\n\n\n\n    5-9\n\n\n0.94\n0.77, 1.15\n0.5\n\n\n    10-14\n\n\n1.15\n0.93, 1.42\n0.2\n\n\n    15-19\n\n\n0.99\n0.80, 1.24\n&gt;0.9\n\n\n    20-29\n\n\n1.03\n0.84, 1.26\n0.8\n\n\n    30-49\n\n\n1.07\n0.85, 1.33\n0.6\n\n\n    50-69\n\n\n0.68\n0.41, 1.13\n0.13\n\n\n    70+\n\n\n0.53\n0.07, 3.20\n0.5\n\n\n\n1 OR = Odds Ratio, CI = Confidence Interval\n\n\n\n\n\n\n\n\n\nChúng ta có thể sửa đổi đối với kết quả đầu ra của bảng này, ví dụ như điều chỉnh các nhãn, tô đậm các hàng theo giá trị p, .v.v. Xem hướng dẫn tại đây và các tài liệu trực tuyến khác.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Hồi quy đơn và đa biến</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.vn.html#phân-tích-phân-tầng",
    "href": "new_pages/regression.vn.html#phân-tích-phân-tầng",
    "title": "19  Hồi quy đơn và đa biến",
    "section": "19.3 Phân tích phân tầng",
    "text": "19.3 Phân tích phân tầng\nHiện tại, phân tích phần tầng sử dụng package gtsummary đang được xây dựng, phần này sẽ được cập nhật trong thời gian thích hợp.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Hồi quy đơn và đa biến</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.vn.html#phân-tích-đa-biến",
    "href": "new_pages/regression.vn.html#phân-tích-đa-biến",
    "title": "19  Hồi quy đơn và đa biến",
    "section": "19.4 Phân tích đa biến",
    "text": "19.4 Phân tích đa biến\nĐối với phân tích đa biến, chúng tôi trình bày hai cách tiếp cận:\n\nglm() và tidy()\n\nPackage gtsummary\n\nQuy trình thực hiện khá tương tự và chỉ khác ở bước cuối cùng để kết nối kết quả lại với nhau.\n\nThực hiện phân tích đa biến\nỞ đây chúng tôi sử dụng hàm glm() nhưng thêm nhiều biến hơn vào bên phải của phương trình và được phân tách với nhau bằng dấu cộng (+).\nĐể thực hiện mô hình với tất cả các biến giải thích, chúng ta thực hiện lệnh sau:\n\nmv_reg &lt;- glm(outcome ~ gender + fever + chills + cough + aches + vomit + age_cat, family = \"binomial\", data = linelist)\n\nsummary(mv_reg)\n\n\nCall:\nglm(formula = outcome ~ gender + fever + chills + cough + aches + \n    vomit + age_cat, family = \"binomial\", data = linelist)\n\nCoefficients:\n              Estimate Std. Error z value Pr(&gt;|z|)\n(Intercept)   0.069054   0.131726   0.524    0.600\ngender        0.002448   0.065133   0.038    0.970\nfever         0.004309   0.080522   0.054    0.957\nchills        0.034112   0.078924   0.432    0.666\ncough         0.138584   0.089909   1.541    0.123\naches        -0.070705   0.104078  -0.679    0.497\nvomit         0.086098   0.062618   1.375    0.169\nage_cat5-9   -0.063562   0.101851  -0.624    0.533\nage_cat10-14  0.136372   0.107275   1.271    0.204\nage_cat15-19 -0.011074   0.113640  -0.097    0.922\nage_cat20-29  0.026552   0.102780   0.258    0.796\nage_cat30-49  0.059569   0.116402   0.512    0.609\nage_cat50-69 -0.388964   0.262384  -1.482    0.138\nage_cat70+   -0.647443   0.917375  -0.706    0.480\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 5712.4  on 4166  degrees of freedom\nResidual deviance: 5700.2  on 4153  degrees of freedom\nAIC: 5728.2\n\nNumber of Fisher Scoring iterations: 4\n\n\nNếu muốn bao gồm hai biến và tương tác của hai biến này, chúng ta có thể phân tách chúng bằng dấu hoa thị * thay cho dấu +. Nếu chúng ta chỉ muốn cụ thể sự tương tác, phân tách chúng bằng dấu hai chấm :. Ví dụ:\n\nglm(outcome ~ gender + age_cat * fever, family = \"binomial\", data = linelist)\n\nMột tùy chọn khác, chúng ta có thể sử dụng đoạn mã này để sử dụng một véc tơ đã được định nghĩa trước của các cột và tạo lại lệnh trên bằng cách sử dụng hàm str_c(). Điều này có thể hữu ích nếu chúng ta thay đổi tên các biến giải thích, hoặc bạn không muốn gõ lại tất cả mọi thứ.\n\n## run a regression with all variables of interest \nmv_reg &lt;- explanatory_vars %&gt;%  ## begin with vector of explanatory column names\n  str_c(collapse = \"+\") %&gt;%     ## combine all names of the variables of interest separated by a plus\n  str_c(\"outcome ~ \", .) %&gt;%    ## combine the names of variables of interest with outcome in formula style\n  glm(family = \"binomial\",      ## define type of glm as logistic,\n      data = linelist)          ## define your dataset\n\n\nXây dựng mô hình\nChúng ta có thể xây dựng mô hình theo từng bước, lưu các mô hình khác nhau với một số biến giải thích. Chúng ta có thể sử dụng kiểm định tỷ số khả dĩ (likelihood-ratio tests) để so sánh các mô hình này bằng cách sử dụng hàm lrtest() từ package lmtest, như dưới đây:\nCHÚ Ý: Sử dụng hàn anova(model1, model2, test = \"Chisq) trong base R cũng cho kết quả tương tự\n\nmodel1 &lt;- glm(outcome ~ age_cat, family = \"binomial\", data = linelist)\nmodel2 &lt;- glm(outcome ~ age_cat + gender, family = \"binomial\", data = linelist)\n\nlmtest::lrtest(model1, model2)\n\nLikelihood ratio test\n\nModel 1: outcome ~ age_cat\nModel 2: outcome ~ age_cat + gender\n  #Df  LogLik Df Chisq Pr(&gt;Chisq)\n1   8 -2852.6                    \n2   9 -2852.6  1 2e-04     0.9883\n\n\nMột tùy chọn khác là lấy đối tượng của mô hình và sử dụng hàm step() từ package stats. Chỉ rõ hướng lựa chọn biến mà chúng ta muốn sử dụng khi xây dựng mô hình.\n\n## choose a model using forward selection based on AIC\n## you can also do \"backward\" or \"both\" by adjusting the direction\nfinal_mv_reg &lt;- mv_reg %&gt;%\n  step(direction = \"forward\", trace = FALSE)\n\nĐể hiển thị rõ số, chúng ta có thể tắt ký hiệu khoa học trong R bằng lệnh sau\n\noptions(scipen=999)\n\nNhư được mô tả trong phần phân tích đơn biến, chuyển kết quả đầu ra của mô hình vào hàm tidy() để lấy lũy thừa cho các hệ số và khoảng tin cậy (CIs). Cuối cùng, làm tròn tất cả các cột số với hai số thập phân. Kéo qua để xem tất cả các hàng.\n\nmv_tab_base &lt;- final_mv_reg %&gt;% \n  broom::tidy(exponentiate = TRUE, conf.int = TRUE) %&gt;%  ## get a tidy dataframe of estimates \n  mutate(across(where(is.numeric), round, digits = 2))          ## round \n\nĐây là hiển thị kết quả dưới dạng data frame looks:\n\n\n\n\n\n\n\n\n\n\nGộp kết quả phân tích đơn biến và đa biến\n\nGộp bằng package gtsummary\nHàm tbl_regression() trong package gtsummary sẽ lấy kết quả đầu tra từ một hồi quy (hàm glm() trong trường hợp này) và tạo ra một bảng tóm tắt đẹp.\n\n## show results table of final regression \nmv_tab &lt;- tbl_regression(final_mv_reg, exponentiate = TRUE)\n\nHãy xem bảng sau:\n\nmv_tab\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nOR1\n95% CI1\np-value\n\n\n\n\ngender\n1.00\n0.88, 1.14\n&gt;0.9\n\n\nfever\n1.00\n0.86, 1.18\n&gt;0.9\n\n\nchills\n1.03\n0.89, 1.21\n0.7\n\n\ncough\n1.15\n0.96, 1.37\n0.12\n\n\naches\n0.93\n0.76, 1.14\n0.5\n\n\nvomit\n1.09\n0.96, 1.23\n0.2\n\n\nage_cat\n\n\n\n\n\n\n\n\n    0-4\n—\n—\n\n\n\n\n    5-9\n0.94\n0.77, 1.15\n0.5\n\n\n    10-14\n1.15\n0.93, 1.41\n0.2\n\n\n    15-19\n0.99\n0.79, 1.24\n&gt;0.9\n\n\n    20-29\n1.03\n0.84, 1.26\n0.8\n\n\n    30-49\n1.06\n0.85, 1.33\n0.6\n\n\n    50-69\n0.68\n0.40, 1.13\n0.14\n\n\n    70+\n0.52\n0.07, 3.19\n0.5\n\n\n\n1 OR = Odds Ratio, CI = Confidence Interval\n\n\n\n\n\n\n\n\n\nChúng ta cũng có thể kết hợp một số bảng kết quả đầu ra bằng cách dùng hàm tbl_merge() trong package gtsummary. Bây giờ chúng ta hộp các kết quả đa biến với kết quả đơn biến đã được tạo bên trên bằng package gtsummary:\n\n## combine with univariate results \ntbl_merge(\n  tbls = list(univ_tab, mv_tab),                          # combine\n  tab_spanner = c(\"**Univariate**\", \"**Multivariable**\")) # set header names\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nUnivariate\nMultivariable\n\n\nN\nOR1\n95% CI1\np-value\nOR1\n95% CI1\np-value\n\n\n\n\ngender\n4,167\n1.00\n0.88, 1.13\n&gt;0.9\n1.00\n0.88, 1.14\n&gt;0.9\n\n\nfever\n4,167\n1.00\n0.85, 1.17\n&gt;0.9\n1.00\n0.86, 1.18\n&gt;0.9\n\n\nchills\n4,167\n1.03\n0.89, 1.21\n0.7\n1.03\n0.89, 1.21\n0.7\n\n\ncough\n4,167\n1.15\n0.97, 1.37\n0.11\n1.15\n0.96, 1.37\n0.12\n\n\naches\n4,167\n0.93\n0.76, 1.14\n0.5\n0.93\n0.76, 1.14\n0.5\n\n\nvomit\n4,167\n1.09\n0.96, 1.23\n0.2\n1.09\n0.96, 1.23\n0.2\n\n\nage_cat\n4,167\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    0-4\n\n\n—\n—\n\n\n—\n—\n\n\n\n\n    5-9\n\n\n0.94\n0.77, 1.15\n0.5\n0.94\n0.77, 1.15\n0.5\n\n\n    10-14\n\n\n1.15\n0.93, 1.42\n0.2\n1.15\n0.93, 1.41\n0.2\n\n\n    15-19\n\n\n0.99\n0.80, 1.24\n&gt;0.9\n0.99\n0.79, 1.24\n&gt;0.9\n\n\n    20-29\n\n\n1.03\n0.84, 1.26\n0.8\n1.03\n0.84, 1.26\n0.8\n\n\n    30-49\n\n\n1.07\n0.85, 1.33\n0.6\n1.06\n0.85, 1.33\n0.6\n\n\n    50-69\n\n\n0.68\n0.41, 1.13\n0.13\n0.68\n0.40, 1.13\n0.14\n\n\n    70+\n\n\n0.53\n0.07, 3.20\n0.5\n0.52\n0.07, 3.19\n0.5\n\n\n\n1 OR = Odds Ratio, CI = Confidence Interval\n\n\n\n\n\n\n\n\n\n\n\nGộp bằng package dplyr\nMột cách khác để gộp các kết quả đơn biến và đa biến từ các hàm glm()/tidy() bằng cách sử dụng các hàm kết nối từ package dplyr.\n\nKết nối kết quả đơn biến trước đó (univ_tab_base, chứa được các cột đếm) với kết quả đa biến đã được làm gọn mv_tab_base\n\nSử dụng hàm select() để giữ lại, sắp xếp lại thứ tự và đặt lại tên các cột mà chúng ta muốn\n\nSử dụng hàm round() để làm tròn tất cả các cột với hai số thập phân\n\n\n## combine univariate and multivariable tables \nleft_join(univ_tab_base, mv_tab_base, by = \"term\") %&gt;% \n  ## choose columns and rename them\n  select( # new name =  old name\n    \"characteristic\" = term, \n    \"recovered\"      = \"0\", \n    \"dead\"           = \"1\", \n    \"univ_or\"        = estimate.x, \n    \"univ_ci_low\"    = conf.low.x, \n    \"univ_ci_high\"   = conf.high.x,\n    \"univ_pval\"      = p.value.x, \n    \"mv_or\"          = estimate.y, \n    \"mvv_ci_low\"     = conf.low.y, \n    \"mv_ci_high\"     = conf.high.y,\n    \"mv_pval\"        = p.value.y \n  ) %&gt;% \n  mutate(across(where(is.double), round, 2))   \n\n# A tibble: 20 × 11\n   characteristic recovered  dead univ_or univ_ci_low univ_ci_high univ_pval\n   &lt;chr&gt;              &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;     &lt;dbl&gt;\n 1 (Intercept)          909  1168    1.28        1.18         1.4       0   \n 2 gender               916  1174    1           0.88         1.13      0.97\n 3 (Intercept)          340   436    1.28        1.11         1.48      0   \n 4 fever               1485  1906    1           0.85         1.17      0.99\n 5 (Intercept)         1472  1877    1.28        1.19         1.37      0   \n 6 chills               353   465    1.03        0.89         1.21      0.68\n 7 (Intercept)          272   309    1.14        0.97         1.34      0.13\n 8 cough               1553  2033    1.15        0.97         1.37      0.11\n 9 (Intercept)         1636  2114    1.29        1.21         1.38      0   \n10 aches                189   228    0.93        0.76         1.14      0.51\n11 (Intercept)          931  1144    1.23        1.13         1.34      0   \n12 vomit                894  1198    1.09        0.96         1.23      0.17\n13 (Intercept)          338   427    1.26        1.1          1.46      0   \n14 age_cat5-9           365   433    0.94        0.77         1.15      0.54\n15 age_cat10-14         273   396    1.15        0.93         1.42      0.2 \n16 age_cat15-19         238   299    0.99        0.8          1.24      0.96\n17 age_cat20-29         345   448    1.03        0.84         1.26      0.79\n18 age_cat30-49         228   307    1.07        0.85         1.33      0.58\n19 age_cat50-69          35    30    0.68        0.41         1.13      0.13\n20 age_cat70+             3     2    0.53        0.07         3.2       0.49\n# ℹ 4 more variables: mv_or &lt;dbl&gt;, mvv_ci_low &lt;dbl&gt;, mv_ci_high &lt;dbl&gt;,\n#   mv_pval &lt;dbl&gt;",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Hồi quy đơn và đa biến</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.vn.html#biểu-đồ-forest-plot",
    "href": "new_pages/regression.vn.html#biểu-đồ-forest-plot",
    "title": "19  Hồi quy đơn và đa biến",
    "section": "19.5 Biểu đồ Forest plot",
    "text": "19.5 Biểu đồ Forest plot\nPhần này hướng dẫn cách tạo ra một biểu đồ của các kết quả hồi quy. Có hai lựa chọn để tạo biểu đồ, chúng ta có thể tự tạo một biểu đồ bằng cách sử dụng package ggplot2 hoặc sử dụng một meta-package có tên easystats (một package gồm nhiều package).\nNếu chưa quen thuộc với gói lệnh tạo biểu đồ ggplot2, xem thêm chương ggplot cơ bản.\n\n\nggplot2 package\nBạn có thể xây dựng một forest plot với hàm ggplot() bằng cách vẽ các thành phần của kết quả hồi quy đa biến. Thêm các lớp của biều đồ bằng cách sử dụng các “geoms”:\n\nCác ước lượng bằng hàm geom_point()\n\nKhoảng tin cậy bằng hàm geom_errorbar()\n\nĐường thẳng đứng ở vị trí OR = 1 bằng hàm geom_vline()\n\nTrước khi tạo biểu đồ, chúng ta sử dụng hàm fct_relevel() từ package forcats để đặt thứ tự các biến trên trục y. Hàm ggplot() cho phép hiển thị theo thứ tự chữ-số mà có thể không hiển thị tốt cho các giá trị của biến tuổi (“30” có thể hiển thị trước “5”). Xem chương Factors để biết thêm chi tiết.\n\n## remove the intercept term from your multivariable results\nmv_tab_base %&gt;% \n  \n  #set order of levels to appear along y-axis\n  mutate(term = fct_relevel(\n    term,\n    \"vomit\", \"gender\", \"fever\", \"cough\", \"chills\", \"aches\",\n    \"age_cat5-9\", \"age_cat10-14\", \"age_cat15-19\", \"age_cat20-29\",\n    \"age_cat30-49\", \"age_cat50-69\", \"age_cat70+\")) %&gt;%\n  \n  # remove \"intercept\" row from plot\n  filter(term != \"(Intercept)\") %&gt;% \n  \n  ## plot with variable on the y axis and estimate (OR) on the x axis\n  ggplot(aes(x = estimate, y = term)) +\n  \n  ## show the estimate as a point\n  geom_point() + \n  \n  ## add in an error bar for the confidence intervals\n  geom_errorbar(aes(xmin = conf.low, xmax = conf.high)) + \n  \n  ## show where OR = 1 is for reference as a dashed line\n  geom_vline(xintercept = 1, linetype = \"dashed\")\n\n\n\n\n\n\n\n\n\n\n\neasystats packages\nLựa chọn thứ hai là sử dụng một sự kết hợp của các package trong easystats, nếu chúng ta không muốn mức độ kiểm soát chặt chẽ mà package ggplot2 cung cấp.\nHàm model_parameters() từ package parameters thực hiện tương đương với hàm tidy() trong package broom . Sau đó, package see chấp nhận các kết quả đầu ra và tạo một biểu đồ forest plot mặc định giống như cho một đối tượng ggplot().\n\npacman::p_load(easystats)\n\n## remove the intercept term from your multivariable results\nfinal_mv_reg %&gt;% \n  model_parameters(exponentiate = TRUE) %&gt;% \n  plot()",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Hồi quy đơn và đa biến</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.vn.html#nguồn",
    "href": "new_pages/regression.vn.html#nguồn",
    "title": "19  Hồi quy đơn và đa biến",
    "section": "19.6 Nguồn",
    "text": "19.6 Nguồn\nNội dung của chương này được tham khảo từ các nguồn sau:\nLinear regression in R\ngtsummary\nUCLA stats page\nsthda stepwise regression",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Hồi quy đơn và đa biến</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.vn.html",
    "href": "new_pages/missing_data.vn.html",
    "title": "20  Dữ liệu Missing",
    "section": "",
    "text": "20.1 Chuẩn bị",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Dữ liệu Missing</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.vn.html#chuẩn-bị",
    "href": "new_pages/missing_data.vn.html#chuẩn-bị",
    "title": "20  Dữ liệu Missing",
    "section": "",
    "text": "Gọi package\nĐoạn code này hiển thị cách gọi các package cần thiết cho phân tích. Trong cuốn sổ tay này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, mà hàm này sẽ cài đặt package khi cần thiết và gọi nó ra để sử dụng. Bạn cũng có thể gọi các gói lệnh đã cài đặt bằng hàm library() trong base R. Xem chương R cơ bản để biết thêm thông tin về các R packages.\n\npacman::p_load(\n  rio,           # import/export\n  tidyverse,     # data mgmt and viz\n  naniar,        # assess and visualize missingness\n  mice           # missing data imputation\n)\n\n\n\nNhập số liệu\nChúng ta nhập bộ số liệu của các ca bệnh được mô phỏng từ một vụ dịch Ebola. Để tiện làm theo, bấm để tải số liệu linelist “đã làm sạch” (as .rds file). Nhập số liệu này bằng hàm import() trong package rio (nó chấp nhận nhiều loại tập tin như .xlsx, .rds, .csv – xem chi tiết trong chương Nhập xuất dữ liệu).\n\n# import the linelist\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nBên dưới là hiển thị của 50 hàng đầu tiên của bộ số liệu linelist.\n\n\n\n\n\n\n\n\nChuyển đổi missing khi nhập dữ liệu\nKhi nhập số liệu, hãy lưu ý các giá trị có thể được phân loại là các giá trị missing. Ví dụ: 99, 999, “Missing”, ô trống (““), hoặc các ô có khoảng trống (” “). Bạn có thể chuyển đổi các giá trị này thành NA (cách R lưu trữ số liệu missing) trong khi thực hiện lệnh nhập số liệu.\nXem phần nhập số liệu trong chương Dữ liệu missing để biết thêm chi tiết, vì cú pháp chính xác sẽ khác nhau tùy theo loại tệp.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Dữ liệu Missing</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.vn.html#giá-trị-missing-trong-r",
    "href": "new_pages/missing_data.vn.html#giá-trị-missing-trong-r",
    "title": "20  Dữ liệu Missing",
    "section": "20.2 Giá trị missing trong R",
    "text": "20.2 Giá trị missing trong R\nSau đây chúng ta sẽ khảo sát rõ cách số liệu bị thiếu được trình bày và đánh giá trong R bởi các giá trị liền kề và các hàm.\n\nNA\nTrong R, giá trị bị thiếu được đại diện bởi một giá trị dành riêng (đặc biệt) - NA. Lưu ý rằng giá trị này được nhập không có dấu ngoặc kép. “NA” là khác biệt và cũng chỉ là một giá trị ký tự bình thường (như lời bài hát của Beatles trong bài Hey Jude).\nSố liệu của chúng ta có thể có các cách khác để biểu thị giá trị bị thiếu, như là “99”, hoặc “Giá trị bị thiếu / Missing”, hoặc “Không biết / Unknown”, thậm chí chúng ta có giá trị ký tự trống “” như “để trống / blank”, hoặc một khoảng trắng ” “. Cần lưu ý những giá trị này và xem xét có nên chuyển đổi chúng thành NA khi nhập vào R hoặc trong khi làm sạch số liệu bằng hàm na_if() hay không.\nTrong lúc làm sạch số liệu, chúng ta cũng có thể muốn chuyển đổi số liệu theo một cách khác – chuyển đổi tất cả NA thành “Missing” hoặc làm tương tự với hàm replace_na() hoặc với hàm fct_explicit_na() cho các factors.\n\n\nCác phiên bản của NA\nTrong hầu hết trường hợp, NA đại diện cho giá trị bị thiếu và mọi thứ đều vận hành tốt. Tuy nhiên, trong một số trường hợp, chúng ta có thể gặp phải những tình huống khó khăn đối với các biến thể của NA mà đặc trưng cho một lớp đối tượng (ký tự, số, .v.v.). Điều này rất hiếm, nhưng chúng ta cần phải lưu ý.\nTình huống điển hình cho trường hợp này là khi tạo một cột mới bằng hàm case_when() trong package dplyr. Như được mô tả trong chương Làm sạch số liệu và các hàm quan trọng, hàm này lượng giá mọi hàng trong data frame, đánh giá xem các hàng có đáp ứng với các tiêu chí logic cụ thể hay không (phía bên phải của code), và gán giá trị chính xác mới (phía bên trái của code). Quan trọng: tất cả các giá trị bên phải phải cùng một lớp biến số.\n\nlinelist &lt;- linelist %&gt;% \n  \n  # Create new \"age_years\" column from \"age\" column\n  mutate(age_years = case_when(\n    age_unit == \"years\"  ~ age,       # if age is given in years, assign original value\n    age_unit == \"months\" ~ age/12,    # if age is given in months, divide by 12\n    is.na(age_unit)      ~ age,       # if age UNIT is missing, assume years\n    TRUE                 ~ NA_real_)) # any other circumstance, assign missing\n\nNếu bạn muốn NA ở phía bên phải, có thể cần phải chỉ định một trong các tùy chọn đặc biệt của NA được liệt kê bên dưới. Nếu các giá trị bên phải khác là ký tự, cân nhắc sử dụng “Missing” hoặc sử dụng NA_character_. Nếu chúng là các giá trị số, sử dụng NA_real_. Nếu tất cả các giá trị là ngày tháng hoặc logic, chúng ta có thể sử dụng NA.\n\nNA - dùng cho biến ngày tháng hoặc biến số logic TRUE/FALSE\nNA_character_ - dùng cho biến số ký tự\n\nNA_real_ - dùng cho biến dạng số\n\nMột lần nữa, chúng ta sẽ không gặp các loại biến thể này trừ khi chúng ta sử dụng hàm case_when() để tạo biến mới. Xem phần Tài liệu về NA trong R để biết thêm thông tin.\n\n\nNULL\nNULL là một giá trị dành riêng khác nữa trong R. Nó đại điện cho một mệnh đề không đúng cũng không sai. Nó là kết quả của các biểu thức hoặc hàm có giá trị không xác định. Nói chung, không gán NULL như một giá trị, trừ khi viết hàm hoặc khi viết một Ứng dụng shiny để trả về NULL trong các tình huống cụ thể.\nNull có thể được đánh giá bằng cách sử dụng hàm is.null() và có thể chuyển đổi thành bằng hàm as.null().\nXem bài viết trên blog này on để biết về sự khác biệt giữa NULL và NA.\n\n\nNaN\nCác giá trị không thể được đại diện bằng một giá trị đặc biệt NaN. Một ví dụ cho giá trị này là khi chúng ta bắt buộc R chia 0 cho 0. Chúng ta có thể đánh giá giá trị này bằng cách dùng hàm is.nan(). Chúng ta cũng có thể gặp các hàm bổ sung bao gồm is.infinite() và is.finite().\n\n\nInf\nInf đại diện cho giá trị vô hạn như là khi chia một số nào đó cho 0.\nMột ví dụ về cách mà giá trị này ảnh hưởng đến số liệu của chúng ta: giả sử chúng ta có một véctơ hay một cột z chứa các giá trị sau: z &lt;- c(1, 22, NA, Inf, NaN, 5)\nNếu bạn muốn sử dụng hàm max() của cột bên trên để tìm giá trị lớn nhất, bạn có thể sử dụng na.rm = TRUE để loại bỏ NA khỏi phép tính, nhưng Inf và NaN vẫn còn, và Inf sẽ được trả về. Để giải quyết vấn đề này, chúng ta có thể sử dụng dấu ngoặc vuông [ ] và hàm is.finite() để tạo tập hợp con mà chỉ có các giá trị hữu hạn được sử dụng để tính toán: max(z[is.finite(z)]).\n\nz &lt;- c(1, 22, NA, Inf, NaN, 5)\nmax(z)                           # returns NA\nmax(z, na.rm=T)                  # returns Inf\nmax(z[is.finite(z)])             # returns 22\n\n\n\nCác ví dụ\n\n\n\n\n\n\n\nLệnh trong R\nĐầu ra\n\n\n\n\n5 / 0\nInf\n\n\n0 / 0\nNaN\n\n\n5 / NA\nNA\n\n\n5 / Inf |0NA - 5|NAInf / 5|Infclass(NA)| \"logical\"class(NaN)| \"numeric\"class(Inf)| \"numeric\"class(NULL)`\n“NULL”\n\n\n\n“NAs introduced by coercion (NAs được tạo ra do ép buộc)” là một cảnh báo phổ biến. Điều này có thể xảy ra khi chúng ta cố gắng thực hiện một chuyển đổi không hợp lệ như chèn một giá trị ký tự vào trong một véctơ dạng số.\n\nas.numeric(c(\"10\", \"20\", \"thirty\", \"40\"))\n\nWarning: NAs introduced by coercion\n\n\n[1] 10 20 NA 40\n\n\nNULL được bỏ qua trong một véctơ.\n\nmy_vector &lt;- c(25, NA, 10, NULL)  # define\nmy_vector                         # print\n\n[1] 25 NA 10\n\n\nPhương sai của một số cho kết quả là NA.\n\nvar(22)\n\n[1] NA",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Dữ liệu Missing</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.vn.html#các-hàm-hữu-dụng",
    "href": "new_pages/missing_data.vn.html#các-hàm-hữu-dụng",
    "title": "20  Dữ liệu Missing",
    "section": "20.3 Các hàm hữu dụng",
    "text": "20.3 Các hàm hữu dụng\nDưới đây là các hàm hữu dụng trong base R khi đánh giá hoặc xử lý các giá trị bị thiếu:\n\nis.na() và !is.na()\nSử dụng hàm is.na() để nhận ra các giá trị bị thiếu hoặc sử dụng hàm đối của nó (với dấu ! ở phía trước) để nhận ra các giá trị không phải là missing. Cả hai hàm trên đều trả kết quả về một giá trị logic (TRUE hoặc FALSE). Nhớ rằng bạn có thể dùng hàm sum() đối với véc tơ kết quả/đầu ra để đếm số lượng TRUE, vd: sum(is.na(linelist$date_outcome)).\n\nmy_vector &lt;- c(1, 4, 56, NA, 5, NA, 22)\nis.na(my_vector)\n\n[1] FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE\n\n!is.na(my_vector)\n\n[1]  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\n\nsum(is.na(my_vector))\n\n[1] 2\n\n\n\n\nna.omit()\nHàm này, nếu được áp dụng trên một data frame, sẽ loại bỏ các hàng có bất kỳ giá trị nào bị thiếu. Hàm này cũng từ base R.\nNếu áp dụng cho một véctơ, hàm này sẽ loại bỏ các giá trị NA của véctơ này. Ví dụ:\n\nna.omit(my_vector)\n\n[1]  1  4 56  5 22\nattr(,\"na.action\")\n[1] 4 6\nattr(,\"class\")\n[1] \"omit\"\n\n\n\n\ndrop_na()\nĐây là một hàm của package tidyr mà rất hữu dụng trong một pipeline làm sạch số liệu. Nếu thực hiện hàm với dấu ngoặc trống, nó sẽ loại bỏ các hàng có bất kỳ giá trị nào bị thiếu. Nếu cụ thể tên cột trong dấu ngoặc, các hàng nào có giá trị bị thiếu trong những cột này sẽ bị loại bỏ. Chúng ta có thể sử dụng cú pháp “tidyselect” để chỉ định các cột này.\n\nlinelist %&gt;% \n  drop_na(case_id, date_onset, age) # drops rows missing values for any of these columns\n\n\n\nna.rm = TRUE\nKhi chúng ta thực hiện một hàm toán học như max(), min(), sum() hoặc mean(), nếu có sự hiện diện của bất kỳ giá trị NA, kết quả sẽ là NA. Cách xử lý mặc định này là có chủ ý để cảnh báo chúng ta khi có số liệu bị thiếu.\nBạn có thể tránh việc này bằng cách loại bỏ các giá trị bị thiếu ra khỏi phép tính. Để thực hiện, hãy thêm đối số na.rm = TRUE (“na.rm” là viết tắt của “remove NA”).\n\nmy_vector &lt;- c(1, 4, 56, NA, 5, NA, 22)\n\nmean(my_vector)     \n\n[1] NA\n\nmean(my_vector, na.rm = TRUE)\n\n[1] 17.6",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Dữ liệu Missing</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.vn.html#đánh-giá-tính-không-đầy-đủ-của-một-data-frame",
    "href": "new_pages/missing_data.vn.html#đánh-giá-tính-không-đầy-đủ-của-một-data-frame",
    "title": "20  Dữ liệu Missing",
    "section": "20.4 Đánh giá tính không đầy đủ của một data frame",
    "text": "20.4 Đánh giá tính không đầy đủ của một data frame\nBạn có thể sử dụng package naniar để đánh giá và trực quan hóa các giá trị bị thiếu trong bộ số liệu linelist.\n\n# install and/or load package\npacman::p_load(naniar)\n\n\nĐịnh lượng tính không đầy đủ\nĐể tìm phần trăm của tất cả các giá trị bị thiếu, sử dụng hàm pct_miss(). Để biết số lượng bị thiếu, sử dụng hàm n_miss().\n\n# percent of ALL data frame values that are missing\npct_miss(linelist)\n\n[1] 6.688745\n\n\nHai hàm bên dưới trả về phần trăm số hàng có bất kỳ giá trị bị thiếu hoặc hoàn toàn đầy đủ. Hãy nhớ rằng NA có nghĩa là giá trị missing, và `\"\" hoặc \" \" sẽ không được đếm là giá trị missing.\n\n# Percent of rows with any value missing\npct_miss_case(linelist)   # use n_complete() for counts\n\n[1] 69.12364\n\n\n\n# Percent of rows that are complete (no values missing)  \npct_complete_case(linelist) # use n_complete() for counts\n\n[1] 30.87636\n\n\n\n\nTrực quan hóa tính không đầy đủ\nHàm gg_miss_var() sẽ hiển thị cho chúng ta số lượng (hoặc %) của các giá trị bị thiếu trong mỗi cột. Một vài sắc thái như sau:\n\nChúng ta có thể thêm tên cột (không ở trong dấu ngoặc kép) vào đối số facet = để xem biểu đồ theo nhóm\n\nTheo mặc định, số đếm sẽ được hiển thị thay vì con số phần trăm, để thay đổi điều này bằng cách sử dụng thêm show_pct = TRUE\n\nChúng ta có thể thêm nhãn các trục và tiêu đề như đối với các hàm ggplot() thông thường với + labs(...)\n\n\ngg_miss_var(linelist, show_pct = TRUE)\n\n\n\n\n\n\n\n\nỞ đây số liệu được dẫn bằng ký hiệu %&gt;% vào trong hàm. Đối số facet = cũng được sử dụng để phân chia số liệu.\n\nlinelist %&gt;% \n  gg_miss_var(show_pct = TRUE, facet = outcome)\n\n\n\n\n\n\n\n\nBạn có thể sử dụng hàm vis_miss() để hình ảnh hóa số liệu dưới dạng một bản đồ nhiệt, mà cho biết từng giá trị có bị thiếu hay không. Chúng ta cũng có thể sử dụng hàm select() để lựa chọn một số cột nhất định từ data frame và chỉ cung cấp các cột đó vào trong hàm.\n\n# Heatplot of missingness across the entire data frame  \nvis_miss(linelist)\n\n\n\n\n\n\n\n\n\n\nKhám phá và trực quan hóa các mối quan hệ của dữ liệu bị thiếu\nLàm thế nào chúng ta hình ảnh hóa một cái gì đó mà không có ở đó??? Theo mặc định, hàm ggplot() sẽ loại bỏ các giá trị bị thiếu ra khỏi biểu đồ.\nPackage naniar cung cấp một giải pháp thông qua hàm geom_miss_point(). Khi tạo biểu đồ phân tán của hai cột, các bản ghi có một trong các giá trị bị thiếu và sự hiện diện của giá trị khác được hiển thị bằng cách đặt các giá trị bị thiếu thấp hơn 10% so với giá trị thấp nhất trong cột đó và và tô màu để dễ phân biệt.\nTrong biểu đồ phân tán bên dưới, các chấm màu đỏ là các bản ghi khi có giá trị của một cột nhưng thiếu giá trị của cột còn lại. Điều này cho phép chúng ta thấy được sự phân bố của các giá trị bị thiếu tương quan với giá trị không bị thiếu.\n\nggplot(\n  data = linelist,\n  mapping = aes(x = age_years, y = temp)) +     \n  geom_miss_point()\n\n\n\n\n\n\n\n\nĐể đánh giá giá trị bị thiếu trong một data frame được phân tầng bởi một cột khác, hãy lưu ý đến hàm gg_miss_fct(), mà sẽ trả về một bản đồ nhiệt chứa thông tin về phần trăm giá trị bị thiếu trong một data frame bởi một cột của biến số factor/phân loại (hoặc ngày):\n\ngg_miss_fct(linelist, age_cat5)\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `age_cat5 = (function (x) ...`.\nCaused by warning:\n! `fct_explicit_na()` was deprecated in forcats 1.0.0.\nℹ Please use `fct_na_value_to_level()` instead.\nℹ The deprecated feature was likely used in the naniar package.\n  Please report the issue at &lt;https://github.com/njtierney/naniar/issues&gt;.\n\n\n\n\n\n\n\n\n\nHàm này cũng có thể được sử dụng đối với cột dạng ngày tháng để xem mức độ của số liệu bị thiếu thay đổi theo thời gian:\n\ngg_miss_fct(linelist, date_onset)\n\nWarning: Removed 29 rows containing missing values or values outside the scale range\n(`geom_tile()`).\n\n\n\n\n\n\n\n\n\n\n\nCác cột “hình bóng”\nMột cách khác để trực quan hóa số liệu bị thiếu trong một cột bởi các giá trị của cột thứ hai là sử dụng “hình bóng/shadow” mà package naniar có thể tạo ra. Hàm bind_shadow() tạo ra một cột biến số nhị phân NA/không NA cho mọi cột hiện có và liên kết tất cả các cột mới này với bộ số liệu gốc bằng phần phụ “_NA”. Điều này làm tăng gấp đôi số cột – xem bên dưới:\n\nshadowed_linelist &lt;- linelist %&gt;% \n  bind_shadow()\n\nnames(shadowed_linelist)\n\n [1] \"case_id\"                 \"generation\"             \n [3] \"date_infection\"          \"date_onset\"             \n [5] \"date_hospitalisation\"    \"date_outcome\"           \n [7] \"outcome\"                 \"gender\"                 \n [9] \"age\"                     \"age_unit\"               \n[11] \"age_years\"               \"age_cat\"                \n[13] \"age_cat5\"                \"hospital\"               \n[15] \"lon\"                     \"lat\"                    \n[17] \"infector\"                \"source\"                 \n[19] \"wt_kg\"                   \"ht_cm\"                  \n[21] \"ct_blood\"                \"fever\"                  \n[23] \"chills\"                  \"cough\"                  \n[25] \"aches\"                   \"vomit\"                  \n[27] \"temp\"                    \"time_admission\"         \n[29] \"bmi\"                     \"days_onset_hosp\"        \n[31] \"case_id_NA\"              \"generation_NA\"          \n[33] \"date_infection_NA\"       \"date_onset_NA\"          \n[35] \"date_hospitalisation_NA\" \"date_outcome_NA\"        \n[37] \"outcome_NA\"              \"gender_NA\"              \n[39] \"age_NA\"                  \"age_unit_NA\"            \n[41] \"age_years_NA\"            \"age_cat_NA\"             \n[43] \"age_cat5_NA\"             \"hospital_NA\"            \n[45] \"lon_NA\"                  \"lat_NA\"                 \n[47] \"infector_NA\"             \"source_NA\"              \n[49] \"wt_kg_NA\"                \"ht_cm_NA\"               \n[51] \"ct_blood_NA\"             \"fever_NA\"               \n[53] \"chills_NA\"               \"cough_NA\"               \n[55] \"aches_NA\"                \"vomit_NA\"               \n[57] \"temp_NA\"                 \"time_admission_NA\"      \n[59] \"bmi_NA\"                  \"days_onset_hosp_NA\"     \n\n\nCác cột “hình bóng” này có thể được sử dụng để vẽ biểu đồ tỷ lệ các giá trị bị thiếu theo bất kỳ cột nào khác.\nVí dụ: biểu đồ bên dưới cho thấy tỷ lệ các giá trị bị thiếu của các bản ghi trong biến số days_onset_hosp (số ngày từ ngày khởi phát triệu chứng đến ngày nhập viện), theo giá trị của bản ghi đó trong biến số date_hospitalisation. Về bản chất là chúng ta đang vẽ biểu độ mật độ của cột này trên trục x, nhưng phân tầng kết quả (color =) bằng cột hình bóng đang được quan tâm. Phân tích này thể hiện tốt nhất khi trục x là cột số hoặc cột ngày.\n\nggplot(data = shadowed_linelist,          # data frame with shadow columns\n  mapping = aes(x = date_hospitalisation, # numeric or date column\n                colour = age_years_NA)) + # shadow column of interest\n  geom_density()                          # plots the density curves\n\n\n\n\n\n\n\n\nBạn cũng có thể sử dụng cột “hình bóng” để phân tầng một bảng tóm tắt thống kê, như được hiển thị bên dưới:\n\nlinelist %&gt;%\n  bind_shadow() %&gt;%                # create the shows cols\n  group_by(date_outcome_NA) %&gt;%    # shadow col for stratifying\n  summarise(across(\n    .cols = age_years,             # variable of interest for calculations\n    .fns = list(\"mean\" = mean,     # stats to calculate\n                \"sd\" = sd,\n                \"var\" = var,\n                \"min\" = min,\n                \"max\" = max),  \n    na.rm = TRUE))                 # other arguments for the stat calculations\n\nWarning: There was 1 warning in `summarise()`.\nℹ In argument: `across(...)`.\nℹ In group 1: `date_outcome_NA = !NA`.\nCaused by warning:\n! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\nSupply arguments directly to `.fns` through an anonymous function instead.\n\n  # Previously\n  across(a:b, mean, na.rm = TRUE)\n\n  # Now\n  across(a:b, \\(x) mean(x, na.rm = TRUE))\n\n\n# A tibble: 2 × 6\n  date_outcome_NA age_years_mean age_years_sd age_years_var age_years_min\n  &lt;fct&gt;                    &lt;dbl&gt;        &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n1 !NA                       16.0         12.6          158.             0\n2 NA                        16.2         12.9          167.             0\n# ℹ 1 more variable: age_years_max &lt;dbl&gt;\n\n\nBên dưới là một cách khác để vẽ biểu đồ tỷ lệ các giá trị bị thiếu của một cột theo thời gian. Nó không liên quan đến package naniar. Ví dụ này cho thấy phần trăm số liệu bị thiếu theo tuần.\n\nTổng hợp số liệu thành một đơn vị thời gian muốn sử dụng (ngày, tuần, .v.v.), tóm tắt tỷ lệ quan sát theo NA (và bất kỳ các giá trị quan tâm khác)\n\nVẽ biểu đồ tỷ lệ giá trị bị thiếu dưới dạng một dòng bằng cách sử dụng hàm ggplot()\n\nBên dưới, chúng ta lấy bộ số liệu linelist, thêm một cột mới cho tuần, nhóm số liệu theo tuần và sau đó tính phần trăm của các bản ghi có số liệu bị thiếu theo tuần. (lưu ý: nếu chúng ta muốn % của 7 ngày, việc tính toán sẽ hơi khác một chút).\n\noutcome_missing &lt;- linelist %&gt;%\n  mutate(week = lubridate::floor_date(date_onset, \"week\")) %&gt;%   # create new week column\n  group_by(week) %&gt;%                                             # group the rows by week\n  summarise(                                                     # summarize each week\n    n_obs = n(),                                                  # number of records\n    \n    outcome_missing = sum(is.na(outcome) | outcome == \"\"),        # number of records missing the value\n    outcome_p_miss  = outcome_missing / n_obs,                    # proportion of records missing the value\n  \n    outcome_dead    = sum(outcome == \"Death\", na.rm=T),           # number of records as dead\n    outcome_p_dead  = outcome_dead / n_obs) %&gt;%                   # proportion of records as dead\n  \n  tidyr::pivot_longer(-week, names_to = \"statistic\") %&gt;%         # pivot all columns except week, to long format for ggplot\n  filter(stringr::str_detect(statistic, \"_p_\"))                  # keep only the proportion values\n\nSau đó, chúng ta vẽ biểu đồ tỷ lệ các giá trị bị thiếu dưới dạng một dòng theo tuần. Xem thêm chương ggplot cơ bản nếu bạn chưa quen với package vẽ biểu đồ ggplot2.\n\nggplot(data = outcome_missing)+\n    geom_line(\n      mapping = aes(x = week, y = value, group = statistic, color = statistic),\n      size = 2,\n      stat = \"identity\")+\n    labs(title = \"Weekly outcomes\",\n         x = \"Week\",\n         y = \"Proportion of weekly records\") + \n     scale_color_discrete(\n       name = \"\",\n       labels = c(\"Died\", \"Missing outcome\"))+\n    scale_y_continuous(breaks = c(seq(0,1,0.1)))+\n  theme_minimal()+\n  theme(legend.position = \"bottom\")",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Dữ liệu Missing</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.vn.html#sử-dụng-dữ-liệu-có-giá-trị-missing",
    "href": "new_pages/missing_data.vn.html#sử-dụng-dữ-liệu-có-giá-trị-missing",
    "title": "20  Dữ liệu Missing",
    "section": "20.5 Sử dụng dữ liệu có giá trị missing",
    "text": "20.5 Sử dụng dữ liệu có giá trị missing\n\nLọc bỏ các hàng có giá trị bị thiếu\nĐể loại bỏ nhanh các hàng có giá trị bị thiếu, sử dụng hàm drop_na() trong package dplyr.\nBộ số liệu gốc linelist có nrow(linelist) hàng. Số hàng sau khi hiệu chỉnh được hiển thị bên dưới:\n\nlinelist %&gt;% \n  drop_na() %&gt;%     # remove rows with ANY missing values\n  nrow()\n\n[1] 1818\n\n\nBạn có thể chỉ định loại bỏ các hàng có giá trị bị thiếu trong một số hàng nhất định:\n\nlinelist %&gt;% \n  drop_na(date_onset) %&gt;% # remove rows missing date_onset \n  nrow()\n\n[1] 5632\n\n\nBạn có thể liệt kê lần lượt từng cột một, hoặc sử dụng các hàm trợ giúp trong “tidyselect”:\n\nlinelist %&gt;% \n  drop_na(contains(\"date\")) %&gt;% # remove rows missing values in any \"date\" column \n  nrow()\n\n[1] 3029\n\n\n\n\n\nXử lý NA trong hàm ggplot()\nThường là khôn ngoan khi báo cáo số lượng các giá trị bị loại ra trong phần chú thích của biểu đồ. Bên dưới là một ví dụ:\nTrong hàm ggplot(), bạn có thể thêm labs() và bên trong nó là một chú thích caption =. Trong phần chú thích này, chúng ta có thể sử dụng hàm str_glue() từ package stringr để dán các giá trị lại với nhau thành một câu có tính chất động (dynamic), vì vậy nó sẽ điều chỉnh theo số liệu. Bên dưới là một ví dụ:\n\nLưu ý sử dụng \\n để tạo một hàng mới (ngắt chữ xuống hàng).\n\nLưu ý rằng nếu nhiều cột góp phần tạo ra các giá trị, thì sẽ không vẽ được trên biểu đồ (ví dụ như tuổi hoặc giới nếu chúng được phản ánh trên biểu đồ, thì chúng ta cũng phải lọc trên các cột đó để tính toán chính xác số lượng không được hiển thị.\n\n\nlabs(\n  title = \"\",\n  y = \"\",\n  x = \"\",\n  caption  = stringr::str_glue(\n  \"n = {nrow(central_data)} from Central Hospital;\n  {nrow(central_data %&gt;% filter(is.na(date_onset)))} cases missing date of onset and not shown.\"))  \n\nThỉnh thoảng, có thể dễ dàng hơn để lưu chuỗi này dưới dạng một đối tượng trong các lệnh trước khi dùng lệnh ggplot(), và chỉ cần tham chiếu tên của đối tượng chuỗi bên trong hàm str_glue().\n\n\n\nNA trong các factors\nNếu cột đang quan tâm là một factor, sử dụng hàm fct_explicit_na() thuộc package forcats để chuyển đổi các giá trị NA thành giá trị ký tự. Xem thêm chi tiết trong chương Factors. Theo mặc định, giá trị mới là “(Missing)” nhưng nó có thể được điều chỉnh thông qua đối số na_level =.\n\npacman::p_load(forcats)   # load package\n\nlinelist &lt;- linelist %&gt;% \n  mutate(gender = fct_explicit_na(gender, na_level = \"Missing\"))\n\nlevels(linelist$gender)\n\n[1] \"f\"       \"m\"       \"Missing\"",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Dữ liệu Missing</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.vn.html#thay-thế-missing---imputation",
    "href": "new_pages/missing_data.vn.html#thay-thế-missing---imputation",
    "title": "20  Dữ liệu Missing",
    "section": "20.6 Thay thế missing - Imputation",
    "text": "20.6 Thay thế missing - Imputation\nThỉnh thoảng, khi phân tích số liệu, điều quan trọng là phải “làm đầy khoảng trống” và gán giá trị cho số liệu bị thiếu. Trong khi chúng ta luôn luôn có thể chỉ cần phân tích một bộ số liệu sau khi đã loại bỏ tất cả các giá trị bị thiếu, nhưng điều này có thể đưa đến các vấn đề theo nhiều cách. Đây là các ví dụ:\n\nBằng cách loại bỏ tất cả các quan sát có giá trị bị thiếu hoặc các biến số có một số lượng lớn giá trị bị thiếu, chúng ta có thể giảm lực thống kê hay khả năng thực hiện một số loại phân tích. Ví dụ như khi chúng ta đã phát hiện trước đó, chỉ có một phần nhỏ của các quan sát trong bộ số liệu linelist không có số liệu bị thiếu trên tất cả các biến số. Nếu chúng ta xóa phần lớn số liệu, chúng ta sẽ mất rất nhiều thông tin! Và hầu hết các biến của bộ số liệu trên đều có một số lượng dữ liệu missing – đối với hầu hết các phân tích, hầu như là không hợp lý để loại bỏ tất cả các biến có nhiều số liệu bị missing.\nTùy thuộc vào lý do tại sao số liệu bị thiếu, nhưng chỉ phân tích số liệu không bị thiếu có thể dẫn đến kết quả sai lệch. Ví dụ như khi chúng ta đã biết trước đó, chúng ta đang thiếu số liệu của một số bệnh nhân về việc họ có một số triệu chứng quan trọng như sốt hoặc ho hay không. Nhưng có một khả năng là có thể thông tin đó không được ghi nhận đối với những người mà rõ ràng không bị bệnh nặng. Trong trường hợp đó, nếu chúng ta chỉ loại bỏ những quan sát này, chúng ta sẽ loại trừ một số người khỏe nhất trong bộ số liệu và điều đó thật sự có thể làm sai lệch bất kỳ kết quả nào.\n\nĐiều quan trọng là suy nghĩ tại sao số liệu có thể bị thiếu cũng như là thiếu bao nhiêu. Làm điều này có thể giúp chúng ta xác định mức độ quan trọng của việc gán giá trị bị thiếu và lựa chọn phương pháp tốt nhất để imputing giá trị missing trong tình huống của chúng ta.\n\nCác loại số liệu bị thiếu\nDưới đây là ba loại số liệu bị thiếu điển hình:\n\nMissing Completely at Random (MCAR): Số liệu bị thiếu hoàn toàn ngẫu nhiên. Điều này có nghĩa là không có mối quan hệ giữa xác suất số liệu bị thiếu và bất kỳ biến số nào trong bộ số liệu. Xác suất số liệu bị thiếu là ngang nhau đối với tất cả các trường hợp. Đây là một tình huống hiếm gặp. Nhưng nếu chúng ta có lý do chính đáng để tin rằng số liệu của chúng ta là MCAR, thì chỉ phân tích số liệu không bị thiếu (mà không imputing giá trị bị thiếu) sẽ không làm sai lệch kết quả (mặc dù chúng ta có thể mất một ít lực thống kê). [CẦN LÀM: lưu ý đến các thảo luận về các kiểm định thống kê cho MCAR]\nMissing at Random (MAR). Số liệu bị thiếu Ngẫu nhiên. Tên của loại số liệu này thực sự gây ra một ít hiểu lầm vì MAR có nghĩa là số liệu bị thiếu một cách có hệ thống, có thể dự đoán dựa trên các thông tin khác mà chúng ta có. Ví dụ như có lẽ giá trị bị thiếu đối với biến số sốt của mọi quan sát trong bộ số liệu là thật sự không được ghi nhận vì mọi bệnh nhân có ớn lạnh và đau nhức được giả định là bị sốt, vì vậy thân nhiệt của họ không bao giờ được đo. Nếu đúng như vậy, chúng ta có thể dễ dàng dự đoán rằng, mọi quan sát bị thiếu khi có ớn lạnh và đau nhức cũng sẽ bị sốt và chúng ta sẽ sử dụng thông tin này để gán các giá trị bị thiếu. Trong thực tế, đây là loại nhiều hơn. Có thể nếu một bệnh nhân có cả ớn lạnh và đau nhức, thì hầu như họ cũng sẽ bị sốt nếu thân nhiệt không được đo, nhưng không phải lúc nào cũng như vậy. Điều này vẫn có thể dự đoán được ngay cả khi nó không thể dự đoán một cách hoàn toàn, nhưng không phải là luôn luôn. Đây là một loại số liệu bị thiếu phổ biến\nMissing not at Random (MNAR): Số liệu bị thiếu không ngẫu nhiên. Thỉnh thoảng, loại này được gọi là Not Missing at Random - Không bị Thiếu Ngẫu nhiên (NMAR). Loại này giả định rằng xác suất của một giá trị bị thiếu là KHÔNG có hệ thống hoặc không thể dự đoán được bằng cách sử dụng thông tin khác mà chúng ta có, nhưng nó cũng không là giá trị bị thiếu một cách ngẫu nhiên. Trong tình huống này, số liệu bị thiếu không rõ lý do hoặc vì các lý do mà chúng ta không có bất kỳ thông tin nào. Ví dụ: trong bộ số liệu có thể thiếu thông tin về tuổi bởi vì một số bệnh nhân rất cao tuổi hoặc không biết hoặc từ chối cho biết tuổi. Trong tình huống này, số liệu bị thiếu về tuổi có liên quan đến giá trị của chính nó (và vì thế nó không phải là ngẫu nhiên) và không thể dự đoán được dựa trên các thông tin khác mà chúng ta có. MNAR là phức tạp và cách tốt nhất để giải quyết loại số liệu này thường là cố gắng thu thập thêm số liệu hoặc thông tin tại sao số liệu bị thiếu thay vì cố gắng gán giá trị cho nó.\n\nNhìn chung, việc gán số liệu cho MCAR thường khá đơn giản, trong khi cho MNAR là khá thách thức nếu không muốn nói là không thể. Có nhiều phương pháp gán số liệu phổ biến cho các số liệu được cho là MAR.\n\n\nCác packages hữu dụng\nMột số package hữu dụng để gán số liệu bị thiếu là Mmisc, missForest (mà sử dụng kỹ thuật Random Forests để gán số liệu bị thiếu), và package mice (viết tắt của Multivariate Imputation by Chained Equations). Đối với phần này, chúng ta chỉ sử dụng package mice để thực hiện nhiều kỹ thuật khác nhau. Người bảo trì package mice xuất bản một cuốn sách trực tuyến về gán số liệu bị thiếu, xem chi tiết hơn tại đây (https://stefvanbuuren.name/fimd/).\nĐây là code để tải package mice:\n\npacman::p_load(mice)\n\n\n\nGán bằng giá trị trung bình\nThỉnh thoảng, nếu chúng ta thực hiện một phân tích đơn giản hoặc chúng ta có một lý do chính đáng để nghĩ rằng chúng ta có thể giả định số liệu bị thiếu là hoàn toàn ngẫu nhiên (MCAR), chúng ta có thể chỉ cần gán các giá trị bị thiếu bằng giá trị trung bình của biến số đó. Có lẽ chúng ta có thể giả định rằng các giá trị bị thiếu của thân nhiệt trong bộ số liệu là MCAR hoặc chỉ là các giá trị bình thường. Đây là code để tạo một biến số mới để thay thế các giá trị thân nhiệt bị thiếu bằng giá trị thân nhiệt trung bình trong bộ số liệu. Tuy nhiên, trong nhiều tình huống, việc thay thế số liệu bằng giá trị trung bình có thể dẫn đến sai lệch, vì thế hãy cẩn thận.\n\nlinelist &lt;- linelist %&gt;%\n  mutate(temp_replace_na_with_mean = replace_na(temp, mean(temp, na.rm = T)))\n\nBạn cũng có thể thực hiện một quy trình tương tự để thay thế số liệu của biến phân loại bằng một giá trị cụ thể. Đối với bộ số liệu linelist, giả sử là bạn đã biết tất cả các quan sát có giá trị bị thiếu của biến số kết cục (mà có thể là “Tử vong” hoặc “Hồi phục”) thực sự là những người đã chết (lưu ý: điều này không thực sự đúng đối với bộ số liệu này):\n\nlinelist &lt;- linelist %&gt;%\n  mutate(outcome_replace_na_with_death = replace_na(outcome, \"Death\"))\n\n\n\nGán bằng hồi quy\nMột phương pháp nâng hơi cao hơn là sử dụng một số loại mô hình thống kê để dự đoán giá trị có lẽ bị thiếu và thay thế nó bằng giá trị dự đoán. Đây là một ví dụ về việc tạo ra các giá trị dự đoán cho tất cả các quan sát bị thiếu của biến số thân nhiệt (temperature), nhưng biến số tuổi (age) và biến số sốt (fever) thì không bị thiếu, bằng cách sử dụng hồi quy tuyến tính đơn giản với biến số dự đoán là tình trạng sốt và tuổi theo năm. Trong thực tế, chúng ta muốn sử dụng một mô hình tốt hơn kiểu tiếp cận đơn giản này..\n\nsimple_temperature_model_fit &lt;- lm(temp ~ fever + age_years, data = linelist)\n\n#using our simple temperature model to predict values just for the observations where temp is missing\npredictions_for_missing_temps &lt;- predict(simple_temperature_model_fit,\n                                        newdata = linelist %&gt;% filter(is.na(temp))) \n\nHoặc sử dụng cùng phương pháp mô hình hóa thông qua gói lệnh mice để tạo ra các giá trị gán cho các quan sát thân nhiệt bị thiếu:\n\nmodel_dataset &lt;- linelist %&gt;%\n  select(temp, fever, age_years)  \n\ntemp_imputed &lt;- mice(model_dataset,\n                            method = \"norm.predict\",\n                            seed = 1,\n                            m = 1,\n                            print = F)\n\nWarning: Number of logged events: 1\n\ntemp_imputed_values &lt;- temp_imputed$imp$temp\n\nCách trên có cùng cách tiếp cận với một số phương pháp nâng cao hơn như sử dụng package missForest để thay thế giá trị bị thiếu bằng các giá trị dự đoán. Trong trường hợp đó, mô hình dự đoán là một random forest thay vì là một hồi quy tuyến tính. Chúng ta cũng có thể sử dụng các loại mô hình khác để làm điều này. Tuy nhiên, phương pháp này thực hiện tốt với số liệu loại MCAR, nhưng chúng ta nên cẩn thận một chút nếu chúng ta tin rằng loại số liệu của chúng ta chính xác hơn là MAR hoặc MNAR. Chất lượng của việc gán giá trị bị thiếu sẽ phụ thuộc vào mô hình dự đoán tốt như thế nào, và ngay cả khi với một mô hình dự đoán rất tốt, tính biến thiên của số liệu được gán có thể đưa đến một ước lượng non.\n\n\nLOCF và BOCF\nLOCF (viết tắt của Last observation carried forward) và BOCF (viết tắt của baseline observation carried forward) là các phương pháp gán số liệu bị thiếu đối với số liệu chuỗi thời gian/số liệu dọc. Ý tưởng là lấy giá trị được quan sát trước đó để thay thế cho số liệu bị thiếu. Khi có nhiều giá trị bị thiếu liên tiếp, phương pháp này sẽ tìm kiếm giá trị được quan sát cuối cùng.\nHàm fill() từ package tidyr có thể được sử dụng cho cả phương pháp gán LOCF và BOCF (tuy nhiên, các package khác như HMISC, zoo, và data.table cũng có các phương pháp để làm điều này). Để hiển thị cú pháp của hàmfill(), chúng ta sẽ tạo một bộ số liệu chuỗi thời gian đơn giản mà bao gồm một số ca của một bệnh trong các quý của năm 2000 và 2001. Tuy nhiên, giá trị năm cho các quý tiếp theo sau Q1 bị thiếu, vì thế chúng ta cần gán các số liệu bị thiếu này. Hàm fill() cũng được trình bày chi tiết trong chương Xoay trục dữ liệu.\n\n#creating our simple dataset\ndisease &lt;- tibble::tribble(\n  ~quarter, ~year, ~cases,\n  \"Q1\",    2000,    66013,\n  \"Q2\",      NA,    69182,\n  \"Q3\",      NA,    53175,\n  \"Q4\",      NA,    21001,\n  \"Q1\",    2001,    46036,\n  \"Q2\",      NA,    58842,\n  \"Q3\",      NA,    44568,\n  \"Q4\",      NA,    50197)\n\n#imputing the missing year values:\ndisease %&gt;% fill(year)\n\n# A tibble: 8 × 3\n  quarter  year cases\n  &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;\n1 Q1       2000 66013\n2 Q2       2000 69182\n3 Q3       2000 53175\n4 Q4       2000 21001\n5 Q1       2001 46036\n6 Q2       2001 58842\n7 Q3       2001 44568\n8 Q4       2001 50197\n\n\nLưu ý: cần đảm bảo số liệu được sắp xếp chính xác trước khi sử dụng hàm fill(). Mặc định của hàm fill() là điền “xuống” nhưng chúng ta cũng có thể gán giá trị bị thiếu theo các hướng khác nhau bằng cách thay đổi tham số .direction. WChúng ta có thể tạo một tập số liệu tương tự mà giá trị của năm chỉ được ghi nhận vào cuối năm và bị thiếu ở các quý trước đó:\n\n#creating our slightly different dataset\ndisease &lt;- tibble::tribble(\n  ~quarter, ~year, ~cases,\n  \"Q1\",      NA,    66013,\n  \"Q2\",      NA,    69182,\n  \"Q3\",      NA,    53175,\n  \"Q4\",    2000,    21001,\n  \"Q1\",      NA,    46036,\n  \"Q2\",      NA,    58842,\n  \"Q3\",      NA,    44568,\n  \"Q4\",    2001,    50197)\n\n#imputing the missing year values in the \"up\" direction:\ndisease %&gt;% fill(year, .direction = \"up\")\n\n# A tibble: 8 × 3\n  quarter  year cases\n  &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;\n1 Q1       2000 66013\n2 Q2       2000 69182\n3 Q3       2000 53175\n4 Q4       2000 21001\n5 Q1       2001 46036\n6 Q2       2001 58842\n7 Q3       2001 44568\n8 Q4       2001 50197\n\n\nTrong ví dụ này, rõ ràng LOCF và BOCF thực hiện đúng các công việc, nhưng trong những tình huống phức tạp hơn, có thể là khó khăn hơn để quyết định những phương pháp này có phù hợp hay không. Ví dụ: chúng ta có thể thiếu các giá trị xét nghiệm của một bệnh nhân nằm viện sau ngày đầu tiên. Đôi lúc, điều này có thể có nghĩa là các giá trị xét nghiệm không thay đổi … nhưng cũng có thể là bệnh nhân đã hồi phục và những giá trị xét nghiệm của bệnh nhân này có thể là rất khác sau ngày đầu tiên! Hãy sử dụng những phương pháp này một cách thận trọng.\n\n\nGán số liệu nhiều lần\nCuốn sách trực tuyến mà chúng tôi đã đề cập trước đây bởi tác giả của package mice (https://stefvanbuuren.name/fimd/) bao gồm một giải thích chi tiết về gán số liệu nhiều lần và lý do tại sao chúng ta muốn sử dụng nó. Dưới đây là một giải thích cơ bản của phương pháp này:\nKhi chúng ta thực hiện gán nhiều lần, chúng ta tạo nhiều bộ số liệu với các giá trị bị thiếu mà được gán các giá trị hợp lý (tùy thuộc vào số liệu của chúng ta, chúng ta có thể muốn tạo nhiều hay ít các bộ số liệu được gán này, nhưng package mice đặt con số mặc định là 5). TSự khác biệt là thay vì một giá trị đơn lẻ cụ thể, mỗi giá trị được gán được rút ra từ một phân phối được ước tính (vì vậy nó bao gồm một số đặc tính ngẫu nhiên). Kết quả là, mỗi bộ số liệu này sẽ có các giá trị được gán khác nhau một chút (tuy nhiên, số liệu không bị thiếu sẽ giống nhau trong mỗi bộ số liệu được gán này). Chúng ta vẫn sử dụng một số loại mô hình dự đoán để thực hiện việc gán số liệu bị thiếu cho mỗi bộ số liệu mới này (package mice có nhiều tùy chọn cho các phương pháp dự đoán bao gồm Predictive Mean Matching, logistic regression, và random forest), nhưng package mice có thể đảm nhận nhiều chi tiết của mô hình.\nSau đó, một khi chúng ta đã tạo các bộ số liệu mới được gán giá trị bị thiếu này, chúng ta có thể áp dụng bất kỳ mô hình thống kê hoặc phân tích nào mà chúng ta dự định thực hiện cho mỗi bộ số liệu mới này và gộp kết quả của các mô hình này lại với nhau. Thao tác này rất tốt để giảm sai lệch đối với cả MCAR và MAR và thường cho các ước tính sai số chuẩn chính xác hơn.\nĐây là một ví dụ về việc áp dụng quy trình Gán Nhiều lần để dự đoán thân nhiệt trong bộ số liệu linelist bằng cách sử dụng tuổi và sốt (bộ số liệu mô hình đơn giản hóa bên trên):\n\n# imputing missing values for all variables in our model_dataset, and creating 10 new imputed datasets\nmultiple_imputation = mice(\n  model_dataset,\n  seed = 1,\n  m = 10,\n  print = FALSE) \n\nWarning: Number of logged events: 1\n\nmodel_fit &lt;- with(multiple_imputation, lm(temp ~ age_years + fever))\n\nbase::summary(mice::pool(model_fit))\n\n         term     estimate    std.error    statistic        df       p.value\n1 (Intercept) 3.703143e+01 0.0270863456 1.367162e+03  26.83673  1.583113e-66\n2   age_years 3.867829e-05 0.0006090202 6.350905e-02 171.44363  9.494351e-01\n3    feveryes 1.978044e+00 0.0193587115 1.021785e+02 176.51325 5.666771e-159\n\n\nỞ đây, chúng tôi sử dụng phương pháp gán mặc định của gói lệnh mice, đó là Predictive Mean Matching. Sau đó, chúng tôi sử dụng các bộ số liệu đã được gán này để ước tính riêng rẽ và gộp kết quả từ các hồi quy tuyến tính đơn giản trên mỗi bộ số liệu này. Có nhiều chi tiết mà chúng tôi đã phớt lờ và nhiều chỗ mà chúng ta có thể điều chỉnh trong suốt quá trình Gán Nhiều lần trong khi sử dụng gói lệnh mice. Ví dụ: chúng ta không phải lúc nào cũng có số liệu dạng số và có thể cần các phương pháp gán khác (chúng ta vẫn có thể sử dụng gói lệnh mice cho nhiều loại số liệu và phương pháp khác). Để một phân tích thiết thực hơn khi số liệu bị thiếu là một mối quan tâm đáng chú ý, Gán số liệu Nhiều lần là một giải pháp tốt, nhưng không phải lúc nào cũng hiệu quả hơn việc thực hiện một phân tích của các trường hợp hoàn chỉnh.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Dữ liệu Missing</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.vn.html#tài-nguyên-học-liệu",
    "href": "new_pages/missing_data.vn.html#tài-nguyên-học-liệu",
    "title": "20  Dữ liệu Missing",
    "section": "20.7 Tài nguyên học liệu",
    "text": "20.7 Tài nguyên học liệu\nMô tả của naniar package\nThư viện trực quan hóa giá trị Missing\nSách trực tuyến về multiple imputation trong R bởi người bảo trì của package mice",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Dữ liệu Missing</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.vn.html",
    "href": "new_pages/standardization.vn.html",
    "title": "21  Tỷ suất chuẩn hóa",
    "section": "",
    "text": "21.1 Tổng quan\nCó hai cách để chuẩn hóa: trực tiếp và gián tiếp. Giả sử chúng ta muốn chuẩn hóa tỷ suất tử vong theo tuổi và giới của quốc gia A và quốc gia B, và so sánh tỷ suất chuẩn hóa giữa hai quốc gia này",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Tỷ suất chuẩn hóa</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.vn.html#tổng-quan",
    "href": "new_pages/standardization.vn.html#tổng-quan",
    "title": "21  Tỷ suất chuẩn hóa",
    "section": "",
    "text": "Đối với chuẩn hóa trực tiếp, chúng ta phải biết dân số nguy cơ và số tử vong theo từng tầng của tuổi và giới của quốc gia A và B. Một tầng trong ví dụ của chúng ta là phụ nữ trong nhóm tuổi từ 15-44.\n\nĐối với chuẩn hóa gián tiếp, chúng ta chỉ cần biết tổng số tử vong và cấu trúc tuổi và giới của mỗi quốc gia. Vì thế, phương án này là khả khi tỷ suất tử vong hoặc dân số theo tuổi và giới không có sẵn. Hơn nữa, chuẩn hóa gián tiếp được ưa chuộng hơn khi có số lượng nhỏ trong các tầng, vì các ước tính trong chuẩn hóa trực tiếp sẽ bị ảnh hưởng bởi các thay đổi quan trọng khi lấy mẫu.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Tỷ suất chuẩn hóa</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.vn.html#chuẩn-bị",
    "href": "new_pages/standardization.vn.html#chuẩn-bị",
    "title": "21  Tỷ suất chuẩn hóa",
    "section": "21.2 Chuẩn bị",
    "text": "21.2 Chuẩn bị\nĐể chỉ dẫn cách thực hiện chuẩn hóa, chúng ta tạo ra dân số và số tử vong của quốc gia A và B theo tuổi (trong các nhóm tuổi của mỗi 5 tuổi) và giới (nữ, nam). Để các bộ số liệu có thể sử dụng được, chúng ta sẽ thực hiện các bước chuẩn bị như sau:\n\nGọi các packages\n\nTải các bộ số liệu\n\nNối số liệu dân số và tử vong của hai quốc gia\nXoay trục bộ số liệu dọc/dài hơn để có một hàng là một tầng theo tuổi-giới\nLàm sạch quần thể tham chiếu (dân số thế giới chuẩn) và kết nối nó với số liệu của quốc gia\n\nTrong trường hợp này, số liệu của chúng ta có thể có các định dạng khác nhau. Có lẽ số liệu của chúng ta theo tỉnh, thành phố, hoặc khu vực dịch vụ khác. Chúng ta có thể có một hàng cho mỗi ca tử vong và các thông tin về tuổi và giới cho mỗi trường hợp (hoặc một tỷ lệ có ý nghĩa) của các ca tử vong này. Trong trường hợp này, hãy xem các chương về Nhóm dữ liệu, Xoay trục dữ liệu, và Bảng mô tả để tạo một bộ số liệu với số lượng tử vong và dân số theo tầng của tuổi-giới tính.\nChúng ta cũng cần một quần thể tham chiếu, dân số chuẩn. Với mục đích của thực hành này, chúng ta sẽ sử dụng bộ số liệu world_standard_population_by_sex. Dân số chuẩn này dựa trên dân số của 46 quốc gia và được tạo ra vào năm 1960. Có rất nhiều dân số “chuẩn” – ví dụ, trang web của NHS Scotland cung cấp khá nhiều thông tin về Dân số Chuẩn của châu u, Dân số Chuẩn Thế giới, Dân số Chuẩn của Scotland.\n\n\nGọi packages\nĐoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R.\n\npacman::p_load(\n     rio,                 # import/export data\n     here,                # locate files\n     stringr,             # cleaning characters and strings\n     frailtypack,         # needed for dsr, for frailty models\n     dsr,                 # standardise rates\n     PHEindicatormethods, # alternative for rate standardisation\n     tidyverse)           # data management and visualization\n\nCẨN TRỌNG: Nếu đang sử dụng một phiên bản mới hơn của R, chúng ta không thể tải gói lệnh dsr trực tiếp từ CRAN. Tuy nhiên, nó vẫn còn trong mục lưu trữ của CRAN. Chúng ta có thể cài đặt và sử dụng nó. \nĐối với người không sử dụng hệ điều hành Mac:\n\npackageurl &lt;- \"https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz\"\ninstall.packages(packageurl, repos=NULL, type=\"source\")\n\n\n# Other solution that may work\nrequire(devtools)\ndevtools::install_version(\"dsr\", version=\"0.2.2\", repos=\"http:/cran.us.r.project.org\")\n\nĐối với người sử dụng hệ điều hành Mac:\n\nrequire(devtools)\ndevtools::install_version(\"dsr\", version=\"0.2.2\", repos=\"https://mac.R-project.org\")\n\n\n\nTải số liệu dân số\nXem chương Tải sách và dữ liệu để biết các hướng dẫn về cách tải tất cả các bộ số liệu mẫu trong cuốn số tay này. Chúng ta có thể nhập trực tiếp dữ liệu trong chương Chuẩn hóa này tới R thông qua kho lưu trữ Github của chúng tôi bằng cách thực hiện lệnh sau import():\n\n# import demographics for country A directly from Github\nA_demo &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics.csv\")\n\n# import deaths for country A directly from Github\nA_deaths &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryA.csv\")\n\n# import demographics for country B directly from Github\nB_demo &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics_2.csv\")\n\n# import deaths for country B directly from Github\nB_deaths &lt;- import(\"https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/standardization/deaths_countryB.csv\")\n\n# import demographics for country B directly from Github\nstandard_pop_data &lt;- import(\"https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/standardization/world_standard_population_by_sex.csv\")\n\nTrước tiên, chúng ta tải số liệu nhân khẩu (số lượng nam và nữ theo nhóm mỗi 5 tuổi) của hai quốc gia mà chúng ta sẽ so sánh, “Quốc gia A” và “Quốc gia B”.\n\n# Country A\nA_demo &lt;- import(\"country_demographics.csv\")\n\n\n\n\n\n\n\n\n# Country B\nB_demo &lt;- import(\"country_demographics_2.csv\")\n\n\n\n\n\n\n\n\n\nTải số liệu tử vong\nĐể thuận tiện cho việc thực hành, chúng ta cũng có số lượng tử vong theo tuổi và giới trong khoảng thời gian quan tâm. Số lượng tử vong của mỗi quốc gia nằm trong một tập tin riêng, được hiện thị bên dưới.\nSố tử vong ở Quốc gia A\n\n\n\n\n\n\nSố tử vong ở Quốc gia B\n\n\n\n\n\n\n\n\nLàm sạch số liệu dân số và tử vong\nChúng ta cần kết nối và chuyển đổi các số liệu này theo những cách sau:\n\nLiên kết dân số của các quốc gia vào một bộ số liệu và xoay trục thành bộ số liệu dạng “dọc/dài” để mỗi tầng tuổi-giới là một hàng\n\nLiên kết số liệu tử vong của các quốc gia vào một bộ số liệu và xoay trục thành bộ số liệu dạng “dọc/dài” để mỗi tầng tuổi-giới là một hàng\n\nNối số liệu tử vong với số liệu dân số\n\nĐầu tiên, chúng ta liên kết các bộ số liệu dân số quốc gia, chuyển đổi thành số liệu dạng dọc/dài hơn, và làm sạch số liệu. Xem chương Xoay trục dữ liệu để biết thêm chi tiết.\n\npop_countries &lt;- A_demo %&gt;%  # begin with country A dataset\n     bind_rows(B_demo) %&gt;%        # bind rows, because cols are identically named\n     pivot_longer(                       # pivot longer\n          cols = c(m, f),                   # columns to combine into one\n          names_to = \"Sex\",                 # name for new column containing the category (\"m\" or \"f\") \n          values_to = \"Population\") %&gt;%     # name for new column containing the numeric values pivoted\n     mutate(Sex = recode(Sex,            # re-code values for clarity\n          \"m\" = \"Male\",\n          \"f\" = \"Female\"))\n\nSố liệu dân số đã liên kết bây giờ trông giống như sau (nhấp qua để xem cột quốc gia A và B):\n\n\n\n\n\n\nVà bây giờ, chúng ta thực hiện các thao tác tương tự trên hai bộ số liệu tử vong.\n\ndeaths_countries &lt;- A_deaths %&gt;%    # begin with country A deaths dataset\n     bind_rows(B_deaths) %&gt;%        # bind rows with B dataset, because cols are identically named\n     pivot_longer(                  # pivot longer\n          cols = c(Male, Female),        # column to transform into one\n          names_to = \"Sex\",              # name for new column containing the category (\"m\" or \"f\") \n          values_to = \"Deaths\") %&gt;%      # name for new column containing the numeric values pivoted\n     rename(age_cat5 = AgeCat)      # rename for clarity\n\nSố liệu tử vong bây giờ trông giống như sau và chứa số liệu của cả hai quốc gia:\n\n\n\n\n\n\nBây giờ, chúng ta nối số liệu tử vong và số liệu dân số dựa trên các cột chung Country, age_cat5, và Sex. Thao tác này sẽ thêm cột Deaths.\n\ncountry_data &lt;- pop_countries %&gt;% \n     left_join(deaths_countries, by = c(\"Country\", \"age_cat5\", \"Sex\"))\n\nBây giờ, chúng ta có thể phân loại các biến số Sex, age_cat5, và Country thành dạng factors và đặt thứ tự các giá trị của biến số bằng cách sử dụng hàm fct_relevel() từ package forcats, như được mô tả trong chương Factors. Lưu ý rằng việc phân loại giá trị biến không thay đổi số liệu một cách rõ ràng, nhưng lệnh arrange() sẽ sắp xếp nó theo Quốc gia, nhóm tuổi và giới tính.\n\ncountry_data &lt;- country_data %&gt;% \n  mutate(\n    Country = fct_relevel(Country, \"A\", \"B\"),\n      \n    Sex = fct_relevel(Sex, \"Male\", \"Female\"),\n        \n    age_cat5 = fct_relevel(\n      age_cat5,\n      \"0-4\", \"5-9\", \"10-14\", \"15-19\",\n      \"20-24\", \"25-29\",  \"30-34\", \"35-39\",\n      \"40-44\", \"45-49\", \"50-54\", \"55-59\",\n      \"60-64\", \"65-69\", \"70-74\",\n      \"75-79\", \"80-84\", \"85\")) %&gt;% \n          \n  arrange(Country, age_cat5, Sex)\n\n\n\n\n\n\n\nCẨN TRỌNG: Nếu số trường hợp tử vong mỗi tầng là nhỏ, hãy cân nhắc chia nhóm tuổi mỗi 10-15 năm thay vì mỗi 5 năm cho các nhóm.\n\n\nTải dân số tham chiếu\nCuối cùng, để chuẩn hóa trực tiếp, chúng ta nhập dân số tham chiếu (“dân số chuẩn” thế giới theo giới tính)\n\n# Reference population\nstandard_pop_data &lt;- import(\"world_standard_population_by_sex.csv\")\n\n\n\n\n\n\n\n\n\n\nLàm sach dân số tham chiếu\nCác giá trị của biến tuổi trong bộ số liệu country_data và standard_pop_data cần phải được căn chỉnh.\nHiện tại, các giá trị của cột biến phân loại age_cat5 trong bộ số liệu standard_pop_data có chứa từ “years” và “plus”, trong khi không có các từ này trong trong bộ số liệu country_data. Chúng ta cần phải chuyển đổi các giá trị này giống nhau. Chúng ta sẽ sử dụng hàm str_replace_all() từ package stringr, như được mô tả trong chương Ký tự và chuỗi, để thay thế thành những kiểu mẫu không có khoảng trắng \"\".\nHơn nữa, package dsr đòi hỏi cột chứa số lượng trong bộ số liệu dân số chuẩn phải được gọi là \"pop\". Vì vậy, chúng ta đổi tên cột này cho phù hợp.\n\n# Remove specific string from column values\nstandard_pop_clean &lt;- standard_pop_data %&gt;%\n     mutate(\n          age_cat5 = str_replace_all(age_cat5, \"years\", \"\"),   # remove \"year\"\n          age_cat5 = str_replace_all(age_cat5, \"plus\", \"\"),    # remove \"plus\"\n          age_cat5 = str_replace_all(age_cat5, \" \", \"\")) %&gt;%   # remove \" \" space\n     \n     rename(pop = WorldStandardPopulation)   # change col name to \"pop\", as this is expected by dsr package\n\nCẨN TRỌNG: Nếu chúng ta cố gắng sử dụng hàm str_replace_all() để loại bỏ biểu tượng dấu cộng, hàm này sẽ không thực hiện bởi vì nó là một biểu tượng đặc biệt. “Xử lý” các biểu tượng này bằng cách đặt hai dấu gạch chéo phía trước như trong lệnh str_replace_call(column, \"\\\\+\", \"\"). \n\n\nTạo bộ số liệu với dân số chuẩn\nCuối cùng, sử dụng package PHEindicatormethods, được trình bày chi tiết bên dưới, để nối dân số chuẩn vào biến tử vong và dân số của các quốc gia. Vì vậy, chúng ta sẽ tạo một bộ số liệu với tên all_data cho mục đích đó.\n\nall_data &lt;- left_join(country_data, standard_pop_clean, by=c(\"age_cat5\", \"Sex\"))\n\nBộ số liệu hoàn chỉnh trông sẽ như thế này:",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Tỷ suất chuẩn hóa</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.vn.html#package-dsr",
    "href": "new_pages/standardization.vn.html#package-dsr",
    "title": "21  Tỷ suất chuẩn hóa",
    "section": "21.3 Package dsr",
    "text": "21.3 Package dsr\nBên dưới, chúng tôi trình bày việc tính toán và so sánh các tỷ suất được chuẩn hóa trực tiếp bằng cách sử dụng package dsr. Package dsr cho phép chúng ta tính toán và so sánh các tỷ suất được chuẩn hóa trực tiếp (không phải các tỷ suất được chuẩn hóa gián tiếp!).\nTrong phần Chuẩn bị số liệu, chúng ta đã tạo các bộ số liệu riêng biệt cho các quốc gia và dân số chuẩn:\n\nđối tượng country_data mà là một bảng dân số với số lượng dân số và số tử vong theo tầng cho mỗi quốc gia\n\nđối tượng standard_pop_clean, bao gồm số lượng dân số theo tầng cho dân số tham chiếu, Dân số Chuẩn Thế giới\n\nChúng ta sẽ sử dụng các bộ số liệu riêng rẽ này cho cách tiếp cận sử dụng package dsr.\n\n\nTỷ suất chuẩn hóa\nBên dưới, chúng ta tính toán các tỷ suất theo quốc gia được chuẩn hóa trực tiếp theo tuổi và giới. Chúng ta sử dụng hàm dsr().\nLưu ý - dsr() đòi hỏi một bộ số liệu dân số của các quốc gia và số lượng sự kiện (tử vong), và một bộ số liệu riêng rẽ với dân số tham chiếu. Nó cũng đòi hỏi trong bộ số liệu của dân số tham chiếu này tên cột đơn vị-thời gian là “pop” (chúng ta đã đảm bảo điều này trong phần Chuẩn bị số liệu).\nCó nhiều đối số, như được chú thích bên dưới. Đáng chú ý, đối số event = được đặt thành cột Deaths, và đối số fu = (“follow-up”) được đặt thành cột Population. Chúng ta đặt các nhóm so sánh là cột Country và chuẩn hóa dựa trên cột age_cat5 và Sex. Hai cột cuối cùng này không được gán với một đối số có tên cụ thể. Gõ ?dsr để biết thêm chi tiết.\n\n# Calculate rates per country directly standardized for age and sex\nmortality_rate &lt;- dsr::dsr(\n     data = country_data,  # specify object containing number of deaths per stratum\n     event = Deaths,       # column containing number of deaths per stratum \n     fu = Population,      # column containing number of population per stratum\n     subgroup = Country,   # units we would like to compare\n     age_cat5,             # other columns - rates will be standardized by these\n     Sex,\n     refdata = standard_pop_clean, # reference population data frame, with column called pop\n     method = \"gamma\",      # method to calculate 95% CI\n     sig = 0.95,            # significance level\n     mp = 100000,           # we want rates per 100.000 population\n     decimals = 2)          # number of decimals)\n\n\n# Print output as nice-looking HTML table\nknitr::kable(mortality_rate) # show mortality rate before and after direct standardization\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSubgroup\nNumerator\nDenominator\nCrude Rate (per 1e+05)\n95% LCL (Crude)\n95% UCL (Crude)\nStd Rate (per 1e+05)\n95% LCL (Std)\n95% UCL (Std)\n\n\n\n\nA\n11344\n86790567\n13.07\n12.83\n13.31\n23.57\n23.08\n24.06\n\n\nB\n9955\n52898281\n18.82\n18.45\n19.19\n19.33\n18.46\n20.22\n\n\n\n\n\nBên trên, chúng ta thấy rằng tỷ suất tử vong thô của quốc gia A thấp hơn quốc gia B, nhưng tỷ suất được chuẩn hóa trực tiếp theo tuổi và giới thì cao hơn.\n\n\n\nTỷ số của các tỷ suất chuẩn hóa\n\n# Calculate RR\nmortality_rr &lt;- dsr::dsrr(\n     data = country_data, # specify object containing number of deaths per stratum\n     event = Deaths,      # column containing number of deaths per stratum \n     fu = Population,     # column containing number of population per stratum\n     subgroup = Country,  # units we would like to compare\n     age_cat5,\n     Sex,                 # characteristics to which we would like to standardize \n     refdata = standard_pop_clean, # reference population, with numbers in column called pop\n     refgroup = \"B\",      # reference for comparison\n     estimate = \"ratio\",  # type of estimate\n     sig = 0.95,          # significance level\n     mp = 100000,         # we want rates per 100.000 population\n     decimals = 2)        # number of decimals\n\n# Print table\nknitr::kable(mortality_rr) \n\n\n\n\n\n\n\n\n\n\n\n\nComparator\nReference\nStd Rate (per 1e+05)\nRate Ratio (RR)\n95% LCL (RR)\n95% UCL (RR)\n\n\n\n\nA\nB\n23.57\n1.22\n1.17\n1.27\n\n\nB\nB\n19.33\n1.00\n0.94\n1.06\n\n\n\n\n\nTỷ suất tử vong chuẩn hóa của quốc gia A cao gấp 1.22 lần so với quốc gia B (95% CI 1.17-1.27).\n\n\n\nKhác biệt của các tỷ suất chuẩn hóa\n\n# Calculate RD\nmortality_rd &lt;- dsr::dsrr(\n     data = country_data,       # specify object containing number of deaths per stratum\n     event = Deaths,            # column containing number of deaths per stratum \n     fu = Population,           # column containing number of population per stratum\n     subgroup = Country,        # units we would like to compare\n     age_cat5,                  # characteristics to which we would like to standardize\n     Sex,                        \n     refdata = standard_pop_clean, # reference population, with numbers in column called pop\n     refgroup = \"B\",            # reference for comparison\n     estimate = \"difference\",   # type of estimate\n     sig = 0.95,                # significance level\n     mp = 100000,               # we want rates per 100.000 population\n     decimals = 2)              # number of decimals\n\n# Print table\nknitr::kable(mortality_rd) \n\n\n\n\n\n\n\n\n\n\n\n\nComparator\nReference\nStd Rate (per 1e+05)\nRate Difference (RD)\n95% LCL (RD)\n95% UCL (RD)\n\n\n\n\nA\nB\n23.57\n4.24\n3.24\n5.24\n\n\nB\nB\n19.33\n0.00\n-1.24\n1.24\n\n\n\n\n\nQuốc gia A có hơn 4,24 ca tử vong trên 100,000 dân (95% CI 3.24-5.24) so với quốc gia B.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Tỷ suất chuẩn hóa</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.vn.html#standard_phe",
    "href": "new_pages/standardization.vn.html#standard_phe",
    "title": "21  Tỷ suất chuẩn hóa",
    "section": "21.4 Package PHEindicatormethods",
    "text": "21.4 Package PHEindicatormethods\nMột cách khác để tính tỷ suất chuẩn hóa là dùng package PHEindicatormethods. Package này cho phép chúng ta tính toán tỷ suất chuẩn hóa trực tiếp cũng như gián tiếp. Chúng tôi sẽ hướng dẫn cả hai.\nPhần này chúng ta sẽ sử dụng bộ số liệu all_data được tạo ở cuối phần Chuẩn bị. Bộ số liệu này bao gồm dân số quốc gia, số tử vong và dân số tham chiếu. Bạn có thể xem nó ở đây.\n\n\nTỷ suất chuẩn hóa trực tiếp\nĐầu tiên, chúng ta nhóm số liệu theo Quốc gia như bên dưới và sau đó chuyển số liệu vào hàm phe_dsr() để có được tỷ suất chuẩn hóa trực tiếp theo quốc gia.\nLưu ý, dân số tham chiếu (chuẩn) có thể được cung cấp dưới dạng một cột bên trong số liệu của một quốc gia cụ thể hoặc dưới dạng một véctơ riêng biệt. Nếu được cung cấp bên trong số liệu của một quốc gia cụ thể, bạn phải đặt stdpoptype = \"field\". Nếu được cung cấp như một véc tơ, đặt stdpoptype = \"vector\". Trong trường hợp thứ hai, chúng ta phải đảm bảo thứ tự của các hàng theo tầng tương tự nhau trong cả khung số liệu quốc gia và dân số tham chiếu, vì vị trí các bản ghi/các hàng phải khớp với nhau. Trong ví dụ bên dưới, chúng tôi đã cung cấp dân số tham chiếu dưới dạng một cột bên trong khung số liệu của một quốc gia cụ thể.\nXem trợ giúp bằng cách gõ ?phr_dsr hoặc các liên kết trong phần Tài nguyên học liệu để biết thêm thông tin.\n\n# Calculate rates per country directly standardized for age and sex\nmortality_ds_rate_phe &lt;- all_data %&gt;%\n     group_by(Country) %&gt;%\n     PHEindicatormethods::phe_dsr(\n          x = Deaths,                 # column with observed number of events\n          n = Population,             # column with non-standard pops for each stratum\n          stdpop = pop,               # standard populations for each stratum\n          stdpoptype = \"field\")       # either \"vector\" for a standalone vector or \"field\" meaning std populations are in the data  \n\n# Print table\nknitr::kable(mortality_ds_rate_phe)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCountry\ntotal_count\ntotal_pop\nvalue\nlowercl\nuppercl\nconfidence\nstatistic\nmethod\n\n\n\n\nA\n11344\n86790567\n23.56686\n23.08107\n24.05944\n95%\ndsr per 100000\nDobson\n\n\nB\n9955\n52898281\n19.32549\n18.45516\n20.20882\n95%\ndsr per 100000\nDobson\n\n\n\n\n\n\n\n\nTỷ suất chuẩn hóa gián tiếp\nĐể chuẩn hóa gián tiếp, chúng ta cần dân số tham chiếu có số lượng tử vong và dân số theo tầng. Trong ví dụ này, chúng ta sẽ tính tỷ suất của quốc gia A bằng cách sử dụng quốc gia B làm dân số tham chiếu, vì dân số tham chiếu trong bộ số liệu standard_pop_clean không có số lượng tử vong theo tầng.\nTrước tiên, chúng ta tạo dân số tham chiếu từ quốc gia B như bên dưới. Sau đó, chúng ta chuyển số liệu tử vong và dân số của quốc gia A, kết nối nó với dân số tham chiếu và chuyển nó vào hàm calculate_ISRate(), để có được tỷ suất chuẩn hóa gián tiếp. Dĩ nhiên, chúng ta cũng có thể làm ngược lại.\nLưu ý - trong ví dụ bên dưới, dân số tham chiếu được cung cấp dưới dạng một data frame riêng rẽ. Trong trường hợp này, chúng ta cần đảm bảo rằng các véctơ x =, n =, x_ref = và n_ref = tất cả được sắp đặt cùng giá trị với loại chuẩn hóa (theo đúng tầng) như được sắp đặt trong data frame quốc gia, vì vị trí các bản ghi/các hàng phải khớp với nhau.\nXem trợ giúp bằng cách gõ ?phr_isr hoặc các liên kết trong phần Tài nguyên học liệu để biết thêm thông tin.\n\n# Create reference population\nrefpopCountryB &lt;- country_data %&gt;% \n  filter(Country == \"B\") \n\n# Calculate rates for country A indirectly standardized by age and sex\nmortality_is_rate_phe_A &lt;- country_data %&gt;%\n     filter(Country == \"A\") %&gt;%\n     PHEindicatormethods::calculate_ISRate(\n          x = Deaths,                 # column with observed number of events\n          n = Population,             # column with non-standard pops for each stratum\n          x_ref = refpopCountryB$Deaths,  # reference number of deaths for each stratum\n          n_ref = refpopCountryB$Population)  # reference population for each stratum\n\n# Print table\nknitr::kable(mortality_is_rate_phe_A)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nobserved\nexpected\nref_rate\nvalue\nlowercl\nuppercl\nconfidence\nstatistic\nmethod\n\n\n\n\n11344\n15847.42\n18.81914\n13.47123\n13.22446\n13.72145\n95%\nindirectly standardised rate per 100000\nByars",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Tỷ suất chuẩn hóa</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.vn.html#tài-nguyên-học-liệu",
    "href": "new_pages/standardization.vn.html#tài-nguyên-học-liệu",
    "title": "21  Tỷ suất chuẩn hóa",
    "section": "21.5 Tài nguyên học liệu",
    "text": "21.5 Tài nguyên học liệu\nNếu bạn muốn tìm thêm các ví dụ có thể tái lập được sử dụng package dsr, vui lòng xem hướng dẫn này\nVới các ví dụ khác sử dụng package PHEindicatormethods, vui lòng xem tại website này\nXem thêm PHEindicatormethods tài liệu dưới dạng tệp pdf",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Tỷ suất chuẩn hóa</span>"
    ]
  },
  {
    "objectID": "new_pages/moving_average.vn.html",
    "href": "new_pages/moving_average.vn.html",
    "title": "22  Đường trung bình động",
    "section": "",
    "text": "22.1 Chuẩn bị",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Đường trung bình động</span>"
    ]
  },
  {
    "objectID": "new_pages/moving_average.vn.html#chuẩn-bị",
    "href": "new_pages/moving_average.vn.html#chuẩn-bị",
    "title": "22  Đường trung bình động",
    "section": "",
    "text": "Gọi package\nĐoạn code này hiển thị những package cần tải cho các phân tích. Trong sổ tay này, chúng tôi nhấn mạnh đến hàm p_load() từ pacman, hàm sẽ cài đặt package nếu cần và gọi nó ra để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với library() từ base R. Xem chương R cơ bản để có thêm thông tin về các R package.\n\npacman::p_load(\n  tidyverse,      # for data management and viz\n  slider,         # for calculating moving averages\n  tidyquant       # for calculating moving averages within ggplot\n)\n\n\n\nNhập dữ liệu\nChúng ta nhập các trường hợp trong linelist đã được làm sạch từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn theo dõi, bấm để tải xuống linelist “đã được làm sạch” (tệp .rds). Nhập dữ liệu với hàm import() từ package rio (hàm này xử lý nhiều loại tệp như .xlsx, .csv, .rds - Xem chương Nhập xuất dữ liệu để biết thêm chi tiết).\n\n# import the linelist\nlinelist &lt;- import(\"linelist_cleaned.xlsx\")\n\n50 hàng đầu tiên của linelist được hiển thị dưới đây.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Đường trung bình động</span>"
    ]
  },
  {
    "objectID": "new_pages/moving_average.vn.html#tính-toán-với-slider",
    "href": "new_pages/moving_average.vn.html#tính-toán-với-slider",
    "title": "22  Đường trung bình động",
    "section": "22.2 Tính toán với slider",
    "text": "22.2 Tính toán với slider\nSử dụng cách tiếp cận này để tính toán đường trung bình động trong một data frame trước khi vẽ biểu đồ.\nPackage slider cung cấp một số hàm tạo “cửa sổ trượt” giúp tính toán trung bình động, tổng tích lũy, hồi quy động (rolling regression), v.v. Nó coi data frame như một vectơ của các hàng, cho phép lặp lại hàng qua một data frame.\nDưới đây là một số hàm phổ biến:\n\nslide_dbl() - lặp qua một cột dạng số (từ “_dbl”) để thực hiện thao tác sử dụng cửa sổ trượt\n\nslide_sum() - hàm tắt tính tổng động (rolling sum) cho slide_dbl()\n\nslide_mean() - hàm tắt tính trung bình động (rolling average) cho slide_dbl()\n\nslide_index_dbl() - áp dụng cửa sổ cuộn trên một cột dạng số bằng cách sử dụng một cột riêng biệt để lập chỉ mục cửa sổ tiến trình (hữu ích nếu cuộn theo ngày mà một số ngày bị thiếu)\n\nslide_index_sum() - hàm tắt tính tổng động với chỉ mục\n\nslide_index_mean() - hàm tắt tính trung bình động với chỉ mục\n\n\nPackage slider có nhiều hàm khác được đề cập đến trong phần Tài nguyên học liệu của chương này. Ở đây, chúng tôi sẽ đề cập ngắn gọn đến những điểm thông dụng nhất.\nNhững đối số chính\n\n.x, đối số đầu tiên theo mặc định, là vectơ để lặp lại và để áp dụng hàm\n\n.i = cho các phiên bản “chỉ mục (index)” của hàm slider - cung cấp một cột để “lập chỉ mục” khi cuộn (xem phần dưới đây)\n\n.f =, đối số thứ hai theo mặc định, có thể dùng theo một trong hai cách:\n\nMột hàm, được viết không có dấu ngoặc đơn, như mean hoặc\n\nMột công thức, mà sẽ được chuyển đổi thành một hàm. Ví dụ ~ .x - mean(.x) sẽ trả về kết quả của giá trị hiện tại trừ đi giá trị trung bình của cửa sổ giá trị\n\nĐể biết thêm chi tiết xem tài liệu tham khảo này\n\nKích thước cửa sổ\nXác định kích thước của cửa sổ bằng cách sử dụng một trong hai đối số .before, .after, hoặc cả hai đối số:\n\n.before = - Cung cấp một số nguyên\n\n.after = - Cung cấp một số nguyên\n\n.complete = - Đặt giá trị này thành TRUE nếu bạn chỉ muốn tính toán được thực hiện trên các cửa sổ hoàn chỉnh\n\nVí dụ: Để có cửa sổ 7 ngày liên tục bao gồm giá trị hiện tại và sáu giá trị trước đó, hãy sử dụng .before = 6. Để có cửa sổ “trung tâm”, hãy cung cấp cùng một giá trị số cho cả .before = và .after =.\nTheo mặc định, .complete = sẽ nhận giá trị FALSE nên nếu cửa sổ hoàn chỉnh của các hàng không tồn tại, các hàm sẽ sử dụng các hàng sẵn có để thực hiện phép tính. Thiết lập giá trị thành TRUE giúp hạn chế việc các phép tính chỉ được thực hiện trên các cửa sổ hoàn chỉnh.\nMở rộng cửa sổ\nĐể có các tính toán tích lũy, hãy thiết lập đối số .before = thành Inf. Điều này giúp tiến hành tính toán cả trên giá trị hiện tại và tất cả các giá trị trước đó.\n\nCuộn theo ngày\nTrường hợp sử dụng có khả năng xảy ra nhất của tính toán biến động trong dịch tễ học ứng dụng là kiểm tra một số liệu theo thời gian. Ví dụ: đo lường động các ca mới mắc, dựa trên số lượng trường hợp hàng ngày.\nNếu bạn có dữ liệu chuỗi thời gian đã được làm sạch với đủ giá trị cho tất cả các ngày, bạn có thể sử dụng hàm slide_dbl(), như đã được trình bày trong chương Chuỗi thời gian và phát hiện ổ dịch.\nTuy nhiên, trong nhiều trường hợp dịch tễ học ứng dụng, bạn có thể gặp những ngày trống trong dữ liệu của mình, những ngày mà không có sự kiện nào được ghi lại. Trong những trường hợp này, tốt nhất là sử dụng các phiên bản “chỉ mục” của các hàm slider.\n\n\nDữ liệu được lập chỉ mục\nDưới đây, chúng tôi trình bày một ví dụ sử dụng slide_index_dbl() đối với các trường hợp của bộ dữ liệu linelist. Giả sử rằng mục tiêu của chúng ta là tính toán tỷ lệ mới mắc liên tục trong 7 ngày - tính tổng các trường hợp bằng cách sử dụng cửa sổ 7 ngày luân phiên. Nếu bạn đang tìm kiếm ví dụ về trung bình động, hãy xem phần bên dưới về cuộn theo nhóm.\nĐể bắt đầu, bộ dữ liệu daily_counts được tạo ra để phản ánh số lượng ca mắc hàng ngày từ linelist, như đã được tính toán với hàm count() trong dplyr.\n\n# make dataset of daily counts\ndaily_counts &lt;- linelist %&gt;% \n  count(date_hospitalisation, name = \"new_cases\")\n\nDưới đây là data frame daily_counts - bao gồm nrow(daily_counts) hàng, mỗi hàng đại diện cho một ngày, nhưng đặc biệt trong giai đoạn đầu của dịch, có một số ngày không xuất hiện (không có ca mắc nào được tiếp nhận vào những ngày đó).\n\n\n\n\n\n\nĐiều quan trọng là phải nhận ra rằng một hàm cuộn tiêu chuẩn (như slide_dbl() sẽ sử dụng cửa sổ của 7 hàng, không phải 7 ngày. Vì vậy, nếu có bất kỳ ngày nào trống, một số cửa sổ sẽ thực sự kéo dài hơn 7 ngày theo lịch!\nMột cửa sổ động “thông minh” có thể được tạo với hàm slide_index_dbl(). “Chỉ mục” có nghĩa là hàm sử dụng một cột riêng biệt làm “chỉ mục” cho cửa sổ động. Cửa sổ đó không chỉ đơn giản dựa trên các hàng của data frame.\nNếu cột chỉ mục là ngày, bạn có thêm khả năng xác định phạm vi cửa sổ cho .before = và/hoặc .after = theo đơn vị days() và months() của lubridate. Nếu bạn thực hiện những điều này, hàm sẽ bao gồm những ngày trống trong cửa sổ như thể chúng ở đó (dưới dạng giá trị NA).\nHãy đưa ra một so sánh. Dưới đây, chúng tôi tính toán số trường hợp mới mắc biến động trong 7 ngày với các cửa sổ thông thường và được lập chỉ mục.\n\nrolling &lt;- daily_counts %&gt;% \n  mutate(                                # create new columns\n    # Using slide_dbl()\n    ###################\n    reg_7day = slide_dbl(\n      new_cases,                         # calculate on new_cases\n      .f = ~sum(.x, na.rm = T),          # function is sum() with missing values removed\n      .before = 6),                      # window is the ROW and 6 prior ROWS\n    \n    # Using slide_index_dbl()\n    #########################\n    indexed_7day = slide_index_dbl(\n        new_cases,                       # calculate on new_cases\n        .i = date_hospitalisation,       # indexed with date_onset \n        .f = ~sum(.x, na.rm = TRUE),     # function is sum() with missing values removed\n        .before = days(6))               # window is the DAY and 6 prior DAYS\n    )\n\nQuan sát trong cột thông thường cho 7 hàng đầu tiên, cách số lượng ca mắc tăng đều đặn mặc dù các hàng không cách nhau 7 ngày! Cột “được lập chỉ mục” liền kề tính cho những ngày lịch trống này, vì vậy tổng 7 ngày của nó thấp hơn nhiều, ít nhất là khi khoảng thời gian các ca mắc cách nhau xa hơn trong thời kỳ dịch bệnh này.\n\n\n\n\n\n\nBây giờ bạn có thể vẽ biểu đồ những dữ liệu này bằng cách sử dụng ggplot():\n\nggplot(data = rolling)+\n  geom_line(mapping = aes(x = date_hospitalisation, y = indexed_7day), size = 1)\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBiến động theo nhóm\nNếu bạn nhóm dữ liệu của mình trước khi sử dụng hàm slider, các cửa sổ trượt sẽ được áp dụng theo nhóm. Hãy cẩn thận để sắp xếp các hàng của bạn với thứ tự mong muốn theo nhóm.\nMỗi khi một nhóm mới được tạo, cửa sổ trượt sẽ bắt đầu lại. Do đó, một điều cần lưu ý là nếu dữ liệu của bạn được nhóm lại và bạn đã thiết lập .complete = TRUE, bạn sẽ có các giá trị trống ở mỗi lần dịch chuyển giữa các nhóm. Khi hàm di chuyển xuống dưới qua các hàng, mọi dịch chuyển trong cột được nhóm sẽ bắt đầu lại việc cộng dồn kích thước cửa sổ tối thiểu để cho phép tính toán.\nXem chương Nhóm dữ liệu trong sổ tay này để biết thêm chi tiết về nhóm dữ liệu.\nDưới đây, chúng tôi đếm các ca mắc trong linelist theo ngày và theo bệnh viện. Sau đó, chúng tôi sắp xếp các hàng theo thứ tự tăng dần, thứ tự đầu tiên theo bệnh viện và sau đó là theo ngày. Tiếp theo, chúng tôi đặt group_by(). Cuối cùng, chúng tôi có thể tạo trung bình động mới của mình.\n\ngrouped_roll &lt;- linelist %&gt;%\n     \n  count(hospital, date_hospitalisation, name = \"new_cases\") %&gt;% \n     \n  arrange(hospital, date_hospitalisation) %&gt;%   # arrange rows by hospital and then by date\n     \n  group_by(hospital) %&gt;%              # group by hospital \n     \n  mutate(                             # rolling average  \n    mean_7day_hosp = slide_index_dbl(\n      .x = new_cases,                 # the count of cases per hospital-day\n      .i = date_hospitalisation,      # index on date of admission\n      .f = mean,                      # use mean()                  \n      .before = days(6)               # use the day and the 6 days prior\n      )\n  )\n\nĐây là bộ dữ liệu mới:\n\n\n\n\n\n\nBây giờ chúng ta có thể vẽ các đường trung bình động, hiển thị dữ liệu theo nhóm bằng cách chỉ định ~ hospital tới facet_wrap() trong ggplot(). Để giải trí, chúng tôi vẽ hai biểu đồ - một biểu đồ cột geom_col() thể hiện số lượng ca mắc hàng ngày và một biểu đồ đường geom_line() thể hiện đường trung bình động của 7 ngày.\n\nggplot(data = grouped_roll)+\n  geom_col(                       # plot daly case counts as grey bars\n    mapping = aes(\n      x = date_hospitalisation,\n      y = new_cases),\n    fill = \"grey\",\n    width = 1)+\n  geom_line(                      # plot rolling average as line colored by hospital\n    mapping = aes(\n      x = date_hospitalisation,\n      y = mean_7day_hosp,\n      color = hospital),\n    size = 1)+\n  facet_wrap(~hospital, ncol = 2)+ # create mini-plots per hospital\n  theme_classic()+                 # simplify background  \n  theme(legend.position = \"none\")+ # remove legend\n  labs(                            # add plot labels\n    title = \"7-day rolling average of daily case incidence\",\n    x = \"Date of admission\",\n    y = \"Case incidence\")\n\n\n\n\n\n\n\n\nNGUY HIỂM: Nếu bạn gặp lỗi cho biết “slide() was deprecated in tsibble 0.9.0 and is now defunct. Please use slider::slide() instead.”, điều đó có nghĩa là hàm slide() từ package tsibble đang đè lên hàm slide() từ package slider. Khắc phục lỗi này bằng cách cụ thể tên package trong lệnh, ví dụ slider::slide_dbl().",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Đường trung bình động</span>"
    ]
  },
  {
    "objectID": "new_pages/moving_average.vn.html#tính-toán-với-tidyquant-trong-ggplot",
    "href": "new_pages/moving_average.vn.html#tính-toán-với-tidyquant-trong-ggplot",
    "title": "22  Đường trung bình động",
    "section": "22.3 Tính toán với tidyquant trong ggplot()",
    "text": "22.3 Tính toán với tidyquant trong ggplot()\nPackage tidyquant cung cấp một cách tiếp cận khác để tính toán đường trung bình động - lần này chính là từ bên trong lệnh ggplot().\nDữ liệu linelist dưới đây được đếm theo ngày khởi phát và được vẽ dưới dạng một đường mờ (alpha &lt;1). Được phủ lên trên là một đường được tạo bằng hàm geom_ma() từ package tidyquant, với cửa sổ được thiết lập là 7 ngày (n = 7) với màu sắc và độ dày được chỉ định.\nTheo mặc định, geom_ma() sử dụng một đường trung bình động đơn giản (ma_fun = \"SMA\"), tuy nhiên, hàm này cũng có thể sử dụng các loại đường trung bình khác, chẳng hạn như:\n\n“EMA” - đường trung bình động lũy thừa (exponential moving average) (thêm trọng số cho các quan sát gần đây)\n\n“WMA” - đường trung bình động có trọng số (weighted moving average) (wts được sử dụng để đánh trọng số các quan sát trong đường trung bình động)\n\nCác loại đường trung bình động khác có thể được tìm thấy trong tài liệu về hàm\n\n\nlinelist %&gt;% \n  count(date_onset) %&gt;%                 # count cases per day\n  drop_na(date_onset) %&gt;%               # remove cases missing onset date\n  ggplot(aes(x = date_onset, y = n))+   # start ggplot\n    geom_line(                          # plot raw values\n      size = 1,\n      alpha = 0.2                       # semi-transparent line\n      )+             \n    tidyquant::geom_ma(                 # plot moving average\n      n = 7,           \n      size = 1,\n      color = \"blue\")+ \n  theme_minimal()                       # simple background\n\nWarning: Using the `size` aesthetic in this geom was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` in the `default_aes` field and elsewhere instead.\n\n\n\n\n\n\n\n\n\nXem tài liệu này để biết thêm chi tiết về các tùy chọn sẵn có trong tidyquant.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Đường trung bình động</span>"
    ]
  },
  {
    "objectID": "new_pages/moving_average.vn.html#tài-nguyên-học-liệu",
    "href": "new_pages/moving_average.vn.html#tài-nguyên-học-liệu",
    "title": "22  Đường trung bình động",
    "section": "22.4 Tài nguyên học liệu",
    "text": "22.4 Tài nguyên học liệu\nXem thông tin trực tuyến hữu ích về vignette for the slider package\nTrang github về Slider\nMột vignette slider\ntidyquant vignette\nNếu tình huống sử dụng của bạn yêu cầu “bỏ qua” các ngày cuối tuần và thậm chí là những ngày lễ, bạn có thể quan tâm đến package almanac.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Đường trung bình động</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.vn.html",
    "href": "new_pages/time_series.vn.html",
    "title": "23  Chuỗi thời gian và phát hiện ổ dịch",
    "section": "",
    "text": "23.1 Tổng quan\nChương này minh họa cách sử dụng của một số packages cho phân tích chuỗi thời gian. Các packages chủ yếu đến từ hệ sinh thái tidyverts, ngoài ra cũng sử dụng RECON trending package để fit các mô hình dịch tễ học bệnh truyền nhiễm.\nVÍ dụ dưới đây chúng ta sẽ sử dụng bộ dữ liệu về Campylobacter ở Đức thuộc package surveillance (xem chương Tải sách và dữ liệu để biết thêm chi tiết). Tuy nhiên, nếu bạn muốn thử chạy code này trên bộ dữ liệu lớn hơn (nhiều quốc gia hoặc tầng), bạn có thể tham khảo code mẫu tại repo github của r4epis.\nCác chủ đề được đề cập bao gồm:",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Chuỗi thời gian và phát hiện ổ dịch</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.vn.html#tổng-quan",
    "href": "new_pages/time_series.vn.html#tổng-quan",
    "title": "23  Chuỗi thời gian và phát hiện ổ dịch",
    "section": "",
    "text": "Dữ liệu chuỗi thời gian\nPhân tích mô tả\nFitting đường hồi quy\nMối liên hệ của hai chuỗi thời gian\nPhát hiện dịch bệnh\nChuỗi thời gian bị gián đoạn",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Chuỗi thời gian và phát hiện ổ dịch</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.vn.html#chuẩn-bị",
    "href": "new_pages/time_series.vn.html#chuẩn-bị",
    "title": "23  Chuỗi thời gian và phát hiện ổ dịch",
    "section": "23.2 Chuẩn bị",
    "text": "23.2 Chuẩn bị\n\nPackages\nĐoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R.\n\npacman::p_load(rio,          # File import\n               here,         # File locator\n               tidyverse,    # data management + ggplot2 graphics\n               tsibble,      # handle time series datasets\n               slider,       # for calculating moving averages\n               imputeTS,     # for filling in missing values\n               feasts,       # for time series decomposition and autocorrelation\n               forecast,     # fit sin and cosin terms to data (note: must load after feasts)\n               trending,     # fit and assess models \n               tmaptools,    # for getting geocoordinates (lon/lat) based on place names\n               ecmwfr,       # for interacting with copernicus sateliate CDS API\n               stars,        # for reading in .nc (climate data) files\n               units,        # for defining units of measurement (climate data)\n               yardstick,    # for looking at model accuracy\n               surveillance  # for aberration detection\n               )\n\n\n\nNhập dữ liệu\nBạn có thể tải xuống tất cả dữ liệu được sử dụng trong sổ tay này thông qua các hướng dẫn trong chương Tải sách và dữ liệu.\nBộ dữ liệu minh họa được sử dụng trong phần này là số lượng các trường hợp campylobacter hàng tuần được báo cáo ở Đức từ năm 2001 đến 2011. Bạn có thể bấm vào đây để tải xuống bộ dữ liệu này (.xlsx).\nBộ dữ liệu này là một phiên bản rút gọn của bộ dữ liệu có sẵn trong package surveillance. (để biết chi tiết, hãy gọi surveillance package ra sau đó nhập ?campyDE)\nNhập dữ liệu này với hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương Nhập xuất dữ liệu để biết thêm chi tiết).\n\n# import the counts into R\ncounts &lt;- rio::import(\"campylobacter_germany.xlsx\")\n\n10 hàng đầu tiên được hiển thị như bên dưới.\n\n\n\n\n\n\n\n\nLàm sạch dữ liệu\nCode dưới đây đảm bảo rằng cột ngày thág đã ở đúng định dạng. Trong chương này chúng ta sẽ sử dụng package tsibble và hàm yearweek sẽ được sử dụng để tạp biến lịch theo tuần. Có một số cách để thực hiện việc này (Xem chương Làm việc với ngày tháng để biết thêm chi tiết), tuy nhiên đối với dữ liệu chuỗi thời gian thì tốt nhất nên sử dụng thống nhất một framework (tsibble).\n\n## ensure the date column is in the appropriate format\ncounts$date &lt;- as.Date(counts$date)\n\n## create a calendar week variable \n## fitting ISO definitons of weeks starting on a monday\ncounts &lt;- counts %&gt;% \n     mutate(epiweek = yearweek(date, week_start = 1))\n\n\n\nTải xuống dữ liệu khí hậu\nTrong mục mối tương quan của hai chuỗi thời gian trong chương này, chúng ta sẽ so sánh số lượng trường hợp campylobacter với dữ liệu khí hậu. Dữ liệu khí hậu tại bất kỳ đâu trên thế giới đều có thể được tải xuống từ EU’s Copernicus Satellite. Đây không phải là các phép đo chính xác, mà dựa trên một mô hình (tương tự như phép nội suy), tuy nhiên lợi ích là mức độ bao phủ toàn cầu hàng giờ cũng như các dự báo.\nBạn có thể tải xuống từng tệp dữ liệu khí hậu này từ chương Tải sách và dữ liệu.\nVới mục đích minh họa ở đây, chúng tôi sẽ trình bày code để sử dụng package ecmwfr để lấy những dữ liệu này từ kho dữ liệu khí hậu Copernicus. Bạn sẽ cần tạo một tài khoản miễn phí để thực hiện. Trang web của package có một hướng dẫn hữu ích về cách thực hiện việc này. Dưới đây là code minh họa về cách thực hiện việc này, khi bạn có các khóa API thích hợp. Bạn phải thay thế X bên dưới bằng ID tài khoản của mình. Bạn sẽ cần tải xuống một năm dữ liệu cùng một lúc nếu không máy chủ sẽ hết thời gian chờ.\nNếu bạn không chắc chắn về tọa độ cho vị trí mà bạn muốn tải dữ liệu xuống, bạn có thể sử dụng gói tmaptools để lấy tọa độ ra từ open street maps. Một cách khác là dùng package photon, tuy nhiên nó chưa được chính thức xuất bản lên trên CRAN; cái hay của photon là nó cung cấp nhiều dữ liệu ngữ cảnh hơn khi có một số kết quả phù hợp cho tìm kiếm của bạn.\n\n## retrieve location coordinates\ncoords &lt;- geocode_OSM(\"Germany\", geometry = \"point\")\n\n## pull together long/lats in format for ERA-5 querying (bounding box) \n## (as just want a single point can repeat coords)\nrequest_coords &lt;- str_glue_data(coords$coords, \"{y}/{x}/{y}/{x}\")\n\n\n## Pulling data modelled from copernicus satellite (ERA-5 reanalysis)\n## https://cds.climate.copernicus.eu/cdsapp#!/software/app-era5-explorer?tab=app\n## https://github.com/bluegreen-labs/ecmwfr\n\n## set up key for weather data \nwf_set_key(user = \"XXXXX\",\n           key = \"XXXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXX\",\n           service = \"cds\") \n\n## run for each year of interest (otherwise server times out)\nfor (i in 2002:2011) {\n  \n  ## pull together a query \n  ## see here for how to do: https://bluegreen-labs.github.io/ecmwfr/articles/cds_vignette.html#the-request-syntax\n  ## change request to a list using addin button above (python to list)\n  ## Target is the name of the output file!!\n  request &lt;- request &lt;- list(\n    product_type = \"reanalysis\",\n    format = \"netcdf\",\n    variable = c(\"2m_temperature\", \"total_precipitation\"),\n    year = c(i),\n    month = c(\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\"),\n    day = c(\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\",\n            \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\",\n            \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\"),\n    time = c(\"00:00\", \"01:00\", \"02:00\", \"03:00\", \"04:00\", \"05:00\", \"06:00\", \"07:00\",\n             \"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\", \"13:00\", \"14:00\", \"15:00\",\n             \"16:00\", \"17:00\", \"18:00\", \"19:00\", \"20:00\", \"21:00\", \"22:00\", \"23:00\"),\n    area = request_coords,\n    dataset_short_name = \"reanalysis-era5-single-levels\",\n    target = paste0(\"germany_weather\", i, \".nc\")\n  )\n  \n  ## download the file and store it in the current working directory\n  file &lt;- wf_request(user     = \"XXXXX\",  # user ID (for authentication)\n                     request  = request,  # the request\n                     transfer = TRUE,     # download the file\n                     path     = here::here(\"data\", \"Weather\")) ## path to save the data\n  }\n\n\n\nNhập dữ liệu khí hậu\nCho dù bạn đã tải xuống dữ liệu khí hậu thông qua sổ tay này hay sử dụng code ở trên, thì bạn cần phải các tệp dữ liệu khí hậu trong 10 năm có phần mở rộng là “.nc”, được lưu trữ trong cùng một thư mục trong máy tính của bạn.\nSử dụng mã bên dưới để nhập các tệp này vào R với package stars.\n\n## define path to weather folder \nfile_paths &lt;- list.files(\n  here::here(\"data\", \"time_series\", \"weather\"), # replace with your own file path \n  full.names = TRUE)\n\n## only keep those with the current name of interest \nfile_paths &lt;- file_paths[str_detect(file_paths, \"germany\")]\n\n## read in all the files as a stars object \ndata &lt;- stars::read_stars(file_paths)\n\nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \n\n\nKhi các tệp này đã được nhập vào một đối tượng có tên data, chúng ta sẽ chuyển chúng thành một data frame.\n\n## change to a data frame \ntemp_data &lt;- as_tibble(data) %&gt;% \n  ## add in variables and correct units\n  mutate(\n    ## create an calendar week variable \n    epiweek = tsibble::yearweek(time), \n    ## create a date variable (start of calendar week)\n    date = as.Date(epiweek),\n    ## change temperature from kelvin to celsius\n    t2m = set_units(t2m, celsius), \n    ## change precipitation from metres to millimetres \n    tp  = set_units(tp, mm)) %&gt;% \n  ## group by week (keep the date too though)\n  group_by(epiweek, date) %&gt;% \n  ## get the average per week\n  summarise(t2m = as.numeric(mean(t2m)), \n            tp = as.numeric(mean(tp)))\n\n`summarise()` has grouped output by 'epiweek'. You can override using the\n`.groups` argument.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Chuỗi thời gian và phát hiện ổ dịch</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.vn.html#dữ-liệu-chuỗi-thời-gian",
    "href": "new_pages/time_series.vn.html#dữ-liệu-chuỗi-thời-gian",
    "title": "23  Chuỗi thời gian và phát hiện ổ dịch",
    "section": "23.3 Dữ liệu chuỗi thời gian",
    "text": "23.3 Dữ liệu chuỗi thời gian\nCó một số package khác nhau để cấu trúc và xử lý dữ liệu chuỗi thời gian. Như đã nói, chúng ta sẽ tập trung vào họ các package thuộc tidyverts và sẽ sử dụng package tsibble để xác định đối tượng chuỗi thời gian. Việc có một tập dữ liệu được xác định là một đối tượng chuỗi thời gian có nghĩa là việc cấu trúc phân tích của chúng ta sẽ trở nên dễ dàng hơn nhiều.\nĐể thực hiện, chúng ta sử dụng hàm tsibble() và cụ thể “chỉ mục (index)”, vd: biến số cụ thể đơn vị thời gian quan tâm. Trong trường hợp của chúng ta, biến số này có tên epiweek.\nVí dụ: nếu chúng ta có một tập dữ liệu với số lượng hàng tuần theo tỉnh, chúng ta cũng có thể cụ thể biến nhóm bằng cách cụ sử dụng đối số key =. Điều này sẽ cho phép chúng ta thực hiện phân tích cho từng nhóm.\n\n## define time series object \ncounts &lt;- tsibble(counts, index = epiweek)\n\nNhìn vào class(counts), ta thấy ngoài việc là một data frame gọn gàng (“tbl_df”, “tbl”, “data.frame”), nó có các thuộc tính bổ sung của một khung dữ liệu chuỗi thời gian (“tbl_ts”).\nBạn có thể xem nhanh dữ liệu của mình bằng cách sử dụng ggplot2. Từ biểu đồ ta thấy có một xu hướng theo mùa, và không có bất kỳ giá trị bị thiếu nào. Tuy nhiên, dường như có vấn đề với việc báo cáo vào đầu mỗi năm; số ca mắc bệnh giảm vào tuần cuối cùng của năm và sau đó tăng vào tuần đầu tiên của năm tiếp theo.\n\n## plot a line graph of cases by week\nggplot(counts, aes(x = epiweek, y = case)) + \n     geom_line()\n\n\n\n\n\n\n\n\nNGUY HIỂM: Không giống như ví dụ này, phần lớn các bộ dữ liệu sẽ chưa được làm sạch. Bạn sẽ cần phải kiểm tra các bản ghi trùng lặp và bản ghi bị thiếu như bên dưới.\n\n\nTrùng lặp\ntsibble không cho phép các quan sát trùng lặp. Vì vậy, mỗi hàng sẽ cần phải là duy nhất, hoặc duy nhất trong nhóm (biến key). Package này có một số hàm để xác định các bản ghi trùng lặp. Chúng bao gồm các hàm: are_duplicated() trả về một vectơ có giá trị TRUE/FALSE vector, truy vấn xem hàng có là duy nhất không; và hàm duplicates() sẽ cung cấp cho bạn một data frame chứa các hàng trùng lặp.\nXem chương Loại bỏ trùng lặp để biết thêm chi tiết về cách lựa chọn các hàng bạn muốn.\n\n## get a vector of TRUE/FALSE whether rows are duplicates\nare_duplicated(counts, index = epiweek) \n\n## get a data frame of any duplicated rows \nduplicates(counts, index = epiweek) \n\n\n\n\nBản ghi bị thiếu\nChúng ta đã thấy từ cuộc khảo sát tóm tắt bên trên, không có bất kỳ giá trị missing nào được phát hiện, nhưng chúng ta cũng đã thấy rằng dường như có vấn đề với việc báo cáo chậm trễ vào khoảng năm mới. Một cách để giải quyết vấn đề này có thể là đặt các giá trị này thành missing và sau đó impute các giá trị. Dạng đơn giản nhất của khi impute chuỗi thời gian là vẽ một đường thẳng giữa giá trị không bị thiếu cuối cùng và giá trị không bị thiếu tiếp theo. Để làm điều này, chúng ta sẽ sử dụng hàm na_interpolation() từ package imputeTS .\nXem chương Dữ liệu Missing để biết các tùy chọn khác của imputation.\nMột giải pháp thay thế khác sẽ là tính toán đường trung bình động, để thử và giải quyết các vấn đề báo cáo rõ ràng này (xem phần tiếp theo và chương Đường trung bình động.\n\n## create a variable with missings instead of weeks with reporting issues\ncounts &lt;- counts %&gt;% \n     mutate(case_miss = if_else(\n          ## if epiweek contains 52, 53, 1 or 2\n          str_detect(epiweek, \"W51|W52|W53|W01|W02\"), \n          ## then set to missing \n          NA_real_, \n          ## otherwise keep the value in case\n          case\n     ))\n\n## alternatively interpolate missings by linear trend \n## between two nearest adjacent points\ncounts &lt;- counts %&gt;% \n  mutate(case_int = imputeTS::na_interpolation(case_miss)\n         )\n\n## to check what values have been imputed compared to the original\nggplot_na_imputations(counts$case_miss, counts$case_int) + \n  ## make a traditional plot (with black axes and white background)\n  theme_classic()",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Chuỗi thời gian và phát hiện ổ dịch</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.vn.html#phân-tích-mô-tả",
    "href": "new_pages/time_series.vn.html#phân-tích-mô-tả",
    "title": "23  Chuỗi thời gian và phát hiện ổ dịch",
    "section": "23.4 Phân tích mô tả",
    "text": "23.4 Phân tích mô tả\n\n\nĐường trung bình động\nNếu dữ liệu rất nhiễu (dao động lên và xuống), việc tính toán đường trung bình động có thể sẽ hữu ích. Trong ví dụ dưới đây, với mỗi tuần chúng ta sẽ tính toán số trường hợp trung bình từ bốn tuần trước đó. Việc này sẽ giúp dữ liệu dễ diễn giải hơn. Trong trường hợp của chúng ta, điều này không thực sự bổ sung nhiều, vì vậy chúng ta sẽ bám vào dữ liệu nội suy để phân tích thêm. Xem chương Đường trung bình động để biết thêm chi tiết.\n\n## create a moving average variable (deals with missings)\ncounts &lt;- counts %&gt;% \n     ## create the ma_4w variable \n     ## slide over each row of the case variable\n     mutate(ma_4wk = slider::slide_dbl(case, \n                               ## for each row calculate the name\n                               ~ mean(.x, na.rm = TRUE),\n                               ## use the four previous weeks\n                               .before = 4))\n\n## make a quick visualisation of the difference \nggplot(counts, aes(x = epiweek)) + \n     geom_line(aes(y = case)) + \n     geom_line(aes(y = ma_4wk), colour = \"red\")\n\n\n\n\n\n\n\n\n\n\n\nTính chu kỳ\nSau đây chúng ta sẽ định nghĩa một hàm để tạo một biểu đồ chu kỳ. Xem chương Viết hàm để biết cách tạo một hàm trong R.\nĐầu tiên, hàm được định nghĩa. Các đối số của nó bao gồm một bộ dữ liệu với cột counts, start_week = là tuần đầu tiên của bộ dữ liệu, một con số để cho biết có bao nhiêu chu kỳ mỗi năm (ví dụ: 52, 12), và cuối cùng là kiểu đầu ra (xem chi tiết trong đoạn mã bên dưới).\n\n## Function arguments\n#####################\n## x is a dataset\n## counts is variable with count data or rates within x \n## start_week is the first week in your dataset\n## period is how many units in a year \n## output is whether you want return spectral periodogram or the peak weeks\n  ## \"periodogram\" or \"weeks\"\n\n# Define function\nperiodogram &lt;- function(x, \n                        counts, \n                        start_week = c(2002, 1), \n                        period = 52, \n                        output = \"weeks\") {\n  \n\n    ## make sure is not a tsibble, filter to project and only keep columns of interest\n    prepare_data &lt;- dplyr::as_tibble(x)\n    \n    # prepare_data &lt;- prepare_data[prepare_data[[strata]] == j, ]\n    prepare_data &lt;- dplyr::select(prepare_data, {{counts}})\n    \n    ## create an intermediate \"zoo\" time series to be able to use with spec.pgram\n    zoo_cases &lt;- zoo::zooreg(prepare_data, \n                             start = start_week, frequency = period)\n    \n    ## get a spectral periodogram not using fast fourier transform \n    periodo &lt;- spec.pgram(zoo_cases, fast = FALSE, plot = FALSE)\n    \n    ## return the peak weeks \n    periodo_weeks &lt;- 1 / periodo$freq[order(-periodo$spec)] * period\n    \n    if (output == \"weeks\") {\n      periodo_weeks\n    } else {\n      periodo\n    }\n    \n}\n\n## get spectral periodogram for extracting weeks with the highest frequencies \n## (checking of seasonality) \nperiodo &lt;- periodogram(counts, \n                       case_int, \n                       start_week = c(2002, 1),\n                       output = \"periodogram\")\n\n## pull spectrum and frequence in to a dataframe for plotting\nperiodo &lt;- data.frame(periodo$freq, periodo$spec)\n\n## plot a periodogram showing the most frequently occuring periodicity \nggplot(data = periodo, \n                aes(x = 1/(periodo.freq/52),  y = log(periodo.spec))) + \n  geom_line() + \n  labs(x = \"Period (Weeks)\", y = \"Log(density)\")\n\n\n\n\n\n\n\n## get a vector weeks in ascending order \npeak_weeks &lt;- periodogram(counts, \n                          case_int, \n                          start_week = c(2002, 1), \n                          output = \"weeks\")\n\nLƯU Ý: Có thể sử dụng các tuần ở trên để thêm chúng vào các chu kỳ sin và cosin, tuy nhiên chúng ta sẽ sử dụng một hàm để tạo ra các chu kỳ này (xem phần hồi quy bên dưới) \n\n\n\nTách nhỏ chuỗi thời gian\nPhân tách cổ điển được sử dụng để chia nhỏ một chuỗi thời gian thành một số phần, khi kết hợp lại với nhau sẽ tạo nên xu hướng mà bạn nhìn thấy. Các phần khác nhau này là:\n\nChu kỳ xu hướng (hướng dài hạn của dữ liệu)\n\nTheo mùa (lặp lại xu hướng)\n\nSự ngẫu nhiên (những gì còn lại sau khi loại bỏ xu hướng và theo mùa)\n\n\n## decompose the counts dataset \ncounts %&gt;% \n  # using an additive classical decomposition model\n  model(classical_decomposition(case_int, type = \"additive\")) %&gt;% \n  ## extract the important information from the model\n  components() %&gt;% \n  ## generate a plot \n  autoplot()\n\n\n\n\n\n\n\n\n\n\n\nTự tương quan\nTự tương quan cho bạn biết về mối quan hệ giữa số lượng của mỗi tuần và các tuần trước đó (được gọi là trễ).\nSử dụng hàm ACF(), chúng ta có thể tạo ra một biểu đồ cho chúng ta thấy số lượng đường có mối quan hệ ở các độ trễ khác nhau. Khi độ trễ bằng 0 (x = 0), đường này sẽ luôn là 1 vì nó cho thấy mối quan hệ giữa một quan sát và chính nó (không được hiển thị). Đường đầu tiên hiển thị ở đây (x = 1) cho thấy mối quan hệ giữa mỗi quan sát và quan sát trước nó (độ trễ bằng 1), đường thứ hai cho thấy mối quan hệ giữa mỗi quan sát và quan sát trước quan sát cuối cùng (độ trễ là 2) và cứ như thế cho đến khi độ trễ là 52, cho thấy mối quan hệ giữa mỗi quan sát và quan sát từ 1 năm (52 tuần trước đó).\nSử dụng hàm ACF() (cho tự tương quan một phần) hiển thị cùng một loại quan hệ nhưng được hiệu chỉnh cho tất cả các tuần khác nằm giữa. Nó sẽ ít thông tin hơn để xác định tính chu kỳ.\n\n## using the counts dataset\ncounts %&gt;% \n  ## calculate autocorrelation using a full years worth of lags\n  ACF(case_int, lag_max = 52) %&gt;% \n  ## show a plot\n  autoplot()\n\n\n\n\n\n\n\n## using the counts data set \ncounts %&gt;% \n  ## calculate the partial autocorrelation using a full years worth of lags\n  PACF(case_int, lag_max = 52) %&gt;% \n  ## show a plot\n  autoplot()\n\n\n\n\n\n\n\n\nBạn có thể kiểm định giả thuyết không về tính độc lập trong một chuỗi thời gian (vd: không tự tương quan) sử dụng kiểm định Ljung-Box (trong package stats). Giá trị p có ý nghĩa cho thấy rằng có sự tự tương quan trong dữ liệu.\n\n## test for independance \nBox.test(counts$case_int, type = \"Ljung-Box\")\n\n\n    Box-Ljung test\n\ndata:  counts$case_int\nX-squared = 462.65, df = 1, p-value &lt; 2.2e-16",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Chuỗi thời gian và phát hiện ổ dịch</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.vn.html#fit-mô-hình-hồi-quy",
    "href": "new_pages/time_series.vn.html#fit-mô-hình-hồi-quy",
    "title": "23  Chuỗi thời gian và phát hiện ổ dịch",
    "section": "23.5 Fit mô hình hồi quy",
    "text": "23.5 Fit mô hình hồi quy\nCó thể fit một số lượng lớn các hồi quy khác nhau vào một chuỗi thời gian, tuy nhiên ở đây chúng tôi sẽ trình bày cách để fit một hồi quy nhị thức âm - vì nó thường phù hợp nhất cho dữ liệu về trường hợp bệnh trong các bệnh truyền nhiễm.\n\n\nChu kỳ Fourier\nChu kỳ Fourier tương đương với các đường cong sin và cosin. Sự khác biệt là chúng được dựa trên việc tìm ra sự kết hợp thích hợp nhất của các đường cong để giải thích dữ liệu của bạn.\nIf only fitting một chu kỳ Fourier, điều này sẽ tương đương với việc fitting một đường sin và cosin cho độ trễ xảy ra thường xuyên nhất được thấy trong biểu đồ chu kỳ của bạn (trong trường hợp của chúng ta là 52 tuần). Chúng ta sử dụng hàm fourier() từ package forecast.\nTrong code dưới đây, chúng ta gán bằng cách sử dụng $, vì hàm fourier() trả về hai cột (một cho sin và một cho cosin) và vì vậy chúng được thêm vào tập dữ liệu dưới dạng danh sách, được gọi là “fourier” - nhưng danh sách này sau đó có thể được sử dụng như một biến bình thường trong hồi quy.\n\n## add in fourier terms using the epiweek and case_int variabless\ncounts$fourier &lt;- select(counts, epiweek, case_int) %&gt;% \n  fourier(K = 1)\n\n\n\n\nHồi quy nhị thức âm\nBạn có thể fit các mô hình hồi quy sử dụng các hàm từ package stats hoặc MASS trong base R (vd: lm(), glm() và glm.nb()). Tuy nhiên, chúng ta sẽ sử dụng các hàm từ package trending, vì nó cho phép tính khoảng tin cậy và khoảng tiên lượng phù hợp (các hàm khác không có sẵn). Cú pháp vẫn như vậy, bạn cụ thể biến đầu ra và theo sau bởi dấu ngã (~), sau đó thêm các biến giải thích vào, phân cách nhau bởi dấu cộng (+).\nSự khác biệt là đầu tiên chúng ta phải xác định model trước, và sau đó fit() nó vào dữ liệu. Điều này rất hữu ích vì nó cho phép so sánh nhiều mô hình khác nhau với cùng một cú pháp..\nMẸO: Nếu bạn muốn sử dụng tỷ suất hơn là số lượng, bạn có thể bao gồm biến dân số dưới dạng thuật ngữ bù logarit, bằng cách thêm offset(log(population). Sau đó, bạn sẽ cần đặt dân số là 1, trước khi sử dụng hàm predict() để tạo ra tỷ suất. \nMẸO: Để fit những mô hình phức tạp hơn chẳng hạn như ARIMA hoặc prophet, hãy tham khảo package fable.\n\n## define the model you want to fit (negative binomial) \nmodel &lt;- glm_nb_model(\n  ## set number of cases as outcome of interest\n  case_int ~\n    ## use epiweek to account for the trend\n    epiweek +\n    ## use the fourier terms to account for seasonality\n    fourier)\n\n## fit your model using the counts dataset\nfitted_model &lt;- trending::fit(model, counts)\n\n## calculate confidence intervals and prediction intervals \nobserved &lt;- predict(fitted_model, simulate_pi = FALSE)\n\nestimate_res &lt;- data.frame(observed$result)\n\n## plot your regression \nggplot(data = estimate_res, aes(x = epiweek)) + \n  ## add in a line for the model estimate\n  geom_line(aes(y = estimate),\n            col = \"Red\") + \n  ## add in a band for the prediction intervals \n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## add in a line for your observed case counts\n  geom_line(aes(y = case_int), \n            col = \"black\") + \n  ## make a traditional plot (with black axes and white background)\n  theme_classic()\n\n\n\n\n\n\n\n\n\n\n\nPhần dư\nĐể xem mô hình của chúng ta phù hợp với dữ liệu quan sát như thế nào, chúng ta cần xem xét phần dư. Phần dư là sự khác biệt giữa số lượng được quan sát và số lượng được ước tính từ mô hình. Chúng ta có thể tính toán nó một cách đơn giản bằng cách dùng hàm case_int - estimate, nhưng hàm residuals() trích xuất nó trực tiếp từ mô hình hồi quy cho chúng ta.\nNhững gì chúng ta thấy dưới đây là chúng ta không giải thích tất cả các sự dao động mà chúng ta có thể có với mô hình. Có thể chúng ta cần fit nhiều chu kỳ fourier hơn, và gủau quyết biên độ. Tuy nhiên đối với ví dụ này, chúng ta sẽ để nguyên như vậy. Các biểu đồ cho thấy mô hình của chúng ta hoạt động kém hơn ở các đỉnh và đáy (khi số lượng ở mức cao nhất và thấp nhất) và có nhiều khả năng ước tính không đầy đủ các số lượng quan sát được.\n\n## calculate the residuals \nestimate_res &lt;- estimate_res %&gt;% \n  mutate(resid = fitted_model$result[[1]]$residuals)\n\n## are the residuals fairly constant over time (if not: outbreaks? change in practice?)\nestimate_res %&gt;%\n  ggplot(aes(x = epiweek, y = resid)) +\n  geom_line() +\n  geom_point() + \n  labs(x = \"epiweek\", y = \"Residuals\")\n\n\n\n\n\n\n\n## is there autocorelation in the residuals (is there a pattern to the error?)  \nestimate_res %&gt;% \n  as_tsibble(index = epiweek) %&gt;% \n  ACF(resid, lag_max = 52) %&gt;% \n  autoplot()\n\n\n\n\n\n\n\n## are residuals normally distributed (are under or over estimating?)  \nestimate_res %&gt;%\n  ggplot(aes(x = resid)) +\n  geom_histogram(binwidth = 100) +\n  geom_rug() +\n  labs(y = \"count\") \n\n\n\n\n\n\n\n## compare observed counts to their residuals \n  ## should also be no pattern \nestimate_res %&gt;%\n  ggplot(aes(x = estimate, y = resid)) +\n  geom_point() +\n  labs(x = \"Fitted\", y = \"Residuals\")\n\n\n\n\n\n\n\n## formally test autocorrelation of the residuals\n## H0 is that residuals are from a white-noise series (i.e. random)\n## test for independence \n## if p value significant then non-random\nBox.test(estimate_res$resid, type = \"Ljung-Box\")\n\n\n    Box-Ljung test\n\ndata:  estimate_res$resid\nX-squared = 336.25, df = 1, p-value &lt; 2.2e-16",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Chuỗi thời gian và phát hiện ổ dịch</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.vn.html#mối-quan-hệ-của-hai-chuỗi-thời-gian",
    "href": "new_pages/time_series.vn.html#mối-quan-hệ-của-hai-chuỗi-thời-gian",
    "title": "23  Chuỗi thời gian và phát hiện ổ dịch",
    "section": "23.6 Mối quan hệ của hai chuỗi thời gian",
    "text": "23.6 Mối quan hệ của hai chuỗi thời gian\nỞ đây chúng ta xem xét việc sử dụng dữ liệu thời tiết (đặc biệt là nhiệt độ) để giải thích số lượng trường hợp campylobacter.\n\n\nNối hai bộ dữ liệu\nBạn có thể nối các tập dữ liệu của mình sử dụng biến tuần. Để biết thêm về nối dữ liệu, xem chương Nối dữ liệu.\n\n## left join so that we only have the rows already existing in counts\n## drop the date variable from temp_data (otherwise is duplicated)\ncounts &lt;- left_join(counts, \n                    select(temp_data, -date),\n                    by = \"epiweek\")\n\n\n\n\nPhân tích mô tả\nĐầu tiên hãy trực quan hóa dữ liệu của bạn để kiểm tra xem có bất kỳ mối tương quan rõ ràng nào không. Biểu đồ dưới đây cho thấy một mối quan hệ rõ ràng về tính mùa vụ của các biến, và nhiệt độ có thể đạt đỉnh vài tuần trước khi các trường hợp xảy ra. Để biết thêm về xoay trục dữ liệu, xem chương Xoay trục dữ liệu.\n\ncounts %&gt;% \n  ## keep the variables we are interested \n  select(epiweek, case_int, t2m) %&gt;% \n  ## change your data in to long format\n  pivot_longer(\n    ## use epiweek as your key\n    !epiweek,\n    ## move column names to the new \"measure\" column\n    names_to = \"measure\", \n    ## move cell values to the new \"values\" column\n    values_to = \"value\") %&gt;% \n  ## create a plot with the dataset above\n  ## plot epiweek on the x axis and values (counts/celsius) on the y \n  ggplot(aes(x = epiweek, y = value)) + \n    ## create a separate plot for temperate and case counts \n    ## let them set their own y-axes\n    facet_grid(measure ~ ., scales = \"free_y\") +\n    ## plot both as a line\n    geom_line()\n\n\n\n\n\n\n\n\n\n\n\nLags và tương quan chéo\nĐể kiểm định xem những tuần nào có tương quan nhiều nhất tới các trường hợp và nhiệt độ, bạn có thể sử dụng hàm tương quan chéo (CCF()) từ package feasts. Bạn cũng có thể trực quan hóa (hơn là sử dụng arrange) sử dụng hàm autoplot().\n\ncounts %&gt;% \n  ## calculate cross-correlation between interpolated counts and temperature\n  CCF(case_int, t2m,\n      ## set the maximum lag to be 52 weeks\n      lag_max = 52, \n      ## return the correlation coefficient \n      type = \"correlation\") %&gt;% \n  ## arange in decending order of the correlation coefficient \n  ## show the most associated lags\n  arrange(-ccf) %&gt;% \n  ## only show the top ten \n  slice_head(n = 10)\n\n# A tsibble: 10 x 2 [1W]\n        lag   ccf\n   &lt;cf_lag&gt; &lt;dbl&gt;\n 1      -4W 0.749\n 2      -5W 0.745\n 3      -3W 0.735\n 4      -6W 0.729\n 5      -2W 0.727\n 6      -7W 0.704\n 7      -1W 0.695\n 8      -8W 0.671\n 9       0W 0.649\n10      47W 0.638\n\n\nChúng ta thấy rằng độ trễ 4 tuần có mối tương quan cao nhất, vì vậy chúng ta tạo một biến nhiệt độ trễ để đưa vào mô hình hồi quy.\nNGUY HIỂM: Lưu ý rằng bốn tuần đầu tiên dữ liệu của chúng ta trong biến nhiệt độ trễ bị thiếu (NA) - bởi vì không có bốn tuần trước đó để lấy dữ liệu. Để sử dụng bộ dữ liệu này với hàm trending predict(), chúng ta cần phải sử dụng đối số simulate_pi = FALSE bên trong hàm predict(). Nếu chúng ta muốn sử dụng tùy chọn mô phỏng, thì chúng ta phải loại bỏ các giá trị missings và lưu thành một bộ dữ liệu mới bằng cách thêm hàm drop_na(t2m_lag4) vào đoạn code dưới đây.\n\ncounts &lt;- counts %&gt;% \n  ## create a new variable for temperature lagged by four weeks\n  mutate(t2m_lag4 = lag(t2m, n = 4))\n\n\n\n\nHồi quy nhị thức âm với hai biến số\nChúng ta sẽ fit một mô hình hồi quy nhị thức âm như đã thực hiện trước đó. Lần này chúng ta thêm biến nhiệt độ có độ trễ là bốn tuần.\nCẨN TRỌNG: Lưu ý cách sử dụng của đối số simulate_pi = FALSE bên trong hàm predict(). Điều này là bởi hành vi mặc định của trending là sử dụng package ciTools để ước tính khoảng tiên lượng. Nó sẽ không hoạt động nếu có giá trị NA, cũng như tạo ra nhiều khoảng chi tiết hơn. Xem ?trending::predict.trending_model_fit để biết thêm chi tiết. \n\n## define the model you want to fit (negative binomial) \nmodel &lt;- glm_nb_model(\n  ## set number of cases as outcome of interest\n  case_int ~\n    ## use epiweek to account for the trend\n    epiweek +\n    ## use the fourier terms to account for seasonality\n    fourier + \n    ## use the temperature lagged by four weeks \n    t2m_lag4\n    )\n\n## fit your model using the counts dataset\nfitted_model &lt;- trending::fit(model, counts)\n\n## calculate confidence intervals and prediction intervals \nobserved &lt;- predict(fitted_model, simulate_pi = FALSE)\n\nĐể khảo sát các chu kỳ đơn lẻ, chúng ta có thể lấy mô hình hồi quy nhị thức âm gốc ra khỏi định dạng trending bằng cách sử dụng hàm get_model() và chuyển nó tới hàm tidy() của package broom để truy xuất các ước tính được lũy thừa hóa và các khoảng tin cậy.\nĐiều này cho chúng ta thấy là nhiệt độ trễ, sau khi kiểm soát xu hướng và tính theo mùa, tương tự như số lượng trường hợp (ước tính ~ 1) và sự liên quan có ý nghĩa. Điều này cho thấy rằng nó có thể là một biến số tốt để sử dụng trong việc dự báo các ca bệnh trong tương lai (các dữ liệu dự báo khí hậu luôn có sẵn).\n\nfitted_model %&gt;% \n  ## extract original negative binomial regression\n  get_fitted_model()\n\n[[1]]\n\nCall:  glm.nb(formula = case_int ~ epiweek + fourier + t2m_lag4, data = counts, \n    init.theta = 32.80689607, link = log)\n\nCoefficients:\n (Intercept)       epiweek  fourierS1-52  fourierC1-52      t2m_lag4  \n   5.825e+00     8.464e-05    -2.850e-01    -1.954e-01     6.672e-03  \n\nDegrees of Freedom: 504 Total (i.e. Null);  500 Residual\n  (4 observations deleted due to missingness)\nNull Deviance:      2015 \nResidual Deviance: 508.2    AIC: 6784\n\n  ## get a tidy dataframe of results\n  #tidy(exponentiate = TRUE, \n  #     conf.int = TRUE)\n\nĐánh giá nhanh mô hình cho thấy nó có thể thực hiện tốt hơn công việc ước tính số ca bệnh quan sát được.\n\nestimate_res &lt;- data.frame(observed$result)\n\n## plot your regression \nggplot(data = estimate_res, aes(x = epiweek)) + \n  ## add in a line for the model estimate\n  geom_line(aes(y = estimate),\n            col = \"Red\") + \n  ## add in a band for the prediction intervals \n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## add in a line for your observed case counts\n  geom_line(aes(y = case_int), \n            col = \"black\") + \n  ## make a traditional plot (with black axes and white background)\n  theme_classic()\n\n\n\n\n\n\n\n\n\nPhần dư\nChúng ta một lần nữa lại khảo sát phần dư để xem mô hình của chúng ta phù hợp với dữ liệu quan sát như thế nào. Các kết quả và phiên giải ở đây tương tự như kết quả của hồi quy trước đó, vì vậy sẽ khả thi hơn khi chọn mô hình đơn giản hơn mà không có nhiệt độ.\n\n## calculate the residuals \nestimate_res &lt;- estimate_res %&gt;% \n  mutate(resid = case_int - estimate)\n\n## are the residuals fairly constant over time (if not: outbreaks? change in practice?)\nestimate_res %&gt;%\n  ggplot(aes(x = epiweek, y = resid)) +\n  geom_line() +\n  geom_point() + \n  labs(x = \"epiweek\", y = \"Residuals\")\n\n\n\n\n\n\n\n## is there autocorelation in the residuals (is there a pattern to the error?)  \nestimate_res %&gt;% \n  as_tsibble(index = epiweek) %&gt;% \n  ACF(resid, lag_max = 52) %&gt;% \n  autoplot()\n\n\n\n\n\n\n\n## are residuals normally distributed (are under or over estimating?)  \nestimate_res %&gt;%\n  ggplot(aes(x = resid)) +\n  geom_histogram(binwidth = 100) +\n  geom_rug() +\n  labs(y = \"count\") \n\n\n\n\n\n\n\n## compare observed counts to their residuals \n  ## should also be no pattern \nestimate_res %&gt;%\n  ggplot(aes(x = estimate, y = resid)) +\n  geom_point() +\n  labs(x = \"Fitted\", y = \"Residuals\")\n\n\n\n\n\n\n\n## formally test autocorrelation of the residuals\n## H0 is that residuals are from a white-noise series (i.e. random)\n## test for independence \n## if p value significant then non-random\nBox.test(estimate_res$resid, type = \"Ljung-Box\")\n\n\n    Box-Ljung test\n\ndata:  estimate_res$resid\nX-squared = 339.52, df = 1, p-value &lt; 2.2e-16",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Chuỗi thời gian và phát hiện ổ dịch</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.vn.html#phát-hiện-ổ-dịch",
    "href": "new_pages/time_series.vn.html#phát-hiện-ổ-dịch",
    "title": "23  Chuỗi thời gian và phát hiện ổ dịch",
    "section": "23.7 Phát hiện ổ dịch",
    "text": "23.7 Phát hiện ổ dịch\nChúng tôi sẽ trình bày hai phương pháp (tương tự) để phát hiện các ổ dịch ở đây. Cách đầu tiên được xây dựng dựa vào phần bên trên. Chúng ta sử dụng package trending để fit các mô hình hồi quy cho các năm trước đó, sau đó dự báo cho các năm tiếp theo. Nếu số lượng quan sát được cao hơn những gì chúng tôi dự báo, thì khả năng là đã có một đợt bùng phát. Phương pháp thứ hai dựa trên nguyên tắc tương tự nhưng sử dụng package surveillance, cung cấp nhiều thuật toán khác nhau để phát hiện các thay đổi bất thường.\nCẨN TRỌNG: Thông thường, bạn quan tâm đến năm hiện tại (do bạn chỉ biết số ca bệnh đến tuần hiện tại). Vì vậy, trong ví dụ này, chúng tôi đang giả định là tuần 39 của năm 2011.\n\n\nPackage trending\nĐối với phương pháp này, chúng ta xác định một mốc (baseline) (thường là khoảng 5 năm dữ liệu). Chúng ta fit một mô hình hồi quy tới dữ liệu baseline, và sau đó sử dụng nó để ước tính cho năm sau.\n\n\nĐiểm cắt ngày\nSẽ dễ dàng hơn khi xác định ngày của bạn ở một nơi và sau đó sử dụng những ngày này trong suốt phần còn lại trong của bạn.\nỞ đây chúng ta xác định ngày bắt đầu (khi các quan sát của chúng ta bắt đầu) và ngày làm điểm cắt (cut-off date) (kết thúc giai đoạn baseline - và giai đoạn chúng ta muốn dự đoán cho sự bắt đầu). ~Chúng ta cũng xác định có bao nhiêu tuần trong năm mà chúng tôi sẽ dự đoán)~. Chúng ta cũng xác định có bao nhiêu tuần mà chúng ta đang muốn dự báo nằm giữa điểm cắt baseline và ngày kết thúc.\nLƯU Ý: Trong ví dụ này, chúng tôi giả sử hiện đang ở cuối tháng 9 năm 2011 (“2011 W39”).\n\n## define start date (when observations began)\nstart_date &lt;- min(counts$epiweek)\n\n## define a cut-off week (end of baseline, start of prediction period)\ncut_off &lt;- yearweek(\"2010-12-31\")\n\n## define the last date interested in (i.e. end of prediction)\nend_date &lt;- yearweek(\"2011-12-31\")\n\n## find how many weeks in period (year) of interest\nnum_weeks &lt;- as.numeric(end_date - cut_off)\n\n\n\n\nThêm hàng\nĐể có thể dự báo ở định dạng tidyverse, chúng ta cần có số hàng phù hợp trong tập dữ liệu của mình, tức là một hàng cho mỗi tuần cho tới ngày kết thúc end_date đã được xác định bên trên. Đoạn mã bên dưới cho phép bạn thêm các hàng này theo một biến nhóm - ví dụ: nếu chúng ta có nhiều quốc gia trong một tập dữ liệu, chúng ta có thể nhóm theo quốc gia và sau đó thêm các hàng một cách thích hợp cho từng quốc gia. Hàm group_by_key() trong package tsibble cho phép chúng ta thực hiện điều này và sau đó chuyển dữ liệu đã nhóm tới các hàm dplyr như group_modify() và add_row(). Sau đó, chúng ta cụ thể trình tự các tuần giữa một tuần sau tuần tối đa hiện có trong dữ liệu và tuần kết thúc.\n\n## add in missing weeks till end of year \ncounts &lt;- counts %&gt;%\n  ## group by the region\n  group_by_key() %&gt;%\n  ## for each group add rows from the highest epiweek to the end of year\n  group_modify(~add_row(.,\n                        epiweek = seq(max(.$epiweek) + 1, \n                                      end_date,\n                                      by = 1)))\n\n\n\n\nChu kỳ Fourier\nChúng ta phải định nghĩa lại chu kỳ Fourier - bởi vì chúng ta chỉ muốn fit chúng tới ngày baseline và sau đó dự báo (ngoại suy) các chu kỳ này cho năm sau. Để làm điều này, chúng ta cần kết hợp hai danh sách đầu ra từ hàm fourier() lại với nhau; cái đầu tiên dành cho dữ liệu baseline, và cái thứ hai dự đoán cho năm quan tâm (bằng cách xác định đối số h).\nLưu ý để nối dòng chúng ta phải sử dụng hàm rbind() (thay vì hàm tidyverse bind_rows) bởi vì các cột fourier ở định dạng danh sách (vì vậy không được đặt tên riêng lẻ).\n\n## define fourier terms (sincos) \ncounts &lt;- counts %&gt;% \n  mutate(\n    ## combine fourier terms for weeks prior to  and after 2010 cut-off date\n    ## (nb. 2011 fourier terms are predicted)\n    fourier = rbind(\n      ## get fourier terms for previous years\n      fourier(\n        ## only keep the rows before 2011\n        filter(counts, \n               epiweek &lt;= cut_off), \n        ## include one set of sin cos terms \n        K = 1\n        ), \n      ## predict the fourier terms for 2011 (using baseline data)\n      fourier(\n        ## only keep the rows before 2011\n        filter(counts, \n               epiweek &lt;= cut_off),\n        ## include one set of sin cos terms \n        K = 1, \n        ## predict 52 weeks ahead\n        h = num_weeks\n        )\n      )\n    )\n\n\n\n\nChia dữ liệu và fit mô hình hồi quy\nChúng ta bây giờ cần phải chia dữ liệu của mình thành 2 giai đoạn: giai đoạn baseline và giai đoạn dự báo. Nó có thể thực hiện được với hàm dplyr group_split() sau khi nhóm bởi group_by(), và sẽ tạo ra một danh sách gồm hai data frame, một trước thời điểm cut-off và một cái ở thời điểm sau cut-off.\nChúng ta sau đó sử dụng hàm pluck() từ package purrr để kéo tập dữ liệu ra khỏi danh sách (tương đương với việc sử dụng ngoặc vuông, vd: dat[[1]]), và sau đó có thể fit mô hình của chúng ta tới dữ liệu nền,và sau đó sử dụng hàm predict() cho dữ liệu mà chúng ta quan tâm sau cut-off.\nXem chương Lặp, vòng lặp, và danh sách để biết thêm về purrr.\nCẨN TRỌNG: Lưu ý cách sử dụng của đối số simulate_pi = FALSE bên trong hàm predict(). Điều này là bởi hành vi mặc định của trending là sử dụng package ciTools để ước tính khoảng tiên lượng. Nó sẽ không hoạt động nếu có giá trị NA, cũng như tạo ra nhiều khoảng chi tiết hơn. Xem ?trending::predict.trending_model_fit để biết thêm chi tiết. \n\n# split data for fitting and prediction\ndat &lt;- counts %&gt;% \n  group_by(epiweek &lt;= cut_off) %&gt;%\n  group_split()\n\n## define the model you want to fit (negative binomial) \nmodel &lt;- glm_nb_model(\n  ## set number of cases as outcome of interest\n  case_int ~\n    ## use epiweek to account for the trend\n    epiweek +\n    ## use the furier terms to account for seasonality\n    fourier\n)\n\n# define which data to use for fitting and which for predicting\nfitting_data &lt;- pluck(dat, 2)\npred_data &lt;- pluck(dat, 1) %&gt;% \n  select(case_int, epiweek, fourier)\n\n# fit model \nfitted_model &lt;- trending::fit(model, fitting_data)\n\n# get confint and estimates for fitted data\nobserved &lt;- fitted_model %&gt;% \n  predict(simulate_pi = FALSE)\n\n# forecast with data want to predict with \nforecasts &lt;- fitted_model %&gt;% \n  predict(pred_data, simulate_pi = FALSE)\n\n## combine baseline and predicted datasets\nobserved &lt;- bind_rows(observed$result, forecasts$result)\n\nNhư bên trên, chúng ta có thể trực quan hóa mô hình với ggplot. Chúng ta đánh dấu các cảnh báo bằng các chấm màu đỏ cho các trường hợp quan sát được phía trên 95% khoảng dự đoán. Lần này, chúng ta cũng thêm một đường dọc để dán nhãn khi dự báo bắt đầu.\n\n## plot your regression \nggplot(data = observed, aes(x = epiweek)) + \n  ## add in a line for the model estimate\n  geom_line(aes(y = estimate),\n            col = \"grey\") + \n  ## add in a band for the prediction intervals \n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## add in a line for your observed case counts\n  geom_line(aes(y = case_int), \n            col = \"black\") + \n  ## plot in points for the observed counts above expected\n  geom_point(\n    data = filter(observed, case_int &gt; upper_pi), \n    aes(y = case_int), \n    colour = \"red\", \n    size = 2) + \n  ## add vertical line and label to show where forecasting started\n  geom_vline(\n           xintercept = as.Date(cut_off), \n           linetype = \"dashed\") + \n  annotate(geom = \"text\", \n           label = \"Forecast\", \n           x = cut_off, \n           y = max(observed$upper_pi) - 250, \n           angle = 90, \n           vjust = 1\n           ) + \n  ## make a traditional plot (with black axes and white background)\n  theme_classic()\n\nWarning: Removed 13 rows containing missing values or values outside the scale range\n(`geom_line()`).\n\n\n\n\n\n\n\n\n\n\n\n\nĐánh giá dự báo\nNgoài việc kiểm tra các phần dư, cũng quan trọng khi đánh giá xem mô hình của bạn tốt như thế nào trong việc dự đoán các trường hợp trong tương lai. Điều này cung cấp cho bạn ý tưởng về mức độ đáng tin cậy của các ngưỡng cảnh báo của bạn.\nCách kiểm định truyền thống là xem bạn có thể dự đoán năm gần nhất trước năm hiện tại tốt như thế nào (bởi vì bạn chưa biết số lượng cho “năm hiện tại”). Ví dụ: trong tập dữ liệu của chúng ta, chúng ta sẽ sử dụng dữ liệu từ năm 2002 đến năm 2009 để dự đoán năm 2010 và sau đó xem mức độ chính xác của những dự đoán đó. Sau đó, fit lại mô hình có bao gồm dữ liệu năm 2010 và sử dụng dữ liệu đó để dự đoán cho năm 2011.\nBạn có thể xem ảnh minh họa bên dưới bởi Hyndman và cộng sự trong cuốn “Các nguyên tắc dự báo và thực hành”.\n hình sử dụng lại với sự cho phép của các tác giả\nNhược điểm của cách này là bạn không sử dụng tất cả dữ liệu có sẵn và nó không phải là mô hình cuối cùng mà bạn đang sử dụng để dự đoán.\nMột giải pháp thay thế là sử dụng một phương pháp được gọi là xác thực chéo (cross-validation). Trong trường hợp này, bạn cuộn qua tất cả dữ liệu có sẵn để fit nhiều mô hình để dự đoán một năm tới. Bạn sẽ sử dụng nhiều dữ liệu hơn trong các mô hình, như được trình bày dưới đây từ cùng cuốn sách của Hyndman và cộng sự. Ví dụ, mô hình đầu tiên sử dụng 2002 để dự đoán năm 2003, mô hình thứ hai sử dụng 2002 và 2003 để dự đoán năm 2004, v.v.\n hình sử dụng lại với sự cho phép của các tác giả\nDưới đây chúng ta sử dụng hàm map() từ package purrr để chạy vòng lặp trên từng tập dữ liệu. Sau đó, chúng ta đặt các ước tính vào một tập dữ liệu và hợp nhất với số lượng trường hợp ban đầu để sử dụng package yardstick để tính toán các đo lường về độ chính xác. Chúng ta sẽ tính toán bốn giá trị bao gồm: Root mean squared error (RMSE), Mean absolute error (MAE), Mean absolute scaled error (MASE), Mean absolute percent error (MAPE).\nCẨN TRỌNG: Lưu ý cách sử dụng của đối số simulate_pi = FALSE bên trong hàm predict(). Điều này là bởi hành vi mặc định của trending là sử dụng package ciTools để ước tính khoảng tiên lượng. Nó sẽ không hoạt động nếu có giá trị NA, cũng như tạo ra nhiều khoảng chi tiết hơn. Xem ?trending::predict.trending_model_fit để biết thêm chi tiết. \n\n## Cross validation: predicting week(s) ahead based on sliding window\n\n## expand your data by rolling over in 52 week windows (before + after) \n## to predict 52 week ahead\n## (creates longer and longer chains of observations - keeps older data)\n\n## define window want to roll over\nroll_window &lt;- 52\n\n## define weeks ahead want to predict \nweeks_ahead &lt;- 52\n\n## create a data set of repeating, increasingly long data\n## label each data set with a unique id\n## only use cases before year of interest (i.e. 2011)\ncase_roll &lt;- counts %&gt;% \n  filter(epiweek &lt; cut_off) %&gt;% \n  ## only keep the week and case counts variables\n  select(epiweek, case_int) %&gt;% \n    ## drop the last x observations \n    ## depending on how many weeks ahead forecasting \n    ## (otherwise will be an actual forecast to \"unknown\")\n    slice(1:(n() - weeks_ahead)) %&gt;%\n    as_tsibble(index = epiweek) %&gt;% \n    ## roll over each week in x after windows to create grouping ID \n    ## depending on what rolling window specify\n    stretch_tsibble(.init = roll_window, .step = 1) %&gt;% \n  ## drop the first couple - as have no \"before\" cases\n  filter(.id &gt; roll_window)\n\n\n## for each of the unique data sets run the code below\nforecasts &lt;- purrr::map(unique(case_roll$.id), \n                        function(i) {\n  \n  ## only keep the current fold being fit \n  mini_data &lt;- filter(case_roll, .id == i) %&gt;% \n    as_tibble()\n  \n  ## create an empty data set for forecasting on \n  forecast_data &lt;- tibble(\n    epiweek = seq(max(mini_data$epiweek) + 1,\n                  max(mini_data$epiweek) + weeks_ahead,\n                  by = 1),\n    case_int = rep.int(NA, weeks_ahead),\n    .id = rep.int(i, weeks_ahead)\n  )\n  \n  ## add the forecast data to the original \n  mini_data &lt;- bind_rows(mini_data, forecast_data)\n  \n  ## define the cut off based on latest non missing count data \n  cv_cut_off &lt;- mini_data %&gt;% \n    ## only keep non-missing rows\n    drop_na(case_int) %&gt;% \n    ## get the latest week\n    summarise(max(epiweek)) %&gt;% \n    ## extract so is not in a dataframe\n    pull()\n  \n  ## make mini_data back in to a tsibble\n  mini_data &lt;- tsibble(mini_data, index = epiweek)\n  \n  ## define fourier terms (sincos) \n  mini_data &lt;- mini_data %&gt;% \n    mutate(\n    ## combine fourier terms for weeks prior to  and after cut-off date\n    fourier = rbind(\n      ## get fourier terms for previous years\n      forecast::fourier(\n        ## only keep the rows before cut-off\n        filter(mini_data, \n               epiweek &lt;= cv_cut_off), \n        ## include one set of sin cos terms \n        K = 1\n        ), \n      ## predict the fourier terms for following year (using baseline data)\n      fourier(\n        ## only keep the rows before cut-off\n        filter(mini_data, \n               epiweek &lt;= cv_cut_off),\n        ## include one set of sin cos terms \n        K = 1, \n        ## predict 52 weeks ahead\n        h = weeks_ahead\n        )\n      )\n    )\n  \n  \n  # split data for fitting and prediction\n  dat &lt;- mini_data %&gt;% \n    group_by(epiweek &lt;= cv_cut_off) %&gt;%\n    group_split()\n\n  ## define the model you want to fit (negative binomial) \n  model &lt;- glm_nb_model(\n    ## set number of cases as outcome of interest\n    case_int ~\n      ## use epiweek to account for the trend\n      epiweek +\n      ## use the furier terms to account for seasonality\n      fourier\n  )\n\n  # define which data to use for fitting and which for predicting\n  fitting_data &lt;- pluck(dat, 2)\n  pred_data &lt;- pluck(dat, 1)\n  \n  # fit model \n  fitted_model &lt;- trending::fit(model, fitting_data)\n  \n  # forecast with data want to predict with \n  forecasts &lt;- fitted_model %&gt;% \n    predict(pred_data, simulate_pi = FALSE) \n  forecasts &lt;- data.frame(forecasts$result[[1]]) %&gt;%   \n    ## only keep the week and the forecast estimate\n    select(epiweek, estimate)\n    \n  }\n  )\n\n## make the list in to a data frame with all the forecasts\nforecasts &lt;- bind_rows(forecasts)\n\n## join the forecasts with the observed\nforecasts &lt;- left_join(forecasts, \n                       select(counts, epiweek, case_int),\n                       by = \"epiweek\")\n\n## using {yardstick} compute metrics\n  ## RMSE: Root mean squared error\n  ## MAE:  Mean absolute error  \n  ## MASE: Mean absolute scaled error\n  ## MAPE: Mean absolute percent error\nmodel_metrics &lt;- bind_rows(\n  ## in your forcasted dataset compare the observed to the predicted\n  rmse(forecasts, case_int, estimate), \n  mae( forecasts, case_int, estimate),\n  mase(forecasts, case_int, estimate),\n  mape(forecasts, case_int, estimate),\n  ) %&gt;% \n  ## only keep the metric type and its output\n  select(Metric  = .metric, \n         Measure = .estimate) %&gt;% \n  ## make in to wide format so can bind rows after\n  pivot_wider(names_from = Metric, values_from = Measure)\n\n## return model metrics \nmodel_metrics\n\n# A tibble: 1 × 4\n   rmse   mae  mase  mape\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1  252.  199.  1.96  17.3\n\n\n\n\n\n\npackage surveillance\nTrong phần này chúng ta sẽ sử dụng package surveillance để tạo các ngưỡng cảnh báo dựa trên thuật toán phát hiện ổ dịch. Có một số phương pháp khác có sẵn trong package, tuy nhiên chúng ta sẽ tập trung vào hai tùy chọn ở đây. Để biết chi tiết, xem các bài báo sau về sự ứng dụng và lý thuyết về các thuật toán được sử dụng.\nLựa chọn đầu tiên là sử dụng phương pháp Farrington cải tiến. Nó fit một mô hình nhị thức âm tổng quát (bao gồm xu hướng) và down-weights các đợt bùng phát trong quá khứ (giá trị ngoại lai) để tạo một mức ngưỡng.\nLựa chọn thứ hai là dùng phương pháp glrnb. Nó cũng fit một mô hình nhị thức âm tổng quát nhưng bao gồm cả xu hướng và chu kỳ fourier (vì vậy được ưu ái ở đây). Mô hình hồi quy được sử dụng để tính toán “control mean” (~fitted values) - nó sau đó sử dụng một phép thống kê tính toán likelihood ratio statistic tổng quát hóa để đánh giá nếu có sự thay đổi trung bình cho mỗi tuần. Lưu ý rằng ngưỡng cho mỗi tuần sẽ tính đến các tuần trước, vì vậy nếu có sự thay đổi liên tục, một cảnh báo sẽ được kích hoạt. (Cũng lưu ý rằng sau mỗi lần cảnh báo, thuật toán sẽ được đặt lại)\nĐể làm việc được với package surveillance, trước tiên chúng ta cần xác định đối tượng “chuỗi thời gian giám sát” (sử dụng hàm sts()) để fit vào bên trong framework.\n\n## define surveillance time series object\n## nb. you can include a denominator with the population object (see ?sts)\ncounts_sts &lt;- sts(observed = counts$case_int[!is.na(counts$case_int)],\n                  start = c(\n                    ## subset to only keep the year from start_date \n                    as.numeric(str_sub(start_date, 1, 4)), \n                    ## subset to only keep the week from start_date\n                    as.numeric(str_sub(start_date, 7, 8))), \n                  ## define the type of data (in this case weekly)\n                  freq = 52)\n\n## define the week range that you want to include (ie. prediction period)\n## nb. the sts object only counts observations without assigning a week or \n## year identifier to them - so we use our data to define the appropriate observations\nweekrange &lt;- cut_off - start_date\n\n\n\nPhương pháp Farrington\nSau đó chúng ta xác định từng tham số cho phương pháp Farrington trong một danh sách list. Sau đó, chúng ta chạy thuật toán bằng cách sử dụng hàm farringtonFlexible() và sau đó chúng ta có thể trích xuất ngưỡng cảnh báo bằng hàm farringtonmethod@upperbound để thêm vào tệp dữ liệu của chúng ta. Bạn cũng có thể trích xuất giá trị TRUE/FALSE cho từng tuần nếu nó kích hoạt một cảnh báo (cao hơn ngưỡng) bằng cách sử dụng farringtonmethod@alarm.\n\n## define control\nctrl &lt;- list(\n  ## define what time period that want threshold for (i.e. 2011)\n  range = which(counts_sts@epoch &gt; weekrange),\n  b = 9, ## how many years backwards for baseline\n  w = 2, ## rolling window size in weeks\n  weightsThreshold = 2.58, ## reweighting past outbreaks (improved noufaily method - original suggests 1)\n  ## pastWeeksNotIncluded = 3, ## use all weeks available (noufaily suggests drop 26)\n  trend = TRUE,\n  pThresholdTrend = 1, ## 0.05 normally, however 1 is advised in the improved method (i.e. always keep)\n  thresholdMethod = \"nbPlugin\",\n  populationOffset = TRUE\n  )\n\n## apply farrington flexible method\nfarringtonmethod &lt;- farringtonFlexible(counts_sts, ctrl)\n\n## create a new variable in the original dataset called threshold\n## containing the upper bound from farrington \n## nb. this is only for the weeks in 2011 (so need to subset rows)\ncounts[which(counts$epiweek &gt;= cut_off & \n               !is.na(counts$case_int)),\n              \"threshold\"] &lt;- farringtonmethod@upperbound\n\nSau đó, chúng ta có thể trực quan hóa kết quả với ggplot như đã thực hiện ở trên.\n\nggplot(counts, aes(x = epiweek)) + \n  ## add in observed case counts as a line\n  geom_line(aes(y = case_int, colour = \"Observed\")) + \n  ## add in upper bound of aberration algorithm\n  geom_line(aes(y = threshold, colour = \"Alert threshold\"), \n            linetype = \"dashed\", \n            size = 1.5) +\n  ## define colours\n  scale_colour_manual(values = c(\"Observed\" = \"black\", \n                                 \"Alert threshold\" = \"red\")) + \n  ## make a traditional plot (with black axes and white background)\n  theme_classic() + \n  ## remove title of legend \n  theme(legend.title = element_blank())\n\n\n\n\n\n\n\n\n\n\n\nPhương pháp GLRNB\nTương tự với phương pháp GLRNB, chúng ta xác định từng tham số vào một danh sách list, sau đó fit thuật toán và trích xuất các giới hạn trên.\nCẨN TRỌNG: Phương pháp này sử dụng “brute force” (tương tự như bootstrapping) để tính toán các ngưỡng, vì vậy có thể mất nhiều thời gian!\nXem GLRNB vignette để biết thêm chi tiết.\n\n## define control options\nctrl &lt;- list(\n  ## define what time period that want threshold for (i.e. 2011)\n  range = which(counts_sts@epoch &gt; weekrange),\n  mu0 = list(S = 1,    ## number of fourier terms (harmonics) to include\n  trend = TRUE,   ## whether to include trend or not\n  refit = FALSE), ## whether to refit model after each alarm\n  ## cARL = threshold for GLR statistic (arbitrary)\n     ## 3 ~ middle ground for minimising false positives\n     ## 1 fits to the 99%PI of glm.nb - with changes after peaks (threshold lowered for alert)\n   c.ARL = 2,\n   # theta = log(1.5), ## equates to a 50% increase in cases in an outbreak\n   ret = \"cases\"     ## return threshold upperbound as case counts\n  )\n\n## apply the glrnb method\nglrnbmethod &lt;- glrnb(counts_sts, control = ctrl, verbose = FALSE)\n\n## create a new variable in the original dataset called threshold\n## containing the upper bound from glrnb \n## nb. this is only for the weeks in 2011 (so need to subset rows)\ncounts[which(counts$epiweek &gt;= cut_off & \n               !is.na(counts$case_int)),\n              \"threshold_glrnb\"] &lt;- glrnbmethod@upperbound\n\nTrực quan hóa kết quả đầu ra như bên trên.\n\nggplot(counts, aes(x = epiweek)) + \n  ## add in observed case counts as a line\n  geom_line(aes(y = case_int, colour = \"Observed\")) + \n  ## add in upper bound of aberration algorithm\n  geom_line(aes(y = threshold_glrnb, colour = \"Alert threshold\"), \n            linetype = \"dashed\", \n            size = 1.5) +\n  ## define colours\n  scale_colour_manual(values = c(\"Observed\" = \"black\", \n                                 \"Alert threshold\" = \"red\")) + \n  ## make a traditional plot (with black axes and white background)\n  theme_classic() + \n  ## remove title of legend \n  theme(legend.title = element_blank())",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Chuỗi thời gian và phát hiện ổ dịch</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.vn.html#chuỗi-thời-gian-bị-gián-đoạn",
    "href": "new_pages/time_series.vn.html#chuỗi-thời-gian-bị-gián-đoạn",
    "title": "23  Chuỗi thời gian và phát hiện ổ dịch",
    "section": "23.8 Chuỗi thời gian bị gián đoạn",
    "text": "23.8 Chuỗi thời gian bị gián đoạn\nChuỗi thời gian bị gián đoạn (còn được gọi là hồi quy phân đoạn hoặc phân tích can thiệp), thường được sử dụng để đánh giá tác động của vắc-xin đối với tỷ lệ mắc mới của bệnh. Nhưng nó có thể được sử dụng để đánh giá tác động của một loạt các can thiệp hoặc sự giới thiệu. Ví dụ như những thay đổi trong quy trình của bệnh viện hoặc sự xuất hiện của chủng bệnh mới vào quần thể. Trong ví dụ này, chúng ta sẽ giả định rằng một chủng mới của Campylobacter đã xuất hiện ở Đức vào cuối năm 2008, và xem liệu điều đó có ảnh hưởng đến số lượng trường hợp. Chúng ta sẽ sử dụng hồi quy nhị thức âm một lần nữa. Sự hồi quy lần này sẽ được chia thành hai phần, một phần trước khi can thiệp (hoặc sự xuất hiện của chủng mới) và một phần sau (trước và sau giai đoạn). Điều này cho phép chúng ta tính toán tỷ số tỷ lệ mới mắc giữa hai khoảng thời gian. Giải thích phương trình có thể làm cho điều này rõ ràng hơn (nếu không thì chỉ cần bỏ qua!).\nHồi quy nhị thức âm có thể được định nghĩa như sau:\n\\[\\log(Y_t)= β_0 + β_1 \\times t+ β_2 \\times δ(t-t_0) + β_3\\times(t-t_0 )^+ + log(pop_t) + e_t\\]\nTrong đó:\n\\(Y_t\\) là số trường hợp quan sát được tại thời điểm \\(t\\)\n\\(pop_t\\) nếu kích thước quần thể trong 100,000s tại thời điểm \\(t\\) (không sử dụng tại đây)\n\\(t_0\\) là năm cuối cùng của giai đoạn trước (bao gồm cả thời gian chuyển tiếp nếu có)\n\\(δ(x\\) là hàm chỉ báo (nó là 0 nếu x ≤ 0 và 1 nếu x &gt; 0)\n\\((x)^+\\) là toán tử cut off (nó là x nếu x &gt; 0 và ngược lại sẽ bằng 0)\n\\(e_t\\) biểu thị phần dư\nCác chu kỳ bổ sung có xu hướng hoặc theo mùa có thể được thêm vào nếu cần thiết.\n\\(β_2 \\times δ(t-t_0) + β_3\\times(t-t_0 )^+\\) là một phần của mô hình tuyến tỉnh tổng quát hóa của giai đoạn sau và bằng không ở giai đoạn trước. Điều này có nghĩa là \\(β_2\\) và \\(β_3\\) ước tính các hiệu quả của can thiệp.\nChúng ta cần tính toán lại chu kỳ Fourier mà không có dự báo ở đây, vì chúng ta sẽ sử dụng tất cả dữ liệu có sẵn (vd: hồi cứu). Ngoài ra, chúng ta cần tính toán các điều khoản bổ sung cần thiết cho hồi quy. thực tế là chúng ta cần tính chu kỳ mở rộng (extra terms) cho đường hồi quy.\n\n## add in fourier terms using the epiweek and case_int variabless\ncounts$fourier &lt;- select(counts, epiweek, case_int) %&gt;% \n  as_tsibble(index = epiweek) %&gt;% \n  fourier(K = 1)\n\n## define intervention week \nintervention_week &lt;- yearweek(\"2008-12-31\")\n\n## define variables for regression \ncounts &lt;- counts %&gt;% \n  mutate(\n    ## corresponds to t in the formula\n      ## count of weeks (could probably also just use straight epiweeks var)\n    # linear = row_number(epiweek), \n    ## corresponds to delta(t-t0) in the formula\n      ## pre or post intervention period\n    intervention = as.numeric(epiweek &gt;= intervention_week), \n    ## corresponds to (t-t0)^+ in the formula\n      ## count of weeks post intervention\n      ## (choose the larger number between 0 and whatever comes from calculation)\n    time_post = pmax(0, epiweek - intervention_week + 1))\n\nChúng ta sau đó sử dụng các chi kỳ này để fit một mô hình hồi quy nhị thức âm, và tạo một bảng với phần trăm thay đổi. Những gì ví dụ này cho thấy là không có thay đổi đáng kể.\nCẨN TRỌNG: Lưu ý cách sử dụng của đối số simulate_pi = FALSE bên trong hàm predict(). Điều này là bởi hành vi mặc định của trending là sử dụng package ciTools để ước tính khoảng tiên lượng. Nó sẽ không hoạt động nếu có giá trị NA, cũng như tạo ra nhiều khoảng chi tiết hơn. Xem ?trending::predict.trending_model_fit để biết thêm chi tiết. \n\n## define the model you want to fit (negative binomial) \nmodel &lt;- glm_nb_model(\n  ## set number of cases as outcome of interest\n  case_int ~\n    ## use epiweek to account for the trend\n    epiweek +\n    ## use the furier terms to account for seasonality\n    fourier + \n    ## add in whether in the pre- or post-period \n    intervention + \n    ## add in the time post intervention \n    time_post\n    )\n\n## fit your model using the counts dataset\nfitted_model &lt;- trending::fit(model, counts)\n\n## calculate confidence intervals and prediction intervals \nobserved &lt;- predict(fitted_model, simulate_pi = FALSE)\n\n\n## show estimates and percentage change in a table\nfitted_model %&gt;% \n  ## extract original negative binomial regression\n  get_model() %&gt;% \n  ## get a tidy dataframe of results\n  tidy(exponentiate = TRUE, \n       conf.int = TRUE) %&gt;% \n  ## only keep the intervention value \n  filter(term == \"intervention\") %&gt;% \n  ## change the IRR to percentage change for estimate and CIs \n  mutate(\n    ## for each of the columns of interest - create a new column\n    across(\n      all_of(c(\"estimate\", \"conf.low\", \"conf.high\")), \n      ## apply the formula to calculate percentage change\n            .f = function(i) 100 * (i - 1), \n      ## add a suffix to new column names with \"_perc\"\n      .names = \"{.col}_perc\")\n    ) %&gt;% \n  ## only keep (and rename) certain columns \n  select(\"IRR\" = estimate, \n         \"95%CI low\" = conf.low, \n         \"95%CI high\" = conf.high,\n         \"Percentage change\" = estimate_perc, \n         \"95%CI low (perc)\" = conf.low_perc, \n         \"95%CI high (perc)\" = conf.high_perc,\n         \"p-value\" = p.value)\n\nNhư bên trên, chúng ta có thể trực quan hóa các đầu ra của mô hình hồi quy.\n\nestimate_res &lt;- data.frame(observed$result)\n\nggplot(estimate_res, aes(x = epiweek)) + \n  ## add in observed case counts as a line\n  geom_line(aes(y = case_int, colour = \"Observed\")) + \n  ## add in a line for the model estimate\n  geom_line(aes(y = estimate, col = \"Estimate\")) + \n  ## add in a band for the prediction intervals \n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## add vertical line and label to show where forecasting started\n  geom_vline(\n           xintercept = as.Date(intervention_week), \n           linetype = \"dashed\") + \n  annotate(geom = \"text\", \n           label = \"Intervention\", \n           x = intervention_week, \n           y = max(observed$upper_pi), \n           angle = 90, \n           vjust = 1\n           ) + \n  ## define colours\n  scale_colour_manual(values = c(\"Observed\" = \"black\", \n                                 \"Estimate\" = \"red\")) + \n  ## make a traditional plot (with black axes and white background)\n  theme_classic()\n\nWarning: Unknown or uninitialised column: `upper_pi`.\n\n\nWarning in max(observed$upper_pi): no non-missing arguments to max; returning\n-Inf",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Chuỗi thời gian và phát hiện ổ dịch</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.vn.html#nguồn-tham-khảo",
    "href": "new_pages/time_series.vn.html#nguồn-tham-khảo",
    "title": "23  Chuỗi thời gian và phát hiện ổ dịch",
    "section": "23.9 Nguồn tham khảo",
    "text": "23.9 Nguồn tham khảo\nforecasting: principles and practice textbook\nEPIET timeseries analysis case studies\nPenn State course Surveillance package manuscript",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Chuỗi thời gian và phát hiện ổ dịch</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.vn.html",
    "href": "new_pages/epidemic_models.vn.html",
    "title": "24  Mô hình hóa dịch bệnh",
    "section": "",
    "text": "24.1 Tổng quan\nNgày càng có nhiều công cụ để tạo một mô hình dịch bệnh cho phép chúng ta tiến hành các phân tích khá phức tạp và tiết kiệm nguồn lực. Chương này sẽ cung cấp một cái nhìn tổng quan về cách sử dụng các công cụ để:\nChương này không tổng quan về các phương pháp luận và phương pháp thống kê cơ bản của các công cụ này, vì vậy vui lòng tham khảo mục Tài liệu tham khảo để đọc các bài báo có đề cập tới. Hãy chắc chắn rằng bạn có kiến thức cơ bản về các phương pháp trước khi sử dụng các công cụ này; điều này sẽ đảm bảo bạn có thể giải thích chính xác các kết quả của chúng.\nDưới đây là một ví dụ về những kết quả đầu ra mà chúng ta sẽ thực hiện trong chương này.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Mô hình hóa dịch bệnh</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.vn.html#tổng-quan",
    "href": "new_pages/epidemic_models.vn.html#tổng-quan",
    "title": "24  Mô hình hóa dịch bệnh",
    "section": "",
    "text": "ước tính hệ số lây nhiễm hiệu quả Rt và các thống kê liên quan chẳng hạn như thời gian tăng gấp đôi\nđưa ra các dự báo ngắn hạn về số mắc mới trong tương lai",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Mô hình hóa dịch bệnh</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.vn.html#chuẩn-bị",
    "href": "new_pages/epidemic_models.vn.html#chuẩn-bị",
    "title": "24  Mô hình hóa dịch bệnh",
    "section": "24.2 Chuẩn bị",
    "text": "24.2 Chuẩn bị\nChúng ta sẽ sử dụng hai phương pháp và package khác nhau để ước tính Rt, cụ thể là package EpiNow và package EpiEstim, cũng như package projections cho dự báo các trường hợp mới mắc.\nĐoạn code này hiển thị tải các package cần thiết cho các phân tích. Trong sổ tay này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, để cài đặt package nếu cần thiết và gọi package để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm library() từ base R. Xem thêm chương R cơ bản để biết thêm thông tin về package R.\n\npacman::p_load(\n   rio,          # File import\n   here,         # File locator\n   tidyverse,    # Data management + ggplot2 graphics\n   epicontacts,  # Analysing transmission networks\n   EpiNow2,      # Rt estimation\n   EpiEstim,     # Rt estimation\n   projections,  # Incidence projections\n   incidence2,   # Handling incidence data\n   epitrix,      # Useful epi functions\n   distcrete     # Discrete delay distributions\n)\n\nChúng ta sẽ sử dụng bộ dữ liệu các trường hợp linelist đã được làm sạch cho tất cả các phân tích trong chương này. Để tiện theo dõi,  bấm để tải xuống bộ dữ liệu linelist đã được “làm sạch”  (dưới dạng tệp .rds). Xem chương Tải sách và dữ liệu để tải xuống tất cả các dữ liệu minh họa được sử dụng trong sổ tay này.\n\n# import the cleaned linelist\nlinelist &lt;- import(\"linelist_cleaned.rds\")",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Mô hình hóa dịch bệnh</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.vn.html#ước-tính-rt",
    "href": "new_pages/epidemic_models.vn.html#ước-tính-rt",
    "title": "24  Mô hình hóa dịch bệnh",
    "section": "24.3 Ước tính Rt",
    "text": "24.3 Ước tính Rt\n\nEpiNow2 và EpiEstim\nHệ số lây nhiễm R là thước đo khả năng lây truyền của một bệnh và được định nghĩa là số ca thứ phát kỳ vọng trên mỗi trường hợp nhiễm bệnh. Trong một quần thể cảm nhiễm toàn bộ, giá trị này đại diện cho hệ số lây nhiễm cơ bản R0. Tuy nhiên, vì số lượng các cá thể cảm nhiễm trong một quần thể thay đổi trong suốt vụ dịch hoặc đại dịch và khi các biện pháp ứng phó khác nhau được thực hiện, chỉ số đo lường khả năng lây truyền thường được sử dụng phổ biến nhất là hệ số lây nhiễm hiệu quả Rt; nó được định nghĩa là số trường hợp thứ cấp kỳ vọng trên mỗi trường hợp bị nhiễm tại một thời điểm t nhất định.\nPackage EpiNow2 cung cấp một framework phức tạp nhất cho việc ước tính Rt. Package này có hai điểm mạnh chính so với package thường dùng khác là EpiEstim như sau:\n\nNó giải thích cho thời gian trì hoãn (delay) trong báo cáo và do đó có thể ước tính Rt ngay cả khi dữ liệu không đầy đủ.\nNó ước tính Rt dựa vào ngày nhiễm bệnh hơn là ngày khởi phát được báo cáo, có nghĩa là ảnh hưởng của một can thiệp sẽ được thể hiện ngay lập tức bởi sự thay đổi của Rt, thay vì có một sự trì hoãn.\n\nTuy nhiên, nó cũng có hai nhược điểm chính:\n\nNó yêu cầu kiến thức về phân phối thời gian phát sinh một thế hệ (generation time: tức là phân phối khoảng thời gian giữa ca nhiễm trùng sơ cấp và các ca thứ cấp), phân bố thời gian ủ bệnh (incubation period: tức là phân bố khoảng thời gian giữa nhiễm trùng và khởi phát triệu chứng) và bất kỳ phân phối khoảng thời gian nào khác có liên quan đến dữ liệu của bạn (ví dụ: nếu bạn có ngày báo cáo, bạn cần thông tin phân phối độ trễ từ khi bắt đầu có triệu chứng đến khi được báo cáo). Trong khi điều này sẽ cho phép ước tính Rt chính xác hơn thì package EpiEstim chỉ yêu cầu phân bố của khoảng thời gian liên tiếp (serial interval: khoảng thời gian từ lúc bệnh nhân ban đầu khởi phát triệu chứng đến lúc bệnh nhân thứ phát có triệu chứng khởi phát), mà đó có thể là phân phối duy nhất có sẵn cho bạn.\n\nPackage EpiNow2 chậm hơn đáng kể so với package EpiEstim theo một hệ số khoảng 100-1000 (tin đồn)! Ví dụ: ước tính Rt đối với đợt bùng phát được lấy ví dụ trong phần này mất khoảng bốn giờ (được chạy lặp lại một số lượng lớn lần để đảm bảo độ chính xác và tất nhiên có thể giảm nếu cần thiết, tuy nhiên nói chung là thuật toán chậm). Điều này có thể không khả thi nếu bạn thường xuyên phải cập nhật ước tính Rt.\n\nDo đó, package bạn chọn sử dụng sẽ phụ thuộc vào dữ liệu, thời gian và tài nguyên tính toán có sẵn cho bạn.\n###Package EpiNow2 {.unnumbered}\n\nƯớc tính phân phối thời gian trì hoãn\nPhân phối độ trễ yêu cầu chạy package EpiNow2 tùy thuộc vào dữ liệu bạn có. Về cơ bản, bạn cần có khả năng mô tả độ trễ từ ngày nhiễm bệnh đến ngày diễn ra sự kiện bạn muốn sử dụng để ước tính Rt. Nếu bạn đang sử dụng ngày bắt đầu, thì nó sẽ chỉ đơn giản là phân bố thời kỳ ủ bệnh. Nếu bạn đang sử dụng ngày báo cáo, bạn yêu cầu thời gian trì hoãn từ khi lây nhiễm đến khi báo cáo. Bởi vì phân phối này khó có thể được biết trực tiếp, package EpiNow2 cho phép bạn xâu chuỗi nhiều phân phối trì hoãn với nhau; trong trường hợp này, đó là thời gian trì hoãn từ khi nhiễm trùng đến khi khởi phát triệu chứng (ví dụ: thời kỳ ủ bệnh, thường có khả năng biết) và từ khi bắt đầu có triệu chứng đến khi báo cáo ca bệnh (mà bạn có thể thường xuyên ước tính từ dữ liệu).\nVì chúng ta có ngày bắt đầu cho tất cả các trường hợp trong ví dụ của bộ dữ liệu linelist, chúng ta sẽ chỉ cần phân phối thời gian ủ bệnh để liên kết dữ liệu của chúng ta (ví dụ: ngày bắt đầu có triệu chứng) đến ngày nhiễm bệnh. Chúng ta có thể ước tính phân phối này từ dữ liệu hoặc sử dụng các giá trị từ y văn.\nTài liệu về ước tính thời gian ủ bệnh của Ebola (trích dẫn từ bài báo này) với giá trị trung bình là 9.1, độ lệch chuẩn là 7.3 và giá trị lớn nhất là 30 sẽ được chỉ định như sau:\n\nincubation_period_lit &lt;- list(\n  mean = log(9.1),\n  mean_sd = log(0.1),\n  sd = log(7.3),\n  sd_sd = log(0.1),\n  max = 30\n)\n\nLưu ý rằng package EpiNow2 yêu cầu các phân phối thời gian trì hoãn này phải được cung cấp trên thang đo log bằng cách dùng lệnh gọi log xung quanh mỗi giá trị (ngoại trừ tham số max, hơi rắc rối, cung cấp theo thang đo tự nhiên). mean_sd và sd_sd xác định độ lệch chuẩn của ước tính giá trị trung bình và độ lệch chuẩn. Vì chúng không được biết trong trường hợp này, chúng tôi chọn giá trị khá tùy ý là 0.1.\nTrong phân tích này, thay vào đó, chúng ta ước tính phân phối thời gian ủ bệnh từ chính bộ dữ liệu linelist bằng cách sử dụng hàm bootstrapped_dist_fit, để fit một phân phối lognormal cho thời gian trì hoãn giữa nhiễm trùng và khởi phát quan sát được trong linelist.\n\n## estimate incubation period\nincubation_period &lt;- bootstrapped_dist_fit(\n  linelist$date_onset - linelist$date_infection,\n  dist = \"lognormal\",\n  max_value = 100,\n  bootstraps = 1\n)\n\nPhân phối khác mà chúng ta cần là thời gian phát sinh một thế hệ. Vì chúng ta có dữ liệu về thời gian nhiễm bệnh và đường lây truyền, chúng ta có thể ước tính phân phối này từ linelist bằng cách tính toán đỗ trễ giữa các lần lây nhiễm của các cặp người lây nhiễm-người bị lây nhiễm. Để làm điều này, chúng ta sử dụng hàm get_pairwise từ package epicontacts, cho phép chúng ta tính toán sự khác biệt từng cặp trường hợp lây nhiễm của linelist. Đầu tiên, chúng ta tạo một đối tượng epicontacts (xem chương Chuỗi lây nhiễm để biết thêm chi tiết):\n\n## generate contacts\ncontacts &lt;- linelist %&gt;%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %&gt;%\n  drop_na()\n\n## generate epicontacts object\nepic &lt;- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n\nSau đó, chúng ta fit một phân phối gamma cho sự khác biệt về thời gian nhiễm bệnh giữa các cặp lây nhiễm (được tính toán bằng cách sử dụng hàm get_pairwise)\n\n## estimate gamma generation time\ngeneration_time &lt;- bootstrapped_dist_fit(\n  get_pairwise(epic, \"date_infection\"),\n  dist = \"gamma\",\n  max_value = 20,\n  bootstraps = 1\n)\n\n\n\nChạy EpiNow2\nBây giờ chúng ta chỉ cần tính toán số mới mắc hàng ngày từ linelist mà có thể thực hiện dễ dàng với các hàm group_by() và n() từ package dplyr. Lưu ý rằng EpiNow2 yêu cầu tên cột phải là date và confirm.\n\n## get incidence from onset dates\ncases &lt;- linelist %&gt;%\n  group_by(date = date_onset) %&gt;%\n  summarise(confirm = n())\n\nSau đó, chúng ta có thể ước tính Rt bằng cách sử dụng hàm epinow. Một vài lưu ý về các dữ liệu đầu vào:\n\nChúng ta có thể cung cấp một số lượng bất kỳ các ‘chuỗi’ phân phối thời gian trì hoãn tới đối số delays; chúng ta chỉ cần chèn chúng cùng với đối tượng incubation_period bên trong hàm delay_opts.\nreturn_output đảm bảo đầu ra được trả về trong R chứ không chỉ được lưu vào một tệp.\nverbose nếu chúng ta muốn đọc tiến trình.\nhorizon để yêu cầu hiển thị số ngày chúng ta muốn tính số mới mắc trong tương lai\nChúng ta chuyển các tùy chọn bổ sung cho đối số stan để chỉ định cách chúng ta muốn chạy suy luận. Tăng số lượng mẫu samples và chuỗi chain sẽ cung cấp cho bạn một ước tính chính xác hơn với những phẩm chất tốt hơn cho sự không chắc chắn, tuy nhiên sẽ mất nhiều thời gian hơn để chạy.\n\n\n## run epinow\nepinow_res &lt;- epinow(\n  reported_cases = cases,\n  generation_time = generation_time,\n  delays = delay_opts(incubation_period),\n  return_output = TRUE,\n  verbose = TRUE,\n  horizon = 21,\n  stan = stan_opts(samples = 750, chains = 4)\n)\n\n\n\nPhân tích kết quả đầu ra\nKhi code đã chạy xong, chúng ta có thể vẽ biểu đồ tóm tắt rất dễ dàng như sau. Cuộn hình ảnh để xem toàn bộ.\n\n## plot summary figure\nplot(epinow_res)\n\n\n\n\n\n\n\n\nChúng ta cũng có thể xem xét các thống kê tóm tắt khác nhau:\n\n## summary table\nepinow_res$summary\n\n                                 measure                  estimate\n                                  &lt;char&gt;                    &lt;char&gt;\n1: New confirmed cases by infection date                4 (2 -- 6)\n2:        Expected change in daily cases                    Unsure\n3:            Effective reproduction no.        0.88 (0.73 -- 1.1)\n4:                        Rate of growth -0.012 (-0.028 -- 0.0052)\n5:          Doubling/halving time (days)          -60 (130 -- -25)\n    numeric_estimate\n              &lt;list&gt;\n1: &lt;data.table[1x9]&gt;\n2:              0.56\n3: &lt;data.table[1x9]&gt;\n4: &lt;data.table[1x9]&gt;\n5: &lt;data.table[1x9]&gt;\n\n\nĐể có các phân tích sâu hơn và vẽ biểu đồ tùy chỉnh, bạn có thể truy cập vào phần ước tính hàng ngày tổng hợp thông qua $estimates$summarised. Chúng ta sẽ chuyển nó từ định dạng mặc định data.table thành định dạng tibble để dễ dàng sử dụng với package dplyr.\n\n## extract summary and convert to tibble\nestimates &lt;- as_tibble(epinow_res$estimates$summarised)\nestimates\n\n\n\n\n\n\n\nĐể ví dụ, chúng ta hãy vẽ một biểu đồ về thời gian nhân đôi và Rt. Chúng ta sẽ chỉ xem xét vài tháng đầu tiên của đợt bùng phát khi Rt chỉ cao hơn một, để tránh vẽ biểu đồ số lần nhân đôi quá cao.\nChúng ta sử dụng công thức log(2)/growth_rate để tính thời gian nhân đôi từ tốc độ tăng trưởng ước tính.\n\n## make wide df for median plotting\ndf_wide &lt;- estimates %&gt;%\n  filter(\n    variable %in% c(\"growth_rate\", \"R\"),\n    date &lt; as.Date(\"2014-09-01\")\n  ) %&gt;%\n  ## convert growth rates to doubling times\n  mutate(\n    across(\n      c(median, lower_90:upper_90),\n      ~ case_when(\n        variable == \"growth_rate\" ~ log(2)/.x,\n        TRUE ~ .x\n      )\n    ),\n    ## rename variable to reflect transformation\n    variable = replace(variable, variable == \"growth_rate\", \"doubling_time\")\n  )\n\n## make long df for quantile plotting\ndf_long &lt;- df_wide %&gt;%\n  ## here we match matching quantiles (e.g. lower_90 to upper_90)\n  pivot_longer(\n    lower_90:upper_90,\n    names_to = c(\".value\", \"quantile\"),\n    names_pattern = \"(.+)_(.+)\"\n  )\n\n## make plot\nggplot() +\n  geom_ribbon(\n    data = df_long,\n    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = date, y = median)\n  ) +\n  ## use label_parsed to allow subscript label\n  facet_wrap(\n    ~ variable,\n    ncol = 1,\n    scales = \"free_y\",\n    labeller = as_labeller(c(R = \"R[t]\", doubling_time = \"Doubling~time\"), label_parsed),\n    strip.position = 'left'\n  ) +\n  ## manually define quantile transparency\n  scale_alpha_manual(\n    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = NULL,\n    alpha = \"Credibel\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    strip.background = element_blank(),\n    strip.placement = 'outside'\n  )\n\n\n\n\n\n\n\n\n\n\n\n\nEpiEstim\nĐể chạy EpiEstim, chúng ta cần cung cấp dữ liệu về số trường hợp mới mắc hàng ngày và cụ thể khoảng thời gian nối tiếp (tức là phân bố thời gian trì hoãn khởi phát triệu chứng giữa các trường hợp sơ cấp và thứ cấp).\nDữ liệu về con số mới mắc có thể được cung cấp cho EpiEstim dưới dạng một vectơ, một bảng số liệu, hoặc một đối tượng incidence nguyên bản từ package incidence. Bạn thậm chí có thể phân biệt giữa ca nhiễm bệnh từ nơi khác đến và tại địa phương; xem tài liệu hướng dẫn bằng cách gõ ?estimate_R để biết thêm chi tiết.\nChúng ta sẽ tạo dữ liệu đầu vào bằng cách sử dụng package incidence2. Xem chương Đường cong dịch bệnh để xem thêm các ví dụ về package incidence2. Do có một số cập nhật của package incidence2 khiến nó không hoàn toàn phù hợp với đầu vào kỳ vọng của hàm estimateR(), bạn cần thực hiện một số bước bổ sung cần thiết. Đối tượng incidence bao gồm một tibble với thông tin về ngày tháng và số lượng trường hợp tương ứng. Chúng ta sử dụng hàm complete() từ package tidyr để đảm bảo tất cả các ngày đều được bao gồm (kể cả những ngày không có trường hợp), và sau đó dùng hàm rename() để đổi tên các cột để căn chỉnh sao cho phù hợp với hàm estimate_R() ở bước sau.\n\n## get incidence from onset date\ncases &lt;- incidence2::incidence(linelist, date_index = \"date_onset\") %&gt;% # get case counts by day\n  tidyr::complete(date_index = seq.Date(                              # ensure all dates are represented\n    from = min(date_index, na.rm = T),\n    to = max(date_index, na.rm=T),\n    by = \"day\"),\n    fill = list(count = 0)) %&gt;%                                       # convert NA counts to 0\n  rename(I = count,                                                   # rename to names expected by estimateR\n         dates = date_index)\n\nPackage này cung cấp một số tùy chọn để cụ thể khoảng thời gian nối tiếp, chi tiết được cung cấp trong tài liệu hướng dẫn bằng cách gõ ?estimate_R. Chúng tôi sẽ đề cập đến hai trong số chúng ở đây.\n\nSử dụng ước tính khoảng thời gian nối tiếp từ y văn\nSử dụng tùy chọn method = \"parametric_si\", chúng ta có thể chỉ định thủ công trung bình và độ lệch chuẩn của khoảng thời gian nối tiếp của đối tượng config được tạo bằng hàm make_config. Chúng ta sử dụng giá trị trung bình và độ lệch chuẩn tương ứng là 12.0 và 5.2, được xác định trong bài báo này:\n\n## make config\nconfig_lit &lt;- make_config(\n  mean_si = 12.0,\n  std_si = 5.2\n)\n\nSau đó, chúng ta có thể ước tính Rt bằng hàm estimate_R:\n\ncases &lt;- cases %&gt;% \n     filter(!is.na(date))\n#create a dataframe for the function estimate_R()\ncases_incidence &lt;- data.frame(dates = seq.Date(from = min(cases$dates),\n                               to = max(cases$dates), \n                               by = 1))\ncases_incidence &lt;- left_join(cases_incidence, cases) %&gt;% \n     select(dates, I) %&gt;% \n     mutate(I = ifelse(is.na(I), 0, I))\n\nJoining with `by = join_by(dates)`\n\nepiestim_res_lit &lt;- estimate_R(\n  incid = cases_incidence,\n  method = \"parametric_si\",\n  config = config_lit\n)\n\nDefault config will estimate R on weekly sliding windows.\n    To change this change the t_start and t_end arguments. \n\n\nvà vẽ tóm tắt các kết quả đầu ra:\n\nplot(epiestim_res_lit)\n\n\n\n\n\n\n\n\n\n\nSử dụng ước tính khoảng thời gian nối tiếp từ dữ liệu\nVì chúng ta có dữ liệu về ngày khởi phát triệu chứng và các liên kết lây truyền, chúng ta cũng có thể ước tính khoảng thời gian nối tiếp từ bộ số liệu linelist bằng cách tính toán độ trễ giữa ngày khởi phát của các cặp người truyền bệnh-người nhiễm bệnh. Như chúng ta đã làm trong mục EpiNow2, chúng ta sẽ sử dụng hàm get_pairwise từ package epicontacts, cho phép chúng ta tính toán theo từng cặp sự khác biệt giữa các cặp lây truyền trong bộ số liệu linelist. Chúng ta trước hết tạo một đối tượng epicontacts (xem chương Chuỗi lây nhiễm để biết thêm chi tiết):\n\n## generate contacts\ncontacts &lt;- linelist %&gt;%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %&gt;%\n  drop_na()\n\n## generate epicontacts object\nepic &lt;- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n\nSau đó, chúng ta fit một phân phối gamma cho sự khác biệt về ngày khởi phát giữa các cặp lây truyền (được tính toán bằng hàm get_pairwise). Chúng ta sử dụng hàm fit_disc_gamma từ package epitrix cho quy trình kết hợp này, vì chúng ta yêu cầu một phân phối rời rạc (discretised).\n\n## estimate gamma serial interval\nserial_interval &lt;- fit_disc_gamma(get_pairwise(epic, \"date_onset\"))\n\nSau đó, chúng ta chuyển thông tin này đến đối tượng config, và chạy EpiEstim một lần nữa và vẽ biểu đồ kết quả:\n\n## make config\nconfig_emp &lt;- make_config(\n  mean_si = serial_interval$mu,\n  std_si = serial_interval$sd\n)\n\n## run epiestim\nepiestim_res_emp &lt;- estimate_R(\n  incid = cases_incidence,\n  method = \"parametric_si\",\n  config = config_emp\n)\n\nDefault config will estimate R on weekly sliding windows.\n    To change this change the t_start and t_end arguments. \n\n## plot outputs\nplot(epiestim_res_emp)\n\n\n\n\n\n\n\n\n\n\nCụ thể thời gian bắt đầu ước tính\nCác tùy chọn mặc định này sẽ cung cấp một ước tính theo tuần và có thể hoạt động như một cảnh báo rằng bạn đang ước tính Rt quá sớm trong đợt bùng phát để có một ước tính chính xác. Bạn có thể thay đổi điều này bằng cách đặt ngày bắt đầu ước tính muộn hơn như dưới đây. Thật không may, EpiEstim chỉ cung cấp một cách rất khó hiểu để cụ thể thời gian ước tính này, trong đó bạn phải cung cấp một vectơ số nguyên đề cập đến ngày bắt đầu và ngày kết thúc cho mỗi cửa sổ thời gian.\n\n## define a vector of dates starting on June 1st\nstart_dates &lt;- seq.Date(\n  as.Date(\"2014-06-01\"),\n  max(cases$dates) - 7,\n  by = 1\n) %&gt;%\n  ## subtract the starting date to convert to numeric\n  `-`(min(cases$dates)) %&gt;%\n  ## convert to integer\n  as.integer()\n\n## add six days for a one week sliding window\nend_dates &lt;- start_dates + 6\n  \n## make config\nconfig_partial &lt;- make_config(\n  mean_si = 12.0,\n  std_si = 5.2,\n  t_start = start_dates,\n  t_end = end_dates\n)\n\nBây giờ chúng ta chạy lại EpiEstim và có thể thấy rằng các ước tính chỉ bắt đầu từ tháng 6:\n\n## run epiestim\nepiestim_res_partial &lt;- estimate_R(\n  incid = cases_incidence,\n  method = \"parametric_si\",\n  config = config_partial\n)\n\n## plot outputs\nplot(epiestim_res_partial)\n\n\n\n\n\n\n\n\n\n\nPhân tích kết quả đầu ra\nCác đầu ra chính có thể được truy cập thông qua $R. Ví dụ: chúng ta sẽ tạo một biểu đồ của Rt và một thước đo “khả năng truyền bệnh” được đưa ra bởi sản phẩm của Rt và số trường hợp được báo cáo vào ngày đó; điều này thể hiện số trường hợp dự kiến trong thế hệ lây nhiễm tiếp theo.\n\n## make wide dataframe for median\ndf_wide &lt;- epiestim_res_lit$R %&gt;%\n  rename_all(clean_labels) %&gt;%\n  rename(\n    lower_95_r = quantile_0_025_r,\n    lower_90_r = quantile_0_05_r,\n    lower_50_r = quantile_0_25_r,\n    upper_50_r = quantile_0_75_r,\n    upper_90_r = quantile_0_95_r,\n    upper_95_r = quantile_0_975_r,\n    ) %&gt;%\n  mutate(\n    ## extract the median date from t_start and t_end\n    dates = epiestim_res_emp$dates[round(map2_dbl(t_start, t_end, median))],\n    var = \"R[t]\"\n  ) %&gt;%\n  ## merge in daily incidence data\n  left_join(cases, \"dates\") %&gt;%\n  ## calculate risk across all r estimates\n  mutate(\n    across(\n      lower_95_r:upper_95_r,\n      ~ .x*I,\n      .names = \"{str_replace(.col, '_r', '_risk')}\"\n    )\n  ) %&gt;%\n  ## seperate r estimates and risk estimates\n  pivot_longer(\n    contains(\"median\"),\n    names_to = c(\".value\", \"variable\"),\n    names_pattern = \"(.+)_(.+)\"\n  ) %&gt;%\n  ## assign factor levels\n  mutate(variable = factor(variable, c(\"risk\", \"r\")))\n\n## make long dataframe from quantiles\ndf_long &lt;- df_wide %&gt;%\n  select(-variable, -median) %&gt;%\n  ## seperate r/risk estimates and quantile levels\n  pivot_longer(\n    contains(c(\"lower\", \"upper\")),\n    names_to = c(\".value\", \"quantile\", \"variable\"),\n    names_pattern = \"(.+)_(.+)_(.+)\"\n  ) %&gt;%\n  mutate(variable = factor(variable, c(\"risk\", \"r\")))\n\n## make plot\nggplot() +\n  geom_ribbon(\n    data = df_long,\n    aes(x = dates, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = dates, y = median),\n    alpha = 0.2\n  ) +\n  ## use label_parsed to allow subscript label\n  facet_wrap(\n    ~ variable,\n    ncol = 1,\n    scales = \"free_y\",\n    labeller = as_labeller(c(r = \"R[t]\", risk = \"Transmission~potential\"), label_parsed),\n    strip.position = 'left'\n  ) +\n  ## manually define quantile transparency\n  scale_alpha_manual(\n    values = c(`50` = 0.7, `90` = 0.4, `95` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = NULL,\n    alpha = \"Credible\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    strip.background = element_blank(),\n    strip.placement = 'outside'\n  )",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Mô hình hóa dịch bệnh</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.vn.html#dự-đoán-số-trường-hợp-mắc-mới",
    "href": "new_pages/epidemic_models.vn.html#dự-đoán-số-trường-hợp-mắc-mới",
    "title": "24  Mô hình hóa dịch bệnh",
    "section": "24.4 Dự đoán số trường hợp mắc mới",
    "text": "24.4 Dự đoán số trường hợp mắc mới\n\nEpiNow2\nBên cạnh ước tính Rt, package EpiNow2 cũng hỗ trợ dự báo Rt và dự báo các số trường hợp bằng cách tích hợp với package EpiSoon. Tất cả những gì bạn cần làm là chỉ định đối số horizon trong hàm epinow của bạn, cho biết số ngày bạn muốn dự báo trong tương lai; xem phần EpiNow2 trong mục “Ước tính Rt” để biết chi tiết về cách thiết lập và chạy EpiNow2. Trong phần này, chúng ta sẽ chỉ vẽ các kết quả đầu ra từ phân tích đó, được lưu trữ trong đối tượng epinow_res.\n\n## define minimum date for plot\nmin_date &lt;- as.Date(\"2015-03-01\")\n\n## extract summarised estimates\nestimates &lt;-  as_tibble(epinow_res$estimates$summarised)\n\n## extract raw data on case incidence\nobservations &lt;- as_tibble(epinow_res$estimates$observations) %&gt;%\n  filter(date &gt; min_date)\n\n## extract forecasted estimates of case numbers\ndf_wide &lt;- estimates %&gt;%\n  filter(\n    variable == \"reported_cases\",\n    type == \"forecast\",\n    date &gt; min_date\n  )\n\n## convert to even longer format for quantile plotting\ndf_long &lt;- df_wide %&gt;%\n  ## here we match matching quantiles (e.g. lower_90 to upper_90)\n  pivot_longer(\n    lower_90:upper_90,\n    names_to = c(\".value\", \"quantile\"),\n    names_pattern = \"(.+)_(.+)\"\n  )\n\n## make plot\nggplot() +\n  geom_histogram(\n    data = observations,\n    aes(x = date, y = confirm),\n    stat = 'identity',\n    binwidth = 1\n  ) +\n  geom_ribbon(\n    data = df_long,\n    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = date, y = median)\n  ) +\n  geom_vline(xintercept = min(df_long$date), linetype = 2) +\n  ## manually define quantile transparency\n  scale_alpha_manual(\n    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = \"Daily reported cases\",\n    alpha = \"Credible\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14)\n\n\n\n\n\n\n\n\n\n\nDự đoán\nPackage projections do RECON phát triển giúp bạn dễ dàng đưa ra dự báo số trường hợp mắc mới trong ngắn hạn, chỉ yêu cầu kiến thức về hệ số lây nhiễm hiệu quả Rt và khoảng thời gian nối tiếp. Ở đây chúng tôi sẽ trình bày cách sử dụng ước tính khoảng thời gian nối tiếp từ y văn và từ ước tính của riêng chúng ta từ dữ liệu linelist.\n\nSử dụng ước tính khoảng thời gian nối tiếp từ y văn\nprojections yêu cầu một phân phối rời rạc của khoảng thời gian nối tiếp của class distcrete từ package distcrete. Chúng ta sẽ sử dụng phân phối gamma với giá trị trung bình là 12.0 và và độ lệch chuẩn là 5.2 được lấy từ bài báo này. Để chuyển đổi các giá trị này thành các tham số shape và scale cần thiết cho phân phối gamma, chúng ta sẽ sử dụng hàm gamma_mucv2shapescale từ package epitrix.\n\n## get shape and scale parameters from the mean mu and the coefficient of\n## variation (e.g. the ratio of the standard deviation to the mean)\nshapescale &lt;- epitrix::gamma_mucv2shapescale(mu = 12.0, cv = 5.2/12)\n\n## make distcrete object\nserial_interval_lit &lt;- distcrete::distcrete(\n  name = \"gamma\",\n  interval = 1,\n  shape = shapescale$shape,\n  scale = shapescale$scale\n)\n\nSau đây là một cách kiểm tra nhanh để đảm bảo rằng khoảng thời gian nối tiếp chính xác. Chúng ta truy cập mật độ của phân phối gamma mà chúng ta vừa xác định thông qua $d, tương đương với cách gọi dgamma:\n\n## check to make sure the serial interval looks correct\nqplot(\n  x = 0:50, y = serial_interval_lit$d(0:50), geom = \"area\",\n  xlab = \"Serial interval\", ylab = \"Density\"\n)\n\nWarning: `qplot()` was deprecated in ggplot2 3.4.0.\n\n\n\n\n\n\n\n\n\n\n\nSử dụng ước tính khoảng thời gian nối tiếp từ dữ liệu\nVì chúng ta có dữ liệu về ngày khởi phát triệu chứng và các liên kết lây truyền, chúng ta cũng có thể ước tính khoảng thời gian nối tiếp từ bộ số liệu linelist bằng cách tính toán độ trễ giữa ngày khởi phát của các cặp người truyền bệnh-người nhiễm bệnh. Như chúng ta đã làm trong mục EpiNow2, chúng ta sẽ sử dụng hàm get_pairwise từ package epicontacts, cho phép chúng ta tính toán theo từng cặp sự khác biệt giữa các cặp lây truyền trong bộ số liệu linelist. Chúng ta trước hết tạo một đối tượng epicontacts (xem chương Chuỗi lây nhiễm để biết thêm chi tiết):\n\n## generate contacts\ncontacts &lt;- linelist %&gt;%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %&gt;%\n  drop_na()\n\n## generate epicontacts object\nepic &lt;- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n\nSau đó, chúng ta fit một phân phối gamma cho sự khác biệt về ngày khởi phát giữa các cặp lây truyền (được tính toán bằng hàm get_pairwise). Chúng ta sử dụng hàm fit_disc_gamma từ package epitrix cho quy trình kết hợp này, vì chúng ta yêu cầu một phân phối rời rạc (discretised).\n\n## estimate gamma serial interval\nserial_interval &lt;- fit_disc_gamma(get_pairwise(epic, \"date_onset\"))\n\n## inspect estimate\nserial_interval[c(\"mu\", \"sd\")]\n\n$mu\n[1] 11.51047\n\n$sd\n[1] 7.696056\n\n\n\n\nDự đoán số trường hợp mắc mới\nĐể dự đoán số mắc mới trong tương lai, chúng ta vẫn cần cung cấp lịch sử số mới mắc dưới dạng một đối tượng incidence, cũng như một mẫu các giá trị Rt khả dĩ. Chúng ta sẽ tạo các giá trị này bằng cách sử dụng ước tính Rt được sinh ra bởi EpiEstim trong phần trước (trong mục “Ước tính Rt”) và được lưu trữ trong đối tượng epiestim_res_emp. Trong đoạn code dưới đây, chúng ta trích xuất các ước tính trung bình và độ lệch chuẩn của Rt cho khoảng thời gian cửa sổ cuối cùng của đợt bùng phát (sử dụng hàm tail để truy cập giá trị cuối cùng trong một vectơ) và mô phỏng 1000 giá trị từ phân phối gamma bằng cách sử dụng hàm rgamma. Bạn cũng có thể cung cấp vectơ của các giá trị Rt của riêng mình mà bạn muốn sử dụng để dự báo.\n\n## create incidence object from dates of onset\ninc &lt;- incidence::incidence(linelist$date_onset)\n\n256 missing observations were removed.\n\n## extract plausible r values from most recent estimate\nmean_r &lt;- tail(epiestim_res_emp$R$`Mean(R)`, 1)\nsd_r &lt;- tail(epiestim_res_emp$R$`Std(R)`, 1)\nshapescale &lt;- gamma_mucv2shapescale(mu = mean_r, cv = sd_r/mean_r)\nplausible_r &lt;- rgamma(1000, shape = shapescale$shape, scale = shapescale$scale)\n\n## check distribution\nqplot(x = plausible_r, geom = \"histogram\", xlab = expression(R[t]), ylab = \"Counts\")\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nSau đó, chúng ta sử dụng hàm project() để đưa ra dự báo thực tế. Chúng ta cụ thể số ngày chúng ta muốn dự báo qua đối số n_days và chỉ định số lượng mô phỏng bằng cách sử dụng đối số n_sim.\n\n## make projection\nproj &lt;- project(\n  x = inc,\n  R = plausible_r,\n  si = serial_interval$distribution,\n  n_days = 21,\n  n_sim = 1000\n)\n\nSau đó, chúng ta có thể vẽ biểu đồ số trường hợp mắc mới và số dự báo bằng cách sử dụng các hàm plot() và add_projections(). Chúng ta có thể dễ dàng lấy tập con của đối tượng incidence để chỉ hiển thị các trường hợp gần đây nhất bằng cách sử dụng toán tử dấu ngoặc vuông.\n\n## plot incidence and projections\nplot(inc[inc$dates &gt; as.Date(\"2015-03-01\")]) %&gt;%\n  add_projections(proj)\n\n\n\n\n\n\n\n\nBạn cũng có thể dễ dàng trích xuất các ước tính thô của số trường hợp hàng ngày bằng cách chuyển đổi đầu ra thành một dataframe.\n\n## convert to data frame for raw data\nproj_df &lt;- as.data.frame(proj)\nproj_df",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Mô hình hóa dịch bệnh</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.vn.html#tài-liệu-tham-khảo",
    "href": "new_pages/epidemic_models.vn.html#tài-liệu-tham-khảo",
    "title": "24  Mô hình hóa dịch bệnh",
    "section": "24.5 Tài liệu tham khảo",
    "text": "24.5 Tài liệu tham khảo\n\nBài báo này mô tả phương pháp được thực hiện trong EpiEstim.\nBài báo này mô tả phương pháp được thực hiện trong EpiNow2.\nBài báo này mô tả các cân nhắc phương pháp luận và thực tế khác nhau để ước tính Rt.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Mô hình hóa dịch bệnh</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.vn.html",
    "href": "new_pages/contact_tracing.vn.html",
    "title": "25  Truy vết tiếp xúc",
    "section": "",
    "text": "25.1 Chuẩn bị",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Truy vết tiếp xúc</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.vn.html#chuẩn-bị",
    "href": "new_pages/contact_tracing.vn.html#chuẩn-bị",
    "title": "25  Truy vết tiếp xúc",
    "section": "",
    "text": "Gọi package\nĐoạn code này hiển thị những package cần cho các phân tích. Trong sổ tay này, chúng tôi nhấn mạnh đến hàm p_load() từ pacman, hàm sẽ cài đặt package nếu cần và gọi nó để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm library() từ base R. Xem chương R cơ bản để có thêm thông tin về các R package.\n\npacman::p_load(\n  rio,          # importing data  \n  here,         # relative file pathways  \n  janitor,      # data cleaning and tables\n  lubridate,    # working with dates\n  epikit,       # age_categories() function\n  apyramid,     # age pyramids\n  tidyverse,    # data manipulation and visualization\n  RColorBrewer, # color palettes\n  formattable,  # fancy tables\n  kableExtra    # table formatting\n)\n\n\n\nNhập dữ liệu\nChúng ta sẽ nhập bộ dữ liệu mẫu về những người tiếp xúc và thông tin “theo dõi” của họ. Những dữ liệu này đã được truy xuất và không được lồng ghép với Go.Data API, đồng thời được lưu trữ dưới dạng tệp “.rds”.\nBạn có thể tải xuống tất cả dữ liệu mẫu cho sổ tay này từ chương Tải sách và dữ liệu.\nNếu bạn muốn tải xuống dữ liệu truy vết tiếp xúc mẫu cụ thể cho chương này, hãy sử dụng ba liên kết tải xuống dưới đây:\nBấm để tải xuống dữ liệu điều tra ca mắc (file .rds)\nBấm để tải xuống dữ liệu khai báo tiếp xúc (file .rds)\nBấm để tải xuống dữ liệu theo dõi tiếp xúc (file .rds)\n\n\n\n\n\n\n\n\n\nỞ dạng gốc các các tệp có thể tải xuống được, dữ liệu thể hiện dữ liệu gốc được cung cấp bởi Go.Data API (tìm hiểu thêm về APIs ở đây). Đối với mục đích ví dụ ở đây, chúng ta sẽ làm sạch dữ liệu để giúp bạn đọc chương này dễ dàng hơn. Nếu bạn đang sử dụng một phiên bản Go.Data, bạn có thể xem hướng dẫn đầy đủ về cách truy xuất dữ liệu của mình tại đây.\nDưới đây, các bộ dữ liệu được nhập bằng hàm import() từ package rio. Xem chương về Nhập xuất dữ liệu để biết những cách nhập dữ liệu khác nhau. Chúng tôi sử dụng hàm here() để xác định đường dẫn tệp - bạn nên cung cấp đường dẫn tệp cụ thể cho máy tính của mình. Sau đó, chúng tôi sử dụng hàm select() để chỉ chọn một số cột nhất định của dữ liệu, nhằm đơn giản hóa cho mục đích diễn giải.\n\nDữ liệu ca mắc\nDữ liệu này là một bảng các ca mắc và thông tin về họ.\n\ncases &lt;- import(here(\"data\", \"godata\", \"cases_clean.rds\")) %&gt;% \n  select(case_id, firstName, lastName, gender, age, age_class,\n         occupation, classification, was_contact, hospitalization_typeid)\n\nDưới đây là nrow(cases) các trường hợp :\n\n\n\n\n\n\n\n\nDữ liệu tiếp xúc\nNhững dữ liệu này là một bảng gồm tất cả những người tiếp xúc và thông tin về họ. Một lần nữa, hãy cung cấp đường dẫn tệp của riêng bạn. Sau khi nhập, chúng tôi thực hiện một số bước làm sạch dữ liệu sơ bộ bao gồm:\n\nThiết lập age_class là biến kiểu factor và đảo ngược thứ tự giá trị của biến sao cho những người trẻ hơn nằm ở trên đầu\n\nChỉ chọn một số cột nhất định, và đặt lại tên cho một trong số chúng\n\nGiả định gán các hàng missing ở cột admin_2_name thành “Djembe”, để cải thiện sự rõ ràng ở một số ví dụ trực quan hóa.\n\n\ncontacts &lt;- import(here(\"data\", \"godata\", \"contacts_clean.rds\")) %&gt;% \n  mutate(age_class = forcats::fct_rev(age_class)) %&gt;% \n  select(contact_id, contact_status, firstName, lastName, gender, age,\n         age_class, occupation, date_of_reporting, date_of_data_entry,\n         date_of_last_exposure = date_of_last_contact,\n         date_of_followup_start, date_of_followup_end, risk_level, was_case, admin_2_name) %&gt;% \n  mutate(admin_2_name = replace_na(admin_2_name, \"Djembe\"))\n\nĐây là nrow(contacts) các hàng của bộ dữ liệu contacts:\n\n\n\n\n\n\n\n\nDữ liệu theo dõi\nNhững dữ liệu này là bản ghi của các tương tác được “theo dõi” với những người tiếp xúc. Mỗi người tiếp xúc được cho là có một cuộc gặp gỡ mỗi ngày với ca mắc trong vòng 14 ngày sau khi phơi nhiễm.\nChúng ta nhập dữ liệu và thực hiện một số bước làm sạch. Chúng ta chọn một số cột nhất định và cũng chuyển đổi tất cả các giá trị thành chữ thường ở một cột định dạng ký tự.\n\nfollowups &lt;- rio::import(here::here(\"data\", \"godata\", \"followups_clean.rds\")) %&gt;% \n  select(contact_id, followup_status, followup_number,\n         date_of_followup, admin_2_name, admin_1_name) %&gt;% \n  mutate(followup_status = str_to_lower(followup_status))\n\nĐây là 50 hàng đầu tiên của nrow(followups) - hàng của bộ dữ liệu followups (mỗi hàng là một người tiếp xúc được theo dõi, với trạng thái kết quả trong cột followup_status):\n\n\n\n\n\n\n\n\nDữ liệu mối quan hệ\nỞ đây chúng ta nhập dữ liệu cho thấy mối quan hệ giữa các ca mắc và người tiếp xúc. Chúng ta chọn một số cột nhất định để hiển thị.\n\nrelationships &lt;- rio::import(here::here(\"data\", \"godata\", \"relationships_clean.rds\")) %&gt;% \n  select(source_visualid, source_gender, source_age, date_of_last_contact,\n         date_of_data_entry, target_visualid, target_gender,\n         target_age, exposure_type)\n\nDưới đây là 50 hàng đầu tiên của bộ dữ liệu relationships, bộ dữ liệu này ghi lại tất cả mối quan hệ giữa các ca mắc và những người tiếp xúc.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Truy vết tiếp xúc</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.vn.html#phân-tích-mô-tả",
    "href": "new_pages/contact_tracing.vn.html#phân-tích-mô-tả",
    "title": "25  Truy vết tiếp xúc",
    "section": "25.2 Phân tích mô tả",
    "text": "25.2 Phân tích mô tả\nBạn có thể sử dụng các kỹ thuật được đề cập đến trong những chương khác của sổ tay này để tiến hành các phân tích mô tả về những ca mắc, người tiếp xúc và mối quan hệ của họ. Dưới đây là một số ví dụ.\n\nNhân khẩu học\nNhư được trình bày trong chương Tháp dân số và thang đo Likert, bạn có thể trực quan hóa phân bố theo độ tuổi và giới tính (ở đây chúng tôi sử dụng package apyramid).\n\nTuổi và Giới tính của người tiếp xúc\nKim tự tháp dưới đây so sánh sự phân bố độ tuổi của những người tiếp xúc theo giới tính. Lưu ý rằng những người tiếp xúc bị missing tuổi được đưa vào thanh riêng của họ ở trên cùng. Bạn có thể thay đổi hiển thị mặc định này, nhưng sau đó hãy xem xét liệt kê số bị missing trong chú thích.\n\napyramid::age_pyramid(\n  data = contacts,                                   # use contacts dataset\n  age_group = \"age_class\",                           # categorical age column\n  split_by = \"gender\") +                             # gender for halfs of pyramid\n  labs(\n    fill = \"Gender\",                                 # title of legend\n    title = \"Age/Sex Pyramid of COVID-19 contacts\")+ # title of the plot\n  theme_minimal()                                    # simple background\n\n\n\n\n\n\n\n\nVới cấu trúc dữ liệu Go.Data, bộ dữ liệu relationships bao gồm độ tuổi của cả các ca mắc và những người tiếp xúc, vì vậy bạn có thể sử dụng bộ dữ liệu đó và tạo tháp tuổi cho thấy sự khác biệt giữa hai nhóm người này. Data frame relationships sẽ được biến đổi để chuyển các cột tuổi ở dạng số số thành các nhóm định danh (xem chương Làm sạch số liệu và các hàm quan trọng). Chúng ta cũng sẽ xoay trục dataframe sang định dạng dọc nhằm vẽ biểu đồ dễ dàng hơn với ggplot2 (xem chương Xoay trục dữ liệu).\n\nrelation_age &lt;- relationships %&gt;% \n  select(source_age, target_age) %&gt;% \n  transmute(                              # transmute is like mutate() but removes all other columns not mentioned\n    source_age_class = epikit::age_categories(source_age, breakers = seq(0, 80, 5)),\n    target_age_class = epikit::age_categories(target_age, breakers = seq(0, 80, 5)),\n    ) %&gt;% \n  pivot_longer(cols = contains(\"class\"), names_to = \"category\", values_to = \"age_class\")  # pivot longer\n\n\nrelation_age\n\n# A tibble: 200 × 2\n   category         age_class\n   &lt;chr&gt;            &lt;fct&gt;    \n 1 source_age_class 80+      \n 2 target_age_class 15-19    \n 3 source_age_class &lt;NA&gt;     \n 4 target_age_class 50-54    \n 5 source_age_class &lt;NA&gt;     \n 6 target_age_class 20-24    \n 7 source_age_class 30-34    \n 8 target_age_class 45-49    \n 9 source_age_class 40-44    \n10 target_age_class 30-34    \n# ℹ 190 more rows\n\n\nBây giờ chúng ta có thể vẽ biểu đồ bộ dữ liệu đã chuyển đổi này với hàm age_pyramid() như trước đây, nhưng thay thế gender bởi category (người tiếp xúc, hoặc ca mắc).\n\napyramid::age_pyramid(\n  data = relation_age,                               # use modified relationship dataset\n  age_group = \"age_class\",                           # categorical age column\n  split_by = \"category\") +                           # by cases and contacts\n  scale_fill_manual(\n    values = c(\"orange\", \"purple\"),                  # to specify colors AND labels\n    labels = c(\"Case\", \"Contact\"))+\n  labs(\n    fill = \"Legend\",                                           # title of legend\n    title = \"Age/Sex Pyramid of COVID-19 contacts and cases\")+ # title of the plot\n  theme_minimal()                                              # simple background\n\n\n\n\n\n\n\n\nChúng ta cũng có thể xem xét các đặc điểm khác như cơ cấu nghề nghiệp (ví dụ: ở dạng biểu đồ tròn).\n\n# Clean dataset and get counts by occupation\nocc_plot_data &lt;- cases %&gt;% \n  mutate(occupation = forcats::fct_explicit_na(occupation),  # make NA missing values a category\n         occupation = forcats::fct_infreq(occupation)) %&gt;%   # order factor levels in order of frequency\n  count(occupation)                                          # get counts by occupation\n  \n# Make pie chart\nggplot(data = occ_plot_data, mapping = aes(x = \"\", y = n, fill = occupation))+\n  geom_bar(width = 1, stat = \"identity\") +\n  coord_polar(\"y\", start = 0) +\n  labs(\n    fill = \"Occupation\",\n    title = \"Known occupations of COVID-19 cases\")+\n  theme_minimal() +                    \n  theme(axis.line = element_blank(),\n        axis.title = element_blank(),\n        axis.text = element_blank())\n\n\n\n\n\n\n\n\n\n\n\nSố người tiếp xúc trên mỗi ca mắc\nSố người tiếp xúc trên mỗi ca mắc có thể là một thước đo quan trọng để đánh giá chất lượng của việc điều tra số người tiếp xúc và mức độ tuân thủ của người dân với việc ứng phó sức khỏe cộng đồng.\nTùy thuộc vào cấu trúc dữ liệu của bạn, điều này có thể được đánh giá thông qua bộ dữ liệu chứa thông tin tất cả các ca mắc và những người tiếp xúc. Trong bộ dữ liệu Go.Data, liên kết giữa các ca mắc (“nguồn”) và những người tiếp xúc (“mục tiêu”) được lưu trữ trong bộ dữ liệu relationships.\nTrong bộ dữ liệu này, mỗi hàng là một người tiếp xúc và trong đó có liệt kê ca mắc nguồn. Không có người tiếp xúc nào có mối quan hệ với nhiều ca mắc, nhưng nếu điều này tồn tại, bạn có thể cần tính toán những người đó trước khi vẽ biểu đồ (và khám phá chúng nữa!).\nChúng ta bắt đầu bằng cách đếm số hàng (người tiếp xúc) trên mỗi ca mắc nguồn. Kết quả này được lưu dưới dạng một data frame.\n\ncontacts_per_case &lt;- relationships %&gt;% \n  count(source_visualid)\n\ncontacts_per_case\n\n   source_visualid  n\n1   CASE-2020-0001 13\n2   CASE-2020-0002  5\n3   CASE-2020-0003  2\n4   CASE-2020-0004  4\n5   CASE-2020-0005  5\n6   CASE-2020-0006  3\n7   CASE-2020-0008  3\n8   CASE-2020-0009  3\n9   CASE-2020-0010  3\n10  CASE-2020-0012  3\n11  CASE-2020-0013  5\n12  CASE-2020-0014  3\n13  CASE-2020-0016  3\n14  CASE-2020-0018  4\n15  CASE-2020-0022  3\n16  CASE-2020-0023  4\n17  CASE-2020-0030  3\n18  CASE-2020-0031  3\n19  CASE-2020-0034  4\n20  CASE-2020-0036  1\n21  CASE-2020-0037  3\n22  CASE-2020-0045  3\n23            &lt;NA&gt; 17\n\n\nChúng ta sử dụng hàm geom_histogram() để vẽ các dữ liệu này dưới dạng biểu đồ histogram.\n\nggplot(data = contacts_per_case)+        # begin with count data frame created above\n  geom_histogram(mapping = aes(x = n))+  # print histogram of number of contacts per case\n  scale_y_continuous(expand = c(0,0))+   # remove excess space below 0 on y-axis\n  theme_light()+                         # simplify background\n  labs(\n    title = \"Number of contacts per case\",\n    y = \"Cases\",\n    x = \"Contacts per case\"\n  )",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Truy vết tiếp xúc</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.vn.html#theo-dõi-người-tiếp-xúc",
    "href": "new_pages/contact_tracing.vn.html#theo-dõi-người-tiếp-xúc",
    "title": "25  Truy vết tiếp xúc",
    "section": "25.3 Theo dõi người tiếp xúc",
    "text": "25.3 Theo dõi người tiếp xúc\nDữ liệu truy vết tiếp xúc thường chứa dữ liệu “theo dõi”, dữ liệu này ghi lại kết quả kiểm tra triệu chứng hàng ngày của những người trong diện cách ly. Phân tích dữ liệu này có thể xác định chiến lược ứng phó, xác định những người tiếp xúc có nguy cơ mất theo dõi hoặc có nguy cơ phát triển bệnh.\n\nLàm sạch dữ liệu\nNhững dữ liệu này có thể tồn tại ở nhiều định dạng khác nhau. Chúng có thể tồn tại dưới dạng trang tính Excel định dạng “ngang” với một hàng cho mỗi người tiếp xúc và một cột cho mỗi “ngày” theo dõi. Xem chương Xoay trục dữ liệu để hiểu về mô tả dữ liệu “dọc” và “ngang”, và cả cách xoay trục dữ liệu sang định dạng ngang hoặc dọc.\nTrong ví dụ Go.Data của chúng tôi, những dữ liệu này được lưu trữ trong data frame followups, data frame này có định dạng “dọc” với một hàng cho mỗi tương tác theo dõi. 50 hàng đầu tiên như sau:\n\n\n\n\n\n\nCẨN TRỌNG: Cẩn thận với các bản trùng lặp khi xử lý dữ liệu theo dõi; vì có thể có một vài lần theo dõi sai sót trong cùng một ngày cho một người tiếp xúc nhất định. Nó dường như có vẻ là một lỗi nhưng lại phản ánh đúng thực tế - ví dụ: người theo dõi trường hợp tiếp xúc có thể gửi biểu mẫu theo dõi từ sớm trong ngày dù họ chưa liên hệ được với người tiếp xúc và gửi biểu mẫu thứ hai khi họ đã liên hệ được sau đó. Việc này sẽ phụ thuộc vào quy trình thực hiện hoạt động đối với cách bạn muốn xử lý các bản trùng lặp - chỉ cần đảm bảo ghi lại cách tiếp cận của bạn một cách rõ ràng.\nHãy xem chúng ta có bao nhiêu trường hợp hàng “trùng lặp”:\n\nfollowups %&gt;% \n  count(contact_id, date_of_followup) %&gt;%   # get unique contact_days\n  filter(n &gt; 1)                             # view records where count is more than 1  \n\n  contact_id date_of_followup n\n1       &lt;NA&gt;       2020-09-03 2\n2       &lt;NA&gt;       2020-09-04 2\n3       &lt;NA&gt;       2020-09-05 2\n\n\nTrong dữ liệu ví dụ của chúng ta, các bản ghi duy nhất áp dụng điều này là những bản ghi missing ID! Chúng ta có thể loại bỏ chúng. Tuy nhiên, với mục đích diễn giải, chúng ta sẽ trình bày các bước nhằm loại bỏ trùng lặp để mỗi người tiếp xúc chỉ có một lần theo dõi truy vết mỗi ngày. Xem chương Loại bỏ trùng lặp để biết thêm chi tiết. Chúng ta sẽ giả định rằng bản ghi cuộc gọi truy vết mới nhất là bản ghi chính xác. Chúng ta cũng tận dụng cơ hội để làm sạch cột followup_number (“ngày” theo dõi sẽ nằm trong khoảng 1 - 14).\n\nfollowups_clean &lt;- followups %&gt;%\n  \n  # De-duplicate\n  group_by(contact_id, date_of_followup) %&gt;%        # group rows per contact-day\n  arrange(contact_id, desc(date_of_followup)) %&gt;%   # arrange rows, per contact-day, by date of follow-up (most recent at top)\n  slice_head() %&gt;%                                  # keep only the first row per unique contact id  \n  ungroup() %&gt;% \n  \n  # Other cleaning\n  mutate(followup_number = replace(followup_number, followup_number &gt; 14, NA)) %&gt;% # clean erroneous data\n  drop_na(contact_id)                               # remove rows with missing contact_id\n\nĐối với mỗi cuộc gọi truy vết tiếp theo, chúng ta có một trạng thái theo dõi (chẳng hạn như cuộc gọi truy vết có xảy ra hay không và nếu có, người tiếp xúc có triệu chứng hay không). Để xem tất cả các giá trị, chúng ta có thể chạy nhanh lệnh tabyl() (từ janitor) hoặc table() (từ base R) (xem chương Bảng mô tả) bằng followup_status để xem tần suất của từng kết quả.\nTrong bộ dữ liệu này, “seen_not_ok” có nghĩa là “được thấy có triệu chứng” và “seen_ok” có nghĩa là “được thấy không có triệu chứng”.\n\nfollowups_clean %&gt;% \n  tabyl(followup_status)\n\n followup_status   n    percent\n          missed  10 0.02325581\n   not_attempted   5 0.01162791\n   not_performed 319 0.74186047\n     seen_not_ok   6 0.01395349\n         seen_ok  90 0.20930233\n\n\n\n\nVẽ biểu đồ theo thời gian\nVì dữ liệu ngày là liên tục, chúng ta sẽ sử dụng biểu đồ histogram để vẽ chúng với biến date_of_followup được gán cho trục x. Chúng ta có thể vẽ được biểu đồ histogram “xếp chồng” bằng cách chỉ định đối số fill = trong aes(), đối số mà chúng ta gán cho cột followup_status. Do đó, bạn có thể thiết lập chú thích bằng cách sử dụng đối số fill = của labs().\nChúng ta có thể thấy rằng những người tiếp xúc được xác định theo từng đợt (có lẽ là tương ứng với các đợt dịch) và việc hoàn thành theo dõi dường như không cải thiện trong suốt đợt dịch.\n\nggplot(data = followups_clean)+\n  geom_histogram(mapping = aes(x = date_of_followup, fill = followup_status)) +\n  scale_fill_discrete(drop = FALSE)+   # show all factor levels (followup_status) in the legend, even those not used\n  theme_classic() +\n  labs(\n    x = \"\",\n    y = \"Number of contacts\",\n    title = \"Daily Contact Followup Status\",\n    fill = \"Followup Status\",\n    subtitle = str_glue(\"Data as of {max(followups$date_of_followup, na.rm=T)}\"))   # dynamic subtitle\n\n\n\n\n\n\n\n\nCẨN TRỌNG: Nếu bạn đang chuẩn bị nhiều biểu đồ (ví dụ: cho nhiều khu vực pháp lý), bạn sẽ muốn các chú thích xuất hiện giống hệt nhau ngay cả với các mức độ hoàn thiện dữ liệu hoặc thành phần dữ liệu khác nhau. Có thể có những biểu đồ mà không phải tất cả các trạng thái theo dõi đều có trong dữ liệu, nhưng bạn vẫn muốn các danh mục đó xuất hiện trong chú thích. Trong ggplots (như trên), bạn có thể chỉ định đối số drop = FALSE của hàm scale_fill_discrete(). Trong bảng, hãy sử dụng tabyl() để hiển thị số lượng cho tất cả các thực bậc của factor hoặc nếu sử dụng count() từ dplyr, hãy thêm đối số .drop = FALSE để bao gồm số lượng của tất cả các thứ bậc factors.\n\n\nTheo dõi cá nhân hàng ngày\nNếu sự bùng phát dịch của bạn đủ nhỏ, bạn có thể muốn xem xét từng người tiếp xúc và xem trạng thái của họ trong suốt quá trình theo dõi. May mắn rằng, bộ dữ liệu followups này đã chứa sẵn một cột với “số” ngày theo dõi (1-14). Nếu cột này không tồn tại trong dữ liệu của bạn, bạn có thể tạo ra nó bằng cách tính toán sự khác biệt giữa ngày truy vết và ngày dự định bắt đầu theo dõi người tiếp xúc.\nMột cơ chế trực quan hóa thuận tiện (nếu số lượng ca mắc không quá lớn) có thể là một biểu đồ nhiệt, được tạo bằng geom_tile(). Xem thêm chi tiết trong chương Biểu đồ nhiệt.\n\nggplot(data = followups_clean)+\n  geom_tile(mapping = aes(x = followup_number, y = contact_id, fill = followup_status),\n            color = \"grey\")+       # grey gridlines\n  scale_fill_manual( values = c(\"yellow\", \"grey\", \"orange\", \"darkred\", \"darkgreen\"))+\n  theme_minimal()+\n  scale_x_continuous(breaks = seq(from = 1, to = 14, by = 1))\n\n\n\n\n\n\n\n\n\n\nPhân tích theo nhóm\nCó lẽ những dữ liệu theo dõi này đang được kiểm tra hàng ngày hoặc hàng tuần để đưa ra quyết định hành động. Bạn có thể muốn những phân tách có ý nghĩa hơn theo khu vực địa lý hoặc theo nhóm truy vết tiếp xúc. Chúng ta có thể làm điều này bằng cách điều chỉnh các cột được cung cấp tới hàm group_by().\n\nplot_by_region &lt;- followups_clean %&gt;%                                        # begin with follow-up dataset\n  count(admin_1_name, admin_2_name, followup_status) %&gt;%   # get counts by unique region-status (creates column 'n' with counts)\n  \n  # begin ggplot()\n  ggplot(                                         # begin ggplot\n    mapping = aes(x = reorder(admin_2_name, n),     # reorder admin factor levels by the numeric values in column 'n'\n                  y = n,                            # heights of bar from column 'n'\n                  fill = followup_status,           # color stacked bars by their status\n                  label = n))+                      # to pass to geom_label()              \n  geom_col()+                                     # stacked bars, mapping inherited from above \n  geom_text(                                      # add text, mapping inherited from above\n    size = 3,                                         \n    position = position_stack(vjust = 0.5), \n    color = \"white\",           \n    check_overlap = TRUE,\n    fontface = \"bold\")+\n  coord_flip()+\n  labs(\n    x = \"\",\n    y = \"Number of contacts\",\n    title = \"Contact Followup Status, by Region\",\n    fill = \"Followup Status\",\n    subtitle = str_glue(\"Data as of {max(followups_clean$date_of_followup, na.rm=T)}\")) +\n  theme_classic()+                                                                      # Simplify background\n  facet_wrap(~admin_1_name, strip.position = \"right\", scales = \"free_y\", ncol = 1)      # introduce facets \n\nplot_by_region",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Truy vết tiếp xúc</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.vn.html#bảng-kpi",
    "href": "new_pages/contact_tracing.vn.html#bảng-kpi",
    "title": "25  Truy vết tiếp xúc",
    "section": "25.4 Bảng KPI",
    "text": "25.4 Bảng KPI\nCó một số Chỉ Số Đánh Giá Hiệu Quả Công Việc (KPI) khác nhau có thể được tính toán và theo dõi ở các mức độ phân tách khác nhau và trong những khoảng thời gian khác nhau để theo dõi hiệu suất thực hiện truy vết tiếp xúc. Khi bạn đã tính toán xong và có định dạng bảng cơ bản; khá dễ dàng để hoán đổi các KPI khác nhau.\nCó nhiều nguồn KPI truy vết tiếp xúc, chẳng hạn như nguồn này từ ResolveToSaveLives.org. Phần lớn công việc sẽ là xem xét cấu trúc dữ liệu và suy nghĩ về tất cả các tiêu chí bao gồm/loại trừ. Chúng tôi đưa ra một vài ví dụ dưới đây; sử dụng cấu trúc siêu dữ liệu Go.Data:\n\n\n\n\n\n\n\n\n\nDanh mục\nChỉ số\nTử số Go.Data\nMẫu số Go.Data\n\n\n\n\nChỉ Số Quy Trình - Tốc Độ Truy Vết Tiếp Xúc\n% các trường hợp được phỏng vấn và cách ly trong vòng 24 giờ kể từ khi báo cáo ca mắc\nĐẾM case_id MÀ (date_of_reporting - date_of_data_entry) &lt; 1 ngày VÀ (isolation_startdate - date_of_data_entry) &lt; 1 ngày\nĐẾM case_id\n\n\nChỉ Số Quy Trình - Tốc Độ Truy Vết Tiếp Xúc\n% những người tiếp xúc được thông báo và cách ly trong vòng 24 giờ kể từ khi được tìm thấy\nĐẾM contact_id MÀ followup_status == “SEEN_NOT_OK” HOẶC “SEEN_OK” VÀ date_of_followup - date_of_reporting &lt; 1 ngày\nĐẾM contact_id\n\n\nChỉ Số Quy Trình - Tính Hoàn chỉnh của Việc Kiểm Tra\n% các ca mắc có triệu chứng mới được kiểm tra và phỏng vấn trong vòng 3 ngày kể từ khi bắt đầu có triệu chứng\nĐẾM case_id MÀ (date_of_reporting - date_of_onset) &lt; =3 ngày\nĐẾM case_id\n\n\nChỉ Số Kết quả - Tổng Kết\n% các ca mắc mới trong danh sách liên hệ hiện có\nĐẾM case_id MÀ was_contact == “TRUE”\nĐẾM case_id\n\n\n\nSau đây chúng tôi sẽ giới thiệu một bài tập mẫu về cách tạo bảng đẹp mắt để hiển thị thông tin theo dõi người tiếp xúc trên các khu vực hành chính. Cho tới bước cuối cùng, chúng tôi sẽ tạo bảng phù hợp để trình bày với package formattable (nhưng bạn có thể sử dụng các package khác như flextable - xem chương Trình bày bảng).\nCách bạn tạo một bảng như thế nào sẽ phụ thuộc vào cấu trúc của dữ liệu truy vết tiếp xúc của bạn. Sử dụng chương Bảng mô tả để tìm hiểu cách tóm tắt dữ liệu bằng các hàm dplyr.\nChúng tôi sẽ tạo một bảng động và thay đổi khi dữ liệu thay đổi. Để làm cho kết quả thú vị, chúng tôi sẽ thiết lập report_date nhằm cho phép chúng tôi mô phỏng việc chạy bảng vào một ngày nhất định (chúng tôi chọn ngày 10 tháng 6 năm 2020). Dữ liệu được lọc cho ngày đó.\n\n# Set \"Report date\" to simulate running the report with data \"as of\" this date\nreport_date &lt;- as.Date(\"2020-06-10\")\n\n# Create follow-up data to reflect the report date.\ntable_data &lt;- followups_clean %&gt;% \n  filter(date_of_followup &lt;= report_date)\n\nBây giờ, dựa trên cấu trúc dữ liệu, chúng ta sẽ làm như sau:\n\nBắt đầu với dữ liệu followups và tóm tắt nó để chứa cho mỗi liên hệ duy nhất:\n\n\nNgày của bản ghi gần nhất (bất kể tình trạng của truy vết)\n\nNgày truy vết gần nhất mà người tiếp xúc được “seen”\n\nTrạng thái truy vết ở lần truy vết “seen” cuối cùng (ví dụ: có triệu chứng, không có triệu chứng)\n\n\n\nNối dữ liệu này với dữ liệu người tiếp xúc, dữ liệu mà chứa các thông tin khác như trạng thái tổng thể của người tiếp xúc, ngày tiếp xúc cuối với một ca mắc, v.v. Ngoài ra, chúng ta sẽ tính toán các số liệu được quan tâm cho mỗi người tiếp xúc, chẳng hạn như số ngày kể từ lần phơi nhiễm cuối\n\nChúng ta nhóm dữ liệu người tiếp xúc nâng cao theo vùng địa lý (admin_2_name) và tính toán tóm tắt thống kê cho mỗi khu vực\n\nCuối cùng, chúng ta định dạng bảng thích hợp để trình bày\n\nĐầu tiên, chúng ta tóm tắt dữ liệu theo dõi để có được thông tin quan tâm:\n\nfollowup_info &lt;- table_data %&gt;% \n  group_by(contact_id) %&gt;% \n  summarise(\n    date_last_record   = max(date_of_followup, na.rm=T),\n    date_last_seen     = max(date_of_followup[followup_status %in% c(\"seen_ok\", \"seen_not_ok\")], na.rm=T),\n    status_last_record = followup_status[which(date_of_followup == date_last_record)]) %&gt;% \n  ungroup()\n\nĐây là cách những dữ liệu này được nhìn thấy:\n\n\n\n\n\n\nBây giờ chúng ta sẽ thêm thông tin này vào bộ dữ liệu contacts và tính toán một số cột bổ sung.\n\ncontacts_info &lt;- followup_info %&gt;% \n  right_join(contacts, by = \"contact_id\") %&gt;% \n  mutate(\n    database_date       = max(date_last_record, na.rm=T),\n    days_since_seen     = database_date - date_last_seen,\n    days_since_exposure = database_date - date_of_last_exposure\n    )\n\nĐây là cách những dữ liệu này được nhìn thấy. Lưu ý cột contacts nằm ở bên phải và cột mới được tính toán nằm ở ngoài cùng bên phải.\n\n\n\n\n\n\nTiếp theo, chúng ta tổng hợp dữ liệu người tiếp xúc theo khu vực, để có một data frame ngắn gọn của các cột thống kê đã tóm tắt.\n\ncontacts_table &lt;- contacts_info %&gt;% \n  \n  group_by(`Admin 2` = admin_2_name) %&gt;%\n  \n  summarise(\n    `Registered contacts` = n(),\n    `Active contacts`     = sum(contact_status == \"UNDER_FOLLOW_UP\", na.rm=T),\n    `In first week`       = sum(days_since_exposure &lt; 8, na.rm=T),\n    `In second week`      = sum(days_since_exposure &gt;= 8 & days_since_exposure &lt; 15, na.rm=T),\n    `Became case`         = sum(contact_status == \"BECAME_CASE\", na.rm=T),\n    `Lost to follow up`   = sum(days_since_seen &gt;= 3, na.rm=T),\n    `Never seen`          = sum(is.na(date_last_seen)),\n    `Followed up - signs` = sum(status_last_record == \"Seen_not_ok\" & date_last_record == database_date, na.rm=T),\n    `Followed up - no signs` = sum(status_last_record == \"Seen_ok\" & date_last_record == database_date, na.rm=T),\n    `Not Followed up`     = sum(\n      (status_last_record == \"NOT_ATTEMPTED\" | status_last_record == \"NOT_PERFORMED\") &\n        date_last_record == database_date, na.rm=T)) %&gt;% \n    \n  arrange(desc(`Registered contacts`))\n\n\n\n\n\n\n\nVà bây giờ chúng ta áp dụng kiểu bảng từ các package formattable và knitr, bao gồm một chú thích cuối trang hiển thị “kể từ” ngày.\n\ncontacts_table %&gt;%\n  mutate(\n    `Admin 2` = formatter(\"span\", style = ~ formattable::style(\n      color = ifelse(`Admin 2` == NA, \"red\", \"grey\"),\n      font.weight = \"bold\",font.style = \"italic\"))(`Admin 2`),\n    `Followed up - signs`= color_tile(\"white\", \"orange\")(`Followed up - signs`),\n    `Followed up - no signs`= color_tile(\"white\", \"#A0E2BD\")(`Followed up - no signs`),\n    `Became case`= color_tile(\"white\", \"grey\")(`Became case`),\n    `Lost to follow up`= color_tile(\"white\", \"grey\")(`Lost to follow up`), \n    `Never seen`= color_tile(\"white\", \"red\")(`Never seen`),\n    `Active contacts` = color_tile(\"white\", \"#81A4CE\")(`Active contacts`)\n  ) %&gt;%\n  kable(\"html\", escape = F, align =c(\"l\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\")) %&gt;%\n  kable_styling(\"hover\", full_width = FALSE) %&gt;%\n  add_header_above(c(\" \" = 3, \n                     \"Of contacts currently under follow up\" = 5,\n                     \"Status of last visit\" = 3)) %&gt;% \n  kableExtra::footnote(general = str_glue(\"Data are current to {format(report_date, '%b %d %Y')}\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOf contacts currently under follow up\n\n\nStatus of last visit\n\n\n\nAdmin 2\nRegistered contacts\nActive contacts\nIn first week\nIn second week\nBecame case\nLost to follow up\nNever seen\nFollowed up - signs\nFollowed up - no signs\nNot Followed up\n\n\n\n\nDjembe \n59\n30\n44\n0\n2\n15\n22\n0\n0\n0\n\n\nTrumpet\n3\n1\n3\n0\n0\n0\n0\n0\n0\n0\n\n\nVenu \n2\n0\n0\n0\n2\n0\n2\n0\n0\n0\n\n\nCongas \n1\n0\n0\n0\n1\n0\n1\n0\n0\n0\n\n\nCornet \n1\n0\n1\n0\n1\n0\n1\n0\n0\n0\n\n\n\nNote: \n\n\n\n\n\n\n\n\n\n\n\n\n Data are current to Jun 10 2020",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Truy vết tiếp xúc</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.vn.html#ma-trận-lây-truyền",
    "href": "new_pages/contact_tracing.vn.html#ma-trận-lây-truyền",
    "title": "25  Truy vết tiếp xúc",
    "section": "25.5 Ma trận lây truyền",
    "text": "25.5 Ma trận lây truyền\nNhư đã thảo luận trong chương Biểu đồ nhiệt, bạn có thể tạo ma trận “ai đã lây nhiễm cho ai” bằng cách sử dụng hàm geom_tile().\nKhi những ca tiếp xúc mới được tạo, Go.Data lưu trữ thông tin về mối quan hệ này tại điểm cuối API relationships; chúng ta có thể thấy 50 hàng đầu tiên của bộ dữ liệu này bên dưới. Điều này có nghĩa là chúng ta có thể tạo một biểu đồ nhiệt với một vài bước với mỗi tiếp điểm được nối với ca mắc nguồn của nó.\n\n\n\n\n\n\nNhư đã thực hiện ở trên đối với tháp tuổi so sánh các ca mắc và những người tiếp xúc, chúng ta có thể chọn một vài biến số chúng ta cần và tạo các cột nhóm tuổi được phân loại cho cả dữ liệu nguồn (ca mắc) và mục tiêu (người tiếp xúc).\n\nheatmap_ages &lt;- relationships %&gt;% \n  select(source_age, target_age) %&gt;% \n  mutate(                              # transmute is like mutate() but removes all other columns\n    source_age_class = epikit::age_categories(source_age, breakers = seq(0, 80, 5)),\n    target_age_class = epikit::age_categories(target_age, breakers = seq(0, 80, 5))) \n\nNhư đã mô tả bên trên, chúng ta tạo bảng chéo;\n\ncross_tab &lt;- table(\n  source_cases = heatmap_ages$source_age_class,\n  target_cases = heatmap_ages$target_age_class)\n\ncross_tab\n\n            target_cases\nsource_cases 0-4 5-9 10-14 15-19 20-24 25-29 30-34 35-39 40-44 45-49 50-54\n       0-4     0   0     0     0     0     0     0     0     0     1     0\n       5-9     0   0     1     0     0     0     0     1     0     0     0\n       10-14   0   0     0     0     0     0     0     0     0     0     0\n       15-19   0   0     0     0     0     0     0     0     0     0     0\n       20-24   1   1     0     1     2     0     2     1     0     0     0\n       25-29   1   2     0     0     0     0     0     0     0     0     0\n       30-34   0   0     0     0     0     0     0     0     1     1     0\n       35-39   0   2     0     0     0     0     0     0     0     1     0\n       40-44   0   0     0     0     1     0     2     1     0     3     1\n       45-49   1   2     2     0     0     0     3     0     1     0     3\n       50-54   1   2     1     2     0     0     1     0     0     3     4\n       55-59   0   1     0     0     1     1     2     0     0     0     0\n       60-64   0   0     0     0     0     0     0     0     0     0     0\n       65-69   0   0     0     0     0     0     0     0     0     0     0\n       70-74   0   0     0     0     0     0     0     0     0     0     0\n       75-79   0   0     0     0     0     0     0     0     0     0     0\n       80+     1   0     0     2     1     0     0     0     1     0     0\n            target_cases\nsource_cases 55-59 60-64 65-69 70-74 75-79 80+\n       0-4       1     0     0     0     0   0\n       5-9       1     0     0     0     0   0\n       10-14     0     0     0     0     0   0\n       15-19     0     0     0     0     0   0\n       20-24     1     0     0     0     0   1\n       25-29     0     0     0     0     0   0\n       30-34     1     0     0     0     0   0\n       35-39     0     0     0     0     0   0\n       40-44     1     0     0     0     1   1\n       45-49     2     1     0     0     0   1\n       50-54     1     0     1     0     0   1\n       55-59     0     0     0     0     0   0\n       60-64     0     0     0     0     0   0\n       65-69     0     0     0     0     0   0\n       70-74     0     0     0     0     0   0\n       75-79     0     0     0     0     0   0\n       80+       0     0     0     0     0   0\n\n\nchuyển đổi thành định dạng dọc với những tỷ lệ;\n\nlong_prop &lt;- data.frame(prop.table(cross_tab))\n\nvà tạo biểu đồ nhiệt cho độ tuổi.\n\nggplot(data = long_prop)+       # use long data, with proportions as Freq\n  geom_tile(                    # visualize it in tiles\n    aes(\n      x = target_cases,         # x-axis is case age\n      y = source_cases,     # y-axis is infector age\n      fill = Freq))+            # color of the tile is the Freq column in the data\n  scale_fill_gradient(          # adjust the fill color of the tiles\n    low = \"blue\",\n    high = \"orange\")+\n  theme(axis.text.x = element_text(angle = 90))+\n  labs(                         # labels\n    x = \"Target case age\",\n    y = \"Source case age\",\n    title = \"Who infected whom\",\n    subtitle = \"Frequency matrix of transmission events\",\n    fill = \"Proportion of all\\ntranmsission events\"     # legend title\n  )",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Truy vết tiếp xúc</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.vn.html#tài-nguyên-học-liệu",
    "href": "new_pages/contact_tracing.vn.html#tài-nguyên-học-liệu",
    "title": "25  Truy vết tiếp xúc",
    "section": "25.6 Tài nguyên học liệu",
    "text": "25.6 Tài nguyên học liệu\nhttps://github.com/WorldHealthOrganization/godata/tree/master/analytics/r-reporting\nhttps://worldhealthorganization.github.io/godata/\nhttps://community-godata.who.int/",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Truy vết tiếp xúc</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.vn.html",
    "href": "new_pages/survey_analysis.vn.html",
    "title": "26  Phân tích khảo sát",
    "section": "",
    "text": "26.1 Tổng quan\nChương này trình bày việc sử dụng một số packages để phân tích khảo sát.\nHầu hết các packages R dùng để phân tích khảo sát đều dựa trên survey package cho phân tích có trọng số. Chúng tôi sẽ sử dụng survey cũng như srvyr (cho phép survey mã hóa theo kiểu tidyverse) và gtsummary (cho phép survey tạo các bảng sẵn sàng cho xuất bản). Trong khi package survey ban đầu không cho phép mã hóa theo kiểu tidyverse, nhưng nó có điểm cộng là cho phép khảo sát được trọng số hóa mô hình tuyến tính tổng quát (sẽ được thêm vào chương này sau). Chúng tôi cũng sẽ minh họa bằng cách sử dụng một hàm từ package sitrep để tạo mẫu trọng số (lưu ý package này hiện chưa có trên CRAN, nhưng có thể được cài đặt từ github).\nHầu hết chương này dựa trên công việc đã hoàn thành của dự án “R4Epis”; để biết code chi tiết và mẫu R-markdown xem trang github của “R4Epis”. Một số package survey dựa trên các phiên bản đầu tiên của các nghiên cứuu trường hợp EPIET.\nHiện tại, chương này không đề cập đến các phép tính cỡ mẫu hoặc lấy mẫu. Để tính cỡ mẫu đơn giản, hãy xem OpenEpi. Chương GIS cơ bản trong sổ tay này sẽ có một phần về lấy mẫu ngẫu nhiên theo không gian và chương này cũng sẽ đề cập một phần về khung lấy mẫu cũng như tính toán cỡ mẫu.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Phân tích khảo sát</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.vn.html#tổng-quan",
    "href": "new_pages/survey_analysis.vn.html#tổng-quan",
    "title": "26  Phân tích khảo sát",
    "section": "",
    "text": "Dữ liệu khảo sát\nThời gian quan sát\nÁp dụng trọng số\nĐối tượng thiết kế nghiên cứu\nPhân tích mô tả\nTỷ lệ được áp dụng trọng số\nTỷ suất được áp dụng trọng số",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Phân tích khảo sát</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.vn.html#chuẩn-bị",
    "href": "new_pages/survey_analysis.vn.html#chuẩn-bị",
    "title": "26  Phân tích khảo sát",
    "section": "26.2 Chuẩn bị",
    "text": "26.2 Chuẩn bị\n\nPackages\nĐoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R. Ở đây chúng tôi cũng minh họa việc sử dụng hàm p_load_gh() từ pacman để cài đặt một package tải từ github mà chưa được công bố trên CRAN.\n\n## load packages from CRAN\npacman::p_load(rio,          # File import\n               here,         # File locator\n               tidyverse,    # data management + ggplot2 graphics\n               tsibble,      # handle time series datasets\n               survey,       # for survey functions\n               srvyr,        # dplyr wrapper for survey package\n               gtsummary,    # wrapper for survey package to produce tables\n               apyramid,     # a package dedicated to creating age pyramids\n               patchwork,    # for combining ggplots\n               ggforce       # for alluvial/sankey plots\n               ) \n\n## load packages from github\npacman::p_load_gh(\n     \"R4EPI/sitrep\"          # for observation time / weighting functions\n)\n\n\n\nNạp dữ liệu\nBộ dữ liệu ví dụ được sử dụng trong phần này:\n\ndữ liệu điều tra tỷ lệ tử vong mô phỏng.\nsố lượng dân cư mô phỏng cho khu vực khảo sát.\ntừ điển dữ liệu cho dữ liệu khảo sát tử vong mô phỏng.\n\nBộ này dựa trên khảo sát đã được phê duyệt trước của hội đồng đạo đức MSF OCA. Các tập dữ liệu mô phỏng được tạo như một phần của Dự án “R4Epis”. Tất cả đều dựa trên dữ liệu được thu thập bằng KoboToolbox, đây là một phần mềm thu thập dữ liệu dựa trên Open Data Kit.\nKobo cho phép bạn xuất cả dữ liệu đã thu thập, cũng như từ điển dữ liệu cho tập dữ liệu đó. Chúng tôi thực sự khuyên bạn nên làm điều này vì nó đơn giản hóa việc làm sạch dữ liệu và hữu ích cho việc tra cứu các biến/câu hỏi.\nMẸO: Từ điển dữ liệu Kobo có tên biến trong cột “name” của sheet “survey” (khảo sát). Các giá trị có thể có cho mỗi biến được chỉ định trong sheet “choices” (lựa chọn). Trong tab lựa chọn, “name” có giá trị rút gọn và các cột “label::english” và “label::french” chứa các nhãn mô tả đầy đủ. Sử dụng hàm msf_dict_survey() của package epidict để nhập tệp excel từ điển Kobo sẽ định dạng lại tệp này cho bạn để bạn có thể dễ dàng sử dụng để code lại.\nTHẬN TRỌNG: Bộ dữ liệu ví dụ không giống nhau dưới dạng xuất (như trong Kobo, bạn xuất từng cấp bảng câu hỏi khác nhau) - xem phần dữ liệu khảo sát bên dưới để hợp nhất các cấp độ khác nhau.\nBộ dữ liệu được nhập bằng hàm import() từ package rio. Xem chương về Nhập xuất dữ liệu để biết các cách nhập dữ liệu khác nhau.\n\n# import the survey data\nsurvey_data &lt;- rio::import(\"survey_data.xlsx\")\n\n# import the dictionary into R\nsurvey_dict &lt;- rio::import(\"survey_dict.xlsx\") \n\n10 hàng đầu tiên của khảo sát được hiển thị bên dưới.\n\n\n\n\n\n\nChúng ta cũng muốn nhập dữ liệu về quần thể lấy mẫu để có thể tạo ra các trọng số thích hợp. Dữ liệu này có thể ở các định dạng khác nhau, tuy nhiên chúng tôi khuyên bạn nên định dạng như hình bên dưới (dữ liệu này có thể chỉ cần nhập vào excel).\n\n# import the population data\npopulation &lt;- rio::import(\"population.xlsx\")\n\n10 hàng đầu tiên của khảo sát được hiển thị bên dưới.\n\n\n\n\n\n\nĐối với khảo sát theo cụm, bạn có thể muốn thêm trọng số khảo sát ở cấp cụm. Bạn có thể đọc dữ liệu này như trên. Ngoài ra, nếu số lượng ít, chúng có thể được nhập như dưới đây dưới dạng một tibble. Trong mọi trường hợp, bạn sẽ cần có một cột với mã định danh cụm khớp với dữ liệu khảo sát của bạn và một cột khác với số lượng hộ gia đình ở từng cụm.\n\n## define the number of households in each cluster\ncluster_counts &lt;- tibble(cluster = c(\"village_1\", \"village_2\", \"village_3\", \"village_4\", \n                                     \"village_5\", \"village_6\", \"village_7\", \"village_8\",\n                                     \"village_9\", \"village_10\"), \n                         households = c(700, 400, 600, 500, 300, \n                                        800, 700, 400, 500, 500))\n\n\n\nLàm sạch dữ liệu\nDưới đây đảm bảo rằng cột ngày ở định dạng thích hợp. Có một số cách khác để thực hiện việc này (xem chương Làm việc với ngày tháng để biết chi tiết), tuy nhiên sử dụng từ điển để xác định ngày sẽ nhanh chóng và dễ dàng.\nChúng tôi cũng tạo một biến nhóm tuổi bằng cách sử dụng hàm age_categories() từ epikit - xem phần Làm sạch dữ liệu của sổ tay để biết chi tiết. Ngoài ra, chúng tôi tạo một biến ký tự xác định các cụm khác nhau nằm trong khu vực nào.\nCuối cùng, chúng tôi mã hóa lại tất cả các biến yes/no thành các biến TRUE/FALSE - nếu không, các biến này không thể được sử dụng bởi các hàm tính tỷ lệ trong package survey.\n\n## select the date variable names from the dictionary \nDATEVARS &lt;- survey_dict %&gt;% \n  filter(type == \"date\") %&gt;% \n  filter(name %in% names(survey_data)) %&gt;% \n  ## filter to match the column names of your data\n  pull(name) # select date vars\n  \n## change to dates \nsurvey_data &lt;- survey_data %&gt;%\n  mutate(across(all_of(DATEVARS), as.Date))\n\n\n## add those with only age in months to the year variable (divide by twelve)\nsurvey_data &lt;- survey_data %&gt;% \n  mutate(age_years = if_else(is.na(age_years), \n                             age_months / 12, \n                             age_years))\n\n## define age group variable\nsurvey_data &lt;- survey_data %&gt;% \n     mutate(age_group = age_categories(age_years, \n                                    breakers = c(0, 3, 15, 30, 45)\n                                    ))\n\n\n## create a character variable based off groups of a different variable \nsurvey_data &lt;- survey_data %&gt;% \n  mutate(health_district = case_when(\n    cluster_number %in% c(1:5) ~ \"district_a\", \n    TRUE ~ \"district_b\"\n  ))\n\n\n## select the yes/no variable names from the dictionary \nYNVARS &lt;- survey_dict %&gt;% \n  filter(type == \"yn\") %&gt;% \n  filter(name %in% names(survey_data)) %&gt;% \n  ## filter to match the column names of your data\n  pull(name) # select yn vars\n  \n## change to dates \nsurvey_data &lt;- survey_data %&gt;%\n  mutate(across(all_of(YNVARS), \n                str_detect, \n                pattern = \"yes\"))\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `across(all_of(YNVARS), str_detect, pattern = \"yes\")`.\nCaused by warning:\n! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\nSupply arguments directly to `.fns` through an anonymous function instead.\n\n  # Previously\n  across(a:b, mean, na.rm = TRUE)\n\n  # Now\n  across(a:b, \\(x) mean(x, na.rm = TRUE))",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Phân tích khảo sát</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.vn.html#dữ-liệu-khảo-sát",
    "href": "new_pages/survey_analysis.vn.html#dữ-liệu-khảo-sát",
    "title": "26  Phân tích khảo sát",
    "section": "26.3 Dữ liệu khảo sát",
    "text": "26.3 Dữ liệu khảo sát\nCó rất nhiều thiết kế lấy mẫu khác nhau có thể được sử dụng cho các khảo sát. Ở đây chúng tôi sẽ trình bày code cho: - Phân tầng - Cụm - Cụm phân tầng\nNhư đã mô tả ở trên (tùy thuộc vào cách bạn thiết kế bảng câu hỏi của mình), dữ liệu cho mỗi cấp độ sẽ được xuất dưới dạng bộ dữ liệu riêng biệt từ Kobo. Trong ví dụ của chúng tôi, có một cấp cho các hộ gia đình và một cấp cho các cá nhân trong các hộ gia đình đó.\nHai cấp độ này được liên kết bởi một mã định danh duy nhất. Đối với bộ dữ liệu Kobo, biến này là “_index” ở cấp hộ gia đình, khớp với “_parent_index” ở cấp cá nhân. Thao tác này sẽ tạo các hàng mới cho hộ gia đình với mỗi cá nhân phù hợp, hãy xem chương Nối dữ liệu để biết chi tiết.\n\n## join the individual and household data to form a complete data set\nsurvey_data &lt;- left_join(survey_data_hh, \n                         survey_data_indiv,\n                         by = c(\"_index\" = \"_parent_index\"))\n\n\n## create a unique identifier by combining indeces of the two levels \nsurvey_data &lt;- survey_data %&gt;% \n     mutate(uid = str_glue(\"{index}_{index_y}\"))",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Phân tích khảo sát</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.vn.html#thời-gian-quan-sát",
    "href": "new_pages/survey_analysis.vn.html#thời-gian-quan-sát",
    "title": "26  Phân tích khảo sát",
    "section": "26.4 Thời gian quan sát",
    "text": "26.4 Thời gian quan sát\nĐối với các cuộc khảo sát về tỷ lệ tử vong, chúng ta muốn biết mỗi cá nhân đã có mặt tại địa điểm trong bao lâu để có thể tính toán tỷ lệ tử vong thích hợp trong khoảng thời gian nghiên cứu. Điều này không áp dụng đối với tất cả các cuộc điều tra, nhưng đặc biệt rất quan trọng đối với các cuộc điều tra tử vong vì chúng thường được khảo sát ở các quần thể di động hoặc di cư.\nĐể làm điều này, trước tiên chúng ta xác định khoảng thời gian quan tâm, còn được gọi là khoảng thời gian hồi cứu (tức là thời gian mà những người tham gia được yêu cầu báo cáo khi trả lời câu hỏi). Sau đó, chúng ta có thể sử dụng khoảng thời gian này để đặt các ngày không thích hợp thành giá trị missing, vd: các trường hợp tử vong được báo cáo ngoài khoảng thời gian quan tâm.\n\n## set the start/end of recall period\n## can be changed to date variables from dataset \n## (e.g. arrival date & date questionnaire)\nsurvey_data &lt;- survey_data %&gt;% \n  mutate(recall_start = as.Date(\"2018-01-01\"), \n         recall_end   = as.Date(\"2018-05-01\")\n  )\n\n\n# set inappropriate dates to NA based on rules \n## e.g. arrivals before start, departures departures after end\nsurvey_data &lt;- survey_data %&gt;%\n      mutate(\n           arrived_date = if_else(arrived_date &lt; recall_start, \n                                 as.Date(NA),\n                                  arrived_date),\n           birthday_date = if_else(birthday_date &lt; recall_start,\n                                  as.Date(NA),\n                                  birthday_date),\n           left_date = if_else(left_date &gt; recall_end,\n                              as.Date(NA),\n                               left_date),\n           death_date = if_else(death_date &gt; recall_end,\n                               as.Date(NA),\n                               death_date)\n           )\n\nSau đó, chúng ta có thể sử dụng các biến ngày của mình để xác định ngày bắt đầu và ngày kết thúc cho từng cá nhân. Chúng ta có thể sử dụng hàm find_start_date() từ sitrep để xác định ngày bắt đầu và sau đó sử dụng hàm đó để tính toán sự khác biệt giữa các ngày (người-thời gian).\nNgày bắt đầu: Sự kiện phù hợp tới sớm nhất trong khoảng thời gian hồi cứu của bạn. Hoặc là ngày bắt đầu thời gian hồi cứu của bạn (mà bạn xác định trước) hoặc ngày sau khi bắt đầu hồi cứu nếu có (ví dụ: đi đến hoặc sinh ra)\nNgày kết thúc: Sự kiện dừng lại thích hợp sớm nhất trong thời gian hồi cứu của bạn. Hoặc là ngày kết thúc thời gian hồi cứu hoặc ngày trước khi kết thúc hồi cứu nếu có (ví dụ: rời đi, tử vong)\n\n## create new variables for start and end dates/causes\nsurvey_data &lt;- survey_data %&gt;% \n     ## choose earliest date entered in survey\n     ## from births, household arrivals, and camp arrivals \n     find_start_date(\"birthday_date\",\n                  \"arrived_date\",\n                  period_start = \"recall_start\",\n                  period_end   = \"recall_end\",\n                  datecol      = \"startdate\",\n                  datereason   = \"startcause\" \n                 ) %&gt;%\n     ## choose earliest date entered in survey\n     ## from camp departures, death and end of the study\n     find_end_date(\"left_date\",\n                \"death_date\",\n                period_start = \"recall_start\",\n                period_end   = \"recall_end\",\n                datecol      = \"enddate\",\n                datereason   = \"endcause\" \n               )\n\n\n## label those that were present at the start/end (except births/deaths)\nsurvey_data &lt;- survey_data %&gt;% \n     mutate(\n       ## fill in start date to be the beginning of recall period (for those empty) \n       startdate = if_else(is.na(startdate), recall_start, startdate), \n       ## set the start cause to present at start if equal to recall period \n       ## unless it is equal to the birth date \n       startcause = if_else(startdate == recall_start & startcause != \"birthday_date\",\n                              \"Present at start\", startcause), \n       ## fill in end date to be end of recall period (for those empty) \n       enddate = if_else(is.na(enddate), recall_end, enddate), \n       ## set the end cause to present at end if equall to recall end \n       ## unless it is equal to the death date\n       endcause = if_else(enddate == recall_end & endcause != \"death_date\", \n                            \"Present at end\", endcause))\n\n\n## Define observation time in days\nsurvey_data &lt;- survey_data %&gt;% \n  mutate(obstime = as.numeric(enddate - startdate))",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Phân tích khảo sát</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.vn.html#áp-dụng-trọng-số",
    "href": "new_pages/survey_analysis.vn.html#áp-dụng-trọng-số",
    "title": "26  Phân tích khảo sát",
    "section": "26.5 Áp dụng trọng số",
    "text": "26.5 Áp dụng trọng số\nĐiều quan trọng là bạn phải loại bỏ các đối tượng có lỗi trước khi thêm trọng số khảo sát. Ví dụ: nếu bạn có các quan sát với thời gian theo dõi âm, bạn sẽ cần kiểm tra các đối tượng đó (bạn có thể thực hiện việc này với hàm assert_positive_timespan() từ sitrep. Một điều khác là nếu bạn muốn bỏ các hàng trống (ví dụ: với drop_na(uid)) hoặc xóa các bản ghi trùng lặp (xem chương Loại bỏ trùng lặp trong sổ tay này để biết thêm chi tiết). Những đối tượng không có sự đồng ý tham gia nghiên cứu cũng cần phải bị xóa.\nTrong ví dụ này, chúng ta lọc các trường hợp muốn loại bỏ và lưu trữ chúng trong một dataframe riêng - theo cách này, chúng ta có thể mô tả những trường hợp đã bị loại khỏi khảo sát. Sau đó, chúng ta sử dụng hàm anti_join() từ dplyr để xóa những trường hợp bị loại bỏ này khỏi dữ liệu khảo sát của chúng ta.\nNGUY HIỂM: Bạn không thể có giá trị missing trong biến trọng số của mình hoặc bất kỳ biến nào có liên quan đến thiết kế khảo sát của bạn (ví dụ: tuổi, giới tính, biến phân tầng hoặc cụm).\n\n## store the cases that you drop so you can describe them (e.g. non-consenting \n## or wrong village/cluster)\ndropped &lt;- survey_data %&gt;% \n  filter(!consent | is.na(startdate) | is.na(enddate) | village_name == \"other\")\n\n## use the dropped cases to remove the unused rows from the survey data set  \nsurvey_data &lt;- anti_join(survey_data, dropped, by = names(dropped))\n\nNhư đã đề cập ở trên, chúng tôi trình bày cách thêm trọng số cho ba thiết kế nghiên cứu khác nhau (phân tầng, phân cụm và cụm phân tầng). Chúng yêu cầu thông tin về dân số gốc và/hoặc các cụm được khảo sát. Chúng tôi sẽ sử dụng code cụm phân tầng cho ví dụ này, nhưng hãy sử dụng code nào thích hợp nhất cho thiết kế nghiên cứu của bạn.\n\n# stratified ------------------------------------------------------------------\n# create a variable called \"surv_weight_strata\"\n# contains weights for each individual - by age group, sex and health district\nsurvey_data &lt;- add_weights_strata(x = survey_data,\n                                         p = population,\n                                         surv_weight = \"surv_weight_strata\",\n                                         surv_weight_ID = \"surv_weight_ID_strata\",\n                                         age_group, sex, health_district)\n\n## cluster ---------------------------------------------------------------------\n\n# get the number of people of individuals interviewed per household\n# adds a variable with counts of the household (parent) index variable\nsurvey_data &lt;- survey_data %&gt;%\n  add_count(index, name = \"interviewed\")\n\n\n## create cluster weights\nsurvey_data &lt;- add_weights_cluster(x = survey_data,\n                                          cl = cluster_counts,\n                                          eligible = member_number,\n                                          interviewed = interviewed,\n                                          cluster_x = village_name,\n                                          cluster_cl = cluster,\n                                          household_x = index,\n                                          household_cl = households,\n                                          surv_weight = \"surv_weight_cluster\",\n                                          surv_weight_ID = \"surv_weight_ID_cluster\",\n                                          ignore_cluster = FALSE,\n                                          ignore_household = FALSE)\n\n\n# stratified and cluster ------------------------------------------------------\n# create a survey weight for cluster and strata\nsurvey_data &lt;- survey_data %&gt;%\n  mutate(surv_weight_cluster_strata = surv_weight_strata * surv_weight_cluster)",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Phân tích khảo sát</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.vn.html#đối-tượng-theo-thiết-kế-nghiên-cứu",
    "href": "new_pages/survey_analysis.vn.html#đối-tượng-theo-thiết-kế-nghiên-cứu",
    "title": "26  Phân tích khảo sát",
    "section": "26.6 Đối tượng theo thiết kế nghiên cứu",
    "text": "26.6 Đối tượng theo thiết kế nghiên cứu\nTạo đối tượng khảo sát theo thiết kế nghiên cứu của bạn. Sử dụng theo cách tương tự như dataframe để tính toán trọng số cho tỷ lệ, v.v. Đảm bảo rằng tất cả các biến cần thiết đã được tạo trước bước này.\nCó bốn tùy chọn, hãy đánh dấu thành bình luận những tùy chọn bạn không sử dụng: - Ngẫu nhiên đơn - Phân tầng - Cụm - Cụm phân tầng\nĐối với mẫu này - chúng ta sẽ giả vờ rằng chúng ta nhóm cụm các cuộc khảo sát theo hai tầng riêng biệt (khu vực A và B). Vì vậy, để có được ước tính tổng thể, chúng ta cần có trọng số kết hợp của cụm và tầng.\nNhư đã đề cập trước đây, có hai packages có sẵn để thực hiện việc này. Package cổ điển là survey và một package gọn hơn được gọi là srvyr giúp tạo các đối tượng và hàm theo phong cách tidyverse. Chúng tôi sẽ trình bày cả hai, nhưng lưu ý rằng hầu hết code trong chương này sẽ sử dụng các đối tượng dựa trên srvyr. Một ngoại lệ là package gtsummary chỉ chấp nhận các đối tượng từ package survey.\n\n26.6.1 Package Survey\nPackage survey sử dụng hiệu quả code base R nên không thể sử dụng các pipes (%&gt;%) hoặc các cú pháp dplyr khác. Với package survey, chúng tôi sử dụng hàm svydesign() để xác định đối tượng khảo sát với các cụm, trọng số và tầng thích hợp.\nLƯU Ý: chúng ta cần sử dụng dấu ngã (~) trước các biến, điều này là do package sử dụng cú pháp base R để gán các biến dựa trên công thức.\n\n# simple random ---------------------------------------------------------------\nbase_survey_design_simple &lt;- svydesign(ids = ~1, # 1 for no cluster ids\n                   weights = NULL,               # No weight added\n                   strata = NULL,                # sampling was simple (no strata)\n                   data = survey_data            # have to specify the dataset\n                  )\n\n## stratified ------------------------------------------------------------------\nbase_survey_design_strata &lt;- svydesign(ids = ~1,  # 1 for no cluster ids\n                   weights = ~surv_weight_strata, # weight variable created above\n                   strata = ~health_district,     # sampling was stratified by district\n                   data = survey_data             # have to specify the dataset\n                  )\n\n# cluster ---------------------------------------------------------------------\nbase_survey_design_cluster &lt;- svydesign(ids = ~village_name, # cluster ids\n                   weights = ~surv_weight_cluster, # weight variable created above\n                   strata = NULL,                 # sampling was simple (no strata)\n                   data = survey_data              # have to specify the dataset\n                  )\n\n# stratified cluster ----------------------------------------------------------\nbase_survey_design &lt;- svydesign(ids = ~village_name,      # cluster ids\n                   weights = ~surv_weight_cluster_strata, # weight variable created above\n                   strata = ~health_district,             # sampling was stratified by district\n                   data = survey_data                     # have to specify the dataset\n                  )\n\n\n\n26.6.2 Package Srvyr\nVới package srvyr, chúng ta có thể sử dụng hàm as_survey_design(), nó có tất cả các đối số tương tự như trên nhưng cho phép dùng các pipes (%&gt;%), và vì vậy chúng ta không cần sử dụng dấu ngã (~).\n\n## simple random ---------------------------------------------------------------\nsurvey_design_simple &lt;- survey_data %&gt;% \n  as_survey_design(ids = 1, # 1 for no cluster ids \n                   weights = NULL, # No weight added\n                   strata = NULL # sampling was simple (no strata)\n                  )\n## stratified ------------------------------------------------------------------\nsurvey_design_strata &lt;- survey_data %&gt;%\n  as_survey_design(ids = 1, # 1 for no cluster ids\n                   weights = surv_weight_strata, # weight variable created above\n                   strata = health_district # sampling was stratified by district\n                  )\n## cluster ---------------------------------------------------------------------\nsurvey_design_cluster &lt;- survey_data %&gt;%\n  as_survey_design(ids = village_name, # cluster ids\n                   weights = surv_weight_cluster, # weight variable created above\n                   strata = NULL # sampling was simple (no strata)\n                  )\n\n## stratified cluster ----------------------------------------------------------\nsurvey_design &lt;- survey_data %&gt;%\n  as_survey_design(ids = village_name, # cluster ids\n                   weights = surv_weight_cluster_strata, # weight variable created above\n                   strata = health_district # sampling was stratified by district\n                  )",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Phân tích khảo sát</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.vn.html#phân-tích-mô-tả",
    "href": "new_pages/survey_analysis.vn.html#phân-tích-mô-tả",
    "title": "26  Phân tích khảo sát",
    "section": "26.7 Phân tích mô tả",
    "text": "26.7 Phân tích mô tả\nPhân tích mô tả và trực quan hóa cơ bản được đề cập nhiều trong các chương khác của cuốn sổ tay, vì vậy chúng tôi sẽ không đi sâu vào nó ở đây. Để biết chi tiết, hãy xem các chương về Bảng mô tả, Các kiểm định thống kê cơ bản, Trình bày bảng, ggplot cơ bản và Báo cáo với R Markdown.\nTrong phần này, chúng ta sẽ tập trung vào cách điều tra sai số trong mẫu của bạn và trực quan hóa chúng. Chúng ta cũng sẽ xem xét việc trực quan hóa dòng dân cư trong bối cảnh khảo sát bằng cách sử dụng sơ đồ luồng alluvial/sankey.\nNhìn chung, bạn nên xem xét đưa vào các phân tích mô tả sau:\n\nSố cụm, hộ gia đình và cá nhân cuối cùng được đưa vào\nSố lượng cá nhân bị loại trừ và lý do loại trừ\nTrung vị (biên độ) số hộ gia đình trên một cụm và số cá thể trên một hộ gia đình\n\n\n26.7.1 Sai số chọn mẫu\nSo sánh tỷ lệ trong từng nhóm tuổi giữa mẫu của bạn và quần thể gốc. Điều này rất quan trọng để có thể làm nổi bật sai số chọn mẫu tiềm ẩn. Tương tự, bạn có thể lặp lại điều này khi xem xét sự phân bố theo giới tính.\nLưu ý rằng các giá trị p từ phép kiểm định hai nhóm chỉ mang tính chất chỉ dẫn và phần thảo luận mang tính mô tả (hoặc trực quan với tháp tuổi bên dưới) về các phân bố trong mẫu nghiên cứu của bạn so với quần thể gốc là quan trọng. Đó là bởi vì việc tăng cỡ mẫu sẽ hay dẫn đến những khác biệt có thể không liên quan sau khi áp dụng trọng số vào dữ liệu của bạn.\n\n## counts and props of the study population\nag &lt;- survey_data %&gt;% \n  group_by(age_group) %&gt;% \n  drop_na(age_group) %&gt;% \n  tally() %&gt;% \n  mutate(proportion = n / sum(n), \n         n_total = sum(n))\n\n## counts and props of the source population\npropcount &lt;- population %&gt;% \n  group_by(age_group) %&gt;%\n    tally(population) %&gt;%\n    mutate(proportion = n / sum(n))\n\n## bind together the columns of two tables, group by age, and perform a \n## binomial test to see if n/total is significantly different from population\n## proportion.\n  ## suffix here adds to text to the end of columns in each of the two datasets\nleft_join(ag, propcount, by = \"age_group\", suffix = c(\"\", \"_pop\")) %&gt;%\n  group_by(age_group) %&gt;%\n  ## broom::tidy(binom.test()) makes a data frame out of the binomial test and\n  ## will add the variables p.value, parameter, conf.low, conf.high, method, and\n  ## alternative. We will only use p.value here. You can include other\n  ## columns if you want to report confidence intervals\n  mutate(binom = list(broom::tidy(binom.test(n, n_total, proportion_pop)))) %&gt;%\n  unnest(cols = c(binom)) %&gt;% # important for expanding the binom.test data frame\n  mutate(proportion_pop = proportion_pop * 100) %&gt;%\n  ## Adjusting the p-values to correct for false positives \n  ## (because testing multiple age groups). This will only make \n  ## a difference if you have many age categories\n  mutate(p.value = p.adjust(p.value, method = \"holm\")) %&gt;%\n                      \n  ## Only show p-values over 0.001 (those under report as &lt;0.001)\n  mutate(p.value = ifelse(p.value &lt; 0.001, \n                          \"&lt;0.001\", \n                          as.character(round(p.value, 3)))) %&gt;% \n  \n  ## rename the columns appropriately\n  select(\n    \"Age group\" = age_group,\n    \"Study population (n)\" = n,\n    \"Study population (%)\" = proportion,\n    \"Source population (n)\" = n_pop,\n    \"Source population (%)\" = proportion_pop,\n    \"P-value\" = p.value\n  )\n\n# A tibble: 5 × 6\n# Groups:   Age group [5]\n  `Age group` `Study population (n)` `Study population (%)`\n  &lt;chr&gt;                        &lt;int&gt;                  &lt;dbl&gt;\n1 0-2                             12                 0.0256\n2 3-14                            42                 0.0896\n3 15-29                           64                 0.136 \n4 30-44                           52                 0.111 \n5 45+                            299                 0.638 \n# ℹ 3 more variables: `Source population (n)` &lt;dbl&gt;,\n#   `Source population (%)` &lt;dbl&gt;, `P-value` &lt;chr&gt;\n\n\n\n\n26.7.2 Tháp dân số\nTháp dân số (hoặc tháp tuổi-giới) là một cách dễ dàng để trực quan hóa sự phân bố trong quần thể khảo sát của bạn. Cũng nên xem xét việc tạo [Bảng mô tả] về độ tuổi và giới tính theo tầng khảo sát. Chúng ta sẽ minh họa bằng package apyramid vì nó cho phép các tỷ lệ được áp dụng trọng số sử dụng đối tượng theo thiết kế nghiên cứu mà chúng ta đã tạo ở trên. Các tùy chọn khác để tạo Tháp dân số được đề cập nhiều hơn trong chương đó của sổ tay. Chúng ta cũng sẽ sử dụng một hàm trong package apyramid là age_pyramid() để code ngắn gọn hơn một biểu đồ theo tỷ lệ.\nGiống như với phép kiểm định sự khác biệt giữa hai nhóm chuẩn được thảo luận ở trên trong phần sai số chọn mẫu, ở đây chúng ta quan tâm đến việc trực quan hóa liệu quần thể mẫu của chúng ta có khác biệt đáng kể so với quần thể gốc hay không, và liệu trọng số có sửa chữa được sự khác biệt này hay không. Để làm điều này, chúng ta sẽ sử dụng package patchwork để hiển thị các biểu đồ tạo bởi ggplot song song với nhau; chi tiết xem phần kết hợp các đồ thị trong chương Các mẹo với ggplot của sổ tay này. Chúng ta sẽ trực quan hóa quần thể gốc, quần thể khảo sát không trọng số và quần thể khảo sát có trọng số. Bạn cũng có thể xem xét trực quan theo từng tầng của khảo sát - bằng cách sử dụng đối số stack_by  = \"health_district\" trong ví dụ của chúng tôi ở đây (xem ?plot_age_pyramid để biết chi tiết).\nLưu ý: Trục x và y được lật ngược trong tháp\n\n## define x-axis limits and labels ---------------------------------------------\n## (update these numbers to be the values for your graph)\nmax_prop &lt;- 35      # choose the highest proportion you want to show \nstep &lt;- 5           # choose the space you want beween labels \n\n## this part defines vector using the above numbers with axis breaks\nbreaks &lt;- c(\n    seq(max_prop/100 * -1, 0 - step/100, step/100), \n    0, \n    seq(0 + step / 100, max_prop/100, step/100)\n    )\n\n## this part defines vector using the above numbers with axis limits\nlimits &lt;- c(max_prop/100 * -1, max_prop/100)\n\n## this part defines vector using the above numbers with axis labels\nlabels &lt;-  c(\n      seq(max_prop, step, -step), \n      0, \n      seq(step, max_prop, step)\n    )\n\n\n## create plots individually  --------------------------------------------------\n\n## plot the source population \n## nb: this needs to be collapsed for the overall population (i.e. removing health districts)\nsource_population &lt;- population %&gt;%\n  ## ensure that age and sex are factors\n  mutate(age_group = factor(age_group, \n                            levels = c(\"0-2\", \n                                       \"3-14\", \n                                       \"15-29\",\n                                       \"30-44\", \n                                       \"45+\")), \n         sex = factor(sex)) %&gt;% \n  group_by(age_group, sex) %&gt;% \n  ## add the counts for each health district together \n  summarise(population = sum(population)) %&gt;% \n  ## remove the grouping so can calculate overall proportion\n  ungroup() %&gt;% \n  mutate(proportion = population / sum(population)) %&gt;% \n  ## plot pyramid \n  age_pyramid(\n            age_group = age_group, \n            split_by = sex, \n            count = proportion, \n            proportional = TRUE) +\n  ## only show the y axis label (otherwise repeated in all three plots)\n  labs(title = \"Source population\", \n       y = \"\", \n       x = \"Age group (years)\") + \n  ## make the x axis the same for all plots \n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n  \n  \n## plot the unweighted sample population \nsample_population &lt;- age_pyramid(survey_data, \n                 age_group = \"age_group\", \n                 split_by = \"sex\",\n                 proportion = TRUE) + \n  ## only show the x axis label (otherwise repeated in all three plots)\n  labs(title = \"Unweighted sample population\", \n       y = \"Proportion (%)\", \n       x = \"\") + \n  ## make the x axis the same for all plots \n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n\n\n## plot the weighted sample population \nweighted_population &lt;- survey_design %&gt;% \n  ## make sure the variables are factors\n  mutate(age_group = factor(age_group), \n         sex = factor(sex)) %&gt;%\n  age_pyramid(\n    age_group = \"age_group\",\n    split_by = \"sex\", \n    proportion = TRUE) +\n  ## only show the x axis label (otherwise repeated in all three plots)\n  labs(title = \"Weighted sample population\", \n       y = \"\", \n       x = \"\")  + \n  ## make the x axis the same for all plots \n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n\n## combine all three plots  ----------------------------------------------------\n## combine three plots next to eachother using + \nsource_population + sample_population + weighted_population + \n  ## only show one legend and define theme \n  ## note the use of & for combining theme with plot_layout()\n  plot_layout(guides = \"collect\") & \n  theme(legend.position = \"bottom\",                    # move legend to bottom\n        legend.title = element_blank(),                # remove title\n        text = element_text(size = 18),                # change text size\n        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1) # turn x-axis text\n       )\n\n\n\n\n\n\n\n\n\n\n26.7.3 Sơ đồ alluvial/sankey\nTrực quan điểm bắt đầu và kết quả của từng cá nhân có thể rất hữu ích để có được cái nhìn tổng quan. Có một ứng dụng khá rõ ràng cho quần thể di động, tuy nhiên có rất nhiều ứng dụng khác như nhóm thuần tập hoặc bất kỳ tình huống nào khác trong đó có sự chuyển đổi ở các trạng thái của các cá nhân. Các sơ đồ này có một số tên khác nhau bao gồm các tập hợp alluvial, sankey và parallel - chi tiết có trong chương sổ tay về Sơ đồ và biểu đồ.\n\n## summarize data\nflow_table &lt;- survey_data %&gt;%\n  count(startcause, endcause, sex) %&gt;%  # get counts \n  gather_set_data(x = c(\"startcause\", \"endcause\"))     # change format for plotting\n\n\n## plot your dataset \n  ## on the x axis is the start and end causes\n  ## gather_set_data generates an ID for each possible combination\n  ## splitting by y gives the possible start/end combos\n  ## value as n gives it as counts (could also be changed to proportion)\nggplot(flow_table, aes(x, id = id, split = y, value = n)) +\n  ## colour lines by sex \n  geom_parallel_sets(aes(fill = sex), alpha = 0.5, axis.width = 0.2) +\n  ## fill in the label boxes grey\n  geom_parallel_sets_axes(axis.width = 0.15, fill = \"grey80\", color = \"grey80\") +\n  ## change text colour and angle (needs to be adjusted)\n  geom_parallel_sets_labels(color = \"black\", angle = 0, size = 5) +\n  ## remove axis labels\n  theme_void()+\n  ## move legend to bottom\n  theme(legend.position = \"bottom\")",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Phân tích khảo sát</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.vn.html#tỷ-lệ-được-áp-dụng-trọng-số",
    "href": "new_pages/survey_analysis.vn.html#tỷ-lệ-được-áp-dụng-trọng-số",
    "title": "26  Phân tích khảo sát",
    "section": "26.8 Tỷ lệ được áp dụng trọng số",
    "text": "26.8 Tỷ lệ được áp dụng trọng số\nPhần này sẽ trình bày chi tiết cách tạo bảng cho số lượng và tỷ lệ được áp dụng trọng số, với khoảng tin cậy và hệ số thiết kế liên quan. Có bốn tùy chọn khác nhau sử dụng các hàm từ các packages sau: survey, srvyr, sitrep và gtsummary. Để tạo ra một bảng dịch tễ học tiêu chuẩn với code tối giản, chúng tôi khuyên bạn nên dùng hàm sitrep - là một hàm có code gọn hơn của srvyr; Tuy nhiên, lưu ý rằng hàm này chưa có trên CRAN và có thể thay đổi trong tương lai. Mặt khác, code của survey có thể là code ổn định nhất trong thời gian dài, trong khi srvyr sẽ phù hợp nhất đối với các luồng công việc sử dụng tidyverse. Mặc dù các hàm gtsummary có rất nhiều tiềm năng, nhưng chúng vẫn đang được thử nghiệm và chưa hoàn thiện tại thời điểm viết chương này.\n\n26.8.1 Package survey\nChúng ta có thể sử dụng hàm svyciprop() từ survey để lấy tỷ lệ có trọng số và khoảng tin cậy 95% đi kèm. Một hệ số thiết kế thích hợp có thể được trích xuất bằng cách sử dụng hàm svymean() chứ không phải hàm svyprop(). Cần lưu ý rằng svyprop() dường như chỉ chấp nhận các biến có giá trị từ 0 đến 1 (hoặc TRUE/FALSE), vì vậy các biến phân loại sẽ không hoạt động.\nLƯU Ý: Các hàm từ survey cũng chấp nhận các đối tượng thiết kế từ srvyr, nhưng ở đây chúng tôi đã sử dụng đối tượng thiết kế từ package survey với mục đích tạo sự nhất quán\n\n## produce weighted counts \nsvytable(~died, base_survey_design)\n\ndied\n     FALSE       TRUE \n1406244.43   76213.01 \n\n## produce weighted proportions\nsvyciprop(~died, base_survey_design, na.rm = T)\n\n              2.5% 97.5%\ndied 0.0514 0.0208  0.12\n\n## get the design effect \nsvymean(~died, base_survey_design, na.rm = T, deff = T) %&gt;% \n  deff()\n\ndiedFALSE  diedTRUE \n 3.755508  3.755508 \n\n\nChúng ta có thể kết hợp các hàm từ survey được hiển thị ở trên với một hàm mà chúng ta tự định nghĩa như bên dưới, được gọi là svy_prop; và sau đó chúng ta có thể sử dụng hàm đó cùng với hàm map() từ package purrr để lặp qua một số biến và tạo một bảng. Xem chương Lặp, vòng lặp, và danh sách để biết chi tiết về purrr.\n\n# Define function to calculate weighted counts, proportions, CI and design effect\n# x is the variable in quotation marks \n# design is your survey design object\n\nsvy_prop &lt;- function(design, x) {\n  \n  ## put the variable of interest in a formula \n  form &lt;- as.formula(paste0( \"~\" , x))\n  ## only keep the TRUE column of counts from svytable\n  weighted_counts &lt;- svytable(form, design)[[2]]\n  ## calculate proportions (multiply by 100 to get percentages)\n  weighted_props &lt;- svyciprop(form, design, na.rm = TRUE) * 100\n  ## extract the confidence intervals and multiply to get percentages\n  weighted_confint &lt;- confint(weighted_props) * 100\n  ## use svymean to calculate design effect and only keep the TRUE column\n  design_eff &lt;- deff(svymean(form, design, na.rm = TRUE, deff = TRUE))[[TRUE]]\n  \n  ## combine in to one data frame\n  full_table &lt;- cbind(\n    \"Variable\"        = x,\n    \"Count\"           = weighted_counts,\n    \"Proportion\"      = weighted_props,\n    weighted_confint, \n    \"Design effect\"   = design_eff\n    )\n  \n  ## return table as a dataframe\n  full_table &lt;- data.frame(full_table, \n             ## remove the variable names from rows (is a separate column now)\n             row.names = NULL)\n  \n  ## change numerics back to numeric\n  full_table[ , 2:6] &lt;- as.numeric(full_table[, 2:6])\n  \n  ## return dataframe\n  full_table\n}\n\n## iterate over several variables to create a table \npurrr::map(\n  ## define variables of interest\n  c(\"left\", \"died\", \"arrived\"), \n  ## state function using and arguments for that function (design)\n  svy_prop, design = base_survey_design) %&gt;% \n  ## collapse list in to a single data frame\n  bind_rows() %&gt;% \n  ## round \n  mutate(across(where(is.numeric), round, digits = 1))\n\n  Variable    Count Proportion X2.5. X97.5. Design.effect\n1     left 701199.1       47.3  39.2   55.5           2.4\n2     died  76213.0        5.1   2.1   12.1           3.8\n3  arrived 761799.0       51.4  40.9   61.7           3.9\n\n\n\n\n26.8.2 Package srvyr\nVới srvyr chúng ta có thể sử dụng cú pháp của package dplyr để tạo một bảng. Lưu ý rằng hàm survey_mean() được sử dụng, đối số tỷ lệ được chỉ định và hàm tương tự cũng được sử dụng để tính toán hệ số thiết kế. Điều này là do srvyr bao gồm cả hai hàm svyciprop() và svymean() của package survey được sử dụng trong phần trên.\nLƯU Ý: Có vẻ như không thể lấy tỷ lệ từ các biến phân loại bằng srvyr, nếu bạn cần điều này, hãy xem phần bên dưới sử dụng sitrep\n\n## use the srvyr design object\nsurvey_design %&gt;% \n  summarise(\n    ## produce the weighted counts \n    counts = survey_total(died), \n    ## produce weighted proportions and confidence intervals \n    ## multiply by 100 to get a percentage \n    props = survey_mean(died, \n                        proportion = TRUE, \n                        vartype = \"ci\") * 100, \n    ## produce the design effect \n    deff = survey_mean(died, deff = TRUE)) %&gt;% \n  ## only keep the rows of interest\n  ## (drop standard errors and repeat proportion calculation)\n  select(counts, props, props_low, props_upp, deff_deff)\n\n# A tibble: 1 × 5\n  counts props props_low props_upp deff_deff\n   &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1 76213.  5.14      2.08      12.1      3.76\n\n\nỞ đây, chúng ta cũng có thể viết một hàm để sau đó lặp qua nhiều biến bằng cách sử dụng package purrr. Xem chương Lặp, vòng lặp, và danh sách trong sổ tay này để biết chi tiết về purrr.\n\n# Define function to calculate weighted counts, proportions, CI and design effect\n# design is your survey design object\n# x is the variable in quotation marks \n\n\nsrvyr_prop &lt;- function(design, x) {\n  \n  summarise(\n    ## using the survey design object\n    design, \n    ## produce the weighted counts \n    counts = survey_total(.data[[x]]), \n    ## produce weighted proportions and confidence intervals \n    ## multiply by 100 to get a percentage \n    props = survey_mean(.data[[x]], \n                        proportion = TRUE, \n                        vartype = \"ci\") * 100, \n    ## produce the design effect \n    deff = survey_mean(.data[[x]], deff = TRUE)) %&gt;% \n  ## add in the variable name\n  mutate(variable = x) %&gt;% \n  ## only keep the rows of interest\n  ## (drop standard errors and repeat proportion calculation)\n  select(variable, counts, props, props_low, props_upp, deff_deff)\n  \n}\n  \n\n## iterate over several variables to create a table \npurrr::map(\n  ## define variables of interest\n  c(\"left\", \"died\", \"arrived\"), \n  ## state function using and arguments for that function (design)\n  ~srvyr_prop(.x, design = survey_design)) %&gt;% \n  ## collapse list in to a single data frame\n  bind_rows()\n\n# A tibble: 3 × 6\n  variable  counts props props_low props_upp deff_deff\n  &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1 left     701199. 47.3      39.2       55.5      2.38\n2 died      76213.  5.14      2.08      12.1      3.76\n3 arrived  761799. 51.4      40.9       61.7      3.93\n\n\n\n\n26.8.3 Package sitrep\nHàm tab_survey() từ sitrep là một hàm gọn hơn cho srvyr, cho phép bạn tạo các bảng có trọng số với code tối giản. Nó cũng cho phép bạn tính toán tỷ lệ có trọng số cho các biến phân loại.\n\n## using the survey design object\nsurvey_design %&gt;% \n  ## pass the names of variables of interest unquoted\n  tab_survey(arrived, left, died, education_level,\n             deff = TRUE,   # calculate the design effect\n             pretty = TRUE  # merge the proportion and 95%CI\n             )\n\nWarning: removing 257 missing value(s) from `education_level`\n\n\n# A tibble: 9 × 5\n  variable        value            n  deff ci               \n  &lt;chr&gt;           &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;            \n1 arrived         TRUE       761799.  3.93 51.4% (40.9-61.7)\n2 arrived         FALSE      720658.  3.93 48.6% (38.3-59.1)\n3 left            TRUE       701199.  2.38 47.3% (39.2-55.5)\n4 left            FALSE      781258.  2.38 52.7% (44.5-60.8)\n5 died            TRUE        76213.  3.76 5.1% (2.1-12.1)  \n6 died            FALSE     1406244.  3.76 94.9% (87.9-97.9)\n7 education_level higher     171644.  4.70 42.4% (26.9-59.7)\n8 education_level primary    102609.  2.37 25.4% (16.2-37.3)\n9 education_level secondary  130201.  6.68 32.2% (16.5-53.3)\n\n\n\n\n26.8.4 Package gtsummary\nVới gtsummary, dường như vẫn chưa có hàm sẵn có để thêm khoảng tin cậy hoặc hệ số thiết kế. Ở đây chúng tôi trình bày cách định nghĩa một hàm để thêm khoảng tin cậy và sau đó thêm khoảng tin cậy vào bảng được tạo bằng gtsummary với hàm tbl_svysummary().\n\nconfidence_intervals &lt;- function(data, variable, by, ...) {\n  \n  ## extract the confidence intervals and multiply to get percentages\n  props &lt;- svyciprop(as.formula(paste0( \"~\" , variable)),\n              data, na.rm = TRUE)\n  \n  ## extract the confidence intervals \n  as.numeric(confint(props) * 100) %&gt;% ## make numeric and multiply for percentage\n    round(., digits = 1) %&gt;%           ## round to one digit\n    c(.) %&gt;%                           ## extract the numbers from matrix\n    paste0(., collapse = \"-\")          ## combine to single character\n}\n\n## using the survey package design object\ntbl_svysummary(base_survey_design, \n               include = c(arrived, left, died),   ## define variables want to include\n               statistic = list(everything() ~ c(\"{n} ({p}%)\"))) %&gt;% ## define stats of interest\n  add_n() %&gt;%  ## add the weighted total \n  add_stat(fns = everything() ~ confidence_intervals) %&gt;% ## add CIs\n  ## modify the column headers\n  modify_header(\n    list(\n      n ~ \"**Weighted total (N)**\",\n      stat_0 ~ \"**Weighted Count**\",\n      add_stat_1 ~ \"**95%CI**\"\n    )\n    )\n\n\n\n\n\n\n\n\nCharacteristic\nWeighted total (N)\nWeighted Count1\n95%CI\n\n\n\n\narrived\n1,482,457\n761,799 (51%)\n40.9-61.7\n\n\nleft\n1,482,457\n701,199 (47%)\n39.2-55.5\n\n\ndied\n1,482,457\n76,213 (5.1%)\n2.1-12.1\n\n\n\n1 n (%)",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Phân tích khảo sát</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.vn.html#tỷ-suất-được-áp-dụng-trọng-số",
    "href": "new_pages/survey_analysis.vn.html#tỷ-suất-được-áp-dụng-trọng-số",
    "title": "26  Phân tích khảo sát",
    "section": "26.9 Tỷ suất được áp dụng trọng số",
    "text": "26.9 Tỷ suất được áp dụng trọng số\nTương tự đối với các tỷ lệ được áp dụng trọng số (chẳng hạn như tỷ lệ tử vong), bạn có thể sử dụng package survey hoặc srvyr. Tương tự, bạn có thể viết các hàm (tương tự như ở trên) để lặp qua một số biến. Bạn cũng có thể tạo một hàm cho gtsummary như trên nhưng hiện tại nó không có chức năng sẵn có.\n\n26.9.1 Package survey\n\nratio &lt;- svyratio(~died, \n         denominator = ~obstime, \n         design = base_survey_design)\n\nci &lt;- confint(ratio)\n\ncbind(\n  ratio$ratio * 10000, \n  ci * 10000\n)\n\n      obstime    2.5 %   97.5 %\ndied 5.981922 1.194294 10.76955\n\n\n\n\n26.9.2 Package srvyr\n\nsurvey_design %&gt;% \n  ## survey ratio used to account for observation time \n  summarise(\n    mortality = survey_ratio(\n      as.numeric(died) * 10000, \n      obstime, \n      vartype = \"ci\")\n    )\n\n# A tibble: 1 × 3\n  mortality mortality_low mortality_upp\n      &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n1      5.98         0.349          11.6",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Phân tích khảo sát</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.vn.html#tài-nguyên-học-liệu",
    "href": "new_pages/survey_analysis.vn.html#tài-nguyên-học-liệu",
    "title": "26  Phân tích khảo sát",
    "section": "26.10 Tài nguyên học liệu",
    "text": "26.10 Tài nguyên học liệu\nUCLA stats page\nAnalyze survey data free\nsrvyr packge\ngtsummary package\nEPIET survey case studies",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Phân tích khảo sát</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.vn.html",
    "href": "new_pages/survival_analysis.vn.html",
    "title": "27  Phân tích sống còn",
    "section": "",
    "text": "27.1 Tổng quan\nPhân tích sống còn tập trung mô tả cho một cá thể hay một nhóm cá thể nhất định. Một điểm xác định của một sự kiện được gọi là failure (như là xuất hiện bệnh, chữa khỏi bệnh, tử vong, tái phát sau khi đáp ứng với điều trị…) mà xảy ra sau một khoảng thời gian được gọi là failure time (thời gian dẫn đến sự kiện) (hoặc follow-up time (thời gian theo dõi) trong nghiên cứu thuần tập/nghiên cứu dựa vào dân số) trong suốt thời gian các cá thể được quan sát. Để xác định thời gian dẫn đến sự kiện, chúng ta cần xác định thời điểm bắt đầu (có thể là ngày nhận vào, ngày chẩn đoán…).\nMục tiêu suy luận đối với phân tích sống còn là khoảng thời gian giữa thời điểm bắt đầu và thời điểm sự kiện xảy ra. Trong nghiên cứu y học hiện nay, phân tích sống còn được sử dụng rộng rãi trong các nghiên cứu lâm sàng để đánh giá hiệu quả của một phương phương điều trị hoặc để đánh giá tình trạng sống còn của một số các biện pháp điều trị ung thư.\nNó thường được diễn đạt qua survival probability (xác suất sống sót) là xác suất mà sự hiện đang quan tâm không xảy ra trong khoảng thời gian t.\nCensoring: Censoring xảy ra khi sự kiện đang quan tâm không xảy ra trong một số cá thể ở cuối quá trình theo dõi, và vì thế, thời gian thật dẫn đến sự kiện của những cá thể này là không biết. Trong chương này, chúng tôi tập trung chủ yếu vào sự kiện không xảy ra về phía bên phải. Để biết thêm chi tiết về các loại censoring và phân tích sống còn nói chung, xem thêm các tài liệu tham khảo.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Phân tích sống còn</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.vn.html#chuẩn-bị",
    "href": "new_pages/survival_analysis.vn.html#chuẩn-bị",
    "title": "27  Phân tích sống còn",
    "section": "27.2 Chuẩn bị",
    "text": "27.2 Chuẩn bị\n\nGọi packages\nSurvival là gói lệnh được sử dụng rộng rãi nhất để phân tích sống còn bằng R. Đầu tiên, chúng ta cài đặt và sau đó tải gói lệnh này cũng như các gói lệnh khác sẽ được sử dụng trong phần này:\nTrong cuốn sổ tay này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, giúp cài đặt package nếu cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các package đã được cài đặt bằng hàm library() trong base R. Xem chương R cơ bản để biết thêm thông tin về các package trong R.\nChương này sẽ tìm hiểu phân tích sống còn bằng cách dùng bộ số liệu linelist đã được sử dụng trong hầu hết các chương trước và thay đổi một vài điểm để tạo ra bộ số liệu phù hợp cho phân tích sống còn.\n\n\nNhập bộ số liệu\nChúng ta nhập bộ số liệu của các ca bệnh được mô phỏng từ một vụ dịch Ebola. Để tiện làm theo, bấm để tải số liệu linelist “đã được làm sạch” (dưới dạng tệp .rds). Nhập số liệu này bằng hàm import() từ package rio (hàm này chấp nhận nhiều loại tập tin như .xlsx, .rds, .csv – xem chi tiết trong chương Nhập xuất số liệu.\n\n# import linelist\nlinelist_case_data &lt;- rio::import(\"linelist_cleaned.rds\")\n\n\n\nQuản lý và chuyển đổi số liệu\nNói ngắn gọn, số liệu cho phân tích sống còn có ba đặc điểm sau:\n\nbiến phụ thuộc hay đáp ứng là khoảng thời gian từ thời điểm bắt đầu đến thời điểm một sự kiện (được xác định rõ) xảy ra,\nquan sát censored là các quan sát mà sự kiện quan tâm không xảy ra tại thời điểm phân tích số liệu, và\ncác biến dự đoán hay giải thích có ảnh hưởng đến thời gian dẫn đến sự kiện mà chúng ta muốn đánh giá hoặc kiểm soát.\n\nDo đó, chúng ta sẽ tạo các biến số khác nhau tuân theo cấu trúc dữ liệu đó và tiến hành phân tích sống còn.\nChúng ta định nghĩa:\n\nmột bộ số liệu mới linelist_surv cho phân tích này\n\nsự kiện quan tâm là “tử vong” (vì thế xác suất sống sót sẽ là xác suất sống trong một khoảng thời gian nhất định sau thời đểm bắt đầu),\nthời gian theo dõi (futime) là số ngày giữa thời điểm khởi phát bệnh và thời điểm có kết cục,\nbệnh nhân censored là những người đã hồi phục hoặc những người không biết kết cục, ví dụ như sự kiện “tử vong” không được quan sát (event=0).\n\nTHẬN TRỌNG: Trong một nghiên cứu thuần tập thực tế, thông tin về thời điểm bắt đầu và thời điểm kết thúc theo dõi của các cá thể là được biết, do đó chúng ta sẽ loại bỏ các quan sát không có ngày bắt đầu và ngày có kết cục. Ngoài ra, các trường hợp có ngày khởi phát bệnh trễ hơn ngày có kết cục cũng bị loại bỏ vì các trường hợp này được xem là sai.\nMẸO: Khi lọc đến các giá trị lớn hơn (&gt;) hoặc nhỏ hơn (&lt;) một ngày có thể loại bỏ các hàng có giá trị missing, nên khi áp dụng lọc sai ngày cũng sẽ loại bỏ các hàng có ngày bị thiếu.\nSau đó, chúng ta sử dụng hàm case_when() để tạo ra một cột age_cat_small mà chỉ có 3 giá trị của nhóm tuổi.\n\n#create a new data called linelist_surv from the linelist_case_data\n\nlinelist_surv &lt;-  linelist_case_data %&gt;% \n     \n  dplyr::filter(\n       # remove observations with wrong or missing dates of onset or date of outcome\n       date_outcome &gt; date_onset) %&gt;% \n  \n  dplyr::mutate(\n       # create the event var which is 1 if the patient died and 0 if he was right censored\n       event = ifelse(is.na(outcome) | outcome == \"Recover\", 0, 1), \n    \n       # create the var on the follow-up time in days\n       futime = as.double(date_outcome - date_onset), \n    \n       # create a new age category variable with only 3 strata levels\n       age_cat_small = dplyr::case_when( \n            age_years &lt; 5  ~ \"0-4\",\n            age_years &gt;= 5 & age_years &lt; 20 ~ \"5-19\",\n            age_years &gt;= 20   ~ \"20+\"),\n       \n       # previous step created age_cat_small var as character.\n       # now convert it to factor and specify the levels.\n       # Note that the NA values remain NA's and are not put in a level \"unknown\" for example,\n       # since in the next analyses they have to be removed.\n       age_cat_small = fct_relevel(age_cat_small, \"0-4\", \"5-19\", \"20+\")\n       )\n\nMẸO: Chúng ta có thể kiểm tra lại các cột mới đã được tạo ra bằng cách thực hiện tóm tắt đối với biến số futime avà bảng chéo giữa biến số event và biến kết cục outcome. Bên cạnh việc kiểm tra này, đây là một thói quen tốt để biết được thời gian theo dõi trung vị khi giải thích kết quả của phân tích sống còn.\n\nsummary(linelist_surv$futime)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00    6.00   10.00   11.98   16.00   64.00 \n\n# cross tabulate the new event var and the outcome var from which it was created\n# to make sure the code did what it was intended to\nlinelist_surv %&gt;% \n  tabyl(outcome, event)\n\n outcome    0    1\n   Death    0 1952\n Recover 1547    0\n    &lt;NA&gt; 1040    0\n\n\nBây giờ, chúng ta tạo bảng chéo giữa biến nhóm tuổi mới age_cat_small và biến nhóm tuổi cũ age_cat để đảm bảo tính chính xác của việc chuyển đổi số liệu\n\nlinelist_surv %&gt;% \n  tabyl(age_cat_small, age_cat)\n\n age_cat_small 0-4 5-9 10-14 15-19 20-29 30-49 50-69 70+ NA_\n           0-4 834   0     0     0     0     0     0   0   0\n          5-19   0 852   717   575     0     0     0   0   0\n           20+   0   0     0     0   862   554    69   5   0\n          &lt;NA&gt;   0   0     0     0     0     0     0   0  71\n\n\nBây giờ, chúng ta xem lại 10 quan sát đầu tiên của bộ số liệu linelist_surv bằng cách xem xét các biến cụ thể (bao gồm cả các biến mới được tạo ra).\n\nlinelist_surv %&gt;% \n  select(case_id, age_cat_small, date_onset, date_outcome, outcome, event, futime) %&gt;% \n  head(10)\n\n   case_id age_cat_small date_onset date_outcome outcome event futime\n1   8689b7           0-4 2014-05-13   2014-05-18 Recover     0      5\n2   11f8ea           20+ 2014-05-16   2014-05-30 Recover     0     14\n3   893f25           0-4 2014-05-21   2014-05-29 Recover     0      8\n4   be99c8          5-19 2014-05-22   2014-05-24 Recover     0      2\n5   07e3e8          5-19 2014-05-27   2014-06-01 Recover     0      5\n6   369449           0-4 2014-06-02   2014-06-07   Death     1      5\n7   f393b4           20+ 2014-06-05   2014-06-18 Recover     0     13\n8   1389ca           20+ 2014-06-05   2014-06-09   Death     1      4\n9   2978ac          5-19 2014-06-06   2014-06-15   Death     1      9\n10  fc15ef          5-19 2014-06-16   2014-07-09 Recover     0     23\n\n\nChúng ta cũng có thể tạo bảng chéo giữa cột biến age_cat_small và gender để biết thêm chi tiết về sự phân bố của biến số mới này theo giới tính. Chúng ta sử dụng hàm tabyl() và hàm adorn từ package janitor như được mô tả trong chương Bảng mô tả.\n\n\nlinelist_surv %&gt;% \n  tabyl(gender, age_cat_small, show_na = F) %&gt;% \n  adorn_totals(c(\"row\", \"col\")) %&gt;% \n  adorn_percentages() %&gt;% \n  adorn_pct_formatting() %&gt;% \n  adorn_ns(position = \"front\")\n\n gender         0-4          5-19           20+          Total\n      f 482 (22.4%) 1,184 (54.9%)   490 (22.7%) 2,156 (100.0%)\n      m 325 (15.0%)   880 (40.6%)   960 (44.3%) 2,165 (100.0%)\n  Total 807 (18.7%) 2,064 (47.8%) 1,450 (33.6%) 4,321 (100.0%)",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Phân tích sống còn</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.vn.html#cơ-bản-về-phân-tích-sống-còn",
    "href": "new_pages/survival_analysis.vn.html#cơ-bản-về-phân-tích-sống-còn",
    "title": "27  Phân tích sống còn",
    "section": "27.3 Cơ bản về phân tích sống còn",
    "text": "27.3 Cơ bản về phân tích sống còn\n\nTạo ra đối tượng kiểu surv\nĐầu tiên, chúng ta dùng hàm Surv() từ package survival để tạo ra một ‘đối tượng surv’ từ cột follow-up time và event.\nKết quả của bước này tạo ra một đối tượng Surv bao gồm thông tin thời gian và có hay không sự kiện quan tâm (tử vong) được nhận thấy. Đối tượng này sẽ được sử dụng sau này ở phía bên phải trong công thức của những mô hình tiếp theo (xem tài liệu).\n\n# Use Suv() syntax for right-censored data\nsurvobj &lt;- Surv(time = linelist_surv$futime,\n                event = linelist_surv$event)\n\n\n\n\n\n\nĐể xem lại số liệu, đây là 10 hàng đầu tiên của bộ số liệu linelist_surv data, chỉ hiển thị các cột quan trọng.\n\nlinelist_surv %&gt;% \n  select(case_id, date_onset, date_outcome, futime, outcome, event) %&gt;% \n  head(10)\n\n   case_id date_onset date_outcome futime outcome event\n1   8689b7 2014-05-13   2014-05-18      5 Recover     0\n2   11f8ea 2014-05-16   2014-05-30     14 Recover     0\n3   893f25 2014-05-21   2014-05-29      8 Recover     0\n4   be99c8 2014-05-22   2014-05-24      2 Recover     0\n5   07e3e8 2014-05-27   2014-06-01      5 Recover     0\n6   369449 2014-06-02   2014-06-07      5   Death     1\n7   f393b4 2014-06-05   2014-06-18     13 Recover     0\n8   1389ca 2014-06-05   2014-06-09      4   Death     1\n9   2978ac 2014-06-06   2014-06-15      9   Death     1\n10  fc15ef 2014-06-16   2014-07-09     23 Recover     0\n\n\nVà đây là 10 thành phần đầu tiên của đối tượng survobj. Về bản chất, nó xuất ra đưới dạng một véc tơ của biến số thời gian theo dõi, dấu “+” là đại điện cho một quan sát censored ở phía bên phải. Xem cách các con số sắp xếp bên trên và bên dưới.\n\n#print the 50 first elements of the vector to see how it presents\nhead(survobj, 10)\n\n [1]  5+ 14+  8+  2+  5+  5  13+  4   9  23+\n\n\n\n\nThực hiện các phân tích ban đầu\nSau đó, chúng ta bắt đầu phân tích bằng cách sử dụng hàm survfit() để tạo ra một đối tượng survfit, phù hợp với các tính toán mặc định cho các ước tính Kaplan Meier (KM) của đường cong sống sót chung (cận biên), mà thực tế là một hàm bước với các bước nhảy tại thời điểm sự kiện được quan sát. Đối tượng survfit object cuối cùng chứa đựng một hoặc nhiều đường cong sống sót và được tạo ra bằng cách sử dụng đối tượng Surv làm biến đáp ứng trong công thức của mô hình.\nLƯU Ý: Ước tính Kaplan-Meier là một ước tính khả dĩ tối đa phi tham số của hàm sống còn (xem mục Tài nguyên học liệu để biết thêm thông tin).\nTóm tắt của đối tượng survfit này sẽ cho một bảng được gọi là life table (bảng sống còn). Đối với mỗi bước thời gian theo dõi (time) là nơi một sự kiện xảy ra (theo thứ tự tăng dần):\n\nsố người có nguy cơ dẫn đến sự kiện (người chưa có sự kiện cũng như sự kiện chưa xảy ra: n.risk)\n\nnhững người có sự kiện (n.event)\n\nvà từ những dữ kiện trên tính xác suất không đưa đến sự kiện (xác suất không tử vong, hoặc sống sót sau khoảng thời gian cụ thể đó)\n\ncuối cùng, sai số chuẩn và khoảng tin cậy cho xác suất đó được tính toán và trình bày\n\nChúng ta thực hiện các ước tính KM bằng cách sử dụng công thức với đối tượng Surv trước đó “survobj” làm biến đáp ứng. “~ 1” diễn đạt rẳng chúng ta đang thực hiện mô hình sống còn tổng quát.\n\n# fit the KM estimates using a formula where the Surv object \"survobj\" is the response variable.\n# \"~ 1\" signifies that we run the model for the overall survival  \nlinelistsurv_fit &lt;-  survival::survfit(survobj ~ 1)\n\n#print its summary for more details\nsummary(linelistsurv_fit)\n\nCall: survfit(formula = survobj ~ 1)\n\n time n.risk n.event survival std.err lower 95% CI upper 95% CI\n    1   4539      30    0.993 0.00120        0.991        0.996\n    2   4500      69    0.978 0.00217        0.974        0.982\n    3   4394     149    0.945 0.00340        0.938        0.952\n    4   4176     194    0.901 0.00447        0.892        0.910\n    5   3899     214    0.852 0.00535        0.841        0.862\n    6   3592     210    0.802 0.00604        0.790        0.814\n    7   3223     179    0.757 0.00656        0.745        0.770\n    8   2899     167    0.714 0.00700        0.700        0.728\n    9   2593     145    0.674 0.00735        0.660        0.688\n   10   2311     109    0.642 0.00761        0.627        0.657\n   11   2081     119    0.605 0.00788        0.590        0.621\n   12   1843      89    0.576 0.00809        0.560        0.592\n   13   1608      55    0.556 0.00823        0.540        0.573\n   14   1448      43    0.540 0.00837        0.524        0.556\n   15   1296      31    0.527 0.00848        0.511        0.544\n   16   1152      48    0.505 0.00870        0.488        0.522\n   17   1002      29    0.490 0.00886        0.473        0.508\n   18    898      21    0.479 0.00900        0.462        0.497\n   19    798       7    0.475 0.00906        0.457        0.493\n   20    705       4    0.472 0.00911        0.454        0.490\n   21    626      13    0.462 0.00932        0.444        0.481\n   22    546       8    0.455 0.00948        0.437        0.474\n   23    481       5    0.451 0.00962        0.432        0.470\n   24    436       4    0.447 0.00975        0.428        0.466\n   25    378       4    0.442 0.00993        0.423        0.462\n   26    336       3    0.438 0.01010        0.419        0.458\n   27    297       1    0.436 0.01017        0.417        0.457\n   29    235       1    0.435 0.01030        0.415        0.455\n   38     73       1    0.429 0.01175        0.406        0.452\n\n\nKhi sử dụng hàm summary(), chúng ta có thể thêm tùy chọn times và cụ thể các thời điểm nhất định mà chúng ta muốn xem các thông tin sống còn\n\n#print its summary at specific times\nsummary(linelistsurv_fit, times = c(5,10,20,30,60))\n\nCall: survfit(formula = survobj ~ 1)\n\n time n.risk n.event survival std.err lower 95% CI upper 95% CI\n    5   3899     656    0.852 0.00535        0.841        0.862\n   10   2311     810    0.642 0.00761        0.627        0.657\n   20    705     446    0.472 0.00911        0.454        0.490\n   30    210      39    0.435 0.01030        0.415        0.455\n   60      2       1    0.429 0.01175        0.406        0.452\n\n\nChúng ta cũng có thể sử dụng hàm print(). Đối số print.rmean = TRUE được sử dụng để có được giá trị trung bình của thời gian sống sót và sai số chuẩn (se).\nLƯU Ý: Thời gian sống sót trung bình giới hạn là một đo lường sống còn cụ thể ngày càng được sử dụng trong phân tích sống còn của bệnh ung thư và thường được định nghĩa là khu vực dưới đường cong, khi chúng ta quan sát bệnh nhân cho đến thời gian giới hạn T (xem phần Tài nguyên học liệu để biết thêm chi tiết).\n\n# print linelistsurv_fit object with mean survival time and its se. \nprint(linelistsurv_fit, print.rmean = TRUE)\n\nCall: survfit(formula = survobj ~ 1)\n\n        n events rmean* se(rmean) median 0.95LCL 0.95UCL\n[1,] 4539   1952   33.1     0.539     17      16      18\n    * restricted mean with upper limit =  64 \n\n\nMẸO: Chúng ta có thể tạo ra đối tượng surv trực tiếp trong hàm survfit() và tiết kiệm một dòng lệnh. Thực hiện điều này như sau: linelistsurv_quick &lt;-  survfit(Surv(futime, event) ~ 1, data=linelist_surv).\n\n\nMối nguy tích lũy\nBên cạnh hàm summary(), chúng ta có thể sử dụng hàm str(), hàm này cho biết chi tiết hơn vể cấu trúc của các đối tượng trong hàm survfit(). Cấu trúc này là một danh sách của 16 thành phần.\nMột thành phần quan trọng trong số những thành phần này là: cumhaz, một véc tơ kiểu số. Thành phần này có thể được vẽ để hiển thị mối nguy tích lũy, với mối nguy là tỷ suất xảy ra sự kiện tức thời (xem tài liệu tham khảo).\n\nstr(linelistsurv_fit)\n\nList of 16\n $ n        : int 4539\n $ time     : num [1:59] 1 2 3 4 5 6 7 8 9 10 ...\n $ n.risk   : num [1:59] 4539 4500 4394 4176 3899 ...\n $ n.event  : num [1:59] 30 69 149 194 214 210 179 167 145 109 ...\n $ n.censor : num [1:59] 9 37 69 83 93 159 145 139 137 121 ...\n $ surv     : num [1:59] 0.993 0.978 0.945 0.901 0.852 ...\n $ std.err  : num [1:59] 0.00121 0.00222 0.00359 0.00496 0.00628 ...\n $ cumhaz   : num [1:59] 0.00661 0.02194 0.05585 0.10231 0.15719 ...\n $ std.chaz : num [1:59] 0.00121 0.00221 0.00355 0.00487 0.00615 ...\n $ type     : chr \"right\"\n $ logse    : logi TRUE\n $ conf.int : num 0.95\n $ conf.type: chr \"log\"\n $ lower    : num [1:59] 0.991 0.974 0.938 0.892 0.841 ...\n $ upper    : num [1:59] 0.996 0.982 0.952 0.91 0.862 ...\n $ call     : language survfit(formula = survobj ~ 1)\n - attr(*, \"class\")= chr \"survfit\"\n\n\n\n\n\nVẽ đường cong Kaplan-Meir\nSau khi ước tính KM đã được fit, chúng ta có thể hình dung xác suất sống sót qua một thời gian nhất định bằng cách dùng hàm plot() để vẽ “đường cong Kaplan-Meier”. Nói cách khác, đường cong bên dưới là một minh họa đường cong sống sót quy ước của toàn bộ nhóm bệnh nhân.\nChúng ta có thể nhanh chóng xác minh thời gian theo dõi tối thiểu và tối đa trên đường cong.\nMột cách dễ dàng để giải thích là phát biểu rằng, tại thời điểm 0, tất cả người tham gia đều sống và xác suất sống sót khi đó là 100%.Xác suất ngày giảm dần theo thời gian khi có bệnh nhân tử vong. Tỷ lệ người tham gia sống sót sau 60 ngày là khoảng 40%.\n\nplot(linelistsurv_fit, \n     xlab = \"Days of follow-up\",    # x-axis label\n     ylab=\"Survival Probability\",   # y-axis label\n     main= \"Overall survival curve\" # figure title\n     )\n\n\n\n\n\n\n\n\nKhoảng tin cậy của các ước tính KM cũng được vẽ mặc định trên biểu đồ và có thể bị loại bỏ bằng cách thêm tùy chọn conf.int = FALSE vào trong lệnh plot().\nVì sự kiện quan tâm là “tử vong”, việc vẽ một đường cong mô tả phần bù tỷ lệ sống sót sẽ đưa đến việc vẽ tỷ lệ tử vong tích lũy. Điều này có thể được thực hiện với hàm lines(), bổ sung thông tin trên biểu đồ hiện có.\n\n# original plot\nplot(\n  linelistsurv_fit,\n  xlab = \"Days of follow-up\",       \n  ylab = \"Survival Probability\",       \n  mark.time = TRUE,              # mark events on the curve: a \"+\" is printed at every event\n  conf.int = FALSE,              # do not plot the confidence interval\n  main = \"Overall survival curve and cumulative mortality\"\n  )\n\n# draw an additional curve to the previous plot\nlines(\n  linelistsurv_fit,\n  lty = 3,             # use different line type for clarity\n  fun = \"event\",       # draw the cumulative events instead of the survival \n  mark.time = FALSE,\n  conf.int = FALSE\n  )\n\n# add a legend to the plot\nlegend(\n  \"topright\",                               # position of legend\n  legend = c(\"Survival\", \"Cum. Mortality\"), # legend text \n  lty = c(1, 3),                            # line types to use in the legend\n  cex = .85,                                # parametes that defines size of legend text\n  bty = \"n\"                                 # no box type to be drawn for the legend\n  )",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Phân tích sống còn</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.vn.html#so-sánh-các-đường-cong-sống-sót",
    "href": "new_pages/survival_analysis.vn.html#so-sánh-các-đường-cong-sống-sót",
    "title": "27  Phân tích sống còn",
    "section": "27.4 So sánh các đường cong sống sót",
    "text": "27.4 So sánh các đường cong sống sót\nĐể so sánh các đường cong sống sót của những nhóm người tham gia hoặc bệnh nhân khác nhau, đầu tiên chúng ta có thể cần xem xét các đường cong tương ứng của các nhóm và sau đó thực hiện các kiểm định để lượng giá sự khác biệt giữa các nhóm độc lập. So sánh này có thể liên quan đến các nhóm dựa vào giới tính, tuổi tác, điều trị, bệnh đi kèm,…\n\nKiểm định Log rank\nKiểm định log rank là một kiểm định phổ biến để so sánh toàn bộ quá trình sống sót giữa hai hay nhiều nhóm độc lập và có thể xem xét các đường cong sống sót có tương đồng (chồng chéo) hay không (giả thuyết vô hiệu là không có sự khác biệt về sự sống sót giữa các nhóm). Hàm survdiff() trong survival package cho phép thực hiện kiểm định log-rank khi chúng ta cụ thể rho = 0 (mặc định). Kết quả kiểm định cho ra một thống kê chi bình phương cùng với giá trị p vì log-rank phân phối gần giống như thống kê của kiểm định chi bình phương.\nĐầu tiên, chúng ta thử so sánh các đường cong sống sót theo giới tính. Đối với điều này, chúng ta thử hình dung nó (kiểm tra xem hai đường cong sống sót có chồng lên nhau không). Một đối tượng survfit mới sẽ được tạo ra với một công thức hơi khác một chút. Sau đó, đối tượng survdiff sẽ được tạo ra.\nBằng cách cung cấp ~ gender ở phía bên phải của công thức, chúng ta không còn vẽ biểu đồ đường cong sống sót chung mà thay vào đó là theo giới tính.\n\n# create the new survfit object based on gender\nlinelistsurv_fit_sex &lt;-  survfit(Surv(futime, event) ~ gender, data = linelist_surv)\n\nBây giờ, chúng ta có thể vẽ các đường cong sống sót theo giới tính. Hãy xem thứ tự giá trị biến của giới tính trước khi xác định màu sắc và chú giải.\n\n# set colors\ncol_sex &lt;- c(\"lightgreen\", \"darkgreen\")\n\n# create plot\nplot(\n  linelistsurv_fit_sex,\n  col = col_sex,\n  xlab = \"Days of follow-up\",\n  ylab = \"Survival Probability\")\n\n# add legend\nlegend(\n  \"topright\",\n  legend = c(\"Female\",\"Male\"),\n  col = col_sex,\n  lty = 1,\n  cex = .9,\n  bty = \"n\")\n\n\n\n\n\n\n\n\nVà bây giờ, chúng ta có thể tính toán kiểm định sự khác biệt giữa các đường cong bằng cách sử dụng hàm survdiff()\n\n#compute the test of the difference between the survival curves\nsurvival::survdiff(\n  Surv(futime, event) ~ gender, \n  data = linelist_surv\n  )\n\nCall:\nsurvival::survdiff(formula = Surv(futime, event) ~ gender, data = linelist_surv)\n\nn=4321, 218 observations deleted due to missingness.\n\n            N Observed Expected (O-E)^2/E (O-E)^2/V\ngender=f 2156      924      909     0.255     0.524\ngender=m 2165      929      944     0.245     0.524\n\n Chisq= 0.5  on 1 degrees of freedom, p= 0.5 \n\n\nChúng ta thấy rằng đường cong sống sót cho nữ và đường cong cho nam chồng lên nhau và kiểm định log-rank không đưa ra bằng chứng về sự khác biệt sống sót giữa nam và nữ.\nMột số package trong R cho phép minh họa các đường cong sống sót cho các nhóm và kiểm định sự khác biệt cùng một lúc. Sử dụng hàm ggsurvplot() từ package survminer, chúng ta cũng có thể bao gồm các bảng nguy cơ với các đường cong này cũng như giá trị p từ kiểm định log-rank.\nTHẬN TRỌNG: Các hàm từ package survminer đòi hỏi chúng ta cụ thể đối tượng sống sót và cụ thể bộ số liệu để so sánh đối tượng sống sót. Hãy nhớ làm điều này để tránh thông báo lỗi do không cụ thể. \n\nsurvminer::ggsurvplot(\n    linelistsurv_fit_sex, \n    data = linelist_surv,          # again specify the data used to fit linelistsurv_fit_sex \n    conf.int = FALSE,              # do not show confidence interval of KM estimates\n    surv.scale = \"percent\",        # present probabilities in the y axis in %\n    break.time.by = 10,            # present the time axis with an increment of 10 days\n    xlab = \"Follow-up days\",\n    ylab = \"Survival Probability\",\n    pval = T,                      # print p-value of Log-rank test \n    pval.coord = c(40,.91),        # print p-value at these plot coordinates\n    risk.table = T,                # print the risk table at bottom \n    legend.title = \"Gender\",       # legend characteristics\n    legend.labs = c(\"Female\",\"Male\"),\n    font.legend = 10, \n    palette = \"Dark2\",             # specify color palette \n    surv.median.line = \"hv\",       # draw horizontal and vertical lines to the median survivals\n    ggtheme = theme_light()        # simplify plot background\n)\n\n\n\n\n\n\n\n\nChúng ta có thể cũng muốn kiểm định sự khác biệt về sống còn theo nguồn lây (nguồn ô nhiễm).\nTrong trường hợp này, kiểm định log-rank cho thấy có đủ bằng chứng về sự khác biệt trong xác suất sống sót với alpha= 0.005. Xác suất sống sót cho những bệnh nhân bị nhiễm tại các đám tang cao hơn xác suất sống sót ở những nơi khác mà gợi ý về lợi ích sống sót.\n\nlinelistsurv_fit_source &lt;-  survfit(\n  Surv(futime, event) ~ source,\n  data = linelist_surv\n  )\n\n# plot\nggsurvplot( \n  linelistsurv_fit_source,\n  data = linelist_surv,\n  size = 1, linetype = \"strata\",   # line types\n  conf.int = T,\n  surv.scale = \"percent\",  \n  break.time.by = 10, \n  xlab = \"Follow-up days\",\n  ylab= \"Survival Probability\",\n  pval = T,\n  pval.coord = c(40,.91),\n  risk.table = T,\n  legend.title = \"Source of \\ninfection\",\n  legend.labs = c(\"Funeral\", \"Other\"),\n  font.legend = 10,\n  palette = c(\"#E7B800\",\"#3E606F\"),\n  surv.median.line = \"hv\", \n  ggtheme = theme_light()\n)\n\nWarning in geom_segment(aes(x = 0, y = max(y2), xend = max(x1), yend = max(y2)), : All aesthetics have length 1, but the data has 2 rows.\nℹ Did you mean to use `annotate()`?\nAll aesthetics have length 1, but the data has 2 rows.\nℹ Did you mean to use `annotate()`?\nAll aesthetics have length 1, but the data has 2 rows.\nℹ Did you mean to use `annotate()`?\nAll aesthetics have length 1, but the data has 2 rows.\nℹ Did you mean to use `annotate()`?",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Phân tích sống còn</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.vn.html#phân-tích-bằng-hồi-quy-cox",
    "href": "new_pages/survival_analysis.vn.html#phân-tích-bằng-hồi-quy-cox",
    "title": "27  Phân tích sống còn",
    "section": "27.5 Phân tích bằng hồi quy Cox",
    "text": "27.5 Phân tích bằng hồi quy Cox\nHồi quy mối nguy theo tỷ lệ Cox (sau này sẽ gọi ngắn gọn là hồi quy Cox) là một trong những kỹ thuật hồi quy phổ biến nhất cho phân tích sống còn. Các mô hình khác cũng có thể được sử dụng, vì để sử dụng thích hợp mô hình Cox, các giả định quan trọng cần phải được xác minh: xem tài liệu tham khảo.\nTrong một mô hình hồi quy Cox, đo lường ảnh hưởng là hazard rate (tỷ suất mối nguy) (HR), là nguy cơ xảy ra sự kiện (hay là nguy cơ tử vong trong ví dụ này), của người tham gia sống sót đến một thời điểm cụ thể. Thông thường, chúng ta quan tâm đến việc so sánh giữa các nhóm độc lập gvề nguy cơ của nó, và sử dụng tỷ số nguy cơ mà tương tự như tỷ số chênh khi thực hiện hồi quy logistic đa biến. Hàm cox.ph() từ package survival được sử dụng để fit mô hình. Hàm cox.zph() từ package survival có thể được sử dụng để kiểm tra tính phù hợp của giả định nguy cơ theo tỷ lệ với mô hình hồi quy Cox.\nLƯU Ý: Xác suất phải nằm trong khoảng từ 0 đến 1. Tuy nhiên, nguy cơ đại điện cho số sự kiện dự đoán trên một đơn vị thời gian.\n\nNếu tỷ số nguy cơ cho một yếu tố dự đoán gần bằng 1, thì yếu tố dự đoán đó không ảnh hưởng đến sự sống sót,\nNếu HR nhỏ hơn 1, thì yếu tố dự đoán là yếu tố bảo vệ (tức là yếu tố liên quan đến cải thiện khả năng sống sót),\nVà nếu HR lớn hơn 1, thì yếu tố dự đoán kết hợp với tăng nguy cơ (hay là giảm khả năng sống sót).\n\n\nFitting một mô hình Cox\nĐầu tiên, chúng ta có thể fit một mô hình để đánh giá ảnh hưởng của tuổi và giới lên sự sống sót. Chỉ cần xuất mô hình, chúng ta có những thông tin sau:\n\ncác ước lượng hệ số hồi quy coef để xác định mối liên hệ giữa các biến dự đoán và biến kết cục,\nlũy thừa của các ước số (exp(coef)) để tính tỷ số nguy cơ,\ncác sai số chuẩn se(coef),\nchỉ số z-score: bao nhiêu sai số chuẩn là hệ số ước tính khác biệt từ giá trị 0,\nvà p-value: xác suất mà ước số có thể là 0.\n\nÁp dụng hàm summary() cho các đối tượng của mô hình Cox cho biết thêm thông tin như là khoảng tin cậy của HR và các chỉ số kiểm định khác.\nKết quả của hiệp biến đầu tiên gender được trình bày ở hàng đầu tiên. genderm (nam) được in ra có ngụ ý rằng vị trí tầng đầu tiên (“f”), tức là nhóm nữ, là nhóm tham chiếu cho biến số giới tính. Vì thế, giải thích các thông số kiểm định là của nam so với nữ. Giá trị p chỉ ra rằng không có đủ bằng chứng về ảnh hưởng của giới tính lên mối nguy hay là không có đủ bằng chứng về mối liên quan giữa giới và tử vong (do tất cả các nguyên nhân).\nCũng thiếu bằng chứng như vậy đối với biến số nhóm tuổi.\n\n#fitting the cox model\nlinelistsurv_cox_sexage &lt;-  survival::coxph(\n              Surv(futime, event) ~ gender + age_cat_small, \n              data = linelist_surv\n              )\n\n\n#printing the model fitted\nlinelistsurv_cox_sexage\n\nCall:\nsurvival::coxph(formula = Surv(futime, event) ~ gender + age_cat_small, \n    data = linelist_surv)\n\n                      coef exp(coef) se(coef)      z     p\ngenderm           -0.03149   0.96900  0.04767 -0.661 0.509\nage_cat_small5-19  0.09400   1.09856  0.06454  1.456 0.145\nage_cat_small20+   0.05032   1.05161  0.06953  0.724 0.469\n\nLikelihood ratio test=2.8  on 3 df, p=0.4243\nn= 4321, number of events= 1853 \n   (218 observations deleted due to missingness)\n\n#summary of the model\nsummary(linelistsurv_cox_sexage)\n\nCall:\nsurvival::coxph(formula = Surv(futime, event) ~ gender + age_cat_small, \n    data = linelist_surv)\n\n  n= 4321, number of events= 1853 \n   (218 observations deleted due to missingness)\n\n                      coef exp(coef) se(coef)      z Pr(&gt;|z|)\ngenderm           -0.03149   0.96900  0.04767 -0.661    0.509\nage_cat_small5-19  0.09400   1.09856  0.06454  1.456    0.145\nage_cat_small20+   0.05032   1.05161  0.06953  0.724    0.469\n\n                  exp(coef) exp(-coef) lower .95 upper .95\ngenderm               0.969     1.0320    0.8826     1.064\nage_cat_small5-19     1.099     0.9103    0.9680     1.247\nage_cat_small20+      1.052     0.9509    0.9176     1.205\n\nConcordance= 0.514  (se = 0.007 )\nLikelihood ratio test= 2.8  on 3 df,   p=0.4\nWald test            = 2.78  on 3 df,   p=0.4\nScore (logrank) test = 2.78  on 3 df,   p=0.4\n\n\nThật rất thú vị để thực hiện mô hình và xem kết quả, nhưng quan sát đầu tiên để xác minh xem có thỏa các giả định về nguy cơ theo tỷ lệ hay không mà có thể giúp tiết kiệm thời gian.\n\ntest_ph_sexage &lt;- survival::cox.zph(linelistsurv_cox_sexage)\ntest_ph_sexage\n\n              chisq df    p\ngender        0.454  1 0.50\nage_cat_small 0.838  2 0.66\nGLOBAL        1.399  3 0.71\n\n\nLƯU Ý: đối số thứ hai được gọi là method có thể được định rõ khi tính toán mô hình Cox để xác định cách ràng buộc được vận dụng. Phương pháp mặc định là “efron”, và các tùy chọn khác là “breslow” và “exact”.\nTrong một mô hình khác, chúng tôi thêm nhiều yếu tố nguy cơ hơn như nguồn lây và số ngày giữa ngày khởi phát và ngày nhập viện. Điều trước tiên vào lúc này là xác minh các giả định nguy cơ theo tỷ lệ trước khi thực hiện các bước tiếp theo.\nTrong mô hình này, chúng ta bao gồm một biến dự báo liên tục (days_onset_hosp). Trong trường hợp này, chúng ta giải thích các ước tính của thông số như là sự gia tăng theo lôgarít kỳ vọng của nguy cơ tương đối cho mỗi mức tăng của một đơn vị trong biến dự đoán, bằng cách giữ các yếu tố dự đoán khác cố định. Đầu tiên chúng ta xác minh giả định nguy cơ theo tỷ lệ.\n\n#fit the model\nlinelistsurv_cox &lt;-  coxph(\n                        Surv(futime, event) ~ gender + age_years+ source + days_onset_hosp,\n                        data = linelist_surv\n                        )\n\n\n#test the proportional hazard model\nlinelistsurv_ph_test &lt;- cox.zph(linelistsurv_cox)\nlinelistsurv_ph_test\n\n                   chisq df       p\ngender           0.45062  1    0.50\nage_years        0.00199  1    0.96\nsource           1.79622  1    0.18\ndays_onset_hosp 31.66167  1 1.8e-08\nGLOBAL          34.08502  4 7.2e-07\n\n\nViệc xác minh bằng đồ thị của giả định này có thể được thực hiện bằng hàm ggcoxzph() của package survminer.\n\nsurvminer::ggcoxzph(linelistsurv_ph_test)\n\n\n\n\n\n\n\n\nKết quả mô hình chỉ ra rằng có mối liên quan nghịch giữa khoảng thời gian từ khởi phát bệnh đến nhân viện và tử vong do tất cả các nguyên nhân. Nguy cơ dự đoán là bằng 0.9 lần ở một người nhập viện trễ hơn một ngày so với người khác, khi giữ biến giới tính cố định. Hay giải thích một cách dễ hiểu hơn, tăng một đơn vị thời gian từ lúc khởi phát đến nhập viện thì có liên quan đến giảm 10.7% (coef *100) nguy cơ tử vong.\nKết quả cũng cho thấy một mối liên quan thuận giữa nguồn lây và tử vong. Điều này có nghĩa là nguy cơ tử vong của bệnh nhân có nguồn lây bằng 1.21 lần so với bệnh nhân có nguồn lây là đám tang.\n\n#print the summary of the model\nsummary(linelistsurv_cox)\n\nCall:\ncoxph(formula = Surv(futime, event) ~ gender + age_years + source + \n    days_onset_hosp, data = linelist_surv)\n\n  n= 2772, number of events= 1180 \n   (1767 observations deleted due to missingness)\n\n                     coef exp(coef)  se(coef)      z Pr(&gt;|z|)    \ngenderm          0.004710  1.004721  0.060827  0.077   0.9383    \nage_years       -0.002249  0.997753  0.002421 -0.929   0.3528    \nsourceother      0.178393  1.195295  0.084291  2.116   0.0343 *  \ndays_onset_hosp -0.104063  0.901169  0.014245 -7.305 2.77e-13 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n                exp(coef) exp(-coef) lower .95 upper .95\ngenderm            1.0047     0.9953    0.8918    1.1319\nage_years          0.9978     1.0023    0.9930    1.0025\nsourceother        1.1953     0.8366    1.0133    1.4100\ndays_onset_hosp    0.9012     1.1097    0.8764    0.9267\n\nConcordance= 0.566  (se = 0.009 )\nLikelihood ratio test= 71.31  on 4 df,   p=1e-14\nWald test            = 59.22  on 4 df,   p=4e-12\nScore (logrank) test = 59.54  on 4 df,   p=4e-12\n\n\nChúng ta có thể xác minh mối quan hệ này bằng một bảng:\n\nlinelist_case_data %&gt;% \n  tabyl(days_onset_hosp, outcome) %&gt;% \n  adorn_percentages() %&gt;%  \n  adorn_pct_formatting()\n\n days_onset_hosp Death Recover   NA_\n               0 44.3%   31.4% 24.3%\n               1 46.6%   32.2% 21.2%\n               2 43.0%   32.8% 24.2%\n               3 45.0%   32.3% 22.7%\n               4 41.5%   38.3% 20.2%\n               5 40.0%   36.2% 23.8%\n               6 32.2%   48.7% 19.1%\n               7 31.8%   38.6% 29.5%\n               8 29.8%   38.6% 31.6%\n               9 30.3%   51.5% 18.2%\n              10 16.7%   58.3% 25.0%\n              11 36.4%   45.5% 18.2%\n              12 18.8%   62.5% 18.8%\n              13 10.0%   60.0% 30.0%\n              14 10.0%   50.0% 40.0%\n              15 28.6%   42.9% 28.6%\n              16 20.0%   80.0%  0.0%\n              17  0.0%  100.0%  0.0%\n              18  0.0%  100.0%  0.0%\n              22  0.0%  100.0%  0.0%\n              NA 52.7%   31.2% 16.0%\n\n\nChúng ta cần phải xem xét và điều tra tại sao sự kết hợp này tồn tại trong số liệu. Một giải thích có thể chấp nhận được là bệnh nhân nhập viện trễ hơn vì có bệnh lúc đầu ít nghiêm trọng hơn. Một giải thích khác có lẽ dễ chấp nhận hơn là vì chúng ta sử dụng một bộ số liệu mô phỏng, mẫu này không phản ánh đúng thực tế!\n\n\n\nBiểu đồ Forest plot\nChúng ta có thể vẽ kết quả của mô hình Cox bằng cách sử dụng hàm ggforest() trong package survminer để vẽ biểu đồ Forest plot.\n\nggforest(linelistsurv_cox, data = linelist_surv)",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Phân tích sống còn</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.vn.html#các-hiệp-biến-phụ-thuộc-vào-thời-gian-trong-mô-hình-sống-còn",
    "href": "new_pages/survival_analysis.vn.html#các-hiệp-biến-phụ-thuộc-vào-thời-gian-trong-mô-hình-sống-còn",
    "title": "27  Phân tích sống còn",
    "section": "27.6 Các hiệp biến phụ thuộc vào thời gian trong mô hình sống còn",
    "text": "27.6 Các hiệp biến phụ thuộc vào thời gian trong mô hình sống còn\nMột số nội dung dưới đây được adapt từ tài liệu Giới thiệu về phân tích sống còn với R với sự cho phép của TS. Emily Zabor\nTrong phần trước, chúng ta đã đề cập đến việc sử dụng hồi quy Cox để kiểm tra mối liên quan giữa hiệp biến và biến kết cục sống còn. Nhưng những phân tích này dựa trên hiệp biến được đo lường ở thời điểm ban đầu, tức là trước thời gian theo dõi sự kiện bắt đầu.\nĐiều gì sẽ xảy ra nếu chúng ta quan tâm đến một hiệp biến được đo sau khi thời gian theo dõi bắt đầu? Hoặc điều gì sẽ xảy ra nếu chúng ta có một hiệp biến có thể thay đổi theo thời gian\nVí dụ: có thể chúng ta đang làm việc với các số liệu lâm sàng mà chúng lặp lại đo lường các giá trị xét nghiệm mà có thể thay đổi theo thời gian. Đây là một ví dụ về hiệp biến phụ thuộc vào thời gian. Để nhấn mạnh vào vấn đề này, chúng ta cần một thiết lập đặc biệt, nhưng may là mô hình Cox rất linh động và loại số liệu này cũng có thể được mô hình hóa bằng các công cụ từ package survival.\n\nThiết lập hiệp biến phụ thuộc vào thời gian\nPhân tích các hiệp biến phụ thuộc vào thời gian trong R đòi hỏi thiết lập một bộ dữ liệu đặc biệt. Nếu quan tâm, hãy xem chi tiết hơn về vấn đề này được viết bởi tác giả của package survival Sử Dụng Hiệp Biến Phụ Thuộc Vào Thời Gian và Hệ Số Phụ Thuộc Vào Thời Gian trong Mô Hình Cox.\nĐối với vấn đề này, chúng ta sử dụng một bộ số liệu mới từ package SemiCompRisks có tên là BMT, bộ số liệu này bao gồm 137 bệnh nhân cấy ghép tủy xương. Các biến chúng ta sẽ tập trung vào là:\n\nT1 - thời gian (tính bằng ngày) đến khi tử vong hoặc đến lần theo dõi cuối cùng\n\ndelta1 - chỉ số tử vong; 1-Tử vong, 0-Còn sống\n\nTA - thời gian (tính theo ngày) đến khi phát bệnh GVHD cấp tính (bệnh tế bào ghép tấn công vật chủ)\n\ndeltaA - chỉ số của bệnh GVHD cấp tính;\n\n1 - Đã tiến triển bệnh GVHD cấp tính\n\n0 - Không tiến triển bệnh GVHD cấp tính\n\n\nChúng ta sẽ gọi bộ số liệu này từ package survival bằng cách sử dụng lệnh data() từ base R, giúp tải số liệu được chứa ở trong một package đã được cài đặt. Một data frame có tên BMT sẽ hiện thị trong môi trường R.\n\ndata(BMT, package = \"SemiCompRisks\")\n\n\nThêm mã nhận dạng bệnh nhân\nKhông có cột ID trong bộ số liệu BMT, cột này cần thiết để tạo ra bộ số liệu mà chúng ta muốn. Vì vậy, chúng ta sử dụng hàm rowid_to_column() từ package tibble thuộc hệ sinh thái tidyverse để tạo một biến id mới gọi là my_id (thêm cột ở vị trí đầu tiên của bộ số liệu với việc đánh số hàng tuần tự theo số nhận dạng bắt đầu từ số 1). Chúng ta đặt tên bộ số liệu này là bmt.\n\nbmt &lt;- rowid_to_column(BMT, \"my_id\")\n\nBộ số liệu mới bây giờ trông sẽ như thế này:\n\n\n\n\n\n\n\n\nMở rộng hàng của các bệnh nhân\nTiếp theo, chúng ta sử dụng hàm tmerge() với các hàm hỗ trợ event() và tdc() để tái cấu trúc bộ số liệu. Mục tiêu của chúng ta là tái cấu trúc bộ số liệu để tạo một hàng riêng biệt cho từng bệnh nhân trong mỗi khoảng thời gian mà họ có giá trị deltaA khác nhau. Trong bộ số liệu này, mỗi bệnh nhân có thể có nhiều nhất là hai hàng tùy thuộc vào việc họ có phát bệnh GVHD hay không trong giai đoạn thu thập số liệu. Chúng ta sẽ gọi chỉ số mới cho việc phát bệnh GVHD là agvhd.\n\ntmerge() tạo một bộ số liệu dài với nhiều khoảng thời gian cho các giá trị hiệp biến khác nhau cho từng bệnh nhân\nevent() tạo chỉ số cho sự kiện mới để đi cùng với khoảng thời gian mới được tạo ra\ntdc() tạo cột hiệp biến phụ thuộc vào thời gian agvhd để đi cùng với các khoảng thời gian mới được tạo ra\n\n\ntd_dat &lt;- \n  tmerge(\n    data1 = bmt %&gt;% select(my_id, T1, delta1), \n    data2 = bmt %&gt;% select(my_id, T1, delta1, TA, deltaA), \n    id = my_id, \n    death = event(T1, delta1),\n    agvhd = tdc(TA)\n    )\n\nĐể xem điều này thực hiện thế nào, hãy xem số liệu của 5 bệnh nhân đầu tiên.\nCác biến quan tâm trong bộ số liệu gốc trông như sau:\n\nbmt %&gt;% \n  select(my_id, T1, delta1, TA, deltaA) %&gt;% \n  filter(my_id %in% seq(1, 5))\n\n  my_id   T1 delta1   TA deltaA\n1     1 2081      0   67      1\n2     2 1602      0 1602      0\n3     3 1496      0 1496      0\n4     4 1462      0   70      1\n5     5 1433      0 1433      0\n\n\nBộ số liệu mới cho cùng các bệnh nhân này trông như sau:\n\ntd_dat %&gt;% \n  filter(my_id %in% seq(1, 5))\n\n  my_id   T1 delta1 tstart tstop death agvhd\n1     1 2081      0      0    67     0     0\n2     1 2081      0     67  2081     0     1\n3     2 1602      0      0  1602     0     0\n4     3 1496      0      0  1496     0     0\n5     4 1462      0      0    70     0     0\n6     4 1462      0     70  1462     0     1\n7     5 1433      0      0  1433     0     0\n\n\nBây giờ, một số bệnh nhân có hai hàng trong bộ số liệu tương ứng với khoảng thời gian mà họ có giá trị khác của biến mới agvhd. Ví dụ như Bệnh nhân số 1 hiện có hai hàng có giá trị của biến agvhd bằng 0 từ thời điểm 0 đến 67 và giá trị bằng 1 từ thời điểm 67 đến 2081.\n\n\n\nHồi quy Cox với hiệp biến phụ thuộc vào thời gian\nBây giờ, chúng ta đã định hình lại số liệu và thêm biến mới aghvd phụ thuộc vào thời gian, hãy fit mô hình cox đơn biến. Chúng ta có thể sử dụng cùng hàm coxph() như trước, chỉ cần thay đổi trong hàm Surv() để chỉ rõ thời gian bắt đầu và thời gian kết thúc cho mỗi khoảng thời gian bằng cách sử dụng các đối số cho time1 = và time2 =.\n\nbmt_td_model = coxph(\n  Surv(time = tstart, time2 = tstop, event = death) ~ agvhd, \n  data = td_dat\n  )\n\nsummary(bmt_td_model)\n\nCall:\ncoxph(formula = Surv(time = tstart, time2 = tstop, event = death) ~ \n    agvhd, data = td_dat)\n\n  n= 163, number of events= 80 \n\n        coef exp(coef) se(coef)    z Pr(&gt;|z|)\nagvhd 0.3351    1.3980   0.2815 1.19    0.234\n\n      exp(coef) exp(-coef) lower .95 upper .95\nagvhd     1.398     0.7153    0.8052     2.427\n\nConcordance= 0.535  (se = 0.024 )\nLikelihood ratio test= 1.33  on 1 df,   p=0.2\nWald test            = 1.42  on 1 df,   p=0.2\nScore (logrank) test = 1.43  on 1 df,   p=0.2\n\n\nMột lần nữa, chúng ta trực quan hóa kết quả mô hình Cox bằng cách sử dụng hàm ggforest() từ survminer package.:\n\nggforest(bmt_td_model, data = td_dat)\n\n\n\n\n\n\n\n\nNhư bạn thấy từ biểu đồ forest plot, khoảng tin cậy và giá trị p cho thấy rằng không có mối liên hệ chặt chẽ giữa tử vong và bệnh GVHD cấp tính trong mô hình hồi quy đơn giản này.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Phân tích sống còn</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.vn.html#tài-nguyên-học-liệu",
    "href": "new_pages/survival_analysis.vn.html#tài-nguyên-học-liệu",
    "title": "27  Phân tích sống còn",
    "section": "27.7 Tài nguyên học liệu",
    "text": "27.7 Tài nguyên học liệu\nSurvival Analysis Part I: Basic concepts and first analyses\nSurvival Analysis in R\nSurvival analysis in infectious disease research: Describing events in time\nChapter on advanced survival models Princeton\nUsing Time Dependent Covariates and Time Dependent Coefficients in the Cox Model\nSurvival analysis cheatsheet R\nSurvminer cheatsheet\nPaper on different survival measures for cancer registry data with Rcode provided as supplementary materials",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Phân tích sống còn</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.vn.html",
    "href": "new_pages/gis.vn.html",
    "title": "28  GIS cơ bản",
    "section": "",
    "text": "28.1 Tổng quan\nCác khía cạnh không gian trong dữ liệu của bạn có thể cung cấp nhiều thông tin chi tiết về tình hình đợt bùng phát dịch và để trả lời các câu hỏi như:\nTrọng tâm hiện tại trong chương GIS này nhằm giải quyết nhu cầu của các nhà dịch tễ học ứng dụng trong ứng phó với các đợt bùng phát dịch. Chúng ta sẽ khám phá các phương pháp trực quan hóa dữ liệu không gian cơ bản bằng cách sử dụng package tmap và ggplot2. Chúng ta cũng sẽ đi qua một số phương pháp quản lý và truy vấn dữ liệu không gian cơ bản với package sf. Cuối cùng, chúng ta sẽ đề cập ngắn gọn đến các khái niệm về thống kê không gian (spatial statistics) như mối quan hệ không gian, tự tương quan không gian và hồi quy không gian bằng cách sử dụng package spdep.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>GIS cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.vn.html#tổng-quan",
    "href": "new_pages/gis.vn.html#tổng-quan",
    "title": "28  GIS cơ bản",
    "section": "",
    "text": "Các điểm nóng về dịch bệnh hiện nay ở đâu?\nCác điểm nóng đã thay đổi như thế nào theo thời gian?\nViệc tiếp cận các cơ sở y tế như thế nào? Có cần thêm sự tăng cường nào không?",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>GIS cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.vn.html#các-thuật-ngữ-chính",
    "href": "new_pages/gis.vn.html#các-thuật-ngữ-chính",
    "title": "28  GIS cơ bản",
    "section": "28.2 Các thuật ngữ chính",
    "text": "28.2 Các thuật ngữ chính\nDưới đây chúng tôi giới thiệu một số thuật ngữ chính. Để được giới thiệu kỹ lưỡng về GIS và phân tích không gian, chúng tôi khuyên bạn nên xem lại một trong các hướng dẫn hoặc khóa học dài hơn được liệt kê trong phần Tài nguyên học liệu.\nHệ thống thông tin địa lý (Geographic Information System - GIS) - GIS là một framework hoặc môi trường để thu thập, quản lý, phân tích và trực quan hóa dữ liệu không gian.\n\nPhần mềm GIS\nMột số phần mềm GIS phổ biến cho phép tương tác bằng các thao tác chuột để phát triển bản đồ và phân tích không gian. Những công cụ này đi kèm với những lợi thế như không cần phải học code và dễ dàng lựa chọn và đặt các biểu tượng và tính năng trên bản đồ theo cách thủ công. Dưới đây là hai phần mềm phổ biến:\nArcGIS - Một phần mềm GIS thương mại do công ty ESRI phát triển, rất phổ biến nhưng khá đắt\nQGIS - Một phần mềm GIS mã nguồn mở nhưng làm được hầu hết mọi thứ mà ArcGIS có thể làm được. Bạn có thể tải QGIS tại đây\nSử dụng R để thao tác GIS thoạt đầu có vẻ đáng sợ hơn bởi vì thay bằng các “thao tác chuột”, nó có “giao diện dòng lệnh” (bạn phải viết code để có được kết quả mong muốn). Tuy nhiên, đây là một lợi thế lớn nếu bạn cần tạo bản đồ lặp đi lặp lại hoặc tạo các phân tích có thể tái lập được.\n\n\nDữ liệu không gian\nHai dạng dữ liệu không gian chính được sử dụng trong GIS là dữ liệu vectơ và raster:\nVector Data - Định dạng phổ biến nhất của dữ liệu không gian được sử dụng trong GIS, dữ liệu vectơ bao gồm các đặc điểm hình học của vertices and paths. Dữ liệu không gian dạng vectơ có thể được chia thành ba loại nhỏ được sử dụng rộng rãi:\n\nĐiểm (Points) - Một điểm bao gồm một cặp tọa độ (x, y) đại diện cho một vị trí cụ thể trong một hệ tọa độ. Điểm là dạng dữ liệu không gian cơ bản nhất và có thể được sử dụng để biểu thị một trường hợp (vd: nhà bệnh nhân) hoặc một vị trí (vd: bệnh viện) trên bản đồ.\nĐường (Lines) - Một đường bao gồm hai điểm kết nối với nhau. Đường có độ dài và có thể được sử dụng để biểu thị những thứ như con đường hoặc sông.\nĐa giác (Polygons) - A polygon is composed of at least three line segments connected by points. Polygon features have a length (i.e. the perimeter of the area) as well as an area measurement. Polygons may be used to note an area (i.e. a village) or a structure (i.e. the actual area of a hospital).\n\nRaster Data - Một đa giác bao gồm ít nhất ba đoạn thẳng được nối với nhau bằng các điểm. Các đối tượng đa giác có chiều dài (vd: chu vi của khu vực) cũng như số đo diện tích. Đa giác có thể được sử dụng để biểu diễn một khu vực (vd: một ngôi làng) hoặc một cấu trúc (vd: diện tích thực tế của một bệnh viện).\n\n\nTrực quan hóa dữ liệu không gian\nĐể thể hiện trực quan dữ liệu không gian trên bản đồ, phần mềm GIS yêu cầu bạn cung cấp đầy đủ thông tin về vị trí của các đối tượng địa lý khác nhau, trong mối quan hệ của chúng với nhau. Nếu bạn đang sử dụng dữ liệu vectơ, điều này sẽ đúng cho hầu hết các trường hợp sử dụng, thông tin này thường sẽ được lưu trữ trong một shapefile:\nShapefiles - Shapefile là một định dạng dữ liệu phổ biến để lưu trữ dữ liệu không gian “vectơ” bao gồm hoặc đường, điểm hoặc đa giác. Một shapefile thực chất là một tập hợp của ít nhất ba tệp - .shp, .shx và .dbf. Tất cả các tệp thành phần phụ này phải nằm trong cùng một thư mục để chúng có thể đọc được. Các tệp liên quan này có thể được nén vào một thư mục ZIP để gửi qua email hoặc tải xuống từ một trang web.\nShapefile sẽ chứa thông tin về bản thân các đối tượng địa lý cũng như vị trí định vị chúng trên bề mặt Trái đất. Điều này rất quan trọng bởi vì trong khi Trái đất là một quả địa cầu, các bản đồ thường là hai chiều; các lựa chọn về cách “làm phẳng” dữ liệu không gian có thể có tác động lớn đến giao diện và cách giải thích các kết quả..\nHệ trục tọa độ tham chiếu (Coordinate Reference Systems - CRS) - CRS là một hệ thống dựa trên tọa độ được sử dụng để xác định vị trí các đối tượng địa lý trên bề mặt Trái đất. Nó có một số thành phần chính:\n\nHệ tọa độ - Có nhiều hệ tọa độ khác nhau, vì vậy hãy đảm bảo rằng bạn biết hệ tọa độ của mình là từ hệ nào. Các kinh độ/vĩ độ là phổ biến nhẩt, nhưng bạn cũng có thể gặp hệ tọa độ UTM.\nĐơn vị - Các đơn vị dành cho hệ tọa độ của bạn (ví dụ: độ thập phân, mét)\nDữ liệu - Một phiên bản được mô hình hóa cụ thể của Trái đất. Chúng đã được sửa đổi trong nhiều năm, vì vậy hãy đảm bảo rằng các lớp bản đồ của bạn đang sử dụng cùng một dữ liệu..\nPhép chiếu - Tham chiếu đến phương trình toán học được sử dụng để chiếu trái đất hình tròn lên một bề mặt phẳng (bản đồ).\n\nHãy nhớ rằng bạn có thể tóm tắt dữ liệu không gian mà không cần sử dụng các công cụ lập bản đồ được hiển thị bên dưới. Đôi khi một bảng đơn giản phân chia theo địa lý (ví dụ: huyện, quốc gia, v.v.) là tất cả những gì cần thiết!",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>GIS cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.vn.html#bắt-đầu-với-gis",
    "href": "new_pages/gis.vn.html#bắt-đầu-với-gis",
    "title": "28  GIS cơ bản",
    "section": "28.3 Bắt đầu với GIS",
    "text": "28.3 Bắt đầu với GIS\nCó một số thứ quan trọng bạn sẽ cần phải có và suy nghĩ tới khi tạo bản đồ. Bao gồm:\n\nMột tập dữ liệu – tập dữ liệu này có thể ở định dạng dữ liệu không gian (chẳng hạn như shapefiles, như đã lưu ý ở trên) hoặc nó có thể không ở định dạng không gian (chẳng hạn như csv).\nNếu tập dữ liệu của bạn không ở định dạng không gian, bạn cũng sẽ cần một tập dữ liệu tham chiếu. Dữ liệu tham chiếu bao gồm biểu diễn không gian của dữ liệu và các thuộc tính liên quan, sẽ bao gồm tài liệu chứa thông tin vị trí và địa chỉ của các đối tượng địa lý cụ thể.\n\n+   Nếu bạn đang làm việc với các ranh giới địa lý được xác định trước (ví dụ: khu vực hành chính), các shapefiles tham chiếu thường có sẵn miễn phí để tải xuống từ cơ quan chính phủ hoặc tổ chức chia sẻ dữ liệu. Khi nghi ngờ, bạn có thể tìm kiếm trên Google cụm từ \"[tên vùng] shapefile\"\n\n+   Nếu bạn có thông tin địa chỉ, nhưng không có vĩ độ và kinh độ, bạn có thể cần sử dụng một **công cụ mã hóa địa lý** để lấy dữ liệu không gian tham chiếu cho bản ghi của mình.\n\nÝ tưởng về cách bạn muốn trình bày thông tin trong bộ dữ liệu của mình cho đối tượng mục tiêu. Có nhiều loại bản đồ khác nhau, và điều quan trọng là phải suy nghĩ xem loại bản đồ nào phù hợp nhất với nhu cầu của bạn.\n\n\nCác loại bản đồ để trực quan hóa dữ liệu\nBản đồ Choropleth - một loại bản đồ trong đó màu sắc, sự đổ bóng, hoặc các họa tiết được sử dụng để thể hiện các vùng địa lý liên quan đến giá trị của một thuộc tính. Ví dụ: giá trị lớn hơn có thể được biểu thị bằng màu tối hơn giá trị nhỏ hơn. Loại bản đồ này đặc biệt hữu ích khi trực quan hóa một biến số và xem cách nó thay đổi trên các vùng hoặc khu vực địa chính trị xác định.\n\n\n\n\n\n\n\n\n\nBản đồ nhiệt mật độ trường hợp - một loại bản đồ trong đó màu sắc được sử dụng để thể hiện cường độ của một giá trị, tuy nhiên, nó không sử dụng các vùng hoặc ranh giới địa chính trị xác định để nhóm dữ liệu. Loại bản đồ này thường được sử dụng để hiển thị ‘điểm nóng’ hoặc các khu vực có mật độ hoặc tập trung điểm cao.\n\n\n\n\n\n\n\n\n\nBản đồ mật độ điểm - một loại bản đồ sử dụng các điểm để biểu thị các giá trị thuộc tính trong dữ liệu của bạn. Loại bản đồ này được sử dụng tốt nhất để trực quan hóa phân tán dữ liệu của bạn và scan một cách trực quan các cụm.\nBản đồ ký hiệu tỷ lệ (bản đồ ký hiệu chia độ) - một loại bản đồ tương tự như bản đồ choropleth, nhưng thay vì sử dụng màu sắc để biểu thị giá trị của một thuộc tính, nó sử dụng một ký hiệu (thường là một vòng tròn) liên quan đến giá trị. Ví dụ, một giá trị lớn hơn có thể được biểu thị bằng một ký hiệu lớn hơn một giá trị nhỏ hơn. Loại bản đồ này được sử dụng tốt nhất khi bạn muốn trực quan hóa kích thước hoặc số lượng dữ liệu của mình trên các vùng địa lý.\nBạn cũng có thể kết hợp một số loại trực quan hóa khác nhau để hiển thị các trường hợp địa lý phức tạp. Ví dụ, các trường hợp (điểm) trong bản đồ dưới đây được tô màu theo cơ sở y tế gần nhất của họ (xem phần chú thích). Các vòng tròn lớn hiển thị cơ sở y tế gần nhất trong khu vực ở một bán kính xác định, và các điểm màu đỏ tươi là những cơ sở y tế không nằm trong bất kỳ bán kính nào:\n\n\n\n\n\n\n\n\n\nLưu ý: Trọng tâm chính trong chương GIS này được dựa trên tình huống đáp ứng các vụ dịch tại thực địa. Do đó, nội dung của chương sẽ bao gồm các thao tác, hình ảnh hóa và phân tích dữ liệu không gian cơ bản.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>GIS cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.vn.html#chuẩn-bị",
    "href": "new_pages/gis.vn.html#chuẩn-bị",
    "title": "28  GIS cơ bản",
    "section": "28.4 Chuẩn bị",
    "text": "28.4 Chuẩn bị\n\nGọi package\nĐoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R.\n\npacman::p_load(\n  rio,           # to import data\n  here,          # to locate files\n  tidyverse,     # to clean, handle, and plot the data (includes ggplot2 package)\n  sf,            # to manage spatial data using a Simple Feature format\n  tmap,          # to produce simple maps, works for both interactive and static maps\n  janitor,       # to clean column names\n  OpenStreetMap, # to add OSM basemap in ggplot map\n  spdep          # spatial statistics\n  ) \n\nBạn có thể xem tổng quan về tất cả các package trong R xử lý dữ liệu không gian tại CRAN “Spatial Task View”.\n\n\nDữ liệu trường hợp mẫu\nVới mục đích minh họa, chúng ta sẽ làm việc với một mẫu ngẫu nhiên gồm 1000 trường hợp từ bộ dữ liệu một vụ dịch Ebola mô phỏng có tên linelist (về mặt tính toán, việc làm việc với ít trường hợp hơn sẽ dễ hiển thị hơn trong sổ tay này). Để tiện the dõi, bấm để tải dữ liệu linelist “đã được làm sạch” (dưới dạng tệp .rds).\nVì chúng ta đang lấy một mẫu ngẫu nhiên của các trường hợp, nên kết quả của bạn có thể hơi khác so với những gì được minh họa ở đây khi bạn tự chạy code của mình.\nNhập dữ liệu vào bằng hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương Nhập xuất dữ liệu để biết thêm chi tiết).\n\n# import clean case linelist\nlinelist &lt;- import(\"linelist_cleaned.rds\")  \n\nTiếp theo, chúng ta chọn một mẫu ngẫu nhiên gồm 1000 hàng bằng hàm sample() từ base R.\n\n# generate 1000 random row numbers, from the number of rows in linelist\nsample_rows &lt;- sample(nrow(linelist), 1000)\n\n# subset linelist to keep only the sample rows, and all columns\nlinelist &lt;- linelist[sample_rows,]\n\nBây giờ chúng ta muốn chuyển đổi bộ dữ liệu linelist đang là một dataframe, thành một đối tượng “sf” (spatial features - các đặc tính không gian). Do bộ dữ liệu linelist có hai cột “lon” và “lat” đại diện cho kinh độ và vĩ độ của nơi cư trú của từng trường hợp, nên việc chuyển đổi này khá dễ dàng.\nChúng ta sử dụng package sf (spatial features - các đặc tính không gian) và hàm st_as_sf() của nó để tạo đối tượng mới có tên linelist_sf. Đối tượng mới này về cơ bản giống với linelist, nhưng các cột lon và lat đã được chỉ định là cột tọa độ, và một hệ thống tham chiếu tọa độ (CRS) đã được gán khi các điểm được hiển thị. 4326 xác định tọa độ của chúng ta dựa trên Hệ thống trắc địa thế giới 1984 (WGS84) - là tiêu chuẩn cho tọa độ GPS.\n\n# Create sf object\nlinelist_sf &lt;- linelist %&gt;%\n     sf::st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326)\n\nDưới đây là cách bộ dữ liệu linelist gốc được hiển thị. Trong phần minh họa này, chúng ta sẽ chỉ sử dụng cột date_onset và geometry (được xây dựng từ các trường kinh độ và vĩ độ ở trên và là cột cuối cùng trong khung dữ liệu).\n\nDT::datatable(head(linelist_sf, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )\n\n\n\n\n\n\n\nShapefiles phân cấp hành chính\nSierra Leone: shapefiles phân cấp hành chính\nTrước đó, chúng tôi đã tải xuống tất cả các phân cấp hành chính của Sierra Leone từ website của Humanitarian Data Exchange (HDX). Ngoài ra, bạn có thể tải xuống các dữ liệu này và tất cả các dữ liệu mẫu khác cho sổ tay này qua gói R của chúng tôi, như được giải thích trong trang Tải sách và dữ liệu.\nBây giờ chúng ta sẽ thực hiện những bước sau để lưu shapefile hành chính cấp 3 vào R:\n\nNhập shapefile\n\nLàm sạch tên cột\n\nLọc các hàng để chỉ giữ lại các khu vực quan tâm\n\nĐể nhập một shapefile, chúng ta sử dụng hàm read_sf() từ package sf. Nó được cung cấp đường dẫn tệp thông qua hàm here(). - trong trường hợp này tệp nằm bên trong Dự án R của bạn tại thư mục “data”, rồi tới “gis”, và thư mục con “shp”, với tệp có tên “sle_adm3.shp” (xem chương Nhập xuất dữ liệu và Dự án R để biết thêm chi tiết). Bạn sẽ cần cung cấp đường dẫn tệp của riêng mình.\nTiếp theo, chúng ta sử dụng hàm clean_names() từ package janitor để chuẩn hóa tên các cột của shapefile. Chúng ta cũng sử dụng hàm filter() để chỉ giữ lại các hàng có tên admin2 là “Western Area Urban” hoặc “Western Area Rural”.\n\n# ADM3 level clean\nsle_adm3 &lt;- sle_adm3_raw %&gt;% \n  janitor::clean_names() %&gt;% # standardize column names\n  filter(admin2name %in% c(\"Western Area Urban\", \"Western Area Rural\")) # filter to keep certain areas\n\nDưới đây, bạn có thể thấy shapefile trông như thế nào sau khi nhập và làm sạch. Cuộn sang phải to see how there are columns hành chính cấp 0 (quốc gia), hành chính cấp 1, hành chính cấp 2, và cuối cùng là hành chính cấp 3. Mỗi cấp độ có một tên và một mã định danh duy nhất “pcode”. Pcode mở rộng với mỗi sự tăng lên của cấp hành chính, vd. SL (Sierra Leone) -&gt; SL04 (Western) -&gt; SL0410 (Western Area Rural) -&gt; SL040101 (Koya Rural).\n\n\n\n\n\n\n\n\nDữ liệu dân số\nSierra Leone: Dân số theo ADM3\nNhững dữ liệu này có thể tải xuống từ HDX (link tại đây) hoặc thông qua R package epirhandbook như đã được giải thích trong chương này. Chúng ta cũng sử dụng hàm import() để nạp tệp .csv. Chúng tôi cũng chuyển file được nhập tới hàm clean_names() để chuẩn hóa cú pháp tên cột.\n\n# Population by ADM3\nsle_adm3_pop &lt;- import(here(\"data\", \"gis\", \"population\", \"sle_admpop_adm3_2020.csv\")) %&gt;%\n  janitor::clean_names()\n\nBộ dữ liệu dân số trông sẽ như bên dưới. Cuộn sang bên phải để xem các cột: dân số nam (male population), dân số nữ (female populaton), tổng dân số (total population), và dân số theo từng nhóm tuổi.\n\n\n\n\n\n\n\n\nCác cơ sở y tế\nSierra Leone: Dữ liệu cơ sở y tế từ OpenStreetMap\nMột lần nữa, bạn có thể tải xuống thông tin vị trí của các cơ sở y tế từ HDX tại đây hoặc thông qua hướng dẫn trong chương Tải sách và dữ liệu.\nChúng ta nhập shapefile tọa độ điểm các cơ sở với hàm read_sf(), làm sạch lại tên cột, sau đó lọc để chỉ giữ lại các điểm được gắn thẻ là “hospital”, “clinic”, hoặc “doctors”.\n\n# OSM health facility shapefile\nsle_hf &lt;- sf::read_sf(here(\"data\", \"gis\", \"shp\", \"sle_hf.shp\")) %&gt;% \n  janitor::clean_names() %&gt;%\n  filter(amenity %in% c(\"hospital\", \"clinic\", \"doctors\"))\n\nDưới đây là dataframe kết quả - Cuộn phải để xem tên cơ sở và tọa độ geometry.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>GIS cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.vn.html#vẽ-đồ-thị-tọa-độ",
    "href": "new_pages/gis.vn.html#vẽ-đồ-thị-tọa-độ",
    "title": "28  GIS cơ bản",
    "section": "28.5 Vẽ đồ thị tọa độ",
    "text": "28.5 Vẽ đồ thị tọa độ\nCách dễ nhất để vẽ đồ thị tọa độ X-Y (kinh độ / vĩ độ, điểm), trong trường hợp này, là vẽ chúng dưới dạng điểm trực tiếp từ đối tượng linelist_sf mà chúng ta đã tạo trong phần chuẩn bị.\nPackage tmap cung cấp khả năng lập bản đồ đơn giản ở cả dạng tĩnh (“plot” mode) và tương tác (“view” mode) chỉ với một vài dòng code. Cú pháp của tmap tương tự như cú pháp của ggplot2, chẳng hạn như các lệnh được thêm vào nhau bằng dấu +. Đọc thêm chi tiết trong hướng dẫn này.\n\nThiết lập tmap mode. Trong trường hợp này chúng ta sẽ sử dụng “plot” mode để tạo ra các biểu đồ tĩnh.\n\n\ntmap_mode(\"plot\") # choose either \"view\" or \"plot\"\n\nDưới đây, các điểm được vẽ độc lập. Hàm tm_shape() được cung cấp bởi đối tượng linelist_sf. Chúng ta sau đó thêm các điểm thông qua hàm tm_dots(), và cụ thể kích thước và màu sắc. linelist_sf là một đối tượng sf đã được chúng ta chỉ định hai cột chứa tọa độ vĩ độ/kinh độ và hệ quy chiếu tọa độ (CRS):\n\n# Just the cases (points)\ntm_shape(linelist_sf) + tm_dots(size=0.08, col='blue')\n\n\n\n\n\n\n\n\nKhi đứng một mình, các điểm không cho biết nhiều thông tin. Vì vậy, chúng ta nên lập bản đồ địa giới hành chính:\nMột lần nữa chúng ta sử dụng hàm tm_shape() (xem tài liệu này) nhưng thay vì cung cấp shapefile tọa độ điểm các trường hợp, chúng ta cung cấp shapefile địa giới hành chính (đa giác).\nVới đối số bbox = (bbox là viết tắt của “bounding box”), chúng ta có thể chỉ định các ranh giới tọa độ. Đầu tiên, chúng ta hiển thị bản đồ mà không có bbox, và sau đó thêm nó vào.\n\n# Just the administrative boundaries (polygons)\ntm_shape(sle_adm3) +               # admin boundaries shapefile\n  tm_polygons(col = \"#F7F7F7\")+    # show polygons in light grey\n  tm_borders(col = \"#000000\",      # show borders with color and line weight\n             lwd = 2) +\n  tm_text(\"admin3name\")            # column text to display for each polygon\n\n\n# Same as above, but with zoom from bounding box\ntm_shape(sle_adm3,\n         bbox = c(-13.3, 8.43,    # corner\n                  -13.2, 8.5)) +  # corner\n  tm_polygons(col = \"#F7F7F7\") +\n  tm_borders(col = \"#000000\", lwd = 2) +\n  tm_text(\"admin3name\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVà bây giờ hiển thị các điểm và đa giác cùng nhau:\n\n# All together\ntm_shape(sle_adm3, bbox = c(-13.3, 8.43, -13.2, 8.5)) +     #\n  tm_polygons(col = \"#F7F7F7\") +\n  tm_borders(col = \"#000000\", lwd = 2) +\n  tm_text(\"admin3name\")+\ntm_shape(linelist_sf) +\n  tm_dots(size=0.08, col='blue', alpha = 0.5) +\n  tm_layout(title = \"Distribution of Ebola cases\")   # give title to map\n\n\n\n\n\n\n\n\nĐể đọc một bài so sánh hay về các tùy chọn vẽ bản đồ trong R, hãy xem bài đăng blog này.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>GIS cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.vn.html#phép-nối-theo-không-gian",
    "href": "new_pages/gis.vn.html#phép-nối-theo-không-gian",
    "title": "28  GIS cơ bản",
    "section": "28.6 Phép nối theo không gian",
    "text": "28.6 Phép nối theo không gian\nBạn có thể đã quen với việc nối dữ liệu từ một tập dữ liệu này sang một tập dữ liệu khác. Một số phương pháp được thảo luận trong chương Nối dữ liệu của cuốn sổ tay này. Một phép nối theo không gian phục vụ một mục đích tương tự nhưng tận dụng các mối quan hệ không gian. Thay vì dựa vào các giá trị chung trong các cột để khớp chính xác các quan sát, bạn có thể sử dụng các mối quan hệ không gian của chúng, chẳng hạn như một đối tượng địa lý nằm trong đối tượng khác, hoặc hàng xóm gần nhất với đối tượng khác, hoặc ở trong vùng đệm của một bán kính nhất định từ đối tượng khác, v.v.\nPackage sf cung cấp nhiều phương thức khác nhau để nối theo không gian. Xem thêm tài liệu về phương pháp st_join và các kiểu nối theo không gian trong tài liệu tham khảo này.\n\nĐiểm trong đa giác\nGán đơn vị hành chính cho các trường hợp theo không gian\nSau đây là một câu hỏi hóc búa thú vị: linelist không chứa bất kỳ thông tin nào về các đơn vị hành chính của các trường hợp. Mặc dù lý tưởng nhất là thu thập thông tin như vậy trong giai đoạn thu thập dữ liệu ban đầu, chúng ta cũng có thể gán các đơn vị hành chính cho các trường hợp riêng lẻ dựa trên mối quan hệ không gian của chúng (tức là điểm giao với một đa giác)..\nDưới đây, chúng ta sẽ giao các vị trí (điểm) theo không gian với địa giới hành chính cấp 3 (đa giác):\n\nBắt đầu với linelist (các điểm)\n\nNối theo không gian tới các địa giới, thiết lập kiểu nối là “st_intersects”\n\nSử dụng hàm select() để chỉ giữ lại một số cột địa giới hành chính mới\n\n\nlinelist_adm &lt;- linelist_sf %&gt;%\n  \n  # join the administrative boundary file to the linelist, based on spatial intersection\n  sf::st_join(sle_adm3, join = st_intersects)\n\nTất cả các cột từ sle_adms đã được thêm vào linelist! Mỗi trường hợp bây giờ có các cột thể hiện chi tiết cấp hành chính mà nó nằm trong đó. Trong ví dụ này, chúng ta chỉ muốn giữ lại hai trong số các cột mới (địa giới hành chính cấp 3), vì vậy chúng dùng hàm select() để chọn tên các cột cũ và chỉ hai cột bổ sung quan tâm:\n\nlinelist_adm &lt;- linelist_sf %&gt;%\n  \n  # join the administrative boundary file to the linelist, based on spatial intersection\n  sf::st_join(sle_adm3, join = st_intersects) %&gt;% \n  \n  # Keep the old column names and two new admin ones of interest\n  select(names(linelist_sf), admin3name, admin3pcod)\n\nDưới đây, chỉ với mục đích hiển thị, bạn có thể thấy mười trường hợp đầu tiên và địa giới hành chính cấp 3 của chúng đã được gắn với nhau, dựa trên vị trí giao nhau trong không gian giữa các điểm với đa giác.\n\n# Now you will see the ADM3 names attached to each case\nlinelist_adm %&gt;% select(case_id, admin3name, admin3pcod)\n\nSimple feature collection with 1000 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -13.2709 ymin: 8.447753 xmax: -13.20522 ymax: 8.490662\nGeodetic CRS:  WGS 84\nFirst 10 features:\n     case_id     admin3name admin3pcod                   geometry\n1679  9ae82c         East I   SL040203  POINT (-13.2173 8.487221)\n3011  6d6a86        West II   SL040207 POINT (-13.24628 8.466879)\n4139  8da173 Mountain Rural   SL040102 POINT (-13.21589 8.451834)\n5044  1154b1 Mountain Rural   SL040102 POINT (-13.22102 8.463624)\n1647  ecd845        West II   SL040207  POINT (-13.24534 8.46586)\n3163  bbda1c Mountain Rural   SL040102 POINT (-13.21161 8.467091)\n2743  a7634a Mountain Rural   SL040102 POINT (-13.20891 8.453408)\n1109  c4c05a        East II   SL040204  POINT (-13.2204 8.483799)\n5742  ff211d Mountain Rural   SL040102 POINT (-13.22246 8.480502)\n4034  954007 Mountain Rural   SL040102 POINT (-13.21928 8.478523)\n\n\nBây giờ chúng ta có thể mô tả các trường hợp theo đơn vị hành chính - điều mà chúng ta đã không thể làm trước khi nối theo không gian!\n\n# Make new dataframe containing counts of cases by administrative unit\ncase_adm3 &lt;- linelist_adm %&gt;%          # begin with linelist with new admin cols\n  as_tibble() %&gt;%                      # convert to tibble for better display\n  group_by(admin3pcod, admin3name) %&gt;% # group by admin unit, both by name and pcode \n  summarise(cases = n()) %&gt;%           # summarize and count rows\n  arrange(desc(cases))                 # arrange in descending order\n\ncase_adm3\n\n# A tibble: 10 × 3\n# Groups:   admin3pcod [10]\n   admin3pcod admin3name     cases\n   &lt;chr&gt;      &lt;chr&gt;          &lt;int&gt;\n 1 SL040102   Mountain Rural   281\n 2 SL040208   West III         228\n 3 SL040207   West II          177\n 4 SL040204   East II          124\n 5 SL040201   Central I         62\n 6 SL040203   East I            51\n 7 SL040206   West I            39\n 8 SL040202   Central II        21\n 9 SL040205   East III          13\n10 &lt;NA&gt;       &lt;NA&gt;               4\n\n\nChúng ta cũng có thể tạo một biểu đồ cột về số lượng trường hợp theo đơn vị hành chính.\nTrong ví dụ này, chúng ta bắt đầu hàm ggplot() với bộ dữ liệu linelist_adm, trong đó chúng ta có thể áp dụng các hàm làm việc với factor như fct_infreq() để sắp xếp các cột theo tần suất (xem chương Factors để biết thêm các mẹo).\n\nggplot(\n    data = linelist_adm,                       # begin with linelist containing admin unit info\n    mapping = aes(\n      x = fct_rev(fct_infreq(admin3name))))+ # x-axis is admin units, ordered by frequency (reversed)\n  geom_bar()+                                # create bars, height is number of rows\n  coord_flip()+                              # flip X and Y axes for easier reading of adm units\n  theme_classic()+                           # simplify background\n  labs(                                      # titles and labels\n    x = \"Admin level 3\",\n    y = \"Number of cases\",\n    title = \"Number of cases, by adminstative unit\",\n    caption = \"As determined by a spatial join, from 1000 randomly sampled cases from linelist\"\n  )\n\n\n\n\n\n\n\n\n\n\n\nHàng xóm gần nhất\nTìm cơ sở y tế gần nhất / khu vực cung cấp dịch vụ y tế\nCó thể sẽ hữu ích nếu biết các cơ sở y tế nằm ở đâu trong mối liên quan đến các điểm nóng về dịch bệnh.\nChúng ta có thể sử dụng phương pháp nối st_nearest_feature trong hàm st_join() (sf package) để trực quan hóa cơ sở y tế gần nhất với các trường hợp bệnh nhân.\n\nChúng ta bắt đầu với shapefile linelist có tên linelist_sf\n\nChúng ta nối theo không gian với đối tượng sle_hf, chứa thông tin về vị trí của các cơ sở y tế và phòng khám (các điểm)\n\n\n# Closest health facility to each case\nlinelist_sf_hf &lt;- linelist_sf %&gt;%                  # begin with linelist shapefile  \n  st_join(sle_hf, join = st_nearest_feature) %&gt;%   # data from nearest clinic joined to case data \n  select(case_id, osm_id, name, amenity) %&gt;%       # keep columns of interest, including id, name, type, and geometry of healthcare facility\n  rename(\"nearest_clinic\" = \"name\")                # re-name for clarity\n\nChúng ta có thể thấy bên dưới (50 hàng đầu tiên) rằng mỗi trường hợp hiện đã có dữ liệu về phòng khám/bệnh viện gần nhất\n\n\n\n\n\n\nChúng ta có thể thấy rằng “Den Clinic” là cơ sở y tế gần nhất với khoảng ~30% các trường hợp.\n\n# Count cases by health facility\nhf_catchment &lt;- linelist_sf_hf %&gt;%   # begin with linelist including nearest clinic data\n  as.data.frame() %&gt;%                # convert from shapefile to dataframe\n  count(nearest_clinic,              # count rows by \"name\" (of clinic)\n        name = \"case_n\") %&gt;%         # assign new counts column as \"case_n\"\n  arrange(desc(case_n))              # arrange in descending order\n\nhf_catchment                         # print to console\n\n                         nearest_clinic case_n\n1                            Den Clinic    360\n2       Shriners Hospitals for Children    339\n3         GINER HALL COMMUNITY HOSPITAL    185\n4                             panasonic     58\n5 Princess Christian Maternity Hospital     26\n6                     ARAB EGYPT CLINIC     13\n7                                  &lt;NA&gt;     10\n8                  MABELL HEALTH CENTER      9\n\n\nĐể trực quan hóa kết quả, chúng ta có thể sử dụng tmap - lúc này interactive mode sẽ xem dễ dàng hơn\n\ntmap_mode(\"view\")   # set tmap mode to interactive  \n\n# plot the cases and clinic points \ntm_shape(linelist_sf_hf) +            # plot cases\n  tm_dots(size=0.08,                  # cases colored by nearest clinic\n          col='nearest_clinic') +    \ntm_shape(sle_hf) +                    # plot clinic facilities in large black dots\n  tm_dots(size=0.3, col='black', alpha = 0.4) +      \n  tm_text(\"name\") +                   # overlay with name of facility\ntm_view(set.view = c(-13.2284, 8.4699, 13), # adjust zoom (center coords, zoom)\n        set.zoom.limits = c(13,14))+\ntm_layout(title = \"Cases, colored by nearest clinic\")\n\n\n\n\n\n\n\nVùng đệm\nChúng ta cũng có thể tìm hiểu xem có bao nhiêu trường hợp nằm trong khoảng cách đi bộ 2,5 km (~30 phút) từ cơ sở y tế gần nhất.\nChú ý: Để tính toán khoảng cách chính xác hơn, tốt hơn nên chiếu lại đối tượng sf của bạn lên hệ thống chiếu bản đồ địa phương tương ứng chẳng hạn như UTM (Trái đất được chiếu lên bề mặt phẳng). Trong ví dụ này, để đơn giản hơn, chúng ta sẽ dựa vào Hệ tọa độ địa lý của Hệ thống trắc địa thế giới (WGS84) (Trái đất được biểu diễn trong một bề mặt hình cầu/tròn, do đó các đơn vị được tính bằng độ thập phân). Chúng ta sẽ sử dụng quy đổi chung là: 1 độ thập phân = ~111km.\nXem thêm thông tin về phép chiếu bản đồ và hệ tọa độ tại bài viết này esri article. Blog này nói về các loại phép chiếu bản đồ khác nhau và cách người ta có thể chọn phép chiếu phù hợp tùy thuộc vào khu vực quan tâm và bối cảnh của bản đồ/phân tích của bạn.\nĐầu tiên, tạo một vùng đệm hình tròn với bán kính ~2.5km xung quanh mỗi cơ sở y tế. Điều này được thực hiện với hàm st_buffer() trong package tmap. Bởi vì đơn vị của bản đồ là kinh/vĩ độ thập phân, đó là cách “0.02” được diễn giải. Nếu hệ tọa độ bản đồ của bạn tính bằng mét, thì số đó phải được cung cấp bằng mét.\n\nsle_hf_2k &lt;- sle_hf %&gt;%\n  st_buffer(dist=0.02)       # decimal degrees translating to approximately 2.5km \n\nSau đây chúng ta vẽ biểu đồ của chính các vùng đệm, với:\n\ntmap_mode(\"plot\")\n# Create circular buffers\ntm_shape(sle_hf_2k) +\n  tm_borders(col = \"black\", lwd = 2)+\ntm_shape(sle_hf) +                    # plot clinic facilities in large red dots\n  tm_dots(size=0.3, col='black')      \n\n\n\n\n\n\n\n\nThứ hai, chúng ta giao các vùng đệm này với các trường hợp (điểm) bằng cách sử dụng hàm st_join() và kiểu nối là st_intersects. Tức là, dữ liệu từ vùng đệm được nối với các điểm mà chúng giao với nhau.\n\n# Intersect the cases with the buffers\nlinelist_sf_hf_2k &lt;- linelist_sf_hf %&gt;%\n  st_join(sle_hf_2k, join = st_intersects, left = TRUE) %&gt;%\n  filter(osm_id.x==osm_id.y | is.na(osm_id.y)) %&gt;%\n  select(case_id, osm_id.x, nearest_clinic, amenity.x, osm_id.y)\n\nBây giờ chúng ta có thể đếm kết quả: có nrow(linelist_sf_hf_2k[is.na(linelist_sf_hf_2k$osm_id.y),]) trường hợp trong số 1000 trường hợp không giao nhau với bất kỳ vùng đệm nào (giá trị đó bị thiếu), và do đó họ sống ở nơi cách nhiều hơn 30 phút đi bộ tới cơ sở y tế gần nhất.\n\n# Cases which did not get intersected with any of the health facility buffers\nlinelist_sf_hf_2k %&gt;% \n  filter(is.na(osm_id.y)) %&gt;%\n  nrow()\n\n[1] 1000\n\n\nChúng ta có thể trực quan hóa kết quả sao cho các trường hợp không giao nhau với bất kỳ vùng đệm nào sẽ xuất hiện với màu đỏ.\n\ntmap_mode(\"view\")\n\n# First display the cases in points\ntm_shape(linelist_sf_hf) +\n  tm_dots(size=0.08, col='nearest_clinic') +\n\n# plot clinic facilities in large black dots\ntm_shape(sle_hf) +                    \n  tm_dots(size=0.3, col='black')+   \n\n# Then overlay the health facility buffers in polylines\ntm_shape(sle_hf_2k) +\n  tm_borders(col = \"black\", lwd = 2) +\n\n# Highlight cases that are not part of any health facility buffers\n# in red dots  \ntm_shape(linelist_sf_hf_2k %&gt;%  filter(is.na(osm_id.y))) +\n  tm_dots(size=0.1, col='red') +\ntm_view(set.view = c(-13.2284,8.4699, 13), set.zoom.limits = c(13,14))+\n\n# add title  \ntm_layout(title = \"Cases by clinic catchment area\")\n\n\n\n\n\n\n\nCác hàm nối theo không gian khác\nCác giá trị tùy chọn cho đối số join bao gồm (lấy từ tài liệu này)\n\nst_contains_properly\n\nst_contains\n\nst_covered_by\n\nst_covers\n\nst_crosses\n\nst_disjoint\n\nst_equals_exact\n\nst_equals\n\nst_is_within_distance\n\nst_nearest_feature\n\nst_overlaps\n\nst_touches\n\nst_within",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>GIS cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.vn.html#bản-đồ-choropleth",
    "href": "new_pages/gis.vn.html#bản-đồ-choropleth",
    "title": "28  GIS cơ bản",
    "section": "28.7 Bản đồ Choropleth",
    "text": "28.7 Bản đồ Choropleth\nBản đồ Choropleth có thể hữu ích để trực quan hóa dữ liệu của bạn theo khu vực được xác định trước, thường là đơn vị hành chính hoặc khu vực y tế. Ví dụ, trong ứng phó với ổ dịch, điều này có thể giúp xác định mục tiêu phân bổ nguồn lực cho các khu vực cụ thể có tỷ lệ mắc bệnh cao.\nBây giờ chúng ta đã gán tên đơn vị hành chính cho tất cả các trường hợp (xem phần về phép nối không gian, ở trên), chúng ta có thể bắt đầu lập bản đồ số lượng trường hợp theo khu vực (bản đồ choropleth).\nVì chúng ta cũng có dữ liệu dân số theo cấp hành chính cấp 3 (ADM3), chúng ta có thể thêm thông tin này vào bảng case_adm3 đã được tạo trước đó.\nChúng ta bắt đầu với dataframe case_adm3 được tạo trong bước trước đó, là bảng tóm tắt của từng đơn vị hành chính và số lượng các trường hợp của nó.\n\nDữ liệu dân số sle_adm3_pop được nối sử dụng hàm left_join() từ dplyr trên cơ sở các giá trị chung trên cột admin3pcod trong bộ dữ liệu case_adm3, và cột adm_pcode trong bộ dữ liệu sle_adm3_pop. Xem chương Nối dữ liệu).\n\nselect() được áp dụng trên dataframe mới, để chỉ giữ những cột cần thiệt - total nghĩa là tổng dân số\n\nCác trường hợp trên 10,000 dân được tính toán bằng cách tạo cột mới với hàm mutate()\n\n\n# Add population data and calculate cases per 10K population\ncase_adm3 &lt;- case_adm3 %&gt;% \n     left_join(sle_adm3_pop,                             # add columns from pop dataset\n               by = c(\"admin3pcod\" = \"adm3_pcode\")) %&gt;%  # join based on common values across these two columns\n     select(names(case_adm3), total) %&gt;%                 # keep only important columns, including total population\n     mutate(case_10kpop = round(cases/total * 10000, 3)) # make new column with case rate per 10000, rounded to 3 decimals\n\ncase_adm3                                                # print to console for viewing\n\n# A tibble: 10 × 5\n# Groups:   admin3pcod [10]\n   admin3pcod admin3name     cases  total case_10kpop\n   &lt;chr&gt;      &lt;chr&gt;          &lt;int&gt;  &lt;int&gt;       &lt;dbl&gt;\n 1 SL040102   Mountain Rural   281  33993       82.7 \n 2 SL040208   West III         228 210252       10.8 \n 3 SL040207   West II          177 145109       12.2 \n 4 SL040204   East II          124  99821       12.4 \n 5 SL040201   Central I         62  69683        8.90\n 6 SL040203   East I            51  68284        7.47\n 7 SL040206   West I            39  60186        6.48\n 8 SL040202   Central II        21  23874        8.80\n 9 SL040205   East III          13 500134        0.26\n10 &lt;NA&gt;       &lt;NA&gt;               4     NA       NA   \n\n\nNối bảng này với đa giác shapfile ADM3 để vẽ bản đồ\n\ncase_adm3_sf &lt;- case_adm3 %&gt;%                 # begin with cases & rate by admin unit\n  left_join(sle_adm3, by=\"admin3pcod\") %&gt;%    # join to shapefile data by common column\n  select(objectid, admin3pcod,                # keep only certain columns of interest\n         admin3name = admin3name.x,           # clean name of one column\n         admin2name, admin1name,\n         cases, total, case_10kpop,\n         geometry) %&gt;%                        # keep geometry so polygons can be plotted\n  drop_na(objectid) %&gt;%                       # drop any empty rows\n\n  st_as_sf()                                  # convert to shapefile\n\nVẽ bản đồ kết quả\n\n# tmap mode\ntmap_mode(\"plot\")               # view static map\n\n# plot polygons\ntm_shape(case_adm3_sf) + \n        tm_polygons(\"cases\") +  # color by number of cases column\n        tm_text(\"admin3name\")   # name display\n\n\n\n\n\n\n\n\nChúng ta cũng có thể lập bản đồ tỷ suất mới mắc\n\n# Cases per 10K population\ntmap_mode(\"plot\")             # static viewing mode\n\n# plot\ntm_shape(case_adm3_sf) +                # plot polygons\n  tm_polygons(\"case_10kpop\",            # color by column containing case rate\n              breaks=c(0, 10, 50, 100), # define break points for colors\n              palette = \"Purples\"       # use a purple color palette\n              ) +\n  tm_text(\"admin3name\")                 # display text",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>GIS cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.vn.html#vẽ-bản-đồ-với-ggplot2",
    "href": "new_pages/gis.vn.html#vẽ-bản-đồ-với-ggplot2",
    "title": "28  GIS cơ bản",
    "section": "28.8 Vẽ bản đồ với ggplot2",
    "text": "28.8 Vẽ bản đồ với ggplot2\nNếu bạn đã quen với việc sử dụng ggplot2, bạn có thể sử dụng package này để vẽ bản đồ tĩnh cho dữ liệu của bạn. Hàm geom_sf() sẽ vẽ các đối tượng khác nhau dựa trên các đối tượng địa lý (điểm, đường thẳng hoặc đa giác) có trong dữ liệu của bạn. Ví dụ: bạn có thể sử dụng hàm geom_sf() trong ggplot() bằng cách sử dụng dữ liệu sf với dạng hình học đa giác để tạo bản đồ choropleth.\nĐể minh họa cách thức hoạt động của nó, Chúng ta có thể bắt đầu với shapefile đa giác ADM3 mà chúng ta đã sử dụng lúc trước. Xin nhớ lại rằng đây là các khu vực hành chính cấp 3 ở Sierra Leone:\n\nsle_adm3\n\nSimple feature collection with 12 features and 19 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -13.29894 ymin: 8.094272 xmax: -12.91333 ymax: 8.499809\nGeodetic CRS:  WGS 84\n# A tibble: 12 × 20\n   objectid admin3name   admin3pcod admin3ref_n admin2name admin2pcod admin1name\n *    &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;     \n 1      155 Koya Rural   SL040101   Koya Rural  Western A… SL0401     Western   \n 2      156 Mountain Ru… SL040102   Mountain R… Western A… SL0401     Western   \n 3      157 Waterloo Ru… SL040103   Waterloo R… Western A… SL0401     Western   \n 4      158 York Rural   SL040104   York Rural  Western A… SL0401     Western   \n 5      159 Central I    SL040201   Central I   Western A… SL0402     Western   \n 6      160 East I       SL040203   East I      Western A… SL0402     Western   \n 7      161 East II      SL040204   East II     Western A… SL0402     Western   \n 8      162 Central II   SL040202   Central II  Western A… SL0402     Western   \n 9      163 West III     SL040208   West III    Western A… SL0402     Western   \n10      164 West I       SL040206   West I      Western A… SL0402     Western   \n11      165 West II      SL040207   West II     Western A… SL0402     Western   \n12      167 East III     SL040205   East III    Western A… SL0402     Western   \n# ℹ 13 more variables: admin1pcod &lt;chr&gt;, admin0name &lt;chr&gt;, admin0pcod &lt;chr&gt;,\n#   date &lt;date&gt;, valid_on &lt;date&gt;, valid_to &lt;date&gt;, shape_leng &lt;dbl&gt;,\n#   shape_area &lt;dbl&gt;, rowcacode0 &lt;chr&gt;, rowcacode1 &lt;chr&gt;, rowcacode2 &lt;chr&gt;,\n#   rowcacode3 &lt;chr&gt;, geometry &lt;MULTIPOLYGON [°]&gt;\n\n\nChúng ta có thể sử dụng hàm left_join() từ dplyr để thêm dữ liệu mà chúng ta muốn vẽ tới đối tượng shapefile. Trong trường hợp này, chúng ta sẽ sử dụng bộ dữ liệu case_adm3 mà chúng ta đã tạo trước đó để tóm tắt số lượng trường hợp theo khu vực hành chính; tuy nhiên, chúng ta có thể sử dụng phương pháp tương tự này để vẽ bất kỳ dữ liệu nào được lưu trữ trong data frame.\n\nsle_adm3_dat &lt;- sle_adm3 %&gt;% \n  inner_join(case_adm3, by = \"admin3pcod\") # inner join = retain only if in both data objects\n\nselect(sle_adm3_dat, admin3name.x, cases) # print selected variables to console\n\nSimple feature collection with 9 features and 2 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -13.29894 ymin: 8.384533 xmax: -13.12612 ymax: 8.499809\nGeodetic CRS:  WGS 84\n# A tibble: 9 × 3\n  admin3name.x   cases                                                  geometry\n  &lt;chr&gt;          &lt;int&gt;                                        &lt;MULTIPOLYGON [°]&gt;\n1 Mountain Rural   281 (((-13.21496 8.474341, -13.21479 8.474289, -13.21465 8.4…\n2 Central I         62 (((-13.22646 8.489716, -13.22648 8.48955, -13.22644 8.48…\n3 East I            51 (((-13.2129 8.494033, -13.21076 8.494026, -13.21013 8.49…\n4 East II          124 (((-13.22653 8.491883, -13.22647 8.491853, -13.22642 8.4…\n5 Central II        21 (((-13.23154 8.491768, -13.23141 8.491566, -13.23144 8.4…\n6 West III         228 (((-13.28529 8.497354, -13.28456 8.496497, -13.28403 8.4…\n7 West I            39 (((-13.24677 8.493453, -13.24669 8.493285, -13.2464 8.49…\n8 West II          177 (((-13.25698 8.485518, -13.25685 8.485501, -13.25668 8.4…\n9 East III          13 (((-13.20465 8.485758, -13.20461 8.485698, -13.20449 8.4…\n\n\nĐể tạo biểu đồ cột về số lượng trường hợp theo khu vực, sử dụng ggplot2, sau đó chúng ta có thể gọi geom_col() như sau:\n\nggplot(data=sle_adm3_dat) +\n  geom_col(aes(x=fct_reorder(admin3name.x, cases, .desc=T),   # reorder x axis by descending 'cases'\n               y=cases)) +                                  # y axis is number of cases by region\n  theme_bw() +\n  labs(                                                     # set figure text\n    title=\"Number of cases, by administrative unit\",\n    x=\"Admin level 3\",\n    y=\"Number of cases\"\n  ) + \n  guides(x=guide_axis(angle=45))                            # angle x-axis labels 45 degrees to fit better\n\n\n\n\n\n\n\n\nNếu chúng ta muốn sử dụng ggplot2 để tạo bản đồ choropleth về số lượng trường hợp, chúng ta có thể sử dụng cú pháp tương tự để gọi hàm geom_sf():\n\nggplot(data=sle_adm3_dat) + \n  geom_sf(aes(fill=cases))    # set fill to vary by case count variable\n\n\n\n\n\n\n\n\nSau đó, chúng ta có thể tùy chỉnh hình thức bản đồ bằng cách sử dụng ngữ pháp nhất quán trên ggplot2, ví dụ:\n\nggplot(data=sle_adm3_dat) +                           \n  geom_sf(aes(fill=cases)) +                        \n  scale_fill_continuous(high=\"#54278f\", low=\"#f2f0f7\") +    # change color gradient\n  theme_bw() +\n  labs(title = \"Number of cases, by administrative unit\",   # set figure text\n       subtitle = \"Admin level 3\"\n  )\n\n\n\n\n\n\n\n\nĐối với người dùng R cảm thấy thoải mái khi làm việc với ggplot2, geom_sf() cung cấp một cách làm đơn giản và trực tiếp, phù hợp với việc trực quan hóa bản đồ cơ bản. Để tìm hiểu thêm, hãy đọc hướng dẫn geom_sf() này hoặc sách về ggplot2.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>GIS cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.vn.html#bản-đồ-cơ-sở",
    "href": "new_pages/gis.vn.html#bản-đồ-cơ-sở",
    "title": "28  GIS cơ bản",
    "section": "28.9 Bản đồ cơ sở",
    "text": "28.9 Bản đồ cơ sở\n\nOpenStreetMap\nDưới đây, chúng tôi mô tả cách lấy được bản đồ cơ sở cho bản đồ ggplot2 bằng cách sử dụng các tính năng của OpenStreetMap. Các phương pháp thay thế bao gồm sử dụng ggmap, yêu cầu bạn đăng ký miễn phí với Google (chi tiết).\nOpenStreetMap là một dự án hợp tác nhằm tạo ra một bản đồ thế giới có thể chỉnh sửa miễn phí. Dữ liệu vị trí địa lý nền tảng ví dụ: vị trí của các thành phố, đường xá, đặc điểm tự nhiên, sân bay, trường học, bệnh viện, đường xá, v.v.) được coi là đầu ra chính của dự án.\nĐầu tiên, chúng ta gọi package OpenStreetMap để lấy bản đồ cơ sở.\nSau đó chúng ta tạo đối tượng map, được xác định bằng cách sử dụng hàm openmap() từ package OpenStreetMap (tài liệu). Chúng ta cung cấp những thông tin sau:\n\nupperLeft và lowerRight Hai cặp tọa độ xác định giới hạn của ô bản đồ cơ sở\n\nTrong trường hợp này, chúng tôi đã đưa giá trị tối đa và tối thiểu từ các hàng trong linelist, vì vậy bản đồ sẽ tương tác động với dữ liệu\n\n\nzoom = (nếu null nó sẽ được xác định tự động)\n\ntype = loại bản đồ cơ sở nào - chúng tôi đã liệt kê một số khả năng ở đây và code hiện đang sử dụng cái đầu tiên ([1]) “osm”\n\nmergeTiles = chúng tôi đã chọn TRUE để tất cả các lớp nền được hợp nhất thành một\n\n\n# load package\npacman::p_load(OpenStreetMap)\n\n# Fit basemap by range of lat/long coordinates. Choose tile type\nmap &lt;- OpenStreetMap::openmap(\n  upperLeft = c(max(linelist$lat, na.rm=T), max(linelist$lon, na.rm=T)),   # limits of basemap tile\n  lowerRight = c(min(linelist$lat, na.rm=T), min(linelist$lon, na.rm=T)),\n  zoom = NULL,\n  type = c(\"osm\", \"stamen-toner\", \"stamen-terrain\", \"stamen-watercolor\", \"esri\",\"esri-topo\")[1])\n\nNếu chúng ta vẽ bản đồ cơ sở này ngay bây giờ, sử dụng hàm autoplot.OpenStreetMap() từ package OpenStreetMap, bạn sẽ thấy rằng các đơn vị trên các trục không phải là kinh/vĩ độ. Nó đang sử dụng một hệ tọa độ khác. Để hiển thị chính xác nơi cứ trú các trường hợp (được lưu trữ theo vĩ độ/kinh độ), điều này phải được thay đổi.\n\nautoplot.OpenStreetMap(map)\n\n\n\n\n\n\n\n\nVì vậy, chúng ta muốn chuyển đổi bản đồ thành vĩ độ/kinh độ với hàm openproj() từ package OpenStreetMap. Chúng ta cung cấp bản đồ cơ sở map và cũng cung cấp Hệ thống tham chiếu tọa độ (CRS) mà chúng ta muốn. Chúng ta thực hiện điều này bằng cách cung cấp chuỗi ký tự “proj.4” cho phép chiếu WGS 1984, nhưng bạn cũng có thể cung cấp CRS theo những cách khác. (xem trang này để hiểu rõ hơn chuỗi proj.4 là gì)\n\n# Projection WGS84\nmap_latlon &lt;- openproj(map, projection = \"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs\")\n\nBây giờ khi chúng ta tạo biểu đồ, chúng ta thấy rằng dọc theo các trục là tọa độ vĩ độ và kinh độ. Hệ tọa độ đã được chuyển đổi. Bây giờ các trường hợp của chúng ta sẽ được biểu diễn chính xác nếu được phủ lên!\n\n# Plot map. Must use \"autoplot\" in order to work with ggplot\nautoplot.OpenStreetMap(map_latlon)\n\n\n\n\n\n\n\n\nXem các hướng dẫn tại đây và tại đây để biết thêm chi tiết.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>GIS cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.vn.html#bản-đồ-nhiệt-mật-độ-đường-viền",
    "href": "new_pages/gis.vn.html#bản-đồ-nhiệt-mật-độ-đường-viền",
    "title": "28  GIS cơ bản",
    "section": "28.10 Bản đồ nhiệt mật độ đường viền",
    "text": "28.10 Bản đồ nhiệt mật độ đường viền\nDưới đây, chúng tôi mô tả cách đạt được bản đồ nhiệt mật độ đường viền của các trường hợp, trên một bản đồ cơ sở, bắt đầu với một danh sách dòng (một dòng cho mỗi trường hợp).\n\nTạo ô bản đồ cơ sở từ OpenStreetMap, như được mô tả ở trên\n\nVẽ biểu đồ các trường hợp từ linelist bằng cách sử dụng cột vĩ độ và kinh độ\n\nChuyển đổi các điểm thành bản đồ nhiệt mật độ với hàm stat_density_2d() trong ggplot2,\n\nKhi chúng ta có một bản đồ cơ sở với tọa độ vĩ độ/kinh độ, chúng ta có thể vẽ các trường hợp của mình lên trên bằng cách sử dụng tọa độ vĩ độ/kinh độ của nơi cư trú của chúng.\nXây dựng dựa trên hàm autoplot.OpenStreetMap() để tạo bản đồ cơ sở, các hàm ggplot2 sẽ dễ dàng thêm vào trên cùng, như được hiển thị với hàm geom_point() bên dưới:\n\n# Plot map. Must be autoplotted to work with ggplot\nautoplot.OpenStreetMap(map_latlon)+                 # begin with the basemap\n  geom_point(                                       # add xy points from linelist lon and lat columns \n    data = linelist,                                \n    aes(x = lon, y = lat),\n    size = 1, \n    alpha = 0.5,\n    show.legend = FALSE) +                          # drop legend entirely\n  labs(x = \"Longitude\",                             # titles & labels\n       y = \"Latitude\",\n       title = \"Cumulative cases\")\n\n\n\n\n\n\n\n\nBản đồ trên có thể khó giải thích, đặc biệt là với các điểm trùng lặp. Vì vậy, thay vào đó bạn có thể vẽ một bản đồ mật độ 2d bằng cách sử dụng hàm stat_density_2d() trong ggplot2. Bạn vẫn đang sử dụng tọa độ vĩ độ/kinh độ của linelist, nhưng ước tính mật độ lõi 2D được thực hiện và kết quả được hiển thị với các đường đồng mức - giống như bản đồ địa hình. Đọc bản đầy đủ tài liệu tại đây.\n\n# begin with the basemap\nautoplot.OpenStreetMap(map_latlon)+\n  \n  # add the density plot\n  ggplot2::stat_density_2d(\n        data = linelist,\n        aes(\n          x = lon,\n          y = lat,\n          fill = ..level..,\n          alpha = ..level..),\n        bins = 10,\n        geom = \"polygon\",\n        contour_var = \"count\",\n        show.legend = F) +                          \n  \n  # specify color scale\n  scale_fill_gradient(low = \"black\", high = \"red\")+\n  \n  # labels \n  labs(x = \"Longitude\",\n       y = \"Latitude\",\n       title = \"Distribution of cumulative cases\")\n\n\n\n\n\n\n\n\n\n\nBản đồ nhiệt chuỗi thời gian\nBản đồ nhiệt mật độ ở trên cho thấy các trường hợp tích lũy. Chúng ta có thể khảo sát các vụ dịch theo thời gian và không gian bằng cách faceting bản đồ nhiệt dựa trên tháng khởi phát triệu chứng, như được rút ra từ linelist.\nChúng ta bắt đầu với linelist, tạo một cột mới với Năm và Tháng khởi phát. Hàm format() trong base R thay đổi cách hiển thị ngày. Trong trường hợp này, chúng ta muốn “YYYY-MM”..\n\n# Extract month of onset\nlinelist &lt;- linelist %&gt;% \n  mutate(date_onset_ym = format(date_onset, \"%Y-%m\"))\n\n# Examine the values \ntable(linelist$date_onset_ym, useNA = \"always\")\n\n\n2014-04 2014-05 2014-06 2014-07 2014-08 2014-09 2014-10 2014-11 2014-12 2015-01 \n      1       6      18      43      95     169     190     125      97      66 \n2015-02 2015-03 2015-04    &lt;NA&gt; \n     57      58      29      46 \n\n\nBây giờ, chúng ta chỉ cần đơn giản facet thông qua ggplot2 vào bản đồ nhiệt mật độ. facet_wrap() được áp dụng, sử dụng cột mới làm hàng. Chúng ta thiết lập số lượng cột được facet là 4 cho rõ ràng.\n\n# packages\npacman::p_load(OpenStreetMap, tidyverse)\n\n# begin with the basemap\nautoplot.OpenStreetMap(map_latlon)+\n  \n  # add the density plot\n  ggplot2::stat_density_2d(\n        data = linelist,\n        aes(\n          x = lon,\n          y = lat,\n          fill = ..level..,\n          alpha = ..level..),\n        bins = 10,\n        geom = \"polygon\",\n        contour_var = \"count\",\n        show.legend = F) +                          \n  \n  # specify color scale\n  scale_fill_gradient(low = \"black\", high = \"red\")+\n  \n  # labels \n  labs(x = \"Longitude\",\n       y = \"Latitude\",\n       title = \"Distribution of cumulative cases over time\")+\n  \n  # facet the plot by month-year of onset\n  facet_wrap(~ date_onset_ym, ncol = 4)",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>GIS cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.vn.html#thống-kê-không-gian",
    "href": "new_pages/gis.vn.html#thống-kê-không-gian",
    "title": "28  GIS cơ bản",
    "section": "28.11 Thống kê không gian",
    "text": "28.11 Thống kê không gian\nHầu hết các cuộc thảo luận của chúng ta cho đến nay đều tập trung vào việc trực quan hóa dữ liệu không gian. Trong một số trường hợp, bạn cũng có thể quan tâm đến việc sử dụng thống kê không gian để định lượng mối quan hệ không gian của các thuộc tính trong dữ liệu của mình. Phần này sẽ cung cấp một cái nhìn tổng quan ngắn gọn về một số khái niệm chính trong thống kê không gian và đề xuất một số tài liệu sẽ hữu ích để khám phá nếu bạn muốn thực hiện các phân tích không gian toàn diện hơn.\n\nMối quan hệ không gian\nTrước khi có thể tính toán bất kỳ số liệu thống kê không gian nào, chúng ta cần xác định mối quan hệ giữa các đối tượng địa lý trong dữ liệu của mình. Có nhiều cách để khái niệm hóa các mối quan hệ không gian, nhưng một mô hình đơn giản và thường được áp dụng để sử dụng là mô hình adjancy - liền kề - cụ thể là chúng ta mong đợi mối quan hệ địa lý giữa các khu vực có chung biên giới hoặc “láng giềng” với nhau..\nChúng ta có thể định lượng các mối quan hệ liền kề giữa các vùng địa giới hành chính trong dữ liệu sle_adm3 mà chúng ta đang sử dụng với package spdep. Chúng ta sẽ cụ thể sự tiếp giáp queen, có nghĩa là các khu vực sẽ là hàng xóm của nhau nếu chúng có chung ít nhất một điểm dọc theo biên giới của chúng. Phương pháp thay thế có thể là sự tiếp giáp rook, đòi hỏi các khu vực phải chia sẻ một cạnh - trong trường hợp của chúng ta, với các đa giác không đều, sự phân biệt là không đáng kể, nhưng trong một số trường hợp, sự lựa chọn giữa queen và rook có thể có ảnh hưởng.\n\nsle_nb &lt;- spdep::poly2nb(sle_adm3_dat, queen=T) # create neighbors \nsle_adjmat &lt;- spdep::nb2mat(sle_nb)    # create matrix summarizing neighbor relationships\nsle_listw &lt;- spdep::nb2listw(sle_nb)   # create listw (list of weights) object -- we will need this later\n\nsle_nb\n\nNeighbour list object:\nNumber of regions: 9 \nNumber of nonzero links: 30 \nPercentage nonzero weights: 37.03704 \nAverage number of links: 3.333333 \n\nround(sle_adjmat, digits = 2)\n\n  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n1 0.00 0.20 0.00 0.20 0.00  0.2 0.00 0.20 0.20\n2 0.25 0.00 0.00 0.25 0.25  0.0 0.00 0.25 0.00\n3 0.00 0.00 0.00 0.50 0.00  0.0 0.00 0.00 0.50\n4 0.25 0.25 0.25 0.00 0.00  0.0 0.00 0.00 0.25\n5 0.00 0.33 0.00 0.00 0.00  0.0 0.33 0.33 0.00\n6 0.50 0.00 0.00 0.00 0.00  0.0 0.00 0.50 0.00\n7 0.00 0.00 0.00 0.00 0.50  0.0 0.00 0.50 0.00\n8 0.20 0.20 0.00 0.00 0.20  0.2 0.20 0.00 0.00\n9 0.33 0.00 0.33 0.33 0.00  0.0 0.00 0.00 0.00\nattr(,\"call\")\nspdep::nb2mat(neighbours = sle_nb)\n\n\nMa trận được in ở trên hiển thị mối quan hệ giữa 9 vùng trong dữ liệu sle_adm3 của chúng ta. Điểm 0 cho biết hai vùng không phải là láng giềng, trong khi bất kỳ giá trị nào khác 0 cho biết mối quan hệ láng giềng. Các giá trị trong ma trận được chia tỷ lệ để mỗi vùng có tổng trọng số hàng là 1.\nMột cách tốt hơn để trực quan hóa những mối quan hệ láng giềng này là vẽ biểu đồ chúng:\n\nplot(sle_adm3_dat$geometry) +                                           # plot region boundaries\n  spdep::plot.nb(sle_nb,as(sle_adm3_dat, 'Spatial'), col='grey', add=T) # add neighbor relationships\n\n\n\n\n\n\n\n\nChúng ta đã sử dụng phương pháp tiếp cận adjacency để xác định các đa giác hàng xóm; những người hàng xóm mà chúng ta đã xác định đôi khi cũng được gọi là những người hàng xóm dựa trên sự tiếp giáp. Nhưng đây chỉ là một cách để lựa chọn các khu vực dự kiến có mối quan hệ địa lý. Các cách tiếp cận thay thế phổ biến nhất để xác định các mối quan hệ địa lý tạo ra những người hàng xóm dựa trên khoảng cách; ngắn gọn thì chúng là:\n\nK-nearest neighbors - Dựa trên khoảng cách giữa các tâm (trung tâm có trọng số địa lý của mỗi vùng đa giác), hãy chọn n vùng gần nhất làm vùng lân cận. Ngưỡng khoảng cách tối đa cũng có thể được chỉ định. Trong spdep, bạn có thể sử dụng hàm knearneigh() (xem tài liệu).\nDistance threshold neighbors - Chọn tất cả hàng xóm trong một ngưỡng khoảng cách. Trong spdep, các mối quan hệ láng giềng này có thể được xác định bằng cách sử dụng hàm dnearneigh() (xem tài liệu).\n\n\n\nTự tương quan không gian\nĐịnh luật địa lý đầu tiên được trích dẫn của Tobler tuyên bố rằng “mọi thứ đều liên quan đến mọi thứ khác, nhưng những thứ ở gần có liên quan hơn những thứ ở xa”. Trong dịch tễ học, điều này thường có nghĩa là nguy cơ về một kết quả sức khỏe cụ thể ở một vùng nhất định tương tự với các vùng lân cận hơn là những vùng xa. Khái niệm này đã được chính thức hóa dưới dạng tự tương quan không gian - thuộc tính thống kê mà các đối tượng địa lý có giá trị tương tự được nhóm lại với nhau trong không gian. Các phép đo thống kê về tự tương quan không gian có thể được sử dụng để định lượng mức độ phân cụm không gian trong dữ liệu của bạn, xác định vị trí xảy ra phân cụm, và xác định các xu hướng chung về tự tương quan không gian giữa các biến khác nhau trong dữ liệu của bạn. Phần này giới thiệu tổng quan về một số thước đo phổ biến của tự tương quan không gian và cách tính chúng trong R.\nMoran’s I - Đây là thống kê tóm tắt mang tính toàn cục (global) về mối tương quan giữa giá trị của một biến trong một vùng và giá trị của cùng một biến ở các vùng lân cận. Thống kê Moran’s I thường dao động từ -1 tới 1. Giá trị 0 cho thấy không có tương quan không gian, trong khi các giá trị gần 1 hoặc -1 cho thấy tự tương quan không gian (các giá trị tương tự gần nhau) hoặc phân tán không gian (các giá trị không tương tự ở gần nhau) mạnh hơn.\nVí dụ: chúng ta sẽ tính toán thống kê Moran’s I để định lượng tự tương quan theo không gian trong các trường hợp Ebola mà chúng ta đã mapping trước đó (hãy nhớ rằng đây là một tập con các trường hợp từ một vụ dịch mô phỏng trong dataframe linelist). Package spdep có hàm moran.test có thể giúp chúng ta thực hiện phép tính toán này:\n\nmoran_i &lt;-spdep::moran.test(sle_adm3_dat$cases,    # numeric vector with variable of interest\n                            listw=sle_listw)       # listw object summarizing neighbor relationships\n\nmoran_i                                            # print results of Moran's I test\n\n\n    Moran I test under randomisation\n\ndata:  sle_adm3_dat$cases  \nweights: sle_listw    \n\nMoran I statistic standard deviate = 1.5655, p-value = 0.05874\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n       0.20394756       -0.12500000        0.04415291 \n\n\nĐầu ra từ hàm moran.test() cho chúng ta thấy kết quả thống kê Moran I statistic từ hàm round(moran_i$estimate[1],2). Điều này cho thấy sự hiện diện của tự tương quan không gian trong dữ liệu của chúng ta - cụ thể là những khu vực có số ca mắc Ebola tương tự nhau thì có khả năng ở gần nhau. Giá trị p cung cấp bởi kiểm định moran.test() được tạo ra bằng cách so sánh với kỳ vọng trong giả thuyết không là không có tự tương quan không gian, và có thể được sử dụng nếu bạn cần báo cáo kết quả của một kiểm định giả thuyết chính thức.\nLocal Moran’s I - Chúng ta có thể phân tách thống kê Moran’s I (toàn cục - global) được tính toán ở trên để xác định tự tương quan cục bộ (local); nghĩa là, để xác định các cụm cụ thể trong dữ liệu của chúng ta. Thống kê này, đôi khi còn được gọi là Local Indicator of Spatial Association (LISA), tóm tắt mức độ tự tương quan không gian xung quanh mỗi vùng riêng lẻ. Nó có thể hữu ích để tìm các điểm “nóng - hot” và “lạnh - cold” trên bản đồ.\nĐể hiển thị một ví dụ, chúng ta có thể tính toán và lập bản đồ Local Moran’s I cho các trường hợp Ebola ở trên với hàm local_moran() từ package spdep:\n\n# calculate local Moran's I\nlocal_moran &lt;- spdep::localmoran(                  \n  sle_adm3_dat$cases,                              # variable of interest\n  listw=sle_listw                                  # listw object with neighbor weights\n)\n\n# join results to sf data\nsle_adm3_dat&lt;- cbind(sle_adm3_dat, local_moran)    \n\n# plot map\nggplot(data=sle_adm3_dat) +\n  geom_sf(aes(fill=Ii)) +\n  theme_bw() +\n  scale_fill_gradient2(low=\"#2c7bb6\", mid=\"#ffffbf\", high=\"#d7191c\",\n                       name=\"Local Moran's I\") +\n  labs(title=\"Local Moran's I statistic for Ebola cases\",\n       subtitle=\"Admin level 3 regions, Sierra Leone\")\n\n\n\n\n\n\n\n\nGetis-Ord Gi* - Đây là một thống kê khác thường được sử dụng để phân tích điểm nóng - hotspot analysis; mức độ phổ biến của thống kê này liên quan đến ứng dụng của nó trong công cụ Phân tích điểm nóng của ArcGIS. Nó dựa trên giả định rằng thông thường, sự khác biệt về giá trị của một biến giữa các vùng lân cận phải tuân theo phân phối chuẩn. Nó sử dụng cách tiếp cận z-score để xác định các vùng có giá trị cao hơn đáng kể (điểm nóng) hoặc thấp hơn đáng kể (điểm lạnh) của một biến cụ thể, so với các vùng lân cận của chúng..\nChúng ta có thể tính toán và lập bản đồ chỉ số Gi* sử dụng hàm localG() từ package spdep:\n\n# Perform local G analysis\ngetis_ord &lt;- spdep::localG(\n  sle_adm3_dat$cases,\n  sle_listw\n)\n\n# join results to sf data\nsle_adm3_dat$getis_ord &lt;- as.numeric(getis_ord)\n\n# plot map\nggplot(data=sle_adm3_dat) +\n  geom_sf(aes(fill=getis_ord)) +\n  theme_bw() +\n  scale_fill_gradient2(low=\"#2c7bb6\", mid=\"#ffffbf\", high=\"#d7191c\",\n                       name=\"Gi*\") +\n  labs(title=\"Getis-Ord Gi* statistic for Ebola cases\",\n       subtitle=\"Admin level 3 regions, Sierra Leone\")\n\n\n\n\n\n\n\n\nNhư bạn có thể thấy, bản đồ được tạo ra bởi Getis-Ord Gi* trông hơi khác so với bản đồ của Local Moran’s I được tạo ra trước đó. Điều này phản ánh rằng phương pháp được sử dụng để tính toán hai số liệu thống kê này hơi khác nhau; bạn nên sử dụng cái nào tùy thuộc vào trường hợp sử dụng cụ thể của bạn và câu hỏi nghiên cứu quan tâm.\nLee’s L test - Đây là một kiểm định thống kê về mối tương quan không gian giữa hai biến. Nó cho phép bạn kiểm định xem xu hướng không gian của một biến x có tương tự với xu hướng không gian của một biến y khác hay không, với giả định là chúng có mối tương quan không gian với nhau\nĐể đưa ra một ví dụ, hãy kiểm định liệu rằng xu hướng không gian các trường hợp Ebola từ một vụ dịch mô phỏng có tương quan với xu hướng không gian của dân số hay không. Để bắt đầu, chúng ta cần có một biến population trong bộ dữ liệu sle_adm3 của mình. Chúng ta có thể sử dụng biến total từ bộ dữ liệu sle_adm3_pop mà chúng ta đã tải trước đó.\n\nsle_adm3_dat &lt;- sle_adm3_dat %&gt;% \n  rename(population = total)                          # rename 'total' to 'population'\n\nChúng ta có thể trực quan hóa nhanh xu hướng không gian của hai biến cạnh nhau, để xem liệu chúng có tương tự nhau hay không:\n\ntmap_mode(\"plot\")\n\ncases_map &lt;- tm_shape(sle_adm3_dat) + tm_polygons(\"cases\") + tm_layout(main.title=\"Cases\")\npop_map &lt;- tm_shape(sle_adm3_dat) + tm_polygons(\"population\") + tm_layout(main.title=\"Population\")\n\ntmap_arrange(cases_map, pop_map, ncol=2)   # arrange into 2x1 facets\n\n\n\n\n\n\n\n\nMột cách trực quan, các xu hướng có vẻ không giống nhau. Chúng ta có thể sử dụng hàm lee.test() trong package spdep để kiểm định liệu xu hướng tự tương quan không gian giữa hai biến số có liên quan có ý nghĩa thống kê với nhau hay không. Thống kê L sẽ gần tới 0 nếu không có mối tương quan giữa các xu hướng, gần bằng 1 nếu có mối tương quan dương mạnh (tức là các xu hướng tương tự nhau) và gần bằng -1 nếu có mối tương quan âm mạnh (tức là các xu hướng là ngược nhau).\n\nlee_test &lt;- spdep::lee.test(\n  x=sle_adm3_dat$cases,          # variable 1 to compare\n  y=sle_adm3_dat$population,     # variable 2 to compare\n  listw=sle_listw                # listw object with neighbor weights\n)\n\nlee_test\n\n\n    Lee's L statistic randomisation\n\ndata:  sle_adm3_dat$cases ,  sle_adm3_dat$population \nweights: sle_listw  \n\nLee's L statistic standard deviate = -0.85374, p-value = 0.8034\nalternative hypothesis: greater\nsample estimates:\nLee's L statistic       Expectation          Variance \n      -0.14239652       -0.04752710        0.01234804 \n\n\nKết quả từ thống kê Lee’s L cho hai biến là round(lee_test$estimate[1],2), chỉ ra rằng chúng có mối tương quan âm yếu. Điều này khẳng định đánh giá trực quan của chúng ta rằng xu hướng các trường hợp bệnh và dân số không liên quan đến nhau cũng như cung cấp bằng chứng rằng xu hướng không gian của các trường hợp không hoàn toàn là kết quả của mật độ dân số ở các khu vực có nguy cơ cao.\nThống kê Lee L có thể hữu ích để đưa ra các suy luận về mối quan hệ phân bố theo không gian giữa các biến; tuy nhiên, để mô tả bản chất của mối quan hệ giữa hai biến một cách chi tiết hơn, hoặc điều chỉnh cho nhiễu, sẽ cần đến các kỹ thuật hồi quy không gian. Chúng sẽ được mô tả ngắn gọn trong phần sau.\n\n\nHồi quy không gian\nBạn có thể muốn đưa ra các suy luận thống kê về mối quan hệ giữa các biến trong dữ liệu không gian của mình. Trong những trường hợp này, sẽ hữu ích khi xem xét các kỹ thuật hồi quy không gian - nghĩa là, các cách tiếp cận hồi quy xem xét rõ ràng tổ chức không gian của các đơn vị trong dữ liệu của bạn. Một số lý do mà bạn có thể cần xem xét các mô hình hồi quy không gian, thay vì các mô hình hồi quy tiêu chuẩn như GLM, bao gồm:\n\nCác mô hình hồi quy tiêu chuẩn giả định rằng các phần dư là độc lập với nhau. Khi có hiện tượng tự tương quan không gian mạnh, các phần dư của mô hình hồi quy chuẩn cũng có khả năng tự tương quan không gian, do đó vi phạm giả định này. Điều này có thể dẫn đến các vấn đề trong việc giải thích kết quả mô hình, trong trường hợp đó, một mô hình không gian sẽ được ưu tiên hơn.\nCác mô hình hồi quy cũng thường giả định rằng tác động của một biến x là không đổi đối với tất cả các quan sát. Trong trường hợp không đồng nhất về không gian - spatial heterogenity, các tác động mà chúng ta muốn ước tính có thể thay đổi theo không gian và chúng ta có thể quan tâm đến việc định lượng những khác biệt đó. Trong trường hợp này, các mô hình hồi quy không gian mang lại sự linh hoạt hơn cho việc ước lượng và giải thích các tác động.\n\nCác chi tiết về phương pháp tiếp cận hồi quy không gian nằm ngoài phạm vi của sổ tay này. Thay vào đó, phần này sẽ cung cấp tổng quan về các mô hình hồi quy không gian phổ biến nhất và cách sử dụng của chúng, đồng thời giới thiệu cho bạn tài liệu tham khảo có thể sử dụng nếu bạn muốn khám phá thêm lĩnh vực này.\nCác mô hình sai số không gian - Spatial error models - Các mô hình này giả định rằng sai số trên các đơn vị không gian có tương quan với nhau, trong trường hợp đó, dữ liệu sẽ vi phạm các giả định của mô hình OLS tiêu chuẩn. Các mô hình này đôi khi còn được biết đến với tên Các mô hình tự hồi quy đồng thời - simultaneous autoregressive (SAR) models. Mô hình được fit bằng cách sử dụng hàm errorsarlm() trong package spatialreg (các hàm hồi quy không gian là một phần của package spdep).\nCác mô hình độ trễ không gian - Spatial lag models - Các mô hình này giả định rằng biến phụ thuộc của một vùng i không chỉ bị ảnh hưởng bởi giá trị của các biến độc lập trong i, mà còn bởi giá trị của các biến đó ở các vùng lân cận i. Tương tự như các mô hình sai số không gian, các mô hình độ trễ không gian cũng thường được biết đến với tên gọi Các mô hình tự hồi quy đồng thời. Mô hình được fit bằng cách sử dụng hàm lagsarlm() trong package spatialreg.\nPackage spdep chứa một số kiểm định hữu ích để quyết định lựa chọn giữa các mô hình OLS chuẩn, độ trễ không gian và sai số không gian. Các kiểm định này được gọi là chẩn đoán Lagrange Multiplier, có thể được sử dụng để xác định loại phụ thuộc không gian trong dữ liệu của bạn và chọn mô hình nào phù hợp nhất. Hàm lm.LMtests() có thể được sử dụng để tính toán tất cả các kiểm định Lagrange Multiplier. Anselin (1988) cũng cung cấp một sơ đồ khối hữu ích để quyết định sử dụng mô hình hồi quy không gian nào dựa trên kết quả của các kiểm định Lagrange Multiplier:\n\n\n\n\n\n\n\n\n\nCác mô hình Bayesian phân tầng - Bayesian hierarchical models - Phương pháp tiếp cận Bayes thường được sử dụng cho một số ứng dụng trong phân tích không gian, phổ biến nhất là lập bản đồ dịch bệnh. Chúng được ưu tiên sử dụng trong các trường hợp dữ liệu trường hợp được phân phối thưa thớt (ví dụ trong trường hợp các outcome là hiếm gặp) hoặc “nhiễu” về mặt thống kê, vì chúng có thể được sử dụng để tạo ra các ước tính “mượt mà” về nguy cơ bệnh tật bằng cách tính đến quy trình không gian tiềm ẩn cơ bản. Điều này có thể giúp cải thiện chất lượng của các ước tính. Chúng cũng cho phép người điều tra cụ thể trước (thông qua việc lựa chọn prior) các xu hướng tương quan không gian phức tạp có thể tồn tại trong dữ liệu, mà có thể giải thích cho các sự biến động phụ thuộc hoặc không phụ thuộc không gian trong cả biến độc lập và phụ thuộc. Trong R, các mô hình Bayesian phân tầng có thể sử dụng thông qua package CARbayes (xem hưỡng dẫn) hoặc R-INLA (xem trang web và sách giáo khoa). R cũng có thể được sử dụng để gọi phần mềm bên ngoài thực hiện ước lượng Bayes, chẳng hạn như JAGS hoặc WinBUGS.",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>GIS cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.vn.html#tài-nguyên-học-liệu",
    "href": "new_pages/gis.vn.html#tài-nguyên-học-liệu",
    "title": "28  GIS cơ bản",
    "section": "28.12 Tài nguyên học liệu",
    "text": "28.12 Tài nguyên học liệu\n\nR Các tính năng cơ bản và package sf vignette\nR tmap package vignette\nggmap: Trực quan hóa không gian với ggplot2\nGiới thiệu về cách tạo bản đồ với R, tổng quan về các package khác nhau\nDữ liệu không gian trong R (khóa học EarthLab)\nPhân tích dữ liệu không gian ứng dụng trong R sách giáo khoa\nSpatialEpiApp - một ứng dụng Shiny có thể tải xuống dưới dạng một package trong R, cho phép bạn cung cấp dữ liệu của riêng mình và tiến hành lập bản đồ, phân tích cụm và thống kê không gian.\nGiới thiệu về kinh tế lượng không gian với R hội thảo",
    "crumbs": [
      "Phân tích dữ liệu",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>GIS cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.vn.html",
    "href": "new_pages/tables_presentation.vn.html",
    "title": "29  Trình bày bảng",
    "section": "",
    "text": "29.1 Chuẩn bị",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Trình bày bảng</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.vn.html#chuẩn-bị",
    "href": "new_pages/tables_presentation.vn.html#chuẩn-bị",
    "title": "29  Trình bày bảng",
    "section": "",
    "text": "Gọi packages\nHãy cài đặt và gọi package flextable. Trong sổ tay này chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt package nếu cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi package bằng lệnh library() từ base R. Xem thêm chương R cơ bản để biết thêm các thông tin về các package trong R.\n\npacman::p_load(\n  rio,            # import/export\n  here,           # file pathways\n  flextable,      # make HTML tables \n  officer,        # helper functions for tables\n  tidyverse)      # data management, summary, and visualization\n\n\n\nNhập dữ liệu\nĐể bắt đầu, chúng ta nhập bộ dữ liệu linelist đã được làm sạch về các ca bệnh Ebola mô phỏng. Để tiện theo dõi, bấm để tải dữ liệu linelist “đã làm sạch” (as .rds file). Nhập dữ liệu bằng hàm import() từ package rio (chấp nhận nhiều loại tập tin như .xlsx, .csv, .rds - xem thêm chương Nhập xuất dữ liệu để biết thêm chi tiết).\n\n# import the linelist\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\n50 hàng đầu tiên của bộ dữ liệu linelist được hiển thị như dưới đây.\n\n\n\n\n\n\n\n\nChuẩn bị bảng\nTrước khi bắt đầu sử dụng flextable bạn cần phải tạo bảng của bạn dưới một data frame. Xem chương Bảng mô tả và Xoay trục dữ liệu để biết cách tạo một data frame sử dụng các packages như janitor và dplyr. Đầu tiên, bạn phải sắp xếp nội dung theo hàng và cột như cách bạn muốn nội dung hiển thị. Sau đó, data frame sẽ được chuyển đến flextable để hiển thị nó với màu sắc, tiêu đề, phông chữ, v.v.\nDưới đây là một ví dụ trong chương Bảng mô tả về cách biến đổi các trường hợp bệnh trong linelist thành một data frame để tóm tắt các outcomes của bệnh nhân và giá trị CT theo bệnh viện, với hàng Tổng ở cuối bảng. Đầu ra được lưu dưới dạng table.\n\ntable &lt;- linelist %&gt;% \n  \n  # Get summary values per hospital-outcome group\n  ###############################################\n  group_by(hospital, outcome) %&gt;%                      # Group data\n  summarise(                                           # Create new summary columns of indicators of interest\n    N = n(),                                            # Number of rows per hospital-outcome group     \n    ct_value = median(ct_blood, na.rm=T)) %&gt;%           # median CT value per group\n  \n  # add totals\n  ############\n  bind_rows(                                           # Bind the previous table with this mini-table of totals\n    linelist %&gt;% \n      filter(!is.na(outcome) & hospital != \"Missing\") %&gt;%\n      group_by(outcome) %&gt;%                            # Grouped only by outcome, not by hospital    \n      summarise(\n        N = n(),                                       # Number of rows for whole dataset     \n        ct_value = median(ct_blood, na.rm=T))) %&gt;%     # Median CT for whole dataset\n  \n  # Pivot wider and format\n  ########################\n  mutate(hospital = replace_na(hospital, \"Total\")) %&gt;% \n  pivot_wider(                                         # Pivot from long to wide\n    values_from = c(ct_value, N),                       # new values are from ct and count columns\n    names_from = outcome) %&gt;%                           # new column names are from outcomes\n  mutate(                                              # Add new columns\n    N_Known = N_Death + N_Recover,                               # number with known outcome\n    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # percent cases who died (to 1 decimal)\n    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %&gt;% # percent who recovered (to 1 decimal)\n  select(                                              # Re-order columns\n    hospital, N_Known,                                   # Intro columns\n    N_Recover, Pct_Recover, ct_value_Recover,            # Recovered columns\n    N_Death, Pct_Death, ct_value_Death)  %&gt;%             # Death columns\n  arrange(N_Known)                                    # Arrange rows from lowest to highest (Total row at bottom)\n\ntable  # print\n\n# A tibble: 7 × 8\n# Groups:   hospital [7]\n  hospital      N_Known N_Recover Pct_Recover ct_value_Recover N_Death Pct_Death\n  &lt;chr&gt;           &lt;int&gt;     &lt;int&gt; &lt;chr&gt;                  &lt;dbl&gt;   &lt;int&gt; &lt;chr&gt;    \n1 St. Mark's M…     325       126 38.8%                     22     199 61.2%    \n2 Central Hosp…     358       165 46.1%                     22     193 53.9%    \n3 Other             685       290 42.3%                     21     395 57.7%    \n4 Military Hos…     708       309 43.6%                     22     399 56.4%    \n5 Missing          1125       514 45.7%                     21     611 54.3%    \n6 Port Hospital    1364       579 42.4%                     21     785 57.6%    \n7 Total            3440      1469 42.7%                     22    1971 57.3%    \n# ℹ 1 more variable: ct_value_Death &lt;dbl&gt;",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Trình bày bảng</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.vn.html#cơ-bản-về-flextable",
    "href": "new_pages/tables_presentation.vn.html#cơ-bản-về-flextable",
    "title": "29  Trình bày bảng",
    "section": "29.2 Cơ bản về flextable",
    "text": "29.2 Cơ bản về flextable\n\nTạo một flextable\nĐể tạo và quản lý các đối tượng của flextable, đầu tiên chúng ta đẩy data frame vào hàm flextable(), sau đó lưu kết quả là my_table.\n\nmy_table &lt;- flextable(table) \nmy_table\n\nhospitalN_KnownN_RecoverPct_Recoverct_value_RecoverN_DeathPct_Deathct_value_DeathSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\nSau khi thực hiện việc này, chúng ta có thể pipe dần đối tượng my_table thông qua các hàm định dạng flextable khác.\nTrong trang này để rõ ràng, chúng tôi sẽ lưu bảng ở các bước trung gian vào đối tượng my_table, thêm các hàm flextable theo từng bước. Nếu bạn muốn xem tất cả code từ đầu đến cuối được viết trong một đoạn, hãy xem mục Kết hợp tất cả các code phía dưới đây.\nCú pháp chung của mỗi dòng code flextable như sau:\n\nfunction(table, i = X, j = X, part = \"X\"), where:\n\n‘function’ có thể là một trong số rất nhiều hàm khác nhau, ví dụ như width() để xác định độ rộng cột, bg() để thiết lập màu nền, align() để điều chỉnh văn bản căn giữa / phải / trái, v.v.\ntable = tên của data frame, có thể bỏ qua nếu như data frame được piping vào trong hàm.\npart = đề cập đến phần nào của bảng mà hàm đang được áp dụng. Ví dụ. “tiêu đề”, “nội dung” hoặc “tất cả”.\ni = chỉ định hàng mà hàm sẽ được áp dụng, trong đó ‘X’ là số thứ tự hàng. Nếu nhiều hàng được chọn, ví dụ: từ hàng đầu tiên đến hàng thứ ba, ta có thể viết: i = c (1: 3). Lưu ý nếu chọn ‘body’, hàng đầu tiên bắt đầu từ bên dưới phần tiêu đề.\nj = chỉ định cột mà hàm sẽ được áp dụng, trong đó ‘X’ là số thứ tự cột hoặc tên cột. Nếu nhiều cột được chọn, ví dụ: từ hàng thứ năm đến hàng thứ sáu, ta có thể viết: j = c(5,6).\n\n\nBạn có thể tìm thấy danh sách đầy đủ các hàm định dạng trong package flextable tại đây hoặc xem tài liệu hướng dẫn bằng cách gõ ?flextable.\n\n\nĐộ rộng cột\nChúng ta có thể sử dụng hàm autofit() để điều chỉnh bảng sao cho mỗi ô chỉ có một hàng văn bản. Hàm qflextable() là một cách viết tắt thuận tiện cho flextable() và autofit().\n\nmy_table %&gt;% autofit()\n\nhospitalN_KnownN_RecoverPct_Recoverct_value_RecoverN_DeathPct_Deathct_value_DeathSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\nTuy nhiên, điều này có thể không phải lúc nào cũng phù hợp, đặc biệt nếu có các giá trị rất dài trong các ô, nghĩa là bảng có thể không vừa trong độ rộng của trang.\nThay vào đó, chúng ta có thể điều chỉnh độ rộng cột bằng hàm width(). Điều này có thể tốn một chút thời gian để tìm giá trị chiều rộng phù hợp cho các cột. Trong ví dụ dưới đây, chúng ta chỉ định các độ rộng khác nhau cho cột 1, cột 2 và cột 4 đến 8.\n\nmy_table &lt;- my_table %&gt;% \n  width(j=1, width = 2.7) %&gt;% \n  width(j=2, width = 1.5) %&gt;% \n  width(j=c(4,5,7,8), width = 1)\n\nmy_table\n\nhospitalN_KnownN_RecoverPct_Recoverct_value_RecoverN_DeathPct_Deathct_value_DeathSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\n\n\nTiêu đề cột\nMột bảng có nhiều tiêu đề cột sẽ giúp giải thích nội dung bảng một cách dễ dàng hơn.\nĐối với bảng này, chúng ta cần thêm một lớp tiêu đề thứ hai để các cột bao gồm các nhóm con giống nhau có thể được nhóm lại với nhau. Chúng ta thực hiện điều này bằng hàm add_header_row() với top = TRUE. Chúng ta cung cấp tên mới của mỗi cột bằng values =, bỏ trống \"\" đối với các cột chúng ta dự định sẽ ghép lại với nhau sau này.\nChúng ta cũng đổi tên các tên tiêu đề phụ ở hàng thứ hai bằng lệnh set_header_labels().\nCuối cùng, chúng ta sử dụng hàm merge_at () để hợp nhất các tiêu đề cột trong hàng tiêu đề trên cùng.\n\nmy_table &lt;- my_table %&gt;% \n  \n  add_header_row(\n    top = TRUE,                # New header goes on top of existing header row\n    values = c(\"Hospital\",     # Header values for each column below\n               \"Total cases with known outcome\", \n               \"Recovered\",    # This will be the top-level header for this and two next columns\n               \"\",\n               \"\",\n               \"Died\",         # This will be the top-level header for this and two next columns\n               \"\",             # Leave blank, as it will be merged with \"Died\"\n               \"\")) %&gt;% \n    \n  set_header_labels(         # Rename the columns in original header row\n      hospital = \"\", \n      N_Known = \"\",                  \n      N_Recover = \"Total\",\n      Pct_Recover = \"% of cases\",\n      ct_value_Recover = \"Median CT values\",\n      N_Death = \"Total\",\n      Pct_Death = \"% of cases\",\n      ct_value_Death = \"Median CT values\")  %&gt;% \n  \n  merge_at(i = 1, j = 3:5, part = \"header\") %&gt;% # Horizontally merge columns 3 to 5 in new header row\n  merge_at(i = 1, j = 6:8, part = \"header\")     # Horizontally merge columns 6 to 8 in new header row\n\nmy_table  # print\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\n\n\nĐường viền và nền\nBạn có thể điều chỉnh đường viền, đường bên trong, v.v. bằng các hàm khác nhau trong flextable. Để dễ dàng, thông thường đầu tiên bạn cần loại bỏ hết các đường viền trong bảng bằng hàm border_remove().\nSau đó, bạn có thể áp dụng các theme đường viền mặc định bằng cách đưa bảng tới hàm theme_box(), theme_booktabs(), hoặc theme_alafoli().\nBạn có thể thêm các đường dọc và ngang bằng nhiều hàm khác nhau. hline() và vline() sẽ thêm các dòng vào một hàng hoặc cột cụ thể. Bên trong hàm, bạn cần chỉ định phần mà bảng sẽ áp dụng qua đối số part = với các tùy chọn “all”, “body”, hoặc “header”. Đối với các đường dọc, ghi rõ cột được áp dụng với j =, đối với các đường ngang, ghi rõ hàng được áp dụng với i =. Các hàm khác như vline_right(), vline_left(), hline_top(), và hline_bottom() chỉ thêm các đường viền ở bên ngoài.\nBên trong tất cả các hàm này, kiểu đường phải được định nghĩa thông qua đối số border = và phải là đầu ra của một lệnh riêng biệt bằng cách sử dụng hàm fp_border() từ package officer. Hàm này giúp bạn xác định độ rộng và màu sắc của đường. Bạn có thể định nghĩa các thông tin này phía trên trước khi thực hiện các lệnh liên quan tới bảng, như được trình bày dưới đây:\n\n# define style for border line\nborder_style = officer::fp_border(color=\"black\", width=1)\n\n# add border lines to table\nmy_table &lt;- my_table %&gt;% \n\n  # Remove all existing borders\n  border_remove() %&gt;%  \n  \n  # add horizontal lines via a pre-determined theme setting\n  theme_booktabs() %&gt;% \n  \n  # add vertical lines to separate Recovered and Died sections\n  vline(part = \"all\", j = 2, border = border_style) %&gt;%   # at column 2 \n  vline(part = \"all\", j = 5, border = border_style)       # at column 5\n\nmy_table\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\n\n\nPhông chữ và căn chỉnh\nChúng ta căn giữa tất cả các cột ngoại trừ cột ngoài cùng bên trái với tên các bệnh viện, bằng cách sử dụng hàm align() từ flextable.\n\nmy_table &lt;- my_table %&gt;% \n   flextable::align(align = \"center\", j = c(2:8), part = \"all\") \nmy_table\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\nNgoài ra, chúng ta có thể tăng kích thước phông chữ tiêu đề và sau đó thay đổi thành in đậm. Chúng ta cũng có thể thay đổi hàng “Total” thành in đậm.\n\nmy_table &lt;-  my_table %&gt;%  \n  fontsize(i = 1, size = 12, part = \"header\") %&gt;%   # adjust font size of header\n  bold(i = 1, bold = TRUE, part = \"header\") %&gt;%     # adjust bold face of header\n  bold(i = 7, bold = TRUE, part = \"body\")           # adjust bold face of total row (row 7 of body)\n\nmy_table\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\nChúng ta cũng có thể thiết lập để các cột tỷ lệ chỉ hiển thị một chữ số thập phân bằng cách sử dụng hàm colformat_num(). Lưu ý rằng điều này cũng có thể được thực hiện ở giai đoạn quản lý dữ liệu với hàm round().\n\nmy_table &lt;- colformat_num(my_table, j = c(4,7), digits = 1)\nmy_table\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\n\n\nHợp nhất ô\nCũng giống như khi chúng ta hợp nhất các ô theo chiều ngang trong hàng tiêu đề, chúng ta cũng có thể hợp nhất các ô theo chiều dọc bằng cách sử dụng merge_at() và chỉ rõ các hàng (i) và cột (j). Ở đây chúng ta hợp nhất ô “Hospital” và “Total cases with known outcome” theo chiều dọc để cung cấp thêm không gian cho chúng.\n\nmy_table &lt;- my_table %&gt;% \n  merge_at(i = 1:2, j = 1, part = \"header\") %&gt;% \n  merge_at(i = 1:2, j = 2, part = \"header\")\n\nmy_table\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\n\n\nMàu nền\nĐể phân biệt nội dung của bảng với các tiêu đề, chúng ta có thể muốn thêm định dạng bổ sung, ví dụ như thay đổi màu nền. Trong ví dụ này, chúng ta sẽ thay đổi nội dung bảng thành màu xám.\n\nmy_table &lt;- my_table %&gt;% \n    bg(part = \"body\", bg = \"gray95\")  \n\nmy_table \n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Trình bày bảng</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.vn.html#định-dạng-có-điều-kiện",
    "href": "new_pages/tables_presentation.vn.html#định-dạng-có-điều-kiện",
    "title": "29  Trình bày bảng",
    "section": "29.3 Định dạng có điều kiện",
    "text": "29.3 Định dạng có điều kiện\nChúng ta có thể highlight tất cả các giá trị trong một cột đáp ứng một quy tắc nhất định, ví dụ các ô có hơn 55% trường hợp tử vong. Đơn giản chỉ cần đặt điều kiện so sánh vào trong đối số i = hoặc j =, phía sau dấu ~. Bạn cần tham chiếu tới thứ tự cột cần highlight trong trong data frame, không phải tiêu đề cột.\n\nmy_table %&gt;% \n  bg(j = 7, i = ~ Pct_Death &gt;= 55, part = \"body\", bg = \"red\") \n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22\n\n\nHoặc, chúng ta có thể highlight toàn bộ hàng đáp ứng một tiêu chí nhất định, chẳng hạn như tên một bệnh viện. Để làm điều này đơn giản chỉ cần không định danh thông số ở đối số (j), để các tiêu chí được áp dụng cho tất cả các cột.\n\nmy_table %&gt;% \n  bg(., i= ~ hospital == \"Military Hospital\", part = \"body\", bg = \"#91c293\") \n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Trình bày bảng</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.vn.html#tbl_pres_all",
    "href": "new_pages/tables_presentation.vn.html#tbl_pres_all",
    "title": "29  Trình bày bảng",
    "section": "29.4 Kết hợp tất cả các code",
    "text": "29.4 Kết hợp tất cả các code\nDưới đây, chúng tôi ghép tất cả code từ các phần trên lại với nhau.\n\nborder_style = officer::fp_border(color=\"black\", width=1)\n\npacman::p_load(\n  rio,            # import/export\n  here,           # file pathways\n  flextable,      # make HTML tables \n  officer,        # helper functions for tables\n  tidyverse)      # data management, summary, and visualization\n\ntable &lt;- linelist %&gt;% \n\n  # Get summary values per hospital-outcome group\n  ###############################################\n  group_by(hospital, outcome) %&gt;%                      # Group data\n  summarise(                                           # Create new summary columns of indicators of interest\n    N = n(),                                            # Number of rows per hospital-outcome group     \n    ct_value = median(ct_blood, na.rm=T)) %&gt;%           # median CT value per group\n  \n  # add totals\n  ############\n  bind_rows(                                           # Bind the previous table with this mini-table of totals\n    linelist %&gt;% \n      filter(!is.na(outcome) & hospital != \"Missing\") %&gt;%\n      group_by(outcome) %&gt;%                            # Grouped only by outcome, not by hospital    \n      summarise(\n        N = n(),                                       # Number of rows for whole dataset     \n        ct_value = median(ct_blood, na.rm=T))) %&gt;%     # Median CT for whole dataset\n  \n  # Pivot wider and format\n  ########################\n  mutate(hospital = replace_na(hospital, \"Total\")) %&gt;% \n  pivot_wider(                                         # Pivot from long to wide\n    values_from = c(ct_value, N),                       # new values are from ct and count columns\n    names_from = outcome) %&gt;%                           # new column names are from outcomes\n  mutate(                                              # Add new columns\n    N_Known = N_Death + N_Recover,                               # number with known outcome\n    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # percent cases who died (to 1 decimal)\n    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %&gt;% # percent who recovered (to 1 decimal)\n  select(                                              # Re-order columns\n    hospital, N_Known,                                   # Intro columns\n    N_Recover, Pct_Recover, ct_value_Recover,            # Recovered columns\n    N_Death, Pct_Death, ct_value_Death)  %&gt;%             # Death columns\n  arrange(N_Known) %&gt;%                                 # Arrange rows from lowest to highest (Total row at bottom)\n\n  # formatting\n  ############\n  flextable() %&gt;%              # table is piped in from above\n  add_header_row(\n    top = TRUE,                # New header goes on top of existing header row\n    values = c(\"Hospital\",     # Header values for each column below\n               \"Total cases with known outcome\", \n               \"Recovered\",    # This will be the top-level header for this and two next columns\n               \"\",\n               \"\",\n               \"Died\",         # This will be the top-level header for this and two next columns\n               \"\",             # Leave blank, as it will be merged with \"Died\"\n               \"\")) %&gt;% \n    set_header_labels(         # Rename the columns in original header row\n      hospital = \"\", \n      N_Known = \"\",                  \n      N_Recover = \"Total\",\n      Pct_Recover = \"% of cases\",\n      ct_value_Recover = \"Median CT values\",\n      N_Death = \"Total\",\n      Pct_Death = \"% of cases\",\n      ct_value_Death = \"Median CT values\")  %&gt;% \n  merge_at(i = 1, j = 3:5, part = \"header\") %&gt;% # Horizontally merge columns 3 to 5 in new header row\n  merge_at(i = 1, j = 6:8, part = \"header\") %&gt;%  \n  border_remove() %&gt;%  \n  theme_booktabs() %&gt;% \n  vline(part = \"all\", j = 2, border = border_style) %&gt;%   # at column 2 \n  vline(part = \"all\", j = 5, border = border_style) %&gt;%   # at column 5\n  merge_at(i = 1:2, j = 1, part = \"header\") %&gt;% \n  merge_at(i = 1:2, j = 2, part = \"header\") %&gt;% \n  width(j=1, width = 2.7) %&gt;% \n  width(j=2, width = 1.5) %&gt;% \n  width(j=c(4,5,7,8), width = 1) %&gt;% \n  flextable::align(., align = \"center\", j = c(2:8), part = \"all\") %&gt;% \n  bg(., part = \"body\", bg = \"gray95\")  %&gt;% \n  bg(., j=c(1:8), i= ~ hospital == \"Military Hospital\", part = \"body\", bg = \"#91c293\") %&gt;% \n  colformat_num(., j = c(4,7), digits = 1) %&gt;%\n  bold(i = 1, bold = TRUE, part = \"header\") %&gt;% \n  bold(i = 7, bold = TRUE, part = \"body\")\n\n`summarise()` has grouped output by 'hospital'. You can override using the\n`.groups` argument.\n\ntable\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Missing1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total3,4401,46942.7%221,97157.3%22",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Trình bày bảng</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.vn.html#lưu-bảng-của-bạn",
    "href": "new_pages/tables_presentation.vn.html#lưu-bảng-của-bạn",
    "title": "29  Trình bày bảng",
    "section": "29.5 Lưu bảng của bạn",
    "text": "29.5 Lưu bảng của bạn\nCó nhiều cách khác nhau mà bảng có thể được tích hợp vào kết quả đầu ra của bạn.\n\nLưu bảng đơn\nBạn có thể xuất các bảng ra file Word, PowerPoint hoặc HTML hoặc dưới tệp tin ảnh (PNG). Để thực hiện điều này, hãy sử dụng một trong các hàm sau:\n\nsave_as_docx()\n\nsave_as_pptx()\n\nsave_as_image()\n\nsave_as_html()\n\nVí dụ dưới đây, chúng ta sẽ lưu bảng dưới dạng tài liệu word. Lưu ý cú pháp của đối số đầu tiên - bạn chỉ có thể cung cấp tên của đối tượng flextable, ví dụ: my_table, hoặc bạn có thể gán một “tên” cho bảng (ví dụ đặt tên là “my table”). Nếu đặt tên thì tên này sẽ xuất hiện dưới dạng tiêu đề của bảng trong Word. Code để lưu bảng dưới dạng ảnh PNG cũng được minh họa như dưới đây.\n\n# Edit the 'my table' as needed for the title of table.  \nsave_as_docx(\"my table\" = my_table, path = \"file.docx\")\n\nsave_as_image(my_table, path = \"file.png\")\n\nLưu ý là bạn cần cài đặt package webshot hoặc webshot2 để lưu bảng từ flextable dưới dạng ảnh. Hình ảnh xuất ra sẽ có nền trong suốt.\nNếu bạn muốn xem thử kết quả đầu ra của bảng flextable , sử dụng lệnh print() và chỉ định định dạng muốn xem trước với preview =. Tài liệu sẽ được “mở lên” trên máy tính của bạn bằng phần mềm đã chỉ định, nhưng sẽ không được lưu. Điều này có thể hữu ích để kiểm tra xem bảng có vừa với một trang/slide hay không hoặc bạn có thể nhanh chóng copy kết quả sang một tài liệu khác. Bạn có thể sử dụng phương pháp này với đối số preview đặt là “pptx” hoặc “docx”.\n\nprint(my_table, preview = \"docx\") # Word document example\nprint(my_table, preview = \"pptx\") # Powerpoint example\n\n\n\nIn bảng trong R markdown\nBảng này có thể được tích hợp vào R markdown, một dạng báo cáo tự động của bạn, nếu đối tượng bảng được gọi trong phần code chunk của R markdown. Điều này có nghĩa là bảng có thể được cập nhật như một phần của báo cáo trong đó dữ liệu có thể thay đổi, do đó, các con số có thể được làm mới.\nXem thêm chi tiết trong chương Báo cáo với R Markdown của cuốn sổ tay này.",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Trình bày bảng</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.vn.html#nguồn",
    "href": "new_pages/tables_presentation.vn.html#nguồn",
    "title": "29  Trình bày bảng",
    "section": "29.6 Nguồn",
    "text": "29.6 Nguồn\nSách đầy đủ về flextable có thể xem ở đây: https://ardata-fr.github.io/flextable-book/ Trang Github xem ở đây\nCó thể tìm thấy sách hướng dẫn về tất cả các hàm flextable ở đây\nThư viên các ví dụ về mẫu bảng flextable cùng code có thể truy cập tại đây",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Trình bày bảng</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.vn.html",
    "href": "new_pages/ggplot_basics.vn.html",
    "title": "30  ggplot cơ bản",
    "section": "",
    "text": "30.1 Chuẩn bị",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.vn.html#chuẩn-bị",
    "href": "new_pages/ggplot_basics.vn.html#chuẩn-bị",
    "title": "30  ggplot cơ bản",
    "section": "",
    "text": "Gọi packages\nĐoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R.\n\npacman::p_load(\n  tidyverse,      # includes ggplot2 and other data management tools\n  janitor,        # cleaning and summary tables\n  ggforce,        # ggplot extras\n  rio,            # import/export\n  here,           # file locator\n  stringr         # working with characters   \n)\n\n\n\nNhập dữ liệu\nĐể bắt đầu, chúng ta nhập bộ dữ liệu có tên linelist đã làm sạch bao gồm các trường hợp từ vụ dịch Ebola mô phỏng. Để tiện theo dõi, bấm để tải dữ liệu linelist “đã được làm sạch”  (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương Nhập xuất dữ liệu để biết thêm chi tiết).\n\nlinelist &lt;- rio::import(\"linelist_cleaned.rds\")\n\n50 hàng đầu tiên của bộ dữ liệu được hiển thị như bên dưới. Chúng ta sẽ tập trung và hai biến liên tục là age, wt_kg (cân nặng được tính bằng kilogram), ct_blood (giá trị CT), vàdays_onset_hosp (sự khác biệt giữa ngày khởi phát và nhập viện).\n\n\n\n\n\n\n\n\nLàm sạch chung\nKhi chuẩn bị dữ liệu để vẽ biểu đồ, tốt nhất là làm cho dữ liệu tuân thủ tiêu chuẩn dữ liệu “gọn gàng” nhất có thể. Để đạt được điều này, bạn có thể tham khảo chương Làm sạch số liệu và các hàm quan trọng trong cuốn sổ tay này.\nMột số cách đơn giản mà chúng ta có thể chuẩn bị dữ liệu của mình để tốt hơn cho việc vẽ biểu đồ, có thể bao gồm việc làm cho nội dung của dữ liệu hiển thị tốt hơn - điều này không nhất thiết phải tương đương với việc bạn chuẩn bị dữ liệu tốt hơn để thao tác với dữ liệu. Ví dụ:\n\nThay thế giá trị NA trong cột kiểu ký tự thành “Unknown”\n\nCân nhắc chuyển đổi cột thành dạng factor để các giá trị của chúng được quy định một có thứ tự\n\nLàm sạch một số cột để các giá trị “thân thiện với dữ liệu” của chúng với dấu gạch dưới, v.v. được thay đổi thành văn bản bình thường hoặc chữ hoa tiêu đề (xem chương Ký tự và chuỗi)\n\nSau đây là một số ví dụ:\n\n# make display version of columns with more friendly names\nlinelist &lt;- linelist %&gt;%\n  mutate(\n    gender_disp = case_when(gender == \"m\" ~ \"Male\",        # m to Male \n                            gender == \"f\" ~ \"Female\",      # f to Female,\n                            is.na(gender) ~ \"Unknown\"),    # NA to Unknown\n    \n    outcome_disp = replace_na(outcome, \"Unknown\")          # replace NA outcome with \"unknown\"\n  )\n\n\n\nChuyển đổi dữ liệu sang dạng dọc\nVề cấu trúc dữ liệu, đối với ggplot2 chúng ta thường muốn xoay trục dữ liệu sang định dạng dọc. Xem thêm ở chương Xoay trục dữ liệu.\n\n\n\n\n\n\n\n\n\nVí dụ, chúng ta muốn vẽ biểu đồ dữ liệu đang ở định dạng “ngang”, chẳng hạn từng trường hợp trong bộ dữ liệu linelist và các triệu chứng của chúng. Dưới đây chúng ta sẽ tạo một bộ dữ liệu nhỏ từ linelist gọi là symptoms_data chỉ chứa case_id và các cột triệu chứng.\n\nsymptoms_data &lt;- linelist %&gt;% \n  select(c(case_id, fever, chills, cough, aches, vomit))\n\nĐây là 50 dòng đầu tiên của bộ dữ liệu mới được tạo ra - hãy xem cách chúng được định dạng lại với mỗi triệu chứng là một cột:\n\n\n\n\n\n\nNếu chúng ta muốn lập biểu đồ số trường hợp có các triệu chứng cụ thể, chúng ta bị giới hạn bởi thực tế là mỗi triệu chứng là một cột khác nhau. Tuy nhiên, chúng ta có thể xoay các cột triệu chứng sang một định dạng dọc như sau:\n\nsymptoms_data_long &lt;- symptoms_data %&gt;%    # begin with \"mini\" linelist called symptoms_data\n  \n  pivot_longer(\n    cols = -case_id,                       # pivot all columns except case_id (all the symptoms columns)\n    names_to = \"symptom_name\",             # assign name for new column that holds the symptoms\n    values_to = \"symptom_is_present\") %&gt;%  # assign name for new column that holds the values (yes/no)\n  \n  mutate(symptom_is_present = replace_na(symptom_is_present, \"unknown\")) # convert NA to \"unknown\"\n\nDưới đây là danh sách 50 dòng đầu tiên. Lưu ý rằng với mỗi trường hợp sẽ có 5 dòng - mỗi dòng tương ứng với một triệu chứng có thể xảy ra. Các cột mới có tên symptom_name và symptom_is_present là kết quả của việc xoay trục dữ liệu. Lưu ý rằng định dạng này có thể không hữu ích cho các hoạt động khác, nhưng rất hữu ích cho việc vẽ biểu đồ.",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.vn.html#các-khái-niệm-cơ-bản-của-ggplot",
    "href": "new_pages/ggplot_basics.vn.html#các-khái-niệm-cơ-bản-của-ggplot",
    "title": "30  ggplot cơ bản",
    "section": "30.2 Các khái niệm cơ bản của ggplot",
    "text": "30.2 Các khái niệm cơ bản của ggplot\n“Ngữ pháp đồ thị” - ggplot2\nVẽ đồ thị với ggplot2 dựa trên việc “thêm” các lớp đồ thị và các phần tử thiết kế chồng lên nhau, với mỗi lệnh được thêm vào các lệnh trước bằng một dấu cộng (+). Kết quả là một đối tượng biểu đồ nhiều lớp có thể được lưu, sửa đổi, in, xuất ra, v.v.\nCác đối tượng ggplot có thể rất phức tạp, nhưng thứ tự cơ bản của các lớp thường sẽ giống như sau:\n\nBắt đầu với lớp nền bằng lệnh ggplot() - lệnh này “mở” ggplot và cho phép các hàm tiếp theo được thêm vào với dấu +. Thông thường, tập dữ liệu cũng được chỉ định trong lệnh này\n\nThêm các lớp “geom” - các hàm này trực quan hóa dữ liệu dưới dạng geometries - hình học (shapes - hình dạng), ví dụ: biểu đồ cột, biểu đồ đường, biểu đồ phân tán, histogram (hoặc là sự kết hợp giữa chúng!). Tất cả các hàm này đều bắt đầu với tiền tố geom_.\n\nThêm các yếu tố thiết kế vào đồ thị, chẳng hạn như nhãn trục, tiêu đề, phông chữ, kích thước, phối màu, chú giải hoặc xoay trục\n\nMột ví dụ đơn giản về bộ khung code như dưới đây. Chúng tôi sẽ giải thích từng cấu phần trong các phần bên dưới.\n\n# plot data from my_data columns as red points\nggplot(data = my_data)+                   # use the dataset \"my_data\"\n  geom_point(                             # add a layer of points (dots)\n    mapping = aes(x = col1, y = col2),    # \"map\" data column to axes\n    color = \"red\")+                       # other specification for the geom\n  labs()+                                 # here you add titles, axes labels, etc.\n  theme()                                 # here you adjust color, font, size etc of non-data plot elements (axes, title, etc.)",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.vn.html#ggplot",
    "href": "new_pages/ggplot_basics.vn.html#ggplot",
    "title": "30  ggplot cơ bản",
    "section": "30.3 ggplot()",
    "text": "30.3 ggplot()\nLệnh mở đầu của bất kỳ biểu đồ ggplot2 nào cũng là ggplot(). Lệnh này chỉ đơn giản là tạo ra một khung trống để thêm các lớp. Nó “mở ra” con đường cho các lớp tiếp theo được thêm vào với dấu +.\nThông thường, lệnh ggplot() bao gồm đối số data = cho biểu đồ. Việc này giúp thiết lập bộ dữ liệu mặc định được sử dụng cho các lớp tiếp theo của biểu đồ.\nLệnh này sẽ kết thúc bằng một dấu + sau dấu ngoặc đơn đóng cuối cùng của hàm. Điều này giúp lệnh “mở” trở lại. ggplot sẽ chỉ thực thi/xuất hiện khi lệnh đầy đủ bao gồm một lớp cuối cùng mà không có dấu + ở cuối.\n\n# This will create plot that is a blank canvas\nggplot(data = linelist)",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.vn.html#kiểu-biều-đồ---geoms",
    "href": "new_pages/ggplot_basics.vn.html#kiểu-biều-đồ---geoms",
    "title": "30  ggplot cơ bản",
    "section": "30.4 Kiểu biều đồ - Geoms",
    "text": "30.4 Kiểu biều đồ - Geoms\nMột khung trống chắc chắn là không đủ - chúng ta cần tạo thêm các hình học (dạng) từ dữ liệu (vd: biểu đồ cột, histograms, biểu đồ phân tán, box plots).\nĐiều này được thực hiện bằng cách thêm các lớp “geoms” vào lệnh ggplot() ban đầu. Có rất nhiều hàm ggplot2 có thể tạo ra các “geoms”. Mỗi hàm này bắt đầu bằng “geom_”, vì vậy chúng tôi sẽ gọi chúng một cách chung chung là geom_XXXX(). Có hơn 40 loại geoms trong ggplot2 và rất nhiều cái khác được tạo ra bởi cộng đồng. Xem chúng tại thư viện ggplot2. Một số geom phổ biến được liệt kê dưới đây:\n\nHistograms - geom_histogram()\n\nBiểu đồ cột - geom_bar() hoặc geom_col() (xem mục “Biểu đồ cột”)\n\nBox plots - geom_boxplot()\n\nĐiểm (vd: biểu đồ phân tán) - geom_point()\n\nBiểu đồ đường - geom_line() hoặc geom_path()\n\nĐường xu hướng - geom_smooth()\n\nTrong một biểu đồ, bạn có thể hiển thị một hoặc nhiều geoms. Chúng sẽ được thêm vào các lệnh ggplot2 trước đó bằng dấu +, và chúng được vẽ theo thứ tự sao cho các geoms sau được vẽ lên phía trên của geoms trước đó.",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.vn.html#ggplot_basics_mapping",
    "href": "new_pages/ggplot_basics.vn.html#ggplot_basics_mapping",
    "title": "30  ggplot cơ bản",
    "section": "30.5 Chọn dữ liệu cho biểu đồ",
    "text": "30.5 Chọn dữ liệu cho biểu đồ\nHầu hết các hàm geom phải được cho biết cái gì được sử dụng để vẽ biểu đồ - vì vậy bạn phải cung cấp cách map (gán) các biến số trong dữ liệu của bạn tới các thành phần của biểu đồ như là các trục, màu đối tượng, kích thước đối tượng, v.v. Đối với hầu hết các geoms, các thành phần thiết yếu phải được gán tới các cột trong dữ liệu là trục x, và (nếu cần) là trục y.\nViệc “mapping” được thực hiện bằng đối số mapping = của hàm. Giá trị bạn cung cấp tới mapping phải được gói trong hàm aes(), vì vậy bạn sẽ viết một cái gì đó kiểu như mapping = aes(x = col1, y = col2), như được trình bày bên dưới.\nDưới đây, trong lệnh ggplot(), dữ liệu được thiết lập là các trường hợp trong bộ linelist. Trong đối số mapping = aes(), cột age được gán cho trục x, và cột wt_kg được gán cho trục y.\nSau dấu +, các lệnh vẽ biểu đồ được tiếp tục. Một đối tượng được tạo bằng hàm “geom” thông qua geom_point(). Geom này kế thừa các thông số được gán từ lệnh ggplot() bên trên - nó biết các trục được gán và tiếp tục trực quan hóa mối quan hệ giữa chúng dưới dạng các điểm trên khung vẽ.\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+\n  geom_point()\n\n\n\n\n\n\n\n\nMột ví dụ khác, lệnh sau sử dụng bộ số liệu tương tự, chỉ có một sự khác biệt nhỏ về cách mapping và hàm geom. Hàm geom_histogram() chỉ yêu cầu gán cột cho trục x, bởi vì trục số lượng y được tạo ra một cách tự động.\n\nggplot(data = linelist, mapping = aes(x = age))+\n  geom_histogram()\n\n\n\n\n\n\n\n\n\nThuộc tính biểu đồ\nTrong ggplot, thuật ngữ “thẩm mỹ đồ thị” có một ý nghĩa đặc biệt. Nó đề cập đến một thuộc tính trực quan của dữ liệu được vẽ. Lưu ý rằng “thẩm mỹ” ở đây đề cập đến dữ liệu đưuợc vẽ bằng các geoms/shapes - không phải các thành phần hiển thị xung quanh như là tiêu đề, nhãn của trục, màu nền, mà bạn có thể liên kết với từ “thẩm mỹ” trong Tiếng Anh thông dụng. Trong ggplot, những chi tiết đó được gọi là “chủ đề” và được điều chỉnh trong lệnh theme()(xem phần này).\nDo đó, thẩm mỹ của đối tượng biểu đồ có thể là màu sắc, kích thước, độ trong suốt, vị trí, v.v. của dữ liệu được vẽ. Không phải tất cả các geoms sẽ có các tùy chọnthuộc tính giống nhau, nhưng một số tùy chọn được áp dụng với phần lớn các geoms. Dưới đây là một số ví dụ:\n\nshape = Hiển thị một điểm với hàm geom_point() dưới dạng dấu chấm, ngôi sao, hình tam giác hoặc hình vuông…\n\nfill = Màu sắc bên trong (vd: của cột hoặc boxplot)\n\ncolor = Đường bên ngoài của cột, boxplot, v.v., hoặc màu của điểm nếu sử dụng hàm geom_point()\n\nsize = Kích thước (vd: độ dày của đường, kích thước của điểm)\n\nalpha = Độ trong suốt (1 = bình thường, 0 = vô hình)\n\nbinwidth = Độ rộng các bins trong biểu đồ histogram\n\nwidth = Độ rộng của các cột trong “biểu đồ cột”\n\nlinetype = Kiểu của đường (vd: liền, nét đứt, chấm chấm)\n\nThẩm mỹ của đối tượng biểu đồ có thể được gán giá trị theo hai cách:\n\nGán một giá trị tĩnh (vd: color = \"blue\") để áp dụng cho tất cả các quan sát được vẽ biểu đồ\n\nGán cho một cột của dữ liệu (vd: color = hospital) để hiển thị từng quan sát phụ thuộc vào giá trị của nó trong cột đó\n\n\n\n\nGán một giá trị tĩnh\nNếu bạn muốn thuộc tính biểu đồ cho đối tượng biểu đồ là tĩnh, nghĩa là - giống nhau đối với mọi quan sát trong dữ liệu, bạn viết phép gán của nó bên trong geom nhưng ở bên ngoài của bất cứ đối số mapping = aes() nào. Các phép gán này có thể trông như này size = 1 hoặc color = \"blue\". Sau đây là hai ví dụ:\n\nTrong ví dụ đầu tiên, đối số mapping = aes() ở bên trong hàm ggplot() và các trục được gán tới cột age và weight trong bộ dữ liệu. Các thuộc tính biểu đồ như là color =, size =, và alpha = (độ trong suốt) được gán các giá trị tĩnh. Để rõ ràng, điều này được thực hiện trong hàm geom_point(), vì bạn có thể thêm các geom khác sau đó mà sẽ nhận các giá trị khác nhau cho các thuộc tính biểu đồ của biểu đồ.\n\nTrong ví dụ thứ hai, biểu đồ histogram chỉ yêu cầu trục x được gán với một cột. Các thông số của biểu đồ histogram như binwidth =, color =, fill = (màu sắc bên trong), và alpha = một lần nữa được đặt trong geom thành các giá trị tĩnh.\n\n\n# scatterplot\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  # set data and axes mapping\n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)         # set static point aesthetics\n\n# histogram\nggplot(data = linelist, mapping = aes(x = age))+       # set data and axes\n  geom_histogram(              # display histogram\n    binwidth = 7,                # width of bins\n    color = \"red\",               # bin line color\n    fill = \"blue\",               # bin interior color\n    alpha = 0.1)                 # bin transparency\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVẽ theo tỷ lệ giá trị của cột\nMột cách khác đó là vẽ theo tỷ lệ giá trị của cột các đối tượngthuộc tính của biểu đồ. Theo cách tiếp cận này, việc hiển thị các đối tượngthuộc tính sẽ phụ thuộc vào giá trị của quan sát trong cột dữ liệu đó. Nếu các giá trị cột là liên tục, thang đo hiển thị (chú giải) chothuộc tính đó sẽ là liên tục. Nếu các giá trị cột là rời rạc, chú giải sẽ hiển thị từng giá trị và dữ liệu được vẽ biểu đồ sẽ xuất hiện dưới dạng “được nhóm” (đọc thêm ở mục Nhóm trong chương này).\nĐể đạt được điều này, bạn gán thuộc tính biểu đồ của biểu đồ với một tên cột (không trong dấu ngoặc kép). Điều này phải được thực hiện bên trong một hàm mapping = aes() (lưu ý: có một số vị trí trong code mà bạn có thể thực hiện các phép gán, như được thảo luận bên dưới).\nHai ví dụ như sau.\n\nỞ ví dụ đầu tiên, thuộc tính biểu đồ color = (của mỗi điểm) được gán cho cột age - và thang đo liên tục được xuất hiện dưới dạng chú thích! Hiện tại bạn chỉ cần quan tâm tới sự xuất hiện của thanh này - chúng ta sẽ học cách chỉnh sửa nó trong các phần sau.\n\nTrong ví dụ thứ hai, hai thuộc tính biểu đồ được gán cho hai cột tương ứng (color = và size =), trong khi shape = và alpha = được gán cho các giá trị tĩnh bên ngoài đối số mapping = aes().\n\n\n# scatterplot\nggplot(data = linelist,   # set data\n       mapping = aes(     # map aesthetics to column values\n         x = age,           # map x-axis to age            \n         y = wt_kg,         # map y-axis to weight\n         color = age)\n       )+     # map color to age\n  geom_point()         # display data as points \n\n# scatterplot\nggplot(data = linelist,   # set data\n       mapping = aes(     # map aesthetics to column values\n         x = age,           # map x-axis to age            \n         y = wt_kg,         # map y-axis to weight\n         color = age,       # map color to age\n         size = age))+      # map size to age\n  geom_point(             # display data as points\n    shape = \"diamond\",      # points display as diamonds\n    alpha = 0.3)            # point transparency at 30%\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLưu ý: Các phép gán trục luôn được gán cho các cột trong dữ liệu (không phải cho các giá trị tĩnh) và điều này luôn được thực hiện với mapping = aes().\nĐiều quan trọng là phải theo dõi các lớp của biểu đồ và các đối tượngthuộc tính khi vẽ các biểu đồ phức tạp - ví dụ biểu đồ được cấu thành từ nhiều geoms. ITrong ví dụ dưới đây, size = được gán hai lần - một lần cho geom_point() và một lần cho geom_smooth() - cả hai lần đều là giá trị tĩnh.\n\nggplot(data = linelist,\n       mapping = aes(           # map aesthetics to columns\n         x = age,\n         y = wt_kg,\n         color = age_years)\n       ) + \n  geom_point(                   # add points for each row of data\n    size = 1,\n    alpha = 0.5) +  \n  geom_smooth(                  # add a trend line \n    method = \"lm\",              # with linear method\n    size = 2)                   # size (width of line) of 2\n\n\n\n\n\n\n\n\n\n\nCách gán thuộc tính đồ thị\nViệc gán các thuộc tính biểu đồ bên trong đối số mapping = aes() có thể được viết ở nhiều hàm vẽ biểu đồ và thậm chí có thể được viết nhiều lần. Nó có thể được viết ở hàm ggplot() cao nhất, và/hoặc cho từng biểu đồ riêng lẻ bên dưới. Các kiểu viết bao gồm:\n\nCác phép gán được thực hiện ở lệnh ggplot() trên cùng sẽ được mặc định kế thừa ở bất kỳ các biểu đồ bên dưới, giống như cách mà x = và y = được kế thừa\nCác phép gán được thực hiện trong một hàm vẽ biểu đồ chỉ áp dụng cho biểu đồ đó\n\nTương tự, data = được chỉ định cho lệnh ggplot() ở trên đầu sẽ áp dụng mặc định cho tất cả các biểu đồ bên dưới, nhưng bạn vẫn có thể chỉ định data riêng cho từng biểu đồ (nhưng sẽ khó hơn).\nDo đó, mỗi lệnh sau sẽ tạo ra cùng một biểu đồ giống nhau:\n\n# These commands will produce the exact same plot\nggplot(data = linelist, mapping = aes(x = age))+\n  geom_histogram()\n\nggplot(data = linelist)+\n  geom_histogram(mapping = aes(x = age))\n\nggplot()+\n  geom_histogram(data = linelist, mapping = aes(x = age))\n\n\n\nNhóm\nBạn có thể dễ dàng nhóm dữ liệu và “vẽ biểu đồ theo nhóm”. Trên thực tế, bạn đã làm điều này rồi!\nGán cột “phân nhóm” với thuộc tính biểu đồ biều đồ phù hợp, bên trong đối số mapping = aes(). Ở bên trên, chúng ta đã minh họa nó bằng cách sử dụng các giá trị liên tục khi gán điểm size = tới cột age. Tuy nhiên, cách này cũng hoạt động theo cùng một cơ chế đối với các cột rời rạc/phân loại.\nVí dụ, nếu bạn muốn các điểm được hiển thị theo giới, bạn sẽ đặt mapping = aes(color = gender). Một chú giải tự động hiện lên. Phép gán này có thể được thực hiện bên trong mapping = aes() ở lệnh ggplot() đầu tiên (và được thừa kế bởi các biểu đồ), hoặc nó thể được đặt trong một mapping = aes() riêng biệt bên trong biểu đồ Cả hai cách tiếp cận được trình bày dưới đây:\n\nggplot(data = linelist,\n       mapping = aes(x = age, y = wt_kg, color = gender))+\n  geom_point(alpha = 0.5)\n\n\n\n\n\n\n\n\n\n# This alternative code produces the same plot\nggplot(data = linelist,\n       mapping = aes(x = age, y = wt_kg))+\n  geom_point(\n    mapping = aes(color = gender),\n    alpha = 0.5)\n\nLưu ý rằng tùy thuộc vào loại geom bạn sử dụng, bạn sẽ cần sử dụng các đối số khác nhau để nhóm dữ liệu. Đối với geom_point(), bạn sẽ thường sử dụng nhất các tham số như color =, shape = hoặc size =. Trong khi đó đối với geom_bar(), bạn thường sử dụng nhất tham số fill =. Điều này chỉ phụ thuộc vào loại geom và yếu tố trang trí nào bạn muốn thể hiện sự phân nhóm.\nCách cơ bản nhất để nhóm dữ liệu là chỉ sử dụng đối số group = bên trong mapping = aes(). Tuy nhiên, cách này tự nó sẽ không làm thay đổi màu sắc, hình dạng hoặc tạo ra chú thích. Tuy nhiên dữ liệu được nhóm lại, do đó hiển thị thống kê có thể bị ảnh hưởng.\nĐể thay đổi thứ tự của các nhóm trong biểu đồ, xem chương Các mẹo với ggplot hoặc chương Factors. Ngoài ra cũng có rất nhiều ví dụ về các biểu đồ được nhóm trong các phần bên dưới đối với dữ liệu dạng liên tục và danh mục.",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.vn.html#ggplot_basics_facet",
    "href": "new_pages/ggplot_basics.vn.html#ggplot_basics_facet",
    "title": "30  ggplot cơ bản",
    "section": "30.6 Facets / Chia nhỏ biểu đồ",
    "text": "30.6 Facets / Chia nhỏ biểu đồ\nFacets, hay “chia nhỏ biểu đồ”, được sử dụng để chia một biểu đồ thành nhiều phần nhỏ, với mỗi phần (“facet”) đại diện cho một nhóm của dữ liệu. Các biểu đồ giống nhau được tạo nhiều lần, mỗi cái sử dụng một phân nhóm của cùng một bộ dữ liệu.\nFaceting là một chức năng đi kèm với ggplot2, vì vậy các chú giải và trục của các biểu đồ nhỏ được căn chỉnh tự động. Có các package khác được thảo luận trong chương Các mẹo với ggplot được sử dụng để kết hợp các biểu đồ hoàn toàn khác nhau (cowplot và patchwork) thành một biểu đồ.\nFaceting được thực hiện bằng các hàm ggplot2 sau đây:\n\nfacet_wrap() Để hiện thị các biểu đồ khác nhau cho từng thứ bậc của một biến số đơn lẻ. Một ví dụ như thể hiện các đường cong dịch bệnh khác nhau cho từng bệnh viện trong khu vực. Các facets được sắp xếp theo thứ tự bảng chữ cái, trừ khi biến có kiểu factor với các thứ bậc đã được xác định.\n\n\n\nBạn có thể sử dụng một số tùy chọn nhất định để xác định bố cục của các facets, vd: nrow = 1 hoặc ncol = 1 để kiểm soát số hàng hoặc cột mà chúng được sắp xếp.\n\n\nfacet_grid() Áp dụng khi bạn muốn đưa một biến thứ hai vào sắp xếp các biểu đồ con. Ở đây mỗi ô thể hiện sự giao nhau của các giá trị giữa hai cột. Ví dụ, các đường cong dịch bệnh cho từng sự kết hợp của bệnh viện-nhóm tuổi với các bệnh viện dọc theo phía đỉnh (các cột) và các nhóm tuổi dọc theo hai bên (các hàng).\n\n\n\nnrow và ncol không được áp dụng, bởi vì các phân nhóm được trình bày dưới dạng lưới\n\nMỗi hàm này chấp nhận một cú pháp công thức để chỉ định cột được faceting. Cả hai đều chấp nhận tối đa hai cột, mỗi cột ở một bên dấu ngã ~.\n\nĐối với facet_wrap(), bạn sẽ thường chỉ viết một cột trước dấu ngã ~ chẳng hạn như facet_wrap(~hospital). Tuy nhiên, bạn vẫn có thể viết hai cột, ví dụ facet_wrap(outcome ~ hospital) - mỗi kết hợp duy nhất sẽ hiển thị trong một ô riêng biệt, nhưng chúng sẽ không được sắp xếp trong một lưới. Các tiêu đề sẽ hiển thị các thuật ngữ kết hợp và chúng sẽ không phải là logic cụ thể cho các cột so với các hàng. Nếu bạn đang chỉ cung cấp một biến số để faceting, dấu chấm . được sử dụng như để giữ chỗ cho phía bên kia của công thức - hãy xem các ví dụ về code.\nĐối với facet_grid() bạn cũng có thể chỉ định một hoặc hai cột tới công thức (grid rows ~ columns). Nếu bạn chỉ muốn chỉ định một cột, hãy đặt một dấu chấm . ở một phía của dấu ngã chẳng hạn như facet_grid(. ~ hospital) hoặc facet_grid(hospital ~ .).\n\nFacets có thể chứa một lượng lớn thông tin - vì vậy bạn nên đảm bảo những biến số được lựa chọn để facets không có quá nhiều thứ bậc. Dưới đây là một số ví dụ nhanh với tập dữ liệu sốt rét (xem chương Tải sách và dữ liệu) bao gồm số lượng trường hợp sốt rét hàng ngày của các cơ sở theo nhóm tuổi..\nSau đây chúng ta nhập số liệu vào và thực hiện một số biến đổi để đơn giản hóa:\n\n# These data are daily counts of malaria cases, by facility-day\nmalaria_data &lt;- import(here(\"data\", \"malaria_facility_count_data.rds\")) %&gt;%  # import\n  select(-submitted_date, -Province, -newid)                                 # remove unneeded columns\n\n50 hàng đầu tiên của dữ liệu sốt rét được trình bày như bên dưới. Lưu ý rằng có một cột tên là malaria_tot, ngoài ra còn có các cột khác chứa thông tin về số lượng trường hợp theo nhóm tuổi (chúng sẽ được sử dụng trong ví dụ thứ hai với facet_grid()).\n\n\n\n\n\n\n\nfacet_wrap()\nTại thời điểm này, hãy chỉ tập trung vào các cột malaria_tot và District, tạm thời bỏ qua cột số lượng ca bệnh theo tuổi. Chúng ta sẽ vẽ các đường cong dịch bệnh với hàm geom_col(), giúp tạo ra một cột cho từng ngày với độ cao được xác định từ giá trị của cột malaria_tot (dữ liệu đã là số lượng hàng ngày, vì vậy chúng tôi sử dụng hàm geom_col() - xem mục “Biểu đồ cột” bên dưới).\nKhi chúng ta thêm lệnh facet_wrap(), hãy thêm dấu ngã kèm với cột dùng để facet bên trong lệnh (trong trường hợp này là District). Bạn có thể đặt một cột khác ở bên trái của dấu ngã, - điều này sẽ tạo ra một facet cho từng sự kết hợp - nhưng chúng tôi khuyên bạn nên làm điều đó bằng hàm facet_grid(). Trong ví dụ này, chỉ một facet được tạo ra cho giá trị duy nhất của cột District.\n\n# A plot with facets by district\nggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1, fill = \"darkred\") +       # plot the count data as columns\n  theme_minimal()+                              # simplify the background panels\n  labs(                                         # add plot labels, title, etc.\n    x = \"Date of report\",\n    y = \"Malaria cases\",\n    title = \"Malaria cases by district\") +\n  facet_wrap(~District)                       # the facets are created\n\n\n\n\n\n\n\n\n\n\nfacet_grid()\nChúng ta có thể sử dụng cách tiếp cận facet_grid() đối với hai biến. Giả sử chúng ta muốn thêm District and age vào biểu đồ của mình. Trước hết, chúng ta cần thực hiện một số biến đổi dữ liệu trên các cột tuổi để đưa những dữ liệu này sang định dạng “dài” được ggplot ưu tiên. Tất cả các nhóm tuổi đều có các cột riêng - chúng ta cần chúng nhập vào một cột duy nhất có tên age_group và một cột khasc có tên num_cases. Xem chương Xoay trục dữ liệu để hiểu thêm về quy trình này.\n\nmalaria_age &lt;- malaria_data %&gt;%\n  select(-malaria_tot) %&gt;% \n  pivot_longer(\n    cols = c(starts_with(\"malaria_rdt_\")),  # choose columns to pivot longer\n    names_to = \"age_group\",      # column names become age group\n    values_to = \"num_cases\"      # values to a single column (num_cases)\n  ) %&gt;%\n  mutate(\n    age_group = str_replace(age_group, \"malaria_rdt_\", \"\"),\n    age_group = forcats::fct_relevel(age_group, \"5-14\", after = 1))\n\n50 hàng đầu tiên của dữ liệu trông giống như sau:\n\n\n\n\n\n\nKhi bạn chuyển hai biến số tới facet_grid(), cách đơn giản nhất là sử dụng ký hiệu công thức (vd: x ~ y), trong đó x là hàng và y là cột. Dưới đây là biểu đồ, sử dụng facet_grid() để hiển thị các biểu đồ cho mỗi kết hợp của các cột age_group và District.\n\nggplot(malaria_age, aes(x = data_date, y = num_cases)) +\n  geom_col(fill = \"darkred\", width = 1) +\n  theme_minimal()+\n  labs(\n    x = \"Date of report\",\n    y = \"Malaria cases\",\n    title = \"Malaria cases by district and age group\"\n  ) +\n  facet_grid(District ~ age_group)\n\n\n\n\n\n\n\n\n\n\nGiới hạn trục tự do hoặc cố định\nTheo mặc định, các tỷ lệ trục được hiển thị khi faceting là giống nhau (cố định) trên tất cả các facets. Điều này rất hữu ích cho việc so sánh chéo, nhưng không phải lúc nào cũng thích hợp.\nKhi sử dụng facet_wrap() hoặc facet_grid(), chúng ta có thể thêm scales = \"free_y\" để “free” hoặc giải phóng trục y của các biểu đồ nhỏ chia tỷ lệ thích hợp với tập con dữ liệu của chúng. Điều này đặc biệt hữu ích nếu số lượng thực tế là nhỏ đối với một trong các danh mục phụ và khó có thể nhìn thấy xu hướng. Thay vì “free_y”, chúng ta cũng có thể viết “free_x” để làm tương tự đối với trục x (vd: biến ngày thág) hoặc “free” đối với cả hai trục. Lưu ý rằng trong facet_grid, tỷ lệ y sẽ giống nhau đối với các facets trong cùng một hàng và tỷ lệ x sẽ giống nhau đối với các facets trong cùng một cột.\nKhi chỉ sử dụng facet_grid, chúng ta có thể thêm space = \"free_y\" hoặc space = \"free_x\" để chiều cao hoặc chiều rộng thực tế của facet được tính theo giá trị của biều đồ bên trong. Điều này chỉ hoạt động nếu scales = \"free\" (y hoặc x) đã được áp dụng.\n\n# Free y-axis\nggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1, fill = \"darkred\") +       # plot the count data as columns\n  theme_minimal()+                              # simplify the background panels\n  labs(                                         # add plot labels, title, etc.\n    x = \"Date of report\",\n    y = \"Malaria cases\",\n    title = \"Malaria cases by district - 'free' x and y axes\") +\n  facet_wrap(~District, scales = \"free\")        # the facets are created\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTrật tự thứ bậc của Factor trong facets\nXem bài viết này về cách làm thế nào để sắp xếp lại thức bậc của biến factor bên trong facets.",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.vn.html#lưu-biểu-đồ",
    "href": "new_pages/ggplot_basics.vn.html#lưu-biểu-đồ",
    "title": "30  ggplot cơ bản",
    "section": "30.7 Lưu biểu đồ",
    "text": "30.7 Lưu biểu đồ\n\nLưu biểu đồ\nMặc định khi bạn chạy lệnh ggplot(), biểu đồ sẽ được in ở cửa số Plots của RStudio. Tuy nhiên, bạn cũng có thể lưu biểu đồ dưới dạng một đối tượng bằng cách sử dụng toán tử gán &lt;- và đặt tên cho nó. Biểu đồ sẽ không được in ra trừ khi bạn gọi tên của đối tượng. Bạn cũng có thể in nó bằng cách đưa tên biểu đồ vào hàm print(), nhưng điều này chỉ cần thiết trong một số trường hợp nhất định chẳng hạn như khi biểu đồ được tạo bên trong một vòng lặp for để in nhiều biểu đồ cùng một lúc (xem chương Lặp, vòng lặp, và danh sách).\n\n# define plot\nage_by_wt &lt;- ggplot(data = linelist, mapping = aes(x = age_years, y = wt_kg, color = age_years))+\n  geom_point(alpha = 0.1)\n\n# print\nage_by_wt    \n\n\n\n\n\n\n\n\n\n\nChỉnh sửa biều đồ đã lưu\nMột điểm hay của ggplot2 là bạn có thể gán tên cho một biểu đồ (như bên trên), và sau đó thêm các lớp mới bắt đầu bằng tên của nó. Bạn không cần phải lặp lại tất cả các lệnh đã tạo ra biểu đồ ban đầu!\nVí dụ: để sửa đổi biểu đồ age_by_wt đã được định nghĩa ở bên trên, thêm một trục dọc tại tuổi bằng 50, chúng ta chỉ cần thêm dấu + và bắt đầu thêm các lớp bổ sung vào biểu đồ.\n\nage_by_wt+\n  geom_vline(xintercept = 50)\n\n\n\n\n\n\n\n\n\n\nXuất biểu đồ\nViệc xuất biểu đồ được thực hiện dễ dàng với hàm ggsave() của package ggplot2. Nó có thể hoạt động theo hai cách:\n\nChỉ định tên của đối tượng biểu đồ, sau đó là đường dẫn tệp và tên có phần mở rộng\n\nVí dụ: ggsave(my_plot, here(\"plots\", \"my_plot.png\"))\n\n\nChạy lệnh chỉ với một đường dẫn tệp, để lưu biểu đồ gần nhất được in ra\n\nVí dụ: ggsave(here(\"plots\", \"my_plot.png\"))\n\n\nBạn có thể xuất dưới dạng tệp png, pdf, jpeg, tiff, bmp, svg, hoặc một số định dạng khác, bằng cách chỉ định phần mở rộng tệp trong đường dẫn tệp.\nBạn cũng có thể chỉ định các đối số width =, height =, và units = (“in”, “cm”, hoặc “mm”). Bạn cũng có thể chỉ định dpi = để điều chỉnh độ phân giâỉ của biểu đồ (vd: dpi = 300). Xem hướng dẫn chi tiết về hàm bằng cách gõ ?ggsave hoặc đọc tài liệu online này.\nHãy nhớ rằng bạn có thể sử dụng cú pháp here() để cung cấp đường dẫn tệp mong muốn. Xem chương Nhập xuất dữ liệu để biết thêm thông tin.",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.vn.html#nhãn",
    "href": "new_pages/ggplot_basics.vn.html#nhãn",
    "title": "30  ggplot cơ bản",
    "section": "30.8 Nhãn",
    "text": "30.8 Nhãn\nChắc chắn là bạn sẽ muốn thêm hoặc điều chỉnh nhãn của biểu đồ. Việc này được thực hiện dễ dàng nhất với hàm labs() bằng cách thêm dấu + như cách bạn thêm các geoms.\nBên trong hàm labs(), bạn có thể cung cấp các chuỗi ký tự cho các đối số sau:\n\nx = và y = Tiêu đề trục x và trục y (nhãn)\n\ntitle = Tiêu đề chính của biểu đồ\n\nsubtitle = Tiêu đề phụ của biểu đồ, nhỏ hơn và đặt bên dưới tiêu đề chính\n\ncaption = Caption của biểu đồ, mặc định ở góc phải dưới\n\nDưới đây là biểu đồ chúng ta đã tạo lúc trước, nhưng có thêm các nhãn:\n\nage_by_wt &lt;- ggplot(\n  data = linelist,   # set data\n  mapping = aes(     # map aesthetics to column values\n         x = age,           # map x-axis to age            \n         y = wt_kg,         # map y-axis to weight\n         color = age))+     # map color to age\n  geom_point()+           # display data as points\n  labs(\n    title = \"Age and weight distribution\",\n    subtitle = \"Fictional Ebola outbreak, 2014\",\n    x = \"Age in years\",\n    y = \"Weight in kilos\",\n    color = \"Age\",\n    caption = stringr::str_glue(\"Data as of {max(linelist$date_hospitalisation, na.rm=T)}\"))\n\nage_by_wt\n\n\n\n\n\n\n\n\nHãy để ý chúng ta đã sử dụng hàm str_glue() từ package stringr để tạo một code R động bên trong văn bản khi gán giá trị cho caption. Caption sẽ hiển thị “Dữ liệu kể từ:” phản ánh ngày nhập viện gần nhất trong bộ dữ liệu linelist. Đọc thêm ở chương Ký tự và chuỗi.\nMột chú ý khi bạn muốn thêm tiêu đề cho chú giải: Đó là không có đối số “legend title”, vì bạn có thể có nhiều thang đo trong chú giải của mình. Bên trong lệnh labs(), bạn có thể viết đối số cho thuộc tính biểu đồ được sử dụng để tạo chú giải, và cung cấp tiêu đề cho nó theo cách này. Trong ví dụ bên trên, chúng ta đã gán color = age để tạo chú giải. Do đó, chúng ta cũng cung cấp đối số color = ttrong hàm labs() và gán tiêu đề chú giải mong muốn (“Age” với chữ A được viết hoa). Nếu bạn tạo chú thích bằng đối số aes(fill = COLUMN), thì trong lệnh labs() bạn nên viết fill = để điều chỉnh tiêu đề cho chú thích. Xem thêm mục thang đo màu sắc trong chương Các mẹo với ggplot để biết thêm chi tiết về cách chỉnh sửa chú giải và cách tiếp cận thay thế bằng cách sử dụng các hàm scales_().",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.vn.html#ggplot_basics_themes",
    "href": "new_pages/ggplot_basics.vn.html#ggplot_basics_themes",
    "title": "30  ggplot cơ bản",
    "section": "30.9 Chủ đề",
    "text": "30.9 Chủ đề\nMột trong những phần hay nhất của ggplot2 là mức độ kiểm soát của bạn đối với biểu đồ - bạn có thể định nghĩa bất kỳ điều gì! Như đã đề cập ở trên, thiết kế của biểu đồ không liên quan tới dạng biểu đồ mà được điều chỉnh bên trong hàm theme(). Ví dụ, màu nền của biểu đồ, sự xuất hiện/biến mất của đường lưới, cũng như phông chữ/cỡ chữ/màu sắc/căn lề của văn bản (tiêu đề chính, tiêu đề phụ, captions, chữ trên các trục…). Những điều chỉnh này có thể được thực hiện theo hai cách:\n\nThêm một chủ đề hoàn chỉnh bằng hàm theme_() để điều chỉnh toàn bộ các thành phần biểu đồ - các chủ đề hoàn chỉnh này bao gồm theme_classic(), theme_minimal(), theme_dark(), theme_light() theme_grey(), theme_bw()\nĐiều chỉnh từng khía cạnh đơn lẻ của biểu đồ với hàm theme()\n\n\nChủ đề hoàn chỉnh\nVì chúng khá đơn giản, chúng tôi sẽ trình bày các hàm chủ đề hoàn chỉnh bên dưới và sẽ không mô tả thêm ở đây. Lưu ý rằng bất kỳ điều chỉnh nhỏ nào bằng hàm theme() nên được thực hiện sau khi áp dụng một chủ đề hoàn chỉnh.\nViết chúng với dấu ngoặc đơn trống.\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme classic\")+\n  theme_classic()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme bw\")+\n  theme_bw()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme minimal\")+\n  theme_minimal()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Theme gray\")+\n  theme_gray()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTùy chỉnh chủ đề\nHàm theme() có thể nhận một số lượng lớn các đối số, mỗi đối số sẽ chỉnh sửa một khía cạnh rất cụ thể của biểu đồ. Chúng tôi sẽ không trình bày tất cả các đối số, nhưng sẽ tập trung mô tả công thức chung cho chúng và chỉ cho bạn cách tìm tên đối số mà bạn cần. Cú pháp cơ bản là:\n\nBên trong hàm theme(), hãy viết tên đối số cho phần tử biểu đồ mà bạn muốn chỉnh sửa, chẳng hạn như plot.title =\n\nCung cấp một hàm element_() tới đối số\n\n\n\nThường sử dụng nhất là element_text(), một số khác bao gồm element_rect() chọn màu nền cho canvas, hoặc element_blank() để xóa các phần tử biểu đồ\n\n\n\nBên trong hàm element_(), xác định giá trị đối số cần gán để điều chỉnh theo ý bạn mong muốn\n\nVì trình bày bên trên vẫn khá trừu tượng, nên đây là một số ví dụ.\nLưu ý là biểu đồ dưới đây trông không thật sự đẹp, nhưng nó giúp bạn thấy nhiều cách khác nhau để bạn có thể điều chỉnh biểu đồ của mình.\n\nChúng ta bắt đầu với biểu đồ có tên age_by_wt đã được tạo ra bên trên và thêm hàm theme_classic()\n\nĐể điều chỉnh đẹp hơn, chúng ta thêm hàm theme() và bao gồm một đối số cho từng phần tử biểu đồ muốn điều chỉnh\n\nSẽ rất tốt nếu bạn sắp xếp các đối số theo một trật tự logic. Hãy xem ví dụ sau:\n\nlegend.position = là đặc biệt nhất vì nó chỉ chấp nhận các giá trị đơn giản như “bottom”, “top”, “left”, và “right”. các đối số liên quan đến văn bản yêu cầu bạn đặt các chi tiết bên trong hàm element_text().\n\nCỡ chư tiêu đề với element_text(size = 30)\n\nCăn lề caption với element_text(hjust = 0) (từ trái qua phải)\n\nTiêu đề phụ được in nghiêng với element_text(face = \"italic\")\n\n\nage_by_wt + \n  theme_classic()+                                 # pre-defined theme adjustments\n  theme(\n    legend.position = \"bottom\",                    # move legend to bottom\n    \n    plot.title = element_text(size = 30),          # size of title to 30\n    plot.caption = element_text(hjust = 0),        # left-align caption\n    plot.subtitle = element_text(face = \"italic\"), # italicize subtitle\n    \n    axis.text.x = element_text(color = \"red\", size = 15, angle = 90), # adjusts only x-axis text\n    axis.text.y = element_text(size = 15),         # adjusts only y-axis text\n    \n    axis.title = element_text(size = 20)           # adjusts both axes titles\n    )     \n\n\n\n\n\n\n\n\nSau đây là một số đối số phổ biến của hàm theme(). Bạn sẽ nhận ra một số xu hướng chung, chẳng hạn như thêm .x hoặc .y để chỉ áp dụng thay đổi cho một trục.\n\n\n\n\n\n\n\nĐối số theme()\nNhững gì nó điều chỉnh\n\n\n\n\nplot.title = element_text()\nTiêu đề chính\n\n\nplot.subtitle = element_text()\nTiêu đề phụ\n\n\nplot.caption = element_text()\nLiên quan tới caption (kiểu font, màu sắc, kích cỡ, góc độ, vjust, hjust…)\n\n\naxis.title = element_text()\nTiêu đề trục (cả trục x và y) (kích cỡ, góc độ, màu sắc…)\n\n\naxis.title.x = element_text()\nChỉ tiêu đề trục x (sử dụng .y để chỉ áp dụng với trục y)\n\n\naxis.text = element_text()\nVăn bản trên trục (cả trục x và y)\n\n\naxis.text.x = element_text()\nChỉ văn bản trục x (sử dụng .y để chỉ áp dụng với trục y)\n\n\naxis.ticks = element_blank()\nLoại bỏ ticks của trục\n\n\naxis.line = element_line()\nĐường trục (màu sắc, kích thước, kiểu đường: nét đứt, nét liền mảnh, v.v.)\n\n\nstrip.text = element_text()\nVăn bản trong Facet strip (màu sắc, kích thước, góc độ…)\n\n\nstrip.background = element_rect()\nfacet strip (tô màu, màu sắc, kích thước…)\n\n\n\nNhưng còn rất nhiều các đối số khác! Làm thế nào tôi có thể nhớ tất cả chúng? Đừng lo lắng - bạn không thể nhớ hết chúng được đâu. May mắn thay, có một vài công cụ có thể thể giúp bạn:\nTài liệu hướng dẫn của tidyverse phần tùy chỉnh chủ đề, có chứa một danh sách đầy đủ các đối số.\nMẸO: Chạy lệnh theme_get() từ ggplot2 để in tất cả hơn 90 đối số của hàm theme() ra console.\nMẸO: Nếu bạn muốn xóa một phần tử của biểu đồ, bạn cũng có thể làm điều đó bằng hàm theme(). Chỉ cần đặt element_blank() tới đối số để nó biến mất hoàn toàn. Đối với chú thích, thiết lập legend.position = \"none\".",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.vn.html#màu-sắc",
    "href": "new_pages/ggplot_basics.vn.html#màu-sắc",
    "title": "30  ggplot cơ bản",
    "section": "30.10 Màu sắc",
    "text": "30.10 Màu sắc\nXem mục thang đo cho màu sắc trong chương Các mẹo với ggplot.",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.vn.html#piping-tới-ggplot2",
    "href": "new_pages/ggplot_basics.vn.html#piping-tới-ggplot2",
    "title": "30  ggplot cơ bản",
    "section": "30.11 Piping tới ggplot2",
    "text": "30.11 Piping tới ggplot2\nKhi sử dụng pipes để làm sạch và chuyển đổi dữ liệu của bạn, bạn có thể dễ dàng chuyển dữ liệu đã chuyển đổi tới ggplot().\nCác pipes sẽ chuyển dữ liệu từ hàm-tới-hàm và sẽ chuyển tới dấu + một khi hàm ggplot() được gọi. Lưu ý rằng trong trường hợp này, không cần chỉ định đối số data =, bởi vì nó đã được tự động xác định khi bạn piping dữ liệu.\nDưới đây là cách mà nó hoạt động:\n\nlinelist %&gt;%                                                     # begin with linelist\n  select(c(case_id, fever, chills, cough, aches, vomit)) %&gt;%     # select columns\n  pivot_longer(                                                  # pivot longer\n    cols = -case_id,                                  \n    names_to = \"symptom_name\",\n    values_to = \"symptom_is_present\") %&gt;%\n  mutate(                                                        # replace missing values\n    symptom_is_present = replace_na(symptom_is_present, \"unknown\")) %&gt;% \n  \n  ggplot(                                                        # begin ggplot!\n    mapping = aes(x = symptom_name, fill = symptom_is_present))+\n  geom_bar(position = \"fill\", col = \"black\") +                    \n  theme_classic() +\n  labs(\n    x = \"Symptom\",\n    y = \"Symptom status (proportion)\"\n  )",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.vn.html#vẽ-biểu-đồ-dữ-liệu-liên-tục",
    "href": "new_pages/ggplot_basics.vn.html#vẽ-biểu-đồ-dữ-liệu-liên-tục",
    "title": "30  ggplot cơ bản",
    "section": "30.12 Vẽ biểu đồ dữ liệu liên tục",
    "text": "30.12 Vẽ biểu đồ dữ liệu liên tục\nXuyên xuốt chương này, bạn đã gặp rất nhiều ví dụ về cách vẽ biểu đồ dữ liệu liên tục. Ở đây chúng tôi tổng hợp ngắn gọn chúng và trình bày một vài biến thể.\nCác ví dụ bao gồm:\n\nVẽ biểu đồ cho một biến liên tục:\n\nHistogram, một biểu đồ thường dùng để trình bày sự phân bố của một biến số liên tục.\nBox plot (còn được gọi là box và whisker), để hiện thị khoảng phân vị 25%, 50%, và 75%, phần cuối của phân phối, và các giá trị ngoại lai (outliers) (những hạn chế quan trọng).\n\nJitter plot, để hiển thị tất cả các giá trị dưới dạng các điểm ‘lộn xộn’ để chúng có thể (hầu hết) được nhìn thấy, ngay cả khi hai điểm có cùng giá trị.\n\nViolin plot, hiển thị sự phân bố của một biến liên tục dựa trên chiều rộng đối xứng của đàn ‘violin’.\nSina plot, là sự kết hợp của jitter và violin plots, trong đó các điểm riêng lẻ được hiển thị nhưng ở hình dạng đối xứng của sự phân bố (thông qua package ggforce).\n\n\nBiểu đồ phân tán (Scatter plot) cho hai biến liên tục.\n\nBiểu đồ nhiệt dành cho ba biến liên tục (xem chương Biểu đồ nhiệt)\n\n\nHistograms\nHistograms có thể trông giống như biểu đồ cột, nhưng sự khác biệt là nó đo lường sự phân phối của một biến liên tục. Không có khoảng cách giữa các “thanh” và chỉ có một biến số được cung cấp cho hàm geom_histogram().\nDưới đây là code để tạo một histograms, mà sẽ nhóm dữ liệu liên tục thành các dải và hiển thị trong các thanh liền kề có độ cao khác nhau. Việc này được thực hiện bằng hàm geom_histogram(). Xem mục “Biểu đồ cột” trong chương này để hiểu sự khác biệt giữa các hàm geom_histogram(), geom_bar(), và geom_col().\nChúng ta sẽ hiển thị sự phân bố độ tuổi của các trường hợp. Bên trong đối số mapping = aes(), chỉ định cột bạn muốn xem phân phối. Bạn có thể gán cột này cho trục x hoặc trục y.\nCác hàng sẽ được chỉ định tới các “bins” dựa trên số tuổi của chúng, và các bins này sẽ được đồ thị hóa bằng các cột. Nếu bạn chỉ định số lượng bins bnằg đối số bins =, các điểm ngắt được cách đều giữa các giá trị tối thiểu và tối đa của biểu đồ. Nếu bins = không được chỉ định, một số lượng bins thích hợp sẽ được chọn và một thông báo sẽ hiện ra ngay sau biểu đồ:\n## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\nNếu bạn không muốn chỉ định số lượng bins tới bins =, bạn có thể chỉ định binwidth = theo đơn vị của trục. Chúng tôi đưa ra một vài ví dụ trình bày sự khác biệt giữa bins và bin widths:\n\n# A) Regular histogram\nggplot(data = linelist, aes(x = age))+  # provide x variable\n  geom_histogram()+\n  labs(title = \"A) Default histogram (30 bins)\")\n\n# B) More bins\nggplot(data = linelist, aes(x = age))+  # provide x variable\n  geom_histogram(bins = 50)+\n  labs(title = \"B) Set to 50 bins\")\n\n# C) Fewer bins\nggplot(data = linelist, aes(x = age))+  # provide x variable\n  geom_histogram(bins = 5)+\n  labs(title = \"C) Set to 5 bins\")\n\n\n# D) More bins\nggplot(data = linelist, aes(x = age))+  # provide x variable\n  geom_histogram(binwidth = 1)+\n  labs(title = \"D) binwidth of 1\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nĐể vẽ đường mật độ phân bố, bạn có thể sử dụng hàm geom_density():\n\n# Frequency with proportion axis, smoothed\nggplot(data = linelist, mapping = aes(x = age)) +\n  geom_density(size = 2, alpha = 0.2)+\n  labs(title = \"Proportional density\")\n\n# Stacked frequency with proportion axis, smoothed\nggplot(data = linelist, mapping = aes(x = age, fill = gender)) +\n  geom_density(size = 2, alpha = 0.2, position = \"stack\")+\n  labs(title = \"'Stacked' proportional densities\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nĐể vẽ một biểu đồ histogram “chồng” (của một biến liên tục trong dữ liệu),bạn có thể làm như sau:\n\nDùng hàm geom_histogram() với đối số fill = bên trong aes() và gán tới cột được dùng để nhóm, hoặc\n\nDùng hàm geom_freqpoly(), có thể sẽ dễ đọc hơn (bạn vẫn có thể đặt binwidth =)\n\nĐể xem tỷ lệ của tất cả các giá trị, hãy thiết lập y = after_stat(density) (sử dụng chính xác cú pháp này - không thay đổi đối với dữ liệu của bạn). Lưu ý: các tỷ lệ này sẽ hiển thị theo từng nhóm.\n\nCác kết quả được trình bày bên dưới (*lưu ý cách sử dụng của color = và. fill =):\n\n# \"Stacked\" histogram\nggplot(data = linelist, mapping = aes(x = age, fill = gender)) +\n  geom_histogram(binwidth = 2)+\n  labs(title = \"'Stacked' histogram\")\n\n# Frequency \nggplot(data = linelist, mapping = aes(x = age, color = gender)) +\n  geom_freqpoly(binwidth = 2, size = 2)+\n  labs(title = \"Freqpoly\")\n\n# Frequency with proportion axis\nggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), color = gender)) +\n  geom_freqpoly(binwidth = 5, size = 2)+\n  labs(title = \"Proportional freqpoly\")\n\n# Frequency with proportion axis, smoothed\nggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), fill = gender)) +\n  geom_density(size = 2, alpha = 0.2)+\n  labs(title = \"Proportional, smoothed with geom_density()\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNếu bạn muốn nghịch vui một chút, hãy thử hàm geom_density_ridges từ package ggridges (vignette tại đây.\nĐọc thêm về histograms tại tài liệu về tidyverse chương về geom_histogram().\n\n\nBox plots\nBox plots rất phổ biến, nhưng có những hạn chế quan trọng. Chúng có thể che khuất phân phối thực tế - vd: phân phối hai mode (bimodal distribution). Xem trang R graph gallery và trang data-to-viz article để biết thêm chi tiết. Tuy nhiên, chúng hiển thị tốt các khoảng tứ phân vị và các giá trị ngoại lai - vì vậy chúng có thể được phủ lên trên các loại biểu đồ khác thể hiện sự phân bố chi tiết hơn.\nDưới đây, chúng ta ôn lại về các thành phần khác nhau của boxplot:\n\n\n\n\n\n\n\n\n\nKhi sử dụng geom_boxplot() để tạo biểu đồ box plot, bạn thường chỉ map duy nhất một trục (x hoặc y) bên trong aes(). Trục được chỉ định sẽ xác định xem các ô nằm ngang hay dọc.\nTrong hầu hết các geoms, bạn tạo ra một biểu đồ theo từng nhóm bằng cách mapping các thuộc tính biểu đồ như color = hoặc fill = tới cột bên trong aes(). Tuy nhiên, biểu đồ box plots làm điều này bằng cách gán cột phân nhóm cho trục chưa được gán (x hoặc y). Dưới đây là code cho một boxplot của tất cả các giá trị tuổi trong bộ dữ liệu, và code còn lại là để hiển thị từng box plot cho từng nhóm giới tính (không-missing) trong dữ liệu. Lưu ý là giá trị missing NA sẽ xuất hiện dưới dạng một box plot riêng rẽ trừ khi nó được loại bỏ. Ở ví dụ này chúng tôi cũng thiết lập fill tới cột outcome, do đó mà mỗi biểu đồ sẽ có màu khác nhau- nhưng điều này không quan trọng.\n\n# A) Overall boxplot\nggplot(data = linelist)+  \n  geom_boxplot(mapping = aes(y = age))+   # only y axis mapped (not x)\n  labs(title = \"A) Overall boxplot\")\n\n# B) Box plot by group\nggplot(data = linelist, mapping = aes(y = age, x = gender, fill = gender)) + \n  geom_boxplot()+                     \n  theme(legend.position = \"none\")+   # remove legend (redundant)\n  labs(title = \"B) Boxplot by gender\")      \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode để thêm một box plot vào các cạnh của biểu đồ phân tán (còn gọi là “marginal” plots), vui lòng xem chương Các mẹo với ggplot .\n\n\nViolin, jitter, và sina plots\nDưới đây là code để tạo violin plots (geom_violin) và jitter plots (geom_jitter) để hiển thị phân bố của biến. Bạn có thể chỉ định các màu sắc được xác định từ dữ liệu bằng cách chèn các tùy chọn này vào bên trong aes().\n\n# A) Jitter plot by group\nggplot(data = linelist %&gt;% drop_na(outcome),      # remove missing values\n       mapping = aes(y = age,                     # Continuous variable\n           x = outcome,                           # Grouping variable\n           color = outcome))+                     # Color variable\n  geom_jitter()+                                  # Create the violin plot\n  labs(title = \"A) jitter plot by gender\")     \n\n\n\n# B) Violin plot by group\nggplot(data = linelist %&gt;% drop_na(outcome),       # remove missing values\n       mapping = aes(y = age,                      # Continuous variable\n           x = outcome,                            # Grouping variable\n           fill = outcome))+                       # fill variable (color)\n  geom_violin()+                                   # create the violin plot\n  labs(title = \"B) violin plot by gender\")    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBạn cũng có thể kết hợp hai biểu đồ này làm một nhờ hàm geom_sina() từ package ggforce. Biểu đồ sina vẽ các điểm phân bố trên hình dạng của biểu đồ violin. Khi được phủ lên biểu đồ violin (bằng cách điều chỉnh độ trong suốt), nó giúp việc diễn giải một cách trực quan hơn.\n\n# A) Sina plot by group\nggplot(\n  data = linelist %&gt;% drop_na(outcome), \n  aes(y = age,           # numeric variable\n      x = outcome)) +    # group variable\n  geom_violin(\n    aes(fill = outcome), # fill (color of violin background)\n    color = \"white\",     # white outline\n    alpha = 0.2)+        # transparency\n  geom_sina(\n    size=1,                # Change the size of the jitter\n    aes(color = outcome))+ # color (color of dots)\n  scale_fill_manual(       # Define fill for violin background by death/recover\n    values = c(\"Death\" = \"#bf5300\", \n              \"Recover\" = \"#11118c\")) + \n  scale_color_manual(      # Define colours for points by death/recover\n    values = c(\"Death\" = \"#bf5300\", \n              \"Recover\" = \"#11118c\")) + \n  theme_minimal() +                                # Remove the gray background\n  theme(legend.position = \"none\") +                # Remove unnecessary legend\n  labs(title = \"B) violin and sina plot by gender, with extra formatting\")      \n\n\n\n\n\n\n\n\n\n\nHai biến liên tục\nTheo cú pháp tương tự, geom_point() sẽ cho phép bạn vẽ biểu đồ hai biến liên tục dưới dạng một biểu đồ phân tán. Điều này hữu ích để hiển thị các giá trị thực tế hơn là phân phối của chúng. Một biểu đồ phân tán cơ bản của tuổi so với cân nặng được trình bày ở hình (A). Ở hình (B), chúng ta lại sử dụng facet_grid() để hiển thị mối quan hệ giữa hai biến liên tục trong bộ dữ liệu linelist.\n\n# Basic scatter plot of weight and age\nggplot(data = linelist, \n       mapping = aes(y = wt_kg, x = age))+\n  geom_point() +\n  labs(title = \"A) Scatter plot of weight and age\")\n\n# Scatter plot of weight and age by gender and Ebola outcome\nggplot(data = linelist %&gt;% drop_na(gender, outcome), # filter retains non-missing gender/outcome\n       mapping = aes(y = wt_kg, x = age))+\n  geom_point() +\n  labs(title = \"B) Scatter plot of weight and age faceted by gender and outcome\")+\n  facet_grid(gender ~ outcome) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBa biến liên tục\nBạn có thể hiển thị ba biến liên tục bằng cách sử dụng đối số fill = để tạo một biểu đồ nhiệt. Màu của mỗi “ô” sẽ phản ánh giá trị của biên liên tục thứ ba trong bộ dữ liệu. Xem chương Các mẹo với ggplot và chương Biều đồ nhiệt để biết thêm chi tiết và một số ví dụ.\nCó nhiều cách để tạo biểu đồ 3D trong R, nhưng đối với dịch tễ học ứng dụng, chúng thường khó giải thích và do đó ít hữu ích hơn trong việc ra quyết định.",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.vn.html#vẽ-biểu-đồ-cho-biến-danh-mục",
    "href": "new_pages/ggplot_basics.vn.html#vẽ-biểu-đồ-cho-biến-danh-mục",
    "title": "30  ggplot cơ bản",
    "section": "30.13 Vẽ biểu đồ cho biến danh mục",
    "text": "30.13 Vẽ biểu đồ cho biến danh mục\nDữ liệu dạng danh mục có thể là các giá trị ký tự, có thể là logic (TRUE/FALSE), hoặc factors (Xem chương Factors).\n\nChuẩn bị\n\nCấu trúc dữ liệu\nĐiều đầu tiên cần hiểu về dữ liệu dạng danh mục đó là kiểm tra xem nó đang tồn tại ở dạng dữ liệu thô như các trường hợp trong bộ dữ liệu linelist, hay dưới dạng dữ liệu tóm tắt hoặc tổng hợp chứa các số lượng hoặc tỷ lệ. Trạng thái dữ liệu của bạn sẽ quyết định hàm vẽ biểu đồ nào được sử dụng:\n\nNếu dữ liệu của bạn là các quan sát thô với một hàng cho mỗi quan sát, bạn có thể sử dụng hàm geom_bar()\n\nNếu dữ liệu của bạn đã được tổng hợp thành số lượng hoặc tỷ lệ, bạn có thể sử dụng hàm geom_col()\n\n\n\nKiểu của cột và thứ tự các giá trị\nSau đó, kiểm tra kiểu dữ liệu của cột mà bạn muốn vẽ. Chúng ta xem xét cột hospital, đầu tiên bằng hàm class() từ base R, sau đó là với hàm tabyl() từ package janitor.\n\n# View class of hospital column - we can see it is a character\nclass(linelist$hospital)\n\n[1] \"character\"\n\n# Look at values and proportions within hospital column\nlinelist %&gt;% \n  tabyl(hospital)\n\n                             hospital    n    percent\n                     Central Hospital  454 0.07710598\n                    Military Hospital  896 0.15217391\n                              Missing 1469 0.24949049\n                                Other  885 0.15030571\n                        Port Hospital 1762 0.29925272\n St. Mark's Maternity Hospital (SMMH)  422 0.07167120\n\n\nChúng ta có thể thấy các giá trị bên trong là các ký tự, vì chúng là tên bệnh viện và theo mặc định, chúng được sắp xếp theo thứ tự bảng chữ cái. Ngoài ra còn có các giá trị ‘other’ và ‘missing’, thứ mà chúng ta muốn nó sẽ là danh mục cuối cùng khi trình bày. Vì thế chúng ta cần chuyển cột này sang dạng factor và sắp xếp lại chúng. Xem chương Factors để biết chi tiết cách thực hiện.\n\n# Convert to factor and define level order so \"Other\" and \"Missing\" are last\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    hospital = fct_relevel(hospital, \n      \"St. Mark's Maternity Hospital (SMMH)\",\n      \"Port Hospital\", \n      \"Central Hospital\",\n      \"Military Hospital\",\n      \"Other\",\n      \"Missing\"))\n\n\nlevels(linelist$hospital)\n\n[1] \"St. Mark's Maternity Hospital (SMMH)\"\n[2] \"Port Hospital\"                       \n[3] \"Central Hospital\"                    \n[4] \"Military Hospital\"                   \n[5] \"Other\"                               \n[6] \"Missing\"                             \n\n\n\n\n\ngeom_bar()\nSử dụng geom_bar() nếu bạn muốn chiều cao cột (hoặc chiều cao của các cột trong biểu đồ cột chồng) phản ánh số lượng hàng có liên quan trong dữ liệu. Các thanh này sẽ có khoảng trống giữa chúng, trừ khi width = được điều chỉnh.\n\nChỉ cung cấp phép gán cột trên một trục (thường là trục x). Nếu bạn cung cấp cả trục x và y, bạn sẽ nhận được thông báo Error: stat_count() can only have an x or y aesthetic.\n\nBạn có thể tạo biểu đồ cột chồng bằng cách thêm fill = cột được chỉ định bên trong mapping = aes()\n\nTrục đối diện sẽ có tiêu đề là “số lượng” theo mặc định, bởi vì nó đại diện cho số hàng\n\nDưới đây, chúng ta đã chỉ định cột outcome tới trục y, nhưng nó cũng có thể dễ dàng thực hiện trên trục x. Nếu bạn có các giá trị ký tự dài hơn, đôi khi sẽ dễ nhìn hơn nếu bạn lật các thanh sang một bên và đặt chú giải ở dưới cùng. Điều này có thể ảnh hưởng đến cách sắp xếp các thứ bậc trong biến factor - trong trường hợp này, chúng tôi đảo ngược chúng với hàm fct_rev() để đặt giá trị missing và other ở dưới cùng.\n\n# A) Outcomes in all cases\nggplot(linelist %&gt;% drop_na(outcome)) + \n  geom_bar(aes(y = fct_rev(hospital)), width = 0.7) +\n  theme_minimal()+\n  labs(title = \"A) Number of cases by hospital\",\n       y = \"Hospital\")\n\n\n# B) Outcomes in all cases by hosptial\nggplot(linelist %&gt;% drop_na(outcome)) + \n  geom_bar(aes(y = fct_rev(hospital), fill = outcome), width = 0.7) +\n  theme_minimal()+\n  theme(legend.position = \"bottom\") +\n  labs(title = \"B) Number of recovered and dead Ebola cases, by hospital\",\n       y = \"Hospital\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngeom_col()\nSử dụng geom_col() nếu bạn muốn chiều cao cột (hoặc chiều cao của các cột trong biểu đồ cột chồng) các giá trị được tính toán trước tồn tại trong dữ liệu. Thông thường, đây là các số lượng hoặc tỷ lệ đã được tóm tắt hoặc “tổng hợp”.\nCung cấp phép gán cột cho cả hai trục tới hàm geom_col(). Thông thường, cột trục x của bạn là biến rời rạc và cột trục y của bạn là biến dạng số.\nGiả sử chúng ta có một bộ dữ liệu có tên outcomes:\n\n\n# A tibble: 2 × 3\n  outcome     n proportion\n  &lt;chr&gt;   &lt;int&gt;      &lt;dbl&gt;\n1 Death    1022       56.2\n2 Recover   796       43.8\n\n\nDưới đây là code sử dụng hàm geom_col để tạo biểu đồ cột đơn giản trình bày phân bố các outcome của bệnh nhân Ebola. Với geom_col, cả x và y đều cần được chỉ định. Ở đây x là biến phân loại dọc theo trục x và y là cột chứa tỷ lệ proportion.\n\n# Outcomes in all cases\nggplot(outcomes) + \n  geom_col(aes(x=outcome, y = proportion)) +\n  labs(subtitle = \"Number of recovered and dead Ebola cases\")\n\n\n\n\n\n\n\n\nĐể trình bày kết quả tách theo từng bệnh viện, chúng ta cần bảng phải chứa nhiều thông tin hơn, và ở định dạng “dài”. Chúng ta tạo bảng này với các tần số là sự kết hợp của các danh mục của biến outcome và hospital (xem chương Nhóm dữ liệu để biết thêm các mẹo).\n\noutcomes2 &lt;- linelist %&gt;% \n  drop_na(outcome) %&gt;% \n  count(hospital, outcome) %&gt;%  # get counts by hospital and outcome\n  group_by(hospital) %&gt;%        # Group so proportions are out of hospital total\n  mutate(proportion = n/sum(n)*100) # calculate proportions of hospital total\n\nhead(outcomes2) # Preview data\n\n# A tibble: 6 × 4\n# Groups:   hospital [3]\n  hospital                             outcome     n proportion\n  &lt;fct&gt;                                &lt;chr&gt;   &lt;int&gt;      &lt;dbl&gt;\n1 St. Mark's Maternity Hospital (SMMH) Death     199       61.2\n2 St. Mark's Maternity Hospital (SMMH) Recover   126       38.8\n3 Port Hospital                        Death     785       57.6\n4 Port Hospital                        Recover   579       42.4\n5 Central Hospital                     Death     193       53.9\n6 Central Hospital                     Recover   165       46.1\n\n\nSau đó, chúng ta vẽ biểu đồ ggplot với một số định dạng được bổ sung:\n\nLật trục: Hoán đổi vị trị trục với coord_flip() để chúng ta có thể đọc tên các bệnh viện.\nColumns side-by-side: Added a position = \"dodge\" argument so that the bars for death and recover are presented side by side rather than stacked. Lưu ý mặc định là các cột xếp chồng lên nhau.\nĐộ rộng cột: Chỉ định ‘chiều rộng’, do đó các cột mỏng bằng một nửa chiều rộng đầy đủ có thể.\nThứ tự cột: Đảo lại các danh mục trên trục y để ‘Other’ và ‘Missing’ ở dưới cùng, với hàm scale_x_discrete(limits=rev). Lưu ý rằng chúng ta sử dụng cách này thay vì scale_y_discrete bởi vì hospital được nhắc tới trong đối số x của aes(), ngay cả khi một cách trực quan nó nằm trên trục y. Chúng ta làm vậy bởi vì ggplot dường như trình bày các danh mục từ sau lên trước trừ khi chúng ta yêu cầu nó không làm vậy.\n\nCác chi tiết khác: Nhãn/tiêu đề và màu sắc được thêm tương ứng vào bên trong lệnh labs và scale_fill_color.\n\n\n# Outcomes in all cases by hospital\nggplot(outcomes2) +  \n  geom_col(\n    mapping = aes(\n      x = proportion,                 # show pre-calculated proportion values\n      y = fct_rev(hospital),          # reverse level order so missing/other at bottom\n      fill = outcome),                # stacked by outcome\n    width = 0.5)+                    # thinner bars (out of 1)\n  theme_minimal() +                  # Minimal theme \n  theme(legend.position = \"bottom\")+\n  labs(subtitle = \"Number of recovered and dead Ebola cases, by hospital\",\n       fill = \"Outcome\",             # legend title\n       y = \"Count\",                  # y axis title\n       x = \"Hospital of admission\")+ # x axis title\n  scale_fill_manual(                 # adding colors manually\n    values = c(\"Death\"= \"#3B1c8C\",\n               \"Recover\" = \"#21908D\" )) \n\n\n\n\n\n\n\n\nLưu ý rằng tỷ lệ là nhị phân, do đó chúng ta có thể loại bỏ các giá trị ‘recover’ và chỉ hiện thị tỷ lệ những người tử vong. Việc này chỉ nhằm cho mục đích minh họa.\nNếu sử dụng geom_col() cho dữ liệu ngày tháng (vd: đường cong dịch bệnh từ dữ liệu tổng hợp) - bạn sẽ muốn điều chỉnh đối số width = để loại bỏ “khoảng trống” giữa các cột. nếu sử dụng số liệu cập nhật hàng ngày, hãy thiết lập width = 1. Nếu là hàng tuần, width = 7. Không thể thiết lập cho tháng vì mỗi tháng có số ngày khác nhau.\n\n\ngeom_histogram()\nHistograms có thể trông giống biểu đồ cột, nhưng khác biệt vì nó đo lường sự phân bố của một biến liên tục. Không có khoảng cách giữa các “cột”, và chỉ có một cột được cung cấp cho hàm geom_histogram(). Có các đối số cụ thể cho biểu đồ chẳng hạn như bin_width = và breaks = ể chỉ định cách dữ liệu nên được xếp. Phần bên trên về dữ liệu liên tục và chương Đường cong dịch bệnh sẽ cung cấp thêm các hi tiết.",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.vn.html#tài-nguyên-học-liệu",
    "href": "new_pages/ggplot_basics.vn.html#tài-nguyên-học-liệu",
    "title": "30  ggplot cơ bản",
    "section": "30.14 Tài nguyên học liệu",
    "text": "30.14 Tài nguyên học liệu\nCó rất nhiều trợ giúp trực tuyến, đặc biệt là với ggplot. Xem:\n\nggplot2 cheat sheet\nanother cheat sheet\ntidyverse ggplot basics page\n\nplotting continuous variables\n\nR for Data Science trang về data visualization\ngraphics for communicaton",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>ggplot cơ bản</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.vn.html",
    "href": "new_pages/ggplot_tips.vn.html",
    "title": "31  Các mẹo với ggplot",
    "section": "",
    "text": "31.1 Chuẩn bị",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Các mẹo với ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.vn.html#chuẩn-bị",
    "href": "new_pages/ggplot_tips.vn.html#chuẩn-bị",
    "title": "31  Các mẹo với ggplot",
    "section": "",
    "text": "Gọi packages\nĐoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R.\n\npacman::p_load(\n  tidyverse,      # includes ggplot2 and other\n  rio,            # import/export\n  here,           # file locator\n  stringr,        # working with characters   \n  scales,         # transform numbers\n  ggrepel,        # smartly-placed labels\n  gghighlight,    # highlight one part of plot\n  RColorBrewer    # color scales\n)\n\n\n\nNhập dữ liệu\nĐể bắt đầu, chúng ta nhập bộ dữ liệu có tên linelist đã làm sạch bao gồm các trường hợp từ vụ dịch Ebola mô phỏng. Để tiện theo dõi, bấm để tải dữ liệu linelist “đã được làm sạch”  (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương Nhập xuất dữ liệu để biết thêm chi tiết.\n\nlinelist &lt;- rio::import(\"linelist_cleaned.rds\")\n\n50 hàng đầu tiên của bộ dữ liệu được hiển thị như bên dưới.",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Các mẹo với ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.vn.html#ggplot_tips_colors",
    "href": "new_pages/ggplot_tips.vn.html#ggplot_tips_colors",
    "title": "31  Các mẹo với ggplot",
    "section": "31.2 Cân chỉnh lại màu sắc, trục, v.v.",
    "text": "31.2 Cân chỉnh lại màu sắc, trục, v.v.\nTrong ggplot2, khi các thuộc tính (vd: kích thước, màu sắc, hình dạng, tô màu, trục biểu đồ) được gắn với các cột trong bộ dữ liệu, thì chúng có thể được cân chỉnh lại với lệnh “scale” tương ứng. Trong phần này, chúng tôi sẽ giới một số các cân chỉnh thuộc tính biểu đồ phổ biến.\n\n31.2.1 Phối màu\nMột điều ban đầu có thể khó hiểu khi dùng ggplot2 là kiểm soát các phối màu. Lưu ý rằng phần này thảo luận về màu sắc của các đối tượng biểu đồ (geoms/shapes) ví dụ như điểm, cột, đường, ô, v.v. Để điều chỉnh màu của các văn bản, tiêu đề hoặc màu nền, hãy xem phần Chủ đề trong chương ggplot cơ bản.\nĐể kiểm soát “màu sắc” của các đối tượng biểu đồ, bạn sẽ điều chỉnh hoặc là color = (màu bên ngoài) hoặc fill = (màu bên trong). Một ngoại lệ đó là với biểu đồ điểm geom_point(), khi bạn thực sự chỉ có thể điều chỉnh color =, để xác định màu của điểm (bên trong và bên ngoài).\nKhi thiết lập màu bên trong hoặc bên ngoài, bạn có thể sử dụng các tên màu phổ thông được R nhận dạng như \"red\" (xem danh sách đầy đủ hoặc gõ ?colors), hoặc chỉ rõ một mã màu hex như \"#ff0505\".\n\n# histogram - \nggplot(data = linelist, mapping = aes(x = age))+       # set data and axes\n  geom_histogram(              # display histogram\n    binwidth = 7,                # width of bins\n    color = \"red\",               # bin line color\n    fill = \"lightblue\")          # bin interior color (fill) \n\n\n\n\n\n\n\n\nNhư đã được giải thích trong chương ggplot cơ bản phần gán dữ liệu cho biểu đồ, các thuộc tính như fill = và color = có thể được định nghĩa ở bên ngoài của biểu thức mapping = aes() hoặc bên trong hàm. Nếu đặt bên ngoài hàm aes(), giá trị được gán nên là giá trị tĩnh (vd: color = \"blue\") và sẽ áp dụng cho toàn bộ dữ liệu được vẽ. Nếu đặt bên trong, các thuộc tính cần được gán với các cột tương ứng trên biển đồ, ví dụ như color = hospital, và sự hiển thị sẽ thay đổi theo giá trị của dữ liệu. Sau đây là một vài ví dụ:\n\n# Static color for points and for line\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     \n  geom_point(color = \"purple\")+\n  geom_vline(xintercept = 50, color = \"orange\")+\n  labs(title = \"Static color for points and line\")\n\n# Color mapped to continuous column\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     \n  geom_point(mapping = aes(color = temp))+         \n  labs(title = \"Color mapped to continuous column\")\n\n# Color mapped to discrete column\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     \n  geom_point(mapping = aes(color = gender))+         \n  labs(title = \"Color mapped to discrete column\")\n\n# bar plot, fill to discrete column, color to static value\nggplot(data = linelist, mapping = aes(x = hospital))+     \n  geom_bar(mapping = aes(fill = gender), color = \"yellow\")+         \n  labs(title = \"Fill mapped to discrete column, static color\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCân chỉnh biểu đồ\nMột khi bạn gán cột tới một trong các thuộc tính của biểu đồ của biểu đồ (vd: x =, y =, fill =, color =…), biểu đồ của bạn sẽ hiển thị thêm một chú giải. Xem ở trên để biết các cân chỉnh có thể thực hiện trên các giá trị liên tục, rời rạc, ngày tháng, v.v. tùy thuộc vào kiểu dữ liệu của cột được chỉ định. Nếu bạn có nhiều thuộc tính biểu đồ được gán tới cột, biểu đồ của bạn sẽ có nhiều thang đo.\nBạn có thể kiểm soát các thang đo bằng hàm scales_() thích hợp. Các hàm scale của ggplot() có 3 phần được viết như sau: scale_AESTHETIC_METHOD().\n\nPhần đầu tiên, scale_(), là cố định.\n\nPhần thứ hai, AESTHETIC, là tên thuộc tính biểu đồ bạn muốn điều chỉnh thang đó (_fill_, _shape_, _color_, _size_, _alpha_…) - các tùy chọn ở đây cũng bao gồm _x_ và _y_.\n\nPhần thứ ba, METHOD, sẽ là một trong số các tùy chọn sau _discrete(), continuous(), _date(), _gradient(), hoặc _manual(), tùy thuộc vào kiểu dữ liệu của cột và cách bạn muốn kiểm soát nó. Có những tùy chọn khác, tuy nhiên những lựa chọn trên thường được sử dụng nhất.\n\nHãy chắc chắn rằng bạn sử dụng đúng hàm scale! Nếu không, lệnh scale của bạn sẽ không xuất hiện để thay đổi bất cứ điều gì. Nếu bạn có nhiều thang đo, bạn có thể sử dụng nhiều hàm scale để điều chỉnh chúng! Ví dụ:\n\n\nCác đối số của hàm Scale\nMỗi loại thang đo có những đối số riêng của chúng, mặc dù cũng có những sự trùng nhau. Hãy tìm đọc tài liệu về hàm bằng cách gõ ?scale_color_discrete trong cửa sổ R console để hiểu thêm về các đối số của hàm.\nVới thang đo liên tục, sử dụng breaks = để cung cấp một chuỗi giá trị tới seq() (đặt to =, from =, và by = như được minh họa trong ví dụ bên dưới. Thiết lập expand = c(0,0) để loại bỏ không gian đệm xung quanh các trục (điều này có thể được sử dụng trên bất kỳ thang đo của trục _x_ hoặc _y_ nào)\nVới thang đo rời rạc, bạn có thể điều chỉnh thứ tự của các giá trị với breaks =, và cách các giá trị hiển thị với đối số labels =. Cung cấp một vectơ ký tự cho mỗi cái đó (xem ví dụ bên dưới). Bạn cũng có thể loại bỏ NA dễ dàng bằng cách đặt na.translate = FALSE.\nCác điều chỉnh với thang đo ngày tháng được trình bãy rõ hơn trong chương Đường cong dịch bệnh.\n\n\nĐiều chỉnh thủ công\nMột trong những thủ thuật hữu ích nhất là sử dụng các hàm scaling “một cách thủ công” để gán màu sắc như bạn mong muốn. Có những hàm với cú pháp scale_xxx_manual() (vd: scale_colour_manual() hoặc scale_fill_manual()). Mỗi đối số dưới đây được minh họa trong các code ví dụ bên dưới.\n\nGán màu cho các giá trị dữ liệu với đối số values =\n\nCụ thể màu sắc cho giá trị NA với na.value =\n\nThay đổi cách các giá trị được viết trong chú giải với đối số labels =\nThay đổi tiêu đề chú giải bằng name =\n\nDưới đây, chúng ta tạo một biểu đồ cột và hiển thị cách nó xuất hiện theo mặc định, sau đó với ba thang đo được điều chỉnh - thang đo trục y liên tục, thang đo trục x rời rạc, và điều chỉnh thủ công cách tô màu (màu bên trong cột).\n\n# BASELINE - no scale adjustment\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = outcome, fill = gender))+\n  labs(title = \"Baseline - no scale adjustments\")\n\n\n\n\n\n\n\n# SCALES ADJUSTED\nggplot(data = linelist)+\n  \n  geom_bar(mapping = aes(x = outcome, fill = gender), color = \"black\")+\n  \n  theme_minimal()+                   # simplify background\n  \n  scale_y_continuous(                # continuous scale for y-axis (counts)\n    expand = c(0,0),                 # no padding\n    breaks = seq(from = 0,\n                 to = 3000,\n                 by = 500))+\n  \n  scale_x_discrete(                   # discrete scale for x-axis (gender)\n    expand = c(0,0),                  # no padding\n    drop = FALSE,                     # show all factor levels (even if not in data)\n    na.translate = FALSE,             # remove NA outcomes from plot\n    labels = c(\"Died\", \"Recovered\"))+ # Change display of values\n    \n  \n  scale_fill_manual(                  # Manually specify fill (bar interior color)\n    values = c(\"m\" = \"violetred\",     # reference values in data to assign colors\n               \"f\" = \"aquamarine\"),\n    labels = c(\"m\" = \"Male\",          # re-label the legend (use \"=\" assignment to avoid mistakes)\n              \"f\" = \"Female\",\n              \"Missing\"),\n    name = \"Gender\",                  # title of legend\n    na.value = \"grey\"                 # assign a color for missing values\n  )+\n  labs(title = \"Adjustment of scales\") # Adjust the title of the fill legend\n\n\n\n\n\n\n\n\n\n\nThang đo liên tục trên trục\nKhi dữ liệu được ánh xạ tới các trục của biểu đồ, chúng cũng có thể được điều chỉnh bằng các lệnh scales. Một ví dụ phổ biến là điều chỉnh hiển thị của một trục (ví dụ: trục y) được ánh xạ tới một cột có dữ liệu liên tục.\nChúng ta có thể muốn điều chỉnh độ chia hoặc hiển thị của giá trị trong ggplot bằng cách sử dụng scale_y_continuous(). Như đã lưu ý ở trên, sử dụng đối số breaks = để cung cấp một chuỗi các giá trị sẽ đóng vai trò là “ngắt các khoảng giá trị” dọc theo thang đo. Đây là những giá trị mà các số sẽ hiển thị. Đối với đối số này, bạn có thể cung cấp một vectơ c() chứa các giá trị để chia thang đo theo mong muốn hoặc bạn có thể cung cấp một chuỗi số thông thường bằng cách sử dụng hàm seq() từ base R. Hàm seq() này chấp nhận to =, from =, và by =.\n\n# BASELINE - no scale adjustment\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = outcome, fill = gender))+\n  labs(title = \"Baseline - no scale adjustments\")\n\n# \nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = outcome, fill = gender))+\n  scale_y_continuous(\n    breaks = seq(\n      from = 0,\n      to = 3000,\n      by = 100)\n  )+\n  labs(title = \"Adjusted y-axis breaks\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHiển thị phần trăm\nNếu giá trị dữ liệu ban đầu của bạn là tỷ lệ, bạn có thể dễ dàng hiển thị chúng dưới dạng phần trăm với “%” bằng cách cung cấp labels = scales::percent trong lệnh scales command, như được trình bày dưới đây.\nMặc dù có một giải pháp thay thế là chuyển đổi các giá trị thành ký tự và thêm ký tự “%” vào cuối, cách tiếp cận này sẽ gây ra phức tạp vì dữ liệu của bạn sẽ không còn là các giá trị số liên tục.\n\n# Original y-axis proportions\n#############################\nlinelist %&gt;%                                   # start with linelist\n  group_by(hospital) %&gt;%                       # group data by hospital\n  summarise(                                   # create summary columns\n    n = n(),                                     # total number of rows in group\n    deaths = sum(outcome == \"Death\", na.rm=T),   # number of deaths in group\n    prop_death = deaths/n) %&gt;%                   # proportion deaths in group\n  ggplot(                                      # begin plotting\n    mapping = aes(\n      x = hospital,\n      y = prop_death))+ \n  geom_col()+\n  theme_minimal()+\n  labs(title = \"Display y-axis original proportions\")\n\n\n\n# Display y-axis proportions as percents\n########################################\nlinelist %&gt;%         \n  group_by(hospital) %&gt;% \n  summarise(\n    n = n(),\n    deaths = sum(outcome == \"Death\", na.rm=T),\n    prop_death = deaths/n) %&gt;% \n  ggplot(\n    mapping = aes(\n      x = hospital,\n      y = prop_death))+\n  geom_col()+\n  theme_minimal()+\n  labs(title = \"Display y-axis as percents (%)\")+\n  scale_y_continuous(\n    labels = scales::percent                    # display proportions as percents\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThang đo Log\nĐể biến đổi một trục liên tục sang thang đo log, hãy thêm trans = \"log2\" vào lệnh scale. Ví dụ: chúng ta tạo một data frame của các vùng với các giá trị preparedness_index và số trường hợp tích lũy tương ứng.\n\nplot_data &lt;- data.frame(\n  region = c(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\"),\n  preparedness_index = c(8.8, 7.5, 3.4, 3.6, 2.1, 7.9, 7.0, 5.6, 1.0),\n  cases_cumulative = c(15, 45, 80, 20, 21, 7, 51, 30, 1442)\n)\n\nplot_data\n\n  region preparedness_index cases_cumulative\n1      A                8.8               15\n2      B                7.5               45\n3      C                3.4               80\n4      D                3.6               20\n5      E                2.1               21\n6      F                7.9                7\n7      G                7.0               51\n8      H                5.6               30\n9      I                1.0             1442\n\n\nCác trường hợp tích lũy ở vùng “I” lớn hơn đáng kể so với tất cả các vùng khác. Trong những trường hợp như thế này, bạn có thể chọn hiển thị trục y bằng thang đo log để người đọc có thể thấy sự khác biệt giữa các vùng với ít trường hợp tích lũy hơn.\n\n# Original y-axis\npreparedness_plot &lt;- ggplot(data = plot_data,  \n       mapping = aes(\n         x = preparedness_index,\n         y = cases_cumulative))+\n  geom_point(size = 2)+            # points for each region \n  geom_text(\n    mapping = aes(label = region),\n    vjust = 1.5)+                  # add text labels\n  theme_minimal()\n\npreparedness_plot                  # print original plot\n\n\n# print with y-axis transformed\npreparedness_plot+                   # begin with plot saved above\n  scale_y_continuous(trans = \"log2\") # add transformation for y-axis\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThang đo Gradient\nTô màu thang đo gradient có thể liên quan đến sắc thái bổ sung. Các giá trị mặc định thường khá dễ chịu, nhưng bạn có thể muốn điều chỉnh các giá trị, điểm cắt, v.v.\nĐể trình bày cách điều chỉnh thang màu liên tục, chúng tôi sẽ sử dụng bộ dữ liệu từ chương Truy vết tiếp xúc chứa độ tuổi của các trường hợp và các trường hợp tiếp xúc gốc của chúng.\n\ncase_source_relationships &lt;- rio::import(here::here(\"data\", \"godata\", \"relationships_clean.rds\")) %&gt;% \n  select(source_age, target_age) \n\nDưới đây, chúng ta sẽ tạo ra một “raster” biểu đồ mật độ nhiệt. Chúng ta sẽ không đề cập chi tiết đến cách thức (xem link ở đoạn trên), nhưng chúng ta sẽ tập trung vào cách chúng ta có thể điều chỉnh thang màu. Đọc thêm về hàm stat_density2d() của package ggplot2 tại đây. Lưu ý cách mà thang đo fill là liên tục.\n\ntrans_matrix &lt;- ggplot(\n    data = case_source_relationships,\n    mapping = aes(x = source_age, y = target_age))+\n  stat_density2d(\n    geom = \"raster\",\n    mapping = aes(fill = after_stat(density)),\n    contour = FALSE)+\n  theme_minimal()\n\nBây giờ chúng ta hiển thị một số biến đổi trên fill scale:\n\ntrans_matrix\ntrans_matrix + scale_fill_viridis_c(option = \"plasma\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBây giờ chúng ta sẽ xem xét một số ví dụ về việc thực sự điều chỉnh các điểm ngắt của thang đo:\n\nscale_fill_gradient() chấp nhận hai màu (cao/thấp)\n\nscale_fill_gradientn() chấp nhận một vectơ có độ dài màu bất kỳ tới values = (các giá trị trung gian sẽ được nội suy)\n\nSử dụng scales::rescale() để điều chỉnh cách định vị màu sắc dọc theo gradient; nó sẽ cân chỉnh lại vectơ vị trí của bạn nằm giữa 0 và 1.\n\n\ntrans_matrix + \n  scale_fill_gradient(     # 2-sided gradient scale\n    low = \"aquamarine\",    # low value\n    high = \"purple\",       # high value\n    na.value = \"grey\",     # value for NA\n    name = \"Density\")+     # Legend title\n  labs(title = \"Manually specify high/low colors\")\n\n# 3+ colors to scale\ntrans_matrix + \n  scale_fill_gradientn(    # 3-color scale (low/mid/high)\n    colors = c(\"blue\", \"yellow\",\"red\") # provide colors in vector\n  )+\n  labs(title = \"3-color scale\")\n\n# Use of rescale() to adjust placement of colors along scale\ntrans_matrix + \n  scale_fill_gradientn(    # provide any number of colors\n    colors = c(\"blue\", \"yellow\",\"red\", \"black\"),\n    values = scales::rescale(c(0, 0.05, 0.07, 0.10, 0.15, 0.20, 0.3, 0.5)) # positions for colors are rescaled between 0 and 1\n    )+\n  labs(title = \"Colors not evenly positioned\")\n\n# use of limits to cut-off values that get fill color\ntrans_matrix + \n  scale_fill_gradientn(    \n    colors = c(\"blue\", \"yellow\",\"red\"),\n    limits = c(0, 0.0002))+\n  labs(title = \"Restrict value limits, resulting in grey space\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBảng màu\n\nColorbrewer và Viridis\nNhìn chung, nếu bạn muốn sử dụng các bảng màu có sẵn, bạn có thể sử dụng các hàm scale_xxx_brewer hoặc scale_xxx_viridis_y.\nCàm hàm ‘brewer’ có thể rút ra từ bảng màu colorbrewer.org.\nCác hàm ‘viridis’ lấy từ các bảng màu viridis (thân thiện với người mù màu!), giúp “cung cấp các bản đồ màu sắc đồng nhất về mặt tri giác ở cả hai màu đen và trắng. Chúng cũng được thiết kế để người xem cảm nhận được các dạng mù màu phổ biến.” (đọc thêm tại đây và tại đây). Xác định xem bảng màu là rời rạc, liên tục hay xếp chồng bằng cách cụ thể điều này ở cuối hàm (vd: nếu rời rạc sẽ là scale_xxx_viridis_d).\nBạn nên kiểm tra biểu đồ của mình trong trình mô phỏng mù màu này. Nếu bạn có phối màu đỏ/xanh lá cây, hãy thử phối “nóng-lạnh” (đỏ-xanh lam) như được môt tả ở đây\nSau đây là một ví dụ từ chương ggplot cơ bản, sử dụng các phối màu khác nhau.\n\nsymp_plot &lt;- linelist %&gt;%                                         # begin with linelist\n  select(c(case_id, fever, chills, cough, aches, vomit)) %&gt;%     # select columns\n  pivot_longer(                                                  # pivot longer\n    cols = -case_id,                                  \n    names_to = \"symptom_name\",\n    values_to = \"symptom_is_present\") %&gt;%\n  mutate(                                                        # replace missing values\n    symptom_is_present = replace_na(symptom_is_present, \"unknown\")) %&gt;% \n  ggplot(                                                        # begin ggplot!\n    mapping = aes(x = symptom_name, fill = symptom_is_present))+\n  geom_bar(position = \"fill\", col = \"black\") +                    \n  theme_classic() +\n  theme(legend.position = \"bottom\")+\n  labs(\n    x = \"Symptom\",\n    y = \"Symptom status (proportion)\"\n  )\n\nsymp_plot  # print with default colors\n\n#################################\n# print with manually-specified colors\nsymp_plot +\n  scale_fill_manual(\n    values = c(\"yes\" = \"black\",         # explicitly define colours\n               \"no\" = \"white\",\n               \"unknown\" = \"grey\"),\n    breaks = c(\"yes\", \"no\", \"unknown\"), # order the factors correctly\n    name = \"\"                           # set legend to no title\n\n  ) \n\n#################################\n# print with viridis discrete colors\nsymp_plot +\n  scale_fill_viridis_d(\n    breaks = c(\"yes\", \"no\", \"unknown\"),\n    name = \"\"\n  )",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Các mẹo với ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.vn.html#thay-đổi-thứ-tự-của-biến-rời-rạc",
    "href": "new_pages/ggplot_tips.vn.html#thay-đổi-thứ-tự-của-biến-rời-rạc",
    "title": "31  Các mẹo với ggplot",
    "section": "31.3 Thay đổi thứ tự của biến rời rạc",
    "text": "31.3 Thay đổi thứ tự của biến rời rạc\nViệc thay đổi thứ tự các biến rời rạc thường khó hiểu đối với những người mới làm quen với vẽ biểu đồ bằng ggplot2. Tuy nhiên, thật dễ hiểu cách thực hiện việc này khi bạn hiểu cách ggplot2 xử lý các biến rời rạc. Nói chung, nếu một biến số rời rạc được sử dụng, nó sẽ tự động được chuyển đổi thành một biến dạng factor - theo mặc định sắp xếp các giá trị theo thứ tự bảng chữ cái. Để xử lý điều này, bạn chỉ cần sắp xếp lại các levels của biến factor để phản ánh thứ tự bạn muốn chúng xuất hiện trong biểu đồ. Để biết thêm thông tin chi tiết về cách sắp xếp lại các đối tượng factor, hãy xem chương factor trong cuốn sách này.\nChúng ta có thể xem xét một ví dụ phổ biến bằng cách sử dụng các nhóm tuổi - theo mặc định, nhóm 5-9 tuổi sẽ được đặt ở giữa các nhóm tuổi (thứ tự chữ và số đã cho), nhưng chúng ta có thể di chuyển nó phía sau nhóm tuổi 0-4 của biểu đồ bằng cách sắp xếp lại thứ bậc của biến factor này.\n\nggplot(\n  data = linelist %&gt;% drop_na(age_cat5),                         # remove rows where age_cat5 is missing\n  mapping = aes(x = fct_relevel(age_cat5, \"5-9\", after = 1))) +  # relevel factor\n\n  geom_bar() +\n  \n  labs(x = \"Age group\", y = \"Number of hospitalisations\",\n       title = \"Total hospitalisations by age group\") +\n  \n  theme_minimal()\n\n\n\n\n\n\n\n\n\n31.3.0.1 ggthemr\nBạn cũng có thể xem xét sử dụng package ggthemr. Bạn có thể tải xuống package này từ Github theo hướng dẫn này. Nó cung cấp các bảng màu rất đẹp về mặt thẩm mỹ, nhưng hãy lưu ý rằng chúng thường có số lượng giá trị tối đa có thể bị giới hạn nếu bạn muốn nhiều hơn 7 hoặc 8 màu.",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Các mẹo với ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.vn.html#đường-đồng-mức",
    "href": "new_pages/ggplot_tips.vn.html#đường-đồng-mức",
    "title": "31  Các mẹo với ggplot",
    "section": "31.4 Đường đồng mức",
    "text": "31.4 Đường đồng mức\nContour plots rất hữu ích khi bạn có nhiều điểm cần biểu diễn có thể che lấp nhau (“overplotting”). Dữ liệu case-source bên trên một lần nữa được dùng để vẽ, nhưng đơn giản hơn bằng cách sử dụng hàm stat_density2d() và stat_density2d_filled() để tạo ra các mức đường đồng mức rời rạc - giống như một bản đồ địa hình. Đọc thêm về các số liệu thống kê ở đây.\n\ncase_source_relationships %&gt;% \n  ggplot(aes(x = source_age, y = target_age))+\n  stat_density2d()+\n  geom_point()+\n  theme_minimal()+\n  labs(title = \"stat_density2d() + geom_point()\")\n\n\ncase_source_relationships %&gt;% \n  ggplot(aes(x = source_age, y = target_age))+\n  stat_density2d_filled()+\n  theme_minimal()+\n  labs(title = \"stat_density2d_filled()\")",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Các mẹo với ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.vn.html#phân-phối-biên",
    "href": "new_pages/ggplot_tips.vn.html#phân-phối-biên",
    "title": "31  Các mẹo với ggplot",
    "section": "31.5 Phân phối biên",
    "text": "31.5 Phân phối biên\nĐể hiển thị các phân phối trên các cạnh của biểu đồ tán xạ với hàm geom_point(), bạn có thể sử dụng package ggExtra với hàm ggMarginal(). Lưu biểu đồ ggplot nguyên gốc của bạn dưới dạng một đối tượng, sau đó chuyển nó tới hàm ggMarginal() như được trình bày dưới đây. Sau đây là những đối số chính:\n\nBạn phải cụ thể kiểu type = theo một số lựa chọn sau: “histogram”, “density” “boxplot”, “violin”, hoặc “densigram”.\n\nTheo mặc định, các đồ thị biên sẽ xuất hiện ở cả hai trục. Bạn có thể thiết lập margins = thành “x” hoặc “y” nếu bạn chỉ muốn hiện thị ở một trong số chúng.\n\nCác đối số tùy chọn khác bao gồm fill = (màu cột), color = (màu đường), size = (kích thương biểu đồ so với kích thước biên, do đó số lớn hơn làm biểu đồ biên nhỏ hơn).\n\nBạn có thể cung cấp các đối số theo trục khác với xparams = và yparams =. Ví dụ, để có các kích thước bin khác nhau trong biểu đồ histogram, như được minh họa dưới đây.\n\nBạn có thể có các nhóm biểu đồ biên phản ánh (các cột đã được gán tới color = trong thuộc tính biểu đồ của ggplot()). Nếu đúng như vậy, hãy thiết lập các đối số của hàm ggMarginal() như groupColour = hoặc groupFill = thành TRUE, như được trình bày dưới đây.\nĐọc thêm ở vignette này, ở trang web R Graph Gallery hoặc tài liệu trợ giúp hàm ?ggMarginal.\n\n# Install/load ggExtra\npacman::p_load(ggExtra)\n\n# Basic scatter plot of weight and age\nscatter_plot &lt;- ggplot(data = linelist)+\n  geom_point(mapping = aes(y = wt_kg, x = age)) +\n  labs(title = \"Scatter plot of weight and age\")\n\nĐể thêm biểu đồ biên, hãy sử dụng type = \"histogram\". Bạn có thể tùy chọn thiết lập groupFill = TRUE để có biểu đồ histograms trầm.\n\n# with histograms\nggMarginal(\n  scatter_plot,                     # add marginal histograms\n  type = \"histogram\",               # specify histograms\n  fill = \"lightblue\",               # bar fill\n  xparams = list(binwidth = 10),    # other parameters for x-axis marginal\n  yparams = list(binwidth = 5))     # other parameters for y-axis marginal\n\n\n\n\n\n\n\n\nBiểu đồ mật độ biên với các giá trị được nhóm/tô màu:\n\n# Scatter plot, colored by outcome\n# Outcome column is assigned as color in ggplot. groupFill in ggMarginal set to TRUE\nscatter_plot_color &lt;- ggplot(data = linelist %&gt;% drop_na(gender))+\n  geom_point(mapping = aes(y = wt_kg, x = age, color = gender)) +\n  labs(title = \"Scatter plot of weight and age\")+\n  theme(legend.position = \"bottom\")\n\nggMarginal(scatter_plot_color, type = \"density\", groupFill = TRUE)\n\n\n\n\n\n\n\n\nĐặt kích thước size = để điều chỉnh kích thước tương đối của ô biên. Số nhỏ hơn tạo ra biểu đồ cận biên lớn hơn. Bạn cũng có thể đặt color =. Dưới đây một biểu đồ boxplot cận biên, với sự minh họa của đối số margins = để nó chỉ hiện thị trên một trục:\n\n# with boxplot \nggMarginal(\n  scatter_plot,\n  margins = \"x\",      # only show x-axis marginal plot\n  type = \"boxplot\")",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Các mẹo với ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.vn.html#dán-nhãn-thông-minh",
    "href": "new_pages/ggplot_tips.vn.html#dán-nhãn-thông-minh",
    "title": "31  Các mẹo với ggplot",
    "section": "31.6 Dán nhãn thông minh",
    "text": "31.6 Dán nhãn thông minh\nTrong ggplot2, bạn có thể thêm văn bản vào biểu đồ. Tuy nhiên, điều này đi kèm với hạn chế đáng chú ý là các nhãn văn bản thường xung đột với các điểm dữ liệu trong một biểu đồ, khiến chúng trông lộn xộn hoặc khó đọc. Không có cách nào để giải quyết triệt để vấn đề này với các package trong base R, nhưng có một tiện ích bổ sung của ggplot2 đó là ggrepel giúp xử lý vấn đề này rất đơn giản!\nPackage ggrepel cung cấp hai hàm mới, geom_label_repel() và geom_text_repel(), thay thế cho geom_label() và geom_text(). Đơn giản chỉ cần sử dụng các hàm này thay vì các hàm cơ bản để tạo các nhãn. Bên trong hàm, hãy cụ thể các thông số cho hàm aes() như thường lệ, nhưng bao gồm thêm đối số label = trong đó bạn cung cấp tên cột có chứa giá trị bạn muốn hiển thị (vd: id bệnh nhân, hoặc tên, v.v.). Bạn có thể tạo các nhãn phức tạp hơn bằng cách kết hợp các cột và dòng mới (\\n) bên trong hàm str_glue() như được trình bày bên dưới.\nMột vào mẹo:\n\nSử dụng min.segment.length = 0 để luôn vẽ các đoạn thẳng hoặc min.segment.length = Inf để không bao giờ vẽ chúng\n\nSử dụng size = bên ngoài hàm aes() để thiết lập cỡ chữ\n\nSử dụng force = để thay đổi khoảng cách giữa các nhãn và các điểm tương ứng của chúng (mặc định là 1)\n\nThêm đối số fill = bên trong hàm aes() để có nhãn được tô màu theo giá trị\n\nKý tự “a” có thể xuất hiện trong chú giải - hãy thêm guides(fill = guide_legend(override.aes = aes(color = NA)))+ để xóa nó\n\n\nHãy xem hướng dẫn chuyên sâu này để biết thêm.\n\npacman::p_load(ggrepel)\n\nlinelist %&gt;%                                               # start with linelist\n  group_by(hospital) %&gt;%                                   # group by hospital\n  summarise(                                               # create new dataset with summary values per hospital\n    n_cases = n(),                                           # number of cases per hospital\n    delay_mean = round(mean(days_onset_hosp, na.rm=T),1),    # mean delay per hospital\n  ) %&gt;% \n  ggplot(mapping = aes(x = n_cases, y = delay_mean))+      # send data frame to ggplot\n  geom_point(size = 2)+                                    # add points\n  geom_label_repel(                                        # add point labels\n    mapping = aes(\n      label = stringr::str_glue(\n        \"{hospital}\\n{n_cases} cases, {delay_mean} days\")  # how label displays\n      ), \n    size = 3,                                              # text size in labels\n    min.segment.length = 0)+                               # show all line segments                \n  labs(                                                    # add axes labels\n    title = \"Mean delay to admission, by hospital\",\n    x = \"Number of cases\",\n    y = \"Mean delay (days)\")\n\n\n\n\n\n\n\n\nBạn chỉ có thể gắn nhãn một tập hợp con của các điểm dữ liệu - bằng cách sử dụng cú pháp ggplot() tiêu chuẩn để cung cấp các dữ liệu data = khác nhau cho từng lớp geom của biểu đồ. Dưới đây, tất cả các trường hợp đều được vẽ biểu đồ, nhưng chỉ một số ít được gắn nhãn.\n\nggplot()+\n  # All points in grey\n  geom_point(\n    data = linelist,                                   # all data provided to this layer\n    mapping = aes(x = ht_cm, y = wt_kg),\n    color = \"grey\",\n    alpha = 0.5)+                                              # grey and semi-transparent\n  \n  # Few points in black\n  geom_point(\n    data = linelist %&gt;% filter(days_onset_hosp &gt; 15),  # filtered data provided to this layer\n    mapping = aes(x = ht_cm, y = wt_kg),\n    alpha = 1)+                                                # default black and not transparent\n  \n  # point labels for few points\n  geom_label_repel(\n    data = linelist %&gt;% filter(days_onset_hosp &gt; 15),  # filter the data for the labels\n    mapping = aes(\n      x = ht_cm,\n      y = wt_kg,\n      fill = outcome,                                          # label color by outcome\n      label = stringr::str_glue(\"Delay: {days_onset_hosp}d\")), # label created with str_glue()\n    min.segment.length = 0) +                                  # show line segments for all\n  \n  # remove letter \"a\" from inside legend boxes\n  guides(fill = guide_legend(override.aes = aes(color = NA)))+\n  \n  # axis labels\n  labs(\n    title = \"Cases with long delay to admission\",\n    y = \"weight (kg)\",\n    x = \"height(cm)\")",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Các mẹo với ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.vn.html#trục-thời-gian",
    "href": "new_pages/ggplot_tips.vn.html#trục-thời-gian",
    "title": "31  Các mẹo với ggplot",
    "section": "31.7 Trục thời gian",
    "text": "31.7 Trục thời gian\nLàm việc với các trục thời gian trong ggplot có vẻ khó khăn, nhưng được thực hiện rất dễ dàng với một vài hàm chính. Hãy nhớ rằng khi làm việc với thời gian hoặc ngày tháng, bạn phải đảm bảo rằng các biến cần được định dạng chính xác dưới kiểu date hoặc datetime - hãy xem chương Làm việc với ngày tháng để biết thêm chi tiết, hoặc chương [Đường con dịch bệnh] mục ggplot để xem các ví dụ.\nNhóm các hàm hữu dụng nhất khi làm việc với ngày tháng trong ggplot2 là các hàm scale (scale_x_date(), scale_x_datetime(), và tương tự với các hàm trục y). Các hàm này cho phép bạn xác định tần suất bạn có nhãn trục và cách định dạng nhãn trục. Để tìm hiểu cách định dạng ngày tháng, hãy xem lại mục làm việc với ngày tháng một lần nữa! Bạn có thể sử dụng các đối số date_breaks và date_labels để cụ thể ngày sẽ trông như thế nào:\n\ndate_breaks cho phép bạn cụ thể khoảng cách ngắt trục bằng cách truyền một chuỗi tới đối số (vd: \"3 months\", hoặc “2 days\")\ndate_labels cho phép bạn định nghĩa định dạng ngày tháng hiển thị. Bạn có thể truyền một chuỗi định dạng ngày tháng tới đối số (vd: \"%b-%d-%Y\"):\n\n\n# make epi curve by date of onset when available\nggplot(linelist, aes(x = date_onset)) +\n  geom_histogram(binwidth = 7) +\n  scale_x_date(\n    # 1 break every 1 month\n    date_breaks = \"1 months\",\n    # labels should show month then date\n    date_labels = \"%b %d\"\n  ) +\n  theme_classic()",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Các mẹo với ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.vn.html#làm-nổi-bật",
    "href": "new_pages/ggplot_tips.vn.html#làm-nổi-bật",
    "title": "31  Các mẹo với ggplot",
    "section": "31.8 Làm nổi bật",
    "text": "31.8 Làm nổi bật\nLàm nổi bật các phần tử cụ thể trong biểu đồ là một cách hữu ích để thu hút sự chú ý đến một trường hợp cụ thể của một biến đồng thời cung cấp thông tin về sự phân tán của tập dữ liệu đầy đủ. Mặc dù điều này không dễ dàng thực hiện với ggplot2, tuy nhiên có một package bên ngoài giúp bạn làm điều đó có tên gghighlight. Nó rất dễ sử dụng cùng với cú pháp của ggplot.\nPackage gghighlight sử dụng hàm gghighlight() để thực hiện. Để sử dụng hàm này, hãy cung cấp một biểu thức logic tới hàm - điều này có thể có các kết quả khá linh hoạt, nhưng ở đây chúng ta sẽ trình bày một ví dụ về phân bổ độ tuổi của các trường hợp trong bộ dữ liệu linelist, làm nổi bật chúng theo outcome.\n\n# load gghighlight\nlibrary(gghighlight)\n\n# replace NA values with unknown in the outcome variable\nlinelist &lt;- linelist %&gt;%\n  mutate(outcome = replace_na(outcome, \"Unknown\"))\n\n# produce a histogram of all cases by age\nggplot(\n  data = linelist,\n  mapping = aes(x = age_years, fill = outcome)) +\n  geom_histogram() + \n  gghighlight::gghighlight(outcome == \"Death\")     # highlight instances where the patient has died.\n\n\n\n\n\n\n\n\nNó cũng hoạt động tốt khi faceting - cho phép người dùng tạo ra các biểu đồ con và làm nổi bật một nhóm dữ liệu mà không áp dụng cho toàn bộ biểu đồ con ! Dưới đây, chúng tôi đếm các ca bệnh theo tuần và vẽ đồ thị đường cong dịch bệnh theo bệnh viện (color = và facet_wrap() được gán cho cột hospital).\n\n# produce a histogram of all cases by age\nlinelist %&gt;% \n  count(week = lubridate::floor_date(date_hospitalisation, \"week\"),\n        hospital) %&gt;% \n  ggplot()+\n  geom_line(aes(x = week, y = n, color = hospital))+\n  theme_minimal()+\n  gghighlight::gghighlight() +                      # highlight instances where the patient has died\n  facet_wrap(~hospital)                              # make facets by outcome",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Các mẹo với ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.vn.html#vẽ-nhiều-tập-dữ-liệu",
    "href": "new_pages/ggplot_tips.vn.html#vẽ-nhiều-tập-dữ-liệu",
    "title": "31  Các mẹo với ggplot",
    "section": "31.9 Vẽ nhiều tập dữ liệu",
    "text": "31.9 Vẽ nhiều tập dữ liệu\nLưu ý rằng việc căn chỉnh các trục một cách chính xác để vẽ biểu đồ từ nhiều tập dữ liệu trong cùng một biểu đồ có thể khó khăn. Hãy xem xét một trong các chiến lược sau:\n\nHợp nhất dữ liệu trước khi vẽ biểu đồ và chuyển đổi sang định dạng “dài” với một cột biểu diễn tập dữ liệu\n\nSử dụng package cowplot hoặc các package tương tự để ghép hai biểu đồ (xem bên dưới)",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Các mẹo với ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.vn.html#ghép-các-biểu-đồ",
    "href": "new_pages/ggplot_tips.vn.html#ghép-các-biểu-đồ",
    "title": "31  Các mẹo với ggplot",
    "section": "31.10 Ghép các biểu đồ",
    "text": "31.10 Ghép các biểu đồ\nHai packages phổ biến dùng để ghép các biểu đồ là cowplot và patchwork. Trong chương này chúng ta sẽ tập trung chủ yếu vào package cowplot, và một vài lần sử dụng package patchwork.\nĐây là tài liệu trực tuyến giới thiệu về cowplot. Bạn có thể đọc thêm các tài liệu trực tuyến mở rộng hơn cho từng hàm tại đây. Chúng tôi sẽ đề cập đến một vài trường hợp sử dụng và hàm phổ biến nhất bên dưới.\nPackage cowplot hoạt động song song với ggplot2 - về cơ bản, bạn sử dụng nó để sắp xếp và kết hợp các ggplots và chú giải của chúng thành một biểu đồ ghép. Package này cũng chấp nhận các biểu đồ vẽ bởi base R.\n\npacman::p_load(\n  tidyverse,      # data manipulation and visualisation\n  cowplot,        # combine plots\n  patchwork       # combine plots\n)\n\nTrong khi faceting (được mô tả trong chương ggplot cơ bản) là cách tiếp cận thuận tiện để vẽ biểu đồ, nhưng đôi khi không thể đạt được kết quả bạn muốn từ cách tiếp cận tương đối hạn chế của nó. Tại đây, bạn có thể chọn kết hợp các biểu đồ bằng cách dán chúng lại với nhau thành một biểu đồ lớn hơn. Có ba packages tuyệt vời được sử dụng cho mục đích này - cowplot, gridExtra, và patchwork. Tuy nhiên, các package này phần lớn tương tự nhau, do đó chúng ta sẽ tập trung vào package cowplot trong phần này.\n\nplot_grid()\nPackage cowplot có một số lượng lớn hàm, nhưng việc sử dụng nó dễ dàng nhất có thể đạt được thông qua việc sử dụng hàm plot_grid(). Đây là một cách hiệu quả để sắp xếp các biểu đồ được xác định trước theo dạng lưới. Chúng ta có thể làm việc thông qua một ví dụ khác với bộ dữ liệu sốt rét - ở đây chúng ta có thể vẽ biểu đồ tổng số ca bệnh theo huyện và cũng hiển thị đường cong dịch bệnh theo thời gian.\n\nmalaria_data &lt;- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\")) \n\n# bar chart of total cases by district\np1 &lt;- ggplot(malaria_data, aes(x = District, y = malaria_tot)) +\n  geom_bar(stat = \"identity\") +\n  labs(\n    x = \"District\",\n    y = \"Total number of cases\",\n    title = \"Total malaria cases by district\"\n  ) +\n  theme_minimal()\n\n# epidemic curve over time\np2 &lt;- ggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1) +\n  labs(\n    x = \"Date of data submission\",\n    y =  \"number of cases\"\n  ) +\n  theme_minimal()\n\ncowplot::plot_grid(p1, p2,\n                  # 1 column and two rows - stacked on top of each other\n                   ncol = 1,\n                   nrow = 2,\n                   # top plot is 2/3 as tall as second\n                   rel_heights = c(2, 3))\n\n\n\n\n\n\n\n\n\n\nGhép các chú giải\nNếu các biểu đồ của bạn có cùng chú giải, việc kết hợp chúng là tương đối dễ dàng. Đơn giản, hãy sử dụng phương pháp cowplot ở trên để kết hợp các biểu đồ, sau đó xóa chú giải khỏi một trong số chúng (loại bỏ trùng lặp).\nNếu các biểu đồ có các chú giải khác nhau, bạn phải sử dụng cách khác:\n\nTạo và lưu các biểu đồ không có chú giải bằng cách sử dụng theme(legend.position = \"none\")\n\nTrích xuất các chú giải từ từng biểu đồ sử dụng hàm get_legend() như được trình bày bên dưới - nhưng trích xuất các chú giải từ các biểu đồ đã sửa đổi để thực sự hiển thị chú giải\n\nKết hợp các chú giải vào bảng chú giải\n\nKết hợp các biểu đồ và bảng chú giải\n\nVới mục đích minh họa, chúng ta hiển thị hai biểu đồ một cách riêng biệt, sau đó sắp xếp trong một lưới với các chú giải của riêng chúng (xấu xí và không sử dụng hiệu quả không gian):\n\np1 &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %&gt;% \n  count(hospital, outcome) %&gt;% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+\n  scale_fill_brewer(type = \"qual\", palette = 4, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  labs(title = \"Cases by outcome\")\n\n\np2 &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %&gt;% \n  count(hospital, age_cat) %&gt;% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+\n  scale_fill_brewer(type = \"qual\", palette = 1, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  theme(axis.text.y = element_blank())+\n  labs(title = \"Cases by age\")\n\nĐây là khi hai biểu đồ được kết hợp sử dụng hàm plot_grid() mà không kết hợp các chú giải:\n\ncowplot::plot_grid(p1, p2, rel_widths = c(0.3))\n\n\n\n\n\n\n\n\nVà bây giờ chúng ta sẽ kế hợp các chú giải. Về cơ bản chúng ta cần xác định từng biểu đồ mà không bao gồm chú giải của nó (theme(legend.position = \"none\"), sau đó chúng ta xác định từng chú giải của biểu đồ một cách riêng biệt, sử dụng hàm get_legend() từ package cowplot. Khi chúng ta trích xuất chú giải từ các biểu đồ đã lưu, chúng ta cần thêm + chú thích vào lại, bao gồm việc cụ thể vị trí (“bên phải”) và các điều chỉnh nhỏ hơn để căn chỉnh các chú giải và tiêu đề của chúng. Sau đó, chúng ta kết hợp các chú giải lại với nhau theo chiều dọc, và rồi kết hợp hai biểu đồ lại với bảng chú giải mới.\n\n# Define plot 1 without legend\np1 &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %&gt;% \n  count(hospital, outcome) %&gt;% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+\n  scale_fill_brewer(type = \"qual\", palette = 4, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  theme(legend.position = \"none\")+\n  labs(title = \"Cases by outcome\")\n\n\n# Define plot 2 without legend\np2 &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %&gt;% \n  count(hospital, age_cat) %&gt;% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+\n  scale_fill_brewer(type = \"qual\", palette = 1, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  theme(\n    legend.position = \"none\",\n    axis.text.y = element_blank(),\n    axis.title.y = element_blank()\n  )+\n  labs(title = \"Cases by age\")\n\n\n# extract legend from p1 (from p1 + legend)\nleg_p1 &lt;- cowplot::get_legend(p1 +\n                                theme(legend.position = \"right\",        # extract vertical legend\n                                      legend.justification = c(0,0.5))+ # so legends  align\n                                labs(fill = \"Outcome\"))                 # title of legend\n# extract legend from p2 (from p2 + legend)\nleg_p2 &lt;- cowplot::get_legend(p2 + \n                                theme(legend.position = \"right\",         # extract vertical legend   \n                                      legend.justification = c(0,0.5))+  # so legends align\n                                labs(fill = \"Age Category\"))             # title of legend\n\n# create a blank plot for legend alignment\n#blank_p &lt;- patchwork::plot_spacer() + theme_void()\n\n# create legends panel, can be one on top of the other (or use spacer commented above)\nlegends &lt;- cowplot::plot_grid(leg_p1, leg_p2, nrow = 2, rel_heights = c(.3, .7))\n\n# combine two plots and the combined legends panel\ncombined &lt;- cowplot::plot_grid(p1, p2, legends, ncol = 3, rel_widths = c(.4, .4, .2))\n\ncombined  # print\n\n\n\n\n\n\n\n\nGiải pháp này đã được học hỏi từ bài đăng này với một thay đổi nhỏ để sắp xếp các chú giải từ bài đăng này.\nMẸO: Lưu ý vui - từ “cow” trong cowplot bằt nguồn từ tên của người sáng tạo ra nó - Claus O. Wilke.\n\n\nThêm biểu đồ phụ\nBạn cũng có thể thêm một biểu đồ nhỏ vào một biểu đồ khác sử dụng package cowplot. Dưới đây là những điều cần lưu ý:f:\n\nXác định biểu đồ chính với hàm theme_half_open() trong package cowplot; tốt nhất có thể có chú giải ở trên cùng hoặc dưới cùng\n\nXác định biểu đồ phụ. Tốt nhất là biểu đồ đó bạn không cần chú giải. Bạn có thể xóa các phần tử chủ đề của biểu đồ đó bằng hàm element_blank() như được trình bày bên dưới.\n\nKết hợp chúng bằng cách áp dụng hàm ggdraw() tới biểu đồ chính, rồi sau đó thêm hàm draw_plot() chỉ định biểu đồ phụ và cụ thể hệ trục tọa độ (x và y của góc dưới bên trái), chiều cao và chiều rộng theo tỷ lệ của toàn bộ biểu đồ chính)\n\n\n# Define main plot\nmain_plot &lt;- ggplot(data = linelist)+\n  geom_histogram(aes(x = date_onset, fill = hospital))+\n  scale_fill_brewer(type = \"qual\", palette = 1, na.value = \"grey\")+ \n  theme_half_open()+\n  theme(legend.position = \"bottom\")+\n  labs(title = \"Epidemic curve and outcomes by hospital\")\n\n\n# Define inset plot\ninset_plot &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %&gt;% \n  count(hospital, outcome) %&gt;% \n  ggplot()+\n    geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+\n    scale_fill_brewer(type = \"qual\", palette = 4, na.value = \"grey\")+\n    coord_flip()+\n    theme_minimal()+\n    theme(legend.position = \"none\",\n          axis.title.y = element_blank())+\n    labs(title = \"Cases by outcome\") \n\n\n# Combine main with inset\ncowplot::ggdraw(main_plot)+\n     draw_plot(inset_plot,\n               x = .6, y = .55,    #x = .07, y = .65,\n               width = .4, height = .4)\n\n\n\n\n\n\n\n\nKỹ thuật này được giải thích chi tiết hơn trong hai hướng dẫn sau:\nWilke lab\ndraw_plot() documentation",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Các mẹo với ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.vn.html#trục-kép",
    "href": "new_pages/ggplot_tips.vn.html#trục-kép",
    "title": "31  Các mẹo với ggplot",
    "section": "31.11 Trục kép",
    "text": "31.11 Trục kép\nTrục y thứ hai thường là phần bổ sung được yêu cầu cho đồ thị ggplot2. Mặc dù có một cuộc tranh luận gay gắt về tính hợp lệ của các biểu đồ như vậy trong cộng đồng trực quan hóa dữ liệu và chúng thường không được khuyến nghị, nhưng người quản lý của bạn có thể vẫn muốn điều này. Dưới đây, chúng tôi trình bày một phương pháp để vẽ các biểu đồ như vậy: sử dụng package cowplot để kết hợp hai biểu đồ riêng biệt.\nCách tiếp cận này bao gồm việc tạo hai biểu đồ riêng biệt - một biểu đồ có trục y ở bên trái và biểu đồ còn lại có trục y ở bên phải. Cả hai sẽ cùng sử dụng một theme_cowplot() và phải có cùng trục x. Sau đó, trong lệnh thứ ba, hai biểu đồ được căn chỉnh và chồng lên nhau. Các hàm chức năng của cowplot, được mô tả chi tiết tại trang web này.\nĐể chứng minh kỹ thuật này, chúng ta sẽ phủ đường cong dịch bệnh bằng một đường biểu diễn phần trăm bệnh nhân tử vong hàng tuần. Chúng tôi sử dụng ví dụ này vì việc căn chỉnh ngày tháng trên trục x phức tạp hơn là căn chỉnh biểu đồ cột với một biểu đồ khác. Một số điều cần lưu ý:\n\nĐường cong dịch bệnh và đường biểu diễn được tổng hợp thành nhiều tuần trước khi vẽ biểu đồ và date_breaks và date_labels giống hệt nhau - chúng ta làm điều này để trục x của hai biểu đồ giống nhau khi chúng được phủ lên nhau.\n\nTrục y được chuyển sang phía bên phải cho biểu đồ 2 với đối số position = của hàm scale_y_continuous().\n\nCả hai biểu đồ cùng sử dụng theme_cowplot()\n\nLưu ý rằng có một ví dụ khác về kỹ thuật này trong chương Đường cong dịch bệnh - phủ tỷ lệ mới mắc tích lũy lên trên đỉnh đường cong dịch bệnh.\nTạo biểu đồ 1\nĐâu là biểu đồ đương cong dịch bệnh cơ bản. Chúng ta sử dụng hàm geom_area() chỉ để minh họa cách sử dụng của nó (mặc dịch là vùng dưới một đường)\n\npacman::p_load(cowplot)            # load/install cowplot\n\np1 &lt;- linelist %&gt;%                 # save plot as object\n     count(\n       epiweek = lubridate::floor_date(date_onset, \"week\")) %&gt;% \n     ggplot()+\n          geom_area(aes(x = epiweek, y = n), fill = \"grey\")+\n          scale_x_date(\n               date_breaks = \"month\",\n               date_labels = \"%b\")+\n     theme_cowplot()+\n     labs(\n       y = \"Weekly cases\"\n     )\n\np1                                      # view plot \n\n\n\n\n\n\n\n\nTạo biểu đồ 2\nTạo biểu đồ thứ hai hiển thị một đường về tỷ lệ phần trăm trường hợp tử vong hàng tuần..\n\np2 &lt;- linelist %&gt;%         # save plot as object\n     group_by(\n       epiweek = lubridate::floor_date(date_onset, \"week\")) %&gt;% \n     summarise(\n       n = n(),\n       pct_death = 100*sum(outcome == \"Death\", na.rm=T) / n) %&gt;% \n     ggplot(aes(x = epiweek, y = pct_death))+\n          geom_line()+\n          scale_x_date(\n               date_breaks = \"month\",\n               date_labels = \"%b\")+\n          scale_y_continuous(\n               position = \"right\")+\n          theme_cowplot()+\n          labs(\n            x = \"Epiweek of symptom onset\",\n            y = \"Weekly percent of deaths\",\n            title = \"Weekly case incidence and percent deaths\"\n          )\n\np2     # view plot\n\n\n\n\n\n\n\n\nBây giờ chúng ta căn chỉnh biểu đồ bằng cách sử dụng hàm align_plots(), cụ thể căn chỉnh theo chiều ngang và dọc (“hv”, cũng có thể hoặc là “h”, “v”, “none”). Chúng ta cũng chỉ định căn chỉnh tất cả các trục (trên, dưới, trái, và phải) với “tblr”. Đầu ra là một class list (2 phần tử).\nSau đó, chúng tôi vẽ hai biểu đồ lại với nhau bằng cách sử dụng hàm ggdraw() (từ pakcage cowplot) à tham chiếu đến hai phần của đối tượng aligned_plots.\n\naligned_plots &lt;- cowplot::align_plots(p1, p2, align=\"hv\", axis=\"tblr\")         # align the two plots and save them as list\naligned_plotted &lt;- ggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])  # overlay them and save the visual plot\naligned_plotted                                                                # print the overlayed plots",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Các mẹo với ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.vn.html#packages-giúp-đỡ-bạn",
    "href": "new_pages/ggplot_tips.vn.html#packages-giúp-đỡ-bạn",
    "title": "31  Các mẹo với ggplot",
    "section": "31.12 Packages giúp đỡ bạn",
    "text": "31.12 Packages giúp đỡ bạn\nCó một số package R thực sự gọn gàng được thiết kế đặc biệt để giúp bạn điều hướng ggplot2:\n\nGiao diện kéo thả ggplot2 với package equisse\n“Addin này cho phép bạn khám phá dữ liệu của mình một cách tương tác bằng cách trực quan hóa nó với package ggplot2. Nó cho phép bạn vẽ biểu đồ cột, đường cong, biểu đồ tán xạ, histograms, boxplot và các đối tượng sf, sau đó xuất biểu đồ hoặc truy xuất code để tái tạo biểu đồ.”\nCài đặt và sau đó khởi chạy addin thông qua menu của RStudio hoặc gõ esquisse::esquisser().\nXem thêm Github page\nDocumentation",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Các mẹo với ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.vn.html#tổng-hợp",
    "href": "new_pages/ggplot_tips.vn.html#tổng-hợp",
    "title": "31  Các mẹo với ggplot",
    "section": "31.13 Tổng hợp",
    "text": "31.13 Tổng hợp\n\nHiển thị số\nBạn có thể tắt ký hiệu khoa học bằng cách chạy lệnh này trước khi vẽ biểu đồ.\n\noptions(scipen=999)\n\nHoặc áp dụng hàm number_format() từ package scales cho một giá trị cụ thể hoặc cột, như được trình bày bên dưới.\nSử dụng các hàm từ package scales to easily adjust how numbers are displayed. để dễ dàng điều chỉnh cách hiển thị số. Chúng có thể được áp dụng cho các cột trong data frame của bạn, nhưng được hiển thị trên các số riêng lẻ cho mục đích ví dụ.\n\nscales::number(6.2e5)\n\n[1] \"620 000\"\n\nscales::number(1506800.62,  accuracy = 0.1,)\n\n[1] \"1 506 800.6\"\n\nscales::comma(1506800.62, accuracy = 0.01)\n\n[1] \"1,506,800.62\"\n\nscales::comma(1506800.62, accuracy = 0.01,  big.mark = \".\" , decimal.mark = \",\")\n\n[1] \"1.506.800,62\"\n\nscales::percent(0.1)\n\n[1] \"10%\"\n\nscales::dollar(56)\n\n[1] \"$56\"\n\nscales::scientific(100000)\n\n[1] \"1e+05\"",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Các mẹo với ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.vn.html#nguồn",
    "href": "new_pages/ggplot_tips.vn.html#nguồn",
    "title": "31  Các mẹo với ggplot",
    "section": "31.14 Nguồn",
    "text": "31.14 Nguồn\nCảm hứng ggplot graph gallery\nTrình bày dữ liệu của Trung tâm Phòng ngừa và Kiểm soát Dịch bệnh Châu Âu Guidelines of presentation of surveillance data\nFacets và dán nhãn Using labellers for facet strips Labellers\nĐiều chỉnh thức bậc biến factors fct_reorder\nfct_inorder\nHow to reorder a boxplot\nReorder a variable in ggplot2\nR for Data Science - Factors\nChú giải\nAdjust legend order\nChú thích Caption alignment\nNhãn ggrepel\nCheatsheets\nBeautiful plotting with ggplot2",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Các mẹo với ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.vn.html",
    "href": "new_pages/epicurves.vn.html",
    "title": "32  Đường cong dịch bệnh",
    "section": "",
    "text": "32.1 Chuẩn bị",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Đường cong dịch bệnh</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.vn.html#chuẩn-bị",
    "href": "new_pages/epicurves.vn.html#chuẩn-bị",
    "title": "32  Đường cong dịch bệnh",
    "section": "",
    "text": "Packages\nĐoạn code này hiển thị cách gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, sẽ cài đặt package nếu cần và gọi package để sử dụng. Bạn cũng có thể cài đặt package với hàm library() từ base R. Xem chương R cơ bản để biết thêm thông tin về các package trong R.\n\npacman::p_load(\n  rio,          # file import/export\n  here,         # relative filepaths \n  lubridate,    # working with dates/epiweeks\n  aweek,        # alternative package for working with dates/epiweeks\n  incidence2,   # epicurves of linelist data\n  i2extras,     # supplement to incidence2\n  stringr,      # search and manipulate character strings\n  forcats,      # working with factors\n  RColorBrewer, # Color palettes from colorbrewer2.org\n  tidyverse     # data management + ggplot2 graphics\n) \n\n\n\nNhập dữ liệu\nHai bộ dữ liệu mẫu được sử dụng trong chương này:\n\nBộ số liệu linelist về các ca bệnh từ một vụ dịch mô phỏng\n\nSố lượng tổng hợp theo bệnh viện từ cùng một dịch bệnh mô phỏng bên trên\n\nCác bộ dữ liệu được nhập bằng hàm import() từ package rio. Xem chương Nhập xuất dữ liệu để biết các cách nhập dữ liệu khác nhau.\nBộ số liệu linelist\nChúng ta nhập bộ dữ liệu về các ca bệnh mô phỏng từ một vụ dịch Ebola. Nếu bạn muốn tải xuống dữ liệu để làm theo từng bước, hãy xem hướng dẫn trong chương [Tải sách và dữ liệu]. Chúng tôi giả sử các tệp tin nằm trong thư mục làm việc nên không có thư mục con nào được chỉ định trong đường dẫn này.\n\nlinelist &lt;- import(\"linelist_cleaned.xlsx\")\n\n50 dòng đầu tiên được hiển thị như bên dưới:\n\n\n\n\n\n\nSố lượng ca bệnh do bệnh viện tổng hợp\nTheo mục tiêu của cuốn sách này, bộ dữ liệu về số lượng tổng hợp hàng tuần theo bệnh viện được tạo từ linelist với đoạn code sau.\n\n# import the counts data into R\ncount_data &lt;- linelist %&gt;% \n  group_by(hospital, date_hospitalisation) %&gt;% \n  summarize(n_cases = dplyr::n()) %&gt;% \n  filter(date_hospitalisation &gt; as.Date(\"2013-06-01\")) %&gt;% \n  ungroup()\n\n50 dòng đầu tiên được hiển thị như bên dưới:\n\n\n\n\n\n\n\n\nThiết lập các tham số\nĐể tạo báo cáo, bạn có thể muốn thiết lập các thông số có thể chỉnh sửa, chẳng hạn như ngày dữ liệu hiện tại (“ngày dữ liệu”). Sau đó, bạn có thể tham chiếu đối tượng data_date trong code khi áp dụng bộ lọc hoặc trong chú thích động.\n\n## set the report date for the report\n## note: can be set to Sys.Date() for the current date\ndata_date &lt;- as.Date(\"2015-05-15\")\n\n\n\nXác minh ngày\nXác minh rằng mỗi cột ngày có liên quan là phân lớp Ngày và có phạm vi giá trị thích hợp. Bạn có thể thực hiện việc này đơn giản bằng cách sử dụng hàm hist() cho histogram hoặc hàm range() với na.rm=TRUE, hoặc với hàm ggplot() như bên dưới.\n\n# check range of onset dates\nggplot(data = linelist)+\n  geom_histogram(aes(x = date_onset))",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Đường cong dịch bệnh</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.vn.html#đường-cong-dịch-bệnh-với-ggplot2",
    "href": "new_pages/epicurves.vn.html#đường-cong-dịch-bệnh-với-ggplot2",
    "title": "32  Đường cong dịch bệnh",
    "section": "32.2 Đường cong dịch bệnh với ggplot2",
    "text": "32.2 Đường cong dịch bệnh với ggplot2\nSử dụng ggplot() để xây dựng đường cong dịch bệnh cho phép sự linh hoạt và tùy chỉnh nhiều hơn, nhưng đòi hỏi nhiều nỗ lực và hiểu biết hơn về sử dụng ggplot().\nKhông giống như sử dụng package incidence2, bạn phải kiểm soát thủ công việc tổng hợp các trường hợp theo thời gian (theo tuần, tháng, v.v.) và khoảng thời gian của các nhãn trên trục ngày thág. Việc này phải được quản lý rất cẩn thận.\nCác ví dụ này sử dụng một tập con của bộ dữ liệu linelist - chỉ các trường hợp từ Central Hospital.\n\ncentral_data &lt;- linelist %&gt;% \n  filter(hospital == \"Central Hospital\")\n\nĐể tạo ra một đường cong dịch bệnh với ggplot(), có ba yếu tố chính:\n\nMột histogram, với các ca bệnh linelist được tổng hợp thành các “bins” được phân biệt bằng các điểm “ngắt” cụ thể\n\nCân chỉnh các trục và nhãn\n\nChủ đề của biểu đồ, bao gồm tiêu đề, nhãn, chú thích, v.v.\n\n\nXác định bins của số liệu\nỞ đây chúng ta trình bày cách xác định các ca bệnh sẽ được tổng hợp thành các bins của một histogram (“cột”). Điều quan trọng cần nhận ra là việc tổng hợp số ca bệnh thành các bins của một histogram không nhất thiết phải có cùng khoảng với thời gian xuất hiện trên trục x.\nDưới đây có lẽ là đoạn code đơn giản nhất để tạo ra các đường cong dịch bệnh hàng ngày và hàng tuần.\nTrong lệnh ggplot() tổng quát, bộ dữ liệu được đưa vào data =. Trên nền tảng này, dạng hình học của histogram được thêm bằng một dấu +. Trong geom_histogram(), chúng ta ánh xạ các yếu tố thẩm mỹ sao cho cột date_onset được ánh xạ tới trục x. Cũng trong hàm geom_histogram() nhưng không phải trong đối số aes(), chúng ta đặt binwidth = bằng số bins của histogram, tính bằng ngày. Nếu cú pháp ggplot2 này khó hiểu, hãy xem lại chương ggplot cơ bản.\nTHẬN TRỌNG: Lập biểu đồ các trường hợp hàng tuần bằng cách sử dụng binwidth = 7 bắt đầu cột 7 ngày đầu tiên ở ca bệnh đầu tiên, mà có thể là bất kỳ ngày nào trong tuần! Để tạo các tuần cụ thể, hãy xem phần bên dưới.\n\n# daily \nggplot(data = central_data) +          # set data\n  geom_histogram(                      # add histogram\n    mapping = aes(x = date_onset),     # map date column to x-axis\n    binwidth = 1)+                     # cases binned by 1 day \n  labs(title = \"Central Hospital - Daily\")                # title\n\n# weekly\nggplot(data = central_data) +          # set data \n  geom_histogram(                      # add histogram\n      mapping = aes(x = date_onset),   # map date column to x-axis\n      binwidth = 7)+                   # cases binned every 7 days, starting from first case (!) \n  labs(title = \"Central Hospital - 7-day bins, starting at first case\") # title\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChúng tôi xin lưu ý rằng ca bệnh đầu tiên trong bộ dữ liệu của Central Hospital có triệu chứng khởi phát vào ngày:\n\nformat(min(central_data$date_onset, na.rm=T), \"%A %d %b, %Y\")\n\n[1] \"Thursday 01 May, 2014\"\n\n\nĐể chỉ định thủ công chia biểu đồ cột, không sử dụng argument binwidth = và thay vào đó cung cấp vectơ ngày để breaks =.\nTạo vectơ ngày tháng với hàm seq.Date() trong base R. Hàm này sử dụng các đối số to =, from =, và by =. Ví dụ: lệnh bên dưới trả về ngày mỗi tháng bắt đầu từ ngày 15 Tháng 1 và kết thúc trước ngày 28 Tháng 6.\n\nmonthly_breaks &lt;- seq.Date(from = as.Date(\"2014-02-01\"),\n                           to = as.Date(\"2015-07-15\"),\n                           by = \"months\")\n\nmonthly_breaks   # print\n\n [1] \"2014-02-01\" \"2014-03-01\" \"2014-04-01\" \"2014-05-01\" \"2014-06-01\"\n [6] \"2014-07-01\" \"2014-08-01\" \"2014-09-01\" \"2014-10-01\" \"2014-11-01\"\n[11] \"2014-12-01\" \"2015-01-01\" \"2015-02-01\" \"2015-03-01\" \"2015-04-01\"\n[16] \"2015-05-01\" \"2015-06-01\" \"2015-07-01\"\n\n\nVectơ này có được cung cấp cho hàm geom_histogram() dưới dạng breaks =:\n\n# monthly \nggplot(data = central_data) +  \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    breaks = monthly_breaks)+         # provide the pre-defined vector of breaks                    \n  labs(title = \"Monthly case bins\")   # title\n\n\n\n\n\n\n\n\nMột chuỗi ngày hàng tuần đơn giản có thể được trả về bằng cách đặt by = \"week\". Ví dụ:\n\nweekly_breaks &lt;- seq.Date(from = as.Date(\"2014-02-01\"),\n                          to = as.Date(\"2015-07-15\"),\n                          by = \"week\")\n\nMột giải pháp thay thế cho việc xác định ngày bắt đầu và ngày kết thúc cụ thể là viết code động để các cột hàng tuần bắt đầu vào thứ Hai trước ca đầu tiên. Chúng tôi sẽ sử dụng các vectơ ngày này trong suốt các ví dụ dưới đây.\n\n# Sequence of weekly Monday dates for CENTRAL HOSPITAL\nweekly_breaks_central &lt;- seq.Date(\n  from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 1), # monday before first case\n  to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # monday after last case\n  by   = \"week\")\n\nHãy giải mã đoạn code khá “khoai” ở trên:\n\nGiá trị “from” (ngày sớm nhất của chuỗi) được tạo như sau: giá trị ngày nhỏ nhất (min() với na.rm=TRUE) trong cột date_onset được đưa vào hàm floor_date() thuộc package lubridate. floor_date() được đặt thành “tuần” trả về ngày bắt đầu của “tuần” của trường hợp đó, với điều kiện là ngày bắt đầu của mỗi tuần là Thứ Hai (week_start = 1).\n\nTương tự như vậy, giá trị “to” (ngày kết thúc của chuỗi) được tạo bằng cách sử dụng hàm ngược lại ceiling_date() để trả về thứ hai sau ca cuối cùng.\n\nĐối số “by” của seq.Date() có thể được đặt thành bất kỳ số ngày, tuần hoặc tháng nào.\n\nSử dụng week_start = 7 cho tuần bắt đầu vào Chủ nhật\n\nVì chúng ta sẽ sử dụng các vectơ ngày dạng này trong toàn bộ chương này, chúng ta cũng xác định một vectơ cho toàn bộ đợt bùng phát (ở trên chỉ dành cho Central Hospital).\n\n# Sequence for the entire outbreak\nweekly_breaks_all &lt;- seq.Date(\n  from = floor_date(min(linelist$date_onset, na.rm=T),   \"week\", week_start = 1), # monday before first case\n  to   = ceiling_date(max(linelist$date_onset, na.rm=T), \"week\", week_start = 1), # monday after last case\n  by   = \"week\")\n\nCác kết quả trả về của seq.Date() có thể được sử dụng để tạo các khoảng chia bins trong histogram, cũng như khoảng chia cho các nhãn ngày mà có thể độc lập với các bins. Đọc thêm về nhãn ngày trong các phần sau.\nMẸO: Đối với lệnh ggplot() đơn giản hơn, hãy lưu các khoảng chia bins và khoảng chia nhãn ngày dưới dạng các vectơ đã đặt tên trước và gán tên này vào đối số breaks =.\n\n\nVí dụ về đường cong dịch bệnh theo tuần\nDưới đây là code ví dụ chi tiết để tạo đường cong dịch bệnh hàng tuần cho các tuần bắt đầu vào Thứ Hai, với các cột, nhãn ngày và đường lưới dọc đã được căn chỉnh. Phần này dành cho người dùng có nhu cầu code nhanh. Để hiểu sâu từng khía cạnh (chủ đề, nhãn ngày, v.v.), hãy tiếp tục xem các phần tiếp theo. Chú ý:\n\nCác đoạn chia bins của histogram được xác định bằng hàm seq.Date() như được giải thích ở trên để bắt đầu vào thứ Hai trước ca sớm nhất và kết thúc vào thứ Hai sau ca cuối cùng\n\nKhoảng nhãn ngày được xác định bởi date_breaks = bên trong scale_x_date()\n\nKhoảng đường lưới dọc nhỏ giữa các nhãn ngày được xác định bởi date_minor_breaks =\n\nexpand = c(0,0) trong trục x và y loại bỏ không gian thừa trên mỗi cạnh của trục, điều này cũng đảm bảo các nhãn ngày bắt đầu từ cột đầu tiên.\n\n\n# TOTAL MONDAY WEEK ALIGNMENT\n#############################\n# Define sequence of weekly breaks\nweekly_breaks_central &lt;- seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 1), # Monday before first case\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # Monday after last case\n      by   = \"week\")    # bins are 7-days \n\n\nggplot(data = central_data) + \n  \n  # make histogram: specify bin break points: starts the Monday before first case, end Monday after last case\n  geom_histogram(\n    \n    # mapping aesthetics\n    mapping = aes(x = date_onset),  # date column mapped to x-axis\n    \n    # histogram bin breaks\n    breaks = weekly_breaks_central, # histogram bin breaks defined previously\n    \n    # bars\n    color = \"darkblue\",     # color of lines around bars\n    fill = \"lightblue\"      # color of fill within bars\n  )+ \n    \n  # x-axis labels\n  scale_x_date(\n    expand            = c(0,0),           # remove excess x-axis space before and after case bars\n    date_breaks       = \"4 weeks\",        # date labels and major vertical gridlines appear every 3 Monday weeks\n    date_minor_breaks = \"week\",           # minor vertical lines appear every Monday week\n    date_labels       = \"%a\\n%d %b\\n%Y\")+ # date labels format\n  \n  # y-axis\n  scale_y_continuous(\n    expand = c(0,0))+             # remove excess y-axis space below 0 (align histogram flush with x-axis)\n  \n  # aesthetic themes\n  theme_minimal()+                # simplify plot background\n  \n  theme(\n    plot.caption = element_text(hjust = 0,        # caption on left side\n                                face = \"italic\"), # caption in italics\n    axis.title = element_text(face = \"bold\"))+    # axis titles in bold\n  \n  # labels including dynamic caption\n  labs(\n    title    = \"Weekly incidence of cases (Monday weeks)\",\n    subtitle = \"Note alignment of bars, vertical gridlines, and axis labels on Monday weeks\",\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly incident cases reported\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %&gt;% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))\n\n\n\n\n\n\n\n\n\nTuần bắt đầu bằng Chủ nhật\nĐể vẽ được biểu đồ cho các tuần bắt đầu bằng Chủ nhật, cần có một số sửa đổi, vì date_breaks = \"weeks\" chỉ hoạt động cho các tuần bắt đầu bằng thứ Hai.\n\nCác điểm ngắt của các histogram bins phải được đặt thành Chủ nhật (week_start = 7)\n\nTrong scale_x_date(), các đoạn ngắt ngày tương tự nên được gắn với breaks = và minor_breaks = để đảm bảo các nhãn ngày và đường lưới dọc căn chỉnh vào ngày Chủ nhật.\n\nVí dụ: lệnh scale_x_date() cho các tuần bắt đầu vào Chủ nhật có thể trông như sau:\n\nscale_x_date(\n    expand = c(0,0),\n    \n    # specify interval of date labels and major vertical gridlines\n    breaks = seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7), # Sunday before first case\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # Sunday after last case\n      by   = \"4 weeks\"),\n    \n    # specify interval of minor vertical gridline \n    minor_breaks = seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7), # Sunday before first case\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # Sunday after last case\n      by   = \"week\"),\n   \n    # date label format\n    #date_labels = \"%a\\n%d %b\\n%Y\")+         # day, above month abbrev., above 2-digit year\n    label = scales::label_date_short())      # automatic label formatting\n\n\n\n\nNhóm/tô màu theo giá trị\nCác cột histogram có thể được tô màu theo nhóm và “xếp chồng lên nhau”. Để chỉ định cột nhóm, hãy thực hiện các thay đổi sau. Xem chương ggplot cơ bản để biết thêm chi tiết.\n\nBên trong đối số aes() của hàm vẽ histogram, ánh xạ tên cột tới đối số group = và fill =\n\nLoại bỏ bất kỳ tham số fill = nào bên ngoài đối số aes(), vì nó sẽ ghi đè giá trị bên trong\n\nĐối số bên trong aes() sẽ áp dụng theo nhóm, trong khi bất kỳ đối số bên ngoài nào đều sẽ áp dụng cho tất cả các cột (ví dụ: bạn có thể vẫn muốn tô màu color = bên ngoài, vì vậy mỗi cột có cùng một đường viền)\n\nĐây là lệnh aes() hiển thị nhóm và tô màu các cột theo giới tính:\n\naes(x = date_onset, group = gender, fill = gender)\n\nĐây là kết quả khi áp dụng:\n\nggplot(data = linelist) +     # begin with linelist (many hospitals)\n  \n  # make histogram: specify bin break points: starts the Monday before first case, end Monday after last case\n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = hospital,       # set data to be grouped by hospital\n      fill = hospital),       # bar fill (inside color) by hospital\n    \n    # bin breaks are Monday weeks\n    breaks = weekly_breaks_all,   # sequence of weekly Monday bin breaks for whole outbreak, defined in previous code       \n    \n    # Color around bars\n    color = \"black\")\n\n\n\n\n\n\n\n\n\n\nHiệu chỉnh màu\n\nĐể thiết lập thủ công tô màu cho từng nhóm, hãy sử dụng scale_fill_manual() (lưu ý: scale_color_manual() là một cái khác!)\n\nSử dụng đối số values = để áp dụng một vectơ màu\n\nSử dụng na.value = để xác định màu cho giá trị NA\n\nSử dụng đối số labels = để thay đổi văn bản trong mục chú thích. Để cho an toàn, sử dụng một vectơ được đặt tên kiểu như c(\"old\" = \"new\", \"old\" = \"new\") hoặc điều chỉnh giá trị trong bộ dữ liệu\n\nSử dụng name = để đặt một tiêu đề thích hợp cho mục chú thích\n\n\nĐể biết thêm mẹo về thang màu và bảng màu, hãy xem chương ggplot cơ bản.\n\n\nggplot(data = linelist)+           # begin with linelist (many hospitals)\n  \n  # make histogram\n  geom_histogram(\n    mapping = aes(x = date_onset,\n        group = hospital,          # cases grouped by hospital\n        fill = hospital),          # bar fill by hospital\n    \n    # bin breaks\n    breaks = weekly_breaks_all,        # sequence of weekly Monday bin breaks, defined in previous code\n    \n    # Color around bars\n    color = \"black\")+              # border color of each bar\n  \n  # manual specification of colors\n  scale_fill_manual(\n    values = c(\"black\", \"orange\", \"grey\", \"beige\", \"blue\", \"brown\"),\n    labels = c(\"St. Mark's Maternity Hospital (SMMH)\" = \"St. Mark's\"),\n    name = \"Hospital\") # specify fill colors (\"values\") - attention to order!\n\n\n\n\n\n\n\n\n\n\nHiệu chỉnh thứ bậc\nThứ tự mà các cột được nhóm xếp chồng lên nhau được điều chỉnh tốt nhất bằng cách phân loại cột nhóm dưới dạng Factor. Sau đó, bạn có thể chỉ định thứ tự cấp độ phân loại (và nhãn hiển thị của chúng). Xem chương về Factors hoặc Các mẹo với ggplot để biết thêm chi tiết.\nTrước khi tạo biểu đồ, hãy sử dụng hàm fct_relevel() từ package forcats để chuyển đổi cột phân nhóm thành kiểu Factor và điều chỉnh thứ tự cấp độ theo cách thủ công, như được trình bày chi tiết trong chương về Factors.\n\n# load forcats package for working with factors\npacman::p_load(forcats)\n\n# Define new dataset with hospital as factor\nplot_data &lt;- linelist %&gt;% \n  mutate(hospital = fct_relevel(hospital, c(\"Missing\", \"Other\"))) # Convert to factor and set \"Missing\" and \"Other\" as top levels to appear on epicurve top\n\nlevels(plot_data$hospital) # print levels in order\n\n[1] \"Missing\"                             \n[2] \"Other\"                               \n[3] \"Central Hospital\"                    \n[4] \"Military Hospital\"                   \n[5] \"Port Hospital\"                       \n[6] \"St. Mark's Maternity Hospital (SMMH)\"\n\n\nTrong biểu đồ dưới đây, điểm khác biệt duy nhất so với trước đó là cột hospital đã được hợp nhất như trên và chúng ta sử dụng các guides() để đảo ngược thứ tự chú thích, do đó “nhãn Missing” nằm ở cuối chú thích.\n\nggplot(plot_data) +                     # Use NEW dataset with hospital as re-ordered factor\n  \n  # make histogram\n  geom_histogram(\n    mapping = aes(x = date_onset,\n        group = hospital,               # cases grouped by hospital\n        fill = hospital),               # bar fill (color) by hospital\n    \n    breaks = weekly_breaks_all,         # sequence of weekly Monday bin breaks for whole outbreak, defined at top of ggplot section\n    \n    color = \"black\")+                   # border color around each bar\n    \n  # x-axis labels\n  scale_x_date(\n    expand            = c(0,0),           # remove excess x-axis space before and after case bars\n    date_breaks       = \"3 weeks\",        # labels appear every 3 Monday weeks\n    date_minor_breaks = \"week\",           # vertical lines appear every Monday week\n    label = scales::label_date_short()) + # efficient label formatting\n  \n  # y-axis\n  scale_y_continuous(\n    expand = c(0,0))+                   # remove excess y-axis space below 0\n  \n  # manual specification of colors, ! attention to order\n  scale_fill_manual(\n    values = c(\"grey\", \"beige\", \"black\", \"orange\", \"blue\", \"brown\"),\n    labels = c(\"St. Mark's Maternity Hospital (SMMH)\" = \"St. Mark's\"),\n    name = \"Hospital\")+ \n  \n  # aesthetic themes\n  theme_minimal()+                      # simplify plot background\n  \n  theme(\n    plot.caption = element_text(face = \"italic\", # caption on left side in italics\n                                hjust = 0), \n    axis.title = element_text(face = \"bold\"))+   # axis titles in bold\n  \n  # labels\n  labs(\n    title    = \"Weekly incidence of cases by hospital\",\n    subtitle = \"Hospital as re-ordered factor\",\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly cases\")\n\n\n\n\n\n\n\n\nMẸO: Để chỉ đảo ngược thứ tự của chú thích, hãy thêm lệnh ggplot2 này: guides(fill = guide_legend(reverse = TRUE)).\n\n\nHiệu chỉnh chú thích\nĐọc thêm về chú thích và scale trong chương Các mẹo với ggplot. Dưới đây là một vài điểm nổi bật:\n\nChỉnh sửa tiêu đề chú thích trong hàm scale hoặc với labs(fill = \"Legend title\") (nếu bạn đang sử dụng color =, thì hãy sử dụng labs(color = \"\"))\n\ntheme(legend.title = element_blank()) để bỏ trống tiêu đề chú thích\n\ntheme(legend.position = \"top\") (“bottom”, “left”, “right”, hoặc “none” để bỏ chú thích)\ntheme(legend.direction = \"horizontal\") xoay ngang chú thích\nguides(fill = guide_legend(reverse = TRUE)) để đảo ngược thứ tự các mục chú thích\n\n\n\nCột kề cột\nHiển thị song song các cột nhóm (trái ngược với xếp chồng lên nhau) được chỉ định trong geom_histogram() với position = \"dodge\" được đặt bên ngoài aes().\nNếu có nhiều hơn hai nhóm giá trị, nó có thể gây khó đọc. Thay vào đó, hãy cân nhắc sử dụng một biểu đồ được chia nhỏ (gồm nhiều biểu đồ nhỏ). Để dễ xem trong ví dụ này, các giá trị giới tính bị thiếu sẽ bị xóa.\n\nggplot(central_data %&gt;% drop_na(gender))+   # begin with Central Hospital cases dropping missing gender\n    geom_histogram(\n        mapping = aes(\n          x = date_onset,\n          group = gender,         # cases grouped by gender\n          fill = gender),         # bars filled by gender\n        \n        # histogram bin breaks\n        breaks = weekly_breaks_central,   # sequence of weekly dates for Central outbreak - defined at top of ggplot section\n        \n        color = \"black\",          # bar edge color\n        \n        position = \"dodge\")+      # SIDE-BY-SIDE bars\n                      \n  \n  # The labels on the x-axis\n  scale_x_date(expand            = c(0,0),         # remove excess x-axis space below and after case bars\n               date_breaks       = \"3 weeks\",      # labels appear every 3 Monday weeks\n               date_minor_breaks = \"week\",         # vertical lines appear every Monday week\n               label = scales::label_date_short())+ # efficient date labels\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+             # removes excess y-axis space between bottom of bars and the labels\n  \n  #scale of colors and legend labels\n  scale_fill_manual(values = c(\"brown\", \"orange\"),  # specify fill colors (\"values\") - attention to order!\n                    na.value = \"grey\" )+     \n\n  # aesthetic themes\n  theme_minimal()+                                               # a set of themes to simplify plot\n  theme(plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n        axis.title = element_text(face = \"bold\"))+               # axis titles in bold\n  \n  # labels\n  labs(title    = \"Weekly incidence of cases, by gender\",\n       subtitle = \"Subtitle\",\n       fill     = \"Gender\",                                      # provide new title for legend\n       x        = \"Week of symptom onset\",\n       y        = \"Weekly incident cases reported\")\n\n\n\n\n\n\n\n\n\n\nGiới hạn trục\nCó hai cách để giới hạn phạm vi các giá trị trên trục.\nNói chung, cách khuyến khích sử dụng là lệnh coord_cartesian(), chấp nhận xlim = c(min, max) và ylim = c(min, max) (trong đó bạn cung cấp giá trị nhỏ nhất và lớn nhất). Cách này hoạt động như một “thu phóng kích thước” mà không thực sự loại bỏ bất kỳ dữ liệu nào, điều này rất quan trọng đối với các số liệu thống kê và các thang đo tổng hợp.\nNgoài ra, bạn có thể thiết lập giá trị ngày tối đa và tối thiểu bằng cách sử dụng limits = c() bên trong hàm scale_x_date(). Ví dụ:\n\nscale_x_date(limits = c(as.Date(\"2014-04-01\"), NA)) # sets a minimum date but leaves the maximum open.  \n\nTương tự như vậy, nếu bạn muốn trục x kéo dài đến một ngày cụ thể (ví dụ: ngày hiện tại), ngay cả khi không có trường hợp mới nào được báo cáo, bạn có thể sử dụng:\n\nscale_x_date(limits = c(NA, Sys.Date()) # ensures date axis will extend until current date  \n\nLƯU Ý: Hãy thận trọng khi đặt giới hạn hoặc chia tỷ lệ trục y (ví dụ: 0 đến 30 với khoảng là 5: seq(0, 30, 5)). Những con số tĩnh như vậy có thể cắt bớt biểu đồ quá ngắn nếu dữ liệu thay đổi vượt quá giới hạn!.\n\n\nNhãn/đường lưới của trục ngày\nMẸO: Hãy nhớ rằng các nhãn trục ngày độc lập với việc tổng hợp dữ liệu thành các cột, nhưng về mặt trực quan, điều quan trọng là phải căn chỉnh các cột, nhãn ngày và các đường lưới dọc.\nĐể sửa đổi nhãn ngày và đường lưới, hãy sử dụng scale_x_date() theo một trong những cách sau:\n\nNếu histogram bins là ngày, tuần bắt đầu vào thứ hai, tháng hoặc năm:\n\nSử dụng date_breaks = để xác định khoảng thời gian của các nhãn và đường lưới chính (ví dụ: “day”, “week”, “3 weeks”, “month” hoặc “year”)\nSử dụng date_minor_breaks = để xác định khoảng của các đường lưới dọc nhỏ (giữa các nhãn ngày)\n\nThêm expand = c(0,0) để bắt đầu các nhãn ở cột đầu tiên\n\nSử dụng date_labels = để xác định định dạng của nhãn ngày - hãy xem chương Ngày để biết các mẹo (sử dụng \\n cho một dòng mới)\n\n\nNếu histogram bins là các tuần bắt đầu vào Chủ nhật:\n\nSử dụng breaks = và minor_breaks = bằng cách cung cấp một chuỗi ngày cho mỗi khoảng chia\nVẫn có thể sử dụng date_labels = và expand = để định dạng như mô tả ở trên\n\n\nMột số ghi chú:\n\nXem phần mở đầu của mục ggplot về hướng dẫn cách tạo chuỗi ngày bằng seq.Date().\n\nXem trang này hoặc chương Làm việc với ngày tháng để biết thêm mẹo tạo nhãn ngày.\n\n\nMinh họa\nDưới đây là minh họa biểu đồ trong đó các cột và nhãn biểu đồ/đường lưới được căn chỉnh thẳng hàng và không thẳng hàng:\n\n# 7-day bins + Monday labels\n#############################\nggplot(central_data) +\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    binwidth = 7,                 # 7-day bins with start at first case\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n  \n  scale_x_date(\n    expand = c(0,0),               # remove excess x-axis space below and after case bars\n    date_breaks = \"3 weeks\",       # Monday every 3 weeks\n    date_minor_breaks = \"week\",    # Monday weeks\n    label = scales::label_date_short())+ # automatic label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+              # remove excess space under x-axis, make flush\n  \n  labs(\n    title = \"MISALIGNED\",\n    subtitle = \"! CAUTION: 7-day bars start Thursdays at first case\\nDate labels and gridlines on Mondays\\nNote how ticks don't align with bars\")\n\n\n\n# 7-day bins + Months\n#####################\nggplot(central_data) +\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    binwidth = 7,\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n  \n  scale_x_date(\n    expand = c(0,0),                  # remove excess x-axis space below and after case bars\n    date_breaks = \"months\",           # 1st of month\n    date_minor_breaks = \"week\",       # Monday weeks\n    label = scales::label_date_short())+ # automatic label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remove excess space under x-axis, make flush \n  \n  labs(\n    title = \"MISALIGNED\",\n    subtitle = \"! CAUTION: 7-day bars start Thursdays with first case\\nMajor gridlines and date labels at 1st of each month\\nMinor gridlines weekly on Mondays\\nNote uneven spacing of some gridlines and ticks unaligned with bars\")\n\n\n# TOTAL MONDAY ALIGNMENT: specify manual bin breaks to be mondays\n#################################################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # histogram breaks set to 7 days beginning Monday before first case\n    breaks = weekly_breaks_central,    # defined earlier in this page\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),                   # remove excess x-axis space below and after case bars\n    date_breaks = \"4 weeks\",           # Monday every 4 weeks\n    date_minor_breaks = \"week\",        # Monday weeks \n    label = scales::label_date_short())+ # label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remove excess space under x-axis, make flush \n  \n  labs(\n    title = \"ALIGNED Mondays\",\n    subtitle = \"7-day bins manually set to begin Monday before first case (28 Apr)\\nDate labels and gridlines on Mondays as well\")\n\n\n# TOTAL MONDAY ALIGNMENT WITH MONTHS LABELS:\n############################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # histogram breaks set to 7 days beginning Monday before first case\n    breaks = weekly_breaks_central,            # defined earlier in this page\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),                   # remove excess x-axis space below and after case bars\n    date_breaks = \"months\",            # Monday every 4 weeks\n    date_minor_breaks = \"week\",        # Monday weeks \n    label = scales::label_date_short())+ # label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remove excess space under x-axis, make flush \n  \n  theme(panel.grid.major = element_blank())+  # Remove major gridlines (fall on 1st of month)\n          \n  labs(\n    title = \"ALIGNED Mondays with MONTHLY labels\",\n    subtitle = \"7-day bins manually set to begin Monday before first case (28 Apr)\\nDate labels on 1st of Month\\nMonthly major gridlines removed\")\n\n\n# TOTAL SUNDAY ALIGNMENT: specify manual bin breaks AND labels to be Sundays\n############################################################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # histogram breaks set to 7 days beginning Sunday before first case\n    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                      by   = \"7 days\"),\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),\n    # date label breaks and major gridlines set to every 3 weeks beginning Sunday before first case\n    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                      by   = \"3 weeks\"),\n    \n    # minor gridlines set to weekly beginning Sunday before first case\n    minor_breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                            to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                            by   = \"7 days\"),\n    \n    label = scales::label_date_short())+ # label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remove excess space under x-axis, make flush \n  \n  labs(title = \"ALIGNED Sundays\",\n       subtitle = \"7-day bins manually set to begin Sunday before first case (27 Apr)\\nDate labels and gridlines manually set to Sundays as well\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDữ liệu tổng hợp\nThông thường, thay vì bắt đầu với bộ số liệu linelist, bạn có thể bắt đầu với số lượng tổng hợp từ các cơ sở y tế, quận, huyện, v.v. Bạn có thể tạo đường cong dịch bệnh với ggplot() nhưng code sẽ hơi khác một chút. Phần này sẽ tận dụng bộ dữ liệu count_data đã được nạp trước đó trong mục chuẩn bị dữ liệu. Bộ dữ liệu này là linelist được tổng hợp thành số lượng bệnh viện theo ngày. 50 hàng đầu tiên được hiển thị dưới đây.\n\n\n\n\n\n\n\nVẽ biểu đồ dữ liệu đếm hàng ngày\nChúng ta có thể vẽ biểu đồ đường cong dịch bệnh từ dữ liệu đếm hàng ngày. Dưới đây là sự khác biệt trong đoạn code:\n\nKhi ánh xạ các yếu tố trong hàm aes(), hãy cụ thể y = bằng một cột đếm (trong trường hợp này, tên cột là n_cases)\nThêm đối số stat = \"identity\" trong geom_histogram(), giúp xác định rằng chiều cao cột phải là giá trị y =, không phải số hàng như mặc định\n\nThêm đối số width = để tránh các đường trắng dọc giữa các cột. Đối với dữ liệu hàng ngày được đặt thành 1. Đối với dữ liệu đếm hàng tuần được đặt thành 7. Đối với dữ liệu đếm hàng tháng, các đường màu trắng là một vấn đề (mỗi tháng có số ngày khác nhau) - hãy xem xét chuyển đổi trục x của bạn thành cột phân loại (factor) theo thứ tự (tháng) và sử dụng geom_col().\n\n\nggplot(data = count_data)+\n  geom_histogram(\n   mapping = aes(x = date_hospitalisation, y = n_cases),\n   stat = \"identity\",\n   width = 1)+                # for daily counts, set width = 1 to avoid white space between bars\n  labs(\n    x = \"Date of report\", \n    y = \"Number of cases\",\n    title = \"Daily case incidence, from daily count data\")\n\n\n\n\n\n\n\n\n\n\nVẽ biểu đồ dữ liệu đếm hàng tuần\nNếu dữ liệu của bạn đã là số lượng ca bệnh đếm theo tuần, chúng có thể trông giống như bộ dữ liệu này (được gọi là count_data_weekly):\n50 hàng đầu tiên của count_data_weekly được hiển thị bên dưới. Bạn có thể thấy rằng số lượng đếm đã được tổng hợp thành các tuần. Mỗi tuần được hiển thị theo ngày đầu tiên của tuần (mặc định là Thứ Hai).\n\n\n\n\n\n\nBây giờ vẽ biểu đồ sao cho x = cột epiweek. Hãy nhớ thêm y = cột đếm khi ánh xạ trục và thêm stat = \"identity\" như đã giải thích ở trên.\n\nggplot(data = count_data_weekly)+\n  \n  geom_histogram(\n    mapping = aes(\n      x = epiweek,           # x-axis is epiweek (as class Date)\n      y = n_cases_weekly,    # y-axis height in the weekly case counts\n      group = hospital,      # we are grouping the bars and coloring by hospital\n      fill = hospital),\n    stat = \"identity\")+      # this is also required when plotting count data\n     \n  # labels for x-axis\n  scale_x_date(\n    date_breaks = \"2 months\",      # labels every 2 months \n    date_minor_breaks = \"1 month\", # gridlines every month\n    label = scales::label_date_short())+ # label formatting\n     \n  # Choose color palette (uses RColorBrewer package)\n  scale_fill_brewer(palette = \"Pastel2\")+ \n  \n  theme_minimal()+\n  \n  labs(\n    x = \"Week of onset\", \n    y = \"Weekly case incidence\",\n    fill = \"Hospital\",\n    title = \"Weekly case incidence, from aggregated count data by hospital\")\n\n\n\n\n\n\n\n\n\n\n\nĐường trung bình động\nXem chương về Đường trung bình động để có mô tả chi tiết và một số tùy chọn. Dưới đây là một tùy chọn để tính toán đường trung bình động với package slider. Theo cách tiếp cận này, trung bình động được tính toán trong bộ dữ liệu trước khi vẽ biểu đồ:\n\nTổng hợp dữ liệu thành số lượng nếu cần thiết (hàng ngày, hàng tuần, v.v.) (xem chương Nhóm dữ liệu)\n\nTạo một cột mới để giữ đường trung bình động, được tạo bằng hàm slide_index() từ package slider\n\nVẽ đường trung bình động dưới dạng một geom_line() ở trên đỉnh (phía sau) histogram đường cong dịch bệnh\n\nTham khảo thêm tại vignette của package slider\n\n# load package\npacman::p_load(slider)  # slider used to calculate rolling averages\n\n# make dataset of daily counts and 7-day moving average\n#######################################################\nll_counts_7day &lt;- linelist %&gt;%    # begin with linelist\n  \n  ## count cases by date\n  count(date_onset, name = \"new_cases\") %&gt;%   # name new column with counts as \"new_cases\"\n  drop_na(date_onset) %&gt;%                     # remove cases with missing date_onset\n  \n  ## calculate the average number of cases in 7-day window\n  mutate(\n    avg_7day = slider::slide_index(    # create new column\n      new_cases,                       # calculate based on value in new_cases column\n      .i = date_onset,                 # index is date_onset col, so non-present dates are included in window \n      .f = ~mean(.x, na.rm = TRUE),    # function is mean() with missing values removed\n      .before = 6,                     # window is the day and 6-days before\n      .complete = FALSE),              # must be FALSE for unlist() to work in next step\n    avg_7day = unlist(avg_7day))       # convert class list to class numeric\n\n\n# plot\n######\nggplot(data = ll_counts_7day) +  # begin with new dataset defined above \n    geom_histogram(              # create epicurve histogram\n      mapping = aes(\n        x = date_onset,          # date column as x-axis\n        y = new_cases),          # height is number of daily new cases\n        stat = \"identity\",       # height is y value\n        fill=\"#92a8d1\",          # cool color for bars\n        colour = \"#92a8d1\",      # same color for bar border\n        )+ \n    geom_line(                   # make line for rolling average\n      mapping = aes(\n        x = date_onset,          # date column for x-axis\n        y = avg_7day,            # y-value set to rolling average column\n        lty = \"7-day \\nrolling avg\"), # name of line in legend\n      color=\"red\",               # color of line\n      size = 1) +                # width of line\n    scale_x_date(                # date scale\n      date_breaks = \"1 month\",\n      label = scales::label_date_short(), # label formatting\n      expand = c(0,0)) +\n    scale_y_continuous(          # y-axis scale\n      expand = c(0,0),\n      limits = c(0, NA)) +       \n    labs(\n      x=\"\",\n      y =\"Number of confirmed cases\",\n      fill = \"Legend\")+ \n    theme_minimal()+\n    theme(legend.title = element_blank())  # removes title of legend\n\n\n\n\n\n\n\n\n\n\nFaceting/chia nhỏ biểu đồ\nNhư với các ggplots khác, bạn có thể tạo các biểu đồ được chia nhỏ (“nhiều biểu đồ con”). Như đã giải thích trong chương Các mẹo với ggplot trong cuốn sách này, bạn có thể sử dụng facet_wrap() hoặc facet_grid(). Ở đây chúng tôi sẽ minh họa bằng hàm facet_wrap(). Đối với đường cong dịch bệnh, sử dụng facet_wrap() thường dễ dàng hơn vì khả năng bạn thường chỉ cần chia nhỏ biểu đồ theo một biến.\nCú pháp chung là facet_wrap(rows ~ cols), trong đó bên trái dấu ngã (~) là tên của biến sẽ được trải trên các “hàng” của biểu đồ chia nhỏ và ở bên phải dấu ngã là tên của biến sẽ được trải trên các “cột” của biểu đồ chia nhỏ. Đơn giản nhất, chỉ cần sử dụng một tên cột, ở bên phải dấu ngã: facet_wrap(~age_cat).\nTrục tự do\nBạn sẽ cần phải quyết định xem tỷ lệ của các trục cho mỗi biểu đồ nhỏ là “cố định” với cùng một kích thước (mặc định) hay “tự do” (nghĩa là chúng sẽ thay đổi dựa trên dữ liệu của chúng). Thực hiện điều này với đối số scales = trong hàm facet_wrap() bằng cách chỉ định “free_x” hoặc “free_y” hoặc “free”.\nSố cột và hàng của các biểu đồ con\nĐiều này có thể xác định với ncol = và nrow = trong hàm facet_wrap().\nThứ tự các biểu đồ con\nĐể thay đổi thứ tự xuất hiện, hãy thay đổi thứ tự cơ bản của các cấp của cột phân loại được sử dụng để tạo các biểu đồ con.\nĐinh dạng trục\nKích thước phông chữ và mặt biểu đồ, dải màu, v.v. có thể được sửa đổi thông qua theme() với các đối số như:\n\nstrip.text = element_text() (kích thước, màu sắc, mặt, góc …)\nstrip.background = element_rect() (ví dụ: element_rect(fill = \"grey\"))\n\nstrip.position = (vị trị “dưới”, “trên”, “trái”, hoặc “phải”)\n\nDải nhãn\nNhãn của các biểu đồ con có thể được sửa đổi thông qua “nhãn” của cột như một factor hoặc bằng cách sử dụng một “người dán nhãn - labeller”.\nĐể tạo một labeller như thế, sử dụng hàm as_labeller() từ ggplot2. Sau đó, cung cấp labeller cho đối số labeller = của facet_wrap() như dưới đây.\n\nmy_labels &lt;- as_labeller(c(\n     \"0-4\"   = \"Ages 0-4\",\n     \"5-9\"   = \"Ages 5-9\",\n     \"10-14\" = \"Ages 10-14\",\n     \"15-19\" = \"Ages 15-19\",\n     \"20-29\" = \"Ages 20-29\",\n     \"30-49\" = \"Ages 30-49\",\n     \"50-69\" = \"Ages 50-69\",\n     \"70+\"   = \"Over age 70\"))\n\nMột ví dụ về chia nhỏ biểu đồ - chia bằng cột age_cat.\n\n# make plot\n###########\nggplot(central_data) + \n  \n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = age_cat,\n      fill = age_cat),    # arguments inside aes() apply by group\n      \n    color = \"black\",      # arguments outside aes() apply to all data\n        \n    # histogram breaks\n    breaks = weekly_breaks_central)+  # pre-defined date vector (see earlier in this page)\n                      \n  # The labels on the x-axis\n  scale_x_date(\n    expand            = c(0,0),         # remove excess x-axis space below and after case bars\n    date_breaks       = \"2 months\",     # labels appear every 2 months\n    date_minor_breaks = \"1 month\",      # vertical lines appear every 1 month \n    label = scales::label_date_short())+ # label formatting\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+                       # removes excess y-axis space between bottom of bars and the labels\n  \n  # aesthetic themes\n  theme_minimal()+                                           # a set of themes to simplify plot\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    strip.text = element_text(face = \"bold\", size = 10),\n    strip.background = element_rect(fill = \"grey\"))+         # axis titles in bold\n  \n  # create facets\n  facet_wrap(\n    ~age_cat,\n    ncol = 4,\n    strip.position = \"top\",\n    labeller = my_labels)+             \n  \n  # labels\n  labs(\n    title    = \"Weekly incidence of cases, by age category\",\n    subtitle = \"Subtitle\",\n    fill     = \"Age category\",                                      # provide new title for legend\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly incident cases reported\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %&gt;% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))\n\n\n\n\n\n\n\n\nXem link để biết thêm thông tin về labellers.\n\nTổng vụ dịch trong nền của biểu đồ con\nĐể hiển thị tổng vụ dịch trong nền của mỗi biểu đồ con, hãy thêm hàm gghighlight() với dấu ngoặc đơn trống vào ggplot. Hàm này thuộc package gghighlight. Lưu ý rằng trục y tối đa trong tất cả các biểu đồ con hiện dựa vào đỉnh của toàn bộ vụ dịch. Có nhiều ví dụ hơn về package này trong chương Các mẹo với ggplot.\n\nggplot(central_data) + \n  \n  # epicurves by group\n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = age_cat,\n      fill = age_cat),  # arguments inside aes() apply by group\n    \n    color = \"black\",    # arguments outside aes() apply to all data\n    \n    # histogram breaks\n    breaks = weekly_breaks_central)+     # pre-defined date vector (see top of ggplot section)                \n  \n  # add grey epidemic in background to each facet\n  gghighlight::gghighlight()+\n  \n  # labels on x-axis\n  scale_x_date(\n    expand            = c(0,0),         # remove excess x-axis space below and after case bars\n    date_breaks       = \"2 months\",     # labels appear every 2 months\n    date_minor_breaks = \"1 month\",      # vertical lines appear every 1 month \n    label = scales::label_date_short())+ # label formatting\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+  # removes excess y-axis space below 0\n  \n  # aesthetic themes\n  theme_minimal()+                                           # a set of themes to simplify plot\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    strip.text = element_text(face = \"bold\", size = 10),\n    strip.background = element_rect(fill = \"white\"))+        # axis titles in bold\n  \n  # create facets\n  facet_wrap(\n    ~age_cat,                          # each plot is one value of age_cat\n    ncol = 4,                          # number of columns\n    strip.position = \"top\",            # position of the facet title/strip\n    labeller = my_labels)+             # labeller defines above\n  \n  # labels\n  labs(\n    title    = \"Weekly incidence of cases, by age category\",\n    subtitle = \"Subtitle\",\n    fill     = \"Age category\",                                      # provide new title for legend\n    x        = \"Week of symptom onset\",\n    y        = \"Weekly incident cases reported\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %&gt;% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))\n\n\n\n\n\n\n\n\n\n\nDữ liệu một biểu đồ con\nNếu bạn muốn có một hộp biểu đồ con chứa tất cả dữ liệu, hãy sao chép toàn bộ dữ liệu và coi các bản sao như một giá trị cho các biểu đồ con. Hàm “trợ giúp” CreateAllFacet() bên dưới có thể hỗ trợ việc này (nhờ bài đăng trên blog này). Khi nó được chạy, số hàng tăng gấp đôi và sẽ có một cột mới được gọi là facet, trong đó các hàng được sao chép sẽ có giá trị “tất cả” và các hàng ban đầu có giá trị ban đầu của cột phân chia. Bây giờ bạn chỉ cần phân chia cột facet .\nDưới đây là hàm trợ giúp. Chạy code này và nó sẽ luôn sẵn sàng để bạn sử dụng.\n\n# Define helper function\nCreateAllFacet &lt;- function(df, col){\n     df$facet &lt;- df[[col]]\n     temp &lt;- df\n     temp$facet &lt;- \"all\"\n     merged &lt;-rbind(temp, df)\n     \n     # ensure the facet value is a factor\n     merged[[col]] &lt;- as.factor(merged[[col]])\n     \n     return(merged)\n}\n\nBây giờ hãy áp dụng hàm trợ giúp cho bộ dữ liệu, trên cột age_cat:\n\n# Create dataset that is duplicated and with new column \"facet\" to show \"all\" age categories as another facet level\ncentral_data2 &lt;- CreateAllFacet(central_data, col = \"age_cat\") %&gt;%\n  \n  # set factor levels\n  mutate(facet = fct_relevel(facet, \"all\", \"0-4\", \"5-9\",\n                             \"10-14\", \"15-19\", \"20-29\",\n                             \"30-49\", \"50-69\", \"70+\"))\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `facet = fct_relevel(...)`.\nCaused by warning:\n! 1 unknown level in `f`: 70+\n\n# check levels\ntable(central_data2$facet, useNA = \"always\")\n\n\n  all   0-4   5-9 10-14 15-19 20-29 30-49 50-69  &lt;NA&gt; \n  454    84    84    82    58    73    57     7     9 \n\n\nNhững thay đổi đáng chú ý đối với lệnh ggplot() là:\n\nDữ liệu được sử dụng bây giờ là central_data2 (nhân đôi các hàng, với cột mới là “facet”)\nLabeller sẽ cần được cập nhật, nếu được sử dụng\n\nTùy chọn: để có các biểu đồ con xếp chồng lên nhau theo chiều dọc: cột chia được chuyển sang các hàng bên cạnh của phương trình và ở bên phải được thay thế bằng “.” (facet_wrap(facet~.)), và ncol = 1. Bạn cũng có thể cần điều chỉnh chiều rộng và chiều cao của ảnh biểu đồ đã lưu dưới dạng png (xem ggsave() trong chương Các mẹo với ggplot).\n\n\nggplot(central_data2) + \n  \n  # actual epicurves by group\n  geom_histogram(\n        mapping = aes(\n          x = date_onset,\n          group = age_cat,\n          fill = age_cat),  # arguments inside aes() apply by group\n        color = \"black\",    # arguments outside aes() apply to all data\n        \n        # histogram breaks\n        breaks = weekly_breaks_central)+    # pre-defined date vector (see top of ggplot section)\n                     \n  # Labels on x-axis\n  scale_x_date(\n    expand            = c(0,0),         # remove excess x-axis space below and after case bars\n    date_breaks       = \"2 months\",     # labels appear every 2 months\n    date_minor_breaks = \"1 month\",      # vertical lines appear every 1 month \n    label = scales::label_date_short())+ # label formatting\n  \n  # y-axis\n  scale_y_continuous(expand = c(0,0))+  # removes excess y-axis space between bottom of bars and the labels\n  \n  # aesthetic themes\n  theme_minimal()+                                           # a set of themes to simplify plot\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # caption on left side in italics\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\")+               \n  \n  # create facets\n  facet_wrap(facet~. ,                            # each plot is one value of facet\n             ncol = 1)+            \n\n  # labels\n  labs(title    = \"Weekly incidence of cases, by age category\",\n       subtitle = \"Subtitle\",\n       fill     = \"Age category\",                                      # provide new title for legend\n       x        = \"Week of symptom onset\",\n       y        = \"Weekly incident cases reported\",\n       caption  = stringr::str_glue(\"n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %&gt;% filter(is.na(date_onset)))} cases missing date of onset and not shown\"))",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Đường cong dịch bệnh</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.vn.html#dữ-liệu-dự-kiến",
    "href": "new_pages/epicurves.vn.html#dữ-liệu-dự-kiến",
    "title": "32  Đường cong dịch bệnh",
    "section": "32.3 Dữ liệu dự kiến",
    "text": "32.3 Dữ liệu dự kiến\nDữ liệu gần đây nhất được biểu thị trong đường cong dịch tễ nên được đánh dấu là dự kiến hoặc có thể báo cáo chậm trễ. Điều này có thể được thực hiện bằng cách thêm một đường thẳng đứng và/hoặc hình chữ nhật trong một số ngày cụ thể. Đây là hai tùy chọn:\n\nSử dụng annotate():\n\nĐể sử dụng dạng đường annotate(geom = \"segment\"). Cung cấp x, xend, y, và yend. Hiệu chỉnh kích thước, kiểu dòng (lty), và màu.\n\nĐể sử dụng dạng hình chữ nhật annotate(geom = \"rect\"). Cung cấp xmin/xmax/ymin/ymax. Hiệu chỉnh màu và hệ số alpha.\n\n\nNhóm dữ liệu theo trạng thái tạm thời và tô màu các cột đó theo cách khác nhau\n\nTHẬN TRỌNG: Bạn có thể thử hàm geom_rect() để vẽ hình chữ nhật, nhưng việc điều chỉnh độ trong suốt không khả thi trong bối cảnh cảnh bộ số liệu linelist. Hàm này sẽ phủ lên một hình chữ nhật cho mỗi hàng/quan sát!. Sử dụng hệ số alpha rất thấp (ví dụ: 0.01) hoặc một cách tiếp cận khác.\n\nSử dụng annotate()\n\nTrong annotate(geom = \"rect\"), đối số xmin và xmax cần được định dạng phân lớp ngày\n\nLưu ý rằng vì những dữ liệu này được tổng hợp thành các cột hàng tuần và cột cuối cùng kéo dài đến Thứ Hai sau điểm dữ liệu cuối cùng, vùng được tô bóng có thể bao gồm 4 tuần\n\nĐây là một ví dụ trực tuyến về annotate()\n\n\nggplot(central_data) + \n  \n  # histogram\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    breaks = weekly_breaks_central,   # pre-defined date vector - see top of ggplot section\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") +\n\n  # scales\n  scale_y_continuous(expand = c(0,0))+\n  scale_x_date(\n    expand = c(0,0),                   # remove excess x-axis space below and after case bars\n    date_breaks = \"1 month\",           # 1st of month\n    date_minor_breaks = \"1 month\",     # 1st of month\n    label = scales::label_date_short())+ # automatic label formatting\n  \n  # labels and theme\n  labs(\n    title = \"Using annotate()\\nRectangle and line showing that data from last 21-days are tentative\",\n    x = \"Week of symptom onset\",\n    y = \"Weekly case indicence\")+ \n  theme_minimal()+\n  \n  # add semi-transparent red rectangle to tentative data\n  annotate(\n    \"rect\",\n    xmin  = as.Date(max(central_data$date_onset, na.rm = T) - 21), # note must be wrapped in as.Date()\n    xmax  = as.Date(Inf),                                          # note must be wrapped in as.Date()\n    ymin  = 0,\n    ymax  = Inf,\n    alpha = 0.2,          # alpha easy and intuitive to adjust using annotate()\n    fill  = \"red\")+\n  \n  # add black vertical line on top of other layers\n  annotate(\n    \"segment\",\n    x     = max(central_data$date_onset, na.rm = T) - 21, # 21 days before last data\n    xend  = max(central_data$date_onset, na.rm = T) - 21, \n    y     = 0,         # line begins at y = 0\n    yend  = Inf,       # line to top of plot\n    size  = 2,         # line size\n    color = \"black\",\n    lty   = \"solid\")+   # linetype e.g. \"solid\", \"dashed\"\n\n  # add text in rectangle\n  annotate(\n    \"text\",\n    x = max(central_data$date_onset, na.rm = T) - 15,\n    y = 15,\n    label = \"Subject to reporting delays\",\n    angle = 90)\n\n\n\n\n\n\n\n\nĐường thẳng đứng màu đen có thể tạo ra với code bên dưới, nhưng sử dụng geom_vline(), bạn sẽ mất khả năng kiểm soát chiều cao:\n\ngeom_vline(xintercept = max(central_data$date_onset, na.rm = T) - 21,\n           size = 2,\n           color = \"black\")\n\n\n\nMàu cột\nMột cách tiếp cận thay thế có thể là điều chỉnh màu sắc hoặc cách hiển thị của chính các cột dữ liệu dự kiến. Bạn có thể tạo một cột mới trong giai đoạn chuẩn bị dữ liệu và sử dụng cột đó để nhóm dữ liệu, sao cho aes(fill = ) của dữ liệu tạm thời có thể có màu hoặc hệ số alpha khác với các cột khác.\n\n# add column\n############\nplot_data &lt;- central_data %&gt;% \n  mutate(tentative = case_when(\n    date_onset &gt;= max(date_onset, na.rm=T) - 7 ~ \"Tentative\", # tenative if in last 7 days\n    TRUE                                       ~ \"Reliable\")) # all else reliable\n\n# plot\n######\nggplot(plot_data, aes(x = date_onset, fill = tentative)) + \n  \n  # histogram\n  geom_histogram(\n    breaks = weekly_breaks_central,   # pre-defined data vector, see top of ggplot page\n    color = \"black\") +\n\n  # scales\n  scale_y_continuous(expand = c(0,0))+\n  scale_fill_manual(values = c(\"lightblue\", \"grey\"))+\n  scale_x_date(\n    expand = c(0,0),                   # remove excess x-axis space below and after case bars\n    date_breaks = \"3 weeks\",           # Monday every 3 weeks\n    date_minor_breaks = \"week\",        # Monday weeks \n    label = scales::label_date_short())+ # label formatting\n  \n  # labels and theme\n  labs(title = \"Show days that are tentative reporting\",\n    subtitle = \"\")+ \n  theme_minimal()+\n  theme(legend.title = element_blank())                 # remove title of legend",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Đường cong dịch bệnh</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.vn.html#nhãn-ngày-nhiều-cấp-độ",
    "href": "new_pages/epicurves.vn.html#nhãn-ngày-nhiều-cấp-độ",
    "title": "32  Đường cong dịch bệnh",
    "section": "32.4 Nhãn ngày nhiều cấp độ",
    "text": "32.4 Nhãn ngày nhiều cấp độ\nNếu bạn muốn phân nhiều cấp nhãn ngày (ví dụ: tháng và năm) mà không sao chép các cấp nhãn cấp độ thấp hơn, hãy xem xét một trong các cách tiếp cận bên dưới:\nHãy nhớ rằng - bạn có thể sử dụng các công cụ như \\n trong các đối số date_labels hoặc labels để đặt các phần của mỗi nhãn trên một dòng mới bên dưới. Tuy nhiên, đoạn code dưới đây giúp bạn thực hiện nhiều năm hoặc tháng (ví dụ) ở dòng thấp hơn và chỉ một lần. Một số lưu ý về code bên dưới:\n\nSố lượng ca bệnh được tổng hợp thành các tuần vì lý do thẩm mỹ. Xem chương Đường cong dịch bệnh (tab dữ liệu tổng hợp) để biết chi tiết.\n\nMột miền geom_area() được sử dụng thay vì một histogram, vì phương pháp tiếp cận chia biểu đồ dưới đây không hoạt động tốt với histogram.\n\nTổng hợp dữ đếm hàng tuần\n\n# Create dataset of case counts by week\n#######################################\ncentral_weekly &lt;- linelist %&gt;%\n  filter(hospital == \"Central Hospital\") %&gt;%   # filter linelist\n  mutate(week = lubridate::floor_date(date_onset, unit = \"weeks\")) %&gt;%  \n  count(week) %&gt;%                              # summarize weekly case counts\n  drop_na(week) %&gt;%                            # remove cases with missing onset_date\n  complete(                                    # fill-in all weeks with no cases reported\n    week = seq.Date(\n      from = min(week),   \n      to   = max(week),\n      by   = \"week\"),\n    fill = list(n = 0))                        # convert new NA values to 0 counts\n\nVẽ biểu đồ\n\n# plot with box border on year\n##############################\nggplot(central_weekly) +\n  geom_area(aes(x = week, y = n),    # make line, specify x and y\n            stat = \"identity\") +             # because line height is count number\n  scale_x_date(date_labels=\"%b\",             # date label format show month \n               date_breaks=\"month\",          # date labels on 1st of each month\n               expand=c(0,0)) +              # remove excess space on each end\n  scale_y_continuous(\n    expand  = c(0,0))+                       # remove excess space below x-axis\n  facet_grid(~lubridate::year(week), # facet on year (of Date class column)\n             space=\"free_x\",                \n             scales=\"free_x\",                # x-axes adapt to data range (not \"fixed\")\n             switch=\"x\") +                   # facet labels (year) on bottom\n  theme_bw() +\n  theme(strip.placement = \"outside\",         # facet labels placement\n        strip.background = element_rect(fill = NA, # facet labels no fill grey border\n                                        colour = \"grey50\"),\n        panel.spacing = unit(0, \"cm\"))+      # no space between facet panels\n  labs(title = \"Nested year labels, grey label border\")\n\n\n\n\n\n\n\n# plot with no box border on year\n#################################\nggplot(central_weekly,\n       aes(x = week, y = n)) +              # establish x and y for entire plot\n  geom_line(stat = \"identity\",              # make line, line height is count number\n            color = \"#69b3a2\") +            # line color\n  geom_point(size=1, color=\"#69b3a2\") +     # make points at the weekly data points\n  geom_area(fill = \"#69b3a2\",               # fill area below line\n            alpha = 0.4)+                   # fill transparency\n  scale_x_date(date_labels=\"%b\",            # date label format show month \n               date_breaks=\"month\",         # date labels on 1st of each month\n               expand=c(0,0)) +             # remove excess space\n  scale_y_continuous(\n    expand  = c(0,0))+                      # remove excess space below x-axis\n  facet_grid(~lubridate::year(week),        # facet on year (of Date class column)\n             space=\"free_x\",                \n             scales=\"free_x\",               # x-axes adapt to data range (not \"fixed\")\n             switch=\"x\") +                  # facet labels (year) on bottom\n  theme_bw() +\n  theme(strip.placement = \"outside\",                     # facet label placement\n          strip.background = element_blank(),            # no facet lable background\n          panel.grid.minor.x = element_blank(),          \n          panel.border = element_rect(colour=\"grey40\"),  # grey border to facet PANEL\n          panel.spacing=unit(0,\"cm\"))+                   # No space between facet panels\n  labs(title = \"Nested year labels - points, shaded, no label border\")\n\n\n\n\n\n\n\n\nCác kỹ thuật trên được điều chỉnh từ đây và bài đăng này trên stackoverflow.com.",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Đường cong dịch bệnh</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.vn.html#trục-kép",
    "href": "new_pages/epicurves.vn.html#trục-kép",
    "title": "32  Đường cong dịch bệnh",
    "section": "32.5 Trục kép",
    "text": "32.5 Trục kép\nMặc dù có những cuộc thảo luận gay gắt về tính hợp lệ của trục kép trong cộng đồng về trực quan hóa dữ liệu, nhiều chuyên gia dịch tễ vẫn muốn nhìn nhận biểu đồ đường cong dịch bệnh hoặc biểu đồ tương tự với phần trăm trên trục thứ hai. Điều này được thảo luận nhiều hơn trong chương Các mẹo với ggplot, nhưng một ví dụ sử dụng phương pháp cowplot được trình bày bên dưới:\n\nHai biểu đồ riêng biệt được tạo, và sau đó được kết hợp với package cowplot.\n\nCác biểu đồ phải có chính xác cùng trục x (đã đặt giới hạn), nếu không dữ liệu và nhãn sẽ không được căn chỉnh phù hợp\n\nMỗi biểu đồ sử dụng theme_cowplot() và một biểu đồ có trục y được di chuyển sang phía bên phải của biểu đồ\n\n\n#load package\npacman::p_load(cowplot)\n\n# Make first plot of epicurve histogram\n#######################################\nplot_cases &lt;- linelist %&gt;% \n  \n  # plot cases per week\n  ggplot()+\n  \n  # create histogram  \n  geom_histogram(\n    \n    mapping = aes(x = date_onset),\n    \n    # bin breaks every week beginning monday before first case, going to monday after last case\n    breaks = weekly_breaks_all)+  # pre-defined vector of weekly dates (see top of ggplot section)\n        \n  # specify beginning and end of date axis to align with other plot\n  scale_x_date(\n    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # min/max of the pre-defined weekly breaks of histogram\n  \n  # labels\n  labs(\n      y = \"Daily cases\",\n      x = \"Date of symptom onset\"\n    )+\n  theme_cowplot()\n\n\n# make second plot of percent died per week\n###########################################\nplot_deaths &lt;- linelist %&gt;%                        # begin with linelist\n  group_by(week = floor_date(date_onset, \"week\")) %&gt;%  # create week column\n  \n  # summarise to get weekly percent of cases who died\n  summarise(n_cases = n(),\n            died = sum(outcome == \"Death\", na.rm=T),\n            pct_died = 100*died/n_cases) %&gt;% \n  \n  # begin plot\n  ggplot()+\n  \n  # line of weekly percent who died\n  geom_line(                                # create line of percent died\n    mapping = aes(x = week, y = pct_died),  # specify y-height as pct_died column\n    stat = \"identity\",                      # set line height to the value in pct_death column, not the number of rows (which is default)\n    size = 2,\n    color = \"black\")+\n  \n  # Same date-axis limits as the other plot - perfect alignment\n  scale_x_date(\n    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # min/max of the pre-defined weekly breaks of histogram\n  \n  \n  # y-axis adjustments\n  scale_y_continuous(                # adjust y-axis\n    breaks = seq(0,100, 10),         # set break intervals of percent axis\n    limits = c(0, 100),              # set extent of percent axis\n    position = \"right\")+             # move percent axis to the right\n  \n  # Y-axis label, no x-axis label\n  labs(x = \"\",\n       y = \"Percent deceased\")+      # percent axis label\n  \n  theme_cowplot()                   # add this to make the two plots merge together nicely\n\nBây giờ sử dụng cowplot để chồng lên hai biểu đồ. Sự chú ý đã được tập trung vào việc căn chỉnh trục x, cạnh của trục y và việc sử dụng theme_cowplot().\n\naligned_plots &lt;- cowplot::align_plots(plot_cases, plot_deaths, align=\"hv\", axis=\"tblr\")\nggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Đường cong dịch bệnh</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.vn.html#số-mới-mắc-tích-lũy",
    "href": "new_pages/epicurves.vn.html#số-mới-mắc-tích-lũy",
    "title": "32  Đường cong dịch bệnh",
    "section": "32.6 Số mới mắc tích lũy",
    "text": "32.6 Số mới mắc tích lũy\nLưu ý: Nếu sử dụng incidence2, hãy xem chương về cách bạn có thể tính số mới mắc tích lũy bằng một hàm đơn giản. Chương này sẽ đề cập đến cách tính số mới mắc tích lũy và vẽ biểu đồ bằng ggplot().\nNếu bắt đầu bằng bộ số liệu linelist, hãy tạo một cột mới chứa số ca bệnh tích lũy mỗi ngày trong đợt bùng phát bằng cách sử dụng cumsum() từ base R:\n\ncumulative_case_counts &lt;- linelist %&gt;% \n  count(date_onset) %&gt;%                # count of rows per day (returned in column \"n\")   \n  mutate(                         \n    cumulative_cases = cumsum(n)       # new column of the cumulative number of rows at each date\n    )\n\n10 hàng đầu tiên được hiển thị bên dưới:\n\n\n\n\n\n\nSau đó, cột tích lũy này có thể được vẽ dựa trên date_onset, sử dụng geom_line():\n\nplot_cumulative &lt;- ggplot()+\n  geom_line(\n    data = cumulative_case_counts,\n    aes(x = date_onset, y = cumulative_cases),\n    size = 2,\n    color = \"blue\")\n\nplot_cumulative\n\n\n\n\n\n\n\n\nNó cũng có thể được phủ đè lên đường cong dịch bệnh, với trục kép bằng cách sử dụng phương pháp cowplot được mô tả ở trên và trong chương Các mẹo với ggplot:\n\n#load package\npacman::p_load(cowplot)\n\n# Make first plot of epicurve histogram\nplot_cases &lt;- ggplot()+\n  geom_histogram(          \n    data = linelist,\n    aes(x = date_onset),\n    binwidth = 1)+\n  labs(\n    y = \"Daily cases\",\n    x = \"Date of symptom onset\"\n  )+\n  theme_cowplot()\n\n# make second plot of cumulative cases line\nplot_cumulative &lt;- ggplot()+\n  geom_line(\n    data = cumulative_case_counts,\n    aes(x = date_onset, y = cumulative_cases),\n    size = 2,\n    color = \"blue\")+\n  scale_y_continuous(\n    position = \"right\")+\n  labs(x = \"\",\n       y = \"Cumulative cases\")+\n  theme_cowplot()+\n  theme(\n    axis.line.x = element_blank(),\n    axis.text.x = element_blank(),\n    axis.title.x = element_blank(),\n    axis.ticks = element_blank())\n\nBây giờ sử dụng cowplot để chồng lên hai biểu đồ. Sự chú ý đã được tập trung vào việc căn chỉnh trục x, cạnh của trục y và việc sử dụng theme_cowplot().\n\naligned_plots &lt;- cowplot::align_plots(plot_cases, plot_cumulative, align=\"hv\", axis=\"tblr\")\nggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Đường cong dịch bệnh</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.vn.html#nguồn-tham-khảo",
    "href": "new_pages/epicurves.vn.html#nguồn-tham-khảo",
    "title": "32  Đường cong dịch bệnh",
    "section": "32.7 Nguồn tham khảo",
    "text": "32.7 Nguồn tham khảo",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Đường cong dịch bệnh</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.vn.html",
    "href": "new_pages/age_pyramid.vn.html",
    "title": "33  Tháp dân số và thang đo Likert",
    "section": "",
    "text": "33.1 Chuẩn bị",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Tháp dân số và thang đo Likert</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.vn.html#chuẩn-bị",
    "href": "new_pages/age_pyramid.vn.html#chuẩn-bị",
    "title": "33  Tháp dân số và thang đo Likert",
    "section": "",
    "text": "Gọi package\nĐoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R.\n\npacman::p_load(rio,       # to import data\n               here,      # to locate files\n               tidyverse, # to clean, handle, and plot the data (includes ggplot2 package)\n               apyramid,  # a package dedicated to creating age pyramids\n               janitor,   # tables and cleaning data\n               stringr)   # working with strings for titles, captions, etc.\n\n\n\nNhập dữ liệu\nĐể bắt đầu, chúng ta nhập bộ dữ liệu có tên linelist đã làm sạch bao gồm các trường hợp từ vụ dịch Ebola mô phỏng. Để tiện theo dõi, bấm để tải dữ liệu linelist “đã được làm sạch”  (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương Nhập xuất dữ liệu để biết thêm chi tiết.\n\n# import case linelist \nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\n50 hàng đầu tiên của bộ dữ liệu được hiển thị như bên dưới.\n\n\n\n\n\n\n\n\nLàm sạch\nĐể tạo tháp nhân khẩu học theo độ tuổi/giới tính truyền thống, trước tiên dữ liệu phải được làm sạch theo những cách sau:\n\nCột gender phải được làm sạch.\n\nTùy thuộc vào phương pháp của bạn, độ tuổi phải được lưu trữ dưới dạng số hoặc trong cột age category.\n\nNếu sử dụng nhóm tuổi, các giá trị trong cột phải được sắp xếp thứ tự, hoặc là thứ tự chữ-số mặc định hoặc được đặt có chủ ý bằng cách chuyển đổi thành kiểu factor.\nSau đây chúng ta sử dụng hàm tabyl() từ package janitor để khảo sát hai cột gender và age_cat5.\n\nlinelist %&gt;% \n  tabyl(age_cat5, gender)\n\n age_cat5   f   m NA_\n      0-4 640 416  39\n      5-9 641 412  42\n    10-14 518 383  40\n    15-19 359 364  20\n    20-24 305 316  17\n    25-29 163 259  13\n    30-34 104 213   9\n    35-39  42 157   3\n    40-44  25 107   1\n    45-49   8  80   5\n    50-54   2  37   1\n    55-59   0  30   0\n    60-64   0  12   0\n    65-69   0  12   1\n    70-74   0   4   0\n    75-79   0   0   1\n    80-84   0   1   0\n      85+   0   0   0\n     &lt;NA&gt;   0   0  86\n\n\nChúng ta có thể vẽ biểu đồ histogram đối với cột age để chắc chắn rằng nó đã được làm sạch và phân loại chính xác:\n\nhist(linelist$age)",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Tháp dân số và thang đo Likert</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.vn.html#apyramid-package",
    "href": "new_pages/age_pyramid.vn.html#apyramid-package",
    "title": "33  Tháp dân số và thang đo Likert",
    "section": "33.2 apyramid package",
    "text": "33.2 apyramid package\nPackage apyramid là một sản phẩm của dự án R4Epis. Bạn có thể đọc thêm về package này tại đây. Nó cho phép bạn nhanh chóng tạo một tháp tuổi. Để tùy biến đẹp hơn, xem mục sử dụng ggplot(). Bạn có thể đọc thêm về package apyramid tại trang Help bằng cách nhập ?age_pyramid vào R console.\n\nDữ liệu Linelist\nSử dụng dữ liệu linelist đã làm sạch, chúng ta có thể tạo một tháp tuổi chỉ với một lệnh age_pyramid() cơ bản. Trong lệnh này:\n\nĐối số data = sử dụng bộ dữ liệu linelist\n\nĐối số age_group = (trục y) lấy thông tin từ cột nhóm tuổi (trong ngoặc kép)\n\nĐối số split_by = (trục x) lấy thông tin từ cột giới\n\n\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\")\n\n\n\n\n\n\n\n\nTháp có thể hiện thị phần trăm của tất cả các trường hợp trên trục x, thay vì chỉ số lượng, bằng cách thêm proportional = TRUE.\n\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\",\n                      proportional = TRUE)\n\n\n\n\n\n\n\n\nKhi sử dụng package agepyramid, nếu cột được phân chia split_by là nhị phân (vd. nam/nữ, hoặc có/không), thì kết quả sẽ xuất hiện dưới dạng một kim tự tháp. Tuy nhiên nếu có nhiều hơn hai giá trị trong cột được phân chia split_by (không bao gồm NA), kim tự tháp sẽ xuất hiện dưới dạng nhiều biểu đồ cột ngang với các thanh màu xám trong “background” cho biết phạm vi của dữ liệu không có mặt cho nhóm tuổi đó. Trong trường hợp này, giá trị của split_by = sẽ xuất hiện dưới dạng nhãn ở đỉnh mỗi biểu đồ. Chẳng hạn, bên dưới là những gì xảy ra nếu split_by = được chỉ định tới cột hospital.\n\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"hospital\")  \n\n\n\n\n\n\n\n\n\nGiá trị Missing\nCác hàng chứa giá trị missing NA của các cột split_by = hoặc age_group =, nếu được mã hóa là NA, sẽ không tự động kích hoạt việc phân chia biểu đồ như được hiển thị ở trên. Mặc định những hàng này không được hiển thị. Tuy nhiên, bạn có thể chỉ định các giá trị missing hiển thị, trong một biểu đồ liền kề và dưới dạng một nhóm tuổi riêng biệt, bằng cách chỉ định na.rm = FALSE.\n\napyramid::age_pyramid(data = linelist,\n                      age_group = \"age_cat5\",\n                      split_by = \"gender\",\n                      na.rm = FALSE)         # show patients missing age or gender\n\n\n\n\n\n\n\n\n\n\nTỷ lệ, màu sắc, & thẩm mỹ\nTheo mặc định, các cột hiển thị số lượng (không phải %), đường gạch ngang giữa cho mỗi nhóm được hiển thị và màu sắc là xanh lục/tím. Các thông số này có thể được điều chỉnh, như được trình bày dưới đây:\nBạn cũng có thể thêm các lệnh ggplot() vào biểu đồ bằng cách sử dụng các cú pháp chuẩn của ggplot() “+” , chẳng hạn như chủ đề trang trí và điều chỉnh nhãn:\n\napyramid::age_pyramid(\n  data = linelist,\n  age_group = \"age_cat5\",\n  split_by = \"gender\",\n  proportional = TRUE,              # show percents, not counts\n  show_midpoint = FALSE,            # remove bar mid-point line\n  #pal = c(\"orange\", \"purple\")      # can specify alt. colors here (but not labels)\n  )+                 \n  \n  # additional ggplot commands\n  theme_minimal()+                               # simplfy background\n  scale_fill_manual(                             # specify colors AND labels\n    values = c(\"orange\", \"purple\"),              \n    labels = c(\"m\" = \"Male\", \"f\" = \"Female\"))+\n  labs(y = \"Percent of all cases\",              # note x and y labs are switched\n       x = \"Age categories\",                          \n       fill = \"Gender\", \n       caption = \"My data source and caption here\",\n       title = \"Title of my plot\",\n       subtitle = \"Subtitle with \\n a second line...\")+\n  theme(\n    legend.position = \"bottom\",                          # legend to bottom\n    axis.text = element_text(size = 10, face = \"bold\"),  # fonts/sizes\n    axis.title = element_text(size = 12, face = \"bold\"))\n\n\n\n\n\n\n\n\n\n\n\nDữ liệu được tổng hợp\nVí dụ bên trên giả định rằng dữ liệu của bạn có định dạng mỗi hàng cho một quan sát. Nếu dữ liệu của bạn đã được tổng hợp thành số lượng theo nhóm tuổi, bạn vẫn có thể sử dụng package apyramid, như được trình bày dưới đây.\nĐể minh họa, chúng ta sẽ tổng hợp dữ liệu linelist theo số lượng đối với nhóm tuổi và giới, dưới định dạng “ngang”. Việc này sẽ mô phỏng như thể dữ liệu ban đầu của bạn đang được trình bày dưới dạng số lượng. Tìm hiểu thêm về Nhóm dữ liệu và Xoay trục dữ liệu ở các chương tương ứng.\n\ndemo_agg &lt;- linelist %&gt;% \n  count(age_cat5, gender, name = \"cases\") %&gt;% \n  pivot_wider(\n    id_cols = age_cat5,\n    names_from = gender,\n    values_from = cases) %&gt;% \n  rename(`missing_gender` = `NA`)\n\n…lệnh trên sẽ khiến bộ dữ liệu trông như thế này: bao gồm các cột nhóm tuổi, số lượng nam, nữ, và missing.\n\n\n\n\n\n\nĐể thiết lập chủ đề cho tháp tuổi, chúng ta sẽ xoay trục dữ liệu sang dạng “dọc” bằng hàm pivot_longer() trong package dplyr. Đó là bởi vì ggplot() thường thích dữ liệu được bố trí ở dạng “dọc”, và package apyramid đang sử dụng ggplot().\n\n# pivot the aggregated data into long format\ndemo_agg_long &lt;- demo_agg %&gt;% \n  pivot_longer(\n    col = c(f, m, missing_gender),            # cols to elongate\n    names_to = \"gender\",                # name for new col of categories\n    values_to = \"counts\") %&gt;%           # name for new col of counts\n  mutate(\n    gender = na_if(gender, \"missing_gender\")) # convert \"missing_gender\" to NA\n\n\n\n\n\n\n\nSau đó sử dụng các đối số split_by = và count = của hàm age_pyramid() để chỉ định các cột tương ứng trong bộ dữ liệu:\n\napyramid::age_pyramid(data = demo_agg_long,\n                      age_group = \"age_cat5\",# column name for age category\n                      split_by = \"gender\",   # column name for gender\n                      count = \"counts\")      # column name for case counts\n\n\n\n\n\n\n\n\nLưu ý rằng ở trên, thứ tự của “m” và “f” là khác nhau (tháp bị đảo ngược). Để điều chỉnh thự tự, bạn phải định nghĩa lại cột giới trong dữ liệu được tổng hợp thành kiểu Factor và sắp xếp thứ tự như mong muốn. Xem chương Factors.",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Tháp dân số và thang đo Likert</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.vn.html#demo_pyr_gg",
    "href": "new_pages/age_pyramid.vn.html#demo_pyr_gg",
    "title": "33  Tháp dân số và thang đo Likert",
    "section": "33.3 ggplot()",
    "text": "33.3 ggplot()\nSử dụng ggplot() cho phép bạn xây dựng tháp tuổi một cách linh hoạt hơn, nhưng đòi hỏi nhiều nỗ lực và hiểu biết hơn về cách hoạt động của ggplot(). Việc vô tình mắc sai lầm cũng dễ dàng hơn.\nĐể sử dụng ggplot() tạo tháp nhân khẩu học, bạn tạo hai biểu đồ cột (cho từng giới tính), chuyển đổi các giá trị trong một biểu đồ thành âm và cuối cùng lật các trục x và y để hiển thị các biểu đồ cột theo chiều dọc, xuất phát điểm của chúng gặp nhau ở chính giữa biểu đồ.\n\nChuẩn bị\nCách tiếp cận này sử dụng cột tuổi ở dạng numeric, không phải cột nhóm tuổi age_cat5 dạng categorical. Vì vậy, chúng ta cần kiểm tra để đảm bảo rằng kiểu của cột này thực sự là dạng số.\n\nclass(linelist$age)\n\n[1] \"numeric\"\n\n\nBạn có thể sử dụng logic tương tự như dưới đây để xây dựng một kim tự tháp từ dữ liệu dạng danh mục sử dụng geom_col() thay vì geom_histogram().\n\n\n\nXây dựng biểu đồ\nTrước tiên, hãy hiểu rằng để tạo một kim tự tháp như vậy bằng cách sử dụng ggplot(), cách tiếp cận sẽ là như sau:\n\nBên trong hàm ggplot(), tạo hai biểu đồ histograms sử dụng cột tuổi dạng numeric, tương ứng cho hai nhóm (trong trường hợp này là giới nam và nữ). Để thực hiện việc này, dữ liệu cho mỗi biểu đồ được chỉ định trong các lệnh geom_histogram() tương ứng của chúng, với các bộ lọc tương ứng được áp dụng cho bộ dữ liệu linelist.\nMột biểu đồ sẽ có các giá trị dương, trong khi biểu đồ kia sẽ có các giá trị được chuyển thành giá trị âm - điều này tạo ra “kim tự tháp” với giá trị 0 ở giữa biểu đồ. Các giá trị âm được tạo bằng cách sử dụng thuật ngữ đặc biệt của ggplot2 là ..count.. và nhân với -1.\nLệnh coord_flip() chuyển trục X và Y, dẫn đến các đồ thị quay dọc và tạo ra hình kim tự tháp.\nCuối cùng, các nhãn giá trị trục đếm phải được thay đổi để chúng xuất hiện dưới dạng số “dương” trên cả hai mặt của kim tự tháp (mặc dù các giá trị thực tế ở một mặt là âm).\n\nMột phiên bản đơn giản của biểu đồ, sử dụng hàm geom_histogram(), như dưới đây:\n\n  # begin ggplot\n  ggplot(mapping = aes(x = age, fill = gender)) +\n  \n  # female histogram\n  geom_histogram(data = linelist %&gt;% filter(gender == \"f\"),\n                 breaks = seq(0,85,5),\n                 colour = \"white\") +\n  \n  # male histogram (values converted to negative)\n  geom_histogram(data = linelist %&gt;% filter(gender == \"m\"),\n                 breaks = seq(0,85,5),\n                 mapping = aes(y = ..count..*(-1)),\n                 colour = \"white\") +\n  \n  # flip the X and Y axes\n  coord_flip() +\n  \n  # adjust counts-axis scale\n  scale_y_continuous(limits = c(-600, 900),\n                     breaks = seq(-600,900,100),\n                     labels = abs(seq(-600, 900, 100)))\n\n\n\n\n\n\n\n\nNGUY HIỂM: Nếu như giới hạn của trục counts được thiết lập quá nhỏ, và cột số lượng vượt quá giá trị đó, cột sẽ biến mất hoàn toàn hoặc bị rút ngắn một cách không tự nhiên! Hãy chú ý điều này nếu dữ liệu phân tích thường xuyên được cập nhật. Có thể ngăn chặn điều này bằng cách tự động điều chỉnh các giới hạn trục count cho phù hợp với dữ liệu của bạn, như dưới đây.\nCó nhiều thứ bạn có thể thay đổi/thêm vào phiên bản đơn giản này, bao gồm:\n\nTự động điều chỉnh tỷ lệ trục count cho dữ liệu của bạn (tránh các lỗi được thảo luận trong cảnh báo bên dưới)\n\nChỉ định màu sắc và nhãn chú giải một cách thủ công\n\nChuyển đổi số lượng thành tỷ lệ phần trăm\nĐể chuyển đổi số lượng thành phần trăm (của tổng số), hãy thực hiện điều này với dữ liệu của bạn trước khi vẽ biểu đồ. Dưới đây, chúng ta lấy số lượng của age-gender, sau đó ungroup(), và tiếp tục mutate() để tạo cột phần trăm mới. Nếu bạn muốn phần trăm theo giới tính, hãy bỏ qua bước hủy nhóm.\n\n# create dataset with proportion of total\npyramid_data &lt;- linelist %&gt;%\n  count(age_cat5,\n        gender,\n        name = \"counts\") %&gt;% \n  ungroup() %&gt;%                 # ungroup so percents are not by group\n  mutate(percent = round(100*(counts / sum(counts, na.rm=T)), digits = 1), \n         percent = case_when(\n            gender == \"f\" ~ percent,\n            gender == \"m\" ~ -percent,     # convert male to negative\n            TRUE          ~ NA_real_))    # NA val must by numeric as well\n\nQuan trọng là, chúng ta lưu các giá trị lớn nhất vầ nhỏ nhất để chúng ta biết giới hạn của thang đo. Chúng sẽ được sử dụng trong lệnh ggplot() dưới đây.\n\nmax_per &lt;- max(pyramid_data$percent, na.rm=T)\nmin_per &lt;- min(pyramid_data$percent, na.rm=T)\n\nmax_per\n\n[1] 10.9\n\nmin_per\n\n[1] -7.1\n\n\nCuối cùng, chúng ta dùng hàm ggplot() trên dữ liệu phần trăm. Chúng ta chỉ rõ scale_y_continuous() để mở rộng độ dài được xác định trước theo mỗi hướng (dương và “âm”). Chúng ta sử dụng hàm floor() vả ceiling() để làm tròn số thập phân theo cách thích hợp (làm tròn xuống hoặc lên).\n\n# begin ggplot\n  ggplot()+  # default x-axis is age in years;\n\n  # case data graph\n  geom_col(data = pyramid_data,\n           mapping = aes(\n             x = age_cat5,\n             y = percent,\n             fill = gender),         \n           colour = \"white\")+       # white around each bar\n  \n  # flip the X and Y axes to make pyramid vertical\n  coord_flip()+\n  \n\n  # adjust the axes scales\n  # scale_x_continuous(breaks = seq(0,100,5), labels = seq(0,100,5)) +\n  scale_y_continuous(\n    limits = c(min_per, max_per),\n    breaks = seq(from = floor(min_per),                # sequence of values, by 2s\n                 to = ceiling(max_per),\n                 by = 2),\n    labels = paste0(abs(seq(from = floor(min_per),     # sequence of absolute values, by 2s, with \"%\"\n                            to = ceiling(max_per),\n                            by = 2)),\n                    \"%\"))+  \n\n  # designate colors and legend labels manually\n  scale_fill_manual(\n    values = c(\"f\" = \"orange\",\n               \"m\" = \"darkgreen\"),\n    labels = c(\"Female\", \"Male\")) +\n  \n  # label values (remember X and Y flipped now)\n  labs(\n    title = \"Age and gender of cases\",\n    x = \"Age group\",\n    y = \"Percent of total\",\n    fill = NULL,\n    caption = stringr::str_glue(\"Data are from linelist \\nn = {nrow(linelist)} (age or sex missing for {sum(is.na(linelist$gender) | is.na(linelist$age_years))} cases) \\nData as of: {format(Sys.Date(), '%d %b %Y')}\")) +\n  \n  # display themes\n  theme(\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    axis.line = element_line(colour = \"black\"),\n    plot.title = element_text(hjust = 0.5), \n    plot.caption = element_text(hjust=0, size=11, face = \"italic\")\n    )\n\n\n\n\n\n\n\n\n\n\n\nSo sánh với đường cơ sở\nWith the flexibility of ggplot(), you can have a second layer of bars in the background that represent the “true” or “baseline” population pyramid. This can provide a nice visualization to compare the observed with the baseline.\nVới sự linh hoạt của ggplot(), bạn có thể có lớp thanh thứ hai trong nền đại diện cho tháp dân số “chuẩn” hoặc “đường cơ sở”. Điều này có thể cung cấp khả năng trực quan hóa tốt để so sánh những gì quan sát được với đường cơ sở.\nNhập và xem dữ liệu dân số (xem chương [Tải sách và dữ liệu]):\n\n# import the population demographics data\npop &lt;- rio::import(\"country_demographics.csv\")\n\n\n\n\n\n\n\nĐầu tiên là một số bước quản lý dữ liệu:\nỞ đây chúng ta sắp xếp lại thứ tự của các danh mục tuổi mà chúng ta muốn chúng xuất hiện. Do một số điểm khác biệt trong cách thực thi ggplot(), trong trường hợp cụ thể này, dễ dàng nhất là lưu trữ chúng dưới dạng vectơ ký tự và sử dụng chúng sau này trong hàm vẽ đồ thị.\n\n# record correct age cat levels\nage_levels &lt;- c(\"0-4\",\"5-9\", \"10-14\", \"15-19\", \"20-24\",\n                \"25-29\",\"30-34\", \"35-39\", \"40-44\", \"45-49\",\n                \"50-54\", \"55-59\", \"60-64\", \"65-69\", \"70-74\",\n                \"75-79\", \"80-84\", \"85+\")\n\nKết hợp dữ liệu quần thể và dữ liệu trường hợp thông qua hàm bind_rows() của package dplyr:\n\nTrước tiên, hãy đảm bảo hai bộ dữ liệu có tên cột giống nhau, các giá trị nhóm tuổi và giá trị giới tính\n\nLàm cho chúng có cấu trúc dữ liệu giống nhau: cột nhóm tuổi, giới tính, số lượng và phần trăm tổng số\nGắn chúng lại với nhau, một bộ dữ liệu này ở trên bộ dữ liệu kia (bind_rows())\n\n\n# create/transform populaton data, with percent of total\n########################################################\npop_data &lt;- pop %&gt;% \n  pivot_longer(      # pivot gender columns longer\n    cols = c(m, f),\n    names_to = \"gender\",\n    values_to = \"counts\") %&gt;% \n  \n  mutate(\n    percent  = round(100*(counts / sum(counts, na.rm=T)),1),  # % of total\n    percent  = case_when(                                                        \n     gender == \"f\" ~ percent,\n     gender == \"m\" ~ -percent,               # if male, convert % to negative\n     TRUE          ~ NA_real_))\n\nXem lại bộ dữ liệu dân số đã thay đổi\n\n\n\n\n\n\nBây giờ thực hiện tương tự cho bộ linelist. Sẽ hơi khác một chút bởi vì nó bắt đầu với các trường hợp theo hàng, không phải số lượng.\n\n# create case data by age/gender, with percent of total\n#######################################################\ncase_data &lt;- linelist %&gt;%\n  count(age_cat5, gender, name = \"counts\") %&gt;%  # counts by age-gender groups\n  ungroup() %&gt;% \n  mutate(\n    percent = round(100*(counts / sum(counts, na.rm=T)),1),  # calculate % of total for age-gender groups\n    percent = case_when(                                     # convert % to negative if male\n      gender == \"f\" ~ percent,\n      gender == \"m\" ~ -percent,\n      TRUE          ~ NA_real_))\n\nXem lại bộ dữ liệu trường hợp đã thay đổi\n\n\n\n\n\n\nBây giờ hai data frame sẽ được kết hợp, cái này ở trên cái kia (chúng có cùng tên cột). Chúng ta có thể “đặt tên” cho từng data frame, và sử dụng đối số .id = để tạo một cột mới “data_source” sẽ cho biết dữ liệu có nguồn gốc từ data frame nào. Chúng tôi có thể sử dụng cột này để lọc với hàm ggplot().\n\n# combine case and population data (same column names, age_cat values, and gender values)\npyramid_data &lt;- bind_rows(\"cases\" = case_data, \"population\" = pop_data, .id = \"data_source\")\n\nLưu trữ các giá trị phần trăm tối đa và tối thiểu, được sử dụng trong hàm vẽ biểu đồ để xác định phạm vi của biểu đồ (và không cắt ngắn bất kỳ cột nào!)\n\n# Define extent of percent axis, used for plot limits\nmax_per &lt;- max(pyramid_data$percent, na.rm=T)\nmin_per &lt;- min(pyramid_data$percent, na.rm=T)\n\nBây giờ biểu đồ được tạo bởi ggplot() có:\n\nMột biểu đồ cột ngang của dữ liệu dan số (rộng hơn, trong suốt)\nMột biểu đồ cột ngang của dữ liệu các trường hợp (nhỏ hơn, đậm hơn)\n\n\n# begin ggplot\n##############\nggplot()+  # default x-axis is age in years;\n\n  # population data graph\n  geom_col(\n    data = pyramid_data %&gt;% filter(data_source == \"population\"),\n    mapping = aes(\n      x = age_cat5,\n      y = percent,\n      fill = gender),\n    colour = \"black\",                               # black color around bars\n    alpha = 0.2,                                    # more transparent\n    width = 1)+                                     # full width\n  \n  # case data graph\n  geom_col(\n    data = pyramid_data %&gt;% filter(data_source == \"cases\"), \n    mapping = aes(\n      x = age_cat5,                               # age categories as original X axis\n      y = percent,                                # % as original Y-axis\n      fill = gender),                             # fill of bars by gender\n    colour = \"black\",                               # black color around bars\n    alpha = 1,                                      # not transparent \n    width = 0.3)+                                   # half width\n  \n  # flip the X and Y axes to make pyramid vertical\n  coord_flip()+\n  \n  # manually ensure that age-axis is ordered correctly\n  scale_x_discrete(limits = age_levels)+     # defined in chunk above\n  \n  # set percent-axis \n  scale_y_continuous(\n    limits = c(min_per, max_per),                                          # min and max defined above\n    breaks = seq(floor(min_per), ceiling(max_per), by = 2),                # from min% to max% by 2 \n    labels = paste0(                                                       # for the labels, paste together... \n              abs(seq(floor(min_per), ceiling(max_per), by = 2)), \"%\"))+                                                  \n\n  # designate colors and legend labels manually\n  scale_fill_manual(\n    values = c(\"f\" = \"orange\",         # assign colors to values in the data\n               \"m\" = \"darkgreen\"),\n    labels = c(\"f\" = \"Female\",\n               \"m\"= \"Male\"),      # change labels that appear in legend, note order\n  ) +\n\n  # plot labels, titles, caption    \n  labs(\n    title = \"Case age and gender distribution,\\nas compared to baseline population\",\n    subtitle = \"\",\n    x = \"Age category\",\n    y = \"Percent of total\",\n    fill = NULL,\n    caption = stringr::str_glue(\"Cases shown on top of country demographic baseline\\nCase data are from linelist, n = {nrow(linelist)}\\nAge or gender missing for {sum(is.na(linelist$gender) | is.na(linelist$age_years))} cases\\nCase data as of: {format(max(linelist$date_onset, na.rm=T), '%d %b %Y')}\")) +\n  \n  # optional aesthetic themes\n  theme(\n    legend.position = \"bottom\",                             # move legend to bottom\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.background = element_blank(),\n    axis.line = element_line(colour = \"black\"),\n    plot.title = element_text(hjust = 0), \n    plot.caption = element_text(hjust=0, size=11, face = \"italic\"))",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Tháp dân số và thang đo Likert</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.vn.html#thang-đo-likert",
    "href": "new_pages/age_pyramid.vn.html#thang-đo-likert",
    "title": "33  Tháp dân số và thang đo Likert",
    "section": "33.4 Thang đo Likert",
    "text": "33.4 Thang đo Likert\nCác kỹ thuật được sử dụng để tạo tháp dân số với ggplot() cũng có thể được sử dụng để lập các biểu đồ của dữ liệu khảo sát từ thang đo Likert.\nNhập dữ liệu (xem chương [Tải sách và dữ liệu] nếu cần).\n\n# import the likert survey response data\nlikert_data &lt;- rio::import(\"likert_data.csv\")\n\nBắt đầu với dữ liệu giống như sau, với một biến phân loại từng người trả lời (status) và câu trả lời của họ cho 8 câu hỏi trên thang điểm Likert 4 mức độ (“Rất kém”, “Kém”, “Tốt”, “Rất tốt”).\n\n\n\n\n\n\nĐầu tiên là một vài bước quản lý số liệu:\n\nXoay trục dữ liệu dài hơn\nTạo cột mới direction tùy thuộc vào việc phản hồi “tích cực” hay “tiêu cực”\nThiết lập thứ bậc kiểu factor cho cột status và cột Response\n\nLưu trữ giá trị đếm tối đa để các giới hạn của biểu đồ là phù hợp\n\n\nmelted &lt;- likert_data %&gt;% \n  pivot_longer(\n    cols = Q1:Q8,\n    names_to = \"Question\",\n    values_to = \"Response\") %&gt;% \n  mutate(\n    \n    direction = case_when(\n      Response %in% c(\"Poor\",\"Very Poor\")  ~ \"Negative\",\n      Response %in% c(\"Good\", \"Very Good\") ~ \"Positive\",\n      TRUE                                 ~ \"Unknown\"),\n    \n    status = fct_relevel(status, \"Junior\", \"Intermediate\", \"Senior\"),\n    \n    # must reverse 'Very Poor' and 'Poor' for ordering to work\n    Response = fct_relevel(Response, \"Very Good\", \"Good\", \"Very Poor\", \"Poor\")) \n\n# get largest value for scale limits\nmelted_max &lt;- melted %&gt;% \n  count(status, Question) %&gt;% # get counts\n  pull(n) %&gt;%                 # column 'n'\n  max(na.rm=T)                # get max\n\nBây giờ hãy cùng vẽ biểu đồ. Tương tự các tháp tuổi ở trên, chúng ta đang tạo hai biểu đồ thanh và đảo các giá trị của một trong số chúng thành âm.\nChúng ta sử dụng hàm geom_bar() bởi vì dữ liệu của chúng ta mỗi quan sát nằm trên một hàng, không phải là số lượng tổng hợp. Chúng ta sử dụng thuật ngữ đặc biệt của ggplot2 là ..count.. ở một biểu đồ thanh để đảo ngược các giá trị thành âm(*-1), sau đó chúng ta thiết lập position = \"stack\" để các giá trị xếp chồng lên nhau.\n\n# make plot\nggplot()+\n     \n  # bar graph of the \"negative\" responses \n     geom_bar(\n       data = melted %&gt;% filter(direction == \"Negative\"),\n       mapping = aes(\n         x = status,\n         y = ..count..*(-1),    # counts inverted to negative\n         fill = Response),\n       color = \"black\",\n       closed = \"left\",\n       position = \"stack\")+\n     \n     # bar graph of the \"positive responses\n     geom_bar(\n       data = melted %&gt;% filter(direction == \"Positive\"),\n       mapping = aes(\n         x = status,\n         fill = Response),\n       colour = \"black\",\n       closed = \"left\",\n       position = \"stack\")+\n     \n     # flip the X and Y axes\n     coord_flip()+\n  \n     # Black vertical line at 0\n     geom_hline(yintercept = 0, color = \"black\", size=1)+\n     \n    # convert labels to all positive numbers\n    scale_y_continuous(\n      \n      # limits of the x-axis scale\n      limits = c(-ceiling(melted_max/10)*11,    # seq from neg to pos by 10, edges rounded outward to nearest 5\n                 ceiling(melted_max/10)*10),   \n      \n      # values of the x-axis scale\n      breaks = seq(from = -ceiling(melted_max/10)*10,\n                   to = ceiling(melted_max/10)*10,\n                   by = 10),\n      \n      # labels of the x-axis scale\n      labels = abs(unique(c(seq(-ceiling(melted_max/10)*10, 0, 10),\n                            seq(0, ceiling(melted_max/10)*10, 10))))) +\n     \n    # color scales manually assigned \n    scale_fill_manual(\n      values = c(\"Very Good\"  = \"green4\", # assigns colors\n                \"Good\"      = \"green3\",\n                \"Poor\"      = \"yellow\",\n                \"Very Poor\" = \"red3\"),\n      breaks = c(\"Very Good\", \"Good\", \"Poor\", \"Very Poor\"))+ # orders the legend\n     \n    \n     \n    # facet the entire plot so each question is a sub-plot\n    facet_wrap( ~ Question, ncol = 3)+\n     \n    # labels, titles, caption\n    labs(\n      title = str_glue(\"Likert-style responses\\nn = {nrow(likert_data)}\"),\n      x = \"Respondent status\",\n      y = \"Number of responses\",\n      fill = \"\")+\n\n     # display adjustments \n     theme_minimal()+\n     theme(axis.text = element_text(size = 12),\n           axis.title = element_text(size = 14, face = \"bold\"),\n           strip.text = element_text(size = 14, face = \"bold\"),  # facet sub-titles\n           plot.title = element_text(size = 20, face = \"bold\"),\n           panel.background = element_rect(fill = NA, color = \"black\")) # black box around each facet",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Tháp dân số và thang đo Likert</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.vn.html#nguồn",
    "href": "new_pages/age_pyramid.vn.html#nguồn",
    "title": "33  Tháp dân số và thang đo Likert",
    "section": "33.5 Nguồn",
    "text": "33.5 Nguồn\napyramid documentation",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Tháp dân số và thang đo Likert</span>"
    ]
  },
  {
    "objectID": "new_pages/heatmaps.vn.html",
    "href": "new_pages/heatmaps.vn.html",
    "title": "34  Biểu đồ nhiệt",
    "section": "",
    "text": "34.1 Chuẩn bị",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Biểu đồ nhiệt</span>"
    ]
  },
  {
    "objectID": "new_pages/heatmaps.vn.html#chuẩn-bị",
    "href": "new_pages/heatmaps.vn.html#chuẩn-bị",
    "title": "34  Biểu đồ nhiệt",
    "section": "",
    "text": "Gọi packages\nĐoạn code dưới đây hiển thị cách gọi các packages cần thiết cho việc phân tích dữ liệu. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, cài đặt packages nếu cần và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() từ base R. Xem chương R cơ bản để biết thêm thông tin về các packages trong R.\n\npacman::p_load(\n  tidyverse,       # data manipulation and visualization\n  rio,             # importing data \n  lubridate        # working with dates\n  )\n\nBộ dữ liệu\nChương này sẽ sử dụng bộ dữ liệu linelist-một vụ dịch mô phỏng trong mục ma trận lây truyền và bộ dữ liệu về số trường hợp sốt rét được ghi nhận hàng ngày theo cơ sở trong phần theo dõi các chỉ số báo cáo. Các bộ dữ liệu sẽ được gọi và làm sạch trong khi trình bày.",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Biểu đồ nhiệt</span>"
    ]
  },
  {
    "objectID": "new_pages/heatmaps.vn.html#ma-trận-lây-truyền",
    "href": "new_pages/heatmaps.vn.html#ma-trận-lây-truyền",
    "title": "34  Biểu đồ nhiệt",
    "section": "34.2 Ma trận lây truyền",
    "text": "34.2 Ma trận lây truyền\nBảng nhiệt có thể hữu ích để trực quan hóa ma trận. Một ví dụ là hiển thị “ai đã lây nhiễm cho ai” trong một vụ dịch. Giả sử rằng bạn có đầy đủ thông tin về các sự kiện lây truyền.\nLưu ý rằng chương [Truy vết tiếp xúc] có một ví dụ khác về tạo ma trận tiếp xúc thành bảng nhiệt, sử dụng một dataset khác (có lẽ đơn giản hơn) trong đó tuổi của các trường hợp và nguồn lây của chúng được căn chỉnh gọn gàng trên cùng một hàng của data frame. Dataset này cũng được sử dụng để tạo bản đồ mật độ trong chương [Các mẹo với ggplot]. Ví dụ dưới đây bắt đầu từ một danh sách các trường hợp và yêu cầu nhiều thao tác biến đổi dữ liệu trước khi thành một data frame sẵn sàng để vẽ biểu đồ. Vì vậy, có rất nhiều kịch bản để bạn lựa chọn…\nChúng tôi bắt đầu từ danh sách trường hợp của một vụ dịch Ebola mô phỏng. Nếu bạn muốn theo dõi, hãy bấm để tải bộ dữ liệu linelist “đã làm sạch” (as .rds file). Nhập dữ liệu của bạn bằng hàm import() từ package rio (hàm này chấp nhận nhiều loại tệp như .xlsx, .rds, .csv - Xem chương Nhập xuất dữ liệu để biết thêm chi tiết).\nDanh sách dưới đây bao gồm 50 hàng đầu tiên của linelist:\n\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nTrong bộ dữ liệu linelist này:\n\nMỗi trường hợp được thể hiện trên một hàng, được định danh bằng case_id\n\nKéo sang phải bạn sẽ thấy cột infector có chứa case_id của nguồn lây, mỗi nguồn lây cũng là một trường hợp trong linelist\n\n\n\n\n\n\n\n\nChuẩn bị dữ liệu\nMục tiêu: Chúng ta cần tạo một data frame dạng “dọc”, tức là mỗi đường lây truyền theo lứa tuổi có thể có nằm trên một hàng, với một cột số chứa tỷ lệ của hàng đó đối với tất cả các sự kiện lây nhiễm được quan sát trong linelist.\nĐể đạt được mục tiêu này, một số bước biến đổi dữ liệu cần được thực hiện:\n\nTạo data frame các trường hợp\nĐể bắt đầu, chúng ta tạo một data frame về các trường hợp, bao gồm độ tuổi và nguồn lây nhiễm của chúng - chúng ta đặt tên data frame này là case_ages. 50 hàng đầu tiên của bộ dữ liệu dữ liệu được hiển thị bên dưới.\n\ncase_ages &lt;- linelist %&gt;% \n  select(case_id, infector, age_cat) %&gt;% \n  rename(\"case_age_cat\" = \"age_cat\")\n\n\n\n\n\n\n\n\n\nTạo data frame nguồn lây nhiễm\nTiếp theo, chúng ta tạo một data frame các nguồn lây nhiễm - tại thời điểm này, nó chỉ gồm một cột duy nhất. Đây là các ID của các nguồn lâu nhiễm trong bộ dữ liệu linelist. Không phải mọi trường hợp đều xác định được nguồn lây, vì vậy chúng ta cần loại bỏ các giá trị missing. 50 hàng đầu tiên được hiển thị bên dưới.\n\ninfectors &lt;- linelist %&gt;% \n  select(infector) %&gt;% \n  drop_na(infector)\n\n\n\n\n\n\n\nTiếp theo, chúng ta sử dụng hàm join để thu thập tuổi của những nguồn lây nhiễm. Điều này không đơn giản, vì trong linelist, tuổi của người lây nhiễm không được liệt kê như vậy. Chúng ta sẽ đạt được kết quả này bằng cách nối dữ liệu các trường hợp trong linelist với dữ liệu những người lây nhiễm. Chúng ta bắt đầu với bộ dữ liệu infectors, sau đó dùng hàm left_join() thêm các trường hợp trong linelist sao cho cột id của các trường hợp lây nhiễm trong bộ dữ liệu infector nối với cột case_id trong bộ dữ liệu linelist.\nDo đó, dữ liệu từ bản ghi trường hợp của người lây nhiễm trong linelist (bao gồm cả tuổi) được thêm vào hàng của người lây nhiễm. 50 hàng đầu tiên được hiển thị bên dưới.\n\ninfector_ages &lt;- infectors %&gt;%             # begin with infectors\n  left_join(                               # add the linelist data to each infector  \n    linelist,\n    by = c(\"infector\" = \"case_id\")) %&gt;%    # match infector to their information as a case\n  select(infector, age_cat) %&gt;%            # keep only columns of interest\n  rename(\"infector_age_cat\" = \"age_cat\")   # rename for clarity\n\n\n\n\n\n\n\nSau đó, chúng ta kết hợp các trường hợp và tuổi của chúng với những người lây nhiễm và tuổi của những người này lại. Mỗi data frame đều có chung cột infector, vì vậy nó được sử dụng cho phép nối. Các hàng đầu tiên được hiển thị bên dưới:\n\nages_complete &lt;- case_ages %&gt;%  \n  left_join(\n    infector_ages,\n    by = \"infector\") %&gt;%        # each has the column infector\n  drop_na()                     # drop rows with any missing data\n\nWarning in left_join(., infector_ages, by = \"infector\"): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 1 of `x` matches multiple rows in `y`.\nℹ Row 6 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\n\n\nDưới đây là bảng chéo đơn giản về số lượng các trường hợp và người lây nhiễm theo nhóm tuổi. Nhãn được thêm vào để phân biệt.\n\ntable(cases = ages_complete$case_age_cat,\n      infectors = ages_complete$infector_age_cat)\n\n       infectors\ncases   0-4 5-9 10-14 15-19 20-29 30-49 50-69 70+\n  0-4   105 156   105   114   143   117    13   0\n  5-9   102 132   110   102   117    96    12   5\n  10-14 104 109    91    79   120    80    12   4\n  15-19  85 105    82    39    75    69     7   5\n  20-29 101 127   109    80   143   107    22   4\n  30-49  72  97    56    54    98    61     4   5\n  50-69   5   6    15     9     7     5     2   0\n  70+     1   0     2     0     0     0     0   0\n\n\nChúng ta có thể chuyển đổi bảng này thành data frame với hàm data.frame() từ base R, hàm sẽ tự động chuyển đổi dữ liệu sang dạng “dọc” để có thể áp dụng trong hàm ggplot(). Các hàng đầu tiên được hiển thị bên dưới.\n\nlong_counts &lt;- data.frame(table(\n    cases     = ages_complete$case_age_cat,\n    infectors = ages_complete$infector_age_cat))\n\n\n\n\n\n\n\nBây giờ chúng ta làm tương tự, nhưng áp dụng hàm prop.table() từ base R vào bảng để thay vì nhận số lượng, chúng ta nhận được tỷ lệ của tất cả các biến. 50 hàng đầu tiên được hiển thị bên dưới.\n\nlong_prop &lt;- data.frame(prop.table(table(\n    cases = ages_complete$case_age_cat,\n    infectors = ages_complete$infector_age_cat)))\n\n\n\n\n\n\n\n\n\n\nTạo biểu đồ nhiệt\nCuối cùng, chúng ta có thể vẽ biểu đồ nhiệt với hàm geom_tile() trong package ggplot2. Xem chương Các mẹo với ggplot để tìm hiểu sâu hơn về thang màu/tô màu cho biểu đồ, đặc biệt là hàm scale_fill_gradient().\n\nBên trong hàm aes() của hàm geom_tile(), thiết lập trục x và y tương ứng với tuổi của các trường hợp và tuổi của người lây nhiễm\n\nNgoài ra trong hàm aes(), hãy đặt đối số fill = tới cột tần suất Freq - đây là giá trị sẽ được chuyển đổi thành màu gạch\nĐặt màu thang đo với scale_fill_gradient() - bạn có thể chỉ định màu cao/thấp\n\nLưu ý rằng scale_color_gradient() là một cái khác! Trong trường hợp này, bạn sẽ sử dụng fill\n\nBởi vì màu được tạo thông qua “fill”, bạn có thể sử dụng đối số fill = đối số trong hàm labs() để thay đổi tiêu đề chú giải\n\n\nggplot(data = long_prop)+       # use long data, with proportions as Freq\n  geom_tile(                    # visualize it in tiles\n    aes(\n      x = cases,         # x-axis is case age\n      y = infectors,     # y-axis is infector age\n      fill = Freq))+            # color of the tile is the Freq column in the data\n  scale_fill_gradient(          # adjust the fill color of the tiles\n    low = \"blue\",\n    high = \"orange\")+\n  labs(                         # labels\n    x = \"Case age\",\n    y = \"Infector age\",\n    title = \"Who infected whom\",\n    subtitle = \"Frequency matrix of transmission events\",\n    fill = \"Proportion of all\\ntranmsission events\"     # legend title\n  )",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Biểu đồ nhiệt</span>"
    ]
  },
  {
    "objectID": "new_pages/heatmaps.vn.html#các-chỉ-số-báo-cáo-theo-thời-gian",
    "href": "new_pages/heatmaps.vn.html#các-chỉ-số-báo-cáo-theo-thời-gian",
    "title": "34  Biểu đồ nhiệt",
    "section": "34.3 Các chỉ số báo cáo theo thời gian",
    "text": "34.3 Các chỉ số báo cáo theo thời gian\nThông thường, trong lĩnh vực y tế công cộng, một mục tiêu là đánh giá xu hướng theo thời gian của nhiều thực thể (cơ sở điều trị, địa giới hành chính, v.v.). Một cách để hình dung các xu hướng như vậy theo thời gian là biểu đồ nhiệt trong đó trục x là thời gian và trên trục y là các thực thể.\n\nChuẩn bị dữ liệu\nChúng ta bắt đầu bằng cách nhập bộ dữ liệu báo cáo về bệnh sốt rét hàng ngày từ nhiều cơ sở. Các báo cáo chứa dữu liệu về ngày, tỉnh, huyện và số trường hợp sốt rét. Xem chương Tải sách và dữ liệu để biết thông tin về cách tải xuống các dữ liệu này. Dưới đây là 30 hàng đầu tiên:\n\nfacility_count_data &lt;- import(\"malaria_facility_count_data.rds\")\n\n\n\n\n\n\n\n\nTổng hợp và tóm tắt\nMục tiêu của ví dụ này là chuyển đổi tổng số số ca bệnh sốt rét hàng ngày tại các cơ sở (xem trong tab trước) thành số liệu thống kê tóm tắt hàng tuần về hiệu suất báo cáo của cơ sở - trong trường hợp này là tỷ lệ số ngày mỗi tuần mà cơ sở báo cáo bất kỳ dữ liệu nào. Đối với ví dụ này, chúng ta sẽ chỉ hiển thị dữ liệu cho Spring District.\nĐể đạt được điều này, chúng ta sẽ thực hiện các bước quản lý dữ liệu sau:\n\nLọc dữ liệu phù hợp (theo địa điểm, ngày tháng)\n\nTạo cột tuần bằng cách sử dụng hàm floor_date() trong package lubridate\n\nHàm này trả về ngày bắt đầu trong tuần của một ngày cụ thể, sử dụng ngày bắt đầu được chỉ định của mỗi tuần (ví dụ: “Thứ Hai”)\n\nDữ liệu được nhóm theo cột “location” và “week” để tạo ra các đơn vị phân tích “facility-week”\n\nHàm summarise() tạo các cột mới để trình bày thống kê tóm tắt cho từng nhóm cơ sở theo tuần (facility-week):\n\nSố ngày mỗi tuần (7 - một giá trị không đổi)\n\nSố lượng báo cáo nhận được từ cơ sở-tuần (có thể nhiều hơn 7!)\n\nTổng số ca sốt rét do cơ sở báo cáo trong tuần (chỉ dành cho ai quan tâm)\n\nSố ngày duy nhất trong mỗi cơ sở-tuần có dữ liệu được báo cáo\n\nPhần trăm trong số 7 ngày mỗi cơ sở-tuần mà dữ liệu được báo cáo\n\n\nData frame được kết hợp bằng hàm right_join() thành một danh sách hoàn chỉnh về tất cả các kết hợp cơ sở-tuần có thể có, để làm cho tập dữ liệu hoàn thiện. Ma trận của tất cả các kết hợp có thể có được tạo bằng cách áp dụng hàm expand() cho hai cột đó của data frame giống như tại thời điểm đó trong chuỗi pipe (được biểu thị bằng .). Vì sử dụng hàm right_join(), nên tất cả các hàng trong data frame expand() mở rộng được giữ lại và được thêm vào agg_weeks nếu cần. Các hàng mới này xuất hiện với các giá trị tóm tắt NA (missing).\n\nDưới đây là từng bước thực hiện:\n\n# Create weekly summary dataset\nagg_weeks &lt;- facility_count_data %&gt;% \n  \n  # filter the data as appropriate\n  filter(\n    District == \"Spring\",\n    data_date &lt; as.Date(\"2020-08-01\")) \n\nBây giờ tập dữ liệu có số lượng hàng tính theo agg_week nrow(agg_weeks), trong khi trước được tính theo facility_count_data nrow(facility_count_data).\nTiếp theo, chúng ta tạo cột tuần để phản ánh ngày bắt đầu trong tuần cho mỗi bản ghi. Thực hiện điều này với hàm floor_date () trong package lubridate, giúp thiết lập theo “tuần” và các tuần sẽ bắt đầu vào Thứ Hai (ngày 1 trong tuần - Chủ Nhật sẽ là 7). Các hàng đầu tiên được hiển thị như bên dưới.\n\nagg_weeks &lt;- agg_weeks %&gt;% \n  # Create week column from data_date\n  mutate(\n    week = lubridate::floor_date(                     # create new column of weeks\n      data_date,                                      # date column\n      unit = \"week\",                                  # give start of the week\n      week_start = 1))                                # weeks to start on Mondays \n\nCột tuần mới này có thể được nhìn thấy ở ngoài cùng bên phải của data frame được tạo ra:\n\n\n\n\n\n\nBây giờ chúng ta nhóm dữ liệu thành các cơ sở-tuần và tóm tắt chúng để tạo ra số liệu thống kê cho mỗi cơ sở-tuần. Xem thêm chương Bảng mô tả để biết các mẹo. Bản thân việc nhóm sẽ không làm thay đổi data frame, nhưng nó ảnh hưởng đến cách các thống kê tóm tắt tiếp theo được tính toán.\nCác hàng đầu tiên được hiển thị bên dưới. Lưu ý cách các cột đã thay đổi hoàn toàn để phản ánh thống kê tóm tắt mong muốn. Mỗi hàng phản ánh một cơ sở-tuần.\n\nagg_weeks &lt;- agg_weeks %&gt;%   \n\n  # Group into facility-weeks\n  group_by(location_name, week) %&gt;%\n  \n  # Create summary statistics columns on the grouped data\n  summarize(\n    n_days          = 7,                                          # 7 days per week           \n    n_reports       = dplyr::n(),                                 # number of reports received per week (could be &gt;7)\n    malaria_tot     = sum(malaria_tot, na.rm = T),                # total malaria cases reported\n    n_days_reported = length(unique(data_date)),                  # number of unique days reporting per week\n    p_days_reported = round(100*(n_days_reported / n_days))) %&gt;%  # percent of days reporting\n\n  ungroup(location_name, week)                                    # ungroup so expand() works in next step\n\n\n\n\n\n\n\nCuối cùng, chúng ta chạy lệnh dưới đây để đảm bảo rằng TẤT CẢ các cặp cơ sở điều trị-tuần báo cáo có thể có trong dữ liệu, ngay cả khi chúng bị missing trước đó.\nChúng ta tiếp tục sử dụng hàm right_join() trên chính dữ liệu (tập dữ liệu được thể hiện bởi dấu “.”) vừa được mở rộng để bao gồm tất cả các kết hợp có thể có của các cột week và location_name. Xem tài liệu về hàm expand() trong chương Xoay trục dữ liệu. Trước khi chạy đoạn lệnh này, tập dữ liệu cần chứa nrow(agg_weeks) hàng.\n\n# Create data frame of every possible facility-week\nexpanded_weeks &lt;- agg_weeks %&gt;% \n  tidyr::expand(location_name, week)  # expand data frame to include all possible facility-week combinations\n\nĐây là expanded_weeks:\n\n\n\n\n\n\nTRước khi chạy dòng lệnh này, agg_weeks bao gồm nrow(agg_weeks) hàng.\n\n# Use a right-join with the expanded facility-week list to fill-in the missing gaps in the data\nagg_weeks &lt;- agg_weeks %&gt;%      \n  right_join(expanded_weeks) %&gt;%                            # Ensure every possible facility-week combination appears in the data\n  mutate(p_days_reported = replace_na(p_days_reported, 0))  # convert missing values to 0                           \n\nJoining with `by = join_by(location_name, week)`\n\n\nSau khi chạy dòng lệnh này, agg_weeks vẫn bao gồm nrow(agg_weeks) hàng.\n\n\n\n\nTạo biểu đồ nhiệt\nHàm ggplot() được thực hiện bằng cách sử dụng hàm geom_tile() từ package ggplot2:\n\nCác tuần trên trục x được chuyển đổi thành ngày tháng, cho phép sử dụng scale_x_date()\n\nlocation_name trên trục y sẽ hiển thị tất cả các tên cơ sở\nfill được gán cho p_days_reported, hiệu suất cho cơ sở-tuần đó (dạng số)\nscale_fill_gradient() được sử dụng để tô màu cho biến dạng số, cụ thể màu sắc gồm cao, thấp và NA\n\nscale_x_date() được sử dụng trên trục x, chỉ định các nhãn 2 tuần một lần và định dạng của chúng\n\nCác chủ đề và nhãn hiển thị có thể được điều chỉnh khi cần thiết\n\n\n\n\nCơ bản\nBiểu đồ nhiệt cơ bản sẽ được tạo như bên dưới, sử dụng màu, thang đo, v.v mặc định. Như đã giải thích ở trên, trong aes() của hàm geom_tile(), bạn phải cung cấp cột trục x, cột trục y, và một cột cho fill =. Phần tô là giá trị số thể hiện dưới dạng màu ô.\n\nggplot(data = agg_weeks)+\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported))\n\n\n\n\n\n\n\n\n\n\nLàm sạch biểu đồ nhiệt\nChúng ta có thể làm cho biểu đồ này trông đẹp hơn bằng cách thêm các hàm ggplot2 bổ sung, như được hiển thị bên dưới. Xem thêm chương Các mẹo với ggplot để biết thêm chi tiết.\n\nggplot(data = agg_weeks)+ \n  \n  # show data as tiles\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported),      \n    color = \"white\")+                 # white gridlines\n  \n  scale_fill_gradient(\n    low = \"orange\",\n    high = \"darkgreen\",\n    na.value = \"grey80\")+\n  \n  # date axis\n  scale_x_date(\n    expand = c(0,0),             # remove extra space on sides\n    date_breaks = \"2 weeks\",     # labels every 2 weeks\n    date_labels = \"%d\\n%b\")+     # format is day over month (\\n in newline)\n  \n  # aesthetic themes\n  theme_minimal()+                                  # simplify background\n  \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1,\"cm\"),           # height of legend key\n    legend.key.width  = grid::unit(0.6,\"cm\"),         # width of legend key\n    \n    axis.text.x = element_text(size=12),              # axis text size\n    axis.text.y = element_text(vjust=0.2),            # axis text alignment\n    axis.ticks = element_line(size=0.4),               \n    axis.title = element_text(size=12, face=\"bold\"),  # axis title size and bold\n    \n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),  # title right-aligned, large, bold\n    plot.caption = element_text(hjust = 0, face = \"italic\")  # caption right-aligned and italic\n    )+\n  \n  # plot labels\n  labs(x = \"Week\",\n       y = \"Facility name\",\n       fill = \"Reporting\\nperformance (%)\",           # legend title, because legend shows fill\n       title = \"Percent of days per week that facility reported data\",\n       subtitle = \"District health facilities, May-July 2020\",\n       caption = \"7-day weeks beginning on Mondays.\")\n\n\n\n\n\n\n\n\n\n\n\nSắp xếp thứ tự trục y\nHiện tại, các cơ sở được sắp xếp theo thứ tự “theo bảng chữ cái” từ dưới lên trên. Nếu bạn muốn điều chỉnh thứ tự các cơ sở trục y, hãy chuyển đổi chúng thành factor thứ bậc và cung cấp thứ tự. Xem thêm chương Factors để biết các mẹo để thực hiện điều này.\nVì có rất nhiều cơ sở và chúng ta không muốn viết hết chúng ra, chúng ta sẽ thử một cách tiếp cận khác - sắp xếp thứ tự các cơ sở trong data frame và sử dụng cột tên kết quả làm thứ tự của factor. Bên dưới, cột location_name được chuyển đổi thành một factor và thứ tự của các cấp của nó được đặt dựa trên tổng số ngày báo cáo do cơ sở nộp trong toàn bộ khoảng thời gian.\nĐể làm điều này, chúng ta tạo một data frame đại diện cho tổng số báo cáo cho mỗi cơ sở, được sắp xếp theo thứ tự tăng dần. Chúng ta có thể sử dụng vectơ này để sắp xếp các mức thứ tự trong biểu đồ.\n\nfacility_order &lt;- agg_weeks %&gt;% \n  group_by(location_name) %&gt;% \n  summarize(tot_reports = sum(n_days_reported, na.rm=T)) %&gt;% \n  arrange(tot_reports) # ascending order\n\nXem data frame bên dưới:\n\n\n\n\n\n\nBây giờ, hãy sử dụng một cột từ data frame bên trên (facility_order$location_name) để trở thành thứ bậc factors của biến location_name trong data frame agg_weeks:\n\n# load package \npacman::p_load(forcats)\n\n# create factor and define levels manually\nagg_weeks &lt;- agg_weeks %&gt;% \n  mutate(location_name = fct_relevel(\n    location_name, facility_order$location_name)\n    )\n\nVà bây giờ dữ liệu được vẽ lại, với location_name trở thành một factor có thứ tự:\n\nggplot(data = agg_weeks)+ \n  \n  # show data as tiles\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported),      \n    color = \"white\")+                 # white gridlines\n  \n  scale_fill_gradient(\n    low = \"orange\",\n    high = \"darkgreen\",\n    na.value = \"grey80\")+\n  \n  # date axis\n  scale_x_date(\n    expand = c(0,0),             # remove extra space on sides\n    date_breaks = \"2 weeks\",     # labels every 2 weeks\n    date_labels = \"%d\\n%b\")+     # format is day over month (\\n in newline)\n  \n  # aesthetic themes\n  theme_minimal()+                                  # simplify background\n  \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1,\"cm\"),           # height of legend key\n    legend.key.width  = grid::unit(0.6,\"cm\"),         # width of legend key\n    \n    axis.text.x = element_text(size=12),              # axis text size\n    axis.text.y = element_text(vjust=0.2),            # axis text alignment\n    axis.ticks = element_line(size=0.4),               \n    axis.title = element_text(size=12, face=\"bold\"),  # axis title size and bold\n    \n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),  # title right-aligned, large, bold\n    plot.caption = element_text(hjust = 0, face = \"italic\")  # caption right-aligned and italic\n    )+\n  \n  # plot labels\n  labs(x = \"Week\",\n       y = \"Facility name\",\n       fill = \"Reporting\\nperformance (%)\",           # legend title, because legend shows fill\n       title = \"Percent of days per week that facility reported data\",\n       subtitle = \"District health facilities, May-July 2020\",\n       caption = \"7-day weeks beginning on Mondays.\")\n\n\n\n\n\n\n\n\n\n\n\nBiểu diễn các giá trị\nBạn có thể thêm lớp văn bản geom_text() lên phía trên các ô, để hiển thị số lượng thực của mỗi ô. Hãy lưu ý rằng điều này có thể trông không đẹp nếu bạn có nhiều ô nhỏ!\nĐoạn code sau đã được thêm vào: geom_text(aes(label = p_days_reported)). Điều này giúp thêm văn bản vào từng ô. Văn bản được hiển thị là giá trị được gán cho đối số label =, trong trường hợp này đã được đặt thành cùng một cột số p_days_reported cũng được sử dụng để tạo gradient màu.\n\nggplot(data = agg_weeks)+ \n  \n  # show data as tiles\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported),      \n    color = \"white\")+                 # white gridlines\n  \n  # text\n  geom_text(\n    aes(\n      x = week,\n      y = location_name,\n      label = p_days_reported))+      # add text on top of tile\n  \n  # fill scale\n  scale_fill_gradient(\n    low = \"orange\",\n    high = \"darkgreen\",\n    na.value = \"grey80\")+\n  \n  # date axis\n  scale_x_date(\n    expand = c(0,0),             # remove extra space on sides\n    date_breaks = \"2 weeks\",     # labels every 2 weeks\n    date_labels = \"%d\\n%b\")+     # format is day over month (\\n in newline)\n  \n  # aesthetic themes\n  theme_minimal()+                                    # simplify background\n  \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1,\"cm\"),           # height of legend key\n    legend.key.width  = grid::unit(0.6,\"cm\"),         # width of legend key\n    \n    axis.text.x = element_text(size=12),              # axis text size\n    axis.text.y = element_text(vjust=0.2),            # axis text alignment\n    axis.ticks = element_line(size=0.4),               \n    axis.title = element_text(size=12, face=\"bold\"),  # axis title size and bold\n    \n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),  # title right-aligned, large, bold\n    plot.caption = element_text(hjust = 0, face = \"italic\")  # caption right-aligned and italic\n    )+\n  \n  # plot labels\n  labs(x = \"Week\",\n       y = \"Facility name\",\n       fill = \"Reporting\\nperformance (%)\",           # legend title, because legend shows fill\n       title = \"Percent of days per week that facility reported data\",\n       subtitle = \"District health facilities, May-July 2020\",\n       caption = \"7-day weeks beginning on Mondays.\")",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Biểu đồ nhiệt</span>"
    ]
  },
  {
    "objectID": "new_pages/heatmaps.vn.html#nguồn",
    "href": "new_pages/heatmaps.vn.html#nguồn",
    "title": "34  Biểu đồ nhiệt",
    "section": "34.4 Nguồn",
    "text": "34.4 Nguồn\nscale_fill_gradient()\nR graph gallery - heatmap",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Biểu đồ nhiệt</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.vn.html",
    "href": "new_pages/diagrams.vn.html",
    "title": "35  Sơ đồ và biểu đồ",
    "section": "",
    "text": "35.1 Chuẩn bị",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Sơ đồ và biểu đồ</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.vn.html#chuẩn-bị",
    "href": "new_pages/diagrams.vn.html#chuẩn-bị",
    "title": "35  Sơ đồ và biểu đồ",
    "section": "",
    "text": "Gọi packages\nĐoạn code dưới đây hiển thị cách gọi các packages cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, cài đặt gói nếu cần và gọi nó ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() từ base R. Xem chương R cơ bản để biết thêm thông tin về các package R.\n\npacman::p_load(\n  DiagrammeR,     # for flow diagrams\n  networkD3,      # For alluvial/Sankey diagrams\n  tidyverse)      # data management and visualization\n\n\n\nNhập dữ liệu\nHầu hết nội dung trong chương này không yêu cầu bộ dữ liệu. Tuy nhiên, trong phần sơ đồ Sankey, chúng ta sẽ sử dụng bộ dữ liệu linelist từ một vụ dịch Ebola mô phỏng. Để tiện theo dõi, hãy bấm để tải bộ dữ liệu linelist “đã làm sạch” ở đây (as .rds file). Nhập dữ liệu bằng hàm import () từ package rio (có thể xử lý nhiều loại tệp như .xlsx, .csv, .rds - Xem chương Nhập xuất dữ liệu để biết chi tiết).\n\n# import the linelist\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\n50 hàng đầu tiên của linelist được hiển thị bên dưới:",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Sơ đồ và biểu đồ</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.vn.html#sơ-đồ-flow",
    "href": "new_pages/diagrams.vn.html#sơ-đồ-flow",
    "title": "35  Sơ đồ và biểu đồ",
    "section": "35.2 Sơ đồ flow",
    "text": "35.2 Sơ đồ flow\nChúng ta có thể sử dụng package R DiagrammeR để vẽ biểu đồ/sơ đồ flow. Chúng có thể là sơ đồ tĩnh hoặc có động dựa thay đổi theo những thay đổi trong tập dữ liệu.\nCông cụ\nHàm grViz() được sử dụng để tạo sơ đồ “Graphviz”. Hàm này chấp nhận một chuỗi ký tự đầu vào chứa các hướng dẫn để tạo sơ đồ. Trong chuỗi đó, các hướng dẫn được viết bằng một ngôn ngữ khác, được gọi là ngôn ngữ DOT - khá dễ dàng để học những điều cơ bản.\nCấu trúc cơ bản\n\nMở hướng dẫn grViz(\"\n\nChỉ định hướng và tên của biểu đồ, đồng thời mở ngoặc, vd: digraph my_flow_chart {\nCâu lệnh biểu đồ (bố cục, hướng sắp xếp các biến số)\n\nCâu lệnh nút (tạo nút)\nCâu lệnh Edges (cung cấp liên kết giữa các nút)\n\nĐóng các hướng dẫn }\")\n\n\nVí dụ đơn giản\nDưới đây là hai ví dụ đơn giản\nMột ví dụ rất đơn giản:\n\n# A minimal plot\nDiagrammeR::grViz(\"digraph {\n  \ngraph[layout = dot, rankdir = LR]\n\na\nb\nc\n\na -&gt; b -&gt; c\n}\")\n\n\n\n\n\nMột ví dụ khác áp dụng trong y tế công cộng:\n\ngrViz(\"                           # All instructions are within a large character string\ndigraph surveillance_diagram {    # 'digraph' means 'directional graph', then the graph name \n  \n  # graph statement\n  #################\n  graph [layout = dot,\n         rankdir = TB,\n         overlap = true,\n         fontsize = 10]\n  \n  # nodes\n  #######\n  node [shape = circle,           # shape = circle\n       fixedsize = true\n       width = 1.3]               # width of circles\n  \n  Primary                         # names of nodes\n  Secondary\n  Tertiary\n\n  # edges\n  #######\n  Primary   -&gt; Secondary [label = ' case transfer']\n  Secondary -&gt; Tertiary [label = ' case transfer']\n}\n\")\n\n\n\n\n\n\n\nCú pháp\nCú pháp cơ bản\nTên nút hoặc biểu thức cạnh, có thể được phân tách bằng dấu cách, dấu chấm phẩy hoặc dòng mới.\nĐiều hướng\nMột biểu đồ có thể được định hướng lại để di chuyển từ trái sang phải bằng cách điều chỉnh đối số rankdir trong câu lệnh biểu đồ. Mặc định là TB (từ trên xuống dưới), nhưng nó có thể là LR (trái sang phải), RL hoặc BT.\nTên nút\nTên nút có thể là các từ đơn, như trong ví dụ đơn giản ở trên. Để sử dụng tên nhiều từ hoặc các ký tự đặc biệt (ví dụ: dấu ngoặc đơn, dấu gạch ngang), hãy đặt tên nút trong dấu ngoặc đơn (’ ’). Có thể dễ dàng hơn để có một tên nút ngắn và gán một nhãn, như được hiển thị bên dưới trong dấu ngoặc vuông [ ]. Nếu bạn muốn có một dòng mới trong tên của nút, bạn phải thực hiện điều đó thông qua một nhãn - sử dụng \\n trong nhãn của nút trong bên dấu ngoặc kép, như được trình bày bên dưới.\nNhóm phụ\nTrong các biểu thức cạnh, nhóm phụ có thể được tạo ở hai bên của cạnh bằng dấu ngoặc nhọn ({ }). Sau đó, cạnh áp dụng cho tất cả các nút trong dấu ngoặc - nó là cách viết tắt.\nBố cục\n\ndot (đặt đối số rankdir cho một trong các giá trị sau TB, LR, RL, BT, )\nneato\n\ntwopi\n\ncirco\n\nNút - có thể chỉnh sửa\n\nlabel (ký tự, trong dấu ngoặc kép nếu nhiều từ)\n\nfillcolor (nhiều màu)\n\nwidth of shape borderfontcolor\n\nalpha (độ trong suốt 0-1)\n\nshape (hình elip, hình bầu dục, kim cương, trứng, bản rõ, điểm, hình vuông, hình tam giác)\n\nstyle\n\nsides\n\nperipheries\n\nfixedsize (h x w)\n\nheight\n\nwidth\n\ndistortion\n\npenwidth (độ dày của đường viền)\n\nx (dịch chuyển trái/phải)\n\ny (dịch chuyển lên/xuống )\n\nfontname\n\nfontsize\n\nicon\n\nCác cạnh - có thể chỉnh sửa\n\narrowsize\n\narrowhead (normal, box, crow, curve, diamond, dot, inv, none, tee, vee)\n\narrowtail\n\ndir (điều hướng, )\n\nstyle (gạch ngang, …)\n\ncolor\n\nalpha\n\nheadport (văn bản phía trước đầu mũi tên )\n\ntailport (văn bản phía sau đuôi mũi tên)\n\nfontname\n\nfontsize\n\nfontcolor\n\npenwidth (độ dày của mũi tên)\n\nminlen (chiều dài tối thiểu)\n\nTên màu: mã màu theo bảng mã hex hoặc tên màu ‘X11’, xem tại đây để biết thông tin chi tiết về X11\n\n\nVí dụ phức tạp\nVí dụ dưới đây mở rộng trên một sơ đồ giám sát, thêm các tên nút phức tạp, các cạnh được nhóm lại, màu sắc và style\nDiagrammeR::grViz(\"               # All instructions are within a large character string\ndigraph surveillance_diagram {    # 'digraph' means 'directional graph', then the graph name \n  \n  # graph statement\n  #################\n  graph [layout = dot,\n         rankdir = TB,            # layout top-to-bottom\n         fontsize = 10]\n  \n\n  # nodes (circles)\n  #################\n  node [shape = circle,           # shape = circle\n       fixedsize = true\n       width = 1.3]                      \n  \n  Primary   [label = 'Primary\\nFacility'] \n  Secondary [label = 'Secondary\\nFacility'] \n  Tertiary  [label = 'Tertiary\\nFacility'] \n  SC        [label = 'Surveillance\\nCoordination',\n             fontcolor = darkgreen] \n  \n  # edges\n  #######\n  Primary   -&gt; Secondary [label = ' case transfer',\n                          fontcolor = red,\n                          color = red]\n  Secondary -&gt; Tertiary [label = ' case transfer',\n                          fontcolor = red,\n                          color = red]\n  \n  # grouped edge\n  {Primary Secondary Tertiary} -&gt; SC [label = 'case reporting',\n                                      fontcolor = darkgreen,\n                                      color = darkgreen,\n                                      style = dashed]\n}\n\")\n\n\n\n\n\n\nCác cụm biểu đồ phụ\nĐể nhóm các nút thành các cụm có khung, hãy đặt chúng trong cùng một đồ thị con được đặt tên (subgraph name {}). Để xác định từng đồ thị con trong một khung giới hạn, hãy bắt đầu tên của đồ thị con bằng “cluster”, như được trình bày ở 4 khung bên dưới.\nDiagrammeR::grViz(\"             # All instructions are within a large character string\ndigraph surveillance_diagram {  # 'digraph' means 'directional graph', then the graph name \n  \n  # graph statement\n  #################\n  graph [layout = dot,\n         rankdir = TB,            \n         overlap = true,\n         fontsize = 10]\n  \n\n  # nodes (circles)\n  #################\n  node [shape = circle,                  # shape = circle\n       fixedsize = true\n       width = 1.3]                      # width of circles\n  \n  subgraph cluster_passive {\n    Primary   [label = 'Primary\\nFacility'] \n    Secondary [label = 'Secondary\\nFacility'] \n    Tertiary  [label = 'Tertiary\\nFacility'] \n    SC        [label = 'Surveillance\\nCoordination',\n               fontcolor = darkgreen] \n  }\n  \n  # nodes (boxes)\n  ###############\n  node [shape = box,                     # node shape\n        fontname = Helvetica]            # text font in node\n  \n  subgraph cluster_active {\n    Active [label = 'Active\\nSurveillance'] \n    HCF_active [label = 'HCF\\nActive Search']\n  }\n  \n  subgraph cluster_EBD {\n    EBS [label = 'Event-Based\\nSurveillance (EBS)'] \n    'Social Media'\n    Radio\n  }\n  \n  subgraph cluster_CBS {\n    CBS [label = 'Community-Based\\nSurveillance (CBS)']\n    RECOs\n  }\n\n  \n  # edges\n  #######\n  {Primary Secondary Tertiary} -&gt; SC [label = 'case reporting']\n\n  Primary   -&gt; Secondary [label = 'case transfer',\n                          fontcolor = red]\n  Secondary -&gt; Tertiary [label = 'case transfer',\n                          fontcolor = red]\n  \n  HCF_active -&gt; Active\n  \n  {'Social Media' Radio} -&gt; EBS\n  \n  RECOs -&gt; CBS\n}\n\")\n\n\n\n\n\n\n\nHình dạng nút\nVí dụ dưới đây, tham khảo từtài liệu trực tuyến này, hiển thị các hình dạng nút được áp dụng và cách viết tắt cho các kết nối cạnh nối tiếp.\n\nDiagrammeR::grViz(\"digraph {\n\ngraph [layout = dot, rankdir = LR]\n\n# define the global styles of the nodes. We can override these in box if we wish\nnode [shape = rectangle, style = filled, fillcolor = Linen]\n\ndata1 [label = 'Dataset 1', shape = folder, fillcolor = Beige]\ndata2 [label = 'Dataset 2', shape = folder, fillcolor = Beige]\nprocess [label =  'Process \\n Data']\nstatistical [label = 'Statistical \\n Analysis']\nresults [label= 'Results']\n\n# edge definitions with the node IDs\n{data1 data2}  -&gt; process -&gt; statistical -&gt; results\n}\")\n\n\n\n\n\n\n\nKết quả đầu ra\nCách xử lý và lưu kết quả đầu ra\n\nKết quả đầu ra sẽ xuất hiện trong cửa sổ RStudio’s Viewer, theo mặc định ở phía dưới bên phải cùng với các mục Files, Plots, Packages, và Help.\nĐể xuất, bạn có thể chọn “Save as image” để lưu dưới dạng ảnh hoặc “Copy to clipboard” để sao chép vào bộ nhớ tạm từ Viewer. Hình ảnh sẽ điều chỉnh theo kích thước được chỉ định.\n\n\n\nĐồ thị được tham số hóa\nMục này được trích dẫn từ nguồn sau: https://mikeyharper.uk/flowcharts-in-r-using-diagrammer/\n“Các biểu đồ được tham số hóa: Lợi ích tuyệt vời của việc thiết kế các đồ thị trong R là chúng ta có thể kết nối các đồ thị trực tiếp với phân tích của mình bằng cách đọc các giá trị R trực tiếp vào flowchart của chúng ta. Ví dụ: giả sử bạn đã tạo một quy trình lọc để loại bỏ các giá trị sau mỗi giai đoạn của một quy trình, bạn có thể có một đồ thị hiển thị số lượng giá trị còn lại trong tập dữ liệu sau mỗi giai đoạn trong quy trình của bạn. Để làm điều này, chúng ta có thể sử dụng ký hiệu @@X trực tiếp trong đồ thị, sau đó tham chiếu tới footer của biểu đồ bằng cách sử dụng [X]:, trong đó X là chỉ số số duy nhất.”\nChúng tôi khuyến khích bạn xem lại hướng dẫn này nếu tham số hóa là điều bạn quan tâm.",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Sơ đồ và biểu đồ</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.vn.html#sơ-đồ-alluvialsankey",
    "href": "new_pages/diagrams.vn.html#sơ-đồ-alluvialsankey",
    "title": "35  Sơ đồ và biểu đồ",
    "section": "35.3 Sơ đồ Alluvial/Sankey",
    "text": "35.3 Sơ đồ Alluvial/Sankey\n\nGọi packages\nĐoạn code dưới đây hiển thị cách gọi các packages cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, cài đặt gói nếu cần và gọi nó ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() từ base R. Xem chương R cơ bản để biết thêm thông tin về các package R.\nChúng ta gọi package networkD3 để vẽ sơ đồ và package tidyverse cho các bước chuẩn bị dữ liệu.\n\npacman::p_load(\n  networkD3,\n  tidyverse)\n\n\n\nVẽ đồ thị từ một tập dữ liệu\nVẽ những mối liên quan trong một tập dữ liệu. Dưới đây, chúng tôi minh họa việc sử dụng package này với bộ số liệu linelist. Hãy đọc thêm hướng dẫn trực tuyến sau..\nChúng ta sẽ bắt đầu bằng cách lấy số lượng các trường hợp theo sự kết hợp của nhóm tuổi và bệnh viện. Chúng ta cũng xóa các giá trị thiếu nhóm tuổi để làm sạch. Chúng ta cũng gắn lại nhãn các cột hospital và cột age_cat tương ứng là source và target. Đây sẽ là hai mặt của sơ đồ Alluvial.\n\n# counts by hospital and age category\nlinks &lt;- linelist %&gt;% \n  drop_na(age_cat) %&gt;% \n  select(hospital, age_cat) %&gt;%\n  count(hospital, age_cat) %&gt;% \n  rename(source = hospital,\n         target = age_cat)\n\nTập dữ liệu bây giờ trông như thế này:\n\n\n\n\n\n\nBây giờ chúng ta tạo một data frame cho tất cả các nút của sơ đồ, dưới cột name. Điều này bao gồm tất cả các giá trị cho cột hospital và cột age_cat. Lưu ý rằng chúng ta cần đảm bảo tất cả chúng đều có kiểu Ký tự trước khi kết hợp chúng và điều chỉnh cột ID thành dạng số thay vì dạng nhãn:\n\n# The unique node names\nnodes &lt;- data.frame(\n  name=c(as.character(links$source), as.character(links$target)) %&gt;% \n    unique()\n  )\n\nnodes  # print\n\n                                   name\n1                      Central Hospital\n2                     Military Hospital\n3                               Missing\n4                                 Other\n5                         Port Hospital\n6  St. Mark's Maternity Hospital (SMMH)\n7                                   0-4\n8                                   5-9\n9                                 10-14\n10                                15-19\n11                                20-29\n12                                30-49\n13                                50-69\n14                                  70+\n\n\nChúng ta tiếp tục chỉnh sửa data frame có tên links mà chúng ta đã tạo ở trên với hàm count(). Chúng ta thêm hai cột dạng số là cột IDsource và IDtarget để thực sự phản ánh/tạo liên kết giữa các nút. Các cột này sẽ giữ số thứ tự hàng (vị trí) của nút nguồn và nút đích. Số 1 sẽ bị trừ để các số vị trí này bắt đầu bằng 0 (không phải 1).\n\n# match to numbers, not names\nlinks$IDsource &lt;- match(links$source, nodes$name)-1 \nlinks$IDtarget &lt;- match(links$target, nodes$name)-1\n\nTập dữ liệu link bây giờ trông như sau:\n\n\n\n\n\n\nBây giờ, chúng ta vẽ sơ đồ Sankey với hàm sankeyNetwork(). Bạn có thể đọc thêm về từng đối số bằng cách chạy lệnh ?sankeyNetwork trong bảng điều khiển. Lưu ý rằng trừ khi bạn đặt iterations = 0, thứ tự các nút của bạn có thể sẽ không như bạn mong đợi.\n\n# plot\n######\np &lt;- sankeyNetwork(\n  Links = links,\n  Nodes = nodes,\n  Source = \"IDsource\",\n  Target = \"IDtarget\",\n  Value = \"n\",\n  NodeID = \"name\",\n  units = \"TWh\",\n  fontSize = 12,\n  nodeWidth = 30,\n  iterations = 0)        # ensure node order is as in data\np\n\n\n\n\n\nĐây là một ví dụ trong đó Kết quả của bệnh nhân cũng được bao gồm. Lưu ý trong bước chuẩn bị dữ liệu, chúng ta phải tính toán số lượng các trường hợp giữa tuổi và bệnh viện, và phân biệt biệt giữa bệnh viện và outcome - sau đó liên kết tất cả các số lượng này với nhau bằng hàm bind_rows().\n\n# counts by hospital and age category\nage_hosp_links &lt;- linelist %&gt;% \n  drop_na(age_cat) %&gt;% \n  select(hospital, age_cat) %&gt;%\n  count(hospital, age_cat) %&gt;% \n  rename(source = age_cat,          # re-name\n         target = hospital)\n\nhosp_out_links &lt;- linelist %&gt;% \n    drop_na(age_cat) %&gt;% \n    select(hospital, outcome) %&gt;% \n    count(hospital, outcome) %&gt;% \n    rename(source = hospital,       # re-name\n           target = outcome)\n\n# combine links\nlinks &lt;- bind_rows(age_hosp_links, hosp_out_links)\n\n# The unique node names\nnodes &lt;- data.frame(\n  name=c(as.character(links$source), as.character(links$target)) %&gt;% \n    unique()\n  )\n\n# Create id numbers\nlinks$IDsource &lt;- match(links$source, nodes$name)-1 \nlinks$IDtarget &lt;- match(links$target, nodes$name)-1\n\n# plot\n######\np &lt;- sankeyNetwork(Links = links,\n                   Nodes = nodes,\n                   Source = \"IDsource\",\n                   Target = \"IDtarget\",\n                   Value = \"n\",\n                   NodeID = \"name\",\n                   units = \"TWh\",\n                   fontSize = 12,\n                   nodeWidth = 30,\n                   iterations = 0)\np\n\n\n\n\n\nhttps://www.displayr.com/sankey-diagrams-r/",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Sơ đồ và biểu đồ</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.vn.html#chuỗi-sự-kiện-trong-thời-gian",
    "href": "new_pages/diagrams.vn.html#chuỗi-sự-kiện-trong-thời-gian",
    "title": "35  Sơ đồ và biểu đồ",
    "section": "35.4 Chuỗi sự kiện trong thời gian",
    "text": "35.4 Chuỗi sự kiện trong thời gian\nĐể tạo dòng thời gian hiển thị các sự kiện cụ thể, bạn có thể sử dụng package vistime.\nXem thêm vignette này\n\n# load package\npacman::p_load(vistime,  # make the timeline\n               plotly    # for interactive visualization\n               )\n\nĐây là tập dữ liệu mà chúng ta sẽ bắt đầu sử dụng:\n\n\n\n\n\n\n\np &lt;- vistime(data)    # apply vistime\n\nlibrary(plotly)\n\n# step 1: transform into a list\npp &lt;- plotly_build(p)\n\n# step 2: Marker size\nfor(i in 1:length(pp$x$data)){\n  if(pp$x$data[[i]]$mode == \"markers\") pp$x$data[[i]]$marker$size &lt;- 10\n}\n\n# step 3: text size\nfor(i in 1:length(pp$x$data)){\n  if(pp$x$data[[i]]$mode == \"text\") pp$x$data[[i]]$textfont$size &lt;- 10\n}\n\n\n# step 4: text position\nfor(i in 1:length(pp$x$data)){\n  if(pp$x$data[[i]]$mode == \"text\") pp$x$data[[i]]$textposition &lt;- \"right\"\n}\n\n#print\npp",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Sơ đồ và biểu đồ</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.vn.html#sơ-đồ-dags",
    "href": "new_pages/diagrams.vn.html#sơ-đồ-dags",
    "title": "35  Sơ đồ và biểu đồ",
    "section": "35.5 Sơ đồ DAGs",
    "text": "35.5 Sơ đồ DAGs\nBạn có thể tạo sơ đồ DAG theo cách thủ công bằng cách sử dụng package DiagammeR và ngôn ngữ DOT như đã mô tả ở trên.\nNgoài ra, có các package như ggdag và daggity\nGiới thiệu về sơ đồ DAGs\nSuy luận nhân quả với dags trong R",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Sơ đồ và biểu đồ</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.vn.html#tài-nguyên-học-liệu",
    "href": "new_pages/diagrams.vn.html#tài-nguyên-học-liệu",
    "title": "35  Sơ đồ và biểu đồ",
    "section": "35.6 Tài nguyên học liệu",
    "text": "35.6 Tài nguyên học liệu\nPhần lớn nội dung ở trên liên quan đến ngôn ngữ DOT được tham khảo từ hướng dẫn này\nMột tài liệu khác chuyên sâu hơn tại đây Tài liệu về DiagammeR\nXem thêm về Sơ đồ Sankey tại đây",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Sơ đồ và biểu đồ</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.vn.html",
    "href": "new_pages/combination_analysis.vn.html",
    "title": "36  Biểu đồ kết hợp",
    "section": "",
    "text": "36.1 Chuẩn bị",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Biểu đồ kết hợp</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.vn.html#chuẩn-bị",
    "href": "new_pages/combination_analysis.vn.html#chuẩn-bị",
    "title": "36  Biểu đồ kết hợp",
    "section": "",
    "text": "Gọi package\nĐoạn code này hiển thị việc gọi các gói cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package nếu cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R.\n\npacman::p_load(\n  tidyverse,     # data management and visualization\n  UpSetR,        # special package for combination plots\n  ggupset)       # special package for combination plots\n\n\n\n\nNhập dữ liệu\nĐể bắt đầu, chúng ta nhập bộ dữ liệu có tên linelist đã làm sạch bao gồm các trường hợp từ vụ dịch Ebola mô phỏng. Để tiện theo dõi, bấm để tải dữ liệu linelist “đã được làm sạch”  (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương Nhập xuất dữ liệu để biết thêm chi tiết.\n\n# import case linelist \nlinelist_sym &lt;- import(\"linelist_cleaned.rds\")\n\nBộ số liệu linelist bao gồm năm biến “có/không” về các triệu chứng được ghi nhận. Chúng ta sẽ cần phải biến đổi các biến số này một chút trước khi sử dụng package ggupset để tạo biểu đồ. Xem dữ liệu (cuộn sang phải để xem các biến triệu chứng).\n\n\n\n\n\n\n\n\n\nĐịnh dạng lại giá trị\nĐể tương đồng với định dạng của package ggupset, chúng ta cần đổi giá trị “yes” và “no” thành tên các triệu chứng thực tế, sử dụng hàm case_when() từ package dplyr. Nếu giá trị là “no”, chúng ta sẽ bỏ trống, nghĩa là biến mới sẽ có giá trị hoặc là NA hoặc là triệu chứng.\n\n# create column with the symptoms named, separated by semicolons\nlinelist_sym_1 &lt;- linelist_sym %&gt;% \n  \n  # convert the \"yes\" and \"no\" values into the symptom name itself\n  mutate(\n    fever = case_when(\n      fever == \"yes\" ~ \"fever\",          # if old value is \"yes\", new value is \"fever\"\n      TRUE           ~ NA_character_),   # if old value is anything other than \"yes\", the new value is NA\n         \n    chills = case_when(\n       chills == \"yes\" ~ \"chills\",\n       TRUE           ~ NA_character_),\n    \n    cough = case_when(\n      cough == \"yes\" ~ \"cough\",\n      TRUE           ~ NA_character_),\n         \n    aches = case_when(\n      aches == \"yes\" ~ \"aches\",\n      TRUE           ~ NA_character_),\n         \n    vomit = case_when(\n      vomit == \"yes\" ~ \"vomit\",\n      TRUE           ~ NA_character_)\n    )\n\nBây giờ chúng ta tạo hai cột cuối cùng:\n\nKết hợp (ghép lại với nhau) tất cả các triệu chứng của bệnh nhân (thành một cột ký tự)\n\nChuyển đổi định dạng cột bên trên thành kiểu danh sách để được chấp nhận bởi package ggupset khi vẽ biểu đồ\n\nXem thêm chương Ký tự và chuỗi để biết thêm về hàm unite() trong package stringr\n\nlinelist_sym_1 &lt;- linelist_sym_1 %&gt;% \n  unite(col = \"all_symptoms\",\n        c(fever, chills, cough, aches, vomit), \n        sep = \"; \",\n        remove = TRUE,\n        na.rm = TRUE) %&gt;% \n  mutate(\n    # make a copy of all_symptoms column, but of class \"list\" (which is required to use ggupset() in next step)\n    all_symptoms_list = as.list(strsplit(all_symptoms, \"; \"))\n    )\n\nBây giờ chúng ta cùng xem dữ liệu mới. Lưu ý hai cột ở cuối bên phải - các giá trị kết hợp được ghép và danh sách",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Biểu đồ kết hợp</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.vn.html#ggupset",
    "href": "new_pages/combination_analysis.vn.html#ggupset",
    "title": "36  Biểu đồ kết hợp",
    "section": "36.2 ggupset",
    "text": "36.2 ggupset\nGọi package\n\npacman::p_load(ggupset)\n\nVẽ biểu đồ. Chúng ta bắt đầu bằng hàm ggplot() và geom_bar(), nhưng sau đó chúng ta thêm hàm đặc biệt scale_x_upset() từ package ggupset.\n\nggplot(\n  data = linelist_sym_1,\n  mapping = aes(x = all_symptoms_list)) +\ngeom_bar() +\nscale_x_upset(\n  reverse = FALSE,\n  n_intersections = 10,\n  sets = c(\"fever\", \"chills\", \"cough\", \"aches\", \"vomit\"))+\nlabs(\n  title = \"Signs & symptoms\",\n  subtitle = \"10 most frequent combinations of signs and symptoms\",\n  caption = \"Caption here.\",\n  x = \"Symptom combination\",\n  y = \"Frequency in dataset\")\n\n\n\n\n\n\n\n\nBạn có thể đọc thêm về package ggupset ở tài liệu online này hoặc trong tài liệu trợ giúp của package bằng cách gõ vào cửa RStudio Help lệnh ?ggupset.",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Biểu đồ kết hợp</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.vn.html#upsetr",
    "href": "new_pages/combination_analysis.vn.html#upsetr",
    "title": "36  Biểu đồ kết hợp",
    "section": "36.3 UpSetR",
    "text": "36.3 UpSetR\nPackage UpSetR cho phép tùy chỉnh biểu đồ sâu hơn, nhưng nó cũng khó thực hiện hơn:\nGọi package\n\npacman::p_load(UpSetR)\n\nLàm sạch dữ liệu\nChúng ta phải chuyển đổi các triệu chứng trong bộ dữ liệu linelist thành các giá trị 1 / 0.\n\n# Make using upSetR\n\nlinelist_sym_2 &lt;- linelist_sym %&gt;% \n  \n  # convert the \"yes\" and \"no\" values into the symptom name itself\n  mutate(\n    fever = case_when(\n      fever == \"yes\" ~ 1,    # if old value is \"yes\", new value is 1\n      TRUE           ~ 0),   # if old value is anything other than \"yes\", the new value is 0\n         \n    chills = case_when(\n      chills == \"yes\" ~ 1,\n      TRUE           ~ 0),\n         \n    cough = case_when(\n      cough == \"yes\" ~ 1,\n      TRUE           ~ 0),\n         \n    aches = case_when(\n      aches == \"yes\" ~ 1,\n      TRUE           ~ 0),\n         \n    vomit = case_when(\n      vomit == \"yes\" ~ 1,\n      TRUE           ~ 0)\n    )\n\nBạn có thể tham khảo hàm +() được dùng kết hợp với hàm across() để thực hiện thay đổi trên nhiều cột cùng lúc (đọc thêm tại chương Các hàm làm sạch dữ liệu).\n\n# Efficiently convert \"yes\" to 1 and 0\nlinelist_sym_2 &lt;- linelist_sym %&gt;% \n  \n  # convert the \"yes\" and \"no\" values into 1s and 0s\n  mutate(across(c(fever, chills, cough, aches, vomit), .fns = ~+(.x == \"yes\")))\n\nBây giờ chúng ta hãy vẽ biểu đồ bằng hàm tùy chỉnh upset() - chỉ sử dụng các cột triệu chứng. Bạn phải chỉ định “bộ” nào để so sánh (tên của các cột triệu chứng). Một cách khác, sử dụng nsets = và order.by = \"freq\" để chỉ hiện thị X các sự kết hợp nhiều nhất.\n\n# Make the plot\nUpSetR::upset(\n  select(linelist_sym_2, fever, chills, cough, aches, vomit),\n  sets = c(\"fever\", \"chills\", \"cough\", \"aches\", \"vomit\"),\n  order.by = \"freq\",\n  sets.bar.color = c(\"blue\", \"red\", \"yellow\", \"darkgreen\", \"orange\"), # optional colors\n  empty.intersections = \"on\",\n  # nsets = 3,\n  number.angles = 0,\n  point.size = 3.5,\n  line.size = 2, \n  mainbar.y.label = \"Symptoms Combinations\",\n  sets.x.label = \"Patients with Symptom\")",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Biểu đồ kết hợp</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.vn.html#nguồn",
    "href": "new_pages/combination_analysis.vn.html#nguồn",
    "title": "36  Biểu đồ kết hợp",
    "section": "36.4 Nguồn",
    "text": "36.4 Nguồn\nThe github page on UpSetR\nA Shiny App version - you can upload your own data\n*documentation - difficult to interpret",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Biểu đồ kết hợp</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.vn.html",
    "href": "new_pages/transmission_chains.vn.html",
    "title": "37  Chuỗi lây nhiễm",
    "section": "",
    "text": "37.1 Tổng quan\nCông cụ chính để xử lý, phân tích và trực quan hóa chuỗi lây nhiễm và dữ liệu theo dõi tiếp xúc là package epicontacts, được phát triển bởi những chuyên gia làm việc tại RECON. Hãy thử biểu đồ tương tác bên dưới bằng cách di chuột qua các nút để biết thêm thông tin, kéo-thả để di chuyển chúng và nhấp vào chúng để đánh dấu các trường hợp phía dưới.\nWarning in epicontacts::make_epicontacts(linelist = linelist, contacts =\ncontacts, : Cycle(s) detected in the contact network: this may be unwanted",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Chuỗi lây nhiễm</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.vn.html#chuẩn-bị",
    "href": "new_pages/transmission_chains.vn.html#chuẩn-bị",
    "title": "37  Chuỗi lây nhiễm",
    "section": "37.2 Chuẩn bị",
    "text": "37.2 Chuẩn bị\n\nGọi packages\nĐầu tiên hãy tải các package tiêu chuẩn cần thiết để nhập và xử lý dữ liệu. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, sẽ cài đặt package nếu cần và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các package bằng hàm library() từ base R. Xem chương R cơ bản để biết thêm thông tin về các package trong R.\n\npacman::p_load(\n   rio,          # File import\n   here,         # File locator\n   tidyverse,    # Data management + ggplot2 graphics\n   remotes       # Package installation from github\n)\n\nBạn sẽ sử dụng phiên bản phát triển của epicontacts, có thể được cài đặt từ github bằng cách sử dụng hàm p_install_github() từ package pacman. Bạn chỉ cần chạy lệnh này dưới đây một lần, không phải bất cứ khi nào bạn sử dụng package (sau đó, bạn có thể sử dụng hàm p_load() như bình thường).\n\npacman::p_install_gh(\"reconhub/epicontacts@timeline\")\n\n\n\nNhập dữ liệu\nChúng ta nhập bộ dữ liệu về các trường hợp bệnh từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn tải xuống dữ liệu để làm theo từng bước, hãy xem hướng dẫn trong chương Tải sách và dữ liệu. Bộ dữ liệu được nhập bằng hàm import() từ package rio. Xem chương Nhập xuất dữ liệu để biết các cách nhập dữ liệu khác nhau.\n\n# import the linelist\nlinelist &lt;- import(\"linelist_cleaned.xlsx\")\n\n50 hàng đầu tiên của bộ dữ liệu linelist được hiển thị bên dưới. Mối quan tâm đặc biệt là các cột case_id, generation, infector, và source.\n\n\n\n\n\n\n\n\nTạo đối tượng epicontacts\nSau đó, chúng ta cần tạo một đối tượng epicontacts, với yêu cầu hai kiểu dữ liệu như sau:\n\nMột bộ dữ liệu linelist ghi lại các trường hợp trong đó các cột là các biến và các hàng tương ứng với các trường hợp duy nhất\nMột danh sách các cạnh (edge) thể hiện liên kết giữa các quan sát trên ID duy nhất (có thể là liên hệ, sự kiện lây nhiễm, v.v.)\n\nBởi vì chúng ta đã có sẵn bộ dữ liệu linelist, chúng ta chỉ cần tạo một danh sách các đường liên kết giữa các trường hợp, cụ thể hơn là giữa các ID. Chúng ta có thể trích xuất các đường liên kết lây nhiễm từ bộ số liệu linelist bằng cách liên kết cột infector với cột case_id. Tại đây, chúng ta cũng có thể thêm các “thuộc tính cạnh - edge properties”, nghĩa là bất kỳ biến nào mô tả mối liên kết giữa hai trường hợp, không phải bản thân các trường hợp đó. Để minh họa, chúng ta sẽ thêm một biến location mô tả vị trí của sự kiện truyền nhiễm và một biến mô tả khoảng thời gian tiếp xúc tính bằng ngày.\nTrong đoạn code dưới đây, hàm transmute thuộc package dplyr tương tự như hàm mutate, ngoại trừ nó chỉ giữ các cột mà chúng ta đã chỉ định trong hàm. Hàm drop_na sẽ lọc ra bất kỳ hàng nào mà các cột được chỉ định có giá trị NA ; trong trường hợp này, chúng ta chỉ muốn giữ lại các hàng mà tác nhân lây nhiễm đã biết.\n\n## generate contacts\ncontacts &lt;- linelist %&gt;%\n  transmute(\n    infector = infector,\n    case_id = case_id,\n    location = sample(c(\"Community\", \"Nosocomial\"), n(), TRUE),\n    duration = sample.int(10, n(), TRUE)\n  ) %&gt;%\n  drop_na(infector)\n\nBây giờ chúng ta có thể tạo đối tượng epicontacts bằng cách sử dụng hàm make_epicontacts. Chúng ta cần chỉ định cột trong bộ dữ liệu linelist trỏ đến mã định danh trường hợp duy nhất (ID), cũng như cột trong điểm tiếp xúc tới mã định danh duy nhất của các trường hợp có liên quan trong mỗi liên kết. Các liên kết này có tính định hướng, nghĩa là việc lây nhiễm sẽ đi từ người lây nhiễm đến ca bệnh, vì vậy chúng ta cần chỉ định các đối số from và to cho phù hợp. Chúng ta cũng đặt đối số directed thành TRUE, điều này sẽ ảnh hưởng đến các hoạt động về sau.\n\n## generate epicontacts object\nepic &lt;- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts,\n  id = \"case_id\",\n  from = \"infector\",\n  to = \"case_id\",\n  directed = TRUE\n)\n\nWarning in make_epicontacts(linelist = linelist, contacts = contacts, id =\n\"case_id\", : Cycle(s) detected in the contact network: this may be unwanted\n\n\nSau khi kiểm tra các đối tượng epicontacts, chúng ta có thể thấy rằng cột case_id trong bộ dữ liệu linelist đã được đổi tên thành id và các cột case_id và cột infector trong liên hệ đã được đổi tên thành from và to. Điều này đảm bảo tính nhất quán trong các hoạt động xử lý, trực quan và phân tích tiếp theo.\n\n## view epicontacts object\nepic\n\n\n/// Epidemiological Contacts //\n\n  // class: epicontacts\n  // 5,888 cases in linelist; 3,800 contacts; directed \n\n  // linelist\n\n# A tibble: 5,888 × 30\n   id     generation date_infection date_onset date_hospitalisation date_outcome\n   &lt;chr&gt;       &lt;dbl&gt; &lt;date&gt;         &lt;date&gt;     &lt;date&gt;               &lt;date&gt;      \n 1 5fe599          4 2014-05-08     2014-05-13 2014-05-15           NA          \n 2 8689b7          4 NA             2014-05-13 2014-05-14           2014-05-18  \n 3 11f8ea          2 NA             2014-05-16 2014-05-18           2014-05-30  \n 4 b8812a          3 2014-05-04     2014-05-18 2014-05-20           NA          \n 5 893f25          3 2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n 6 be99c8          3 2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n 7 07e3e8          4 2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n 8 369449          4 2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n 9 f393b4          4 NA             2014-06-05 2014-06-06           2014-06-18  \n10 1389ca          4 NA             2014-06-05 2014-06-07           2014-06-09  \n# ℹ 5,878 more rows\n# ℹ 24 more variables: outcome &lt;chr&gt;, gender &lt;chr&gt;, age &lt;dbl&gt;, age_unit &lt;chr&gt;,\n#   age_years &lt;dbl&gt;, age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;, hospital &lt;chr&gt;, lon &lt;dbl&gt;,\n#   lat &lt;dbl&gt;, infector &lt;chr&gt;, source &lt;chr&gt;, wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;,\n#   ct_blood &lt;dbl&gt;, fever &lt;chr&gt;, chills &lt;chr&gt;, cough &lt;chr&gt;, aches &lt;chr&gt;,\n#   vomit &lt;chr&gt;, temp &lt;dbl&gt;, time_admission &lt;chr&gt;, bmi &lt;dbl&gt;,\n#   days_onset_hosp &lt;dbl&gt;\n\n  // contacts\n\n# A tibble: 3,800 × 4\n   from   to     location   duration\n   &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;         &lt;int&gt;\n 1 f547d6 5fe599 Community         6\n 2 f90f5f b8812a Community        10\n 3 11f8ea 893f25 Community         6\n 4 aec8ec be99c8 Nosocomial        8\n 5 893f25 07e3e8 Community         7\n 6 133ee7 369449 Community         7\n 7 996f3a 2978ac Community         6\n 8 133ee7 57a565 Community         3\n 9 37a6f6 fc15ef Nosocomial        1\n10 9f6884 2eaa9a Community         1\n# ℹ 3,790 more rows",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Chuỗi lây nhiễm</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.vn.html#xử-lý",
    "href": "new_pages/transmission_chains.vn.html#xử-lý",
    "title": "37  Chuỗi lây nhiễm",
    "section": "37.3 Xử lý",
    "text": "37.3 Xử lý\n\nChia nhỏ bộ dữ liệu\nPhương thức subset() cho các đối tượng epicontacts cho phép lọc các mạng lưới dựa trên các thuộc tính của bộ dữ liệu linelist (“thuộc tính nút”) và cơ sở dữ liệu tiếp xýc (“thuộc tính cạnh”). Các giá trị này phải được chuyển đổi dưới dạng danh sách đã đặt tên cho đối số tương ứng. Ví dụ: trong đoạn code bên dưới, chúng tôi chỉ giữ lại các trường hợp nam giới trong bộ số liệu linelist có ngày lây nhiễm từ tháng 4 đến tháng 7 năm 2014 (ngày tháng được chỉ định dưới dạng khoảng) và các liên kết lây nhiễm xảy ra trong bệnh viện.\n\nsub_attributes &lt;- subset(\n  epic,\n  node_attribute = list(\n    gender = \"m\",\n    date_infection = as.Date(c(\"2014-04-01\", \"2014-07-01\"))\n  ), \n  edge_attribute = list(location = \"Nosocomial\")\n)\nsub_attributes\n\n\n/// Epidemiological Contacts //\n\n  // class: epicontacts\n  // 69 cases in linelist; 1,859 contacts; directed \n\n  // linelist\n\n# A tibble: 69 × 30\n   id     generation date_infection date_onset date_hospitalisation date_outcome\n   &lt;chr&gt;       &lt;dbl&gt; &lt;date&gt;         &lt;date&gt;     &lt;date&gt;               &lt;date&gt;      \n 1 5fe599          4 2014-05-08     2014-05-13 2014-05-15           NA          \n 2 893f25          3 2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n 3 2978ac          4 2014-05-30     2014-06-06 2014-06-08           2014-06-15  \n 4 57a565          4 2014-05-28     2014-06-13 2014-06-15           NA          \n 5 fc15ef          6 2014-06-14     2014-06-16 2014-06-17           2014-07-09  \n 6 99e8fa          7 2014-06-24     2014-06-28 2014-06-29           2014-07-09  \n 7 f327be          6 2014-06-14     2014-07-12 2014-07-13           2014-07-14  \n 8 90e5fe          5 2014-06-18     2014-07-13 2014-07-14           2014-07-16  \n 9 a47529          5 2014-06-13     2014-07-17 2014-07-18           2014-07-26  \n10 da8ecb          5 2014-06-20     2014-07-18 2014-07-20           2014-08-01  \n# ℹ 59 more rows\n# ℹ 24 more variables: outcome &lt;chr&gt;, gender &lt;chr&gt;, age &lt;dbl&gt;, age_unit &lt;chr&gt;,\n#   age_years &lt;dbl&gt;, age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;, hospital &lt;chr&gt;, lon &lt;dbl&gt;,\n#   lat &lt;dbl&gt;, infector &lt;chr&gt;, source &lt;chr&gt;, wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;,\n#   ct_blood &lt;dbl&gt;, fever &lt;chr&gt;, chills &lt;chr&gt;, cough &lt;chr&gt;, aches &lt;chr&gt;,\n#   vomit &lt;chr&gt;, temp &lt;dbl&gt;, time_admission &lt;chr&gt;, bmi &lt;dbl&gt;,\n#   days_onset_hosp &lt;dbl&gt;\n\n  // contacts\n\n# A tibble: 1,859 × 4\n   from   to     location   duration\n   &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;         &lt;int&gt;\n 1 aec8ec be99c8 Nosocomial        8\n 2 37a6f6 fc15ef Nosocomial        1\n 3 8e104d ddddee Nosocomial       10\n 4 5d9e4d 8bd1e8 Nosocomial        8\n 5 beb26e 959170 Nosocomial        8\n 6 a2086d a47529 Nosocomial        8\n 7 d6584f f5c142 Nosocomial        2\n 8 f5c142 c71dcd Nosocomial       10\n 9 d05405 316781 Nosocomial        5\n10 700448 422831 Nosocomial        1\n# ℹ 1,849 more rows\n\n\nChúng ta có thể sử dụng hàm thin để lọc trong bộ số liệu linelist để bao gồm các trường hợp được tìm thấy trong danh sách “contacts” bằng cách đặt đối số what = \"linelist\", hoặc lọc trong danh sách “contacts” để bao gồm các trường hợp được tìm thấy trong bộ số liệu linelist bằng cách đặt đối số what = \"contacts\". Trong đoạn code dưới đây, chúng ta đang lọc thêm từ đối tượng epicontacts để chỉ giữ lại các đường liên kết lây nhiễm có liên quan đến các trường hợp nam giới bị lây nhiễm giữa tháng 4 và tháng 7 mà chúng ta đã lọc ở trên. Chúng ta có thể thấy rằng chỉ có hai liên kết lây nhiễm đã biết phù hợp với đặc điểm đó.\n\nsub_attributes &lt;- thin(sub_attributes, what = \"contacts\")\nnrow(sub_attributes$contacts)\n\n[1] 4\n\n\nBên cạnh việc subset theo thuộc tính nút (node) và cạnh (edge), các mạng liên kết có thể được cắt tỉa để chỉ bao gồm các thành phần được kết nối với một số nút nhất định. Đối số cluster_id sẽ lấy một vectơ chứa ID các ca bệnh và trả về danh sách của các cá nhân được liên kết một cách trực tiếp hoặc gián tiếp tới các ID đó. Trong đoạn code dưới đây, chúng ta có thể thấy rằng tổng cộng 13 trường hợp trong bộ số liệu linelist có liên quan đến các cụm chứa 2ae019 và 71577a.\n\nsub_id &lt;- subset(epic, cluster_id = c(\"2ae019\",\"71577a\"))\nnrow(sub_id$linelist)\n\n[1] 13\n\n\nPhương pháo subset() cho các đối tượng epicontacts cũng cho phép lọc theo kích thước cụm bằng cách sử dụng các đối số cs, cs_min và cs_max. Trong đoạn code bên dưới, chúng ta chỉ giữ lại các trường hợp được liên kết với các cụm 10 trường hợp hoặc lớn hơn và có thể thấy rằng 271 trường hợp trong trong bộ số liệu linelist có liên quan đến các cụm đó.\n\nsub_cs &lt;- subset(epic, cs_min = 10)\nnrow(sub_cs$linelist)\n\n[1] 271\n\n\n\n\nTruy cập thông tin ID\nHàm get_id() truy xuất thông tin về ID ca bệnh trong bộ dữ liệu và có thể được tham số hóa như sau:\n\nlinelist: ID trong bộ dữ liệu linelist\ncontacts: ID trong bộ dữ liệu contact (kết hợp “from” và “to”)\nfrom: ID trong cột “from” của bộ dữ liệu contact\nto: ID trong cột “to” của bộ dữ liệu contact\nall: các ID xuất hiện ở bất kỳ một trong hai bộ dữ liệu\ncommon: các ID xuất hiện trong cả bộ dữ liệu contact và bộ dữ liệu linelist\n\nVí dụ: xem 10 ID đầu tiên trong bộ dữ liệu contact?\n\ncontacts_ids &lt;- get_id(epic, \"contacts\")\nhead(contacts_ids, n = 10)\n\n [1] \"f547d6\" \"f90f5f\" \"11f8ea\" \"aec8ec\" \"893f25\" \"133ee7\" \"996f3a\" \"37a6f6\"\n [9] \"9f6884\" \"4802b1\"\n\n\nCó bao nhiêu ID được tìm thấy trong cả hai bộ dữ liệu tiếp xúc và linelist?\n\nlength(get_id(epic, \"common\"))\n\n[1] 4352",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Chuỗi lây nhiễm</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.vn.html#trực-quan-hóa",
    "href": "new_pages/transmission_chains.vn.html#trực-quan-hóa",
    "title": "37  Chuỗi lây nhiễm",
    "section": "37.4 Trực quan hóa",
    "text": "37.4 Trực quan hóa\n\nBiểu đồ cơ bản\nTất cả các hình ảnh trực quan của các đối tượng epicontacts được xử lý bởi hàm plot. Trước tiên, chúng ta sẽ lọc đối tượng epicontacts để chỉ bao gồm các trường hợp có ngày bắt đầu vào tháng 6 năm 2014 bằng cách sử dụng hàm subset, và chỉ bao gồm các tiếp xúc được liên kết với các trường hợp đó bằng cách sử dụng hàm thin.\n\n## subset epicontacts object\nsub &lt;- epic %&gt;%\n  subset(\n    node_attribute = list(date_onset = c(as.Date(c(\"2014-06-30\", \"2014-06-01\"))))\n  ) %&gt;%\n thin(\"contacts\")\n\nSau đó, chúng ta có thể tạo biểu đồ cơ bản, có tính tương tác rất đơn giản như sau:\n\n## plot epicontacts object\nplot(\n  sub,\n  width = 700,\n  height = 700\n)\n\n\n\n\n\nBạn có thể di chuyển các nút xung quanh bằng cách kéo chúng, di chuột qua chúng để biết thêm thông tin và nhấp vào chúng để đánh dấu các trường hợp được kết nối.\nCó một số lượng lớn các đối số để tùy chỉnh biểu đồ này. Chúng ta sẽ trình bày những vấn đề chính ở đây, nhưng bạn có thể xem thêm tài liệu thông qua lệnh ?vis_epicontacts (hàm được gọi khi sử dụng biểu đồ trên đối tượng epicontacts) để có được mô tả đầy đủ về các đối số của hàm.\n\nTrực quan hóa các thuộc tính của nút\nMàu nút, hình dạng nút và kích thước nút có thể được ánh xạ tới một cột nhất định trong bộ số liệu linelist bằng cách sử dụng các đối số node_color, node_shape và node_size. Điều này tương tự với cú pháp aes mà bạn có thể thấy trong ggplot2.\nMàu sắc, hình dạng và kích thước cụ thể của các nút có thể được chỉ định như sau:\n\nMàu sắc thông qua đối số col_pal, bằng cách cung cấp một danh sách tên được chỉ định cho từng màu cụ thể như được thực hiện bên dưới hoặc bằng cách cung cấp một hàm bảng màu như colorRampPalette(c(\"black\", \"red\", \"orange\")), mà sẽ giúp cung cấp một dải màu giữa các màu được chỉ định.\nHình dạng bằng cách chuyển một danh sách đã đặt tên đến đối số shapes, chỉ định một hình dạng cho mỗi phần tử duy nhất trong cột bộ số liệu linelist được chỉ định bởi đối số node_shape. Xem codeawesome để biết các hình dạng có sẵn.\nKích thước bằng cách chuyển một phạm vi kích thước của các nút tới đối số size_range.\n\nDưới đây là một ví dụ, trong đó màu sắc thể hiện cho outcome, hình dạng thể hiện cho giới tính và kích thước thể hiện cho độ tuổi:\n\nplot(\n  sub, \n  node_color = \"outcome\",\n  node_shape = \"gender\",\n  node_size = \"age\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  shapes = c(f = \"female\", m = \"male\"),\n  size_range = c(40, 60),\n  height = 700,\n  width = 700\n)\n\n\n\n\n\n\n\nTrực quan hóa các thuộc tính cạnh\nMàu, độ dày và kiểu đường có thể được ánh xạ tới một cột nhất định trong bộ dữ liệu tiếp xúc bằng cách sử dụng các đối số edge_color, edge_width và edge_linetype. Các màu cụ và độ dày của các cạnh có thể được chỉ định như sau:\n\nMàu sắc thông qua đối số edge_col_pal, theo cách tương tự được sử dụng cho col_pal.\nĐộ rộng bằng cách chuyển phạm vi kích thước của các nút tới đối số width_range.\n\nDưới đây là ví dụ:\n\nplot(\n  sub, \n  node_color = \"outcome\",\n  node_shape = \"gender\",\n  node_size = 'age',\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  shapes = c(f = \"female\", m = \"male\"),\n  size_range = c(40, 60),\n  edge_color = 'location',\n  edge_linetype = 'location',\n  edge_width = 'duration',\n  edge_col_pal = c(Community = \"orange\", Nosocomial = \"purple\"),\n  width_range = c(1, 3),\n  height = 700,\n  width = 700\n)\n\n\n\n\n\n\n\n\nTrục thời gian\nChúng ta cũng có thể trực quan hóa mạng lây nhiễm dọc theo trục thời gian bằng cách ánh xạ đối số x_axis vào một cột trong bộ số liệu linelist. Trong ví dụ dưới đây, trục x biểu thị ngày bắt đầu triệu chứng. Chúng ta cũng đã chỉ định đối số arrow_size để đảm bảo các mũi tên không quá lớn và đặt label = FALSE để làm cho hình bớt lộn xộn.\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n\n\n\n\n\nCó một số lượng lớn các đối số bổ sung để cụ thể hơn cách mà mạng lưới này được hiển thị dọc theo trục thời gian, bạn có thể kiểm tra thông qua lệnh ?vis_temporal_interactive (hàm được gọi khi sử dụng hàm plot trên đối tượng epicontacts với đối số x_axis được chỉ định). Chúng tôi sẽ mô tả kỹ hơn ở bên dưới.\n\nChỉ định hình dạng cây lây nhiễm\nCó hai hình dạng chính mà cây lây nhiễm có thể giả định, được chỉ định bằng cách sử dụng đối số network_shape. Đầu tiên là hình dạng nhánh branching như hình trên, trong đó một cạnh thẳng nối hai nút bất kỳ. Đây là cách trình bày trực quan nhất, tuy nhiên có thể dẫn đến các cạnh chồng lên nhau trong một mạng kết nối dày đặc. Kiểu hình thứ hai là rectangle, sẽ tạo ra một cái cây giống như cây phát sinh loài. Ví dụ:\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n\n\n\n\n\nMỗi nút có thể được gán một vị trí dọc duy nhất bằng cách chuyển đổi đối số position_dodge. Vị trí của các trường hợp không được kết nối (tức là không có lây nhiễm được báo cáo) được xác định bằng cách sử dụng đối số unlinked_pos.\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  position_dodge = TRUE,\n  unlinked_pos = \"bottom\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n\n\n\n\n\nVị trí của nút “mẹ” so với các nút “con” có thể được xác định bằng cách sử dụng đối số parent_pos. Tùy chọn mặc định là đặt nút “mẹ” ở giữa, tuy nhiên nó có thể được đặt ở dưới cùng (parent_pos = 'bottom') hoặc ở trên cùng (parent_pos = 'top').\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  parent_pos = \"top\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n\n\n\n\n\n\n\nLưu biểu đồ\nBạn có thể lưu một biểu đồ dưới dạng tệp tin html tương tác, độc lập với hàm visSave từ package VisNetwork:\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  parent_pos = \"top\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n) %&gt;%\n  visNetwork::visSave(\"network.html\")\n\nRất tiếc, việc lưu các kết quả đầu ra mạng lưới lây nhiễm này dưới dạng hình ảnh trở nên khó khăn và bạn cần lưu dưới dạng tệp tin html và sau đó chụp ảnh màn hình của tệp tin này bằng backage webshot. Trong đoạn code dưới đây, chúng ta đang chuyển đổi tệp tin html được lưu ở trên thành dạng file ảnh PNG:\n\nwebshot(url = \"network.html\", file = \"network.png\")\n\n\n\n\nDòng thời gian\nBạn cũng có thể thêm dòng thời gian cho mạng lưới truyền nhiễm, được biểu diễn trên trục x của mỗi trường hợp. Nó có thể được sử dụng để trực quan hóa các vị trí ca bệnh, hoặc thời gian dẫn đến outcome. Để tạo dòng thời gian, chúng ta cần tạo một data.frame gồm ít nhất ba cột bao gồm ID, ngày bắt đầu của “sự kiện” và ngày kết thúc của “sự kiện”. Bạn cũng có thể thêm bất kỳ cột giá trị nào khác mà sau đó có thể được ánh xạ tới các thuộc tính nút và cạnh của dòng thời gian. Trong đoạn code dưới đây, chúng ta tạo một dòng thời gian từ ngày bắt đầu có triệu chứng đến ngày có outcome và giữ các biến outcome và bệnh viện mà chúng ta đã sử dụng để xác định hình dạng và màu sắc của nút. Lưu ý rằng bạn có thể có nhiều hơn một dòng thời gian hàng/sự kiện cho mỗi trường hợp, ví dụ: nếu một trường hợp được chuyển viện giữa nhiều bệnh viện.\n\n## generate timeline\ntimeline &lt;- linelist %&gt;%\n  transmute(\n    id = case_id,\n    start = date_onset,\n    end = date_outcome,\n    outcome = outcome,\n    hospital = hospital\n  )\n\nSau đó, chúng ta chuyển phần tử dòng thời gian vào đối số timeline. Chúng ta có thể ánh xạ các thuộc tính dòng thời gian với màu sắc, hình dạng và kích thước của nút dòng thời gian theo cùng một cách đã xác định trong các phần trước, ngoại trừ việc chúng ta có hai nút: nút bắt đầu và nút kết thúc của mỗi dòng thời gian, có các đối số riêng biệt. Ví dụ: tl_start_node_color xác định cột dòng thời gian nào được ánh xạ với màu của nút bắt đầu, trong khi tl_end_node_shape xác định cột dòng thời gian nào được ánh xạ tới hình dạng của nút kết thúc. Chúng ta cũng có thể ánh xạ màu, độ dày, kiểu đường kẻ và nhãn vào cạnh dòng thời gian thông qua các đối số tl_edge_.\nXem ?vis_temporal_interactive (hàm được gọi khi vẽ biểu đồ một đối tượng epicontacts) để biết tài liệu chi tiết về các đối số. Mỗi đối số cũng được chú thích trong đoạn code bên dưới:\n\n## define shapes\nshapes &lt;- c(\n  f = \"female\",\n  m = \"male\",\n  Death = \"user-times\",\n  Recover = \"heartbeat\",\n  \"NA\" = \"question-circle\"\n)\n\n## define colours\ncolours &lt;- c(\n  Death = \"firebrick\",\n  Recover = \"green\",\n  \"NA\" = \"grey\"\n)\n\n## make plot\nplot(\n  sub,\n  ## max x coordinate to date of onset\n  x_axis = \"date_onset\",\n  ## use rectangular network shape\n  network_shape = \"rectangle\",\n  ## mape case node shapes to gender column\n  node_shape = \"gender\",\n  ## we don't want to map node colour to any columns - this is important as the\n  ## default value is to map to node id, which will mess up the colour scheme\n  node_color = NULL,\n  ## set case node size to 30 (as this is not a character, node_size is not\n  ## mapped to a column but instead interpreted as the actual node size)\n  node_size = 30,\n  ## set transmission link width to 4 (as this is not a character, edge_width is\n  ## not mapped to a column but instead interpreted as the actual edge width)\n  edge_width = 4,\n  ## provide the timeline object\n  timeline = timeline,\n  ## map the shape of the end node to the outcome column in the timeline object\n  tl_end_node_shape = \"outcome\",\n  ## set the size of the end node to 15 (as this is not a character, this\n  ## argument is not mapped to a column but instead interpreted as the actual\n  ## node size)\n  tl_end_node_size = 15,\n  ## map the colour of the timeline edge to the hospital column\n  tl_edge_color = \"hospital\",\n  ## set the width of the timeline edge to 2 (as this is not a character, this\n  ## argument is not mapped to a column but instead interpreted as the actual\n  ## edge width)\n  tl_edge_width = 2,\n  ## map edge labels to the hospital variable\n  tl_edge_label = \"hospital\",\n  ## specify the shape for everyone node attribute (defined above)\n  shapes = shapes,\n  ## specify the colour palette (defined above)\n  col_pal = colours,\n  ## set the size of the arrow to 0.5\n  arrow_size = 0.5,\n  ## use two columns in the legend\n  legend_ncol = 2,\n  ## set font size\n  font_size = 15,\n  ## define formatting for dates\n  date_labels = c(\"%d %b %Y\"),\n  ## don't plot the ID labels below nodes\n  label = FALSE,\n  ## specify height\n  height = 1000,\n  ## specify width\n  width = 1200,\n  ## ensure each case node has a unique y-coordinate - this is very important\n  ## when using timelines, otherwise you will have overlapping timelines from\n  ## different cases\n  position_dodge = TRUE\n)\n\nWarning in assert_timeline(timeline, x, x_axis): 5865 timeline row(s) removed\nas ID not found in linelist or start/end date is NA",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Chuỗi lây nhiễm</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.vn.html#phân-tích",
    "href": "new_pages/transmission_chains.vn.html#phân-tích",
    "title": "37  Chuỗi lây nhiễm",
    "section": "37.5 Phân tích",
    "text": "37.5 Phân tích\n\nTổng hợp\nChúng ta có thể xem tổng quan về một số thuộc tính mạng lưới bằng cách sử dụng hàm summary.\n\n## summarise epicontacts object\nsummary(epic)\n\n\n/// Overview //\n  // number of unique IDs in linelist: 5888\n  // number of unique IDs in contacts: 5511\n  // number of unique IDs in both: 4352\n  // number of contacts: 3800\n  // contacts with both cases in linelist: 56.868 %\n\n/// Degrees of the network //\n  // in-degree summary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.0000  0.0000  1.0000  0.5392  1.0000  1.0000 \n\n  // out-degree summary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.0000  0.0000  0.0000  0.5392  1.0000  6.0000 \n\n  // in and out degree summary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   1.000   1.000   1.078   1.000   7.000 \n\n/// Attributes //\n  // attributes in linelist:\n generation date_infection date_onset date_hospitalisation date_outcome outcome gender age age_unit age_years age_cat age_cat5 hospital lon lat infector source wt_kg ht_cm ct_blood fever chills cough aches vomit temp time_admission bmi days_onset_hosp\n\n  // attributes in contacts:\n location duration\n\n\nVí dụ, chúng ta có thể thấy rằng chỉ có 57% các tiếp xúc có cả hai trường hợp trong bộ số liệu linelist; điều này có nghĩa là chúng ta không có dữ liệu trong bộ số liệu linelist về một số lượng đáng kể các trường hợp liên quan đến các chuỗi lây nhiễm này.\n\n\nĐặc điểm ghép cặp\nHàm get_pairwise() cho phép xử lý (các) biến trong bộ số liệu linelist theo từng cặp trong bộ dữ liệu tiếp xúc. Ở ví dụ dưới đây, ngày khởi phát bệnh được trích xuất từ bộ số liệu linelist để tính toán sự khác biệt giữa ngày khởi phát bệnh cho từng cặp. Giá trị được tạo ra từ phép so sánh này đại diện cho khoảng nối tiếp (serial interval - si).\n\nsi &lt;- get_pairwise(epic, \"date_onset\")   \nsummary(si)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00    5.00    9.00   11.01   15.00   99.00    1820 \n\ntibble(si = si) %&gt;%\n  ggplot(aes(si)) +\n  geom_histogram() +\n  labs(\n    x = \"Serial interval\",\n    y = \"Frequency\"\n  )\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\nWarning: Removed 1820 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\nget_pairwise() sẽ diễn giải phân lớp của cột đang được sử dụng để so sánh và sẽ điều chỉnh phương pháp so sánh các giá trị của nó cho phù hợp. Đối với số và ngày (như ví dụ si ở trên), hàm sẽ trừ các giá trị. Khi được áp dụng cho các cột là ký tự hoặc phân loại, get_pairwise() sẽ gán các giá trị lại với nhau. Bởi vì hàm cũng cho phép xử lý tùy ý (xem đối số “f”), các kết hợp rời rạc này có thể dễ dàng được mô tả và phân tích.\n\nhead(get_pairwise(epic, \"gender\"), n = 10)\n\n [1] \"f -&gt; m\" NA       \"m -&gt; m\" NA       \"m -&gt; f\" \"f -&gt; f\" NA       \"f -&gt; m\"\n [9] NA       \"m -&gt; f\"\n\nget_pairwise(epic, \"gender\", f = table)\n\n           values.to\nvalues.from   f   m\n          f 464 516\n          m 510 468\n\nfisher.test(get_pairwise(epic, \"gender\", f = table))\n\n\n    Fisher's Exact Test for Count Data\n\ndata:  get_pairwise(epic, \"gender\", f = table)\np-value = 0.03758\nalternative hypothesis: true odds ratio is not equal to 1\n95 percent confidence interval:\n 0.6882761 0.9892811\nsample estimates:\nodds ratio \n 0.8252575 \n\n\nỞ đây, chúng ta thấy có một mối liên hệ lớn giữa các liên kết lây nhiễm và giới tính.\n\n\nXác định cụm\nHàm get_clusters() có thể được sử dụng để xác định các thành phần được kết nối trong một đối tượng epicontacts. Đầu tiên, chúng ta sử dụng nó để truy xuất data.frame chứa thông tin cụm:\n\nclust &lt;- get_clusters(epic, output = \"data.frame\")\ntable(clust$cluster_size)\n\n\n   1    2    3    4    5    6    7    8    9   10   11   12   13   14 \n1536 1680 1182  784  545  342  308  208  171  100   99   24   26   42 \n\nggplot(clust, aes(cluster_size)) +\n  geom_bar() +\n  labs(\n    x = \"Cluster size\",\n    y = \"Frequency\"\n  )\n\n\n\n\n\n\n\n\nGiờ chúng ta hãy xem xét các cụm lớn nhất. Đối với điều này, chúng ta thêm thông tin cụm vào đối tượng epicontacts và sau đó subset nó để chỉ giữ lại các cụm lớn nhất:\n\nepic &lt;- get_clusters(epic)\nmax_size &lt;- max(epic$linelist$cluster_size)\nplot(subset(epic, cs = max_size))\n\n\n\n\n\n\n\nTính toán mức độ\nMức độ của một nút tương ứng với số cạnh hoặc kết nối của nó với các nút khác. get_degree() cung cấp một phương pháp dễ dàng để tính toán giá trị này cho các mạng lưới epicontacts. Mức độ cao trong ngữ cảnh này cho biết một cá nhân đã tiếp xúc với nhiều người khác. Đối sôs type chỉ ra rằng chúng ta muốn đếm cả mức độ trong và ngoài, đối số only_linelist chỉ ra rằng chúng ta chỉ muốn tính mức độ cho các trường hợp trong bộ số liệu linelist.\n\ndeg_both &lt;- get_degree(epic, type = \"both\", only_linelist = TRUE)\n\nNhững cá nhân nào có 10 tiếp xúc?\n\nhead(sort(deg_both, decreasing = TRUE), 10)\n\n916d0a 858426 6833d7 f093ea 11f8ea 3a4372 38fc71 c8c4d5 a127a7 02d8fd \n     7      6      6      6      5      5      5      5      5      5 \n\n\nSố lượng lây nhiễm trung bình là bao nhiêu?\n\nmean(deg_both)\n\n[1] 1.078473",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Chuỗi lây nhiễm</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.vn.html#tham-khảo",
    "href": "new_pages/transmission_chains.vn.html#tham-khảo",
    "title": "37  Chuỗi lây nhiễm",
    "section": "37.6 Tham khảo",
    "text": "37.6 Tham khảo\nEpicontacts page cung cấp tổng quan về các hàm và package bao gồm một số thông tin chi tiết chuyên sâu hơn.\nGithub page có thể được sử dụng để nêu vấn đề và yêu cầu chỉnh sửa.",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Chuỗi lây nhiễm</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.vn.html",
    "href": "new_pages/phylogenetic_trees.vn.html",
    "title": "38  Cây phả hệ",
    "section": "",
    "text": "38.1 Tổng quan\nCây phả hệ được sử dụng để trực quan hóa và mô tả mối liên hệ cũng như sự tiến hóa của các sinh vật dựa trên trình tự mã di truyền của chúng.\nChúng có thể được xây dựng từ trình tự di truyền bằng các phương pháp dựa trên khoảng cách (distance-based methods) (chẳng hạn như phương pháp neighbor-joining) hoặc các phương pháp dựa trên ký tự (character-based methods) (chẳng hạn như phương pháp maximum likelihood và Bayesian Markov Chain Monte Carlo). Công nghệ giải trình tự gen thế hệ mới (Next Generation Sequencing - NGS) có giá thành ngày càng hợp lý và ngày càng được sử dụng rộng rãi hơn trong y tế công cộng để mô tả các mầm bệnh gây ra các bệnh truyền nhiễm. Các thiết bị giải trình tự di động giúp giảm thời gian quay vòng và hứa hẹn cung cấp dữ liệu để hỗ trợ điều tra ổ dịch trong thời gian thực. Dữ liệu NGS có thể được sử dụng để xác định nguồn gốc hoặc nguồn gốc của một chủng bùng phát và sự lan truyền của nó, cũng như xác định sự hiện diện của các gen kháng thuốc kháng sinh. Để trực quan hóa mối quan hệ di truyền giữa các mẫu, một cây phát sinh loài được xây dựng.\nTrong chương này chúng ta sẽ học cách sử dụng package ggtree, cho phép kết hợp cây phả hệ với dữ liệu bổ sung dưới dạng một dataframe. Điều này sẽ cho phép chúng ta quan sát các xu hướng và nâng cao hiểu biết về động học của dịch bệnh.",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Cây phả hệ</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.vn.html#chuẩn-bị",
    "href": "new_pages/phylogenetic_trees.vn.html#chuẩn-bị",
    "title": "38  Cây phả hệ",
    "section": "38.2 Chuẩn bị",
    "text": "38.2 Chuẩn bị\n\nGọi packages\nĐoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R.\n\npacman::p_load(\n  rio,             # import/export\n  here,            # relative file paths\n  tidyverse,       # general data management and visualization\n  ape,             # to import and export phylogenetic files\n  ggtree,          # to visualize phylogenetic files\n  treeio,          # to visualize phylogenetic files\n  ggnewscale)      # to add additional layers of color schemes\n\n\n\nNhập dữ liệu\nDữ liệu sử dụng trong chương này có thể tải xuống với hướng dẫn từ chương Tải sách và dữ liệu.\nCó một số định dạng khác nhau mà cây phát sinh loài có thể được lưu trữ (vd: Newick, NEXUS, Phylip). Định dạng phổ biến là ở dạng tệp Newick (.nwk), là tiêu chuẩn để biểu diễn cây ở dạng máy tính có thể đọc được. Điều này có nghĩa là toàn bộ cây có thể được biểu diễn ở định dạng chuỗi chẳng hạn như “((t2:0.04,t1:0.34):0.89,(t5:0.37,(t4:0.03,t3:0.67):0.9):0.59);”, liệt kê toàn bộ các nút và tips cũng như mối quan hệ của chúng (độ dài nhánh) với nhau.\nLưu ý: Điều quan trọng là phải hiểu rằng bản thân tệp cây phát sinh loài không chứa dữ liệu trình tự, mà chỉ đơn thuần là kết quả của khoảng cách gen giữa các trình tự. Do đó, chúng ta không thể trích xuất dữ liệu trình tự từ tệp cây.\nĐầu tiên, chúng ta sử dụng hàm read.tree() từ package ape để nhập một tệp cây phát sinh loài Newick ở định dạng .txt, và lưu nó dưới dạng một đối tượng danh sách với kiểu dữ liệu (class) “phylo”. Nếu cần, hãy sử dụng hàm here() từ package here để chỉ định đường dẫn tệp tương đối.\nLưu ý: Trong trường hợp này, newick tree được lưu dưới dạng tệp .txt để dễ dàng xử lý và tải xuống từ Github.\n\ntree &lt;- ape::read.tree(\"Shigella_tree.txt\")\n\nChúng ta khảo sát đối tượng cây của chúng ta và thấy nó chứa 299 tips (hoặc mẫu) và 236 nút (nodes).\n\ntree\n\n\nPhylogenetic tree with 299 tips and 236 internal nodes.\n\nTip labels:\n  SRR5006072, SRR4192106, S18BD07865, S18BD00489, S17BD08906, S17BD05939, ...\nNode labels:\n  17, 29, 100, 67, 100, 100, ...\n\nRooted; includes branch lengths.\n\n\nThứ hai, chúng ta nhập một bảng được lưu trữ dưới dạng tệp .csv với thông tin bổ sung cho từng mẫu được giải trình tự, chẳng hạn như giới tính, quốc gia xuất xứ và các thuộc tính kháng kháng sinh, bằng cách sử dụng hàm import() từ package rio:\n\nsample_data &lt;- import(\"sample_data_Shigella_tree.csv\")\n\nDưới đây là 50 dòng đầu tiên của bộ dữ liệu:\n\n\n\n\n\n\n\n\nLàm sạch và khảo sát dữ liệu\nChúng ta làm sạch và khảo sát dữ liệu để gán dữ liệu mẫu chính xác cho cây phát sinh loài, các giá trị trong cột Sample_ID của data frame sample_data cần phải khớp với giá trị tip.labels ở trong tệp tree:\nChúng ta kiểm tra định dạng của tip.labels trong tệp tree bằng cách xem xét 6 hàng đầu tiên với hàm head() của base R.\n\nhead(tree$tip.label) \n\n[1] \"SRR5006072\" \"SRR4192106\" \"S18BD07865\" \"S18BD00489\" \"S17BD08906\"\n[6] \"S17BD05939\"\n\n\nChúng ta cũng cần chắc chắn rằng cột đầu tiên trong data frame sample_data là cột Sample_ID. Chúng ta xem tên các cột của dataframe bằng cách sử dụng hàm colnames() từ base R.\n\ncolnames(sample_data)   \n\n [1] \"Sample_ID\"                  \"serotype\"                  \n [3] \"Country\"                    \"Continent\"                 \n [5] \"Travel_history\"             \"Year\"                      \n [7] \"Belgium\"                    \"Source\"                    \n [9] \"Gender\"                     \"gyrA_mutations\"            \n[11] \"macrolide_resistance_genes\" \"MIC_AZM\"                   \n[13] \"MIC_CIP\"                   \n\n\nChúng ta hãy để ý cột Sample_IDs trong data frame để chắc chắn rằng các định dạng là tương tự với tip.label (vd: các chữ cái đều viết hoa, không có dấu gạch dưới thừa _ giữa ký tự và số, v.v.)\n\nhead(sample_data$Sample_ID) # we again inspect only the first 6 using head()\n\n[1] \"S17BD05944\" \"S15BD07413\" \"S18BD07247\" \"S19BD07384\" \"S18BD07338\"\n[6] \"S18BD02657\"\n\n\nChúng ta cũng có thể so sánh nếu tất cả các mẫu có trong tệp tree và ngược lại bằng cách tạo một vectơ logic TRUE hoặc FALSE khi chúng khớp hoặc không khớp. Chúng không được in ở đây để cho đơn giản.\n\nsample_data$Sample_ID %in% tree$tip.label\n\ntree$tip.label %in% sample_data$Sample_ID\n\nChúng ta có thể sử dụng các vectơ này để hiển thị bất kỳ ID mẫu nào không có trên cây (không có ID nào).\n\nsample_data$Sample_ID[!tree$tip.label %in% sample_data$Sample_ID]\n\ncharacter(0)\n\n\nSau khi khảo sát, chúng ta có thể thấy định dạng của cột Sample_ID trong dataframe tương ứng với định dạng của tên mẫu tại tip.labels. Chúng không cần phải được sắp xếp theo cùng một thứ tự để có thể khớp.\nBây giờ chúng ta đã sẵn sàng!",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Cây phả hệ</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.vn.html#trực-quan-hóa-cây-đơn-giản",
    "href": "new_pages/phylogenetic_trees.vn.html#trực-quan-hóa-cây-đơn-giản",
    "title": "38  Cây phả hệ",
    "section": "38.3 Trực quan hóa cây đơn giản",
    "text": "38.3 Trực quan hóa cây đơn giản\n\nCác bố cục cây khác nhau\nggtree cung cấp nhiều định dạng bố cục khác nhau và một số có thể phù hợp với mục đích cụ thể của bạn hơn những định dạng khác. Dưới đây là một vài minh hoạt. Đối với các tùy chọn khác, hãy xem cuốn sách trực tuyến này.\nDưới đây là một số bố cục cây mẫu:\n\nggtree(tree)                                            # simple linear tree\nggtree(tree,  branch.length = \"none\")                   # simple linear tree with all tips aligned\nggtree(tree, layout=\"circular\")                         # simple circular tree\nggtree(tree, layout=\"circular\", branch.length = \"none\") # simple circular tree with all tips aligned\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCây đơn giản cộng với dữ liệu mẫu\nToán tử %&lt;+% được sử dụng để kết nối data frame sample_data tới tệp tree. Cách chú thích dễ dàng nhất cho cây của bạn là thêm tên mẫu ở các ngọn, cũng như tô màu các điểm ngọn và các nhánh nếu muốn:\nDưới đây là một ví dụ về cây phả hệ dạng tròn:\n\nggtree(tree, layout = \"circular\", branch.length = 'none') %&lt;+% sample_data + # %&lt;+% adds dataframe with sample data to tree\n  aes(color = Belgium)+                       # color the branches according to a variable in your dataframe\n  scale_color_manual(\n    name = \"Sample Origin\",                      # name of your color scheme (will show up in the legend like this)\n    breaks = c(\"Yes\", \"No\"),                     # the different options in your variable\n    labels = c(\"NRCSS Belgium\", \"Other\"),        # how you want the different options named in your legend, allows for formatting\n    values = c(\"blue\", \"black\"),                  # the color you want to assign to the variable \n    na.value = \"black\") +                        # color NA values in black as well\n  new_scale_color()+                             # allows to add an additional color scheme for another variable\n    geom_tippoint(\n      mapping = aes(color = Continent),          # tip color by continent. You may change shape adding \"shape = \"\n      size = 1.5)+                               # define the size of the point at the tip\n  scale_color_brewer(\n    name = \"Continent\",                    # name of your color scheme (will show up in the legend like this)\n    palette = \"Set1\",                      # we choose a set of colors coming with the brewer package\n    na.value = \"grey\") +                    # for the NA values we choose the color grey\n  geom_tiplab(                             # adds name of sample to tip of its branch \n    color = 'black',                       # (add as many text lines as you wish with + , but you may need to adjust offset value to place them next to each other)\n    offset = 1,\n    size = 1,\n    geom = \"text\",\n    align = TRUE)+    \n  ggtitle(\"Phylogenetic tree of Shigella sonnei\")+       # title of your graph\n  theme(\n    axis.title.x = element_blank(), # removes x-axis title\n    axis.title.y = element_blank(), # removes y-axis title\n    legend.title = element_text(    # defines font size and format of the legend title\n      face = \"bold\",\n      size = 12),   \n    legend.text=element_text(       # defines font size and format of the legend text\n      face = \"bold\",\n      size = 10),  \n    plot.title = element_text(      # defines font size and format of the plot title\n      size = 12,\n      face = \"bold\"),  \n    legend.position = \"bottom\",     # defines placement of the legend\n    legend.box = \"vertical\",        # defines placement of the legend\n    legend.margin = margin())   \n\n\n\n\n\n\n\n\nBạn có thể xuất biểu đồ cây với hàm ggsave() như cách bạn làm với bất kỳ đối tượng ggplot nào khác. Được viết theo cách này, ggsave() lưu hình ảnh cuối cùng được tạo vào đường dẫn tệp bạn chỉ định. Hãy nhớ rằng bạn có thể sử dụng hàm here() và các đường dẫn tệp tương đối để dễ dàng lưu trong các thư mục con, v.v.\n\nggsave(\"example_tree_circular_1.png\", width = 12, height = 14)",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Cây phả hệ</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.vn.html#thao-tác-với-cây",
    "href": "new_pages/phylogenetic_trees.vn.html#thao-tác-với-cây",
    "title": "38  Cây phả hệ",
    "section": "38.4 Thao tác với cây",
    "text": "38.4 Thao tác với cây\nĐôi khi bạn có thể có một cây phát sinh loài rất lớn và bạn chỉ quan tâm đến một phần của cây. Ví dụ, bạn muốn tạo ra một cây bao gồm các mẫu lịch sử hoặc quốc tế để có cái nhìn tổng quan về vị trí mà tập dữ liệu của bạn có thể phù hợp trong bức tranh lớn hơn. Nhưng sau đó để xem xét kỹ hơn dữ liệu của bạn, bạn chỉ muốn kiểm tra phần đó của cây lớn hơn.\nVì tệp cây phát sinh loài chỉ là sản phẩm đầu ra của phân tích dữ liệu trình tự, chúng ta không thể thao tác trên thứ tự của các nút và nhánh trên chính tệ đó. Chúng đã được xác định trong phân tích trước đó từ dữ liệu NGS thô. Mặc dù vậy, chúng ta có thể phóng to các thành phần, ẩn các thành phần và thậm chí tạo tập con một phần của cây.\n\nPhóng to\nNếu bạn không muốn “chặt” cây của mình mà chỉ kiểm tra kỹ hơn một phần của nó, bạn có thể phóng to để xem một phần cụ thể.\nĐầu tiên, chúng ta vẽ toàn bộ cây ở định dạng tuyến tính và thêm các nhãn số cho mỗi nút trong cây.\n\np &lt;- ggtree(tree,) %&lt;+% sample_data +\n  geom_tiplab(size = 1.5) +                # labels the tips of all branches with the sample name in the tree file\n  geom_text2(\n    mapping = aes(subset = !isTip,\n                  label = node),\n    size = 5,\n    color = \"darkred\",\n    hjust = 1,\n    vjust = 1)                            # labels all the nodes in the tree\n\np  # print\n\n\n\n\n\n\n\n\nĐể phóng to vào một nhánh cụ thể (nhô ra bên phải), hãy sử dụng hàm viewClade() trên đối tượng ggtree có tên p và cung cấp số nút để xem gần hơn:\n\nviewClade(p, node = 452)\n\n\n\n\n\n\n\n\n\n\nThu gọn nhánh\nTuy nhiên, chúng ta có thể muốn bỏ qua nhánh này và có thể thu gọn nó tại cùng một nút đó (nút nr. 452) bằng cách sử dụng hàm collapse(). Cây này sẽ được gán cho đối tượng mới có tên p_collapsed.\n\np_collapsed &lt;- collapse(p, node = 452)\np_collapsed\n\n\n\n\n\n\n\n\nĐể rõ ràng, khi chúng ta in p_collapsed, chúng ta thêm một điểm (viên kim cương màu xanh) với hàm geom_point2() tại nút của nhánh được thu gọn.\n\np_collapsed + \ngeom_point2(aes(subset = (node == 452)),  # we assign a symbol to the collapsed node\n            size = 5,                     # define the size of the symbol\n            shape = 23,                   # define the shape of the symbol\n            fill = \"steelblue\")           # define the color of the symbol\n\n\n\n\n\n\n\n\n\n\nTạo tập con một cây\nNếu chúng ta muốn thực hiện một thay đổi lâu dài hơn và tạo một cây mới, gọn hơn để làm việc, chúng ta có thể subset một phần của nó với hàm tree_subset(). Sau đó, bạn có thể lưu nó dưới dạng tệp newick tree hoặc tệp .txt mới.\nĐầu tiên, chúng ta kiểm tra các nút cây và các nhãn của tips để quyết định cái gì sẽ được subset.\n\nggtree(\n  tree,\n  branch.length = 'none',\n  layout = 'circular') %&lt;+% sample_data +               # we add the asmple data using the %&lt;+% operator\n  geom_tiplab(size = 1)+                                # label tips of all branches with sample name in tree file\n  geom_text2(\n    mapping = aes(subset = !isTip, label = node),\n    size = 3,\n    color = \"darkred\") +                                # labels all the nodes in the tree\n theme(\n   legend.position = \"none\",                            # removes the legend all together\n   axis.title.x = element_blank(),\n   axis.title.y = element_blank(),\n   plot.title = element_text(size = 12, face=\"bold\"))\n\n\n\n\n\n\n\n\nBây giờ, giả sử chúng ta đã quyết định subset cây tại nút số 528 (chỉ giữ lại các tips bên trong nhánh sau nút 528) và lưu nó vào một đối tượng mới sub_tree1:\n\nsub_tree1 &lt;- tree_subset(\n  tree,\n  node = 528)                                            # we subset the tree at node 528\n\nHãy cùng xem cây con 1:\n\nggtree(sub_tree1) +\n  geom_tiplab(size = 3) +\n  ggtitle(\"Subset tree 1\")\n\n\n\n\n\n\n\n\nBạn cũng có thể subset dựa trên một mẫu cụ thể, bằng cách chỉ định số lượng nút “backwards” bạn muốn đưa vào. Hãy subset chính phần đó của cây dựa trên một mẫu, trong trường hợp này là S17BD07692, quay lại 9 nút và chúng ta lưu nó dưới dạng đối tượng sub_tree2 mớit:\n\nsub_tree2 &lt;- tree_subset(\n  tree,\n  \"S17BD07692\",\n  levels_back = 9) # levels back defines how many nodes backwards from the sample tip you want to go\n\nGiờ hãy cùng xem cây con 2:\n\nggtree(sub_tree2) +\n  geom_tiplab(size =3)  +\n  ggtitle(\"Subset tree 2\")\n\n\n\n\n\n\n\n\nBạn cũng có thể lưu cây mới của mình dưới dạng kiểu Newick hoặc thậm chí là tệp văn bản bằng cách sử dụng hàm write.tree() từ package ape:\n\n# to save in .nwk format\nape::write.tree(sub_tree2, file='data/phylo/Shigella_subtree_2.nwk')\n\n# to save in .txt format\nape::write.tree(sub_tree2, file='data/phylo/Shigella_subtree_2.txt')\n\n\n\nXoay các nút trong một cây\nNhư đã đề cập bên trên, chúng ta không thể thay đổi thứ tự của các tips hoặc nút trong cây, vì điều này dựa trên mối liên hệ di truyền của chúng và không phải là đối tượng cho các điều chỉnh thị giác. Nhưng chúng ta có thể xoay các nhánh xung quanh nút nếu điều đó giúp chúng ta dễ nhìn hơn.\nĐầu tiên, chúng ta hãy vẽ subset tree 2 với nhãn nút để chọn nút mà chúng ta muốn thao tác và lưu nó vào một đối tượng biểu đồ ggtree có tên p.\n\np &lt;- ggtree(sub_tree2) +  \n  geom_tiplab(size = 4) +\n  geom_text2(aes(subset=!isTip, label=node), # labels all the nodes in the tree\n             size = 5,\n             color = \"darkred\", \n             hjust = 1, \n             vjust = 1) \np\n\n\n\n\n\n\n\n\nSau đó chúng ta có thể thao tác với các nút bằng cách áp dụng hàm ggtree::rotate() hoặc ggtree::flip(): Lưu ý: để biểu diễn những nút nào chúng ta đang thao tác, trước tiên chúng ta áp dụng hàm geom_hilight() từ package ggtree để đánh dấu các mẫu trong các nút mà chúng ta quan tâm và lưu trữ sang một đối tượng biểu đồ mới có tên p1.\n\np1 &lt;- p + geom_hilight(  # highlights node 39 in blue, \"extend =\" allows us to define the length of the color block\n  node = 39,\n  fill = \"steelblue\",\n  extend = 0.0017) +  \ngeom_hilight(            # highlights the node 37 in yellow\n  node = 37,\n  fill = \"yellow\",\n  extend = 0.0017) +               \nggtitle(\"Original tree\")\n\n\np1 # print\n\n\n\n\n\n\n\n\nBây giờ chúng ta có thể xoay nút 37 trong đối tượng p1 để các mẫu trên nút 38 di chuyển lên đỉnh. Chúng ta lưu trữ cây đã xoay trong một đối tượng mới có tên p2.\n\np2 &lt;- ggtree::rotate(p1, 37) + \n      ggtitle(\"Rotated Node 37\")\n\n\np2   # print\n\n\n\n\n\n\n\n\nHoặc chúng ta có thể sử dụng lệnh flip để xoay nút 36 trong đối tượng p1 và đổi nút 37 lên đỉnh và nút 39 xuống dưới đáy. Chúng ta lưu cây đã được lật lại vào một đối tượng mới có tên p3.\n\np3 &lt;-  flip(p1, 39, 37) +\n      ggtitle(\"Rotated Node 36\")\n\n\np3   # print\n\n\n\n\n\n\n\n\n\n\nVí dụ về cây con với chú thích dữ liệu mẫu\nGiả sử chúng tôi đang điều tra cụm các trường hợp với nhân bản vô tính xảy ra vào năm 2017 và 2018 tại nút 39 trong cây con của chúng ta. Chúng ta thêm năm phân lập chủng cũng như lịch sử di chuyển và màu sắc theo quốc gia để xem nguồn gốc của các chủng có liên quan gần khác:\n\nggtree(sub_tree2) %&lt;+% sample_data +     # we use th %&lt;+% operator to link to the sample_data\n  geom_tiplab(                          # labels the tips of all branches with the sample name in the tree file\n    size = 2.5,\n    offset = 0.001,\n    align = TRUE) + \n  theme_tree2()+\n  xlim(0, 0.015)+                       # set the x-axis limits of our tree\n  geom_tippoint(aes(color=Country),     # color the tip point by continent\n                size = 1.5)+ \n  scale_color_brewer(\n    name = \"Country\", \n    palette = \"Set1\", \n    na.value = \"grey\")+\n  geom_tiplab(                          # add isolation year as a text label at the tips\n    aes(label = Year),\n    color = 'blue',\n    offset = 0.0045,\n    size = 3,\n    linetype = \"blank\" ,\n    geom = \"text\",\n    align = TRUE)+ \n  geom_tiplab(                          # add travel history as a text label at the tips, in red color\n    aes(label = Travel_history),\n    color = 'red',\n    offset = 0.006,\n    size = 3,\n    linetype = \"blank\",\n    geom = \"text\",\n    align = TRUE)+ \n  ggtitle(\"Phylogenetic tree of Belgian S. sonnei strains with travel history\")+  # add plot title\n  xlab(\"genetic distance (0.001 = 4 nucleotides difference)\")+                    # add a label to the x-axis \n  theme(\n    axis.title.x = element_text(size = 10),\n    axis.title.y = element_blank(),\n    legend.title = element_text(face = \"bold\", size = 12),\n    legend.text = element_text(face = \"bold\", size = 10),\n    plot.title = element_text(size = 12, face = \"bold\"))\n\n\n\n\n\n\n\n\nQuan sát của chúng ta hướng tới một sự kiện nhập khẩu các chủng từ châu Á, sau đó lưu hành ở Bỉ trong nhiều năm và dường như đã gây ra đợt bùng phát mới nhất của chúng ta.",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Cây phả hệ</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.vn.html#các-cây-phức-tạp-hơn-thêm-bản-đồ-nhiệt-của-dữ-liệu-mẫu",
    "href": "new_pages/phylogenetic_trees.vn.html#các-cây-phức-tạp-hơn-thêm-bản-đồ-nhiệt-của-dữ-liệu-mẫu",
    "title": "38  Cây phả hệ",
    "section": "Các cây phức tạp hơn: thêm bản đồ nhiệt của dữ liệu mẫu",
    "text": "Các cây phức tạp hơn: thêm bản đồ nhiệt của dữ liệu mẫu\nChúng tôi có thể thêm thông tin phức tạp hơn, chẳng hạn như sự phân loại của các gen kháng thuốc và các giá trị đo lường về khả năng kháng thuốc dưới dạng bản đồ nhiệt bằng cách sử dụng hàm ggtree::gheatmap().\nTrước tiên, chúng ta cần vẽ cây của mình (có thể là tuyến tính hoặc hình tròn) và lưu trữ nó trong một đối tượng biểu đồ ggtree mới có tên p: Chúng ta sẽ sử dụng sub_tree từ phần 3.)\n\np &lt;- ggtree(sub_tree2, branch.length='none', layout='circular') %&lt;+% sample_data +\n  geom_tiplab(size =3) + \n theme(\n   legend.position = \"none\",\n    axis.title.x = element_blank(),\n    axis.title.y = element_blank(),\n    plot.title = element_text(\n      size = 12,\n      face = \"bold\",\n      hjust = 0.5,\n      vjust = -15))\np\n\n\n\n\n\n\n\n\nThứ hai, chúng ta chuẩn bị dữ liệu của mình. Để trực quan hóa các biến khác nhau bằng các phối màu mới, chúng ta subset dataframe thành các biến mong muốn. Điều quan trọng là phải thêm Sample_ID làm tên hàng nếu không nó không thể khớp dữ liệu với cây tip.labels:\nTrong ví dụ của này, chúng ta muốn xem xét giới tính và các đột biến có thể dẫn đến kháng Ciprofloxacin, một loại kháng sinh hàng đầu quan trọng được sử dụng để điều trị nhiễm trùng Shigella.\nChúng ta tạo một dataframe cho biến giới tính:\n\ngender &lt;- data.frame(\"gender\" = sample_data[,c(\"Gender\")])\nrownames(gender) &lt;- sample_data$Sample_ID\n\nChúng ta tạo một dataframe cho đột biến ở gen gyrA, gen này tạo ra khả năng kháng Ciprofloxacin:\n\ncipR &lt;- data.frame(\"cipR\" = sample_data[,c(\"gyrA_mutations\")])\nrownames(cipR) &lt;- sample_data$Sample_ID\n\nChúng ta tạo một dataframe đối với nồng độ ức chế tối thiểu đo được (MIC) đối với Ciprofloxacin trong phòng thí nghiệm:\n\nMIC_Cip &lt;- data.frame(\"mic_cip\" = sample_data[,c(\"MIC_CIP\")])\nrownames(MIC_Cip) &lt;- sample_data$Sample_ID\n\nChúng ta tạo một biểu đồ đầu tiên và thêm bản đồ nhiệt nhị phân cho giới tính vào cây phát sinh loài và lưu trữ nó trong một đối tượng biểu đồ ggtree mới h1:\n\nh1 &lt;-  gheatmap(p, gender,                                 # we add a heatmap layer of the gender dataframe to our tree plot\n                offset = 10,                               # offset shifts the heatmap to the right,\n                width = 0.10,                              # width defines the width of the heatmap column,\n                color = NULL,                              # color defines the boarder of the heatmap columns\n         colnames = FALSE) +                               # hides column names for the heatmap\n  scale_fill_manual(name = \"Gender\",                       # define the coloring scheme and legend for gender\n                    values = c(\"#00d1b1\", \"purple\"),\n                    breaks = c(\"Male\", \"Female\"),\n                    labels = c(\"Male\", \"Female\")) +\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\nh1\n\n\n\n\n\n\n\n\nSau đó, chúng ta thêm thông tin về các đột biến trong gen gyrA, gen này tạo ra khả năng kháng Ciprofloxacin:\nLưu ý: Sự hiện diện của đột biến điểm nhiễm sắc thể trong dữ liệu WGS đã được xác định trước bằng cách sử dụng công cụ PointFinder do Zankari et al phát triển. (xem tham khảo trong phần tài liệu tham khảo bổ sung)\nĐầu tiên, chúng ta gán một bảng màu mới cho đối tượng biểu đồ h1 có sẵn và lưu nó thành một đối tượng mới có tên h2. Điều này cho phép chúng ta xác định và thay đổi màu sắc cho biến thứ hai của chúng tôi trong bản đồ nhiệt.\n\nh2 &lt;- h1 + new_scale_fill() \n\nSau đó, chúng ta thêm lớp bản đồ nhiệt thứ hai vào h2 và lưu biểu đồ thành đối tượng mới có tên h3:\n\nh3 &lt;- gheatmap(h2, cipR,         # adds the second row of heatmap describing Ciprofloxacin resistance mutations\n               offset = 12, \n               width = 0.10, \n               colnames = FALSE) +\n  scale_fill_manual(name = \"Ciprofloxacin resistance \\n conferring mutation\",\n                    values = c(\"#fe9698\",\"#ea0c92\"),\n                    breaks = c( \"gyrA D87Y\", \"gyrA S83L\"),\n                    labels = c( \"gyrA d87y\", \"gyrA s83l\")) +\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())+\n  guides(fill = guide_legend(nrow = 2,byrow = TRUE))\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\nh3\n\n\n\n\n\n\n\n\nChúng tôi lặp lại quy trình trên, trước tiên bằng cách thêm một lớp thang màu mới vào đối tượng hiện có h3, sau đó thêm dữ liệu liên tục về nồng độ ức chế tối thiểu (MIC) của Ciprofloxacin cho mỗi chủng vào đối tượng kết quả h4 để tạo ra đối tượng cuối cùng h5:\n\n# First we add the new coloring scheme:\nh4 &lt;- h3 + new_scale_fill()\n\n# then we combine the two into a new plot:\nh5 &lt;- gheatmap(h4, MIC_Cip,  \n               offset = 14, \n               width = 0.10,\n                colnames = FALSE)+\n  scale_fill_continuous(name = \"MIC for Ciprofloxacin\",  # here we define a gradient color scheme for the continuous variable of MIC\n                      low = \"yellow\", high = \"red\",\n                      breaks = c(0, 0.50, 1.00),\n                      na.value = \"white\") +\n   guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\nh5\n\n\n\n\n\n\n\n\nChúng ta có thể thực hiện tương tự đối với cây tuyến tính:\n\np &lt;- ggtree(sub_tree2) %&lt;+% sample_data +\n  geom_tiplab(size = 3) + # labels the tips\n  theme_tree2()+\n  xlab(\"genetic distance (0.001 = 4 nucleotides difference)\")+\n  xlim(0, 0.015)+\n theme(legend.position = \"none\",\n      axis.title.y = element_blank(),\n      plot.title = element_text(size = 12, \n                                face = \"bold\",\n                                hjust = 0.5,\n                                vjust = -15))\np\n\n\n\n\n\n\n\n\nĐầu tiên chúng ta thêm giới:\n\nh1 &lt;-  gheatmap(p, gender, \n                offset = 0.003,\n                width = 0.1, \n                color=\"black\", \n         colnames = FALSE)+\n  scale_fill_manual(name = \"Gender\",\n                    values = c(\"#00d1b1\", \"purple\"),\n                    breaks = c(\"Male\", \"Female\"),\n                    labels = c(\"Male\", \"Female\"))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\nh1\n\n\n\n\n\n\n\n\nSau đó, chúng ta thêm các đột biến kháng Ciprofloxacin sau khi thêm một lớp phối màu khác:\n\nh2 &lt;- h1 + new_scale_fill()\nh3 &lt;- gheatmap(h2, cipR,   \n               offset = 0.004, \n               width = 0.1,\n               color = \"black\",\n                colnames = FALSE)+\n  scale_fill_manual(name = \"Ciprofloxacin resistance \\n conferring mutation\",\n                    values = c(\"#fe9698\",\"#ea0c92\"),\n                    breaks = c( \"gyrA D87Y\", \"gyrA S83L\"),\n                    labels = c( \"gyrA d87y\", \"gyrA s83l\"))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())+\n  guides(fill = guide_legend(nrow = 2,byrow = TRUE))\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\n h3\n\n\n\n\n\n\n\n\nSau đó, chúng ta thêm nồng độ ức chế tối thiểu được xác định bởi phòng thí nghiệm (MIC):\n\nh4 &lt;- h3 + new_scale_fill()\nh5 &lt;- gheatmap(h4, MIC_Cip, \n               offset = 0.005,  \n               width = 0.1,\n               color = \"black\", \n                colnames = FALSE)+\n  scale_fill_continuous(name = \"MIC for Ciprofloxacin\",\n                      low = \"yellow\", high = \"red\",\n                      breaks = c(0,0.50,1.00),\n                      na.value = \"white\")+\n   guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 10),\n        legend.text = element_text(size = 8),\n        legend.box = \"horizontal\", legend.margin = margin())+\n  guides(shape = guide_legend(override.aes = list(size = 2)))\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\nh5",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Cây phả hệ</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.vn.html#nguồn",
    "href": "new_pages/phylogenetic_trees.vn.html#nguồn",
    "title": "38  Cây phả hệ",
    "section": "38.5 Nguồn",
    "text": "38.5 Nguồn\nhttp://hydrodictyon.eeb.uconn.edu/eebedia/index.php/Ggtree# Clade_Colors https://bioconductor.riken.jp/packages/3.2/bioc/vignettes/ggtree/inst/doc/treeManipulation.html https://guangchuangyu.github.io/ggtree-book/chapter-ggtree.html https://bioconductor.riken.jp/packages/3.8/bioc/vignettes/ggtree/inst/doc/treeManipulation.html\nEa Zankari, Rosa Allesøe, Katrine G Joensen, Lina M Cavaco, Ole Lund, Frank M Aarestrup, PointFinder: a novel web tool for WGS-based detection of antimicrobial resistance associated with chromosomal point mutations in bacterial pathogens, Journal of Antimicrobial Chemotherapy, Volume 72, Issue 10, October 2017, Pages 2764–2768, https://doi.org/10.1093/jac/dkx217",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Cây phả hệ</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.vn.html",
    "href": "new_pages/interactive_plots.vn.html",
    "title": "39  Biểu đồ tương tác",
    "section": "",
    "text": "39.1 Chuẩn bị",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Biểu đồ tương tác</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.vn.html#chuẩn-bị",
    "href": "new_pages/interactive_plots.vn.html#chuẩn-bị",
    "title": "39  Biểu đồ tương tác",
    "section": "",
    "text": "Gọi packages\nĐoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R.\n\npacman::p_load(\n  rio,       # import/export\n  here,      # filepaths\n  lubridate, # working with dates\n  plotly,    # interactive plots\n  scales,    # quick percents\n  tidyverse  # data management and visualization\n  ) \n\n\n\nBắt đầu với ggplot()\nTrong chương này chúng ta giả định rằng bạn đang bắt đầu với một biểu đồ tạo bởi ggplot() và muốn chuyển đổi nó thành biểu đồ tương tác. Chúng ta sẽ xây dựng một số biểu đồ như vậy trong chương này, sử dụng bộ dữ liệu linelist đã được đề cập ở rất nhiều chương trong cuốn sổ tay này.\n\n\nNhập dữ liệu\nĐể bắt đầu, chúng ta nhập bộ dữ liệu có tên linelist đã làm sạch bao gồm các trường hợp từ vụ dịch Ebola mô phỏng. Để tiện theo dõi, bấm để tải dữ liệu linelist “đã được làm sạch”  (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương Nhập xuất dữ liệu để biết thêm chi tiết).\n\n# import case linelist \nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\n50 hàng đầu tiên của bộ dữ liệu được hiển thị như bên dưới.",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Biểu đồ tương tác</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.vn.html#vẽ-biểu-đồ-với-ggplotly",
    "href": "new_pages/interactive_plots.vn.html#vẽ-biểu-đồ-với-ggplotly",
    "title": "39  Biểu đồ tương tác",
    "section": "39.2 Vẽ biểu đồ với ggplotly()",
    "text": "39.2 Vẽ biểu đồ với ggplotly()\nHàm ggplotly() thuộc package plotly hỗ trợ chuyển đổi dễ dàng một biểu đồ ggplot() thành có tính tương tác. Đơn giản chỉ cần lưu biểu đồ ggplot() và sau đó pipe nó tới hàm ggplotly().\nDưới đây, chúng ta biểu diễn một đường đơn giản đại diện cho tỷ lệ các trường hợp tử vong trong một tuần xác định:\nChúng ta bắt đầu bằng cách tạo một bộ dữ liệu tổng hợp cho từng tuần dịch tễ học, và phần trăm các trường hợp có outcome là tử vong.\n\nweekly_deaths &lt;- linelist %&gt;%\n  group_by(epiweek = floor_date(date_onset, \"week\")) %&gt;%  # create and group data by epiweek column\n  summarise(                                              # create new summary data frame:\n    n_known_outcome = sum(!is.na(outcome), na.rm=T),      # number of cases per group with known outcome\n    n_death  = sum(outcome == \"Death\", na.rm=T),          # number of cases per group who died\n    pct_death = 100*(n_death / n_known_outcome)           # percent of cases with known outcome who died\n  )\n\nĐây là 50 hàng đầu tiên của bộ dữ liệu weekly_deaths.\n\n\n\n\n\n\nSau đó chúng ta vẽ biểu đồ với hàm geom_line() thuộc ggplot2.\n\ndeaths_plot &lt;- ggplot(data = weekly_deaths)+            # begin with weekly deaths data\n  geom_line(mapping = aes(x = epiweek, y = pct_death))  # make line \n\ndeaths_plot   # print\n\n\n\n\n\n\n\n\nChúng ta có thể tạo tính tương tác cho biểu đồ bằng cách chuyển nó tới hàm ggplotly() như dưới đây. Di chuyển trỏ chuột của bạn tới vị trí các đường để hiện thị giá trị x và y. Bạn có thể phóng to và kéo thả trong biểu đồ. Bạn cũng sẽ thấy các biểu tượng ở góc phải trên của biểu đồ. Theo thứ tự, chúng cho phép bạn:\n\nTải xuống trạng thái hiện tại của biểu đồ dưới dạng ảnh PNG\n\nPhóng to với hộp thoại lựa chọn\n\n“Pan”, hay còn gọi là di chuyển biểu đồ bằng cách nhấp và kéo thả biểu đồ\n\nPhóng to, thu nhỏ, hoặc quay trở về mặc định\n\nReset trục về mặc định\n\nBật/tắt “spike lines - đường vnah đai”, là các đường chấm chấm mở rộng theo trục x và y từ các điểm tương tác\n\nĐiều chỉnh hiển thị dữ liệu ngay cả khi bạn không rê chuột tới đường thẳng\n\n\ndeaths_plot %&gt;% plotly::ggplotly()\n\n\n\n\n\nDữ liệu được nhóm cũng hoạt động với hàm ggplotly(). Dưới đây đường cong dịch tễ theo tuần được tạo, nhóm theo outcome. Các cột chồng có tính tương tác. Hãy thử nhấp vào các items khác nhau trong phần chú giải (chúng sẽ xuất hiện/biến mất).\n\n# Make epidemic curve with incidence2 pacakge\np &lt;- incidence2::incidence(\n  linelist,\n  date_index = date_onset,\n  interval = \"weeks\",\n  groups = outcome) %&gt;% plot(fill = outcome)\n\n\n# Plot interactively  \np %&gt;% plotly::ggplotly()",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Biểu đồ tương tác</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.vn.html#điều-chỉnh",
    "href": "new_pages/interactive_plots.vn.html#điều-chỉnh",
    "title": "39  Biểu đồ tương tác",
    "section": "39.3 Điều chỉnh",
    "text": "39.3 Điều chỉnh\n\nKích thước tệp\nKhi xuất một tệp HTML sinh ra bởi một tệp R Markdown (như cuốn sách này!), bạn sẽ muốn dung lượng của biểu đồ nhỏ nhất có thể (mà không có các tác dụng phụ tiêu cực trong phần lớn trường hợp). Để làm điều này, chỉ cần pipe biểu đồ tương tác tới hàm partial_bundle(), cũng thuộc plotly.\n\np &lt;- p %&gt;% \n  plotly::ggplotly() %&gt;%\n  plotly::partial_bundle()\n\n\n\nNút bấm\nMột số nút bẩm trong biểu đồ plotly khá thừa thải vã gây mất tập trung, vì vậy bạn có thể loại bỏ chúng. Đơn giản bạn chỉ cần piping đầu ra tới hàm config() thuộc plotly và cụ thể tên của nút bấm muốn loại bỏ. Trong ví dụ dưới đây, chúng ta cụ thể trước tên của nút bấm muốn loại bỏ vào một danh sách, sau đó cung cấp chúng tới đối số modeBarButtonsToRemove =. Chúng ta cũng thiết lập displaylogo = FALSE để loại bỏ logo của plotly.\n\n## these buttons are distracting and we want to remove them\nplotly_buttons_remove &lt;- list('zoom2d','pan2d','lasso2d', 'select2d','zoomIn2d',\n                              'zoomOut2d','autoScale2d','hoverClosestCartesian',\n                              'toggleSpikelines','hoverCompareCartesian')\n\np &lt;- p %&gt;%          # re-define interactive plot without these buttons\n  plotly::config(displaylogo = FALSE, modeBarButtonsToRemove = plotly_buttons_remove)",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Biểu đồ tương tác</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.vn.html#biểu-đồ-nhiệt",
    "href": "new_pages/interactive_plots.vn.html#biểu-đồ-nhiệt",
    "title": "39  Biểu đồ tương tác",
    "section": "39.4 Biểu đồ nhiệt",
    "text": "39.4 Biểu đồ nhiệt\nBạn có thể khiến bất kỳ loại biểu đồ nào tạo bởi ggplot() có khả năng tương tác, bao gồm biểu đồ nhiệt. Trong chương Biểu đồ nhiệt, bạn có thể đọc thêm về cách tạo biểu đồ dưới đây để hiển thị tỷ lệ số ngày trong tuần mà các cơ sở y tế báo cáo dữ liệu lên tuyến tỉnh.\nSau đây là code, mặc dù chúng tôi sẽ không giải thích chi tiết tại đây.\n\n# import data\nfacility_count_data &lt;- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\"))\n\n# aggregate data into Weeks for Spring district\nagg_weeks &lt;- facility_count_data %&gt;% \n  filter(District == \"Spring\",\n         data_date &lt; as.Date(\"2020-08-01\")) %&gt;% \n  mutate(week = aweek::date2week(\n    data_date,\n    start_date = \"Monday\",\n    floor_day = TRUE,\n    factor = TRUE)) %&gt;% \n  group_by(location_name, week, .drop = F) %&gt;%\n  summarise(\n    n_days          = 7,\n    n_reports       = n(),\n    malaria_tot     = sum(malaria_tot, na.rm = T),\n    n_days_reported = length(unique(data_date)),\n    p_days_reported = round(100*(n_days_reported / n_days))) %&gt;% \n  ungroup(location_name, week) %&gt;% \n  right_join(tidyr::expand(., week, location_name)) %&gt;% \n  mutate(week = aweek::week2date(week))\n\n# create plot\nmetrics_plot &lt;- ggplot(agg_weeks,\n       aes(x = week,\n           y = location_name,\n           fill = p_days_reported))+\n  geom_tile(colour=\"white\")+\n  scale_fill_gradient(low = \"orange\", high = \"darkgreen\", na.value = \"grey80\")+\n  scale_x_date(expand = c(0,0),\n               date_breaks = \"2 weeks\",\n               date_labels = \"%d\\n%b\")+\n  theme_minimal()+ \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1,\"cm\"),\n    legend.key.width  = grid::unit(0.6,\"cm\"),\n    axis.text.x = element_text(size=12),\n    axis.text.y = element_text(vjust=0.2),\n    axis.ticks = element_line(size=0.4),\n    axis.title = element_text(size=12, face=\"bold\"),\n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),\n    plot.caption = element_text(hjust = 0, face = \"italic\")\n    )+\n  labs(x = \"Week\",\n       y = \"Facility name\",\n       fill = \"Reporting\\nperformance (%)\",\n       title = \"Percent of days per week that facility reported data\",\n       subtitle = \"District health facilities, April-May 2019\",\n       caption = \"7-day weeks beginning on Mondays.\")\n\nmetrics_plot # print\n\n\n\n\n\n\n\n\nSau đó, chúng tôi biến nó trở thành biểu đồ tương tác và điều chỉnh các nút bấm và dung lượng tệp.\n\nmetrics_plot %&gt;% \n  plotly::ggplotly() %&gt;% \n  plotly::partial_bundle() %&gt;% \n  plotly::config(displaylogo = FALSE, modeBarButtonsToRemove = plotly_buttons_remove)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n–&gt;",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Biểu đồ tương tác</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.vn.html#tài-nguyên-học-liệu",
    "href": "new_pages/interactive_plots.vn.html#tài-nguyên-học-liệu",
    "title": "39  Biểu đồ tương tác",
    "section": "39.5 Tài nguyên học liệu",
    "text": "39.5 Tài nguyên học liệu\nPlotly không chỉ dành riêng cho R mà còn hoạt động tốt với Python (và bất cứ ngôn ngữ khoa học dữ liệu nào khác bởi vì nó được xây dựng trên JavaScript). Bạn có thể tìm hiểu thêm về nở ở website của plotly",
    "crumbs": [
      "Trực quan hóa dữ liệu",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Biểu đồ tương tác</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.vn.html",
    "href": "new_pages/rmarkdown.vn.html",
    "title": "40  Báo cáo với R Markdown",
    "section": "",
    "text": "40.1 Chuẩn bị\nNền tảng về R Markdown\nNhằm giải thích một số khái niệm và packages cần thiết:\nTổng kết lại, quá trình được tiến hành trong nền (bạn không cần biết tới tất cả những bước này!), gồm chuyển tệp .Rmd tới knitr để thực thi các đoạn code R và tạo một tệp .md (markdown) mới bao gồm cả code R lẫn kết quả đầu ra đã được chuyển đổi. Các tệp .md này sau đó được pandoc chạy để tạo ra sản phẩm hoàn thiện như là một tài liệu Microsoft Word, tệp HTML, tài liệu powerpoint, pdf, v.v.\n(Nguồn: https://rmarkdown.rstudio.com/authoring_quick_tour.html):\nCài đặt\nĐể tạo một kết quả đầu ra của R Markdown, bạn cần phải cài đặt:\npacman::p_load(tinytex)     # install tinytex package\ntinytex::install_tinytex()  # R command to install TinyTeX software",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Báo cáo với R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.vn.html#chuẩn-bị",
    "href": "new_pages/rmarkdown.vn.html#chuẩn-bị",
    "title": "40  Báo cáo với R Markdown",
    "section": "",
    "text": "Markdown là một “ngôn ngữ” cho phép bạn soạn tài liệu bằng chữ thuần túy, sau đó có thể chuyển đổi sang html và các định dạng khác. Nó không dành riêng cho R. Các tệp được viết trong Markdown có đuôi ‘.md’.\n\nR Markdown: là một biến thể trên markdown chỉ dành riêng cho R - nó cho phép bạn soạn một tài liệu sử dụng markdown để tạo chữ cũng như nhúng code R và hiển thị kết quả đầu ra. Các tệp R Markdown có đuôi ‘.Rmd’.\n\nPackage rmarkdown: Package được R sử dụng để chuyển tệp .Rmd thành đầu ra mong muốn. Nó tập trung vào việc chuyển cú pháp markdown (chữ), vì vậy chúng ta cũng cần tới…\nknitr: Package R này sẽ đọc các đoạn code, thực thi chúng, và ‘knit’ (kết hợp) chúng vào lại tài liệu. Đây là cách bảng, biểu đồ được thêm vào văn bản.\n\nPandoc: Cuối cùng, pandoc thật sự chuyển đổi kết quả đầu ra thành word/pdf/powerpoint, v.v. Nó là một phần mềm tách biệt khỏi R nhưng được cài đặt tự động cùng với RStudio.\n\n\n\n\n\n\n\nPackage rmarkdown (knitr cũng sẽ được cài đặt tự động)\n\nPandoc sẽ được cài đặt cùng với RStudio. Nếu bạn không dùng RStudio, bạn có thể tải Pandoc tại đây: http://pandoc.org.\n\nNếu bạn muốn tạo đầu ra là tệp PDF (phức tạp hơn một chút), bạn sẽ cần cài đặt LaTex. Với những người dùng R Markdown chưa cài đặt LaTex trước đó, các bạn có thể cài đặt TinyTeX (https://yihui.name/tinytex/). Bạn có thể sử dụng lệnh sau để cài đặt:",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Báo cáo với R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.vn.html#bắt-đầu",
    "href": "new_pages/rmarkdown.vn.html#bắt-đầu",
    "title": "40  Báo cáo với R Markdown",
    "section": "40.2 Bắt đầu",
    "text": "40.2 Bắt đầu\n\nCài đặt package rmarkdown\nCài đặt R package rmarkdown. Trong quyển sổ tay này chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt package nếu cần và gọi ra để sử dụng. Bạn cũng có thể cài đặt package với library() từ base R. Xem thêm ở chương R cơ bản để biết thêm thông tin về R packages.\n\npacman::p_load(rmarkdown)\n\n\n\nBắt đầu một tệp Rmd mới\nTrong RStudio, để mở một tệp R markdown mới, bắt đầu với ‘File’, rồi ‘New file’, rồi ‘R markdown…’.\n\n\n\n\n\n\n\n\n\nR Studio sẽ đưa ra cho bạn một số lựa chọn kết quả đầu ra. Trong ví dụ bên dưới, chúng tôi chọn “HTML” bởi chúng tôi muốn tạo ra một văn bản html. Tiêu đề và tên các tác giả không quan trọng. Nếu loại tài liệu đầu ra bạn muốn không có, đừng lo - bạn có thể chọn bất kỳ loại nào và thay đổi trong script sau đó.\n\n\n\n\n\n\n\n\n\nNhư vậy sẽ mở ra một script .Rmd mới.\n\n\nĐiều quan trọng cần phải biết\nThư mục làm việc\nThư mục làm việc của một tệp markdown là ở bất kỳ vị trí nào tệp được lưu. Ví dụ, nếu R project nằm trong ~/Documents/projectX và tệp Rmd được lưu ở thư mục con ~/Documents/projectX/markdownfiles/markdown.Rmd, thì lệnh read.csv(“data.csv”) trong markdown sẽ tìm tệp csv trong thư mục markdownfiles, mà không phải là ở thư mục gốc nơi mà scripts trong projects sẽ thường tự động tìm kiếm.\nĐể tìm kiếm các tệp này ở chỗ khác, bạn sẽ vừa cần sử dụng cả đường dẫn tệp đầy đủ và sử dụng package here. Package here cài đặt thư mục làm việc tới thư mục gốc của R project và sẽ được giải thích chi tiết trong các chương Dự án R và Nhập xuất dữ liệu của sổ tay này. Ví dụ, để nhập một tệp tên “data.csv” từ trong thư mục projectX, code sẽ là import(here(“data.csv”)).\nLưu ý rằng không nên sử dụng setwd() trong R Markdown scripts - nó chỉ dùng cho các đoạn code được viết trong đó.\nLàm việc với ổ cứng mạng so với trên máy tính của bạn\nVì R Markdown có thể gặp các vấn đề với pandoc khi chạy trên một ổ cứng mạng được chia sẻ, thư mục của bạn nên nằm ở ở cứng vật lý, ví dụ trong dự án thuộc ‘My Documents’. Nếu bạn dùng Git (rất khuyến khích!), nó sẽ thân thuộc hơn. Để biết thêm chi tiết, xem thêm chương R trên ổ cứng mạng và Các lỗi thường gặp.",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Báo cáo với R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.vn.html#các-cấu-phần-của-r-markdown",
    "href": "new_pages/rmarkdown.vn.html#các-cấu-phần-của-r-markdown",
    "title": "40  Báo cáo với R Markdown",
    "section": "40.3 Các cấu phần của R Markdown",
    "text": "40.3 Các cấu phần của R Markdown\nMột tài liệu R Markdown có thể chỉnh sửa trong RStudio giống như một R script tiêu chuẩn. Khi bạn tạo một R Markdown script mới, RStudio vô cùng hữu ích bằng cách đưa ra một mẫu có các phần khác nhau của một tệp R Markdown script.\nDưới đây là khung hiển thị khi bắt đầu một Rmd script mới có kết quả đầu ra là html (như phần trước)\n\n\n\n\n\n\n\n\n\nNhư bạn có thể thấy, một tệp Rmd gồm có 3 cấu phần: YAML, chữ Markdown, và đoạn code R.\nChúng sẽ tạo ra và trở thành tài liệu đầu ra của bạn. Xem biểu đồ bên dưới:\n\n\n\n\n\n\n\n\n\n\nYAML metadata\n‘YAML metadata’ hoặc chỉ ‘YAML’ nằm ở trên cùng trong tài liệu R Markdown. Phần này của script sẽ cho tệp Rmd của bạn biết cần tạo loại kết quả đầu ra nào, định dạng mong muốn, và metadata khác như tiêu đề tài liệu, tác giả, và ngày. Có những công dụng khác không được nhắc ở đây (nhưng được nhắc tới trong ‘Tạo kết quả đầu ra’). Lưu ý rằng có sự thụt đầu dòng, nhưng chỉ chấp nhận spaces chứ không nhận tabs.\nPhần này phải được bắt đầu với với một dòng gồm có 3 dấu gạch ngang --- và phải kết thúc với một dòng chỉ có 3 dấu gạch ngang ---. Tham số của YAML ở dạng cặp key:value. Dấu hai chấm trong YAML có vị trí quan trọng - cặp key:value được tách ra bởi dấu hai chấm (không phải dấu bằng!)\nYAML nên bắt đầu với metadata cho tài liệu. Thứ tự của những tham số YAML chính (không thụt lề) không quan trọng. Ví dụ:\ntitle: \"My document\"\nauthor: \"Me\"\ndate: \"2024-05-10\"\nBạn có thể sử dụng code R trong giá trị YAML bằng cách viết nó như code tại dòng (mở đầu bằng r trong dấu back-ticks/nháy đơn ngược) nhưng nằm trong trích dẫn (xem tại ví dụ phía trên với date:).\nTrong hình ảnh phía trên, vì chúng ta ấn vào kết quả đầu ra mặc định là tệp html, chúng ta có thể thấy rằng YAML hiện output: html_document. Tuy nhiên, chúng ta cũng có thể thay đổi thành powerpoint_presentation hoặc word_document hoặc cả pdf_document.\n\n\nVăn bản\nĐây là phần diễn giải trong tài liệu của bạn, gồm các tiêu đề và đề mục. Nó được viết bằng ngôn ngữ “markdown”, được sử dụng trên nhiều phần mềm khác nhau.\nDưới đây là những cách cốt lõi để viết văn bản định dạng này. Xem thêm tài liệu mở rộng có sẵn trên R Markdown “cheatsheet” tại Trang web RStudio.\n\nDòng mới\nDuy nhất trong R Markdown, để bắt đầu một dòng mới, nhập *hai dấu cách** vào cuối dòng trước đó và ấn Enter/Return.\n\n\nĐịnh dạng\nĐặt các chữ bình thường bên trong các kí tự sau để thay đổi định dạng của chúng ở đầu ra.\n\nGạch dưới (_chữ_) hoặc dấu hoa thị đơn (*chữ*) để in nghiêng\nDấu hoa thị kép (**chữ**) để in đậm\nDấu nháy đơn ngược (chữ) để hiển thị chữ như code\n\nPhông chữ hiển thị thực tế có thể được đặt bằng cách sử dụng các mẫu cụ thể (được chỉ định trong YAML metadata; xem các tab ví dụ).\n\n\nMàu sắc\nKhông có cơ chế đơn giản nào để thay đổi màu chữ trong R Markdown. Một giải pháp khác, NẾU đầu ra của bạn là tệp HTML, là thêm một dòng HTML vào văn bản markdown. Đoạn mã HTML dưới đây sẽ in ra một dòng văn bản có màu đỏ đậm.\n&lt;span style=\"color: red;\"&gt;**_DANGER:_** This is a warning.&lt;/span&gt;  \nDANGER: This is a warning.\n\n\nTiêu đề và đầu mục\nDấu thăng trong phần văn bản của một script R Markdown tạo ra đầu mục. Điều này khác với một đoạn code R trong script, trong đó ký hiệu thăng là cơ chế nhận xét/chú thích/hủy kích hoạt, như trong R script bình thường.\nCác mức tiêu đề khác nhau được thiết lập với số lượng ký hiệu thăng khác nhau khi bắt đầu một dòng mới. Một ký hiệu thăng là tiêu đề hoặc đầu mục chính. Hai ký hiệu thăng là một đầu mục cấp hai. Các đầu mục cấp ba và cấp bốn có thể được tạo bằng các ký hiệu thăng liên tiếp.\n# Đầu mục cấp một / Tiêu đề\n\n## Đầu mục cấp hai\n\n### Đầu mục cấp ba\n\n\nDấu đầu dòng và đánh số\nSử dụng dấu hoa thị (*) để tạo danh sách gạch đầu dòng. Kết thúc câu trước, nhập hai dấu cách, Enter/Return hai lần, và bắt đầu tạo gạch đầu dòng. Thêm một dấu cách vào giữa dấu hoa thị và chữ đầu dòng. Sau mỗi đầu dòng nhập hai dấu cách và Enter/Return. Gạch đầu dòng phụ được tạo tương tự nhưng được thụt vào. Các số cũng hoạt động tương tự nhưng thay vì dấu hoa thị, viết 1), 2), v.v. Dưới đây là cách văn bản R Markdown script của bạn trông như thế nào.\nĐây là gạch đầu dòng của tôi (có hai dấu cách sau dấu hai chấm này):  \n\n* Gạch đầu dòng 1 (theo sau là 2 dấu cách và Enter/Return)  \n* Gạch đầu dòng 2 (theo sau là 2 dấu cách và Enter/Return)  \n  * Gạch đầu dòng phụ 1 (theo sau là 2 dấu cách và Enter/Return)  \n  * Gạch đầu dòng phụ 2 (theo sau là 2 dấu cách và Enter/Return)  \n  \n\n\nChữ chú giải\nBạn có thể “chú giải” văn bản R Markdown giống như bạn sử dụng “#” để chú giải một dòng code R trong một đoạn code R. Chỉ cần đánh dấu văn bản và nhấn Ctrl+Shift+c (Cmd+Shift+c cho Mac). Văn bản sẽ được bao quanh bởi các mũi tên và chuyển sang màu xanh lục. Nó sẽ không xuất hiện trong kết quả đầu ra của bạn.\n\n\n\n\n\n\n\n\n\n\n\n\nĐoạn Code\nCác phần của script dành riêng để chạy code R được gọi là “chunk - đoạn”. Đây là nơi bạn có thể tải các package, nhập dữ liệu và thực hiện quản lý và trực quan hóa dữ liệu thực tế. Có thể có nhiều đoạn code, vì vậy chúng có thể giúp bạn tổ chức code R của mình thành các phần, có thể xen kẽ với văn bản. Cần lưu ý:\nNhững ‘đoạn’ này sẽ có màu nền hơi khác so với phần diễn giải của tài liệu.\nMỗi đoạn code được mở với một dòng bắt đầu với 3 dấu nháy đơn ngược, và ngoặc nhọn chứa các tham số cho đoạn ({ }). Đoạn code kết thúc với 3 dấu nháy đơn ngược.\nBạn có thể tạo một đoạn code mới bằng cách tự gõ nó ra, hoặc bằng cách sử dụng phím tắt “Ctrl + Alt + i” (hoặc Cmd + Shift + r trong Mac), hoặc bằng cách nhấp vào biểu tượng ‘insert a new code chunk’ màu xanh lục ở đầu trình chỉnh sửa script của bạn.\nMột số lưu ý về nội dung bên trong dấu ngoặc nhọn { }:\n\nChúng bắt đầu bằng ‘r’ để chỉ ra rằng tên ngôn ngữ trong đoạn này là R\nSau chữ r, bạn có thể tùy ý viết “tên” đoạn - việc này không cần thiết nhưng có thể giúp bạn sắp xếp công việc của mình tốt hơn. Lưu ý rằng nếu bạn đặt tên cho các phần của mình, bạn phải LUÔN sử dụng các tên độc nhất, nếu không R sẽ báo lỗi khi bạn cố gắng kết xuất.\n\nDấu ngoặc nhọn cũng có thể bao gồm các tùy chọn khác, được viết dưới dạng tag = value, chẳng hạn như:\n\neval = FALSE để không chạy code R\n\necho = FALSE để không hiển thị mã nguồn code R của đoạn trong kết quả đầu ra\n\nwarning = FALSE để không hiển thị cảnh báo được tạo bởi code R\n\nmessage = FALSE để không hiển thị bất kỳ thông báo nào được tạo bởi code R\n\ninclude = TRUE/FALSE có bao gồm đầu ra đoạn code (ví dụ: các đồ thị) trong tài liệu hay không\n\nout.width = và out.height = - cung cấp theo kiểu out.width = \"75%\"\n\nfig.align = \"center\" điều chỉnh cách một hình được căn trên trang\n\nfig.show='hold' nếu đoạn code của bạn hiển thị nhiều biểu đồ và bạn muốn chúng hiển thị cạnh nhau (cùng với out.width = c(\"33%\", \"67%\"). Có thể đặt là fig.show='asis' để hiển thị chúng dưới code tạo chúng, 'hide' để ẩn, hoặc 'animate' để nối nhiều cái thành một ảnh động.\n\nTiêu đề đoạn phải được viết trên một dòng\n\nCố gắng tránh dấu chấm, dấu gạch dưới và dấu cách. Sử dụng dấu gạch ngang ( - ) thay thế nếu bạn cần dấu ngăn cách.\n\nĐọc kĩ hơn về các tùy chọn knitr tại đây.\nMột số tùy chọn ở trên có thể được định cấu hình với trỏ và nhấp bằng cách sử dụng các nút cài đặt ở trên cùng bên phải của đoạn. Tại đây, bạn có thể chỉ định những phần nào của đoạn mà bạn muốn tài liệu được kết xuất bao gồm cụ thể là code, kết quả đầu ra và cảnh báo. Điều này sẽ xuất hiện dưới dạng tùy chọn được viết trong dấu ngoặc nhọn, ví dụ echo = FALSE nếu bạn muốn ‘Chỉ hiển thị đầu ra’.\n\n\n\n\n\n\n\n\n\nNgoài ra còn có hai mũi tên ở trên cùng bên phải của mỗi đoạn code. Chúng rất hữu ích để chạy code trong một đoạn hoặc tất cả code trong các đoạn trước. Di chuột lên chúng để xem chúng làm gì.\nĐể các tùy chọn toàn cục được áp dụng cho tất cả các đoạn trong tập lệnh, bạn có thể thiết lập điều này trong đoạn code R đầu tiên của mình trong tập lệnh. Ví dụ, để chỉ các kết quả đầu ra được hiển thị cho mỗi đoạn code chứ không phải bản thân code, bạn có thể đưa lệnh này vào đoạn code R:\n\nknitr::opts_chunk$set(echo = FALSE) \n\n\nCode R trong văn bản\nBạn cũng có thể bao gồm code R đơn giản trong dấu nháy đơn ngược. Trong dấu nháy đơn ngược, hãy bắt đầu mã bằng “r” và một dấu cách, để RStudio biết đánh giá code đó là code R. Xem ví dụ bên dưới.\nVí dụ bên dưới hiển thị nhiều cấp tiêu đề, dấu đầu dòng và sử dụng code R cho ngày hiện tại (Sys.Date ()) để chuyển thành ngày in.\n\n\n\n\n\n\n\n\n\nPhía trên là một ví dụ đơn giản (hiển thị ngày hiện tại), nhưng sử dụng cùng một cú pháp, bạn có thể hiển thị các giá trị được tạo bởi code R phức tạp hơn (ví dụ: để tính toán giá trị nhỏ nhất, trung bình, giá trị lớn nhất của một cột). Bạn cũng có thể tích hợp các đối tượng hoặc giá trị R đã được tạo trong các đoạn code R trước đó trong script.\nVí dụ, script dưới đây tính toán tỷ lệ các trường hợp dưới 18 tuổi, sử dụng các hàm tidyverse và tạo các đối tượng less18,total và less18prop. Giá trị động này được chèn vào văn bản tiếp theo. Chúng ta thấy nó trông như thế nào khi được knit vào một tài liệu word.\n\n\n\n\n\n\n\n\n\n\n\n\nẢnh\nBạn có thể đưa hình ảnh vào R Markdown của mình theo một trong hai cách:\n\n![](\"path/to/image.png\")  \n\nNếu cách trên không được, thử dùng knitr::include_graphics()\n\nknitr::include_graphics(\"path/to/image.png\")\n\n(hãy nhớ rằng, đường dẫn tệp của bạn có thể được viết bằng cách sử dụng package here)\n\nknitr::include_graphics(here::here(\"path\", \"to\", \"image.png\"))\n\n\n\nBảng\nTạo bảng bằng dấu gạch ngang ( - ) và dấu thanh ( | ). Số lượng dấu gạch nối trước/giữa các thanh cho phép số lượng khoảng trắng trong ô trước khi văn bản bắt đầu được bao lại.\nCột 1    |Cột  2    |Cột 3\n---------|----------|--------\nÔ A      |Ô B       |Ô C\nÔ D      |Ô E       |Ô F\nCode trên tạo ra bảng ở dưới:\n\n\n\nCột 1\nCột 2\nCột 3\n\n\n\n\nÔ A\nÔ B\nÔ C\n\n\nÔ D\nÔ E\nÔ F\n\n\n\n\n\nCác phần được chia thẻ\nĐối với đầu ra là tệp HTML, bạn có thể sắp xếp các phần thành các “tab - thẻ”. Chỉ cần thêm .tabset vào trong dấu ngoặc nhọn{}được đặt sau đề mục. Bất kỳ đề mục phụ nào bên dưới tiêu đề đó (cho đến khi tiêu đề khác cùng cấp) sẽ xuất hiện dưới dạng các tab mà người dùng có thể nhấp qua. Đọc thêm tại đây\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBạn có thể thêm một tùy chọn bổ sung .tabset-pills sau .tabset để tạo cho các thẻ có giao diện “được tô màu”. Lưu ý rằng khi xem đầu ra HTML theo thẻ, chức năng tìm kiếm Ctrl+f sẽ chỉ tìm kiếm các tab “đang hoạt động” chứ không phải các thẻ ẩn.",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Báo cáo với R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.vn.html#cấu-trúc-tệp",
    "href": "new_pages/rmarkdown.vn.html#cấu-trúc-tệp",
    "title": "40  Báo cáo với R Markdown",
    "section": "40.4 Cấu trúc tệp",
    "text": "40.4 Cấu trúc tệp\nCó nhiều cách để tổ chức R Markdown của bạn và bất kỳ script R nào liên quan. Mỗi cách đều có cả ưu điểm và nhược điểm:\n\nR Markdown khép kín - mọi thứ cần thiết cho báo cáo đều được nhập hoặc tạo trong R Markdown\n\nNguồn từ các tệp khác - Bạn có thể chạy các script R bên ngoài bằng lệnh source () và sử dụng đầu ra của chúng trong Rmd\n\nScipt con - một cơ chế thay thế cho source()\n\n\nSử dụng “runfile” - Chạy các lệnh trong script R trước khi kết xuất tệp R Markdown\n\n\nRmd khép kín\nĐối với một báo cáo tương đối đơn giản, bạn có thể chọn tổ chức tập lệnh R Markdown của mình sao cho nó “khép kín” và không liên quan đến bất kỳ tập lệnh bên ngoài nào.\nMọi thứ bạn cần để chạy R markdown đều được nhập hoặc tạo trong tệp Rmd, bao gồm tất cả các đoạn code và package. Cách tiếp cận “khép kín” này phù hợp khi bạn không cần xử lý nhiều dữ liệu (ví dụ: nó mang đến một tệp dữ liệu sạch hoặc gần sạch) và việc kết xuất R Markdown sẽ không mất quá nhiều thời gian.\nTrong trường hợp này, một cấu trúc hợp lý của script R Markdown có thể là:\n\nThiết lập các tùy chọn knitr chung\n\nTải packages\n\nNhập dữ liệu\n\nXử lý dữ liệu\n\nTạo kết quả đầu ra (bảng, đồ thị, etc.)\n\nLưu kết quả đầu ra nếu cần (.csv, .png, v.v.)\n\n\nNguồn từ các tệp khác\nMột biến thể của cách tiếp cận “khép kín” là có các đoạn code R Markdown “nguồn” (chạy) chạy các script R khác. Điều này có thể làm cho tập lệnh R Markdown của bạn ít lộn xộn hơn, đơn giản hơn và dễ tổ chức hơn. Nó cũng có thể hữu ích nếu bạn muốn hiển thị số liệu cuối cùng ở đầu báo cáo. Theo cách tiếp cận này, script R Markdown cuối cùng chỉ đơn giản là kết hợp các đầu ra được xử lý trước thành một tài liệu.\nMột cách để làm điều này là cung cấp script R (đường dẫn tệp và tên có phần mở rộng) cho lệnh R base source().\n\nsource(\"your-script.R\", local = knitr::knit_global())\n# or sys.source(\"your-script.R\", envir = knitr::knit_global())\n\nLưu ý rằng khi sử dụng source () trong R Markdown, các tệp bên ngoài sẽ vẫn được chạy trong quá trình kết xuất tệp Rmd của bạn. Do đó, mỗi tập lệnh được chạy mỗi lần bạn kết xuất báo cáo. Do đó, việc có các lệnh source () này trong R Markdown không tăng tốc thời gian chạy của bạn, cũng như không hỗ trợ nhiều cho việc gỡ lỗi, vì lỗi vẫn được hiển thị khi tạo R Markdown.\nMột giải pháp thay thế là sử dụng tùy chọn child = của knitr. GIẢI THÍCH THÊM ĐỂ LÀM\nBạn phải để ý các môi trường R khác nhau. Các đối tượng được tạo trong một môi trường sẽ không nhất thiết phải có sẵn cho môi trường được R Markdown sử dụng.\n\n\n\nRunfile\nCách tiếp cận này liên quan đến việc sử dụng R script có chứa (các) lệnh render () để xử lý trước các đối tượng đưa vào R markdown.\nVí dụ, bạn có thể tải các package, tải và làm sạch dữ liệu, và thậm chí tạo các biểu đồ trước khi render(). Các bước này có thể xảy ra trong R script hoặc trong các script khác được lưu nguồn. Miễn là các lệnh này diễn ra trong cùng một phiên RStudio và các đối tượng được lưu vào môi trường, các đối tượng sau đó có thể được gọi trong nội dung Rmd. Sau đó, bản thân R markdown sẽ chỉ được sử dụng cho bước cuối cùng - để tạo ra kết quả với tất cả các đối tượng được xử lý trước. Điều này dễ dàng hơn để gỡ lỗi nếu có sự cố.\nCách tiếp cận này hữu ích vì những lý do sau:\n\nThông báo lỗi mang nhiều thông tin hơn - những thông báo này sẽ được tạo từ R script, không phải R Markdown. Lỗi R Markdown có xu hướng cho bạn biết đoạn nào có vấn đề, nhưng sẽ không cho bạn biết dòng nào.\nNếu có thể, bạn có thể chạy các bước xử lý dài trước lệnh render () - chúng sẽ chỉ chạy một lần.\n\nTrong ví dụ bên dưới, chúng ta có một R script riêng biệt, trong đó chúng tôi xử lý trước một đối tượng data vào Môi trường R và sau đó kết xuất “create_output.Rmd” bằng cách sử dụng render().\n\ndata &lt;- import(\"datafile.csv\") %&gt;%       # Load data and save to environment\n  select(age, hospital, weight)          # Select limited columns\n\nrmarkdown::render(input = \"create_output.Rmd\")   # Create Rmd file\n\n\n\nCấu trúc thư mục\nQuy trình làm việc cũng liên quan đến cấu trúc thư mục tổng thể, chẳng hạn như có thư mục ‘đầu ra’ cho các tài liệu và số liệu đã tạo và thư mục ‘dữ liệu’ hoặc ‘đầu vào’ cho dữ liệu đã được làm sạch. Chúng tôi không đi sâu vào chi tiết ở đây, nhưng hãy xem chương Tổ chức báo cáo định kỳ.",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Báo cáo với R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.vn.html#tạo-tài-liệu",
    "href": "new_pages/rmarkdown.vn.html#tạo-tài-liệu",
    "title": "40  Báo cáo với R Markdown",
    "section": "40.5 Tạo tài liệu",
    "text": "40.5 Tạo tài liệu\nBạn có thể tạo tài liệu theo những cách sau:\n\nThủ công bằng cách nhấn nút “Knit” ở đầu trình chỉnh sửa script RStudio (nhanh chóng và dễ dàng)\n\nChạy lệnh render() (được thực thi bên ngoài R Markdown script)\n\n\nCách 1: Nút “Knit”\nKhi bạn mở tệp Rmd, hãy nhấn vào biểu tượng/nút ‘Knit’ ở đầu tệp.\nR Studio sẽ cho bạn thấy tiến trình trong tab ‘R Markdown’ gần R console của bạn. Tài liệu sẽ tự động mở khi hoàn tất.\nTài liệu sẽ được lưu trong cùng một thư mục với R markdown script của bạn và có cùng tên tệp (ngoại trừ phần mở rộng). Điều này rõ ràng không phải là lý tưởng cho việc kiểm soát phiên bản (nó sẽ bị ghi đè lên mỗi lần bạn knit, trừ khi được di chuyển theo cách thủ công), như sau đó bạn có thể cần phải tự đổi tên tệp (ví dụ: thêm ngày).\nĐây là nút tắt của RStudio cho hàm render () từ rmarkdown. Cách tiếp cận này chỉ tương thích với R markdown khép kín, nơi tất cả các thành phần cần thiết tồn tại hoặc có nguồn trong tệp.\n\n\n\n\n\n\n\n\n\n\n\nCách 2: Lệnh render()\nMột cách khác để tạo đầu ra R Markdown của bạn là chạy hàm render () (từ package rmarkdown). Bạn phải thực hiện lệnh này bên ngoài R Markdown script - vì vậy hoặc trong một tập lệnh R riêng biệt (thường được gọi là “run file”) hoặc dưới dạng lệnh độc lập trong R Console.\n\nrmarkdown::render(input = \"my_report.Rmd\")\n\nNhư với “knit”, cài đặt mặc định sẽ lưu đầu ra Rmd vào cùng thư mục với Rmd script, với cùng tên tệp (ngoài phần mở rộng tệp). Ví dụ: “my_report.Rmd” khi được knit sẽ tạo ra “my_report.docx” nếu bạn đang knit vào một tài liệu word. Tuy nhiên, bằng cách sử dụng render (), bạn có tùy chọn sử dụng các cài đặt khác nhau. render () có thể chấp nhận các đối số bao gồm:\n\noutput_format = Đây là định dạng đầu ra để chuyển đổi (e.g. \"html_document\", \"pdf_document\", \"word_document\", hoặc \"all\"). Bạn cũng có thể chỉ định điều này trong YAML bên trong R Markdown script.\n\noutput_file = Đây là tên của tệp đầu ra (và đường dẫn tệp). Điều này có thể được tạo thông qua các hàm R như here() hoặc str_glue() như minh họa bên dưới.\n\noutput_dir = Đây là thư mục đầu ra (thư mục) để lưu tệp. Điều này cho phép bạn chọn một thư mục khác với thư mục mà tệp Rmd được lưu vào.\n\noutput_options = Bạn có thể cung cấp một danh sách các tùy chọn sẽ ghi đè các tùy chọn đó trong script YAML (ví dụ, )\noutput_yaml = Bạn có thể cung cấp đường dẫn đến tệp .yml chứa thông số kỹ thuật YAML\n\nparams = Xem phần thông số bên dưới\n\nXem danh sách đầy đủ tại đây\n\nVí dụ, để cải thiện kiểm soát phiên bản, lệnh sau sẽ lưu tệp đầu ra trong thư mục con ‘đầu ra’, với ngày hiện tại trong tên tệp. Để tạo tên tệp, hàm str_glue () từ package stringr được sử dụng để ‘dán’ các chuỗi tĩnh lại với nhau (được viết đơn giản) với code R động (được viết trong dấu ngoặc nhọn). Ví dụ: nếu đó là ngày 10 tháng 4 năm 2021, tên tệp từ bên dưới sẽ là “Report_2021-04-10.docx”. Xem chương Ký tự và chuỗi để biết thêm chi tiết về str_glue ().\n\nrmarkdown::render(\n  input = \"create_output.Rmd\",\n  output_file = stringr::str_glue(\"outputs/Report_{Sys.Date()}.docx\")) \n\nKhi file đang kết xuất, RStudio Console sẽ cho bạn thấy quá trình kết xuất tới 100%, và một thông báo cuối để báo rằng quá trình kết xuất đã hoàn thành.\n\n\nCách 3: reportfactory package\nR package reportfactory cung cấp một phương pháp thay thế để tổ chức và soạn báo cáo R Markdown phù hợp với các tình huống mà bạn chạy báo cáo thường xuyên (ví dụ hàng ngày, hàng tuần …). Nó giúp giảm bớt việc soạn nhiều tệp R Markdown và tổ chức đầu ra của chúng. Về bản chất, nó cung cấp một “nhà máy” mà từ đó bạn có thể chạy báo cáo R Markdown, nhận các thư mục được đánh dấu ngày tháng và thời gian tự động cho kết quả đầu ra và có cách kiểm soát phiên bản “nhẹ nhàng”.\nĐọc thêm về quy trình công việc này trong chương về Tổ chức báo cáo định kỳ.",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Báo cáo với R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.vn.html#báo-cáo-được-tham-số-hóa",
    "href": "new_pages/rmarkdown.vn.html#báo-cáo-được-tham-số-hóa",
    "title": "40  Báo cáo với R Markdown",
    "section": "40.6 Báo cáo được tham số hóa",
    "text": "40.6 Báo cáo được tham số hóa\nBạn có thể sử dụng tham số hóa để tạo báo cáo động, sao cho báo cáo có thể được chạy với cài đặt cụ thể (ví dụ: ngày hoặc địa điểm cụ thể hoặc với các tùy chọn knit nhất định). Dưới đây, chúng tôi tập trung vào những điều cơ bản, nhưng có thêm các tài liệu chi tiết trực tuyến về các báo cáo được tham số hóa.\nSử dụng bộ dữ liệu Ebola có tên linelist làm ví dụ, giả sử chúng ta muốn chạy một báo cáo giám sát tiêu chuẩn cho từng bệnh viện mỗi ngày. Chúng ta chỉ ra cách người ta có thể làm điều này bằng cách sử dụng các tham số.\nQuan trọng: các báo cáo động cũng có thể thực hiện được mà không có cấu trúc tham số chính thức (không có params:), bằng cách sử dụng các đối tượng R đơn giản trong R script liền kề. Điều này được giải thích ở cuối phần này.\n\nCài đặt tham số\nBạn có nhiều cách để chỉ định giá trị tham số cho đầu ra R Markdown của mình.\n\nCách 1: Đặt tham số trong YAML\nChỉnh sửa YAML để bao gồm tùy chọn params:, với các biểu thức được thụt lề cho mỗi tham số bạn muốn xác định. Trong ví dụ này, chúng tôi tạo các tham số date vàhospital, với các giá trị mà chúng tôi chỉ định. Các giá trị này có thể thay đổi mỗi khi chạy báo cáo. Nếu bạn sử dụng nút “Knit” để tạo ra đầu ra, các tham số sẽ có các giá trị mặc định này. Tương tự như vậy, nếu bạn sử dụng render (), các tham số sẽ có các giá trị mặc định này trừ khi được chỉ định khác trong lệnh render ().\n---\ntitle: Surveillance report\noutput: html_document\nparams:\n date: 2021-04-10\n hospital: Central Hospital\n---\nỞ chế độ nền, các giá trị tham số này được chứa trong danh sách chỉ đọc được gọi là params. Do đó, bạn có thể chèn các giá trị tham số trong code R như cách bạn làm với một đối tượng/giá trị R khác trong môi trường của bạn. Chỉ cần gõ params $ theo sau là tên tham số. Ví dụ: params $ Hospital để đại diện cho tên bệnh viện (“Central Hospital” theo mặc định).\nLưu ý rằng các tham số cũng có thể giữ các giá trị true hoặc false, và vì vậy chúng có thể được đưa vào các tùy chọn knitr của bạn trong một đoạn code R. Ví dụ: bạn có thể đặt {r, eval=params$run} thay vì {r, eval=FALSE}, và bây giờ việc đoạn code chạy hay không phụ thuộc vào giá trị của tham số run:.\nLưu ý rằng đối với các tham số là ngày tháng, chúng sẽ được nhập dưới dạng một chuỗi. Vì vậy, để params$date được diễn giải trong code R, nó có thể sẽ cần được bao bọc bằng as.Date() hoặc một hàm tương tự để chuyển đổi thành lớp Date.\n\n\nCách 2: Đặt tham số trong render()\nNhư đã đề cập ở trên, thay thế cho việc nhấn nút “Knit” để tạo đầu ra là thực thi hàm render() từ một script riêng biệt. Trong trường hợp sau này, bạn có thể chỉ định các tham số được sử dụng trong việc hiển thị đó cho đối số params = của render ().\nLưu ý rằng bất kỳ giá trị tham số nào được cung cấp ở đây sẽ ghi đè các giá trị mặc định của chúng nếu được viết trong YAML. Chúng tôi viết các giá trị trong dấu ngoặc kép vì trong trường hợp này chúng phải được định nghĩa là giá trị ký tự/chuỗi.\nLệnh dưới đây kết xuất tệp “surveillance_report.Rmd”, chỉ định tên và thư mục tệp đầu ra động, đồng thời cung cấp một list() gồm hai tham số và giá trị của chúng cho đối số params =.\n\nrmarkdown::render(\n  input = \"surveillance_report.Rmd\",  \n  output_file = stringr::str_glue(\"outputs/Report_{Sys.Date()}.docx\"),\n  params = list(date = \"2021-04-10\", hospital  = \"Central Hospital\"))\n\n\n\nCách 3: Đặt tham số sử Giao diện Người dùng (GUI)\nĐể có cảm giác tương tác hơn, bạn cũng có thể sử dụng Giao diện Người dùng (Graphical User Interface - GUI) để chọn thủ công các giá trị cho các tham số. Để thực hiện việc này, chúng ta có thể nhấp vào menu thả xuống bên cạnh nút ‘Knit’ và chọn ‘Knit with parameter’.\nMột cửa sổ bật lên sẽ xuất hiện cho phép bạn nhập các giá trị cho các tham số được thiết lập trong YAML của tài liệu.\n\n\n\n\n\n\n\n\n\nBạn có thể đạt được điều tương tự thông qua lệnh render() bằng cách chỉ định params = \"ask\", như được minh họa bên dưới.\n\nrmarkdown::render(\n  input = \"surveillance_report.Rmd\",  \n  output_file = stringr::str_glue(\"outputs/Report_{Sys.Date()}.docx\"),\n  params = “ask”)\n\nTuy nhiên, việc nhập giá trị vào cửa sổ bật lên này có thể xảy ra lỗi và lỗi chính tả. Bạn có thể chọn thêm các hạn chế cho các giá trị có thể được nhập thông qua menu thả xuống. Bạn có thể làm điều này bằng cách thêm vào YAML một số thông số kỹ thuật cho mỗi mục nhập params:.\n\nlabel: là cách tiêu đề cho menu thả xuống cụ thể đó\n\nvalue: là giá trị mặc định (bắt đầu)\n\ninput: đặt thành select cho menu thả xuống\n\nchoices: cung cấp các giá trị đủ điều kiện trong menu thả xuống\n\nDưới đây, các thông số kỹ thuật này được viết cho tham số hospital.\n---\ntitle: Surveillance report\noutput: html_document\nparams:\n date: 2021-04-10\n hospital: \n  label: “Town:”\n  value: Central Hospital\n  input: select\n  choices: [Central Hospital, Military Hospital, Port Hospital, St. Mark's Maternity Hospital (SMMH)]\n---\nKhi knit (thông qua nút ‘knit with parameters’ hoặc bằng cách render()), cửa sổ bật lên sẽ có các tùy chọn thả xuống để bạn lựa chọn.\n\n\n\n\n\n\n\n\n\n\n\n\nVí dụ tham số hóa\nĐoạn mã sau đây tạo các tham số cho date và hospital, được sử dụng trong R Markdown tương ứng là params$date và params$hospital.\nTrong kết quả đầu ra của báo cáo, hãy xem cách dữ liệu được lọc cho bệnh viện cụ thể và tiêu đề biểu đồ đề cập đến bệnh viện và ngày chính xác. Chúng tôi sử dụng tệp “linelist_cleaned.rds” ở đây, nhưng nó sẽ đặc biệt thích hợp nếu bản thân tệp linelist cũng có một dấu ngày tháng bên trong nó để căn chỉnh với ngày được tham số hóa.\n\n\n\n\n\n\n\n\n\nKnit sẽ tạo ra kết quả cuối cùng với phông chữ và bố cục mặc định.\n\n\n\n\n\n\n\n\n\n\n\nTham số hóa không có params\nNếu bạn đang kết xuất tệp R Markdown với render () từ một script riêng biệt, bạn thực sự có thể tạo ra tác động của tham số hóa mà không cần sử dụng chức năng params:.\nVí dụ, trong R script có chứa lệnh render (), bạn có thể chỉ cần xác định hospital và date là hai đối tượng R (giá trị) trước lệnh render (). Trong R Markdown, bạn sẽ không cần phải có phần params: trong YAML, và chúng tôi sẽ đề cập đến đối tượng date hơn là params$date và hospital hơn là params$hospital.\n\n# This is a R script that is separate from the R Markdown\n\n# define R objects\nhospital &lt;- \"Central Hospital\"\ndate &lt;- \"2021-04-10\"\n\n# Render the R markdown\nrmarkdown::render(input = \"create_output.Rmd\") \n\nLàm theo cách này có nghĩa là bạn không thể “knit với các tham số”, sử dụng GUI hoặc bao gồm các tùy chọn knit trong các tham số. Tuy nhiên, điều này có thể có ích vì nó cho phép code đơn giản hơn.",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Báo cáo với R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.vn.html#tạo-vòng-lặp-nhiều-báo-cáo",
    "href": "new_pages/rmarkdown.vn.html#tạo-vòng-lặp-nhiều-báo-cáo",
    "title": "40  Báo cáo với R Markdown",
    "section": "40.7 Tạo vòng lặp nhiều báo cáo",
    "text": "40.7 Tạo vòng lặp nhiều báo cáo\nChúng ta có thể muốn chạy một báo cáo nhiều lần, thay đổi các thông số đầu vào, để tạo ra một báo cáo cho từng khu vực pháp lý/đơn vị. Điều này có thể được thực hiện bằng cách sử dụng các công cụ cho việc lặp lại, được giải thích chi tiết trong chương về Lặp, vòng lặp và danh sách. Các tùy chọn bao gồm package purrr hoặc sử dụng vòng lặp for như được giải thích bên dưới.\nDưới đây, chúng tôi sử dụng vòng lặp for đơn giản để tạo báo cáo giám sát cho tất cả các bệnh viện được chọn. Điều này được thực hiện bằng một lệnh (thay vì thay đổi từng thông số bệnh viện theo cách thủ công). Lệnh kết xuất báo cáo phải tồn tại trong một script riêng biệt bên ngoài báo cáo Rmd. Script này cũng sẽ chứa các đối tượng được xác định để “lặp qua” - ngày hôm nay và một vectơ tên bệnh viện để lặp qua.\n\nhospitals &lt;- c(\"Central Hospital\",\n                \"Military Hospital\", \n                \"Port Hospital\",\n                \"St. Mark's Maternity Hospital (SMMH)\") \n\nSau đó, chúng tôi cung cấp từng giá trị này vào lệnh render() bằng cách sử dụng một vòng lặp, lệnh này chạy lệnh một lần cho mỗi giá trị trong vectơ hospitals. Chữ cái i đại diện cho vị trí chỉ mục (từ 1 đến 4) của bệnh viện hiện đang được sử dụng trong lần lặp đó, như vậy hospital_list[1] sẽ là “Central Hospital”. Thông tin này được cung cấp ở hai nơi trong lệnh render():\n\nĐối với tên tệp, sao cho tên tệp của lần lặp đầu tiên nếu được tạo vào ngày 10 tháng 4 năm 2021 sẽ là “Report_Central Hospital_2021-04-10.docx”, được lưu trong thư mục con ‘output’ của thư mục làm việc.\n\nVới params = sao cho Rmd sử dụng tên bệnh viện trong nội bộ bất cứ khi nào giá trị params$hospital được gọi (ví dụ: chỉ để lọc tập dữ liệu cho bệnh viện cụ thể). Trong ví dụ này, bốn tệp sẽ được tạo - mỗi tệp cho một bệnh viện.\n\n\nfor(i in 1:length(hospitals)){\n  rmarkdown::render(\n    input = \"surveillance_report.Rmd\",\n    output_file = str_glue(\"output/Report_{hospitals[i]}_{Sys.Date()}.docx\"),\n    params = list(hospital  = hospitals[i]))\n}",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Báo cáo với R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.vn.html#mẫu",
    "href": "new_pages/rmarkdown.vn.html#mẫu",
    "title": "40  Báo cáo với R Markdown",
    "section": "40.8 Mẫu",
    "text": "40.8 Mẫu\nBằng cách sử dụng tài liệu mẫu có chứa bất kỳ định dạng mong muốn nào, bạn có thể điều chỉnh tính thẩm mỹ của đầu ra Rmd sẽ trông như thế nào. Ví dụ, bạn có thể tạo tệp MS Word hoặc Powerpoint chứa các trang/trang trình bày với kích thước, hình đóng dấu, hình nền và phông chữ mong muốn.\n\nTài liệu Word\nĐể tạo một mẫu, hãy bắt đầu một tài liệu word mới (hoặc sử dụng đầu ra hiện có với định dạng phù hợp với bạn) và chỉnh sửa phông chữ bằng cách xác định Kiểu. Trong Kiểu, Đầu mục 1, 2 và 3 đề cập đến các cấp đề mục markdown khác nhau (tương ứng #Đề mục 1, ##Đề mục 2 và ### Đề mục 3). Nhấp chuột phải vào kiểu và nhấp vào ‘sửa đổi’ để thay đổi định dạng phông chữ cũng như đoạn văn (ví dụ: bạn có thể giới thiệu các ngắt trang trước các kiểu nhất định có thể giúp giãn cách). Các khía cạnh khác của tài liệu word như lề, kích thước trang, đề mục, v.v., có thể được thay đổi giống như một tài liệu word thông thường mà bạn đang làm việc trực tiếp bên trong.\n\n\n\n\n\n\n\n\n\n\n\nTài liệu Powerpoint\nNhư trên, hãy tạo một slide mới hoặc sử dụng một file powerpoint hiện có với định dạng mong muốn. Để chỉnh sửa thêm, hãy nhấp vào ‘View’ và ‘Slide Master’. Từ đây, bạn có thể thay đổi giao diện trang chiếu ‘master’ bằng cách chỉnh sửa định dạng văn bản trong các hộp văn bản, cũng như kích thước nền/trang cho trang tổng thể.\n\n\n\n\n\n\n\n\n\nThật không may, việc chỉnh sửa tệp powerpoint hơi kém linh hoạt:\n\nĐề mục cấp đầu tiên (# Đề mục 1) sẽ tự động trở thành tiêu đề của trang trình bày mới,\n\nChữ ## Đề mục 2 sẽ không xuất hiện dưới dạng phụ đề mà là chữ trong hộp văn bản chính của trang chiếu (trừ khi bạn tìm được cách để làm rộng chế độ xem Master).\nCác ô và bảng đã xuất sẽ tự động chuyển sang các trang trình bày mới. Bạn sẽ cần kết hợp chúng, chẳng hạn như hàm patchwork để kết hợp các ggplots, để chúng hiển thị trên cùng một trang. Xem bài đăng trên blog về cách sử dụng package patchwork để đặt nhiều hình ảnh trên một trang chiếu.\n\nXem officer package để biết công cụ làm việc chuyên sâu hơn với các bài thuyết trình powerpoint.\n\n\nTích hợp các mẫu vào YAML\nKhi một mẫu được chuẩn bị, chi tiết của mẫu này có thể được thêm vào YAML của Rmd bên dưới dòng ‘đầu ra’ và bên dưới nơi loại tài liệu được chỉ định (chính nó sẽ đi đến một dòng riêng). Lưu ý reference_doc có thể được sử dụng cho các mẫu slide powerpoint.\nDễ dàng nhất là lưu mẫu trong cùng một thư mục với nơi chứa tệp Rmd (như trong ví dụ bên dưới) hoặc trong một thư mục con bên trong.\n---\ntitle: Surveillance report\noutput: \n word_document:\n  reference_docx: \"template.docx\"\nparams:\n date: 2021-04-10\n hospital: Central Hospital\ntemplate:\n \n---\n\n\nĐịnh dạng tệp HTML\nCác tệp HTML không sử dụng các mẫu, nhưng có thể có các kiểu được định cấu hình trong YAML. HTML là tài liệu tương tác và đặc biệt linh hoạt. Chúng tôi đề cập đến một số tùy chọn cơ bản ở đây.\n\nMục lục: Chúng ta có thể thêm mục lục với toc: true bên dưới, và cũng chỉ định rằng nó vẫn có thể xem được (“float”) khi bạn cuộn, vớitoc_float: true.\nChủ đề: Chúng ta có thể tham khảo một số chủ đề được tạo sẵn, lấy từ thư viện chủ đề của Bootswatch. Trong ví dụ dưới đây, chúng tôi sử dụng cerulean. Các tùy chọn khác bao gồm: journal, flatly, darkly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, và yeti.\nĐánh dấu: Định cấu hình này sẽ thay đổi giao diện của chữ được đánh dấu (ví dụ: code trong các đoạn được hiển thị). Các kiểu được hỗ trợ bao gồm mặc định, tango, pygments, kate, monochrome, espresso, zenburn, hasdock, breezedark và textmate.\n\nĐây là một ví dụ về cách tích hợp các tùy chọn trên vào YAML.\n---\ntitle: \"HTML example\"\noutput:\n  html_document:\n    toc: true\n    toc_float: true\n    theme: cerulean\n    highlight: kate\n    \n---\nDưới đây là hai ví dụ về kết quả đầu ra HTML, cả hai đều có mục lục nổi, nhưng chủ đề và kiểu đánh dấu khác nhau được chọn:",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Báo cáo với R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.vn.html#nội-dung-động",
    "href": "new_pages/rmarkdown.vn.html#nội-dung-động",
    "title": "40  Báo cáo với R Markdown",
    "section": "40.9 Nội dung động",
    "text": "40.9 Nội dung động\nTrong đầu ra HTML, nội dung báo cáo của bạn có thể là động. Dưới đây là một số ví dụ:\n\nBảng\nTrong báo cáo HTML, bạn có thể in khung/ô dữ liệu sao cho nội dung là động, với các bộ lọc và thanh cuộn. Có một số packages cung cấp khả năng này.\nĐể thực hiện việc này với package DT, như được sử dụng trong cuốn sổ tay này, bạn có thể chèn một đoạn code như sau:\n\n\n\n\n\n\n\n\n\nHàm datatable() sẽ in khung dữ liệu đã cung cấp dưới dạng bảng động cho trình đọc. Bạn có thể đặt rownames = FALSE để đơn giản hóa phần ngoài cùng bên trái của bảng. filter = \"top\" cung cấp một bộ lọc trên mỗi cột. Trong đối số option() cung cấp danh sách các thông số kỹ thuật khác. Dưới đây, chúng tôi bao gồm hai đối số: pageLength = 5 đặt số hàng xuất hiện là 5 (các hàng còn lại có thể được xem bằng cách phân trang thông qua các mũi tên) vàscrollX = TRUE bật thanh cuộn ở cuối bảng (đối với cột mở rộng quá xa sang bên phải).\nNếu tập dữ liệu của bạn rất lớn, hãy xem xét chỉ hiển thị X hàng trên cùng bằng cách gói khung dữ liệu trong head().\n\n\nTiện ích HTML\nTiện ích HTML cho R là một lớp packages R đặc biệt cho phép tăng tính tương tác bằng cách sử dụng các thư viện JavaScript. Bạn có thể nhúng chúng vào các đầu ra HTML R Markdown.\nMột số ví dụ phổ biến về các tiện ích này bao gồm:\n\nPlotly (được sử dụng trong chương sổ tay này và trong chương Biểu đồ tương tác)\nvisNetwork (được sử dụng trong chương Chuỗi lây nhiễm của sổ tay này)\n\nLeaflet (được sử dụng trong chương GIS Cơ bản của sổ tay này)\n\ndygraphs ( hữu ích để hiển thị dữ liệu chuỗi thời gian tương tác)\n\nDT (datatable()) (được sử dụng để hiển thị các bảng động với bộ lọc, sắp xếp, v.v.)\n\nHàm ggplotly() từ plotly đặc biệt dễ sử dụng. Xem chương Biểu đồ tương tác.",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Báo cáo với R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.vn.html#tài-nguyên",
    "href": "new_pages/rmarkdown.vn.html#tài-nguyên",
    "title": "40  Báo cáo với R Markdown",
    "section": "40.10 Tài nguyên",
    "text": "40.10 Tài nguyên\nTìm thêm thông tin tại:\n\nhttps://bookdown.org/yihui/rmarkdown/\nhttps://rmarkdown.rstudio.com/articles_intro.html\n\nMột giải thích tốt về so sánh giữa markdown, knitr và Rmarkdown ở đây: https://stackoverflow.com/questions/40563479/relationship-between-r-markdown-knitr-pandoc-and-bookdown",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Báo cáo với R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.vn.html",
    "href": "new_pages/reportfactory.vn.html",
    "title": "41  Tổ chức báo cáo định kỳ",
    "section": "",
    "text": "41.1 Chuẩn bị",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Tổ chức báo cáo định kỳ</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.vn.html#chuẩn-bị",
    "href": "new_pages/reportfactory.vn.html#chuẩn-bị",
    "title": "41  Tổ chức báo cáo định kỳ",
    "section": "",
    "text": "Tải packages\nTừ trong RStudio, hãy cài đặt phiên bản mới nhất của reportfactory package từ Github.\nBạn có thể thực hiện việc này thông qua pacman package với p_load_current_gh(), lệnh này sẽ buộc nhập phiên bản mới nhất từ Github. Cung cấp chuỗi ký tự “reconverse/reportfactory”, trong đó chỉ định tổ chức Github (reconverse) và kho lưu trữ (reportfactory). Bạn cũng có thể sử dụng install_github() từ remotes package để thay thế.\n\n# Install and load the latest version of the package from Github\npacman::p_load_current_gh(\"reconverse/reportfactory\")\n#remotes::install_github(\"reconverse/reportfactory\") # alternative",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Tổ chức báo cáo định kỳ</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.vn.html#nhà-máy-mới",
    "href": "new_pages/reportfactory.vn.html#nhà-máy-mới",
    "title": "41  Tổ chức báo cáo định kỳ",
    "section": "41.2 Nhà máy mới",
    "text": "41.2 Nhà máy mới\nĐể tạo một nhà máy mới, chạy hàm new_factory(). Thao tác này sẽ tạo một thư mục dự án R độc lập mới. Mặc định là:\n\nNhà máy sẽ được thêm vào thư mục làm việc của bạn\n\nTên của nhà máy dự án R sẽ được gọi là “new_factory.Rproj”\n\nPhiên RStudio của bạn sẽ “chuyển sang” dự án R này\n\n\n# This will create the factory in the working directory\nnew_factory()\n\nNhìn vào bên trong nhà máy, bạn có thể thấy rằng các thư mục con và một số tệp đã được tạo tự động.\n\n\n\n\n\n\n\n\n\n\nThư mục report_sources sẽ chứa các scripts R Markdown của bạn, các scripts này sẽ tạo ra các báo cáo của bạn\n\nThư mục outputs sẽ chứa các kết quả đầu ra của báo cáo (ví dụ: HTML, Word, PDF, v.v.)\n\nThư mục scripts có thể được sử dụng để lưu trữ các scripts R khác (ví dụ: được lấy từ các scripts Rmd của bạn)\n\nThư mục data có thể được sử dụng để chứa dữ liệu của bạn (bao gồm các thư mục con “thô” và “sạch”)\n\nTệp .here, vì vậy bạn có thể sử dụng here package để gọi các tệp trong thư mục con theo mối quan hệ của chúng với thư mục gốc này (xem chương R projects để biết thêm chi tiết)\nTệp gitignore được tạo trong trường hợp bạn liên kết dự án R này với kho lưu trữ Github (xem Version control and collaboration with Github)\n\nTệp README trống, nếu bạn sử dụng kho lưu trữ Github\n\nTHẬN TRỌNG: tùy thuộc vào cài đặt máy tính của bạn, các tệp như “.here” có thể tồn tại nhưng ẩn.\nTrong số các cài đặt mặc định, dưới đây là một số cài đặt mà bạn có thể điều chỉnh trong lệnh new_factory():\n\nfactory = - Đặt tên cho thư mục gốc (mặc định là “new_factory”)\n\npath = - Chỉ định đường dẫn tệp cho nhà máy mới (mặc định là thư mục làm việc)\n\nreport_sources = Đặt tên thay thế cho thư mục con chứa các R Markdown scripts (mặc định là “report_sources”)\n\noutputs = Đặt tên thay thế cho thư mục chứa kết quả đầu ra báo cáo (mặc định là “outputs”)\n\nXem ?new_factory để biết danh sách đầy đủ các đối số.\nKhi bạn tạo nhà máy mới, phiên R của bạn được chuyển sang dự án R mới, vì vậy bạn nên tải lại package reportfactory.\n\npacman::p_load(reportfactory)\n\nBây giờ bạn có thể chạy lệnh factory_overview() để xem cấu trúc bên trong (tất cả các thư mục và tệp) trong nhà máy.\n\nfactory_overview()            # print overview of the factory to console\n\n“Cây” các thư mục và tệp của nhà sản xuất được in ra R console. Lưu ý rằng trong thư mục “data” có các thư mục con cho dữ liệu “raw” (thô) và “clean” (sạch) cũng như dữ liệu CSV mẫu. Ngoài ra còn có “example_report.Rmd” trong thư mục “report_sources”.",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Tổ chức báo cáo định kỳ</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.vn.html#tạo-báo-cáo",
    "href": "new_pages/reportfactory.vn.html#tạo-báo-cáo",
    "title": "41  Tổ chức báo cáo định kỳ",
    "section": "41.3 Tạo báo cáo",
    "text": "41.3 Tạo báo cáo\nTừ bên trong dự án R của nhà máy, hãy tạo báo cáo R Markdown giống như bạn thường làm và lưu nó vào thư mục “report_sources”. Xem chương R Markdown để biết hướng dẫn. Để ví dụ, chúng tôi đã thêm những thứ sau vào nhà máy:\n\nR markdown script mới có tên “daily_sitrep.Rmd”, được lưu trong thư mục “report_sources”\n\nDữ liệu cho báo cáo (“linelist_cleaned.rds”), được lưu vào thư mục con “clean” trong thư mục “data”\n\nChúng ta có thể thấy bằng cách sử dụng factory_overview() R Markdown trong thư mục “report_sources” và tệp dữ liệu trong thư mục dữ liệu “clean” (được đánh dấu):\n\n\n\n\n\n\n\n\n\nDưới đây là ảnh chụp phần đầu của R Markdown “daily_sitrep.Rmd”. Bạn có thể thấy rằng định dạng đầu ra được đặt là HTML, thông qua tiêu đề YAML output: html_document.\n\n\n\n\n\n\n\n\n\nTrong script đơn giản này, có các lệnh để:\n\nTải các packages cần thiết\n\nNhập dữ liệu danh sách dòng bằng đường dẫn tệp từ package here (đọc thêm trong chương Import and export)\n\n\nlinelist &lt;- import(here(\"data\", \"clean\", \"linelist_cleaned.rds\"))\n\n\nIn bảng tóm tắt các trường hợp và xuất nó với export() dưới dạng tệp .csv\n\nIn một đường cong dịch tễ và xuất nó bằng ggsave () dưới dạng tệp .png\n\nBạn chỉ có thể xem lại danh sách các báo cáo R Markdown trong thư mục “report_sources” bằng lệnh này:\n\nlist_reports()",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Tổ chức báo cáo định kỳ</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.vn.html#biên-soạn",
    "href": "new_pages/reportfactory.vn.html#biên-soạn",
    "title": "41  Tổ chức báo cáo định kỳ",
    "section": "41.4 Biên soạn",
    "text": "41.4 Biên soạn\nTrong nhà máy báo cáo, để “biên soạn” báo cáo R Markdown có nghĩa là .Rmd script sẽ được chạy và đầu ra sẽ được tạo (như được chỉ định trong script YAML, ví dụ như HTML, Word, PDF, v.v.).\nNhà máy sẽ tự động tạo một thư mục được đánh dấu ngày tháng và thời gian cho các kết quả đầu ra trong thư mục “outputs”.\nBản thân báo cáo và mọi tệp đã xuất do script tạo ra (ví dụ: csv, png, xlsx) sẽ được lưu vào thư mục này. Ngoài ra, bản thân script Rmd sẽ được lưu trong thư mục này, vì vậy bạn có bản ghi của phiên bản script đó.\nĐiều này trái ngược với hoạt động bình thường của R Markdown “knitted” (kết hợp), lưu kết quả đầu ra vào vị trí của script Rmd. Hành vi mặc định này có thể dẫn đến các thư mục đông đúc, lộn xộn. Nhà máy nhằm mục đích cải thiện tổ chức khi một người cần chạy báo cáo thường xuyên.\n\nBiên soạn theo tên\nBạn có thể biên dịch một báo cáo cụ thể bằng cách chạy compile_reports() và đặt tên Rmd script (không có phần mở rộng .Rmd) cho reports =. Để đơn giản hơn, bạn có thể bỏ qua reports = và chỉ cần viết tên R Markdown trong dấu ngoặc kép, như bên dưới.\n\n\n\n\n\n\n\n\n\nLệnh này sẽ chỉ biên dịch báo cáo “daily_sitrep.Rmd”, lưu báo cáo HTML, xuất bảng .csv và đường cong dịch bệnh .png vào một thư mục con được đóng dấu ngày và giờ cụ thể cho báo cáo, trong thư mục “outputs” .\nLưu ý rằng nếu bạn chọn cung cấp phần mở rộng .Rmd, bạn phải nhập chính xác phần mở rộng vì nó được lưu trong tên tệp (.rmd so với .Rmd).\nCũng lưu ý rằng khi biên soạn, bạn có thể thấy một số tệp tạm thời xuất hiện trong thư mục “report_sources” - nhưng chúng sẽ sớm biến mất khi chúng được chuyển đến đúng thư mục “output”.\n\n\nBiên soạn theo số\nBạn cũng có thể chỉ định Rmd script để biên dịch bằng cách cung cấp một số hoặc vectơ số cho reports =. Các con số phải phù hợp với thứ tự các báo cáo xuất hiện khi bạn chạy list_reports().\n\n# Compile the second and fourth Rmds in the \"report_sources\" folder\ncompile_reports(reports = c(2, 4))\n\n\n\nBiên soạn tất cả\nBạn có thể biên soạn tất cả báo cáo R Markdown trong thư mục “report_sources” bằng cách đặt đối số report = thành TRUE.\n\n\n\n\n\n\n\n\n\n\n\nBiên soạn từ thư mục con\nBạn có thể thêm các thư mục con vào thư mục “report_sources”. Để chạy báo cáo R Markdown từ một thư mục con, chỉ cần cung cấp tên của thư mục cho subfolder =. Dưới đây là ví dụ về code để biên soạn báo cáo Rmd nằm trong thư mục con của “report_sources”.\n\ncompile_reports(\n     reports = \"summary_for_partners.Rmd\",\n     subfolder = \"for_partners\")\n\nBạn có thể biên soạn tất cả các báo cáo Rmd trong một thư mục con bằng cách cung cấp tên thư mục con cho reports =, với một dấu gạch chéo ở cuối, như bên dưới.\n\ncompile_reports(reports = \"for_partners/\")\n\n\n\nTham số hóa\nNhư đã lưu ý trong chương về Reports with R Markdown, bạn có thể chạy báo cáo với các thông số được chỉ định. Bạn có thể chuyển các tham số này dưới dạng danh sách tới compile_reports () thông qua đối số params =. Ví dụ, trong báo cáo hư cấu này, có ba tham số được cung cấp cho báo cáo R Markdown.\n\ncompile_reports(\n  reports = \"daily_sitrep.Rmd\",\n  params = list(most_recent_data = TRUE,\n                region = \"NORTHERN\",\n                rates_denominator = 10000),\n  subfolder = \"regional\"\n)\n\n\n\nDùng “run-file”\nNếu bạn có nhiều báo cáo cần chạy, hãy cân nhắc tạo R script chứa tất cả các lệnh compile_reports(). Người dùng có thể chỉ cần chạy tất cả các lệnh trong R script này và tất cả các báo cáo sẽ được biên soạn. Bạn có thể lưu “run-file” này vào thư mục “scripts”.",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Tổ chức báo cáo định kỳ</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.vn.html#kết-quả-đầu-ra",
    "href": "new_pages/reportfactory.vn.html#kết-quả-đầu-ra",
    "title": "41  Tổ chức báo cáo định kỳ",
    "section": "41.5 Kết quả đầu ra",
    "text": "41.5 Kết quả đầu ra\nSau khi chúng ta đã biên soạn các báo cáo một vài lần, thư mục “outputs” có thể trông giống như sau (các điểm nổi bật được thêm vào để rõ ràng):\n\n\n\n\n\n\n\n\n\n\nTrong “outputs”, các thư mục con đã được tạo cho mỗi báo cáo Rmd\n\nTrong đó, các thư mục con khác đã được tạo cho mỗi lần biên soạn duy nhất\n\nĐây là những ngày tháng và thời gian được đóng dấu (“2021-04-23_T11-07-36” có nghĩa là ngày 23 tháng 4 năm 2021 lúc 11:07:36)\nBạn có thể chỉnh sửa định dạng dấu ngày/giờ. Xem ?compile_reports\n\n\nTrong mỗi thư mục ngày/giờ được biên soạn, kết quả báo cáo được lưu trữ (ví dụ: HTML, PDF, Word) cùng với tập lệnh Rmd (kiểm soát phiên bản!) Và bất kỳ tệp nào được xuất khác (ví dụ: table.csv, translate_curve.png)\n\nĐây là chế độ xem bên trong một trong các thư mục được đánh dấu ngày/giờ cho báo cáo “daily_sitrep”. Đường dẫn tệp được đánh dấu bằng màu vàng để nhấn mạnh.\n\n\n\n\n\n\n\n\n\nCuối cùng, bên dưới là ảnh chụp màn hình của kết quả báo cáo HTML.\n\n\n\n\n\n\n\n\n\nBạn có thể sử dụng list_outputs() để xem lại danh sách các kết quả đầu ra.",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Tổ chức báo cáo định kỳ</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.vn.html#mục-khác",
    "href": "new_pages/reportfactory.vn.html#mục-khác",
    "title": "41  Tổ chức báo cáo định kỳ",
    "section": "41.6 Mục khác",
    "text": "41.6 Mục khác\n\nKnit\nBạn vẫn có thể “knit” một trong các báo cáo R Markdown của mình bằng cách nhấn nút “Knit” nếu muốn. Nếu bạn làm điều này, theo mặc định, kết quả đầu ra sẽ xuất hiện trong thư mục lưu Rmd - thư mục “report_sources”. Trong các phiên bản trước của reportfactory, việc có bất kỳ tệp nào không phải Rmd trong “report_sources” sẽ ngăn việc biên dịch, nhưng trường hợp này không còn nữa. Bạn có thể chạy compile_reports() và không có lỗi nào xảy ra.\n\n\nScripts\nChúng tôi khuyến khích bạn sử dụng thư mục “scripts” để lưu trữ “runfiles” hoặc các .R scripts được lấy từ các .R scripts của bạn. Xem trang trên R Markdown để biết các mẹo về cách cấu trúc code của bạn trên một số tệp.\n\n\nThêm\n\nVới reportfactory, bạn có thể sử dụng hàm list_deps() để liệt kê tất cả các packages được yêu cầu trên tất cả các báo cáo trong toàn bộ nhà máy.\nCó một package đi kèm trong quá trình phát triển được gọi là rfextras cung cấp nhiều chức năng trợ giúp hơn để hỗ trợ bạn trong việc xây dựng báo cáo, chẳng hạn như:\n\nload_scripts() - dẫn nguồn/tải tất cả các .R scripts trong một thư mục nhất định (thư mục “scripts” theo mặc định)\nfind_latest() - tìm phiên bản mới nhất của tệp (ví dụ: tập dữ liệu mới nhất)",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Tổ chức báo cáo định kỳ</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.vn.html#tài-nguyên",
    "href": "new_pages/reportfactory.vn.html#tài-nguyên",
    "title": "41  Tổ chức báo cáo định kỳ",
    "section": "41.7 Tài nguyên",
    "text": "41.7 Tài nguyên\nXem Github page của reportfactory package\nXem Github page của rfextras package",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Tổ chức báo cáo định kỳ</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.vn.html",
    "href": "new_pages/flexdashboard.vn.html",
    "title": "42  Dashboards với R Markdown",
    "section": "",
    "text": "42.1 Chuẩn bị",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Dashboards với R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.vn.html#chuẩn-bị",
    "href": "new_pages/flexdashboard.vn.html#chuẩn-bị",
    "title": "42  Dashboards với R Markdown",
    "section": "",
    "text": "Gọi các packages\nTrong sổ tay này, chúng tôi nhấn mạnh đến hàm p_load() từ package pacman, cài đặt package nếu cần và gọi nó để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm library() từ base R. Xem chương R cơ bản để biết thêm thông tin về các R packages.\n\npacman::p_load(\n  rio,             # nhập/xuất dữ liệu     \n  here,            # định vị tệp\n  tidyverse,       # quản lý và trực quan hóa dữ liệu \n  flexdashboard,   # phiên bản dashboard của báo cáo R Markdown\n  shiny,           # biểu đồ tương tác\n  plotly           # biểu đồ tương tác\n)\n\n\n\nNhập dữ liệu\nChúng ta nhập bộ dữ liệu về các trường hợp từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn theo dõi, hãy  nhấp để tải xuống linelist “sạch” (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm import() từ package rio (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - Xem chương Nhập xuất dữ liệu để biết chi tiết).\n\n# nhập linelist\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\n50 hàng đầu tiên của linelist được hiển thị bên dưới.",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Dashboards với R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.vn.html#tạo-r-markdown-mới",
    "href": "new_pages/flexdashboard.vn.html#tạo-r-markdown-mới",
    "title": "42  Dashboards với R Markdown",
    "section": "42.2 Tạo R Markdown mới",
    "text": "42.2 Tạo R Markdown mới\nSau khi bạn đã cài đặt package, hãy tạo một tệp R Markdown mới bằng cách nhấp qua File &gt; New file &gt; R Markdown.\n\n\n\n\n\n\n\n\n\nTrong cửa sổ mở ra, chọn “From Template” và chọn mẫu “Flex Dashboard”. Sau đó, bạn sẽ được nhắc đặt tên cho tài liệu. Trong ví dụ của chương này, chúng tôi sẽ đặt tên R Markdown của chúng tôi là “outbreak_dashboard.Rmd”.",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Dashboards với R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.vn.html#script",
    "href": "new_pages/flexdashboard.vn.html#script",
    "title": "42  Dashboards với R Markdown",
    "section": "42.3 Script",
    "text": "42.3 Script\nScript là một script R Markdown và do đó có các thành phần và tổ chức tương tự như được mô tả trong chương Báo cáo với R Markdown. Chúng ta sẽ xem lại một cách ngắn gọn định dạng này và nêu rõ sự khác biệt so với các định dạng đầu ra R Markdown khác.\n\nYAML\nỞ đầu script là tiêu đề “YAML”. Mục này phải bắt đầu bằng ba dấu gạch ngang --- và phải kết thúc bằng ba dấu gạch ngang ---. Tham số YAML có trong cặp key:value. Thụt lề và đặt dấu hai chấm trong YAML là việc quan trọng - các cặp key:value được phân tách bằng dấu hai chấm (không phải dấu bằng!).\nYAML phải bắt đầu bằng metadata cho tài liệu. Thứ tự của các tham số YAML chính này (không thụt lề) không quan trọng. Ví dụ:\n\ntitle: \"My document\"\nauthor: \"Me\"\ndate: \"`r Sys.Date()`\"\n\nBạn có thể sử dụng code R trong các giá trị YAML bằng cách đặt nó giống như code nội dòng (bắt dầu bằng r trong dấu nháy đơn ngược) nhưng cũng trong dấu ngoặc kép (xem phần Ngày ở trên).\nTham số YAML bắt buộc là output:, chỉ định loại tệp sẽ được tạo (ví dụ: html_document, pdf_document, word_document hoặcpowerpoint_presentation). Đối với flexdashboard giá trị tham số này hơi khó hiểu - nó phải được đặt là output:flexdashboard::flex_dashboard. Lưu ý dấu hai chấm đơn, dấu hai chấm đôi và dấu gạch dưới. Tham số đầu ra YAML này thường được theo sau bởi một dấu hai chấm nữa và các tham số phụ được thụt lề (xem các tham số orientation: và vertical_layout: bên dưới).\n\ntitle: \"My dashboard\"\nauthor: \"Me\"\ndate: \"`r Sys.Date()`\"\noutput:\n  flexdashboard::flex_dashboard:\n    orientation: rows\n    vertical_layout: scroll\n\nNhư hình trên, thụt lề (2 dấu cách) được sử dụng cho các tham số phụ. Trong trường hợp này, đừng quên đặt thêm một dấu hai chấm sau dấu chính, như key:value:.\nNếu thích hợp, các giá trị logic phải được đưa ra trong YAML ở dạng chữ thường (true, false, null). Nếu dấu hai chấm là một phần giá trị của bạn (ví dụ: trong tiêu đề), hãy đặt giá trị trong dấu ngoặc kép. Xem các ví dụ trong các phần bên dưới.\n\n\nĐoạn Code\nMột script R Markdown có thể chứa nhiều “đoạn” code - đây là những vùng của script mà bạn có thể viết code R nhiều dòng và chúng hoạt động giống như các scripts R nhỏ.\nCác đoạn code được tạo bằng ba dấu nháy đơn ngược và dấu ngoặc nhọn với chữ “r” viết thường bên trong. Đoạn code được đóng bằng ba dấu nháy đơn ngược. Bạn có thể tạo một đoạn code mới bằng cách tự gõ nó ra, bằng cách sử dụng phím tắt “Ctrl + Alt + i” (hoặc Cmd + Shift + r trong Mac) hoặc bằng cách nhấp vào biểu tượng ‘insert a new code chunk’ màu xanh lục ở đầu trình chỉnh sửa script của bạn. Nhiều ví dụ được đưa ra dưới đây.\n\n\nVăn bản tường thuật\nBên ngoài “đoạn” code R, bạn có thể viết văn bản tường thuật. Như được mô tả trong chương Báo cáo với R Markdown, bạn có thể in nghiêng văn bản bằng cách bao quanh nó bằng một dấu hoa thị (*) hoặc in đậm bằng cách bao quanh nó bằng hai dấu hoa thị (**). Nhớ lại rằng dấu đầu dòng và lược đồ đánh số nhạy cảm với dòng mới, thụt đầu dòng và kết thúc một dòng có hai dấu cách.\nBạn cũng có thể chèn code R nội dòng vào văn bản như được mô tả trong chương Báo cáo với R Markdown, bằng cách bao quanh code bằng dấu nháy đơn ngược và bắt đầu lệnh bằng “r”: ` 1+1` (xem ví dụ với ngày ở trên).\n\n\nĐầu mục\nCác cấp đầu mục khác nhau được thiết lập với số lượng ký hiệu thăng khác nhau, như được mô tả trong chương Báo cáo với R Markdown.\nTrong flexdashboard, đầu mục chính (#) tạo một “trang” của dashboard. Đầu mục cấp hai (##) tạo một cột hoặc một hàng tùy thuộc vào thông số orientation: của bạn (xem chi tiết bên dưới). Đầu mục cấp ba (###) tạo bảng điều khiển cho các đồ thị, biểu đồ, bảng, văn bản, v.v.\n# Đầu mục cấp một (trang)\n\n## Đầu mục cấp hai (hàng hoặc cột)  \n\n### Đầu mục cấp ba (bảng điều khiển cho đồ thị, biểu đồ, v.v.)",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Dashboards với R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.vn.html#thuộc-tính-mục",
    "href": "new_pages/flexdashboard.vn.html#thuộc-tính-mục",
    "title": "42  Dashboards với R Markdown",
    "section": "42.4 Thuộc tính mục",
    "text": "42.4 Thuộc tính mục\nNhư trong R markdown bình thường, bạn có thể chỉ định các thuộc tính để áp dụng cho các phần của dashboard của mình bằng cách bao gồm các tùy chọn key=value sau một đầu mục, trong dấu ngoặc nhọn { }. Ví dụ: trong một báo cáo HTML R Markdown điển hình, bạn có thể sắp xếp các tiêu đề phụ thành các tab với ## Đầu mục của tôi {.tabset}.\nLưu ý rằng các thuộc tính này được viết sau một đầu mục trong một phần văn bản của script. Các tùy chọn này khác với các tùy chọn knitr được chèn bên trong ở đầu các đoạn code R, chẳng hạn như out.height =.\nCác thuộc tính mục dành riêng cho flexdashboard bao gồm:\n\n{data-orientation=} Đặt thành rows (hàng) hoặc columns (cột). Nếu dashboard của bạn có nhiều trang, hãy thêm thuộc tính này vào mỗi trang để biểu thị hướng (được giải thích thêm trong layout section).\n\n{data-width=} và {data-height=} đặt kích thước tương đối của biểu đồ, cột, hàng được bố trí theo cùng một chiều (ngang hoặc dọc). Kích thước tuyệt đối được điều chỉnh để lấp đầy không gian tốt nhất trên bất kỳ thiết bị hiển thị nào nhờ công cụ flexbox.\n\nĐộ cao của biểu đồ cũng phụ thuộc vào việc bạn đặt tham số YAML vertical_layout: fill hay vertical_layout: scroll. Nếu được đặt thành cuộn, độ cao biểu đồ sẽ phản ánh tùy chọn fig.height = truyền thống trong đoạn code R.\n\nXem tài liệu về kích thước đầy đủ tại flexdashboard website\n\n\n{.hidden} Sử dụng tùy chọn này để loại trừ một trang cụ thể khỏi thanh điều hướng\n{data-navbar =} Sử dụng điều này trong đầu mục cấp trang để lồng nó vào menu thả xuống của thanh điều hướng. Cung cấp tên (trong dấu ngoặc kép) của menu thả xuống. Xem ví dụ bên dưới.",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Dashboards với R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.vn.html#layout",
    "href": "new_pages/flexdashboard.vn.html#layout",
    "title": "42  Dashboards với R Markdown",
    "section": "42.5 Bố cục",
    "text": "42.5 Bố cục\nĐiều chỉnh bố cục dashboard của bạn theo những cách sau:\n\nThêm trang, cột/hàng và biểu đồ với đầu mục R Markdown (ví dụ: #, ## hoặc ###)\nĐiều chỉnh tham số YAML orientation: thành rows hoặc columns\nChỉ định xem bố cục lấp đầy trình duyệt hay cho phép cuộn\nThêm các tab vào một đầu mục phần cụ thể\n\n\nTrang\nCác đầu mục cấp đầu tiên (#) trong R Markdown sẽ đại diện cho “các trang” của dashboard. Theo mặc định, các trang sẽ xuất hiện trong thanh điều hướng dọc theo đầu dashboard.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBạn có thể nhóm các trang thành một “menu” trong thanh điều hướng trên cùng bằng cách thêm thuộc tính {data-navmenu=} vào đầu mục trang. Hãy cẩn thận - không bao gồm dấu cách xung quanh dấu bằng nếu không nó sẽ không hoạt động!\n\n\n\n\n\n\n\n\n\nĐây là những gì script tạo ra:\n\n\n\n\n\n\n\n\n\nBạn cũng có thể chuyển đổi một trang hoặc một cột thành “thanh bên” ở phía bên trái của dashboard bằng cách thêm thuộc tính {.sidebar}. Nó có thể giữ văn bản (có thể xem từ bất kỳ trang nào) hoặc nếu bạn đã tích hợp tính năng tương tác shiny, nó có thể hữu ích để giữ các điều khiển nhập của người dùng như thanh trượt hoặc menu thả xuống.\n\n\n\n\n\n\n\n\n\nĐây là những gì script tạo ra:\n\n\n\n\n\n\n\n\n\n\n\nHướng\nĐặt thông số orientation: yaml để cho biết cách hiểu các đầu mục cấp hai R Markdown (##) của bạn - dưới dạng orientation: columns hoặc orientation: rows.\nĐầu mục cấp hai (##) sẽ được hiểu là các cột hoặc hàng mới dựa trên cài đặt orientation này.\nNếu bạn đặt orientation: columns, đầu mục cấp hai sẽ tạo cột mới trong dashboard. Dashboard bên dưới có một trang, chứa hai cột, với tổng số ba bảng. Bạn có thể điều chỉnh độ rộng tương đối của các cột với {data-width=} như hình dưới đây.\n\n\n\n\n\n\n\n\n\nĐây là những gì script tạo ra:\n\n\n\n\n\n\n\n\n\nNếu bạn đặt orientation: rows, đầu mục cấp hai sẽ tạo hàng mới thay vì cột. Dưới đây là script tương tự như trên, nhưng orientation: rows để các đầu mục cấp hai tạo ra hàng thay vì cột. Bạn có thể điều chỉnh chiều cao tương đối của các hàng với {data-height=} như hình dưới đây.\n\n\n\n\n\n\n\n\n\nĐây là những gì script tạo ra:\n\n\n\n\n\n\n\n\n\nNếu dashboard của bạn có nhiều trang, bạn có thể chỉ định hướng cho từng trang cụ thể bằng cách thêm thuộc tính {data-orientation=} vào tiêu đề của mỗi trang (chỉ định rows hoặc columns mà không có dấu ngoặc kép).\n\n\nTabs\nBạn có thể chia nội dung thành các tab bằng thuộc tính {.tabset}, như trong các đầu ra HTML R Markdown khác.\nChỉ cần thêm thuộc tính này sau đầu mục mong muốn. Các đầu mục con dưới đầu mục đó sẽ được hiển thị dưới dạng tab. Ví dụ: trong script ví dụ bên dưới, cột 2 bên phải (##) được sửa đổi để đường cong dịch bệnh và ngăn bảng (###) được hiển thị trong các tab.\nBạn có thể làm tương tự với các hàng nếu hướng của bạn là các hàng.\n\n\n\n\n\n\n\n\n\nĐây là những gì script tạo ra:",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Dashboards với R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.vn.html#thêm-nội-dung",
    "href": "new_pages/flexdashboard.vn.html#thêm-nội-dung",
    "title": "42  Dashboards với R Markdown",
    "section": "42.6 Thêm nội dung",
    "text": "42.6 Thêm nội dung\nHãy bắt đầu xây dựng một dashboard. Dashboard đơn giản của chúng tôi sẽ có 1 trang, 2 cột và 4 ô điều khiển. Chúng tôi sẽ xây dựng từng ô điều khiển một để minh họa.\nBạn có thể dễ dàng bao gồm các đầu ra R tiêu chuẩn như văn bản, ggplots và bảng (xem chương Trình bày bảng). Đơn giản chỉ cần code chúng trong một đoạn code R như bạn làm đối với bất kỳ script R Markdown nào khác.\nLưu ý: bạn có thể tải xuống script Rmd hoàn chỉnh và đầu ra dashboard HTML - xem chương Tải sách và dữ liệu.\n\nChữ\nBạn có thể nhập văn bản Markdown và bao gồm code nội dòng như đối với bất kỳ đầu ra R Markdown nào khác. Xem chương Báo cáo với R Markdown để biết chi tiết.\nTrong dashboard này, chúng tôi bao gồm một ô điều khiển văn bản tóm tắt bao gồm văn bản động cho thấy ngày nhập viện mới nhất và số trường hợp được báo cáo trong các ổ dịch.\n\n\nBảng\nBạn có thể bao gồm các đoạn code R in kết quả đầu ra chẳng hạn như bảng. Nhưng kết quả đầu ra sẽ trông đẹp nhất và đáp ứng với kích thước cửa sổ nếu bạn sử dụng hàm kable() từ knitr để hiển thị các bảng của mình. Các hàm flextable có thể tạo ra các bảng được rút ngắn/cắt bỏ.\nVí dụ: bên dưới chúng tôi cung cấp linelist() thông qua lệnh count() để tạo ra một bảng tóm tắt các trường hợp theo bệnh viện. Cuối cùng, bảng này được chuyển đến knitr::kable() và kết quả có một thanh cuộn ở bên phải. Bạn có thể đọc thêm về cách tùy chỉnh bảng của mình với kable() và kableExtra tại đây.\n\n\n\n\n\n\n\n\n\nĐây là những gì script tạo ra:\n\n\n\n\n\n\n\n\n\nNếu bạn muốn hiển thị một bảng động cho phép người dùng lọc, sắp xếp và/hoặc nhấp qua “các trang” của dataframe, hãy sử dụng package DT và đó là hàm datatable(), như trong code bên dưới.\nTrong code ví dụ dưới đây, dataframe linelist được in. Bạn có thể đặt rownames = FALSE để tiết kiệm không gian theo chiều ngang và filter = \"top\" để có bộ lọc ở đầu mỗi cột. Danh sách các thông số kỹ thuật khác có thể được cung cấp cho options =. Dưới đây, chúng tôi đặt pageLength = để 5 hàng xuất hiện và scrollX = để người dùng có thể sử dụng thanh cuộn ở dưới cùng để cuộn theo chiều ngang. Đối số class = 'white-space: nowrap' đảm bảo rằng mỗi hàng chỉ là một dòng (không phải nhiều dòng). Bạn có thể đọc về các đối số và giá trị có thể có khác tại đây hoặc bằng cách nhập ?datatable\n\nDT::datatable(linelist, \n              rownames = FALSE, \n              options = list(pageLength = 5, scrollX = TRUE), \n              class = 'white-space: nowrap' )\n\n\n\nĐồ thị\nBạn có thể in các đồ thị vào cửa sổ dashboard như bạn làm trong script R. Trong ví dụ của chúng tôi, chúng tôi sử dụng package incidence2 để tạo một “epicurve” theo nhóm tuổi bằng hai lệnh đơn giản (xem trang Đường cong dịch bệnh). Tuy nhiên, bạn có thể sử dụng ggplot() và in một đồ thị theo cách tương tự.\n\n\n\n\n\n\n\n\n\nĐây là những gì script tạo ra:\n\n\n\n\n\n\n\n\n\n\n\nĐồ thị tương tác\nBạn cũng có thể chuyển một ggplot tiêu chuẩn hoặc đối tượng đồ thị khác vào ggplotly() từ package plotly (xem chương Đồ thị tương tác). Điều này sẽ làm cho đồ thị của bạn có tính tương tác, cho phép người đọc “phóng to” và hiển thị khi di chuột qua giá trị của mọi điểm dữ liệu (trong trường hợp này là số trường hợp mỗi tuần và nhóm tuổi trong đường cong).\n\nage_outbreak &lt;- incidence(linelist, date_onset, \"week\", groups = age_cat)\nplot(age_outbreak, fill = age_cat, col_pal = muted, title = \"\") %&gt;% \n  plotly::ggplotly()\n\nĐây là những gì hiển thị trong dashboard (gif). Chức năng tương tác này sẽ vẫn hoạt động ngay cả khi bạn gửi email dashboard dưới dạng tệp tĩnh (không trực tuyến trên máy chủ).\n\n\n\n\n\n\n\n\n\n\n\nTiện ích HTML\nTiện ích HTML cho R là một loại package R đặc biệt giúp tăng tính tương tác bằng cách sử dụng các thư viện JavaScript. Bạn có thể nhúng chúng vào đầu ra R Markdown (chẳng hạn như flexdashboard) và trong dashboard Shiny.\nMột số ví dụ phổ biến về các tiện ích này bao gồm:\n\nPlotly (được sử dụng trong chương sổ tay này và trong chương Đồ thị tương tác)\nvisNetwork (được sử dụng trong chương Chuỗi lây nhiễm của sổ tay này)\nLeaflet (được sử dụng trong chương GIS cơ bản của sổ tay này)\ndygraph (hữu ích để hiển thị dữ liệu chuỗi thời gian một cách tương tác)\nDT (datatable()) (được sử dụng để hiển thị các bảng động với bộ lọc, sắp xếp, v.v.)\n\nDưới đây, chúng tôi biểu diễn thêm một chuỗi lây nhiễm dịch sử dụng visNetwork vào dashboard. Script chỉ hiển thị code mới được thêm vào phần “Cột 2” của script R Markdown. Bạn có thể tìm thấy code trong chương Chuỗi lây nhiễm của sổ tay này.\n\n\n\n\n\n\n\n\n\nĐây là những gì script tạo ra:",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Dashboards với R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.vn.html#tổ-chức-code",
    "href": "new_pages/flexdashboard.vn.html#tổ-chức-code",
    "title": "42  Dashboards với R Markdown",
    "section": "42.7 Tổ chức Code",
    "text": "42.7 Tổ chức Code\nBạn có thể chọn có tất cả code trong script R Markdown flexdashboard. Ngoài ra, để có một script dashboard rõ ràng và ngắn gọn hơn, bạn có thể chọn gọi code/biểu đồ được lưu trữ hoặc tạo trong các scripts R bên ngoài. Điều này được mô tả chi tiết hơn trong chương Báo cáo với R Markdown.",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Dashboards với R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.vn.html#shiny",
    "href": "new_pages/flexdashboard.vn.html#shiny",
    "title": "42  Dashboards với R Markdown",
    "section": "42.8 Shiny",
    "text": "42.8 Shiny\nViệc tích hợp package R shiny có thể giúp dashboards của bạn phản ứng mạnh hơn với thông tin nhập của người dùng. Ví dụ: bạn có thể yêu cầu người dùng chọn một khu vực pháp lý hoặc một phạm vi ngày và để các bảng phản ứng với lựa chọn của họ (ví dụ: lọc dữ liệu được hiển thị). Để nhúng phản ứng shiny vào flexdashboard, bạn chỉ cần thực hiện một số thay đổi đối với R Markdown script flexdashboard của mình.\nBạn có thể sử dụng shiny để tạo ứng dụng/dashboards mà không cần đến flexdashboard (bảng điều khiển linh hoạt). Chương Dashboards với Shiny trong sổ tay cung cấp thông tin tổng quan về cách tiếp cận này, bao gồm phần bổ sung về cú pháp shiny, cấu trúc tệp ứng dụng và các tùy chọn chia sẻ/xuất bản (bao gồm cả tùy chọn máy chủ miễn phí). Cú pháp và các mẹo chung này cũng chuyển sang ngữ cảnh flexdashboard.\nTuy nhiên, nhúng shiny vào flexdashboard là một thay đổi cơ bản đối với flexdashboard của bạn. Nó sẽ không còn tạo ra một đầu ra HTML mà bạn có thể gửi qua email và bất kỳ ai cũng có thể mở và xem. Thay vào đó, nó sẽ là một “ứng dụng”. Nút “Knit” ở đầu script sẽ được thay thế bằng biểu tượng “Run document”, biểu tượng này sẽ mở ra một phiên bản của dashboard tương tác cục bộ trên máy tính của bạn.\nChia sẻ dashboard của bạn bây giờ sẽ yêu cầu bạn:\n\nGửi script Rmd cho người xem, họ mở nó trên máy tính của họ và chạy ứng dụng, hoặc\n\nỨng dụng/dashboard được lưu trữ trên máy chủ mà người xem có thể truy cập\n\nDo đó, có những lợi ích khi tích hợp shiny, nhưng cũng có những rắc rối. Nếu ưu tiên chia sẻ dễ dàng qua email và bạn không cần các khả năng phản ứng shiny, hãy xem xét khả năng tương tác giảm do ggplotly() cung cấp như đã trình bày ở trên.\nDưới đây, chúng tôi đưa ra một ví dụ rất đơn giản bằng cách sử dụng cùng một “outbreak_dashboard.Rmd” như trên. Tài liệu mở rộng về tích hợp Shiny vào flexdashboard có sẵn trực tuyến here.\n\nCài đặt\nKích hoạt shiny trong flexdashboard bằng cách thêm thông số YAML `runtime: shiny ở cùng mức thụt lề như output:, như bên dưới:\n---\ntitle: \"Outbreak dashboard (Shiny demo)\"\noutput: \n  flexdashboard::flex_dashboard:\n    orientation: columns\n    vertical_layout: fill\nruntime: shiny\n---\nNó cũng thuận tiện để kích hoạt một “thanh bên” để giữ các công cụ shiny đầu vào sẽ thu thập thông tin từ người dùng. Như đã giải thích ở trên, hãy tạo một cột và chỉ ra tùy chọn {.sidebar} để tạo một thanh bên ở phía bên trái. Bạn có thể thêm các đoạn văn bản và R chứa các lệnh shiny input trong cột này.\nNếu ứng dụng/dashboard của bạn được lưu trữ trên một máy chủ và có thể có nhiều người dùng đồng thời, hãy đặt tên cho đoạn code R đầu tiên là global. Bao gồm các lệnh để nhập/tải dữ liệu của bạn trong đoạn này. Đoạn code có tên đặc biệt này được xử lý theo cách khác và dữ liệu được nhập trong nó chỉ được nhập một lần (không liên tục) và có sẵn cho tất cả người dùng. Điều này cải thiện tốc độ khởi động của ứng dụng.\n\n\nVí dụ đã làm việc\nỞ đây chúng tôi điều chỉnh script flexdashboard “outbreak_dashboard.Rmd” để bao gồm shiny. Chúng tôi sẽ thêm khả năng để người dùng chọn bệnh viện từ menu thả xuống và để đường cong dịch bệnh chỉ phản ánh các trường hợp từ bệnh viện đó, với tiêu đề đồ thị động. Chúng tôi làm như sau:\n\nThêm runtime: shiny vào YAML\n\nĐặt lại tên cho đoạn code thiết lập là global\n\nTạo một thanh bên chứa:\n\nCode để tạo vectơ tên bệnh viện duy nhất\n\nLệnh selectInput() (menu thả xuống shiny) với sự lựa chọn tên bệnh viện. Lựa chọn được lưu dưới dạng hospital_choice, có thể được tham chiếu trong mã sau này dưới dạng input$hospital_choice\n\n\nCode đường cong dịch bệnh (cột 2) được đặt trong renderPlot({ }), gồm:\n\nBộ lọc trên tập dữ liệu giới hạn cột hospital thành giá trị hiện tại của input$hospital_choice\n\nTiêu đề đồ thị động kết hợp input$hospital_choice\n\n\nLưu ý rằng bất kỳ code nào tham chiếu đến giá trị input$ phải nằm trong một hàm render({}) (là hàm phản ứng).\nĐây là phần trên cùng của script, bao gồm YAML, global chunk và sidebar:\n\n\n\n\n\n\n\n\n\nĐây là Cột 2, với đồ thi epicurve phản ứng:\n\n\n\n\n\n\n\n\n\nVà đây là dashboard:\n\n\n\n\n\n\n\n\n\n\n\nCác ví dụ khác\nĐể đọc một ví dụ liên quan đến sức khỏe về Shiny-flexdashboard bằng cách sử dụng tính năng tương tác shiny và tiện ích vẽ bản đồ leaflet, hãy xem chương này của sách trực tuyến Geospatial Health Data: Modeling and Visualization with R-INLA and Shiny.",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Dashboards với R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.vn.html#chia-sẻ",
    "href": "new_pages/flexdashboard.vn.html#chia-sẻ",
    "title": "42  Dashboards với R Markdown",
    "section": "42.9 Chia sẻ",
    "text": "42.9 Chia sẻ\nDashboards không chứa các phần tử Shiny sẽ xuất ra tệp HTML (.html), tệp này có thể được gửi qua email (nếu kích thước cho phép). Điều này rất hữu ích, vì bạn có thể gửi báo cáo “dashboard” và không phải thiết lập máy chủ để lưu trữ báo cáo đó dưới dạng trang web.\nNếu bạn đã nhúng shiny, bạn sẽ không thể gửi đầu ra qua email, nhưng bạn có thể gửi chính script cho người dùng R hoặc lưu trữ dashboard trên một máy chủ như đã giải thích ở trên.",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Dashboards với R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.vn.html#tài-nguyên-học-liệu",
    "href": "new_pages/flexdashboard.vn.html#tài-nguyên-học-liệu",
    "title": "42  Dashboards với R Markdown",
    "section": "42.10 Tài nguyên học liệu",
    "text": "42.10 Tài nguyên học liệu\nBạn có thể tìm thấy các hướng dẫn đầy đủ cho chương này bên dưới. Nếu bạn xem lại chúng, rất có thể trong vòng một giờ, bạn có thể có dashboard của riêng mình.\nhttps://bookdown.org/yihui/rmarkdown/dashboards.html\nhttps://rmarkdown.rstudio.com/flexdashboard/\nhttps://rmarkdown.rstudio.com/flexdashboard/using.html\nhttps://rmarkdown.rstudio.com/flexdashboard/examples.html",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Dashboards với R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.vn.html",
    "href": "new_pages/shiny_basics.vn.html",
    "title": "43  Dashboards với Shiny",
    "section": "",
    "text": "43.1 Chuẩn bị",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Dashboards với Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.vn.html#chuẩn-bị",
    "href": "new_pages/shiny_basics.vn.html#chuẩn-bị",
    "title": "43  Dashboards với Shiny",
    "section": "",
    "text": "Gọi packages\nTrong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm p_load() từ package pacman, giúp cài đặt các package cần thiết và gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm library() của base R. Xem thêm chương R cơ bản để có thêm thông tin về các packages trong R.\nChúng ta bắt đầu bằng cách cài đặt package shiny:\n\npacman::p_load(\"shiny\")\n\n\n\nNhập dữ liệu\nNếu bạn muốn theo dõi chương này, hãy xem phần này trong chương Tải sách và dữ liệu. Có các liên kết để tải xuống scripts R và các tệp dữ liệu tạo ra ứng dụng Shiny cuối cùng.\nNếu bạn cố gắng xây dựng lại app bằng các tệp này, hãy lưu ý về cấu trúc thư mục dự án R được tạo trong quá trình thực hiện (ví dụ: thư mục cho “data” và “funcs”).",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Dashboards với Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.vn.html#cấu-trúc-của-một-ứng-dụng-shiny",
    "href": "new_pages/shiny_basics.vn.html#cấu-trúc-của-một-ứng-dụng-shiny",
    "title": "43  Dashboards với Shiny",
    "section": "43.2 Cấu trúc của một ứng dụng shiny",
    "text": "43.2 Cấu trúc của một ứng dụng shiny\n\nCấu trúc tệp cơ bản\nĐể hiểu về shiny, trước tiên chúng ta cần hiểu cấu trúc tệp của một ứng dụng hoạt động như thế nào! Chúng ta nên tạo một thư mục hoàn toàn mới trước khi bắt đầu. Điều này thực sự có thể được thực hiện dễ dàng hơn bằng cách chọn New project trong Rstudio và chọn Shiny Web Application. Điều này sẽ giúp tạo ra cấu trúc cơ bản của một ứng dụng shiny cho bạn.\nKhi mở dự án này, bạn sẽ nhận thấy có một tệp .R có tên là app.R. Điều cần thiết là chúng ta có một trong hai cấu trúc tệp cơ bản:\n\nMột tệp có tên là app.R, hoặc\n\nHai tệp, một tệp có tên là ui.R và tệp còn lại là server.R\n\nTrong chương này, chúng tôi sẽ sử dụng cách tiếp cận đầu tiên là có một tệp có tên là app.R. Đây là một script ví dụ:\n\n# an example of app.R\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n\n    # Application title\n    titlePanel(\"My app\"),\n\n    # Sidebar with a slider input widget\n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(\"input_1\")\n        ),\n\n        # Show a plot \n        mainPanel(\n           plotOutput(\"my_plot\")\n        )\n    )\n)\n\n# Define server logic required to draw a histogram\nserver &lt;- function(input, output) {\n     \n     plot_1 &lt;- reactive({\n          plot_func(param = input_1)\n     })\n     \n    output$my_plot &lt;- renderPlot({\n       plot_1()\n    })\n}\n\n\n# Run the application \nshinyApp(ui = ui, server = server)\n\nNếu bạn mở tệp này, bạn sẽ nhận thấy rằng hai đối tượng được xác định - một đối tượng được gọi là ui và đối tượng khác được gọi là server. Các đối tượng này phải được xác định trong mọi ứng dụng shiny và là trung tâm cấu trúc của chính ứng dụng đó! Trên thực tế, sự khác biệt duy nhất giữa hai cấu trúc tệp được mô tả ở trên là trong cấu trúc 1, cả ui và server đều được xác định trong một tệp, trong khi ở cấu trúc 2, chúng được định nghĩa trong các tệp riêng biệt. Lưu ý: chúng ta cũng có thể (và nên có nếu chúng ta có một ứng dụng lớn hơn) có các tệp .R khác trong cấu trúc để chúng ta có thể nhúng source() vào ứng dụng của mình.\n\n\nMáy chủ và giao diện người dùng\nTiếp theo, chúng ta cần hiểu các đối tượng server và ui thực sự làm gì. Nói một cách đơn giản, đây là hai đối tượng tương tác với nhau bất cứ khi nào người dùng tương tác với ứng dụng shiny.\nPhần tử UI (giao diện người dùng) của một ứng dụng shiny, ở cấp độ cơ bản, là code R tạo ra giao diện HTML. Điều này có nghĩa là mọi thứ được hiển thị trong giao diện người dùng của một ứng dụng. Điều này thường bao gồm:\n\n“Widgets (thành phần điều khiển)” - menu thả xuống, hộp kiểm, thanh trượt, v.v. mà người dùng có thể tương tác\nĐồ thị, bảng, v.v. - kết quả đầu ra được tạo bằng code R\nCác khía cạnh điều hướng của một ứng dụng - tab, cửa sổ, v.v.\nVăn bản chung, đường liên kết, v.v.\nCác phần tử HTML và CSS\n\nĐiều quan trọng nhất cần hiểu về UI là nó nhận đầu vào từ người dùng và hiển thị đầu ra từ máy chủ. Không có code hoạt động chạy trong ui tại bất kỳ thời điểm nào - tất cả các thay đổi được nhìn thấy trong UI đều được chuyển qua máy chủ (nhiều hơn hoặc ít hơn). Vì vậy, chúng ta phải tạo các đồ thị, tải xuống, v.v. trong máy chủ\nMáy chủ của ứng dụng shiny là nơi tất cả code đang được chạy khi ứng dụng khởi động. Cách nó hoạt động hơi khó hiểu một chút. Chức năng máy chủ sẽ phản hồi một cách hiệu quả đối theo những gì người dùng giao tiếp với UI và chạy các đoạn code phản hồi tương ứng. Nếu mọi thứ thay đổi trong máy chủ, những thứ này sẽ được chuyển trở lại ui, nơi có thể nhìn thấy những thay đổi. Quan trọng là code trong máy chủ sẽ được thực thi không liên tiếp (hoặc tốt nhất là bạn nên nghĩ theo cách này). Về cơ bản, bất cứ khi nào đầu vào ui ảnh hưởng đến một đoạn code trong máy chủ, nó sẽ tự động chạy và đầu ra đó sẽ được tạo ra và hiển thị.\nTất cả điều này bây giờ có vẻ rất trừu tượng, vì vậy chúng ta sẽ phải đi sâu vào một số ví dụ để có một ý tưởng rõ ràng về cách nó thực sự hoạt động.\n\n\nTrước khi bạn bắt đầu tạo một ứng dụng\nTrước khi bạn bắt đầu xây dựng một ứng dụng, việc biết những gì bạn muốn tạo sẽ vô cùng hữu ích. Vì UI của bạn sẽ được viết bằng code, bạn không thể thực sự hình dung những gì bạn đang tạo trừ khi bạn đang nhắm đến một cái gì đó cụ thể. Vì lý do này, sẽ vô cùng hữu ích khi xem xét rất nhiều ví dụ về các ứng dụng shiny để biết được những gì bạn có thể tạo ra - thậm chí còn tốt hơn nếu bạn có thể xem code gốc đằng sau các ứng dụng này! Một số tài nguyên tuyệt vời cho việc này là:\n\nThư viện ứng dụng của Rstudio\n\nKhi bạn có ý tưởng về những gì có thể thực hiện, sẽ rất hữu ích nếu bạn phác thảo ra diện mạo sản phẩm - bạn có thể thực hiện việc này trên giấy hoặc trong bất kỳ phần mềm vẽ nào (PowerPoint, MS paint, v.v.). Sẽ hữu ích khi bắt đầu đơn giản cho ứng dụng đầu tiên của bạn! Cũng không có gì phải xấu hổ nếu bạn sử dụng code có sẵn trên mạng của một ứng dụng mẫu phục vụ cho công việc của bạn - việc này dễ dàng hơn nhiều so với việc xây dựng thứ gì đó từ đầu!",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Dashboards với Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.vn.html#tạo-một-ui",
    "href": "new_pages/shiny_basics.vn.html#tạo-một-ui",
    "title": "43  Dashboards với Shiny",
    "section": "43.3 Tạo một UI",
    "text": "43.3 Tạo một UI\nKhi xây dựng ứng dụng, trước tiên, bạn nên làm việc trên UI để chúng ta có thể thấy những gì đang làm và không có nguy cơ ứng dụng bị lỗi do bất kỳ lỗi máy chủ nào. Như đã đề cập trước đây, bạn nên sử dụng một mẫu có sẵn khi tạo UI. Bạn có thể tìm thấy một số bố cục tiêu chuẩn có sẵn trong package shiny, ngoài ra là ở các package mở rộng khác, chằng hạn như shinydashboard. Chúng tôi sẽ sử dụng một ví dụ từ package shiny cơ sở để bắt đầu.\nMột shiny UI thường được định nghĩa là một loạt các hàm lồng nhau, theo thứ tự sau\n\nMột hàm xác định bố cục chung (cơ bản nhất là fluidPage(), nhưng có nhiều hàm khác)\n\nCác ô điều khiển trong bố cục như:\n\nmột thanh bên (sidebarPanel())\nmột bảng điều khiển “chính” (mainPanel())\nmột tab (tabPanel())\nmột “cột” chung (column())\n\nCác widget và đầu ra - những thứ này có thể đưa đầu vào cho máy chủ (tiện ích) hoặc đưa ra từ máy chủ (đầu ra)\n\nCác widget thường được thiết kế kiểu như xxxInput(), ví dụ: selectInput()\n\nKết quả đầu ra thường được thiết kế kiểu như xxxOutput(), ví dụ: plotOutput()\n\n\nCần phải nói lại rằng những thứ này không thể được hình dung một cách dễ dàng theo cách trừu tượng, vì vậy tốt nhất hãy xem một ví dụ! Hãy xem xét tạo một ứng dụng cơ bản hiển thị dữ liệu số lượng cơ sở sốt rét theo quận. Dữ liệu này có rất nhiều tham số khác nhau, vì vậy sẽ thật tuyệt nếu cuối cùng người dùng có thể áp dụng một số bộ lọc để xem dữ liệu theo nhóm tuổi/quận khi họ thấy phù hợp! Chúng ta có thể sử dụng một bố cục shiny rất đơn giản để bắt đầu - bố cục thanh bên. Đây là một bố cục trong đó các widget được đặt trong một thanh bên ở bên trái và đồ thị được đặt ở bên phải.\nHãy lập kế hoạch cho ứng dụng của chúng ta - chúng ta có thể bắt đầu với một bộ chọn cho phép chúng ta chọn quận nơi chúng ta muốn trực quan hóa dữ liệu và một bộ chọn khác để biểu diễn nhóm tuổi quan tâm. Chúng ta sẽ sử dụng các bộ lọc này để hiển thị một đường cong dịch bệnh phản ánh các tham số này. Vì vậy, chúng ta cần:\n\nHai menu thả xuống cho phép chúng ta chọn quận chúng ta muốn và nhóm tuổi quan tâm.\n\nMột khu vực mà chúng ta có thể hiển thị đường cong dịch bệnh kết quả.\n\nCode minh họa có thể trông giống như sau:\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # selector for district\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = c(\n                   \"All\",\n                   \"Spring\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selected = \"All\",\n              multiple = TRUE\n         ),\n         # selector for age group\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         )\n\n    ),\n\n    mainPanel(\n      # epicurve goes here\n      plotOutput(\"malaria_epicurve\")\n    )\n    \n  )\n)\n\nKhi app.R được chạy với code UI ở trên (không có code đang hoạt động trong phần server của app.R), bố cục sẽ xuất hiện như thế này - lưu ý rằng sẽ không có đồ thị nếu không có máy chủ để hiển thị nó, nhưng đầu vào của chúng ta đang hoạt động!\n\n\n\n\n\n\n\n\n\nĐây là cơ hội tốt để thảo luận về cách mà các widget hoạt động - lưu ý rằng mỗi widget đang chấp nhận một inputId, một label và một loạt các tùy chọn khác dành riêng cho loại widget. InputId này cực kỳ quan trọng - đây là những ID được sử dụng để truyền thông tin từ UI đến máy chủ. Vì lý do này, chúng phải là duy nhất. Bạn nên cố gắng đặt cho chúng một cái tên gì đó hợp lý và cụ thể theo chức năng của chúng trong các trường hợp thiết kế một ứng dụng lớn.\nBạn nên đọc kỹ tài liệu để biết chi tiết đầy đủ về chức năng của mỗi widget này. Các widget sẽ chuyển các loại dữ liệu cụ thể đến máy chủ tùy thuộc vào loại widget và điều này cần được hiểu đầy đủ. Ví dụ: selectInput() sẽ chuyển dữ liệu dạng ký tự cho máy chủ:\n\nNếu chúng ta chọn Spring cho widget đầu tiên ở đây, nó sẽ chuyển đối tượng ký tự \"Spring\" đến máy chủ.\n\nNếu chúng ta chọn hai mục từ menu thả xuống, chúng sẽ đi qua dưới dạng vectơ ký tự (ví dụ: c(\"Spring\", \"Bolo\")).\n\nCác widget khác sẽ chuyển các loại đối tượng khác nhau đến máy chủ! Ví dụ:\n\nnumericInput() sẽ chuyển một đối tượng dạng số đến máy chủ\n\ncheckboxInput() sẽ chuyển một đối tượng kiểu logic đến máy chủ (TRUE hoặc FALSE)\n\nCũng cần lưu ý vectơ được đặt tên mà chúng ta đã sử dụng cho dữ liệu độ tuổi ở đây. Đối với nhiều widget, việc sử dụng vectơ được đặt tên làm các lựa chọn sẽ hiển thị tên của vectơ dưới dạng các lựa chọn hiển thị, nhưng chuyển giá trị thực của lựa chọn từ vectơ đến máy chủ. Ví dụng chúng ta chọn “15+” từ menu thả xuống và UI sẽ chuyển \"malaria_rdt_15\" đến máy chủ - đây chính là tên của cột mà chúng ta quan tâm!\nCó rất nhiều widget mà bạn có thể sử dụng để làm nhiều việc với ứng dụng của mình. Các widget cũng cho phép bạn tải tệp lên ứng dụng của mình và tải xuống kết quả đầu ra. Ngoài ra còn có một số gói shiny mở rộng tuyệt vời cho phép bạn truy cập vào nhiều widget hơn so với shiny cơ bản - package shinyWidgets là một ví dụ tuyệt vời về điều này. Để xem một số ví dụ, bạn có thể xem các liên kết sau:\n\nbase shiny widget gallery\nshinyWidgets gallery",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Dashboards với Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.vn.html#tải-dữ-liệu-vào-ứng-dụng",
    "href": "new_pages/shiny_basics.vn.html#tải-dữ-liệu-vào-ứng-dụng",
    "title": "43  Dashboards với Shiny",
    "section": "43.4 Tải dữ liệu vào ứng dụng",
    "text": "43.4 Tải dữ liệu vào ứng dụng\nBước tiếp theo trong quá trình phát triển ứng dụng là thiết lập và chạy máy chủ. Tuy nhiên, để làm điều này, chúng ta cần đưa một số dữ liệu vào ứng dụng của mình và tìm ra tất cả các phép tính mà chúng ta sẽ thực hiện. Một ứng dụng shiny không dễ để gỡ lỗi, vì thường không rõ lỗi đến từ đâu, do đó, lý tưởng nhất là hãy chắc chắn tất cả code dùng để trực quan và xử lý dữ liệu của chúng ta hoạt động tốt trước khi chúng ta bắt đầu tự tạo máy chủ.\nBây giờ chúng ta muốn tạo một ứng dụng hiển thị các đường cong dịch bệnh thay đổi dựa trên đầu vào của người dùng, chúng ta nên nghĩ về code chúng ta sẽ cần để chạy chúng trong một R script bình thường. Chúng ta sẽ cần:\n\nGọi các packages\nTải dữ liệu\nChuyển đổi dữ liệu\nPhát triển một hàm để trực quan hóa dữ liệu của chúng ta dựa trên đầu vào của người dùng\n\nDanh sách này khá đơn giản và không quá khó để thực hiện. Bây giờ, điều quan trọng là phải nghĩ về những phần nào của quy trình này chỉ được thực hiện một lần và những phần nào cần chạy dựa theo các đầu vào của người dùng. Điều này là do các ứng dụng shiny thường chạy một số code trước khi chạy, code này chỉ được thực hiện một lần. Nó sẽ giúp cải thiện hiệu suất ứng dụng của chúng ta nếu có thể chuyển nhiều code đến phần này. Đối với ví dụ này, chúng ta chỉ cần tải dữ liệu/packages của mình và thực hiện các phép biến đổi cơ bản một lần, vì vậy chúng ta có thể đặt code đó bên ngoài máy chủ. Điều này có nghĩa là thứ duy nhất chúng ta cần trong máy chủ là code để trực quan hóa dữ liệu của chúng ta. Trước tiên, hãy phát triển tất cả các thành phần này trong một script. Tuy nhiên, vì chúng ta đang trực quan hóa dữ liệu của mình bằng một hàm, chúng ta cũng có thể đặt code cho hàm bên ngoài máy chủ để hàm của chúng ta ở trong môi trường khi ứng dụng chạy!\nĐầu tiên, hãy tải dữ liệu của chúng ta. Vì chúng ta đang làm việc với một dự án mới và chúng ta cần làm sạch số liệu, chúng ta có thể tạo một thư mục mới có tên là data và thêm bộ dữ liệu sốt rét vào đó. Chúng ta có thể chạy code bên dưới trong một script thử nghiệm mà cuối cùng chúng ta sẽ xóa khi chúng ta dọn cấu trúc ứng dụng của mình.\n\npacman::p_load(\"tidyverse\", \"lubridate\")\n\n# read data\nmalaria_data &lt;- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\")) %&gt;% \n  as_tibble()\n\nprint(malaria_data)\n\n# A tibble: 3,038 × 10\n   location_name data_date  submitted_date Province District `malaria_rdt_0-4`\n   &lt;chr&gt;         &lt;date&gt;     &lt;date&gt;         &lt;chr&gt;    &lt;chr&gt;                &lt;int&gt;\n 1 Facility 1    2020-08-11 2020-08-12     North    Spring                  11\n 2 Facility 2    2020-08-11 2020-08-12     North    Bolo                    11\n 3 Facility 3    2020-08-11 2020-08-12     North    Dingo                    8\n 4 Facility 4    2020-08-11 2020-08-12     North    Bolo                    16\n 5 Facility 5    2020-08-11 2020-08-12     North    Bolo                     9\n 6 Facility 6    2020-08-11 2020-08-12     North    Dingo                    3\n 7 Facility 6    2020-08-10 2020-08-12     North    Dingo                    4\n 8 Facility 5    2020-08-10 2020-08-12     North    Bolo                    15\n 9 Facility 5    2020-08-09 2020-08-12     North    Bolo                    11\n10 Facility 5    2020-08-08 2020-08-12     North    Bolo                    19\n# ℹ 3,028 more rows\n# ℹ 4 more variables: `malaria_rdt_5-14` &lt;int&gt;, malaria_rdt_15 &lt;int&gt;,\n#   malaria_tot &lt;int&gt;, newid &lt;int&gt;\n\n\nSẽ dễ dàng hơn để làm việc với dữ liệu này nếu chúng ta sử dụng các tiêu chuẩn dữ liệu tidy, vì vậy chúng ta cũng nên chuyển đổi dữ liệu sang định dạng dài hơn, trong đó nhóm tuổi là một cột và các trường hợp là một cột khác. Chúng ta có thể thực hiện việc này một cách dễ dàng bằng cách sử dụng những gì chúng ta đã học được trong chương Xoay trục dữ liệu.\n\nmalaria_data &lt;- malaria_data %&gt;%\n  select(-newid) %&gt;%\n  pivot_longer(cols = starts_with(\"malaria_\"), names_to = \"age_group\", values_to = \"cases_reported\")\n\nprint(malaria_data)\n\n# A tibble: 12,152 × 7\n   location_name data_date  submitted_date Province District age_group       \n   &lt;chr&gt;         &lt;date&gt;     &lt;date&gt;         &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;           \n 1 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_rdt_0-4 \n 2 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_rdt_5-14\n 3 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_rdt_15  \n 4 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_tot     \n 5 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_rdt_0-4 \n 6 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_rdt_5-14\n 7 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_rdt_15  \n 8 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_tot     \n 9 Facility 3    2020-08-11 2020-08-12     North    Dingo    malaria_rdt_0-4 \n10 Facility 3    2020-08-11 2020-08-12     North    Dingo    malaria_rdt_5-14\n# ℹ 12,142 more rows\n# ℹ 1 more variable: cases_reported &lt;int&gt;\n\n\nVà cùng với đó, chúng ta đã chuẩn bị xong dữ liệu của mình! Chúng ta đã hoàn thành các mục 1, 2 và 3 trong danh sách những thứ cần phát triển cho một “script R thử nghiệm”. Nhiệm vụ cuối cùng và khó khăn nhất sẽ là xây dựng một hàm để tạo ra một đường cong dịch bệnh dựa trên các thông số do người dùng xác định. Như đã đề cập trước đây, chúng tôi rất khuyến khích bất kỳ ai học shiny trước tiên hãy xem phần về lập trình hướng chức năng (Viết hàm) để hiểu cách thức hoạt động của nó!\nKhi định nghĩa một hàm, có thể khó khăn khi nghĩ về những tham số chúng ta muốn đưa vào. Đối với lập trình hướng chức năng với shiny, mọi tham số liên quan thường sẽ có một widget liên kết với nó, vì vậy việc suy nghĩ về điều này thường khá dễ dàng! Ví dụ: trong ứng dụng hiện tại, chúng ta muốn có thể lọc theo quận và có một widget cho việc này, vì vậy chúng ta có thể thêm thông số quận để phản ánh điều này. Chúng ta (hiện tại) không có bất kỳ chức năng ứng dụng nào để lọc theo cơ sở, vì vậy chúng ta không cần thêm thông số này làm tham số. Hãy bắt đầu bằng cách tạo một hàm với ba tham số:\n\nBộ dữ liệu cốt lõi\n\nQuận được lựa chọn\n\nNhóm tuổi được lựa chọn\n\n\nplot_epicurve &lt;- function(data, district = \"All\", agegroup = \"malaria_tot\") {\n  \n  if (!(\"All\" %in% district)) {\n    data &lt;- data %&gt;%\n      filter(District %in% district)\n    \n    plot_title_district &lt;- stringr::str_glue(\"{paste0(district, collapse = ', ')} districts\")\n    \n  } else {\n    \n    plot_title_district &lt;- \"all districts\"\n    \n  }\n  \n  # if no remaining data, return NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  data &lt;- data %&gt;%\n    filter(age_group == agegroup)\n  \n  \n  # if no remaining data, return NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  if (agegroup == \"malaria_tot\") {\n      agegroup_title &lt;- \"All ages\"\n  } else {\n    agegroup_title &lt;- stringr::str_glue(\"{str_remove(agegroup, 'malaria_rdt')} years\")\n  }\n  \n  \n  ggplot(data, aes(x = data_date, y = cases_reported)) +\n    geom_col(width = 1, fill = \"darkred\") +\n    theme_minimal() +\n    labs(\n      x = \"date\",\n      y = \"number of cases\",\n      title = stringr::str_glue(\"Malaria cases - {plot_title_district}\"),\n      subtitle = agegroup_title\n    )\n  \n  \n  \n}\n\nChúng ta sẽ không đi sâu vào chi tiết về hàm này, vì nó tương đối đơn giản về cách hoạt động. Tuy nhiên, một điều cần lưu ý là chúng ta xử lý lỗi bằng cách trả về NULL khi nó sẽ xuất hiện lỗi. Lý do là khi một máy chủ shiny tạo ra một đối tượng NULL thay vì một đối tượng đồ thị, sẽ không có gì được hiển thị trong ui! Điều này rất quan trọng, vì nếu không, các lỗi thường sẽ khiến ứng dụng của bạn ngừng hoạt động.\nMột điều khác cần lưu ý là việc sử dụng toán tử %in% khi đánh giá đầu vào district. Như đã đề cập ở trên, toán tử này có thể đến dưới dạng một vectơ ký tự có nhiều giá trị, vì vậy việc sử dụng %in% sẽ linh hoạt hơn so với nói,==.\nHãy kiểm tra hàm này!\n\nplot_epicurve(malaria_data, district = \"Bolo\", agegroup = \"malaria_rdt_0-4\")\n\n\n\n\n\n\n\n\nVới một hàm hoạt động được, bây giờ chúng ta phải hiểu cách mà tất cả những thứ này sẽ được fit vào một ứng dụng shiny như thế nào. Chúng ta đã đề cập đến khái niệm code khởi động (startup code) trước đây, nhưng hãy xem cách chúng ta thực sự có thể kết hợp nó vào cấu trúc ứng dụng của chúng ta. Có hai cách chúng ta có thể làm điều này!\n\nĐặt code này vào tệp app.R của bạn ở phần đầu script (phía trên UI) hoặc\nTạo một tệp mới trong thư mục của ứng dụng có tên global.R và đặt code khởi động vào tệp này.\n\nCó một lưu ý ở điểm này đó là nó sẽ thường dễ dàng hơn, đặc biệt là với các ứng dụng lớn, khi bạn sử dụng cấu trúc tệp thứ hai, vì nó cho phép bạn tách cấu trúc tệp của mình theo cách đơn giản. Hãy phát triển đầy đủ script global.R này ngay bây giờ. Đây là những gì nó có thể hiển thị:\n\n# global.R script\n\npacman::p_load(\"tidyverse\", \"lubridate\", \"shiny\")\n\n# read data\nmalaria_data &lt;- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\")) %&gt;% \n  as_tibble()\n\n# clean data and pivot longer\nmalaria_data &lt;- malaria_data %&gt;%\n  select(-newid) %&gt;%\n  pivot_longer(cols = starts_with(\"malaria_\"), names_to = \"age_group\", values_to = \"cases_reported\")\n\n\n# define plotting function\nplot_epicurve &lt;- function(data, district = \"All\", agegroup = \"malaria_tot\") {\n  \n  # create plot title\n  if (!(\"All\" %in% district)) {            \n    data &lt;- data %&gt;%\n      filter(District %in% district)\n    \n    plot_title_district &lt;- stringr::str_glue(\"{paste0(district, collapse = ', ')} districts\")\n    \n  } else {\n    \n    plot_title_district &lt;- \"all districts\"\n    \n  }\n  \n  # if no remaining data, return NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  # filter to age group\n  data &lt;- data %&gt;%\n    filter(age_group == agegroup)\n  \n  \n  # if no remaining data, return NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  if (agegroup == \"malaria_tot\") {\n      agegroup_title &lt;- \"All ages\"\n  } else {\n    agegroup_title &lt;- stringr::str_glue(\"{str_remove(agegroup, 'malaria_rdt')} years\")\n  }\n  \n  \n  ggplot(data, aes(x = data_date, y = cases_reported)) +\n    geom_col(width = 1, fill = \"darkred\") +\n    theme_minimal() +\n    labs(\n      x = \"date\",\n      y = \"number of cases\",\n      title = stringr::str_glue(\"Malaria cases - {plot_title_district}\"),\n      subtitle = agegroup_title\n    )\n  \n  \n  \n}\n\nThật đơn giản! Một tính năng tuyệt vời của shiny là nó sẽ hiểu các tệp có tên app.R, server.R, ui.R và global.R dùng để làm gì, vì vậy không cần phải kết nối chúng với nhau thông qua bất kỳ code nào. Vì vậy, chỉ cần có code này trong global.R trong thư mục, nó sẽ chạy trước khi chúng ta khởi động ứng dụng của mình!\nChúng ta cũng nên lưu ý rằng có thể cải thiện tổ chức ứng dụng nếu chúng ta chuyển hàm vẽ biểu đồ sang tệp riêng của nó - điều này sẽ đặc biệt hữu ích khi các ứng dụng trở nên lớn hơn. Để làm điều này, chúng ta có thể tạo một thư mục khác có tên funcs và đặt hàm này dưới một tệp có tên plot_epicurve.R. Sau đó, chúng ta có thể đọc hàm này thông qua lệnh sau trong global.R\n\nsource(here(\"funcs\", \"plot_epicurve.R\"), local = TRUE)\n\nLưu ý rằng bạn nên luôn chỉ định local = TRUE trong các ứng dụng shiny, vì nó sẽ ảnh hưởng đến việc tìm nguồn khi/nếu ứng dụng được xuất bản trên máy chủ.",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Dashboards với Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.vn.html#phát-triển-một-máy-chủ-ứng-dụng",
    "href": "new_pages/shiny_basics.vn.html#phát-triển-một-máy-chủ-ứng-dụng",
    "title": "43  Dashboards với Shiny",
    "section": "43.5 Phát triển một máy chủ ứng dụng",
    "text": "43.5 Phát triển một máy chủ ứng dụng\nBây giờ chúng ta đã có hầu hết code cần thiết, chúng ta chỉ cần phát triển thêm máy chủ. Đây là phần cuối cùng của ứng dụng và có lẽ là phần khó hiểu nhất. Máy chủ là một hàm R lớn, nhưng sẽ hữu ích nếu coi nó như một chuỗi các hàm hoặc nhiệm vụ nhỏ hơn mà ứng dụng có thể thực hiện. Điều quan trọng là phải hiểu rằng các hàm này không được thực thi theo thứ tự tuyến tính. Nghĩa là có một thứ tự cho chúng, nhưng không cần phải hiểu đầy đủ khi bắt đầu với shiny. Ở cấp độ rất cơ bản, các tác vụ hoặc chức năng này sẽ kích hoạt khi có thay đổi về đầu vào của người dùng ảnh hưởng đến chúng, trừ khi nhà phát triển đã thiết lập chúng để chúng hoạt động khác biệt. Một lần nữa, nó khá trừu tượng, nhưng trước tiên hãy xem qua ba loại cơ bản của đối tượng shiny\n\nNguồn phản hồi (Reactive sources) - đây là một thuật ngữ khác của đầu vào người dùng. Máy chủ shiny có quyền truy cập vào các đầu ra từ UI thông qua các widget mà chúng ta đã lập trình. Mỗi khi các giá trị được thay đổi, chúng được chuyển đến máy chủ.\nVật dẫn phản hồi (Reactive conductors) - đây là những đối tượng tồn tại chỉ bên trong máy chủ shiny. Chúng ta không thực sự cần những thứ này cho các ứng dụng đơn giản, nhưng chúng tạo ra các đối tượng chỉ có thể được nhìn thấy bên trong máy chủ và được sử dụng trong các hoạt động khác. Chúng thường phụ thuộc vào các nguồn phản ứng.\nĐiểm cuối (Endpoints) - đây là các đầu ra được chuyển từ máy chủ đến UI. Trong ví dụ của chúng ta, đây sẽ là đường cong dịch bệnh mà chúng ta đang tạo.\n\nVới các khái niệm này, chúng ta hãy xây dựng máy chủ theo từng bước. Chúng tôi hiển thị lại code UI một lần nữa ở đây để bạn tham khảo:\n\nui &lt;- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # selector for district\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = c(\n                   \"All\",\n                   \"Spring\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selected = \"All\",\n              multiple = TRUE\n         ),\n         # selector for age group\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         )\n\n    ),\n\n    mainPanel(\n      # epicurve goes here\n      plotOutput(\"malaria_epicurve\")\n    )\n    \n  )\n)\n\nTừ UI code này, chúng ta có:\n\nHai đầu vào:\n\nBộ chọn quận (với inputId là select_district)\n\nBộ chọn nhóm tuổi (với inputId là select_agegroup)\n\n\nMột đầu ra:\n\nĐường cong dịch bệnh (với outputId là malaria_epicurve)\n\n\nNhư đã nói ở trên, những tên riêng mà chúng ta đã gán cho các đầu vào và đầu ra là rất quan trọng. Chúng phải là duy nhất và được sử dụng để chuyển thông tin giữa ui và máy chủ. Trong máy chủ, chúng ta truy cập tới các đầu vào thông qua cú pháp input$inputID và các đầu ra, và chuyển đến ui thông qua cú pháp output$output_name Hãy cùng xem xét một ví dụ, bởi vì điều này rất khó hiểu!\n\nserver &lt;- function(input, output, session) {\n  \n  output$malaria_epicurve &lt;- renderPlot(\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  )\n  \n}\n\nMáy chủ cho một ứng dụng đơn giản như thế này thực sự khá dễ dàng! Bạn sẽ nhận thấy rằng máy chủ là một hàm có ba tham số - input, output và session - điều này không quan trọng để hiểu ngay bây giờ, nhưng điều quan trọng là phải tuân theo thiết lập này! Trong máy chủ bên trên, chúng ta chỉ có một nhiệm vụ - đó là kết xuất một biểu đồ dựa trên hàm mà chúng ta đã thực hiện trước đó và các đầu vào từ máy chủ. Lưu ý cách tên của các đối tượng đầu vào và đầu ra tương ứng chính xác với các đối tượng trong ui.\nĐể hiểu những điều cơ bản về cách máy chủ phản hồi với thông tin đầu vào của người dùng, bạn cần lưu ý rằng đầu ra sẽ biết (thông qua package nhầm) khi đầu vào thay đổi và chạy lại hàm này để tạo biểu đồ mỗi khi chúng thay đổi. Lưu ý rằng chúng tôi cũng sử dụng hàm renderPlot() ở đây - đây là một trong số họ các hàm dành riêng cho lớp truyền các đối tượng đó đến đầu ra ui. Có một số hàm hoạt động tương tự, nhưng bạn cần đảm bảo hàm được sử dụng khớp với lớp đối tượng mà bạn đang chuyển tới ui! Ví dụ:\n\nrenderText() - gửi văn bản tới ui\n\nrenderDataTable - gửi bảng tương tác tới ui.\n\nHãy nhớ rằng chúng cũng cần phải khớp với hàm đầu ra được sử dụng trong ui - vì vậy renderPlot() được ghép cặp với plotOutput() và renderText() được kết hợp với textOutput().\nCuối cùng chúng ta đã tạo ra một ứng dụng hoạt động! Chúng ta có thể chạy ứng dùng bằng cách nhấn nút Run App ở trên cùng bên phải của cửa sổ script trong Rstudio. Bạn nên lưu ý rằng bạn có thể chọn chạy ứng dụng của mình trong trình duyệt mặc định (thay vì Rstudio), điều này sẽ phản ánh chính xác hơn giao diện của ứng dụng đối với những người dùng khác.\n\n\n\n\n\n\n\n\n\nLưu ý vui rằng trong R console, ứng dụng đang “lắng nghe”! Hãy nói về sự phản hồi!",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Dashboards với Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.vn.html#thêm-nhiều-chức-năng-hơn",
    "href": "new_pages/shiny_basics.vn.html#thêm-nhiều-chức-năng-hơn",
    "title": "43  Dashboards với Shiny",
    "section": "43.6 Thêm nhiều chức năng hơn",
    "text": "43.6 Thêm nhiều chức năng hơn\nTại thời điểm này, cuối cùng chúng ta đã có một ứng dụng đang chạy, nhưng chúng ta có rất ít chức năng. Chúng ta cũng không thực sự khai thác hết những gì shiny có thể làm, vì vậy có nhiều thứ để tìm hiểu thêm! Hãy tiếp tục xây dựng ứng dụng hiện có của chúng ta bằng cách thêm một số tính năng bổ sung. Một số thứ hay bạn có thể thêm vào là:\n\nMột văn bản giải thích\nNút tải đồ thị xuống - Cung cấp cho người dùng phiên bản chất lượng cao của hình ảnh mà họ đang tạo trong ứng dụng\nMột bộ chọn cho các cơ sở cụ thể\nMột trang dashboard khác - Có thể hiển thị một bảng cho dữ liệu của chúng ta.\n\nCó rất nhiều thứ để thêm, nhưng chúng ta có thể sử dụng nó để tìm hiểu về một loạt các tính năng shiny khác nhau sau này. Có rất nhiều thứ để tìm hiểu về Shiny (nó có thể trở nên rất nâng cao, nhưng hy vọng nó là trường hợp một khi người dùng có ý tưởng tốt hơn về cách sử dụng nó, họ có thể trở nên thoải mái hơn khi sử dụng các nguồn học tập bên ngoài).\n\nThêm văn bản tĩnh\nTrước tiên hãy thảo luận về việc thêm văn bản tĩnh vào ứng dụng shiny. Thêm văn bản vào ứng dụng của chúng ta cực kỳ dễ dàng khi bạn có kiến thức cơ bản về nó. Vì văn bản tĩnh không thay đổi trong ứng dụng shiny (nếu bạn muốn thay đổi, bạn có thể sử dụng hàm kết xuất văn bản (text rendering) trong máy chủ!), Tất cả văn bản tĩnh của Shiny thường được thêm vào UI của ứng dụng. Chúng tôi sẽ không đi vào chi tiết cho điều này, nhưng bạn có thể thêm nhiều yếu tố khác nhau vào giao diện UI (và thậm chí cả tùy chỉnh) bằng cách giao tiếp R với HTML và css.\nHTML và css là các ngôn ngữ có liên quan mật thiết trong thiết kế giao diện người dùng. Chúng ta không cần phải hiểu quá rõ những thứ này, nhưng HTML tạo các đối tượng trong UI (như hộp văn bản hoặc bảng) và css thường được sử dụng để thay đổi kiểu và tính thẩm mỹ của các đối tượng đó. Shiny có quyền truy cập vào một mảng lớn của các thẻ HTML - các thẻ này trình bày các đối tượng hoạt động theo một cách cụ thể, chẳng hạn như các tiêu đề, đoạn văn bản, ngắt dòng, bảng, v.v. Chúng ta có thể sử dụng một số ví dụ này như sau:\n\nh1() - đây là một thẻ đầu mục, sẽ tự động tạo văn bản lớn hơn và thay đổi mặc định khi chúng liên quan đến mặt phông chữ, màu v.v (tùy thuộc vào theme tổng thể ứng dụng của bạn). Bạn có thể truy cập tiêu đề phụ nhỏ hơn và nhỏ hơn với h2() xuống tới cả h6(). Cách sử dụng sẽ trông như sau:\n\nh1(\"my header - section 1\")\n\np() - đây là thẻ đoạn, sẽ khiến văn bản được chọn tương tự như văn bản trong một thân văn bản. Văn bản này sẽ tự động bao quanh, và có kích thước tương đối nhỏ (footers có thể còn nhỏ hơn). Hãy nghĩ về nó như phần thân văn bản của tài liệu Word. Cách sử dụng trông như sau\n\np(\"This is a larger body of text where I am explaining the function of my app\")\n\ntags$b() và tags$i() - chúng được sử dụng để tạo in đậm tags$b() và in nghiêng tags$i() với bất kỳ văn bản nào được chọn!\ntags$ul(), tags$ol() và tags$li() - đây là các thẻ được sử dụng trong việc tạo danh sách. Tất cả đều được sử dụng trong cú pháp bên dưới và cho phép người dùng tạo một danh sách theo thứ tự (tags$ol(); nghĩa là được đánh số) hoặc danh sách không có thứ tự (tags$ul(), nghĩa là tạo gạch đầu dòng). tags$li() được sử dụng để biểu thị các mục trong danh sách, bất kể loại danh sách nào được sử dụng. ví dụ:\n\n\ntags$ol(\n  \n  tags$li(\"Item 1\"),\n  \n  tags$li(\"Item 2\"),\n  \n  tags$li(\"Item 3\")\n  \n)\n\n\nbr() và hr() - các thẻ này tương ứng tạo ngắt dòng và dòng ngang (với một ngắt dòng). Sử dụng chúng để tách riêng các phần của ứng dụng và văn bản của bạn! Không cần phải chuyền bất kỳ đối tượng nào vào các thẻ này (dấu ngoặc đơn có thể vẫn trống).\ndiv() - Đây là thẻ chung có thể chứa bất cứ thứ gì và có thể có bất cứ tên gì. Khi bạn tiến bộ với thiết kế UI, bạn có thể sử dụng chúng để phân các UI ra từng loại, cung cấp các style cho từng phần cụ thể và tạo các tương tác giữa các phần tử máy chủ và UI. Chúng tôi sẽ không đi sâu vào những chi tiết này, nhưng quan trọng để biết qua về chúng!\n\nLưu ý rằng mỗi đối tượng này có thể được truy cập thông qua các thẻ tags$... hoặc chỉ qua hàm với một số khác. Chúng có hiệu quả như nhau, nhưng nó có thể giúp sử dụng kiểu tags$... nếu bạn thích rõ ràng hơn và không vô tình ghi đè các hàm. Điều này cũng không có nghĩa là có sẵn một danh sách thẻ đầy đủ. Có một danh sách khá đầy đủ tất cả các thẻ có sẵn trong shiny ở đây và thậm chí nhiều thẻ có thể được sử dụng hơn nếu bạn biết cách chèn HTML trực tiếp vào UI của bạn!\nNếu bạn cảm thấy tự tin, bạn cũng có thể thêm bất kỳ phần tử tạo kiểu css nào vào các thẻ HTML của mình với đối số style trong bất kỳ phần tử nào. Chúng ta sẽ không đi vào chi tiết cách thức hoạt động, nhưng một mẹo để thử nghiệm các thay đổi thẩm mỹ đối với UI đang sử dụng chế độ HTML inspector trong Chrome (bên trong ứng dụng shiny của bạn khi bạn đang chạy trong trình duyệt) và tự chỉnh sửa style của các đối tượng!\nHãy thêm một số văn bản vào ứng dụng của chúng ta\n\nui &lt;- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         h4(\"Options\"),\n         # selector for district\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = c(\n                   \"All\",\n                   \"Spring\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selected = \"All\",\n              multiple = TRUE\n         ),\n         # selector for age group\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         ),\n    ),\n\n    mainPanel(\n      # epicurve goes here\n      plotOutput(\"malaria_epicurve\"),\n      br(),\n      hr(),\n      p(\"Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:\"),\n    tags$ul(\n      tags$li(tags$b(\"location_name\"), \" - the facility that the data were collected at\"),\n      tags$li(tags$b(\"data_date\"), \" - the date the data were collected at\"),\n      tags$li(tags$b(\"submitted_daate\"), \" - the date the data were submitted at\"),\n      tags$li(tags$b(\"Province\"), \" - the province the data were collected at (all 'North' for this dataset)\"),\n      tags$li(tags$b(\"District\"), \" - the district the data were collected at\"),\n      tags$li(tags$b(\"age_group\"), \" - the age group the data were collected for (0-5, 5-14, 15+, and all ages)\"),\n      tags$li(tags$b(\"cases_reported\"), \" - the number of cases reported for the facility/age group on the given date\")\n    )\n    \n  )\n)\n)\n\n\n\n\n\n\n\n\n\n\n\n\nThêm liên kết\nĐể thêm một liên kết đến một trang web, hãy sử dụng tags$a() với liên kết và văn bản hiển thị như bên dưới. Để có một đoạn độc lập, hãy đặt nó trong p(). Để chỉ có một vài từ của một câu được gắn liên kết, hãy chia câu thành các phần và sử dụng tags$a() cho thành phần gắn hyperlink. Để đảm bảo liên kết được mở trong một cửa sổ trình duyệt mới, hãy thêm target = \"_blank\" dưới dạng một đối số.\n\ntags$a(href = \"www.epiRhandbook.com\", \"Visit our website!\")\n\n\n\nThêm nút tải về\nHãy cùng chuyển sang tính năng thứ hai. Nút tải xuống là một điều khá phổ biến để thêm vào một ứng dụng và khá dễ thực hiện. Chúng ta cần thêm một Widget khác vào giao diện người dùng và thêm một đầu ra khác tới máy chủ của chúng ta để đính kèm vào Widget đó. Chúng tôi cũng có thể giới thiệu về vật dẫn phản hồi trong ví dụ này!\nHãy cập nhật giao diện người dùng của chúng ta trước - Điều này dễ dàng khi Shiny đi kèm với một widget có tên là downloadButton() - cho phép đặt inputId và nhãn.\n\nui &lt;- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # selector for district\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = c(\n                   \"All\",\n                   \"Spring\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selected = \"All\",\n              multiple = FALSE\n         ),\n         # selector for age group\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         ),\n         # horizontal line\n         hr(),\n         downloadButton(\n           outputId = \"download_epicurve\",\n           label = \"Download plot\"\n         )\n\n    ),\n\n    mainPanel(\n      # epicurve goes here\n      plotOutput(\"malaria_epicurve\"),\n      br(),\n      hr(),\n      p(\"Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:\"),\n      tags$ul(\n        tags$li(tags$b(\"location_name\"), \" - the facility that the data were collected at\"),\n        tags$li(tags$b(\"data_date\"), \" - the date the data were collected at\"),\n        tags$li(tags$b(\"submitted_daate\"), \" - the date the data were submitted at\"),\n        tags$li(tags$b(\"Province\"), \" - the province the data were collected at (all 'North' for this dataset)\"),\n        tags$li(tags$b(\"District\"), \" - the district the data were collected at\"),\n        tags$li(tags$b(\"age_group\"), \" - the age group the data were collected for (0-5, 5-14, 15+, and all ages)\"),\n        tags$li(tags$b(\"cases_reported\"), \" - the number of cases reported for the facility/age group on the given date\")\n      )\n      \n    )\n    \n  )\n)\n\nLưu ý rằng chúng ta cũng đã thêm vào thẻ hr() - Điều này thêm một đường ngang ngăn cách các widget điều khiển với các widget tải xuống của chúng ta. Đây là một trong những thẻ HTML khác mà chúng ta đã thảo luận trước đây.\nBây giờ khi giao diện người dùng của chúng ta đã sẵn sàng, chúng ta cần thêm thành phần máy chủ. Việc thiết kế tải xuống đã được hoàn thành trong máy chủ với hàm downloadHandler(). Tương tự như đồ thị, chúng ta cần đính kèm nó vào một đầu ra có cùng inputId như là nút tải xuống. Hàm này có hai đối số - filename và content - cả hai đều là các hàm. Như bạn có thể đoán, fileName được sử dụng để chỉ định tên của tệp đã tải xuống và content được sử dụng để chỉ định những gì nên tải xuống. content chứa một hàm mà bạn sẽ sử dụng để lưu dữ liệu cục bộ - vì vậy nếu bạn đang tải xuống tệp CSV, bạn có thể sử dụng hàm rio::export(). Bởi vì chúng ta đang tải xuống một đồ thị, chúng ta sẽ sử dụng hàm ggplot2::ggsave(). Hãy xem cách chúng ta sẽ lập trình nó như sau (chúng ta sẽ không thêm nó vào máy chủ).\n\nserver &lt;- function(input, output, session) {\n  \n  output$malaria_epicurve &lt;- renderPlot(\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  )\n  \n  output$download_epicurve &lt;- downloadHandler(\n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n}\n\nLưu ý rằng hàm content luôn có đối số file, đối số giúp chúng ta chỉ định tên tệp đầu ra. Bạn cũng có thể nhận thấy rằng chúng ta đang lặp lại code tại đây - chúng ta đang sử dụng hàm plot_epicurve() hai lần trong máy chủ, một lần để tải xuống và một lần cho hình ảnh được hiển thị trong ứng dụng. Trong khi điều này sẽ không ảnh hưởng lớn đến hiệu suất, nghĩa là code để tạo ra đồ thị này sẽ phải chạy khi người dùng thay đổi các widget xác định nhóm quận và tuổi, và một lần nữa khi bạn muốn tải xuống đồ thị. Trong các ứng dụng lớn hơn, các quyết định làm giảm hiệu quả tối ưu như thế này sẽ càng ngày càng làm chậm mọi thứ, vì vậy sẽ tốt khi bạn học cách làm cho ứng dụng của chúng ta hiệu quả hơn theo nghĩa này. Sẽ hợp lý hơn nếu chúng ta có cách chạy code epicurve khi các nhóm quận/tuổi thay đổi, và để chúng được sử dụng bởi các hàm renderPlot() và downloadHandler(). Đây là khi mà các vật dẫn phản hồi có tác dụng!\nVật dẫn phản hồi là các đối tượng được tạo trong máy chủ shiny theo cơ chế tương tác, nhưng không xuất hiện - chúng chỉ có thể được sử dụng bởi các phần khác của máy chủ. Có một số loại vật dẫn phản hồi khác nhau, nhưng chúng ta sẽ đi qua hai loại cơ bản.\n1.reactive() - đây là vật dẫn phản hồi cơ bản nhất - nó sẽ phản hồi bất cứ khi nào bất kỳ đầu vào nào được sử dụng bên trong bởi nó thay đổi (các widget nhóm/nhóm tuổi)\n2. eventReactive() - vật dẫn phản hồi này hoạt động giống với reactive(), ngoại trừ người dùng có thể quy định các đầu vào nào khiến nó tiến hành chạy lại. Cách này rất hữu ích nếu vật dẫn phản hồi của bạn mất nhiều thời gian để xử lý, nhưng chúng tôi sẽ giải thích rõ hơn ở phần sau\nHãy xem hai ví dụ:\n\nmalaria_plot_r &lt;- reactive({\n  \n  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  \n})\n\n\n# only runs when the district selector changes!\nmalaria_plot_er &lt;- eventReactive(input$select_district, {\n  \n  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  \n})\n\nKhi chúng ta sử dụng thiết lập eventReactive(), chúng ta có thể chỉ định các đầu vào nào chạy đoạn code này - điều này không hữu ích với chúng ta vào lúc này, nên chúng ta có thể bỏ qua nó. Lưu ý rằng bạn có thể bao gồm nhiều đầu vào với c()\nHãy xem cách chúng ta có thể tích hợp vào code máy chủ:\n\nserver &lt;- function(input, output, session) {\n  \n  malaria_plot &lt;- reactive({\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  })\n  \n  \n  \n  output$malaria_epicurve &lt;- renderPlot(\n    malaria_plot()\n  )\n  \n  output$download_epicurve &lt;- downloadHandler(\n    \n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             malaria_plot(),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n}\n\nBạn có thể thấy chúng ta chỉ cần gọi đầu ra của phản hồi mà chúng ta đã xác định trong cả hai hàm tải xuống và tạo biểu đồ. Một điều cần lưu ý là bạn phải sử dụng các đầu ra của các phản hồi như thể chúng là các hàm - vì vậy bạn phải thêm dấu đơn ngoặc trống ở cuối chúng (tức là malaria_plot() là chính xác, còn malaria_plot thì không). Bây giờ khi chúng ta đã thêm giải pháp này, ứng dụng của chúng ta trở nên gọn gẽ hơn, nhanh hơn và dễ thay đổi hơn vì tất cả các code chạy hàm epicurve đều ở một nơi.\n\n\n\n\n\n\n\n\n\n\n\nThêm bộ chọn cơ sở y tế\nHãy chuyển sang tính năng tiếp theo của chúng ta - một bộ chọn cho các cơ sở cụ thể. Chúng ta sẽ thêm một tham số khác vào hàm của mình để có thể biến nó thành đối số từ code của chúng ta. Trước tiên, hãy xem việc thực hiện điều này - nó chỉ hoạt động theo các nguyên tắc tương tự như các tham số khác mà chúng ta đã thiết lập. Hãy cập nhật và kiểm tra hàm của chúng ta.\n\nplot_epicurve &lt;- function(data, district = \"All\", agegroup = \"malaria_tot\", facility = \"All\") {\n  \n  if (!(\"All\" %in% district)) {\n    data &lt;- data %&gt;%\n      filter(District %in% district)\n    \n    plot_title_district &lt;- stringr::str_glue(\"{paste0(district, collapse = ', ')} districts\")\n    \n  } else {\n    \n    plot_title_district &lt;- \"all districts\"\n    \n  }\n  \n  # if no remaining data, return NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  data &lt;- data %&gt;%\n    filter(age_group == agegroup)\n  \n  \n  # if no remaining data, return NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  if (agegroup == \"malaria_tot\") {\n      agegroup_title &lt;- \"All ages\"\n  } else {\n    agegroup_title &lt;- stringr::str_glue(\"{str_remove(agegroup, 'malaria_rdt')} years\")\n  }\n  \n    if (!(\"All\" %in% facility)) {\n    data &lt;- data %&gt;%\n      filter(location_name == facility)\n    \n    plot_title_facility &lt;- facility\n    \n  } else {\n    \n    plot_title_facility &lt;- \"all facilities\"\n    \n  }\n  \n  # if no remaining data, return NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n\n  \n  \n  ggplot(data, aes(x = data_date, y = cases_reported)) +\n    geom_col(width = 1, fill = \"darkred\") +\n    theme_minimal() +\n    labs(\n      x = \"date\",\n      y = \"number of cases\",\n      title = stringr::str_glue(\"Malaria cases - {plot_title_district}; {plot_title_facility}\"),\n      subtitle = agegroup_title\n    )\n  \n  \n  \n}\n\nHãy kiểm tra nó:\n\nplot_epicurve(malaria_data, district = \"Spring\", agegroup = \"malaria_rdt_0-4\", facility = \"Facility 1\")\n\n\n\n\n\n\n\n\nVới tất cả các cơ sở trong dữ liệu của chúng ta, sẽ khó để biết cơ sở nào tương ứng với các quận nào - và người dùng cuối cũng sẽ không biết. Điều này có thể làm cho việc sử dụng ứng dụng trở nên không trực quan. Vì lý do này, chúng ta nên làm cho các tùy chọn cơ sở trong UI thay đổi động khi người dùng thay đổi khu vực - để cái này lọc cái kia! Vì chúng ta có rất nhiều biến đang sử dụng trong các tùy chọn, chúng ta cũng có thể muốn tạo một số tùy chọn cho ui trong tệp global.R từ số liệu. Ví dụ: chúng ta có thể thêm đoạn code này vào global.R sau khi đọc dữ liệu của mình:\n\nall_districts &lt;- c(\"All\", unique(malaria_data$District))\n\n# data frame of location names by district\nfacility_list &lt;- malaria_data %&gt;%\n  group_by(location_name, District) %&gt;%\n  summarise() %&gt;% \n  ungroup()\n\nHãy xem chúng:\n\nall_districts\n\n[1] \"All\"     \"Spring\"  \"Bolo\"    \"Dingo\"   \"Barnard\"\n\n\n\nfacility_list\n\n# A tibble: 65 × 2\n   location_name District\n   &lt;chr&gt;         &lt;chr&gt;   \n 1 Facility 1    Spring  \n 2 Facility 10   Bolo    \n 3 Facility 11   Spring  \n 4 Facility 12   Dingo   \n 5 Facility 13   Bolo    \n 6 Facility 14   Dingo   \n 7 Facility 15   Barnard \n 8 Facility 16   Barnard \n 9 Facility 17   Barnard \n10 Facility 18   Bolo    \n# ℹ 55 more rows\n\n\nChúng ta có thể chuyển các biến mới này tới giao diện người dùng mà không gặp bất kỳ vấn đề gì, vì chúng được hiển thị trên toàn bộ cả server và ui! Hãy cập nhật UI của chúng ta:\n\nui &lt;- fluidPage(\n\n  titlePanel(\"Malaria facility visualisation app\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # selector for district\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Select district\",\n              choices = all_districts,\n              selected = \"All\",\n              multiple = FALSE\n         ),\n         # selector for age group\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Select age group\",\n              choices = c(\n                   \"All ages\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ), \n              selected = \"All\",\n              multiple = FALSE\n         ),\n         # selector for facility\n         selectInput(\n           inputId = \"select_facility\",\n           label = \"Select Facility\",\n           choices = c(\"All\", facility_list$location_name),\n           selected = \"All\"\n         ),\n         \n         # horizontal line\n         hr(),\n         downloadButton(\n           outputId = \"download_epicurve\",\n           label = \"Download plot\"\n         )\n\n    ),\n\n    mainPanel(\n      # epicurve goes here\n      plotOutput(\"malaria_epicurve\"),\n      br(),\n      hr(),\n      p(\"Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:\"),\n      tags$ul(\n        tags$li(tags$b(\"location_name\"), \" - the facility that the data were collected at\"),\n        tags$li(tags$b(\"data_date\"), \" - the date the data were collected at\"),\n        tags$li(tags$b(\"submitted_daate\"), \" - the date the data were submitted at\"),\n        tags$li(tags$b(\"Province\"), \" - the province the data were collected at (all 'North' for this dataset)\"),\n        tags$li(tags$b(\"District\"), \" - the district the data were collected at\"),\n        tags$li(tags$b(\"age_group\"), \" - the age group the data were collected for (0-5, 5-14, 15+, and all ages)\"),\n        tags$li(tags$b(\"cases_reported\"), \" - the number of cases reported for the facility/age group on the given date\")\n      )\n      \n    )\n    \n  )\n)\n\nLưu ý cách chúng ta hiện đang chuyển các biến cho các lựa chọn thay vì mã hóa cứng chúng trong ui! Điều này cũng có thể làm cho code của chúng ta nhỏ gọn hơn! Cuối cùng, chúng ta sẽ phải cập nhật máy chủ. Sẽ dễ dàng cập nhật hàm của chúng ta để kết hợp với đầu vào mới (chúng ta chỉ cần chuyển nó làm đối số cho tham số mới), nhưng nên nhớ rằng chúng ta cũng muốn ui cập nhật khi người dùng thay đổi khu vực đã chọn. Điều quan trọng cần hiểu ở đây là chúng ta có thể thay đổi các tham số và đặc tính của widget trong khi ứng dụng đang chạy, nhưng điều này cần được thực hiện trên máy chủ. Chúng ta cần tìm hiểu một cách mới để xuất ra máy chủ.\nCác hàm chúng ta cần hiểu cách thực hiện điều này được gọi là các hàm observer (trình quan sát) và tương tự như các hàm reactive (phản ứng) về cách chúng hoạt động. Tuy nhiên, chúng có một điểm khác biệt chính:\n\nCác hàm phản ứng không ảnh hưởng trực tiếp đến kết quả đầu ra và tạo ra các đối tượng có thể được nhìn thấy ở các vị trí khác trong máy chủ\n\nCác hàm quan sát có thể ảnh hưởng đến kết quả đầu ra của máy chủ, nhưng làm như vậy thông qua các hiệu ứng bên ngoài của các hàm khác. (Chúng cũng có thể làm những việc khác, nhưng đây là chức năng chính của chúng trong thực tế)\n\nTương tự như các hàm phản ứng, có hai loại của các hàm quan sát và chúng được phân chia theo cùng một logic phân chia các hàm phản ứng:\n\nobserve() - hàm này chạy bất cứ khi nào bất kỳ đầu vào nào được sử dụng bên trong nó thay đổi\n\nobserveEvent() - hàm này chạy khi đầu vào do người dùng chỉ định thay đổi\n\nChúng ta cũng cần hiểu các hàm được shiny cung cấp giúp cập nhật các widget. Chúng khá đơn giản để chạy - trước tiên chúng lấy đối tượng session từ hàm máy chủ (tại thời điểm này bạn chưa cần phải hiểu), và sau đó thay đổi inputId của hàm. Sau đó, chúng ta chuyển các phiên bản mới của tất cả các tham số đã được lấy bởi selectInput() - những tham số này sẽ được cập nhật tự động trong widget.\nHãy xem một ví dụ riêng lẻ về cách chúng ta có thể sử dụng điều này trong máy chủ của mình. Khi người dùng thay đổi quận, chúng ta muốn lọc các cơ sở theo quận và cập nhật các lựa chọn để chỉ hiển thị những cơ sở có sẵn trong quận đó (và một tùy chọn cho tất cả các cơ sở)\n\nobserve({\n  \n  if (input$select_district == \"All\") {\n    new_choices &lt;- facility_list$location_name\n  } else {\n    new_choices &lt;- facility_list %&gt;%\n      filter(District == input$select_district) %&gt;%\n      pull(location_name)\n  }\n  \n  new_choices &lt;- c(\"All\", new_choices)\n  \n  updateSelectInput(session, inputId = \"select_facility\",\n                    choices = new_choices)\n  \n})\n\nVậy đó! Chúng ta có thể thêm nó vào máy chủ và đặc tính đó bây giờ sẽ hoạt động. Đây là giao diện máy chủ mới của chúng ta:\n\nserver &lt;- function(input, output, session) {\n  \n  malaria_plot &lt;- reactive({\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)\n  })\n  \n  \n  \n  observe({\n    \n    if (input$select_district == \"All\") {\n      new_choices &lt;- facility_list$location_name\n    } else {\n      new_choices &lt;- facility_list %&gt;%\n        filter(District == input$select_district) %&gt;%\n        pull(location_name)\n    }\n    \n    new_choices &lt;- c(\"All\", new_choices)\n    \n    updateSelectInput(session, inputId = \"select_facility\",\n                      choices = new_choices)\n    \n  })\n  \n  \n  output$malaria_epicurve &lt;- renderPlot(\n    malaria_plot()\n  )\n  \n  output$download_epicurve &lt;- downloadHandler(\n    \n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             malaria_plot(),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n  \n  \n}\n\n\n\n\n\n\n\n\n\n\n\n\nThêm một bảng vào một tab khác\nBây giờ chúng ta sẽ chuyển sang thành phần cuối cùng mà chúng ta muốn thêm vào ứng dụng của mình. Chúng ta sẽ muốn tách giao diện thành hai tab, trong đó 1 tab sẽ hiện thị một bảng tương tác nơi người dùng có thể xem dữ liệu mà họ đang tạo đường cong dịch bệnh. Để làm điều này, chúng ta có thể sử dụng các phần tử giao diện được đóng gói sẵn đi kèm với các tab shiny có liên quan. Ở cấp độ cơ bản, chúng ta có thể bao gồm hầu hết cửa sổ chính trong cấu trúc chung này:\n\n# ... the rest of ui\n\nmainPanel(\n  \n  tabsetPanel(\n    type = \"tabs\",\n    tabPanel(\n      \"Epidemic Curves\",\n      ...\n    ),\n    tabPanel(\n      \"Data\",\n      ...\n    )\n  )\n)\n\nBây giờ hãy áp dụng nó vào giao diện. Chúng ta sẽ sử dụng package DT ở đây - đây là một package tuyệt vời để tạo bảng tương tác từ dữ liệu có sẵn. Chúng ta có thể thấy nó được sử dụng cho DT::datatableOutput() trong ví dụ này.\n\nui &lt;- fluidPage(\n     \n     titlePanel(\"Malaria facility visualisation app\"),\n     \n     sidebarLayout(\n          \n          sidebarPanel(\n               # selector for district\n               selectInput(\n                    inputId = \"select_district\",\n                    label = \"Select district\",\n                    choices = all_districts,\n                    selected = \"All\",\n                    multiple = FALSE\n               ),\n               # selector for age group\n               selectInput(\n                    inputId = \"select_agegroup\",\n                    label = \"Select age group\",\n                    choices = c(\n                         \"All ages\" = \"malaria_tot\",\n                         \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                         \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                         \"15+ yrs\" = \"malaria_rdt_15\"\n                    ), \n                    selected = \"All\",\n                    multiple = FALSE\n               ),\n               # selector for facility\n               selectInput(\n                    inputId = \"select_facility\",\n                    label = \"Select Facility\",\n                    choices = c(\"All\", facility_list$location_name),\n                    selected = \"All\"\n               ),\n               \n               # horizontal line\n               hr(),\n               downloadButton(\n                    outputId = \"download_epicurve\",\n                    label = \"Download plot\"\n               )\n               \n          ),\n          \n          mainPanel(\n               tabsetPanel(\n                    type = \"tabs\",\n                    tabPanel(\n                         \"Epidemic Curves\",\n                         plotOutput(\"malaria_epicurve\")\n                    ),\n                    tabPanel(\n                         \"Data\",\n                         DT::dataTableOutput(\"raw_data\")\n                    )\n               ),\n               br(),\n               hr(),\n               p(\"Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:\"),\n               tags$ul(\n                    tags$li(tags$b(\"location_name\"), \" - the facility that the data were collected at\"),\n                    tags$li(tags$b(\"data_date\"), \" - the date the data were collected at\"),\n                    tags$li(tags$b(\"submitted_daate\"), \" - the date the data were submitted at\"),\n                    tags$li(tags$b(\"Province\"), \" - the province the data were collected at (all 'North' for this dataset)\"),\n                    tags$li(tags$b(\"District\"), \" - the district the data were collected at\"),\n                    tags$li(tags$b(\"age_group\"), \" - the age group the data were collected for (0-5, 5-14, 15+, and all ages)\"),\n                    tags$li(tags$b(\"cases_reported\"), \" - the number of cases reported for the facility/age group on the given date\")\n               )\n               \n               \n          )\n     )\n)\n\nBây giờ ứng dụng của chúng ta được sắp xếp thành các tab! Hãy thực hiện các chỉnh sửa cần thiết đối với máy chủ. Vì chúng ta không cần phải thao tác với dữ liệu trước khi kết xuất nên điều này thực sự rất đơn giản - chúng ta chỉ cần kết xuất bộ dữ liệu malaria_data qua DT::renderDT() tới ui!\n\nserver &lt;- function(input, output, session) {\n  \n  malaria_plot &lt;- reactive({\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)\n  })\n  \n  \n  \n  observe({\n    \n    if (input$select_district == \"All\") {\n      new_choices &lt;- facility_list$location_name\n    } else {\n      new_choices &lt;- facility_list %&gt;%\n        filter(District == input$select_district) %&gt;%\n        pull(location_name)\n    }\n    \n    new_choices &lt;- c(\"All\", new_choices)\n    \n    updateSelectInput(session, inputId = \"select_facility\",\n                      choices = new_choices)\n    \n  })\n  \n  \n  output$malaria_epicurve &lt;- renderPlot(\n    malaria_plot()\n  )\n  \n  output$download_epicurve &lt;- downloadHandler(\n    \n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             malaria_plot(),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n  # render data table to ui\n  output$raw_data &lt;- DT::renderDT(\n    malaria_data\n  )\n  \n  \n}",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Dashboards với Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.vn.html#chia-sẻ-các-ứng-dụng-shiny",
    "href": "new_pages/shiny_basics.vn.html#chia-sẻ-các-ứng-dụng-shiny",
    "title": "43  Dashboards với Shiny",
    "section": "43.7 Chia sẻ các ứng dụng shiny",
    "text": "43.7 Chia sẻ các ứng dụng shiny\nSau khi bạn đã phát triển ứng dụng của riêng mình, bạn có thể muốn chia sẻ nó với những người khác - đây là lợi thế lớn nhất của shiny! Chúng ta có thể làm điều này bằng cách chia sẻ trực tiếp code hoặc chúng ta có thể xuất bản nó trên một máy chủ. Nếu chúng ta chia sẻ code, những người khác sẽ có thể thấy những gì bạn đã làm và xây dựng trên nó, nhưng điều này sẽ làm mất đi một trong những lợi thế chính của shiny - loại bỏ nhu cầu của người dùng cuối việc phải duy trì cài đặt R . Vì lý do này, nếu bạn đang chia sẻ ứng dụng của mình với những người dùng không cảm thấy thoải mái với R, thì việc chia sẻ ứng dụng đã được xuất bản trên máy chủ sẽ dễ dàng hơn nhiều.\nNếu muốn chia sẻ code, bạn có thể tạo tệp .zip của ứng dụng hoặc tốt hơn, xuất bản ứng dụng của bạn trên github và thêm cộng tác viên. Bạn có thể tham khảo thêm cách thực hiện trên github tại đây.\nTuy nhiên, nếu chúng ta xuất bản ứng dụng trực tuyến, chúng ta cần phải làm thêm một số bước nữa. Mục đích cuối cùng là bạn muốn ứng dụng của bạn có thể được truy cập qua URL web để những người khác có thể truy cập nhanh chóng và dễ dàng. Thật không may, để xuất bản ứng dụng của bạn trên một máy chủ, bạn cần có quyền truy cập vào một máy chủ để xuất bản nó! Có một số tùy chọn lưu trữ khi nói đến điều này:\n\nshinyapps.io: đây là nơi dễ dàng nhất để xuất bản các ứng dụng shiny, vì bạn không cần thực hiện nhiều các tinh chỉnh cấu hình cần thiết và có một số giấy phép miễn phí nhưng có giới hạn.\nRStudio Connect: đây là phiên bản mạnh hơn nhiều của máy chủ R, có thể thực hiện nhiều hoạt động, bao gồm cả xuất bản các ứng dụng shiny. Tuy nhiên, nó khó sử dụng hơn và ít được khuyến khích cho người dùng lần đầu.\n\nĐối với mục đích của tài liệu này, chúng tôi sẽ sử dụng shinyapps.io, vì nó dễ dàng hơn cho người dùng mới. Bạn có thể tạo một tài khoản miễn phí tại đây để bắt đầu - cũng có các gói giá khác nhau cho giấy phép máy chủ nếu cần. Nếu bạn mong đợi có nhiều người sử dụng ứng dụng của bạn, gói giá sẽ đắt hơn, vì vậy hãy cân nhắc kỹ điều này. Nếu bạn đang muốn tạo thứ gì đó cho một nhóm nhỏ cá nhân sử dụng, một giấy phép miễn phí có thể hoàn toàn phù hợp, nhưng một ứng dụng công khai có thể cần nhiều giấy phép hơn.\nTrước hết nên đảm bảo rằng ứng dụng của chúng ta phù hợp để xuất bản trên máy chủ. Bên trong ứng dụng, bạn nên khởi động lại phiên R và đảm bảo rằng nó chạy tốt mà không cần chạy thêm bất kỳ code nào. Điều này rất quan trọng vì một ứng dụng yêu cầu tải package hoặc đọc dữ liệu không được xác định sẽ không chạy được trên máy chủ. Bạn cũng cần lưu ý rằng bạn không thể sử dụng các đường dẫn tệp đặc trưng trong ứng dụng của mình - những đường dẫn này sẽ không hợp lệ trong cài đặt máy chủ - sử dụng package here sẽ giải quyết vấn đề này một cách triệt để. Cuối cùng, nếu bạn đang đọc dữ liệu từ một nguồn yêu cầu xác thực người dùng, chẳng hạn như máy chủ của tổ chức của bạn, thông thường nó sẽ không hoạt động trên máy chủ. Bạn sẽ cần phải làm việc với bộ phận IT (Công nghệ Thông tin) của mình để tìm ra cách đưa máy chủ shiny vào whitelist tại đây.\nđăng ký tài khoản\nSau khi có tài khoản của mình, bạn có thể điều hướng đến trang mã đăng nhập (tokens) trong Accounts. Tại đây, bạn sẽ thêm mã đăng nhập mới - mã này sẽ được sử dụng để triển khai ứng dụng của bạn.\nTừ đây, bạn nên lưu ý rằng url của tài khoản sẽ hiển thị tên ứng dụng của bạn - vì vậy nếu ứng dụng của bạn có tên là my_app, url sẽ được thêm vào là xxx.io/my_app/. Hãy chọn tên ứng dụng của bạn một cách khôn ngoan! Khi bạn đã sẵn sàng, hãy nhấp vào triển khai (deploy) - nếu thành công, điều này sẽ chạy ứng dụng của bạn trên url web bạn đã chọn!\nsomething on making apps in documents?",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Dashboards với Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.vn.html#đọc-thêm",
    "href": "new_pages/shiny_basics.vn.html#đọc-thêm",
    "title": "43  Dashboards với Shiny",
    "section": "43.8 Đọc thêm",
    "text": "43.8 Đọc thêm\nCho tới đây, chúng tôi đã đề cập rất nhiều khía cạnh của shiny, và hầu như không đi sâu vào những gì được cung cấp bởi shiny. Hướng dẫn này có chức năng như một phần giới thiệu, còn rất nhiều thứ nữa bạn phải học để hiểu đầy đủ về shiny. Bạn nên bắt đầu bằng cách tạo một ứng dụng cơ bản và dần dần thêm các chức năng cho nó.",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Dashboards với Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.vn.html#các-packages-mở-rộng-được-đề-xuất",
    "href": "new_pages/shiny_basics.vn.html#các-packages-mở-rộng-được-đề-xuất",
    "title": "43  Dashboards với Shiny",
    "section": "43.9 Các packages mở rộng được đề xuất",
    "text": "43.9 Các packages mở rộng được đề xuất\nNhững đề xuất dưới đây đại diện cho một số shiny extension chất lượng cao. Chúng tôi không sắp xếp chúng theo thứ tự đặc biệt nào cả:\n\nshinyWidgets - package này cung cấp cho bạn rất nhiều widget có thể được sử dụng trong ứng dụng của bạn. Chạy shinyWidgets::shinyWidgetsGallery() để xem một số lựa chọn các tiện ích có sẵn với package này. Xem các ví dụ ở đây\nshinyjs - Đây là một package tuyệt vời mang đến cho người dùng khả năng mở rộng tiện ích của Shiny thông qua JavaScript. Các ứng dụng của package này từ rất đơn giản đến cực kỳ chuyên sâu, nhưng trước hết bạn sẽ muốn sử dụng nó để thao tác với giao diện người dùng theo những cách đơn giản, như ẩn/hiển thị các yếu tố hoặc bật/tắt các nút. Tìm hiểu thêm ở đây\nshinydashboard - package này mở rộng UI có sẵn có thể được sử dụng trong shiny, đặc biệt để người dùng tạo dashboard phức tạp với nhiều bố cục phức tạp. Xem thêm ở đây\nshinydashboardPlus - Nhận nhiều tính năng hơn nữa so với shinydashboard! Xem thêm ở đây\nshinythemes - Thay đổi chủ đề css mặc định cho ứng dụng shiny của bạn với một loạt các mẫu có sẵn! Xem thêm ở đây\n\nNgoài ra còn có một số packages có thể được sử dụng để tạo các đầu ra tương tác tương thích với shiny.\n\nDT được bán liên kết hóa vào bản shiny cơ sở, cung cấp một tập hợp các hàm tuyệt vời để tạo các bảng tương tác.\nplotly là một package để tạo các đồ thị tương tác mà người dùng có thể thao tác trong ứng dụng. Bạn cũng có thể chuyển đổi đồ thị của mình sang các phiên bản tương tác thông qua plotly::ggplotly()! Các lựa chọn thay thế như dygraphs và highcharter cũng rất tuyệt vời.",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Dashboards với Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.vn.html#tài-nguyên-đề-xuất",
    "href": "new_pages/shiny_basics.vn.html#tài-nguyên-đề-xuất",
    "title": "43  Dashboards với Shiny",
    "section": "43.10 Tài nguyên đề xuất",
    "text": "43.10 Tài nguyên đề xuất",
    "crumbs": [
      "Báo cáo và dashboards",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Dashboards với Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.vn.html",
    "href": "new_pages/writing_functions.vn.html",
    "title": "44  Viết hàm",
    "section": "",
    "text": "44.1 Chuẩn bị",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Viết hàm</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.vn.html#chuẩn-bị",
    "href": "new_pages/writing_functions.vn.html#chuẩn-bị",
    "title": "44  Viết hàm",
    "section": "",
    "text": "Gọi packages\nĐoạn code này hiển thị việc tải các gói lệnh cần thiết cho phân tích. Trong cuốn sổ tay này, chúng tôi nhấn mạnh đến hàm p_load() trong package pacman, giúp cài đặt package nếu cần thiết và gọi chúng ra để sử dụng. Các package đã cài đặt cũng có thể được gọi ra bằng hàm library() từ base R. Xem chương R cơ bản để biết thêm thong tin về các packages trong R.\n\n\nNhập dữ liệu\nChúng tôi nhập bộ số liệu của các ca bệnh được mô phỏng từ một vụ dịch Ebola. Nếu muốn tải số liệu để làm theo từng bước, xem hướng dẫn trong chương Tải sách và dữ liệu. Bộ số liệu được nhập vào bằng hàm import() từ package rio. Xem chương Nhập xuất số liệu để biết các cách nhập dữ liệu khác.\nChúng tôi cũng sẽ sử dụng một vài số liệu về bệnh cúm do H7N9 xảy ra năm 2013 ở phần cuối của chương này.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Viết hàm</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.vn.html#hàm",
    "href": "new_pages/writing_functions.vn.html#hàm",
    "title": "44  Viết hàm",
    "section": "44.2 Hàm",
    "text": "44.2 Hàm\nCác hàm rất hữu ích trong lập trình vì chúng cho phép tạo ra các code dễ hiểu hơn, ngắn hơn và ít bị lỗi hơn (vì không có lỗi trong chính hàm này).\nNếu bạn đã xem đến chương này, có nghĩa là bạn đã đi qua vô số các hàm bởi vì trong R, mỗi toán tử là một lần gọi hàm +, for, if, [, $, { …. Ví dụ, x + y là tương đương với'+'(x, y)\nR là một ngôn ngữ cung cấp nhiều khả năng nhất để thực hiện các hàm và cung cấp đầy đủ các công cụ để người dùng dễ dàng viết chúng. Chúng ta không nên nghĩ các hàm là cố định ở đầu hay ở cuối chuỗi lập trình, R cung cấp các khả năng sử dụng chúng như thể chúng là các véc tơ và thậm chí sử dụng chúng bên trong các hàm, danh sách…\nCó rất nhiều nguồn nâng cao về lập trình hướng chức năng và chúng tôi sẽ chỉ cung cấp cho bạn một cái nhìn bao quát để giúp bạn bắt đầu với lập trình hướng chức năng với các ví dụ thực tế, ngắn gọn. Sau đó, bạn có thể truy cập thêm các tài liệu tham khảo ở phía dưới.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Viết hàm</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.vn.html#tại-sao-chúng-ta-sử-dụng-hàm",
    "href": "new_pages/writing_functions.vn.html#tại-sao-chúng-ta-sử-dụng-hàm",
    "title": "44  Viết hàm",
    "section": "44.3 Tại sao chúng ta sử dụng hàm?",
    "text": "44.3 Tại sao chúng ta sử dụng hàm?\nTrước khi trả lời câu hỏi này, điều quan trọng cần lưu ý là chúng ta đã biết các mẹo để viết các hàm đầu tiên trong R trong chương Lặp, vòng lặp và danh sách trong cuốn sổ tay này. Nói tóm lại, việc sử dụng “if/else” và vòng lặp thường là một phần cốt lõi trong nhiều hàm vì chúng dễ dàng giúp mở rộng tính ứng dụng code của chúng ta, cho phép nhiều điều kiện hoặc lặp lại code cho các tác vụ lặp lại.\n\nTôi có đang lặp lại nhiều lần cùng một đoạn code để áp dụng nó cho một biến hoặc số liệu khác không?\nLoại bỏ nó có rút ngắn đáng kể số dòng code tổng thể và giúp việc thực hiện nhanh hơn không?\nĐoạn code có thể sử dụng lại với giá trị khác ở nhiều vị trí trong code không?\n\nNếu một trong những trả lời cho các câu hỏi bên trên là “CÓ”, bạn có thể sẽ cần phải viết hàm",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Viết hàm</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.vn.html#cách-viết-hàm-trong-r",
    "href": "new_pages/writing_functions.vn.html#cách-viết-hàm-trong-r",
    "title": "44  Viết hàm",
    "section": "44.4 Cách viết hàm trong R",
    "text": "44.4 Cách viết hàm trong R\nCác hàm trong R có ba thành phần chính:\n\nphần hình thức formals() là danh sách các đối số mà kiểm soát cách chúng ta có thể gọi hàm\nphần thân body() là đoạn code bên trong hàm, vd: bên trong hoặc theo sau các dấu ngoặc, tùy thuộc vào cách chúng ta viết nó\n\nvà,\n\nphần môi trường thực hiện environment() để giúp chúng ta xác định vị trí các biến trong hàm và xác định cách các hàm tìm giá trị.\n\nMột khi đã tạo hàm, chúng ta cần kiểm tra mỗi thành phần này bằng cách gọi các hàm liên kết.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Viết hàm</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.vn.html#cấu-trúc-và-cú-pháp-cơ-bản",
    "href": "new_pages/writing_functions.vn.html#cấu-trúc-và-cú-pháp-cơ-bản",
    "title": "44  Viết hàm",
    "section": "44.5 Cấu trúc và cú pháp cơ bản",
    "text": "44.5 Cấu trúc và cú pháp cơ bản\n\nMột hàm cần được đặt tên cẩn thận theo đúng công việc của nó để có thể hiểu được khi chúng ta đọc tên hàm. A Thực tế, điều này đã được sử dụng trong phần lớn các kiến trúc của base R. Các hàm như mean(), print(), summary() có những cái tên đúng như nhiệm vụ của nó\nMột hàm cần các đối số như là số liệu để thực hiện và các đối tượng khác mà có thể là các giá trị tĩnh trong một danh sách các tùy chọn khác\nVà cuối cùng, một hàm sẽ cho kết quả đầu ra dựa trên nhiệm vụ cốt lõi của nó và các đối số đã được đưa ra. Thông thường, chúng ta sẽ sử dụng các hàm có sẵn như print(), return()… để tạo ra kết quả đầu ra. Kết quả đầu ra có thể là giá trị logic, một số, một ký tự, một data frame…mà gọi ngắn gọn là đối tượng của R.\n\nVề cơ bản, đây là thành phần của một hàm:\n\nfunction_name &lt;- function(argument_1, argument_2, argument_3){\n  \n           function_task\n  \n           return(output)\n}\n\nChúng ta tạo hàm đầu tiên với tên gọi là contain_covid19().\n\ncontain_covid19 &lt;- function(barrier_gest, wear_mask, get_vaccine){\n  \n                            if(barrier_gest == \"yes\" & wear_mask == \"yes\" & get_vaccine == \"yes\" ) \n       \n                            return(\"success\")\n  \n  else(\"please make sure all are yes, this pandemic has to end!\")\n}\n\nSau đó, chúng ta kiểm tra các thành phần của hàm vừa mới được tạo ra.\n\nformals(contain_covid19)\n\n$barrier_gest\n\n\n$wear_mask\n\n\n$get_vaccine\n\nbody(contain_covid19)\n\n{\n    if (barrier_gest == \"yes\" & wear_mask == \"yes\" & get_vaccine == \n        \"yes\") \n        return(\"success\")\n    else (\"please make sure all are yes, this pandemic has to end!\")\n}\n\nenvironment(contain_covid19)\n\n&lt;environment: R_GlobalEnv&gt;\n\n\nBây giờ, chúng ta sẽ kiểm tra hàm này. Để gọi hàm đã biết, chúng ta sử dụng nó như sử dụng tất cả các hàm trong R, tức là bằng cách viết tên hàm và thêm các đối số cần phải có.\n\ncontain_covid19(barrier_gest = \"yes\", wear_mask = \"yes\", get_vaccine = \"yes\")\n\n[1] \"success\"\n\n\nChúng ta có thể viết lại tên của mỗi đối số cho cẩn thận. Nhưng kể cả khi không cụ thể chúng, code cũng sẽ thực hiện vì R đã nhớ vị trí của mỗi đối số. Vì thế, miễn là chúng ta đặt các giá trị của các đối số theo đúng thứ tự, chúng ta có thể bỏ qua việc viết tên các đối số khi gọi hàm.\n\ncontain_covid19(\"yes\", \"yes\", \"yes\")\n\n[1] \"success\"\n\n\nSau đó, hãy xem điều gì sẽ xảy ra nếu một trong các giá trị là \"no\" hoặc not \"yes\".\n\ncontain_covid19(barrier_gest = \"yes\", wear_mask = \"yes\", get_vaccine = \"no\")\n\n[1] \"please make sure all are yes, this pandemic has to end!\"\n\n\nNếu chúng ta cung cấp các đối số không nhận diện được, chúng ta sẽ gặp lỗi:\n\ncontain_covid19(barrier_gest = \"sometimes\", wear_mask = \"yes\", get_vaccine = \"no\")\n\nError in contain_covid19(barrier_gest = \"sometimes\", wear_mask = \"yes\",  :  could not find function \"contain_covid19\"\nLƯU Ý: Một số hàm (hầu hết là rất ngắn và không phức tạp) có thể không cần tên và có thể sử dụng trực tiếp trên một dòng code hoặc bên trong một hàm khác để thực hiện tác vụ nhanh chóng. Các hàm này được gọi là hàm ẩn danh .\nVí dụ bên dưới là một hàm ẩn danh đầu tiên mà chỉ giữ các biến ký tự trong bộ số liệu.\n\nlinelist %&gt;% \n  dplyr::slice_head(n=10) %&gt;%  #equivalent to R base \"head\" function and that return first n observation of the  dataset\n  select(function(x) is.character(x)) \n\n\n\n\n\n\n\nSau đó, một hàm khác chọn mỗi quan sát thứ hai của bộ số liệu (có thể thích hợp khi chúng ta có số liệu dọc với nhiều bản ghi cho một bệnh nhân, ví dụ như ngày đặt lịch khám hoặc lần khám). Trong trường hợp này, việc viết hàm thích hợp bên ngoài gói lệnh dplyr sẽ là function (x) (x%%2 == 0) để áp dụng đối với véc tơ chứa tất cả các số hàng.\n\nlinelist %&gt;%   \n   slice_head(n=20) %&gt;% \n   tibble::rownames_to_column() %&gt;% # add indices of each obs as rownames to clearly see the final selection\n   filter(row_number() %%2 == 0)\n\n\n\n\n\n\n\nMột code trong base R có thể thực hiện tác vụ tương đương:\n\nlinelist_firstobs &lt;- head(linelist, 20)\n\nlinelist_firstobs[base::Filter(function(x) (x%%2 == 0), seq(nrow(linelist_firstobs))),]\n\n\n\n\n\n\n\nTHẬN TRỌNG: Mặc dù đúng là việc sử dụng hàm có thể giúp chúng ta viết code, tuy nhiên, việc viết một số hàm hay sửa hàm có thể tốn thời gian nếu chưa được suy nghĩ thấu đáo, viết đầy đủ và kết quả là báo lỗi. Vì lý do này, đầu tiên chúng ta nên viết code trước, chạy thử và đảm bảo nó thực hiện những gì chúng ta mong muốn và sau đó chuyển nó vào trong một hàm với ba thành phần chính như đã liệt kê bên trên.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Viết hàm</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.vn.html#các-ví-dụ",
    "href": "new_pages/writing_functions.vn.html#các-ví-dụ",
    "title": "44  Viết hàm",
    "section": "44.6 Các ví dụ",
    "text": "44.6 Các ví dụ\n\nTrả về các bảng tỷ lệ cho một số cột\nĐúng vậy, chúng ta đã có các hàm trong nhiều package mà cho phép tóm tắt thông tin một cách dễ dàng và đẹp mắt. Nhưng chúng ta vẫn cố gắng thử tạo ra hàm riêng trong những bước đầu tiên để làm quen với việc viết hàm.\nTrong ví dụ này, chúng tôi muốn chỉ ra cách viết một hàm đơn giản để tránh việc sao chép và dán cùng một code nhiều lần.\n\nproptab_multiple &lt;- function(my_data, var_to_tab){\n  \n  #print the name of each variable of interest before doing the tabulation\n  print(var_to_tab)\n\n  with(my_data,\n       rbind( #bind the results of the two following function by row\n        #tabulate the variable of interest: gives only numbers\n          table(my_data[[var_to_tab]], useNA = \"no\"),\n          #calculate the proportions for each variable of interest and round the value to 2 decimals\n         round(prop.table(table(my_data[[var_to_tab]]))*100,2)\n         )\n       )\n}\n\n\nproptab_multiple(linelist, \"gender\")\n\n[1] \"gender\"\n\n\n           f       m\n[1,] 2807.00 2803.00\n[2,]   50.04   49.96\n\nproptab_multiple(linelist, \"age_cat\")\n\n[1] \"age_cat\"\n\n\n         0-4     5-9  10-14  15-19   20-29 30-49 50-69 70+\n[1,] 1095.00 1095.00 941.00 743.00 1073.00   754 95.00 6.0\n[2,]   18.87   18.87  16.22  12.81   18.49    13  1.64 0.1\n\nproptab_multiple(linelist, \"outcome\")\n\n[1] \"outcome\"\n\n\n       Death Recover\n[1,] 2582.00 1983.00\n[2,]   56.56   43.44\n\n\nMẸO: Như đã trình bày bên trên, việc chú thích cho các hàm là rất quan trọng, là một thói quen lập trình nói chung. BHãy nhớ rằng mục đích của một hàm là làm cho code sẵn sàng để đọc, ngắn hơn và hiệu quả hơn. Sau đó, người đọc có thể hiểu được hàm này sẽ làm gì chỉ bằng cách đọc tên nó và có thêm thông tin chi tiết khi đọc các chú thích.\nCách thứ hai là sử dụng hàm này trong một hàm khác thông qua vòng lặp để thực hiện quá trình một cách đồng thời:\n\nfor(var_to_tab in c(\"gender\",\"age_cat\",  \"outcome\")){\n  \n  print(proptab_multiple(linelist, var_to_tab))\n  \n}\n\n[1] \"gender\"\n           f       m\n[1,] 2807.00 2803.00\n[2,]   50.04   49.96\n[1] \"age_cat\"\n         0-4     5-9  10-14  15-19   20-29 30-49 50-69 70+\n[1,] 1095.00 1095.00 941.00 743.00 1073.00   754 95.00 6.0\n[2,]   18.87   18.87  16.22  12.81   18.49    13  1.64 0.1\n[1] \"outcome\"\n       Death Recover\n[1,] 2582.00 1983.00\n[2,]   56.56   43.44\n\n\nMột cách đơn giản hơn có thể là sử dụng “apply” trong base R thay vì dùng “for loop” như được trình bày bên dưới:\nMẸO: R thường được định nghĩa như một ngôn ngữ lập trình hướng chức năng và hầu như bất cứ lúc nào chúng ta thực hiện một dòng code, chúng ta đang sử dụng một số hàm có sẵn. Một thói quen tốt để cảm thấy thoải mái hơn với việc viết hàm là thường xuyên nhìn bên trong cách các hàm cơ bản được viết mà chúng ta sử dụng hàng ngày. Phím tắt để làm như vậy là chọn tên hàm và sau đó bấm Ctrl+F2 hoặc fn+F2 hoặc Cmd+F2 (tùy thuộc vào máy tính của bạn) .",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Viết hàm</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.vn.html#sử-dụng-purrr-viết-các-hàm-với-vòng-lặp",
    "href": "new_pages/writing_functions.vn.html#sử-dụng-purrr-viết-các-hàm-với-vòng-lặp",
    "title": "44  Viết hàm",
    "section": "44.7 Sử dụng purrr: viết các hàm với vòng lặp",
    "text": "44.7 Sử dụng purrr: viết các hàm với vòng lặp\n\nSửa đổi kiểu biến trên nhiều cột trong một bộ số liệu\nGiả sử nhiều biến kiểu ký tự trong bộ số liệu gốc linelist cần được thay đổi thành “factor” nhằm mục đích phân tích và vẽ biểu đồ. Thay vì lặp lại bước nhiều lần, chúng ta có thể sử dụng hàm lapply() để chuyển đổi tất cả các biến có liên quan trong một dòng code.\nTHẬN TRỌNG: hàm lapply() trả về một danh sách, vì thế, sử dụng danh sách này có thể đòi hỏi một sửa đổi bổ sung như là một bước cuối cùng.\nBước tương tự có thể được thực hiện bằng cách sử dụng hàm map_if() từ package purrr\n\nlinelist_factor2 &lt;- linelist %&gt;%\n  purrr::map_if(is.character, as.factor)\n\n\nlinelist_factor2 %&gt;%\n        glimpse()\n\nList of 30\n $ case_id             : Factor w/ 5888 levels \"00031d\",\"00086d\",..: 2134 3022 396 4203 3084 4347 179 1241 5594 430 ...\n $ generation          : num [1:5888] 4 4 2 3 3 3 4 4 4 4 ...\n $ date_infection      : Date[1:5888], format: \"2014-05-08\" NA ...\n $ date_onset          : Date[1:5888], format: \"2014-05-13\" \"2014-05-13\" ...\n $ date_hospitalisation: Date[1:5888], format: \"2014-05-15\" \"2014-05-14\" ...\n $ date_outcome        : Date[1:5888], format: NA \"2014-05-18\" ...\n $ outcome             : Factor w/ 2 levels \"Death\",\"Recover\": NA 2 2 NA 2 2 2 1 2 1 ...\n $ gender              : Factor w/ 2 levels \"f\",\"m\": 2 1 2 1 2 1 1 1 2 1 ...\n $ age                 : num [1:5888] 2 3 56 18 3 16 16 0 61 27 ...\n $ age_unit            : Factor w/ 2 levels \"months\",\"years\": 2 2 2 2 2 2 2 2 2 2 ...\n $ age_years           : num [1:5888] 2 3 56 18 3 16 16 0 61 27 ...\n $ age_cat             : Factor w/ 8 levels \"0-4\",\"5-9\",\"10-14\",..: 1 1 7 4 1 4 4 1 7 5 ...\n $ age_cat5            : Factor w/ 18 levels \"0-4\",\"5-9\",\"10-14\",..: 1 1 12 4 1 4 4 1 13 6 ...\n $ hospital            : Factor w/ 6 levels \"Central Hospital\",..: 4 3 6 5 2 5 3 3 3 3 ...\n $ lon                 : num [1:5888] -13.2 -13.2 -13.2 -13.2 -13.2 ...\n $ lat                 : num [1:5888] 8.47 8.45 8.46 8.48 8.46 ...\n $ infector            : Factor w/ 2697 levels \"00031d\",\"002e6c\",..: 2594 NA NA 2635 180 1799 1407 195 NA NA ...\n $ source              : Factor w/ 2 levels \"funeral\",\"other\": 2 NA NA 2 2 2 2 2 NA NA ...\n $ wt_kg               : num [1:5888] 27 25 91 41 36 56 47 0 86 69 ...\n $ ht_cm               : num [1:5888] 48 59 238 135 71 116 87 11 226 174 ...\n $ ct_blood            : num [1:5888] 22 22 21 23 23 21 21 22 22 22 ...\n $ fever               : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n $ chills              : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n $ cough               : Factor w/ 2 levels \"no\",\"yes\": 2 NA NA 1 2 2 NA 2 2 2 ...\n $ aches               : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n $ vomit               : Factor w/ 2 levels \"no\",\"yes\": 2 NA NA 1 2 2 NA 2 2 1 ...\n $ temp                : num [1:5888] 36.8 36.9 36.9 36.8 36.9 37.6 37.3 37 36.4 35.9 ...\n $ time_admission      : Factor w/ 1072 levels \"00:10\",\"00:29\",..: NA 308 746 415 514 589 609 297 409 387 ...\n $ bmi                 : num [1:5888] 117.2 71.8 16.1 22.5 71.4 ...\n $ days_onset_hosp     : num [1:5888] 2 1 2 2 1 1 2 1 1 2 ...\n\n\n\n\nVòng lặp tạo biểu đồ cho nhiều giá trị khác nhau của biến\nỞ đây, chúng ta sẽ tạo biểu đồ tròn để xem phân bố outcome của bệnh nhân trong đợt dịch H7N9 cho từng tỉnh tại Trung Quốc. Thay vì lặp lại code cho từng tỉnh, chúng ta chỉ áp dụng một hàm mà chúng ta sẽ tạo ra.\n\n#precising options for the use of highchart\noptions(highcharter.theme =   highcharter::hc_theme_smpl(tooltip = list(valueDecimals = 2)))\n\n\n#create a function called \"chart_outcome_province\" that takes as argument the dataset and the name of the province for which to plot the distribution of the outcome.\n\nchart_outcome_province &lt;- function(data_used, prov){\n  \n  tab_prov &lt;- data_used %&gt;% \n    filter(province == prov,\n           !is.na(outcome))%&gt;% \n    group_by(outcome) %&gt;% \n    count() %&gt;%\n    adorn_totals(where = \"row\") %&gt;% \n    adorn_percentages(denominator = \"col\", )%&gt;%\n    mutate(\n        perc_outcome= round(n*100,2))\n  \n  \n  tab_prov %&gt;%\n    filter(outcome != \"Total\") %&gt;% \n  highcharter::hchart(\n    \"pie\", hcaes(x = outcome, y = perc_outcome),\n    name = paste0(\"Distibution of the outcome in:\", prov)\n    )\n  \n}\n\nchart_outcome_province(flu_china, \"Shanghai\")\n\n\n\n\nchart_outcome_province(flu_china,\"Zhejiang\")\n\n\n\n\nchart_outcome_province(flu_china,\"Jiangsu\")\n\n\n\n\n\n\n\nVòng lặp tạo bảng cho nhiều giá trị khác nhau của biến\nỞ đây, chúng ta sẽ tạo ba chỉ số để tóm tắt một bảng và chúng ta muốn tạo bảng này theo từng tỉnh. Các chỉ số của chúng ta là khoảng thời gian từ lúc khởi phát bệnh đến lúc nhập viện, tỷ lệ hồi phục và tuổi trung vị của các ca bệnh.\n\nindic_1 &lt;- flu_china %&gt;% \n  group_by(province) %&gt;% \n  mutate(\n    date_hosp= strptime(date_of_hospitalisation, format = \"%m/%d/%Y\"),\n    date_ons= strptime(date_of_onset, format = \"%m/%d/%Y\"), \n    delay_onset_hosp= as.numeric(date_hosp - date_ons)/86400,\n    mean_delay_onset_hosp = round(mean(delay_onset_hosp, na.rm=TRUE ), 0)) %&gt;%\n  select(province, mean_delay_onset_hosp)  %&gt;% \n  distinct()\n     \n\nindic_2 &lt;-  flu_china %&gt;% \n            filter(!is.na(outcome)) %&gt;% \n            group_by(province, outcome) %&gt;% \n            count() %&gt;%\n            pivot_wider(names_from = outcome, values_from = n) %&gt;% \n    adorn_totals(where = \"col\") %&gt;% \n    mutate(\n        perc_recovery= round((Recover/Total)*100,2))%&gt;% \n  select(province, perc_recovery)\n    \n    \n    \nindic_3 &lt;-  flu_china %&gt;% \n            group_by(province) %&gt;% \n            mutate(\n                    median_age_cases = median(as.numeric(age), na.rm = TRUE)\n            ) %&gt;% \n  select(province, median_age_cases)  %&gt;% \n  distinct()\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `median_age_cases = median(as.numeric(age), na.rm = TRUE)`.\nℹ In group 11: `province = \"Shanghai\"`.\nCaused by warning in `median()`:\n! NAs introduced by coercion\n\n#join the three indicator datasets\n\ntable_indic_all &lt;- indic_1 %&gt;% \n  dplyr::left_join(indic_2, by = \"province\") %&gt;% \n        left_join(indic_3, by = \"province\")\n\n\n#print the indicators in a flextable\n\n\nprint_indic_prov &lt;-  function(table_used, prov){\n  \n  #first transform a bit the dataframe for printing ease\n  indic_prov &lt;- table_used %&gt;%\n    filter(province==prov) %&gt;%\n    pivot_longer(names_to = \"Indicateurs\", cols = 2:4) %&gt;% \n   mutate( indic_label = factor(Indicateurs,\n   levels= c(\"mean_delay_onset_hosp\",\"perc_recovery\",\"median_age_cases\"),\n   labels=c(\"Mean delay onset-hosp\",\"Percentage of recovery\", \"Median age of the cases\"))\n   ) %&gt;% \n    ungroup(province) %&gt;% \n    select(indic_label, value)\n  \n\n    tab_print &lt;- flextable(indic_prov)  %&gt;%\n    theme_vanilla() %&gt;% \n    flextable::fontsize(part = \"body\", size = 10) \n    \n    \n     tab_print &lt;- tab_print %&gt;% \n                  autofit()   %&gt;%\n                  set_header_labels( \n                indic_label= \"Indicateurs\", value= \"Estimation\") %&gt;%\n    flextable::bg( bg = \"darkblue\", part = \"header\") %&gt;%\n    flextable::bold(part = \"header\") %&gt;%\n    flextable::color(color = \"white\", part = \"header\") %&gt;% \n    add_header_lines(values = paste0(\"Indicateurs pour la province de: \", prov)) %&gt;% \nbold(part = \"header\")\n \n tab_print &lt;- set_formatter_type(tab_print,\n   fmt_double = \"%.2f\",\n   na_str = \"-\")\n\ntab_print \n    \n}\n\n\n\n\nprint_indic_prov(table_indic_all, \"Shanghai\")\n\nIndicateurs pour la province de: ShanghaiIndicateursEstimationMean delay onset-hosp4.0Percentage of recovery46.7Median age of the cases67.0\n\nprint_indic_prov(table_indic_all, \"Jiangsu\")\n\nIndicateurs pour la province de: JiangsuIndicateursEstimationMean delay onset-hosp6.0Percentage of recovery71.4Median age of the cases55.0",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Viết hàm</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.vn.html#mẹo-và-thực-hành-tốt-để-các-hàm-hoạt-động-tốt",
    "href": "new_pages/writing_functions.vn.html#mẹo-và-thực-hành-tốt-để-các-hàm-hoạt-động-tốt",
    "title": "44  Viết hàm",
    "section": "44.8 Mẹo và thực hành tốt để các hàm hoạt động tốt",
    "text": "44.8 Mẹo và thực hành tốt để các hàm hoạt động tốt\nLập trình hàm có nghĩa là để dễ dàng viết và đọc code. Tuy nhiên, điều ngược lại có thể xảy ra. Những mẹo dưới đây sẽ giúp bạn có một đoạn code gọn gàng và dễ đọc.\n\nĐặt tên và cú pháp\n\nTránh sử dụng ký tự có thể đã được sử dụng bởi các hàm khác trong hàm của chúng ta\nNên đặt tên hàm ngắn gọn và dễ hiểu cho người đọc\nƯu tiên sử dụng động từ làm tên hàm và danh từ làm tên các đối số.\n\n\n\nTên cột và lượng giá tính gọn gàng\nNếu bạn muốn biết cách tham chiếu tên cột để đưa vào code của bạn như một đối số, hãy đọc hướng dẫn lập trình của tidyverse này. Trong số các chủ đề, nên đọc về tidy evaluation và sử dụng embrace { } “hai dấu ngoặc nhọn”\nVí dụ: đây là đoạn code mẫu từ trang hướng dẫn được đề cập bên trên:\n\nvar_summary &lt;- function(data, var) {\n  data %&gt;%\n    summarise(n = n(), min = min({{ var }}), max = max({{ var }}))\n}\nmtcars %&gt;% \n  group_by(cyl) %&gt;% \n  var_summary(mpg)\n\n\n\nKiểm tra và xử lý lỗi\nCông việc của hàm càng phức tạp thì khả năng xảy ra lỗi càng cao. Vì thế, đôi khi cần phải thêm một vài kiểm tra bên trong hàm để giúp nhanh chóng biết được lỗi ở đâu và tìm cách sửa nó.\n\nRất nên đưa một hàm kiểm tra tính thiếu sót của một đối số bằng cách sử dụng missing(argument). Việc kiểm tra đơn giản này trả về giá trị “TRUE” hoặc “FALSE”.\n\n\ncontain_covid19_missing &lt;- function(barrier_gest, wear_mask, get_vaccine){\n  \n  if (missing(barrier_gest)) (print(\"please provide arg1\"))\n  if (missing(wear_mask)) print(\"please provide arg2\")\n  if (missing(get_vaccine)) print(\"please provide arg3\")\n\n\n  if (!barrier_gest == \"yes\" | wear_mask ==\"yes\" | get_vaccine == \"yes\" ) \n       \n       return (\"you can do better\")\n  \n  else(\"please make sure all are yes, this pandemic has to end!\")\n}\n\n\ncontain_covid19_missing(get_vaccine = \"yes\")\n\n[1] \"please provide arg1\"\n[1] \"please provide arg2\"\n\n\nError in contain_covid19_missing(get_vaccine = \"yes\"): argument \"barrier_gest\" is missing, with no default\n\n\n\nSử dụng hàm stop() để dễ phát hiện lỗi hơn.\n\n\ncontain_covid19_stop &lt;- function(barrier_gest, wear_mask, get_vaccine){\n  \n  if(!is.character(barrier_gest)) (stop(\"arg1 should be a character, please enter the value with `yes`, `no` or `sometimes\"))\n  \n  if (barrier_gest == \"yes\" & wear_mask ==\"yes\" & get_vaccine == \"yes\" ) \n       \n       return (\"success\")\n  \n  else(\"please make sure all are yes, this pandemic has to end!\")\n}\n\n\ncontain_covid19_stop(barrier_gest=1, wear_mask=\"yes\", get_vaccine = \"no\")\n\nError in contain_covid19_stop(barrier_gest = 1, wear_mask = \"yes\", get_vaccine = \"no\"): arg1 should be a character, please enter the value with `yes`, `no` or `sometimes\n\n\n\nNhư đã thấy khi chúng ta thực hiện hầu hết các hàm có sẵn, có các thông báo và cảnh báo có thể xuất hiện trong một số điều kiện nhất định. Chúng ta có thể tích hợp chúng trong các hàm đã viết bằng cách sử dụng hàm message() và warning().\nChúng ta cũng có thể xử lý lỗi bằng cách sử dụng hàm safely() để lấy một hàm làm đối số và thực hiện nó một cách an toàn. Trên thực tế, hàm sẽ thực hiện mà không dừng lại nếu nó gặp lỗi. Hàm safely() trả về kết quả đầu ra dưới dạng một list với hai đối tượng là kết quả và lỗi mà nó đã “bỏ qua”.\n\nChúng ta có thể kiểm tra bằng cách thực hiện hàm mean() trước, sau đó thực hiện nó với hàm safely().\n\nmap(linelist, mean)\n\n$case_id\n[1] NA\n\n$generation\n[1] 16.56165\n\n$date_infection\n[1] NA\n\n$date_onset\n[1] NA\n\n$date_hospitalisation\n[1] \"2014-11-03\"\n\n$date_outcome\n[1] NA\n\n$outcome\n[1] NA\n\n$gender\n[1] NA\n\n$age\n[1] NA\n\n$age_unit\n[1] NA\n\n$age_years\n[1] NA\n\n$age_cat\n[1] NA\n\n$age_cat5\n[1] NA\n\n$hospital\n[1] NA\n\n$lon\n[1] -13.23381\n\n$lat\n[1] 8.469638\n\n$infector\n[1] NA\n\n$source\n[1] NA\n\n$wt_kg\n[1] 52.64487\n\n$ht_cm\n[1] 124.9633\n\n$ct_blood\n[1] 21.20686\n\n$fever\n[1] NA\n\n$chills\n[1] NA\n\n$cough\n[1] NA\n\n$aches\n[1] NA\n\n$vomit\n[1] NA\n\n$temp\n[1] NA\n\n$time_admission\n[1] NA\n\n$bmi\n[1] 46.89023\n\n$days_onset_hosp\n[1] NA\n\n\n\nsafe_mean &lt;- safely(mean)\nlinelist %&gt;% \n  map(safe_mean)\n\n$case_id\n$case_id$result\n[1] NA\n\n$case_id$error\nNULL\n\n\n$generation\n$generation$result\n[1] 16.56165\n\n$generation$error\nNULL\n\n\n$date_infection\n$date_infection$result\n[1] NA\n\n$date_infection$error\nNULL\n\n\n$date_onset\n$date_onset$result\n[1] NA\n\n$date_onset$error\nNULL\n\n\n$date_hospitalisation\n$date_hospitalisation$result\n[1] \"2014-11-03\"\n\n$date_hospitalisation$error\nNULL\n\n\n$date_outcome\n$date_outcome$result\n[1] NA\n\n$date_outcome$error\nNULL\n\n\n$outcome\n$outcome$result\n[1] NA\n\n$outcome$error\nNULL\n\n\n$gender\n$gender$result\n[1] NA\n\n$gender$error\nNULL\n\n\n$age\n$age$result\n[1] NA\n\n$age$error\nNULL\n\n\n$age_unit\n$age_unit$result\n[1] NA\n\n$age_unit$error\nNULL\n\n\n$age_years\n$age_years$result\n[1] NA\n\n$age_years$error\nNULL\n\n\n$age_cat\n$age_cat$result\n[1] NA\n\n$age_cat$error\nNULL\n\n\n$age_cat5\n$age_cat5$result\n[1] NA\n\n$age_cat5$error\nNULL\n\n\n$hospital\n$hospital$result\n[1] NA\n\n$hospital$error\nNULL\n\n\n$lon\n$lon$result\n[1] -13.23381\n\n$lon$error\nNULL\n\n\n$lat\n$lat$result\n[1] 8.469638\n\n$lat$error\nNULL\n\n\n$infector\n$infector$result\n[1] NA\n\n$infector$error\nNULL\n\n\n$source\n$source$result\n[1] NA\n\n$source$error\nNULL\n\n\n$wt_kg\n$wt_kg$result\n[1] 52.64487\n\n$wt_kg$error\nNULL\n\n\n$ht_cm\n$ht_cm$result\n[1] 124.9633\n\n$ht_cm$error\nNULL\n\n\n$ct_blood\n$ct_blood$result\n[1] 21.20686\n\n$ct_blood$error\nNULL\n\n\n$fever\n$fever$result\n[1] NA\n\n$fever$error\nNULL\n\n\n$chills\n$chills$result\n[1] NA\n\n$chills$error\nNULL\n\n\n$cough\n$cough$result\n[1] NA\n\n$cough$error\nNULL\n\n\n$aches\n$aches$result\n[1] NA\n\n$aches$error\nNULL\n\n\n$vomit\n$vomit$result\n[1] NA\n\n$vomit$error\nNULL\n\n\n$temp\n$temp$result\n[1] NA\n\n$temp$error\nNULL\n\n\n$time_admission\n$time_admission$result\n[1] NA\n\n$time_admission$error\nNULL\n\n\n$bmi\n$bmi$result\n[1] 46.89023\n\n$bmi$error\nNULL\n\n\n$days_onset_hosp\n$days_onset_hosp$result\n[1] NA\n\n$days_onset_hosp$error\nNULL\n\n\nNhư đã nói trước đây, chú thích rõ ràng trong các đoạn mã là một cách tốt để có tư liệu cho các công việc đã thực hiện.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Viết hàm</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.vn.html#nguồn",
    "href": "new_pages/writing_functions.vn.html#nguồn",
    "title": "44  Viết hàm",
    "section": "44.9 Nguồn",
    "text": "44.9 Nguồn\nR for Data Science link\nCheatsheet advance R programming\nCheatsheet purr Package\nVideo-ACM talk by Hadley Wickham: The joy of functional programming (how does map_dbl work)",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Viết hàm</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.vn.html",
    "href": "new_pages/directories.vn.html",
    "title": "45  Tương tác với thư mục làm việc",
    "section": "",
    "text": "45.1 Chuẩn bị",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Tương tác với thư mục làm việc</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.vn.html#chuẩn-bị",
    "href": "new_pages/directories.vn.html#chuẩn-bị",
    "title": "45  Tương tác với thư mục làm việc",
    "section": "",
    "text": "fs package\nPackage fs thuộc hệ sinh thái tidyverse giúp thuận tiện cho việc tương tác với thư mục, cải thiện một số hàm trong base R. Trong các phần bên dưới, chúng ta sẽ dùng các hàm từ fs.\n\npacman::p_load(\n  fs,             # file/directory interactions\n  rio,            # import/export\n  here,           # relative file pathways\n  tidyverse)      # data management and visualization\n\n\n\nIn thư mục dưới dạng cây biểu đồ dendrogram\nSử dụng hàm dir_tree() từ package fs.\nCung cấp đường dẫn thư mục cho đối số path = và quyết định xem có hay không chúng ta muốn hiển thị chỉ ở một cấp độ (recurse = FALSE) hay tất cả các tập tin trong tất cả các thư mục con (recurse = TRUE). Bên dưới chúng ta sử dụng hàm here() để hiển thị kết quả dưới dạng viết tốc ký trong dự án R và cụ thể thư mục con “data” của nó, mà chứa tất các số liệu được sử dụng cho cuốn sổ tay này. Chúng ta thiết lập nó để hiện thị tất cả các tệp bên trong thư mục “data” và các thư mục con của nó (vd: “cache”, “epidemic models”, “population”, “shp”, và “weather”).\n\nfs::dir_tree(path = here(\"data\"), recurse = TRUE)\n\nC:/Users/ngulu864/AppData/Local/Temp/Rtmp8MqjVI/file26d81e9e49d3/data\n├── africa_countries.geo.json\n├── cache\n│   └── epidemic_models\n│       ├── 2015-04-30\n│       │   ├── estimated_reported_cases_samples.rds\n│       │   ├── estimate_samples.rds\n│       │   ├── latest_date.rds\n│       │   ├── reported_cases.rds\n│       │   ├── summarised_estimated_reported_cases.rds\n│       │   ├── summarised_estimates.rds\n│       │   └── summary.rds\n│       ├── epinow_res.rds\n│       ├── epinow_res_small.rds\n│       ├── generation_time.rds\n│       └── incubation_period.rds\n├── case_linelists\n│   ├── cleaning_dict.csv\n│   ├── fluH7N9_China_2013.csv\n│   ├── linelist_cleaned.rds\n│   ├── linelist_cleaned.xlsx\n│   └── linelist_raw.xlsx\n├── country_demographics.csv\n├── covid_example_data\n│   ├── covid_example_data.xlsx\n│   └── covid_shapefile\n│       ├── FultonCountyZipCodes.cpg\n│       ├── FultonCountyZipCodes.dbf\n│       ├── FultonCountyZipCodes.prj\n│       ├── FultonCountyZipCodes.sbn\n│       ├── FultonCountyZipCodes.sbx\n│       ├── FultonCountyZipCodes.shp\n│       ├── FultonCountyZipCodes.shp.xml\n│       └── FultonCountyZipCodes.shx\n├── covid_incidence.csv\n├── covid_incidence_map.R\n├── district_count_data.xlsx\n├── example\n│   ├── Central Hospital.csv\n│   ├── district_weekly_count_data.xlsx\n│   ├── fluH7N9_China_2013.csv\n│   ├── hospital_linelists.xlsx\n│   ├── linelists\n│   │   ├── 20201007linelist.csv\n│   │   ├── case_linelist20201006.csv\n│   │   ├── case_linelist_2020-10-02.csv\n│   │   ├── case_linelist_2020-10-03.csv\n│   │   ├── case_linelist_2020-10-04.csv\n│   │   ├── case_linelist_2020-10-05.csv\n│   │   └── case_linelist_2020-10-08.xlsx\n│   ├── Military Hospital.csv\n│   ├── Missing.csv\n│   ├── Other.csv\n│   ├── Port Hospital.csv\n│   └── St. Mark's Maternity Hospital (SMMH).csv\n├── facility_count_data.rds\n├── flexdashboard\n│   ├── outbreak_dashboard.html\n│   ├── outbreak_dashboard.Rmd\n│   ├── outbreak_dashboard_shiny.Rmd\n│   ├── outbreak_dashboard_test.html\n│   └── outbreak_dashboard_test.Rmd\n├── fluH7N9_China_2013.csv\n├── gis\n│   ├── africa_countries.geo.json\n│   ├── covid_incidence.csv\n│   ├── covid_incidence_map.R\n│   ├── linelist_cleaned_with_adm3.rds\n│   ├── population\n│   │   ├── sle_admpop_adm3_2020.csv\n│   │   └── sle_population_statistics_sierraleone_2020.xlsx\n│   └── shp\n│       ├── README.txt\n│       ├── sle_adm3.CPG\n│       ├── sle_adm3.dbf\n│       ├── sle_adm3.prj\n│       ├── sle_adm3.sbn\n│       ├── sle_adm3.sbx\n│       ├── sle_adm3.shp\n│       ├── sle_adm3.shp.xml\n│       ├── sle_adm3.shx\n│       ├── sle_hf.CPG\n│       ├── sle_hf.dbf\n│       ├── sle_hf.prj\n│       ├── sle_hf.sbn\n│       ├── sle_hf.sbx\n│       ├── sle_hf.shp\n│       └── sle_hf.shx\n├── godata\n│   ├── cases_clean.rds\n│   ├── contacts_clean.rds\n│   ├── followups_clean.rds\n│   └── relationships_clean.rds\n├── likert_data.csv\n├── linelist_cleaned.rds\n├── linelist_cleaned.xlsx\n├── linelist_raw.xlsx\n├── make_evd_dataset-DESKTOP-JIEUMMI.R\n├── make_evd_dataset.R\n├── malaria_app\n│   ├── app.R\n│   ├── data\n│   │   └── facility_count_data.rds\n│   ├── funcs\n│   │   └── plot_epicurve.R\n│   ├── global.R\n│   ├── malaria_app.Rproj\n│   ├── server.R\n│   └── ui.R\n├── malaria_facility_count_data.rds\n├── phylo\n│   ├── sample_data_Shigella_tree.csv\n│   ├── Shigella_subtree_2.nwk\n│   ├── Shigella_subtree_2.txt\n│   └── Shigella_tree.txt\n├── rmarkdown\n│   ├── outbreak_report.docx\n│   ├── outbreak_report.html\n│   ├── outbreak_report.pdf\n│   ├── outbreak_report.pptx\n│   ├── outbreak_report.Rmd\n│   ├── report_tabbed_example.html\n│   └── report_tabbed_example.Rmd\n├── standardization\n│   ├── country_demographics.csv\n│   ├── country_demographics_2.csv\n│   ├── deaths_countryA.csv\n│   ├── deaths_countryB.csv\n│   └── world_standard_population_by_sex.csv\n├── surveys\n│   ├── population.xlsx\n│   ├── survey_data.xlsx\n│   └── survey_dict.xlsx\n└── time_series\n    ├── campylobacter_germany.xlsx\n    └── weather\n        ├── germany_weather2002.nc\n        ├── germany_weather2003.nc\n        ├── germany_weather2004.nc\n        ├── germany_weather2005.nc\n        ├── germany_weather2006.nc\n        ├── germany_weather2007.nc\n        ├── germany_weather2008.nc\n        ├── germany_weather2009.nc\n        ├── germany_weather2010.nc\n        └── germany_weather2011.nc",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Tương tác với thư mục làm việc</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.vn.html#liệt-kê-các-tập-tin-trong-một-thư-mục",
    "href": "new_pages/directories.vn.html#liệt-kê-các-tập-tin-trong-một-thư-mục",
    "title": "45  Tương tác với thư mục làm việc",
    "section": "45.2 Liệt kê các tập tin trong một thư mục",
    "text": "45.2 Liệt kê các tập tin trong một thư mục\nĐể chỉ liệt kê các tên tập tin trong một thư mục, chúng ta có thể sử dụng hàm dir() từ base Ví dụ, lệnh này liệt kê tên các tập tin của các tập tin trong thư mục con có tên “population” trong thư mục “data” của một dự án R. Đường dẫn tập tin tương đối được cung cấp bằng cách sử dụng hàm here() (đọc thêm trong chương Nhập xuất dữ liệu).\n\n# file names\ndir(here(\"data\", \"gis\", \"population\"))\n\n[1] \"sle_admpop_adm3_2020.csv\"                       \n[2] \"sle_population_statistics_sierraleone_2020.xlsx\"\n\n\nĐể liệt kê đường dẫn đầy đủ của các tập tin trong thư mục, chúng ta có thể sử dụng hàm dir_ls() từ package fs. Một cách khác là dùng hàm list.files() trong base R.\n\n# file paths\ndir_ls(here(\"data\", \"gis\", \"population\"))\n\nC:/Users/ngulu864/AppData/Local/Temp/Rtmp8MqjVI/file26d81e9e49d3/data/gis/population/sle_admpop_adm3_2020.csv\nC:/Users/ngulu864/AppData/Local/Temp/Rtmp8MqjVI/file26d81e9e49d3/data/gis/population/sle_population_statistics_sierraleone_2020.xlsx\n\n\nĐể lấy tất cả thông tin chi tiết của mỗi tập tin trong một thư mục (ví dụ: đường dẫn, ngày sửa đổi, .v.v.), chúng ta có thể sử dụng hàm dir_info() của package fs.\nĐiều này có thể đặc biệt hữu ích nếu chúng ta muốn trích xuất thời gian sửa đổi sau cùng của tập tin, ví dụ như nếu chúng ta muốn nhập phiên bản mới nhất của tập tin. Ví dụ cho việc này, xem trong chương Nhập xuất dữ liệu.\n\n# file info\ndir_info(here(\"data\", \"gis\", \"population\"))\n\nSau đây là data frame được trả về. Cuộn qua phải để xem tất cả các cột.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Tương tác với thư mục làm việc</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.vn.html#thông-tin-tệp",
    "href": "new_pages/directories.vn.html#thông-tin-tệp",
    "title": "45  Tương tác với thư mục làm việc",
    "section": "45.3 Thông tin tệp",
    "text": "45.3 Thông tin tệp\nĐể trích xuất thông tin chi tiết của một tập tin cụ thể, chúng ta có thể sử dụng hàme file_info() từ package fs (hoặc file.info() từ base R).\n\nfile_info(here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))\n\n\n\n\n\n\n\nỞ đây, chúng ta sử dụng ký hiệu $ để chỉ rõ kết quả và xuất chỉ mỗi giá trị về thời gian sửa đổi modification_time.\n\nfile_info(here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))$modification_time\n\n[1] \"2024-02-18 14:56:16 CET\"",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Tương tác với thư mục làm việc</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.vn.html#kiểm-tra-sự-tồn-tại",
    "href": "new_pages/directories.vn.html#kiểm-tra-sự-tồn-tại",
    "title": "45  Tương tác với thư mục làm việc",
    "section": "45.4 Kiểm tra sự tồn tại",
    "text": "45.4 Kiểm tra sự tồn tại\n\nĐối tượng R\nBạn có thể sử dụng hàm exists() trong base R để kiểm tra xem một đối tượng R có tồn tại bên trong môi trường R hay không (cung cấp tên đối tượng trong dấu ngoặc kép).\n\nexists(\"linelist\")\n\n[1] FALSE\n\n\nLưu ý rằng một số gói lệnh trong base R sử dụng các tên chung làm tên cho các đối tượng như “data” trong môi trường R, mà kết quả kiểm tra sẽ là TRUE trừ khi chúng ta chỉ rõ inherit = FALSE. Đây là một lý do để không đặt tên cho bộ số liệu của chúng ta là “data”.\n\nexists(\"data\")\n\n[1] TRUE\n\nexists(\"data\", inherit = FALSE)\n\n[1] FALSE\n\n\nNếu bạn đang viết một hàm, bạn nên sử dụng hàm missing() từ base R để kiểm tra xem có một đối số hiện diện hay không, thay vì dùng hàm exists().\n\n\nThư mục\nĐể kiểm tra xem một thư mục có tồn tại không, cung cấp đường dẫn tập tin (và tên tập tin) đến hàm is_dir() của package fs. Cuộn qua bên phải để thấy thông báo TRUE được in ra.\n\nis_dir(here(\"data\"))\n\nC:/Users/ngulu864/AppData/Local/Temp/Rtmp8MqjVI/file26d81e9e49d3/data \n                                                                 TRUE \n\n\nMột cách làm khác là dùng hàm file.exists() từ base R.\n\n\nTệp\nĐể kiểm tra xem một tập tin cụ thể có tồn tại hay không, sử dụng hàm is_file() của package fs. Cuộn qua bên phải để thấy thông báo TRUE được in ra.\n\nis_file(here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))\n\nC:/Users/ngulu864/AppData/Local/Temp/Rtmp8MqjVI/file26d81e9e49d3/data/case_linelists/linelist_cleaned.rds \n                                                                                                     TRUE \n\n\nMột cách làm khác là dùng hàm file.exists() từ base R.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Tương tác với thư mục làm việc</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.vn.html#tạo-mới",
    "href": "new_pages/directories.vn.html#tạo-mới",
    "title": "45  Tương tác với thư mục làm việc",
    "section": "45.5 Tạo mới",
    "text": "45.5 Tạo mới\n\nThư mục\nĐể tạo một thư mục mới, bạn có thể sử dụng hàm dir_create() từ package fs. Nếu thư mục đã tồn tại, thư mục này sẽ không bị ghi đè và không bị trả lại lỗi.\n\ndir_create(here(\"data\", \"test\"))\n\nMột cách làm khác là dùng hàm dir.create() từ base R, mà sẽ hiển thị lỗi nếu thư mục đó đã tồn tại. Ngược lại, dir_create() sẽ không thông báo gì.\n\n\nTệp\nChúng ta có thể tạo một tâp tin (rỗng) bằng hàm file_create() từ package fs. Nếu tập tin này đã tồn tại, nó sẽ không bị ghi đè hoặc thay đổi.\n\nfile_create(here(\"data\", \"test.rds\"))\n\nMột cách làm khác là dùng hàm file.create() từ base R. Nhưng nếu tập tin này đã tồn tại, tùy chọn này sẽ cắt xén tập tin đó. Nếu dùng hàm file_create() tập tin này sẽ được giữ nguyên.\n\n\nTạo nếu không tồn tại\nĐANG XÂY DỰNG",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Tương tác với thư mục làm việc</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.vn.html#xóa",
    "href": "new_pages/directories.vn.html#xóa",
    "title": "45  Tương tác với thư mục làm việc",
    "section": "45.6 Xóa",
    "text": "45.6 Xóa\n\nĐối tượng R\nDùng hàm rm() từ base R để loại bỏ một đối tượng R.\n\n\nThư mục\nDùng hàm dir_delete() từ package fs.\n\n\nTệp\nChúng ta có thể xóa các tệp bằng hàm file_delete() từ package fs.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Tương tác với thư mục làm việc</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.vn.html#chạy-các-tệp-khác",
    "href": "new_pages/directories.vn.html#chạy-các-tệp-khác",
    "title": "45  Tương tác với thư mục làm việc",
    "section": "45.7 Chạy các tệp khác",
    "text": "45.7 Chạy các tệp khác\n\nsource()\nĐể chạy một R script từ một R script khác, bạn có thể sử dụng hàm source() (trong base R).\n\nsource(here(\"scripts\", \"cleaning_scripts\", \"clean_testing_data.R\"))\n\nở phía trên bên phải của tập lệnh. Điều này sẽ thực hiện tập lệnh này nhưng sẽ thực hiện một cách âm thầm (không có kết quả đầu ra trong bảng điều khiển R) trừ khi có chủ ý cụ thể. Xem các ví dụ ở chương [Bảng điều khiển tương tác] về cách sử dụng source() để tương tác với người dùng qua bảng điều khiên R ở chế độ hỏi và trả lời.\n\n\n\n\n\n\n\n\n\n\n\nrender()\nHàm render() là một biến thể của hàm source() mà thường được sử dụng nhất cho các tập lệnh của R markdown. Chúng ta cung cấp input = tập tin R markdown, và cũng vậy output_format = (thường là “html_document”, “pdf_document”, “word_document”, ““)\nXem chương Báo cáo với R Markdown để biết thêm chi tiết. Ngoài ra, bạn có thể xem thêm tài liệu về render() tại đây hoặc bằng cách gõ ?render.\n\n\nChạy các tệp trong một thư mục\nBạn có thể tạo một vòng lặp for và sử dụng nó để source() từng tệp trong một thư mục, đã được nhận dạng bởi hàm dir().\n\nfor(script in dir(here(\"scripts\"), pattern = \".R$\")) {   # for each script name in the R Project's \"scripts\" folder (with .R extension)\n  source(here(\"scripts\", script))                        # source the file with the matching name that exists in the scripts folder\n}\n\nNếu chúng ta chỉ muốn thực hiện một vài scripts, chúng ta có thể xác định chúng bằng tên như sau:\n\nscripts_to_run &lt;- c(\n     \"epicurves.R\",\n     \"demographic_tables.R\",\n     \"survival_curves.R\"\n)\n\nfor(script in scripts_to_run) {\n  source(here(\"scripts\", script))\n}\n\nĐây là một so sánh giữa các hàm của fs và base R.\n\n\nNhập tệp vào một thư mục\nXem chương [Nhập xuất dữ liệu] để nhập và xuất các tập tin riêng lẻ.\nNgoài ra cũng xem thêm chương [Nhập xuất dữ liệu] để biết các phương pháp nhập một cách tự động các tập tin gần đây nhất dựa trên ngày trong tên tập tin hoặc bằng cách xem các thông tin chi tiết của tập tin.\nXem một ví dụ trong chương [Lặp, vòng lặp và danh sách] để thấy rõ cách sử dụng package purrr:\n\nĐể tách một data frame và lưu nó ra dưới dạng nhiều tập tin\n\nTách một data frame và lưu từng phần vào một trang tính riêng biệt trong một tập tin Excel\n\nNhập nhiều tập tin CSV và kết hợp chúng thành một dataframe\n\nNhập một tập tin Excel có nhiều trang tính riêng biệt và kết hợp chúng thành một dataframe",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Tương tác với thư mục làm việc</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.vn.html#base-r",
    "href": "new_pages/directories.vn.html#base-r",
    "title": "45  Tương tác với thư mục làm việc",
    "section": "45.8 base R",
    "text": "45.8 base R\nXem bên dưới các hàm list.files() và dir(), thực hiện cùng một thao tác liệt kê các tập tin trong một thư mục cụ thể. Chúng ta có thể cụ thể cho đối số ignore.case = hoặc cụ thể một pattern để tìm kiếm.\n\nlist.files(path = here(\"data\"))\n\nlist.files(path = here(\"data\"), pattern = \".csv\")\n# dir(path = here(\"data\"), pattern = \".csv\")\n\nlist.files(path = here(\"data\"), pattern = \"evd\", ignore.case = TRUE)\n\nNếu một tập tin hiện tại đang “mở”, nó sẽ hiện thị trong thư mục với dấu ngã phía trước, chẳng hạn như “~$hospital_linelists.xlsx”.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Tương tác với thư mục làm việc</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.vn.html#nguồn",
    "href": "new_pages/directories.vn.html#nguồn",
    "title": "45  Tương tác với thư mục làm việc",
    "section": "45.9 Nguồn",
    "text": "45.9 Nguồn\nhttps://cran.r-project.org/web/packages/fs/vignettes/function-comparisons.html",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Tương tác với thư mục làm việc</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.vn.html",
    "href": "new_pages/collaboration.vn.html",
    "title": "46  Version control với Git và Github",
    "section": "",
    "text": "46.1 Git là gì?\nGit là một phần mềm kiểm soát phiên bản cho phép theo dõi các thay đổi trong một thư mục. Nó có thể được sử dụng như tùy chọn “track change” trong Word, LibreOffice hoặc Google docs, nhưng dành cho tất cả các loại tệp. Nó là một trong những công cụ mạnh mẽ nhất và được sử dụng nhiều nhất để kiểm soát phiên bản.\nTại sao tôi chưa bao giờ nghe nói về Git? - Trong khi hầu hết những nhà lập trình thường xuyên phải học cách sử dụng phần mềm để kiểm soát phiên bản (Git, Mercurial, Subversion hoặc những phần mềm khác), ít người trong chúng ta xuất thân từ các ngành định lượng được dạy các kỹ năng này. Do đó, hầu hết các nhà dịch tễ học không bao giờ nghe nói về nó trong các nghiên cứu của họ, và phải tìm hiểu nó một cách nhanh chóng.\nChờ đã, tôi có nghe nói về Github, chúng có giống nhau không? - Không hoàn toàn, nhưng bạn thường sử dụng chúng cùng nhau và chúng tôi sẽ hướng dẫn bạn cách thực hiện. Nói ngắn gọn như sau:\nVì vậy, bạn có thể sử dụng ứng dụng/giao diện Github Desktop, sử dụng Git trong nền để quản lý các tệp của bạn, cả cục bộ trên máy tính của bạn và từ xa trên máy chủ Github.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Version control với Git và Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.vn.html#git-là-gì",
    "href": "new_pages/collaboration.vn.html#git-là-gì",
    "title": "46  Version control với Git và Github",
    "section": "",
    "text": "Git là hệ thống kiểm soát phiên bản, là một phần của phần mềm. Bạn có thể tải phần mềm để sử dụng trên máy tính của mình hoặc để đồng bộ hóa một thư mục với một máy chủ trên web. Theo mặc định, bạn sử dụng terminal để đưa ra hướng dẫn cho Git thông qua các dòng lệnh.\nBạn có thể sử dụng ứng dụng người dùng/giao diện Git để không phải gõ lệnh và thực hiện các hành động tương tự (ít nhất là đối với những hành động đơn giản, rất thường dùng).\nNếu bạn muốn lưu trữ thư mục của mình trong một host website để cùng làm việc với những người khác, bạn có thể tạo một tài khoản tại Github, Gitlab, Bitbucket hoặc những nền tảng khác.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Version control với Git và Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.vn.html#tại-sao-lại-sử-dụng-combo-git-và-github",
    "href": "new_pages/collaboration.vn.html#tại-sao-lại-sử-dụng-combo-git-và-github",
    "title": "46  Version control với Git và Github",
    "section": "46.2 Tại sao lại sử dụng combo Git và Github?",
    "text": "46.2 Tại sao lại sử dụng combo Git và Github?\nSử dụng Git để:\n\nLưu trữ các phiên bản của tài liệu với sự ghi nhận các thay đổi để bạn có thể dễ dàng chuyển lại về bất kỳ trạng thái nào trước đó\nCó các nhánh (branches) song song, tức là các phiên bản đang phát triển/“đang làm việc” hoạt động có cấu trúc để tích hợp các thay đổi sau khi đánh giá\n\nĐiều này có thể được thực hiện cục bộ trên máy tính của bạn, ngay cả khi bạn không cộng tác với những người khác. Bạn đã bao giờ từng:\n\nhối tiếc vì đã xóa một đoạn mã, chỉ để nhận ra hai tháng sau bạn thực sự cần nó?\nquay lại một dự án đã bị tạm dừng và cố gắng nhớ liệu bạn đã thực hiện một sửa đổi gì đó phức tạp ở một trong những mô hình?\ncó một tệp model_1.R và một tệp khác model_1_test.R và một tệp model_1_not_working.R để thử mọi thứ?\ncó một tệp report.Rmd, tệp report_full.Rmd, tệp report_true_final.Rmd, tệp report_final_20210304.Rmd, tệp report_final_20210402.Rmd và khó chịu với kỹ năng lưu trữ của bạn?\n\nGit sẽ giúp bạn giải quyết tất cả vấn đề trên, và đây cũng là những thứ rất đáng để học.\nTuy nhiên, nó thậm chí còn trở nên mạnh mẽ hơn khi được sử dụng với kho lưu trữ trực tuyến chẳng hạn như Github để hỗ trợ các dự án hợp tác. Điều này tạo điều kiện cho việc:\n\nCộng tác: những người khác có thể đánh giá, nhận xét và chấp nhận/từ chối các thay đổi\n\nChia sẻ mã, dữ liệu và kết quả đầu ra của bạn và mời phản hồi từ công chúng (hoặc riêng tư, với nhóm của bạn) và tránh:\n“Rất tiếc, tôi đã quên gửi phiên bản cuối cùng và bây giờ bạn cần làm lại tệp mới này trong hai ngày làm việc”\nMina, Henry và Oumar đều làm việc cùng lúc trên một script và cần phải hợp nhất các thay đổi của họ theo cách thủ công\nHai người cố gắng sửa đổi cùng một tệp trên Dropbox và Sharepoint và điều này tạo ra một lỗi đồng bộ hóa.\n\n\nĐiều này nghe có vẻ phức tạp, tôi không phải là một lập trình viên\nBạn hoàn toàn có thể. Ví dụ về cách sử dụng nâng cao có thể khá đáng sợ. Tuy nhiên, giống với như R, hoặc thậm chí là Excel, bạn không cần phải trở thành một chuyên gia để tận dụng lợi ích của công cụ. Học một số nhỏ các hàm và khái niệm cho phép bạn theo dõi các thay đổi của mình, đồng bộ hóa các tệp của bạn trên kho lưu trữ trực tuyến và cộng tác với đồng nghiệp của bạn với thời gian ngắn.\nDo tiến trình học tập, khi bạn cần hoàn thiện một công viêc trong trường hợp khẩn cấp, đó có thể không phải là thời điểm tốt nhất để tìm hiểu các công cụ này. Nhưng việc học có thể đạt được theo từng bước. Một khi bạn có được một vài khái niệm, quy trình làm việc của bạn có thể khá hiệu quả và nhanh chóng. Nếu bạn chưa làm việc trong một dự án cộng tác với mọi người và buộc phải sử dụng qua Git, đó thực sự là thời điểm tốt để có được sự tự tin khi sử dụng Git trước khi bắt tay vào cộng tác với người khác.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Version control với Git và Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.vn.html#cài-đặt",
    "href": "new_pages/collaboration.vn.html#cài-đặt",
    "title": "46  Version control với Git và Github",
    "section": "46.3 Cài đặt",
    "text": "46.3 Cài đặt\n\nCài đặt Git\nGit là công cụ phía sau hậu trường trên máy tính của bạn, theo dõi các thay đổi, các nhánh (phiên bản), hợp nhất và hoàn nguyên. Đầu tiên bạn phải cài đặt Git từ đường link sau https://git-scm.com/downloads.\n\n\nCài đặt giao diện (tùy chọn nhưng được khuyến nghị)\nGit có ngôn ngữ lệnh riêng, có thể được nhập vào terminal. Tuy nhiên, có nhiều phần mềm/giao diện và với tư cách không phải là một lập trình viên, trong quá trình sử dụng hàng ngày, bạn sẽ hiếm khi cần tương tác trực tiếp với Git và giao diện người dùng thường cung cấp các công cụ trực quan đẹp mắt để sửa đổi tệp hoặc các nhánh.\nCó nhiều tùy chọn, trên tất cả các hệ điều hành, từ thân thiện với người mới bắt đầu đến những tùy chọn phức tạp hơn. Các tùy chọn tốt cho người mới bắt đầu bao gồm cửa sổ RStudio Git và Github Desktop, mà chúng tôi sẽ giới thiệu trong chương này. Các tùy chọn trung gian (tiện ích hơn nhưng phức tạp hơn) bao gồm Source Tree, Gitkracken, Smart Git và những tùy chọn khác.\nGiải thích ngắn gọn về Git clients ở đây.\nLưu ý: vì thực tế tất cả các giao diện đều sử dụng Git nội bộ, bạn có thể thử một số trong đó, chuyển từ dạng này sang dạng khác trong một dự án nhất định, sử dụng console đối với một hành động mà giao diện của bạn không hỗ trợ hoặc thậm chí thực hiện bất kỳ hành động nào trực tuyến trên Github.\nNhư đã lưu ý bên dưới, đôi khi bạn có thể phải viết các lệnh Git trong termial chẳng hạn như cửa sổ Ternmial trong RStudio (một tab liền kề với R Console) hoặc terminal của Git Bash.\n\n\nTài khoản Github\nĐăng ký tài khoản miễn phí tại github.com.\nBạn có thể được đề nghị thiết lập xác thực hai yếu tố với một ứng dụng trên điện thoại của bạn. Đọc thêm trong tài liệu trợ giúp của Github .\nNếu bạn sử dụng Github Desktop, bạn có thể nhập thông tin đăng nhập Gitub của mình sau khi cài đặt các bước sau. Nếu bạn không biết, thông tin đăng nhập sẽ được hỏi sau khi bạn cố gắng clone một dự án từ Github.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Version control với Git và Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.vn.html#thuật-ngữ-khái-niệm-và-các-hàm-cơ-bản",
    "href": "new_pages/collaboration.vn.html#thuật-ngữ-khái-niệm-và-các-hàm-cơ-bản",
    "title": "46  Version control với Git và Github",
    "section": "46.4 Thuật ngữ, khái niệm và các hàm cơ bản",
    "text": "46.4 Thuật ngữ, khái niệm và các hàm cơ bản\nGiống như khi học R, bạn cần nhớ một chút thuật ngữ để hiểu Git. Đây là những điều cơ bản giúp bạn làm việc / hướng dẫn tương tác. Ở phần tiếp theo, chúng tôi sẽ chỉ ra cách sử dụng các giao diện, nhưng tốt hơn là bạn nên có một số thuật ngữ và khái niệm trong đầu, để xây dựng mô hình tinh thần của bạn, và vì bạn sẽ cần chúng khi sử dụng các giao diện.\n\nKho lưu trữ (Repository)\nKho lưu trữ Git (“repo”) là một thư mục chứa tất cả các thư mục con và tệp cho dự án của bạn (dữ liệu, mã code, hình ảnh, v.v.) và lịch sử sửa đổi của chúng. Khi bạn bắt đầu theo dõi những thay đổi trong kho lưu trữ, Git sẽ tạo một thư mục ẩn chứa tất cả các thông tin theo dõi. Một kho lưu trữ Git điển hình là thư mục Dự án R của bạn (xem thêm chương Dự án R) để biết thêm chi tiết).\nChúng tôi sẽ hướng dẫn bạn cách tạo (initialize) một kho lưu trữ Git từ Github, Github Desktop hoặc Rstudio trong phần tiếp theo của chương này.\n\n\nCommits\nMột commit là một ảnh chụp nhanh của dự án tại một thời điểm xác định. Khi bạn thực hiện một thay đổi đối với dự án, bạn sẽ tạo một commit mới để theo dõi những thay đổi (the delta) được thực hiện đối với các tập tin của bạn. Ví dụ: bạn đã chỉnh sửa một vài dòng lệnh và cập nhật bộ dữ liệu liên quan. Sau khi các thay đổi của bạn được lưu, bạn có đóng gói các thay đổi cùng nhau tạo thành một “commit”.\nMỗi commit có một ID duy nhất (một hash). Đối với mục tiêu kiểm soát phiên bản, bạn có thể khôi phục dự án của mình theo thời gian dựa trên các commit, vì vậy tốt nhất là bạn nên tạo các commit tương đối nhỏ và mạch lạc. Bạn cũng sẽ đính kèm một bản tóm tắt mô tả về những thay đổi được gọi là “commit message”.\nTổ chức các thay đổi (Staged change)? Tổ chức các thay đổi nghĩa là thêm chúng vào một staging area - khu vực sân khẩu để chuẩn bị cho lần commit tiếp theo. Ý tưởng là bạn có thể quyết định rõ ràng những thay đổi nào sẽ bao gồm trong một commit cụ thể. Ví dụ, nếu bạn đã làm việc với mô hình trong một script và sau đó làm việc với một biểu đồ trong một script khác, sẽ hợp lý nếu có hai commit khác nhau (sẽ dễ dàng hơn trong trường hợp bạn muốn khôi phục các thay đổi trên biểu đồ nhưng không phải trên mô hình).\n\n\nBranches\nMột nhánh (branch) đại diện cho một con đường độc lập chứa các thay đổi trong kho lưu trữ (repo) của bạn. Nó là một phiên bản song song của các tệp dự án của bạn.\nCác nhánh rất hữu ích để thử nghiệm các thay đổi trước khi chúng được tích hợp vào nhánh chính (main branch), thường là phiên bản chính/cuối cùng/“live” của dự án của bạn. Khi bạn hoàn thành việc thử nghiệm trên một nhánh, bạn có thể hợp nhất những thay đổi đó vào nhánh chính của bạn, hoặc xóa những thay đổi không thành công.\nLưu ý: bạn không cần phải cộng tác với người khác để sử dụng các nhánh, cũng như không cần phải có một kho lưu trữ trực tuyến từ xa.\n\n\nKho lưu trữ cục bộ và từ xa\nClone (Nhân bản) là tạo một bản sao của kho lưu trữ Git ở một nơi khác.\nVí dụ: bạn có thể clone một kho lưu trữ trực tuyến từ Github xuống máy tính của bạn hoặc bắt đầu với một kho lưu trữ cục bộ (local repository) và clone nó trực tuyến lên Github.\nKhi bạn đã clone một kho lưu trữ, các tệp dự án tồn tại ở hai nơi:\n\nkho lưu trữ CỤC BỘ (LOCAL) trên máy tính của bạn. Đây là nơi bạn thực hiện các thay đổi thực tế đối với các tệp/code.\nTỪ XA (REMOTE), kho lưu trữ trực tuyến: các phiên bản của tệp dự án trên kho lưu trữ Github (hoặc trên bất kỳ nền tảng nào khác).\n\nĐể đồng bộ hóa các kho này, chúng ta sẽ sử dụng nhiều hàm hơn. Thật vậy, không giống như Sharepoint, Dropbox hoặc các phần mềm đồng bộ hóa khác, Git không thực hiện tự động cập nhật kho lưu trữ cục bộ của bạn dựa trên những gì có trên cloud, hoặc ngược lại. Tuy nhiên, bạn có thể chọn thời điểm và cách thức đồng bộ hóa.\n\ngit fetch tải xuống các thay đổi mới từ kho lưu trữ từ xa nhưng không làm thay đổi kho lưu trữ cục bộ của bạn. Hãy coi như nó giống như việc kiểm tra trạng thái của kho lưu trữ từ xa.\ngit pull tải xuống các thay đổi mới từ kho lưu trữ từ xa và cập nhật kho lưu trữ cục bộ của bạn.\nKhi bạn đã thực hiện một hoặc một số commit cục bộ, bạn có thể git push để đẩy các commit đến kho lưu trữ từ xa. Điều này giúp gửi các thay đổi của bạn tới Github để người khác có thể xem và kéo về (pull) nếu họ muốn.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Version control với Git và Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.vn.html#bắt-đầu-tạo-một-kho-lưu-trữ-mới",
    "href": "new_pages/collaboration.vn.html#bắt-đầu-tạo-một-kho-lưu-trữ-mới",
    "title": "46  Version control với Git và Github",
    "section": "46.5 Bắt đầu: tạo một kho lưu trữ mới",
    "text": "46.5 Bắt đầu: tạo một kho lưu trữ mới\nCó nhiều cách để tạo kho lưu trữ mới. Bạn có thể làm điều đó từ R console, từ Github, hoặc thông qua giao diện người dùng.\nHai cách tiếp cận thường dùng để tạo một kho lưu trữ là:\n\nTạo một Dự án R mới từ kho lưu trữ Github hiện có hoặc mới (ưu tiên cho người mới bắt đầu), hoặc\nTạo kho lưu trữ Github cho một dự án R hiện có\n\n\nCác tệp khởi động\nKhi bạn tạo một kho lưu trữ mới, bạn có thể tùy chọn tạo tất cả các tệp bên dưới hoặc bạn có thể thêm chúng vào kho lưu trữ của mình ở giai đoạn sau. Chúng thường nằm trong thư mục “gốc” của kho lưu trữ.\n\nTệp README là tệp mà người khác có thể đọc để hiểu tại sao dự án của bạn tồn tại và những điều họ nên biết để sử dụng nó. Tệp này ban đầu sẽ trống, nhưng bạn có thể hoàn thiện nó sau đó.\nTệp .gitignore là tệp văn bản trong đó mỗi dòng sẽ chứa các thư mục hoặc tệp mà Git nên bỏ qua (không theo dõi các thay đổi). Đọc thêm về điều này và xem các ví dụ tại đây.\nBạn có thể chọn license cho dự án của mình, để những người khác biết họ có thể sử dụng hoặc tái lập dự án của bạn trong những điều kiện nào. Để biết thêm thông tin, hãy xem Creative Commons licenses.\n\n\n\nTạo một kho lưu trữ mới trong Github\nĐể tạo một kho lưu trữ mới, hãy đăng nhập vào Github và tìm một nút màu xanh lục để tạo một kho lưu trữ mới. Một kho lưu trữ trống được tạo ra và có thể được clone xuống máy tính của bạn (xem phần tiếp theo để biết thêm chi tiết).\n\n\n\n\n\n\n\n\n\nBạn phải chọn nếu bạn muốn kho lưu trữ của mình ở dạng công khai (hiển thị với mọi người trên internet) hoặc riêng tư (chỉ hiển thị với những người trong sự cho phép của bạn). Điều này có ý nghĩa quan trọng nếu dữ liệu của bạn nhạy cảm. Nếu kho lưu trữ của bạn là riêng tư, bạn sẽ gặp phải một số giới hạn trong các trường hợp đặc biệt, chẳng hạn như nếu bạn đang sử dụng actions trong Github để tự động chạy code trên cloud.\n\n\nClone từ kho lưu trữ Github\nBạn có thể clone một kho lưu trữ Github có sẵn để tạo một dự án R mới cục bộ trên máy tính của bạn.\nKho lưu trữ Github có thể là một kho lưu trữ đã tồn tại và chứa nội dung, hoặc có thể là một kho lưu trữ trống mà bạn vừa tạo. Trong trường hợp thứ hai, về cơ bản bạn đang tạo một repo Github và dự án R cục bộ trên máy tính của bạn cùng một lúc (xem hướng dẫn ở trên)\nLưu ý: nếu bạn không có quyền đóng góp trên kho lưu trữ Github, trước tiên bạn có thể fork kho lưu trữ đó vào hồ sơ riêng của bạn, và sau đó tiếp tục với các hành động khác. Forking được giải thích ở phần cuối của chương này nhưng chúng tôi khuyên bạn nên đọc các phần khác trước.\nBước 1: Điều hướng trong Github đến kho lưu trữ, nhấp vào nút màu xanh lá cây “Code” và sao chép HTTPS clone URL (xem hình ảnh minh họa bên dưới)\n\n\n\n\n\n\n\n\n\nBước tiếp theo có thể được thực hiện trong bất kỳ giao diện người dùng nào. Chúng tôi sẽ minh họa bằng Rstudio và Github desktop.\n\nTrong Rstudio\nTrong RStudio, để bắt đầu một dự án R mới, bạn cần nhấp vào File &gt; New Project &gt; Version Control &gt; Git\n\nKhi được yêu cầu nhập “Repository URL”, hãy dán URL HTTPS từ Github \nGán cho dự án R một cái tên ngắn gọn, đầy đủ thông tin\n\nChọn nơi Dự án R mới sẽ được lưu cục bộ trên máy tính của bạn\n\nChọn “Open in new session” và nhấp vào mục “Create project”\n\nBạn hiện đang trong một dự án RStudio mới, cục bộ trên máy tính của bạn, là một bản sao của kho lưu trữ online trên Github. Dự án cục bộ này và kho lưu trữ Github hiện đã được liên kết.\n\n\nTrong Github Desktop\n\nNhấn vào File &gt; Clone a repository\nChọn tab URL\nDán đường dẫn HTTPS URL từ Github vào hộp đầu tiên\nChọn thư mục mà bạn muốn lưu kho lưu trữ cục bộ của mình\nNhấn vào “CLONE”\n\n\n\n\n\n\n\n\n\n\n\n\n\nTạo một Github repo mới từ dự án R đã có sẵn\nMột kịch bản khác là bạn có một dự án R đã tồn tại với các nội dung và bạn muốn tạo một kho lưu trữ Github cho nó.\n\nTạo một kho lưu trữ Github mới, trống cho dự án (Xem hướng dẫn ở trên)\n\nClone cục bộ kho lưu trữ này (Xem hướng dẫn về HTTPS ở trên)\n\nSao chép tất cả nội dung từ dự án R đã có từ trước của bạn (mã, dữ liệu, v.v.) vào kho lưu trữ trống, cục bộ, mới này (ví dụ: sử dụng sao chép và dán).\n\nMở dự án mới của bạn trong RStudio và chuyển đến cửa sổ Git. Các tệp mới sẽ được đăng ký dưới dạng tệp có thay đổi, và hiện được theo dõi bởi Git. Do đó, bạn có thể đóng gói những thay đổi này dưới dạng một commit và push chúng lên Github. Sau khi được push, kho lưu trữ trên Github của bạn sẽ theo dõi sự thay đổi của tất cả các tệp.\n\nXem phần quy trình làm việc Github bên dưới để biết chi tiết về quy trình này.\n\n\nBây giờ, nó trông như thế nào?\n\nTrong RStudio\nKhi bạn đã clone kho lưu trữ Github sang một dự án R mới, bây giờ bạn sẽ thấy trong RStudio có một tab “Git”. Tab này xuất hiện bên cạnh cửa sổ RStudio Environment của bạn:\n\n\n\n\n\n\n\n\n\nLưu ý các nút được khoanh tròn trong hình trên, vì chúng sẽ được giới thiệu dưới đây (từ trái sang phải):\n\nNút để commit những tệp có thay đổi đã được lưu tới nhánh cục bộ “local branch” (sẽ mở ra một cửa sổ mới)\nMũi lên màu xanh lam hướng lên để pull (cập nhật phiên bản của nhánh cục bộ với bất kỳ các thay đổi được thực hiện trên phiên bản từ xa/Github của nhánh đó)\nMũi tên màu xanh lục hướng xuống push (gửi bất kỳ các commits/thay đổi nào trong phiên bản cục bộ lên phiên bản từ xa/Github của nhánh đó)\nTab Git trong RStudio\nNút để tạo một nhánh MỚI bằng cách sử dụng bất kỳ nhánh cục bộ nào được hiển thị bên phải làm cơ sở. Bạn hầu như luôn muốn tách khỏi nhánh chính (sau khi bạn pull lần đầu tiên để cập nhật nhánh chính)\nNhánh bạn hiện đang làm việc\nNhững thay đổi bạn đã thực hiện đối với code hoặc các tệp khác sẽ xuất hiện bên dưới\n\n\n\nTrong Github Desktop\nGithub Desktop là một ứng dụng độc lập trong máy tính cho phép bạn quản lý tất cả các kho lưu trữ của bạn. Khi bạn mở nó, giao diện của nó cho phép bạn chọn kho lưu trữ bạn muốn làm việc và sau đó thực hiện các thao tác Git cơ bản tại đây.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Version control với Git và Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.vn.html#quy-trình-làm-việc-với-git-github",
    "href": "new_pages/collaboration.vn.html#quy-trình-làm-việc-với-git-github",
    "title": "46  Version control với Git và Github",
    "section": "46.6 Quy trình làm việc với Git + Github",
    "text": "46.6 Quy trình làm việc với Git + Github\n\nTổng quan về quy trình\nKhi bạn đã hoàn tất các bước thiết lập (được mô tả ở trên), bạn sẽ có một Github repo được kết nối (cloned) với một dự án R cục bộ. Nhánh chính (được tạo theo mặc định) còn được gọi là phiên bản “live” của tất cả các tệp tin. Khi bạn muốn sửa đổi, một thực hành tốt đó là tạo một nhánh mới từ nhánh chính (giống như “Tạo một bản sao”). Đây là quy trình làm việc điển hình trong Git vì việc tạo một nhánh là dễ dàng và nhanh chóng.\nQuy trình làm việc điển hình như sau:\n\nĐảm bảo rằng kho lưu trữ cục bộ của bạn được cập nhật, hãy cập nhật nó nếu nó chưa phải bản mới nhất\nChuyển đến nhánh mà bạn đã làm việc trước đây hoặc tạo một nhánh làm việc mới để thử một số thứ\nLàm việc với các tệp trực tiếp trên máy tính của bạn, tạo một hoặc nhiều commit với nhánh làm việc này\nCập nhật phiên bản từ xa của nhánh làm việc với các thay đổi của bạn (push)\nKhi bạn hài lòng với nhánh làm việc này, bạn có thể hợp nhất phiên bản trực tuyến vào nhánh “chính” trực tuyến để chuyển tiếp các thay đổi\n\nCác thành viên khác trong nhóm có thể đang làm điều tương tự với các nhánh của riêng họ, hoặc cũng có thể đóng góp các commits vào nhánh làm việc của bạn.\nChúng ta sẽ đi qua một cách chi tiết hơn từng bước của quá trình trên ở phần sau. Đây là một giản đồ mà chúng tôi đã phát triển - nó ở định dạng bảng hai chiều vì vậy nó sẽ giúp các nhà dịch tễ học dễ dàng hiểu được.\n\n\n\n\n\n\n\n\n\nDây là một sơ đồ khác.\nLưu ý: cho đến gần đây, thuật ngữ nhánh “master” vẫn được sử dụng, nhưng bây giờ thuật ngữ này được gọi là nhánh “main (chính)”.\n\n\n\n\n\n\n\n\n\nNguồn hình ảnh",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Version control với Git và Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.vn.html#tạo-một-nhánh-mới",
    "href": "new_pages/collaboration.vn.html#tạo-một-nhánh-mới",
    "title": "46  Version control với Git và Github",
    "section": "46.7 Tạo một nhánh mới",
    "text": "46.7 Tạo một nhánh mới\nKhi bạn chọn một nhánh để làm việc, Git đặt lại trạng thái thư mục làm việc của bạn trở lại lần cuối cùng bạn ở trên nhánh này.\n\nTrong cửa sổ Rstudio Git\nĐảm bảo bạn đang ở trong nhánh “chính”, sau đó nhấp vào biểu tượng màu tím để tạo một nhánh mới (xem hình trên).\n\nBạn sẽ được yêu cầu đặt tên nhánh của mình trong một từ (có thể sử dụng dấu gạch dưới nếu cần).\nBạn sẽ thấy rằng bạn vẫn đang ở trong cùng một dự án R, nhưng bạn không còn làm việc trên nhánh “chính” nữa.\nSau khi được tạo, nhánh mới cũng sẽ xuất hiện trên trang web Github dưới dạng một nhánh.\n\nBạn có thể xem các nhánh tại cửa sổ Git trong Rstudio bằng cách nhấp vào “History”\n\n\n\n\n\n\n\n\n\n\n\nTrong Github Desktop\nQuy trình tương tự bên trên, bạn được yêu cầu đặt tên cho nhánh làm việc của mình. Sau đó, bạn sẽ được yeu cầu “Publish your branch to Github - Xuất bản nhánh làm việc của bạn lên Github” để làm cho nhánh mới cũng xuất hiện trong kho lưu trữ từ xa.\n\n\n\n\n\n\n\n\n\n\n\nTrong console\nĐiều thực sự đang xảy ra ẩn phía sau là bạn tạo ra một nhánh với lệnh git branch, sau đó chuyển đến nhánh đó bằng lệnh git checkout (vd: nói cho Git biết rằng các commit tiếp theo của bạn sẽ xảy ra trên nhánh đó). Từ kho lưu trữ git của bạn, hãy gõ:\n\ngit branch my-new-branch  # Create the new branch branch\ngit checkout my-new-branch # Go to the branch\ngit checkout -b my-new-branch # Both at once (shortcut)\n\nĐể biết thêm thông tin về cách sử dụng bảng console, hãy xem phần Lệnh Git ở cuối.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Version control với Git và Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.vn.html#commit-các-thay-đổi",
    "href": "new_pages/collaboration.vn.html#commit-các-thay-đổi",
    "title": "46  Version control với Git và Github",
    "section": "46.8 Commit các thay đổi",
    "text": "46.8 Commit các thay đổi\nGiờ đây, bạn có thể chỉnh sửa code, thêm tệp mới, cập nhật bộ dữ liệu, v.v.\nMọi thay đổi của bạn đều được theo dõi, sau khi tệp tương ứng được lưu. Các tệp đã thay đổi sẽ xuất hiện trong tab RStudio Git, trong Github Desktop hoặc sử dụng lệnh git status trong terminal (xem bên dưới).\nBất cứ khi nào bạn thực hiện các thay đổi quan trọng (ví dụ: thêm hoặc cập nhật một phần của code), bạn hãy tạm dừng việc thay đổi và commit những thay đổi đó. Hãy tưởng tượng mỗi một commit là một “lô (batch)” của các thay đổi cùng hướng tới một mục đích chung. Bạn sẽ luôn có thể tiếp tục sửa đổi tệp sau khi đã commit các thay đổi trên đó.\nLời khuyên về cách commit: nói chung, tốt hơn là bạn nên tạo các commit nhỏ để có thể dễ dàng khôi phục các chỉnh sửa nếu có vấn đề phát sinh, sau đó commit chúng cùng nhau. Để làm được điều này, bạn sẽ cần phải commit thường xuyên. Khi mới bắt đầu, bạn có thể sẽ quên commit thường xuyên, nhưng sau đó thói quen commit thường xuyên bắt đầu xuất hiện.\n\nTrong Rstudio\nVí dụ dưới đây cho thấy rằng, kể từ lần commit cuối cùng, tập lệnh R Markdown “collab.Rmd” đã thay đổi, và một số hình ảnh PNG đã được thêm vào.\n\n\n\n\n\n\n\n\n\nBạn có thể tự hỏi những hình vuông màu vàng, xanh lam, xanh lá cây và đỏ bên cạnh tên tệp có ý nghĩa gì. Đây là ảnh chụp nhanh từ RStudio cheatsheet trong đó giải thích ý nghĩa của chúng. Lưu ý rằng các thay đổi với màu vàng “?” có thể hoặc là staged, commited và pushed.\n\n\n\n\n\n\n\n\n\n\nNhấn vào nút “Commit” trong cửa sổ Git, nút này sẽ mở ra một cửa sổ mới (hiển thị bên dưới)\nNhấp vào tên tệp trong hộp phía trên bên trái\nXem lại những thay đổi bạn đã thực hiện đối với tệp đó (được đánh dấu màu xanh lá cây hoặc đỏ)\n“Trình bày - Stage” các tệp, sẽ bao gồm những thay đổi có trong commit. Bạn có thể thực hiện việc này bằng cách chọn hộp bên cạnh tên tệp. Ngoài ra, bạn có thể đánh dấu nhiều tên tệp và sau đó nhấp vào “Stage”\nViết một thông điệp commit mô tả ngắn gọn những thay đổi (bắt buộc)\nẤn vào nút “Commit”. Một hộp thoại xuất hiện cho biết lệnh commit được thực hiện thành công hoặc một thông báo về thực hiện lỗi.\n\nGiờ đây, bạn có thể thực hiện nhiều thay đổi hơn và nhiều lần commit hơn, bao nhiêu lần tùy ý\n\n\n\n\n\n\n\n\n\n\n\nTrong Github Desktop\nBạn có thể xem danh sách các tệp đã được thay đổi ở bên trái. Nếu như bạn chọn một tệp văn bản, bạn sẽ thấy một bản tóm tắt về các sửa đổi đã được thực hiện trong ngăn bên phải (chế độ xem sẽ không hoạt động trên các tệp phức tạp hơn như .docs hoặc .xlsx).\nĐể stage các thay đổi, chỉ cần đánh dấu vào ô nhỏ gần tên tệp. Khi bạn đã chọn các tệp bạn muốn thêm vào lần commit này, hãy đặt một cái tên cho commit và mô tả (tùy chọn) và sau đó nhấp vào nút commit.\n\n\n\n\n\n\n\n\n\n\n\nTrong console\nHai hàm thực sự thực hiện các thao tác trên là git add để chọn/stage tệp và git commit để thực hiện commit.\n\ngit status # see the changes \n\ngit add new_pages/collaboration.Rmd  # select files to commit (= stage the changes)\n\ngit commit -m \"Describe commit from Github Desktop\" # commit the changes with a message\n\ngit log  # view information on past commits\n\n\n\nThêm vào một commit trước đó\nĐiều gì sẽ xảy ra nếu bạn đã commit một số thay đổi, tiếp tục làm việc và nhận ra rằng bạn đã thực hiện các thay đổi mà lẽ ra “thuộc về” lần commit trước đó (theo ý kiến của bạn). Đừng sợ! Bạn có thể nối những thay đổi này vào lần commit trước đó của mình.\nTrong Rstudio, nó sẽ khá rõ ràng vì có một hộp kiểm “Thêm vào commit trước - Amend previous commit” trên cùng dòng với nút COMMIT.\nVì một số lý do không rõ ràng, chức năng này không có sẵn trong Github Desktop, nhưng vẫn có cách (khó hiểu về mặt khái niệm nhưng dễ dàng). Nếu bạn đã commit nhưng chưa đẩy các thay đổi của bạn lên nhánh chính, nút “UNDO” xuất hiện ngay dưới nút COMMIT. Nhấp vào nó và nó sẽ khôi phục commit của bạn (nhưng vẫn giữ các staged files và thông điệp commit). Lưu các thay đổi của bạn, thêm tệp mới vào commit nếu cần và commit lại.\nTrong cửa số console:\n\ngit add [YOUR FILES] # Stage your new changes\n\ngit commit --amend  # Amend the previous commit\n\ngit commit --amend -m \"An updated commit message\"  # Amend the previous commit AND update the commit message\n\nLưu ý: hãy suy nghĩ trước khi sửa đổi các commit đã được công khai và chia sẻ với các cộng tác viên của bạn.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Version control với Git và Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.vn.html#pull-và-push-các-thay-đổi-lên-github",
    "href": "new_pages/collaboration.vn.html#pull-và-push-các-thay-đổi-lên-github",
    "title": "46  Version control với Git và Github",
    "section": "46.9 Pull và push các thay đổi lên Github",
    "text": "46.9 Pull và push các thay đổi lên Github\n“PULL trước, PUSH sau”\nMột thực hành tốt đố là fetch và pull trước khi bạn bắt đầu làm việc dự án của bạn, để cập nhật phiên bản nhánh trên máy tính của bạn với bất kỳ thay đổi nào đã được thực hiện trên nhanh đó ở phiên bản từ xa/Github.\nĐừng ngần ngại PULL thường xuyên. Luôn nhớ pull trước khi push.\nKhi các thay đổi của bạn được thực hiện và được commit, cũng như bạn hài lòng với chúng, bạn có thể push (đẩy) commit của mình lên sang phiên bản từ xa/Github nhánh làm việc của bạn.\nKiểm tra và lặp lại trong khi bạn đang làm việc trên kho lưu trữ.\nLưu ý: việc khôi phục các thay đổi đã được commit nhưng chưa push lên Github (tức là vẫn còn ở local) dễ dàng hơn nhiều so với các commit đã được push lên kho lưu trữ từ xa (và có thể đã được ai đó pull xuống), vì vậy tốt nhất là bạn nên push những thay đổi khi bạn hoàn thành nó và giới thiệu về các thay đổi mà bạn đã thực hiện.\n\nTrong Rstudio\nPULL - Đầu tiên, ấn vào biểu tượng “Pull” (mũi tên hướng xuống) để fetch và pull cùng một lúc.\nPUSH - Ấn vào icon màu xanh “Push” (mũi tên hướng lên). Bạn có thể được yêu cầu nhập tên người dùng và mật khẩu Github của bạn. Trong lần đầu tiên được hỏi, bạn có thể cần nhập hai dòng lệnh Git sau vào Terminal:\n\ngit config –global user.email “you@example.com” (Địa chỉ email Github của bạn), và\n\ngit config –global user.name “Tên đăng nhập Github của bạn”\n\nĐể tìm hiểu thêm về cách nhập các lệnh này, hãy xem phần bên dưới về các lệnh Git.\nMẸO: Bị yêu cầu cung cấp mật khẩu quá nhiều? Xem các chương 10 & 11 trong hướng dẫn này để kết nối với kho lưu trữ bằng khóa SSH (phức tạp hơn)\n\n\nTrong Github Desktop\nNhấp vào nút “Fetch origin” để kiểm tra xem có commit mới nào trên kho lưu trữ từ xa hay không.\n\n\n\n\n\n\n\n\n\nNếu Git tìm thấy các commit mới trên kho lưu trữ từ xa, nút commit sẽ thay đổi thành nút “Push”. Bởi vì cùng một nút được sử dụng để push và pull, bạn không thể push các thay đổi của mình nếu bạn không pull trước đó.\n\n\n\n\n\n\n\n\n\nBạn có thể chuyển đến tab “History” (gần tab “Changes”) để xem tất cả các commits (của bạn và những người khác). Đây là một cách tốt để tự làm quen với những gì những người cộng tác với bạn đã làm. Bạn có thể đọc các thông điệp commit, các mô tả nếu có và so sánh code của hai tệp bằng cách sử dụng cửa sổ diff.\n\n\n\n\n\n\n\n\n\nKhi tất cả các thay đổi từ xa đã được pull và ít nhất một thay đổi cục bộ đã được commit, bạn có thể push bằng cách nhấp trên cùng một nút.\n\n\n\n\n\n\n\n\n\n\n\nConsole\nKhông có gì ngạc nhiên, các lệnh là fetch, pull và push.\n\ngit fetch  # are there new commits in the remote directory?\ngit pull   # Bring remote commits into your local branch\ngit push   # Puch local commits of this branch to the remote branch\n\n\n\nTôi muốn pull nhưng tôi cũng có các chỉnh sửa trong local\nĐiều này đôi khi có thể xảy ra: khi bạn đã thực hiện một số thay đổi trên kho lưu trữ cục bộ của mình, nhưng kho lưu trữ từ xa có các commit mà bạn đã không pull.\nGit sẽ từ chối pull vì nó có thể ghi đè các thay đổi của bạn. Có một số chiến lược để giữ các thay đổi của bạn, được mô tả tốt trong trang Happy Git with R, trong đó có hai điểm chính sau:\n\ncommit các thay đổi của bạn, fetch các thay đổi từ xa, pull chúng xuống, giải quyết các xung đột nếu có (xem phần bên dưới) và push mọi thứ lên\nstash các thay đổi của bạn, tức là lưu trữ chúng sang một bên, sau đó pull và unstash (khôi phục), sau đó commit, giải quyết các xung đột và push.\n\nNếu các tệp có thay đổi từ remote và hay đổi bởi local không trùng lặp, Git có thể tự động giải quyết các xung đột.\nTrong Github Desktop, việc này có thể được thực hiện với các nút bấm. Để stash, hãy truy cập Branch &gt; Stash all changes.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Version control với Git và Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.vn.html#hợp-nhất-nhánh-vào-nhánh-chính",
    "href": "new_pages/collaboration.vn.html#hợp-nhất-nhánh-vào-nhánh-chính",
    "title": "46  Version control với Git và Github",
    "section": "46.10 Hợp nhất nhánh vào Nhánh chính",
    "text": "46.10 Hợp nhất nhánh vào Nhánh chính\nNếu bạn đã thực hiện xong các thay đổi, bạn có thể bắt đầu quá trình hợp nhất những thay đổi đó vào nhánh chính. Tùy thuộc vào tình huống của bạn, việc này có thể nhanh hoặc bạn có thể cần sự xem xét và phê duyệt của các thành viên trong nhóm.\n\nHợp nhất cục bộ bằng Github Desktop\nBạn có thể hợp nhất các nhánh bằng Github Desktop. Đầu tiên, hãy truy cập (checkout) nhánh sẽ là nơi tiếp nhận các commit, nói cách khác, nhánh bạn muốn cập nhật. Sau đó vào menu và lựa chọn Branch &gt; Merge into current branch. Một hộp thoại sẽ cho phép bạn chọn nhánh bạn muốn nhập vào.\n\n\n\n\n\n\n\n\n\n\n\nTrong console\nĐầu tiên hãy quay lại nhánh sẽ nhận các thay đổi. Nó thường là nhánh có tên master, nhưng nó cũng có thể là một nhánh khác. Sau đó hợp nhất nhánh làm việc của bạn vào master.\n\ngit checkout master  # Go back to master (or to the branch you want to move your )\ngit merge this_fancy_new_branch\n\nTrang này trình bày một ví dụ nâng cao hơn về phân nhánh và giải thích sơ bộ về cơ chế của nó.\n\n\nTrong Github: gửi một pull requests\nMặc dù hoàn toàn có thể hợp nhất hai nhánh một cách cục bộ, hoặc không thông báo cho bất kỳ ai, thì việc hợp nhất có thể được thảo luận hoặc kiểm tra bởi một số người trước khi được tích hợp vào nhánh master. Để giúp đỡ quá trình này, Github cung cấp một số tính năng thảo luận cho việc hợp nhất có tên là: pull request.\nMột pull request (một “PR”) là một yêu cầu hợp nhất một nhánh vào một nhánh khác (nói cách khác, một yêu cầu nhánh làm việc của bạn được pull vào nhánh “chính”). Một pull request thường bao gồm nhiều lần commit. Một pull request thường bắt đầu một cuộc thảo luận và quá trình review trước khi nó được chấp nhận và được hợp nhất vào nhánh chính. Ví dụ, bạn có thể đọc các cuộc thảo luận về pull request trên trang github của package dplyr.\nBạn có thể gửi một pull request (PR) trực tiếp từ trang web (như minh họa bên dưới) hoặc từ Github Desktop.\n\nĐi tới kho lưu trữ Github (trực tuyến)\nXem tab “Pull Requests” và ấn vào nút “New pull request”\nChọn nhánh cần hợp nhất từ menu thả xuống để hợp nhất vào nhánh chính\nViết chi tiết bình luận cho Pull Request và ấn vào “Create Pull Request”.\n\nTrong ảnh dưới đây, nhánh “forest” được chọn để hợp nhất vào nhánh “chính” (main):\n\n\n\n\n\n\n\n\n\nBây giờ bạn đã có thể xem một pull request (ảnh minh họa bên dưới):\n\nKiểm tra tab “Files changed” để xem nhánh “chính” sẽ thay đổi như thế nào nếu được hợp nhất.\n\nỞ phía bên phải, bạn có thể yêu cầu một thành viên trong nhóm review bằng cách gắn thẻ (tag) ID Github của họ. Nếu bạn muốn, bạn có thể thiết lập các cài đặt cho repository để yêu cầu một ai đó chấp thuận trước khi hợp nhất vào nhánh chính.\n\nKhi pull request được chấp thuận, nút “Merge pull request” sẽ được active. Hãy ấn vào đó.\n\nKhi hợp nhất thành công, xóa nhánh của bạn như được giải thích bên dưới.\n\n\n\n\n\n\n\n\n\n\n\n\nGiải quyết xung đột\nKhi hai người cùng thay đổi code trên cùng một (hoặc nhiều) dòng, thì xung đột khi hợp nhất sẽ xảy ra. Thực tế là Git sẽ từ chối việc đưa ra quyết định phiên bản nào sẽ được giữ, nhưng nó cho phép bạn tìm kiếm nơi xảy ra xung đột. ĐỪNG HOẢNG LẠN. Hầu hết các trường hợp khá dễ dàng để giải quyết.\nVí dụ, trên Github:\n\n\n\n\n\n\n\n\n\nSau khi việc hợp nhất nhắc nhở về có xung đột, hãy mở tệp trong trình chỉnh sửa ưa thích của bạn. Xung đột sẽ được đánh dấu bằng một chuỗi các ký tự như sau:\n\n\n\n\n\n\n\n\n\nĐoạn văn bản nằm giữa &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD và ======= đến từ local repository của bạn, và đoạn văn bản nằm giữa ======= và &gt;&gt;&gt;&gt;&gt;&gt;&gt; đến từ một nhánh khác (có thể là bản gốc, master hoặc bất kỳ nhánh nào theo lựa chọn của bạn).\nBạn phải quyết định phiên bản nào của code bạn muốn giữ (hoặc thậm chí viết một phiên bản thứ ba, bao gồm các thay đổi từ cả hai phía), xóa phần còn lại và loại bỏ tất cả các ký tự đánh dấu mà Git đã thêm vào (&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD, =======, &gt;&gt;&gt;&gt;&gt;&gt;&gt; origin/master/your_branch_name).\nSau đó, lưu tệp, stage và commit nó: Đây là commit để tạo phiên bản hợp nhất “chính thức”. Đừng quên push sau đó.\nNếu bạn và những người cộng tác với bạn thường xuyên pull và push, thì các xung đột lớn hiếm khi xảy ra.\nLưu ý: Nếu bạn tự tin tương tác với console, có nhiều lựa chọn hợp nhất nâng cao (ví dụ: bỏ qua khoảng trống, cho người cộng tác quyền ưu tiên, v.v.).\n\n\nXóa nhánh của bạn\nKhi một nhánh đã được hợp nhất vào master và bạn không cần đến nó nữa, bạn có thể xóa nó.\n\n46.10.0.1 Github + Rstudio\nĐi tới thư mục lưu trữ trên Github và nhấn nút để xem toàn bộ các nhánh hiện có (cạnh mũi tên trỏ xuống để lựa chọn nhánh). Bây giờ tìm nhánh của bạn và nhấn biểu tượng thúng rác bên cạnh nó. Đọc thêm về cách xóa một nhánh tại đây.\nHãy chắc chắn là bạn cũng đã xóa nhánh trong máy tính của mình bởi vì quá trình này không được diễn ra một cách tự động.\n\nTrong RStudio, hãy chắc chắn bạn đang ở nhánh chính (Main branch)\nChuyển sang cửa sổ “Terminal” của RStudio (bên cạnh cửa sổR console), và gõ: git branch -d branch_name, trong đó “branch_name” là tên của nhánh mà bạn muốn xóa\nRefresh lại cửa sổ Git và nhánh đó sẽ biến mất\n\n\n\n46.10.0.2 Trong Github Desktop\nĐơn giản chỉ cần checkout tới nhánh bạn muốn xóa, và đi tới menu Branch &gt; Delete.\n\n\n\nForking\nBạn có thể fork một dự án nếu bạn muốn đóng góp cho nó nhưng không có quyền để thực hiện, hoặc chỉ là bạn muốn chỉnh sửa cho mục đích sử dụng cá nhân. Một mô tả ngắn về forking có thể xem tại đây.\nTrong Github, nhấp vào nút “Fork”:\n\n\n\n\n\n\n\n\n\nThao tác này sẽ clone kho lưu trữ gốc, nhưng được lưu trong hồ sơ của bạn. Do đó, bây giờ có hai phiển bản của kho lưu trữ trong Github: phiên bản gốc mà bạn không thể chỉnh sửa, và phiên bản clone trong hồ sơ của bạn.\nSau đó, bạn có thể tiếp tục clone phiên bản trực tuyến xuống máy tính của bạn, sử dụng bất kỳ phương pháp nào đã được mô tả bên trên. Tiếp theo, bạn có thể tạo một nhánh mới, tạo các thay đổi, commit và push chúng lên kho lưu trữ từ xa của bạn.\nKhi bạn hài lòng với các kết quả, bạn có thể tạo một Pull Request từ Github hoặc Github Desktop để bắt đầu một cuộc thảo luận với chủ sở hữu/người bảo trì của kho lưu trữ gốc.\nNếu bạn muốn lấy những commits mới hơn từ kho lưu trữ gốc thì sao?\nhãy tưởng tượng ai đó đã tạo một thay đổi quan trọng trong kho lưu trữ gốc, và bạn muốn thêm những thay đổi đó vào kho lưu trữ của mình. Điều này là khả thi để đồng bộ hóa kho lưu trữ bạn đã fork với kho lưu trữ gốc. Nó yêu cầu sử dụng terminal, nhưng không quá phức tạp. Bạn chỉ cần nhớ rằng: - upstream (thượng nguồn) = kho lưu trữ gốc, là cái mà bạn không thể chỉnh sửa - origin (bản gốc) = phiên bản kho lưu trữ trong hồ sơ Github của bạn\nBạn có thể đọc tutorial này hoặc theo dõi các bước dưới đây:\nĐầu tiên, gõ vào Git terminal (bên trong repo của bạn):\n\ngit remote -v\n\nNếu bạn chưa từng cấu hình upstream repository (kho lưu trữ gốc), bạn sẽ thấy hai dòng, bắt đầu bởi từ origin. Chúng hiển thị kho lưu trữ từ xa để fetch và push các điểm vào. Hãy nhớ, origin là biệt danh thường dùng cho phiên bản kho lưu trữ của chính bạn trên Github. Ví dụ:\n\n\n\n\n\n\n\n\n\nBây giờ, thêm một kho lưu trữ từ xa:\n\ngit remote add upstream https://github.com/appliedepi/epirhandbook_eng.git\n\nĐịa chỉ ở đây là địa chỉ mà Github tạo ra khi bạn clone một repository (xem mục về cloning). Bây giờ bạn sẽ có bốn điểm từ xa:\n\n\n\n\n\n\n\n\n\nQuá trình thiết lập đã xong. Bất cứ khi nào bạn muốn lấy các sự thay đổi từ kho lưu trữ gốc (upstream), bạn chỉ cần đi tới (checkout) nhánh bạn muốn cập nhật và gõ:\n\ngit fetch upstream # Get the new commits from the remote repository\ngit checkout the_branch_you_want_to_update\ngit merge upstream/the_branch_you_want_to_update  # Merge the upstream branch into your branch.\ngit push # Update your own version of the remote repo\n\nNếu có xung đột, bạn sẽ phải giải quyết chúng như đã trình bày ở bên trên.\nTổng kết: forking là cloning, nhưng chỉ trên phía máy chủ của Github. Các hành động còn lại là điển hình của mô quy trình cộng tác(clone, push, pull, commit, merge, gửi pull requests…).\nLưu ý: trong khi forking là một khái niệm, không phải là một lệnh Git, nó cũng tồn tại ở các nền tảng khác, chẳng hạn như Bitbucket.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Version control với Git và Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.vn.html#chúng-ta-đã-học-được-những-gì",
    "href": "new_pages/collaboration.vn.html#chúng-ta-đã-học-được-những-gì",
    "title": "46  Version control với Git và Github",
    "section": "46.11 Chúng ta đã học được những gì",
    "text": "46.11 Chúng ta đã học được những gì\nBạn đã học được cách:\n\nthiết lập Git để theo dõi sự thay đổi trong thư mục của bạn,\n\nkết nối kho lưu trữ cục bộ và từ xa,\n\ncommit các thay đổi,\n\nđồng bộ kho lưu trữ cục bộ và từ xa.\n\nTất cả chúng là khá đầy đủ cho những nhu cầu của một nhà dịch tễ học. Chúng ta thường không cần sử dụng những chức năng nâng cao như những lập trình viên.\nTuy nhiên, nếu bạn muốn (hoặc cần) đi xa hơn, Git cung cấp nhiều tính năng để đơn giản hóa lịch sử commit, khôi phục một hoặc nhiều commits, cherry-pick commits (chỉ lấy một vài commit trong PR), v.v. Một số chúng nghe thực sự rất thần thánh, nhưng không sao vì bạn đã có cơ bản rồi, sẽ dễ dàng để bổ sung kiến thức trên nền tảng đó.\nLưu ý là trong khi cửa sổ Git trong Rstudio và Github Desktop tốt cho những người mới bắt đầu / sử dụng trong các công việc hàng này, thì chúng không cung cấp giao diện cho những hàm Git trung cấp / cao cấp. Các giao diện đầy đủ hơn cho phép bạn phải sử dụng những tính năng nâng cao chỉ với các thao tác chuột (thông thường phải trả phí).\nHãy nhớ là bạn có thể sử dụng bất kỳ công cụ nào tại mọi thời điểm để theo dõi kho lưu trữ của mình, do đó bạn có thể cài đặt một giao diện để thỉnh thoảng sử dụng, hoặc thực hiện những tác vụ không phiỉ biến, trong khi lựa chọn một giao diện đơn giản hầu hết thời gian (vd: sử dụng Github Desktop phần lớn thời gian, và chuyển qua phần mềm SourceTree hoặc Gitbash cho những tác vụ cụ thể).",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Version control với Git và Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.vn.html#git",
    "href": "new_pages/collaboration.vn.html#git",
    "title": "46  Version control với Git và Github",
    "section": "46.12 Các lệnh Git",
    "text": "46.12 Các lệnh Git\n\nĐược khuyến khích học\nĐể học các lệnh Git một cách tương tác, xem trang web này.\n\n\nGõ lệnh vào đâu\nBạn gõ lệnh vào Git shell.\nLựa chọn 1 Bạn mở một Terminal mới trong RStudio. Tab này ở bên cạnh R Console. Nếu bạn không thể gõ trên đó, nhấp vào menu thả xuống ở dưới chữ “Terminal” và chọn “New terminal”. Gõ lệnh ở khoảng trống phía sau ký tự dollar “$”.\n\n\n\n\n\n\n\n\n\nLựa chọn 2 Bạn cũng có thể mở một shell (một terminal để gõ lệnh) bằng cách nhấp vào biểu tượng “bánh răng” màu xanh trong cửa sổ Git (bên cạnh cửa sổ RStudio Environment). Chọn “Shell” từ menu thả xuống. Một cửa sổ mới sẽ mở ra nơi mà bạn có thể gõ các lệnh sau ký tự dollar “$”.\nLựa chọn 3 Nháy chuột phải để mở “Git Bash here”, cho phép mở một cửa sổ terminal tương tự, hoặc mở Git Bash từ danh sách ứng dụng của bạn. Các thông tin về Git Bash cho người mới bắt đầu, cách tìm nó và một số lệnh bash bạn sẽ cần.\n\n\nMột số lệnh mẫu\nSau đây chúng tôi sẽ trình bày một số lệnh git phổ biến. Khi bạn sử dụng chúng, hãy chú ý nhánh nào đang được active (checked-out), bởi vì điều này sẽ quyết định hành động nào được thực hiện!\nTrong các lệnh dưới đây,  đại diện cho tên nhánh.  đại diện cho hash ID của một commit cụ thể.  đại diện cho một số. Bạn không cần gõ ký tự &lt; hoặc &gt;.\n\n\n\n\n\n\n\nLệnh Git\nHành động\n\n\n\n\ngit branch &lt;name&gt;\nTạo một nhánh mới có tên \n\n\ngit checkout &lt;name&gt;\nChuyển từ nhánh hiện tại sang nhánh có tên \n\n\ngit checkout -b &lt;name&gt;\nLối tắt để tạo nhánh mới và chuyển qua nó\n\n\ngit status\nXem những thay đổi không được theo dõ\n\n\ngit add &lt;file&gt;\nStage một tệp\n\n\ngit commit -m &lt;message&gt;\nCommit những thay đổi tới nhánh hiện tại kèm một thông điệp\n\n\ngit fetch\nFetch các commit từ kho lưu trữ trực tuyến\n\n\ngit pull\nPull các commit từ kho lưu trữ trực tuyến tới nhánh hiện tại\n\n\ngit push\nPush các commits trong local lên thư mục trực tuyến\n\n\ngit switch\nCách khác của git checkout\n\n\ngit merge &lt;name&gt;\nHợp nhất nhánh có tên  vào nhánh hiện tại\n\n\ngit rebase &lt;name&gt;\nThêm các commit từ nhánh hiện tại vào nhánh có tên",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Version control với Git và Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.vn.html#tài-nguyên-học-liệu",
    "href": "new_pages/collaboration.vn.html#tài-nguyên-học-liệu",
    "title": "46  Version control với Git và Github",
    "section": "46.13 Tài nguyên học liệu",
    "text": "46.13 Tài nguyên học liệu\nPhần lớn chương này lấy thông tin từ trang web “Happy Git with R” viết bởi Jenny Bryan. Có một chuyên mục rất hữu ích trong trang web đó có thể giúp bạn giải quyết những lỗi phổ biến về Git và các lỗi liên quan tới R.\nTài liệu Github.com documentation and start guide.\nRStudio “IDE” cheatsheet bao gồm các mẹo về Git với RStudio.\nhttps://ohi-science.org/news/github-going-back-in-time\nLệnh Git cho người mới\nMột hướng dẫn tương tác để học các lệnh Git.\nhttps://www.freecodecamp.org/news/an-introduction-to-git-for-absolute-beginners-86fa1d32ff71/: tốt cho việc học những thứ cơ bản để theo dõi các thay đổi trong một thư mục của máy tính của bạn\nLược đồ để hiểu về nhánh: https://speakerdeck.com/alicebartlett/git-for-humans\nHướng dẫn bao gồm các chủ đề cơ bản và nâng cao\nhttps://tutorialzine.com/2016/06/learn-git-in-30-minutes\nhttps://dzone.com/articles/git-tutorial-commands-and-operations-in-git https://swcarpentry.github.io/git-novice/ (khóa ngắn hạn) https://rsjakob.gitbooks.io/git/content/chapter1.html\nSách Pro Git được xem là tài liệu tham khảo chính thức. Trong khi một số chương khá ổn, đa số khá nặng tính kỹ thuật. Nó có thể là một nguồn tốt khi bạn đã sử dụng Git một thời gian và muốn học thêm những kiến thức nâng cao.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Version control với Git và Github</span>"
    ]
  },
  {
    "objectID": "new_pages/errors.vn.html",
    "href": "new_pages/errors.vn.html",
    "title": "47  Các lỗi thường gặp",
    "section": "",
    "text": "47.1 Phiên giải thông báo lỗi\nCác lỗi trong R đôi khi có thể khó hiểu, vì vậy Google là bạn của bạn. Tìm kiếm thông báo lỗi với “R” và tìm các bài đăng gần đây trong StackExchange.com, stackoverflow.com, community.rstudio.com, twitter (#rstats), và các diễn đàn khác được lập trình viên sử dụng để gửi câu hỏi và câu trả lời. Hãy cố gắng tìm các bài đăng gần đây đã giải quyết các vấn đề tương tự.\nNếu sau nhiều lần tìm kiếm, bạn không thể tìm thấy câu trả lời cho vấn đề của mình, hãy cân nhắc tạo một ví dụ có thể tái tạo (“reprex”) và tự đăng câu hỏi. Xem chương Nhờ sự trợ giúp để biết các mẹo về cách tạo và đăng một ví dụ có thể tái tạo lên diễn đàn.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Các lỗi thường gặp</span>"
    ]
  },
  {
    "objectID": "new_pages/errors.vn.html#các-lỗi-thường-gặp",
    "href": "new_pages/errors.vn.html#các-lỗi-thường-gặp",
    "title": "47  Các lỗi thường gặp",
    "section": "47.2 Các lỗi thường gặp",
    "text": "47.2 Các lỗi thường gặp\nDưới đây, chúng tôi liệt kê một số lỗi phổ biến và các giải thích/giải pháp tiềm năng. Một số trong số này được mượn từ Noam Ross, người đã phân tích các bài đăng phổ biến nhất trên diễn đàn Stack Overflow về các thông báo lỗi trên R (xem bài phân tích tại đây)\n\nLỗi đánh máy\nError: unexpected symbol in:\n\"  geom_histogram(stat = \"identity\")+\n  tidyquant::geom_ma(n=7, size = 2, color = \"red\" lty\"\nNếu bạn thấy lỗi “unexpected symbol”, kiểm tra xem có thiếu dấu phẩy không\n\n\nCác lỗi liên quan đến Package\ncould not find function \"x\"...\nĐiều này có thể có nghĩa là bạn đã nhập sai tên hàm hoặc quên cài đặt hoặc gọi một package.\nError in select(data, var) : unused argument (var)\nBạn nghĩ rằng bạn đang sử dụng dplyr::select() nhưng thực tế là hàm select() đã bị đè bởi hàm MASS::select() - hãy ghi rõ dplyr:: hoặc sắp xếp lại thứ tự các package được gọi để dplyr đứng sau tất cả các package khác.\nCác lỗi hàm bị đè phổ biến khác bắt nguồn từ: plyr::summarise() và stats::filter(). Cân nhắc sử dụng conflicted package.\nError in install.packages : ERROR: failed to lock directory ‘C:\\Users\\Name\\Documents\\R\\win-library\\4.0’ for modifying\nTry removing ‘C:\\Users\\Name\\Documents\\R\\win-library\\4.0/00LOCK’\nNếu bạn gặp lỗi thông báo rằng bạn cần xóa tệp “00LOCK”, go to your “R” library in your computer directory (e.g. R/win-library/) and look for a folder called “00LOCK”. Delete this manually, and try installing the package again. A previous install process was probably interrupted, which led to this.\n\n\nCác lỗi liên quan tới đối tượng\nNo such file or directory:\nNếu bạn gặp lỗi như thế này khi cố gắng xuất hoặc nhập: Hãy kiểm tra lỗi chính tả của tệp và đường dẫn tệp và nếu đường dẫn chứa dấu gạch chéo, hãy đảm bảo rằng bạn đang dùng dấu gạch chéo xuôi / chứ không phải dấu gạch chéo ngược \\. Ngoài ra, hãy đảm bảo rằng bạn đã sử dụng đúng phần mở rộng tệp (ví dụ: .csv, .xlsx).\nobject 'x' not found \nĐiều này có nghĩa là một đối tượng bạn đang tham chiếu không tồn tại. Có lẽ code trên đã không chạy đúng cách?\nError in 'x': subscript out of bounds\nĐiều này có nghĩa là bạn đã cố gắng truy cập vào thứ gì đó (một phần tử của vectơ hoặc danh sách) không có ở đó.\n\n\nCác lỗi liên quan tới cú pháp hàm\n# ran recode without re-stating the x variable in mutate(x = recode(x, OLD = NEW)\nError: Problem with `mutate()` input `hospital`.\nx argument \".x\" is missing, with no default\ni Input `hospital` is `recode(...)`.\nLỗi bên trên (argument .x is missing, with no default) thường gặp với hàm mutate() nếu bạn đang cung cấp một hàm như recode() hoặc replace_na() trong đó nó yêu cầu bạn cung cấp tên cột làm đối số đầu tiên. Điều này rất dễ quên.\n\n\nCác lỗi logic\nError in if\nĐiều này có thể có nghĩa là một mệnh đề if đã được áp dụng cho một cái gì đó không phải là TRUE hoặc FALSE.\n\n\nCác lỗi liên quan tới Factor\n#Tried to add a value (\"Missing\") to a factor (with replace_na operating on a factor)\nProblem with `mutate()` input `age_cat`.\ni invalid factor level, NA generated\ni Input `age_cat` is `replace_na(age_cat, \"Missing\")`.invalid factor level, NA generated\nNếu bạn nhìn thấy lỗi liên quan tới thứ bậc kiểu factor không hợp lệ, có thể bạn đang có một cột kiểu Factor(chứa các thứ bậc đã được xác định) và bạn đang cố gắng thêm một giá trị mới vào nó. Chuyển nó thành kiểu ký tự trước khi thêm giá trị mới.\n\n\nLỗi khi vẽ biểu đồ\nError: Insufficient values in manual scale. 3 needed but only 2 provided. Đây có thể là lỗi khi bạn vẽ biểu đồ bằng ggplot, sử dụng scale_fill_manual() values = c(“orange”, “purple”), trong đó bạn chưa cung cấp đủ số lượng màu cho hàm. Nếu cột này dạng factor, hãy cân nhắc liệu NA có phải là một bậc của factor hay không.\nCan't add x object\nBạn có thể thừa dấu + ở cuối lệnh ggplot mà bạn cần xóa.\n\n\nLỗi R Markdown\nNếu thông báo lỗi là Error in options[[sprintf(\"fig.%s\", i)]], kiểm tra xem các tùy chọn của knitr ở đầu mỗi đoạn code có sử dụng chính xác out.width = hoặc out.height = và không phải fig.width= và fig.height= hay không.\n\n\nTổng hợp\nCân nhắc liệu bạn có đã sắp xếp lại các hàm đã được pipe trong package dplyr và đã không thay thế một pipe ở giữa, hoặc đã không xóa một pipe ở cuối sau khi sắp xếp lại.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Các lỗi thường gặp</span>"
    ]
  },
  {
    "objectID": "new_pages/errors.vn.html#nguồn",
    "href": "new_pages/errors.vn.html#nguồn",
    "title": "47  Các lỗi thường gặp",
    "section": "47.3 Nguồn",
    "text": "47.3 Nguồn\nĐây là một bài đăng trên blog khác liệt kê Các lỗi lập trình R phổ biến mà người mới bắt đầu gặp phải",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Các lỗi thường gặp</span>"
    ]
  },
  {
    "objectID": "new_pages/help.vn.html",
    "href": "new_pages/help.vn.html",
    "title": "48  Nhờ sự trợ giúp",
    "section": "",
    "text": "48.1 Đăng vấn đề lên Github\nNhiều packages và dự án trong R được lưu trữ mã code của chúng trên trang web Github.com. Bạn có thể trao đổi trực tiếp với các tác giả của các package hoặc dự án này bằng cách đăng một “Issue” qua trang web Github.com..\nTìm hiểu thêm về cách lưu trữ các tệp của bạn trên Github trong chương Version control với Git và Github.\nTrên Github, mỗi dự án được chứa trong một kho lưu trữ. Mỗi kho chứa code, dữ liệu, kết quả đầu ra, tài liệu trợ giúp, v.v. Ngoài ra còn có một cách để trao đổi với các tác giả được gọi là “Issues”.\nXem các ảnh bên dưới về Github để hiểu thêm về package incidence2 (được sử dụng để tạo đường cong dịch bệnh). Trong ảnh dưới, bạn có thể thấy mục “Issues” được tô màu vàng. Số 5 bên cạnh chữ “Issues” có nghĩa là có 5 vấn đề đang được mở.\nẤn vào mục Issues, bạn có thể thấy các vấn đề đang mở được hiện ra. Hãy xem lại chúng để đảm bảo những vấn đề này chưa được giải quyết. Bạn có thể mở một vấn đề mới bằng cách nhấp vào nút màu xanh lá cây “New issue” ở bên phải. Để thực hiện những thao tác này, bạn sẽ cần mở một tài khoản Github.\nĐể đọc các tài liệu nâng cao hơn về cách xử lý các vấn đề trong kho lưu trữ Github của riêng bạn, hãy xem Tài liệu về Issues trong Github.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Nhờ sự trợ giúp</span>"
    ]
  },
  {
    "objectID": "new_pages/help.vn.html#ví-dụ-giả-lập",
    "href": "new_pages/help.vn.html#ví-dụ-giả-lập",
    "title": "48  Nhờ sự trợ giúp",
    "section": "48.2 Ví dụ giả lập",
    "text": "48.2 Ví dụ giả lập\nCung cấp một ví dụ giả lập (“reprex”) là chìa khóa để nhận được giúp đỡ khi đăng bài thảo luận trên các diễn đàn hoặc trong vấn đề Github issue. Để người khác có thể giúp bạn, bạn phải cho họ một ví dụ cụ thể để họ có thể xử ý vấn dề của bạn trên máy tính của chính họ. Ví dụ của bạn cần phải:\n\nTrình bày sự cố bạn gặp phải\nHãy nhớ ngắn gọn nhất có thể, bạn chi cân ghi dữ liệu và đoạn code cần thiết để giả lập lại sự cố của bạn\nĐủ thông tin để giả lập lại tình huống của bạn, ví dụ như các thông tin như các đối tượng (ví dụ: dữ liệu), tất cả package được gọi (ví dụ: library() hoặc p_load()).\n\nNgoài ra, hãy đảm bảo rằng bạn không đăng bất kỳ dữ liệu nhạy cảm nào với reprex! Bạn có thể tạo các data frames mẫu hoặc sử dụng một trong các data frames có sẵn trong R (nhập data()để mở danh sách các tập dữ liệu này).\n\nPackage reprex\nPackage reprex có thể hỗ trợ bạn tạo một ví dụ giả lập\n\nPackage reprex được cài đặt với package tidyverse, vì vậy hãy gọi một trong hai package:\n\n\n# install/load tidyverse (which includes reprex)\npacman::p_load(tidyverse)\n\n\nBắt đầu một đoạn R script tạo ra vấn đề của bạn, hãy làm từng từng bước một, bắt đầu từ việc tải các package và dữ liệu.\n\n\n# load packages\npacman::p_load(\n     tidyverse,  # data mgmt and vizualization\n     outbreaks)  # example outbreak datasets\n\n# flu epidemic case linelist\noutbreak_raw &lt;- outbreaks::fluH7N9_china_2013  # retrieve dataset from outbreaks package\n\n# Clean dataset\noutbreak &lt;- outbreak_raw %&gt;% \n     mutate(across(contains(\"date\"), as.Date))\n\n# Plot epidemic\n\nggplot(data = outbreak)+\n     geom_histogram(\n          mapping = aes(x = date_of_onset),\n          binwidth = 7\n     )+\n  scale_x_date(\n    date_format = \"%d %m\"\n  )\n\nSao chép tất cả code vào bộ nhớ tạm của bạn và chạy lệnh sau:\n\nreprex::reprex()\n\nBạn sẽ thấy một tệp HTML xuất hiện trong cửa sổ RStudio Viewer. Nó sẽ chứa tất cả code của bạn và bất kỳ cảnh báo, lỗi hoặc biểu đồ nào. Tệp này cũng được sao chép vào bộ nhớ tạm của bạn, vì vậy bạn có thể đăng trực tiếp nó lên một vấn đề trên Github hoặc một bài đăng trên diễn đàn.\n\n\n\n\n\n\n\n\n\n\nNếu bạn đặt session_info = TRUE, thì kết quả đầu ra của lệnh sessioninfo::session_info() sẽ được bao gồm với các phiên bản R và package R của bạn.\nBạn có thể cung cấp một thư mục làm việc cho wd =\n\nBạn có thể đọc thêm về các đối số và các biến số có thể có tại Tài liệu này hoặc bằng cách nhập ?reprex\n\nTrong ví dụ trên, lệnh ggplot() không chạy vì đối số date_format = không đúng. Nó phải là date_labels =.\n\n\nBộ dữ liệu tối giản\nNhững người giúp bạn cần sử dụng dữ liệu của bạn - lý tưởng nhất là họ có thể tạo ra nó bằng code.\nĐể tạo một tập dữ liệu tối giản, hãy xem xét việc ẩn danh và chỉ sử dụng một tập con của các quan sát.\nĐANG ĐƯỢC PHÁT TRIỂN - Bạn có thể sử dụng lệnh dput() để tạo một bộ dữ liệu tối giản.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Nhờ sự trợ giúp</span>"
    ]
  },
  {
    "objectID": "new_pages/help.vn.html#đăng-lên-diễn-đàn",
    "href": "new_pages/help.vn.html#đăng-lên-diễn-đàn",
    "title": "48  Nhờ sự trợ giúp",
    "section": "48.3 Đăng lên diễn đàn",
    "text": "48.3 Đăng lên diễn đàn\nBạn cần đọc nhiều bài viết trên diễn đàn. Hiểu được bài đăng nào được viết tốt và bài nào thì không.\n\nĐầu tiên, bạn hãy quyết định xem có nên đặt câu hỏi hay không. Bạn đã kỹ lưỡng tìm kiếm câu trả lời trên các trang web diễn đàn, thử các cụm từ tìm kiếm khác nhau, để xem liệu câu hỏi của bạn đã được đặt ra chưa?\nĐặt cho câu hỏi của bạn với một tiêu đề thông tin đầy đủ (không phải “Trợ giúp! Điều này không hoạt động”).\nViết câu hỏi của bạn:\n\n\nGiới thiệu hoàn cảnh và vấn đề của bạn\nLiên kết đến các bài đăng về các vấn đề tương tự và giải thích cách họ không trả lời câu hỏi của bạn\nGhi bất kỳ thông tin liên quan nào để giúp những người không rõ bối cảnh công việc của bạn\nĐưa ra một ví dụ giả lập với thông tin tối thiểu về phiên làm việc R của bạn\nSử dụng đúng chính tả, ngữ pháp, dấu câu và ngắt câu hỏi của bạn thành các đoạn văn để dễ đọc hơn\n\n\nTheo dõi câu hỏi của bạn sau khi được đăng để trả lời bất kỳ yêu cầu làm rõ nào. Lịch sự và nhã nhặn - thường những người trả lời đều tình nguyện dành thời gian của họ để giúp bạn. Nếu bạn có một câu hỏi tiếp theo, hãy cân nhắc xem nó có nên là một câu hỏi được đăng riêng hay không.\nĐánh dấu câu hỏi là đã trả lời, nếu bạn đã nhận được câu trả lời đáp ứng yêu cầu ban đầu của bạn. Điều này giúp những người truy cập sau nhanh chóng nhận ra giải pháp cho vấn đề tương tự với bạn.\n\nĐọc những bài đăng này trong các tài liệu Cách đặt một câu hỏi tốt và Bộ quy tắc ứng xử.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Nhờ sự trợ giúp</span>"
    ]
  },
  {
    "objectID": "new_pages/help.vn.html#tài-liệu-tham-khảo",
    "href": "new_pages/help.vn.html#tài-liệu-tham-khảo",
    "title": "48  Nhờ sự trợ giúp",
    "section": "48.4 Tài liệu tham khảo",
    "text": "48.4 Tài liệu tham khảo\nPackage Tidyverse về cách nhận trợ giúp!\nLời khuyên về tạo ra một tập dữ liệu tối thiểu\nTài liệu về Hàm dput",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Nhờ sự trợ giúp</span>"
    ]
  },
  {
    "objectID": "new_pages/network_drives.vn.html",
    "href": "new_pages/network_drives.vn.html",
    "title": "49  R trên ổ cứng mạng",
    "section": "",
    "text": "49.1 Tổng quan\nViệc sử dụng R trên một ổ cứng mạng dùng chung tại “công ty” hoặc một nhóm có thể gây ra một số vấn đề phát sinh. Chương này sẽ giới thiệu các phương pháp tiếp cận, các lỗi phổ biến và các đề xuất về cách khắc phục sự cố từ những bài học kinh nghiệm của chúng tôi khi giải quyết các vấn đề này. Chúng bao gồm các mẹo cho các tình huống khó liên quan đến R Markdown.\nSử dụng R trên ổ cứng mạng: Một số nguyên tắc chính",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>R trên ổ cứng mạng</span>"
    ]
  },
  {
    "objectID": "new_pages/network_drives.vn.html#tổng-quan",
    "href": "new_pages/network_drives.vn.html#tổng-quan",
    "title": "49  R trên ổ cứng mạng",
    "section": "",
    "text": "Bạn phải có quyền truy cập quản trị đối với máy tính của mình. Thiết lập RStudio đặc biệt để chạy với tư cách quản trị viên (run as administrator).\nHãy lưu các packages trong thư viện trên một ổ cứng vật lý (ví dụ: “C:”). Hạn chế tối đa Sử dụng package thư viện có đường dẫn bắt đầu bằng “\\\".\n\nPackage rmarkdown không được nằm trong thư viện package “\\\", vì khi đó nó không thể kết nối với TinyTex hoặc Pandoc.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>R trên ổ cứng mạng</span>"
    ]
  },
  {
    "objectID": "new_pages/network_drives.vn.html#rstudio-với-tư-cách-quản-trị-viên",
    "href": "new_pages/network_drives.vn.html#rstudio-với-tư-cách-quản-trị-viên",
    "title": "49  R trên ổ cứng mạng",
    "section": "49.2 RStudio với tư cách quản trị viên",
    "text": "49.2 RStudio với tư cách quản trị viên\nBạn cần nhấp vào biểu tượng RStudio để mở RStudio, sau đó bấm chuột phải. Tùy thuộc vào máy của bạn, bạn có thể thấy tùy chọn “Run as Administrator”. Nếu không, bạn có thể thấy một tùy chọn để chọn Properties (sau đó sẽ xuất hiện một cửa sổ có tùy chọn “Compatibility” và bạn có thể chọn hộp kiểm “Run as Administrator”).",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>R trên ổ cứng mạng</span>"
    ]
  },
  {
    "objectID": "new_pages/network_drives.vn.html#các-lệnh-hữu-ích",
    "href": "new_pages/network_drives.vn.html#các-lệnh-hữu-ích",
    "title": "49  R trên ổ cứng mạng",
    "section": "49.3 Các lệnh hữu ích",
    "text": "49.3 Các lệnh hữu ích\nDưới đây là một số lệnh hữu ích trong việc khắc phục sự cố khi sử dụng R trên ổ đĩa mạng.\nBạn có thể trả về (các) đường dẫn đến các thư thư mục lưu trữ package mà R đang sử dụng. Chúng sẽ được liệt kê theo thứ tự mà R đang sử dụng để cài đặt/tải/tìm kiếm các packages. Vì vậy, nếu bạn muốn R sử dụng một thư viện mặc định khác, bạn có thể chuyển đổi thứ tự của các đường dẫn này (xem bên dưới).\n\n# Find libraries\n.libPaths()                   # Your library paths, listed in order that R installs/searches. \n                              # Note: all libraries will be listed, but to install to some (e.g. C:) you \n                              # may need to be running RStudio as an administrator (it won't appear in the \n                              # install packages library drop-down menu) \n\nBạn có thể muốn chuyển đổi thứ tự của các thư viện package được sử dụng bởi R. Ví dụ: nếu R đang chọn một vị trí thư viện với đường dẫn bắt đầu bằng “\\\" và một đường dẫn bắt đầu bằng chữ cái, ví dụ:”D:“. Bạn có thể điều chỉnh thứ tự của .libPaths() bằng đoạn mã code dưới đây.\n\n# Switch order of libraries\n# this can effect the priority of R finding a package. E.g. you may want your C: library to be listed first\nmyPaths &lt;- .libPaths() # get the paths\nmyPaths &lt;- c(myPaths[2], myPaths[1]) # switch them\n.libPaths(myPaths) # reassign them\n\nNếu bạn gặp khó khăn với R Markdown kết nối với Pandoc, hãy bắt đầu với đoạn code mã này để tìm hiểu RStudio cài đặt Pandoc của bạn ở đâu.\n\n# Find Pandoc\nSys.getenv(\"RSTUDIO_PANDOC\")  # Find where RStudio thinks your Pandoc installation is\n\nNếu bạn muốn xem package đang được tải từ thư viện ở đâu, hãy thử đoạn code dưới đây:\n\n# Find a package\n# gives first location of package (note order of your libraries)\nfind.package(\"rmarkdown\", lib.loc = NULL, quiet = FALSE, verbose = getOption(\"verbose\"))",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>R trên ổ cứng mạng</span>"
    ]
  },
  {
    "objectID": "new_pages/network_drives.vn.html#khắc-phục-các-lỗi-thường-gặp",
    "href": "new_pages/network_drives.vn.html#khắc-phục-các-lỗi-thường-gặp",
    "title": "49  R trên ổ cứng mạng",
    "section": "49.4 Khắc phục các lỗi thường gặp",
    "text": "49.4 Khắc phục các lỗi thường gặp\n“Failed to compile…tex in rmarkdown”\n\nKiểm tra cài đặt TinyTex hoặc cài đặt TinyTex vào ổ C:. Xem thêm chương R cơ bản để biết về cách cài đặt TinyTex\n\n\n# check/install tinytex, to C: location\ntinytex::install_tinytex()\ntinytex:::is_tinytex() # should return TRUE (note three colons)\n\nInternet routines cannot be loaded\nVí dụ, Error in tools::startDynamicHelp() : internet routines cannot be loaded\n\nThử chọn phiên bản 32-bit từ RStudio qua Tools/Global Options .\n\nChú ý: nếu phiên bản 32-bit không xuất hiện trong menu, hãy đảm bảo rằng bạn không sử dụng RStudio phiên bản 1.2.\n\n\nNgoài ra, hãy thử gỡ cài đặt R và cài đặt lại với phiên bản bit khác (32 thay vì 64)\n\nC: library does not appear as an option when I try to install packages manually\n\nChạy RStudio với tư cách quản trị viên, sau đó tùy chọn này sẽ xuất hiện.\n\nĐể thiết lập R Studio luôn chạy với tư cách quản trị viên (thuận tiện khi sử dụng dự án R mà bạn không nhấp vào biểu tượng R Studio để mở) … nhấp chuột phải vào biểu tượng R studio\n\nHình ảnh bên dưới cho thấy cách bạn có thể chọn thủ công thư viện để cài đặt một gói. Cửa sổ này xuất hiện khi bạn mở ngăn Packages RStudio và nhấp vào “Install”.\n\n\n\n\n\n\n\n\n\nPandoc 1 error\nNếu bạn gặp phải “pandoc error 1” khi knitting tập lệnh R Markdowns trên ổ đĩa mạng:\n\nTrong số nhiều vị trí thư viện đặt lưu trữ, hãy chọn một vị trí ổ cứng bắt đầu bằng một chữ cái (xem lại ở trên)\nGiải pháp trên có thể thực hiện được khi knitting trên ổ đĩa cá nhân trong khi máy tính có kết nối internet\nXem thêm các mẹo khác tại đây: https://ciser.cornell.edu/rmarkdown-knit-to-html-word-pdf/\n\nPandoc Error 83\nLỗi sẽ có dạng như sau: can't find file...rmarkdown...lua.... Điều này có nghĩa là nó không thể tìm thấy tệp này.\nXem thêm tại đây: https://stackoverflow.com/questions/58830927/rmarkdown-unable-to-locate-lua-filter-when-knitting-to-word\nCác khả năng có thể xảy ra:\n\nPackage Rmarkdown chưa được cài đặt\nPackage Rmarkdown không thể tìm thấy\nVấn đề về quyền quản trị.\n\nCó thể R không thể tìm thấy các package sử dụng trong file rmarkdown, vì vậy hãy kiểm tra thư viện nào mà package trong rmarkdown đang được lưu trữ (xem đoạn code để thực hiện thao tác này ở trên). Nếu package được cài đặt vào một thư viện không thể truy cập được (ví dụ: bắt đầu bằng “\\\") hãy xem xét việc di chuyển nó sang C: hoặc thư viện ổ cứng theo cách thủ công. Lưu ý rằng package rmarkdown phải có thể kết nối với cài đặt TinyTex, vì vậy không thể tồn tại trong thư viện trên ổ đĩa mạng.\nLỗi Pandoc 61\nVú dụ: Error: pandoc document conversion failed with error 61 hoặc Could not fetch...\n\nThử chạy RStudio với tư cách quản trị viên (nhấp chuột phải vào biểu tượng, chọn chạy với tư cách quản trị viên, xem hướng dẫn ở trên)\nNgoài ra, hãy xem nếu có package cụ thể nào không thể truy cập được có thể được chuyển đến ổ C: library.\n\nLỗi LaTex (xem bên dưới)\nMột lỗi như: ! Package pdftex.def Error: File 'cict_qm2_2020-06-29_files/figure-latex/unnamed-chunk-5-1.png' not found: using draft setting. hoặc Error: LaTeX failed to compile file_name.tex.\n\nXem thêm tại đây https://yihui.org/tinytex/r/#debugging để biết các mẹo debug.\n\nXem thêm file_name.log để biết thêm chi tiết.\n\nLỗi Pandoc 127\nĐây có thể là vấn đề về RAM (dung lượng). Hãy bắt đầu lại phiên làm việc R của bạn và thử lại.\nĐịnh vị các ổ đĩa mạng\nĐịnh vị ổ đĩa mạng có thể gặp một số rủi ro. Hãy tham khảo ý kiến với bộ phận CNTT của bạn trước khi làm!\nBạn có thể xem thêm các thảo luận trên diễn đàn này:\nLàm cách nào để mở một tệp “thông qua một ổ đĩa mạng đã được đinh vị”?\n\nTrước tiên, bạn cần biết vị trí ổ mạng mà bạn đang cố gắng truy cập.\nTiếp theo, trong trình quản lý tệp của Windows, bạn sẽ cần phải nhấp chuột phải vào “Máy tính này” ở ngăn bên phải và chọn “Map a network drive”.\nĐi qua hộp thoại để xác định vị trí mạng trước đó dưới dạng ổ đĩa có tên bắt đầu chữ cái.\nBây giờ bạn có hai cách để truy cập tệp bạn đang mở. Sử dụng đường dẫn ổ đĩa bắt đầu bằng ký tự có thể hoạt động.\n\nLỗi khi cài đặt install.packages()\nNếu bạn gặp lỗi bao gồm đề cập đến thư mục “khóa”, ví dụ: Error in install.packages : ERROR: failed to lock directory...\nTìm trong thư viện package của bạn và bạn sẽ thấy một thư mục có tên bắt đầu bằng “00LOCK”. Hãy thử các mẹo sau:\n\nXóa thủ công thư mục thư mục “00LOCK” khỏi thư viện package của bạn. Thử cài đặt lại package này.\nBạn cũng có thể thử lệnh pacman::p_unlock() (bạn cũng có thể đặt lệnh này trong Rprofile để nó chạy mỗi khi mở dự án). Sau đó, hãy thử cài đặt lại package. Bạn có thể cần thử một vìa lần.\nThử chạy RStudio ở chế độ Quản trị viên và thử cài đặt từng package một.\nNếu vẫn không thành công, hãy cài đặt packge vào thư viện hoặc thư mục khác (ví dụ: Temp) và sau đó sao chép thủ công thư mục của package vào thư viện mong muốn.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>R trên ổ cứng mạng</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.vn.html",
    "href": "new_pages/data_table.vn.html",
    "title": "50  Data Table",
    "section": "",
    "text": "50.1 Giới thiệu về data table\nMột data table là một cấu trúc dữ liệu 2-chiều giống như một data frame mà cho phép thực hiện các thao tác phân nhóm phức tạp. Cú pháp data.table được cấu trúc để có thể thực hiện các thao tác trên hàng, cột và nhóm.\nCấu trúc là DT[i, j, by], được chia thành 3 phần; đối số i, j và by. Đối số i cho phép tạo tập con trên các hàng được yêu cầu, đối số j cho phép bạn vận hành trên cột và đối số by cho phép bạn vận hành theo nhóm.\nChương này sẽ giải quyết các chủ đề sau:",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Data Table</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.vn.html#giới-thiệu-về-data-table",
    "href": "new_pages/data_table.vn.html#giới-thiệu-về-data-table",
    "title": "50  Data Table",
    "section": "",
    "text": "Nhập dữ liệu và sử dụng fread() và fwrite()\nChọn và lọc các hàng bằng cách sử dụng đối số i\nSử dụng các hàm trợ giúp %like%, %chin%, %between%\nChọn và tính toán trên các cột bằng cách sử dụng đối số j\nTính toán theo nhóm bằng cách sử dụng đối số by\nThêm và cập nhật dữ liệu vào data table bằng cách sử dụng :=",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Data Table</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.vn.html#gọi-package-và-nhập-dữ-liệu",
    "href": "new_pages/data_table.vn.html#gọi-package-và-nhập-dữ-liệu",
    "title": "50  Data Table",
    "section": "50.2 Gọi package và nhập dữ liệu",
    "text": "50.2 Gọi package và nhập dữ liệu\n\nGọi package\nSử dụng hàm p_load() từ pacman, chúng ta sẽ gọi (và cài đặt nếu cần) các package cần thiết cho phân tích này.\n\npacman::p_load(\n  rio,        # to import data\n  data.table, # to group and clean data\n  tidyverse,  # allows use of pipe (%&gt;%) function in this chapter\n  here \n  ) \n\n\n\nNhập dữ liệu\nChương này sẽ khám phá một số hàm cốt lõi của data.table thông qua bộ số liệu linelist đã được nhắc đền nhiều lần trong sổ tay này.\nChúng ta nhập bộ dữ liệu về các trường hợp từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn tải dữ liệu để làm theo từng bước, hãy xem hướng dẫn trong chương Tải sách và dữ liệu. Bộ dữ liệu được nhập bằng hàm import() từ package rio. Xem chương về Nhập xuất dữ liệu để biết các cách nhập dữ liệu khác nhau. Từ đây chúng tôi sử dụng data.table() để chuyển data frame thành data table.\n\nlinelist &lt;- rio::import(here(\"data\", \"linelist_cleaned.xlsx\")) %&gt;% data.table()\n\nHàm fread() được sử dụng để nhập trực tiếp các delimited files phổ biến, chẳng hạn như tệp .csv, trực tiếp sang định dạng data table. Hàm này và đối tác của nó, fwrite(), được sử dụng để ghi data.table dưới dạng các delimited files phổ biến, là các tùy chọn rất nhanh và hiệu quả về mặt tính toán đối với cơ sở dữ liệu lớn.\n20 hàng đầu tiên của linelist:\nCác lệnh base R như dim() được sử dụng cho data frame cũng có thể được sử dụng cho data table\n\ndim(linelist) #gives the number of rows and columns in the data table\n\n[1] 5888   30",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Data Table</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.vn.html#đối-số-i-chọn-và-lọc-hàng",
    "href": "new_pages/data_table.vn.html#đối-số-i-chọn-và-lọc-hàng",
    "title": "50  Data Table",
    "section": "50.3 Đối số i: chọn và lọc hàng",
    "text": "50.3 Đối số i: chọn và lọc hàng\nNhắc lại cấu trúc DT[i, j, by], chúng ta có thể lọc các hàng bằng cách sử dụng số hàng hoặc biểu thức logic. Đối số i là đối số đầu tiên; do đó, cú pháp DT[i] hoặc DT[i,] có thể được sử dụng.\nVí dụ đầu là việc truy xuất 5 hàng đầu tiên của data table, ví dụ thứ hai là tập hợp các trường hợp từ 18 tuổi trở lên và ví dụ thứ ba là tập hợp các trường hợp từ 18 tuổi trở lên nhưng không được chẩn đoán tại Bệnh viện Trung tâm (Central Hospital):\n\nlinelist[1:5] #returns the 1st to 5th row\nlinelist[age &gt;= 18] #subsets cases are equal to or over 18 years\nlinelist[age &gt;= 18 & hospital != \"Central Hospital\"] #subsets cases equal to or over 18 years old but not diagnosed at the Central Hospital\n\nSử dụng .N trong đối số i đại diện cho tổng số hàng trong data table. Điều này có thể được sử dụng để subset dữ liệu dựa trên số thứ tự hàng:\n\nlinelist[.N] #returns the last row\nlinelist[15:.N] #returns the 15th to the last row\n\n\nSử dụng hàm trợ giúp để lọc\nData table sử dụng các hàm trợ giúp để việc subset các hàng trở nên dễ dàng. Hàm %like% được sử dụng để khớp với một pattern trong cột, %chin% được sử dụng để khớp với một ký tự cụ thể và hàm trợ giúp %between% được sử dụng để khớp các cột theo số thứ tự trong một phạm vi xác định trước.\nTrong các ví dụ dưới đây, chúng ta: * lọc các hàng mà biến hospital có chứa “Hospital” * lọc các hàng có kết quả là “Recover” hoặc “Death” * lọc các hàng trong độ tuổi 40-60\n\nlinelist[hospital %like% \"Hospital\"] #filter rows where the hospital variable contains “Hospital”\nlinelist[outcome %chin% c(\"Recover\", \"Death\")] #filter rows where the outcome is “Recover” or “Death”\nlinelist[age %between% c(40, 60)] #filter rows in the age range 40-60\n\n#%between% must take a vector of length 2, whereas %chin% can take vectors of length &gt;= 1",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Data Table</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.vn.html#đối-số-j-chọn-và-tính-toán-trên-cột",
    "href": "new_pages/data_table.vn.html#đối-số-j-chọn-và-tính-toán-trên-cột",
    "title": "50  Data Table",
    "section": "50.4 Đối số j: chọn và tính toán trên cột",
    "text": "50.4 Đối số j: chọn và tính toán trên cột\nSử dụng cấu trúc DT[i, j, by], chúng ta có thể chọn cột bằng cách sử dụng số hoặc tên. Đối số j là đối số thứ hai; do đó, cú pháp DT[, j] được sử dụng. Để tạo điều kiện tính toán trên đối số j, cột được bao quanh bằng cách sử dụng list() hoặc .().\n\nChọn cột\nVí dụ đầu tiên lấy các cột thứ nhất, thứ ba và thứ năm của data table, ví dụ thứ hai chọn tất cả các cột ngoại trừ các cột height, weight và gender. Ví dụ thứ ba sử dụng .() phía trước để chọn cột case_id và outcome.\n\nlinelist[ , c(1,3,5)]\nlinelist[ , -c(\"gender\", \"age\", \"wt_kg\", \"ht_cm\")]\nlinelist[ , list(case_id, outcome)] #linelist[ , .(case_id, outcome)] works just as well\n\n\n\nTính toán trên cột\nBằng cách kết hợp các đối số i và j, có thể lọc các hàng và tính toán trên các cột. Sử dụng .N trong đối số j cũng thể hiện cho tổng số hàng trong data table và có thể hữu ích để trả về số hàng sau khi lọc.\nTrong các ví dụ dưới đây, chúng tôi: * Đếm số trường hợp nằm viện trên 7 ngày * Tính tuổi trung bình của các trường hợp tử vong tại military hospital * Tính toán độ lệch chuẩn, trung vị, tuổi trung bình của các trường hợp đã khỏi bệnh tại Central Hospital\n\nlinelist[days_onset_hosp &gt; 7 , .N]\n\n[1] 189\n\nlinelist[hospital %like% \"Military\" & outcome %chin% \"Death\", .(mean(age, na.rm = T))] #na.rm = T removes N/A values\n\n        V1\n     &lt;num&gt;\n1: 15.9084\n\nlinelist[hospital == \"Central Hospital\" & outcome == \"Recover\", \n                 .(mean_age = mean(age, na.rm = T),\n                   median_age = median(age, na.rm = T),\n                   sd_age = sd(age, na.rm = T))] #this syntax does not use the helper functions but works just as well\n\n   mean_age median_age   sd_age\n      &lt;num&gt;      &lt;num&gt;    &lt;num&gt;\n1: 16.85185         14 12.93857\n\n\nHãy nhớ rằng việc sử dụng .() bao quanh đối số j sẽ tạo điều kiện thuận lợi cho việc tính toán, trả về data table và cho phép đặt tên cột.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Data Table</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.vn.html#đối-số-by-tính-toán-theo-nhóm",
    "href": "new_pages/data_table.vn.html#đối-số-by-tính-toán-theo-nhóm",
    "title": "50  Data Table",
    "section": "50.5 Đối số by: tính toán theo nhóm",
    "text": "50.5 Đối số by: tính toán theo nhóm\nĐối số by là đối số thứ ba trong cấu trúc DT[i, j, by]. Đối số by chấp nhận cả vectơ ký tự và cú pháp list() hoặc .(). Sử dụng cú pháp .() trong đối số by cho phép đổi tên cột một cách nhanh chóng.\nTrong các ví dụ dưới đây, chúng ta:\n* nhóm số trường hợp theo bệnh viện * trường hợp từ 18 tuổi trở lên, tính chiều cao và cân nặng trung bình theo giới tính và theo tình trạng hồi phục hay tử vong * trong những lần nhập viện kéo dài trên 7 ngày, đếm số trường hợp theo tháng họ nhập viện và theo bệnh viện họ nằm\n\nlinelist[, .N, .(hospital)] #the number of cases by hospital\n\n                               hospital     N\n                                 &lt;char&gt; &lt;int&gt;\n1:                                Other   885\n2:                              Missing  1469\n3: St. Mark's Maternity Hospital (SMMH)   422\n4:                        Port Hospital  1762\n5:                    Military Hospital   896\n6:                     Central Hospital   454\n\nlinelist[age &gt; 18, .(mean_wt = mean(wt_kg, na.rm = T),\n                             mean_ht = mean(ht_cm, na.rm = T)), .(gender, outcome)] #NAs represent the categories where the data is missing\n\n   gender outcome  mean_wt  mean_ht\n   &lt;char&gt;  &lt;char&gt;    &lt;num&gt;    &lt;num&gt;\n1:      m Recover 71.90227 178.1977\n2:      f   Death 63.27273 159.9448\n3:      m   Death 71.61770 175.4726\n4:      f    &lt;NA&gt; 64.49375 162.7875\n5:      m    &lt;NA&gt; 72.65505 176.9686\n6:      f Recover 62.86498 159.2996\n7:   &lt;NA&gt; Recover 67.21429 175.2143\n8:   &lt;NA&gt;   Death 69.16667 170.7917\n9:   &lt;NA&gt;    &lt;NA&gt; 70.25000 175.5000\n\nlinelist[days_onset_hosp &gt; 7, .N, .(month = month(date_hospitalisation), hospital)]\n\n    month                             hospital     N\n    &lt;num&gt;                               &lt;char&gt; &lt;int&gt;\n 1:     5                    Military Hospital     3\n 2:     6                        Port Hospital     4\n 3:     7                        Port Hospital     8\n 4:     8 St. Mark's Maternity Hospital (SMMH)     5\n 5:     8                    Military Hospital     9\n 6:     8                                Other    10\n 7:     8                        Port Hospital    10\n 8:     9                        Port Hospital    28\n 9:     9                              Missing    27\n10:     9                     Central Hospital    10\n11:     9 St. Mark's Maternity Hospital (SMMH)     6\n12:    10                              Missing     2\n13:    10                    Military Hospital     3\n14:     3                        Port Hospital     1\n15:     4                    Military Hospital     1\n16:     5                                Other     2\n17:     5                     Central Hospital     1\n18:     5                              Missing     1\n19:     6                              Missing     7\n20:     6 St. Mark's Maternity Hospital (SMMH)     2\n21:     6                    Military Hospital     1\n22:     7                    Military Hospital     3\n23:     7                                Other     1\n24:     7                              Missing     2\n25:     7 St. Mark's Maternity Hospital (SMMH)     1\n26:     8                     Central Hospital     2\n27:     8                              Missing     6\n28:     9                                Other     9\n29:     9                    Military Hospital    11\n30:    10                        Port Hospital     3\n31:    10                                Other     4\n32:    10 St. Mark's Maternity Hospital (SMMH)     1\n33:    10                     Central Hospital     1\n34:    11                              Missing     2\n35:    11                        Port Hospital     1\n36:    12                        Port Hospital     1\n    month                             hospital     N\n\n\nData.table cũng cho phép các biểu thức chuỗi như sau:\n\nlinelist[, .N, .(hospital)][order(-N)][1:3] #1st selects all cases by hospital, 2nd orders the cases in descending order, 3rd subsets the 3 hospitals with the largest caseload\n\n            hospital     N\n              &lt;char&gt; &lt;int&gt;\n1:     Port Hospital  1762\n2:           Missing  1469\n3: Military Hospital   896\n\n\nTrong các ví dụ này, chúng ta đang tuân theo giả định rằng một hàng trong data table tương đương với một trường hợp mới, vì vậy chúng ta có thể sử dụng .N để thể hiện số hàng trong data table. Một hàm hữu ích khác thể hiện số lượng các trường hợp duy nhất là uniqueN(), hàm này trả về số lượng các giá trị duy nhất trong một đầu vào nhất định.\n\nlinelist[, .(uniqueN(gender))] #remember .() in the j argument returns a data table\n\n      V1\n   &lt;int&gt;\n1:     3\n\n\nĐáp án là 3, vì các giá trị duy nhất trong cột gender là m, f và N/A. So sánh với hàm base R là unique(), trả về tất cả các giá trị duy nhất trong một đầu vào nhất định:\n\nlinelist[, .(unique(gender))]\n\n       V1\n   &lt;char&gt;\n1:      m\n2:      f\n3:   &lt;NA&gt;\n\n\nĐể tìm số trường hợp duy nhất trong một tháng (month) nhất định, chúng tôi sẽ viết như sau:\n\nlinelist[, .(uniqueN(case_id)), .(month = month(date_hospitalisation))]\n\n    month    V1\n    &lt;num&gt; &lt;int&gt;\n 1:     5    62\n 2:     6   100\n 3:     7   198\n 4:     8   509\n 5:     9  1170\n 6:    10  1228\n 7:    11   813\n 8:    12   576\n 9:     1   434\n10:     2   310\n11:     3   290\n12:     4   198",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Data Table</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.vn.html#thêm-và-cập-nhật-dữ-liệu-vào-data-table",
    "href": "new_pages/data_table.vn.html#thêm-và-cập-nhật-dữ-liệu-vào-data-table",
    "title": "50  Data Table",
    "section": "50.6 Thêm và cập nhật dữ liệu vào data table",
    "text": "50.6 Thêm và cập nhật dữ liệu vào data table\nToán tử := được sử dụng để thêm hoặc cập nhật dữ liệu trong data table. Việc thêm cột vào data table của bạn có thể được thực hiện theo những cách dưới đây:\n\nlinelist[, adult := age &gt;= 18] #adds one column\nlinelist[, c(\"child\", \"wt_lbs\") := .(age &lt; 18, wt_kg*2.204)] #to add multiple columns requires c(\"\") and list() or .() syntax\nlinelist[, `:=` (bmi_in_range = (bmi &gt; 16 & bmi &lt; 40),\n                         no_infector_source_data = is.na(infector) | is.na(source))] #this method uses := as a functional operator `:=`\nlinelist[, adult := NULL] #deletes the column\n\nCác tổ hợp phức tạp hơn nằm ngoài phạm vi của chương giới thiệu này, nhưng ý tưởng của chương này là cung cấp một giải pháp thay thế phổ biến và khả thi cho dplyr để phân nhóm và làm sạch dữ liệu. Package data.table là một package tốt giúp code gọn gàng và dễ đọc.",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Data Table</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.vn.html#tài-nguyên-học-liệu",
    "href": "new_pages/data_table.vn.html#tài-nguyên-học-liệu",
    "title": "50  Data Table",
    "section": "50.7 Tài nguyên học liệu",
    "text": "50.7 Tài nguyên học liệu\nĐể có thêm thông tin, dưới đây là một số tài nguyên hữu ích: * https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html * https://github.com/Rdatatable/data.table * https://s3.amazonaws.com/assets.datacamp.com/img/blog/data+table+cheat+sheet.pdf * https://www.machinelearningplus.com/data-manipulation/datatable-in-r-complete-guide/ * https://www.datacamp.com/community/tutorials/data-table-r-tutorial\nBạn có thể thực hiện bất kỳ chức năng tóm tắt nào trên dữ liệu được nhóm; xem Cheat Sheet tại đây để có thêm thông tin: https://s3.amazonaws.com/assets.datacamp.com/blog_assets/datatable_Cheat_Shgiteet_R.pdf",
    "crumbs": [
      "Các chủ điểm khác",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Data Table</span>"
    ]
  }
]