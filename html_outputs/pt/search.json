[
  {
    "objectID": "index.pt.html",
    "href": "index.pt.html",
    "title": "Manual de R para Epidemiologistas",
    "section": "",
    "text": "Bem-vindo",
    "crumbs": [
      "Bem-vindo"
    ]
  },
  {
    "objectID": "index.pt.html#r-para-epidemiologia-aplicada-e-saúde-pública",
    "href": "index.pt.html#r-para-epidemiologia-aplicada-e-saúde-pública",
    "title": "Manual de R para Epidemiologistas",
    "section": "R para epidemiologia aplicada e saúde pública",
    "text": "R para epidemiologia aplicada e saúde pública\nUso: Esse manual já foi utilizado mais de 1 milhão de vezes por 450,000 pessoas ao redor do mundo.\nObjetivo: Servir como um guia de referência rápido para escrever código em R (online e offline) com exemplos centrados em exercícios que abordam problemas epidemiológicos comuns.\nVocê está começando a aprender R agora? Conheça nossos tutoriais interativos gratuitos ou o curso introdutório síncrono e virtual utilizado pelo CDC dos EUA, pela OMS, e mais de 75 outras agências de saúde e programas de treinamento em Epidemiologia de Campo.\nIdiomas: Inglês (English), Francês (Français), Espanhol (Español), Vietnamita (Tiếng Việt), Japonês (日本), Turco (Türkçe), Português, Russo (Русский)\nEsta é uma versão traduzida para Português. Se você quer colaborar em melhorá-la, corrigindo algum erro, ou traduzir para outro idoma, por favor, nos contate!\n Escrito por epidemiologistas, para epidemiologistas\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n\nApplied Epi é uma organização sem fins lucrativos e um movimento de base composto por profissionais epidemiologistas que atuam na linha de frente de todo o mundo. Escrevemos em nosso tempo livre para oferecer este recurso à comunidade. Seu incentivo e feedback são muito bem-vindos:\n\nVisite nosso website e junte-se a nossa lista de contatos\n\ncontact@appliedepi.org, tweet @appliedepi, ou LinkedIn\n\nEnvie problemas para o nosso repositório Github\n\nOferecemos treinamento em R ao vivo ministrado por instrutores com décadas de experiência em epidemiologia aplicada - envie-nos um e-mail para discutir.",
    "crumbs": [
      "Bem-vindo"
    ]
  },
  {
    "objectID": "index.pt.html#como-usar-este-manual",
    "href": "index.pt.html#como-usar-este-manual",
    "title": "Manual de R para Epidemiologistas",
    "section": "Como usar este manual",
    "text": "Como usar este manual\n\nNavegue pelas páginas do Índice, ou use a caixa de busca\nClique nos ícones “copiar” para copiar o código\n\nVocê pode seguir - junto com os dados do exemplo.\n\nConsulte a seção “Recursos” de cada página para obter mais material\n\nVersão off-line\nVeja as instruções na página Fazer o Download do manual e dos dados.",
    "crumbs": [
      "Bem-vindo"
    ]
  },
  {
    "objectID": "index.pt.html#agradecimentos",
    "href": "index.pt.html#agradecimentos",
    "title": "Manual de R para Epidemiologistas",
    "section": "Agradecimentos",
    "text": "Agradecimentos\nEste manual é produzido por uma colaboração de epidemiologistas de todo o mundo, aproveitando a experiência de organizações que incluem agências de saúde locais, estaduais, provinciais e nacionais, a Organização Mundial da Saúde (OMS), Médicos Sem Fronteiras / Médicos sem Fronteiras (MSF), sistemas hospitalares e instituições acadêmicas.\nEste manual não é um produto aprovado de qualquer organização específica. Embora nos esforcemos para ser precisos, não damos nenhuma garantia do conteúdo deste livro.\n\nColaboradores\nEditor: Neale Batra\nAutores: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, Isaac Florence, Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonathan Polonsky, Yurie Izawa, Chris Bailey, Daniel Molling, Isha Berry, Emma Buajitti, Mathilde Mousset, Sara Hollis, Wen Lin\nRevisores: Pat Keating, Annick Lenglet, Margot Charette, Danielly Xavier, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Kate Kelsey, Berhe Etsay, John Rossow, Mackenzie Zendt, James Wright, Laura Haskins, Flavio Finger, Tim Taylor, Jae Hyoung Tim Lee, Brianna Bradley, Wayne Enanoria, Manual Albela Miranda, Molly Mantus, Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao Muianga\nIlustradores: Calder Fong\nTradutores da versão em língua portuguesa (Brasil): Carolina Musso, César Augusto Galvão , Halian Vilela, Laís Relvas, Felipe Cardoso, Rafaela Tadei, Pauliana Galvão, Nathalia Zini, Paula Maçaira, João Pedro Angelici, Ademar Barbosa Dantas Junior, Eucilene Santana, Hudson Gabriel Virtuoso Fontenele, Lucca Nielsen\nOs tradutores agradecem ProEpi pelo apoio para tradução e contato com a Applied Epi.\n\n\n\n\n\n\nFinanciamento e apoio\nO manual recebeu financiamento de apoio através de uma subvenção de emergência COVID-19 da TEPHINET, a rede global de Programas de Treinamento em Epidemiologia de Campo (FETPs).\nO apoio administrativo foi fornecido pela EPIET Alumni Network (EAN), com agradecimentos especiais à Annika Wendland. O EPIET é o Programa Europeu de Treinamento em Epidemiologia de Intervenção.\nAgradecimentos especiais aos Médicos Sem Fronteiras (MSF) Centro Operacional Amsterdã (OCA) por seu apoio durante o desenvolvimento deste manual.\nEsta publicação foi apoiada pelo Acordo Cooperativo número NU2GGH001873, financiado pelos Centros de Controle e Prevenção de Doenças através do TEPHINET, um programa da Força Tarefa para a Saúde Global. Seu conteúdo é de responsabilidade exclusiva dos autores e não representa necessariamente a visão oficial dos Centros de Controle e Prevenção de Doenças, do Departamento de Saúde e Serviços Humanos, The Task Force for Global Health, Inc. ou TEPHINET.\n\n\nInspiração\nA infinidade de tutoriais e vinhetas que forneceram conhecimento para o desenvolvimento do conteúdo do manual são creditados dentro de suas respectivas páginas.\nDe modo mais geral, as seguintes fontes forneceram inspiração para este manual:\nThe “R4Epis” project (colaboração entre MSF e RECON)\nR Epidemics Consortium (RECON)\nR for Data Science book (R4DS)\nbookdown: Authoring Books and Technical Documents with R Markdown\nNetlify hosts this website",
    "crumbs": [
      "Bem-vindo"
    ]
  },
  {
    "objectID": "index.pt.html#termos-de-uso-e-contribuição",
    "href": "index.pt.html#termos-de-uso-e-contribuição",
    "title": "Manual de R para Epidemiologistas",
    "section": "Termos de Uso e Contribuição",
    "text": "Termos de Uso e Contribuição\n\nLicença\nEsta obra está licenciada sob uma Licença Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\nCursos acadêmicos e programas de treinamento de epidemiologistas são bem-vindos para usar este manual com seus alunos. Se você tiver dúvidas sobre o uso pretendido, envie um e-mail para contact@appliedepi.org.\n\n\nCitação\nBatra, Neale, et ai. O Manual do Epidemiologista R. 2021. \n\n\nContribuição\nSe você quiser fazer uma contribuição de conteúdo, entre em contato conosco primeiro por meio de questões do Github ou por e-mail. Estamos implementando um cronograma de atualizações e criando um guia do contribuidor.\nObserve que o projeto epiRhandbook é lançado com um Código de Conduta do Contribuidor. Ao contribuir para este projeto, você concorda em respeitar seus termos.",
    "crumbs": [
      "Bem-vindo"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.pt.html",
    "href": "new_pages/editorial_style.pt.html",
    "title": "1  Notas editoriais e técnicas",
    "section": "",
    "text": "1.1 Abordagem e estilo\nO público em potencial para este livro é grande. Ele será certamente utilizado por pessoas muito novas no R, e também por usuários experientes do R que procuram as melhores práticas e dicas. Portanto, deve ser ao mesmo tempo acessível e sucinto. Portanto, a nossa abordagem foi fornecer o suficiente no texto para que alguém muito novo no R possa aplicar o código e seguir o que o código está fazendo.\nAlguns outros pontos:",
    "crumbs": [
      "Sobre este livro",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Notas editoriais e técnicas</span>"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.pt.html#abordagem-e-estilo",
    "href": "new_pages/editorial_style.pt.html#abordagem-e-estilo",
    "title": "1  Notas editoriais e técnicas",
    "section": "",
    "text": "Este é um livro de referência de códigos, acompanhado de exemplos relativamente breves - não um livro de texto completo sobre R ou sobre ciência de dados\n\nEste é um manual de R para utilização no âmbito da epidemiologia aplicada - não um manual sobre os métodos ou a ciência da epidemiologia aplicada\n\nEste destina-se a ser um documento “vivo” - os pacotes R que são ideais para uma determinada tarefa tendem a mudar frequentemente, e estamos abertos a discussão sobre qual pacote deveríamos enfatizar neste manual\n\n\nPacotes do R\nSão tantas escolhas\nUm dos aspectos mais desafiadores da aprendizagem de R é saber qual o pacote R utilizar para uma dada tarefa. É uma ocorrência comum esforçar-se demais em uma tarefa e só mais tarde perceber - ei, há um pacote R que faz tudo isso numa única linha de código!\nNeste manual, tentamos oferecer-lhe pelo menos duas formas de completar cada tarefa: um método experimentado e validado (provavelmente em R base ou tidyverse) e um pacote especial R que tenha sido construído para esse fim. Queremos que tenham algumas opções caso não consigam fazer o download de um determinado pacote ou que este não funcione.\nAo escolher os pacotes a utilizar, nós demos prioridade aos pacotes R e às abordagens que foram testados e aprovados pela comunidade. Também minimizamos o número de pacotes utilizados numa sessão de trabalho típica, e escolhemos aqueles que são estáveis (não mudam com muita frequência), e que cumprem a tarefa de forma simples e limpa\nEste manual dá, de modo geral, prioridade aos pacotes e funções R do tidyverse. Tidyverse é uma colecção de pacotes de R concebidos para a ciência de dados que partilham gramática e estruturas de dados em comum. Todos os pacotes do tidyverse podem ser instalados ou carregados através do pacote tidyverse. Leia mais em tidyverse website.\nQuando aplicável, também oferecemos opções de código usando o R base - os pacotes e funções que já vêm com R na sua instalação. Isto porque reconhecemos que parte do público deste livro podem não ter Internet estável para realizar o download de pacotes extra.\nExplicitando os pacotes de origem de cada função\nGeralmente é frustrante quando, nos tutoriais de R, uma função é mostrada em código, mas não se sabe de que pacote ela é! Tentamos evitar esta situação.\nNo texto narrativo, os nomes dos pacotes são escritos a negrito (por exemplo dplyr) e as funções são escritas desta forma: mutate(). Esforçamo-nos por ser explícitos sobre de que pacote vem uma função, seja referenciando o pacote em texto próximo ou especificando o pacote explicitamente no código: dplyr::mutate(). Pode parecer redundante, mas estamos fazendo isso de propósito.\nVeja a página em Introdução ao R para saber mais sobre pacotes e funções.\n\n\nEstilo do código\nNo manual, nós utilizamos frequentemente “novas linhas”, fazendo o nosso código parecer “longo”. Fazemos isso por algumas razões:\n\nDessa forma podemos escrever comentários explicativos com `#’, colocando-os posicionados de forma adjacente a cada pequena parte do código\n\nGeralmente, o código mais longo (vertical) é mais fácil de ler\n\nÉ mais fácil de ler em uma tela estreita (não é necessária rolagem lateral)\n\nA partir das indentações, pode ser mais fácil saber que argumentos pertencem a que função\n\nComo resultado, código que poderia ser escrito desta forma:\n\nlinelist %&gt;% \n  group_by(hospital) %&gt;%  # agrupe as linhas por hospital\n  slice_max(date, n = 1, with_ties = F) # se houver um empate (de data), pegue a primeira linha\n\n…é escrito assim:\n\nlinelist %&gt;% \n  group_by(hospital) %&gt;% # agrupe as linhas por hospital\n  slice_max(\n    date,                # mantenha a linha que contem o valor máximo de data para cada grupo k\n    n = 1,               # mantenha unicamente a linha com o valor mais alto\n    with_ties = F)       # se houver um empate (de data), pegue a primeira linha\n\nO código R não é geralmente afetado por novas linhas ou indentações. Ao escrever o código, se você iniciar uma nova linha após uma vírgula, ele aplicará padrões de recuo automáticamente.\nTambém utilizamos muitos espaços (por exemplo n = 1 em vez de n=1) porque é mais fácil de ler. Seja gentil com as pessoas que lêem o seu código!\n\n\nNomenclatura\nNeste manual, referimos geralmente “colunas” e “linhas” em vez de “variáveis” e “observações”. Como explicado neste manual em “tidy data”, a maioria dos conjuntos de dados estatísticos epidemiológicos consistem estruturalmente em linhas, colunas e valores.\nAs variáveis contêm os valores que medem o mesmo atributo subjacente (como grupo etário, resultado, ou data de início). Observações contêm todos os valores medidos na mesma unidade (por exemplo, uma pessoa, local, ou amostra de laboratório). Portanto, estes aspectos podem ser mais difíceis de definir de forma tangível.\nEm conjuntos de dados “arrumados” (tidy), cada coluna é uma variável, cada linha é uma observação, e cada célula é um valor único. No entanto, alguns conjuntos de dados que encontrarem podem não seguir esse modelo - um conjunto de dados de formato “largo” pode ter uma variável dividida em várias colunas (ver um exemplo na página Pivoteando Dados). Da mesma forma, uma única observação pode estar divididas em várias linhas.\nA maior parte deste manual trata da gestão e transformação de dados, e por isso, se referir às estruturas concretas de dados (linhas e colunas) é mais relevante do que se referir às observações e às variáveis de forma mais abstractas. As exceções ocorrem principalmente em páginas sobre análise de dados, onde se verá mais referências a variáveis e observações.\n\n\nNotas\nAqui estão os tipos de notas que você poderá encontrar neste manual:\nNOTA: Isso é uma nota\nDICA: Isso é uma dica.\nCUIDADO: Esta é uma nota de precaução.\nPERIGO: Isso é uma advertência.",
    "crumbs": [
      "Sobre este livro",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Notas editoriais e técnicas</span>"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.pt.html#decisões-editoriais",
    "href": "new_pages/editorial_style.pt.html#decisões-editoriais",
    "title": "1  Notas editoriais e técnicas",
    "section": "1.2 Decisões editoriais",
    "text": "1.2 Decisões editoriais\nAbaixo, relacionamos decisões editoriais significativas em torno da escolha do pacote e da função. Se discordar ou quiser oferecer uma nova ferramenta para consideração, por favor, junte-se/ inicie uma conversa na nossa página Github.\nTabela de pacote, função, e outras decisões editoriais*\n\n\n\n\n\n\n\n\n\nAssunto\nPOssibilidades\nEscolha\nBreve justificativa\n\n\n\n\nAbordagem geral para escrita do código\ntidyverse, data.table, base\ntidyverse, com uma página sobre data.table, e menções a alternativas em R base para leitores sem internet\nA facilidade de leitura proporcionada pelo tidyverse, elém da sua universalidade e maior utilização para ensino.\n\n\nCarregamento de pacotes\nlibrary(),install.packages(), require(), pacman\npacman\nEncurta e simplifica o código para a maioria dos casos de instalação/carregamento de vários pacotes\n\n\nImportar e Exportar\nrio, muitos outros pacotes\nrio\nFácil para muitos tipos de arquivo\n\n\nAgrupamento para estatísticas resumo\ndplyr group_by(), stats aggregate()\ndplyr group_by()\nCompatível com a ênfase em tidyverse\n\n\nPivotamento (\ntidyr (funções de pivotamento), reshape2 (melt/cast), tidyr (spread/gather)\ntidyr (funções de pivotamento)\nreshape2 está em desuso, tidyr usa funções de pivotamento desde a versão v1.0.0\n\n\nLimpar nome das colunas\nlinelist, janitor\njanitor\nConsolidação de pacotes enfatizada\n\n\nEpiweeks\nlubridate, aweek, tsibble, zoo\nlubridate de modo geral, os outros em casos específicos\nA flexibilidade, consistência e perspectiva de manutenção do pacote lubridate\n\n\nRótulos/Legendas do ggplot\nlabs(), ggtitle()/ylab()/xlab()\nlabs()\ntodos os rótulos em um lugar, simplicidade\n\n\nConverter para fator\nfactor(), forcats\nforcats\nsuas várias funções tembém convertem para o formato de fator em um memso comando\n\n\nCurvas epidêmicas\nincidence, ggplot2, EpiCurve\nincidence2 para rapidez, ggplot2 para detalhamento\nfiabilidade\n\n\nConcatenação\npaste(), paste0(), str_glue(), glue()\nstr_glue()\nFunções com sintaxe mais simples do que as funções paste; está contido stringr",
    "crumbs": [
      "Sobre este livro",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Notas editoriais e técnicas</span>"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.pt.html#principais-revisões",
    "href": "new_pages/editorial_style.pt.html#principais-revisões",
    "title": "1  Notas editoriais e técnicas",
    "section": "1.3 Principais revisões",
    "text": "1.3 Principais revisões\n\n\n\nData\nPrincipais mudanças\n\n\n\n\n10 Maio 2021\nLançamento da versão 1.0.0",
    "crumbs": [
      "Sobre este livro",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Notas editoriais e técnicas</span>"
    ]
  },
  {
    "objectID": "new_pages/editorial_style.pt.html#informação-da-sessão-r-rstudio-pacotes",
    "href": "new_pages/editorial_style.pt.html#informação-da-sessão-r-rstudio-pacotes",
    "title": "1  Notas editoriais e técnicas",
    "section": "1.4 Informação da sessão (R, RStudio, pacotes)",
    "text": "1.4 Informação da sessão (R, RStudio, pacotes)\nAbaixo estão as informações sobre as versões dos pacotes R, RStudio, e R utilizados durante esta elaboração deste Manual.\n\nsessioninfo::session_info()\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31 ucrt)\n os       Windows 11 x64 (build 22621)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       Europe/Stockholm\n date     2024-05-08\n pandoc   3.1.11 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n cli           3.6.2   2023-12-11 [2] CRAN (R 4.3.2)\n digest        0.6.35  2024-03-11 [1] CRAN (R 4.3.3)\n evaluate      0.23    2023-11-01 [2] CRAN (R 4.3.2)\n fastmap       1.1.1   2023-02-24 [2] CRAN (R 4.3.2)\n htmltools     0.5.8   2024-03-25 [1] CRAN (R 4.3.3)\n htmlwidgets   1.6.4   2023-12-06 [2] CRAN (R 4.3.2)\n jsonlite      1.8.8   2023-12-04 [2] CRAN (R 4.3.2)\n knitr         1.45    2023-10-30 [2] CRAN (R 4.3.2)\n rlang         1.1.3   2024-01-10 [2] CRAN (R 4.3.2)\n rmarkdown     2.26    2024-03-05 [1] CRAN (R 4.3.3)\n rstudioapi    0.15.0  2023-07-07 [2] CRAN (R 4.3.2)\n sessioninfo   1.2.2   2021-12-06 [2] CRAN (R 4.3.2)\n xfun          0.43    2024-03-25 [1] CRAN (R 4.3.3)\n\n [1] C:/Users/ngulu864/AppData/Local/R/win-library/4.3\n [2] C:/Program Files/R/R-4.3.2/library\n\n──────────────────────────────────────────────────────────────────────────────",
    "crumbs": [
      "Sobre este livro",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Notas editoriais e técnicas</span>"
    ]
  },
  {
    "objectID": "new_pages/data_used.pt.html",
    "href": "new_pages/data_used.pt.html",
    "title": "2  Baixe o livro e os dados",
    "section": "",
    "text": "2.1 Baixe o livro offline\nVocê pode baixar a versão offline deste livro como um arquivo HTML para que você possa ver o arquivo em seu navegador, mesmo se você não tiver mais acesso à Internet. Se você está considerando o uso offline do livro do Epi R, aqui estão algumas coisas a serem consideradas:\nExistem duas maneiras de baixar o livro:",
    "crumbs": [
      "Sobre este livro",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Baixe o livro e os dados</span>"
    ]
  },
  {
    "objectID": "new_pages/data_used.pt.html#baixe-o-livro-offline",
    "href": "new_pages/data_used.pt.html#baixe-o-livro-offline",
    "title": "2  Baixe o livro e os dados",
    "section": "",
    "text": "Quando você abre o arquivo, pode levar um ou dois minutos para as imagens e o índice serem carregados\n\nO livro off-line tem um layout ligeiramente diferente - uma página muito longa com Índice à esquerda. Para pesquisar termos específicos, use Ctrl+f (Cmd+f)\n\nConsulte a página Pacotes sugeridos para ajudá-lo a instalar os pacotes R apropriados antes que você perca a conectividade com a Internet\n\nInstale nosso pacote R epirhandbook que contém todos os dados de exemplo (processo de instalação descrito abaixo)\n\n\n\nUse o link de download\nPara acesso rápido, clique com o botão direito neste link e selecione “Salvar link como”.\nSe estiver em um Mac, use Cmd+clique. Se estiver em um celular, pressione e segure o link e selecione “Salvar link”. O livro será baixado para o seu dispositivo. Se uma tela com código HTML bruto for exibida, certifique-se de seguir as instruções acima ou tente a Opção 2.\n\n\nUse nosso pacote R\nOferecemos um pacote R denominado epirhandbook. Inclui uma função download_book () que baixa o arquivo do livro de nosso repositório Github para o seu computador.\nEste pacote também contém uma função get_data() que baixa todos os dados de exemplo para o seu computador.\nExecute o seguinte código para instalar nosso pacote R epirhandbook do repositório Github applyepi. Este pacote não está no CRAN, então use a função especial p_install_gh() para instalá-lo do Github.\n\n# instale a última versão do pacote do livro do Epi R\npacman::p_install_gh(\"appliedepi/epirhandbook\")\n\nAgora, carregue o pacote para uso em sua sessão R atual:\n\n# carregue o pacote para uso\npacman::p_load(epirhandbook)\n\nEm seguida, execute a função do pacote download_book() (com parênteses vazios) para baixar o livro para o seu computador. Supondo que você esteja no RStudio, uma janela aparecerá permitindo que você selecione um local para salvar.\n\n# baixe o livro offline para o seu computador\ndownload_book()",
    "crumbs": [
      "Sobre este livro",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Baixe o livro e os dados</span>"
    ]
  },
  {
    "objectID": "new_pages/data_used.pt.html#baixe-os-dados-para-acompanhar",
    "href": "new_pages/data_used.pt.html#baixe-os-dados-para-acompanhar",
    "title": "2  Baixe o livro e os dados",
    "section": "2.2 Baixe os dados para acompanhar",
    "text": "2.2 Baixe os dados para acompanhar\nPara acompanhar as páginas do livro, você pode baixar os dados e resultados de exemplo.\n\nUse nosso pacote R\nA abordagem mais fácil para baixar todos os dados é instalar nosso pacote R epirhandbook. Ele contém uma função get_data() que salva todos os dados de exemplo em uma pasta de sua escolha em seu computador.\nPara instalar nosso pacote R epirhandbook, execute o seguinte código. Este pacote não está no CRAN, então use a função p_install_gh() para instalá-lo. A entrada faz referência à nossa organização Github (“appliedepi”) e o pacote epirhandbook.\n\n# instale a última versão do pacote do livro do Epi R\npacman::p_install_gh(\"appliedepi/epirhandbook\")\n\nAgora, carregue o pacote para uso em sua sessão R atual:\n\n# carregue o pacote para uso\npacman::p_load(epirhandbook)\n\nA seguir, use a função do pacote get_data() para baixar os dados de exemplo para o seu computador. Execute get_data(\"all\") para obter todos os dados de exemplo ou forneça um nome de arquivo específico e extensão entre aspas para recuperar apenas um arquivo.\nOs dados já foram baixados com o pacote e simplesmente precisam ser transferidos para uma pasta em seu computador. Uma janela pop-up aparecerá, permitindo que você selecione um local para salvar a pasta. Sugerimos que você crie uma nova pasta de “dados”, pois há cerca de 30 arquivos (incluindo dados de exemplo e saídas de exemplo).\n\n# baixe todos os dados de exemplo em uma pasta em seu computador\nget_data(\"all\")\n\n# baixe apenas os dados de exemplo da lista de linha em uma pasta em seu computador\nget_data(file = \"linelist_cleaned.rds\")\n\n\n# baixe um arquivo específico em uma pasta em seu computador\nget_data(\"linelist_cleaned.rds\")\n\nDepois de usar get_data() para salvar um arquivo em seu computador, você ainda precisará importá-lo para R. Consulte a página Importar e exportar para obter detalhes.\nSe desejar, você pode revisar todos os dados usados neste livro na pasta “data” de nosso repositório Github.\n\n\nBaixe um por um\nEsta opção envolve o download dos dados arquivo por arquivo de nosso repositório Github por meio de um link ou de um comando R específico para o arquivo. Alguns tipos de arquivo permitem um botão de download, enquanto outros podem ser baixados por meio de um comando R.\n\n“Linelist” de casos\nEste é um surto fictício de Ebola, expandido pela equipe do livro a partir do conjunto de dados de prática ebola_sim no pacote outbreaks.\n\n Clique para baixar a linelist “bruta” (.xlsx)  . A linelist do caso “bruta” é uma planilha do Excel com dados confusos. Use-o para acompanhar a página Limpeza de dados e funções principais.\n\nSe você quiser acompanhar,  clique para baixar o linelist “limpo” (clean)  (as .rds file). Use este arquivo para todas as outras páginas deste livro que usam a lista de linha. Um arquivo .rds é um tipo de arquivo específico de R que preserva classes de coluna. Isso garante que você terá apenas uma limpeza mínima para fazer após importar os dados para R.\nOutros arquivos relacionados:\nSe você quiser acompanhar,  clique para baixar o linelist “limpo” (clean)  (as .rds file).\n\nParte da página de limpeza usa um “dicionário de limpeza” (arquivo .csv). Você pode carregá-lo diretamente no R executando os seguintes comandos:\n\n\npacman::p_load(rio) # instalar / carregar o pacote rio\n\n# importe o arquivo diretamente do Github\ncleaning_dict &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/cleaning_dict.csv\")\n\n\n\nDados de contagem de malária\nEsses dados são contagens fictícias de casos de malária por faixa etária, serviço e dia. Um arquivo .rds é um tipo de arquivo específico de R que preserva classes de coluna. Isso garante que você terá apenas uma limpeza mínima para fazer após importar os dados para R.\n Clique para fazer o download  os dados de contagem de malária (arquivo .rds)  \n\n\nDados em escala Likert\nEstes são dados fictícios de uma pesquisa no estilo Likert, usados na página Pirâmides demográficas e escalas Likert. Você pode carregar esses dados diretamente no R executando os seguintes comandos:\n\npacman::p_load(rio) # instalar / carregar o pacote rio\n\n# importe o arquivo diretamente do Github\nlikert_data &lt;- import(\"https://raw.githubusercontent.com/appliedepi/epirhandbook_eng/master/data/likert_data.csv\")\n\n\n\nPainéis com flexdashboard\nAbaixo estão os links para o arquivo associado à página em Painéis (Dashboards) com R Markdown:\n\nPara baixar o R Markdown para o painel de surto, clique com o botão direito neste link (Cmd + clique para Mac) e selecione “Salvar link como”.\n\nPara baixar o painel HTML, clique com o botão direito neste link (Cmd + clique para Mac) e selecione “Salvar link como”.\n\n\n\nRastreamento de contato\nA página Rastreamento de contato demonstra a análise dos dados de rastreamento de contato, usando dados de exemplo de [Go.Data] (https://github.com/WorldHealthOrganization/godata/tree/master/analytics/r-reporting). Os dados usados na página podem ser baixados como arquivos .rds clicando nos seguintes links:\n Clique para fazer o download  os dados de investigação do caso (arquivo .rds)  \n Clique para fazer o download  os dados de registro do contato (arquivo .rds)  \n Clique para fazer o download  os dados de acompanhamento do contato (arquivo .rds)  \n NOTA: Dados de rastreamento de contato estruturado de outro software (por exemplo, KoBo, DHIS2 Tracker, CommCare) podem parecer diferentes. Se desejar contribuir com dados de amostra ou conteúdo alternativo para esta página, entre em contato. \n DICA: Se você estiver implantando Go.Data e quiser se conectar à API da sua instância, consulte a página Importar e exportar (seção API) e a Go.Data Community of Practice. \n\n\n\nSobre o GIS\nOs shapefiles têm muitos arquivos de subcomponentes, cada um com uma extensão de arquivo diferente. Um arquivo terá a extensão “.shp”, mas outros podem ter “.dbf”, “.prj”, etc.\nA página GIS básico fornece links para o site Humanitarian Data Exchange onde você pode baixar os shapefiles diretamente como arquivos compactados.\nPor exemplo, os dados dos pontos das unidades de saúde podem ser baixados aqui. Download “hotosm_sierra_leone_health_facilities_points_shp.zip”. Depois de salvar em seu computador, “descompacte” a pasta. Você verá vários arquivos com extensões diferentes (por exemplo, “.shp”, “.prj”, “.shx”) - todos eles devem ser salvos na mesma pasta em seu computador. Então, para importar para o R, forneça o caminho do arquivo e o nome do arquivo “.shp” para st_read() do pacote sf (conforme descrito na página Introdução ao GIS).\nSe você seguir a Opção 1 para baixar todos os dados de exemplo (por meio de nosso pacote R epirhandbook), todos os shapefiles serão incluídos.\nAlternativamente, você pode baixar os shapefiles da pasta “data” do R Handbook Github (veja a subpasta “gis”). No entanto, esteja ciente de que você precisará baixar cada subarquivo individualmente para o seu computador. No Github, clique em cada arquivo individualmente e baixe-os clicando no botão “Baixar”. Abaixo, você pode ver como o arquivo de forma “sle_adm3” consiste em muitos arquivos - cada um dos quais precisaria ser baixado do Github.\n\n\n\n\n\n\n\n\n\n\n2.2.0.1 Árvores filogenéticas\nVeja a página sobre Árvores filogenéticas. Arquivo Newick da árvore filogenética construída a partir do sequenciamento do genoma completo de 299 amostras de Shigella sonnei e dados de amostra correspondentes (convertidos em um arquivo de texto). As amostras belgas e os dados resultantes são gentilmente fornecidos pelo NRC belga para Salmonella e Shigella no âmbito de um projeto conduzido por um bolsista ECDC EUPHEM, e também serão publicados em um manuscrito. Os dados internacionais estão disponíveis abertamente em bases de dados públicas (NCBI) e foram publicados previamente.\n\nPara baixar o arquivo da árvore filogenética “Shigella_tree.txt”, clique com o botão direito neste link (Cmd + clique para Mac) e selecione “Salvar link como”.\n\nPara baixar o “sample_data_Shigella_tree.csv” com informações adicionais sobre cada amostra, clique com o botão direito neste link (Cmd + clique para Mac) e selecione “Salvar link como”.\n\nPara ver a nova árvore de subconjunto criada, clique com o botão direito neste link (Cmd + clique para Mac) e selecione “Salvar link como”. O arquivo .txt será baixado para o seu computador.\n\nVocê pode então importar os arquivos .txt com read.tree() do pacote ape, conforme explicado na página.\n\nape::read.tree(\"Shigella_tree.txt\")\n\n\n\nPadronização\nConsulte a página sobre Taxas padronizadas. Você pode carregar os dados diretamente de nosso repositório Github na Internet em sua sessão R com os seguintes comandos:\n\n# instalar / carregar o pacote rio\npacman::p_load(rio) \n\n)\n# País A\n)\n# importar dados demográficos para o país A diretamente do Github\nA_demo &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics.csv\")\n\n# importação de mortes para o país A diretamente do Github\nA_deaths &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryA.csv\")\n\n)\n# País B\n)\n# importar dados demográficos para o país B diretamente do Github\nB_demo &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics_2.csv\")\n\n# importação de mortes para o país B diretamente do Github\nB_deaths &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryB.csv\")\n\n\n)\n# População Referência \n)\n# importar dados demográficos para o país B diretamente do Github\nstandard_pop_data &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/world_standard_population_by_sex.csv\")\n\n\n\nSéries temporais e detecção de surto\nConsulte a página em Séries temporais e detecção de surto. Usamos casos de Campylobacter relatados na Alemanha 2002-2011, conforme disponível no pacote surveillance R. (nb. este conjunto de dados foi adaptado do original, em que 3 meses de dados foram excluídos do final de 2011 para fins de demonstração).\n Clique para fazer o download  Campylobacter na Alemanha (.xlsx)  \nTambém usamos dados climáticos da Alemanha 2002-2011 (temperatura em graus Celsius e queda de chuva em milímetros). Eles foram baixados do conjunto de dados de reanálise do satélite Copernicus da UE usando o pacote ecmwfr. Você precisará baixar tudo isso e importá-los com stars::read_stars() conforme explicado na página da série temporal.\n Clique para fazer o download  Alemanha meteorologia 2002 (arquivo .nc)  \n Clique para fazer o download  Alemanha meteorologia 2003 (arquivo .nc)  \n Clique para fazer o download  Alemanha meteorologia 2004 (arquivo .nc)  \n Clique para fazer o download  Clima Alemanha 2005 (arquivo .nc)  \n Clique para fazer o download  Clima Alemanha 2006 (arquivo .nc)  \n Clique para fazer o download  Clima Alemanha 2007 (arquivo .nc)  \n Clique para fazer o download  Clima Alemanha 2008 (arquivo .nc)  \n Clique para fazer o download  Clima Alemanha 2009 (arquivo .nc)  \n Clique para fazer o download  Clima Alemanha 2010 (arquivo .nc)  \n Clique para fazer o download  Clima Alemanha 2011 (arquivo .nc)  \n\n\nAnálise da pesquisa\nPara a página análise da pesquisa, usamos dados fictícios de pesquisa de mortalidade baseados em modelos de pesquisa OCA do MSF. Esses dados fictícios foram gerados como parte do projeto “R4Epis”.\n Clique para fazer o download  Dados de pesquisa fictícios (.xlsx)  \n Clique para fazer o download  Dicionário fictício de dados de pesquisa (.xlsx)  \n Clique para fazer o download  Dados fictícios da população de pesquisas (.xlsx)  \n\n\nShiny\nA página em Painéis com Shiny demonstra a construção de um aplicativo simples para exibir dados da malária.\nPara baixar os arquivos R que produzem o aplicativo Shiny:\nVocê pode  clique aqui para baixar o arquivo app.R  que contém a IU e o código do servidor para o aplicativo Shiny.  \nVocê pode  clique aqui para baixar o arquivo facility_count_data.rds   que contém dados de malária para o aplicativo Shiny. Observe que pode ser necessário armazená-lo em uma pasta “data” para que os caminhos de arquivo here() funcionem corretamente.\nVocê pode  clique aqui para baixar o arquivo global.R   que deve ser executado antes da abertura do aplicativo, conforme explicado na página.\nVocê pode  clique aqui para baixar o arquivo plot_epicurve.R   que é fornecido pela global.R. Observe que pode ser necessário armazená-lo em uma pasta “funcs” para que os caminhos de arquivo here() funcionem corretamente.",
    "crumbs": [
      "Sobre este livro",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Baixe o livro e os dados</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.pt.html",
    "href": "new_pages/basics.pt.html",
    "title": "3  Introdução ao R",
    "section": "",
    "text": "3.1 Porque usar o R?\nSegundo a definição do site R project, R é uma linguagem de programação e também um ambiente para computação estatística e gráfica. É altamente versátil, extensível, e orientado para a comunidade.\nCusto\nR é de utilização livre! Há uma política forte na comunidade para que o material seja gratuito e de código aberto.\nReprodutibilidade\nA prática de conduzir a análise e a gestão dos dados por meio de uma linguagem de programação (em comparação com o Excel ou outra dessas ferramentas que requerem cliques manuais) melhora a reprodutibilidade, torna a detecção de erros mais fácil e alivia sua carga de trabalho.\nComunidade\nA comunidade de usuários de R é enorme e colaborativa. Novos pacotes e ferramentas para resolver problemas da vida real são desenvolvidos diariamente e recebe críticas e contribuições da comunidade de utilizadores. Como um exemplo, R-Ladies é uma organização mundial cuja missão é promover a diversidade de gênero na comunidade R, e é uma das maiores organizações de utilizadores de R. É provável que tenha uma divisão perto de você!",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.pt.html#termos-chave",
    "href": "new_pages/basics.pt.html#termos-chave",
    "title": "3  Introdução ao R",
    "section": "3.2 Termos chave",
    "text": "3.2 Termos chave\nRStudio - RStudio é uma Interface Gráfica de Utilizador (GUI) para uma utilização mais fácil da linguagem R. Leia mais na secção RStudio.\nObjetos - Tudo o que se armazena em R - conjuntos de dados, variáveis, uma lista de nomes de cidades, um número total da população, mesmo saídas como gráficos - são objetos aos quais é atribuído um nome e podem ser referenciados em comandos posteriores. Ler mais na secção Objectos.\nFunções - Uma função é uma operação de código que aceita entradas e devolve uma saída transformada. Leia mais na secção Funções.\nPacotes - Um pacote R é um pacote partilhável de funções. Leia mais na secção Pacotes\nScripts/Códigos - Um script é um arquivo que contém as linhas de comando que escreveu. Leia mais na secção Scripts",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.pt.html#learning",
    "href": "new_pages/basics.pt.html#learning",
    "title": "3  Introdução ao R",
    "section": "3.3 Recursos para a aprendizagem",
    "text": "3.3 Recursos para a aprendizagem\n\nRecursos dentro do RStudio\nDocumentação de ajuda\nPesquisar na aba “Ajuda” do RStudio pela documentação sobre pacotes do R e funções específicas. Isto está dentro do painel que também contém “Arquivos”, “Gráficos” e “Pacotes” (tipicamente no painel inferior direito). Como atalho, também se pode digitar o nome de um pacote ou função no console do R após um ponto de interrogação para abrir a página de Ajuda relevante. Não inclui parênteses.\nPor exemplo: ?filter ou ?diagrammeR.\nTutoriais interativos\nHá várias maneiras de aprender R interactivamente dentro do RStudio.\nO próprio RStudio oferece um painel Tutorial que é alimentado pelo pacote do R learnr. Basta instalar este pacote e abrir um tutorial através da nova aba “Tutorial” no painel superior direito do RStudio, que também contém os separadores Environment (Ambiente) e History (Histórico).\nO pacote do R swirl oferece cursos interativos no Console do R. Instale e carregue este pacote, depois execute o comando swirl() (parênteses vazios) no Console do R. Você verá avisos aparecerem no Console. Responda digitando no Console. Ele irá guiá-lo através de um curso à sua escolha.\n\n\nPágina de dicas\nHá várias “cheatsheets” (“colinhas”) em pdf disponíveis no website do RStudio, por exemplo:\n\nFatores com o pacote forcats\nDatas e horas com o pacote lubridate\nCaracteres com o pacote stringr\nOperações iterativas com o pacote purrr\nImportação de dados\nFolha de dica para transformação de dadas com o pacote dplyr\nR Markdown (para criar documentos como PDF, Word, Powerpoint…)\nShiny (para construir aplicativos de web interativos)\nVisualização de dados com o pacote ggplot2\nCartografia (GIS)\nPacote leaflet (mapas interativos)\nPython com R (pacote reticulate)\n\nEste é um recurso online do R especificamente para usuários do Excel\n\n\nTwitter\nR tem uma vibrante comunidade no twitter onde você pode aprender dicas, atalhos e notícias, siga estas contas:\n\nSiga nos! @epiRhandbook\nR Function A Day (Uma função por dia) @rfuntionaday é um recurso incrível\nR for Data Science (R para Ciência de Dados) @rstats4ds\nRStudio @RStudio\nDicas do RStudio@rstudiotips\nR-Bloggers @Rbloggers\nR-ladies @RLadiesGlobal\nHadley Wickham @hadleywickham\n\nTambém:\n#epitwitter e #rstats\n\n\nRecursos online gratuitos\nUm texto definitivo é o livro R for Data Science de Garrett Grolemund e Hadley Wickham\nO site do projeto R4Epis tem como objetivo “desenvolver ferramentas padronizadas de limpeza, análise e relatório de dados para cobrir tipos comuns de surtos e pesquisas populacionais que seriam conduzidas em um ambiente de resposta a emergências de MSF”. Você pode encontrar materiais de treinamento básicos do R, modelos para relatórios do RMarkdown sobre surtos e pesquisas e tutoriais para ajudá-lo a configurá-los.\n\n\nIdiomas além do inglês\nMateriais do RStudio em Espanhol\nIntrodução ao R e ao tidyverse (Francês)\nCiência de Dados em R (Português)",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.pt.html#instalação",
    "href": "new_pages/basics.pt.html#instalação",
    "title": "3  Introdução ao R",
    "section": "3.4 Instalação",
    "text": "3.4 Instalação\n\nR e R Studio\nComo instalar o R\nVisite o site https://www.r-project.org/ e faça o download da versão mais recente do R que seja adequada para o seu computador.\nComo instalar o RStudio\nVisite esse website https://rstudio.com/products/rstudio/download/ e faça o download da versão gratuita mais recente para Desktop do RStudio que seja adequada para seu computador.\nPermissões\nNote que você deve instalar R e RStudio em um drive onde você tenha permissões de leitura e escrita. Caso contrário, sua capacidade de instalar pacotes R (um problema de ocorrência freqüente) será impactada. Se você encontrar problemas, tente abrir o RStudio clicando com o botão direito do mouse no ícone e selecionando “Executar como administrador”. Outras dicas podem ser encontradas na página R em unidades de rede.\nComo atualizar o R e o RStudio\nSua versão de R é exibida (“printada”) no o Console R na inicialização. Você também pode executar o sessionInfo().\nPara atualizar o R, vá para o site mencionado acima e reinstale o R. Alternativamente, você pode utilizar o pacote installr (no Windows) executando installr::updateR(). Isto abrirá caixas de diálogo para ajudá-lo a baixar a última versão R e atualizar seus pacotes para a nova versão R. Mais detalhes podem ser encontrados na installr documentação.\nEsteja ciente de que a antiga versão R ainda existirá em seu computador. Você pode executar temporariamente uma versão antiga (antiga “instalação”) do R clicando em “Tools” (Ferramentas) -&gt; “Global Options” (Opções Globais) no RStudio e escolhendo uma versão R. Isto pode ser útil se você quiser usar um pacote que não tenha sido atualizado para funcionar na versão mais nova do R.\nPara atualizar o RStudio, você pode ir ao site acima e fazer o download novamente do RStudio. Outra opção é clicar em “Help” (Ajuda) -&gt; “Check for Updates” (Verificar Atualizações) dentro do RStudio, mas isto pode não mostrar as últimas atualizações.\nPara ver quais versões do R, RStudio, ou pacotes foram usados quando este Manual foi feito, veja a página em Notas editoriais e técnicas.\n\n\nOutros softwares você pode precisar instalar\n\nTinyTeX (para compilaar documentos de RMarkdown em PDF)\nPandoc (para compilar documentos de RMarkdown)\nRTools (para construir pacotes em R)\nphantomjs (para salvar imagens ou redes animadas, como redes de transmissão)\n\n\nTinyTex\nTinyTex é uma distribuição do LaTeX customizada, útil quando for tentar produzir PDFs no R. Veja https://yihui.org/tinytex/ para mais informações.\nPara instalar o TinyTex no R:\n\ninstall.packages('tinytex')\ntinytex::install_tinytex()\n# para desisntalar o TinyTeX, corra tinytex::uninstall_tinytex()\n\n\n\nPandoc\nSua versão de R é impressa no o Console R na inicialização. Você também pode executar o Pandoc é um conversor de documentos, um software separado do R. Ele vem junto com o RStudio , provavelmente não precisará ser baixado. Ele ajuda no processo de conversão de documentos Rmarkdown para formatos como .pdf e adição de funcionalidades complexas.\n\n\nRTools\nRTools é uma coleção de softwares para construção de pacotes para R.\nInstale desse website: https://cran.r-project.org/bin/windows/Rtools/\n\n\nphantomjs\nEsta ferramenta é freqüentemente usada para tirar “fotografias da tela” de páginas da web. Por exemplo, quando você cria uma cadeia de transmissão com o pacote epicontacts, um arquivo HTML é produzido e ele é interativo e dinâmico. Se você quiser uma imagem estática, pode ser útil usar o pacote webshot para automatizar este processo. Isto exigirá o programa externo “phantomjs”. Você pode instalar o phantomjs através do pacote webshot com o comando webshot::install_phantomjs().",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.pt.html#rstudio",
    "href": "new_pages/basics.pt.html#rstudio",
    "title": "3  Introdução ao R",
    "section": "3.5 RStudio",
    "text": "3.5 RStudio\n\nSe orientando no RStudio\nPrimeiramente, abra o RStudio. Como os ícones deles podem ser muito parecidos, certifique-se de que você está abrindo mesmo o RStudio e não R.\nPara que o RStudio funcione, você também deve ter R instalado no computador (veja acima as instruções de instalação).\nRStudio é uma interface (GUI) para facilitar o uso de R. Você pode pensar em R como sendo o motor de um veículo, fazendo o trabalho crucial, e RStudio como a carroceria do veículo (com assentos, acessórios, etc.) que ajuda você realmente a usar o motor para seguir em frente! Você pode ver a ficha completa da interface de usuário do RStudio (PDF) aqui\nPor padrão, o RStudio exibe quatro painéis retangulares.\n\n\n\n\n\n\n\n\n\nDICA: Se o seu RStudio mostrar apenas um painel esquerdo, é porque não há nenhum script aberto ainda\nO Painel Fonte (Source) Este painel, por padrão localizado na parte superior esquerda, é um espaço onde é possível editar, executar e salvar seus scripts. Os scripts contêm os comandos que você deseja executar. Este painel também pode exibir conjuntos de dados (quadros de dados) para visualização.\nPara usuários da Stata, este painel é similar às janelas de seu Do-file e Data Editor.\nO Painel do Console R\nO Console R, ou simplesmente Console, é por padrão o painel esquerdo ou inferior esquerdo do RStudio. Ele é a casa do “motor” de R. É aqui que os comandos são realmente executados e as saídas não gráficas e as mensagens de erro/aviso aparecem. Você pode digitar e executar comandos diretamente no Console, mas perceba que estes comandos não são salvos como são ao executar comandos de um script.\nSe você está familiarizado com Stata, o Console R é como a Janela de Comando e também a Janela de Resultados.\nO Painel Ambiente (Environment)\nEste painel, por padrão na parte superior direita, é mais freqüentemente usado para ver resumos breves de objetos no Ambiente R na sessão atual. Estes objetos podem incluir conjuntos de dados importados, modificados ou criados, parâmetros que você definiu (por exemplo, uma semana epidemiológica específica para a análise), ou vetores ou listas que você definiu durante a análise (por exemplo, nomes de regiões). Você pode clicar na seta ao lado de um nome de data frame para ver suas variáveis.\nNo Stata, isto é mais parecido com a janela Gerenciador de Variáveis.\nEste painel também contém a aba History onde você pode ver comandos que você pode ver anteriormente. Tem também uma aba “Tutorial” onde você pode completar tutoriais R interativos se você tiver o pacote learnr instalado. Tem também um painel “Conections” para conexões externas, e pode ter um painel “Git” se você optar por fazer interface com o Github.\nPaineis: Gráficos (Plots), Visualizador (Viewer), Pacotes (Packages), Ajuda (Help)\nO painel inferior-direito inclui várias abas importantes. Gráficos típicos, incluindo mapas, serão exibidos no painel Plo. Saídas interativas ou HTML serão exibidas no painel do Visualizador (Viewer). O painel de Ajuda (Help) pode exibir documentação e arquivos de ajuda. O painel Arquivos (Files) é um navegador que pode ser usado para abrir ou excluir arquivos. O painel Pacotes (Packages) permite ver, instalar, atualizar, excluir, carregar/descarregar pacotes R, e ver qual versão do pacote você tem. Para saber mais sobre pacotes, veja a seção pacotes abaixo.\nEste painel contém os equivalentes Stata das janelas Plots Manager e Project Manager.\n\n\nConfigurações do RStudio\nAltere as configurações e a aparência do RStudio no menu suspenso Ferramentas (Tools), selecionando Opções Globais (Global Options). Lá você pode alterar as configurações padrão, incluindo a cor da aparência/fundo.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRestart (Reiniciar)\nSe seu R travar, você pode reiniciar o R indo ao menu Sessão (Session) e clicando em “Reiniciar R” (Restart R). Isto evita o incômodo de fechar e abrir o RStudio. Tudo em seu ambiente R será removido quando você fizer isso.\n\n\nAtalhos no teclado\nAlguns atalhos de teclado muito úteis estão abaixo. Veja todos os atalhos de teclado para Windows, Mac e Linux na segunda página deste RStudio cheatsheet da interface do usuário.\n\n\n\n\n\n\n\n\nWindows/Linux\nMac\nAção\n\n\n\n\nEsc\nEsc\nInterrompe comando atual  (útil se você acidentalmente executou um comando incompleto e não pode escapar de ver o “+” no console R)\n\n\nCtrl+s\nCmd+s\nSalva (script)\n\n\nTab\nTab\nAuto-completa\n\n\nCtrl + Enter\nCmd + Enter\nRoda a(s) linha(s) atual(is)/seleção de código\n\n\nCtrl + Shift + C\nCmd + Shift + c\ncomenta/descomenta as linhas selecionadas\n\n\nAlt + -\nOption + -\nInsere &lt;-\n\n\nCtrl + Shift + m\nCmd + Shift + m\nInsere %&gt;%\n\n\nCtrl + l\nCmd + l\nLimpa o console\n\n\nCtrl + Alt + b\nCmd + Option + b\nRoda do início até a linha atual\n\n\nCtrl + Alt + t\nCmd + Option + t\nRoda a seção de código atual (R Markdown)\n\n\nCtrl + Alt + i\nCmd + Shift + r\nInsere chunk de código (no R Markdown)\n\n\nCtrl + Alt + c\nCmd + Option + c\nRoda o chunk atual (R Markdown)\n\n\nup/down arrows in R console\nSame\nAlterna entre os comandos executados recentemente\n\n\nShift + up/down arrows in script\nSame\nSeleciona múltiplas linhas de código\n\n\nCtrl + f\nCmd + f\nProcura e substitui no script atual\n\n\nCtrl + Shift + f\nCmd + Shift + f\nEncontra em arquivos (pesquisa/substitui em vários script)\n\n\nAlt + l\nCmd + Option + l\nOculta código atual\n\n\nShift + Alt + l\nCmd + Shift + Option+l\nExibe código sele\n\n\n\nDICA: Use sua tecla Tab ao digitar para ativar a funcionalidade de auto-completar do RStudio. Isto pode evitar erros ortográficos. Pressione Tab enquanto digita para produzir um menu suspenso de funções e objetos prováveis, com base no que você digitou até agora.",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.pt.html#functions",
    "href": "new_pages/basics.pt.html#functions",
    "title": "3  Introdução ao R",
    "section": "3.6 Funções",
    "text": "3.6 Funções\nAs funções estão no cerne do uso de R. As funções são a forma como você executa tarefas e operações. Muitas funções vêm instaladas com R, muitas mais estão disponíveis para download em packages (explicado na seção pacotes), e você pode até mesmo escrever suas próprias funções personalizadas!\nEsta seção básica sobre funções explica:\n\nO que é uma função e como funcionam\nO que são os argumentos/parâmetros de uma função\nComo conseguir ajuda para compreender uma função\n\nUma nota rápida sobre a sintaxe: Neste manual, as funções são escritas em texto de código com parênteses abertos, como este: filter(). Como explicado na seção pacotes, as funções são baixadas dentro de pacotes. Neste manual, os nomes dos pacotes são escritos em negrito, como dplyr. Às vezes, no código de exemplo, você pode ver o nome da função ligado explicitamente ao nome de seu pacote com um par de dois-pontos (::) como este: dplyr::filter(). O propósito desta ligação é explicado na seção de pacotes.\n\n\nFunções simples\nUma função é como uma máquina que recebe entradas, faz alguma ação com essas entradas e produz uma saída. O que é a saída depende da função.\nFunções normalmente operam sobre algum objeto colocado dentro dos parênteses da função. Por exemplo, a função sqrt() calcula a raiz quadrada de um número:\n\nsqrt(49)\n\n[1] 7\n\n\nO objeto fornecido a uma função também pode ser uma coluna em um conjunto de dados (veja a seção Objetos para detalhes sobre todos os tipos de objetos). Como R pode armazenar vários conjuntos de dados, será necessário especificar tanto o conjunto de dados quanto a coluna. Uma maneira de fazer isso é utilizar a notação $ para ligar o nome do conjunto de dados e o nome da coluna (dataset$coluna). No exemplo abaixo, a função summary() é aplicada à coluna numérica age (idade) no conjunto de dados linelist, e a saída é um resumo dos valores numéricos e valores ausentes da coluna.\n\n#Imprimir estatísticas resumidas da coluna 'age' (idade) no conjunto de dados 'linelist'.\nsummary(linelist$age)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00    6.00   13.00   16.07   23.00   84.00      86 \n\n\nNOTA: Nos bastidores, uma função representa um código adicional complexo que foi condensado para o usuário em um comando fácil.\n\n\n\nFunções com argumentos múltiplos\nAs funções frequentemente pedem várias entradas, chamadas argumentos, ou parâmetros, localizadas dentro dos parênteses da função, geralmente separadas por vírgulas.\n\nAlguns argumentos são necessários para que a função funcione corretamente, outros são opcionais\nArgumentos opcionais têm configurações padrão\nOs argumentos podem ter caráter, numérico, lógico (TRUE/FALSE)(verdadeiro/falso), e outros inputs\n\nAqui está uma função ficcional divertida, chamada oven_bake() ( do inglês: assar no forno), como um exemplo de uma função típica. Ela pega um objeto de entrada (por exemplo, um conjunto de dados, ou neste exemplo “dough” - massa) e realiza operações sobre ele como especificado por argumentos adicionais (minutes = e temperature =). A saída pode ser impressa para o console, ou salva como um objeto utilizando o operador de atribuição &lt;-.\n\n\n\n\n\n\n\n\n\nEm um exemplo mais realístico, o comando age_pyramid() abaixo produz uma pirâmide etária baseado em faixas-etárias e uma coluna divisória binária, como gender (gênero). A função recebe três argumentos dentro dos parênteses, separados por vírgulas. Os valores fornecidos aos argumentos estabelecem linelist como o quadro de dados a utilizar, age_cat5 como a coluna a contar, e gender como a coluna binária a utilizar para dividir a pirâmide por cor.\n\n# Crie uma pirâmide etária\nage_pyramid(data = linelist, age_group = \"age_cat5\", split_by = \"gender\")\n\n\n\n\n\n\n\n\nO comando acima pode ser escrito de forma equivalente ao abaixo, em um estilo mais longo com uma nova linha para cada argumento. Este estilo pode ser mais fácil de ler, e mais fácil de escrever “comentários” com # para explicar cada parte (comentar extensivamente é uma boa prática!). Para executar este comando mais longo, você pode destacar todo o comando e clicar em “Run”, ou simplesmente colocar o cursor na primeira linha e, em seguida, pressionar simultaneamente as teclas Ctrl e Enter.\n\n# Crie uma pirâmide etária\nage_pyramid(\n  data = linelist,        # Use a linelist de casos\n  age_group = \"age_cat5\", # disponibilize a coluna de faixa-etária\n  split_by = \"gender\"     #usee a coluna de gênero para criar dois lados da pirâmide \n  )\n\n\n\n\n\n\n\n\nA primeira metade de uma atribuição de argumentos (por exemplo, dados =) não precisa ser especificada se os argumentos forem escritos em uma ordem específica (especificada na documentação da função). O código abaixo produz exatamente a mesma pirâmide que o acima, porque a função espera a ordem dos argumentos: quadro de dados, variável age_group, variável split_by.\n\n# Esse comando retorna o mesmo gráfico gerado acima\nage_pyramid(linelist, \"age_cat5\", \"gender\")\n\nUm comando mais complexo de age_pyramid() poderia incluir os argumentos opcionais para:\n\nMostrar proporções em vez de contagens (definir proportional = TRUE quando o padrão é FALSE)\nEspecifique as duas cores a serem utilizadas (pal = é a abreviação de “paleta” e é fornecido com um vetor de dois nomes de cores. Veja a página objetos para saber como a função c() faz um vetor)\n\nNOTA: Para argumentos que você especificar com ambas as partes do argumento (por exemplo, proportional = TRUE), sua ordem entre todos os argumentos não importa.\n\nage_pyramid(\n  linelist,                    # use a linelist de casos\n  \"age_cat5\",                  # coluna de faixa-etária\n  \"gender\",                    # divida por gênero\n  proportional = TRUE,         # porcentagem em vez de contagens\n  pal = c(\"orange\", \"purple\")  # cores\n  )\n\n\n\n\n\n\n\n\n\n\n\nEscrevendo funções\nR é uma linguagem que é orientada em torno de funções, portanto você deve se sentir capacitado para escrever suas próprias funções. A criação de funções traz várias vantagens:\n\nPara facilitar a programação modular - a separação do código em peças independentes e gerenciáveis\nSubstituir o processo repetitivo de copia e cola, que pode ser propenso a erros.\nDar nomes memoráveis aos pedaços de código\n\nComo escrever uma função é abordado em profundidade na página Escrevendo funções.",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.pt.html#packages",
    "href": "new_pages/basics.pt.html#packages",
    "title": "3  Introdução ao R",
    "section": "3.7 Pacotes",
    "text": "3.7 Pacotes\nPacotes contém funções.\nUm pacote R é um pacote compartilhável de código e documentação que contém funções pré-definidas. Os usuários da comunidade R desenvolvem pacotes o tempo todo, atendendo a problemas específicos, e é provável que alguém possa ajudar com seu trabalho inclusive! Você com certeza irá instalar e usar centenas de pacotes em seu uso de R.\nNa instalação, o R contém pacotes de “base” e funções que executam tarefas elementares e comuns. Mas muitos usuários do R criam funções especializadas, que são verificadas pela comunidade R e que você pode baixar como um package (pacote) para seu próprio uso. Neste manual, os nomes dos pacotes estão escritos em negrito. Um dos aspectos mais desafiadores do R é que muitas vezes há muitas funções ou pacotes a serem escolhidos para complementar uma determinada tarefa.\n\nInstalar e carregar\nAs funções estão contidas nos pacotes que podem ser baixados (“instalados”) para seu computador a partir da Internet. Uma vez que um pacote é baixado, ele é armazenado em sua “biblioteca” (do inglês, library). Você pode então acessar as funções que ele contém durante sua sessão R atual “carregando” este pacote.\nPense em R como sua biblioteca pessoal: Quando você baixa um pacote, sua biblioteca ganha um novo livro de funções, mas cada vez que você quiser usar uma função naquele livro, você deve pegar emprestado (“carregar”) aquele livro de sua biblioteca.\nEm resumo: para usar as funções disponíveis em um pacote R, duas etapas devem ser implementadas:\n\nO pacote precisa ser instalado (uma vez), e\nO pacote precisa ser carregado (a cada sessão de R que abrir)\n\n\nSua biblioteca\nSua “biblioteca” é na verdade uma pasta em seu computador, contendo uma subpasta para cada pacote que foi instalado. Descubra onde R está instalado em seu computador, e procure uma pasta chamada “win-library”. Por exemplo: R\\win-library\\4.0 (a 4.0 é a versão R - você terá uma biblioteca diferente para cada versão R que você baixou).\nVocê pode exibir (“printar”) o caminho do arquivo para sua biblioteca digitando .libPaths() (parênteses vazios). Isto se torna especialmente importante se você trabalhar com R em unidades de rede.\n\n\nInstalar do CRAN\nNa maioria das vezes, os usuários R baixam pacotes da CRAN. CRAN (Comprehensive R Archive Network) é um repositório público on-line de pacotes R que foram publicados por membros da comunidade R.\nVocê está preocupado com vírus e segurança ao fazer o download de um pacote da CRAN? Leia este artigo sobre o assunto.\n\n\nComo instalar e carregar\nNeste manual, sugerimos o uso do pacote pacman (abreviação para “package manager” que significa “gerenciador de pacotes” em inglês). Ele oferece uma função conveniente p_load() que instalará um pacote se necessário e o carregará para utilização na sessão R atual.\nA sintaxe é bastante simples. Basta listar os nomes dos pacotes dentro dos parênteses p_load(), separados por vírgulas. Este comando instalará os pacotes rio, tidyverse, e here se ainda não estiverem instalados, e os carregará para utilização. Isto torna a abordagem p_load() conveniente e concisa se compartilhar scripts com outros. Observe que os nomes dos pacotes são sensíveis a maiúsculas e minúsculas.\n\n# Instala (se necessário) e os carrega para o uso\npacman::p_load(rio, tidyverse, here)\n\nNote que utilizamos a sintaxe pacman::p_load() que escreve explicitamente o nome do pacote (pacman) antes do nome da função (p_load()), conectado por duas colunas ::. Esta sintaxe é útil porque também carrega o pacote pacman (assumindo que já esteja instalado).\nExistem funções alternativas do R base que você verá com freqüência. A função do R base para instalar um pacote é install.packages(). O nome do pacote a ser instalado deve ser fornecido entre parênteses em aspas. Se você quiser instalar vários pacotes em um comando, eles devem ser listados dentro de um vetor de caracteres c().\nNota: este comando instala um pacote, mas não o carrega para utilização na sessão atual.\n\n# essa função disponível no R base instala um único pacote \ninstall.packages(\"tidyverse\")\n\n# install multiple packages with base R\ninstall.packages(c(\"tidyverse\", \"rio\", \"here\"))\n\nA instalação também pode ser feita clicando e apontando para o painel “Pacotes” do RStudio e clicando em “Instalar” e procurando pelo nome do pacote desejado.\nA função do R base para carregar um pacote para utilização (após ter sido instalado) é library(). Ela pode carregar apenas um pacote de cada vez (outro motivo para utilizar p_load()). Você pode fornecer o nome do pacote com ou sem aspas.\n\n# com o R base, você pode carregar os pacotes dessa forma \nlibrary(tidyverse)\nlibrary(rio)\nlibrary(here)\n\nPara verificar se um pacote está instalado e/ou carregado, você pode visualizar o painel de Pacotes no RStudio. Se o pacote estiver instalado, ele é mostrado lá com o número da versão. Se sua caixa for marcada, ela é carregada para a sessão atual.\nInstalar a partir do Github.\nÀs vezes, você precisa instalar um pacote que ainda não está disponível na CRAN. Ou talvez o pacote esteja disponível na CRAN, mas você quer a versão em desenvolvimento com novos recursos ainda não oferecidos na versão publicada mais estável da CRAN. Estes são frequentemente hospedados no site github.com em um “repositório” de código gratuito e voltado para o público. Leia mais sobre Github na página do manual Controle de versão e colaboração com Git e Github.\nPara baixar os pacotes R do Github, você pode utilizar a função p_load_gh() do pacman, que instalará o pacote se necessário, e o carregará para utilização em sua sessão R atual. As alternativas para instalar incluem a utilização dos pacotes remotes ou devtools. Leia mais sobre todas as funções pacman na documentação do pacote.\nPara instalar a partir do Github, você precisa fornecer mais informações. Você tem que fornecer:\n\nA identificação do proprietário do repositório Github\nO nome do repositório que contém o pacote\n(opcional) O nome do “ramo” (o “branch” da versão de desenvolvimento específico) que você deseja baixar\n\nNos exemplos abaixo, a primeira palavra entre aspas representa a ID do Github do proprietário do repositório, após a barra é o nome do repositório (o nome do pacote).\n\n# instala/carrega o pacote epicontacts do seu repositório Github \np_load_gh(\"reconhub/epicontacts\")\n\nSe você quiser instalar de um “branch” (versão) diferente da principal, adicione o nome do “branch” após um “@”, após o nome do repositório.\n\n# instale o \"branch\"(ramo) \"timeline\" do pacte epicontacts do Github\np_load_gh(\"reconhub/epicontacts@timeline\")\n\nSe não houver diferença entre a versão do Github e a versão em seu computador, nenhuma ação será tomada. Você pode “forçar” uma reinstalação utilizando p_load_current_gh() com o argumento update = TRUE. Leia mais sobre pacman nesta vinheta online\nInstale a partir de ZIP ou TAR\nVocê poderia instalar um pacote de um endereço URL:\n\npackageurl &lt;- \"https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz\"\ninstall.packages(packageurl, repos=NULL, type=\"source\")\n\nOu, faça o download dele para seu computador em um arquivo comprimido (“zipado”):\nOpção 1: usandoinstall_local() do pacote remotes\n\nremotes::install_local(\"~/Downloads/dplyr-master.zip\")\n\nOpção 2: usando install.packages() do R base, fornecendo o caminho do arquivo comprimido e configurando os parâmetros type = \"source e repos = NULL.\n\ninstall.packages(\"~/Downloads/dplyr-master.zip\", repos=NULL, type=\"source\")\n\n\n\n\nSintaxe do código\nFor clarity in this handbook, functions are sometimes preceded by the name of their package using the :: symbol in the following way: package_name::function_name()\nOnce a package is loaded for a session, this explicit style is not necessary. One can just use function_name(). However writing the package name is useful when a function name is common and may exist in multiple packages (e.g. plot()). Writing the package name will also load the package if it is not already loaded.\n\n# Este comando usa o pacote \"rio\" e sua função   \"import()\" para importar uma base de dados.\nlinelist &lt;- rio::import(\"linelist.xlsx\", which = \"Sheet1\")\n\n\n\nAuxílio para as funções\nPara maior clareza neste manual, as funções são algumas vezes precedidas pelo nome de seu pacote utilizando o símbolo :: da seguinte forma: nome_do_pacote::nome_da_função()\nUma vez carregado um pacote para uma sessão, este estilo explícito não é mais necessário. Pode-se simplesmente utilizar nome_da_função(). Entretanto, escrever o nome do pacote é útil quando um nome de função é muito comum e pode existir em vários pacotes (por exemplo, plot()). Escrever o nome do pacote também irá carregar o pacote se ele ainda não estiver carregado.\n\n\nAtualizando pacotes\nVocê pode atualizar os pacotes, reinstalando-os. Você também pode clicar no botão verde “Atualizar” em seu painel de Pacotes RStudio para ver quais pacotes têm novas versões para instalar. Esteja ciente de que seu código antigo pode precisar ser atualizado se houver uma grande revisão de como uma função funciona!\n\n\nApagar pacotes\nUtilize p_delete() de pacman, ou remove.packages() do R base. Alternativamente, procure a pasta que contém sua biblioteca e exclua manualmente a pasta.\n\n\nDependências\nOs pacotes muitas vezes dependem de outros pacotes para funcionar. Estes são chamados de dependências. Se uma dependência falhar na instalação, então o pacote dependendo dela também pode falhar na instalação.\nVeja as dependências de um pacote com p_depends(), e veja quais pacotes dependem dele com p_depends_reverse().\n\n\nFunções mascaradas\nNão é raro que dois ou mais pacotes contenham o mesmo nome de função. Por exemplo, o pacote dplyr tem uma função filter(), mas o pacote stats também. A função padrão filter() depende da ordem em que estes pacotes são carregados primeiro na sessão R - a última será o padrão para o comando filter().\nVocê pode verificar a ordem em seu painel Environment (Ambiente) do R Studio - clique no menu suspenso para Global Environment (“Ambiente Global”) e veja a ordem dos pacotes. Funções de pacotes mais abaixo nessa lista suspensa mascararão funções com o mesmo nome em pacotes que aparecem mais altos na lista suspensa. Ao carregar um pacote pela primeira vez, R avisará no console se estiver ocorrendo mascaramento, mas isto pode ser fácil de perder.\n\n\n\n\n\n\n\n\n\n\nEspecifique o nome do pacote no comando. Por exemplo, utilize dplyr::filter()\nReorganize a ordem na qual os pacotes são carregados (por exemplo, dentro de p_load()), e inicie uma nova sessão R.\n\n\n\nDesprender / descarregar\nPara separar (descarregar) um pacote, use este comando, com o nome correto do pacote e apenas um “dois pontos”. Note que isto pode não resolver o mascaramento.\n\ndetach(package:PACKAGE_NAME_HERE, unload=TRUE)\n\n\n\nInstalar uma versão mais antiga\nVeja este guia para instalar uma versão mais antiga de um pacote em particular.\n\n\nPacotes sugeridos\nVeja a página em Pacotes sugeridos para uma listagem de pacotes que recomendamos para o dia-a-dia em epidemiologia.",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.pt.html#scripts",
    "href": "new_pages/basics.pt.html#scripts",
    "title": "3  Introdução ao R",
    "section": "3.8 Scripts",
    "text": "3.8 Scripts\nOs scripts (que significa “roteiro” em inglês) são uma parte fundamental da programação. Eles são documentos que contêm seus comandos (por exemplo, funções para criar e modificar conjuntos de dados, visualizações de impressão, etc.). Você pode salvar um script e executá-lo novamente mais tarde. Há muitas vantagens em armazenar e executar seus comandos a partir de um script (versus digitar comandos um a um na “linha de comando” do console R):\n\nPortabilidade - você pode compartilhar seu trabalho com outros enviando-lhes seus scripts\n\nReprodutibilidade - para que você e outros saibam exatamente o que você fez\nControle de versão - para que você possa acompanhar as mudanças feitas por você ou colegas\n\nComentando/anotando - para explicar a seus colegas o que você tem feito\n\n\nComentando\nEm um script você também pode anotar (“fazer comentários”) ao longo do seu código R. Comentar é útil para explicar a si mesmo e aos outros leitores o que você está fazendo. Você pode adicionar um comentário digitando o símbolo “hashtag” (#) e escrevendo seu comentário depois dele. O texto comentado aparecerá em uma cor diferente da do código R.\nQualquer código escrito após o # não será executado. Portanto, colocar um # antes do código também é uma maneira útil de bloquear temporariamente uma linha de código (“comentar fora”) se você não quiser apagá-lo). Você pode fazer isso em várias linhas ao mesmo tempo, selecionando-as e pressionando Ctrl+Shift+c (Cmd+Shift+c no Mac).\n\n# Um comentário pode ser uma linha por si só\n# importar dados\nlinelist &lt;- import(\"linelist_raw.xlsx\") %&gt;%   # também pode ser após o código\n# filter(age &gt; 50)                          # também pode ser usado para desativar uma linha de código\n  count()\n\n\nComente sobre o que você está fazendo e sobre por que você está fazendo.\nDivida seu código em seções lógicas…\nAcompanhe seu código com uma descrição passo a passo em texto do que você está fazendo (por exemplo, passos numerados)\n\n\n\nEstilo\nÉ importante estar consciente de seu estilo de codificação - especialmente se estiver trabalhando em equipe. Defendemos o uso do tidyverse guia de estilo. Há também pacotes como styler e lintr que o ajudam a se adequar a este estilo.\nAlguns pontos muito básicos para tornar seu código legível para outros:\n* Ao nomear objetos, utilize apenas letras minúsculas, números e sublinhados _, por exemplo my_data. * Utilize espaços frequentes, inclusive ao redor dos operadores, por exemplo n = 1 e age_new &lt;- age_old + 3\n\n\nExemplo de Script\nAbaixo está um exemplo de um pequeno script R. Lembre-se, quanto melhor você explicar sucintamente seu código nos comentários, mais seus colegas vão gostar de você!\n\n\n\n\n\n\n\n\n\n\n\n\nR markdown\nUm script R markdown é um tipo de script R no qual o script em si resulta um documento de saída (PDF, Word, HTML, Powerpoint, etc.). Estas são ferramentas incrivelmente úteis e versáteis, freqüentemente usadas para criar relatórios dinâmicos e automatizados. Mesmo este website e manual são produzidos com um script R markdown!\nVale a pena notar que usuários iniciantes de R também podem usar R Markdown - não se intimidem! Para saber mais, consulte a página do manual nos documentos Relatórios com R Markdown.\n\n\n\nNotebooks R\nNão há diferença entre escrever em um Rmarkdown versus um caderno R. Entretanto, a execução do documento difere ligeiramente. Consulte este site para obter mais detalhes.\n\n\n\n3.8.1 Shiny\nOs aplicativos/websites shiny estão contidas em um script, que deve ser chamado de app.R. Este arquivo tem três componentes:\n\nUma interface de usuário (ui)\n\nUma função de servidor\n\nUma chamada para a função shinyApp.\n\nVeja a página do manual em Dashboards com Shiny, ou este tutorial online: Tutorial com shiny\nNos tempos mais antigos, o arquivo acima era dividido em dois arquivos (ui.R e server.R)\n\n\nCódigo dobrável\nVocê pode colapsar/dobrar (do inglês folding) porções de código para facilitar a leitura de seu roteiro.\nPara isso, crie um cabeçalho de texto com #, escreva seu cabeçalho, e siga-o com pelo menos 4 traços (-), hashes (#) ou igual a (=). Quando você tiver feito isto, uma pequena seta aparecerá na “sarjeta” à esquerda (pelo número da linha). Você pode clicar nesta seta e o código abaixo até o próximo cabeçalho cair e um ícone de seta dupla aparecerá em seu lugar.\nPara expandir o código, clique novamente na seta na sarjeta, ou no ícone de duas fileiras. Há também atalhos de teclado como explicado na seção RStudio desta página.\nAo criar cabeçalhos com #, você também ativará o Índice na parte inferior de seu script (veja abaixo) que você pode usar para navegar em seu script. Você pode criar subtítulos adicionando mais # símbolos, por exemplo, # para primário, # # para secundário e ### para terciário.\nAbaixo estão duas versões de um script de exemplo. À esquerda está o original com os cabeçalhos comentados. À direita, quatro traços foram escritos após cada cabeçalho, tornando-os colapsáveis. Dois deles foram colapsados, e você pode ver que a Tabela de Conteúdos na parte inferior agora mostra cada seção.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOutras áreas de código que são automaticamente elegíveis para fazer esse “dobramento” incluem as regiões entre chaves { } tais como definições de funções ou blocos condicionais ( declarações “if else”). Pode ler mais sobre dobramento de código no RStudio site.",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.pt.html#diretório-de-trabalho",
    "href": "new_pages/basics.pt.html#diretório-de-trabalho",
    "title": "3  Introdução ao R",
    "section": "3.9 Diretório de trabalho",
    "text": "3.9 Diretório de trabalho\nO diretório de trabalho é o local da pasta raiz usada por R para seu trabalho - onde R procura e salva arquivos por padrão. Por padrão, ele salvará novos arquivos e saídas para este local, e procurará por arquivos para importar (por exemplo, conjuntos de dados) também aqui.\nO diretório de trabalho aparece em texto cinza na parte superior do painel do RStudio Console. Você também pode imprimir o diretório de trabalho atual executando getwd() (deixe os parênteses vazios).\n\n\n\n\n\n\n\n\n\n\nAbordagem recomendada\nVeja a página sobre projetos R para obter detalhes sobre nossa abordagem recomendada para gerenciar seu diretório de trabalho. Uma maneira comum, eficiente e sem problemas para gerenciar seu diretório de trabalho e caminhos de arquivos é combinar estes 3 elementos em um fluxo de trabalho orientado segundo projeto R\n\nUm projeto R para armazenar todos os seus arquivos (ver página em projetos R)\n\nO pacote here para localização de arquivos (ver página em Importação e exportação)\n\nO pacote rio para arquivos de importação/exportação (ver página em Importação e exportação)\n\n\n\n\nDefinido por comando\nAté recentemente, muitas pessoas aprendendo R eram ensinadas a começar seus roteiros com um comando setwd(). Em vez disso, considere a utilização de um fluxo de trabalho orientados segundo projeto R e leia as razões para não utilizar setwd(). Em resumo, seu trabalho torna-se específico para seu computador, os caminhos de arquivos utilizados para importar e exportar arquivos tornam-se ” frágeis”, e isso dificulta seriamente a colaboração e a utilização de seu código em qualquer outro computador. Existem alternativas fáceis!\nComo observado acima, embora não recomendamos esta abordagem na maioria das circunstâncias, você pode utilizar o comando setwd() com o caminho do arquivo da pasta desejada escrito entre aspas, como no exemplo abaixo:\n\nsetwd(\"C:/Documents/R Files/My analysis\")\n\nPERIGO: Definir um diretório de trabalho com setwd() pode ser “frágil” se o caminho do arquivo for específico para um computador. Em vez disso, use caminhos de arquivo relativos a um diretório raiz do R Project (com o pacote here).\n\n\n\nDefinindo manualmente\nPara definir o diretório de trabalho manualmente (que seria o equivalente de apontar e clicar de setwd()), clique no menu suspenso Sessão (Session) e vá para “Definir diretório de trabalho” (Set Workig Directory) e depois “Escolher diretório” (Choose Directory). Isso definirá o diretório de trabalho para essa sessão específica do R. Nota: se estiver usando esta abordagem, você terá que fazer isso manualmente toda vez que abrir o RStudio.\n\n\n\nDentro de um projeto R\nSe estiver usando um projeto R, o diretório de trabalho será padronizado para a pasta raiz do projeto R que contém o arquivo “.rproj”. Isso se aplicará se você abrir o RStudio clicando em abrir o Projeto R (o arquivo com extensão “.rproj”).\n\n\n\nDiretório de trabalho em R markdown\nEm um script R markdown, o diretório de trabalho padrão é a pasta na qual o arquivo Rmarkdown (.Rmd) é salvo. Se estiver usando um projeto R e um pacote here, isso não se aplica e o diretório de trabalho será here() conforme explicado na página projetos R.\nSe você quiser alterar o diretório de trabalho de um R markdown autônomo (não em um projeto R), se você usar setwd(), isso se aplicará apenas a esse trecho de código específico. Para fazer a alteração para todos os trechos de código em um markdown R, edite o trecho de configuração para adicionar o parâmetro root.dir =, como abaixo:\n\nknitr::opts_knit$set(root.dir = 'desired/directorypath')\n\nÉ muito mais fácil usar apenas o markdown do R dentro de um projeto R e usar o pacote here.\n\n\n\nFornecendo o caminho dos arquivos\nTalvez a fonte mais comum de frustração para um iniciante em R (pelo menos em uma máquina Windows) seja digitar um caminho de arquivo para importar ou exportar dados. Há uma explicação completa de como melhor inserir caminhos de arquivo na página Importar e exportar, mas aqui estão alguns pontos-chave:\nCaminhos quebrados\nAbaixo está um exemplo de um caminho de arquivo “absoluto” ou “endereço completo”. Eles provavelmente quebrarão se forem usados por outro computador. Uma exceção é se você estiver usando uma unidade compartilhada/de rede.\nC:/Users/Name/Document/Analytic Software/R/Projects/Analysis2019/data/March2019.csv  \nDireção da barra\nSe digitar um caminho de arquivo, observe a direção das barras. Use barras normais (/) para separar os componentes (“data/provincial.csv”). Para usuários do Windows, a maneira padrão de exibição dos caminhos de arquivo é com barras invertidas (ou contra-barra) (\\) - portanto, você precisará alterar a direção de cada barra. Se você usar o pacote here conforme descrito na página projetos R, a direção da barra não será um problema.\nCaminhos relativos\nGeralmente, recomendamos fornecer caminhos de arquivo “relativos” - ou seja, o caminho relativo à raiz do seu projeto R. Você pode fazer isso usando o pacote here conforme explicado na página projetos R. Um caminho de arquivo relativo pode ser assim:\n\n# Import csv linelist from the data/linelist/clean/ sub-folders of an R project\nlinelist &lt;- import(here(\"data\", \"clean\", \"linelists\", \"marin_country.csv\"))\n\nMesmo usando caminhos de arquivo relativos em um projeto R, você ainda pode usar caminhos absolutos para importar/exportar dados fora do seu projeto R.",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.pt.html#objects",
    "href": "new_pages/basics.pt.html#objects",
    "title": "3  Introdução ao R",
    "section": "3.10 Objetos",
    "text": "3.10 Objetos\nTudo em R é um objeto, e R é uma linguagem “orientada a objetos”. Estas seções explicarão:\n\nComo criar objetos (&lt;-)\nTipos de objetos (por exemplo, quadros de dados, vetores..)\n\nComo acessar subpartes de objetos (por exemplo, variáveis em um conjunto de dados)\n\nClasses de objetos (por exemplo, numérico, lógico, inteiro, duplo, caractere, fator)\n\n\n\nTudo é um objeto\nEsta seção é adaptada do projeto R4Epis.\nTudo o que você armazena no R - conjuntos de dados, variáveis, uma lista de nomes de vilarejos, um número total da população, até saídas como gráficos - são objetos que recebem um nome e podem ser referenciados em comandos posteriores.\nUm objeto existe quando você atribui um valor a ele (consulte a seção de atribuição abaixo). Quando lhe é atribuído um valor, o objeto aparece no Ambiente (Environment) (veja o painel superior direito do RStudio). Ele pode então ser operado, manipulado, alterado e redefinido.\n\n\n\nDefinindo objetos (&lt;-)\nCrie objetos atribuindo-lhes um valor com o operador &lt;-.\nVocê pode pensar no operador de atribuição &lt;- como as palavras “é definido como”. Os comandos de atribuição geralmente seguem uma ordem padrão:\nnome_do_objeto &lt;- valor (ou processo/cálculo que produz um valor)\nPor exemplo, você pode querer registrar a semana do relatório epidemiológico atual como um objeto para referência no código posterior. Neste exemplo, o objeto semana_atual é criado quando é atribuído o valor \"2018-W10\" (as aspas fazem disso um valor de caractere). O objeto semana_atual aparecerá no painel RStudio Environment (canto superior direito) e poderá ser referenciado em comandos posteriores.\nVeja os comandos R e sua saída nas caixas abaixo.\n\nsemana_atual &lt;- \"2018-W10\"   # esse comando cria o objeto semana_atual ao atribuir a ele um valor \nsemana_atual                # esse comento exibe (\"printa\") o valor atual do objeto semana_atual no Console \n\n[1] \"2018-W10\"\n\n\nNOTA: Observe que o [1] na saída do console R está simplesmente indicando que você está visualizando o primeiro item da saída\nCUIDADO: O valor de um objeto pode ser sobrescrito a qualquer momento executando um comando de atribuição para redefinir seu valor. Assim, a ordem dos comandos executados é muito importante..\nO comando a seguir irá redefinir o valor de semana_atual:\n\nsemana_atual &lt;- \"2018-W51\"   # atribui um NOVO valor para o objeto semana_atual \nsemana_atual                # Exibe (\"printa\") o valor atual do objeto semana_atual no console \n\n[1] \"2018-W51\"\n\n\nSinal de igual =\nVocê também verá sinais de igual no código R:\n\nUm sinal de igual duplo == entre dois objetos ou valores faz uma pergunta lógica: “isso é igual a isso?”.\n\nVocê também verá sinais de igual dentro de funções usadas para especificar valores de argumentos de função (leia sobre isso nas seções abaixo), por exemplo max(age, na.rm = TRUE).\n\nVocê pode usar um único sinal de igual = no lugar de &lt;- para criar e definir objetos, mas isso é desencorajado. Você pode ler sobre por que isso é desencorajado aqui.\n\nBases de dados\nOs conjuntos de dados também são objetos (geralmente “dataframes”) e devem receber nomes quando são importados. No código abaixo, o objeto linelist é criado e atribuído o valor de um arquivo CSV importado com o pacote rio e sua função import().\n\n# o objeto linelist é criado e a ele é atribuído o valor do arquivo CSV importado\nlinelist &lt;- import(\"my_linelist.csv\")\n\nVocê pode ler mais sobre como importar e exportar conjuntos de dados na seção [Importar e exportar](#importing.\nCUIDADO: Uma nota rápida sobre a nomeação de objetos:\n\nOs nomes dos objetos não devem conter espaços, mas você deve usar sublinhado (_) ou um ponto (.) em vez de um espaço.\n\nOs nomes dos objetos diferenciam maiúsculas de minúsculas (o que significa que Dataset_A é diferente de dataset_A).\nOs nomes dos objetos devem começar com uma letra (não pode começar com um número como 1, 2 ou 3).\n\nSaídas (Outputs)\nSaídas como tabelas e gráficos fornecem um exemplo de como as saídas podem ser salvas como objetos ou apenas exibidas (“printadas” no console) sem serem salvas. Uma tabulação cruzada de gênero e resultado usando a função do R base table() pode ser exibida diretamente no console R (sem ser salva).\n\n# exibe apenas no console R\ntable(linelist$gender, linelist$outcome)\n\n   \n    Death Recover\n  f  1227     953\n  m  1228     950\n\n\nMas a mesma tabela pode ser salva como um objeto nomeado. Então, opcionalmente, pode ser printado.\n\n# salvar\ngen_out_table &lt;- table(linelist$gender, linelist$outcome)\n\n# printar\ngen_out_table\n\n   \n    Death Recover\n  f  1227     953\n  m  1228     950\n\n\nColunas\nAs colunas em um conjunto de dados também são objetos e podem ser definidas, sobrescritas e criadas conforme descrito abaixo na seção Colunas.\nVocê pode usar o operador de atribuição do R base para criar uma nova coluna. Abaixo, a nova coluna bmi (IMC - Índice de Massa Corporal, do inglês Body Mass Index) é criada, e para cada linha o novo valor é resultado de uma operação matemática sobre o valor da linha nas colunas wt_kg e ht_cm.\n\n# criar uma nova colna bmi (que é o valor de IMC) usando a sintaxe do R base\nlinelist$bmi &lt;- linelist$wt_kg / (linelist$ht_cm/100)^2\n\nNo entanto, neste manual, enfatizamos uma abordagem diferente para definir colunas, que usa a função mutate() do pacote dplyr e piping com o operador pipe (%&gt;%). A sintaxe é mais fácil de ler e há outras vantagens explicadas na página em Limpeza de dados e principais funções. Você pode ler mais sobre tubulação na seção Tubulação abaixo.\n\n# criar uma nova colna bmi (que é o valor de IMC) usando a sintaxe do dplyr\nlinelist &lt;- linelist %&gt;% \n  mutate(bmi = wt_kg / (ht_cm/100)^2)\n\n\n\n\nEstrutura de um objeto\nOs objetos podem ser um único dado (por exemplo, meu_numero &lt;- 24) ou podem consistir em dados estruturados.\nO gráfico abaixo é emprestado de este tutorial R online. Ele mostra algumas estruturas de dados comuns e seus nomes. Não estão incluídos nesta imagem os dados espaciais, que são discutidos na página Noções básicas de GIS.\n\n\n\n\n\n\n\n\n\nEm epidemiologia (e particularmente epidemiologia de campo), você encontrará mais comumente dataframes e vetores:\n\n\n\n\n\n\n\n\nEstrutura comum\nExplicação\nExemplo\n\n\n\n\nVetores\nUm conteiner para uma sequência de objetos singulares, de uma mesma classe (es: numérico, caractere).\n“Variáveis” (colunas) em data frames são vetores (ex: a coluna age_years).\n\n\nData Frames\nVetores (ex: colunas) que estão unidas e têm todas o mesmo número de linhas. | linelist é data frame.\n\n\n\nObserve que para criar um vetor que “independente” (não faz parte de um data frame) a função c() é usada para combinar os diferentes elementos. Por exemplo, se estiver criando um vetor de cores para uma paleta de cores de um gráfico: vector_de_cores &lt;- c(\"blue\", \"red2\", \"orange\", \"grey\")\n\n\n\nClasse de objetos\nTodos os objetos armazenados em R possuem uma classe que informa ao R como lidar com o objeto. Existem muitas classes possíveis, mas as mais comuns incluem:\n\n\n\nClasse\nExplicação\nExemplos\n\n\n\n\nCharacter\nCaracteres, esses são textos/palavras/frases “dentro de aspas”. Nenhuma operação matemática pode ser realizada com esses objetos.\n“Objetos do tipo caractere ficam entre aspas”\n\n\nInteger\nNúmeros inteiros (sem decimais)\n-5, 14, or 2000\n\n\nNumeric\nNúmeros que podem incluir decimais. Se estiverem dentro de aspas, serão considerados como caractere\n23.1 or 14\n\n\nFactor\nFatores, são vatores que tem uma ordem específica ou hierarquia de valores\nUma variável de status econômico com valores ordenados\n\n\nDate\nUma vez que o R é informado que um certo grupo de dados corresponde a Data, esses valores só podem ser apresentados e manipulados de algumas maneiras especiais. Veja a página sobre Trabalhando com datas para mais informações\n2018-04-12 ou 15/3/1954 ou Qua 4 Jan 1980\n\n\nLogical\nValores lógicos que precisam um dos dois valores especiais TRUE (verdadeiro) ou FALSE (note que eles não não “TRUE” e “FALSE” entre aspas)\nTRUE ou FALSE\n\n\ndata.frame\nUma data frame é como o R armazena uma base de dados típica. Consiste de vetores (colunas) de dados unidos, que tenha o mesmo número de observações (linhas). | O exemplo AJS nomeado linelist_raw contém 68 variáveis com 300 observações (linhas) cada. |\n\n\n\ntibble\ntibble é uma variação do data frame, a principal diferença operacional é que eles printam melhor no console (exibem as primeiras 10 linhas e apenas as colunas que cabem na tela)\nQualquer data frame, lista ou matriz pode ser convertido em um tibble com as_tibble()\n\n\nlist\nUma lista é como um vetor, mas contém outros objetos que podem ser de outras classes diferentes\nUma lista pode conter um único número, um dataframe, um vetor e até outra lista dentro dele!\n\n\n\nVocê pode testar a classe de um objeto fornecendo seu nome para a função class(). Nota: você pode fazer referência a uma coluna específica dentro de um conjunto de dados utilizando a notação $ para separar o nome do conjunto de dados e o nome da coluna.\n\nclass(linelist)         # a classe deve ser uma data frame ou tibble\n\n[1] \"data.frame\"\n\nclass(linelist$age)     # classe deve ser numérica \n\n[1] \"numeric\"\n\nclass(linelist$gender)  # classe deve ser caractere \n\n[1] \"character\"\n\n\nÀs vezes, uma coluna será convertida automaticamente para uma classe diferente pelo R. Cuidado com isso! Por exemplo, se você tiver um vetor ou coluna de números, mas um valor de caractere for inserido… a coluna inteira mudará para caractere de classe.\n\nnum_vector &lt;- c(1,2,3,4,5) # define um vetor só de números\nclass(num_vector)          # este vetor é da classe numérico\n\n[1] \"numeric\"\n\nnum_vector[3] &lt;- \"three\"   # converte o terceiro elemento para um caractere\nclass(num_vector)          # o vetor agora é classe caractere\n\n[1] \"character\"\n\n\nUm exemplo comum disso é quando se manipula um data frame para exibir uma tabela - se você fizer uma linha total e tentar colar/colar porcentagens na mesma célula dos números (por exemplo, 23 (40%)), toda a coluna numérica acima será convertida em caractere e não poderá mais ser utilizada para cálculos matemáticos.** Algumas vezes, será necessário converter objetos ou colunas em outra classe.**\n\n\n\nFunção\nAção\n\n\n\n\nas.character()\nConverte para a classe caractere\n\n\nas.numeric()\nConverte para a classe numérica\n\n\nas.integer()\nConverte para a classe inteiro\n\n\nas.Date()\nConverte para a classe Data - Nota: Veja a seção sobre datas para detalhes\n\n\nfactor()\nConverte para a classe fator - Nota: Redefinir a ordem dos níveis requer argumentos extras\n\n\n\nDa mesma forma, existem as funções do R base para verificar se um objeto é de uma classe específica, como is.numeric(), is.character(), is.double(), is.factor(), is.integer()\nAqui está mais material on-line sobre classes e estruturas de dados em R.\n\n\n\nColunas/Variáveis ($)\nUma coluna em um data frame é tecnicamente um “vetor” (ver tabela acima) - uma série de valores que devem ser todos da mesma classe (tanto caracter, numérico, lógico, etc.).\nUm vetor pode existir independentemente de um data frame, por exemplo, um vetor de nomes de colunas que você deseja incluir como variáveis explicativas em um modelo. Para criar um vetor independente, utilize a função c() como abaixo:\n\n# define o vetor independente de entradas dp tipo caractere \nexplanatory_vars &lt;- c(\"gender\", \"fever\", \"chills\", \"cough\", \"aches\", \"vomit\")\n\n# printa os valores desse vetor nomeado  \nexplanatory_vars\n\n[1] \"gender\" \"fever\"  \"chills\" \"cough\"  \"aches\"  \"vomit\" \n\n\nAs colunas em uma data frame também são vetores e podem ser chamadas, referenciadas, extraídas ou criadas utilizando o símbolo $. O símbolo $ liga o nome da coluna ao nome de sua moldura de dados. Neste manual, tentamos utilizar a palavra “coluna” em vez de “variável”.\n\n# Obter o comprimento do vetor age\nlength(linelist$age) # (age é uma coluna no data frame linelist)\n\nAo digitar o nome do data frame seguido de $ você verá também um menu suspenso de todas as colunas data frame. Você pode percorrê-las usando sua tecla de seta, selecionar uma com sua tecla Enter e evitar erros ortográficos!\n\n\n\n\n\n\n\n\n\nDICA AVANÇADA: Alguns objetos mais complexos (por exemplo, uma lista, ou um objeto ‘epicontacts’) podem ter múltiplos níveis que podem ser acessados através de múltiplos sinais de dólar. Por exemplo epicontacts$linelist$date_onset\n\n\n\nAccessar/indexar com colchetes ([ ])\nTalvez seja necessário visualizar partes de objetos, também chamadas de “indexação”, o que muitas vezes é feito utilizando os colchetes [ ]. Utilizar $ em um data frame para acessar uma coluna é também um tipo de indexação.\n\nmy_vector &lt;- c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\")  # define o vetor\nmy_vector[5]                                  # printa o quinto elemento\n\n[1] \"e\"\n\n\nOs colchetes também funcionam para retornar partes específicas de uma saída retornada, tais como a saída de uma função summary():\n\n# Todo o resumo\nsummary(linelist$age)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00    6.00   13.00   16.07   23.00   84.00      86 \n\n# Apenas o segundo elemento,sem nome, usando colchetes simples\nsummary(linelist$age)[2]\n\n1st Qu. \n      6 \n\n# Apenas o segundo elemento,sem nome, usando colchetes duplos\n\n# Extrais um elemento pelo nome, sem mostrar o nome aparecer no console\nsummary(linelist$age)[[\"Median\"]]\n\n[1] 13\n\n\nOs colchetes também trabalham em data frames para visualizar linhas e colunas específicas. Você pode fazer isso utilizando a sintaxe dataframe[linhas, colunas]:\n\n# Visualizar uma linha específica (2) de uma base de dados, com todas as colunas (não esqueça a vírgula!) \nlinelist[2,]\n\n# Vert todas as linhas, mas só uma coluna\nlinelist[, \"date_onset\"]\n\n# Ver valores da linha 2, e as colunas 5 a 10\nlinelist[2, 5:10] \n\n# VVer valores da linha 2, e as colunas 5 a 10 e a 18\nlinelist[2, c(5:10, 18)] \n\n# Ver valores da linha 2 a 20 , e colunas específicas\nlinelist[2:20, c(\"date_onset\", \"outcome\", \"age\")]\n\n#Ver linhas e colunas baseado em critérios\n# *** Noque que o dataframe precira ainda ser nomeado no critério!  \nlinelist[linelist$age &gt; 25 , c(\"date_onset\", \"outcome\", \"age\")]\n\n# Use View() para ver as saídas no Painel Visualizador do RStudio Viewer (mais fácil de ler)\n# *** Note o  \"V\" maúsculo na função View() \nView(linelist[2:20, \"date_onset\"])\n\n# Salve como um novo objeto\nnew_table &lt;- linelist[2:20, c(\"date_onset\")] \n\nObserve que você também pode alcançar a indexação de linha/coluna acima em dataframes e tibbles utilizando dplyr sintaxe (funções filter() para linhas, e select() para colunas). Leia mais sobre estas funções centrais na página Dados de limpeza e principais funções.\nPara filtrar com base no “número da linha”, você pode utilizar a função dplyr row_number() com parênteses abertos como parte de uma instrução de filtragem lógica. Muitas vezes você utilizará o operador %in% e uma faixa de números como parte dessa declaração lógica, como mostrado abaixo. Para ver as primeiras N fileiras , você também pode utilizar a função especial dplyr head().\n\n# Visualizar as primeiras 100 linhas\nlinelist %&gt;% head(100)\n\n# Show row 5 only\nlinelist %&gt;% filter(row_number() == 5)\n\n# View rows 2 through 20, and three specific columns (note no quotes necessary on column names)\nlinelist %&gt;% filter(row_number() %in% 2:20) %&gt;% select(date_onset, outcome, age)\n\nAo indexar um objeto de classe lista, parênteses simples sempre retornam coma classe lista, mesmo que apenas um único objeto seja retornado. Entretanto, colchetes duplos podem ser usados para acessar um único elemento e retornar uma classe diferente da lista.\nOs parênteses também podem ser escritos um após o outro, como demonstrado abaixo.\nEsta explicação visual da indexação de listas, com pimenteiros é bem-humorada e útil.\n\n# define uma lista demo\nmy_list &lt;- list(\n  # Primeiro elemento na lista é um vetor do tipo caractere \n  hospitals = c(\"Central\", \"Empire\", \"Santa Anna\"),\n  \n  # segundo elemento na lista é um dataframe com endereços  \n  addresses   = data.frame(\n    street = c(\"145 Medical Way\", \"1048 Brown Ave\", \"999 El Camino\"),\n    city   = c(\"Andover\", \"Hamilton\", \"El Paso\")\n    )\n  )\n\nVeja como fica a lista quando exibida no console. Veja como há dois elementos nomeados:\n\nhospitals,, um vetor de caracteres.\naddresses, um quadro de dados de endereços\n\n\nmy_list\n\n$hospitals\n[1] \"Central\"    \"Empire\"     \"Santa Anna\"\n\n$addresses\n           street     city\n1 145 Medical Way  Andover\n2  1048 Brown Ave Hamilton\n3   999 El Camino  El Paso\n\n\nAgora nos extraímos usando vários métodos:\n\nmy_list[1] # esse retorna o elemanto da classe \"lista\" - o nome do elemento ainda é exibido \n\n$hospitals\n[1] \"Central\"    \"Empire\"     \"Santa Anna\"\n\nmy_list[[1]] # este retorna apenas o vetor de caracter (sem nome) \n\n[1] \"Central\"    \"Empire\"     \"Santa Anna\"\n\nmy_list[[\"hospitals\"]] # você também pode indexar pelo nome do elemento da lista  \n\n[1] \"Central\"    \"Empire\"     \"Santa Anna\"\n\nmy_list[[1]][3] # Isto retorna o terceiro elemento do vetor de caracteres \"hospitals\" \n\n[1] \"Santa Anna\"\n\nmy_list[[2]][1] # Isto retorna a primeira coluna  (\"street\") da data frame de endereços\n\n           street\n1 145 Medical Way\n2  1048 Brown Ave\n3   999 El Camino\n\n\n\n\n\nRemover objetos\nVocê pode remover objetos individuais de seu ambiente R colocando o nome na função rm() (sem aspas):\n\nrm(object_name)\n\nVocê pode reomver todos os objetos (limpar o ambiente de trabalho) ao executar:\n\nrm(list = ls(all = TRUE))",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.pt.html#piping-encadeamento",
    "href": "new_pages/basics.pt.html#piping-encadeamento",
    "title": "3  Introdução ao R",
    "section": "3.11 Piping (Encadeamento, %>%)",
    "text": "3.11 Piping (Encadeamento, %&gt;%)\nDuas abordagens gerais para trabalhar com objetos são:\n\nPipes/tidyverse - pipes send an object from function to function - emphasis is on the action, not the object\n\nDefinir objetos intermediários - um objeto é redefinido repetidamente - a ênfase está no objeto.\n\n\n\nPipes\nExplicado de forma simples, o operador do pipe (%&gt;%) passa uma saída intermediária de uma função para a próxima.\nVocê pode pensar nisso como dizendo “então”. Muitas funções podem ser ligadas com %&gt;%.\n\nPiping enfatiza uma seqüência de ações, não o objeto sobre o qual as ações estão sendo realizadas\n\nPipes são melhores quando uma seqüência de ações deve ser executada em um único objeto.\n\nOs pipes vêm do pacote magrittr, que é automaticamente incluído nos pacotes dplyr e tidyverse\nOs pipes podem tornar o código mais limpo e fácil de ler, mais intuitivo\n\nLeia mais sobre esta abordagem no tidyverse guia de estilo\nAqui está um exemplo falso para comparação, usando funções fictícias para “assar um bolo”. Primeiro, o método do pipe:\n\n# Um exemplo falso de como assar um bolo usando a sintaxe do pipe \n\ncake &lt;- flour %&gt;%       #para definir o bolo, comece com farinha, e então ...\n  add(eggs) %&gt;%   # adicione ovos\n  add(oil) %&gt;%    # adicione óleo\n  add(water) %&gt;%  # adicione água\n  mix_together(         # misture\n    utensil = spoon,\n    minutes = 2) %&gt;%    \n  bake(degrees = 350,   # asse\n       system = \"fahrenheit\",\n       minutes = 35) %&gt;%  \n  let_cool()            # deixe esfriar\n\nAqui está outro link descrevendo a utilidade dos pipes.\nO pipe não é uma função do R base. Para utilizar o pipe, o pacote magrittr deve ser instalado e carregado (isto é normalmente feito carregando os pacotes tidyverse ou dplyr que o inclui). Você pode ler mais sobre pipe na documentação magrittr.\nObserve que, assim como outros comandos R, os pipes podem ser utilizados apenas para exibir o resultado, ou para salvar/reservar um objeto, dependendo se o operador de atribuição &lt;- está envolvido. Veja os dois abaixo:\n\n# Criar ou sobrescrever um objeto, definindo como contagens agregadas por faixa-etária  (não \"printado\")\nlinelist_summary &lt;- linelist %&gt;% \n  count(age_cat)\n\n\n# Printa a tabela de contagens no console, mas nao a salva  \nlinelist %&gt;% \n  count(age_cat)\n\n  age_cat    n\n1     0-4 1095\n2     5-9 1095\n3   10-14  941\n4   15-19  743\n5   20-29 1073\n6   30-49  754\n7   50-69   95\n8     70+    6\n9    &lt;NA&gt;   86\n\n\n%&lt;&gt;%\nEste é um “tubo de atribuição” do pacote magrittr, que encadeia um objeto para frente e também re-define o objeto. Deve ser o primeiro operador pipe da cadeia. É um “atalho”. Os dois comandos abaixo são equivalentes:\n\nlinelist &lt;- linelist %&gt;%\n  filter(age &gt; 50)\n\nlinelist %&lt;&gt;% filter(age &gt; 50)\n\n\n\n\nDefinir objetos intermediários\nEsta abordagem para mudar objetos/dataframes pode ser melhor se:\n\nVocê precisa manipular vários objetos…\nHá etapas intermediárias que são significativas e merecem nomes de objetos separados\n\nRiscos:\n\nCriar novos objetos para cada etapa significa criar muitos objetos. Se você usar o errado, talvez não se dê conta disso!\nNomear todos os objetos pode ser confuso…\nOs erros podem não ser facilmente detectáveis\n\nOu nomear cada objeto intermediário, ou sobrescrever o original, ou combinar todas as funções em conjunto. Todos vêm com seus próprios riscos.\nAbaixo está o mesmo exemplo falso de “bolo” como acima, mas usando este estilo:\n\n# um exemplo falso de como assar um bolo usado este método (definindo objetos intermediários) \nbatter_1 &lt;- left_join(flour, eggs)\nbatter_2 &lt;- left_join(batter_1, oil)\nbatter_3 &lt;- left_join(batter_2, water)\n\nbatter_4 &lt;- mix_together(object = batter_3, utensil = spoon, minutes = 2)\n\ncake &lt;- bake(batter_4, degrees = 350, system = \"fahrenheit\", minutes = 35)\n\ncake &lt;- let_cool(cake)\n\nCombine todas as funções em uma só - isso dificulta a leitura):\n\n# um exemplo de combinação/aninhamento de múltiplas funções  juntas - difícil de ler\ncake &lt;- let_cool(bake(mix_together(batter_3, utensil = spoon, minutes = 2), degrees = 350, system = \"fahrenheit\", minutes = 35))",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.pt.html#operadores",
    "href": "new_pages/basics.pt.html#operadores",
    "title": "3  Introdução ao R",
    "section": "3.12 Principais operadores e funções",
    "text": "3.12 Principais operadores e funções\nEsta seção detalha os operadores em R, como por exemplo:\n\nOperadores de definição\n\nOperadores relacionais (menos do que, igual a…)\nOperadores lógicos (e, ou…)\n\nLidando com valores faltantes…\nOperadores matemáticos e funções (+/-, &gt;, sum(), median(), …)\n\nO operador %in%\n\n\n\nOperador de atribuição\n&lt;-\nO operador de atribuição básica em R é &lt;-. De tal forma que nome_objeto &lt;- valor.\nEste operador de atribuição também pode ser escrito como =. Aconselhamos o uso de &lt;- para uso geral em R.\nAconselhamos também o uso de &lt;- para uso geral em R. Aconselhamos também o uso de espaços em torno de tais operadores, para facilitar a leitura.\n&lt;&lt;-\nSe você estiver Escrevendo funções, ou utilizando R de forma interativa com scripts de origem, então você pode precisar utilizar este operador de atribuição &lt;&lt;- (do R base). Este operador é utilizado para definir um objeto em um ambiente R ‘pai’ superior. Veja isto referência on-line.\n%&lt;&gt;%\nEste é um “pipe de atribuição” do pacote magrittr, que canaliza um objeto para frente e também re-define o objeto. Deve ser o primeiro operador pipe da cadeia. É a abreviação, como mostrado abaixo em dois exemplos equivalentes:\n\nlinelist &lt;- linelist %&gt;% \n  mutate(age_months = age_years * 12)\n\nO código acima é equivalente ao abaixo:\n\nlinelist %&lt;&gt;% mutate(age_months = age_years * 12)\n\n%&lt;+%\nIsso é usado para adicionar dados a árvores filogenéticas com o pacote ggtree. Veja a página em Árvores Filogenéticas ou este livro de recursos online.\n\n\n\nOperadores relacionais e lógicos\nOs operadores relacionais comparam valores e são freqüentemente utilizados na definição de novas variáveis e subconjuntos de conjuntos de dados. Aqui estão os operadores relacionais comuns em R:\n\n\n\nSignificado\nOperador\nExamplo\nResultado do exemplo\n\n\n\n\nIgual a\n==\n\"A\" == \"a\"\nFALSE (porque o R é sensível a letras maiúscula/minúsculas)  Note que == (iguais duplos) é diferente de = (símbolo de igual normal), que age como o operador de atribuição &lt;-\n\n\nNão igual (diferente)\n!=\n2 != 0\nTRUE\n\n\nMaior que\n&gt;\n4 &gt; 2\nTRUE\n\n\nMenor que\n&lt;\n4 &lt; 2\nFALSE\n\n\nMaior ou igual a\n&gt;=\n6 &gt;= 4\nTRUE\n\n\nMenor ou igual a\n&lt;=\n6 &lt;= 4\nFALSE\n\n\nValor está faltante\nis.na()\nis.na(7)\nFALSE (veja página em Dados faltantes)\n\n\nValor não faltante\n!is.na()\n!is.na(7)\nTRUE\n\n\n\nOperadores lógicos, como AND e OR, geralmente são usados para conectar operadores relacionais e criar critérios mais complicados. Instruções complexas podem exigir parênteses ( ) para agrupamento e ordem de aplicação.\n\n\n\n\n\n\n\nSignificado\nOperador\n\n\n\n\nAND\n&\n\n\nOR\n| (barra vertical)\n\n\nParentheses\n( ) Usado para agrupar critérios e clarificar a ordem das operações\n\n\n\nPor exemplo, abaixo, temos uma linelist com duas variáveis que queremos utilizar para criar nossa definição de caso, hep_e_rdt, um resultado de teste e other_cases_in_hh, que nos dirá se há outros casos na casa. O comando abaixo utiliza a função case_when() para criar a nova variável case_def de tal forma que:\n\nlinelist_cleaned &lt;- linelist %&gt;%\n  mutate(case_def = case_when(\n    is.na(rdt_result) & is.na(other_case_in_home)            ~ NA_character_,\n    rdt_result == \"Positive\"                                 ~ \"Confirmed\",\n    rdt_result != \"Positive\" & other_cases_in_home == \"Yes\"  ~ \"Probable\",\n    TRUE                                                     ~ \"Suspected\"\n  ))\n\n\n\n\n\n\n\n\nCritérios no exemplo acima\nValor da nova variável “case_def”\n\n\n\n\nSe o valor das variáveis rdt_result e other_cases_in_home estiverem faltando\nNA (faltante)\n\n\nSe o valor em rdt_result for “Positive”\nConfirmed\n\n\nIf the value in rdt_result is NOT “Positive” AND the value in other_cases_in_home is “Yes”\nProbable\n\n\nIf one of the above criteria are not met\nSuspected\n\n\n\nNote that R is case-sensitive, so “Positive” is different than “positive”…\n\n\n\nValores faltantes\nEm R, os valores ausentes são representados pelo valor especial NA (um valor “reservado”) (letras maiúsculas N e A - não entre aspas). Se você importar dados que registram dados ausentes de outra maneira (por exemplo, 99, “Missing” ou .), convém recodificar esses valores para NA. Como fazer isso é abordado na página Importação e exportação.\nPara testar se um valor é NA, use a função especial is.na(), que retorna TRUE ou FALSE.\n\nrdt_result &lt;- c(\"Positive\", \"Suspected\", \"Positive\", NA)   # dois casos positivos, um suspeito e um desconhecido \nis.na(rdt_result)  # Testa se o valor de  rdt_result é NA\n\n[1] FALSE FALSE FALSE  TRUE\n\n\nLeia mais sobre valores ausentes, infinitos, NULL e impossíveis na página em Campos em branco/faltantes. Saiba como converter valores ausentes ao importar dados na página em Importação e exportação.\n\n\n\nMatemática e estatística\nTodos os operadores e funções nesta página estão disponíveis automaticamente usando o pacote R base.\n\nOperadores mmatemáticos\nEstes são frequentemente usados para realizar adição, divisão, para criar novas colunas, etc. Abaixo estão os operadores matemáticos comuns em R. Colocar ou não os espaços ao redor dos operadores não é importante.\n\n\n\nPropósito\nExemplo no R\n\n\n\n\nadição\n2 + 3\n\n\nsubtração\n2 - 3\n\n\nmultiplicação\n2 \\* 3\n\n\ndivisão\n30 / 5\n\n\npotência\n2\\^3\n\n\nordem das operações\n( )\n\n\n\n\n\nFunções matemáticas\n\n\n\n\n\n\n\nPropósito\nFunção\n\n\n\n\narredondamento\nround(x, digits = n)\n\n\narredondamento\njanitor::round_half_up(x, digits = n)\n\n\nteto (arredondar para cima)\nceiling(x)\n\n\nchão (arredondar para baixo)\nfloor(x)\n\n\nvalor obsoluto (módulo)\nabs(x)\n\n\nraiz quadrada\nsqrt(x)\n\n\nexponencial\nexponent(x)\n\n\nlogaritmo natural/neperiano\nlog(x)\n\n\nlogaritmo na base 10\nlog10(x)\n\n\nlogaritmo na base 2\nlog2(x)\n\n\n\nNota: para round() o digits = especifica o número de casas decimais colocadas. Use signif() para arredondar para um número de algarismos significativos.\n\n\nNotação científica\nA probabilidade de notação científica ser usada depende do valor da opção scipen.\nDa documentação de ?options: scipen é uma penalidade a ser aplicada ao decidir imprimir valores numéricos em notação fixa ou exponencial. Os valores positivos tendem para a notação fixa e os negativos para a notação científica: a notação fixa será preferida, a menos que seja mais do que os dígitos ‘scipen’ mais largos.\nSe estiver definido para um número baixo (por exemplo, 0), ele estará sempre “ligado”. Para “desativar” a notação científica em sua sessão R, defina-a como um número muito alto, por exemplo:\n\n# desligar a notação científica\noptions(scipen=999)\n\n\n\nArredondando\nPERIGO: A função round() usa “arredondamento do banqueiro” que arredonda de .5 somente se o número superior for par. Use round_half_up() do janitor para arredondar consistentemente metades para o número inteiro mais próximo. Veja esta explicação\n\n# use a função de arredondamento adequanda para o seu trabalho \nround(c(2.5, 3.5))\n\n[1] 2 4\n\njanitor::round_half_up(c(2.5, 3.5))\n\n[1] 3 4\n\n\n\n\nFunções estatísticas\nCUIDADO: As funções abaixo incluirão, por padrão, valores ausentes nos cálculos. Valores ausentes resultarão em uma saída de NA, a menos que o argumento na.rm = TRUE seja especificado. Isso pode ser escrito de forma abreviada como na.rm = T.\n\n\n\nObjetivo\nFunção\n\n\n\n\nmédia aritmética\nmean(x, na.rm=T)\n\n\nmediana\nmedian(x, na.rm=T)\n\n\ndesvio padrão\nsd(x, na.rm=T)\n\n\nquantis*\nquantile(x, probs)\n\n\nsoma\nsum(x, na.rm=T)\n\n\nvalor mínimo\nmin(x, na.rm=T)\n\n\nvalor máximo\nmax(x, na.rm=T)\n\n\nrange de valores numéricos\nrange(x, na.rm=T)\n\n\nresumo**\nsummary(x)\n\n\n\nNotas:\n\n* quantile(): x é o vetor numérico a ser examinado e probs = é um vetor numérico com probabilidades entre 0 e 1,0, por exemplo, c(0.5 , 0.8 , 0,.85)\n** summary(): fornece um resumo em um vetor numérico incluindo média, mediana e percentis comuns\n\nPERIGO: Ao fornecer um vetor de números para uma das funções acima, certifique-se de concatenar os números dentro de c() .\n\n# Se fornecer números brutos para uma função, concatene-os antes com c()\nmean(1, 6, 12, 10, 5, 0)    # !!! INCORRETO !!!  \n\n[1] 1\n\nmean(c(1, 6, 12, 10, 5, 0)) # CORRETO\n\n[1] 5.666667\n\n\n\n\nOutras funções úteis\n\n\n\n\n\n\n\n\nObjetivo\nFunção\nExamplo\n\n\n\n\ncriar uma sequência de números\nseq(from, to, by)\nseq(1, 10, 2)\n\n\nrepetir x, n vezes\nrep(x, ntimes)\nrep(1:3, 2) or rep(c(\"a\", \"b\", \"c\"), 3)\n\n\nsubdividir um vetor numérico\ncut(x, n)\ncut(linelist$age, 5)\n\n\npegar uma amostra aleatória\nsample(x, size)\nsample(linelist$id, size = 5, replace = TRUE)\n\n\n\n\n\n\n\n%in%\nUm operador muito útil para combinar valores e avaliar rapidamente se um valor está dentro de um vetor ou dataframe.\n\nmeu_vetor &lt;- c(\"a\", \"b\", \"c\", \"d\")\n\n\n\"a\" %in% meu_vetor\n\n[1] TRUE\n\n\"h\" %in% meu_vetor\n\n[1] FALSE\n\n\nPara perguntar se um valor não está em (%in%) é um vetor, coloque um ponto de exclamação (!) na frente da instrução lógica:\n\n# para negar, coloque a exclamação na frente \n!\"a\" %in% meu_vetor\n\n[1] FALSE\n\n!\"h\" %in% meu_vetor\n\n[1] TRUE\n\n\n%in% é muito útil ao usar a função dplyr case_when(). Você pode definir um vetor anteriormente e depois referenciá-lo. Por exemplo:\n\naffirmative &lt;- c(\"1\", \"Yes\", \"YES\", \"yes\", \"y\", \"Y\", \"oui\", \"Oui\", \"Si\")\n\nlinelist &lt;- linelist %&gt;% \n  mutate(child_hospitaled = case_when(\n    hospitalized %in% affirmative & age &lt; 18 ~ \"Hospitalized Child\",\n    TRUE                                      ~ \"Not\"))\n\nNote: If you want to detect a partial string, perhaps using str_detect() from stringr, it will not accept a character vector like c(\"1\", \"Yes\", \"yes\", \"y\"). Instead, it must be given a regular expression - one condensed string with OR bars, such as “1|Yes|yes|y”. For example, str_detect(hospitalized, \"1|Yes|yes|y\"). See the page on Caracteres e strings for more information.\nYou can convert a character vector to a named regular expression with this command:\n\naffirmative &lt;- c(\"1\", \"Yes\", \"YES\", \"yes\", \"y\", \"Y\", \"oui\", \"Oui\", \"Si\")\naffirmative\n\n[1] \"1\"   \"Yes\" \"YES\" \"yes\" \"y\"   \"Y\"   \"oui\" \"Oui\" \"Si\" \n\n# condensar\naffirmative_str_search &lt;- paste0(affirmative, collapse = \"|\")  # opção com R base\naffirmative_str_search &lt;- str_c(affirmative, collapse = \"|\")   # opção co pacote stringr\n\naffirmative_str_search\n\n[1] \"1|Yes|YES|yes|y|Y|oui|Oui|Si\"",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "new_pages/basics.pt.html#erros-avisos",
    "href": "new_pages/basics.pt.html#erros-avisos",
    "title": "3  Introdução ao R",
    "section": "3.13 Erros & avisos",
    "text": "3.13 Erros & avisos\nEsta seção explica:\n\nA diferença entre erros e avisos\n\nDicas gerais de sintaxe para escrever código R\n\nAjudas para o código.\n\nErros e avisos comuns e dicas de solução de problemas podem ser encontrados na página em Erros e ajuda.\n\n\nErros versus Avisos\nQuando um comando é executado, o Console R pode mostrar mensagens de aviso ou erro em texto vermelho.\n\nUm aviso significa que o R concluiu seu comando, mas teve que executar etapas adicionais ou produziu uma saída incomum da qual você deve estar ciente.\nUm erro significa que o R não conseguiu completar seu comando.\n\nProcurar pistas:\n\nA mensagem de erro/aviso geralmente inclui um número de linha para o problema.\nSe um objeto “é desconhecido” ou “não encontrado”, talvez você o tenha escrito incorretamente, esquecido de chamar um pacote com library() ou esquecido de executar novamente seu script após fazer alterações.\n\nSe tudo mais falhar, copie a mensagem de erro no Google junto com alguns termos-chave: é provável que alguém já tenha trabalhado com isso!\n\n\n\nDicas gerais de sintaxe\nAlgumas coisas para lembrar ao escrever comandos em R, para evitar erros e avisos:\n\nSempre feche os parênteses - dica: conte o número de abertura “(” e fechamento de parênteses “)” para cada pedaço de código\nEvite espaços em nomes de colunas e objetos. Use sublinhado ( _ ) ou pontos ( . )\nAcompanhe e lembre-se de separar os argumentos de uma função com vírgulas\nR diferencia maiúsculas de minúsculas, o que significa que Variable_A é diferente de variable_A\n\n\n\n\nAjudas de código\nQualquer script (RMarkdown ou outro) dará pistas quando você cometer um erro. Por exemplo, se você esqueceu de escrever uma vírgula onde for necessário, ou de fechar um parêntese, o RStudio irá levantar uma bandeira nessa linha, no lado direito do script, para avisá-lo.",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Introdução ao R</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.pt.html",
    "href": "new_pages/transition_to_R.pt.html",
    "title": "4  Transição para o R",
    "section": "",
    "text": "4.1 Partindo do Excel\nA transição do Excel diretamente para R é uma meta muito viável. Pode parecer assustador, mas você consegue fazer isso!\nÉ verdade que alguém com fortes habilidades no Excel pode fazer atividades muito avançadas somente no Excel - até mesmo usando ferramentas de programação em código como VBA. O Excel é usado em todo o mundo e é uma ferramenta essencial para um epidemiologista. Entretanto, complementá-lo com R pode melhorar drasticamente e expandir seus fluxos de trabalho.",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Transição para o R</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.pt.html#partindo-do-excel",
    "href": "new_pages/transition_to_R.pt.html#partindo-do-excel",
    "title": "4  Transição para o R",
    "section": "",
    "text": "Benefícios\nVocê descobrirá que o uso de R oferece imensos benefícios, desde tempo economizado, análises mais consistentes e precisas, reprodutibilidade, compartilhabilidade e correção mais rápida de erros. Como qualquer software novo, há uma “curva” de aprendizado que reflete o tempo que você deve investir para se familiarizar em ele. Os dividendos serão significativos e um imenso escopo de novas possibilidades se abrirá para você com o R.\nExcel é um software bem conhecido que pode ser fácil para um iniciante usar para produzir análises e visualizações simples com o “apontar e clicar”. Em comparação, pode levar algumas semanas para se tornar confortável com as funções e a interface do R. No entanto, o R evoluiu nos últimos anos para se tornar muito mais amigável para iniciantes.\nMuitos fluxos de trabalho do Excel dependem da memória e da repetição - portanto, há muitas oportunidades de erro. Além disso, geralmente a limpeza de dados, a metodologia de análise e as equações utilizadas são ocultadas da vista. Pode ser necessário um tempo substancial para que um novo colega aprenda o que uma pasta de trabalho Excel está fazendo e como resolvê-la. Com R, todas as etapas são explicitamente escritas no script e podem ser facilmente visualizadas, editadas, corrigidas e aplicadas a outros conjuntos de dados.\nPara iniciar sua transição do Excel para o R, você deve ajustar sua mentalidade de algumas maneiras importantes:\n\n\nDados bem arrumados (tidy data)\nUse dados “arrumados” (tidy), isto é, que sejam legíveis para a máquina em vez de dados bagunçados, que são apenas “legíveis para humanos”. Estes são os três principais requisitos para dados do tipo “tidy”, como explicado neste tutorial sobre dados “tidy” em R:\n\nCada variável deve ter sua própria coluna\n\nCada observação deve ter sua própria linha\nCada valor deve ter sua própria célula\n\nPara os usuários do Excel - pense no papel que as “tabelas” Excel desempenham na padronização dos dados e na maior previsibilidade do formato.\nUm exemplo de dados “tidy” seria a lista (linelist) de casos utilizada ao longo deste manual - cada variável está contida dentro de uma coluna, cada observação (um caso) tem sua própria linha, e cada valor está em apenas uma célula. Abaixo você pode ver as primeiras 50 linhas desta linelist:\n\n\n\n\n\n\nO principal motivo pelo qual entramos dados não-arrumados por aí (non-tidy) se deve ao fato de muitas planilhas Excel serem projetadas para priorizar a leitura fácil por humanos, não a leitura fácil por máquinas/software.\nPara ajudá-lo a ver a diferença, abaixo estão alguns exemplos fictícios de dados não-arrumados que priorizam leitura por humanos em vez de leitura por máquina:\n\n\n\n\n\n\n\n\n\nProblemas: Na planilha acima, há células mescladas que não são facilmente digeridas pelo R. Qual linha deve ser considerada o “cabeçalho” não está totalmente clara. Um dicionário baseado em cores está do lado direito e os valores das células são representados por cores - o que também não é facilmente interpretado pelo R (nem por humanos daltônicos!). Além disso, diferentes pedaços de informação são combinados em uma célula (múltiplas organizações parceiras trabalhando em uma área, ou o status “TBC” na mesma célula que “Parceiro (partner) D”).\n\n\n\n\n\n\n\n\n\nProblemas: Na planilha acima, há numerosas linhas e colunas vazias extras dentro do conjunto de dados - isto causará dores de cabeça para a limpeza do banco no R. Além disso, as coordenadas GPS estão espalhadas por duas linhas para um determinado centro de tratamento. Como nota lateral - as coordenadas GPS estão em dois formatos diferentes!\nOs conjuntos de dados “tidy” podem não ser tão legíveis a um olho humano, mas tornam a limpeza e análise dos dados muito mais fácil! Dados “tidy” podem ser armazenados em vários formatos, por exemplo “longo/comprido” (long) ou “largo/amplo” (wide) (ver página em Pivotando dados), mas os princípios acima serão sempre observados.\n\n\nFunções\nA palavra “função” em R pode ser nova, mas o conceito também existe no Excel como fórmulas. As fórmulas no Excel também requerem sintaxe precisa (por exemplo, colocação de ponto-e-vírgula e parênteses). Tudo o que você precisa fazer é aprender algumas novas funções e como elas funcionam juntas em R.\n\n\nScripts\nEm vez de clicar nos botões e arrastar as células, você estará escrevendo todos os passos e procedimentos em um “roteiro” (daqui em diante referido como script). Os usuários do Excel podem estar familiarizados com “macros VBA” que também empregam uma abordagem de códigos de programação.\nO script R consiste de instruções passo a passo. Isto permite que qualquer colega leia o script e veja facilmente os passos que você deu. Isto também ajuda a eliminar erros ou cálculos imprecisos. Veja a seção Introdução ao R sobre scripts para exemplos.\nAqui está um exemplo de um script em R:\n\n\n\n\n\n\n\n\n\n\n\nDo Excel-para-R: recursos\n\nR vs. Excel\n\ncurso RStudio em R para usuários do Excel\n\n\n\nInteração R-Excel\nR tem formas robustas de importar pastas de trabalho do Excel, trabalhar com os dados, exportar/guardar arquivos Excel e trabalhar com as nuances das planilhas Excel.\nÉ verdade que algumas das formatações mais estéticas do Excel podem se perder na tradução (por exemplo, itálico, texto lateral, etc.). Se seu fluxo de trabalho exigir a passagem de documentos entre R e Excel enquanto mantém a formatação original do Excel, tente pacotes como openxlsx*.",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Transição para o R</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.pt.html#partindo-do-stata",
    "href": "new_pages/transition_to_R.pt.html#partindo-do-stata",
    "title": "4  Transição para o R",
    "section": "4.2 Partindo do Stata",
    "text": "4.2 Partindo do Stata\n\nVindo do Stata para R*\nMuitos epidemiologistas são ensinados primeiro a usar Stata, e pode parecer assustador mudar para R. Entretanto, se você é um usuário confortável de Stata, então o salto para R é certamente mais manejável do que você possa pensar. Embora existam algumas diferenças chave entre Stata e R em como os dados podem ser criados e modificados, bem como a maneira que as funções de análise são implementadas - após aprender estas diferenças chave você será capaz de adaptar suas habilidades.\nAbaixo estão algumas traduções chave entre Stata e R, que podem ser úteis como sua revisão deste guia.\nNotas gerais\n\n\n\nSTATA\nR\n\n\n\n\nVocê só pode visualizar e manipular um conjunto de dados de cada vez\nVocê pode visualizar e manipular vários conjuntos de dados ao mesmo tempo, portanto você terá que especificar freqüentemente seu conjunto de dados dentro do código\n\n\nComunidade online disponível por meio de https://www.statalist.org/\nComunidade online disponível por meio de RStudio, StackOverFlow, e R-bloggers\n\n\nFuncionalidade “apontar e clicar” como opção\nFuncionalidade “apontar e clicar” mínima\n\n\nAjuda para comandos disponíveis por help [comando]\nAjuda disponível por ?função ou busca no painel de Ajuda\n\n\nComentar código usando * ou /// ou /* TEXTO */\nComentar código usando #\n\n\nQuase todos os comandos são nativos ao Stata. Funções novas/escritas pelo usuário podem ser instaladas como arquivos ado* usando ssc install [pacote]\nA instalação do R vem com funções base , mas o uso típico envolve a instalação de outros pacotes do CRAN (veja página em Introdução ao R)\n\n\nA análise é geralmente escrita em um arquivo do\nAnálise escrita em um script R no painel de fontes do RStudio. Scripts em R Markdown são uma alternativa.\n\n\n\nDiretório de trabalho\n\n\n\nSTATA\nR\n\n\n\n\nOs diretórios de trabalho envolvem caminhos de arquivo absolutos (por exemplo, “C:/ nome do usuário/documentos/projetos/dados/”)\nOs diretórios de trabalho podem ser absolutos, ou relativos a uma pasta raiz do projeto usando o pacote here (ver Importar e exportar)\n\n\nVer diretório de trabalho atual com pwd\nUtilize getwd() ou here() (se utilizar o pacote here), com parênteses vazios\n\n\nDefinir diretório de trabalho com cd “localização de pasta”\nUtilize setwd(\"localização de pasta\"), ou set_here(\"localização de pasta\") (se estiver utilizando here* pacote)\n\n\n\nImportando e visualizando dados\n\n\n\nSTATA\nR\n\n\n\n\nComandos específicos por tipo de arquivo\nUtilize import() do pacote rio para quase todos os tipos de arquivo. Existem funções específicas como alternativas (ver Importar e exportar)\n\n\nA leitura em arquivos csv é feita por importar delimited “filename.csv”.\nUse import(\"nomedoarquivo.csv\")\n\n\nA leitura em arquivos xslx é feita por import excel “filename.xlsx”\nUse import(\"nomedoarquivo.xlsx\")\n\n\nNavegue seus dados em uma nova janela utilizando o comando browse\nVisualize um conjunto de dados no painel de origem do RStudio utilizando View(conjunto de dados). Você precisa especificar o nome de seu conjunto de dados para a função em R porque vários conjuntos de dados podem ser mantidos ao mesmo tempo. Note “V” maiúsculo nesta função.\n\n\nObtenha uma visão geral do seu conjunto de dados utilizando summarize, que fornece os nomes das variáveis e informações básicas\nObtenha uma visão geral do seu conjunto de dados utilizando summary(conjunto de dados).\n\n\n\nManipulações básicas de dados\n\n\n\nSTATA\nR\n\n\n\n\nAs colunas do conjunto de dados são frequentemente referidas como “variáveis”\nMais frequentemente referidas como “colunas” ou às vezes como “vetores” ou “variáveis”.\n\n\nNão é necessário especificar o conjunto de dados\nEm cada um dos comandos abaixo, você precisa especificar o conjunto de dados - veja a página em Limpeza de dados e principais funções para exemplos\n\n\nNovas variáveis são criadas utilizando o comando generate nome_var =\nGerar novas variáveis utilizando a função mutate(nome_var = ). Consulte a página Limpeza de dados e principais funções para obter detalhes sobre todas as funções abaixo dplyr*.\n\n\nAs variáveis são renomeadas utilizando rename nome_antigo nome_novo\nColunas podem ser renomeadas utilizando a função rename(novo_nome = nome_antigo)\n\n\nAs variáveis são descartadas utilizando drop nome_var\nAs colunas podem ser removidas utilizando a função select() com o nome da coluna entre parênteses, seguindo um sinal de subtração\n\n\nAs variáveis fatoriais podem ser etiquetadas usando uma série de comandos como label define\nOs valores de etiquetagem podem ser feitos convertendo a coluna para a classe fator e especificando níveis. Veja a página em Fatores. Os nomes das colunas não são tipicamente etiquetados como estão na Stata.\n\n\n\nAnálise descritiva\n\n\n\nSTATA\nR\n\n\n\n\nTabula contagens de uma variável utilizando tab nome_var\nForneça o conjunto de dados e nome da coluna para table() tal como table(dataset$nome_da_coluna). Alternativamente, utilize count(nome_var) do pacote dplyr, como explicado em Agrupando dados.\n\n\nUma tabela de contingência de duas variáveis em uma tabela 2x2 é feito com tab nome_var1 nome_var2\nUse table(dataset$nome_var1, dataset$nome_var2 ou count(nome_var1, nome_var2)\n\n\n\nEmbora esta lista dê uma visão geral dos conceitos básicos na tradução dos comandos Stata em R, ela não é completa. Há muitos outros grandes recursos para os usuários da Stata em transição para R que poderiam ser de interesse:\n\nhttps://dss.princeton.edu/training/RStata.pdf\n\nhttps://clanfear.github.io/Stata_R_Equivalency/docs/r_stata_commands.html\n\nhttp://r4stats.com/books/r4stata/",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Transição para o R</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.pt.html#partindo-do-sas",
    "href": "new_pages/transition_to_R.pt.html#partindo-do-sas",
    "title": "4  Transição para o R",
    "section": "4.3 Partindo do SAS",
    "text": "4.3 Partindo do SAS\n\nVindo da SAS para R*\nO SAS é comumente usado em agências de saúde pública e campos de pesquisa acadêmica. Embora a transição para um novo idioma raramente seja um processo simples, compreender as diferenças-chave entre SAS e R pode ajudá-lo a começar a navegar no novo idioma usando seu idioma nativo. A seguir, descrevemos as principais traduções no gerenciamento de dados e análise descritiva entre a SAS e o R.\nNotas gerais\n\n\n\nSAS\nR\n\n\n\n\nComunidade online disponível em SAS Customer Support\nComunidade online disponível em RStudio, StackOverFlow, e R-bloggers\n\n\nAjuda para os comandos disponíveis por help [comando]\nAjuda disponível por ?função ou busca no painel de Ajuda\n\n\nComentar código utilizando * TEXT ; ou /* TEXT */\nComentar código utilizando #\n\n\nQuase todos os comandos são nativos. Os usuários podem escrever novas funções utilizando a macro SAS, SAS/IML, SAS Component Language (SCL) e, mais recentemente, procedimentos Proc Fcmp e Proc Proto\nA instalação do R vem com as funções base, mas o uso típico envolve a instalação de outros pacotes do CRAN (veja a página em Introdução ao R)\n\n\nA análise é geralmente conduzida escrevendo um programa SAS na janela do Editor.\nAnálise escrita em um script R no painel fonte do RStudio. Scripts em R Markdown são uma alternativa.\n\n\n\nDiretório de trabalho\n\n\n\nSAS\nR\n\n\n\n\nOs diretórios de trabalho podem ser absolutos ou relativos a uma pasta raiz do projeto, definindo a pasta raiz utilizando %let rootdir=/root path; %include \"&rootdir/subfoldername/nome_arqquivo\"\nOs diretórios de trabalho podem ser absolutos ou relativos a uma pasta raiz do projeto utilizando o pacote here (ver Importar e exportar)\n\n\nVeja o diretório de trabalho atual com % de produção %sysfunc(getoption(work));\nUse getwd() ou here() (se utilizar o pacote here), com parênteses vazios\n\n\nDefinir diretório de trabalho com libname \"localização de pasta\"\nUse setwd(\"localização de pasta\"), ou set_here(\"localização de pasta) se utilizar o pacote here.\n\n\n\nImportando e visualizando dados\n\n\n\nSAS\nR\n\n\n\n\nUtilize o procedimento Proc Importar' ou utilize a declaraçãoData Step Infile’.\nUtilize a função import() do pacote rio para quase todos os tipos de arquivos. Existem funções específicas como alternativas (ver Importar e exportar).\n\n\nA leitura em arquivos csv é feita utilizando Proc Import datafile=\"nome_arqquivo.csv\" out=work.nome_arqquivo dbms=CSV; run; ou usando Data Step Infile statement\nUse import(\"nome_arqquivo.csv\")\n\n\nA leitura em arquivos xslx é feita utilizando Proc Import datafile=\"nome_arqquivo.xlsx\" out=work.nome_arqquivo dbms=xlsx; run; ou usando Data Step Infile statement\nUse import(“nome_arqquivo.xlsx”)\n\n\nNavegue pelos seus dados em uma nova janela abrindo a janela do Explorer e selecione a biblioteca desejada e o conjunto de dados\nVeja um conjunto de dados no painel de fontes do RStudio usando View(dataset). Você precisa especificar o nome de seu conjunto de dados para a função em R porque vários conjuntos de dados podem ser mantidos ao mesmo tempo. atenção para “V” maiúsculo nesta função\n\n\n\nManipulações básicas de dados\n\n\n\nSAS\nR\n\n\n\n\nAs colunas do conjunto de dados são frequentemente referidas como “variáveis”\nMais frequentemente referidas como “colunas” ou às vezes como “vetores” ou “variáveis”.\n\n\nNão são necessários procedimentos especiais para criar uma variável. Novas variáveis são criadas simplesmente digitando o novo nome da variável, seguido por um sinal de igual e, em seguida, uma expressão para o valor\nGere novas variáveis utilizando a função mutate(). Consulte a página Limpeza de dadps e principais funções para obter detalhes sobre todas as funções abaixo dplyr.\n\n\nAs variáveis são renomeadas utilizando renome *nome_antigo=nome_novo*\nAs colunas podem ser renomeadas utilizando a função rename(novo_nome = nome_antigo)\n\n\nAs variáveis são mantidas utilizando **keep**=nome_var\nColunas podem ser selecionadas utilizando a função select() com o nome da coluna entre parênteses\n\n\nAs variáveis são descartadas utilizando **drop**=nome da coluna\nAs colunas podem ser removidas utilizando a função select() com o nome da coluna entre parênteses, seguindo um sinal de subtração\n\n\nAs variáveis do tipo fator podem ser etiquetadas na Etapa de Dados, utilizando a declaração de ‘Label’\nOs valores do rótulo podem ser feitos convertendo a coluna para a classe Fator e especificando níveis. Veja a página em Fatores. Os nomes das colunas não são tipicamente rotulados.\n\n\nOs registros são selecionados utilizando a instrução Where ou If na Etapa de Dados. As condições de seleção múltipla são separadas utilizando o comando “and”.\nOs registros são selecionados utilizando a função filter() com condições de seleção múltipla separadas por um operador AND (&) ou por uma vírgula\n\n\nOs conjuntos de dados são combinados utilizando a declaração Merge na Etapa de Dados. Os conjuntos de dados a serem fundidos precisam ser ordenados primeiro utilizando o procedimento Proc Sort.\nO pacote dplyr oferece algumas funções para fundir conjuntos de dados. Consulte a página Agrupando Dados para obter detalhes.\n\n\n\nAnálise descritiva\n\n\n\nSAS\nR\n\n\n\n\nObtenha uma visão geral do seu conjunto de dados utilizando o procedimento “Proc Summary”, que fornece os nomes das variáveis e as estatísticas descritivas.\nObtenha uma visão geral do seu conjunto de dados utilizando o “summary(conjunto_de_dados)” ou “skimr(conjunto_de_dados)” do pacote skimr.\n\n\nTabular contagens de uma variável utilizando proc freq data=Dataset; Tables varname; Run;\nVer a página em Tabelas descritivas. As opções incluem table() do R base, e tabyl() do pacote janitor , entre outras. Observe que você precisará especificar o conjunto de dados e o nome da coluna, pois R contém vários conjuntos de dados.\n\n\nA tabulação cruzada (tabela de contingência) de duas variáveis em uma tabela 2x2 é feita com proc freq data=Dataset; Tables rowvar*colvar; Run;\nNovamente, você pode utilizar table(), tabyl() ou outras opções como descritas na página Tabelas descritivas.\n\n\n\nAlguns recursos úteis:\nR para usuários de SAS e SPSS (2011)\nSAS e R, Segunda Edição (2014)",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Transição para o R</span>"
    ]
  },
  {
    "objectID": "new_pages/transition_to_R.pt.html#interoperabilidade-de-dados",
    "href": "new_pages/transition_to_R.pt.html#interoperabilidade-de-dados",
    "title": "4  Transição para o R",
    "section": "4.4 Interoperabilidade de dados",
    "text": "4.4 Interoperabilidade de dados\n\nVeja a página Importar e exportar para detalhes sobre como o pacote rio do R pode importar e exportar arquivos como arquivos STATA .dta, arquivos SAS .xpt e.sas7bdat, arquivos SPSS .por e.sav, e muitos outros.",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Transição para o R</span>"
    ]
  },
  {
    "objectID": "new_pages/packages_suggested.pt.html",
    "href": "new_pages/packages_suggested.pt.html",
    "title": "5  Pacotes sugeridos",
    "section": "",
    "text": "5.1 Pacotes do CRAN\n##########################################\n# Lista de pscotes úteis para uso em epidemiologia#\n##########################################\n\n# Este script usa a função p_load() do pacote R pacman , \n# que  instala se o pacote estiver ausente, e os carrega para uso, se já estiverem instalados\n\n\n# Garante que o pacman eestá instalado\nif (!require(\"pacman\")) install.packages(\"pacman\")\n\n\n# Pacotes disponíveis no CRAN\n##############################\npacman::p_load(\n     \n     # aprendendo R\n     ############\n     learnr,   # tutoriais interativos no RStudio \n     swirl,    # tutoriais interetivos no console\n        \n     # manuseio de projetos e arquivos \n     #############################\n     here,     # caminhos relativos de arquivos para a pasta raiz do projeto \n     rio,      # importar/exportar muitos formatos de arquivos\n     openxlsx, # importar/exportar planilhas de Excel com várias abas \n     \n     # manipulação e instalação de pacotes\n     ################################\n     pacman,   # instalação e carregamento de pacotes\n     renv,     # manipulando versões de pacotes quando trabalhando em grupos \n     remotes,  # instalar pacotes do github \n     \n     # Manipulação geral de dados\n     #########################\n     tidyverse,    # inlcui vários pacotes para arrumação,  manipulação e apresentação de dados. \n          #dplyr,      # manipulação de dados\n          #tidyr,      # manipulação de dados\n          #ggplot2,    # visualização de dados\n          #stringr,    # trabalhar com strings e caracteres\n          #forcats,    # trabalhar com fatores\n          #lubridate,  # trabalhar com datas\n          #purrr       # iteração e trabalhando com listas\n     linelist,     # limpando linelists\n     naniar,       # assessando valores ausentes\n     \n     # estatísticas\n     ############\n     janitor,      # tabelas e limpeza de dados\n     gtsummary,    # fazendo tabelas estatísticas e descritivas\n     rstatix,      #  fazer estatíticas e resumos rápidos \n     broom,        # arrumar resultados de regressões \n     lmtest,       # testes de razão de likelihood\n     easystats,\n          # parametros, # alternativa a limpar os resultados de regressões. \n          # see,        # alternativa para vizualizar gráfico de floresta. \n     \n     # modelagem de epidemias\n     ###################\n     epicontacts,  # Analisando rede de transmissão t\n     EpiNow2,      # Estimando Rt \n     EpiEstim,     # Estimando Rt \n     projections,  # Projeção de incidencia\n     incidence2,   # Fazer epicurvas e manipular dados de incidência. \n     i2extras,     # Funções extra para pacote incidence2 \n     epitrix,      # Funções epi úteis\n     distcrete,    # Distribuições discretas com delay (atraso)\n     \n     \n     # Gráficos - geral\n     #################\n     #ggplot2,         # incluso no tidyverse\n     cowplot,          # combinando gráficos\n     # patchwork,      #combinando gráficos (alternativa)     \n     RColorBrewer,     # escala de cores\n     ggnewscale,       # adicionar novos esquemas de cores\n\n     \n     # Gráficos - tipos específicos\n     ########################\n     DiagrammeR,       # diagramas utilizando linguagem DOT\n     incidence2,       # curvas epidêmicas\n     gghighlight,      # highlight um subset\n     ggrepel,          # rótulos inteligentes\n     plotly,           # gráficos interativos\n     gganimate,        # gráficos animados\n\n     \n     # gis\n     ######\n     sf,               # manusear dados espaciais usado o formato Simple Feature \n     tmap,             # produzir mapas simples, funciona tanto com mapas estáticos ou interativos\n     OpenStreetMap,    # adicionar base OSM num mapa ggplot\n     spdep,            # estatística espacial\n     \n     # relatórios de rotina\n     #################\n     rmarkdown,        # produz arquivos em  PDFs, Word, Powerpoint e HTML \n     reportfactory,    # auto-organização de outputs de R Markdown\n     officer,          # powerpoint\n     \n     # dashboards\n     ############\n     flexdashboard,    # converte um script R Markdown em um dashboard\n     shiny,            # web apps interativo\n     \n     # tabelas para apresentação\n     #########################\n     knitr,            # Geração de relatório R Markdown e tabelas html \n     flextable,        # Tabelas HTML \n     #DT,              # Tabelas HTML  (alternativa)\n     #gt,              # Tabelas HTML  (alternativa)\n     #huxtable,        # Tabelas HTML  (alternativa)\n     \n     # phylogenetics\n     ###############\n     ggtree,           # visualização e de árvores filogenéticas \n     ape,              # análise e de filogenenia e evolução\n     treeio            # visualizar arquivos de filogenia\n \n)",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pacotes sugeridos</span>"
    ]
  },
  {
    "objectID": "new_pages/packages_suggested.pt.html#pacotes-do-github",
    "href": "new_pages/packages_suggested.pt.html#pacotes-do-github",
    "title": "5  Pacotes sugeridos",
    "section": "5.2 Pacotes do Github",
    "text": "5.2 Pacotes do Github\nAbaixo estão os comandos para instalar dois pacotes diretamente dos repositórios Github.\nA versão de desenvolvimento de epicontacts contém a capacidade de fazer árvores de transmissão com um eixo x temporal\nO pacote epirhandbook contém todos os dados de exemplo para este manual e pode ser usado para baixar a versão offline do manual.\n\n# Pacotes para baixar do github (não estão disponíveis no CRAN)\n##########################################################\n\n# Versão de desenvolvimento de epicontacts (para cadeias de transmissão com tempo no  eixo x)\npacman::p_install_gh(\"reconhub/epicontacts@timeline\")\n\n# O pacote para este manual, que inclui todos os dados usados nos exemplos \npacman::p_install_gh(\"appliedepi/epirhandbook\")",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Pacotes sugeridos</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.pt.html",
    "href": "new_pages/r_projects.pt.html",
    "title": "6  R projects",
    "section": "",
    "text": "6.1 Uso sugerido\nUma maneira comum, eficiente e sem problemas de usar R é combinar esses 3 elementos. Um projeto de trabalho discreto é hospedado em um R project. Cada elemento é descrito nas seções abaixo.",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>R projects</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.pt.html#uso-sugerido",
    "href": "new_pages/r_projects.pt.html#uso-sugerido",
    "title": "6  R projects",
    "section": "",
    "text": "Um projeto R\n\nUm ambiente de trabalho independente com pastas para dados, scripts, saídas, etc.\n\n\nO pacote here para caminhos de arquivo relativos\n\nOs caminhos de arquivo são gravados em relação à pasta raiz do R project - consulte Importar e exportar para obter mais informações\n\n\nO pacote rio para importação / exportação\n\nimport() e export() manipulam qualquer tipo de arquivo por sua extensão (por exemplo, .csv, .xlsx, .png)",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>R projects</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.pt.html#criação-de-um-r-project",
    "href": "new_pages/r_projects.pt.html#criação-de-um-r-project",
    "title": "6  R projects",
    "section": "6.2 Criação de um R project",
    "text": "6.2 Criação de um R project\nPara criar um R project, selecione “Novo Projeto” no menu Arquivo.\n\nSe deseja criar uma nova pasta para o projeto, selecione “Novo diretório” e indique onde deseja que seja criado.\n\nSe deseja criar o projeto dentro de uma pasta existente, clique em “Diretório existente” e indique a pasta.\n\nSe você deseja clonar um repositório Github, selecione a terceira opção “Controle de Versão” e depois “Git”. Veja a página em Controle de versão e colaboração com Git e Github para mais detalhes.\n\n\n\n\n\n\n\n\n\n\nO R project que você criar virá na forma de uma pasta contendo um arquivo .Rproj. Este arquivo é um atalho e provavelmente a principal maneira de abrir seu projeto. Você também pode abrir um projeto selecionando “Abrir Projeto” no menu Arquivo. Alternativamente, no canto superior direito do RStudio, você verá um ícone de R project e um menu suspenso de R projects disponíveis.\nPara sair de um R project, abra um novo projeto ou feche o projeto (Arquivo - Fechar Projeto).\n\nAlternar projetos\nPara alternar entre os projetos, clique no ícone do R project e no menu suspenso no canto superior direito do RStudio. Você verá opções para Fechar projeto, Abrir projeto e uma lista de projetos recentes.\n\n\n\n\n\n\n\n\n\n\n\nConfigurações\nEm geral, é aconselhável iniciar o RStudio a cada vez com uma “lousa em branco” - ou seja, com sua área de trabalho não preservada da sessão anterior. Isso significa que seus objetos e resultados não persistirão de sessão para sessão (você deve recriá-los executando seus scripts). Isso é bom, porque o forçará a escrever scripts melhores e evitará erros no longo prazo.\nPara configurar o RStudio para ter uma “lista limpa” a cada vez na inicialização:\n\nSelecione “Opções de projeto” no menu Ferramentas.\n\nNa guia “Geral”, defina o RStudio para não restaurar .RData na área de trabalho na inicialização e para não salvar a área de trabalho em .RData ao sair.\n\n\n\nOrganização\nÉ comum ter subpastas em seu projeto. Considere ter pastas como “dados”, “scripts”, “figuras”, “apresentações”. Você pode adicionar pastas da maneira típica que faria com uma nova pasta para o seu computador. Como alternativa, consulte a página em Interações de diretório para saber como criar novas pastas com comandos R.\n\n\nControle de versão\nConsidere um sistema de controle de versão. Pode ser algo tão simples como ter datas nos nomes dos scripts (por exemplo, “transmission_analysis_2020-10-03.R”) e uma pasta de “arquivo”. Considere também ter um texto de cabeçalho comentado na parte superior de cada script com uma descrição, tags, autores e log de alterações.\nUm método mais complicado envolveria o uso do Github ou uma plataforma semelhante para controle de versão. Veja a página em Controle de versão e colaboração com Git e Github.\nUma dica é que você pode pesquisar um projeto ou pasta inteira usando a ferramenta “Localizar nos arquivos” (menu Editar). Ele pode pesquisar e até mesmo substituir strings em vários arquivos.",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>R projects</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.pt.html#exemplos",
    "href": "new_pages/r_projects.pt.html#exemplos",
    "title": "6  R projects",
    "section": "6.3 Exemplos",
    "text": "6.3 Exemplos\nAbaixo estão alguns exemplos de importação / exportação / salvamento usando here() de dentro de um R project. Leia mais sobre como usar o pacote here na página Importar e exportar.\nImportando linelist_raw.xlsx da pasta” data “em seu R project\n\nlinelist &lt;- import(here(\"data\", \"linelist_raw.xlsx\"))\n\nExportando o objeto R linelist como” my_linelist.rds “para a pasta” clean “dentro da pasta” data “em seu R project.\n\nexport(linelist, here(\"data\",\"clean\", \"my_linelist.rds\"))\n\nSalvar o gráfico impresso mais recentemente como “epicurve_2021-02-15.png” dentro da pasta “epicurves” na pasta “saídas” em seu R project.\n\nggsave(here(\"outputs\", \"epicurves\", \"epicurve_2021-02-15.png\"))",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>R projects</span>"
    ]
  },
  {
    "objectID": "new_pages/r_projects.pt.html#recursos",
    "href": "new_pages/r_projects.pt.html#recursos",
    "title": "6  R projects",
    "section": "6.4 Recursos",
    "text": "6.4 Recursos\nPágina da web do RStudio em usando R projects",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>R projects</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.pt.html",
    "href": "new_pages/importing.pt.html",
    "title": "7  Importar e exportar",
    "section": "",
    "text": "7.1 Visão geral\nQuando você importa um “conjunto de dados” para o R, você geralmente está criando um novo objeto do tipo data frame em seu ambiente R e definindo-o como um arquivo importado (por exemplo, Excel, CSV, TSV, RDS) que está localizado em suas pastas em um determinado caminho/endereço de arquivo.\nVocê pode importar/exportar muitos tipos de arquivos, inclusive aqueles criados por outros programas estatísticos (SAS, STATA, SPSS). Você também pode se conectar a bancos de dados relacionais.\nR tem até seus próprios formatos de dados:",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Importar e exportar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.pt.html#visão-geral",
    "href": "new_pages/importing.pt.html#visão-geral",
    "title": "7  Importar e exportar",
    "section": "",
    "text": "Um arquivo RDS (.rds) armazena um único objeto R, como um data frame. Estes são úteis para armazenar dados limpos, pois eles mantêm as classes de colunas R. Leia mais em esta seção.\n\nUm arquivo RData (.Rdata) pode ser usado para armazenar vários objetos, ou mesmo um espaço de trabalho R completo. Leia mais em esta seção.",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Importar e exportar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.pt.html#o-pacote-rio",
    "href": "new_pages/importing.pt.html#o-pacote-rio",
    "title": "7  Importar e exportar",
    "section": "7.2 O pacote rio",
    "text": "7.2 O pacote rio\nO pacote R que recomendamos é: rio. O nome “rio” é uma abreviação de “R I/O” (input/output ).\nSuas funções import() e export() podem lidar com muitos tipos diferentes de arquivos (por exemplo, .xlsx, .csv, .rds, .tsv). Quando você fornece um caminho de arquivo para qualquer uma destas funções (incluindo a extensão do arquivo como “.csv”), rio lerá a extensão e utilizará a ferramenta correta para importar ou exportar o arquivo.\nA alternativa ao uso do rio é usar funções de muitos outros pacotes, cada um dos quais é específico para um tipo de arquivo. Por exemplo, read.csv() (R base ), read.xlsx() (openxlsx pacote), e write_csv() (readr pacakge), etc. Estas alternativas podem ser difíceis de lembrar, enquanto que utilizar import() e export() de rio* é fácil.\nAs funções do rio import() e export() utilizam o pacote e função apropriados para um determinado arquivo, com base em sua extensão. Veja no final desta página uma tabela completa de quais pacotes/funções rio utilizam em segundo plano. Ele também pode ser utilizado para importar arquivos STATA, SAS e SPSS, entre dezenas de outros tipos de arquivos.\nA importação/exportação de shapefiles (para mapas) requer outros pacotes, conforme detalhado na página sobre GIS básico.",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Importar e exportar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.pt.html#here",
    "href": "new_pages/importing.pt.html#here",
    "title": "7  Importar e exportar",
    "section": "7.3 O pacote here",
    "text": "7.3 O pacote here\nO pacote here e sua função here() tornam fácil dizer a R onde encontrar e salvar seus arquivos - em essência, ele constrói os caminhos dos arquivos.\nUtilizado em conjunto com um projeto R, here permite descrever a localização dos arquivos em seu projeto R em relação ao diretório root do projeto R (a pasta de nível superior). Isto é útil quando o projeto R pode ser compartilhado ou acessado por várias pessoas/computadores. Ele evita complicações devido aos caminhos exclusivos dos arquivos em diferentes computadores (por exemplo, `“C:/Users/Laura/Documents…’’,”iniciando” o caminho do arquivo em um lugar comum a todos os usuários (a raiz do projeto R).\nÉ assim como here() funciona dentro de um projeto R:\n\nQuando o pacote here é carregado pela primeira vez dentro do projeto R, ele coloca um pequeno arquivo chamado “.here” na pasta raiz de seu projeto R como um “benchmark” ou “âncora”.\n\nEm seus scripts, para referenciar um arquivo nas subpastas do projeto R, você utiliza a função here() para construir o caminho do arquivo em relação a essa âncora.\nPara construir o caminho do arquivo, escreva os nomes das pastas além da raiz, entre aspas, separados por vírgulas, finalmente terminando com o nome do arquivo e a extensão do arquivo, como mostrado abaixo\n\nCaminhos de arquivos com a função ’here()` podem ser utilizados tanto para importação quanto para exportação\n\nPor exemplo, abaixo, a função import() está sendo fornecida um caminho de arquivo construído com here().\n\nlinelist &lt;- import(here(\"data\", \"linelists\", \"ebola_linelist.xlsx\"))\n\nO comando here(\"data\", \"linelists\", \"ebola_linelist.xlsx\") está na verdade fornecendo o caminho completo do arquivo que é único para o computador do usuário:\n\"C:/Users/Laura/Documents/my_R_project/data/linelists/ebola_linelist.xlsx\"\nA beleza é que o comando R utilizando here() pode ser executado com sucesso em qualquer computador que acesse o projeto R.\nDICA: Se você não tiver certeza de onde a raiz “.here” está definida, execute a função here() com parênteses vazios.\nLeia mais sobre o pacote here neste link.",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Importar e exportar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.pt.html#caminhos-dos-arquivos",
    "href": "new_pages/importing.pt.html#caminhos-dos-arquivos",
    "title": "7  Importar e exportar",
    "section": "7.4 Caminhos dos arquivos",
    "text": "7.4 Caminhos dos arquivos\nAo importar ou exportar dados, você deve fornecer um caminho para o arquivo. Você pode fazer isso de três maneiras:\n\nRecomendado: fornecer um caminho de arquivo “relativo” com o pacote here\nFornecer o caminho “completo” / “absoluto” do arquivo\n\nSeleção manual do arquivo\n\n\nCaminhos ‘relativo’ dos arquivos\nNo R, os caminhos de arquivo “relativos” consistem no caminho de arquivo relativo à raiz de um projeto R. Eles permitem caminhos de arquivo mais simples que podem funcionar em computadores diferentes (por exemplo, se o projeto R estiver em um drive compartilhado ou for enviado por e-mail). Como descrito acima, os caminhos de arquivo relativos são facilitados pelo uso do pacote here.\nUm exemplo de um caminho de arquivo relativo construído com here() está abaixo. Supomos que o trabalho esteja em um projeto R que contém uma subpasta “dados” e dentro dela uma subpasta “linelists”, na qual há o arquivo .xlsx de interesse.\n\nlinelist &lt;- import(here(\"dados\", \"linelists\", \"ebola_linelist.xlsx\"))\n\n\n\nCaminhos ‘absoluto’ dos arquivos\nCaminhos de arquivo absolutos ou “completos” podem ser fornecidos para funções como import() mas são “frágeis”, pois são exclusivos para o computador específico do usuário e portanto não são recomendados.\nAbaixo está um exemplo de um caminho de arquivo absoluto, onde no computador de Laura há uma pasta “analises”, uma subpasta “dados” e dentro dela uma subpasta “linelists”, na qual há o arquivo .xlsx de interesse.\n\nlinelist &lt;- import(\"C:/Users/Laura/Documents/analises/dados/linelists/ebola_linelist.xlsx\")\n\nAlgumas coisas a serem observadas sobre os caminhos absolutos dos arquivos:\n\nEvite o uso de caminhos de arquivo absolutos, pois eles quebrarão se o script for executado em um computador diferente.\nUtilize barras normais (/), como no exemplo acima (nota: este é NÃO o padrão para caminhos de arquivos do Windows)\n\nOs caminhos de arquivos que começam com barras duplas (por exemplo, “//…”) provavelmente não serão reconhecidos por R e produzirão um erro. Considere mover seu trabalho para uma unidade “nomeado” ou ” com letras” que comece com uma letra (por exemplo, “J:” ou “C:”). Consulte a página em Interações do diretório para obter mais detalhes sobre este assunto.\n\nUm cenário onde caminhos de arquivo absolutos podem ser apropriados é quando você deseja importar um arquivo de um drive compartilhado que tenha o mesmo caminho de arquivo completo para todos os usuários.\nDICA: Para converter rapidemente todas as barras invertidas \\ em barras normais /, destaque o código de interesse, use Ctrl+f (no Windows), selecione a caixa de opção “Em seleção” (In selection), e depois usar a funcionalidade de substituição para convertê-los.\n\n\n\nSelecionando um arquivo manualmente\nVocê pode importar dados manualmente por meio de um destes métodos:\n\nPainel Ambiente (Environment) do RStudio, clique em “Importar Dados” (Import Dataset), e selecione o tipo de dado\nClique em File / Import Dataset / (selecione o tipo de dados)\n\nPara seleção manual por código, utilize o comando do R base file.choose() (deixando os parênteses vazios) para acionar a aparência de uma janela pop-up que permite ao usuário selecionar manualmente o arquivo de seu computador. Por exemplo:\n\n\n# Seleção manual de um arquivo. Quando este comando for executado, uma janela POP-UP aparecerá. \n# O caminho do arquivo selecionado será fornecido ao comando import().\n\nmy_data &lt;- import(file.choose())\n\nDICA: A janela pop-up window pode aparecer ATRÁS di seu RStudio.",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Importar e exportar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.pt.html#importar-dados",
    "href": "new_pages/importing.pt.html#importar-dados",
    "title": "7  Importar e exportar",
    "section": "7.5 Importar dados",
    "text": "7.5 Importar dados\nUtilizar import() para importar um conjunto de dados é bastante simples. Basta fornecer o caminho para o arquivo (incluindo o nome do arquivo e a extensão do arquivo) entre aspas. Se utilizar here() para construir o caminho do arquivo, siga as instruções acima. Abaixo estão alguns exemplos:\nImportar um arquivo csv que está localizado em seu “diretório de trabalho” ou na pasta raiz do projeto R:\n\nlinelist &lt;- import(\"linelist_cleaned.csv\")\n\nImportação da primeira planilha de uma pasta de trabalho do Excel que está localizada nas subpastas “dados” e “linelists” do projeto R (o caminho do arquivo construído utilizando here()):\n\nlinelist &lt;- import(here(\"dados\", \"linelists\", \"linelist_cleaned.xlsx\"))\n\nImportação de um “quadro de dados” ( referido nesse livro como data frame)(um arquivo .rds) usando um caminho de arquivo absoluto:\n\nlinelist &lt;- import(\"C:/Users/Laura/Documents/tuberculosis/data/linelists/linelist_cleaned.rds\")\n\n\nPlanilhas específicas do Excel\nPor padrão, se você fornecer uma pasta de trabalho Excel (.xlsx) para a função import(), a primeira planilha da pasta de trabalho será importada. Se você quiser importar uma aba (sheet) específica, inclua o nome da planilha ao which = argument. Por exemplo:\n\nmy_data &lt;- import(\"my_excel_file.xlsx\", which = \"Sheetname\")\n\nSe utilizar o método here() para fornecer um caminho relativo para import(), você ainda pode indicar uma aba específica adicionando o which = argumento depois dos parênteses de fechamento da função here().\n\n# Demonstração: importação de uma planilha específica do Excel ao utilizar caminhos relativos com o pacote 'here'.  \n\nlinelist_raw &lt;- import(here(\"data\", \"linelist.xlsx\"), which = \"Sheet1\")`  \n\nPara exportar um data frame do R para uma planilha específica do Excel e ter o resto da pasta de trabalho do Excel inalterado, você terá que importar, editar e exportar com um pacote alternativo criado para este propósito, como openxlsx*. Veja mais informações na página em Interações do diretório ou nesta página do github.\nSe sua pasta de trabalho Excel for .xlsb (pasta de trabalho Excel em formato binário) você talvez não consiga importá-la usando rio. Considere a possibilidade de salvá-la como .xlsx, ou usando um pacote como readxlsb* que é construído para este propósito.\n\n\n\nValores faltantes\nVocê pode querer designar que valor(es) em seu conjunto de dados que deve(m) ser considerado(s) como ausente(s)/faltante(s). Como explicado na página em Dados faltantes, o valor em R para dados ausentes é NA, mas talvez o conjunto de dados que você deseja importar utilize 99, “Ausente”, ou apenas espaço vazio de caracteres “” em vez disso.\nUtilize o na = argumento para import() e forneça o(s) valor(es) entre aspas (mesmo que sejam números). Você pode especificar múltiplos valores incluindo-os dentro de um vetor, utilizando c() como mostrado abaixo.\nAqui, o valor “99” no conjunto de dados importados é considerado ausente e convertido para NA em R.\n\nlinelist &lt;- import(here(\"data\", \"my_linelist.xlsx\"), na = \"99\")\n\nQualquer um dos valores “Missing”, “” (célula vazia), ou “” (espaço único) no conjunto de dados importados são convertidos para NA no R.\n\nlinelist &lt;- import(here(\"data\", \"my_linelist.csv\"), na = c(\"Missing\", \"\", \" \"))\n\n\n\n\nPular linhas\nÀs vezes, você pode querer evitar a importação de uma linha específica de dados. Você pode fazer isso com o argumento skip = se utilizar import() de rio em um arquivo .xlsx ou .csv. Forneça o número de linhas que você deseja pular.\n\nlinelist_raw &lt;- import(\"linelist_raw.xlsx\", skip = 1)  # Não importa a linha de cabeçalho\n\nInfelizmente ’skip = ’aceita apenas um valor inteiro, não um intervalo (por exemplo, “2:10” não funciona). Para pular a importação de linhas específicas que não são consecutivas do topo, considere importar várias vezes e utilizar bind_rows() a partir de dplyr*. Veja o exemplo abaixo de pular apenas a linha 2.\n\n\nComo lidar com uma segunda linha de cabeçalho\nÀs vezes, seus dados podem ter uma segunda linha de cabeçalho, por exemplo, se for uma linha de “dicionário de dados”, como mostrado abaixo. Esta situação pode ser problemática porque pode resultar na importação de todas as colunas como a classe “caractere”.\nAbaixo está um exemplo deste tipo de conjunto de dados (sendo a primeira linha o dicionário de dados).\n\n\n\n\n\n\n\nRemover uma segunda linha de cabeçalho\nPara ignorar a segunda linha de cabeçalho, você provavelmente precisará importar os dados duas vezes.\n\nImportar os dados para armazenar os nomes corretos das colunas\n\nImportar os dados novamente, pulando as primeiras duas fileiras (cabeçalho e segunda fileira)\n\nLigar os nomes corretos no campo de dados reduzido\n\nO argumento exato usado para ligar os nomes corretos das colunas depende do tipo de arquivo de dados (.csv, .tsv, .xlsx, etc.). Isto porque rio está usando uma função diferente para os diferentes tipos de arquivo (ver tabela acima).\nPara arquivos Excel: (col_names =)\n\n# importe a primeira vez; salve o nome das colunas\nlinelist_raw_names &lt;- import(\"linelist_raw.xlsx\") %&gt;% names()  # Salva o nome veradeiro das colunas\n\n# Importe uma segunda vez; pule a segunda linha e designe os nomes das colunas para o argumento col_names =\nlinelist_raw &lt;- import(\"linelist_raw.xlsx\",\n                       skip = 2,\n                       col_names = linelist_raw_names\n                       ) \n\nPara arquivos CSV: (col.names =)\n\n# importe a primeira vez; salve o nome das colunas\nlinelist_raw_names &lt;- import(\"linelist_raw.csv\") %&gt;% names() # salve o nome verdadeiro das colunas\n\n# note que o argumento para arquivos csv é 'col.names = '\nlinelist_raw &lt;- import(\"linelist_raw.csv\",\n                       skip = 2,\n                       col.names = linelist_raw_names\n                       ) \n\nOpção de Backup  - atribuir/sobreescrever cabeçalhos usando a função ‘colnames()’ do base\n\n# assign/overwrite headers using the base 'colnames()' function\ncolnames(linelist_raw) &lt;- linelist_raw_names\n\n\n\nFazendo um dicionário de dados\nBônus! Se você tiver uma segunda linha que seja um dicionário de dados, você pode facilmente criar um dicionário de dados adequado a partir dele. Esta dica é adaptada a partir deste post.\n\ndict &lt;- linelist_2headers %&gt;%             # começa: linelist com um dicionário como a primeira linha\n  head(1) %&gt;%                             # mantenha apenas os nomes das colunas e a primeira linha com o dicionário               \n  pivot_longer(cols = everything(),       # faça o pivotamento de todas as coluna spara o formato \"longo\" \n               names_to = \"Column\",       # nomeie as colunas\n               values_to = \"Description\")\n\n\n\n\n\n\n\n\n\nCombinar duas linhas de cabeçalho\nEm alguns casos, quando seu conjunto de dados brutos tiver duas linhas de cabeçalho (ou mais especificamente, a segunda linha de dados é um cabeçalho secundário), você pode querer “combiná-las” ou adicionar os valores da segunda linha de cabeçalho à primeira linha de cabeçalho.\nO comando abaixo definirá os nomes das colunas do data frame como a combinação (colando em conjunto) dos primeiros cabeçalhos (verdadeiros) com o valor imediatamente abaixo (na primeira linha).\n\nnames(my_data) &lt;- paste(names(my_data), my_data[1, ], sep = \"_\")\n\n\n\n\n\nPlanilhas do Google\nVocê pode importar dados de uma planilha on-line do Google com o pacote googlesheet4 e autenticando seu acesso à planilha.\n\npacman::p_load(\"googlesheets4\")\n\nAbaixo, uma planilha de demonstração do Google é importada e salva. Este comando pode solicitar a confirmação da autenticação de sua conta Google. Siga as instruções e pop-ups em seu navegador de internet para conceder permissões aos pacotes Tidyverse API para editar, criar e excluir suas planilhas no Google Drive.\nA planilha abaixo é “visualizável para qualquer pessoa com o link” e você pode tentar importá-la.\n\nGsheets_demo &lt;- read_sheet(\"https://docs.google.com/spreadsheets/d/1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY/edit#gid=0\")\n\nA planilha também pode ser importada usando apenas a identificação da planilha, uma parte mais curta da URL:\n\nGsheets_demo &lt;- read_sheet(\"1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY\")\n\nOutro pacote, googledrive oferece funções úteis para escrever, editar e excluir planilhas do Google. Por exemplo, utilizando as funções gs4_create() e sheet_write() encontradas neste pacote.\nAqui estão alguns outros tutoriais on-line úteis:\ntutorial básico de importação de planilhas do Google\ntutorial mais detalhado\ninteração entre as googlesheets4 e tidyverse",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Importar e exportar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.pt.html#múltiplos-arquivos--importar-exportar-dividir-combinar",
    "href": "new_pages/importing.pt.html#múltiplos-arquivos--importar-exportar-dividir-combinar",
    "title": "7  Importar e exportar",
    "section": "7.6 Múltiplos arquivos- importar, exportar, dividir, combinar",
    "text": "7.6 Múltiplos arquivos- importar, exportar, dividir, combinar\nVeja a página em Iteração, loops e listas para exemplos de como importar e combinar vários arquivos, ou vários arquivos de pastas de trabalho Excel. Essa página também tem exemplos de como dividir um data frame em partes e exportar cada uma separadamente, ou como planilhas nomeadas em uma pasta de trabalho do Excel.",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Importar e exportar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.pt.html#import_github",
    "href": "new_pages/importing.pt.html#import_github",
    "title": "7  Importar e exportar",
    "section": "7.7 Importar do GitHub",
    "text": "7.7 Importar do GitHub\nA importação de dados diretamente do Github para R pode ser muito fácil ou pode exigir alguns passos - dependendo do tipo de arquivo. Abaixo estão algumas abordagens:\n\nArquivos CSV\nPode ser fácil importar um arquivo .csv diretamente do Github para R com um comando R.\n\nVá até o repositório Github, localize o arquivo de interesse e clique sobre ele\n\nClique no botão “Raw” (você verá então os dados “brutos” do csv, como mostrado abaixo)\n\nCopiar a URL (endereço web)\n\nColocar a URL entre aspas dentro do comando import() no R\n\n\n\n\n\n\n\n\n\n\n\n\nArquivo XLSX\nTalvez você não consiga visualizar os dados “Raw” de alguns arquivos (por exemplo, .xlsx, .rds, .nwk, .shp)\n\nVá até o repositório Github, localize o arquivo de interesse e clique sobre ele\n\nClique no botão “Download”, como mostrado abaixo\n\nSalve o arquivo em seu computador, e importe-o para o R\n\n\n\n\n\n\n\n\n\n\n\n\nShapefiles\nOs shapefiles têm muitos sub-componentes, cada um com uma extensão de arquivo diferente. Um arquivo terá a extensão “.shp”, mas outros podem ter “.dbf”, “.prj”, etc. Para baixar um shapefile do Github, você precisará baixar cada um dos arquivos de subcomponentes individualmente, e salvá-los na mesma pasta em seu computador. No Github, clique em cada arquivo individualmente e faça o download deles clicando no botão “Download”.\nUma vez salvo em seu computador, você pode importar o shapefile como mostrado na página GIS básico utilizando st_read() do pacote sf. Você só precisa fornecer o caminho do arquivo e o nome do arquivo “.shp” - desde que os outros arquivos relacionados estejam dentro da mesma pasta em seu computador.\nAbaixo, você pode ver como o shapefile “sle_adm3” consiste de muitos arquivos - cada um dos quais deve ser baixado do Github.",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Importar e exportar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.pt.html#inserir-dados-munualmente",
    "href": "new_pages/importing.pt.html#inserir-dados-munualmente",
    "title": "7  Importar e exportar",
    "section": "7.8 Inserir dados munualmente",
    "text": "7.8 Inserir dados munualmente\n\nInserção por linhas\nUtilize a função tribble do pacote tibble do tidyverse (referência online tibble).\nObserve como os cabeçalhos das colunas começam com um til (~). Observe também que cada coluna deve conter apenas uma classe de dados (caractere, numérico, etc.). Você pode utilizar abas, espaçamento e novas linhas para tornar a entrada de dados mais intuitiva e legível. Os espaços não importam entre os valores, mas cada linha é representada por uma nova linha de código. Por exemplo:\n\n# Crie um conjunto de dados manualmente por linha\nmanual_entry_rows &lt;- tibble::tribble(\n  ~colA, ~colB,\n  \"a\",   1,\n  \"b\",   2,\n  \"c\",   3\n  )\n\nA agora nós exibimos o novo data frame::\n\n\n\n\n\n\n\n\nInserção por colunas\nComo um data frame consiste em vetores (colunas verticais), a abordagem base para a criação manual de data frames no R espera que você defina cada coluna e depois as vincule juntas. Isto pode ser contra-intuitivo em epidemiologia, pois geralmente pensamos em nossos dados em linhas (como acima).\n\n# definir cada vetor (coluna vertical) separadamente, cada um com seu próprio nome\nPatientID &lt;- c(235, 452, 778, 111)\nTreatment &lt;- c(\"Yes\", \"No\", \"Yes\", \"Yes\")\nDeath     &lt;- c(1, 0, 1, 0)\n\nCUIDADO: Todos os vetores devem ter o mesmo comprimento (mesmo número de valores).\nThe vectors can then be bound together using the function data.frame():\n\n# combine as colunas em um *data frame*, referenciando os nomes dos vetores\nmanual_entry_cols &lt;- data.frame(PatientID, Treatment, Death)\n\nE agora vamos vizualizar o novo conjunto de dados:\n\n\n\n\n\n\n\n\nColando a partir da área de transferência\nSe você copiar dados de outro lugar e os tem na “área de transferência” (clipboard), você pode tentar uma das duas maneiras abaixo:\nDo pacote clipr*, você pode utilizar read_clip_tbl() para importar como um data frame, ou apenas read_clip() para importar como um vetor de caracteres. Em ambos os casos, deixe os parênteses vazios.\n\nlinelist &lt;- clipr::read_clip_tbl()  # importa a área de transferência atual como uma data frame\nlinelist &lt;- clipr::read_clip()      # importa como um vetor de caracteres\n\nVocê também pode exportar facilmente para a área de transferência do seu sistema com clipr*. Veja a seção abaixo sobre Exportação.\nAlternativamente, você pode utilizar a função read.table() do R base com file = \"clipboard\") para importar como um data frame:\n\ndf_from_clipboard &lt;- read.table(\n  file = \"clipboard\",  # specify this as \"clipboard\"\n  sep = \"t\",           # separator could be tab, or commas, etc.\n  header=TRUE)         # if there is a header row",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Importar e exportar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.pt.html#importar-o-arquivo-mais-recente",
    "href": "new_pages/importing.pt.html#importar-o-arquivo-mais-recente",
    "title": "7  Importar e exportar",
    "section": "7.9 Importar o arquivo mais recente",
    "text": "7.9 Importar o arquivo mais recente\nMuitas vezes você pode receber atualizações diárias de seus conjuntos de dados. Neste caso, você vai querer escrever o código que importa o arquivo mais recente. A seguir, apresentamos duas formas de abordar este assunto:\n\nSelecionando o arquivo com base na data no nome do arquivo\n\nSeleção do arquivo com base nos metadados do arquivo (última modificação)\n\n\nDatas no nome de um arquivo\nEsta abordagem depende de três premissas:\n\nVocê confia nas datas nos nomes dos arquivos\n\nAs datas são numéricas e aparecem em geralmente no mesmo formato (por exemplo, ano, mês e dia)\n\nNão há outros números no nome do arquivo\n\nExplicaremos cada passo e, no final, mostraremos a combinação deles.\nPrimeiro, utilize dir() do R base para extrair apenas os nomes dos arquivos para cada arquivo na pasta de interesse. Consulte a página em Interações de diretório para obter mais detalhes sobre dir(). Neste exemplo, a pasta de interesse é a pasta “linelists” dentro da pasta “exemplo” dentro de “data” dentro do projeto R.\n\nlinelist_filenames &lt;- dir(here(\"data\", \"example\", \"linelists\")) # pega o nome dos arquivos da pasta\nlinelist_filenames                                              # exibe \n\n[1] \"20201007linelist.csv\"          \"case_linelist_2020-10-02.csv\" \n[3] \"case_linelist_2020-10-03.csv\"  \"case_linelist_2020-10-04.csv\" \n[5] \"case_linelist_2020-10-05.csv\"  \"case_linelist_2020-10-08.xlsx\"\n[7] \"case_linelist20201006.csv\"    \n\n\nUma vez que você tenha este vetor de nomes, você pode extrair as datas a partir deles aplicando str_extract() de stringr utilizando esta expressão regular. Ela extrai quaisquer números no nome do arquivo (incluindo quaisquer outros caracteres no meio, tais como traços ou cortes). Você pode ler mais sobre stringr* na página Strings e caracteres.\n\nlinelist_dates_raw &lt;- stringr::str_extract(linelist_filenames, \"[0-9].*[0-9]\") # extrai números e quaisquer caracteres no meio\nlinelist_dates_raw  # print\n\n[1] \"20201007\"   \"2020-10-02\" \"2020-10-03\" \"2020-10-04\" \"2020-10-05\"\n[6] \"2020-10-08\" \"20201006\"  \n\n\nAssumindo que as datas são escritas geralmente no mesmo formato (por exemplo, Ano e depois Mês e depois Dia) e os anos têm 4 dígitos, você pode utilizar lubridate’s funções flexíveis de conversão (ymd(), dmy(), ou mdy()) para convertê-las em datas. Para estas funções, os traços, espaços ou cortes não importam, apenas a ordem dos números. Leia mais na página Trabalhando com datas.\n\nlinelist_dates_clean &lt;- lubridate::ymd(linelist_dates_raw)\nlinelist_dates_clean\n\n[1] \"2020-10-07\" \"2020-10-02\" \"2020-10-03\" \"2020-10-04\" \"2020-10-05\"\n[6] \"2020-10-08\" \"2020-10-06\"\n\n\nA função do R base which.max() pode então ser utilizada para retornar a posição do índice (por exemplo, 1º, 2º, 3º, …) do valor máximo da data. O último arquivo é corretamente identificado como o 6º arquivo - “case_linelist_2020-10-08.xlsx”.\n\nindex_latest_file &lt;- which.max(linelist_dates_clean)\nindex_latest_file\n\n[1] 6\n\n\nSe nós condensarmos todos esses comandos, o cógico compelto deve parecer com o abaixo. Observe que o . na ultima linha é um marcador para o objeto pipe naquele ponta da sequência de pipes. Naquele ponto o valor é implesmente o número 6. Isso é colocado entre cochetes para extrair o sexto elemnto do vetor de nomes do arquivo produzido por dir().\n\n# carrega os pacotes\npacman::p_load(\ntidyverse,           # manipulação  de dados\n  stringr,           # trabalha com strings/caravteres\n  lubridate,         # trabalha com datas\n  rio,               # importar / exportar\n  here,              # caminhos relativos dos arquivos\n  fs)                # interações entre diretórios\n\n# extrai o nome do arquivo mais recente\nlatest_file &lt;- dir(here(\"data\", \"example\", \"linelists\")) %&gt;%  # nomes dos aequivos da subpasta \"linelists\"         \n  str_extract(\"[0-9].*[0-9]\") %&gt;%                  # extrai as datas (números)\n  ymd() %&gt;%                                        # converte números pra datas (assumindo o formato ano-mês-dia)\n  which.max() %&gt;%                                  # pega o índice da maior data (arquivo mais recente) \n  dir(here(\"data\", \"example\", \"linelists\"))[[.]]              # retorna o nome do arquivo da linelist mais recente\n\nlatest_file  # mostra o nome do arquivo do artigo mais recente\n\n[1] \"case_linelist_2020-10-08.xlsx\"\n\n\nVocê pode agora usar esse nome para finalizar o caminho relativo do arquivo, com here():\n\nhere(\"dados\", \"example\", \"linelists\", latest_file) \n\nE agora você pode importar o arquivo mais recente:\n\n# importar\nimport(here(\"dados\", \"example\", \"linelists\", latest_file)) # import \n\n\n\nUse as informações do arquivo\nSe seus arquivos não tiverem datas em seus nomes (ou se você não confiar nessas datas), você pode tentar extrair a data da última modificação dos metadados do arquivo. Use funções do pacote fs para examinar as informações dos metadados de cada arquivo, que incluem o tempo da última modificação e o caminho do arquivo.\nAbaixo, fornecemos a pasta de interesse para fs’s dir_info(). Neste caso, a pasta de interesse está no projeto R na pasta “dados”, na subpasta “exemplo” e em sua subpasta “linelists”. O resultado é um data frame com uma linha por arquivo e colunas para modification_time',path’, etc. Você pode ver um exemplo visual disto na página em interações de diretório.\nPodemos ordenar este data frame de arquivos pela coluna modification_time, e então manter apenas a linha superior/última linha (arquivo) com a função do R base* head(). Então podemos extrair o caminho do arquivo deste último arquivo somente com a função dplyr* pull() na coluna path. Finalmente, podemos passar este caminho de arquivo para import(). O arquivo importado é salvo como latest_file.\n\nlatest_file &lt;- dir_info(here(\"dados\", \"examplo\", \"linelists\")) %&gt;%  # coleta dados sobre todos os arquivos no diretório\n  arrange(desc(modification_time)) %&gt;%      # classifica por data da última modificação\n  head(1) %&gt;%                               # mantém apenas o arquivo modificado por último\n  pull(path) %&gt;%                            # extrai apenas o endereço do arquivo\n  import()                                  # importa o arquivo",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Importar e exportar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.pt.html#import_api",
    "href": "new_pages/importing.pt.html#import_api",
    "title": "7  Importar e exportar",
    "section": "7.10 APIs",
    "text": "7.10 APIs\nUma “Interface de Programação Automatizada” (API) pode ser usada para solicitar dados diretamente de um website. As APIs são um conjunto de regras que permitem que uma aplicação de software interaja com outra. O cliente (você) envia uma “solicitação” e recebe uma “resposta” contendo o conteúdo. Os pacotes R httr e jsonlite* podem facilitar este processo.\nCada website habilitado para API terá sua própria documentação e especificações para se familiarizar. Alguns sites estão disponíveis publicamente e podem ser acessados por qualquer pessoa. Outros, tais como plataformas com IDs de usuário e credenciais, requerem autenticação para acessar seus dados.\nNão é preciso dizer que é necessário ter uma conexão com a Internet para importar dados via API. Daremos breves exemplos de uso de APIs para importar dados e conectá-lo a outros recursos.\nNote: lembre-se que os dados podem ser postados* em um website sem API, o que pode ser mais fácil de ser recuperado. Por exemplo, um arquivo CSV postado pode ser acessível simplesmente fornecendo a URL do site para import() como descrito na seção sobre importação de Github.*\n\nRequisição HTTP\nA troca de API é mais comumente feita através de uma solicitação HTTP. HTTP é o Protocolo de Transferência de Hipertexto, e é o formato subjacente de uma solicitação/resposta entre um cliente e um servidor. A entrada e saída exata pode variar dependendo do tipo de API, mas o processo é o mesmo - uma “Solicitação” (geralmente Solicitação HTTP) do usuário, muitas vezes contendo uma consulta, seguida por uma “Resposta”, contendo informações de status sobre a solicitação e possivelmente o conteúdo solicitado.\nAqui estão alguns componentes de uma solicitação HTTP:\n\nA URL do endpoint da API\n\nO “Método” (ou “Verbo”)\n\nCabeçalhos\n\nCorpo\n\nO “método” de solicitação HTTP é a ação que você deseja realizar. Os dois métodos HTTP mais comuns são GET e POST, mas outros poderiam incluir PUT, DELETE, PATCH, etc. Ao importar dados para R, é mais provável que você utilize GET.\nApós sua solicitação, seu computador receberá uma “resposta” em um formato similar ao que você enviou, incluindo URL, status HTTP (Status 200 é o que você quer!), tipo de arquivo, tamanho e o conteúdo desejado. Você precisará então analisar esta resposta e transformá-la em um data frame funcional dentro de seu ambiente R.\n\n\nPacotes\nO pacote httr funciona bem para lidar com solicitações HTTP em R. Ele requer pouco conhecimento prévio de APIs Web e pode ser usado por pessoas menos familiarizadas com a terminologia de desenvolvimento de software. Além disso, se a resposta HTTP for .json, você pode usar jsonlite para analisar a resposta.\n\n# carrega pacotes\npacman::p_load(httr, jsonlite, tidyverse)\n\n\n\nDados públicos\nAbaixo é um exemplo de uma solicitação de HTTP, originalmente de um tutorial do the Trafford Data Lab. Esse site têm vários outros recursos para aprender esse tema e exercícios sobre API.\nCenário: nós queremos importar uma lista de restaurantes fast food na cidade de Trafford, Reino Unido. Os dados podem ser acessados pela API da Food Standards Agency, que disponibiliza dados e classificações acerca de hiigiene alimentar no Reino Unido.\nOAqui estão os parâmetros para a nossa solicitação:\n\nHTTP verb: GET\n\nAPI endpoint URL: http://api.ratings.food.gov.uk/Establishments\n\nParâmetros selecionados: name, address, longitude, latitude, businessTypeId, ratingKey, localAuthorityId\n\nCabeçalho: “x-api-version”, 2\n\nFormato(s) dos dados: JSON, XML\n\nDocumentação: http://api.ratings.food.gov.uk/help\n\nO código no R seria como seguinte:\n\n# prepare a solicitação\npath &lt;- \"http://api.ratings.food.gov.uk/Establishments\"\nrequest &lt;- GET(url = path,\n             query = list(\n               localAuthorityId = 188,\n               BusinessTypeId = 7844,\n               pageNumber = 1,\n               pageSize = 5000),\n             add_headers(\"x-api-version\" = \"2\"))\n\n# cheque para algum erro no servidor (\"200\" é bom!)\nrequest$status_code\n\n# submita a solicitação, separe a resposta, e converta para um data frame  \n\nresponse &lt;- content(request, as = \"text\", encoding = \"UTF-8\") %&gt;%\n  fromJSON(flatten = TRUE) %&gt;%\n  pluck(\"establishments\") %&gt;%\n  as_tibble()\n\nAgora você pode limpar e utilizar o data frame resposta (response), que contém uma linha por estabelecimento de fast food.\n\n\nAutenticação necessária\nAlgumas APIs requerem autenticação - para que você possa provar quem você é, para que possa acessar dados restritos. Para importar estes dados, você pode precisar primeiro usar um método POST para fornecer um nome de usuário, senha, ou código. Isto retornará um token de acesso, que pode ser usado para solicitações posteriores do método GET para recuperar os dados desejados.\nAbaixo está um exemplo de consulta de dados do Go.Data, que é uma ferramenta de investigação de surtos. Go.Data usa uma API para todas as interações entre o front-end da web e os aplicativos smartphone usados para a coleta de dados. O Go.Data é usado em todo o mundo. Como os dados do surto são sensíveis e você só deve ser capaz de acessar os dados para seu surto, a autenticação é necessária.\nAbaixo estão alguns exemplos de código R usando httr e jsonlite para conexão com a API Go.Data para importar dados sobre o acompanhamento de contato de seu surto.\n\n# configure as credenciais para a autorização \nurl &lt;- \"https://godatasampleURL.int/\"           # instânica url Go.Data válida\nusername &lt;- \"username\"                          # nome de usuário do Go.Data válido\npassword &lt;- \"password\"                          # senha do Go.Data válida\noutbreak_id &lt;- \"xxxxxx-xxxx-xxxx-xxxx-xxxxxxx\"  # ID do surto do Go.Data outbreak válida\n\n# obtenha o token de acesso\nurl_request &lt;- paste0(url,\"api/oauth/token?access_token=123\") # defina a solicitação da url base \n\n# prepare a solicitação\nresponse &lt;- POST(\n  url = url_request,  \n  body = list(\n    username = username,    # use o nome de usuario e senha salvos acima para autorizar \n    password = password),                                       \n    encode = \"json\")\n\n# execute a rolicitação e separe a resposta \ncontent &lt;-\n  content(response, as = \"text\") %&gt;%\n  fromJSON(flatten = TRUE) %&gt;%          # flatten nested JSON\n  glimpse()\n\n# Salve o token de acesso da resposta \naccess_token &lt;- content$access_token    #  salve o token de acesso para permitir as chamadas subsequentes abaixo \n\n# importat os contatos dos surtos \n# Use o token de access \nresponse_contacts &lt;- GET(\n  paste0(url,\"api/outbreaks/\",outbreak_id,\"/contacts\"),          # OBTENHA (GET) a solicitação\n  add_headers(\n    Authorization = paste(\"Bearer\", access_token, sep = \" \")))\n\njson_contacts &lt;- content(response_contacts, as = \"text\")         # converta para texto JSON\n\ncontacts &lt;- as_tibble(fromJSON(json_contacts, flatten = TRUE))   # \"achate\" o JSON para um tibble\n\nCUIDADO: Se você estiver importando grandes quantidades de dados de um API que requeira autenticação, poderá haver um intervalo de tempo. Para evitar isto, recupere o access_token novamente antes de cada solicitação GET API e tente usar filtros ou limites na consulta.\nDICA: A função fromJSON() no pacote jsonlite não desalinha totalmente na primeira vez em que é executada, então você provavelmente ainda terá itens de lista em seu tibble resultante. Você precisará des-nidificar ainda mais para certas variáveis; dependendo de como seu .json está aninhado. Para ver mais informações sobre isto, veja a documentação do pacote jsonlite, como a função flatten(). \nPara mais detalhes, Veja a documentação em LoopBack Explorer, a página Rastreamento de Contatos ou dicas de API em Go.Data Github repository\nVocê pode ler mais sobre o pacote httr aqui\nEsta seção também foi informada por este tutorial e este tutorial.",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Importar e exportar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.pt.html#exportar",
    "href": "new_pages/importing.pt.html#exportar",
    "title": "7  Importar e exportar",
    "section": "7.11 Exportar",
    "text": "7.11 Exportar\n\n7.11.1 Com o pacote rio {.não numerado}\nCom rio*, você pode utilizar a função export() de uma forma muito semelhante à import(). Primeiro dê o nome do objeto R que você deseja salvar (por exemplo, linelist) e depois, entre aspas, coloque o caminho do arquivo onde você deseja salvar o arquivo, incluindo o nome do arquivo desejado e a extensão do arquivo. Por exemplo, o nome do objeto R:\nIsto salva o data frame linelist como uma pasta de trabalho do Excel para a pasta raiz do diretório de trabalho/R do projeto:\n\nexport(linelist, \"my_linelist.xlsx\") # will save to working directory\n\nVocê poderia salvar o mesmo data frame que um arquivo csv, alterando a extensão. Por exemplo, nós também o salvamos em um caminho de arquivo construído com aqui():\n\nexport(linelist, here(\"data\", \"clean\", \"my_linelist.csv\"))\n\n\n\nPara a área de transferência\nPara exportar um data frame para a “área de transferência” do seu computador (para depois colar em outro software como Excel, Google Spreadsheets, etc.) você pode utilizar write_clip() do pacote clipr*.\n\n# exporte a linelist para a área de transferência do seu sistema\nclipr::write_clip(linelist)",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Importar e exportar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.pt.html#import_rds",
    "href": "new_pages/importing.pt.html#import_rds",
    "title": "7  Importar e exportar",
    "section": "7.12 Arquivos RDS",
    "text": "7.12 Arquivos RDS\nJunto com .csv, .xlsx, etc., você também pode exportar/vendar data frame R como arquivos .rds. Este é um formato de arquivo específico para R, e é muito útil se você souber que irá trabalhar com os dados exportados novamente em R.\nAs classes de colunas são armazenadas, de modo que você não terá que limpar novamente quando for importado (com um arquivo Excel ou mesmo um arquivo CSV isto pode ser uma dor de cabeça!). É também um arquivo menor, que é útil para exportação e importação se seu conjunto de dados for grande.\nPor exemplo, se você trabalha em uma equipe de Epidemiologia e precisa enviar arquivos para uma equipe GIS para mapeamento, e eles usam R também, basta enviar-lhes o arquivo .rds! Então todas as classes de colunas são mantidas e têm menos trabalho a fazer.\n\nexport(linelist, here(\"data\", \"clean\", \"my_linelist.rds\"))",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Importar e exportar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.pt.html#import_rdata",
    "href": "new_pages/importing.pt.html#import_rdata",
    "title": "7  Importar e exportar",
    "section": "7.13 Arquivos e listas Rdata",
    "text": "7.13 Arquivos e listas Rdata\nArquivos do tipo .Rdata cpode armazenar múltiplos objetos R - por exemplo, múltiplos data frames, resultados de modelos, listas, etc. Isto pode ser muito útil para consolidar ou compartilhar muitos de seus dados para um determinado projeto.\nNo exemplo abaixo, múltiplos objetos R são armazenados dentro do arquivo exportado “my_objects.Rdata”:\n\nrio::export(my_list, my_dataframe, my_vector, \"my_objects.Rdata\")\n\nNota: se você estiver tentando importar uma lista, utilize import_list() de rio para importá-la com a estrutura e o conteúdo original completo.\n\nrio::import_list(\"my_list.Rdata\")",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Importar e exportar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.pt.html#salvando-gráficos",
    "href": "new_pages/importing.pt.html#salvando-gráficos",
    "title": "7  Importar e exportar",
    "section": "7.14 Salvando gráficos",
    "text": "7.14 Salvando gráficos\nInstruções em como salvar gráficos, incluindo os criados pelo pacote ggplot(), são discutidos com profundidado na página ggplot basics.\nEm resumo, execute o código ggsave(\"my_plot_filepath_and_name.png\") após exibir o seu gráfico. Você pode prover um objeto de gráfico para o argumento plot =, ou especificar o endereço de salvamento (com extensão de arquivo desejada) para salvar o último gráfico exibido. Você pode tamb[ém controlar o tamanho e qualidade por meio dos argumentos: width =, height =, units = e dpi =.\nComo salvar um gráfico de redes, como uma árvore de transmissão, é discutido na página Cadeias de Transmissão.",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Importar e exportar</span>"
    ]
  },
  {
    "objectID": "new_pages/importing.pt.html#recursos",
    "href": "new_pages/importing.pt.html#recursos",
    "title": "7  Importar e exportar",
    "section": "7.15 Recursos",
    "text": "7.15 Recursos\nO Manual de Importação/Exportação de Dados R\nR 4 Capítulo de ciência dos dados sobre importação de dados\ndocumentação ggsave()\nAbaixo está uma tabela, extraída do rio online vinheta. Para cada tipo de dado ele mostra: a extensão de arquivo esperada, o pacote rio* utilizado para importar ou exportar os dados, e se esta funcionalidade está incluída na versão instalada padrão do rio.\nFormato | Extensão típica | Pacote de Importação | Pacote de exportação | Instalado por padrão —————————_|—————–|————————|———————-|——————— Dados separados por vírgulas | .csv | data.table fread() | data.table | Sim Dados separados por Pipe | .psv | data.table fread() | data.table | Sim Dados separados por Tab .tsv | data.table fread() | data.table | Sim SAS | .sas7bdat | haven | haven | Sim SPSS | .sav | haven | haven | Sim Stata | .dta | haven | haven | Sim SAS | XPORT | .xpt | haven | haven | Sim SPSS Portable | .por | haven | | Sim Excel | .xls | readxl | | Sim Excel | .xlsx | readxl | openxlsx | Sim R syntax | .R | base | base | Sim Objetos R salvos | .RData, .rda | base | base | Sim Objetos R seriados | .rds | base | base | Sim Epiinfo | .rec | foreign | | Sim Minitab | .mtp | foreign | | Sim Systat | .syd | foreign | | Sim “XBASE” | database files | .dbf | foreign | foreign | Sim Weka Attribute-Relation File Format | .arff | foreign | foreign | Sim Dados no formato de intercâmbio| .dif | utils | | Sim Dados Fortran da | no recognized extension | utils | | Sim Dados no formato largura fixa | .fwf | utils | utils | Sim dados separados por vírgulas gzip | .csv.gz | utils | utils | v CSVY (CSV + YAML metadata header) | .csvy | csvy | csvy | Não EViews | .wf1 |hexView | | Não Formato de intercâmbio Feather R/Python | .feather | feather | feather | Não Fast Storage | .fst | fst | fst | Não JSON | .json | jsonlite | jsonlite | Não Matlab | .mat | rmatio | rmatio | Não Planilhas OpenDocument | .ods | readODS | readODS | Não Tabelas HTML | .html | xml2 | xml2 | Não Documentos Shallow XML | .xml | xml2 | xml2 | Não YAML | .yml | yaml | yaml | Não Padrão da área de transferência é tsv | | clipr | clipr | Não",
    "crumbs": [
      "Básico",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Importar e exportar</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.pt.html",
    "href": "new_pages/cleaning.pt.html",
    "title": "8  Limpeza de dados e principais funções",
    "section": "",
    "text": "Funções essenciais\nEste manual emfatiza a utilização das funções da família de pacotes tidyversedo R. As funções essenciais do R demonstradas nesta página estão listadas abaixo.\nMuitas destas funções pertencem ao pacote do R dplyr, que fornece funções “verbo” para resolver desafios de manipulação de dados (o nome é uma referência a um “dataframe-plier (N.T.: plier significa alicate, fazendo uma analogia da funcionalidade dessa ferramenta sobre um dataframe). O pacote dplyr é parte da família de pacotes tidyverse do R (os quais também incluem ggplot2, tidyr, stringr, tibble, purrr, magrittr, e forcats entre outros).\nSe quiser ver como estas funções se comparam aos comandos Stata ou SAS, consulte a página em Transição para o R.\nVocê poderá encontrar uma estrutura alternativa de gestão de dados a partir do pacote do R data.table com operadores como := e utilização frequente de colchetes [ ]. Estas abordagem e sintaxe são brevemente explicadas na página Tabela de dados.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Limpeza de dados e principais funções</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.pt.html#conduta-de-limpeza",
    "href": "new_pages/cleaning.pt.html#conduta-de-limpeza",
    "title": "8  Limpeza de dados e principais funções",
    "section": "8.1 Conduta de limpeza",
    "text": "8.1 Conduta de limpeza\nEsta página prossegue através das típicas etapas de limpeza, adicionando-as sequencialmente a uma cadeia de pipe de limpeza.\nNa análise epidemiológica e processamento de dados, as etapas de limpeza são frequentemente executadas sequencialmente, ligadas entre si. No R, isto manifesta-se frequentemente como um “pipeline” de limpeza, onde o conjunto de dados bruto é passado ou “canalizado” de uma etapa de limpeza para outra.\nTais cadeias utilizam funções “verbo” dplyr e o operador pipe ‘%&gt;%’ do magrittr. Esta pipe começa com os dados “brutos” (“linelist_raw.xlsx”) e termina com um data frame de R “limpo” (linelist) que pode ser utilizada, guardada, exportada, etc.\nEm uma cadeia de limpeza, a ordem das etapas é importante. As etapas de limpeza podem incluir:\n\nImportação de dados\n\nNomes de colunas limpos ou alterados\n\nRemoção de duplicidades\n\nCriação e transformação de colunas (por exemplo, re-codificação ou normalização de valores)\n\nLinhas filtradas ou adicionadas",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Limpeza de dados e principais funções</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.pt.html#carregar-pacotes",
    "href": "new_pages/cleaning.pt.html#carregar-pacotes",
    "title": "8  Limpeza de dados e principais funções",
    "section": "8.2 Carregar pacotes",
    "text": "8.2 Carregar pacotes\nEste pedaço de código mostra o carregamento das pacotes necessários para as análises. Neste manual, damos ênfase a p_load() do pacman, que instala o pacote se necessário e carrega-o para uso. Você pode também carregar pacotes instalados com library() do R base. Veja a página do Introdução ao R para mais informações do pacotes do R.\n\npacman::p_load(\n  rio,        # importação de dados  \n  here,       # caminhos de arquicos relacionados\n  janitor,    # limpeza de dados e tabelas\n  lubridate,  # trabalhando com datas\n  matchmaker, # limpeza baseada no dicionário\n  epikit,     # funções de age_categories() \n  tidyverse,  # manejo e visualização de dados\n  skimr\n)",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Limpeza de dados e principais funções</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.pt.html#importação-de-dados",
    "href": "new_pages/cleaning.pt.html#importação-de-dados",
    "title": "8  Limpeza de dados e principais funções",
    "section": "8.3 Importação de dados",
    "text": "8.3 Importação de dados\n\nImportação\nAqui nós importamos o arquivo de Excel linelist de casos “brutos” usando a função import() do pacote rio. O pacote rio trata de forma flexível muitos tipos de arquivos (por ex. .xlsx, .csv, .tsv, .rds. Ver a página em Importar e exportar para mais informações e dicas sobre situações não usuais (por exemplo, saltar linhas, definir valores em falta, importar Google sheets, etc.)\nSe quiser acompanhar, clique para descarregar a linelist “bruta” (como arquivo .xlsx).\nSe o seu conjunto de dados for grande e demorar muito tempo a importar, pode ser útil que o comando de importação seja separado da cadeia pipe e que o “bruto” seja guardado como um arquivo distinto. Isto também permite uma comparação fácil entre a versão original e a versão limpa.\nAbaixo, importamos o arquivo bruto do Excel e o salvamos como o dataframe linelist_raw. Presumimos que o arquivo esteja localizado no diretório de trabalho ou na raiz do projeto R e, portanto, nenhuma subpasta é especificada no caminho do arquivo.\n\nlinelist_raw &lt;- import(\"linelist_raw.xlsx\")\n\nVocê pode visualizar as primeiras 50 linhas do quadro de dados abaixo. Nota: a função contida no pacote R base head(n) permite que você visualize apenas as primeiras n linhas no console do R.\n\n\n\n\n\n\n\n\nRevisão\nVocê pode usar a função skim() do pacote skimr para obter uma visão geral de todo o dataframe (ver página em Tabelas descritivas para mais informações). As colunas são resumidas por classe/tipo, como caractere, numérico. Nota: “POSIXct” é um tipo de classe de data bruta (ver Trabalhando com datas).\n\nskimr::skim(linelist_raw)\n\n\nData summary\n\n\nName\nlinelist_raw\n\n\nNumber of rows\n6611\n\n\nNumber of columns\n28\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n17\n\n\nnumeric\n8\n\n\nPOSIXct\n3\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\ncase_id\n137\n0.98\n6\n6\n0\n5888\n0\n\n\ndate onset\n293\n0.96\n10\n10\n0\n580\n0\n\n\noutcome\n1500\n0.77\n5\n7\n0\n2\n0\n\n\ngender\n324\n0.95\n1\n1\n0\n2\n0\n\n\nhospital\n1512\n0.77\n5\n36\n0\n13\n0\n\n\ninfector\n2323\n0.65\n6\n6\n0\n2697\n0\n\n\nsource\n2323\n0.65\n5\n7\n0\n2\n0\n\n\nage\n107\n0.98\n1\n2\n0\n75\n0\n\n\nage_unit\n7\n1.00\n5\n6\n0\n2\n0\n\n\nfever\n258\n0.96\n2\n3\n0\n2\n0\n\n\nchills\n258\n0.96\n2\n3\n0\n2\n0\n\n\ncough\n258\n0.96\n2\n3\n0\n2\n0\n\n\naches\n258\n0.96\n2\n3\n0\n2\n0\n\n\nvomit\n258\n0.96\n2\n3\n0\n2\n0\n\n\ntime_admission\n844\n0.87\n5\n5\n0\n1091\n0\n\n\nmerged_header\n0\n1.00\n1\n1\n0\n1\n0\n\n\n…28\n0\n1.00\n1\n1\n0\n1\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\ngeneration\n7\n1.00\n16.60\n5.71\n0.00\n13.00\n16.00\n20.00\n37.00\n▁▆▇▂▁\n\n\nlon\n7\n1.00\n-13.23\n0.02\n-13.27\n-13.25\n-13.23\n-13.22\n-13.21\n▅▃▃▅▇\n\n\nlat\n7\n1.00\n8.47\n0.01\n8.45\n8.46\n8.47\n8.48\n8.49\n▅▇▇▇▆\n\n\nrow_num\n0\n1.00\n3240.91\n1857.83\n1.00\n1647.50\n3241.00\n4836.50\n6481.00\n▇▇▇▇▇\n\n\nwt_kg\n7\n1.00\n52.69\n18.59\n-11.00\n41.00\n54.00\n66.00\n111.00\n▁▃▇▅▁\n\n\nht_cm\n7\n1.00\n125.25\n49.57\n4.00\n91.00\n130.00\n159.00\n295.00\n▂▅▇▂▁\n\n\nct_blood\n7\n1.00\n21.26\n1.67\n16.00\n20.00\n22.00\n22.00\n26.00\n▁▃▇▃▁\n\n\ntemp\n158\n0.98\n38.60\n0.95\n35.20\n38.30\n38.80\n39.20\n40.80\n▁▂▂▇▁\n\n\n\nVariable type: POSIXct\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nmedian\nn_unique\n\n\n\n\ninfection date\n2322\n0.65\n2012-04-09\n2015-04-27\n2014-10-04\n538\n\n\nhosp date\n7\n1.00\n2012-04-20\n2015-04-30\n2014-10-15\n570\n\n\ndate_of_outcome\n1068\n0.84\n2012-05-14\n2015-06-04\n2014-10-26\n575",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Limpeza de dados e principais funções</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.pt.html#nomes-de-colunas",
    "href": "new_pages/cleaning.pt.html#nomes-de-colunas",
    "title": "8  Limpeza de dados e principais funções",
    "section": "8.4 Nomes de colunas",
    "text": "8.4 Nomes de colunas\nNo R, os nomes das colunas são o “cabeçalho” ou valor do “topo” de uma coluna. Eles são usados para referir a colunas em código, e serve como um rotulo por omissão nas figuras.\nOutros softwares estatísticos como SAS e STATA utilizam “etiquetas” que coexistem como versões impressas mais longas dos nomes das colunas mais curtas. Embora o R ofereça a possibilidade de adicionar etiquetas de coluna aos dados, isto não é enfatizado na maioria das práticas. Para que os nomes das colunas sejam “amigáveis para impressão” de figuras, normalmente se ajusta sua exibição dentro dos próprios comandos de criação dos gráficos e tabelas (por exemplo, títulos de eixos ou legendas de um gráfico, ou cabeçalhos de coluna em uma tabela impressa - veja a seção de escalas da página de dicas ggplot e páginas de Tabelas para apresentação). Se você quiser atribuir etiquetas de coluna nos dados, leia mais online aqui e aqui.\nComo os nomes de colunas no R são usados muito frequentemente, então eles devem ter uma sintaxe “limpa”. Nós sugerimos o seguinte:\n\nNomes curtos\nSem espaços (substituir com sublinhados _ )\nSem caracteres especiais (&, #, &lt;, &gt;, …)\n\nNomenclatura de estilo similar (por exemplo, todas as colunas de datas nomeadas como data_início, data_relato, data_morte…)\n\nOs nomes das colunas de linelist_raw são “printados” abaixo utilizando names() do R base. Podemos ver isso inicialmente:\n\nAlguns nomes contêm espaços (por exemplo a data de infeccção infecction date )\n\nDiferentes padrões de nomes são utilizados para datas (data de início vs data de infecção, date onset vs. infecction date)\n\nDeve ter havido um cabeçalho combinado nas duas últimas colunas no .xlsx. Sabemos disso porque o nome de duas colunas combinadas (“merged_header”) foi atribuído pelo R à primeira coluna, e à segunda coluna foi atribuído um nome de espaço reservado “…28” (pois estava então vazia e é a 28ª coluna).\n\n\nnames(linelist_raw)\n\n [1] \"case_id\"         \"generation\"      \"infection date\"  \"date onset\"     \n [5] \"hosp date\"       \"date_of_outcome\" \"outcome\"         \"gender\"         \n [9] \"hospital\"        \"lon\"             \"lat\"             \"infector\"       \n[13] \"source\"          \"age\"             \"age_unit\"        \"row_num\"        \n[17] \"wt_kg\"           \"ht_cm\"           \"ct_blood\"        \"fever\"          \n[21] \"chills\"          \"cough\"           \"aches\"           \"vomit\"          \n[25] \"temp\"            \"time_admission\"  \"merged_header\"   \"...28\"          \n\n\nNOTA: Para referenciar um nome de coluna que inclua espaços, rodeie o nome com o acentro grave (N.T. chamado vulgarmente de “crase”), por exemplo: linelist$` '\\x60infection date\\x60'`. Note que no seu teclado, o acento grave (`) é diferente das aspas simples/apóstrofe (’).\n\nLimpeza automática\nA função clean_names() do pacote janitor padroniza os nomes das colunas e os torna únicos ao fazer o seguinte:\n\nConverte todos os nomes para consistir apenas em sublinhados, números e letras\n\nOs caracteres acentuados são transliterados para ASCII (por exemplo, german o com umlaut torna-se “o”, “enye” espanhol torna-se “n”)\n\nA preferência de capitalização para os nomes das novas colunas pode ser especificada utilizando o argumento case = argumento (“snake” é padrão, as alternativas incluem “sentence”, “title”, “small_camel”…)\n\nVocê pode especificar substituições específicas de nomes fornecendo um vetor para o argumento replace = argumento (por exemplo, replace = c(onset = \"date_of_onset\"))\n\nAqui está uma vinheta online.\n\nA seguir, a linha de limpeza começa utilizando clean_names() na linelist bruta.\n\n# pipe do conjunto de dados brutos através da função clean_names(), atribuindo o resultado como \"linelist\"  \nlinelist &lt;- linelist_raw %&gt;% \n  janitor::clean_names()\n\n# Veja os novos nomes das colunas\nnames(linelist)\n\n [1] \"case_id\"         \"generation\"      \"infection_date\"  \"date_onset\"     \n [5] \"hosp_date\"       \"date_of_outcome\" \"outcome\"         \"gender\"         \n [9] \"hospital\"        \"lon\"             \"lat\"             \"infector\"       \n[13] \"source\"          \"age\"             \"age_unit\"        \"row_num\"        \n[17] \"wt_kg\"           \"ht_cm\"           \"ct_blood\"        \"fever\"          \n[21] \"chills\"          \"cough\"           \"aches\"           \"vomit\"          \n[25] \"temp\"            \"time_admission\"  \"merged_header\"   \"x28\"            \n\n\nNOTA: O nome da última coluna “…28” foi mudado para “x28”.\n\n\nLimpeza manual de nomes\nA renomeação manual das colunas é frequentemente necessária, mesmo após a etapa de padronização acima. Abaixo, a renomeação é realizada utilizando a função rename() do pacote dplyr, como parte de uma cadeia pipe. A função rename() utiliza o estilo NOVO = VELHO - o novo nome da coluna é dado antes do nome da coluna antiga.\nAbaixo, um comando de renomeação é adicionado a linha de pipe limpa. Espaços foram adicionados estrategicamente para alinhar o código para facilitar a leitura.\n\n# CADEIA 'PIPE' DE LIMPEZA\n# (inicia com dados brutos e encadeia funções com o pipe até a limpeza dos dados)\n##################################################################################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # padronização da sintaxe do nome de coluna \n    janitor::clean_names() %&gt;% \n    \n    # colunas renomeadas manualmente\n           # NOVO nome             # nome VELHO\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome)\n\nAgora você pode ver que os nomes das colunas está sendo mudado:\n\n\n [1] \"case_id\"              \"generation\"           \"date_infection\"      \n [4] \"date_onset\"           \"date_hospitalisation\" \"date_outcome\"        \n [7] \"outcome\"              \"gender\"               \"hospital\"            \n[10] \"lon\"                  \"lat\"                  \"infector\"            \n[13] \"source\"               \"age\"                  \"age_unit\"            \n[16] \"row_num\"              \"wt_kg\"                \"ht_cm\"               \n[19] \"ct_blood\"             \"fever\"                \"chills\"              \n[22] \"cough\"                \"aches\"                \"vomit\"               \n[25] \"temp\"                 \"time_admission\"       \"merged_header\"       \n[28] \"x28\"                 \n\n\n\nRenomear a posição da coluna\nVocê pode também renomear pela posição da coluna, ao invés do nome da coluna, por exemplo:\n\nrename(newNameForFirstColumn  = 1,\n       newNameForSecondColumn = 2)\n\n\n\nRenomear via select() e summarise()\nComo um atalho, você também pode renomear colunas dentro das funções dplyr select() e summarise(). select() é utilizada para manter apenas certas colunas (e é abordada mais adiante nesta página). summarise() é coberta nas páginas Agrupamento de dados e Tabelas descritivas. Estas funções também utilizam o formato novo_nome = antigo_nome. Aqui está um exemplo:\n\nlinelist_raw %&gt;% \n  select(# NOVO nome             # nome VELHO\n         date_infection       = `infection date`,    # renomear e MANTER APENAS estas colunas\n         date_hospitalisation = `hosp date`)\n\n\n\n\nOutros desafios\n\nNomes de colunas Excel vazias\nO R não pode ter colunas de conjuntos de dados que não tenham nomes de colunas (cabeçalhos). Portanto, se você importar um conjunto de dados Excel com dados mas sem cabeçalhos de colunas, o R preencherá os cabeçalhos com nomes como “…1” ou “…2”. O número representa o número da coluna (por exemplo, se a 4ª coluna do conjunto de dados não tiver cabeçalho, então R lhe dará o nome “…4”).\nVocê pode limpar estes nomes manualmente referenciando o número de posição (ver exemplo acima), ou seu nome atribuído (linelist_raw$...1).\n\n\nNomes de colunas e células de Excel combinado\nAs células combinadas em um arquivo Excel são uma ocorrência comum no recebimento de dados. Como explicado em Transição para R, células combinadas podem ser agradáveis para a leitura humana de dados, mas não são “dados arrumados” e causam muitos problemas para a leitura de dados pela máquina. O R não pode acomodar células combinadas.\nLembre as pessoas que fazem a entrada de dados que dados legíveis por humanos não é o mesmo que dados legíveis por máquinas. Esforce-se para treinar os usuários sobre os princípios de dados arrumados. Se possível, tente mudar os procedimentos para que os dados cheguem em um formato ordenado sem células combinadas.\n\nCada variável deve ter sua própria coluna.\n\nCada observação deve ter sua própria linha.\n\nCada valor deve ter sua própria célula.\n\nAo utilizar a função import() do rio, o valor em uma célula mesclada será atribuído à primeira célula e as células subsequentes estarão vazias.\nUma solução para lidar com células mescladas é importar os dados com a função readWorkbook() do pacote openxlsx. Defina o argumento fillMergedCells = TRUE. Isto dá o valor em uma célula mesclada a todas as células dentro da faixa mesclada.\n\nlinelist_raw &lt;- openxlsx::readWorkbook(\"linelist_raw.xlsx\", fillMergedCells = TRUE)\n\nATENÇÃO: Se os nomes das colunas forem mesclados com readWorkbook(), você terminará com nomes de colunas duplicadas, que você precisará corrigir manualmente - o R não funciona bem com nomes de colunas duplicadas! Você pode renomeá-los referenciando sua posição (por exemplo, coluna 5), como explicado na seção sobre limpeza manual de nomes de colunas",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Limpeza de dados e principais funções</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.pt.html#selecionar-ou-reordenar-colunas",
    "href": "new_pages/cleaning.pt.html#selecionar-ou-reordenar-colunas",
    "title": "8  Limpeza de dados e principais funções",
    "section": "8.5 Selecionar ou reordenar colunas",
    "text": "8.5 Selecionar ou reordenar colunas\nUtilize select() do dplyr para selecionar as colunas que você deseja reter e especificar sua ordem no quadro de dados,\nCUIDADO: Nos exemplos abaixo, o quadro de dados linelist é modificado com select() e exibido, mas não salvo. Isto é para fins de demonstração. Os nomes das colunas modificadas são exibidos ao fornecer banco de dados com o pipe para função names().\nAqui estão TODOS os nomes que a linelist tem até este ponto da cadeia de limpeza:\n\nnames(linelist)\n\n [1] \"case_id\"              \"generation\"           \"date_infection\"      \n [4] \"date_onset\"           \"date_hospitalisation\" \"date_outcome\"        \n [7] \"outcome\"              \"gender\"               \"hospital\"            \n[10] \"lon\"                  \"lat\"                  \"infector\"            \n[13] \"source\"               \"age\"                  \"age_unit\"            \n[16] \"row_num\"              \"wt_kg\"                \"ht_cm\"               \n[19] \"ct_blood\"             \"fever\"                \"chills\"              \n[22] \"cough\"                \"aches\"                \"vomit\"               \n[25] \"temp\"                 \"time_admission\"       \"merged_header\"       \n[28] \"x28\"                 \n\n\n\nManter colunas\nSelecione apenas as colunas que você quer manter\nColoque seus nomes no comando select(), sem aspas. Eles aparecerão no data frame na ordem que você fornecer. Observe que se você incluir uma coluna que não existe, o R retornará um erro (veja o uso de any_of() abaixo se você não quiser nenhum erro nesta situação).\n\n# O conjunto de dados linelist é canalisado através do comando select(), e names() \"printam\" apenas os nomes das colunas\nlinelist %&gt;% \n  select(case_id, date_onset, date_hospitalisation, fever) %&gt;% \n  names()  # exibir os nomes das colunas\n\n[1] \"case_id\"              \"date_onset\"           \"date_hospitalisation\"\n[4] \"fever\"               \n\n\n\n\nFunções auxiliares “tidyselect”\nEstas funções de ajuda existem para facilitar a especificação de colunas para manter, descartar ou transformar. Elas são do pacote tidyselect, que está incluído no tidyverse e está subjacente à forma como as colunas são selecionadas nas funções dplyr.\nPor exemplo, se você quiser reordenar as colunas, everything() é uma função útil para significar “todas as outras colunas ainda não mencionadas”. O comando abaixo move as colunas date_onset e date_hospitalisation para o início (esquerda) do conjunto de dados, mas mantém todas as outras colunas depois. Note que everything() é escrito com parênteses vazios:\n\n# mova date_onset e date_hospitalisation para o início\nlinelist %&gt;% \n  select(date_onset, date_hospitalisation, everything()) %&gt;% \n  names()\n\n [1] \"date_onset\"           \"date_hospitalisation\" \"case_id\"             \n [4] \"generation\"           \"date_infection\"       \"date_outcome\"        \n [7] \"outcome\"              \"gender\"               \"hospital\"            \n[10] \"lon\"                  \"lat\"                  \"infector\"            \n[13] \"source\"               \"age\"                  \"age_unit\"            \n[16] \"row_num\"              \"wt_kg\"                \"ht_cm\"               \n[19] \"ct_blood\"             \"fever\"                \"chills\"              \n[22] \"cough\"                \"aches\"                \"vomit\"               \n[25] \"temp\"                 \"time_admission\"       \"merged_header\"       \n[28] \"x28\"                 \n\n\nAqui estão outras funções auxiliares “tidyselect” que também trabalham dentro das funções dplyr como select(), across(), e summarise():\n\neverything() - todas as outras colunas não mencionadas\n\nlast_col() - a última coluna\n\nwhere() - aplica uma função a todas as colunas e seleciona aquelas para as quais a função retorna TRUE (verdadeiro)\n\ncontains() - colunas contendo uma cadeia de caracteres\n\nexemplo: select(contains(\"time\"))\n\n\nstarts_with() - corresponde a um prefixo especificado\n\nexemplo: select(starts_with(\"date_\"))\n\n\nends_with() - corresponde a um sufixo especificado\n\nexemplo: select(ends_with(\"_post\"))\n\n\nmatches() - para aplicar uma expressão regular (regex)\n\nexemplo: select(matches(\"[pt]al\"))\n\n\nnum_range() - uma faixa numérica como x01, x02, x03\n\nany_of() - faz a correspondência SE a coluna existir, mas não retorna nenhum erro se não for encontrada\n\nexemplo: select(any_of(date_onset, date_death, cardiac_arrest))\n\n\nAlém disso, utilizar operadores normais como c() para listar várias colunas, : para colunas consecutivas, ! para o oposto, & para AND, e | para OR.\nUtilize where() para especificar critérios lógicos para as colunas. Se fornecer uma função dentro de where(), não inclua os parênteses vazios da função. O comando abaixo seleciona colunas que são de classe Numérica.\n\n# selecione colunas que são a classe numérica\nlinelist %&gt;% \n  select(where(is.numeric)) %&gt;% \n  names()\n\n[1] \"generation\" \"lon\"        \"lat\"        \"row_num\"    \"wt_kg\"     \n[6] \"ht_cm\"      \"ct_blood\"   \"temp\"      \n\n\nUtilize contains() para selecionar apenas colunas nas quais o nome da coluna contém uma cadeia de caracteres especificada. Os ends_with() e starts_with() fornecem mais nuances.\n\n# selecione colunas contendo certos caracteres\nlinelist %&gt;% \n  select(contains(\"date\")) %&gt;% \n  names()\n\n[1] \"date_infection\"       \"date_onset\"           \"date_hospitalisation\"\n[4] \"date_outcome\"        \n\n\nA função matches() funciona de forma semelhante a contains() mas pode ser fornecida uma expressão regular (ver página em Caracteres e strings), tais como múltiplos strings separados por “barras de OU” dentro dos parênteses:\n\n# procurado por combinações de caracteres múltiplos\nlinelist %&gt;% \n  select(matches(\"onset|hosp|fev\")) %&gt;%   # note o símbolo OR \"|\"\n  names()\n\n[1] \"date_onset\"           \"date_hospitalisation\" \"hospital\"            \n[4] \"fever\"               \n\n\nCUIDADO: Se um nome de coluna que você fornecer especificamente não existir nos dados, ele pode retornar um erro e parar seu código. Considere utilizar any_of() para citar colunas que podem ou não existir, especialmente úteis em seleções negativas (remoção).\nApenas uma destas colunas existe, mas nenhum erro é produzido e o código continua sem parar sua cadeia de limpeza.\n\nlinelist %&gt;% \n  select(any_of(c(\"date_onset\", \"village_origin\", \"village_detection\", \"village_residence\", \"village_travel\"))) %&gt;% \n  names()\n\n[1] \"date_onset\"\n\n\n\n\nRemova colunas\nIndicar quais colunas devem ser removidas colocando um símbolo menos “-” na frente do nome da coluna (por exemplo,select(-outcome)), ou um vetor de nomes de colunas (como abaixo). Todas as outras colunas serão retidas.\n\nlinelist %&gt;% \n  select(-c(date_onset, fever:vomit)) %&gt;% # remova date_onset e todas as colunas de febre a vômito\n  names()\n\n [1] \"case_id\"              \"generation\"           \"date_infection\"      \n [4] \"date_hospitalisation\" \"date_outcome\"         \"outcome\"             \n [7] \"gender\"               \"hospital\"             \"lon\"                 \n[10] \"lat\"                  \"infector\"             \"source\"              \n[13] \"age\"                  \"age_unit\"             \"row_num\"             \n[16] \"wt_kg\"                \"ht_cm\"                \"ct_blood\"            \n[19] \"temp\"                 \"time_admission\"       \"merged_header\"       \n[22] \"x28\"                 \n\n\nVocê também pode remover uma coluna utilizando a síntaxe do R base, definindo-a como NULL. Por exemplo:\n\nlinelist$date_onset &lt;- NULL   # elimina a coluna com a síntaxe da base do R \n\n\n\nAutonomia\nselect() também pode ser utilizado como um comando independente (não em uma cadeia de pipe). Neste caso, o primeiro argumento é o dataframe original a ser operado.\n\n# Criar uma nova linelist com colunas relacionadas a id e idade\nlinelist_age &lt;- select(linelist, case_id, contains(\"age\"))\n\n# exiba os nomes das colunas\nnames(linelist_age)\n\n[1] \"case_id\"  \"age\"      \"age_unit\"\n\n\n\nAcrescente à cadeia de pipes\nNa linelist_raw, há algumas colunas que não precisamos: row_num, merged_header, e x28. Nós as removemos com um comando select() na cadeia pipe limpa:\n\n# CADEIA 'PIPE' DE LIMPEZA \n#(inicia com dados brutos e encadeia funções com o pipe até a limpeza dos dados)\n##################################################################################\n\n# inicie a cadeia pipe de limpeza\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # padronize a sintaxe do nome da coluna\n    janitor::clean_names() %&gt;% \n    \n    # renomeie manualmente colunas\n           # NOVO nome             # nome VELHO\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # ACIMA ESTÃO OS PASSOS DE LIMPEZA JÁ DISCUTIDOS\n    #####################################################\n\n    # remova coluna\n    select(-c(row_num, merged_header, x28))",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Limpeza de dados e principais funções</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.pt.html#eliminação-de-duplicidades",
    "href": "new_pages/cleaning.pt.html#eliminação-de-duplicidades",
    "title": "8  Limpeza de dados e principais funções",
    "section": "8.6 Eliminação de duplicidades",
    "text": "8.6 Eliminação de duplicidades\nConsulte a página do manual de Eliminação de duplicidades para obter opções extensivas sobre como de-duplicar os dados. Apenas um exemplo muito simples de eliminação de duplicidades é apresentado aqui.\nO pacotedplyr oferece a função distinct() function. Esta função examina cada linha e reduz o data frame para apenas as linhas únicas. Isto é, ele remove as linhas que são 100% duplicadas.\nAo avaliar linhas duplicadas, ela leva em conta uma gama de colunas - por padrão ele considera todas as colunas. Como mostrado na página de desduplicação, é possível ajustar este intervalo de colunas para que a singularidade das linhas só seja avaliada em relação a determinadas colunas.\nNeste exemplo simples, basta adicionar o comando vazio distinct() para a cadeia de pipe. Isto garante que não haja linhas que sejam 100% duplicatas de outras linhas (avaliadas em todas as colunas).\nComeçamos com nrow(linelist) de linhas em linelist.\n\nlinelist &lt;- linelist %&gt;% \n  distinct()\n\nApós a eliminação de duplicidades, existem nrow(linelist) linhas. Qualquer linha removida teria sido 100% duplicada de outras linhas.\nAbaixo, o comando distinct() é adicionado à cadeia de pipe de limpeza:\n\n# CADEIA 'PIPE' DE LIMPEZA \n#(inicia com dados brutos e encadeia funções com o pipe até a limpeza dos dados)\n##################################################################################\n\n# começa a limpeza da cadeia pipe\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # padronizar a sintaxe do nome da coluna\n    janitor::clean_names() %&gt;% \n    \n    # re-nomear colunas manualmente\n           # NOVO nome             # nome VELHO\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # remova a coluna\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # ACIMA ESTÃO OS PASSOS DE LIMPEZA JÁ DISCUTIDOS\n    #####################################################\n    \n    # desduplicar\n    distinct()",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Limpeza de dados e principais funções</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.pt.html#criação-de-coluna-e-transformação",
    "href": "new_pages/cleaning.pt.html#criação-de-coluna-e-transformação",
    "title": "8  Limpeza de dados e principais funções",
    "section": "8.7 Criação de coluna e transformação",
    "text": "8.7 Criação de coluna e transformação\nNós recomendamos usar a função dplyr mutate() para adicionar uma nova coluna, ou para modificar uma existente.\nAbaixo está um exemplo de criação de uma nova coluna com mutate(). A sintaxe é: mutate(novo_nome_de_coluna = valor ou transformação)\nNo Stata, isto é similar ao comando generate, mas o mutate() do R pode também ser usado para modificar uma coluna existente.\n\nNovas colunas\nO comando mutate() mais básico para criar uma nova coluna deve parecer como este. Ele cria uma nova coluna nova_coluna onde o valor em cada linha é 10.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(nova_coluna = 10)\n\nVocê também pode referenciar valores em outras colunas, para realizar cálculos. Abaixo, uma nova coluna bmi é criada para manter o Índice de Massa Corporal (IMC, Body Mass Index em inglês) para cada caso - como calculado utilizando a fórmula IMC = kg/m^2, utilizando coluna ht_cm e coluna wt_kg.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(bmi = wt_kg / (ht_cm/100)^2) #bmi = IMC em portugês\n\nSe forem criadas várias colunas novas, separe cada uma delas com uma vírgula e uma nova linha. Abaixo estão exemplos de novas colunas, incluindo aquelas que consistem de valores de outras colunas combinadas utilizando str_glue() do pacote stringr (veja a página em Caracteres e strings.\n\nnew_col_demo &lt;- linelist %&gt;%                       \n  mutate(\n    new_var_dup    = case_id,             # nova coluna = duplicata/copia outra coluna existente\n    new_var_static = 7,                   # nova coluna = todos os valores o mesmo\n    new_var_static = new_var_static + 5,  # você pode sobrescrever uma coluna, e ele pode ser um cálculo de outras variáveis\n    new_var_paste  = stringr::str_glue(\"{hospital} on ({date_hospitalisation})\") # nova coluna = colando juntos valores de outras colunas\n    ) %&gt;% \n  select(case_id, hospital, date_hospitalisation, contains(\"new\"))        # mostra apenas nova coluna, para demonstrar objetivos\n\nRevise as novas colunas. Para demonstrar os objetivos, apenas as novas colunas e as colunas usadas para criá-las são mostradas:\n\n\n\n\n\n\nDICA: Uma variação de mutate() é a função transmute(). Esta função adiciona uma nova coluna apenas como mutate(), mas também remove todas outras colunas que você não menciona dentro destes parênteses.\n\n# ESCONDIDO DO LEITOR\n# remove novas colunas de demonstração criadas acima\n# linelist &lt;- linelist %&gt;% \n#   select(-contains(\"new_var\"))\n\n\n\nConverter a classe de coluna\nColunas contendo valores que são datas, números ou valores lógicos (TRUE/FALSE, ou seja, verdadeiro/falso) só se comportarão como esperado se forem corretamente classificadas. Há uma diferença entre “2” da classe caracteres e 2 da classe numérica!\nHá maneiras de definir a classe da coluna durante os comandos de importação, mas isso é muitas vezes complicado. Veja a seção Introdução ao R sobre classes de objetos para saber mais sobre a conversão da classe de objetos e colunas.\nPrimeiro, vamos fazer algumas verificações em colunas importantes para ver se são a classe correta. Também vimos isso no início, quando corremos skim().\nAtualmente, a classe da coluna age é caractere. Para realizar análises quantitativas, precisamos que estes números sejam reconhecidos como numéricos!\n\nclass(linelist$age)\n\n[1] \"character\"\n\n\nA classe da coluna date_onset também é caractere! Para realizar análises, estas datas devem ser reconhecidas como datas!\n\nclass(linelist$date_onset)\n\n[1] \"character\"\n\n\nPara resolver isto, utilize a capacidade de mutate() de redefinir uma coluna com uma transformação. Nós definimos a coluna como ela mesma, mas convertida em uma classe diferente. Aqui está um exemplo básico, convertendo ou assegurando que a coluna ‘age’ seja de classe numérica:\n\nlinelist &lt;- linelist %&gt;% \n  mutate(age = as.numeric(age))\n\nEm um modo similar, você pode usar as.character() e as.logical(). Para converter para a classe Fator, você pode usar factor() do R base ou as_factor() do forcats. Leia mais sobre isso na página Fatores.\nVocê deve ter cuidado ao converter para a classe Data. Vários métodos são explicados na página Trabalhando com datas. Normalmente, os valores de data bruta devem estar todos no mesmo formato para que a conversão funcione corretamente (por exemplo “MM/DD/YYYY”, ou “DD MM YYYY”). Após a conversão para a classe Data, verifique seus dados para confirmar que cada valor foi convertido corretamente.\n\n\nDados agrupados\nSe o seu dataframe já estiver agrupado (veja a página Dados agrupados), mutate() pode se comportar de forma diferente do que se o dataframe não estiver agrupado. Qualquer função resumida, como mean(), median(), max(), etc. será calculada por grupo, não por todas as linhas.\n\n# idade normalizada pela média de TODAS as linhas\nlinelist %&gt;% \n  mutate(age_norm = age / mean(age, na.rm=T))\n\n# idade normalizada pela média do grupo do hospital\nlinelist %&gt;% \n  group_by(hospital) %&gt;% \n  mutate(age_norm = age / mean(age, na.rm=T))\n\nLeia mais sobre a utilização de mutate () em dataframes agrupados nesta documentaçao do mutate tidyverse.\n\n\nTransformar múltiplas colunas\nMuitas vezes para escrever um código conciso você quer aplicar a mesma transformação a várias colunas ao mesmo tempo. Uma transformação pode ser aplicada a múltiplas colunas ao mesmo tempo utilizando a função across() do pacote dplyr (ambém contida no pacote tidyverse). across() pode ser utilizada com qualquer função dplyr, mas é comumente utilizada dentro de select(), mutate(), filter(), ou summarise(). Veja como é aplicado a summarise() na página de Tabelas Descritivas.\nEspecifique as colunas para o argumento .cols = e a(s) função(ões) a ser(em) aplicada(s) a .fns =. Quaisquer argumentos adicionais a serem fornecidos à função .fns' podem ser incluídos após uma vírgula, ainda dentro deacross()`.\n\nSeleção de coluna across()\nEspecifique as colunas para o argumento .cols =. Você pode nomeá-las individualmente, ou usar as funções do helper do “tidyselect”. Especifique a função para .fns =`. Observe que utilizando o modo de função demonstrado abaixo, a função é escrita sem seus parênteses ( ).\nAqui a transformação as.character() é aplicada a colunas específicas nomeadas dentro de across().\n\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))\n\nAs funções auxiliares “tidyselect” estão disponíveis para ajudá-lo a especificar colunas. Elas são detalhadas acima na seção sobre Seleção e reordenação de colunas, e eles incluem: everything(), last_col(), where(), starts_with(), ends_with(), contains(), matches(), num_range() e any_of().\nAqui está um exemplo de como se pode mudar todas as colunas para a classe de caracteres:\n\n# para mudar todas as colunas para a classe caractere\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = everything(), .fns = as.character))\n\nConverter em caracteres todas as colunas onde o nome contém a string “data” (note a colocação de vírgulas e parênteses):\n\n# para mudar todas as colunas para classe de caracteres\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = contains(\"date\"), .fns = as.character))\n\nAbaixo, um exemplo de transformação de colunas que atualmente são da classe POSIXct (uma classe de data/hora bruta que mostra marcações de hora) - em outras palavras, onde a função is.POSIXct() avalia para TRUE. Em seguida, queremos aplicar a função as.Date() a estas colunas para convertê-las em uma classe normal Date.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = where(is.POSIXct), .fns = as.Date))\n\n\nNote que dentro de across() também utilizamos a função where() como is.POSIXct está avaliando para TRUE ou FALSE.\n\nNote que is.POSIXct() é do pacote lubridate. Outras funções “is” similares como is.character(), is.numeric(), e is.logical() são do R base.\n\n\n\nFunçõesacross()\nVocê pode ler a documentação com ?across' para obter detalhes sobre como fornecer funções paraacross()`. Alguns pontos resumidos: há várias maneiras de especificar a(s) função(ões) a ser(em) executada(s) em uma coluna e você pode até mesmo definir suas próprias funções:\n\nVocê pode fornecer apenas o nome da função (por ex., mean ou as.character)\n\nVocê pode fornecer a função no estilo purrr (por ex.,~ mean(.x, na.rm = TRUE)) (veja esta página de Iterações, Listas e Loops)\n\nVocê pode especificar múltiplas funções fornecendo uma lista (por exemplo, list(mean = mean, n_miss = ~ sum(is.na(.x))).\nSe você fornecer múltiplas funções, múltiplas colunas transformadas serão retornadas por coluna de entrada, com nomes únicos no formato col_fn. Você pode ajustar como as novas colunas são nomeadas com o argumento .names = usando a sintaxe glue (veja a página de Caracteres e strings) onde {.col} e {.fn} são are abreviaturas para a coluna de entrada e função.\n\nAqui estão alguns recursos on-line sobre a utilização de across(): creator Hadley Wickham’s thoughts/rationale\n\n\n\ncoalesce()\nEsta função dplyr encontra o primeiro valor não-faltante em cada posição. Ela “preenche” os valores ausentes com o primeiro valor disponível em uma ordem especificada por você.\nAqui está um exemplo fora do contexto de um data frame: Digamos que você tem dois vetores, um contendo a vila de detecção do paciente e outro contendo a vila de residência do paciente. Você pode usar a coalesce para escolher o primeiro valor não-faltante para cada índice:\n\nvillage_detection &lt;- c(\"a\", \"b\", NA,  NA)\nvillage_residence &lt;- c(\"a\", \"c\", \"a\", \"d\")\n\nvillage &lt;- coalesce(village_detection, village_residence)\nvillage    # imprima\n\n[1] \"a\" \"b\" \"a\" \"d\"\n\n\nIsto funciona da mesma forma se você fornecer colunas de data frame: para cada linha, a função atribuirá o novo valor de coluna com o primeiro valor não descartado nas colunas que você forneceu (na ordem fornecida).\n\nlinelist &lt;- linelist %&gt;% \n  mutate(village = coalesce(village_detection, village_residence))\n\nEste é um exemplo de uma operação “em linha”. Para cálculos mais complicados em linha, veja a seção abaixo sobre cálculos em linha.\n\n\nMatemática cumulativa\nSe você quiser que uma coluna reflita a soma cumulativa/média/mínimo/máximo etc para avaliar as linhas em um dataframe até este ponto, usa as seguintes funções:\ncumsum() retorna a soma cumulativa, como mostrado abaixo:\n\nsum(c(2,4,15,10))     # retorna apenas um número\n\n[1] 31\n\ncumsum(c(2,4,15,10))  # retorna a soma cumulativa em cada etapa\n\n[1]  2  6 21 31\n\n\nIsto pode ser usado em um dataframe ao fazer uma nova coluna. Por exemplo, para calcular o número cumulativo de casos por dia em um surto, considere um código como este:\n\ncumulative_case_counts &lt;- linelist %&gt;%  # inicia com o caso linelist\n  count(date_onset) %&gt;%                 # conta as linhas por dia, como coluna 'n'   \n  mutate(cumulative_cases = cumsum(n))  # nova coluna, da soma cumulativa em cada linha\n\nAbaixo estão as primeiras 10 linhas:\n\nhead(cumulative_case_counts, 10)\n\n   date_onset n cumulative_cases\n1  2012-04-15 1                1\n2  2012-05-05 1                2\n3  2012-05-08 1                3\n4  2012-05-31 1                4\n5  2012-06-02 1                5\n6  2012-06-07 1                6\n7  2012-06-14 1                7\n8  2012-06-21 1                8\n9  2012-06-24 1                9\n10 2012-06-25 1               10\n\n\nVeja a página sobre Curvas epidêmicas para saber como plotar a incidência acumulada com a epicurva.\nVeja também:\ncumsum(), cummean(), cummin(), cummax(), cumany(), cumall()\n\n\nUsando o R base\nPara definir uma nova coluna (ou redefinir uma coluna) utilizando o R base, escreva o nome do data frame, conectado com $, para a nova coluna (ou a colunas a ser modificada). Use o operador de atribuição &lt;- para definir o(s) novo(s) valor(es). Relembre que quando usar o R base você deve especificar o nome do data frame antes do nome da coluna toda vez (por ex., dataframe$column). Aqui é um exemplo de criação da coluna bmi usando o R base:\n\nlinelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)\n\n\n\nAdicionar a cadeia pipe\nAbaixo, uma nova coluna é adicionada à cadeia pipe e algumas classes são convertidas.\n\n# CADEIA 'PIPE' DE LIMPEZA\n#(começa com dados brutos e faz pipes através das etapas de limpeza)\n##################################################################################\n\n# inicie a cadeia pipe limpa\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # padronizar a sintaxe do nome da coluna\n    janitor::clean_names() %&gt;% \n    \n    # re-nomear colunas manualmente\n           # NOVO nome             # nome VELHO\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # remova coluna\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # remova duplicidade\n    distinct() %&gt;% \n  \n    # ACIMA SÃO PASSOS DE LIMPEZA A MONTANTE JÁ DISCUTIDOS\n    ###################################################\n    # adicione nova coluna\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %&gt;% \n  \n    # converta a classe das colunas\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age))",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Limpeza de dados e principais funções</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.pt.html#re-codificar-valores",
    "href": "new_pages/cleaning.pt.html#re-codificar-valores",
    "title": "8  Limpeza de dados e principais funções",
    "section": "8.8 Re-codificar valores",
    "text": "8.8 Re-codificar valores\nAqui estão alguns cenários onde você precisa recodificar (mudar) os valores:\n\npara editar um valor específico (por exemplo, uma data com um ano ou formato incorreto)\n\npara reconciliar valores não soletrados da mesma forma\npara criar uma nova coluna de valores categóricos\n\npara criar uma nova coluna de categorias numéricas (por exemplo, categorias de idade)\n\n\nValores específicos\nPara alterar valores manualmente, você pode utilizar a função recode() dentro da função mutate().\nImagine que haja uma data sem sentido nos dados (por exemplo, “2014-14-15”): você poderia fixar a data manualmente nos dados da fonte bruta, ou, você poderia escrever a alteração no pipe de limpeza via mutate() e recode(). Esta última é mais transparente e reprodutível para qualquer outra pessoa que procure entender ou repetir sua análise.\n\n# corrigir valores incorretos          # valor velho       # valor novo\nlinelist &lt;- linelist %&gt;% \n  mutate(date_onset = recode(date_onset, \"2014-14-15\" = \"2014-04-15\"))\n\nA linha mutate() acima pode ser lida como: “mude a coluna date_onset para igualar a coluna date_onset re-codificada para que o VALOR VELHO seja alterado para o NOVO VALOR”. Note que este padrão (VELHO = NOVO) para recode() é o oposto da maioria dos padrões de R (novo = velho). A comunidade de desenvolvedores do R está trabalhando na revisão deste padrão.\nAqui está outro exemplo de recodificação de múltiplos valores dentro de uma coluna.\nNa linelist os valores dna coluna “hospital” devem ser limpos. Há várias grafias diferentes e muitos valores em falta.\n\ntable(linelist$hospital, useNA = \"always\")  # imprimir tabela de todos os valores únicos, incluindo os que faltam\n\n\n                     Central Hopital                     Central Hospital \n                                  11                                  457 \n                          Hospital A                           Hospital B \n                                 290                                  289 \n                    Military Hopital                    Military Hospital \n                                  32                                  798 \n                    Mitylira Hopital                    Mitylira Hospital \n                                   1                                   79 \n                               Other                         Port Hopital \n                                 907                                   48 \n                       Port Hospital St. Mark's Maternity Hospital (SMMH) \n                                1756                                  417 \n  St. Marks Maternity Hopital (SMMH)                                 &lt;NA&gt; \n                                  11                                 1512 \n\n\nO comando recode() abaixo re-define a coluna “hospital” como a coluna atual “hospital”, mas com a recodificação especificada muda. Não esqueça as vírgulas depois de cada uma!\n\nlinelist &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital,\n                     # for reference: OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      ))\n\nAgora vemos que as grafias na coluna ‘hospitalar’ foram corrigidas e consolidadas:\n\ntable(linelist$hospital, useNA = \"always\")\n\n\n                    Central Hospital                           Hospital A \n                                 468                                  290 \n                          Hospital B                    Military Hospital \n                                 289                                  910 \n                               Other                        Port Hospital \n                                 907                                 1804 \nSt. Mark's Maternity Hospital (SMMH)                                 &lt;NA&gt; \n                                 428                                 1512 \n\n\n[DICA: O número de espaços antes e depois de um sinal de igual não importa. Torne seu código mais fácil de ler, alinhando-o = para todas ou para a maioria das linhas. Além disso, considere acrescentar uma linha de comentários em destaque para esclarecer aos futuros leitores qual lado é VELHO e qual lado é NOVO.] {style=“color: darkgreen;”}\nDICA: Às vezes existe um valor de caractere em branco em um conjunto de dados (não reconhecido como o valor de R por ausente - NA). Você pode referenciar este valor com duas aspas sem espaço intermediário\n\n\nPela lógica\nA seguir demonstramos como recodificar valores em uma coluna usando lógica e condições:\n\nUtilizando replace(), ifelse() e if_else() para uma lógica simples\nUtilizando case_when() para uma lógica mais complexa\n\n\n\nLógica simples\n\nreplace()\nPara re-codificar com critérios lógicos simples, você pode utilizar replace() dentro de mutate(). replace() é uma função do R base. Utilize uma condição lógica para especificar as linhas a serem alteradas . A sintaxe geral é:\nmutate(col_to_change = replace(col_to_change, critério para linhas, new value)).\nUma situação comum para utilizar replace() é alterar apenas um valor em uma linha, utilizando um identificador único de linha. Abaixo, o gênero é alterado para “Female” (Feminino) na linha onde a coluna case_id é “2195”.\n\n#  Exemplo: mudar o gênero de uma observação específica para  \"Female\" (Feminino).  \nlinelist &lt;- linelist %&gt;% \n  mutate(gender = replace(gender, case_id == \"2195\", \"Female\"))\n\nO comando equivalente utilizando a síntaxe do R base e colchetes indexadores [ ] está abaixo. Ele é lido como “Alterar o valor da coluna gender do dataframe linelist (para as linhas onde a coluna case_id do linelist tem o valor de ‘2195’) para ‘Female’”.\n\nlinelist$gender[linelist$case_id == \"2195\"] &lt;- \"Female\"\n\n\n\nifelse() e if_else()\nOutra ferramenta de lógica simples é ifelse() e seu parceiro if_else(). Entretanto, na maioria dos casos para re-codificação é mais claro utilizar case_when() (detalhado abaixo). Estes comandos “if else” são versões simplificadas de uma declaração de programação if e else. A sintaxe geral é:\nifelse(condição, valor para retornar se a condição avlia se  TRUE, valor para retornar se a condição avaliada é FALSE)\nAbaixo, a coluna definida source_known é definida. Seu valor em uma determinada linha é definido como “conhecido” se o valor da linha na coluna source não estiver faltando. Se o valor em source está faltando, então o valor em source_known está definido como “desconhecido”.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(source_known = ifelse(!is.na(source), \"known\", \"unknown\"))\n\nif_else() é uma versão especial de dplyr que manipula datas. Observe que se o valor ‘verdadeiro’ é uma data, o valor ‘falso’ também deve qualificar uma data, portanto, utilizando o valor especial NA_real_ em vez de apenas NA.\n\n#  Criar uma coluna de data de morte, que é NA, se o paciente não tiver morrido.\nlinelist &lt;- linelist %&gt;% \n  mutate(date_death = if_else(outcome == \"Death\", date_outcome, NA_real_))\n\nEvitar a junção de muitos comandos ifelse… use case_when() ao invés disso! case_when() é muito mais fácil de ler e você cometerá menos erros.\n\n\n\n\n\n\n\n\n\nFora do contexto de um data frame, se você quiser que um objeto utilizado em seu código mude seu valor, considere utilizar switch() do R base.\n\n\n\nLógica complexa\nUse ocase_when() do dplyr se você estiver recodificando em muitos grupos novos, ou se você precisar utilizar declarações lógicas complexas para recodificar valores. Esta função avalia cada linha no data frame, avalia se as linhas atendem aos critérios especificados e atribui o novo valor correto.\nOs comandos case_when() consistem de declarações que têm um Lado Direito (RHS, de Right-Hand Side em inglês) e um Lado Esquerdo (LHS, Left-Hand Side em inglês) separados por um “til” ~. Os critérios lógicos estão no lado esquerdo e os valores de ajuste estão no lado direito de cada afirmação. As afirmações são separadas por vírgulas.\nPor exemplo, aqui utilizamos as colunas age e age_unit para criar uma coluna age_years:\n\nlinelist &lt;- linelist %&gt;% \n  mutate(age_years = case_when(\n            age_unit == \"years\"  ~ age,       # se a idade for dada em anos\n            age_unit == \"months\" ~ age/12,    # se a idade for dada em meses\n            is.na(age_unit)      ~ age))       # se falta a unidade de idade, suponha anos) \n                                             # qualquer outra circunstância, atribui NA (falta)\n\nComo cada linha dos dados é avaliado, os critérios são aplicados/avaliados na ordem em que as declaraçõe case_when() são escritos - de cima para baixo. Se o critério de cima avaliar TRUE para uma dada linha, o valor RHS é atribuído, e os critérios restantes não são sequer testados para essa linha. Assim, é melhor escrever primeiro os critérios mais específicos, e por último os mais gerais.\nNesta linha, em sua declaração final, coloque TRUE no lado esquerdo, que captará qualquer linha que não atenda a nenhum dos critérios anteriores. Ao lado direito desta declaração pode ser atribuído um valor como “checar!” ou perda.\nPERIGO: Valores no lado direito devem ser todos na mesma classe - seja numérico, caractere, data, lógico, etc. Para atribuir valores em falta (NA), você talvez necessite usar as variações especiais de NA como NA_character_, NA_real_ (para numérico ou POSIX), e as.Date(NA). Leia mais em Trabalhando com datas.\n\n\nValores faltantes\nAbaixo estão as funções especiais para manipular valores ausentes no contexto da limpeza de dados.\nVeja a página em Campos em branco/faltantes para dicas mais detahadas sobre como identificas e tratar os valores ausentes. Por exemplo, a função is.na()que logicamente testa a falta de dados.\nreplace_na()\nPara alterar valores ausentes (NA) para um valor específico, como “Ausente”, use a função dplyr replace_na() dentro de mutate(). Observe que isto é utilizado da mesma forma que a recode acima - o nome da variável deve ser repetida dentro de replace_na().\n\nlinelist &lt;- linelist %&gt;% \n  mutate(hospital = replace_na(hospital, \"Ausente\"))\n\nfct_explicit_na()\nEsta é uma função do pacote forcats. O pacote forcats manipula colunas de classe Fator. Fatores são a forma do R manipular valores ordenados tais como c(\"Primeiro\", \"Segundo\", \"Terceiro\") ou para definir a ordem em que os valores (por exemplo, hospitais) aparecem em tabelas e gráficos. Veja a página de Fatores.\nSe seus dados forem de classe Fator e você tentar converter NA para “Ausente” utilizando replace_na(), você receberá este erro: invalid factor level, NA generated. Você tentou adicionar “Ausente” como um valor, quando este não foi definido como um nível possível do fator, e ele foi rejeitado.\nA maneira mais fácil de resolver isto é utilizar a função de forcats fct_explicit_na() que converte uma coluna para a classe fator, e converte os valores NA para o caractere “(Missing)” (Ausente/Faltante).\n\nlinelist %&gt;% \n  mutate(hospital = fct_explicit_na(hospital))\n\nUma alternativa mais lenta seria adicionar o nível do fator utilizando fct_expand() e então converter os valores ausentes.\nna_if()\nPara converter um valor específico para NA, use na_if() do dplyr. O comando abaixo executa a operação oposta de replace_na(). No exemplo abaixo, quaisquer valores de “Ausente” na coluna hospital são convertidas para NA.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(hospital = na_if(hospital, \"Missing\"))\n\nObserve: na_if() não pode ser usado para critérios lógicos (por ex., “todos os valores &gt; 99”) - use replace() ou case_when() para isso:\n\n# Converta temperaturas acima de 40 para NA \nlinelist &lt;- linelist %&gt;% \n  mutate(temp = replace(temp, temp &gt; 40, NA))\n\n# Converta as datas de início antes de 1 de janeiro de 2000 em ausente\nlinelist &lt;- linelist %&gt;% \n  mutate(date_onset = replace(date_onset, date_onset &gt; as.Date(\"2000-01-01\"), NA))\n\n\n\nDicionário de limpeza\nUtilize o pacote matchmaker do R e sua função match_df() para limpar um data frame com um dicionário de limpeza.\n\nCriar um dicionário de limpeza com 3 colunas:\n\nUma coluna “de” (o valor incorreto)\n\nUma coluna “para” (o valor correto)\n\nUma coluna especificando a coluna para as mudanças a serem aplicadas (ou “.global” para aplicar a todas as colunas)\n\n\nNote: As entradas do dicionário .global serão substituídas por entradas de dicionário específicas de coluna\n\n\n\n\n\n\n\n\n\n\nImportar o arquivo do dicionário para R. Este exemplo pode ser baixado através das instruções na página Baixar manual e dados.\n\n\ncleaning_dict &lt;- import(\"cleaning_dict.csv\")\n\n\nPasse a linelist bruta para match_df(), especificando para dictionary = o data frame do dicionário de limpeza. O argumento from = deve ter o nome da coluna que ontem os valores “antigos”, o argumento by = deve ser a coluna do dicionário que contem os valores “novos”, e o terceiro argumento lista a coluna sobre a qual fazer a mudança.\n\nLeia mais sobre em package documentation digitando ?match_df no console. Note que essa função pode demorar um tempo longo de execução em uma base de dados grande.\n\nlinelist &lt;- linelist %&gt;%     # sua base de dados\n     matchmaker::match_df(\n          dictionary = cleaning_dict,  # nome do dicionário\n          from = \"from\",               # coluna com as variáveis a serem substituidas (o padrão é a col 1)\n          to = \"to\",                   # coluna ocm os valores finais (padrão é col 2)\n          by = \"col\"                   # coluna com nome de colunas (padrão é col 3)\n  )\n\nAgora role para a direita para ver como os valores mudaram - particularmente gender (de minúsculas para maiúsculas), e todas as colunas de sintomas foram transformadas de sim/não para 1/0.\n\n\n\n\n\n\nObserve que os nomes das colunas no dicionário de limpeza devem corresponder aos nomes neste ponto do seu script de limpeza. Veja esta referência online para o pacote linelist para obter mais detalhes.\n\nAdicione a cadeia pipe\nAbaixo, algumas novas colunas e transformações de colunas são adicionadas à cadeia pipe.\n\n# CADEIA 'PIPE' DE LIMPEZA\n# inicia com dados brutos e canaliza-os através de etapas de limpeza)\n##################################################################################\n\n# inicie a cadeia pipe de limpeza\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # padronize a sintaxe do nome da coluna\n    janitor::clean_names() %&gt;% \n    \n    # renomeie as colunas manualmente\n           # NOVO nome             # nome VELHO\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # remova coluna\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # remova duplicidade\n    distinct() %&gt;% \n  \n    # adicione colunas\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %&gt;%     \n\n    # converta classe de colunas\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %&gt;% \n    \n    # adicione coluna: demora para internação\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %&gt;% \n    \n   # ACIMA ESTÃO AS ETAPAS DE LIMPEZA A MONTANTE JÁ DISCUTIDAS\n   ###################################################\n\n    # limpe valores da coluna do hospital\n    mutate(hospital = recode(hospital,\n                      # OLD = NEW\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %&gt;% \n    \n    mutate(hospital = replace_na(hospital, \"Missing\")) %&gt;% \n\n    # crie a coluna age_years (de age e age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_))",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Limpeza de dados e principais funções</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.pt.html#num_cats",
    "href": "new_pages/cleaning.pt.html#num_cats",
    "title": "8  Limpeza de dados e principais funções",
    "section": "8.9 Categorias numéricas",
    "text": "8.9 Categorias numéricas\nAqui descrevemos algumas abordagens especiais para criar categorias a partir de colunas numéricas. Exemplos comuns incluem categorias de idade, grupos de valores de laboratório, etc. Aqui vamos discutir:\n\nage_categories(), do pacote epikit\n\ncut(), do R base\n\ncase_when()\n\nquebras de quantis com quantile() e ntile()\n\n\nDistribuição de comentários\nPara este exemplo, nós vamos criar uma coluna age_cat usando a coluna age_years.\n\n# Verifique a classe da variável da linelist age\nclass(linelist$age_years)\n\n[1] \"numeric\"\n\n\nPrimeiro, examine a distribuição de seus dados, para fazer os pontos de corte apropriados. Veja a página sobre Básico do ggplot.\n\n# examine a distribuição\nhist(linelist$age_years)\n\n\n\n\n\n\n\n\n\nsummary(linelist$age_years, na.rm=T)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00    6.00   13.00   16.04   23.00   84.00     107 \n\n\nCUIDADO: Às vezes, variáveis numéricas serão importadas como classe “character”. Isso ocorre se houver caracteres não numéricos em alguns dos valores, por exemplo, uma entrada de “2 meses” para idade ou (dependendo das configurações locais do R) se uma vírgula for usada na casa decimal (por exemplo, “4,5” para significar quatro anos e meio)..\n\n\n\nage_categories()\nCom o pacote epikit, você pode usar a função age_categories() fpara categorizar e rotular facilmente colunas numéricas (observação: esta função também pode ser aplicada a variáveis numéricas que não sejam de idade). Como bônus, a coluna de saída é automaticamente um fator ordenado.\nAqui estão as entradas necessárias:\n\nUm vetor numérico (coluna)\n\nO argumento breakers = - fornece um vetor numérico de pontos de interrupção para os novos grupos\n\nPrimeiro, o exemplo mais simples:\n\n# Exemplo simples\n################\npacman::p_load(epikit)                    # carregue pacote\n\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = age_categories(             # crie nova coluna\n      age_years,                            # coluna numérica para fazer grupos de\n      breakers = c(0, 5, 10, 15, 20,        # pontos de quebra\n                   30, 40, 50, 60, 70)))\n\n# show table\ntable(linelist$age_cat, useNA = \"always\")\n\n\n  0-4   5-9 10-14 15-19 20-29 30-39 40-49 50-59 60-69   70+  &lt;NA&gt; \n 1227  1223  1048   827  1216   597   251    78    27     7   107 \n\n\nOs valores de quebra que você especifica são, por padrão, os limites inferiores - ou seja, eles são incluídos no grupo “superior” / os grupos são “abertos” no lado inferior/esquerdo. Conforme mostrado abaixo, você pode adicionar 1 a cada valor de quebra para obter grupos abertos na parte superior/direita.\n\n# Incluir extremidades superiores para as mesmas categorias\n############################################\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      breakers = c(0, 6, 11, 16, 21, 31, 41, 51, 61, 71)))\n\n# Mostre tabela\ntable(linelist$age_cat, useNA = \"always\")\n\n\n  0-5  6-10 11-15 16-20 21-30 31-40 41-50 51-60 61-70   71+  &lt;NA&gt; \n 1469  1195  1040   770  1149   547   231    70    24     6   107 \n\n\nVocê pode ajustar como os rótulos são exibidos com separator =. O padrão é “-”\nVocê pode ajustar como os números superiores são tratados, com o argumento ceiling =. Para definir um limite superior, defina ceiling = TRUE. Neste uso, o valor de quebra mais alto fornecido é um “teto” e uma categoria “XX+” não é criada. Quaisquer valores acima do valor de quebra mais alto (ou para upper =, se definido) são categorizados como NA. Abaixo está um exemplo com ceiling = TRUE, para que não haja categoria de XX+ e valores acima de 70 (o maior valor de quebra) sejam atribuídos como NA.\n\n# Com teto definido para TRUE\n##########################\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70),\n      ceiling = TRUE)) # 70 is ceiling, all above become NA\n\n# Mostre a tabela\ntable(linelist$age_cat, useNA = \"always\")\n\n\n  0-4   5-9 10-14 15-19 20-29 30-39 40-49 50-59 60-70  &lt;NA&gt; \n 1227  1223  1048   827  1216   597   251    78    28   113 \n\n\nAlternativamente, em vez de breakers =, você pode fornecer todos de lower =, upper =, e by =:\n\nlower = O número mais baixo que você quer considerar - o padrão é 0\n\nupper = O número mais alto que você quer considerar\n\nby = O número de anos entre grupos\n\n\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = age_categories(\n      age_years, \n      lower = 0,\n      upper = 100,\n      by = 10))\n\n# Mostre a tabela\ntable(linelist$age_cat, useNA = \"always\")\n\n\n  0-9 10-19 20-29 30-39 40-49 50-59 60-69 70-79 80-89 90-99  100+  &lt;NA&gt; \n 2450  1875  1216   597   251    78    27     6     1     0     0   107 \n\n\nVeja a página de Ajuda da função para mais detalhes (digite ?age_categories no console do R).\n\n\n\ncut()\ncut() é uma alternativa do R base para age_categories(), mas eu acho que você verá porque age_categories() foi desenvolvida para simplificar este processo. Algumas diferenças notáveis da age_categories() são:\n\nVocê não precisa instalar/carregar outro pacote\n\nVocê pode especificar se os grupos estão abertos/fechados à direita/esquerda\n\nVocê mesmo deve fornecer etiquetas precisas\n\nSe você quiser 0 incluído no grupo mais baixo, você deve especificar isso\n\nA sintaxe básica dentro de cut() é fornecer primeiro a coluna numérica a ser cortada (age_years), e então o argumento breaks, que é um vetor numérico c() de pontos de quebra. Usando cut(), a coluna resultante é um fator ordenado.\nPor padrão, a categorização ocorre de forma que o lado direito/superior seja “aberto” e inclusivo (e o lado esquerdo/inferior seja “fechado” ou exclusivo). Este é o comportamento oposto da função age_categories(). Os rótulos padrão usam a notação “(A, B]”, o que significa que A não está incluído, mas B sim. Inverta esse comportamento fornecendo o argumento right = TRUE.\nAssim, por padrão, os valores “0” são excluídos do grupo mais baixo e categorizados como NA! Os valores “0” podem ser bebês codificados como 0, então tenha cuidado! Para alterar isso, adicione o argumento include.lowest = TRUE para que qualquer valor “0” seja incluído no grupo mais baixo. O rótulo gerado automaticamente para a categoria mais baixa será “[A],B]”. Observe que se você incluir o argumento include.lowest = TRUE e right = TRUE, a inclusão extrema agora será aplicada ao valor e categoria do ponto de quebra mais alto, não ao mais baixo.\nVocê pode fornecer um vetor de rótulos personalizados usando o argumento labels =. Como estes são escritos manualmente, tenha muito cuidado para garantir que eles sejam precisos! Verifique seu trabalho usando tabulação cruzada, conforme descrito abaixo.\nUm exemplo de cut() aplicado a age_years para fazer a nova variável age_cat está abaixo:\n\n# Crie a nova variável, pelo corte da variável numérica age \n# quebra inferior é excluída, mas quebra superior é incluída em cada categoria\nlinelist &lt;- linelist %&gt;% \n  mutate(\n    age_cat = cut(\n      age_years,\n      breaks = c(0, 5, 10, 15, 20,\n                 30, 50, 70, 100),\n      include.lowest = TRUE         # inclua 0 no grupo mais baixo\n      ))\n\n# tabule o número de observaçõs por grupo\ntable(linelist$age_cat, useNA = \"always\")\n\n\n   [0,5]   (5,10]  (10,15]  (15,20]  (20,30]  (30,50]  (50,70] (70,100] \n    1469     1195     1040      770     1149      778       94        6 \n    &lt;NA&gt; \n     107 \n\n\nVerifique seu trabalho!!! Verifique se cada valor de idade foi atribuído à categoria correta fazendo uma tabulação cruzada das colunas numéricas e de categoria. Examine a atribuição de valores de limite (por exemplo, 15, se as categorias vizinhas forem 10-15 e 16-20).\n\n# Tabulação cruzada das colunas numéricas e de categoria. \ntable(\"Numeric Values\" = linelist$age_years,   # nomes especificados na tabela para maior clareza.\n      \"Categories\"     = linelist$age_cat,\n      useNA = \"always\")                        # não esqueça de examinar os valores NA\n\n                    Categories\nNumeric Values       [0,5] (5,10] (10,15] (15,20] (20,30] (30,50] (50,70]\n  0                    136      0       0       0       0       0       0\n  0.0833333333333333     1      0       0       0       0       0       0\n  0.25                   2      0       0       0       0       0       0\n  0.333333333333333      6      0       0       0       0       0       0\n  0.416666666666667      1      0       0       0       0       0       0\n  0.5                    6      0       0       0       0       0       0\n  0.583333333333333      3      0       0       0       0       0       0\n  0.666666666666667      3      0       0       0       0       0       0\n  0.75                   3      0       0       0       0       0       0\n  0.833333333333333      1      0       0       0       0       0       0\n  0.916666666666667      1      0       0       0       0       0       0\n  1                    275      0       0       0       0       0       0\n  1.5                    2      0       0       0       0       0       0\n  2                    308      0       0       0       0       0       0\n  3                    246      0       0       0       0       0       0\n  4                    233      0       0       0       0       0       0\n  5                    242      0       0       0       0       0       0\n  6                      0    241       0       0       0       0       0\n  7                      0    256       0       0       0       0       0\n  8                      0    239       0       0       0       0       0\n  9                      0    245       0       0       0       0       0\n  10                     0    214       0       0       0       0       0\n  11                     0      0     220       0       0       0       0\n  12                     0      0     224       0       0       0       0\n  13                     0      0     191       0       0       0       0\n  14                     0      0     199       0       0       0       0\n  15                     0      0     206       0       0       0       0\n  16                     0      0       0     186       0       0       0\n  17                     0      0       0     164       0       0       0\n  18                     0      0       0     141       0       0       0\n  19                     0      0       0     130       0       0       0\n  20                     0      0       0     149       0       0       0\n  21                     0      0       0       0     158       0       0\n  22                     0      0       0       0     149       0       0\n  23                     0      0       0       0     125       0       0\n  24                     0      0       0       0     144       0       0\n  25                     0      0       0       0     107       0       0\n  26                     0      0       0       0     100       0       0\n  27                     0      0       0       0     117       0       0\n  28                     0      0       0       0      85       0       0\n  29                     0      0       0       0      82       0       0\n  30                     0      0       0       0      82       0       0\n  31                     0      0       0       0       0      68       0\n  32                     0      0       0       0       0      84       0\n  33                     0      0       0       0       0      78       0\n  34                     0      0       0       0       0      58       0\n  35                     0      0       0       0       0      58       0\n  36                     0      0       0       0       0      33       0\n  37                     0      0       0       0       0      46       0\n  38                     0      0       0       0       0      45       0\n  39                     0      0       0       0       0      45       0\n  40                     0      0       0       0       0      32       0\n  41                     0      0       0       0       0      34       0\n  42                     0      0       0       0       0      26       0\n  43                     0      0       0       0       0      31       0\n  44                     0      0       0       0       0      24       0\n  45                     0      0       0       0       0      27       0\n  46                     0      0       0       0       0      25       0\n  47                     0      0       0       0       0      16       0\n  48                     0      0       0       0       0      21       0\n  49                     0      0       0       0       0      15       0\n  50                     0      0       0       0       0      12       0\n  51                     0      0       0       0       0       0      13\n  52                     0      0       0       0       0       0       7\n  53                     0      0       0       0       0       0       4\n  54                     0      0       0       0       0       0       6\n  55                     0      0       0       0       0       0       9\n  56                     0      0       0       0       0       0       7\n  57                     0      0       0       0       0       0       9\n  58                     0      0       0       0       0       0       6\n  59                     0      0       0       0       0       0       5\n  60                     0      0       0       0       0       0       4\n  61                     0      0       0       0       0       0       2\n  62                     0      0       0       0       0       0       1\n  63                     0      0       0       0       0       0       5\n  64                     0      0       0       0       0       0       1\n  65                     0      0       0       0       0       0       5\n  66                     0      0       0       0       0       0       3\n  67                     0      0       0       0       0       0       2\n  68                     0      0       0       0       0       0       1\n  69                     0      0       0       0       0       0       3\n  70                     0      0       0       0       0       0       1\n  72                     0      0       0       0       0       0       0\n  73                     0      0       0       0       0       0       0\n  76                     0      0       0       0       0       0       0\n  84                     0      0       0       0       0       0       0\n  &lt;NA&gt;                   0      0       0       0       0       0       0\n                    Categories\nNumeric Values       (70,100] &lt;NA&gt;\n  0                         0    0\n  0.0833333333333333        0    0\n  0.25                      0    0\n  0.333333333333333         0    0\n  0.416666666666667         0    0\n  0.5                       0    0\n  0.583333333333333         0    0\n  0.666666666666667         0    0\n  0.75                      0    0\n  0.833333333333333         0    0\n  0.916666666666667         0    0\n  1                         0    0\n  1.5                       0    0\n  2                         0    0\n  3                         0    0\n  4                         0    0\n  5                         0    0\n  6                         0    0\n  7                         0    0\n  8                         0    0\n  9                         0    0\n  10                        0    0\n  11                        0    0\n  12                        0    0\n  13                        0    0\n  14                        0    0\n  15                        0    0\n  16                        0    0\n  17                        0    0\n  18                        0    0\n  19                        0    0\n  20                        0    0\n  21                        0    0\n  22                        0    0\n  23                        0    0\n  24                        0    0\n  25                        0    0\n  26                        0    0\n  27                        0    0\n  28                        0    0\n  29                        0    0\n  30                        0    0\n  31                        0    0\n  32                        0    0\n  33                        0    0\n  34                        0    0\n  35                        0    0\n  36                        0    0\n  37                        0    0\n  38                        0    0\n  39                        0    0\n  40                        0    0\n  41                        0    0\n  42                        0    0\n  43                        0    0\n  44                        0    0\n  45                        0    0\n  46                        0    0\n  47                        0    0\n  48                        0    0\n  49                        0    0\n  50                        0    0\n  51                        0    0\n  52                        0    0\n  53                        0    0\n  54                        0    0\n  55                        0    0\n  56                        0    0\n  57                        0    0\n  58                        0    0\n  59                        0    0\n  60                        0    0\n  61                        0    0\n  62                        0    0\n  63                        0    0\n  64                        0    0\n  65                        0    0\n  66                        0    0\n  67                        0    0\n  68                        0    0\n  69                        0    0\n  70                        0    0\n  72                        1    0\n  73                        3    0\n  76                        1    0\n  84                        1    0\n  &lt;NA&gt;                      0  107\n\n\nRotule novamente os valores NA\nVocê pode querer atribuir a valores NA um rótulo tal como “Ausente”. Como a nova coluna é de classe Fator (valores restritos), você não pode simplesmente mudá-la com replace_na(), pois este valor será rejeitado. Em vez disso, utilize fct_explicit_na() de forcats, como explicado na página Fatores.\n\nlinelist &lt;- linelist %&gt;% \n  \n  # cut() cria age_cat, automaticamente da classe Fator     \n  mutate(age_cat = cut(\n    age_years,\n    breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          \n    right = FALSE,\n    include.lowest = TRUE,        \n    labels = c(\"0-4\", \"5-9\", \"10-14\", \"15-19\", \"20-29\", \"30-49\", \"50-69\", \"70-100\")),\n         \n    # tornar explícitos os valores ausentes\n    age_cat = fct_explicit_na(\n      age_cat,\n      na_level = \"Idade Ausente\")  # você pode especificar o rótulo\n  )    \n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `age_cat = fct_explicit_na(age_cat, na_level = \"Idade\n  Ausente\")`.\nCaused by warning:\n! `fct_explicit_na()` was deprecated in forcats 1.0.0.\nℹ Please use `fct_na_value_to_level()` instead.\n\n# tabela para ver contagens\ntable(linelist$age_cat, useNA = \"always\")\n\n\n          0-4           5-9         10-14         15-19         20-29 \n         1227          1223          1048           827          1216 \n        30-49         50-69        70-100 Idade Ausente          &lt;NA&gt; \n          848           105             7           107             0 \n\n\nFazer quebras e rótulos rapidamente\nPara uma maneira rápida de fazer quebras e rotular vetores, use algo como abaixo. Veja a página Introdução do R para referências em seq() e rep().\n\n# Fazer pontos de quebra de 0 a 90 por 5\nage_seq = seq(from = 0, to = 90, by = 5)\nage_seq\n\n# Fazer etiquetas para as categorias acima, assumindo as configurações padrão de cut()\nage_labels = paste0(age_seq + 1, \"-\", age_seq + 5)\nage_labels\n\n#  verificar se ambos os vetores têm o mesmo comprimento\nlength(age_seq) == length(age_labels)\n\nLeia mais sobre cut() em sua página de Ajuda entrando em ?cut no console R\n\n\nQuebrar por quantil\nNo entendimento comum, “quantis” ou “percentis” normalmente se referem a um valor abaixo do qual uma proporção de valores está contida. Por exemplo, o 95º percentil de idades dessa linelist seria a idade abaixo da qual estão 95% dos valores de idade.\nNo entanto, na fala comum, “quartis” e “decis” também podem se referir aos grupos de dados igualmente divididos em 4 ou 10 grupos (observe que haverá mais um ponto de quebra do que grupo).\nPara obter pontos de quebra de quantil, você pode usar quantile() do pacote stats do R base. Você fornece um vetor numérico (por exemplo, uma coluna em um conjunto de dados) e um vetor de valores numéricos de probabilidade variando de 0 a 1,0. Os pontos de interrupção são retornados como um vetor numérico. Explore os detalhes das metodologias estatísticas inserindo ?quantile.\n\nSe o seu vetor numérico de entrada tiver algum valor ausente, é melhor definir na.rm = TRUE\n\nDefina names = FALSE para obter um vetor numérico sem nome\n\n\nquantile(linelist$age_years,               # especifique o vetor numérico para trabalhar nele\n  probs = c(0, .25, .50, .75, .90, .95),   # especifique os percentis que você quer\n  na.rm = TRUE)                            # ignore os valores ausentes \n\n 0% 25% 50% 75% 90% 95% \n  0   6  13  23  33  41 \n\n\nVocê pode usar os resultados de quantile() como pontos de quebra em age_categories() ou cut(). Abaixo nós criamos uma nova coluna deciles usando cut() onde as quebras são definidas usando quantiles() em age_years. Abaixo, nós exibimos os resultados usando tabyl() do janitor para que você possa ver as porcentagens (consulte a página Tabelas descritivas ). Observe como eles não são exatamente 10% em cada grupo.\n\nlinelist %&gt;%                                # inicie com linelist\n  mutate(deciles = cut(age_years,           # crie a nova coluna decile como cut() da coluna age_years\n    breaks = quantile(                      # defina as quebras usando quantile()\n      age_years,                               # opere em age_years\n      probs = seq(0, 1, by = 0.1),             # de 0.0 a 1.0 a cada 0.1\n      na.rm = TRUE),                           # ignore os valores ausentes\n    include.lowest = TRUE)) %&gt;%             # para cut() incluir idade 0\n  janitor::tabyl(deciles)                   # pipe para a tabela ser exibida\n\n deciles   n    percent valid_percent\n   [0,2] 748 0.11319613    0.11505922\n   (2,5] 721 0.10911017    0.11090601\n   (5,7] 497 0.07521186    0.07644978\n  (7,10] 698 0.10562954    0.10736810\n (10,13] 635 0.09609564    0.09767728\n (13,17] 755 0.11425545    0.11613598\n (17,21] 578 0.08746973    0.08890940\n (21,26] 625 0.09458232    0.09613906\n (26,33] 596 0.09019370    0.09167820\n (33,84] 648 0.09806295    0.09967697\n    &lt;NA&gt; 107 0.01619249            NA\n\n\n\n\nGrupos de tamanho uniforme\nOutra ferramenta para fazer grupos numéricos é a função ntile() do dplyr , que tenta dividir seus dados em n grupos de tamanho uniforme - mas esteja ciente de que diferente com quantile() o mesmo valor pode aparecer em mais de um grupo. Forneça o vetor numérico e, em seguida, o número de grupos. Os valores na nova coluna criada são apenas “números” do grupo (por exemplo, 1 a 10), não o intervalo de valores em si, como ao usar cut().\n\n# faça grupos com ntile()\nntile_data &lt;- linelist %&gt;% \n  mutate(even_groups = ntile(age_years, 10))\n\n# faça uma tabela de contagem e proporções por grupo\nntile_table &lt;- ntile_data %&gt;% \n  janitor::tabyl(even_groups)\n  \n# fixe os valores mín/máx para demonstrar as faixas\nntile_ranges &lt;- ntile_data %&gt;% \n  group_by(even_groups) %&gt;% \n  summarise(\n    min = min(age_years, na.rm=T),\n    max = max(age_years, na.rm=T)\n  )\n\nWarning: There were 2 warnings in `summarise()`.\nThe first warning was:\nℹ In argument: `min = min(age_years, na.rm = T)`.\nℹ In group 11: `even_groups = NA`.\nCaused by warning in `min()`:\n! no non-missing arguments to min; returning Inf\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\n# combine e \"printe\" - note que valores estão presentes em múltiplos grupos\nleft_join(ntile_table, ntile_ranges, by = \"even_groups\")\n\n even_groups   n    percent valid_percent min  max\n           1 651 0.09851695    0.10013844   0    2\n           2 650 0.09836562    0.09998462   2    5\n           3 650 0.09836562    0.09998462   5    7\n           4 650 0.09836562    0.09998462   7   10\n           5 650 0.09836562    0.09998462  10   13\n           6 650 0.09836562    0.09998462  13   17\n           7 650 0.09836562    0.09998462  17   21\n           8 650 0.09836562    0.09998462  21   26\n           9 650 0.09836562    0.09998462  26   33\n          10 650 0.09836562    0.09998462  33   84\n          NA 107 0.01619249            NA Inf -Inf\n\n\n\n\n\ncase_when()\nÉ possível utilizar a função case_when() do dplyr para criar categorias a partir de uma coluna numérica, mas é mais fácil utilizar age_categories() do epikit ou cut() porque estas criarão automaticamente um fator ordenado.\nSe utilizar case_when(), por favor, revise o uso apropriado conforme descrito anteriormente na seção recodificar valores desta página. Esteja ciente também que todos os valores do lado direito devem ser da mesma classe. Assim, se você quiser NA no lado direito, você deve escrever “Ausente” ou utilizar o valor NA especial NA_character_.\n\n\nAdicionar à cadeia pipe\nAbaixo, é adicionado o código para criar duas colunas de idade categóricas à cadeia pipe de limpeza:\n\n# CADEIA DE LIMPEZA 'PIPE' \n# (inicie com dados brutos e canalize-os através de etapas de limpeza)\n##################################################################################\n\n# inicie a cadeia pipe de limpeza\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # padronize a sintaxe do nome da coluna\n    janitor::clean_names() %&gt;% \n    \n    # renomeie as colunas manualmente\n           # NOVO nome             # nome VELHO\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # remova coluna\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # remova as duplicidades\n    distinct() %&gt;% \n\n    # adicione coluna\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %&gt;%     \n\n    # converta classe de colunas\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %&gt;% \n    \n    # adicione coluna: demora para internação\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %&gt;% \n    \n    # limpe valores da coluna do hospital\n    mutate(hospital = recode(hospital,\n                      # VELHO = NOVO\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %&gt;% \n    \n    mutate(hospital = replace_na(hospital, \"Ausente\")) %&gt;% \n\n    # crie a coluna age_years (de age e age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_)) %&gt;% \n  \n    # ACIMA ESTÃO AS ETAPAS DE LIMPEZA A MONTANTE JÁ DISCUTIDAS\n    ###################################################   \n    mutate(\n          # categorias de idade:personalizado\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # categorias etárias: 0 a 85 por 5s\n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Limpeza de dados e principais funções</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.pt.html#adicionar-linhas",
    "href": "new_pages/cleaning.pt.html#adicionar-linhas",
    "title": "8  Limpeza de dados e principais funções",
    "section": "8.10 Adicionar linhas",
    "text": "8.10 Adicionar linhas\n\nUma-por-uma\nAdicionar linhas uma-por-uma manualmente é tediosa mas pode ser feito com add_row() do dplyr. Relembre que cada coluna deve conter valores de apenas uma classe (seja caracter, numérico, lógico, etc.). Então adicionar uma linha reque detalhes para manter isso.\n\nlinelist &lt;- linelist %&gt;% \n  add_row(row_num = 666,\n          case_id = \"abc\",\n          generation = 4,\n          `infection date` = as.Date(\"2020-10-10\"),\n          .before = 2)\n\nUtilize .before e .after. para especificar a colocação da linha que você deseja adicionar. .before = 3colocará a nova linha antes da 3ª linha atual. O comportamento padrão é adicionar a linha ao final. As colunas não especificadas serão deixadas vazias (NA).\nO novo número da linha pode parecer estranho (“…23”), mas os números das linhas preexistentes mudaram. Portanto, se utilizar o comando duas vezes, examine/teste a inserção cuidadosamente.\nSe uma classe que você fornece estiver desligada, você verá um erro como este:\nErro: Não é possível combinar ..1$infection date &lt;date&gt; e ..2$infection date &lt;character&gt;. \n(ao inserir uma linha com um valor de data, lembre-se de embrulhar a data na função as.Date() como as.Date(\"2020-10-10\")).\n\n\nColar linhas\nPara combinar conjuntos de dados unindo as linhas de um dataframe ao fundo de outro dataframe, pode-se utilizar bind_rows() do dplyr. Isto é explicado com mais detalhes na página Juntando dados.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Limpeza de dados e principais funções</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.pt.html#filtrar-linhas",
    "href": "new_pages/cleaning.pt.html#filtrar-linhas",
    "title": "8  Limpeza de dados e principais funções",
    "section": "8.11 Filtrar linhas",
    "text": "8.11 Filtrar linhas\nUma etapa típica de limpeza depois de limpar as colunas e recodificar os valores é filtrar o dataframe para linhas específicas utilizando o verbo filter() do dplyr.\nDentro de filter(), especificar a lógica que deve ser TRUE para que uma linha do conjunto de dados seja mantida. Abaixo mostramos como filtrar linhas com base em condições lógicas simples e complexas.\n\n\nFiltro simples\nEste exemplo simples redefine o dataframe linelist como ela mesma, tendo filtrado as linhas para atender a uma condição lógica. Apenas as linhas onde a declaração lógica dentro dos parênteses avaliada comoTRUE são mantidas.\nNeste exemplo, a afirmação lógica é gender == \"f\", que é perguntar se o valor na colunagender é igual a “f” (sensível a maiúsculas e minúsculas).\nAntes do filtro ser aplicado, o número de linhas da linelist é nrow(linelist).\n\nlinelist &lt;- linelist %&gt;% \n  filter(gender == \"f\")   # mantenha apenas as linhas onde o gênero é igual a  \"f\"\n\nDepois que o filtro é aplicado, o número de linhas da linelist é linelist %&gt;% filter(gender == \"f\") %&gt;% nrow().\n\n\nFiltrar valores faltantes\nÉ bastante comum querer filtrar as linhas que possuem valores ausentes. Resista à tentação de escrever filter(!is.na(column) & !is.na(column)) e ao invés disso use a função tidyr que é customizada para este propósito: drop_na(). Se executado com parênteses vazios, ele remove linhas com qualquer valores ausentes. Alternativamente, você pode fornecer nomes de colunas específicas a serem avaliadas quanto à ausência, ou usar as funções auxiliares “tidyselect” descritas acima.\n\nlinelist %&gt;% \n  drop_na(case_id, age_years)  # elimila as linhas com valores faltates nas colunas case_id ou age_years\n\nVeja a página sobre Campos em branco/faltantes para várias técnicas para analisar e manipular valores faltantes nos seus dados.\n\n\nFiltrar pelo número da linha\nEm um quadro de dados ou tibble, cada linha terá geralmente um “número de linha” que (quando visto no R Viewer) aparece à esquerda da primeira coluna. Não é em si uma coluna verdadeira nos dados, mas pode ser utilizada em uma declaração filter().\nPara filtrar com base no “número de linha”, é possível utilizar a função dplyr com o row_number() com parênteses abertos como parte de uma instrução de filtragem lógica. Muitas vezes você utilizará o operador %in% e um range de números como parte dessa instrução lógica, como mostrado abaixo. Para ver as primeiras N fileiras , você também pode utilizar a função especial head()l do pacote dplyr .\n\n# Veja as primeiras 100 linhas\nlinelist %&gt;% head(100)     # ou use  tail() tvara ver as últimas n linhas\n\n# Mostre apenas 5 linhas\nlinelist %&gt;% filter(row_number() == 5)\n\n# Veja linha 2 a 20 e especifique 3 colunas \nlinelist %&gt;% filter(row_number() %in% 2:20) %&gt;% select(date_onset, outcome, age)\n\nVocê também pode converter os números das linhas para uma coluna verdadeira, canalizando seu data Frame para a função tibble rownames_to_column() (não coloque nada entre parênteses).\n\n\n\nFiltro complexo\nSentenças lógicas mais complexas podes ser contruídas usando parênteses ( ), OU os operadores |, !, %in%, e AND &. Um exemplo pode ser visto abaixo:\nNota: Você pode utilizar o ! operador em frente a um critério lógico para negá-lo. Por exemplo, !is.na(column) avalia para verdadeiro se o valor da coluna não é faltante. Da mesma forma, !column %in% c(\"a\", \"b\", \"c\") avalia se o valor da coluna não está contido no vetor.\n\nExamine os dados\nAbaixo está um simples comando de uma linha para criar um histograma de datas de início. Veja que um segundo surto menor de 2012-2013 também está incluído neste conjunto de dados brutos. Para nossas análises, queremos remover as entradas deste surto anterior.\n\nhist(linelist$date_onset, breaks = 50)\n\n\n\n\n\n\n\n\n\n\nComo os filtros lidam com valores numericos e datas faltantes\nPodemos simplesmente filtrar por ‘date_onset’ para as linhas após junho de 2013? Cuidado! Aplicando o código filter(date_onset &gt; as.Date(\"2013-06-01\"))) removeria qualquer linha na última epidemia com uma data de início ausente!\nPERIGO: Filtrar para maior que (&gt;) ou menor que (&lt;) uma data ou número pode remover qualquer linha com valores ausentes (NA)! Isto porque NA é tratado como infinitamente grande e pequeno.\n(Veja a página em Trabalhando com datas para mais informações sobre como trabalhar com datas e o pacote lubridate)\n\n\nDesenhe o filtro\nExamine a tabulação cruzada para ter certeza que excluímos somente as linhas corretas:\n\ntable(Hospital  = linelist$hospital,                     # nome do hospital\n      YearOnset = lubridate::year(linelist$date_onset),  # ano de inicio dos sintomas (date_onset)\n      useNA     = \"always\")                              # mostrar valores faltantes\n\n                                      YearOnset\nHospital                               2012 2013 2014 2015 &lt;NA&gt;\n  Ausente                                 0    0 1117  318   77\n  Central Hospital                        0    0  351   99   18\n  Hospital A                            229   46    0    0   15\n  Hospital B                            227   47    0    0   15\n  Military Hospital                       0    0  676  200   34\n  Other                                   0    0  684  177   46\n  Port Hospital                           9    1 1372  347   75\n  St. Mark's Maternity Hospital (SMMH)    0    0  322   93   13\n  &lt;NA&gt;                                    0    0    0    0    0\n\n\nQue outros critérios podemos filtrar para remover o primeiro surto (em 2012 e 2013) do conjunto de dados? Vemos isso:\n\nA primeira epidemia em 2012 & 2013 ocorreu no Hospital A, Hospital B, e que também houve 10 casos no Port Hospital.\nOs Hospitais A e B não tiveram casos na segunda epidemia, mas o Port Hospital teve.\n\nQueremos excluir:\n\nA nrow(linelist %&gt;% filter(hospital %in% c(\"Hospital A\", \"Hospital B\") | date_onset &lt; as.Date(\"2013-06-01\"))) filas com início em 2012 e 2013 no hospital A, B, ou no Porto.\n\nExcluir nrow(linelist %&gt;% filter(date_onset &lt; as.Date(\"2013-06-01\"))) filas com início em 2012 e 2013\nExcluir nrow(linelist %&gt;% filter(hospital %em% c('Hospital A', 'Hospital B') & is.na(date_onset)))linhas dos Hospitais A & B com datas de início ausentes\n\nFazer não excluir nrow(linelist %&gt;% filter(!hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset))) outras linhas com datas de início ausentes.\n\n\nComeçamos com uma lineliste de nrow(linelist){\\i1}. Aqui está nossa declaração de filtro:\n\nlinelist &lt;- linelist %&gt;% \n  # mantém linhas onde o início é depois de 1 de Junho OU o início dos sintomas está faltante E o hospital é OUTRO que não A nem B \n  filter(date_onset &gt; as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))\n\nnrow(linelist)\n\n[1] 6019\n\n\nQuando refazemos a tabulação cruzada, vemos que os Hospitais A e B são completamente removidos, e os 10 casos de hospitais portuários de 2012 e 2013 são removidos, e todos os outros valores são os mesmos - exatamente como queríamos.\n\ntable(Hospital  = linelist$hospital,                     # nome do hospital\n      YearOnset = lubridate::year(linelist$date_onset),  # ano de início dos sintomas\n      useNA     = \"always\")                              # mostrar valores faltantes\n\n                                      YearOnset\nHospital                               2014 2015 &lt;NA&gt;\n  Ausente                              1117  318   77\n  Central Hospital                      351   99   18\n  Military Hospital                     676  200   34\n  Other                                 684  177   46\n  Port Hospital                        1372  347   75\n  St. Mark's Maternity Hospital (SMMH)  322   93   13\n  &lt;NA&gt;                                    0    0    0\n\n\nDeclarações múltiplas podem ser incluídas dentro de um comando de filtro (separadas por vírgulas), ou você pode sempre encadear com um %&gt;% para um comando filter() separado para maior clareza.\nNota: alguns leitores podem notar que seria mais fácil filtrar apenas por date_hospitalisation porque é 100% completo sem valores ausentes. Isto é verdade. Mas o date_onset é utilizado com o propósito didático de demonstrar um filtro complexo.\n\n\n\nAutônomo/Independente\nUm filtro também pode ser feito como um comando autônomo (não parte de uma cadeia de pipes (%&gt;%)). Como outros verbos dplyr, neste caso o primeiro argumento deve ser o próprio conjunto de dados.\n\n# dataframe &lt;- filter(dataframe, condition(s) for rows to keep)\n\nlinelist &lt;- filter(linelist, !is.na(case_id))\n\nVocê também pode usar o R base para criar um subconjunto dos dados, usando colchetes que refletem as [linhas, colunas] do que você deseja reter.\n\n# dataframe &lt;- dataframe[row conditions, column conditions] (se deixar a entrada em branco significa \"todas as linhas ou todas as colunas\")\n\nlinelist &lt;- linelist[!is.na(case_id), ]\n\n\n\nRevisar rapidamente registros\nMuitas vezes você quer rever rapidamente alguns registros, para apenas algumas colunas. A função do R base View() exibirá um dataframe para visualização em seu RStudio.\nVeja a lineliste no RStudio:\n\nView(linelist)\n\nAqui estão dois exemplos de visualização de células específicas (linhas específicas, e colunas específicas):\nCom funções dplyr filter() e select():\nDentro de View(), encadeie o conjunto de dados com o pipe (%&gt;%) com a função filter() para manter certas linhas, e depois com a função select() para manter certas colunas. Por exemplo, para rever as datas de início e hospitalização de 3 casos específicos:\n\nView(linelist %&gt;%\n       filter(case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\")) %&gt;%\n       select(date_onset, date_hospitalisation))\n\nVocê consegue os mesmos resultados com a seguinte sintaxe do R base , usando colchetes [ ] para subdividir o que você quer ver.\n\nView(linelist[linelist$case_id %in% c(\"11f8ea\", \"76b97a\", \"47a5f5\"), c(\"date_onset\", \"date_hospitalisation\")])\n\n\nAdiciotar a uma cadeia usando o pipe (%&gt;%)\n\n#  CADEIA DE LIMPEZA 'PIPE' (inicie com dados brutos e canalize-os através de etapas de limpeza)\n##################################################################################\n\n# inicie a cadeia pipe de limpeza\n###########################\nlinelist &lt;- linelist_raw %&gt;%\n    \n    # padronize a sintaxe do nome da coluna\n    janitor::clean_names() %&gt;% \n    \n    # renomeie as colunas manualmente\n           # NOVO nome             # nome VELHO\n    rename(date_infection       = infection_date,\n           date_hospitalisation = hosp_date,\n           date_outcome         = date_of_outcome) %&gt;% \n    \n    # remova coluna\n    select(-c(row_num, merged_header, x28)) %&gt;% \n  \n    # remova duplicidades\n    distinct() %&gt;% \n\n    # adicione colunas\n    mutate(bmi = wt_kg / (ht_cm/100)^2) %&gt;%     \n\n    # converta classe de colunas\n    mutate(across(contains(\"date\"), as.Date), \n           generation = as.numeric(generation),\n           age        = as.numeric(age)) %&gt;% \n    \n    # adicione coluna: demora para internação\n    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %&gt;% \n    \n    # limpe valores da coluna do hospital\n    mutate(hospital = recode(hospital,\n                      # VELHO = NOVO\n                      \"Mitylira Hopital\"  = \"Military Hospital\",\n                      \"Mitylira Hospital\" = \"Military Hospital\",\n                      \"Military Hopital\"  = \"Military Hospital\",\n                      \"Port Hopital\"      = \"Port Hospital\",\n                      \"Central Hopital\"   = \"Central Hospital\",\n                      \"other\"             = \"Other\",\n                      \"St. Marks Maternity Hopital (SMMH)\" = \"St. Mark's Maternity Hospital (SMMH)\"\n                      )) %&gt;% \n    \n    mutate(hospital = replace_na(hospital, \"Ausente\")) %&gt;% \n\n    # crie a coluna age_years (de age e age_unit)\n    mutate(age_years = case_when(\n          age_unit == \"years\" ~ age,\n          age_unit == \"months\" ~ age/12,\n          is.na(age_unit) ~ age,\n          TRUE ~ NA_real_)) %&gt;% \n  \n    mutate(\n          # categorias de idade: personalizado\n          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),\n        \n          # categorias de idade: 0 a 85 por 5s\n          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5))) %&gt;% \n    \n    # ACIMA ESTÃO AS ETAPAS DE LIMPEZA A MONTANTE JÁ DISCUTIDAS\n    ###################################################\n    filter(\n          # keep only rows where case_id is not missing\n          !is.na(case_id),  \n          \n          # also filter to keep only the second outbreak\n          date_onset &gt; as.Date(\"2013-06-01\") | (is.na(date_onset) & !hospital %in% c(\"Hospital A\", \"Hospital B\")))",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Limpeza de dados e principais funções</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.pt.html#cálculo-por-linha",
    "href": "new_pages/cleaning.pt.html#cálculo-por-linha",
    "title": "8  Limpeza de dados e principais funções",
    "section": "8.12 Cálculo por linha",
    "text": "8.12 Cálculo por linha\nSe você quiser realizar um cálculo dentro de uma linha, você pode utilizar rowwise() a partir de dplyr. Veja esta vinheta online em cálculos em linha.\nPor exemplo, este código se aplica rowwise() e então cria uma nova coluna que soma o número das colunas de sintomas especificados que têm o valor “yes” (sim), para cada linha da lista de linhas. As colunas são especificadas dentro de sum() pelo nome dentro de um vetor c(). A coluna rowwise() é essencialmente um tipo especial de group_by(), portanto é melhor utilizar ungroup() quando você terminar (página em Agrupar dados).\n\nlinelist %&gt;%\n  rowwise() %&gt;%\n  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == \"yes\")) %&gt;% \n  ungroup() %&gt;% \n  select(fever, chills, cough, aches, vomit, num_symptoms) # para mostrar\n\n# A tibble: 5,888 × 6\n   fever chills cough aches vomit num_symptoms\n   &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;        &lt;int&gt;\n 1 no    no     yes   no    yes              2\n 2 &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;            NA\n 3 &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;            NA\n 4 no    no     no    no    no               0\n 5 no    no     yes   no    yes              2\n 6 no    no     yes   no    yes              2\n 7 &lt;NA&gt;  &lt;NA&gt;   &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;            NA\n 8 no    no     yes   no    yes              2\n 9 no    no     yes   no    yes              2\n10 no    no     yes   no    no               1\n# ℹ 5,878 more rows\n\n\nAo especificar a coluna a ser avaliada, talvez você queira utilizar as funções de ajuda “tidyselect” descritas na seção select() desta página. Você só tem que fazer um ajuste (porque não está utilizando-as dentro de uma função dplyr como select() ou summarise()).\nColoque o critério de especificação de coluna dentro da função dplyr c_across(). Isto porque c_across (documentação) é projetado para trabalhar com rowwise() especificamente. Por exemplo, o seguinte código:\n\nAplica-se rowwise() assim a seguinte operação (sum()) é aplicada dentro de cada linha (não somando colunas inteiras)\n\nCria nova coluna num_NA_dates, definida para cada linha como o número de colunas (com nome contendo “data”) para as quais is.na() avaliadas para VERDADEIRO (estão faltando dados).\n\ngrupo()ungroup() para remover os efeitos de rowwise() para as etapas subseqüentes.\n\n\nlinelist %&gt;%\n  rowwise() %&gt;%\n  mutate(num_NA_dates = sum(is.na(c_across(contains(\"date\"))))) %&gt;% \n  ungroup() %&gt;% \n  select(num_NA_dates, contains(\"date\")) # para mostrar\n\n# A tibble: 5,888 × 5\n   num_NA_dates date_infection date_onset date_hospitalisation date_outcome\n          &lt;int&gt; &lt;date&gt;         &lt;date&gt;     &lt;date&gt;               &lt;date&gt;      \n 1            1 2014-05-08     2014-05-13 2014-05-15           NA          \n 2            1 NA             2014-05-13 2014-05-14           2014-05-18  \n 3            1 NA             2014-05-16 2014-05-18           2014-05-30  \n 4            1 2014-05-04     2014-05-18 2014-05-20           NA          \n 5            0 2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n 6            0 2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n 7            0 2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n 8            0 2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n 9            1 NA             2014-06-05 2014-06-06           2014-06-18  \n10            1 NA             2014-06-05 2014-06-07           2014-06-09  \n# ℹ 5,878 more rows\n\n\nVocê também poderia fornecer outras funções, tais como max() para obter a data mais recente ou mais recente para cada linha:\n\nlinelist %&gt;%\n  rowwise() %&gt;%\n  mutate(latest_date = max(c_across(contains(\"date\")), na.rm=T)) %&gt;% \n  ungroup() %&gt;% \n  select(latest_date, contains(\"date\"))  # para mostrar \n\n# A tibble: 5,888 × 5\n   latest_date date_infection date_onset date_hospitalisation date_outcome\n   &lt;date&gt;      &lt;date&gt;         &lt;date&gt;     &lt;date&gt;               &lt;date&gt;      \n 1 2014-05-15  2014-05-08     2014-05-13 2014-05-15           NA          \n 2 2014-05-18  NA             2014-05-13 2014-05-14           2014-05-18  \n 3 2014-05-30  NA             2014-05-16 2014-05-18           2014-05-30  \n 4 2014-05-20  2014-05-04     2014-05-18 2014-05-20           NA          \n 5 2014-05-29  2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n 6 2014-05-24  2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n 7 2014-06-01  2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n 8 2014-06-07  2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n 9 2014-06-18  NA             2014-06-05 2014-06-06           2014-06-18  \n10 2014-06-09  NA             2014-06-05 2014-06-07           2014-06-09  \n# ℹ 5,878 more rows",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Limpeza de dados e principais funções</span>"
    ]
  },
  {
    "objectID": "new_pages/cleaning.pt.html#organizar-e-ordenar",
    "href": "new_pages/cleaning.pt.html#organizar-e-ordenar",
    "title": "8  Limpeza de dados e principais funções",
    "section": "8.13 Organizar e ordenar",
    "text": "8.13 Organizar e ordenar\nUtilize a função dplyr arrange() para ordenar ou ordenar as linhas por valores de coluna.\nSimplesmente liste as colunas na ordem em que elas devem ser ordenadas. Especifique .by_group = TRUE se você quiser que a ordenação ocorra primeiro por quaisquer grupos aplicados aos dados (ver página em Agrupar dados).\nPor padrão, a coluna será ordenada em ordem “ascendente” (que se aplica às colunas numéricas e também às colunas de caracteres). Você pode ordenar uma variável em ordem “decrescente”, envolvendo-a com desc().\nA ordenação de dados com arrange() é particularmente útil ao fazer Tabelas para apresentação, utilizando slice() para pegar as linhas “top” por grupo, ou definir a ordem de nível de fator por ordem de aparência.\nPor exemplo, para ordenar as linhas de nossa linelist por hospital, depois por date_onset em ordem decrescente, nós utilizaríamos:\n\nlinelist %&gt;% \n   arrange(hospital, desc(date_onset))",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Limpeza de dados e principais funções</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.pt.html",
    "href": "new_pages/dates.pt.html",
    "title": "9  Trabalhando com datas",
    "section": "",
    "text": "9.1 Preparação",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Trabalhando com datas</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.pt.html#preparação",
    "href": "new_pages/dates.pt.html#preparação",
    "title": "9  Trabalhando com datas",
    "section": "",
    "text": "Carregar os pacotes\nEsse trecho de código mostra o carregamento dos pacotes necessários para esta página. Neste manual enfatizamos a função p_load() do pacman, que instala o pacote se necessário e o carrega para utilização. Tamém é possível carregar os pacotes instalados com library() a partir do R base. Para mais informações, veja a página em Introdução ao R sobre pacotes no R.\n\n# Confere se o pacote está instalado, instala o pacote se necessário, e carrega-o para a sessão atual\n\npacman::p_load(\n  lubridate,  # pacote geral para manipulação e conversão de datas  \n  parsedate,   # possui a função de \"adivinhar\" datas desorganizadas\n  aweek,      # outra opção para conversão de datas em semanas, e de semanas em datas \n  zoo,        # funções adicionais de data/hora\n  here,       # Gerenciamento de arquivos\n  tidyverse,  # gerenciamento e visualização dos dados  \n  rio)        # importação/exportação dos dados\n\n\n\nImportação dos dados\nImportamos o conjunto de dados de casos de uma simulação de epidemia de Ebola. Se você deseja baixar os dados para acompanhar passo a passo, consulte as instruções na página Baixar manual e dados. Presumimos que o arquivo está no diretório de trabalho, portanto, nenhuma subpasta é especificada neste caminho de arquivo.\n\nlinelist &lt;- import(\"linelist_cleaned.xlsx\")",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Trabalhando com datas</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.pt.html#data-atual",
    "href": "new_pages/dates.pt.html#data-atual",
    "title": "9  Trabalhando com datas",
    "section": "9.2 Data atual",
    "text": "9.2 Data atual\nVocê pode obter a data atual do “sistema” ou a data e hora do sistema do seu computador por meio da seguintes funções presentes no R base.\n\n# obter a data do sistema - esta é uma classe DATE\nSys.Date()\n\n[1] \"2024-05-08\"\n\n# obter a hora do sistema - esta é uma classe DATETIME\nSys.time()\n\n[1] \"2024-05-08 12:15:55 CEST\"\n\n\nCom o pacote lubridate, essas informações também pode ser retornadas com today() e now(), respectivamente. date() retorna a data e hora atual com os nomes dos dias da semana e dos meses.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Trabalhando com datas</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.pt.html#converter-para-data",
    "href": "new_pages/dates.pt.html#converter-para-data",
    "title": "9  Trabalhando com datas",
    "section": "9.3 Converter para Data",
    "text": "9.3 Converter para Data\nDepois de importar um conjunto de dados para o R, os valores da coluna com datas podem ser semelhantes a “1989/12/30”, “05/06/2014”, ou “13 Janeiro 2020”. Nesses casos, é provável que o R ainda esteja lendo esses valores como caracteres. O R deve ser informado que esses valores são datas… e o que esse fomato de data representa (qual parte é referente ao dia, mês, ano, etc).\nUma vez informado, o R converte esses valores para a classe Date. Em segundo plano, o R armazenará as datas como números (o número de dias a partir de sua data de “origem” 1 de janeiro de 1970). Você não fará interface com o número da data com frequência, mas isso permite que R trate as datas como variáveis contínuas e permita operações especiais, como calcular a distância entre as datas.\nPor padrão, os valores da classe Date em R são exibidos como AAAA-MM-DD. Posteriormente nesta seção, discutiremos como alterar a exibição dos valores de data.\nA seguir, apresentamos duas abordagens para converter uma coluna de valores de caracteres para a classe Date.\nDICA: Você pode checar a classe atual de uma coluna utilizando a função class()presente na base do R , como por exemplo class(linelist$date_onset).\n\nR base\nas.Date() é a função presente no R base para conversão um objeto ou coluna para a classe Data (observe a capitalização de “D”).\nPara o uso da função as.Date() é preciso que:\n\nVocê especifique o formato existente da data como um caractere bruto ou então que especifique a data de origem, caso forneça datas como números (consulte a seção sobre datas do Excel);\nSe foi usado em uma coluna de caracteres, todos os valores de data devem ter o mesmo formato exato (se este não for o caso, tente parse_date() do pacote parsedate).\n\nPrimeiro, verifique a classe de sua coluna com class() do R base. Se você não tem certeza ou está confuso sobre a classe de seus dados (por exemplo, você vê “POSIXct”, etc.) pode ser mais fácil primeiro converter a coluna para a classe Character com a função as.character(), e depois converter para a classe Date.\nSegundo, dentro da função as.Date(), use o argumento format = para informar ao R o formato atual dos componentes da data como caractere - quais caracteres se referem ao mês, dia e ano, e como eles são separados. Se seus valores já estiverem em um dos formatos de data padrão do R (“AAAA-MM-DD” ou “AAAA/MM/DD”), o argumento format = não é necessário.\nPara format =, forneça uma sequência de caracteres (entre aspas) que representa o formato de data atual usando as abreviações especiais “strptime” abaixo. Por exemplo, se as datas dos caracteres estão atualmente no formato “DD/MM/AAAA”, como “24/04/1968”, você usaria format = \"%d/%m/%Y\" para converter os valores em datas. É necessário colocar o formato entre aspas. E não se esqueça de quaisquer barras ou travessões!\n\n# Converter para classe data\nlinelist &lt;- linelist %&gt;% \n  mutate(date_onset = as.Date(date_of_onset, format = \"%d/%m/%Y\"))\n\nA maioria das abreviações de strptime estão listadas abaixo. Você pode ver a lista completa executando ?strptime.\n%d = Número do dia do mês (5, 17, 28, etc.)\n%j = Número do dia do ano (dia Juliano 001-366)\n%a = Dia da semana abreviado (Seg, Ter, Quarta,etc. ou Mon, Tue, Wed, etc.)\n%A = Dia da semana completo (segunda, terça, etc.)\n%w = Número do dia da semana (0-6, sendo que domingo é 0)\n%u = Número do dia da semana (1-7, sendo que segunda é 1)\n%W = Número da semana (00-53, segunda é início da semana)\n%U = Número da semana (01-53, domingo é o início da semana)\n%m = Número do mês (por exemplo, 01, 02, 03, 04)\n%b = Mês abreviado (Jan, Fev, etc.)\n%B = Mês completo (Janeiro, Fevereiro, etc.)  %y = Ano em 2 dígitos (por exemplo, 89)\n%Y = Ano em 4 dígitos (por exemplo, 1989)\n%h = horas (relógio de 24 horas)\n%M = minutos\n%s = segundos\n%z = deslocamento do GMT\n%Z = fuso horário (caractere)\nDICA: TO argumento format = da função as.Date() não está informando ao R o formato que deseja que as datas tenham, mas sim como identificar as partes da data da forma como elas estão, antes de rodar o comando.\nDICA: Certifique-se de que no argumento format = você usa o separador de data (por exemplo, /, -, ou espaço) que está presente em suas datas.\nUma vez que os valores estão na classe Date, o R os exibirá no formato padrão, que é AAAA-MM-DD.\n\n\nlubridate\nA conversão de objetos de caracteres em datas pode ser facilitada com o uso do pacote lubridate. Este é um pacote tidyverse projetado para tornar o trabalho com datas e horários mais simples e consistente do que nO R base. Por essas razões, lubridate é frequentemente considerado o pacote padrão ouro para datas e horários, e é recomendado sempre que trabalhar com eles.\nO pacote lubridate fornece diferentes funções auxiliares projetadas para converter objetos de caracteres em datas de uma forma intuitiva e mais branda do que especificar o formato em as.Date(). Essas funções são específicas para o formato de data aproximada, mas permitem uma variedade de separadores e sinônimos para datas (como, 01 vs Jan vs Janeiro) - eles são nomeados após abreviações de formatos de data.\n\n# instale/carregue lubridate \npacman::p_load(lubridate)\n\nA função ymd() converte de forma flexível os valores de data fornecidos como ano, seguido de mês, e depois dia.\n\n# Leia a data no formato ano-mês-dia\nymd(\"2020-10-11\")\n\n[1] \"2020-10-11\"\n\nymd(\"20201011\")\n\n[1] \"2020-10-11\"\n\n\nA função mdy() converte de forma flexível os valores de data fornecidos como mês, seguido de dia, e ano.\n\n# Leia a data no formato mês-dia-ano\nmdy(\"10/11/2020\")\n\n[1] \"2020-10-11\"\n\nmdy(\"Oct 11 20\")\n\n[1] \"2020-10-11\"\n\n\nA função dmy() converte de forma flexível os valores de data fornecidos como dia, seguida de mês, e ano.\n\n# Leia a data no formato dia-mês-ano\ndmy(\"11 10 2020\")\n\n[1] \"2020-10-11\"\n\ndmy(\"11 October 2020\")\n\n[1] \"2020-10-11\"\n\n\n\n\n\n\nSe estiver usando o pipe %&gt;%, a conversão de uma coluna de caracteres para datas com lubridate pode ser feita assim:\n\nlinelist &lt;- linelist %&gt;%\n  mutate(date_onset = lubridate::dmy(date_onset))\n\nDepois de concluído, você pode executar class() para verificar a classe da coluna\n\n# Confira a classe da coluna \nclass(linelist$date_onset)  \n\nUma vez que os valores estão na classe Date, o R os exibirá por padrão no formato AAAA-MM-DD.\nObserve que as funções acima funcionam melhor com anos de 4 dígitos. Anos de 2 dígitos podem produzir resultados inesperados, à medida que lubridate tenta adivinhar o século.\nPara converter um ano de 2 dígitos em um ano de 4 dígitos (todos no mesmo século) você pode converter as datas para caractere e então combinar os dígitos existentes com uma pré-correção usando str_glue() do pacote stringr (veja Caracteres e strings). Em seguida, converta para data.\n\nano_dois_digitos &lt;- c(\"15\", \"15\", \"16\", \"17\")\nstr_glue(\"20{ano_dois_digitos}\")\n\n2015\n2015\n2016\n2017\n\n\n\n\nCombine colunas\nVocê pode usar as funções do lubridate make_date() e make_datetime() para combinar múltiplas colunas numéricas em uma coluna de data. Por exemplo, se você tiver colunas numéricas onset_day, onset_month, e onset_year na tabela de dados linelist:\n\nlinelist &lt;- linelist %&gt;% \n  mutate(onset_date = make_date(year = onset_year, month = onset_month, day = onset_day))",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Trabalhando com datas</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.pt.html#datas-do-excel",
    "href": "new_pages/dates.pt.html#datas-do-excel",
    "title": "9  Trabalhando com datas",
    "section": "9.4 Datas do Excel",
    "text": "9.4 Datas do Excel\nEm segundo plano, a maioria dos softwares armazena datas como números. O R armazena datas de uma origem de 1º Janeiro, 1970. Portanto, se você executar as.numeric(as.Date(\"1970-01-01)) você obterá 0.\nO Microsoft Excel armazena datas com um origem em 30 de dezembro de 1899 (Windows) ou 1 de janeiro de 1904 (Mac), dependendo do seu sistema operacional. Consulte em Microsoft guidance para obter mais informações.\nAs datas do Excel geralmente são importadas para o R como esses valores numéricos, em vez de caracteres. Se o conjunto de dados que você importou do Excel mostra datas como números ou caracteres como “41369” … use as.Date() (ou a função do lubridate as_date()) para converter, mas no lugar de fornecer um “formato” como acima, forneça a data de origem do Excel no argumento origin =.\nIsso não irá funcionar se as datas do Excel contidas no R estiverem como caracteres, assim, confirme se os números estão classificados como Numérico!\nNOTA: Você deve fornecer a data de origem no formato de data padrão do R (“AAAA-MM-DD”).\n\n# Um exemplo de fornecimento da 'data de origem' do Excel ao converter datas numéricas do Excel\ndata_cleaned &lt;- data %&gt;% \n  mutate(date_onset = as.numeric(date_onset)) %&gt;%   # garantir que a classe seja numérica\n  mutate(date_onset = as.Date(date_onset, origin = \"1899-12-30\")) # converter para data usando a origem do Excel",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Trabalhando com datas</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.pt.html#datas-bagunçadas",
    "href": "new_pages/dates.pt.html#datas-bagunçadas",
    "title": "9  Trabalhando com datas",
    "section": "9.5 Datas bagunçadas",
    "text": "9.5 Datas bagunçadas\nA função parse_date() do pacote parsedate tenta ler uma coluna de data “bagunçada” contendo datas em muitos formatos diferentes e converte as datas para um formato padrão. Você pode ler mais online sobre parse_date().\nPor exemplo, o parse_date() vê um vetor dos seguintes caracteres de datas “03 Jan 2018”, “07/03/1982”, e “08/20/85” e os converteria para a classe Date como: 2018-01-03, 1982-03-07, e 1985-08-20.\n\nparsedate::parse_date(c(\"03 Jan 2018\",\n                        \"07/03/1982\",\n                        \"08/20/85\"))\n\n[1] \"2018-01-03 UTC\" \"1982-07-03 UTC\" \"1985-08-20 UTC\"\n\n\n\n# Um exemplo usando parse_date() na coluna `date_onset` (data de início de sintomas)\nlinelist &lt;- linelist %&gt;%      \n  mutate(date_onset = parse_date(date_onset))",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Trabalhando com datas</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.pt.html#trabalhando-com-classe-de-data-hora",
    "href": "new_pages/dates.pt.html#trabalhando-com-classe-de-data-hora",
    "title": "9  Trabalhando com datas",
    "section": "9.6 Trabalhando com classe de data-hora",
    "text": "9.6 Trabalhando com classe de data-hora\nConforme mencionado anteriormente, o R também oferece suporte para dados de classe datetime - uma coluna que contém informações de data e hora. Assim como a classe Date, eles geralmente precisam ser convertidos de objetos de character para objetos datetime.\n\nConverter datas com horas\nUm objeto datetime padrão é formatado com a data primeiro, que é seguida por um componente de hora - por exemplo, 01 de janeiro de 2020, 16:30. Assim como acontece com as datas, isso pode ser formatado de muitas maneiras e vários níveis de precisão (horas, minutos, segundos) que podem ser fornecidos.\nFelizmente, as funções auxiliares do lubridate também existem para ajudar a converter essas junções para objetos datetime. Essas funções são extensões das funções auxiliares de data, com _h (apenas horas fornecidas), _hm (horas e minutos fornecidos), ou _hms (horas, minutos e segundos fornecidos) anexado ao final (por exemplo, dmy_hms()). Eles podem ser usados conforme mostrado abaixo:\nConverte “data e hora” contendo apenas horas para o objeto do tipo datetime\n\nymd_h(\"2020-01-01 16hrs\")\n\n[1] \"2020-01-01 16:00:00 UTC\"\n\n\nConverte “data e hora” com horas e minutos para o objeto do tipo datetime\n\ndmy_hm(\"01 January 2020 16:20\")\n\n[1] \"2020-01-01 16:20:00 UTC\"\n\n\nConverte “data e hora” com horas, minutos e segundos para o objeto do tipo datetime\n\nmdy_hms(\"01 January 2020, 16:20:40\")\n\n[1] \"2020-01-20 16:20:40 UTC\"\n\n\nVocê pode fornecer o fuso horário, mas ele será ignorado. Consulte a seção mais adiante nesta página sobre fusos horários.\n\nmdy_hms(\"01 January 2020, 16:20:40 PST\")\n\n[1] \"2020-01-20 16:20:40 UTC\"\n\n\nAo trabalhar com uma tabela de dados, as colunas de hora e data podem ser combinadas para criar uma coluna data-e-hora (datetime) usando str_glue() do pacote stringr e uma função apropriada do lubridate. Consulte a página em Caracteres e strings para obter detalhes sobre o stringr.\nNeste exemplo, a tabela de dados do linelist possui uma coluna no formato “horas:minutos”. Para converter isso para data-e-hora, seguem-se algumas etapas:\n\nCrie uma coluna de tempo de admissão “limpa” na qual os valores ausentes são preenchidos pela mediana da coluna. Isso é realizado, pois lubridate não funciona com valores ausentes. Combine-o com a coluna date_hospitalisation, e então use a função ymd_hm() para converter.\n\n\n# pacotes\npacman::p_load(tidyverse, lubridate, stringr)\n\n# time_admission é a coluna em horas:minutos\nlinelist &lt;- linelist %&gt;%\n  \n  # quando o horário de admissão não é fornecido, atribua o horário médio de admissão\n  mutate(\n    time_admission_clean = ifelse(\n      is.na(time_admission),   # se horário estiver faltando\n      median(time_admission),  # atribua a mediana\n      time_admission           # se não estiver faltando, mantenha como está\n  )) %&gt;%\n  \n    # use str_glue() para combinar as colunas de data-e-horas em uma coluna de caracteres\n    # em seguida, use ymd_hm() para converter em formato datetime\n  mutate(\n    date_time_of_admission = str_glue(\"{date_hospitalisation}{time_admission_clean}\") %&gt;% \n      ymd_hm()\n  )\n\n\n\nConverta horários isolados\nSe seus dados contém apenas caracteres referente a um horário (horas e minutos), você pode convertê-los e manipulá-los como tempos usando strptime() a partir do R base. Por exemplo, para obter a diferença entre dois desses tempos:\n\n# horário como caracteres brutos\ntime1 &lt;- \"13:45\" \ntime2 &lt;- \"15:20\"\n\n# horário convertidos para classe datetime \ntime1_clean &lt;- strptime(time1, format = \"%H:%M\")\ntime2_clean &lt;- strptime(time2, format = \"%H:%M\")\n\n# Por padrão, a diferença é da classe \"difftime\", aqui convertida em horas numéricas \nas.numeric(time2_clean - time1_clean)   # diferença em horas\n\n[1] 1.583333\n\n\nObserve, entretanto, que sem um valor de data fornecido, ele assume que a data é hoje. , Veja como usar stringr na seção acima para combinar uma data string e um tempo string. Leia mais sobre strptime() aqui.\nPara converter números de um dígito em dois dígitos (por exemplo, para “preencher” horas ou minutos com zeros à esquerda para atingir 2 dígitos), consulte a seção “Pad length” da página Caracteres e junções.\n\n\nExtrair o tempo\nVocê pode extrair elementos de um tempo com hour(), minute(), ou second() do lubridate.\nAqui está um exemplo de extração da hora e em seguida, sua classificação por período do dia. Começamos com a coluna time_admission, a qual está na classe Caractere no formato “HH:MM”. Primeiro, a strptime() é usado conforme descrito acima para converter os caracteres para a classe datetime. Em seguida, a hora é extraída com with hour(), retornando um número de 0-24. Finalmente, uma coluna time_period usando a lógica com a função case_when() para classificar as linhas em Manhã / Tarde / Início da noite / Noite com base na hora de admissão.\n\nlinelist &lt;- linelist %&gt;%\n  mutate(hour_admit = hour(strptime(time_admission, format = \"%H:%M\"))) %&gt;%\n  mutate(time_period = case_when(\n    hour_admit &gt; 06 & hour_admit &lt; 12 ~ \"Manhã\",\n    hour_admit &gt;= 12 & hour_admit &lt; 17 ~ \"Tarde\",\n    hour_admit &gt;= 17 & hour_admit &lt; 21 ~ \"Início da noite\",\n    hour_admit &gt;=21 | hour_admit &lt;= 6 ~ \"Noite\"))\n\nPara saber mais sobre case_when() , consulte a página Limpeza dos daos e principais funções.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Trabalhando com datas</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.pt.html#trabalhando-com-datas",
    "href": "new_pages/dates.pt.html#trabalhando-com-datas",
    "title": "9  Trabalhando com datas",
    "section": "9.7 Trabalhando com datas",
    "text": "9.7 Trabalhando com datas\nlubridate também pode ser usado para uma variedade de outras funções, como extrair aspectos de uma data / data e hora, realizar cálculos aritiméticos de data ou calcular intervalos de data.\nAqui, definimos uma data que será usada para os exemplos:\n\n# criar um objeto de classe Date\nexample_date &lt;- ymd(\"2020-03-01\")\n\n\nExtrair os componentes de datas\nVocê pode extrair aspectos comuns, como mês, dia, dia da semana:\n\nmonth(example_date)  # número do mês\n\n[1] 3\n\nday(example_date)    # dia do mês (número)\n\n[1] 1\n\nwday(example_date)   # número do dia da semana (1-7)\n\n[1] 1\n\n\nVocê também pode extrair componentes de tempo de um objeto ou coluna datetime. Isso pode ser útil se você quiser ver a distribuição dos horários de admissão.\n\nexample_datetime &lt;- ymd_hm(\"2020-03-01 14:45\")\n\nhour(example_datetime)     # extrair hora\nminute(example_datetime)   # extrair minuto\nsecond(example_datetime)   # extrair segundo\n\nExistem várias opções para recuperar semanas. Veja a seção sobre semanas epidemiológicas abaixo.\nObserve que se você deseja exibir uma data de uma determinada maneira (por exemplo, “janeiro de 2020” ou “Quinta-feira, 20 de março” ou “Semana 20 de 1977”), pode fazer isso de forma mais flexível, conforme descrito na seção Exibição de data.\n\n\nCálculos com datas\nVocê pode adicionar determinados números de dias ou semanas usando suas respectivas funções do lubridate.\n\n# adicione 3 dias à essa data \nexample_date + days(3)\n\n[1] \"2020-03-04\"\n\n# adicione 7 semanas e subtraia dois dias dessa data\nexample_date + weeks(7) - days(2)\n\n[1] \"2020-04-17\"\n\n\n\n\nIntervalos entre datas\nA diferença entre as datas pode ser calculada por:\n\nCertifique-se de que ambas as datas estejam como classe data\n\nUse a subtração para retornar a diferença “difftime” entre as duas datas\n\nSe necessário, converta o resultado em classe numérica para realizar cálculos matemáticos subsequentes\n\nAbaixo, o intervalo entre duas datas é calculado e exibido. Você pode encontrar intervalos usando o símbolo de subtração “menos” em valores que estão como classe Data. Contudo, observe que a classe do valor retornado é “difftime” conforme exibido abaixo e deve ser convertida para numérico.\n\n# encontre o intervalo entre essa data e 20 de fevereiro de 2020\noutput &lt;- example_date - ymd(\"2020-02-20\")\noutput    # print\n\nTime difference of 10 days\n\nclass(output)\n\n[1] \"difftime\"\n\n\nPara fazer as operações subsequentes em um “difftime”, converta-o para numérico com as.numeric().\nTudo isso pode ser reunido para trabalhar com dados - por exemplo:\n\npacman::p_load(lubridate, tidyverse)   # carregue os pacotes\n\nlinelist &lt;- linelist %&gt;%\n  \n  # converter a data de início (date_onset) de caracteres em objetos de data, especificando o formato dmy\n  mutate(date_onset = dmy(date_onset),\n         date_hospitalisation = dmy(date_hospitalisation)) %&gt;%\n  \n  # filtrar todos os casos sem início em março\n  filter(month(date_onset) == 3) %&gt;%\n    \n  # encontrar a diferença, em dias, entre a data de ínicio e o início da hospitalização\n  mutate(days_onset_to_hosp = date_hospitalisation - date_of_onset)\n\nNo contexto de uma tabela de dados (data frame), se uma das datas acima estiver faltando, a operação falhará para essa linha. Isso resultará em um NA em vez de um valor numérico. Ao usar esta coluna para cálculos, certifique-se de definir o argumento na.rm = como TRUE. Por exemplo:\n\n# calcule o número médio de dias até a hospitalização para todos os casos em que os dados estão disponíveis\nmedian(linelist_delay$days_onset_to_hosp, na.rm = T)",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Trabalhando com datas</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.pt.html#exibição-das-datas",
    "href": "new_pages/dates.pt.html#exibição-das-datas",
    "title": "9  Trabalhando com datas",
    "section": "9.8 Exibição das datas",
    "text": "9.8 Exibição das datas\nUma vez que as datas essão na classe correta, você geralmente deseja que elas sejam exibidas de forma diferente, por exemplo, como “Segunda-feira, 5 de janeiro” em vez de “05/01/2018”. Você também pode ajustar a exibição para agrupar as linhas pelos elementos de data exibidos - por exemplo, agrupar por mês-ano.\n\nformat()\nAjuste a exibição de data com a função format()do R base. Esta função aceita uma cadeia de caracteres entre aspas (string) especificando o formato de saída desejado nas abreviações de strptime “%” (a mesma sintaxe usada em as.Date()). Abaixo estão relacionadas a maioria das abreviações comuns.\nObservação: o uso de format() converterá os valores para a classe Caractere, então geralmente é usado no final de uma análise ou apenas para fins de exibição! Você pode ver a lista completa executando ?strptime.\n%d = Número do dia do mês (5, 17, 28, etc.)\n%j = Número do dia do ano (Julho dia 001-366)\n%a = Dia da semana abreviado (Mon, Tue, Wed, etc.)\n%A = Dia da semana completo (Monday, Tuesday, etc.)\n%w = Número do dia da semana (0-6, Domingo é 0)\n%u = Número do dia da semana (1-7, Segunda-feira é 1)\n%W = Número da semana (00-53, Segunda-feira é o início da semana)\n%U = Número da semana (01-53, Domingo é o início da semana)\n%m = Número do mês (exemplo, 01, 02, 03, 04)\n%b = Mês abreviado (Jan, Fev, etc.)\n%B = Mês completo (Janeiro, Fevereiro, etc.)\n%y = Ano em 2 dígitos (por exemplo, 89)\n%Y = Ano em 7 dígitos (por exemplo, 1989)\n%h = horas (relógio de 24 horas)\n%M = minutos\n%s = segundos\n%z = deslocamento do GMT\n%Z = Fuso horário (caractere)\nUm exemplo de formatação da data de hoje:\n\n# data de hoje com formatação\nformat(Sys.Date(), format = \"%d %B %Y\")\n\n[1] \"08 May 2024\"\n\n# maneira fácil de obter data e hora completas (formatação padrão)\ndate()\n\n[1] \"Wed May  8 12:15:56 2024\"\n\n# data, hora e fuso horário combinados e formatados usando a função str_glue()\nstr_glue(\"{format(Sys.Date(), format = '%A, %B %d %Y, %z  %Z, ')}{format(Sys.time(), format = '%H:%M:%S')}\")\n\nWednesday, May 08 2024, +0000  UTC, 12:15:56\n\n# Usando a função format para exibir as semanas\nformat(Sys.Date(), \"%Y Week %W\")\n\n[1] \"2024 Week 19\"\n\n\nObserve que se estiver usando str_glue(), esteja ciente de que dentro das aspas duplas esperadas “, você deve usar apenas aspas simples (como acima).\n\n\nMês-ano\nPara converter uma coluna de Data para o formato mês-ano, sugerimos que você use a função as.yearmon() do pacote zoo. Isso converte a data para a classe “yearmon” e mantém a ordem adequada. Em contraste, o uso de format(column, \"%Y %B\") irá converter para a classe Caractere e irá ordenar os valores alfabeticamente (incorretamente).\nAbaixo, uma nova coluna yearmonth é criada a partir da coluna date_onset, usando a função as.yearmon(). A ordem padrão (correta) dos valores resultantes é mostrada na tabela.\n\n# criando uma nova tabela \ntest_zoo &lt;- linelist %&gt;% \n     mutate(yearmonth = zoo::as.yearmon(date_onset))\n\n# mostrar tabela\ntable(test_zoo$yearmon)\n\n\nApr 2014 May 2014 Jun 2014 Jul 2014 Aug 2014 Sep 2014 Oct 2014 Nov 2014 \n       7       64      100      226      528     1070     1112      763 \nDec 2014 Jan 2015 Feb 2015 Mar 2015 Apr 2015 \n     562      431      306      277      186 \n\n\nEm contraste, você pode ver como usando apenas format() é possível atingir ao formato de exibição desejado, mas não na ordem correta.\n\n# criar uma nova coluna\ntest_format &lt;- linelist %&gt;% \n     mutate(yearmonth = format(date_onset, \"%b %Y\"))\n\n# mostrar tabela\ntable(test_format$yearmon)\n\n\nApr 2014 Apr 2015 Aug 2014 Dec 2014 Feb 2015 Jan 2015 Jul 2014 Jun 2014 \n       7      186      528      562      306      431      226      100 \nMar 2015 May 2014 Nov 2014 Oct 2014 Sep 2014 \n     277       64      763     1112     1070 \n\n\nObservação: se você estiver trabalhando em um ggplot() e quiser ajustar apenas a forma como as datas são exibidas, pode ser suficiente fornecer um formato strptime para o argumento date_labels = na função scale_x_date() - você pode usar \"%b %Y\" ou \"%Y %b\". Veja a página Dicas para ggplot.\nzoo também oferece a função as.yearqtr(), e você pode usar scale_x_yearmon() ao usar ggplot().",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Trabalhando com datas</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.pt.html#dates_epi_wks",
    "href": "new_pages/dates.pt.html#dates_epi_wks",
    "title": "9  Trabalhando com datas",
    "section": "9.9 Semanas epidemiológicas",
    "text": "9.9 Semanas epidemiológicas\n\nlubridate\nConsulte a página em Agrupando dados para exemplos mais abrangentes de dados de agrupamento por data. Abaixo, descrevemos resumidamente os dados de agrupamento por semanas.\nGeralmente recomendamos usar a função floor_date() do lubridate, com o argumento unit = \"week\". Isso arredonda a data para o “início” da semana, conforme definido pelo argumento week_start =. O início da semana padrão é 1 (para segundas-feiras), mas você pode especificar qualquer dia da semana como o início (por exemplo, 7 para domingos). floor_date() é versátil e pode ser usado para arredondar outras unidades de tempo definindo unit = para “segundo”, “minuto”, “hora”, “dia”, “mês” ou “ano”.\nO valor retornado é a data de início da semana, na classe Date. A classe de data é útil ao plotar os dados, pois serão facilmente reconhecidos e ordenados corretamente por ggplot().\nSe você estiver interessado apenas em ajustar as datas para exibição por semana em um gráfico, consulte a seção nesta página sobre Exibição de data. Por exemplo, ao plotar uma curva epidemiológica, você pode formatar a exibição da data fornecendo a nomenclatura “%” do strptime desejada. Por exemplo, use “%Y-%W” ou “%Y-%U” para retornar o ano e o número da semana (dado o início da semana na segunda-feira ou no domingo, respectivamente).\n\n\nContagens semanais\nVeja a página em Agrupando dados para uma explicação completa de dados de agrupamento com count(), group_by(), e summarise(). Um breve exemplo está mostrado abaixo.\n\nCrie uma nova coluna ‘semana’ com mutate(), usando floor_date() com unit = \"week\";\nObtenha contagens de linhas (casos) por semana com count(); remova quaisquer casos com data ausente;\nConclua com complete() do tidyr para garantir que todas as semanas apareçam nos dados - mesmo aquelas sem linhas/casos. Por padrão, os valores de contagem para quaisquer “novas” linhas são NA, mas você pode torná-los 0 com o argumento fill =, que espera uma lista nomeada (abaixo, n é o nome da coluna de contagens).\n\n\n# Faça um conjunto de dados agregado de contagens de casos semanais\nweekly_counts &lt;- linelist %&gt;% \n  drop_na(date_onset) %&gt;%             # remover casos sem data de início onset date\n  mutate(weekly_cases = floor_date(   # fazer nova coluna, semana de início\n    date_onset,\n    unit = \"week\")) %&gt;%            \n  count(weekly_cases) %&gt;%           # agrupar dados por semana e contar linhas por grupo (cria a coluna 'n')\n  tidyr::complete(                  # garantir que todas as semanas estejam presentes, mesmo aquelas sem casos relatados\n    weekly_cases = seq.Date(          # redefina a coluna \"weekly_cases\" como uma sequência completa,\n      from = min(weekly_cases),       # a partir da data mínima\n      to = max(weekly_cases),         # para a data máxima\n      by = \"week\"),                   # por semanas\n    fill = list(n = 0))             # preencha NAs na coluna de n contagens com 0\n\nAqui estão as primeiras linhas da tabela de dados resultante:\n\n\n\n\n\n\n\n\nAlternativas do Epiweek\nNote que lubridate também tem as funções week(), epiweek(), e isoweek(), cada uma com datas de início ligeiramente diferentes e outras nuances. De modo geral, porém, floor_date() deve ser tudo o que você precisa. Leia os detalhes dessas funções inserindo ?week no console ou lendo a documentação aqui.\nVocê pode considerar usar o pacote aweek para definir semanas epidemiológicas. Você pode ler mais sobre isso no site do RECON. Possui as funções date2week()e week2date() nas quais você pode definir o dia de início da semana com week_start = \"Monday\". Este pacote é mais fácil se você quiser saídas no estilo “semana” (por exemplo, “2020-W12”, sendo W = semana). Outra vantagem de aweek é que quando date2week() é aplicado a uma coluna de data, a coluna retornada (formato de semana) é automaticamente da classe Fator e e inclui níveis para todas as semanas no intervalo de tempo (isso evita a etapa extra de complete() descrito acima). Porém, aweek não tem a funcionalidade de arredondar datas para outras unidades de tempo, como meses, anos, etc..\nOutra alternativa para séries temporais que também funciona bem para mostrar um formato de “semana” (“2020 W12”) é yearweek() do pacote tsibble, como demonstrado na página Séries temporais e detecção de surto.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Trabalhando com datas</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.pt.html#conversão-de-datas-fusos-horários",
    "href": "new_pages/dates.pt.html#conversão-de-datas-fusos-horários",
    "title": "9  Trabalhando com datas",
    "section": "9.10 Conversão de datas / fusos horários",
    "text": "9.10 Conversão de datas / fusos horários\nQuando os dados estão presentes em fusos horários diferentes, muitas vezes pode ser importante padronizar esses dados em um fuso horário unificado. Isso pode representar um desafio adicional, pois o componente de fuso horário dos dados deve ser codificado manualmente na maioria dos casos.\nNo R, cada objeto datetime possui um componente de fuso horário. Por padrão, todos os objetos datetime levarão o fuso horário local do computador que está sendo usado - isso geralmente é específico para um local em vez de um nome do fuso horário, pois os fusos horários geralmente mudam nos locais devido ao horário de verão. Não é possível compensar com precisão os fusos horários sem um componente de tempo de uma data, pois o evento que uma coluna de data representa não pode ser atribuído a um tempo específico e, portanto, as mudanças de tempo medidas em horas não podem ser razoavelmente contabilizadas.\nPara lidar com fusos horários, há várias funções auxiliares no lubridate que podem ser usadas para alterar o fuso horário de um objeto datetime do seu fuso horário local para um fuso horário diferente. Os fusos horários são definidos atribuindo um fuso horário do banco de dados tz válido ao objeto datetime. Uma lista deles pode ser encontrada aqui - se o local do qual você está usando os dados não estiver nessa lista, grandes cidades próximas no fuso horário estão disponíveis e têm a mesma finalidade.\nhttps://en.wikipedia.org/wiki/List_of_tz_database_time_zones\n\n# atribuir a hora atual a uma coluna\ntime_now &lt;- Sys.time()\ntime_now\n\n[1] \"2024-05-08 12:15:57 CEST\"\n\n# use with_tz() para atribuir um novo fuso horário à coluna, enquanto ALTERA a hora do relógio\ntime_london_real &lt;- with_tz(time_now, \"Europe/London\")\n\n# use force_tz() para atribuir um novo fuso horário para a coluna, enquanto MANTÉM a hora do relógio\ntime_london_local &lt;- force_tz(time_now, \"Europe/London\")\n\n\n# observe que, desde que o computador usado para executar este código NÃO esteja definido para o horário de Londres,\n# haverá uma diferença nos horários\n# (o número de horas de diferença do fuso horário do computador para Londres)\ntime_london_real - time_london_local\n\nTime difference of -1 hours\n\n\nIsso pode parecer muito abstrato e geralmente não é necessário se o usuário não estiver trabalhando em outros fusos horários.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Trabalhando com datas</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.pt.html#cálculos-com-valores-anteriores-ou-posteriores",
    "href": "new_pages/dates.pt.html#cálculos-com-valores-anteriores-ou-posteriores",
    "title": "9  Trabalhando com datas",
    "section": "9.11 Cálculos com valores anteriores ou posteriores",
    "text": "9.11 Cálculos com valores anteriores ou posteriores\nlead() and lag() são funções do pacote dplyr que ajudam a encontrar valores anteriores (lag) ou subsequentes (lead) em um vetor - normalmente um vetor numérico ou de data. Isso é útil ao fazer cálculos de mudança / diferença entre unidades de tempo.\nDigamos que você queira calcular a diferença de casos entre uma semana atual e a anterior. Os dados são fornecidos inicialmente em contagens semanais, conforme mostrado abaixo.\n\n\n\n\n\n\nAo usar lag() ou lead(), a ordem das linhas no seus dados é muito importante! - preste atenção se suas datas / números estão de forma crescentes ou decrescentes\nPrimeiro, crie uma nova coluna contendo o valor da semana anterior (defasada).\n\nControle o número de unidades para trás / para frente com n = (deve ser um número inteiro não negativo)\n\nUse default = para definir o valor colocado em linhas não existentes (por exemplo, a primeira linha para a qual não há valor defasado). Por padrão, isso é NA.\n\nUse order_by = TRUE se suas linhas não estiverem ordenadas por sua coluna de referência\n\n\ncounts &lt;- counts %&gt;% \n  mutate(cases_prev_wk = lag(cases_wk, n = 1))\n\n\n\n\n\n\n\nA seguir, crie uma nova coluna que é a diferença entre as duas colunas de casos:\n\ncounts &lt;- counts %&gt;% \n  mutate(cases_prev_wk = lag(cases_wk, n = 1),\n         case_diff = cases_wk - cases_prev_wk)\n\n\n\n\n\n\n\nVocê pode ler mais sobre lead() e lag() no documento aqui ou inserindo ?lag no seu console.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Trabalhando com datas</span>"
    ]
  },
  {
    "objectID": "new_pages/dates.pt.html#recursos",
    "href": "new_pages/dates.pt.html#recursos",
    "title": "9  Trabalhando com datas",
    "section": "9.12 Recursos",
    "text": "9.12 Recursos\nlubridate página tidyverse\nlubridate RStudio cheatsheet\nR para Ciência dos Dados na página datas e horas\nTutorial Online de Formatos de datas",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Trabalhando com datas</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.pt.html",
    "href": "new_pages/characters_strings.pt.html",
    "title": "10  Caracteres e strings",
    "section": "",
    "text": "10.1 Preparação",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Caracteres e strings</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.pt.html#preparação",
    "href": "new_pages/characters_strings.pt.html#preparação",
    "title": "10  Caracteres e strings",
    "section": "",
    "text": "Carregue os pacotes\nInstale ou carregue o stringr e outros pacotes tidyverse.\n\n# instalar/carregar pacotes\npacman::p_load(\n  stringr,    # muitas funções para lidar com strings\n  tidyverse,  # para manipulação opicional de dados\n  tools)      # alternativa para converter para maiúsculas\n\n\n\nImportar os dados\nNesta página, faremos referência ocasional à linelist, uma lista de casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar, clique para realizar o download “clean linelist” (como arquivo .rds). Importe dados com a função import() do pacote rio (ele lida com muitos tipos de arquivo como .xlsx, .csv, .rds - veja a página Importar e exportar para detalhes).\n\n# Exemplo de importação \nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nAs primeiras 50 linhas da lista estão exibidas abaixo.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Caracteres e strings</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.pt.html#unir-dividir-e-organizar",
    "href": "new_pages/characters_strings.pt.html#unir-dividir-e-organizar",
    "title": "10  Caracteres e strings",
    "section": "10.2 Unir, dividir e organizar",
    "text": "10.2 Unir, dividir e organizar\nEssa seção aborda:\n\nO uso das funções str_c(), str_glue(), e unite() para combinar strings (caracteres ou descrições)\n\nO uso da função str_order() para organizar strings\n\nO uso das funções str_split() e separate() para dividir strings\n\n\n\nCombinar strings\nPara combinar ou concatenar múltiplos strings em um único string, sugerimos usar str_c do stringr. Se você tiver distintos valores de caracteres para combinar, basta fornecê-los como argumentos exclusivos, separados por vírgulas.\n\nstr_c(\"String1\", \"String2\", \"String3\")\n\n[1] \"String1String2String3\"\n\n\nO argumento sep = insere um valor de caractere entre cada um dos argumentos fornecidos (por exemplo, inserir uma vírgula, espaço ou nova linha \"\\n\")\n\nstr_c(\"String1\", \"String2\", \"String3\", sep = \", \")\n\n[1] \"String1, String2, String3\"\n\n\nO argumento collapse = é relevante se você estiver inserindo múltiplos vetores como argumentos para a função str_c(). Ele é usado para separar os elementos do que seria um vetor de saída, de forma que o vetor de saída tenha apenas um longo elemento de caractere.\nO exemplo abaixo mostra a combinação de dois vetores em um (nomes e sobrenomes). Outro exemplo semelhante pode ser sobre jurisdições e suas contagens de casos. Neste exemplo:\n\nO valor sep = aparece entre cada nome e sobrenome\n\nO valor collapse = aparece entre cada pessoa\n\n\nfirst_names &lt;- c(\"abdul\", \"fahruk\", \"janice\") \nlast_names  &lt;- c(\"hussein\", \"akinleye\", \"okeke\")\n\n# sep é exibido entre as respectivas strings de entrada, enquanto collapse é exibido entre os elementos produzidos\nstr_c(first_names, last_names, sep = \" \", collapse = \";  \")\n\n[1] \"abdul hussein;  fahruk akinleye;  janice okeke\"\n\n\nNota: Dependendo do contexto de exibição desejado, ao imprimir/exibir uma string combinada com novas linhas, você pode precisar inserir a frase inteira em cat() para que as novas linhas sejam impressas/exibidas corretamente:\n\n# Para que as novas linhas sejam impressas corretamente, a frase pode precisar estar inserida na função cat()\ncat(str_c(first_names, last_names, sep = \" \", collapse = \";\\n\"))\n\nabdul hussein;\nfahruk akinleye;\njanice okeke\n\n\n\n\n\nStrings dinâmicas\nUse str_glue() para inserir um código R dinâmico em um string. Esta é uma função muito útil para criar legendas dinâmicas de gráficos, conforme demonstrado abaixo.\n\nTodo o conteúdo fica entre aspas duplas str_glue(\"\")\n\nQualquer código dinâmico ou referências aos valores predefinidos são colocados entre chaves {} com aspas duplas. Pode haver muitas chaves no mesmo comando str_glue().\n\nPara exibir aspas como caracter ’’, use aspas simples entre aspas duplas (por exemplo, ao fornecer o formato de data - veja o exemplo abaixo)\n\nDica: você pode usar \\n para forçar uma nova linha\n\nDica: você usa format() para ajustar a exibição da data e usa Sys.Date() para exibir a data atual\n\nUm simples exemplo da gráfico com legenda dinâmica:\n\nstr_glue(\"Os dados incluem {nrow(linelist)} casos e são atuais para {format(Sys.Date(), '%d %b %Y')}.\")\n\nOs dados incluem 5888 casos e são atuais para 08 May 2024.\n\n\nUm formato alternativo é usar espaços reservados dentro dos colchetes e definir o código em argumentos separados no final da função str_glue(), conforme abaixo. Isso pode melhorar a legibilidade do código se o texto for longo.\n\nstr_glue(\"Lista  em {current_date}.\\n dos último casos hospitalizados no {last_hospital}.\\n{n_missing_onset} casos sem data de início e não mostrados\",\n         current_date = format(Sys.Date(), '%d %b %Y'),\n         last_hospital = format(as.Date(max(linelist$date_hospitalisation, na.rm=T)), '%d %b %Y'),\n         n_missing_onset = nrow(linelist %&gt;% filter(is.na(date_onset)))\n         )\n\nLista  em 08 May 2024.\n dos último casos hospitalizados no 30 Apr 2015.\n256 casos sem data de início e não mostrados\n\n\nExtraindo de uma tabela de dados\nÀs vezes, é útil extrair dados de um data frame e colá-los juntos na sequência. Abaixo está um exemplo de data frame. Vamos usá-lo para fazer uma declaração resumida sobre as jurisdições e as contagens de casos novos e totais.\n\n# fazer um data frame de casos\ncaso_tabela &lt;- data.frame(\n  zone        = c(\"Zone 1\", \"Zone 2\", \"Zone 3\", \"Zone 4\", \"Zone 5\"),\n  novos_casos   = c(3, 0, 7, 0, 15),\n  total_casos = c(40, 4, 25, 10, 103)\n  )\n\n\n\n\n\n\n\nUse str_glue_data(), que é feito especialmente para obter dados de linhas do data frame:\n\ncaso_tabela %&gt;% \n  str_glue_data(\"{zone}: {novos_casos} ({total_casos} total casos)\")\n\nZone 1: 3 (40 total casos)\nZone 2: 0 (4 total casos)\nZone 3: 7 (25 total casos)\nZone 4: 0 (10 total casos)\nZone 5: 15 (103 total casos)\n\n\nCombine strings em linhas\nSe você estiver tentando “acumular” valores em uma coluna de um data frame, por exemplo, combinar valores de várias linhas em apenas uma linha, colando-os juntos com um separador, consulte a seção da página Eliminação de duplicidades em “acumulando” valores.\nData frame para uma linha\nVocê pode fazer a frase aparecer em uma linha usando str_c() (especificando o data frame e os nomes das colunas) e fornecendo os argumentos sep = e collapse =.\n\nstr_c(caso_tabela$zone, caso_tabela$novos_casos, sep = \" = \", collapse = \";  \")\n\n[1] \"Zone 1 = 3;  Zone 2 = 0;  Zone 3 = 7;  Zone 4 = 0;  Zone 5 = 15\"\n\n\nVocê poderia adicionar o texto “Novos Casos:” ao início da instrução envolvendo a função com str_c() (se “Novos Casos:” estivesse dentro do str_c() original, ele apareceria várias vezes).\n\nstr_c(\"Novos Casos: \", str_c(caso_tabela$zone, caso_tabela$novos_casos, sep = \" = \", collapse = \";  \"))\n\n[1] \"Novos Casos: Zone 1 = 3;  Zone 2 = 0;  Zone 3 = 7;  Zone 4 = 0;  Zone 5 = 15\"\n\n\n\n\nUnir colunas\nDentro de uma tabela de dados, reunir valores de caracteres de várias colunas pode ser obtido com unite() do pacote tidyr. Isso é o oposto de separate().\nForneça o nome da nova coluna unida. Em seguida, forneça os nomes das colunas que deseja unir.\n\nPor padrão, o separador usado na coluna unida é o underline _, mas isso pode ser alterado com o argumento sep =.\n\nremove = rremove as colunas de entrada da tabela de dados (TRUE por padrão)\n\nna.rm = remove os valores ausentes durante a união (FALSE por padrão)\n\nAbaixo, definimos uma mini-tabela de dados para demonstrar:\n\ndf &lt;- data.frame(\n  case_ID = c(1:6),\n  symptoms  = c(\"jaundice, fever, chills\",     # paciente 1\n                \"chills, aches, pains\",        # paciente 2 \n                \"fever\",                       # paciente 3\n                \"vomiting, diarrhoea\",         # paciente 4\n                \"bleeding from gums, fever\",   # paciente 5\n                \"rapid pulse, headache\"),      # paciente 6\n  outcome = c(\"Recover\", \"Death\", \"Death\", \"Recover\", \"Recover\", \"Recover\"))\n\n\ndf_split &lt;- separate(df, symptoms, into = c(\"sym_1\", \"sym_2\", \"sym_3\"), extra = \"merge\")\n\nWarning: Expected 3 pieces. Missing pieces filled with `NA` in 2 rows [3, 4].\n\n\nAqui está o exemplo da tabela de dados:\n\n\n\n\n\n\nAbaixo, unimos as três colunas de sintomas:\n\ndf_split %&gt;% \n  unite(\n    col = \"all_symptoms\",         # nome da nova coluna unida\n    c(\"sym_1\", \"sym_2\", \"sym_3\"), # colunas para unir\n    sep = \", \",                   # separador para usar na coluna unida\n    remove = TRUE,                # se TRUE (verdadeiro), remove colunas de entrada da tabela de dados\n    na.rm = TRUE                  # se TRUE, os valores ausentes são removidos antes da união\n  )\n\n  case_ID                all_symptoms outcome\n1       1     jaundice, fever, chills Recover\n2       2        chills, aches, pains   Death\n3       3                       fever   Death\n4       4         vomiting, diarrhoea Recover\n5       5 bleeding, from, gums, fever Recover\n6       6      rapid, pulse, headache Recover\n\n\n\n\n\nDividir\nPara dividir um objeto de texto (string) com base em um padrão, use str_split(). Ele avalia o(s) string(s) e retorna uma list de vetores de caracteres que consistem nos valores recém-divididos.\nO exemplo simples abaixo avalia uma string e a divide em três. Por padrão, ele retorna um objeto da list de classes com um elemento (um vetor de caracteres) para cada string fornecida inicialmente. Se simplify = TRUE, ele retorna uma matriz de caracteres.\nNeste exemplo, uma string é fornecida e a função retorna uma lista com um elemento - um vetor de caracteres com três valores.\n\nstr_split(string = \"jaundice, fever, chills\",\n          pattern = \",\")\n\n[[1]]\n[1] \"jaundice\" \" fever\"   \" chills\" \n\n\nSe o resultado de saída for salvo, você poderá acessar o enésimo valor de divisão com a sintaxe de colchetes. Para acessar um valor específico, você pode usar uma sintaxe como esta: the_returned_object[[1]][2], que acessaria o segundo valor da primeira string avaliada (“febre”). Consulte a página Introdução ao R para obter mais detalhes sobre como acessar os elementos.\n\npt1_symptoms &lt;- str_split(\"jaundice, fever, chills\", \",\")\n\npt1_symptoms[[1]][2]  # extrai o segundo valor do primeiro (e único) elemento da lista\n\n[1] \" fever\"\n\n\nSe múltiplos strings forem fornecidas por str_split(), haverá mais de um elemento na lista retornada.\n\nsymptoms &lt;- c(\"jaundice, fever, chills\",     # paciente 1\n              \"chills, aches, pains\",        # paciente 2 \n              \"fever\",                       # paciente 3\n              \"vomiting, diarrhoea\",         # paciente 4\n              \"bleeding from gums, fever\",   # paciente 5\n              \"rapid pulse, headache\")       # paciente 6\n\nstr_split(symptoms, \",\")                     # dividir os sintomas de cada paciente\n\n[[1]]\n[1] \"jaundice\" \" fever\"   \" chills\" \n\n[[2]]\n[1] \"chills\" \" aches\" \" pains\"\n\n[[3]]\n[1] \"fever\"\n\n[[4]]\n[1] \"vomiting\"   \" diarrhoea\"\n\n[[5]]\n[1] \"bleeding from gums\" \" fever\"            \n\n[[6]]\n[1] \"rapid pulse\" \" headache\"  \n\n\nPara retornar uma “matriz de caracteres”, que pode ser útil ao criar colunas de tabela de dados, defina o argumento simplify = TRUE como mostrado abaixo:\n\nstr_split(symptoms, \",\", simplify = TRUE)\n\n     [,1]                 [,2]         [,3]     \n[1,] \"jaundice\"           \" fever\"     \" chills\"\n[2,] \"chills\"             \" aches\"     \" pains\" \n[3,] \"fever\"              \"\"           \"\"       \n[4,] \"vomiting\"           \" diarrhoea\" \"\"       \n[5,] \"bleeding from gums\" \" fever\"     \"\"       \n[6,] \"rapid pulse\"        \" headache\"  \"\"       \n\n\nVocê também pode ajustar o número de divisões a serem criadas com o argumento n =. Por exemplo, isso restringe o número de divisões a 2. Quaisquer outras vírgulas permanecem dentro dos segundos valores.\n\nstr_split(symptoms, \",\", simplify = TRUE, n = 2)\n\n     [,1]                 [,2]            \n[1,] \"jaundice\"           \" fever, chills\"\n[2,] \"chills\"             \" aches, pains\" \n[3,] \"fever\"              \"\"              \n[4,] \"vomiting\"           \" diarrhoea\"    \n[5,] \"bleeding from gums\" \" fever\"        \n[6,] \"rapid pulse\"        \" headache\"     \n\n\nOservação - as mesmas saídas podem ser obtidas com str_split_fixed(), em que você não fornece o argumento simplify, mas deve designar o número de colunas (n).\n\nstr_split_fixed(symptoms, \",\", n = 2)\n\n\n\nDividir colunas\nSe você está tentando dividir a coluna da tabela de dados, é melhor usar a função separate() do dplyr. É usado para dividir uma coluna de caracteres em outras colunas.\nDigamos que temos uma simples tabela de dados df (definida e unida na seção Unir) contendo uma coluna case_ID, uma coluna de caractere com muitos sintomas e uma coluna de resultado. Nosso objetivo é separar a coluna de symptoms em várias colunas - cada uma contendo um sintoma.\n\n\n\n\n\n\nAssumindo que os dados sejam divididos por meio do separate(), primeiro forneça a coluna a ser separada. Em seguida, forneça into = como um vetor c( ) contendo os novos nomes das colunas, conforme mostrado abaixo.\n\nsep = o separador, pode ser um caractere ou um número (interpretado como a posição do caractere para dividir)\nremove = FALSE por padrão, remove a coluna de entrada\nconvert = FALSE por padrão, fará com que a string “NA” se torne NA\nextra = isso controla o que acontece se houver mais valores criados pela separação do que novas colunas nomeadas.\nextra = \"warn\" significa que você verá um aviso, mas os valores em excesso serão descartados (o padrão)\nextra = \"drop\" significa que os valores em excesso serão descartados sem aviso\n**extra = \"merge\" somente será dividido para o número de novas colunas listadas em into - *esta configuração preservará todos os seus dados**\n\nUm exemplo com extra = \"merge\" está abaixo - nenhum dado é perdido. Duas novas colunas são definidas, mas quaisquer terceiros sintomas são combinados na segunda coluna nova:\n\n# terceiros sintomas combinados na segunda nova coluna\ndf %&gt;% \n  separate(symptoms, into = c(\"sym_1\", \"sym_2\"), sep=\",\", extra = \"merge\")\n\nWarning: Expected 2 pieces. Missing pieces filled with `NA` in 1 rows [3].\n\n\n  case_ID              sym_1          sym_2 outcome\n1       1           jaundice  fever, chills Recover\n2       2             chills   aches, pains   Death\n3       3              fever           &lt;NA&gt;   Death\n4       4           vomiting      diarrhoea Recover\n5       5 bleeding from gums          fever Recover\n6       6        rapid pulse       headache Recover\n\n\nQuando o padrão extra = \"drop\" é usado abaixo, um aviso é dado, mas os terceiros sintomas são perdidos:\n\n# terceiros sintomas são perdidos\ndf %&gt;% \n  separate(symptoms, into = c(\"sym_1\", \"sym_2\"), sep=\",\")\n\nWarning: Expected 2 pieces. Additional pieces discarded in 2 rows [1, 2].\n\n\nWarning: Expected 2 pieces. Missing pieces filled with `NA` in 1 rows [3].\n\n\n  case_ID              sym_1      sym_2 outcome\n1       1           jaundice      fever Recover\n2       2             chills      aches   Death\n3       3              fever       &lt;NA&gt;   Death\n4       4           vomiting  diarrhoea Recover\n5       5 bleeding from gums      fever Recover\n6       6        rapid pulse   headache Recover\n\n\nCUIDADO: Se você não fornecer valores suficientes into para as novas colunas, seus dados podem ser truncados.\n\n\n\nOrganizar em ordem alfabética\nVárias strings podem ser classificadas em ordem alfabética. str_order() retorna a ordem, enquanto str_sort() retorna as strings nessa ordem.\n\n# strings\nhealth_zones &lt;- c(\"Alba\", \"Takota\", \"Delta\")\n\n# retornar a ordem alfabética\nstr_order(health_zones)\n\n[1] 1 3 2\n\n# retornar as strings em ordem alfabética\nstr_sort(health_zones)\n\n[1] \"Alba\"   \"Delta\"  \"Takota\"\n\n\nPara usar um alfabeto diferente, adicione o argumento locale =. Veja a lista completa de localidades digitando stringi::stri_locale_list() no R console.\n\n\n\nFunções do R base\nÉ comum ver as funções do R base paste() e paste0(), que concatenam vetores após converter todas as partes em caracteres. Eles agem de forma semelhante a str_c() , mas a sintaxe é indiscutivelmente mais complicada - entre parênteses cada parte é separada por uma vírgula. As partes são textos de caracteres (entre aspas) ou objetos de código predefinidos (sem aspas). Por exemplo:\n\nn_beds &lt;- 10\nn_masks &lt;- 20\n\npaste0(\"Hospital regional precisa \", n_beds, \" camas e \", n_masks, \" máscaras.\")\n\n[1] \"Hospital regional precisa 10 camas e 20 máscaras.\"\n\n\nOs argumentos sep = e collapse = podem ser especificados. paste() é simplesmente paste0() com um sep = \" \" padrão (um espaço).",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Caracteres e strings</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.pt.html#limpe-e-padronize",
    "href": "new_pages/characters_strings.pt.html#limpe-e-padronize",
    "title": "10  Caracteres e strings",
    "section": "10.3 Limpe e padronize",
    "text": "10.3 Limpe e padronize\n\n\nMudar maiúsculas e minúsculas\nFrequentemente, é necessário alterar a capitalização / maiúsculas de um valor de string, por exemplo, nomes de jursidições. Use str_to_upper(), str_to_lower(), e str_to_title(), de stringr, como mostrado abaixo:\n\nstr_to_upper(\"California\")\n\n[1] \"CALIFORNIA\"\n\nstr_to_lower(\"California\")\n\n[1] \"california\"\n\n\nUsando R base, o acima também pode ser obtido com toupper(), tolower().\nCapitalização de título\nTransformar o string para que cada palavra inicie com maiúscula pode ser conseguido com str_to_title():\n\nstr_to_title(\"go to the US state of california \")\n\n[1] \"Go To The Us State Of California \"\n\n\nUse toTitleCase() do pacote tools para obter uma capitalização mais sutil (palavras como “para”, “o” e “de” não são capitalizadas).\n\ntools::toTitleCase(\"Este é o estado da califórnia dos EUA\")\n\n[1] \"Este é o Estado Da Califórnia Dos EUA\"\n\n\nVocê também pode usar str_to_sentence(), que coloca em maiúscula apenas a primeira letra do string.\n\nstr_to_sentence(\"o paciente precisa ser transportado\")\n\n[1] \"O paciente precisa ser transportado\"\n\n\n\n\nComprimento do código\nUse str_pad() para adicionar caracteres a uma string, com um comprimento mínimo. Por padrão, espaços são adicionados, mas você também pode preencher com outros caracteres usando o argumento pad =.\n\n# Códigos ICD de comprimento diferente\nICD_codes &lt;- c(\"R10.13\",\n               \"R10.819\",\n               \"R17\")\n\n# Códigos ICD preenchidos com 7 caracteres no lado direito\nstr_pad(ICD_codes, 7, \"right\")\n\n[1] \"R10.13 \" \"R10.819\" \"R17    \"\n\n# Pad com pontos em vez de espaços\nstr_pad(ICD_codes, 7, \"right\", pad = \".\")\n\n[1] \"R10.13.\" \"R10.819\" \"R17....\"\n\n\nPor exemplo, para preencher números com zeros à esquerda (como para horas ou minutos), você pode preencher o número com o comprimento mínimo de 2 com pad = \"0\".\n\n# Adicione zeros à esquerda de dois dígitos (por exemplo, para tempos minutos / horas)\nstr_pad(\"4\", 2, pad = \"0\") \n\n[1] \"04\"\n\n# exemplo usando uma coluna numérica chamada \"horas\"\n# hours &lt;- str_pad(hours, 2, pad = \"0\")\n\n\n\nTruncar\nstr_trunc() define um comprimento máximo para cada string. Se uma string exceder esse comprimento, ela será truncada (encurtada) e uma reticência (…) será incluída para indicar que a string era anteriormente mais longa. Observe que as reticências são counted contadas no comprimento. Os caracteres de reticências podem ser alterados com o argumento ellipsis =. O argumento opcional side = especifica onde as reticências aparecerão dentro da string truncada (“esquerda”, “direita” ou “centro”).\n\noriginal &lt;- \"Symptom onset on 4/3/2020 with vomiting\"\nstr_trunc(original, 10, \"center\")\n\n[1] \"Symp...ing\"\n\n\n\n\nPadronizar comprimento\nUse str_trunc() para definir um comprimento máximo, e então use str_pad() para expandir as strings muito curtas para aquele comprimento truncado. No exemplo abaixo, 6 é definido como o comprimento máximo (um valor é truncado) e, em seguida, um valor muito curto é preenchido para atingir o comprimento de 6.\n\n# Códigos ICD de comprimento diferente\nICD_codes   &lt;- c(\"R10.13\",\n                 \"R10.819\",\n                 \"R17\")\n\n# truncar com comprimento máximo de 6\nICD_codes_2 &lt;- str_trunc(ICD_codes, 6)\nICD_codes_2\n\n[1] \"R10.13\" \"R10...\" \"R17\"   \n\n# expandir para comprimento mínimo de 6\nICD_codes_3 &lt;- str_pad(ICD_codes_2, 6, \"right\")\nICD_codes_3\n\n[1] \"R10.13\" \"R10...\" \"R17   \"\n\n\n\n\nRemova os espaços em branco à esquerda / à direita\nUse str_trim() para remover espaços, \\n para novas linhas ou tabulações (\\t) nos lados de uma entrada de string. Adicione \"right\" \"left\", ou \"both\" ao comando para especificar qual lado cortar (por exemplo, str_trim(x, \"right\").\n\n# Números ID com espaços em excesso à direita\nIDs &lt;- c(\"provA_1852  \", # dois espaços excedentes\n         \"provA_2345\",   # zero espaço excedente\n         \"provA_9460 \")  # um espaço excedente\n\n# IDs cortados para remover espaços em excesso apenas no lado direito\nstr_trim(IDs)\n\n[1] \"provA_1852\" \"provA_2345\" \"provA_9460\"\n\n\n\n\nRemova os espaços em branco repetidos dentro do texto\nUse str_squish() para remover espaços repetidos que aparecem dentro de uma string. Por exemplo, para converter espaços duplos em espaços simples. Ele também remove espaços, novas linhas ou tabulações do lado de fora da string como str_trim().\n\n# o original contém espaços em excesso dentro da string\nstr_squish(\"  Pt requires   IV saline\\n\") \n\n[1] \"Pt requires IV saline\"\n\n\nDigite ?str_trim, ?str_pad em seu console R para ver mais detalhes.\n\n\nQuebrar em parágrafos\nUse str_wrap() para quebrar um texto longo e não estruturado em um parágrafo estruturado com comprimento de linha fixo. Fornece o comprimento de caractere ideal para cada linha e aplica um algoritmo para inserir novas linhas (\\n) dentro do parágrafo, conforme mostrado no exemplo abaixo.\n\npt_course &lt;- \"início dos sintomas 04/01/2020 vômito febre calafrios. Pt viu um curandeiro tradicional na aldeia natal em 04/02/2020. Em 04/05/2020 os sintomas de pt se agravaram e foi internado na clínica de Lumta. A amostra foi coletada e o pt foi transportado para o hospital regional em 04/06/2020. Pt morreu no hospital regional em 04/07/2020.\"\n\nstr_wrap(pt_course, 40)\n\n[1] \"início dos sintomas 04/01/2020 vômito\\nfebre calafrios. Pt viu um curandeiro\\ntradicional na aldeia natal em\\n04/02/2020. Em 04/05/2020 os sintomas\\nde pt se agravaram e foi internado na\\nclínica de Lumta. A amostra foi coletada\\ne o pt foi transportado para o hospital\\nregional em 04/06/2020. Pt morreu no\\nhospital regional em 04/07/2020.\"\n\n\nA função base cat() pode ser envolvida no comando acima para mostrar o resultado, exibindo as novas linhas adicionadas.\n\ncat(str_wrap(pt_course, 40))\n\ninício dos sintomas 04/01/2020 vômito\nfebre calafrios. Pt viu um curandeiro\ntradicional na aldeia natal em\n04/02/2020. Em 04/05/2020 os sintomas\nde pt se agravaram e foi internado na\nclínica de Lumta. A amostra foi coletada\ne o pt foi transportado para o hospital\nregional em 04/06/2020. Pt morreu no\nhospital regional em 04/07/2020.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Caracteres e strings</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.pt.html#manipular-por-posição",
    "href": "new_pages/characters_strings.pt.html#manipular-por-posição",
    "title": "10  Caracteres e strings",
    "section": "10.4 Manipular por posição",
    "text": "10.4 Manipular por posição\n\nExtrair pela posição dos caracteres\nUse str_sub() para retornar apenas uma parte de uma string. A função tem três argumentos principais:\n\no(s) vetor(es) de caracteres\nposição inicial\nposição final\n\nAlgumas notas sobre os números de posição:\n\nSe um número de posição for positivo, a posição é contada a partir da extremidade esquerda da string.\nSe um número de posição for negativo, ele é contado a partir da extremidade direita da string.\nOs números das posições são inclusivos.\nAs posições que se estendem além da string serão truncadas (removidas).\n\nAbaixo estão alguns exemplos aplicados à string “pneumonia”:\n\n# começar e terminar em terceiro da esquerda (3ª letra da esquerda)\nstr_sub(\"pneumonia\", 3, 3)\n\n[1] \"e\"\n\n# 0 não está presente\nstr_sub(\"pneumonia\", 0, 0)\n\n[1] \"\"\n\n# 6º da esquerda, para o 1º da direita\nstr_sub(\"pneumonia\", 6, -1)\n\n[1] \"onia\"\n\n# 5º da direita, para o 2º da direita\nstr_sub(\"pneumonia\", -5, -2)\n\n[1] \"moni\"\n\n# 4º da esquerda para uma posição fora da string\nstr_sub(\"pneumonia\", 4, 15)\n\n[1] \"umonia\"\n\n\n\n\nExtrair por posição de palavra\nPara extrair a enésima ‘palavra’, use word(), também do pacote stringr. Forneça as strings (descriçoes), a posição da primeira palavra a extrair e a posição da última palavra a extrair.\nPor padrão, o separador entre ‘palavras’ é considerado um espaço, a menos que indicado de outra forma com sep = (por exemplo, sep = \"_\" quando as palavras são separadas por underlines).\n\n# strings para avaliar\nchief_complaints &lt;- c(\"Acabei de sair do hospital há 2 dias, mas ainda mal consigo respirar.\",\n                      \"Meu estômago dói\",\n                      \"Dor de ouvido severa\")\n\n# extraia a 1ª a 3ª palavras de cada string (descrição)\nword(chief_complaints, start = 1, end = 3, sep = \" \")\n\n[1] \"Acabei de sair\"   \"Meu estômago dói\" \"Dor de ouvido\"   \n\n\n\n\nSubstituir pela posição do caractere\nstr_sub() emparelhado com o operador de atribuição (&lt;-) pode ser usado para modificar uma parte de uma string:\n\nword &lt;- \"pneumonia\"\n\n# converter o terceiro e o quarto caracteres em X \nstr_sub(word, 3, 4) &lt;- \"XX\"\n\n# exibe\nword\n\n[1] \"pnXXmonia\"\n\n\nUm exemplo aplicado a várias strings (por exemplo, uma coluna). Observe a expansão do comprimento de “HIV”.\n\nwords &lt;- c(\"pneumonia\", \"tubercolose\", \"HIV\")\n\n# converter o terceiro e o quarto caracteres em X \nstr_sub(words, 3, 4) &lt;- \"XX\"\n\nwords\n\n[1] \"pnXXmonia\"   \"tuXXrcolose\" \"HIXX\"       \n\n\n\n\nAvalie o comprimento\n\nstr_length(\"abc\")\n\n[1] 3\n\n\nAlternativamente, use nchar() do R base",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Caracteres e strings</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.pt.html#padrões",
    "href": "new_pages/characters_strings.pt.html#padrões",
    "title": "10  Caracteres e strings",
    "section": "10.5 Padrões",
    "text": "10.5 Padrões\nMuitas funções stringr trabalham para detectar, localizar, extrair, combinar, substituir e dividir com base em um padrão especificado.\n\n\nDetectar um padrão\nUse str_detect() como abaixo para detectar a presença / ausência de um padrão dentro de uma string. Primeiro forneça a string ou vetor a ser pesquisado (string =) e, em seguida, o padrão a ser procurado (pattern =). Observe que, por padrão, a pesquisa diferencia maiúsculas de minúsculas!\n\nstr_detect(string = \"professor de escola primária\", pattern = \"prof\")\n\n[1] TRUE\n\n\nO argumento negate = pode ser incluído e definido como TRUE se você quiser saber se o padrão NÃO está presente.\n\nstr_detect(string = \"professor de escola primária\", pattern = \"prof\", negate = TRUE)\n\n[1] FALSE\n\n\nPara ignorar maiúsculas e minúsculas, envolva o padrão em regex(), e em regex() adicione o argumento ignore_case = TRUE (ou T como abreviação).\n\nstr_detect(string = \"Professor\", pattern = regex(\"prof\", ignore_case = T))\n\n[1] TRUE\n\n\nQuando str_detect() é aplicado a um vetor de caracteres ou uma coluna da tabela de dados, ele retornará TRUE ou FALSE para cada um dos valores.\n\n# um vetor / coluna de ocupações\noccupations &lt;- c(\"trabalhador do campo\",\n                 \"professor universitário\",\n                 \"educador de escola primária\",\n                 \"tutor\",\n                 \"enfermeira em hospital regional\",\n                 \"eletricita da Fábrica em Amberdeen\",\n                 \"médico\",\n                 \"cardiologista\",\n                 \"trabalhador de escritório\",\n                 \"trabalhador de serviço de alimentação\")\n\n# Detecta a presença do padrão \"prof\" em cada string - a saída é um vetor TRUE / FALSE\nstr_detect(occupations, \"prof\")\n\n [1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nSe você precisar contar os TRUEs, simplesmente some os resultados por meio da função sum(). Essa função conta o número de TRUE.\n\nsum(str_detect(occupations, \"prof\"))\n\n[1] 1\n\n\nPara pesquisar incluindo vários termos, inclua-os separados por barras OR (|) dentro do argumento pattern =, conforme mostrado abaixo:\n\nsum(str_detect(string = occupations, pattern = \"prof|educador|tutor\"))\n\n[1] 3\n\n\nSe precisar construir uma longa lista de termos de pesquisa, você pode combiná-los usando str_c() e sep = |, em seguida defina que este é um objeto de caractere e referencie o vetor posteriormente de forma mais sucinta. O exemplo abaixo inclui possíveis termos de pesquisa de ocupação para provedores médicos de linha de frente.\n\n# termos de busca\noccupation_med_frontline &lt;- str_c(\"medical\", \"medicine\", \"hcw\", \"healthcare\", \"home care\", \"home health\",\n                                \"surgeon\", \"doctor\", \"doc\", \"physician\", \"surgery\", \"peds\", \"pediatrician\",\n                               \"intensivist\", \"cardiologist\", \"coroner\", \"nurse\", \"nursing\", \"rn\", \"lpn\",\n                               \"cna\", \"pa\", \"physician assistant\", \"mental health\",\n                               \"emergency department technician\", \"resp therapist\", \"respiratory\",\n                                \"phlebotomist\", \"pharmacy\", \"pharmacist\", \"hospital\", \"snf\", \"rehabilitation\",\n                               \"rehab\", \"activity\", \"elderly\", \"subacute\", \"sub acute\",\n                                \"clinic\", \"post acute\", \"therapist\", \"extended care\",\n                                \"dental\", \"dential\", \"dentist\", sep = \"|\")\n\noccupation_med_frontline\n\n[1] \"medical|medicine|hcw|healthcare|home care|home health|surgeon|doctor|doc|physician|surgery|peds|pediatrician|intensivist|cardiologist|coroner|nurse|nursing|rn|lpn|cna|pa|physician assistant|mental health|emergency department technician|resp therapist|respiratory|phlebotomist|pharmacy|pharmacist|hospital|snf|rehabilitation|rehab|activity|elderly|subacute|sub acute|clinic|post acute|therapist|extended care|dental|dential|dentist\"\n\n\nEste comando retorna o número de ocupações que contêm qualquer um dos termos de pesquisa para provedores médicos de linha de frente (occupation_med_frontline):\n\nsum(str_detect(string = occupations, pattern = occupation_med_frontline))\n\n[1] 2\n\n\nFunções de pesquisa de string do R base\nA função base grepl() funciona de forma similar à função str_detect(), no sentido de que procura por correspondências com um padrão e retorna um vetor lógico. A sintaxe básica é grepl(pattern, strings_to_search, ignore.case = FALSE, ...). Uma vantagem é que o argumento ignore.case é mais fácil de escrever (não há necessidade de envolver a função regex()).\nDa mesma forma, as funções de base sub() e gsub() agem de forma semelhante a str_replace(). Sua sintaxe básica é: gsub(pattern, replacement, strings_to_search, ignore.case = FALSE). sub() substituirá a primeira instância do padrão, enquanto gsub() substituirá todas as instâncias do padrão.\n\nConverta vírgulas em pontos\nAqui está um exemplo de uso de gsub() para converter vírgulas em pontos em um vetor de números. Isso pode ser útil se seus dados vierem de outras partes do mundo que não os Estados Unidos ou a Grã-Bretanha.\nO gsub() interno que atua primeiro em lengths convertendo quaisquer pontos em nenhum espaço ““. O caractere de ponto final”.” deve ser “escapado” com duas barras para realmente significar um ponto, porque “.” em regex significa “qualquer caractere”. Em seguida, o resultado (apenas com vírgulas) é passado para o gsub() , no qual as vírgulas são substituídas por pontos.\n\nlengths &lt;- c(\"2.454,56\", \"1,2\", \"6.096,5\")\n\nas.numeric(gsub(pattern = \",\",                # encontra vírgulas   \n                replacement = \".\",            # substitui por pontos\n                x = gsub(\"\\\\.\", \"\", lengths)  # vetor com outros pontos removidos (deve-se \"escapar\" os pontos)\n                )\n           )                                  # converter resultado em numérico\n\n\n\n\nSubstituir tudo\nUse str_replace_all() omo uma ferramenta de “localizar e substituir”. Primeiro, forneça as strings a serem avaliadas para string =, depois o padrão a ser substituído por pattern = e, a seguir, o valor de substituição para replacement =. O exemplo abaixo substitui todas as ocorrências de “morto” por “falecido”. Observe que isso É sensível a maiúsculas e minúsculas.\n\noutcome &lt;- c(\"Karl: morto\",\n            \"Samantha: morto\",\n            \"Marco: não morto\")\n\nstr_replace_all(string = outcome, pattern = \"morto\", replacement = \"óbito\")\n\n[1] \"Karl: óbito\"      \"Samantha: óbito\"  \"Marco: não óbito\"\n\n\nNotas:\n\nPara substituir um padrão por NA, use str_replace_na().\n\nA função str_replace() substitui apenas a primeira instância do padrão em cada string avaliada.\n\n\n\n\nDetectar dentro da lógica\nDentro de case_when()\nstr_detect() é frequentemente usado em case_when() (de dplyr). Digamos que occupations é uma coluna na lista. A função mutate() abaixo cria uma nova coluna chamada is_educator usando lógica condicional via case_when(). Veja a página sobre limpeza de dados para aprender mais sobre case_when().\n\ndf &lt;- df %&gt;% \n  mutate(is_educator = case_when(\n    # pesquisa de termo dentro da ocupação, sem distinção entre maiúsculas e minúsculas\n    str_detect(occupations,\n               regex(\"educador|prof|tutor|universidade\",\n                     ignore_case = TRUE))              ~ \"Educador\",\n    # todos os outros\n    TRUE                                               ~ \"Não é educador\"))\n\nComo um lembrete, pode ser importante adicionar critérios de exclusão à lógica condicional (negate = F):\n\ndf &lt;- df %&gt;% \n  # valor na nova coluna is_educator é baseado na lógica condicional\n  mutate(is_educator = case_when(\n    \n    # a coluna de ocupação deve atender a 2 critérios para ser atribuído \"Educador\":\n    # deve ter um termo de pesquisa E NÃO qualquer termo de exclusão\n    \n    # Deve conter um termo de pesquisa\n    str_detect(occupations,\n               regex(\"educador|prof|tutor|universidade\", ignore_case = T)) &              \n    \n    # E NÃO deve ter um termo de exclusão\n    str_detect(occupations,\n               regex(\"admin\", ignore_case = T),\n               negate = TRUE                        ~ \"Educador\"\n    \n    # Todas as linhas que não atendem aos critérios acima\n    TRUE                                            ~ \"Não é educador\"))\n\n\n\n\nLocalize a posição do padrão\nPara localizar a primeira posição de um padrão, use str_locate(). Ele produz uma posição inicial e final.\n\nstr_locate(\"I wish\", \"sh\")\n\n     start end\n[1,]     5   6\n\n\nComo outras funções str, há uma versão “_all” (str_locate_all()) que retornará as posições de todas as instâncias do padrão dentro de cada string. Isso resulta em uma list.\n\nphrases &lt;- c(\"I wish\", \"I hope\", \"he hopes\", \"He hopes\")\n\nstr_locate(phrases, \"h\" )     # posição da *primeira* instância do padrão\n\n     start end\n[1,]     6   6\n[2,]     3   3\n[3,]     1   1\n[4,]     4   4\n\nstr_locate_all(phrases, \"h\" ) # posição de *cada* instância do padrão\n\n[[1]]\n     start end\n[1,]     6   6\n\n[[2]]\n     start end\n[1,]     3   3\n\n[[3]]\n     start end\n[1,]     1   1\n[2,]     4   4\n\n[[4]]\n     start end\n[1,]     4   4\n\n\n\n\n\nExtraia uma combinação\nstr_extract_all() retorna os próprios padrões de correspondência, o que é mais útil quando você oferece vários padrões por meio de condições “OU”. Por exemplo, procurando no vetor string de ocupações (consulte a aba anterior) “educador”, “prof” ou “tutor”.\nstr_extract_all() retorna uma list que contém todas as correspondências para cada string avaliada. Veja abaixo como a ocupação 3 tem duas correspondências de padrão dentro dela.\n\nstr_extract_all(occupations, \"educador|prof|tutor\")\n\n[[1]]\ncharacter(0)\n\n[[2]]\n[1] \"prof\"\n\n[[3]]\n[1] \"educador\"\n\n[[4]]\n[1] \"tutor\"\n\n[[5]]\ncharacter(0)\n\n[[6]]\ncharacter(0)\n\n[[7]]\ncharacter(0)\n\n[[8]]\ncharacter(0)\n\n[[9]]\ncharacter(0)\n\n[[10]]\ncharacter(0)\n\n\nstr_extract() extrai apenas a primeira combinação (match) em cada string avaliada, produzindo um vetor de caracteres com um elemento para cada string avaliada. Retorna NA onde não há uma combinação. Os NAs pode ser removido envolvendo o vetor retornado com na.exclude(). Observe como o segundo dos acertos da ocupação 3 não é mostrado.\n\nstr_extract(occupations, \"educador|prof|tutor\")\n\n [1] NA         \"prof\"     \"educador\" \"tutor\"    NA         NA        \n [7] NA         NA         NA         NA        \n\n\n\n\n\nSubconjunto e contagem\nAs funções alinhadas incluem str_subset() e str_count().\nstr_subset() retorna os valores reais que continham o padrão:\n\nstr_subset(occupations, \"educador|prof|tutor\")\n\n[1] \"professor universitário\"     \"educador de escola primária\"\n[3] \"tutor\"                      \n\n\nstr_count() retorna um vetor de números: o número de vezes que um termo de pesquisa aparece em cada valor avaliado.\n\nstr_count(occupations, regex(\"educador|prof|tutor\", ignore_case = TRUE))\n\n [1] 0 1 1 1 0 0 0 0 0 0\n\n\n\n\n\nGrupos Regex\nUNDER CONSTRUCTION",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Caracteres e strings</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.pt.html#caracteres-especiais",
    "href": "new_pages/characters_strings.pt.html#caracteres-especiais",
    "title": "10  Caracteres e strings",
    "section": "10.6 Caracteres especiais",
    "text": "10.6 Caracteres especiais\nBarra invertida \\ como escape\nA barra invertida \\ é usada para “escapar” do significado do próximo caractere. Desta forma, uma barra invertida pode ser usada para exibir uma aspa dentro de outras aspas (\\\") - a aspa do meio não “quebrará” as aspas circundantes.\nObservação - portanto, se você deseja exibir uma barra invertida, deve-se escapar de seu significado com outra barra invertida. Portanto, você deve escrever duas barras invertidas \\\\ para mostrar uma.\nCaracteres especiais\n\n\n\n\n\n\n\nCaracteres especiais\nRepresenta\n\n\n\n\n\"\\\\\"\nbarra invertida\n\n\n\"\\n\"\numa nova linha\n\n\n\"\\\"\"\naspas duplas entre aspas duplas\n\n\n'\\''\naspas simples entre aspas simples\n\n\n\"\\“| grave accent”| carriage return“| tab”| vertical tab“`\nbackspace (exclui caractere anterior ao selecionado)\n\n\n\nExecute ?\"'\" no console R para exibir uma lista completa desses caracteres especiais (ela aparecerá no painel Ajuda do RStudio).",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Caracteres e strings</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.pt.html#regular-expressões-regex",
    "href": "new_pages/characters_strings.pt.html#regular-expressões-regex",
    "title": "10  Caracteres e strings",
    "section": "10.7 Regular expressões (regex)",
    "text": "10.7 Regular expressões (regex)",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Caracteres e strings</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.pt.html#regex-e-caracteres-especiais",
    "href": "new_pages/characters_strings.pt.html#regex-e-caracteres-especiais",
    "title": "10  Caracteres e strings",
    "section": "10.8 Regex e caracteres especiais",
    "text": "10.8 Regex e caracteres especiais\nExpressões regulares, ou “regex”, é uma linguagem concisa para descrever padrões em strings. Se você não estiver familiarizado com ela, uma expressão regular pode parecer uma linguagem alienígena. Aqui tentamos desmistificar um pouco essa linguagem.\nGrande parte desta seção foi adaptada desse tutorial e desta página de referência. Nós adaptamos seletivamente aqui sabendo que este manual pode ser visto por pessoas sem acesso à Internet para ver os outros tutoriais.\nUma expressão regular é frequentemente aplicada para extrair padrões específicos de texto “não estruturado” - por exemplo, notas médicas, queixas principais, histórico do paciente ou outras colunas de texto livre em uma tabela de dados.\nExistem quatro ferramentas básicas que podem ser usadas para criar uma expressão regular básica:\n\nConjuntos de caracteres\nMeta caracteres\nQuantificadores\nGrupos\n\nConjunto de caracteres\nOs conjuntos de caracteres são uma forma de expressar as opções de listagem para uma correspondência de caracteres, entre colchetes. Portanto, qualquer correspondência será acionada se qualquer um dos caracteres entre colchetes for encontrado na string. Por exemplo, para procurar vogais, pode-se usar este conjunto de caracteres: “[aeiou]”. Alguns outros conjuntos de caracteres comuns são:\n\n\n\nConjunto de caracteres\nCorrespondências para\n\n\n\n\n\"[A-Z]\"\nqualquer letra maiúscula isolada\n\n\n\"[a-z]\"\nqualquer letra minúscula isolada\n\n\n\"[0-9]\"\nqualquer dígito\n\n\n[:alnum:]\nqualquer caractere alfanumérico\n\n\n[:digit:]\nqualquer dígito numérico\n\n\n[:alpha:]\nqualquer letra (maiúscula ou minúscula)\n\n\n[:upper:]\nqualquer letra maiúscula\n\n\n[:lower:]\nqualquer letra minúscula\n\n\n\nOs conjuntos de caracteres podem ser combinados dentro de um colchete (sem espaços!), como \"[A-Za-z]\" (qualquer letra maiúscula ou minúscula), ou outro exemplo \"[t-z0-5]\" (t minúsculo até z OU número de 0 a 5).\nMetacaracteres\nMetacaracteres são abreviações para conjuntos de caracteres. Alguns dos mais importantes estão listados abaixo:\n\n\n\n\n\n\n\nMeta character\nRepresenta\n\n\n\n\n\"\\\\s\"\num espaço simples\n\n\n\"\\\\w\"\nqualquer caractere alfanumérico único (A-Z, a-z ou 0-9)\n\n\n\"\\\\d\"\nqualquer dígito numérico único (0-9)\n\n\n\nQuantificadores\nNormalmente, você não deseja pesquisar uma correspondência em apenas um caractere. Os quantificadores permitem que você designe o comprimento das letras/números para permitir a correspondência.\nQuantificadores são números escritos entre chaves { } após o caractere que estão quantificando, por exemplo,\n\n\"A{2}\" retornará instâncias de duas letras A maiúsculas.\n\n\"A{2,4}\" retornará instâncias entre duas e quatro letras A maiúsculas (não coloque espaços!).\n\n\"A{2,}\" retornará as correspondências de duas ou mais letras A maiúsculas.\n\n\"A+\" retornará instâncias de uma ou mais letras A maiúsculas (grupo estendido até que um caractere diferente seja encontrado).\n\nPreceda com um * asterisco para retornar zero ou mais correspondências (útil se você não tiver certeza de que o padrão está presente)\n\nUsando o símbolo mais + como quantificador, a correspondência ocorrerá até que um caractere diferente seja encontrado. Por exemplo, esta expressão retornará todas as palavras (caracteres alfabéticos: \"[A-Za-z]+\"\n\n# teste string para quantificadores\ntest &lt;- \"A-AA-AAA-AAAA\"\n\nQuando um quantificador de {2} é usado, apenas pares de A’s consecutivos são retornados. Dois pares são identificados dentro AAAA.\n\nstr_extract_all(test, \"A{2}\")\n\n[[1]]\n[1] \"AA\" \"AA\" \"AA\" \"AA\"\n\n\nQuando um quantificador de {2,4} é usado, grupos de A’s consecutivos com comprimento de dois a quatro são retornados.\n\nstr_extract_all(test, \"A{2,4}\")\n\n[[1]]\n[1] \"AA\"   \"AAA\"  \"AAAA\"\n\n\nCom o quantificador +, grupos de um ou mais são retornados:\n\nstr_extract_all(test, \"A+\")\n\n[[1]]\n[1] \"A\"    \"AA\"   \"AAA\"  \"AAAA\"\n\n\nPosição relativa\nEsses requisitos expressam o que precede ou segue um padrão. Por exemplo, para extrair frases, “dois números seguidos de um ponto” (\"\"). (?&lt;=\\.)\\s(?=[A-Z])\n\nstr_extract_all(test, \"\")\n\n[[1]]\n [1] \"A\" \"-\" \"A\" \"A\" \"-\" \"A\" \"A\" \"A\" \"-\" \"A\" \"A\" \"A\" \"A\"\n\n\n\n\n\nDeclaração de posição\nCorresponde a\n\n\n\n\n\"(?&lt;=b)a\"\n“a” que é precedido por um “b”\n\n\n\"(?&lt;!b)a\"\n“a” que NÃO é precedido por um “b”\n\n\n\"a(?=b)\"\n“a” que é seguido por um “b”\n\n\n\"a(?!b)\"\n“a” que NÃO é seguido por um “b”\n\n\n\nGrupos\nCapturar grupos em sua expressão regular é uma maneira de ter um resultado mais organizado na extração.\nExemplos de Regex\nAbaixo está um texto livre para os exemplos. Tentaremos extrair informações úteis dele usando um termo de pesquisa de expressão regular.\n\npt_note &lt;- \"O paciente chegou ao pronto-socorro do Broward Hospital às 18h do dia 12/06/2005. O paciente apresentou dor abdominal irradiada no quadrante LR. A pele do paciente estava pálida, fria e úmida. A temperatura do paciente era de 99,8 graus Fahrenheit. A pulsação do paciente era de 100 bpm e intermitente. A frequência respiratória era de 29 por minuto.\"\n\nEsta expressão corresponde a todas as palavras (qualquer caractere até atingir um objeto não caractere, como um espaço):\n\nstr_extract_all(pt_note, \"[A-Za-z]+\")\n\n[[1]]\n [1] \"O\"            \"paciente\"     \"chegou\"       \"ao\"           \"pronto\"      \n [6] \"socorro\"      \"do\"           \"Broward\"      \"Hospital\"     \"s\"           \n[11] \"h\"            \"do\"           \"dia\"          \"O\"            \"paciente\"    \n[16] \"apresentou\"   \"dor\"          \"abdominal\"    \"irradiada\"    \"no\"          \n[21] \"quadrante\"    \"LR\"           \"A\"            \"pele\"         \"do\"          \n[26] \"paciente\"     \"estava\"       \"p\"            \"lida\"         \"fria\"        \n[31] \"e\"            \"mida\"         \"A\"            \"temperatura\"  \"do\"          \n[36] \"paciente\"     \"era\"          \"de\"           \"graus\"        \"Fahrenheit\"  \n[41] \"A\"            \"pulsa\"        \"o\"            \"do\"           \"paciente\"    \n[46] \"era\"          \"de\"           \"bpm\"          \"e\"            \"intermitente\"\n[51] \"A\"            \"frequ\"        \"ncia\"         \"respirat\"     \"ria\"         \n[56] \"era\"          \"de\"           \"por\"          \"minuto\"      \n\n\nA expressão \"[0-9]{1,2}\" corresponde a números consecutivos com 1 ou 2 dígitos de comprimento. Também pode ser escrito \"\\\\d{1,2}\", ou \"[:digit:]{1,2}\".\n\nstr_extract_all(pt_note, \"[0-9]{1,2}\")\n\n[[1]]\n [1] \"18\" \"12\" \"06\" \"20\" \"05\" \"99\" \"8\"  \"10\" \"0\"  \"29\"\n\n\n\n\n\n\nVocê pode ver uma lista útil de expressões regex e dicas na página 2 deste cheatsheet\nTambém veja o tutorial.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Caracteres e strings</span>"
    ]
  },
  {
    "objectID": "new_pages/characters_strings.pt.html#recursos",
    "href": "new_pages/characters_strings.pt.html#recursos",
    "title": "10  Caracteres e strings",
    "section": "10.9 Recursos",
    "text": "10.9 Recursos\nUma planilha de referencia para as funções de stringr pode ser encontrada aqui\nUma vinheta sobre stringr pode ser encontrada aqui",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Caracteres e strings</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.pt.html",
    "href": "new_pages/factors.pt.html",
    "title": "11  Fatores",
    "section": "",
    "text": "11.1 Preparação",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Fatores</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.pt.html#preparação",
    "href": "new_pages/factors.pt.html#preparação",
    "title": "11  Fatores",
    "section": "",
    "text": "Carregar pacotes\nEste trecho de código mostra o carregamento de pacotes necessários para as análises. Neste manual, enfatizamos o p_load() do pacman, o qual instala o pacote se necessário e o carrega para uso. Você também pode carregar pacotes instalados com library() do R base. Veja a pagina em Introdução ao R para mais informações sobre pacotes R.\n\npacman::p_load(\n  rio,           # importar/exportar\n  here,          # diretório\n  lubridate,     # trabalhando com datas\n  forcats,       # fatores\n  aweek,         # criar epiweeks com níveis de fatores automático\n  janitor,       # tabelas\n  tidyverse      # dados mgmt e viz\n  )\n\n\n\nImporte os dados\nImportamos o conjunto de dados de casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar, clique para baixar o “clean” linelist (as .rds file). Importe seus dados com a função import() do pacote rio package (o pacote aceita muitos tipos de arquivo como .xlsx, .rds, .csv - veja a página Importar e exportar para detalhes).\n\n# importar seu conjunto de dados\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\n\n\nNova variável categórica\nPara demonstração nesta página, usaremos um cenário comum - a criação de uma nova variável categórica.\nObserve que se você converter uma coluna numérica em fator, não será capaz de calcular estatísticas numéricas sobre ela.\n\nCriar coluna\nUsamos a coluna existente days_onset_hosp (dias desde o início dos sintomas até a admissão hospitalar) e criamos uma nova coluna delay_cat classificando cada linha em uma das várias categorias. Nós fazemos isso com a função do dplyr case_when(), que aplica critérios lógicos sequencialmente (lado direito) a cada linha e retorna o valor do lado esquerdo correspondente para a nova coluna delay_cat. Leia mais sobre case_when() em Limpeza de dados e principais funções.\n\nlinelist &lt;- linelist %&gt;% \n  mutate(delay_cat = case_when(\n    # critério                                  # novo valor se TRUE\n    days_onset_hosp &lt; 2                        ~ \"&lt;2 dias\",\n    days_onset_hosp &gt;= 2 & days_onset_hosp &lt; 5 ~ \"2-5 dias\",\n    days_onset_hosp &gt;= 5                       ~ \"&gt;5 dias\",\n    is.na(days_onset_hosp)                     ~ NA_character_,\n    TRUE                                       ~ \"Verifique\"))  \n\n\n\nPadrão da ordem dos valores\nConforme criado com case_when(), a nova coluna delay_cat é uma coluna categórica da classe Caractere - ainda não é um fator. Assim, em uma tabela de frequência, vemos que os valores exclusivos aparecem por padrão em uma ordem alfanumérica - uma ordem que não faz muito sentido intuitivo:\n\ntable(linelist$delay_cat, useNA = \"always\")\n\n\n &lt;2 dias  &gt;5 dias 2-5 dias     &lt;NA&gt; \n    2990      602     2040      256 \n\n\nDa mesma forma, se fizermos um gráfico de barra, os valores também aparecem nesta ordem no eixo x (consulte a página O básico o ggplot para mais informações sobre o ggplot2 - o pacote de visualização mais comum no R).\n\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = delay_cat))",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Fatores</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.pt.html#converter-para-fator",
    "href": "new_pages/factors.pt.html#converter-para-fator",
    "title": "11  Fatores",
    "section": "11.2 Converter para fator",
    "text": "11.2 Converter para fator\nPara converter um caractere ou coluna numérica para classe fator, você pode usar qualquer função do pacote forcats (muitos são detalhados abaixo). Eles serão convertidos para fator e, em seguida, também realizarão ou permitirão certa ordenação dos níveis - por exemplo, usar fct_relevel() permite que você especifique manualmente a ordem dos níveis. A função as_factor() simplesmente converte a classe sem quaisquer recursos adicionais.\nA função do R base factor() converte uma coluna em fator e permite que você especifique manualmente a ordem dos níveis, como um vetor de caracteres para seu argumento levels =.\nAbaixo usamos mutate() e fct_relevel() para converter a coluna delay_cat de classe caractere para classe fator. A coluna delay_cat é criada na seção Preparação acima.\n\nlinelist &lt;- linelist %&gt;%\n  mutate(delay_cat = fct_relevel(delay_cat))\n\nOs “valores” únicos nesta coluna são agora considerados “níveis” do fator. Os níveis têm uma ordem, que pode ser exibida com a função do R base levels(), ou, alternativamente, visualizada em uma tabela de contagem via table() do R base ou tabyl() do janitor. Por padrão, a ordem dos níveis será alfanumérica, como antes. Observe que NA não é um nível de fator.\n\nlevels(linelist$delay_cat)\n\n[1] \"&lt;2 dias\"  \"&gt;5 dias\"  \"2-5 dias\"\n\n\nA função fct_relevel() tem a utilidade adicional de permitir que você especifique manualmente a ordem dos níveis. Basta escrever os valores dos níveis em ordem, entre aspas, separados por vírgulas, conforme mostrado abaixo. Observe que a grafia deve corresponder exatamente aos valores. Se você quiser criar níveis que não existem nos dados, use fct_expand() ao invés).\n\nlinelist &lt;- linelist %&gt;%\n  mutate(delay_cat = fct_relevel(delay_cat, \"&lt;2 days\", \"2-5 days\", \"&gt;5 days\"))\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `delay_cat = fct_relevel(delay_cat, \"&lt;2 days\", \"2-5 days\", \"&gt;5\n  days\")`.\nCaused by warning:\n! 3 unknown levels in `f`: &lt;2 days, 2-5 days, and &gt;5 days\n\n\nAgora podemos ver que os níveis estão ordenados, conforme especificado no comando anterior, em uma ordem sensata.\n\nlevels(linelist$delay_cat)\n\n[1] \"&lt;2 dias\"  \"&gt;5 dias\"  \"2-5 dias\"\n\n\nAgora, a ordem do gráfico também faz um sentido mais intuitivo.\n\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = delay_cat))",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Fatores</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.pt.html#adicionar-ou-remover-níveis",
    "href": "new_pages/factors.pt.html#adicionar-ou-remover-níveis",
    "title": "11  Fatores",
    "section": "11.3 Adicionar ou remover níveis",
    "text": "11.3 Adicionar ou remover níveis\n\nAdicionar\nSe você precisar adicionar níveis a um fator, você pode fazer isso com fct_expand(). Basta escrever o nome da coluna seguido pelos novos níveis (separados por vírgulas). Tabulando os valores, podemos ver os novos níveis e as contagens zero. Você pode usar table() do R base, ou tabyl() do janitor:\n\nlinelist %&gt;% \n  mutate(delay_cat = fct_expand(delay_cat, \"Not admitted to hospital\", \"Transfer to other jurisdiction\")) %&gt;% \n  tabyl(delay_cat)   # print table\n\n                      delay_cat    n    percent valid_percent\n                        &lt;2 dias 2990 0.50781250     0.5308949\n                        &gt;5 dias  602 0.10224185     0.1068892\n                       2-5 dias 2040 0.34646739     0.3622159\n       Not admitted to hospital    0 0.00000000     0.0000000\n Transfer to other jurisdiction    0 0.00000000     0.0000000\n                           &lt;NA&gt;  256 0.04347826            NA\n\n\nNota: há uma função especial no forcats para adicionar facilmente valores ausentes (NA) como um nível. Consulte a seção abaixo sobre Valores ausentes.\n\n\nRemover\nSe você usar fct_drop(), os níveis “não usados” com contagem zero serão retirados do conjunto de níveis. Os níveis que adicionamos acima (“Not admitted to a hospital” - Não admitido em um hospital) existem como um nível, mas nenhuma linha realmente possui esses valores. Portanto, eles serão eliminados aplicando fct_drop() na nossa coluna de fator:\n\nlinelist %&gt;% \n  mutate(delay_cat = fct_drop(delay_cat)) %&gt;% \n  tabyl(delay_cat)\n\n delay_cat    n    percent valid_percent\n   &lt;2 dias 2990 0.50781250     0.5308949\n   &gt;5 dias  602 0.10224185     0.1068892\n  2-5 dias 2040 0.34646739     0.3622159\n      &lt;NA&gt;  256 0.04347826            NA",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Fatores</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.pt.html#fct_adjust",
    "href": "new_pages/factors.pt.html#fct_adjust",
    "title": "11  Fatores",
    "section": "11.4 Ajuste a ordem dos níveis",
    "text": "11.4 Ajuste a ordem dos níveis\nO pacote forcats oferece funções úteis para ajustar facilmente a ordem dos níveis de um fator (após uma coluna ser definida como classe fator):\nEssas funções podem ser aplicadas a uma coluna de fator em dois contextos:\n\nPara a coluna no data frame, como de costume, para que a transformação esteja disponível para qualquer uso subsequente dos dados\n\nDentro de um gráfico, de modo que a alteração seja aplicada apenas dentro do gráfico\n\n\nManualmente\nEsta função é usada para ordenar manualmente os níveis dos fatores. Se usada em uma coluna sem fator, a coluna será primeiro convertida para classe fator.\nEntre parênteses, primeiro forneça o nome da coluna do fator e, em seguida, forneça:\n\nTodos os níveis na ordem desejada (como um vetor de caracteres c()), ou\n\nUm nível e seu posicionamento corrigido usando o argumento after =\n\nAqui está um exemplo de redefinição da coluna delay_cat (que já é da classe Factor) e especificando toda a ordem de níveis desejada.\n\n# redefine a ordem dos níveis dos fatores\nlinelist &lt;- linelist %&gt;% \n  mutate(delay_cat = fct_relevel(delay_cat, c(\"&lt;2 days\", \"2-5 days\", \"&gt;5 days\")))\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `delay_cat = fct_relevel(delay_cat, c(\"&lt;2 days\", \"2-5 days\", \"&gt;5\n  days\"))`.\nCaused by warning:\n! 3 unknown levels in `f`: &lt;2 days, 2-5 days, and &gt;5 days\n\n\nSe você quiser mover apenas um nível, você pode especificá-lo sozinha para fct_relevel() e dar um número ao argumento after = para indicar onde na ordem ele deveria estar. Por exemplo, o comando abaixo muda “&lt;2 dias” para a segunda posição:\n\n# redefinir a ordem dos níveis\nlinelist %&gt;% \n  mutate(delay_cat = fct_relevel(delay_cat, \"&lt;2 days\", after = 1)) %&gt;% \n  tabyl(delay_cat)\n\n\n\nDentro de um gráfico\nOs comandos do forcats podem ser usados para definir a ordem dos níveis no data frame ou apenas dentro de um gráfico. Usando o comando para “envolver” o nome da coluna dentro do comando de plotagem ggplot() você pode reverter / reordenar / etc, assim, a transformação só se aplicará a esse gráfico.\nAbaixo, dois gráficos são criados com ggplot() (consulte a página O básico o ggplot). No primeiro, a coluna delay_cat é mapeada para o eixo x do gráfico, com sua ordem de nível padrão como nos dados da linelist. No segundo exemplo, ele é inserido em fct_relevel() e a ordem é alterada no gráfico.\n\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `delay_cat = fct_relevel(delay_cat, c(\"2-5 days\", \"&lt;2 days\", \"&gt;5\n  days\"))`.\nCaused by warning:\n! 3 unknown levels in `f`: 2-5 days, &lt;2 days, and &gt;5 days\n\n\n\n# Ordem alfanumérica padrão - sem ajuste no ggplot\nggplot(data = linelist)+\n    geom_bar(mapping = aes(x = delay_cat))\n\n# Ordem dos níveis dos fatores ajustada dentro do ggplot\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = fct_relevel(delay_cat, c(\"&lt;2 days\", \"2-5 days\", \"&gt;5 days\"))))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nObserve que o título padrão do eixo x agora é bastante complicado - você pode reescrever este título com o argumento labs() do ggplot2.\n\n\nInverter\nÉ bastante comum que você queira inverter a ordem dos níveis. Simplesmente envolva o fator com fct_rev().\nObserve que se você deseja reverter apenas uma legenda do gráfico, mas não os níveis reais dos fatores, pode fazer isso com guides() (consulte Dicas para o ggplot).\n\n\nPor frequência\nPara ordenar pela frequência com que o valor aparece nos dados, use fct_infreq(). Quaisquer valores ausentes (NA) serão incluídos automaticamente no final, a menos que sejam convertidos para um nível explícito (veja essa seção). Você pode inverter a ordem envolvendo em seguida com fct_rev().\nEsta função pode ser usada em um ggplot(), conforme mostrado abaixo.\n\n# ordenando por frequência\nggplot(data = linelist, aes(x = fct_infreq(delay_cat)))+\n  geom_bar()+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Ordered by frequency\")\n\n# inverter frequência\nggplot(data = linelist, aes(x = fct_rev(fct_infreq(delay_cat))))+\n  geom_bar()+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Reverse of order by frequency\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPela aparência\nUse fct_inorder() para definir a ordem dos níveis para corresponder à ordem de aparecimento nos dados, começando da primeira linha. Isso pode ser útil se você primeiro organizar os dados cuidadosamente por meio do arrange() no data frame e, em seguida, usar isso para definir a ordem dos fatores.\n\n\nPela estatística de resumo de outra coluna\nVocê pode usar fct_reorder() para ordenar os níveis de uma coluna por uma estatística de resumo de outra coluna. Visualmente, isso pode resultar em gráficos agradáveis, onde as barras / pontos sobem ou descem de forma constante no gráfico.\nNos exemplos abaixo, o eixo x é delay_cat, e o eixo y é a coluna numérica ct_blood (valor do limite do ciclo). Os gráficos de caixa mostram a distribuição do valor CT por grupo delay_cat. Queremos ordenar os gráficos de caixa em ordem crescente pelo valor de CT mediano do grupo.\nNo primeiro exemplo abaixo, a ordem padrão de nível alfanumérico é usada. Você pode ver que as alturas do box plot estão confusas e não em uma ordem específica. No segundo exemplo, a coluna delay_cat (mapeada para o eixo x) foi agrupada em fct_reorder(), a coluna ct_blood é fornecida como o segundo argumento e “median” (mediana) é fornecido como o terceiro argumento (você também pode usar “max”, “mean”, “min”, etc). Portanto, a ordem dos níveis de delay_cat agora refletirá os valores médios de CT crescentes de cada valor de CT médio dos grupos presentes em delay_cat. Isso se reflete no segundo gráfico - os gráficos de caixa foram reorganizados para ascender. Observe como NA (ausente) aparecerá no final, a menos que seja convertido para um nível explícito.\n\n# boxplots ordenados para os níveis originais dos fatores\nggplot(data = linelist)+\n  geom_boxplot(\n    aes(x = delay_cat,\n        y = ct_blood, \n        fill = delay_cat))+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Ordered by original alpha-numeric levels\")+\n  theme_classic()+\n  theme(legend.position = \"none\")\n\n\n# boxplots ordenados pelo valor médio de CT\nggplot(data = linelist)+\n  geom_boxplot(\n    aes(x = fct_reorder(delay_cat, ct_blood, \"median\"),\n        y = ct_blood,\n        fill = delay_cat))+\n  labs(x = \"Delay onset to admission (days)\",\n       title = \"Ordered by median CT value in group\")+\n  theme_classic()+\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nObserve que neste exemplo acima não há etapas necessárias antes da função ggplot() - o agrupamento e os cálculos são todos feitos dentro do comando do ggplot.\n\n\nPor valor “final”\nUse fct_reorder2() para gráficos de linha agrupados. Ele ordena os níveis (e, portanto, a legenda) para alinhar com a ordem vertical das linhas no “final” do gráfico. Tecnicamente falando, ele “ordena pelos valores y associados aos maiores valores x”.\nPor exemplo, se você tiver linhas mostrando contagens de casos por hospital ao longo do tempo, você pode aplicar fct_reorder2() ao argumento color = dentro do aes(), de modo que a ordem vertical dos hospitais que aparecem na legenda se alinhe com a ordem das linhas no extremidade final do gráfico. Leia mais na documentação online.\n\nepidemic_data &lt;- linelist %&gt;%         # comece com a linelist   \n    filter(date_onset &lt; as.Date(\"2014-09-21\")) %&gt;%    # limite a data para clareza visual\n    count(                                            # obter a contagem dos casos por semana e por hospital\n      epiweek = lubridate::floor_date(date_onset, \"week\"),  \n      hospital                                            \n    ) \n  \nggplot(data = epidemic_data)+                       # inicie o gráfico\n  geom_line(                                        # faça as linhas \n    aes(\n      x = epiweek,                                  # eixo-x epiweek\n      y = n,                                        # altura é o número de casos por semana\n      color = fct_reorder2(hospital, epiweek, n)))+ # dados agrupados e coloridos por hospital, com fator de ordem por altura no final do gráfico\n  labs(title = \"Factor levels (and legend display) by line height at end of plot\",\n       color = \"Hospital\")                          # change legend title",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Fatores</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.pt.html#fct_missing",
    "href": "new_pages/factors.pt.html#fct_missing",
    "title": "11  Fatores",
    "section": "11.5 Valores ausentes",
    "text": "11.5 Valores ausentes\nSe você tiver valores NA em sua coluna de fatores, poderá convertê-los facilmente em um nível nomeado, como “Missing” (ausentes) com fct_explicit_na(). Por padrão, os valores NA são convertidos para “(Missing)” no final da ordenação dos nível. Você pode ajustar o nome do nível com o argumento na_level =.\nA seguir, esta operação é realizada na delay_cat e uma tabela é exibida com tabyl() contendo NA convertido para “Missing delay”.\n\nlinelist %&gt;% \n  mutate(delay_cat = fct_explicit_na(delay_cat, na_level = \"Missing delay\")) %&gt;% \n  tabyl(delay_cat)\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `delay_cat = fct_explicit_na(delay_cat, na_level = \"Missing\n  delay\")`.\nCaused by warning:\n! `fct_explicit_na()` was deprecated in forcats 1.0.0.\nℹ Please use `fct_na_value_to_level()` instead.\n\n\n     delay_cat    n    percent\n       &lt;2 dias 2990 0.50781250\n       &gt;5 dias  602 0.10224185\n      2-5 dias 2040 0.34646739\n Missing delay  256 0.04347826",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Fatores</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.pt.html#combine-os-níveis",
    "href": "new_pages/factors.pt.html#combine-os-níveis",
    "title": "11  Fatores",
    "section": "11.6 Combine os níveis",
    "text": "11.6 Combine os níveis\n\nManualmente\nVocê pode ajustar a exibibição dos níveis manualmente com fct_recode(). Essa função é similar a função recode() do dplyr (veja Limpeza de dados e principais funções), mas permite a criação de novos níveis de fator. Se você usar simplesmente o recode() em um fator, novos valores recodificados serão rejeitados, a menos que já tenham sido definidos como níveis permitidos.\nEssa ferramenta também pode ser usada para “combinar” níveis, atribuindo vários níveis ao mesmo valor recodificado. Só tome cuidado para não perder informações! Considere fazer essas etapas de combinação em uma nova coluna (não sobrescrever a coluna existente).\nfct_recode() tem uma sintaxe diferente de recode(). recode() usa OLD = NEW, enquanto fct_recode() usa NEW = OLD.\nOs níveis atuais de delay_cat são:\n\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `delay_cat = fct_relevel(delay_cat, \"&lt;2 days\", after = 0)`.\nCaused by warning:\n! 1 unknown level in `f`: &lt;2 days\n\n\n\nlevels(linelist$delay_cat)\n\n[1] \"&lt;2 dias\"  \"&gt;5 dias\"  \"2-5 dias\"\n\n\nOs novos níveis são criados usando a sintaxe fct_recode(column, \"new\" = \"old\", \"new\" = \"old\", \"new\" = \"old\") e exibidos:\n\nlinelist %&gt;% \n  mutate(delay_cat = fct_recode(\n    delay_cat,\n    \"Less than 2 days\" = \"&lt;2 days\",\n    \"2 to 5 days\"      = \"2-5 days\",\n    \"More than 5 days\" = \"&gt;5 days\")) %&gt;% \n  tabyl(delay_cat)\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `delay_cat = fct_recode(...)`.\nCaused by warning:\n! Unknown levels in `f`: &lt;2 days, 2-5 days, &gt;5 days\n\n\n delay_cat    n    percent valid_percent\n   &lt;2 dias 2990 0.50781250     0.5308949\n   &gt;5 dias  602 0.10224185     0.1068892\n  2-5 dias 2040 0.34646739     0.3622159\n      &lt;NA&gt;  256 0.04347826            NA\n\n\nAqui, eles são combinados manualmente com fct_recode(). Observe que nenhum erro foi gerado na criação de um novo nível “Less than 5 days” (Menos de 5 dias) .\n\nlinelist %&gt;% \n  mutate(delay_cat = fct_recode(\n    delay_cat,\n    \"Less than 5 days\" = \"&lt;2 days\",\n    \"Less than 5 days\" = \"2-5 days\",\n    \"More than 5 days\" = \"&gt;5 days\")) %&gt;% \n  tabyl(delay_cat)\n\n delay_cat    n    percent valid_percent\n   &lt;2 dias 2990 0.50781250     0.5308949\n   &gt;5 dias  602 0.10224185     0.1068892\n  2-5 dias 2040 0.34646739     0.3622159\n      &lt;NA&gt;  256 0.04347826            NA\n\n\n\n\nReduzir para “Outro”\nVocê pode usar fct_other() para atribuir manualmente níveis de fator a um nível chamado “Outros”. Abaixo, todos os níveis da coluna hospital, aside from “Port Hospital” and “Central Hospital”, are combined into “Other”. exceto “Port Hospital” e “Central Hospital”, são combinados em “Other”. Você pode fornecer um vetor para keep =, ou drop =. Você pode alterar a exibição do nível “Outro” com other_level =.\n\nlinelist %&gt;%    \n  mutate(hospital = fct_other(                      # ajustar níveis\n    hospital,\n    keep = c(\"Port Hospital\", \"Central Hospital\"),  # manter esses separados\n    other_level = \"Other Hospital\")) %&gt;%            # Todos os outros como \"Other Hospital\"\n  tabyl(hospital)                                   # exiba a tabela\n\n         hospital    n    percent\n Central Hospital  454 0.07710598\n    Port Hospital 1762 0.29925272\n   Other Hospital 3672 0.62364130\n\n\n\n\nReduzir por frequência\nVocê pode combinar os níveis do fator menos frequentes automaticamente usando fct_lump().\nPara “agrupar” muitos níveis de baixa frequência em um grupo “Outro”, siga um destes procedimentos:\n\nDefina n = como o número de grupos que deseja manter. Os n níveis mais frequentes serão mantidos e todos os outros serão combinados em “Outros”.\n\nDefina prop = como a proporção de frequência limite para os níveis acima dos quais você deseja manter. Todos os outros valores serão combinados em “Outro”.\n\nVocê pode alterar a exibição do nível “Outro” com other_level =. Abaixo, todos, exceto os dois hospitais mais frequentes, são combinados em “Other Hospital” (Outro hospital).\n\nlinelist %&gt;%    \n  mutate(hospital = fct_lump(                      # ajuste os níveis\n    hospital,\n    n = 2,                                          # mantenha os 2 níveis superiores\n    other_level = \"Other Hospital\")) %&gt;%            # todos os outros como \"Other Hospital\"\n  tabyl(hospital)                                   # exiba a tabela\n\n       hospital    n   percent\n        Ausente 1469 0.2494905\n  Port Hospital 1762 0.2992527\n Other Hospital 2657 0.4512568",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Fatores</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.pt.html#mostrar-todos-os-níveis",
    "href": "new_pages/factors.pt.html#mostrar-todos-os-níveis",
    "title": "11  Fatores",
    "section": "11.7 Mostrar todos os níveis",
    "text": "11.7 Mostrar todos os níveis\nUm benefício de usar fatores é padronizar a aparência das legendas e tabelas do gráfico, independentemente de quais valores estão realmente presentes em um conjunto de dados.\nSe você estiver preparando muitas figuras (por exemplo, para várias jurisdições), você desejará que as legendas e tabelas apareçam de forma idêntica, mesmo com variação nos níveis de conclusão ou composição de dados.\n\nEm gráficos\nEm uma figura ggplot(), simplesmente adicione o argumento drop = FALSE na função de escala relevante scale_xxxx(). Todos os níveis de fator serão exibidos, independentemente de estarem presentes nos dados. Se seus níveis de coluna de fator são exibidos usando fill =, então em scale_fill_discrete() você inclui drop = FALSE, conforme mostrado abaixo. Se seus níveis são exibidos com x = (para o eixo x), você deve fornecer color = ou size = para a função scale_color_discrete() ou para scale_size_discrete(), respectivamente.\nEste exemplo é um gráfico de barras empilhadas das categorias por idade e por hospital. Adicionar scale_fill_discrete(drop = FALSE) garante que todas as faixas etárias apareçam na legenda, mesmo se não estiverem presentes nos dados.\n\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = hospital, fill = age_cat)) +\n  scale_fill_discrete(drop = FALSE)+                        # mostra todos os grupos de idade na legenda, mesmo aqueles não presentes\n  labs(\n    title = \"Todas as faixas etárias aparecerão na legenda, mesmo se não estiverem presentes nos dados\")\n\n\n\n\n\n\n\n\n\n\nEm tabelas\nAmbas as funções table() do R base e tabyl() do janitor mostrarão todos os níveis de fator (mesmo os níveis não utilizados).\nSe você usar count() ou summarise() do dplyr para fazer uma tabela, adicione o argumento .drop = FALSE para incluir contagens para todos os níveis do fator, mesmo aqueles não usados.\nLeia mais na página Tabelas descritivas, ou no documento do scale_discrete, ou na documentação do count(). Você pode ver outro exemplo na página Rastreamento de contatos.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Fatores</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.pt.html#epiweeks-semanas-epidemiológicas",
    "href": "new_pages/factors.pt.html#epiweeks-semanas-epidemiológicas",
    "title": "11  Fatores",
    "section": "11.8 Epiweeks (semanas epidemiológicas)",
    "text": "11.8 Epiweeks (semanas epidemiológicas)\nConsulte a ampla discussão sobre como criar semanas epidemiológicas na página Agrupamento de dados.\nConsulte também a página Trabalhando com datas para obter dicas sobre como criar e formatar semanas epidemiológicas.\n\nEpiweeks em um gráfico\nSe seu objetivo é criar epiweeks para exibir em um gráfico, você pode fazer isso simplesmente com o pacote lubridate e função floor_date(), conforme explicado na página Agrupamento de dados. Os valores retornados serão da classe Data com formato AAAA-MM-DD. Se você usar esta coluna em um gráfico, as datas irão naturalmente ordenar corretamente, e você não precisa se preocupar com os níveis ou com a conversão para a classe Fator. Veja o histograma ggplot() das datas de início abaixo.\nNesta abordagem, você pode ajustar a exibição das datas em um eixo com scale_x_date(). Consulte a página em Curvas epidêmicas para obter mais informações. Você pode especificar um formato de exibição “strptime” para o argumento date_labels = da função scale_x_date(). Esses formatos usam marcadores “%” e são abordados na página Trabalhando com datas. Use “% Y” para representar um ano de 4 dígitos e “% W” ou “% U” para representar o número da semana (semanas de segunda ou domingo, respectivamente).\n\nlinelist %&gt;% \n  mutate(epiweek_date = floor_date(date_onset, \"week\")) %&gt;%  # criando uma coluna de semanas\n  ggplot()+                                                  # iniciando o ggplot\n  geom_histogram(mapping = aes(x = epiweek_date))+           # histograma da data de início\n  scale_x_date(date_labels = \"%Y-W%W\")                       # ajustar a exibição das datas para YYYY-WWw\n\n\n\n\n\n\n\n\n\n\nEpiweeks nos dados\nNo entanto, se o seu objetivo na transformação para fator não é gerar um gráfico, você pode abordar isso de duas maneiras:\n\nPara um controle preciso sobre a exibição, converta no lubridate a coluna epiweek (YYYY-MM-DD) para o formato de exibição desejado (YYYY-WWw) dentro do próprio data frame e, em seguida, converta-o para a classe Fator.\n\nPrimeiro, use format() do R base para converter a exibição de data de YYYY-MM-DD para YYYY-Www (consulte a página Trabalhando com datas). Neste processo, a classe será convertida em caractere. Em seguida, converta de caractere para classe Fator com factor().\n\nlinelist &lt;- linelist %&gt;% \n  mutate(epiweek_date = floor_date(date_onset, \"week\"),       # cria semanas epidemiológicas - epiweeks (YYYY-MM-DD)\n         epiweek_formatted = format(epiweek_date, \"%Y-W%W\"),  # Converter para mostrar (YYYY-WWW)\n         epiweek_formatted = factor(epiweek_formatted))       # Converter para fator\n\n# Mostrar níveis\nlevels(linelist$epiweek_formatted)\n\n [1] \"2014-W13\" \"2014-W14\" \"2014-W15\" \"2014-W16\" \"2014-W17\" \"2014-W18\"\n [7] \"2014-W19\" \"2014-W20\" \"2014-W21\" \"2014-W22\" \"2014-W23\" \"2014-W24\"\n[13] \"2014-W25\" \"2014-W26\" \"2014-W27\" \"2014-W28\" \"2014-W29\" \"2014-W30\"\n[19] \"2014-W31\" \"2014-W32\" \"2014-W33\" \"2014-W34\" \"2014-W35\" \"2014-W36\"\n[25] \"2014-W37\" \"2014-W38\" \"2014-W39\" \"2014-W40\" \"2014-W41\" \"2014-W42\"\n[31] \"2014-W43\" \"2014-W44\" \"2014-W45\" \"2014-W46\" \"2014-W47\" \"2014-W48\"\n[37] \"2014-W49\" \"2014-W50\" \"2014-W51\" \"2015-W00\" \"2015-W01\" \"2015-W02\"\n[43] \"2015-W03\" \"2015-W04\" \"2015-W05\" \"2015-W06\" \"2015-W07\" \"2015-W08\"\n[49] \"2015-W09\" \"2015-W10\" \"2015-W11\" \"2015-W12\" \"2015-W13\" \"2015-W14\"\n[55] \"2015-W15\" \"2015-W16\"\n\n\nPERIGO: Se você colocar as semanas à frente dos anos (“Www-YYYY”) (“% W-% Y”), a ordem de nível alfanumérico padrão estará incorreta (por exemplo, 01-2015 estará antes de 35-2014) . Pode ser necessário ajustar manualmente a ordem, o que seria um processo longo e doloroso.\n\nPara uma exibição padrão rápida, use o pacote aweek e sua função date2week(). Você pode definir o dia do início da semana por week_start = e, se definir factor = TRUE a coluna de saída é um fator ordenado. Como bônus, o fator inclui níveis para todas as semanas possíveis no intervalo - mesmo se não houver casos naquela semana.\n\n\ndf &lt;- linelist %&gt;% \n  mutate(epiweek = date2week(date_onset, week_start = \"Monday\", factor = TRUE))\n\nlevels(df$epiweek)\n\nVeja a página Trabalhando com datas para mais informações sobre aweek. O pacote também oferece a função reversa week2date().",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Fatores</span>"
    ]
  },
  {
    "objectID": "new_pages/factors.pt.html#recursos",
    "href": "new_pages/factors.pt.html#recursos",
    "title": "11  Fatores",
    "section": "11.9 Recursos",
    "text": "11.9 Recursos\nR para a página de Ciência de Dados em factors\nvinheta do pacote aweek",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Fatores</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.pt.html",
    "href": "new_pages/pivoting.pt.html",
    "title": "12  Pivoteando dados",
    "section": "",
    "text": "12.1 Preparação",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Pivoteando dados</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.pt.html#preparação",
    "href": "new_pages/pivoting.pt.html#preparação",
    "title": "12  Pivoteando dados",
    "section": "",
    "text": "Carregue os pacotes R\nO código abaixo realiza o carregamento dos pacotes necessários para a análise dos dados. Neste manual, enfatizamos o uso da função p_load(), do pacman, que instala os pacotes, caso não estejam instalados, e os carrega no R para utilização. Também é possível carregar pacotes instalados utilizando a função library(), do R base. Para mais informações sobre os pacotes do R, veja a página Introdução ao R.\n\npacman::p_load(\n  rio,          # File import\n  here,         # File locator\n  kableExtra,   # Build and manipulate complex tables\n  tidyverse)    # data management + ggplot2 graphics\n\n\n\nImporte os dados\n\n\nDados de Malária\nNesta página, iremos utilizar um banco fictício de casos diários de malária, divididos por local e grupos de idade. Se você quiser acompanhar a análise, clique aqui para baixar (como arquivo .rds ). Importe os dados com a função import() do pacote rio (a função suporta vários tipos de arquivo como .xlsx, .csv, .rds - cheque a página Importar e exportar para mais detalhes).\n\n# Import data\ncount_data &lt;- import(\"malaria_facility_count_data.rds\")\n\nAs primeras 50 linhas são mostradas abaixo.\n\n\n\n\n\n\n\n\nCasos da Linelist\nNas seções finais dessa página também iremos utilizar dados de uma epidemia simulada de Ebola. Se você quiser acompanhar, clique para baixar a linelist “limpa” (como um arquivo .rds). Importe os dados com a função import() do pacote rio (a função suporta vários tipos de arquivo como .xlsx, .csv, .rds - cheque a página Importar e exportar para mais detalhes).\n\n# import your dataset\nlinelist &lt;- import(\"linelist_cleaned.xlsx\")",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Pivoteando dados</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.pt.html#largo-para-longo",
    "href": "new_pages/pivoting.pt.html#largo-para-longo",
    "title": "12  Pivoteando dados",
    "section": "12.2 Largo-para-longo",
    "text": "12.2 Largo-para-longo\n\n\n\n\n\n\n\n\n\n\n\nFormato “Largo” (wide)\nOs dados são normalmente inseridos e armazenados no formato “largo” (wide) - em que as características ou respostas dos sujeitos são acondicionadas em apenas uma linha. Embora possa ser útil para apresentação, esse formato não é ideal para alguns tipos de análises.\nVamos pegar como exemplo o banco count_data importado na seção de Preparação acima. Você pode ver que cada linha representa um “dia-local” (facility-day). As contagens propriamente ditas dos casos (colunas mais à direita) estão armazenadas em um formato “largo”, de forma que as informações para todos os grupos de idade em cada “dia-local” estão armazenadas em apenas uma coluna.\n\n\n\n\n\n\nCada observação nesse banco refere-se às contagens dos casos de malária em um dos 65 locais, em uma referida data, que vai desde count_data$data_date %&gt;% min() até count_data$data_date %&gt;% max(). Esse locais estão divididos em uma Província - Province (North) e quatro Distritos - District (Spring, Bolo, Dingo, e Barnard). O banco disponibiliza as contagens gerais de malária, bem como contagens específicas por idade em cada um dos quatro grupos = &lt;4 anos, 5-14 anos, e 15 anos ou mais.\nDados em formato “largo” (wide) como esse não aderem aos padrões de dados “tidy”, pois os cabeçalhos das colunas não representam, de fato, “variáveis” - eles representam valores de uma varíavel hipotética “grupo de idade” (age group).\nEsse formato pode ser útil para apresentar informações em uma tabela, ou para inserção de dados provenientes de formulários (no Excel, por exemplo). No entanto, na fase de análise, os dados devem ser transformados para um formato mais “longo”, alinhado com os padrões de dados “tidy”. O pacote de gráficos ggplot2, inclusive, funciona melhor quando os dados estão no formato “longo”.\nNo formato atual, não há dificuldade alguma em visualizar o total de casos versus tempo:\n\nggplot(count_data) +\n  geom_col(aes(x = data_date, y = malaria_tot), width = 1)\n\n\n\n\n\n\n\n\nNo entanto, e se quiséssemos mostrar as contribuições relativas de cada grupo de idade a esse total? Neste caso, precisaríamos nos assegurar de que as varíaveis de interesse (grupos de idade - age group) aparecessem no banco em apenas uma coluna que possa ser passada ao {ggplot2} através do argumento aes().\n\n\n\npivot_longer()\nA função pivot_longer() do tidyr torna os dados mais “longos” (“longer”). O pacote tidyr faz parte dos pacotes da família tidyverse.\nEssa função recebe como argumento um intervalo de colunas que serão transformadas (especificado no argumento cols =). Assim, ela pode operar em apenas um parte do banco. Isso é útil para os dados de malária, pois queremos pivotar apenas as colunas com a contagem dos casos.\nExecutando esse processo, você vai obter duas “novas” colunas - uma com as categorias (que antes eram os nomes das colunas), e uma outra com os valores correspondentes (os números de casos). Você pode aceitar os nomes padrão para essas novas colunas ou você pode especificar seus próprios nomes através dos argumentos names_to = e values_to = respectivamente.\nvamos ver pivot_longer() em ação…\n\n\nPivot padrão\nQueremos usar a função pivot_longer() do tidyr para converter os dados do formato “largo” (wide) para o formato “longo” (long). Especificamente, converter as quatro colunas numéricas com as contagens dos casos de malária em duas novas colunas: uma com os grupos de idade (age groups) e uma com os valores correspondentes.\n\ndf_long &lt;- count_data %&gt;% \n  pivot_longer(\n    cols = c(`malaria_rdt_0-4`, `malaria_rdt_5-14`, `malaria_rdt_15`, `malaria_tot`)\n  )\n\ndf_long\n\nperceba que o data frame recém criado (df_long) possui mais linhas (12,152 vs 3,038); ele tornou-se mais longo - longer. De fato, ele está precisamente quatro vezes mais longo, pois cada linha do banco original agora representa quatro linhas em df_long, uma para cada contagem das observações (&lt;4 anos, 5-14 anos, 15 anos+ e total).\nAlém de mais longo, o novo banco também tem menos colunas (8 vs 10), uma vez que os dados que estavam armazenados nas quatro colunas (aquelas que começavam com o prefixo malaria_) passaram a ser armazenados em apenas duas.\nUma vez que os nomes de todas essas quatro colunas começam com o prefixo malaria_, poderíamos ter utilizado uma função muito útil para fazer “tidyselect” - com starts_with() poderíamos chegar no mesmo resultado (veja a página Limpeza de dados e principais funções para conhecer mais dessas funções de auxílio).\n\n# provide column with a tidyselect helper function\ncount_data %&gt;% \n  pivot_longer(\n    cols = starts_with(\"malaria_\")\n  )\n\n# A tibble: 12,152 × 8\n   location_name data_date  submitted_date Province District newid name    value\n   &lt;chr&gt;         &lt;date&gt;     &lt;date&gt;         &lt;chr&gt;    &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;   &lt;int&gt;\n 1 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malari…    11\n 2 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malari…    12\n 3 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malari…    23\n 4 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malari…    46\n 5 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malari…    11\n 6 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malari…    10\n 7 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malari…     5\n 8 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malari…    26\n 9 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malari…     8\n10 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malari…     5\n# ℹ 12,142 more rows\n\n\nou por posição:\n\n# provide columns by position\ncount_data %&gt;% \n  pivot_longer(\n    cols = 6:9\n  )\n\nou por intervalo nomeado:\n\n# provide range of consecutive columns\ncount_data %&gt;% \n  pivot_longer(\n    cols = `malaria_rdt_0-4`:malaria_tot\n  )\n\nAs novas colunas recebem os nomes padrão de name e value, mas podemos sobrescrever esses padrões para fornecer nomes mais semânticos, que vão ajudar a lembrar o que representam, utilizando os argumentos names_to e values_to. Vamos utilizar os nomes age_group e counts:\n\ndf_long &lt;- \n  count_data %&gt;% \n  pivot_longer(\n    cols = starts_with(\"malaria_\"),\n    names_to = \"age_group\",\n    values_to = \"counts\"\n  )\n\ndf_long\n\n# A tibble: 12,152 × 8\n   location_name data_date  submitted_date Province District newid age_group    \n   &lt;chr&gt;         &lt;date&gt;     &lt;date&gt;         &lt;chr&gt;    &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;        \n 1 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_…\n 2 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_…\n 3 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_rdt_…\n 4 Facility 1    2020-08-11 2020-08-12     North    Spring       1 malaria_tot  \n 5 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_…\n 6 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_…\n 7 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_rdt_…\n 8 Facility 2    2020-08-11 2020-08-12     North    Bolo         2 malaria_tot  \n 9 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malaria_rdt_…\n10 Facility 3    2020-08-11 2020-08-12     North    Dingo        3 malaria_rdt_…\n# ℹ 12,142 more rows\n# ℹ 1 more variable: counts &lt;int&gt;\n\n\nAgora podemos passar essa nova base para o {ggplot2}, e mapear a nova coluna count para o eixo y e a nova coluna age_group para o argumento fill = (a cor de preenchimento da barra). Isso vai mostrar as contagens em um gráfico de barras empilhadas, por grupo de idade:\n\nggplot(data = df_long) +\n  geom_col(\n    mapping = aes(x = data_date, y = counts, fill = age_group),\n    width = 1\n  )\n\n\n\n\n\n\n\n\nVeja esse novo gráfico, e compare com o gráfico criado anteriormento - o que deu errado?\nEncontramos um problema comum ao manipular dados de vigilância - acabamos incluindo também o número total de casos da coluna malaria_tot, o que fez com que a altura de cada barra no gráfico fosse o dobro do que deveria.\nPodemos lidar com isso de algumas formas. Podemos simplesmente filtrar esses totais da base antes de passá-la para o ggplot():\n\ndf_long %&gt;% \n  filter(age_group != \"malaria_tot\") %&gt;% \n  ggplot() +\n  geom_col(\n    aes(x = data_date, y = counts, fill = age_group),\n    width = 1\n  )\n\n\n\n\n\n\n\n\nOu então, poderíamos ter excluído essa variável quando rodamos pivot_longer(), mantendo-na assim como uma variável separada na base de dados. Veja como os valores dela se “expandem” para preencher as novas linhas.\n\ncount_data %&gt;% \n  pivot_longer(\n    cols = `malaria_rdt_0-4`:malaria_rdt_15,   # does not include the totals column\n    names_to = \"age_group\",\n    values_to = \"counts\"\n  )\n\n# A tibble: 9,114 × 9\n   location_name data_date  submitted_date Province District malaria_tot newid\n   &lt;chr&gt;         &lt;date&gt;     &lt;date&gt;         &lt;chr&gt;    &lt;chr&gt;          &lt;int&gt; &lt;int&gt;\n 1 Facility 1    2020-08-11 2020-08-12     North    Spring            46     1\n 2 Facility 1    2020-08-11 2020-08-12     North    Spring            46     1\n 3 Facility 1    2020-08-11 2020-08-12     North    Spring            46     1\n 4 Facility 2    2020-08-11 2020-08-12     North    Bolo              26     2\n 5 Facility 2    2020-08-11 2020-08-12     North    Bolo              26     2\n 6 Facility 2    2020-08-11 2020-08-12     North    Bolo              26     2\n 7 Facility 3    2020-08-11 2020-08-12     North    Dingo             18     3\n 8 Facility 3    2020-08-11 2020-08-12     North    Dingo             18     3\n 9 Facility 3    2020-08-11 2020-08-12     North    Dingo             18     3\n10 Facility 4    2020-08-11 2020-08-12     North    Bolo              49     4\n# ℹ 9,104 more rows\n# ℹ 2 more variables: age_group &lt;chr&gt;, counts &lt;int&gt;\n\n\n\n\nPivoteando dados de múltiplas classes\nO exemplo acima funciona bem em situações em que todas as colunas que você quer pivotar para o formato “longo” são da mesma classe (caracter, numérico, lógico, etc…)\nPorém, haverá muitos casos em que, como epidemiologista de campo, você estará trabalhando com dados que foram preparados por não-especialistas e que seguem suas próprias lógicas não padronizadas - como Hadley Wickham citou (em referência a Tolstoy) em seu artigo seminal sobre os princípios de Tidy Data: “Like families, tidy datasets are all alike but every messy dataset is messy in its own way.” (Como famílias, bases de dados tidy são todas parecidas mas todas as bases bagunçadas são bagunçadas à sua maneira.)\nUm problema particularmente comum que você vai encontrar será a necessidade de pivotar colunas que possuem diferentes classes de dados. Essa pivotagem vai resultar no armazenamento desses diferentes tipos em uma única coluna, o que não é uma situação ideal. Existem várias abordagens possíveis para separar a bagunça que isso gera, mas existe um passo importante que você pode dar utilizando pivot_longer() para evitar cair nessa situação.\nVamos analisar a situação em que há uma série de observações em diferentes intervalos de tempo para cada um dos itens A, B e C. Exemplos desses itens podem ser indivíduos (ex: contatos de caso de Ebola sendo monitorados por 21 dias) ou postos de saúde de vilarejos remotos sendo monitorados uma vez por ano para assegurar que ainda funcionam. Vamos utilizar o exemplo do contato com o caso de Ebola. Imagine os dados armazenados da seguinte forma:\n\n\n\n\n\n\nComo pode ser observado, os dados são um pouco complicados. Cada linha armazena informação sobre um item, mas com a série temporal avançando mais e mais para a direita à medida que o tempo passa. Além disso, a classe das colunas alternam entre valores de data e caracteres.\nUm exemplo particularmente ruim encontrado por este autor envolvia dados de vigilância do cólera, no qual 8 novas colunas de observação eram adicionadas à base por dia ao longo de 4 anos. Só para abrir o arquivo de Excel em que esses dados estavam levava mais de 10 minutos no meu laptop!\nPara trabalhar com esses dados, precisamos transformar o data frame para o formato longo, mas mantendo a separação entre as colunas no formato date e character (status), para cada observação e cada item. Se não o fizermos, podemos acabar com uma mistura de tipos de variáveis na mesma coluna (um “sacrilégio” quando se trata de gerenciamento de dados e dados “tidy”):\n\ndf %&gt;% \n  pivot_longer(\n    cols = -id,\n    names_to = c(\"observation\")\n  )\n\n# A tibble: 18 × 3\n   id    observation value     \n   &lt;chr&gt; &lt;chr&gt;       &lt;chr&gt;     \n 1 A     obs1_date   2021-04-23\n 2 A     obs1_status Healthy   \n 3 A     obs2_date   2021-04-24\n 4 A     obs2_status Healthy   \n 5 A     obs3_date   2021-04-25\n 6 A     obs3_status Unwell    \n 7 B     obs1_date   2021-04-23\n 8 B     obs1_status Healthy   \n 9 B     obs2_date   2021-04-24\n10 B     obs2_status Healthy   \n11 B     obs3_date   2021-04-25\n12 B     obs3_status Healthy   \n13 C     obs1_date   2021-04-23\n14 C     obs1_status Missing   \n15 C     obs2_date   2021-04-24\n16 C     obs2_status Healthy   \n17 C     obs3_date   2021-04-25\n18 C     obs3_status Healthy   \n\n\nAcima, nosso pivot mesclou datas e caracteres em apenas uma coluna value. R reagirá convertendo a coluna inteira para a classe de caracteres e assim, a utilidade das datas será perdida.\nPara evitar essa situação, podemos aproveitar a sintaxe da estrutura original do nome das colunas. Existe uma estrutura comum nos nomes, com o número da observação, um underline e depois a palavra “status” ou “date”. Podemos utilizar essa sintaxe para manter esses dois tipos de dados em colunas separadas após o pivot.\nFazemos isso através de:\n\nFornecimento de um vetor de caracteres para o argumento names_to =, com o segundo item sendo (\".value\" ). Esse termo especial indica que as colunas pivotadas vão ser divididas baseadas em um caracter presente em seus nomes…\n\nVocê também precisa fornecer o caracter “separador” para o argumento names_sep =. Nesse caso, é o underline “_“.\n\nAssim, o nome e a separação das novas colunas são baseados nos termos “em volta” do underline nos nomes das variáveis existentes.\n\ndf_long &lt;- df %&gt;% \n  pivot_longer(\n    cols = -id,\n    names_to = c(\"observation\", \".value\"),\n    names_sep = \"_\"\n  )\n\ndf_long\n\n# A tibble: 9 × 4\n  id    observation date       status \n  &lt;chr&gt; &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;  \n1 A     obs1        2021-04-23 Healthy\n2 A     obs2        2021-04-24 Healthy\n3 A     obs3        2021-04-25 Unwell \n4 B     obs1        2021-04-23 Healthy\n5 B     obs2        2021-04-24 Healthy\n6 B     obs3        2021-04-25 Healthy\n7 C     obs1        2021-04-23 Missing\n8 C     obs2        2021-04-24 Healthy\n9 C     obs3        2021-04-25 Healthy\n\n\nToques finais:\nNote que a coluna date está atualmente com a classe caractere - nós podemos convertê-la facilmente em sua classe apropriada utilizando as funções mutate() e as_date() descritas na página Trabalhando com datas.\nTambém podemos converter a coluna observation para o formato numeric removendo o prefixo “obs” e convertendo para numérico. Podemos fazer isso com a função str_remove_all() do pacote stringr (veja a página Caracteres and strings).\n\ndf_long &lt;- df_long %&gt;% \n  mutate(\n    date = date %&gt;% lubridate::as_date(),\n    observation = \n      observation %&gt;% \n      str_remove_all(\"obs\") %&gt;% \n      as.numeric()\n  )\n\ndf_long\n\n# A tibble: 9 × 4\n  id    observation date       status \n  &lt;chr&gt;       &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;  \n1 A               1 2021-04-23 Healthy\n2 A               2 2021-04-24 Healthy\n3 A               3 2021-04-25 Unwell \n4 B               1 2021-04-23 Healthy\n5 B               2 2021-04-24 Healthy\n6 B               3 2021-04-25 Healthy\n7 C               1 2021-04-23 Missing\n8 C               2 2021-04-24 Healthy\n9 C               3 2021-04-25 Healthy\n\n\nE agora, podemos começar a trabalhar com os dados nesse formato. Ex: criando um de mapa de calor descritivo:\n\nggplot(data = df_long, mapping = aes(x = date, y = id, fill = status)) +\n  geom_tile(colour = \"black\") +\n  scale_fill_manual(\n    values = \n      c(\"Healthy\" = \"lightgreen\", \n        \"Unwell\" = \"red\", \n        \"Missing\" = \"orange\")\n  )",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Pivoteando dados</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.pt.html#longo-para-largo",
    "href": "new_pages/pivoting.pt.html#longo-para-largo",
    "title": "12  Pivoteando dados",
    "section": "12.3 Longo-para-largo",
    "text": "12.3 Longo-para-largo\n\n\n\n\n\n\n\n\n\nEm algumas instâncias, pode ser necessário converter uma base para o formato mais largo (wide) utilizando a função pivot_wider().\nUm caso de uso típico é quando queremos transformar o resultado de uma análise em um formato mais “palatável” ao leitor (tal como em Tabelas para apresentação). Normalmente, isso envolve transformar uma base em que a informação para um sujeito está espalhada em múltiplas linhas em um formato em que aquela informação esteja armazenada em apenas uma.\n\nDados\nPara essa seção da página, vamos utilizar o caso da linelist (veja a seção de Preparação), que contém uma linha por caso.\nAqui estão as primeiras 50 linhas:\n\n\n\n\n\n\nSuponha que a gente queira saber a contagem dos indivíduos nos diferentes grupos de idade, por gênero:\n\ndf_wide &lt;- \n  linelist %&gt;% \n  count(age_cat, gender)\n\ndf_wide\n\n   age_cat gender   n\n1      0-4      f 640\n2      0-4      m 416\n3      0-4   &lt;NA&gt;  39\n4      5-9      f 641\n5      5-9      m 412\n6      5-9   &lt;NA&gt;  42\n7    10-14      f 518\n8    10-14      m 383\n9    10-14   &lt;NA&gt;  40\n10   15-19      f 359\n11   15-19      m 364\n12   15-19   &lt;NA&gt;  20\n13   20-29      f 468\n14   20-29      m 575\n15   20-29   &lt;NA&gt;  30\n16   30-49      f 179\n17   30-49      m 557\n18   30-49   &lt;NA&gt;  18\n19   50-69      f   2\n20   50-69      m  91\n21   50-69   &lt;NA&gt;   2\n22     70+      m   5\n23     70+   &lt;NA&gt;   1\n24    &lt;NA&gt;   &lt;NA&gt;  86\n\n\nIsso vai produzir uma base longa que é ótima para fazer visualizações no ggplot2, mas não é ideal para apresentar em uma tabela:\n\nggplot(df_wide) +\n  geom_col(aes(x = age_cat, y = n, fill = gender))\n\n\n\n\n\n\n\n\n\n\nPivot wider\nDesta forma, podemos utilizar pivot_wider() para transformar os dados em um formato melhor para inclusão nas tabelas de nossos relatórios.\nO argumento names_from especifica a coluna a partir da qual serão gerados os nomes da nova coluna names, enquanto o argumento values_from especifica a coluna a partir da qual serão retirados os valores da coluna values que vão popular as células. O argumento id_cols = é opcional, mas pode ser utilizado passando um vetor de nomes de colunas que não deverão ser pivotadas, e assim irá identificar cada linha.\n\ntable_wide &lt;- \n  df_wide %&gt;% \n  pivot_wider(\n    id_cols = age_cat,\n    names_from = gender,\n    values_from = n\n  )\n\ntable_wide\n\n# A tibble: 9 × 4\n  age_cat     f     m  `NA`\n  &lt;fct&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n1 0-4       640   416    39\n2 5-9       641   412    42\n3 10-14     518   383    40\n4 15-19     359   364    20\n5 20-29     468   575    30\n6 30-49     179   557    18\n7 50-69       2    91     2\n8 70+        NA     5     1\n9 &lt;NA&gt;       NA    NA    86\n\n\nEssa tabela é muito mais legível e assim, melhor para utilização em relatórios. Você pode convertê-la em tabelas elegantes e bonitas utilizando vários pacotes, incluindo flextable e knitr. Esse processo é elaborado na página Tabelas para apresentação.\n\ntable_wide %&gt;% \n  janitor::adorn_totals(c(\"row\", \"col\")) %&gt;% # adds row and column totals\n  knitr::kable() %&gt;% \n  kableExtra::row_spec(row = 10, bold = TRUE) %&gt;% \n  kableExtra::column_spec(column = 5, bold = TRUE) \n\n\n\n\n\nage_cat\nf\nm\nNA\nTotal\n\n\n\n\n0-4\n640\n416\n39\n1095\n\n\n5-9\n641\n412\n42\n1095\n\n\n10-14\n518\n383\n40\n941\n\n\n15-19\n359\n364\n20\n743\n\n\n20-29\n468\n575\n30\n1073\n\n\n30-49\n179\n557\n18\n754\n\n\n50-69\n2\n91\n2\n95\n\n\n70+\nNA\n5\n1\n6\n\n\nNA\nNA\nNA\n86\n86\n\n\nTotal\n2807\n2803\n278\n5888",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Pivoteando dados</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.pt.html#preenchimento",
    "href": "new_pages/pivoting.pt.html#preenchimento",
    "title": "12  Pivoteando dados",
    "section": "12.4 Preenchimento",
    "text": "12.4 Preenchimento\nEm algumas situações após um pivot, e mais frequentemente após um bind, acabamos ficando com algumas células vazias que gostaríamos de preencher.\n\n\nDados\nPor exemplo, pegue duas bases, cada uma com observações para o número da medição, o nome do local e a contagem de casos naquele momento. No entanto, a segunda base também possui a variável Year.\n\ndf1 &lt;- \n  tibble::tribble(\n       ~Measurement, ~Facility, ~Cases,\n                  1,  \"Hosp 1\",     66,\n                  2,  \"Hosp 1\",     26,\n                  3,  \"Hosp 1\",      8,\n                  1,  \"Hosp 2\",     71,\n                  2,  \"Hosp 2\",     62,\n                  3,  \"Hosp 2\",     70,\n                  1,  \"Hosp 3\",     47,\n                  2,  \"Hosp 3\",     70,\n                  3,  \"Hosp 3\",     38,\n       )\n\ndf1 \n\n# A tibble: 9 × 3\n  Measurement Facility Cases\n        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;\n1           1 Hosp 1      66\n2           2 Hosp 1      26\n3           3 Hosp 1       8\n4           1 Hosp 2      71\n5           2 Hosp 2      62\n6           3 Hosp 2      70\n7           1 Hosp 3      47\n8           2 Hosp 3      70\n9           3 Hosp 3      38\n\ndf2 &lt;- \n  tibble::tribble(\n    ~Year, ~Measurement, ~Facility, ~Cases,\n     2000,            1,  \"Hosp 4\",     82,\n     2001,            2,  \"Hosp 4\",     87,\n     2002,            3,  \"Hosp 4\",     46\n  )\n\ndf2\n\n# A tibble: 3 × 4\n   Year Measurement Facility Cases\n  &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;\n1  2000           1 Hosp 4      82\n2  2001           2 Hosp 4      87\n3  2002           3 Hosp 4      46\n\n\nQuando fazemos um bind_rows() para mesclar as bases, a variável Year será preenchida com NA para aquelas linhas em que não existia nenhuma informação prévia (ex: na primeira base):\n\ndf_combined &lt;- \n  bind_rows(df1, df2) %&gt;% \n  arrange(Measurement, Facility)\n\ndf_combined\n\n# A tibble: 12 × 4\n   Measurement Facility Cases  Year\n         &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1           1 Hosp 1      66    NA\n 2           1 Hosp 2      71    NA\n 3           1 Hosp 3      47    NA\n 4           1 Hosp 4      82  2000\n 5           2 Hosp 1      26    NA\n 6           2 Hosp 2      62    NA\n 7           2 Hosp 3      70    NA\n 8           2 Hosp 4      87  2001\n 9           3 Hosp 1       8    NA\n10           3 Hosp 2      70    NA\n11           3 Hosp 3      38    NA\n12           3 Hosp 4      46  2002\n\n\n\n\n\nfill()\nNesse caso, Year é uma variável útil para ser incluída, particularmente se quisermos explorar as tendências ao longo do tempo. Por isso, utilizamos fill() para preencher as células vazias, especificando a coluna a ser preenchida e a direção (nesse caso, acima):\n\ndf_combined %&gt;% \n  fill(Year, .direction = \"up\")\n\n# A tibble: 12 × 4\n   Measurement Facility Cases  Year\n         &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1           1 Hosp 1      66  2000\n 2           1 Hosp 2      71  2000\n 3           1 Hosp 3      47  2000\n 4           1 Hosp 4      82  2000\n 5           2 Hosp 1      26  2001\n 6           2 Hosp 2      62  2001\n 7           2 Hosp 3      70  2001\n 8           2 Hosp 4      87  2001\n 9           3 Hosp 1       8  2002\n10           3 Hosp 2      70  2002\n11           3 Hosp 3      38  2002\n12           3 Hosp 4      46  2002\n\n\nOu então, podemos rearranjar os dados para que possamos preencher na direção descendente:\n\ndf_combined &lt;- \n  df_combined %&gt;% \n  arrange(Measurement, desc(Facility))\n\ndf_combined\n\n# A tibble: 12 × 4\n   Measurement Facility Cases  Year\n         &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1           1 Hosp 4      82  2000\n 2           1 Hosp 3      47    NA\n 3           1 Hosp 2      71    NA\n 4           1 Hosp 1      66    NA\n 5           2 Hosp 4      87  2001\n 6           2 Hosp 3      70    NA\n 7           2 Hosp 2      62    NA\n 8           2 Hosp 1      26    NA\n 9           3 Hosp 4      46  2002\n10           3 Hosp 3      38    NA\n11           3 Hosp 2      70    NA\n12           3 Hosp 1       8    NA\n\ndf_combined &lt;- \n  df_combined %&gt;% \n  fill(Year, .direction = \"down\")\n\ndf_combined\n\n# A tibble: 12 × 4\n   Measurement Facility Cases  Year\n         &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt;\n 1           1 Hosp 4      82  2000\n 2           1 Hosp 3      47  2000\n 3           1 Hosp 2      71  2000\n 4           1 Hosp 1      66  2000\n 5           2 Hosp 4      87  2001\n 6           2 Hosp 3      70  2001\n 7           2 Hosp 2      62  2001\n 8           2 Hosp 1      26  2001\n 9           3 Hosp 4      46  2002\n10           3 Hosp 3      38  2002\n11           3 Hosp 2      70  2002\n12           3 Hosp 1       8  2002\n\n\nAgora temos uma base útil para fazer um gráfico:\n\nggplot(df_combined) +\n  aes(Year, Cases, fill = Facility) +\n  geom_col()\n\n\n\n\n\n\n\n\nMas menos útil para apresentar em uma tabela, então vamos praticar e converter esse dataframe longo e não “tidy” em um dataframe largo (wide) e “tidy”:\n\ndf_combined %&gt;% \n  pivot_wider(\n    id_cols = c(Measurement, Facility),\n    names_from = \"Year\",\n    values_from = \"Cases\"\n  ) %&gt;% \n  arrange(Facility) %&gt;% \n  janitor::adorn_totals(c(\"row\", \"col\")) %&gt;% \n  knitr::kable() %&gt;% \n  kableExtra::row_spec(row = 5, bold = TRUE) %&gt;% \n  kableExtra::column_spec(column = 5, bold = TRUE) \n\n\n\n\n\nMeasurement\nFacility\n2000\n2001\n2002\nTotal\n\n\n\n\n1\nHosp 1\n66\nNA\nNA\n66\n\n\n2\nHosp 1\nNA\n26\nNA\n26\n\n\n3\nHosp 1\nNA\nNA\n8\n8\n\n\n1\nHosp 2\n71\nNA\nNA\n71\n\n\n2\nHosp 2\nNA\n62\nNA\n62\n\n\n3\nHosp 2\nNA\nNA\n70\n70\n\n\n1\nHosp 3\n47\nNA\nNA\n47\n\n\n2\nHosp 3\nNA\n70\nNA\n70\n\n\n3\nHosp 3\nNA\nNA\n38\n38\n\n\n1\nHosp 4\n82\nNA\nNA\n82\n\n\n2\nHosp 4\nNA\n87\nNA\n87\n\n\n3\nHosp 4\nNA\nNA\n46\n46\n\n\nTotal\n-\n266\n245\n162\n673\n\n\n\n\n\n\n\n\nObs: Nesse caso, foi necessário especificar para incluir apenas as três variáveis Facility, Year, e Cases pois a outra variável Measurement iria interferir com a criação da tabela:\n\ndf_combined %&gt;% \n  pivot_wider(\n    names_from = \"Year\",\n    values_from = \"Cases\"\n  ) %&gt;% \n  knitr::kable()\n\n\n\n\nMeasurement\nFacility\n2000\n2001\n2002\n\n\n\n\n1\nHosp 4\n82\nNA\nNA\n\n\n1\nHosp 3\n47\nNA\nNA\n\n\n1\nHosp 2\n71\nNA\nNA\n\n\n1\nHosp 1\n66\nNA\nNA\n\n\n2\nHosp 4\nNA\n87\nNA\n\n\n2\nHosp 3\nNA\n70\nNA\n\n\n2\nHosp 2\nNA\n62\nNA\n\n\n2\nHosp 1\nNA\n26\nNA\n\n\n3\nHosp 4\nNA\nNA\n46\n\n\n3\nHosp 3\nNA\nNA\n38\n\n\n3\nHosp 2\nNA\nNA\n70\n\n\n3\nHosp 1\nNA\nNA\n8",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Pivoteando dados</span>"
    ]
  },
  {
    "objectID": "new_pages/pivoting.pt.html#recursos",
    "href": "new_pages/pivoting.pt.html#recursos",
    "title": "12  Pivoteando dados",
    "section": "12.5 Recursos",
    "text": "12.5 Recursos\nAqui tem um tutorial útil.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Pivoteando dados</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.pt.html",
    "href": "new_pages/grouping.pt.html",
    "title": "13  Agrupando dados",
    "section": "",
    "text": "13.1 Preparação",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Agrupando dados</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.pt.html#preparação",
    "href": "new_pages/grouping.pt.html#preparação",
    "title": "13  Agrupando dados",
    "section": "",
    "text": "Carregar pacotes\nEste trecho de código mostra o carregamento dos pacotes necessários para as análises. Neste manual, enfatizamos p_load() de pacman, que instala o pacote se necessário e o carrega para utilização. Você também pode carregar os pacotes instalados com library() do R base. Veja a página em Introdução ao R para mais informações sobre os pacotes R.\n\npacman::p_load(\n  rio,       # para importar os dados\n  here,      # localizar pacotes\n  tidyverse, # limpar, manipular, e visualizar os dados (inlcui dplyr)\n  janitor)   # adicionar totais às linhas e colunas \n\n\n\nImportar datos\nNós importamos os dados de casos de uma epidemia simulada de Ebola. Se você quiser acompanhar,  clique para baixar o linelist “limpo”  (as .rds file). O conjunto de dados é importado utilizando a função import() do pacote rio. Veja a página em Importar e exportar para várias formas de importação de dados.\n\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nAs primeiras 50 linhas da linelist:",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Agrupando dados</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.pt.html#agrupando-os-dados",
    "href": "new_pages/grouping.pt.html#agrupando-os-dados",
    "title": "13  Agrupando dados",
    "section": "13.2 Agrupando os dados",
    "text": "13.2 Agrupando os dados\nA função group_by() de dplyr agrupa as linhas pelos valores únicos na coluna especificada para ela. Se várias colunas forem especificadas, as linhas são agrupadas pelas combinações únicas de valores através das colunas. Cada valor único (ou combinação de valores) constitui um grupo. Alterações subseqüentes no conjunto de dados ou cálculos podem então ser realizadas dentro do contexto de cada grupo.\nPor exemplo, o comando abaixo toma a “linelist” e agrupa as linhas por valores únicos na coluna “outcome”, salvando a saída como uma nova tabela de dados (dataframe) chamada “ll_by_outcome”. A(s) coluna(s) de agrupamento são colocadas dentro dos parênteses da função group_by()\n\nll_by_outcome &lt;- linelist %&gt;% \n  group_by(outcome)\n\nNote que não há nenhuma mudança perceptível no conjunto de dados após executar group_by(), até outra função do dplyr tal como mutate(), summarise(), ou arrange() ser aplicada no dataframe “grouped”.\nVocê pode, no entanto, “ver” os agrupamentos imprimindo o quadro de dados. Ao imprimir um quadro de dados agrupados, você verá que ele foi transformado em um objeto de classe [tibble (https://tibble.tidyverse.org/) que, quando impresso, mostra quais agrupamentos foram aplicados e quantos grupos existem - escritos logo acima da linha do cabeçalho.\n\n# visualizar quais grupos estão ativvos\nll_by_outcome\n\n# A tibble: 5,888 × 30\n# Groups:   outcome [3]\n   case_id generation date_infection date_onset date_hospitalisation\n   &lt;chr&gt;        &lt;dbl&gt; &lt;date&gt;         &lt;date&gt;     &lt;date&gt;              \n 1 5fe599           4 2014-05-08     2014-05-13 2014-05-15          \n 2 8689b7           4 NA             2014-05-13 2014-05-14          \n 3 11f8ea           2 NA             2014-05-16 2014-05-18          \n 4 b8812a           3 2014-05-04     2014-05-18 2014-05-20          \n 5 893f25           3 2014-05-18     2014-05-21 2014-05-22          \n 6 be99c8           3 2014-05-03     2014-05-22 2014-05-23          \n 7 07e3e8           4 2014-05-22     2014-05-27 2014-05-29          \n 8 369449           4 2014-05-28     2014-06-02 2014-06-03          \n 9 f393b4           4 NA             2014-06-05 2014-06-06          \n10 1389ca           4 NA             2014-06-05 2014-06-07          \n# ℹ 5,878 more rows\n# ℹ 25 more variables: date_outcome &lt;date&gt;, outcome &lt;chr&gt;, gender &lt;chr&gt;,\n#   age &lt;dbl&gt;, age_unit &lt;chr&gt;, age_years &lt;dbl&gt;, age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;,\n#   hospital &lt;chr&gt;, lon &lt;dbl&gt;, lat &lt;dbl&gt;, infector &lt;chr&gt;, source &lt;chr&gt;,\n#   wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;, ct_blood &lt;dbl&gt;, fever &lt;chr&gt;, chills &lt;chr&gt;,\n#   cough &lt;chr&gt;, aches &lt;chr&gt;, vomit &lt;chr&gt;, temp &lt;dbl&gt;, time_admission &lt;chr&gt;,\n#   bmi &lt;dbl&gt;, days_onset_hosp &lt;dbl&gt;\n\n\n\nGrupos únicos\nOs grupos criados refletem cada combinação única de valores através das colunas de agrupamento.\nPara ver os grupos e o número de linhas em cada grupo, passe os dados agrupados para tally(). Para ver apenas os grupos únicos sem conta, você pode passar para group_keys().\nVeja abaixo que existem três valores únicos na coluna de agrupamento outcome (desfecho, em português): “Death” (óbito), “Recover” (Recuperado), e NA. Veja que existem nrow(linelist %&gt;% filter(outcome == \"Death\")) óbitos, nrow(linelist %&gt;% filter(outcome == \"Recover\")) recuperações, e nrow(linelist %&gt;% filter(is.na(outcome))) sem nenhum resultado registrado.\n\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  tally()\n\n# A tibble: 3 × 2\n  outcome     n\n  &lt;chr&gt;   &lt;int&gt;\n1 Death    2582\n2 Recover  1983\n3 &lt;NA&gt;     1323\n\n\nVocê pode agrupar por mais de uma coluna. Abaixo, o dataframe é agrupado por ‘outcome’ e ‘gender’, e depois contada. Observe como cada combinação única de “outcome” e “gender” é registrada como seu próprio grupo - incluindo valores ausentes para cada coluna.\n\nlinelist %&gt;% \n  group_by(outcome, gender) %&gt;% \n  tally()\n\n# A tibble: 9 × 3\n# Groups:   outcome [3]\n  outcome gender     n\n  &lt;chr&gt;   &lt;chr&gt;  &lt;int&gt;\n1 Death   f       1227\n2 Death   m       1228\n3 Death   &lt;NA&gt;     127\n4 Recover f        953\n5 Recover m        950\n6 Recover &lt;NA&gt;      80\n7 &lt;NA&gt;    f        627\n8 &lt;NA&gt;    m        625\n9 &lt;NA&gt;    &lt;NA&gt;      71\n\n\n\n\nNovas colunas\nVocê também pode criar uma nova coluna de agrupamento dentro da função group_by(). Isto equivale a chamar a funçãomutate() antes da instrução group_by(). Para uma tabulação rápida, este estilo pode ser útil, mas para maior clareza em seu código, considere criar esta coluna em seu próprio passo mutate() e depois encadear (usando o “pipe” %&gt;%) com o group_by().\n\n# agrupar dados baseado em uma coluna biária criada dentro do próprio comando group_by  \nlinelist %&gt;% \n  group_by(\n    age_class = ifelse(age &gt;= 18, \"adult\", \"child\")) %&gt;% \n  tally(sort = T)\n\n# A tibble: 3 × 2\n  age_class     n\n  &lt;chr&gt;     &lt;int&gt;\n1 child      3618\n2 adult      2184\n3 &lt;NA&gt;         86\n\n\n\n\nAdicionar/Eliminar colunas de agrupamento\nPor padrão, se você executar group_by() em dados que já estão agrupados, os grupos antigos serão removidos e o(s) novo(s) grupo(s) será(ão) aplicado(s). Se você quiser adicionar novos grupos aos já existentes, inclua o argumento `.add = TRUE’.\n\n# Agrupado por 'outcome' (desfecho)\nby_outcome &lt;- linelist %&gt;% \n  group_by(outcome)\n\n# Adicionar um agrupamento por 'gender' (sexo) \nby_outcome_gender &lt;- by_outcome %&gt;% \n  group_by(gender, .add = TRUE)\n\nManter todos os grupos\nSe você agrupar em uma coluna do tipo fator, pode haver níveis do fator que não estão presentes atualmente nos dados. Se você agrupar nesta coluna, por padrão esses níveis não presentes são descartados e não incluídos como grupos. Para alterar isso para que todos os níveis apareçam como grupos (mesmo que não estejam presentes nos dados), defina .drop = FALSE' em seu comandogroup_by()`.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Agrupando dados</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.pt.html#desagrupar",
    "href": "new_pages/grouping.pt.html#desagrupar",
    "title": "13  Agrupando dados",
    "section": "13.3 Desagrupar",
    "text": "13.3 Desagrupar\nOs dados que foram agrupados permanecerão agrupados até que especificamente não sejam agrupados através do ungroup(). Se você se esquecer de desagradar, isso pode levar a cálculos incorretos! Abaixo está um exemplo de remoção de todos os agrupamentos:\n\nlinelist %&gt;% \n  group_by(outcome, gender) %&gt;% \n  tally() %&gt;% \n  ungroup()\n\nVocê também pode remover o agrupamento apenas para colunas específicas, colocando o nome da coluna dentro de ungroup().\n\nlinelist %&gt;% \n  group_by(outcome, gender) %&gt;% \n  tally() %&gt;% \n  ungroup(gender) # remove o agrupamento por `gender` (sexo), mantendo o agrupamento por `outcome` (desfecho) \n\nNOTA: O verbo count() desagrupa os dados automaticamente após a contagem.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Agrupando dados</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.pt.html#group_summarise",
    "href": "new_pages/grouping.pt.html#group_summarise",
    "title": "13  Agrupando dados",
    "section": "13.4 Resumir os dados (Summarise)",
    "text": "13.4 Resumir os dados (Summarise)\nConsulte a seção dplyr da página Tabelas descritivas para obter uma descrição detalhada de como produzir tabelas resumidas com summarise(). Aqui abordamos brevemente como seu comportamento muda quando aplicado a dados agrupados.\nA função dplyr summarise() (ou summarize()) pega um dataframe e o converte em um novo dataframe resumido, com colunas contendo as estatísticas resumidas que você definiu. Em dataframe não agrupados, as estatísticas resumidas serão calculadas a partir de todas as linhas. A aplicação de summarise() aos dados agrupados produz estas estatísticas resumidas para cada grupo.\nA sintaxe de summarise() é tal que você fornece o(s) nome(s) da(s) nova(s) coluna(s) resumo, um sinal de igual, e então uma função estatística a ser aplicada aos dados, como mostrado abaixo. Por exemplo, min(), max(), median(), ou sd(). Dentro da função estatística, liste a coluna a ser operada e qualquer argumento relevante (por exemplo, na.rm = TRUE). Você pode utilizar sum() para contar o número de linhas que satisfazem um critério lógico (com duplo igual a `==``).\nAbaixo está um exemplo de summarise() aplicado em dados não-agrupados. As estatísticas resultantes são produzidas a partir de todo o conjunto de dados.\n\n# estatísticas resumo na linelist desagrupada \nlinelist %&gt;% \n  summarise(\n    n_cases  = n(),\n    mean_age = mean(age_years, na.rm=T),\n    max_age  = max(age_years, na.rm=T),\n    min_age  = min(age_years, na.rm=T),\n    n_males  = sum(gender == \"m\", na.rm=T))\n\n  n_cases mean_age max_age min_age n_males\n1    5888 16.01831      84       0    2803\n\n\nEm contraste, abaixo está a mesma declaração summarise() aplicada aos dados agrupados. As estatísticas são calculadas para cada grupo de “outcome” (desfecho). Observe como as colunas de agrupamento serão transportadas para o dataframe.\n\n# statísticas resumo na linelist agrupada \nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  summarise(\n    n_cases  = n(),\n    mean_age = mean(age_years, na.rm=T),\n    max_age  = max(age_years, na.rm=T),\n    min_age  = min(age_years, na.rm=T),\n    n_males    = sum(gender == \"m\", na.rm=T))\n\n# A tibble: 3 × 6\n  outcome n_cases mean_age max_age min_age n_males\n  &lt;chr&gt;     &lt;int&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;int&gt;\n1 Death      2582     15.9      76       0    1228\n2 Recover    1983     16.1      84       0     950\n3 &lt;NA&gt;       1323     16.2      69       0     625\n\n\nDICA: A função summarise funciona com a ortografia britânica e americana - summarise() e summarize() chamam a mesma função.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Agrupando dados</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.pt.html#contagens",
    "href": "new_pages/grouping.pt.html#contagens",
    "title": "13  Agrupando dados",
    "section": "13.5 Contagens",
    "text": "13.5 Contagens\nAs funções count() e tally() tem funcionalidade semelhante mas são diferentes. Leia mais sobre a distinção entre tally() e count() here\n\ntally()\ntally() é um atalho para summarise(n = n()), e não agrupa os dados. Assim, para ter tallys (contagens) agrupadas, esta função deve ser precedida de um comando group_by(). Você pode adicionar sort = TRUE para ver os grupos maiores primeiro.\n\nlinelist %&gt;% \n  tally()\n\n     n\n1 5888\n\n\n\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  tally(sort = TRUE)\n\n# A tibble: 3 × 2\n  outcome     n\n  &lt;chr&gt;   &lt;int&gt;\n1 Death    2582\n2 Recover  1983\n3 &lt;NA&gt;     1323\n\n\n\n\ncount()\nPor outro lado, count() faz o seguinte:\n\naplica group_by() nas colunas especificadas\n\naplica summarise() e retorna a coluna n com o número de linhas por grupo\naplica ungroup()\n\n\nlinelist %&gt;% \n  count(outcome)\n\n  outcome    n\n1   Death 2582\n2 Recover 1983\n3    &lt;NA&gt; 1323\n\n\nAssim como em group_by() você pode adicionar uma nova coluna dentro do comando count():\n\nlinelist %&gt;% \n  count(age_class = ifelse(age &gt;= 18, \"adult\", \"child\"), sort = T)\n\n  age_class    n\n1     child 3618\n2     adult 2184\n3      &lt;NA&gt;   86\n\n\nO comandocount() pode ser chamado várias vezes, com a funcionalidade “rolling-up” (rolando para cima). Por exemplo, para resumir o número de hospitais presentes para cada sexo, execute o seguinte. Nota, o nome da coluna final é alterado do padrão “n” para maior clareza (com name =).\n\nlinelist %&gt;% \n  # produz contagens para grupos únicos de  \"outcome-gender\" groups\n  count(gender, hospital) %&gt;% \n  # junta lingas por `gender` (3) e conta a quantidade de hospitais por gênero (6)\n  count(gender, name = \"hospitals per gender\" ) \n\n  gender hospitals per gender\n1      f                    6\n2      m                    6\n3   &lt;NA&gt;                    6\n\n\n\n\nAdicionar contagens\nEm contraste com count() e summarise(), você pode utilizar add_count() para adicionar uma nova coluna n com a contagem de linhas por grupo enquanto mantém todas as outras colunas do dataframe.\nIsto significa que o número de contagem de um grupo, na nova coluna n, será impresso em cada linha do grupo. Para fins de demonstração, adicionamos esta coluna e depois reorganizamos as colunas para facilitar a visualização. Veja a seção abaixo em filtro no tamanho do grupo para outro exemplo.\n\nlinelist %&gt;% \n  as_tibble() %&gt;%                   # converte para \"tibble\" para melhro vizualização\n  add_count(hospital) %&gt;%           # adiciona coluna n com as contages por hospital \n  select(hospital, n, everything()) # re-organiza para o propósito desta demostração\n\n# A tibble: 5,888 × 31\n   hospital                       n case_id generation date_infection date_onset\n   &lt;chr&gt;                      &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt; &lt;date&gt;         &lt;date&gt;    \n 1 Other                        885 5fe599           4 2014-05-08     2014-05-13\n 2 Ausente                     1469 8689b7           4 NA             2014-05-13\n 3 St. Mark's Maternity Hosp…   422 11f8ea           2 NA             2014-05-16\n 4 Port Hospital               1762 b8812a           3 2014-05-04     2014-05-18\n 5 Military Hospital            896 893f25           3 2014-05-18     2014-05-21\n 6 Port Hospital               1762 be99c8           3 2014-05-03     2014-05-22\n 7 Ausente                     1469 07e3e8           4 2014-05-22     2014-05-27\n 8 Ausente                     1469 369449           4 2014-05-28     2014-06-02\n 9 Ausente                     1469 f393b4           4 NA             2014-06-05\n10 Ausente                     1469 1389ca           4 NA             2014-06-05\n# ℹ 5,878 more rows\n# ℹ 25 more variables: date_hospitalisation &lt;date&gt;, date_outcome &lt;date&gt;,\n#   outcome &lt;chr&gt;, gender &lt;chr&gt;, age &lt;dbl&gt;, age_unit &lt;chr&gt;, age_years &lt;dbl&gt;,\n#   age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;, lon &lt;dbl&gt;, lat &lt;dbl&gt;, infector &lt;chr&gt;,\n#   source &lt;chr&gt;, wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;, ct_blood &lt;dbl&gt;, fever &lt;chr&gt;,\n#   chills &lt;chr&gt;, cough &lt;chr&gt;, aches &lt;chr&gt;, vomit &lt;chr&gt;, temp &lt;dbl&gt;,\n#   time_admission &lt;chr&gt;, bmi &lt;dbl&gt;, days_onset_hosp &lt;dbl&gt;\n\n\n\n\nAdicionar totais\nPara adicionar facilmente uma linhas ou colunas com os total ou colunas após utilizar tally() ou count(), veja a seção janitor da página Tabelas descritivas. Este pacote oferece funções como adorn_totals() e adorn_percentagens() para adicionar totais e converter para mostrar porcentagens. Abaixo está um breve exemplo:\n\nlinelist %&gt;%                                  # caso linelist\n  tabyl(age_cat, gender) %&gt;%                  # tabela cruzada para duas colinas\n  adorn_totals(where = \"row\") %&gt;%             # adiciona uma linha de totais\n  adorn_percentages(denominator = \"col\") %&gt;%  # converte para proporções com a coluna `denominator`\n  adorn_pct_formatting() %&gt;%                  # converte proporções para porcentagens\n  adorn_ns(position = \"front\") %&gt;%            # mostrar como: \"count (percent)\"\n  adorn_title(                                # ajustar título\n    row_name = \"Age Category\",\n    col_name = \"Gender\")\n\n                      Gender                            \n Age Category              f              m          NA_\n          0-4   640  (22.8%)   416  (14.8%)  39  (14.0%)\n          5-9   641  (22.8%)   412  (14.7%)  42  (15.1%)\n        10-14   518  (18.5%)   383  (13.7%)  40  (14.4%)\n        15-19   359  (12.8%)   364  (13.0%)  20   (7.2%)\n        20-29   468  (16.7%)   575  (20.5%)  30  (10.8%)\n        30-49   179   (6.4%)   557  (19.9%)  18   (6.5%)\n        50-69     2   (0.1%)    91   (3.2%)   2   (0.7%)\n          70+     0   (0.0%)     5   (0.2%)   1   (0.4%)\n         &lt;NA&gt;     0   (0.0%)     0   (0.0%)  86  (30.9%)\n        Total 2,807 (100.0%) 2,803 (100.0%) 278 (100.0%)\n\n\nPara adicionar linhas de totais mais complexas que envolvam estatísticas resumidas diferentes de somas, ver esta seção da página Tabelas Descritivas.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Agrupando dados</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.pt.html#agrupoando-por-data",
    "href": "new_pages/grouping.pt.html#agrupoando-por-data",
    "title": "13  Agrupando dados",
    "section": "13.6 Agrupoando por data",
    "text": "13.6 Agrupoando por data\nAo agrupar os dados por data, você deve ter (ou criar) uma coluna para a unidade de data de interesse - por exemplo “dia”, “epiweek”, “mês”, etc. Você pode fazer esta coluna utilizando floor_date() from lubridate, como explicado na seção Semanas Epidemiológicas da página Trabalhando com datas. Uma vez que você tenha esta coluna, você pode utilizar count() from dplyr* para agrupar as linhas por esses valores de data únicos e obter contagens agregadas.\nUma etapa adicional comum para situações de datas, é “preencher” quaisquer datas na seqüência que não estejam presentes nos dados. Utilize complete() do tidyr* para que a série de datas agregadas seja completa incluindo todas as unidades de data possíveis dentro do intervalo. Sem esta etapa, uma semana sem casos reportados pode não aparecer em seus dados!\nDentro de complete() você define sua coluna de datas como uma seqüência de datas seq.Date() do mínimo para o máximo - assim, as datas são expandidas. Por padrão, os valores de contagem de casos em qualquer nova linha “expandida” serão NA. Você pode defini-los como 0 utilizando o fill = argumento de complete(), que espera uma lista nomeada (se sua coluna de contagem for chamada n, forneça fill = lista(n = 0). Veja `?complete’ para detalhes e a página Trabalhando com datas para um exemplo.\n\nOs casos da Linelist em dias\nAqui está um exemplo de agrupamento de casos em dias sem utilizar a função complete(). Observe que as primeiras linhas saltam as datas sem casos.\n\ndaily_counts &lt;- linelist %&gt;% \n  drop_na(date_onset) %&gt;%        # remove casos que faltam date_onset\n  count(date_onset)              # conta o número de linhas poro data única \n\n\n\n\n\n\n\nAbaixo nós adicionamos o comando complete() para assegurar que todos os dias estão representados.\n\ndaily_counts &lt;- linelist %&gt;% \n  drop_na(date_onset) %&gt;%                 # remove casos em que faltam date_onset\n  count(date_onset) %&gt;%                   # conta o número de linhas poro data única\n  complete(                               # assegura que todos os dias aparecem \n    date_onset = seq.Date(                # re-define a coluna data como uma sequencia diária\n      from = min(date_onset, na.rm=T), \n      to = max(date_onset, na.rm=T),\n      by = \"day\"),\n    fill = list(n = 0))                   # configura as linhas adicionadas para apresentar 0 e na coluna n  (não NAcomo no padrão) \n\n\n\n\n\n\n\n\n\nCasos Linelist em semanas\nO mesmo princípio pode ser aplicado durante semanas. Primeiro cria-se uma nova coluna que é a semana do caso utilizando floor_date() com unit = \"semana\". Em seguida, utilize count() como acima para obter contagens semanais de casos. Termine com complete() para garantir que todas as semanas sejam representadas, mesmo que não contenham casos.\n\n# Mostrar dados por contagens semanais\nweekly_counts &lt;- linelist %&gt;% \n  drop_na(date_onset) %&gt;%                 # remove casos em que está faltando date_onset\n  mutate(week = lubridate::floor_date(date_onset, unit = \"week\")) %&gt;%  # nova coluna com a data \n  count(week) %&gt;%                         #  agrupa dados por semana e conta \n  complete(                               # assegura que todos as semanas aparencem \n    week = seq.Date(                      # redefine a coluna data como uma sequência completa\n      from = min(week, na.rm=T), \n      to = max(week, na.rm=T),\n      by = \"week\"),\n    fill = list(n = 0))                   # configura as linhas adicionadas para apresentar 0 e na coluna n  (não NAcomo no padrão) \n\nAqui estão as 50 primeiras linhas do dataframe resultante:\n\n\n\n\n\n\n\n\nCasos da Linelist em meses\nPara agregar os casos em meses, novamente utilize floor_date() do pacote lubridate, mas com o argumento unit = \"meses\". Isto arredonda cada data até o dia 1 de seu mês. A saída será classe Data. Observe que no passo complete() também utilizamos by = \"meses\".\n\n# Mostrar dados para contagens mensais\nmonthly_counts &lt;- linelist %&gt;% \n  drop_na(date_onset) %&gt;% \n  mutate(month = lubridate::floor_date(date_onset, unit = \"months\")) %&gt;%  # nova colua com o 1 mês do `onset` \n  count(month) %&gt;%                          # conta casos por mês\n  complete(\n    month = seq.Date(\n      min(month, na.rm=T),     # inclui todos os meses mesmo os sem casos reportados \n      max(month, na.rm=T),\n      by=\"month\"),\n    fill = list(n = 0))\n\n\n\n\n\n\n\n\n\nContagens diárias em semanas\nPara agregar as contagens diárias em contagens semanais, utilize floor_date() como acima. Entretanto, utilize group_by() e summarize() em vez de count() porque você precisa sum() contar casos diários em vez de apenas contar o número de filas por semana.\n\nContagens diárias em meses\nPara agregar as contagens diárias em contagens de meses, utilize floor_date() com unit = \"month\" (mês) como acima. Entretanto, utilize group_by() e summarize() em vez de count() porque você precisa sum() contar casos diários em vez de apenas contar o número de filas por mês.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Agrupando dados</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.pt.html#organizando-dados-agrupados",
    "href": "new_pages/grouping.pt.html#organizando-dados-agrupados",
    "title": "13  Agrupando dados",
    "section": "13.7 Organizando dados agrupados",
    "text": "13.7 Organizando dados agrupados\nUtilizando o verbo arrange()do dplyr para ordenar as linhas em um quadro de dados se comporta da mesma forma quando os dados são agrupados, a menos que você defina o argumento .by_group =TRUE. Neste caso, as linhas são ordenadas primeiro pelas colunas de agrupamento e depois por quaisquer outras colunas que você especificar para arrange().",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Agrupando dados</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.pt.html#filtrando-dados-agrupados",
    "href": "new_pages/grouping.pt.html#filtrando-dados-agrupados",
    "title": "13  Agrupando dados",
    "section": "13.8 Filtrando dados agrupados",
    "text": "13.8 Filtrando dados agrupados\n\nfilter()\nQuando aplicadas em conjunto com funções que avaliam o dataframe (como max(), min(), mean()), estas funções serão agora aplicadas aos grupos. Por exemplo, se você quiser filtrar e manter linhas onde os pacientes estão acima da mediana de idade, isto agora será aplicado por grupo - filtrando para manter linhas acima da mediana de idade do grupo.\n\n\nLinhas de corte por grupo\nA função slice() (literalmente: fatiar) do pacote dplyr , que filtra linhas com base em sua posição nos dados, também pode ser aplicada por grupo. Lembre-se de levar em conta a ordenação dos dados dentro de cada grupo para obter a “fatia” desejada.\nPor exemplo, para recuperar apenas as últimas 5 admissões de cada hospital:\n\nAgrupar a lineliste por coluna “hospital”.\n\nOrganizar os registros da mais recente à mais antiga date_hospitalisation (data de hospitalização) em cada grupo hospitalar.\n\nDivide para recuperar as 5 primeiras fileiras de cada hospital\n\n\nlinelist %&gt;%\n  group_by(hospital) %&gt;%\n  arrange(hospital, date_hospitalisation) %&gt;%\n  slice_head(n = 5) %&gt;% \n  arrange(hospital) %&gt;%                            # para visualizar\n  select(case_id, hospital, date_hospitalisation)  # para visualizar\n\n# A tibble: 30 × 3\n# Groups:   hospital [6]\n   case_id hospital         date_hospitalisation\n   &lt;chr&gt;   &lt;chr&gt;            &lt;date&gt;              \n 1 6c286a  Ausente          2014-04-27          \n 2 49731d  Ausente          2014-05-02          \n 3 f1f60f  Ausente          2014-05-09          \n 4 8689b7  Ausente          2014-05-14          \n 5 6285c9  Ausente          2014-05-14          \n 6 20b688  Central Hospital 2014-05-06          \n 7 d58402  Central Hospital 2014-05-10          \n 8 b8f2fd  Central Hospital 2014-05-13          \n 9 acf422  Central Hospital 2014-05-28          \n10 275cc7  Central Hospital 2014-05-28          \n# ℹ 20 more rows\n\n\nslice_head() - selecciona n linhas do topo\nslice_tail() - selecciona n linhas do final slice_sample() - seleciona aleatoriamente n linhas slice_min() - seleciona n linhas com os valores mais altos da coluna order_by =, use with_ties = TRUE para manter os vínculos slice_max() - seleciona os menores valores da coluna order_by = column, , use with_ties = TRUE para manter os vínculos\nVeja a página Eliminando duplicidades para meis exemplos e detalhes de slice().\n\n\nFiltrar por tamanho do grupo\nA função add_count() adiciona uma coluna n aos dados originais dando o número de linhas no grupo daquela linha.\nMostrado abaixo, add_count() é aplicado à coluna hospital, assim os valores na nova coluna n refletem o número de linhas no grupo hospitalar. Observe como os valores na coluna n são repetidos. No exemplo abaixo, o nome da coluna n poderia ser alterado utilizando name = dentro de add_count(). Para fins de demonstração, reorganizamos as colunas com select().\n\nlinelist %&gt;% \n  as_tibble() %&gt;% \n  add_count(hospital) %&gt;%          # adiciona \"número de linhas adimitidas no mesmo hospital que o dessa linha\" \n  select(hospital, n, everything())\n\n# A tibble: 5,888 × 31\n   hospital                       n case_id generation date_infection date_onset\n   &lt;chr&gt;                      &lt;int&gt; &lt;chr&gt;        &lt;dbl&gt; &lt;date&gt;         &lt;date&gt;    \n 1 Other                        885 5fe599           4 2014-05-08     2014-05-13\n 2 Ausente                     1469 8689b7           4 NA             2014-05-13\n 3 St. Mark's Maternity Hosp…   422 11f8ea           2 NA             2014-05-16\n 4 Port Hospital               1762 b8812a           3 2014-05-04     2014-05-18\n 5 Military Hospital            896 893f25           3 2014-05-18     2014-05-21\n 6 Port Hospital               1762 be99c8           3 2014-05-03     2014-05-22\n 7 Ausente                     1469 07e3e8           4 2014-05-22     2014-05-27\n 8 Ausente                     1469 369449           4 2014-05-28     2014-06-02\n 9 Ausente                     1469 f393b4           4 NA             2014-06-05\n10 Ausente                     1469 1389ca           4 NA             2014-06-05\n# ℹ 5,878 more rows\n# ℹ 25 more variables: date_hospitalisation &lt;date&gt;, date_outcome &lt;date&gt;,\n#   outcome &lt;chr&gt;, gender &lt;chr&gt;, age &lt;dbl&gt;, age_unit &lt;chr&gt;, age_years &lt;dbl&gt;,\n#   age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;, lon &lt;dbl&gt;, lat &lt;dbl&gt;, infector &lt;chr&gt;,\n#   source &lt;chr&gt;, wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;, ct_blood &lt;dbl&gt;, fever &lt;chr&gt;,\n#   chills &lt;chr&gt;, cough &lt;chr&gt;, aches &lt;chr&gt;, vomit &lt;chr&gt;, temp &lt;dbl&gt;,\n#   time_admission &lt;chr&gt;, bmi &lt;dbl&gt;, days_onset_hosp &lt;dbl&gt;\n\n\nTorna-se então fácil filtrar para linhas de casos que foram hospitalizados em um hospital “pequeno”, digamos, um hospital que admitiu menos de 500 pacientes:\n\nlinelist %&gt;% \n  add_count(hospital) %&gt;% \n  filter(n &lt; 500)",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Agrupando dados</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.pt.html#criando-novas-variáveis-mutate-em-dados-agrupados",
    "href": "new_pages/grouping.pt.html#criando-novas-variáveis-mutate-em-dados-agrupados",
    "title": "13  Agrupando dados",
    "section": "13.9 Criando novas variáveis (mutate) em dados agrupados",
    "text": "13.9 Criando novas variáveis (mutate) em dados agrupados\nPara manter todas as colunas e linhas (não resumir) e adicionar uma nova coluna contendo estatísticas de grupo, utilizar mutate() após group_by() em vez de summarise().\nIsto é útil se você quiser estatísticas de grupo no conjunto de dados original * com todas as outras colunas presentes* - por exemplo, para cálculos que comparam uma linha com seu grupo.\nPor exemplo, este código abaixo calcula a diferença entre o atraso de para a admissão de uma observação e o atraso mediano para seu hospital. As etapas são:\n\nAgrupar os dados por hospital\n\nUtilize a coluna days_onset_hosp (atraso à hospitalização) para criar uma nova coluna contendo o atraso médio no hospital para aquela linha.\n\nCalcular a diferença entre as duas colunas\n\nNós usamos a função select() para selecionar apenas certas colunas a serem exibidas, para fins de demonstração.\n\nlinelist %&gt;% \n  # agrupando dados por hospital (sem mudanças na linelist ainda)\n  group_by(hospital) %&gt;% \n  \n  # novas colunas\n  mutate(\n    # quantidades de dias média para admissão por hospital (arredondado para 1 decimal)\n    group_delay_admit = round(mean(days_onset_hosp, na.rm=T), 1),\n    \n    # diferença entre o atraso daquela observação e o atraso medio do hospital (arredondado para 1 decimal)\n    diff_to_group     = round(days_onset_hosp - group_delay_admit, 1)) %&gt;%\n  \n  # seleciona alguma linhas apenas - para fim de demostração/visualização  \n  select(case_id, hospital, days_onset_hosp, group_delay_admit, diff_to_group)\n\n# A tibble: 5,888 × 5\n# Groups:   hospital [6]\n   case_id hospital              days_onset_hosp group_delay_admit diff_to_group\n   &lt;chr&gt;   &lt;chr&gt;                           &lt;dbl&gt;             &lt;dbl&gt;         &lt;dbl&gt;\n 1 5fe599  Other                               2               2             0  \n 2 8689b7  Ausente                             1               2.1          -1.1\n 3 11f8ea  St. Mark's Maternity…               2               2.1          -0.1\n 4 b8812a  Port Hospital                       2               2.1          -0.1\n 5 893f25  Military Hospital                   1               2.1          -1.1\n 6 be99c8  Port Hospital                       1               2.1          -1.1\n 7 07e3e8  Ausente                             2               2.1          -0.1\n 8 369449  Ausente                             1               2.1          -1.1\n 9 f393b4  Ausente                             1               2.1          -1.1\n10 1389ca  Ausente                             2               2.1          -0.1\n# ℹ 5,878 more rows",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Agrupando dados</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.pt.html#selecionar-em-dados-agrupados",
    "href": "new_pages/grouping.pt.html#selecionar-em-dados-agrupados",
    "title": "13  Agrupando dados",
    "section": "13.10 Selecionar em dados agrupados",
    "text": "13.10 Selecionar em dados agrupados\nO verbo select() funciona em dados agrupados, mas as colunas de agrupamento são sempre incluídas (mesmo se não mecionadas explicitamente em select()). Se você não quiser essas colunas, precisa usarprimeiro a função ungroup() para desagrupá-los.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Agrupando dados</span>"
    ]
  },
  {
    "objectID": "new_pages/grouping.pt.html#recursos",
    "href": "new_pages/grouping.pt.html#recursos",
    "title": "13  Agrupando dados",
    "section": "13.11 Recursos",
    "text": "13.11 Recursos\nAqui estão alguns recursos úteis para mais informações.\nVocê pode aplicar funções de resumo em dados agrupados; ver a “cheat sheet” (cola) de transformação de dados do RStudio.\nA página do Data Carpentry dplyr\nAs páginas de referência do tidyverse em group_by() and grouping\nEsta página em Manipulação de dados\nResumindo com condicionamento no dplyr",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Agrupando dados</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.pt.html",
    "href": "new_pages/joining_matching.pt.html",
    "title": "14  Juntando dados (Joins)",
    "section": "",
    "text": "14.1 Preparação",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Juntando dados (Joins)</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.pt.html#preparação",
    "href": "new_pages/joining_matching.pt.html#preparação",
    "title": "14  Juntando dados (Joins)",
    "section": "",
    "text": "Carregue os pacotes R\nO código abaixo realiza o carregamento dos pacotes necessários para a análise dos dados. Neste manual, enfatizamos o uso da função p_load(), do pacman, que instala os pacotes, caso não estejam instalados, e os carrega no R para utilização. Também é possível carregar pacotes instalados utilizando a função library(), do R base. Para mais informações sobre os pacotes do R, veja a página Introdução ao R.\n\npacman::p_load(\n  rio, # importar and exportar\n  here, # localizar arquivos\n  tidyverse, # gerenciamento e visualização de dados\n  RecordLinkage, # combinações probabilisticas\n  fastLink # combinações probabilisticas\n)\n\n\n\nImporte dados\nPara iniciar, importaremos a versão limpa da linelist de casos de uma epidemia simulada de Ebola. Se você quiser acompanhar, clique para baixar a linelist “limpa” (com um arquivo .rds). Importe os dados com a função import() do pacote rio (ela manipula vários tipos de arquivo, tais como .xlsx, .csv, .rds - veja na página Importando and exportando para detalhes).\n\n# importa a linelist de casos\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nAs primeiras 50 linhas da linelist são mostradas abaixo.\n\n\n\n\n\n\n\n\n\nBase de dados de exemplo\nPara demonstrar um join na seção abaixo, utilizaremos as seguintes bases de dados:\n\nUma versão “miniatura” da linelist de casos, contendo apenas as colunas case_id, date_onset, e hospital, e apenas as primeiras 10 linhas\nUm dataframe separado chamado hosp_info, que contém mais detalhes sobre cada hospital\n\nNa seção de combinação probabilística, utilizaremos outras duas bases diferentes. O código para criar essas bases serão mostradas naquela seção.\n\nLinelist de casos “miniatura”\nAbaixo está a miniatura da linelist de casos, que contém apenas 10 linhas e só as colunas case_id, date_onset, e hospital.\n\nlinelist_mini &lt;- linelist %&gt;% # começa com a linelist original\n  select(case_id, date_onset, hospital) %&gt;% # seleciona colunas\n  head(10) # seleciona apenas 10 primeira linhas\n\n\n\n\n\n\n\n\n\nDataframe com informações dos hospitais\nAbaixo está o código para criar um dataframe separado com informações adicionais sobre sete hospitais (abrangência populacional e o nível de atenção disponível). Note que o nome “Military Hospital” pertence a dois hospitais diferentes - um no primeiro nível servindo 10000 residentes e outro no nível secundário servindo 50280 residentes.\n\n# Cria o dataframe de informação dos hospitais\nhosp_info &lt;- data.frame(\n  hosp_name     = c(\"central hospital\", \"military\", \"military\", \"port\", \"St. Mark's\", \"ignace\", \"sisters\"),\n  catchment_pop = c(1950280, 40500, 10000, 50280, 12000, 5000, 4200),\n  level         = c(\"Tertiary\", \"Secondary\", \"Primary\", \"Secondary\", \"Secondary\", \"Primary\", \"Primary\")\n)\n\nAqui está esse dataframe:\n\n\n\n\n\n\n\n\n\n\nPré-limpeza\nJoins tradicionais (não-probabilísticos) são sensíveis ao caso (maiúsculos/minúsculos) e necessitam que os caracteres combinem de forma exata (exact match) entre os valores nos dois dataframes. Para demonstrar alguns dos passos de limpeza que você possa precisar executar antes de iniciar um join, vamos limpar e alinhar as bases linelist_mini e hosp_info agora.\nIdentifique as diferenças\nPrecisamos que os valores da coluna hosp_name no dataframe hosp_info combinem com os valores da coluna hospital no dataframe linelist_mini.\nAqui estão os valores do dataframe linelist_mini, impressos com a função unique() do R base:\n\nunique(linelist_mini$hospital)\n\n[1] \"Other\"                               \n[2] \"Ausente\"                             \n[3] \"St. Mark's Maternity Hospital (SMMH)\"\n[4] \"Port Hospital\"                       \n[5] \"Military Hospital\"                   \n\n\ne aqui estão os valores do dataframe hosp_info:\n\nunique(hosp_info$hosp_name)\n\n[1] \"central hospital\" \"military\"         \"port\"             \"St. Mark's\"      \n[5] \"ignace\"           \"sisters\"         \n\n\nVocê pode ver que apesar de alguns dos hospitais existirem em ambos dataframes, existem muitas diferenças na forma como os nomes estão escritos.\nAlinhando valores\nVamos começar limpando os valores do dataframe hosp_info. Como explicado na página Limpando dados e funções principais, podemos recodificar valores com critérios lógicos utilizando a função case_when() do pacote dplyr. Para os quatro hospitais que existem em ambos os dataframes, vamos mudar os valores para alinhar com os valores da linelist_mini. Para os outros hospitais, deixaremos os valores como estão (TRUE ~ hosp_name).\nCUIDADO: Tipicamente, quando estamos limpando dataframes devemos criar uma nova coluna (ex: hosp_name_clean), mas para facilitar a demonstração vamos mostrar diretamente a modificação da antiga coluna\n\nhosp_info &lt;- hosp_info %&gt;%\n  mutate(\n    hosp_name = case_when(\n      # critério                         # novo valor\n      hosp_name == \"military\" ~ \"Military Hospital\",\n      hosp_name == \"port\" ~ \"Port Hospital\",\n      hosp_name == \"St. Mark's\" ~ \"St. Mark's Maternity Hospital (SMMH)\",\n      hosp_name == \"central hospital\" ~ \"Central Hospital\",\n      TRUE ~ hosp_name\n    )\n  )\n\nOs nomes dos hospitais que aparecem em ambos os dataframes estão alinhados. Existem dois hospitais em hosp_info que não estão presentes em linelist_mini - vamos lidar com estes depois, no join.\n\nunique(hosp_info$hosp_name)\n\n[1] \"Central Hospital\"                    \n[2] \"Military Hospital\"                   \n[3] \"Port Hospital\"                       \n[4] \"St. Mark's Maternity Hospital (SMMH)\"\n[5] \"ignace\"                              \n[6] \"sisters\"                             \n\n\nAntes de fazer um join, geralmente o mais fácil é converter uma coluna completamente para letras minúsculas (lowercase) ou letras maiúsculas (uppercase). Se você precisar converter todos os valores de uma coluna para MAIÚSCULO ou minúsculo, utilize a função mutate() e envolva a coluna com alguma dessas funções do pacote stringr, como mostrado na página Caracteres e strings.\nstr_to_upper()\nstr_to_upper()\nstr_to_title()",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Juntando dados (Joins)</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.pt.html#joins-com-dplyr",
    "href": "new_pages/joining_matching.pt.html#joins-com-dplyr",
    "title": "14  Juntando dados (Joins)",
    "section": "14.2 Joins com dplyr",
    "text": "14.2 Joins com dplyr\nO pacote dplyr oferece várias funções diferentes de join. dplyr está incluso no pacote tidyverse. Essas funções de join são descritas abaixo, com casos de uso simples.\nAgradecimentos a https://github.com/gadenbuie pelos gifs informativos!\n\n\nSintaxe geral\nOs comandos de join podem ser executados individualmente para juntar dois dataframes em um novo objeto, ou podem ser usados em uma cadeia de comandos com pipe (%&gt;%) para mesclar um dataframe em outro à medida que ele vai sendo limpo ou modificado de alguma outra forma.\nNo exemplo abaixo, a função left_join() é utilizada como um comando individual para criar um novo dataframe chamado joined_data. As entradas (inputs) são os dataframes 1 e 2 (df1 e df2). O primeiro dataframe listado é o dataframe de base e o segundo é o dataframe que será mesclado a (joined to) ele.\nO terceiro argumento by = é onde você especifica as colunas em cada dataframe que serão utilizadas para alinhar as linhas dos dois dataframes. Se os nomes dessas colunas forem diferentes, insira o nome delas com um vetor c() como mostrado abaixo, onde as linhas são combinadas com base nos valores comuns entre a coluna ID em df1 e a coluna identifier em df2.\n\n# Faz o join baseado nos valores comuns entre a coluna \"ID\" (primeiro dataframe) e coluna \"identifier\" (segundo dataframe)\njoined_data &lt;- left_join(df1, df2, by = c(\"ID\" = \"identifier\"))\n\nSe as colunas utilizadas no parâmetro by tiverem exatamente o mesmo nome em ambos os dataframes, você pode inserir apenas esse nome, entre aspas.\n\n# Join baseado nos valores comuns da coluna \"ID\" em ambos os dataframes\njoined_data &lt;- left_join(df1, df2, by = \"ID\")\n\nSe você estiver juntando dataframes baseado em valores comuns ao longo de múltiplos campos, liste esses campos em um vetor c(). Esse exemplo junta linhas se os valores em três colunas em cada base de dado se alinham de forma exata.\n\n# join baseado nos mesmos primeiro nome, último nome e idade\njoined_data &lt;- left_join(df1, df2, by = c(\"name\" = \"firstname\", \"surname\" = \"lastname\", \"Age\" = \"age\"))\n\nOs comandos de join também podem ser rodados em uma cadeia de comandos com pipe. Isso irá modificar o dataframe que está sendo passado pelo pipe.\nNo exemplo abaixo, df1 está sendo pessado pelos pipes, df2 será juntado a ele e df1 então será modificado e redefinido.\n\ndf1 &lt;- df1 %&gt;%\n  filter(date_onset &lt; as.Date(\"2020-03-05\")) %&gt;% # miscellaneous cleaning\n  left_join(df2, by = c(\"ID\" = \"identifier\")) # join df2 to df1\n\nCUIDADO: Joins são caso-específicos (maiúsculas e minúsculas)! Então, é útil converter todos os valores para minúsculo ou maiúsculo antes de fazer o join. Veja a página sobre caracteres/strings.\n\n\n\nLeft joins e right joins\nUm left join ou right join é normalmente utilizado para adicionar informação a um dataframe - novas informações são adicionadas apenas a linhas que já existem no data frame base. Esses são tipos de joins comuns em trabalhos epidemiológicos pois eles são utilizados para adicionar informações de uma base de dado em outra.\nPara utilizar esses joins, a ordem em que os dataframes estão escritos nos comandos é importante*.\n\nEm um left join, o primeiro dataframe escrito é o de base\n\nEm um right join, o segundo dataframe escrito é o de base\n\nTodas as linhas do dataframe base são mantidas. As informações no outro dataframe (secundário) será juntada ao dataframe de base apenas se houver a combinação via as colunas dos identificadores. E ainda:\n\nLinhas no dataframe secundário que não combinam são removidas.\nSe houver muitas linhas no dataframe base que combinam com uma linha no secundário (muitos-para-um), a informação do secundário é adicionada a cada linha do base que combina.\n\nSe uma linha do base combina com múltiplas linhas no secundário (um-para-muitos), todas as combinações são dadas, o que significa que novas linhas podem ser adicionadas ao dataframe resultante!\n\nExemplos animados de left e right joins (fonte da imagem)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExemplo\nAbaixo está a saída de um left_join() do hosp_info (dataframe secundário, veja aqui) em linelist_mini (dataframe base, veja aqui). O linelist_mini tem nrow(linelist_mini) linhas. O linelist_mini modificado é mostrado. Note o seguinte:\n\nDuas novas colunas, catchment_pop e level foram adicionadas ao lado esquerdo da linelist_mini\n\nTodas as linhas originais do dataframe base linelist_mini são mantidas\nQuaisquer linhas originais do linelist_mini para “Military Hospital” foram duplicadas porque combinaram com duas linhas no dataframe secundário, então ambas as combinações são retornadas\nA coluna de identificador do join na base secundária (hosp_name) desapareceu pois está em redundância com a coluna de identificador da base primária (hospital)\n\nQuando a linha da base não combina com nenhuma linha da base secundária (ex: quando hospital é “Other” ou “Missing”), as colunas do dataframe secundário serão preenchidas com NA (em branco)\nLinhas no dataframe secundário sem nenhuma combinação no dataframe base (hospitais “sisters” e “ignace”) foram removidas\n\n\nlinelist_mini %&gt;%\n  left_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))\n\n\n\nWarning in left_join(., hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 5 of `x` matches multiple rows in `y`.\nℹ Row 4 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\n\n“Devo fazer um right join, ou um left join?”\nPara responder à pergunta acima, pergunte-se “qual dataframe deve manter todas as suas linhas?” - utilize esse como o base. Um left join manterá todas as linhas do primeiro dataframe escrito no comando, enquanto um right join manterá todas as linhas do segundo dataframe.\nOs dois comandos abaixo geram a mesma saída - um join de 10 linhas do hosp_info em linelist_mini (base), mas eles usam joins diferentes. O resultado é que a ordem das colunas vai diferir se hosp_info aparecer na direita (em um left join) ou na esquerda (em um right join). A ordem das linhas também pode mudar de posição da mesma forma. No entanto, ambas essas consequências podem ser resolvidas depois utilizando select() para reordenar as colunas, ou arrange() para ordenar (sort) as linhas.\n\n# Os dois comandos abaixo geram os memso dados, mas com linhas e colunas em ordem diferentes\nleft_join(linelist_mini, hosp_info, by = c(\"hospital\" = \"hosp_name\"))\nright_join(hosp_info, linelist_mini, by = c(\"hosp_name\" = \"hospital\"))\n\nAqui está o resultado do join de hosp_info em linelist_mini por meio de um left join (novas colunas vindas da direita)\n\n\nWarning in left_join(linelist_mini, hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 5 of `x` matches multiple rows in `y`.\nℹ Row 4 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\nAqui, o resultado do join de hosp_info em linelist_mini por meio de um right join (novas colunas vindas da esquerda)\n\n\nWarning in right_join(hosp_info, linelist_mini, by = c(hosp_name = \"hospital\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 4 of `x` matches multiple rows in `y`.\nℹ Row 5 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\nConsidere também se seu caso de uso está em meio a uma cadeia de comandos com pipe (%&gt;%). Se os dados passando através dos pipes for o dataframe base, você irá preferivelmente utilizar um left join para adicionar mais dados a ele.\n\n\n\n\nFull join\nUm full join é o mais inclusivo dos joins - ele retorna todas as linhas de ambos os dataframes.\nSe houver alguma linha presente em um mas não em outro (onde não foi encontrada nenhuma combinação entre os dados), o dataframe vai incluir essa linha e tornar-se mais longo. Os valores NA para representar valores ausentes serão utilizados para preencher os espaços vazios criados. À medida que você for executando o join, monitore cuidadosamente o número de colunas e linhas para resolver problemas de sensitividade de caso (maiúsculo/minúsculo) ou combinação exata de caracteres.\nO dataframe base será aquele escrito primeiro no comando. Mudar essa posição não vai impactar em quais registros serão retornados pelo join, mas pode impactar na ordem das colunas e linhas resultantes e também em quais colunas de identificadores serão mantidos.\n\n\n\n\n\n\n\n\n\nExemplo animado de um full join (fonte da imagem)\nExemplo\nAbaixo está uma saída de um full_join() do hosp_info (originalmente nrow(hosp_info), veja aqui) em linelist_mini (originalmente nrow(linelist_mini), veja aqui). Note o seguinte:\n\nTodas as linhas do dataframe base são mantidas (linelist_mini)\n\nLinhas no dataframe secundário que não combinam com o dataframe base são mantidas (“ignace” e “sisters”), com valores nas colunas correspondentes do base (case_id e onset) preenchidas com os valores ausentes NA\nDa mesma forma, linhas no dataframe base que não combinam com o secundário (“Other” e “Missing”) são mantidas, com as colunas catchment_pop e level do secundário preenchidas com NA\nNos casos das combinações um-para-muitos ou muitos-para-um (ex: linhas para “Military Hospital”), todas as combinações possíveis são retornadas (aumentando o tamanho do dataframe final)\n\nApenas a coluna do identificador do dataframe base foi mantida (hospital)\n\n\nlinelist_mini %&gt;%\n  full_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))\n\n\n\nWarning in full_join(., hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 5 of `x` matches multiple rows in `y`.\nℹ Row 4 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\n\n\n\nInner join\nUm inner join é o mais restritivo dos joins - ele retona apenas as linhas que combinam em ambos os dataframes. Isso significa que o número linhas no dataframe base pode, de fato, reduzir. Ajustes em relação a qual dataframe será o base (escrito primeiro na função) não irá impactar quais linhas serão retornadas, mas vai impactar na ordem das colunas e linhas, e quais colunas de identificadores serão mantidas.\n\n\n\n\n\n\n\n\n\nExemplo animado de um inner join (fonte da imagem)\nExemplo\nAbaixo está a saída de um inner_join() de linelist_mini (base) com hosp_info (secundário). Note o seguinte:\n\nAs linhas do dataframe base que não combinam com as do secundário são removidas (linhas onde hospital é “Missing” ou “Other”)\n\nDe forma análoga, linhas do secundário que não combinam com o base são removidas (linhas onde hosp_name é “sisters” ou “ignace”)\n\nApenas a coluna de identificador do base foi mantida (hospital)\n\n\nlinelist_mini %&gt;%\n  inner_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))\n\n\n\nWarning in inner_join(., hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 5 of `x` matches multiple rows in `y`.\nℹ Row 4 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\n\n\n\nSemi join\nUm semi join é “join filtro” que utiliza outra base de dados não para adicionar linhas ou colunas, mas para fazer uma filtragem.\nUm semi-join mantém todas as observações do dataframe base que combinam com algum valor do dataframe secundário (mas não adiciona novas colunas nem duplica nenhuma linha para o caso de múltiplas combinações). Leia mais sobre esses joins “filtros” aqui.\n\n\n\n\n\n\n\n\n\nExemplo de um semi join animado (fonte da imagem)\nComo um exemplo, o código abaixo retorna as linhas do dataframe hosp_info que tem combinações em linelist_mini baseados no nome do hospital.\n\nhosp_info %&gt;%\n  semi_join(linelist_mini, by = c(\"hosp_name\" = \"hospital\"))\n\n                             hosp_name catchment_pop     level\n1                    Military Hospital         40500 Secondary\n2                    Military Hospital         10000   Primary\n3                        Port Hospital         50280 Secondary\n4 St. Mark's Maternity Hospital (SMMH)         12000 Secondary\n\n\n\n\nAnti join\n\nO anti join é um outro tipo de “join filtro” que retorna linhas no dataframe base que não possuem uma combinação no dataframe secundário.\nLeia mais sobre esses joins “filtros” aqui.\nCenários comuns para anti-join incluem identificar registros que não estão presentes em outro data frame, checar erros de grafia em um join (revisão de registros que deveriam ter combinado) e examinar registros que foram excluídos depois de outro join.\nAssim como com right_join() e left_join(), o dataframe base (listado primeiro) é importante. As linhas retornadas serão apenas do dataframe base. Veja no gif abaixo qu e a linha no dataframe secundário (linha roxa 4) não é retornada mesmo que ela não tenha combinado com o base.\n\n\n\n\n\n\n\n\n\nExemplo animado de um anti join (fonte da imagem)\n\nUm exemplo simples de anti_join()\nPara um exemplo simples, vamos achar os hospitais de hosp_info que não possuem nenhum caso presente em linelist_mini. Nós listamos hosp_info primeiro, como o dataframe base. Os hospitais que não estão presentes em linelist_mini são retornados.\n\nhosp_info %&gt;%\n  anti_join(linelist_mini, by = c(\"hosp_name\" = \"hospital\"))\n\n\n\n\n\n\n\n\n\nExemplo complexo de anti_join()\nPara outro exemplo, vamos supor que rodamos um inner_join() entre linelist_mini e hosp_info. Será retornado apenas um subconjunto dos registros originais de linelist_mini, visto que alguns não estão presentes em hosp_info.\n\nlinelist_mini %&gt;%\n  inner_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))\n\n\n\nWarning in inner_join(., hosp_info, by = c(hospital = \"hosp_name\")): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 5 of `x` matches multiple rows in `y`.\nℹ Row 4 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\nPara revisar os registros de linelist_mini que foram excluídos no inner join, podemos rodar um anti-join com as mesmas configurações (linelist_mini como o dataframe base).\n\nlinelist_mini %&gt;%\n  anti_join(hosp_info, by = c(\"hospital\" = \"hosp_name\"))\n\n\n\n\n\n\n\nPara ver os registros de hosp_info que foram excluídos no inner join, também podemos rodar um anti-join com hosp_info como o dataframe base.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Juntando dados (Joins)</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.pt.html#combinação-probabilística",
    "href": "new_pages/joining_matching.pt.html#combinação-probabilística",
    "title": "14  Juntando dados (Joins)",
    "section": "14.3 Combinação probabilística",
    "text": "14.3 Combinação probabilística\nSe você não tiver um único identificador comum entre as bases de dados para fazer o join, considere utilizar um algoritmo de combinação probabilística. Ele acharia combinações entre os registros baseados em similaridade (ex: distância de strings de Jaro–Winkler, ou distância numérica). Abaixo temos um exemplo simples utilizando o pacote fastLink .\nCarregue o pacote\n\npacman::p_load(\n  tidyverse, # manipulação e visualização de dados\n  fastLink # combinação dos registros\n)\n\nAque estão duas pequenas bases de dados que nós iremos utilizar para demonstrar a combinação probabilística (cases e test_results):\nAqui está o código utilizado para construir as bases de dados:\n\n# cria as bases de dados\n\ncases &lt;- tribble(\n  ~gender, ~first, ~middle, ~last, ~yr, ~mon, ~day, ~district,\n  \"M\", \"Amir\", NA, \"Khan\", 1989, 11, 22, \"River\",\n  \"M\", \"Anthony\", \"B.\", \"Smith\", 1970, 09, 19, \"River\",\n  \"F\", \"Marialisa\", \"Contreras\", \"Rodrigues\", 1972, 04, 15, \"River\",\n  \"F\", \"Elizabeth\", \"Casteel\", \"Chase\", 1954, 03, 03, \"City\",\n  \"M\", \"Jose\", \"Sanchez\", \"Lopez\", 1996, 01, 06, \"City\",\n  \"F\", \"Cassidy\", \"Jones\", \"Davis\", 1980, 07, 20, \"City\",\n  \"M\", \"Michael\", \"Murphy\", \"O'Calaghan\", 1969, 04, 12, \"Rural\",\n  \"M\", \"Oliver\", \"Laurent\", \"De Bordow\", 1971, 02, 04, \"River\",\n  \"F\", \"Blessing\", NA, \"Adebayo\", 1955, 02, 14, \"Rural\"\n)\n\nresults &lt;- tribble(\n  ~gender, ~first, ~middle, ~last, ~yr, ~mon, ~day, ~district, ~result,\n  \"M\", \"Amir\", NA, \"Khan\", 1989, 11, 22, \"River\", \"positive\",\n  \"M\", \"Tony\", \"B\", \"Smith\", 1970, 09, 19, \"River\", \"positive\",\n  \"F\", \"Maria\", \"Contreras\", \"Rodriguez\", 1972, 04, 15, \"Cty\", \"negative\",\n  \"F\", \"Betty\", \"Castel\", \"Chase\", 1954, 03, 30, \"City\", \"positive\",\n  \"F\", \"Andrea\", NA, \"Kumaraswamy\", 2001, 01, 05, \"Rural\", \"positive\",\n  \"F\", \"Caroline\", NA, \"Wang\", 1988, 12, 11, \"Rural\", \"negative\",\n  \"F\", \"Trang\", NA, \"Nguyen\", 1981, 06, 10, \"Rural\", \"positive\",\n  \"M\", \"Olivier\", \"Laurent\", \"De Bordeaux\", NA, NA, NA, \"River\", \"positive\",\n  \"M\", \"Mike\", \"Murphy\", \"O'Callaghan\", 1969, 04, 12, \"Rural\", \"negative\",\n  \"F\", \"Cassidy\", \"Jones\", \"Davis\", 1980, 07, 02, \"City\", \"positive\",\n  \"M\", \"Mohammad\", NA, \"Ali\", 1942, 01, 17, \"City\", \"negative\",\n  NA, \"Jose\", \"Sanchez\", \"Lopez\", 1995, 01, 06, \"City\", \"negative\",\n  \"M\", \"Abubakar\", NA, \"Abullahi\", 1960, 01, 01, \"River\", \"positive\",\n  \"F\", \"Maria\", \"Salinas\", \"Contreras\", 1955, 03, 03, \"River\", \"positive\"\n)\n\nA base de dados cases possui 9 registros de pacientes que estão esperando para testar resultados.\n\n\n\n\n\n\nA base de dados test_results possui 14 registros e contém a coluna result, que nós queremos adicionar aos registros cases baseados nas combinações probabilísticas dos registros.\n\n\n\n\n\n\n\nCombinação Probabilística (probabilistic matching)\nA função fastlink() do pacote fastlink pode ser utilizada para aplicar um algoritmo que busca as combinações entre os valores. Aqui estão as informações básicas. Você pode ler mais detalhes digitando ?fastlink no seu console.\n\nDefina os dois dataframes que serão comparados nos argumentos dfA = e dfB =\n\nEm varnames = defina todos os nomes de colunas que serão utilizadas para testar a combinação. Todas devem existir tanto em dfA quanto em dfB.\n\nEm stringdist.match = defina o nome das colunas que estão em varnames que serão avaliadas pela “distancia” entre strings.\n\nEm numeric.match = defina o nome das colunas que estão em varnames que serão avaliadas pela distância numérica.\n\nValores ausentes serão ignorados\nPor padrão, cada linha em qualquer dos dataframes será combinada com no máximo uma linha do outro dataframe. Se você quiser ver todas as combinações que foram avaliadas defina o parâmetro dedupe.matches = FALSE. A deduplicação é feita utilizando a solução de Winkler para atribuição linear.\n\nDica: divida uma coluna única de data em 3 colunas numéricas separadas utilizadando day(), month(), e year() do pacote lubridate\nO limiar padrão para as combinações é 0.94 (threshold.match =) mas você pode ajustar para maior ou menor. Se você for ajustar manualmente o limiar, considere que com limiares mais altos você pode gerar mais falsos negativos (linhas que não combinam quando na verdade deveriam combinar) e, da mesma forma, um limiar mais baixo pode gerar falsos positivos.\nAbaixo, os dados estão sendo combinados pela distância de strings nas colunas de nome e distrito, e na distância numérica para ano, mês e dia do nascimento. Um limiar para combinação de 95% de probabilidade foi configurado.\n\nfl_output &lt;- fastLink::fastLink(\n  dfA = cases,\n  dfB = results,\n  varnames = c(\"gender\", \"first\", \"middle\", \"last\", \"yr\", \"mon\", \"day\", \"district\"),\n  stringdist.match = c(\"first\", \"middle\", \"last\", \"district\"),\n  numeric.match = c(\"yr\", \"mon\", \"day\"),\n  threshold.match = 0.95\n)\n\n\n==================== \nfastLink(): Fast Probabilistic Record Linkage\n==================== \n\nIf you set return.all to FALSE, you will not be able to calculate a confusion table as a summary statistic.\nCalculating matches for each variable.\nGetting counts for parameter estimation.\n    Parallelizing calculation using OpenMP. 1 threads out of 8 are used.\nRunning the EM algorithm.\nGetting the indices of estimated matches.\n    Parallelizing calculation using OpenMP. 1 threads out of 8 are used.\nDeduping the estimated matches.\nGetting the match patterns for each estimated match.\n\n\nRevisando as combinações\nNós definimos o objeto retornado da função fastLink() como fl_output. Ele é da classe list, e de fato contém vários dataframes internamente que detalham os resultados da combinação. Um desses dataframes é matches, que vai conter as combinações mais prováveis entre cases e results. Você pode acessar esse dataframe de combinações com fl_output$matches. Abaixo, ele está sendo salvo como my_matches para facilitar o acesso depois.\nQuando my_matches é impresso no console, você vê duas colunas de vetores: os pares de número de linhas/índices (também chamados “rownames”) em cases (“inds.a”) e em results (“inds.b”) representando as melhores combinações. Se o número da linha de um dataframe estiver ausente, então nenhuma combinação foi achada no outro dataframe no limiar de combinação especificado.\n\n# print matches\nmy_matches &lt;- fl_output$matches\nmy_matches\n\n  inds.a inds.b\n1      1      1\n2      2      2\n3      3      3\n4      4      4\n5      8      8\n6      7      9\n7      6     10\n8      5     12\n\n\nAlgumas coisas para se ter em mente:\n\nAs combinações ocorrem apesar de algumas diferenças sutis na grafia dos nomes ou nas datas de nascimento:\n\n“Tony B. Smith” combinou com “Anthony B Smith”\n\n“Maria Rodriguez” combinou com “Marialisa Rodrigues”\n\n“Betty Chase” combinou com “Elizabeth Chase”\n\n“Olivier Laurent De Bordeaux” combinou com “Oliver Laurent De Bordow” (data de nascimneto ausente foi ignorada)\n\n\nUma linha de cases (para “Blessing Adebayo”, linha 9) não teve nenhuma boa combinação em results, por isso não está prente em my_matches.\n\nJoin baseado em combinações probabilísticas\nPara utilizar essas combinações para fazer um join de results e cases, uma estratégia seria:\n\nUtilizar left_join() para fazer o join de my_matches em cases (combinando os nomes das colunas em cases com “inds.a” em my_matches)\n\nDepois, utilizar outro left_join() para fazer o join de results em cases (combinando o recém adquirido “inds.b” em cases com os nomes das linhas em results)\n\nAntes dos joins, devemos limpar os três dataframes:\n\nAmbos dfA e dfB devem ter seus números de linhas (“rowname”) convertidos para uma coluna propriamente dita.\n\nAmbas as colunas de my_matches devem ser convertidas para a classe character, para que o join possa ser feito com os nomes de coluna que são caracteres\n\n\n# Limpeza dos dados antes do join\n#############################\n\n# converte os nomes das linhas de cases em coluna\ncases_clean &lt;- cases %&gt;% rownames_to_column()\n\n# converte os nomes das linhas de test_results em coluna\nresults_clean &lt;- results %&gt;% rownames_to_column()\n\n# converte todas as colunas no dataframe de combinações (my_matches) para character, para que o join possa ser feito com os nomes das linhas\nmatches_clean &lt;- my_matches %&gt;%\n  mutate(across(everything(), as.character))\n\n\n\n# Faça o join das combinações com dfA, e depois adicione dfB\n###################################\n# a coluna \"inds.b\" é adicionada ao dfA\ncomplete &lt;- left_join(cases_clean, matches_clean, by = c(\"rowname\" = \"inds.a\"))\n\n# colunas do dfB são adicionadas\ncomplete &lt;- left_join(complete, results_clean, by = c(\"inds.b\" = \"rowname\"))\n\nComo feito no código acima, o dataframe complete, resultado dos joins, vai conter todas as colunas de cases e results. Muitas delas estarão com sufixos “.x” e “.y”, por que, caso contrário, o nome das colunas seriam duplicados.\n\n\n\n\n\n\nComo opção, para ter apenas os 9 registros “originais” em cases com as novaas colunas de results, utilize select() em results antes dos joins, de forma que ela contenha apenas os nomes de linhas e colunas que você queira adicionar a cases (ex: a coluna result).\n\ncases_clean &lt;- cases %&gt;% rownames_to_column()\n\nresults_clean &lt;- results %&gt;%\n  rownames_to_column() %&gt;%\n  select(rowname, result) # selecion apenas algumas colunas\n\nmatches_clean &lt;- my_matches %&gt;%\n  mutate(across(everything(), as.character))\n\n# joins\ncomplete &lt;- left_join(cases_clean, matches_clean, by = c(\"rowname\" = \"inds.a\"))\ncomplete &lt;- left_join(complete, results_clean, by = c(\"inds.b\" = \"rowname\"))\n\n\n\n\n\n\n\nSe você quiser um subconjunto de qualquer um dos dataframes contendo apenas as linhas que combinaram, você pode utilizar o código abaixo:\n\ncases_matched &lt;- cases[my_matches$inds.a, ] # Linhas em cases que combinaram com uma linha em results\nresults_matched &lt;- results[my_matches$inds.b, ] # Linhas em results que combinaram com uma linha em cases\n\nOu, para ver apenas as linhas que não combinaram:\n\ncases_not_matched &lt;- cases[!rownames(cases) %in% my_matches$inds.a, ] # Linhas em cases que NÃO combinaram com uma linha em results\nresults_not_matched &lt;- results[!rownames(results) %in% my_matches$inds.b, ] # Linhas em results que NÃO combinaram com uma linha em cases\n\n\n\nRemoção de duplicidades probabilística\nA combinação probabilística também pode ser utilizada para remover duplicidades uma base de dados. Veja a página de remoção de duplicidades para outros métodos de deduplicação.\nAqui, vamos começar com a base cases, mas a partir daqui chamaremos ela de cases_dup, pois ela tem 2 linhas adicionais que podem ser duplicidades de linhas anteriores: Veja “Tony” com “Anthony”, e “Marialisa Rodrigues” com “Maria Rodriguez”.\n\n\n\n\n\n\nExecute fastLink() como anteriormente, mas compare o dataframe cases_dup com ele mesmo. Quando os dois dataframes passados para a função são idênticos, ela assume que você quer fazer a remoção de duplicidades. Note que nós não especificamos stringdist.match = ou numeric.match = como havíamos feito anteriormente.\n\n## Execute fastLink na mesma base de dados\ndedupe_output &lt;- fastLink(\n  dfA = cases_dup,\n  dfB = cases_dup,\n  varnames = c(\"gender\", \"first\", \"middle\", \"last\", \"yr\", \"mon\", \"day\", \"district\")\n)\n\n\n==================== \nfastLink(): Fast Probabilistic Record Linkage\n==================== \n\nIf you set return.all to FALSE, you will not be able to calculate a confusion table as a summary statistic.\ndfA and dfB are identical, assuming deduplication of a single data set.\nSetting return.all to FALSE.\n\nCalculating matches for each variable.\nGetting counts for parameter estimation.\n    Parallelizing calculation using OpenMP. 1 threads out of 8 are used.\nRunning the EM algorithm.\nGetting the indices of estimated matches.\n    Parallelizing calculation using OpenMP. 1 threads out of 8 are used.\nCalculating the posterior for each pair of matched observations.\nGetting the match patterns for each estimated match.\n\n\nAgora, você pode revisar as duplicidades em potencial com getMatches(). Passe o dataframe tanto como dfA = como dfB =, e passa a saída da função fastLink() como fl.out =. fl.out deve ser da classe fastLink.dedupe, ou em outras palavras, o resultado de fastLink().\n\n## Execute getMatches()\ncases_dedupe &lt;- getMatches(\n  dfA = cases_dup,\n  dfB = cases_dup,\n  fl.out = dedupe_output\n)\n\nVeja a coluna da extrema direita, que indica os IDs das duplicatas - as duas últimas linhas estão identificadas como sendo potenciais duplicatadas das linhas 2 e 3.\n\n\n\n\n\n\nPara retornar o número de linhas que são potenciais duplicidades, você pode contar o número de linhas por valores únicos na coluna dedupe.ids, e aí filtrar para manter apenas aquelas com mais de uma linha. Nesse caso, isso deixaria as linhas 2 e 3.\n\ncases_dedupe %&gt;%\n  count(dedupe.ids) %&gt;%\n  filter(n &gt; 1)\n\n  dedupe.ids n\n1          2 2\n2          3 2\n\n\nPara investigar a totalidade das linhas que poderiam ser duplicidades, coloque o número da linha nesse comando:\n\n# mostra a linha 2 e todas as possíveis duplicidades dela\ncases_dedupe[cases_dedupe$dedupe.ids == 2, ]\n\n   gender   first middle  last   yr mon day district dedupe.ids\n2       M Anthony     B. Smith 1970   9  19    River          2\n10      M    Tony     B. Smith 1970   9  19    River          2",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Juntando dados (Joins)</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.pt.html#anexando-binding-e-alinhando",
    "href": "new_pages/joining_matching.pt.html#anexando-binding-e-alinhando",
    "title": "14  Juntando dados (Joins)",
    "section": "14.4 Anexando (binding) e alinhando",
    "text": "14.4 Anexando (binding) e alinhando\nUm outro método de combinar dois dataframes é anexando (“binding”) um ao outro. Você também pode pensar nisso como incluir (“appending”) ou adicionar (“adding”) linhas ou colunas.\nEssa seção também vai discutir como “alinhar” a ordem das linhas de um dataframe à ordem de outro dataframe. Esse tópico é discutido abaixo na seção de Anexar colunas.\n\nAnexar linhas (bind rows)\nPara anexar linhas de um dataframe no final de outro dataframe, utilize a função bind_rows() do pacote dplyr. Essa é uma função bastante inclusiva, então, todas as colunas presentes em cada dataframe será incluída na saída. Algumas notas:\n\nDiferente da versão row.bind() do R base, bind_rows() do dplyr não exige que a ordem das colunas seja a mesma em ambos os dataframes. Contanto que os nomes das colunas estejam grafados de forma idêntica, a função vai alinhá-las corretamente.\n\nVocê poder, opcionalmente, especificar o argumento .id =. Passe um nome de coluna para o argumento. Isso vai produzir uma nova coluna que serve para identificar de qual dataframe cada linha veio originalmente.\nVocê pode usar bind_rows() em uma lista de dataframes que tenham estrutura semelhante para combiná-los em um só. Veja um exemplo na página Iteração, loops e listas que envolve a importação de múltimplas linelists com purrr.\n\nUm exemplo comum de anexação de linhas é anexar uma linha de “total” no final de uma tabela descritiva feita utilizando a função summarise() do dplyr. Abaixo nós criamos uma tabela de contagem de casos e medianas dos valores de CT por hospital com uma linha total.\nA função summarise() é utilizada em dados agrupados por hospital para retornar um dataframe sumárizado por hospital. Porém, a função summarise() não gera colunas de “totais” automaticamente, então, nós criamos uma sumarizando os dados novamente, mas com os dados não agrupados por hospital. Isso produz um segundo dataframe de apenas uma linha. Nós podemos anexar (bind) esses dataframes um ao outro para chegar na tabela final.\nVeja outros exemplos práticos como esse nas páginas Tabelas descritivas e Tabelas para apresentação.\n\n# Cria a tabela principal\n###################\nhosp_summary &lt;- linelist %&gt;%\n  group_by(hospital) %&gt;% # Agrupa os dados por hospital\n  summarise( # Cria colunas sumário dos indicadores de interesse\n    cases = n(), # Número de linhas por grupo hospital-desfecho\n    ct_value_med = median(ct_blood, na.rm = T)\n  ) # valores medianos de CT por grupo\n\nAqui está o dataframe hosp_summary:\n\n\n\n\n\n\nCria um dataframe com as estatísticas de “total” (sem o agrupamento por hospital). Isso vai retornar apenas uma linha.\n\n# cria totais\n###############\ntotals &lt;- linelist %&gt;%\n  summarise(\n    cases = n(), # Número de linhas da base de dados inteira\n    ct_value_med = median(ct_blood, na.rm = T)\n  ) # CT Mediano para toda a base de dados\n\nE abaixo está o dataframe totals. Note como tem apenas duas colunas. Essas colunas também está em hosp_summary, mas tem uma coluna em hosp_summary que não está em totals (hospital).\n\n\n\n\n\n\nAgora podemos anexar as linhas com bind_rows().\n\n# Bind data frames together\ncombined &lt;- bind_rows(hosp_summary, totals)\n\nAgora podemos visualizar o resultado. Veja como na última linha, um valor vazio, NA, preenche a coluna hospital que não estava em hosp_summary. Como explicado na página Tabelas para apresentação, você pode preencher essa célula com “Total” utilizando replace_na().\n\n\n\n\n\n\n\n\nAnexar colunas\nExiste uma função similar no dplyr, a bind_cols() que você pode utilizar para combinar dois dataframes “lateralmente”. Note que as linhas são combinadas umas com as outras por posição (não como no join acima) - por exemplo, a 12ª linha de cada dataframe estarão alinhadas.\nPara demonstrar, vamos anexar várias tabelas de sumário juntas. Para fazer isso, também demonstraremos como rearranjar a ordem das linhas de um dataframe para combinar com a ordem do outro, com match().\nAqui nós definimos case_info como um dataframe de sumário dos casos da linelist, por hospital, com o número de casos e o número de mortes.\n\n# Informação dos casos\ncase_info &lt;- linelist %&gt;%\n  group_by(hospital) %&gt;%\n  summarise(\n    cases = n(),\n    deaths = sum(outcome == \"Death\", na.rm = T)\n  )\n\n\n\n\n\n\n\nEntão, digamos que haja um dataframe diferente, contact_fu (fu -&gt; follow up), contendo informação acerca da porcentagem de contatos expostos que foram investigados e “acompanhados” (follow-up), novamente por hospital.\n\ncontact_fu &lt;- data.frame(\n  hospital = c(\"St. Mark's Maternity Hospital (SMMH)\", \"Military Hospital\", \"Missing\", \"Central Hospital\", \"Port Hospital\", \"Other\"),\n  investigated = c(\"80%\", \"82%\", NA, \"78%\", \"64%\", \"55%\"),\n  per_fu = c(\"60%\", \"25%\", NA, \"20%\", \"75%\", \"80%\") # fu -&gt; follow up\n)\n\n\n\n\n\n\n\nNote que os hospitais são os mesmos, mas estão em ordens diferentes em cada dataframe. A solução mais fácil seria utilizar left_join() na coluna hospital, mas você poderia também utilizar bind_cols() com um passo extra.\n\nUtilize match() para alinhar a ordem\nPelo fato da ordem das linhas ser diferente, um simples bind_cols() resultaria em um desalinhamento dos dados. Para consertar isso, podemos utilizar match() do base R para alinhar as linhas de um dataframe na mesma ordem de outro. Vamos assumir, para essa abordagem, que não há valores duplicados em nenhum dos dataframes.\nQuando utilizamos match(), a sintaxe é match(ORDEM DO VETOR ALVO, COLUNA PARA MUDAR), onde o primeiro argumento é a ordem desejada (seja um vetor individual, ou nesse caso, uma coluna do dataframe), e o segundo argumento é uma coluna do dataframe que será reordenado. A saída do match() é um vetor de números representando a posição correta do ordenamento. Você pode ler mais com ?match.\n\nmatch(case_info$hospital, contact_fu$hospital)\n\n[1] NA  4  2  6  5  1\n\n\nVocê pode utilizar esse vetor numérico para reordenar o dataframe - coloque ele entre colchetes [ ] antes da vírgula. Leia mais sobre a sintaxe de subconjuntos com colchetes no base R na página Introdução ao R. O comando abaixo cria um novo dataframe, definido como o anterior em que as linhas estão ordenadas de acordo com o vetor numérico acima.\n\ncontact_fu_aligned &lt;- contact_fu[match(case_info$hospital, contact_fu$hospital), ]\n\n\n\n\n\n\n\nAgora podemos anexar as colunas dos dataframes um no outro, com a ordem de linhas correta. Note que algumas colunas estão duplicadas e vão precisar de uma limpeza utilizando rename(). Leia mais sobre bind_rows() aqui.\n\nbind_cols(case_info, contact_fu)\n\nNew names:\n• `hospital` -&gt; `hospital...1`\n• `hospital` -&gt; `hospital...4`\n\n\n# A tibble: 6 × 6\n  hospital...1                     cases deaths hospital...4 investigated per_fu\n  &lt;chr&gt;                            &lt;int&gt;  &lt;int&gt; &lt;chr&gt;        &lt;chr&gt;        &lt;chr&gt; \n1 Ausente                           1469    611 St. Mark's … 80%          60%   \n2 Central Hospital                   454    193 Military Ho… 82%          25%   \n3 Military Hospital                  896    399 Missing      &lt;NA&gt;         &lt;NA&gt;  \n4 Other                              885    395 Central Hos… 78%          20%   \n5 Port Hospital                     1762    785 Port Hospit… 64%          75%   \n6 St. Mark's Maternity Hospital (…   422    199 Other        55%          80%   \n\n\nUma alternativo do R base a bind_cols é a função cbind(), que faz a mesma operação.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Juntando dados (Joins)</span>"
    ]
  },
  {
    "objectID": "new_pages/joining_matching.pt.html#recursos",
    "href": "new_pages/joining_matching.pt.html#recursos",
    "title": "14  Juntando dados (Joins)",
    "section": "14.5 Recursos",
    "text": "14.5 Recursos\nA página do tidyverse sobre joins\nA página do R for Data Science sobre dados relacionais\nA página do tidyverse no dplyr sobre binding (ligação)\nUma vignette sobre fastLink na página do Github do pacote\nPublicação descrevendo a metodologia do fastLink\nPublicação descrevendo o pacote RecordLinkage",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Juntando dados (Joins)</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.pt.html",
    "href": "new_pages/deduplication.pt.html",
    "title": "15  Eliminação de duplicidades",
    "section": "",
    "text": "15.1 Preparação",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Eliminação de duplicidades</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.pt.html#preparação",
    "href": "new_pages/deduplication.pt.html#preparação",
    "title": "15  Eliminação de duplicidades",
    "section": "",
    "text": "Carregar pacotes\nEste pedaço de código mostra o carregamento de pacotes necessários para as análises. Neste manual, enfatizamos p_load() de pacman, que instala o pacote se necessário e o carrega para uso. Você também pode carregar pacotes instalados com library() do R base. Veja a página em Introdução ao R para mais informações sobre pacotes R.\n\npacman :: p_load(\n  tidyverse, # deduplicação, agrupamento e funções de fatiamento\n  janitor, # função para revisar duplicidades\n  stringr) # para pesquisas de strings, pode ser usado em valores \"rolling-up\"\n\n\n\nImportar dados\nPara demonstração, usaremos um conjunto de dados de exemplo criado com o código R abaixo.\nOs dados são registros de encontros telefônicos COVID-19, incluindo encontros com contatos e casos. As colunas incluem recordID (gerado por computador), personID, name, date do encontro, time do encontro, o propósito do encontro (para entrevistar como um caso ou como um contato ), e symptoms_ever (se a pessoa nesse encontro relatou sempre ter sintomas).\nAqui está o código para criar o conjunto de dados obs:\n\nobs &lt;- data.frame(\n  recordID = c(1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18),\n  personID  = c(1,1,2,2,3,2,4,5,6,7,2,1,3,3,4,5,5,7,8),\n  name = c(\"adam\", \"adam\", \"amrish\", \"amrish\", \"mariah\", \"amrish\", \"nikhil\", \"brian\", \"smita\", \"raquel\", \"amrish\",\n                \"adam\", \"mariah\", \"mariah\", \"nikhil\", \"brian\", \"brian\", \"raquel\", \"natalie\"),\n  date = c(\"01/01/2020\", \"01/01/2020\", \"01/02/2020\", \"01/02/2020\", \"01/05/2020\", \"01/05/2020 \", \"01/05/2020\", \"01/05/2020\", \"01/05/2020\", \"01/05/2020\", \"01/02/2020\",\n                \"5/1/2020\", \"6/1/2020\", \"6/1/2020\", \"6/1/2020\", \"6/1/2020\", \"7/1/2020\", \"7/1/2020\", \"7/1/2020\"),\n  time = c(\"09:00\", \"09:00\", \"14:20\", \"14:20\", \"12:00\", \"16:10\", \"13:01\", \"15:20 \", \"14:20\", \"12:30\", \"10:24\",\n                \"09:40\", \"07:25\", \"08:32\", \"15:36\", \"15:31\", \"07:59\", \"11:13\", \"17:12\"),\n  encounter = c(1,1,1,1,1,3,1,1,1,1,2,\n                2,2,3,2,2,3,2,1),\n  purpose   = c(\"contact\", \"contact\", \"contact\", \"contact\", \"case\", \"case\", \"contact\", \"contact\", \"contact\", \"contact\", \"contact\",\n                \"case\", \"contact\", \"contact\", \"contact\", \"contact\", \"case\", \"contact\", \"case\"),\n  symptoms_ever = c(NA, NA, \"No\", \"No\", \"No\", \"Yes\", \"Yes\", \"No\", \"Yes\", NA, \"Yes\",\n                    \"No\", \"No\", \"No\", \"Yes\", \"Yes\", \"No\",\"No\", \"No\")) %&gt;%\n  mutate(date = as.Date(date, format = \"%d/%m/%Y\"))\n\n\nAqui está o data frame\nUse as caixas de filtro na parte superior para revisar os encontros de cada pessoa.\n\n\n\n\n\n\nAlgumas coisas a serem observadas ao revisar os dados:\n\nOs dois primeiros registros são duplicados 100% completos, incluindo recordID duplicado (deve ser uma falha do computador!)\n\nAs duas segundas linhas são duplicidades, em todas as colunas exceto para recordID\n\nVárias pessoas tiveram vários encontros por telefone, em várias datas e horários, e como contatos e/ou casos\n\nEm cada encontro, a pessoa foi perguntada se ela alguma vez teve sintomas, e algumas dessas informações estão faltando.\n\nE aqui está um resumo rápido das pessoas e os propósitos de seus encontros, usando tabyl() do janitor:\n\nobs %&gt;% \n  tabyl(name, purpose)\n\n    name case contact\n    adam    1       2\n  amrish    1       3\n   brian    1       2\n  mariah    1       2\n natalie    1       0\n  nikhil    0       2\n  raquel    0       2\n   smita    0       1",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Eliminação de duplicidades</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.pt.html#remoção-de-duplicidades",
    "href": "new_pages/deduplication.pt.html#remoção-de-duplicidades",
    "title": "15  Eliminação de duplicidades",
    "section": "15.2 Remoção de duplicidades",
    "text": "15.2 Remoção de duplicidades\nEsta seção descreve como revisar e remover duplicidades em um data frame. Também mostra como lidar com elementos duplicados em um vetor.\n\n\nExaminar duplicidades\nPara revisar rapidamente as linhas que têm duplicidades, você pode usar get_dupes() do pacote janitor. Por padrão, todas as colunas são consideradas quando as duplicidades são avaliadas - as linhas retornadas pela função são 100% duplicadas considerando os valores em todas as colunas.\nNo data frame obs, as duas primeiras linhas são 100% duplicadas - elas têm o mesmo valor em todas as colunas (incluindo a coluna recordID, que supõe ser única - deve ser alguma falha do computador ). O data frame retornado inclui automaticamente uma nova coluna dupe_count no lado direito, mostrando o número de linhas com essa combinação de valores duplicados.\n\n# 100% duplicados em todas as colunas\nobs %&gt;% \n  janitor::get_dupes()\n\n\n\n\n\n\n\nVeja os dados originais\nNo entanto, se optarmos por ignorar recordID, as linhas da 3ª e 4ª linhas também serão duplicadas umas das outras. Ou seja, eles têm os mesmos valores em todas as colunas exceto para recordID. Você pode especificar colunas específicas a serem ignoradas na função usando um símbolo de menos -.\n\n# Duplica quando a coluna recordID não é considerada\nobs %&gt;% \n  janitor::get_dupes(-recordID) # se várias colunas, envolva-as em c()\n\n\n\n\n\n\n\nVocê também pode especificar positivamente as colunas a serem consideradas. Abaixo, apenas as linhas que possuem os mesmos valores nas colunas name e purpose são retornadas. Observe como “amrish” agora tem dupe_count igual a 3 para refletir seus três encontros de “contato”.\nRole para a esquerda para mais linhas\n\n# duplicatas com base nas colunas de nome e propósito SOMENTE\nobs %&gt;% \n  janitor::get_dupes(name, purpose)\n\n\n\n\n\n\n\nVeja os dados originais.\nVeja ?get_dupes para mais detalhes, ou veja esta referência online\n\n\n\nManter apenas linhas únicas\nPara manter apenas linhas exclusivas de um data frame, use distinct() de dplyr (conforme demonstrado na página Limpeza de dados e funções principais). As duplicidades são removidas de forma que apenas a primeira dessas linhas seja mantida. Por padrão, “primeiro” significa o maior número da linha (ordem das linhas de cima para baixo). Apenas linhas exclusivas permanecem.\nNo exemplo abaixo, executamos distinct() de forma que a coluna recordID seja excluída da consideração - portanto, duas linhas duplicadas são removidas. A primeira linha (para “adam”) foi 100% duplicada e foi removida. Além disso, a linha 3 (para “amrish”) era uma duplicata em todas as colunas exceto recordID (que não está sendo considerada) e, portanto, também foi removida. O conjunto de dados obs n agora é nrow(obs)-2, não nrow(obs) linhas).\nRole para a esquerda para ver todo o data frame\n\n# adicionado a uma cadeia de pipes (por exemplo, limpeza de dados)\nobs %&gt;% \n  distinct(across(-recordID), # reduz o data frame para apenas linhas únicas (mantém a primeira de todas as duplicidades)\n           .keep_all = TRUE)\n\n# se fora de pipes, inclua os dados como primeiro argumento \n# distinct(obs)\n\n\n\n\n\n\n\nCUIDADO: Se estiver usando distinct() em dados agrupados, a função será aplicada a cada grupo.\nRemover duplicidades com base em colunas específicas\nVocê também pode especificar colunas para serem a base para eliminação de duplicação. Dessa forma, a eliminação de duplicidades se aplica apenas a linhas duplicadas nas colunas especificadas. A menos que você defina .keep_all = TRUE, todas as colunas não mencionadas serão descartadas.\nNo exemplo abaixo, a eliminação de duplicidades se aplica apenas a linhas com valores idênticos para as colunas name e purpose. Assim, “brian” tem apenas 2 linhas em vez de 3 - seu primeiro encontro de “contato” e seu único encontro de “caso”. Para ajustar para que o último encontro de brian de cada propósito seja mantido, veja a aba Fatiar dentro de grupos.\nRole para a esquerda para ver todo o data frame\n\n# adicionado a uma cadeia de pipes (por exemplo, limpeza de dados)\nobs %&gt;% \n  distinct(name, purpose, .keep_all = TRUE) %&gt;% # mantém as linhas únicas por nome e propósito, mantém todas as colunas\n  arrange(name)       # organize para facilitar a visualização\n\n\n\n\n\n\n\nVeja os dados originais.\n\n\n\nRemover duplicidades em um vetor\nA função duplicated() do R base avaliará um vetor (coluna) e retornará um vetor lógico de mesmo comprimento (VERDADEIRO/FALSO). Na primeira vez que um valor aparecer, ele retornará FALSE (não uma duplicata) e, nas próximas vezes em que esse valor aparecer, ele retornará TRUE. Observe como NA é tratado da mesma forma que qualquer outro valor.\n\nx &lt;- c(1, 1, 2, NA, NA, 4, 5, 4, 4, 1, 2)\nduplicated(x)\n\n [1] FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n\n\nPara retornar apenas os elementos duplicados, você pode usar colchetes para subconjunto do vetor original:\n\nx[duplicated(x)]\n\n[1]  1 NA  4  4  1  2\n\n\nPara retornar apenas os elementos exclusivos, use a função unique() do R base. Para remover NAs da saída, aninhe na.omit() dentro de unique().\n\nunique(x) # alternativamente, use x[!duplicated(x)]\n\n[1]  1  2 NA  4  5\n\nunique(na.omit(x)) # remove NAs \n\n[1] 1 2 4 5\n\n\n\n\n\nUsando o R base\nPara retornar linhas duplicadas\nNo R base, você também pode ver quais linhas são 100% duplicadas em um data frame df com o comando duplicated(df) (retorna um vetor lógico das linhas).\nAssim, você também pode usar o subconjunto base [ ] no data frame para ver as linhas duplicadas com df[duplicated(df),] (não esqueça a vírgula, significando que você quer ver todas colunas!).\nPara retornar linhas exclusivas\nVeja as notas acima. Para ver as linhas únicas, você adiciona o negador lógico ! na frente da função duplicated():\ndf[!duplicado(df),]\nPara retornar linhas que são duplicidades em determinadas colunas\nSubsete o df que está dentro dos parênteses duplicated(), então esta função irá operar apenas em certas colunas do df.\nPara especificar as colunas, forneça os números ou nomes das colunas após uma vírgula (lembre-se, tudo isso está dentro da função duplicated()).\nCertifique-se de manter a vírgula , fora após a função duplicated() também!\nPor exemplo, para avaliar apenas as colunas de 2 a 5 para duplicatas: df[!duplicated(df[, 2:5]),]\nPara avaliar apenas as colunas name e purpose para duplicatas: df[!duplicated(df[, c(\"name\", \"purpose)]),]",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Eliminação de duplicidades</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.pt.html#fatiarsubdividir",
    "href": "new_pages/deduplication.pt.html#fatiarsubdividir",
    "title": "15  Eliminação de duplicidades",
    "section": "15.3 Fatiar/Subdividir",
    "text": "15.3 Fatiar/Subdividir\nSubdividir um data frame, ou “fatiá-lo” (literalmente do inglês slice), significa aplicar um filtro nas linhas por número/posição de linha. Isso se torna particularmente útil se você tiver várias linhas por grupo funcional (por exemplo, por “pessoa”) e quiser manter apenas uma ou algumas delas.\nA função básica slice() aceita números e retorna linhas nessas posições. Se os números fornecidos forem positivos, somente eles serão retornados. Se negativo, essas linhas não são retornadas. Os números devem ser todos positivos ou todos negativos.\n\nobs %&gt;% slice(4) # retorna a 4ª linha\n\n  recordID personID   name       date  time encounter purpose symptoms_ever\n1        3        2 amrish 2020-02-01 14:20         1 contact            No\n\n\n\nobs %&gt;% slice(c(2,4)) # retorna as linhas 2 e 4\n\n  recordID personID   name       date  time encounter purpose symptoms_ever\n1        1        1   adam 2020-01-01 09:00         1 contact          &lt;NA&gt;\n2        3        2 amrish 2020-02-01 14:20         1 contact            No\n\n#obs %&gt;% slice(c(2:4)) # retorna as linhas 2 a 4\n\nVeja os dados originais.\nExistem várias variações: Estes devem ser fornecidos com uma coluna e um número de linhas para retornar (para n =).\n\nslice_min() e slice_max() mantêm apenas a(s) linha(s) com o(s) valor(es) mínimo(s) ou máximo(s) da coluna especificada. Isso também funciona para retornar o “min” e o “max” dos fatores ordenados.\n\nslice_head() e slice_tail() - mantém apenas a primeira ou última linha(s).\n\nslice_sample() - mantém apenas uma amostra aleatória das linhas.\n\n\nobs %&gt;% slice_max(encounter, n = 1) # retorna linhas com o maior número de encontro\n\n  recordID personID   name       date  time encounter purpose symptoms_ever\n1        5        2 amrish 2020-05-01 16:10         3    case           Yes\n2       13        3 mariah 2020-01-06 08:32         3 contact            No\n3       16        5  brian 2020-01-07 07:59         3    case            No\n\n\nUse argumentos n = ou prop = para especificar o número ou a proporção de linhas a serem mantidas. Se não estiver usando a função em uma cadeia de pipes, forneça primeiro o argumento de dados (por exemplo, slice(data, n = 2)). Veja ?slice para mais informações.\nOutros argumentos:\n.order_by = usado em slice_min() e slice_max() esta é uma coluna para ordenar antes de fatiar.\nwith_ties = TRUE por padrão, significando que os empates são mantidos.\n.preserve = FALSE por padrão. Se TRUE, a estrutura de agrupamento é recalculada após o fatiamento.\nweight_by = Opcional, coluna numérica para ponderar (número maior com maior probabilidade de ser amostrado). Também replace = para se a amostragem é feita com/sem substituição.\nDICA: Ao usar slice_max() e slice_min(), certifique-se de especificar/escrever o n = (por exemplo, n = 2 , não apenas 2). Caso contrário, você pode receber um erro Erro:…não está vazio. \nNOTE: Você pode encontrar a função top_n(), que tem foi substituído pelas funções slice.\n\n\nSubdividão com grupos\nAs funções slice_*() podem ser muito úteis se aplicadas a um data frame agrupado porque a operação de fatia é executada em cada grupo separadamente. Use a função group_by() em conjunto com slice() para agrupar os dados para obter uma fatia de cada grupo.\nIsso é útil para a eliminação de duplicação se você tiver várias linhas por pessoa, mas quiser manter apenas uma delas. Você primeiro usa group_by() com colunas-chave que são as mesmas por pessoa e, em seguida, usa uma função de fatia em uma coluna que será diferente entre as linhas agrupadas.\nNo exemplo abaixo, para manter apenas o último encontro por pessoa, agrupamos as linhas por name e então usamos slice_max() com n = 1 na coluna date. Estar ciente! Para aplicar uma função como slice_max() em datas, a coluna de data deve ser da classe Date.\nPor padrão, “empates” (por exemplo, mesma data neste cenário) são mantidos e ainda obteríamos várias linhas para algumas pessoas (por exemplo, adam). Para evitar isso, configuramos with_ties = FALSE. Retornamos apenas uma fila por pessoa.\nCAUTION: Se estiver usando arrange(), especifique .by_group = TRUE para organizar os dados em cada grupo.\nDANGER: Se with_ties = FALSE, a primeira linha de um empate é mantida. Isso pode ser enganoso. Veja como para Mariah, ela tem dois encontros em sua última data (6 de janeiro) e o primeiro (mais antigo) foi mantido. Provavelmente, queremos manter seu encontro posterior naquele dia. Veja como “quebrar” esses empates no próximo exemplo. \n\nobs %&gt;% \n  group_by(name) %&gt;% # agrupa as linhas por 'name'\n  slice_max(date, # mantém linha por grupo com valor máximo de data \n            n = 1, # mantém apenas a linha mais alta\n            with_ties = F) # se houver empate (de data), pegue a primeira linha\n\n\n\n\n\n\n\nAcima, por exemplo, podemos ver que apenas a linha de Amrish em 5 de janeiro foi mantida, e apenas a linha de Brian em 7 de janeiro foi mantida. Veja os dados originais.\n“Desempates”\nVárias instruções de fatia podem ser executadas para “desempate”. Neste caso, se uma pessoa tiver vários encontros em sua última data, o encontro com a última hora é mantido (lubridate::hm() é usado para converter os tempos dos caracteres em uma classe de tempo classificável).\nObserve como agora, a única linha mantida para “Mariah” em 6 de janeiro é o encontro 3 das 08:32, não o encontro 2 às 07:25.\n\n# Exemplo de várias instruções de fatia para \"desempate\"\nobs %&gt;%\n  group_by(name) %&gt;%\n  \n  # PRIMEIRO - fatia por data mais recente\n  slice_max(date, n = 1, with_ties = TRUE) %&gt;% \n  \n  # SEGUNDO - se houver empate, selecione a linha com o horário mais recente; empates proibidos\n  slice_max(lubridate::hm(time), n = 1, with_ties = FALSE)\n\n\n\n\n\n\n\nNo exemplo acima, também seria possível dividir por número de encounter, mas mostramos a fatia em data e hora para fins de exemplo.\nDICA: Para usar slice_max() ou slice_min() em uma coluna “character”, altere-a para uma classe de fator ordenada! extensão&gt;\nVeja os dados originais.\n\n\n\nMantenha tudo mas marque-os\nSe você quiser manter todos os registros, mas marcar apenas alguns para análise, considere uma abordagem de duas etapas utilizando um recordID/número de encontro exclusivo:\n\nReduza/faça o recorte do data frame original apenas nas linhas para análise. Salve/retenha este data frame reduzido.\n\nNo data frame original, marque as linhas conforme apropriado com case_when(), com base no fato de seu identificador exclusivo de registro (recordID neste exemplo) estar presente no data frame reduzido.\n\n\n# 1. Defina o data frame de linhas para manter para análise\nobs_keep &lt;- obs %&gt;%\n  group_by(name) %&gt;%\n  slice_max(encounter, n = 1, with_ties = FALSE) # mantém apenas o último encontro por pessoa\n\n\n# 2. Marcar data frame original\nobs_marked &lt;- obs %&gt;%\n\n  # cria uma nova coluna dup_record\n  mutate(dup_record = case_when(\n    \n    # se o registro estiver no data frame obs_keep\n    recordID %in% obs_keep$recordID ~ \"Para análise\", \n    \n    # tudo o mais marcado como \"Ignorar\" para fins de análise\n    TRUE ~ \"Ignorar\"))\n\n# imprimir\nobs_marked\n\n   recordID personID    name       date   time encounter purpose symptoms_ever\n1         1        1    adam 2020-01-01  09:00         1 contact          &lt;NA&gt;\n2         1        1    adam 2020-01-01  09:00         1 contact          &lt;NA&gt;\n3         2        2  amrish 2020-02-01  14:20         1 contact            No\n4         3        2  amrish 2020-02-01  14:20         1 contact            No\n5         4        3  mariah 2020-05-01  12:00         1    case            No\n6         5        2  amrish 2020-05-01  16:10         3    case           Yes\n7         6        4  nikhil 2020-05-01  13:01         1 contact           Yes\n8         7        5   brian 2020-05-01 15:20          1 contact            No\n9         8        6   smita 2020-05-01  14:20         1 contact           Yes\n10        9        7  raquel 2020-05-01  12:30         1 contact          &lt;NA&gt;\n11       10        2  amrish 2020-02-01  10:24         2 contact           Yes\n12       11        1    adam 2020-01-05  09:40         2    case            No\n13       12        3  mariah 2020-01-06  07:25         2 contact            No\n14       13        3  mariah 2020-01-06  08:32         3 contact            No\n15       14        4  nikhil 2020-01-06  15:36         2 contact           Yes\n16       15        5   brian 2020-01-06  15:31         2 contact           Yes\n17       16        5   brian 2020-01-07  07:59         3    case            No\n18       17        7  raquel 2020-01-07  11:13         2 contact            No\n19       18        8 natalie 2020-01-07  17:12         1    case            No\n     dup_record\n1       Ignorar\n2       Ignorar\n3       Ignorar\n4       Ignorar\n5       Ignorar\n6  Para análise\n7       Ignorar\n8       Ignorar\n9  Para análise\n10      Ignorar\n11      Ignorar\n12 Para análise\n13      Ignorar\n14 Para análise\n15 Para análise\n16      Ignorar\n17 Para análise\n18 Para análise\n19 Para análise\n\n\n\n\n\n\n\n\nVeja os dados originais.\n\n\n\nCalcular a completitude da linha\nCrie uma coluna que contenha uma métrica para a completitude da linha (não falta). Isso pode ser útil ao decidir quais linhas priorizar em relação a outras ao remover duplicidade/fatiar.\nNeste exemplo, as colunas “chave” sobre as quais você deseja medir a integridade são salvas em um vetor de nomes de coluna.\nEntão a nova coluna key_completeness é criada com mutate(). O novo valor em cada linha é definido como uma fração calculada: o número de valores não omissos nessa linha entre as colunas-chave, dividido pelo número de colunas-chave.\nIsso envolve a função rowSums() do R base. Também é usado ., que dentro do encadeamento do código (pipe - %&gt;%) se refere ao data frame naquele ponto do pipe (neste caso, está sendo subconjunto com colchetes []).\n*Role para a direita para ver mais linhas**\n\n# cria uma coluna \"completude da variável chave\"\n# esta é uma *proporção* das colunas designadas como \"key_cols\" que não possuem valores omissos\n\nkey_cols = c(\"personID\", \"name\", \"symptoms_ever\")\n\nobs %&gt;% \n  mutate(key_completeness = rowSums(!is.na(.[,key_cols]))/length(key_cols)) \n\n\n\n\n\n\n\nVeja os dados originais.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Eliminação de duplicidades</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.pt.html#str_rollup",
    "href": "new_pages/deduplication.pt.html#str_rollup",
    "title": "15  Eliminação de duplicidades",
    "section": "15.4 Valores acumulados",
    "text": "15.4 Valores acumulados\nEsta seção descreve:\n\nComo “agregar” valores de várias linhas em apenas uma linha, com algumas variações\n\nDepois de ter os valores “acumulados”, como substituir/priorizar os valores em cada célula\n\nEsta guia usa o conjunto de dados de exemplo da guia Preparação.\n\n\nValores acumulados em uma linha\nO exemplo de código abaixo usa group_by() e summarise() para agrupar linhas por pessoa e depois colar todos os valores exclusivos nas linhas agrupadas. Assim, você obtém uma linha de resumo por pessoa. Algumas notas:\n\nUm sufixo é anexado a todas as novas colunas (“_roll” neste exemplo)\n\nSe você quiser mostrar apenas valores exclusivos por célula, envolva o na.omit() com unique()\n\nna.omit() remove valores NA, mas se isso não for desejado, pode ser removido paste0(.x)…\n\n\n# Valores \"roll-up\" em uma linha por grupo (por \"personID\") \ncases_rolled &lt;- obs %&gt;% \n  \n  #cria grupos por nome\n  group_by(personID) %&gt;% \n  \n  # ordena as linhas dentro de cada grupo (por exemplo, por data)\n  arrange(date, .by_group = TRUE) %&gt;% \n  \n  # Para cada coluna, cole todos os valores dentro das linhas agrupadas, separados por \";\"\n  summarise(\n    across(everything(), # aplica-se a todas as colunas\n           ~paste0(na.omit(.x), collapse = \"; \")))) # função é definida que combina valores não-NA\n\nO resultado é uma linha por grupo (ID), com entradas organizadas por data e coladas juntas. Role para a esquerda para ver mais linhas\n\n\n\n\n\n\nVeja os dados originais.\nEsta variação mostra apenas valores únicos:\n\n# Variação - mostra apenas valores únicos \ncases_rolled &lt;- obs %&gt;% \n  group_by(personID) %&gt;% \n  arrange(date, .by_group = TRUE) %&gt;% \n  summarise(\n    across(everything(), # aplica-se a todas as colunas\n           ~paste0(unique(na.omit(.x)), collapse = \"; \"))) # função é definida que combina valores únicos não-NA\n\n\n\n\n\n\n\nEsta variação anexa um sufixo a cada coluna.\nNeste caso “_roll” para significar que foi agregado:\n\n# Variação - sufixo adicionado aos nomes das colunas \ncases_rolled &lt;- obs %&gt;% \n  group_by(personID) %&gt;% \n  arrange(date, .by_group = TRUE) %&gt;% \n  summarise(\n    across(everything(),                \n           list(roll = ~paste0(na.omit(.x), collapse = \"; \")))) # _roll é anexado aos nomes das colunas\n\n\n\n\n\n\n\n\n\n\nSubstituir valores/hierarquia\nSe você quiser avaliar todos os valores rolados e manter apenas um valor específico (por exemplo, valor “melhor” ou “máximo”), você pode usar mutate() nas colunas desejadas, para implementar case_when() , que usa str_detect() do pacote stringr para procurar sequencialmente padrões de string e sobrescrever o conteúdo da célula.\n\n# CASOS LIMPOS\n#############\ncases_clean &lt;- cases_rolled %&gt;% \n# limpar vars Yes-No-Unknown: substitui o texto pelo valor \"mais alto\" presente na string\nmutate(across(c(contains(\"symptoms_ever\")), # opera em colunas especificadas (S/N/U)\n       list(mod = ~case_when( # adiciona o sufixo \"_mod\" a new cols; implementa case_when()\n               \n       str_detect(.x, \"Sim\") ~ \"Sim\", # se \"Sim\" for detectado, o valor da célula será convertido em sim\n       str_detect(.x, \"No\") ~ \"No\", # então, se \"No\" for detectado, o valor da célula será convertido em não\n       str_detect(.x, \"Desconhecido\") ~ \"Desconhecido\", # então, se \"Desconhecido\" for detectado, o valor da célula será convertido em Desconhecido\n               TRUE ~ as.character(.x)))), # então, se mais alguma coisa se mantiver como está\n      .keep = \"unused\") # colunas antigas removidas, deixando apenas colunas _mod\n\nAgora você pode ver na coluna symptoms_ever que se a pessoa ALGUMA VEZ disse “Sim” aos sintomas, então apenas “Sim” é exibido.\n\n\n\n\n\n\nVeja os dados originais.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Eliminação de duplicidades</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.pt.html#remoção-de-duplicidades-probabilística",
    "href": "new_pages/deduplication.pt.html#remoção-de-duplicidades-probabilística",
    "title": "15  Eliminação de duplicidades",
    "section": "15.5 Remoção de duplicidades probabilística",
    "text": "15.5 Remoção de duplicidades probabilística\nÀs vezes, você pode querer identificar duplicidades “prováveis” com base na semelhança (por exemplo, string “distance”) em várias colunas, como nome, idade, sexo, data de nascimento etc. Você pode aplicar um algoritmo de correspondência probabilística para identificar duplicidades prováveis.\nConsulte a página em Juntar dados para obter uma explicação sobre este método. A seção sobre Correspondência Probabilística contém um exemplo de aplicação desses algoritmos para comparar um data frame com o próprio, realizando assim a desduplicação probabilística.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Eliminação de duplicidades</span>"
    ]
  },
  {
    "objectID": "new_pages/deduplication.pt.html#recursos",
    "href": "new_pages/deduplication.pt.html#recursos",
    "title": "15  Eliminação de duplicidades",
    "section": "15.6 Recursos",
    "text": "15.6 Recursos\nMuitas das informações nesta página são adaptadas destes recursos e vinhetas online:\ndatanovia\ndplyr tidyverse reference\nvinheta de janitor de cran",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Eliminação de duplicidades</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.pt.html",
    "href": "new_pages/iteration.pt.html",
    "title": "16  Iterações, loops e listas",
    "section": "",
    "text": "16.1 Preparação",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Iterações, loops e listas</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.pt.html#preparação",
    "href": "new_pages/iteration.pt.html#preparação",
    "title": "16  Iterações, loops e listas",
    "section": "",
    "text": "Carregando pacotes\nEste trecho de código mostra o carregamento de pacotes necessários para as análises. Neste livro nós enfatizamos o p_load() do pacman, que instala o pacote, se necessário, e o carrega para uso. Você também pode carregar pacotes instalados com o library() do R base. Veja a página sobre o [R - o básico] para mais informações sobre pacotes R.\n\npacman::p_load(\n     rio,         # importa/exporta\n     here,        # localizador de arquivos\n     purrr,       # iteração\n     grates,      # scales in ggplot\n     tidyverse    # gerenciamento e visualização de dados\n)\n\n\n\nImportando dados\nImportamos o conjunto de dados de casos de uma epidemia simulada de Ebola. Se você quiser acompanhar clique aqui para fazer download da linelist “limpa” (como um arquivo .rds). Importamos os dados com a função import() do pacote rio (ela lida com muitos tipos de arquivos como .xlsx, .csv, .rds - veja a página Importar e exportar para detalhes).\n\n# importando a linelist\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nAs primeiras 50 linhas da linelist são exibidas abaixo.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Iterações, loops e listas</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.pt.html#loops-for",
    "href": "new_pages/iteration.pt.html#loops-for",
    "title": "16  Iterações, loops e listas",
    "section": "16.2 loops for",
    "text": "16.2 loops for\n\nloops for no R\nloops for não são enfatizados em R, mas são comuns em outras linguagens de programação. Para iniciantes, eles podem ser úteis para aprender e praticar porque são mais fáceis de “explorar”, “depurar” e entender exatamente o que está acontecendo para cada iteração, especialmente quando você ainda não está confortável em escrever suas próprias funções .\nVocê pode passar rapidamente do loop for para iterar com funções mapeadas com o purrr (consulte a seção abaixo)\n\n\nPrincipais componentes\nUm loop for tem três partes principais:\n\nA sequência de itens para percorrer\nAs operações a serem conduzidas por item na sequência\nO contêiner para armazenar os resultados (opcional)\n\nA sintaxe básica é: for (item em sequência) {fazer operações usando item}. Observe os parênteses e os colchetes. Os resultados podem ser impressos no console ou armazenados em um objeto R (o container).\nUm exemplo simples de loop for está abaixo.\n\nfor (num in c(1,2,3,4,5)) {  # a SEQUÊNCIA é definida (números 1 a 5) e o loop é aberto com \"{\"\n  print(num + 2)             # As OPERAÇÕES (adicione dois a cada número de sequência e imprima)\n}                            # O loop é fechado com \"}\"                           \n\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n\n\n\n\nSequência\nEsta é a parte “for” de um loop for - as operações serão executadas “para” cada item na sequência. A sequência pode ser uma série de valores (por exemplo, nomes de jurisdições, doenças, nomes de colunas, elementos de lista, etc.), ou pode ser uma série de números consecutivos (por exemplo, 1,2,3,4,5). Cada abordagem tem suas próprias utilidades, descritas abaixo.\nA estrutura básica de uma instrução de sequência é item em vetor.\n\nVocê pode escrever qualquer caractere ou palavra no lugar de “item” (por exemplo, “i”, “num”, “hosp”, “distrito”, etc.). O valor desse “item” muda a cada iteração do loop, passando por cada valor no vetor.\nO vetor pode ser de valores do tipo caracteres, nomes de colunas ou talvez uma sequência de números - esses são os valores que mudarão a cada iteração. Você pode usá-los nas operações do loop for usando o termo “item”.\n\nExemplo: sequência de valores de caracteres\nNeste exemplo, um loop é executado para cada valor em um vetor de caracteres predefinido de nomes de hospitais.\n\n# criando um vetor com os nomes dos hospitais\nhospital_names &lt;- unique(linelist$hospital)\nhospital_names # printe (mostre o nome do hospital)\n\n[1] \"Other\"                               \n[2] \"Ausente\"                             \n[3] \"St. Mark's Maternity Hospital (SMMH)\"\n[4] \"Port Hospital\"                       \n[5] \"Military Hospital\"                   \n[6] \"Central Hospital\"                    \n\n\nEscolhemos o termo hosp para representar valores do vetor hospital_names. Para a primeira iteração do loop, o valor de hosp será hospital_names[[1]]. Para o segundo loop será hospital_names[[2]]. E assim por diante…\n\n# um 'loop for' com sequência de caracteres\n\nfor (hosp in hospital_names){       # sequência\n  \n       # OPERAÇÕES AQUI\n  }\n\nExemplo: sequência de nomes de colunas\nEsta é uma variação da sequência de caracteres acima, na qual os nomes de um objeto R existente são extraídos e se tornam o vetor. Por exemplo, os nomes das colunas de um data frame. Convenientemente, no código de operações do loop for, os nomes das colunas podem ser usados para indexar (subconjunto) seu data frame original.\nAbaixo, a sequência é o names() (nomes das colunas) do data frame linelist. Nosso nome de “item” é col, que representará o nome de cada coluna à medida que os loops prosseguem.\nPara fins de exemplo, incluímos o código de operações dentro do loop for, que é executado para cada valor na sequência. Neste código, os valores de sequência (nomes das colunas) são usados para indexar (subconjunto) linelist, um de cada vez. Conforme ensinado na página Introdução ao R, colchetes duplos [[ ]] são usados para subconjunto. A coluna resultante é passada para is.na(), então para sum() para produzir o número de valores na coluna que estão faltando. O resultado é impresso no console - um número para cada coluna.\n\nfor (col in names(linelist)){        # o loop é executado para cada coluna na linelist; nome da coluna representado por \"col\" \n  \n  # Exemplo de código de operações - printe o número de valores ausentes na coluna\n  print(sum(is.na(linelist[[col]])))  # linelist é indexado pelo valor atual de \"col\"\n     \n}\n\n[1] 0\n[1] 0\n[1] 2087\n[1] 256\n[1] 0\n[1] 936\n[1] 1323\n[1] 278\n[1] 86\n[1] 0\n[1] 86\n[1] 86\n[1] 86\n[1] 0\n[1] 0\n[1] 0\n[1] 2088\n[1] 2088\n[1] 0\n[1] 0\n[1] 0\n[1] 249\n[1] 249\n[1] 249\n[1] 249\n[1] 249\n[1] 149\n[1] 765\n[1] 0\n[1] 256\n\n\nSequência de números\nNesta abordagem, a sequência é uma série de números consecutivos. Assim, o valor do “item” não é um valor de caractere (por exemplo, “Hospital Central” ou “data_onset”), mas é um número. Isso é útil para fazer loop pelos data frames, pois você pode usar o número do “item” dentro do loop for para indexar o data frame pelo número da linha.\nPor exemplo, digamos que você queira percorrer cada linha em seu data frame e extrair determinadas informações. Seus “itens” seriam números de linha numéricos. Frequentemente, “itens” neste caso são escritos como i.\nO processo loop for pode ser explicado em palavras como “para cada item em uma sequência de números de 1 ao número total de linhas no meu data frame, faça X”. Para a primeira iteração do loop, o valor de “item” i seria 1. Para a segunda iteração, i seria 2, etc.\nAqui está a aparência da sequência no código: for (i in 1:nrow(linelist)) {OPERATIONS CODE} onde i representa o “item” e 1:nrow(linelist) produz uma sequência de números de 1 até o número de linhas em linelist.\n\nfor (i in 1:nrow(linelist)) {  # use em um data frame\n  # OPERAÇÕES AQUI\n}  \n\nSe você deseja que a sequência seja de números, mas está começando de um vetor (não de um data frame), use o atalho seq_along() para retornar uma sequência de números para cada elemento do vetor. Por exemplo, for (i in seq_along(hospital_names) {OPERATIONS CODE}.\nO código abaixo na verdade retorna números, que se tornariam o valor de i em seu respectivo loop.\n\nseq_along(hospital_names)  # use em um vetor de nomes\n\n[1] 1 2 3 4 5 6\n\n\nUma vantagem de usar números na sequência é que é fácil também usar o número i para indexar um contêiner que armazena as saídas do loop. Há um exemplo disso na seção Operações abaixo.\n\n\nOperações\nEste é o código dentro das chaves { } do loop for. Você deseja que esse código seja executado para cada “item” na sequência. Portanto, tome cuidado para que cada parte do seu código que muda pelo “item” seja codificada corretamente de forma que realmente mude! Por exemplo, lembre-se de usar [[ ]] para indexação.\nNo exemplo abaixo, iteramos em cada linha na linelist. Os valores gender e age de cada linha são colados e armazenados no vetor de caracteres do contêiner cases_demographics. Observe como também usamos a indexação [[i]] para salvar a saída do loop na posição correta no vetor “contêiner”.\n\n# criando contêiner para armazenar resultados - um vetor de caractere\ncases_demographics &lt;- vector(mode = \"character\", length = nrow(linelist))\n\n# o loop for\nfor (i in 1:nrow(linelist)){\n  \n  # OPERAÇÕES\n  # extraindo valores da linelist para a linha i, usando colchetes para indexação\n  row_gender  &lt;- linelist$gender[[i]]\n  row_age     &lt;- linelist$age_years[[i]]    # não se esqueça de indexar!\n     \n  # combinando gender-age e armazenar no vetor de contêiner no local indexado\n  cases_demographics[[i]] &lt;- str_c(row_gender, row_age, sep = \",\") \n\n}  # finalizando o loop for\n\n\n# exibindo as primeiras 10 linhas do contêiner\nhead(cases_demographics, 10)\n\n [1] \"m,2\"  \"f,3\"  \"m,56\" \"f,18\" \"m,3\"  \"f,16\" \"f,16\" \"f,0\"  \"m,61\" \"f,27\"\n\n\n\n\nContêiner\nÀs vezes, os resultados do seu loop for serão impressos no console ou no painel RStudio Plots. Outras vezes, você desejará armazenar as saídas em um “contêiner” para uso posterior. Esse contêiner pode ser um vetor, um data frame ou até mesmo uma lista.\nÉ mais eficiente criar o contêiner para os resultados antes mesmo de iniciar o loop. Na prática, isso significa criar um vetor, data frame ou lista vazio. Estes podem ser criados com as funções vector() para vetores ou listas, ou com matrix() e data.frame() para um data frame.\nVetor vazio\nUse vector() e especifique o mode = com base na classe esperada dos objetos que você irá inserir - seja “double” (para armazenar números), “character” ou “logical”. Você também deve definir o length = com antecedência. Este deve ser o comprimento da sua sequência loop for.\nDigamos que você queira armazenar o atraso médio até a admissão de cada hospital. Você usaria “double” e definiria o comprimento como o número de saídas esperadas (o número de hospitais exclusivos no conjunto de dados).\n\ndelays &lt;- vector(\n  mode = \"double\",                            # esperamos armazenar números\n  length = length(unique(linelist$hospital))) # o número de hospitais únicos no conjunto de dados\n\nData frame vazio\nVocê pode criar um data frame vazio especificando o número de linhas e colunas assim:\n\ndelays &lt;- data.frame(matrix(ncol = 2, nrow = 3))\n\nLista vazia\nVocê pode querer armazenar alguns gráficos criados por um loop for em uma lista. Uma lista é como um vetor, mas contém outros objetos R dentro dela que podem ser de diferentes classes. Os itens em uma lista podem ser um único número, um data frame, um vetor e até outra lista.\nVocê realmente inicializa uma lista vazia usando o mesmo comando vector() acima, mas com mode = \"list\". Especifique o comprimento como desejar.\n\nplots &lt;- vector(mode = \"list\", length = 16)\n\n\n\nImprimindo\nObserve que para “printar” (mostrar) de dentro de um loop for você provavelmente precisará envolver explicitamente a função print().\nNeste exemplo abaixo, a sequência é um vetor de caracteres explícito, que é usado para acessar o subconjunto da linelist por hospital. Os resultados não são armazenados em um contêiner, mas são impressos no console com a função print().\n\nfor (hosp in hospital_names){ \n     hospital_cases &lt;- linelist %&gt;% filter(hospital == hosp)\n     print(nrow(hospital_cases))\n}\n\n[1] 885\n[1] 1469\n[1] 422\n[1] 1762\n[1] 896\n[1] 454\n\n\n\n\nTestando o seu loop\nPara testar seu loop, você pode executar um comando para fazer uma atribuição temporária do “item”, como i &lt;- 10 ou hosp &lt;- \"Central Hospital\". Faça isso fora do loop e execute apenas seu código de operações (o código entre colchetes) para ver se os resultados esperados são produzidos.\n\n\nGráficos em loop\nPara juntar todos os três componentes (contêiner, sequência e operações), vamos tentar traçar uma epicurva para cada hospital (consulte a página em Curvas epidêmicas).\nPodemos fazer uma bela epicurva de todos os casos por gênero usando o pacote incidence2 conforme abaixo:\n\n# criando o objeto do tipo 'incidence'\noutbreak &lt;- incidence2::incidence(   \n     x = linelist,                   # data frame - linelist completo\n     date_index = \"date_onset\",        # coluna de data\n     interval = \"week\",              # contagens agregadas semanalmente\n     groups = \"gender\")                # valores de grupo por gênero\n     #na_as_group = TRUE)             # o sexo ausente é um grupo próprio\n\n# plotando a epicurva\nggplot(outbreak, # nom de l'objet d'incidence\n        aes(x = date_index, #aesthetiques et axes\n            y = count, \n            fill = gender), # Fill colour of bars by gender\n       color = \"black\"      # Contour colour of bars\n       ) +  \n     geom_col() + \n     facet_wrap(~gender) +\n     theme_bw() + \n     labs(title = \"Outbreak of all cases\", #titre\n          x = \"Counts\", \n          y = \"Date\", \n          fill = \"Gender\", \n          color = \"Gender\")\n\n\n\n\n\n\n\n\nPara produzir um gráfico separado para os casos de cada hospital, podemos colocar esse código da epicurva dentro de um loop for.\nPrimeiro, salvamos um vetor com os nomes exclusivos do hospital, hospital_names. O loop for será executado uma vez para cada um destes nomes: for (hosp in hospital_names). A cada iteração do loop for, o nome do hospital atual do vetor será representado como hosp para uso dentro do loop.\nDentro das operações de loop, você pode escrever o código R normalmente, mas use o “item” (hosp neste caso) sabendo que seu valor será alterado. Dentro deste loop:\n\nUm filter() é aplicado a linelist, de modo que a coluna hospital deve ser igual ao valor atual de hosp\nO objeto do tipo incidence é criado na linelist filtrada\nO gráfico para o hospital atual é criado, com um título de ajuste automático que usa hosp\nO gráfico do hospital atual é salvo temporariamente e depois impresso\nO loop então avança para repetir com o próximo hospital em hospital_names\n\n\n# criando o vetor dos nomes dos hospitais\nhospital_names &lt;- unique(linelist$hospital)\n\n# para cada nome (\"hosp\") em hospital_names, crie e imprima a epicurva\nfor (hosp in hospital_names) {\n     \n     # criando objeto de incidência específico para o hospital atual\n     outbreak_hosp &lt;- incidence2::incidence(\n          x = linelist %&gt;% filter(hospital == hosp),   # linelist é filtrada para o hospital atual\n          date_index = \"date_onset\",\n          interval = \"week\", \n          groups = \"gender\"#,\n          #na_as_group = TRUE\n     )\n     \n     # Criando e salvando o gráfico. O título se ajusta automaticamente ao hospital atual\n      plot_hosp &lt;- ggplot(outbreak_hosp, # incidence object name\n                         aes(x = date_index, #axes\n                             y = count, \n                             fill = gender), # fill colour by gender\n                         color = \"black\"      # colour of bar contour\n                         ) +  \n          geom_col() + \n          facet_wrap(~gender) +\n          theme_bw() + \n          labs(title = stringr::str_glue(\"Epidemic of cases admitted to {hosp}\"), #title\n               x = \"Counts\", \n               y = \"Date\", \n               fill = \"Gender\", \n               color = \"Gender\")\n     \n     # With older versions of R, remove the # before na_as_group and use this plot command instead.\n    # plot_hosp &lt;- plot(\n#       outbreak_hosp,\n#       fill = \"gender\",\n#       color = \"black\",\n#       title = stringr::str_glue(\"Epidemic of cases admitted to {hosp}\")\n#     )\n     \n     # exibindo o gráfico para o hospital atual\n     print(plot_hosp)\n     \n} # encerrando o loop for quando ele tiver sido executado para todos os hospitais em hospital_names\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAcompanhando o progresso de um loop\nUm loop com muitas iterações pode ser executado por muitos minutos ou até horas. Assim, pode ser útil imprimir o progresso no console R. A instrução if (que significa “se” em inglês) abaixo pode ser colocada dentro das operações de loop para exibir a cada 100 números. Basta ajustá-lo para que i seja o “item” em seu loop.\n\n# loop com código para exibir o progresso a cada 100 iterações\nfor (i in seq_len(nrow(linelist))){\n\n  # print progress\n  if(i %% 100==0){    # O operador %% calcula o resto da operação\n    print(i)\n\n}",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Iterações, loops e listas</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.pt.html#iter_purrr",
    "href": "new_pages/iteration.pt.html#iter_purrr",
    "title": "16  Iterações, loops e listas",
    "section": "16.3 purrr e listas",
    "text": "16.3 purrr e listas\nOutra abordagem para operações iterativas é o pacote purrr - essa é a abordagem tidyverse para iteração.\nSe você tiver que executar a mesma tarefa várias vezes, provavelmente vale a pena criar uma solução generalizada que possa ser usada com várias entradas. Por exemplo, produzindo gráficos para várias jurisdições ou importando e combinando muitos arquivos.\nHá também algumas outras vantagens para usar o purrr - você pode usá-lo com pipes %&gt;%, ele lida com erros melhor do que o normal loop for, e a sintaxe é bastante limpa e simples! Se você estiver usando um loop for, provavelmente poderá fazê-lo de forma mais clara e sucinta com purrr!\nTenha em mente que o purrr é uma ferramenta de programação funcional. Ou seja, as operações que devem ser aplicadas iterativamente são agrupadas em funções. Consulte a página Escrevendo funções para aprender a escrever suas próprias funções.\nO purrr também é quase inteiramente baseado em listas e vetores - então pense nisso como aplicar uma função a cada elemento dessa lista/vetor!\n\nCarregando pacotes\nO purrr faz parte do tidyverse, portanto, não há necessidade de instalar/carregar um pacote separado.\n\npacman::p_load(\n     rio,            # importa/exporta\n     here,           # caminhos de arquivos relativos\n     tidyverse,      # gerenciamento de dados e visualização\n     writexl,        # escreve arquivos Excel com várias abas\n     readxl          # importa arquivos Excel com várias abas\n)\n\n\n\nmap()\nA função principal do purrr é a map(), que “mapeia” (aplica) uma função para cada elemento de entrada de uma lista/vetor que você fornece.\nA sintaxe básica é map(.x = SEQUENCE, .f = FUNCTION, OTHER ARGUMENTS). Com um pouco mais de detalhes:\n\n.x = são as entradas nas quais a função .f será aplicada iterativamente - ex. um vetor de nomes de jurisdição, colunas em um data frame ou uma lista de data frames\n.f = é a função a ser aplicada a cada elemento da entrada .x - pode ser uma função como print() que já existe, ou uma função personalizada que você define. A função geralmente é escrita após um til ~ (detalhes abaixo).\n\nMais algumas notas sobre a sintaxe:\n\nSe a função não precisar de mais argumentos especificados, ela pode ser escrita sem parênteses e sem til (por exemplo, .f = mean). Para fornecer argumentos que terão o mesmo valor para cada iteração, forneça-os dentro da map() mas fora do argumento .f =, como na.rm = T em map(.x = my_list, .f = média, na.rm=T).\nVocê pode usar .x (ou simplesmente .) dentro da função .f = como um espaço reservado para o valor .x dessa iteração\nUse a sintaxe til (~) para ter maior controle sobre a função - escreva a função normalmente com parênteses, como: map(.x = my_list, .f = ~mean(., na.rm = T) ). Use esta sintaxe especialmente se o valor de um argumento mudar a cada iteração, ou se for o próprio valor .x (veja os exemplos abaixo)\n\nO resultado da função map() é uma lista - uma lista é uma classe de objeto como um vetor, mas cujos elementos podem ser de classes diferentes. Assim, uma lista produzida pela map() pode conter muitos data frames, ou muitos vetores, muitos valores únicos, ou mesmo muitas listas! Existem versões alternativas da map() explicadas abaixo que produzem outros tipos de saídas (por exemplo, map_dfr() para produzir um data frame, map_chr() para produzir vetores de caracteres e map_dbl() para produzir vetores).\n\nExemplo - importar e combinar planilhas do Excel\nVamos demonstrar com uma tarefa comum de um epidemiologista: - Você deseja importar um arquivo do Excel com dados do caso, mas os dados são divididos em diferentes abas com nomes. Como você importa e combina com eficiência as planilhas em um data frame?\nDigamos que recebemos arquivo Excel abaixo. Cada folha contém casos de um determinado hospital.\n\n\n\n\n\n\n\n\n\nAqui está uma abordagem que usa a função map():\n\nmap() a função import() para que seja executada para aba do Excel\nCombine em um os data frames importados usando bind_rows()\nAo longo do caminho, preserve o nome da aba original para cada linha, armazenando essas informações em uma nova coluna no data frame final\n\nPrimeiro, precisamos extrair os nomes das abas e salvá-los. Fornecemos o caminho do arquivo Excel para a função excel_sheets() do pacote readxl, que extrai os nomes das abas Nós os armazenamos em um vetor de caracteres chamado sheet_names.\n\nsheet_names &lt;- readxl::excel_sheets(\"hospital_linelists.xlsx\")\n\nAqui estão os nomes:\n\nsheet_names\n\n[1] \"Central Hospital\"              \"Military Hospital\"            \n[3] \"Missing\"                       \"Other\"                        \n[5] \"Port Hospital\"                 \"St. Mark's Maternity Hospital\"\n\n\nAgora que temos esse vetor de nomes, map() pode fornecê-los um a um para a função import(). Neste exemplo, os sheet_names são .x e import() é a função .f.\nLembre-se da página Importar e exportar que quando usado em arquivos do Excel, import() pode aceitar o argumento which = (qual) especificando a aba a ser importada. Dentro da função .f import(), fornecemos which = .x, cujo valor mudará a cada iteração através do vetor sheet_names - primeiro “Central Hospital” (“Hospital Central”), depois “Military Hospital” (“Hospital Militar”) etc.\nNota - porque usamos map(), os dados em cada planilha do Excel serão salvos como um data frame separado dentro de uma lista. Queremos que cada um desses elementos de lista (data frame) tenha um nome, então antes de passarmos sheet_names para map(), passamos por set_names() de purrr, o que garante que cada elemento da lista recebe o nome apropriado.\nSalvamos a lista de saída como o objeto combined.\n\ncombined &lt;- sheet_names %&gt;% \n  purrr::set_names() %&gt;% \n  map(.f = ~import(\"hospital_linelists.xlsx\", which = .x))\n\nQuando inspecionamos o resultado, vemos que os dados de cada aba do Excel são salvos na lista com um nome. Isso é bom, mas ainda não terminamos.\n\n\n\n\n\n\n\n\n\nPor fim, usamos a função bind_rows() (do dplyr) que aceita a lista de data frames com estrutura semelhante e os combina em um único data frame. Para criar uma nova coluna a partir do elemento names da lista, usamos o argumento .id = e fornecemos o nome desejado para a nova coluna.\nAbaixo está toda a sequência de comandos:\n\nsheet_names &lt;- readxl::excel_sheets(\"hospital_linelists.xlsx\")  # extraindo o nome das abas\n \ncombined &lt;- sheet_names %&gt;%                                     # começando com os nomes das abas\n  purrr::set_names() %&gt;%                                        # definindo seus nomes\n  map(.f = ~import(\"hospital_linelists.xlsx\", which = .x)) %&gt;%  # iterando, importando, salvando na lista\n  bind_rows(.id = \"origin_sheet\") # combinar lista de data frames, preservando a origem em uma nova coluna\n\nE agora temos um data frame com uma coluna contendo a aba de origem!\n\n\n\n\n\n\n\n\n\nExistem variações da map() que você deve conhecer. Por exemplo, map_dfr() retorna um data frame, não uma lista. Assim, poderíamos tê-lo usado para a tarefa acima e não ter que vincular linhas. Mas aí não teríamos conseguido capturar de qual aba (hospital) veio cada caso.\nOutras variações incluem map_chr(), map_dbl(). Estas são funções muito úteis por duas razões. Em primeiro lugar, elas convertem automaticamente a saída de uma função iterativa em um vetor (não uma lista). Em segundo lugar, elas podem controlar explicitamente a classe em que os dados voltam - você garante que seus dados voltem como um vetor de caracteres com map_chr(), ou vetor numérico com map_dbl(). Vamos voltar a eles mais tarde na seção!\nAs funções map_at() e map_if() também são muito úteis para iteração - elas permitem que você especifique em quais elementos de uma lista você deve iterar! Estes funcionam simplesmente aplicando um vetor de índices/nomes (no caso de map_at()) ou um teste lógico (no caso de map_if()).\nVamos usar um exemplo em que não queríamos ler a primeira aba de dados do hospital. Usamos map_at() em vez de map(), e especificamos o argumento .at = para c(-1) que significa não usar o primeiro elemento de .x. Alternativamente, você pode fornecer um vetor de números positivos, ou nomes, para .at = para especificar quais elementos usar.\n\nsheet_names &lt;- readxl::excel_sheets(\"hospital_linelists.xlsx\")\n\ncombined &lt;- sheet_names %&gt;% \n     purrr::set_names() %&gt;% \n     # excluindo a primeira aba\n     map_at(.f = ~import( \"hospital_linelists.xlsx\", which = .x),\n            .at = c(-1))\n\nObserve que o nome da primeira aba ainda aparecerá como um elemento da lista de saída - mas é apenas um nome de caractere único (não um data frame). Você precisaria remover esse elemento antes de vincular as linhas. Abordaremos como remover e modificar elementos de uma lista em uma seção posterior.\n\n\n\nDivida o conjunto de dados e exporte\nAbaixo, damos um exemplo de como dividir um conjunto de dados em partes e, em seguida, usar a iteração map() para exportar cada parte como uma aba separada do Excel ou como um arquivo CSV separado.\n\nConjunto de dados dividido\nDigamos que temos o caso completo linelist como um data frame e agora queremos criar uma linelist separada para cada hospital e exportar cada um como um arquivo CSV separado. Abaixo, fazemos os seguintes passos:\nUse group_split() (do dplyr) para dividir o data frame linelist por valores únicos na coluna hospital. A saída é uma lista contendo um data frame por subconjunto de hospital.\n\nlinelist_split &lt;- linelist %&gt;% \n     group_split(hospital)\n\nPodemos executar View(linelist_split) e ver que esta lista contém 6 data frames (“tibbles”), cada um representando os casos de um hospital.\n\n\n\n\n\n\n\n\n\nNo entanto, observe que os data frames na lista não possuem nomes por padrão! Queremos que cada um tenha um nome e, em seguida, use esse nome ao salvar o arquivo CSV.\nUma abordagem para extrair os nomes é usar pull() (do dplyr) para extrair a coluna hospital de cada data frame na lista. Então, por segurança, convertemos os valores em caracteres e usamos unique() para obter o nome desse data frame específico. Todas essas etapas são aplicadas a cada data frame via map().\n\nnames(linelist_split) &lt;- linelist_split %&gt;%   # Atribuindo os nomes de data frames listados\n     # Extraia os nomes fazendo o seguinte para cada data frame:\n     map(.f = ~pull(.x, hospital)) %&gt;%        # Puxe a coluna do hospital\n     map(.f = ~as.character(.x)) %&gt;%          # Converta em caractere, apenas por garantia\n     map(.f = ~unique(.x))                    # Pegue o nome exclusivo do hospital\n\nAgora podemos ver que cada um dos elementos da lista tem um nome. Esses nomes podem ser acessados via names(linelist_split).\n\n\n\n\n\n\n\n\n\n\nnames(linelist_split)\n\n[1] \"Ausente\"                             \n[2] \"Central Hospital\"                    \n[3] \"Military Hospital\"                   \n[4] \"Other\"                               \n[5] \"Port Hospital\"                       \n[6] \"St. Mark's Maternity Hospital (SMMH)\"\n\n\n\nMais de uma coluna group_split()\nSe você quiser dividir a linelist por mais de uma coluna de agrupamento, como para produzir uma lista de linelist pela interseção de hospital E sexo, precisará de uma abordagem diferente para nomear os elementos da lista. Isso envolve coletar as “chaves de grupo” exclusivas usando group_keys() do dplyr - elas são retornadas como um data frame. Então você pode combinar as chaves de grupo em valores com unite() como mostrado abaixo, e atribuir esses nomes de conglomerados a linelist_split.\n\n# dividindo a linelist por combinações exclusivas de hospital-gênero\nlinelist_split &lt;- linelist %&gt;% \n     group_split(hospital, gender)\n\n# extraindo group_keys() como um data frame\ngroupings &lt;- linelist %&gt;% \n     group_by(hospital, gender) %&gt;%       \n     group_keys()\n\ngroupings      # mostrando agrupamentos únicos\n\n# A tibble: 18 × 2\n   hospital                             gender\n   &lt;chr&gt;                                &lt;chr&gt; \n 1 Ausente                              f     \n 2 Ausente                              m     \n 3 Ausente                              &lt;NA&gt;  \n 4 Central Hospital                     f     \n 5 Central Hospital                     m     \n 6 Central Hospital                     &lt;NA&gt;  \n 7 Military Hospital                    f     \n 8 Military Hospital                    m     \n 9 Military Hospital                    &lt;NA&gt;  \n10 Other                                f     \n11 Other                                m     \n12 Other                                &lt;NA&gt;  \n13 Port Hospital                        f     \n14 Port Hospital                        m     \n15 Port Hospital                        &lt;NA&gt;  \n16 St. Mark's Maternity Hospital (SMMH) f     \n17 St. Mark's Maternity Hospital (SMMH) m     \n18 St. Mark's Maternity Hospital (SMMH) &lt;NA&gt;  \n\n\nAgora combinamos os agrupamentos, separados por traços, e os atribuímos como os nomes dos elementos da lista em linelist_split. Isso leva algumas linhas extras, pois substituimos NA por “Ausente”, usamos unite() do dplyr para combinar os valores das colunas (separados por traços) e, em seguida, convertemos em um vetor sem nome para que ele pode ser usado como nomes de linelist_split.\n\n# Combinando em um valor de um nome\nnames(linelist_split) &lt;- groupings %&gt;% \n     mutate(across(everything(), replace_na, \"Ausente\")) %&gt;%  # substituindo NA por \"Ausente\" em todas as colunas\n     unite(\"combined\", sep = \"-\") %&gt;%                         # unindo todos os valores da coluna em um\n     setNames(NULL) %&gt;% \n     as_vector() %&gt;% \n     as.list()\n\n\n\n\nExportando como abas do Excel\nPara exportar as linelists do hospital como um arquivo do Excel com uma linelist por aba, podemos apenas fornecer a lista nomeada linelist_split para a função write_xlsx() do pacote writexl. Isso tem a capacidade de salvar um arquivo Excel com várias abas. Os nomes dos elementos da lista são aplicados automaticamente como os nomes das abas\n\nlinelist_split %&gt;% \n     writexl::write_xlsx(path = here(\"data\", \"hospital_linelists.xlsx\"))\n\nAgora você pode abrir o arquivo Excel e ver que cada hospital tem sua própria aba\n\n\n\n\n\n\n\n\n\n\n\nExportando como arquivos CSV\nÉ um comando um pouco mais complexo, mas você também pode exportar cada linelist específica do hospital como um arquivo CSV separado, com um nome de arquivo específico para o hospital.\nNovamente usamos map(): pegamos o vetor de nomes de elementos da lista (mostrado acima) e usamos map() para iterar por eles, aplicando export() (do pacote rio, veja página Importar e exportar) no data frame na lista linelist_split que tem esse nome. Também usamos o nome para criar um nome de arquivo exclusivo. Aqui está como funciona:\n\nComeçamos com o vetor de nomes de caracteres, passado para map() como .x\nA função .f é export() , que requer um data frame e um caminho de arquivo para gravar\nA entrada .x (o nome do hospital) é usada dentro de .f para extrair/indexar aquele elemento específico da lista linelist_split. Isso resulta em apenas um data frame por vez sendo fornecido para export().\nPor exemplo, quando map() itera para “Military Hospital” (“Hospital Militar”), então linelist_split[[.x]] é na verdade linelist_split[[\"Military Hospital\"]], retornando assim o segundo elemento de linelist_split - que são todos os casos do Hospital Militar.\nO caminho do arquivo fornecido para export() é dinâmico através do uso de str_glue() (consulte a página Caracteres e strings):\n\nhere() é usado para obter a base do caminho do arquivo e especificar a pasta “data” (observe as aspas simples para não interromper as aspas duplas str_glue())\n\nEm seguida, uma barra /, e novamente o .x que imprime o nome do hospital atual para tornar o arquivo identificável\nFinalmente a extensão “.csv” que export() usa para criar um arquivo CSV\n\n\nnames(linelist_split) %&gt;%\n     map(.f = ~export(linelist_split[[.x]], file = str_glue(\"{here('data')}/{.x}.csv\")))\n\nAgora você pode ver que cada arquivo é salvo na pasta “data” do R Project “Epi_R_handbook”!\n\n\n\n\n\n\n\n\n\n\n\n\nCustomizar funções\nVocê pode querer criar sua própria função para fornecer ao map().\nDigamos que queremos criar curvas epidêmicas para os casos de cada hospital. Para fazer isso usando purrr, nossa função .f pode ser ggplot() e extensões com + como de costume. Como a saída de map() é sempre uma lista, os gráficos são armazenados em uma lista. Por serem gráficos, eles podem ser extraídos e plotados com a função ggarrange() do pacote ggpubr (documentação ).\n\n# carregando pacote para plotar elementos da lista\npacman::p_load(ggpubr)\n\n# mapeando o vetor de 6 \"nomes\" de hospitais (criados anteriormente)\n# usando a função ggplot especificada\n# a saída é uma lista com 6 ggplots\n\nhospital_names &lt;- unique(linelist$hospital)\n\nmy_plots &lt;- map(\n  .x = hospital_names,\n  .f = ~ggplot(data = linelist %&gt;% filter(hospital == .x)) +\n                geom_histogram(aes(x = date_onset)) +\n                labs(title = .x)\n)\n\n# exibindo os ggplots (eles são armazenados em uma lista)\nggarrange(plotlist = my_plots, ncol = 2, nrow = 3)\n\n\n\n\n\n\n\n\nSe este código map() parecer muito confuso, você pode obter o mesmo resultado salvando seu comando ggplot() específico como uma função personalizada definida pelo usuário, por exemplo, podemos chamá-lo de make_epicurve()). Esta função é então usada dentro do map(). .x será substituído iterativamente pelo nome do hospital e usado como hosp_name na função make_epicurve(). Consulte a página sobre Escrevendo funções.\n\n# Criando a função\nmake_epicurve &lt;- function(hosp_name){\n  \n  ggplot(data = linelist %&gt;% filter(hospital == hosp_name)) +\n    geom_histogram(aes(x = date_onset)) +\n    theme_classic()+\n    labs(title = hosp_name)\n  \n}\n\n\n# mapeando\nmy_plots &lt;- map(hospital_names, ~make_epicurve(hosp_name = .x))\n\n# exibindo os ggplots (eles são armazenados em uma lista)\nggarrange(plotlist = my_plots, ncol = 2, nrow = 3)\n\n\n\nMapeando uma função ao longo de colunas\nOutro caso de uso comum é mapear uma função ao longo de muitas colunas. Abaixo, mapeamos (map()) a função t.test() em colunas numéricas no data frame linelist, comparando os valores numéricos por gênero.\nLembre-se da página em Testes estatísticos simples que t.test() pode receber entradas em um formato de fórmula, como t.test(coluna numérica ~ coluna binária). Neste exemplo, fazemos o seguinte:\n\nAs colunas numéricas de interesse são selecionadas de linelist - elas se tornam as entradas .x para map()\nA função t.test() é fornecida como a função .f, que é aplicada a cada coluna numérica\nDentro dos parênteses de t.test():\n\no primeiro ~ precede o .f que map() irá iterar sobre .x\no .x representa a coluna atual sendo fornecida para a função t.test()\no segundo ~ faz parte da equação do teste t descrita acima\na função t.test() espera uma coluna binária no lado direito da equação. Nós fornecemos o vetor linelist$gender independentemente e estaticamente (observe que ele não está incluído em select()).\n\n\nmap() retorna uma lista, então a saída é uma lista de resultados do teste t - um elemento de lista para cada coluna numérica analisada.\n\n# Resultados são salvos como uma lista\nt.test_results &lt;- linelist %&gt;% \n  select(age, wt_kg, ht_cm, ct_blood, temp) %&gt;%  # mantendo apenas algumas colunas numéricas para mapear\n  map(.f = ~t.test(.x ~ linelist$gender))        # função t.test com equação NUMERIC ~ CATEGORICAL\n\nAqui está a aparência da lista t.test_results quando aberta (Visualizada) no RStudio. Destacamos partes que são importantes para os exemplos nesta página.\n\nVocê pode ver no topo que a lista inteira é chamada de t.test_results e tem cinco elementos. Esses cinco elementos são nomeados age, wt_km, ht_cm, ct_blood, temp após cada variável que foi usada em um teste t com gender da linelist.\nCada um desses cinco elementos são listas, com elementos dentro deles, como p.value e conf.int. Alguns desses elementos como p.value são números únicos, enquanto alguns como estimate consistem em dois ou mais elementos (média no grupo f e média no grupo m).\n\n\n\n\n\n\n\n\n\n\nNota: Lembre-se que se você deseja aplicar uma função a apenas certas colunas em um data frame, você também pode simplesmente usar mutate() e across(), conforme explicado na página Limpeza de dados e principais funções. Abaixo está um exemplo de aplicação de as.character() apenas para as colunas “age”. Observe o posicionamento dos parênteses e vírgulas.\n\n# convertendo colunas com nome da coluna contendo \"idade\" para classe Character\nlinelist &lt;- linelist %&gt;% \n  mutate(across(.cols = contains(\"age\"), .fns = as.character))  \n\n\n\nExtraindo de listas\nComo map() produz uma saída da classe List (lista), vamos gastar algum tempo discutindo como extrair dados de listas usando funções acompanhantes do purrr. Para demonstrar isso, usaremos a lista t.test_results da seção anterior. Esta é uma lista de 5 listas - cada uma das 5 listas contém os resultados de um teste t entre uma coluna do data frame linelist e sua coluna binária gender. Veja a imagem na seção acima para uma visualização da estrutura da lista.\n\nNomes dos elementos\nPara extrair os nomes dos próprios elementos, simplesmente use names() do R base. Neste caso, usamos names() em t.test_results para retornar os nomes de cada sub-lista , que são os nomes das 5 variáveis que tiveram testes t realizados.\n\nnames(t.test_results)\n\n[1] \"age\"      \"wt_kg\"    \"ht_cm\"    \"ct_blood\" \"temp\"    \n\n\n\n\nElementos por nome ou posição\nPara extrair elementos da lista por nome ou por posição, você pode usar colchetes [[ ]] conforme descrito na página Introdução ao R. Abaixo usamos colchetes duplos para indexar a lista t.tests_results e exibir o primeiro elemento que é o resultado do teste t em age (idade).\n\nt.test_results[[1]] # primeiro elemento por posição\n\n\n    Welch Two Sample t-test\n\ndata:  .x by linelist$gender\nt = -21.3, df = 4902.9, p-value &lt; 2.2e-16\nalternative hypothesis: true difference in means between group f and group m is not equal to 0\n95 percent confidence interval:\n -7.544409 -6.272675\nsample estimates:\nmean in group f mean in group m \n       12.66085        19.56939 \n\nt.test_results[[1]][\"p.value\"] # retorna o elemento nomeado \"p.value\" do primeiro elemento\n\n$p.value\n[1] 2.350374e-96\n\n\nNo entanto, abaixo vamos demonstrar o uso das funções simples e flexíveis do purrr map() e pluck() para alcançar os mesmos resultados.\n\n\npluck()\npluck() extrai elementos por nome ou por posição. Por exemplo - para extrair os resultados do teste t para idade, você pode usar pluck() assim:\n\nt.test_results %&gt;% \n  pluck(\"age\")        # alternativamente, use pluck(1)\n\n\n    Welch Two Sample t-test\n\ndata:  .x by linelist$gender\nt = -21.3, df = 4902.9, p-value &lt; 2.2e-16\nalternative hypothesis: true difference in means between group f and group m is not equal to 0\n95 percent confidence interval:\n -7.544409 -6.272675\nsample estimates:\nmean in group f mean in group m \n       12.66085        19.56939 \n\n\nIndexe níveis mais profundos especificando os níveis adicionais com vírgulas. O código abaixo extrai o elemento chamado “p.value” (o p-valor)da lista age de dentro da lista t.test_results. Você também pode usar números em vez de nomes de caracteres.\n\nt.test_results %&gt;% \n  pluck(\"age\", \"p.value\")\n\n[1] 2.350374e-96\n\n\nVocê pode extrair esses elementos internos de todos os elementos de primeiro nível usando map() para executar a função pluck() em cada elemento de primeiro nível. Por exemplo, o código abaixo extrai os elementos “p.value” de todas as listas dentro de t.test_results. A lista de resultados do teste t é o .x iterado, pluck() é a função .f sendo iterada e o valor “p-value” é fornecido para a função.\n\nt.test_results %&gt;%\n  map(pluck, \"p.value\")   # retorna cada p-valor\n\n$age\n[1] 2.350374e-96\n\n$wt_kg\n[1] 2.664367e-182\n\n$ht_cm\n[1] 3.515713e-144\n\n$ct_blood\n[1] 0.4473498\n\n$temp\n[1] 0.5735923\n\n\nComo outra alternativa, map() oferece uma abreviação onde você pode escrever o nome do elemento entre aspas, e ele irá “arrancá-lo”. Se você usar map() a saída será uma lista, enquanto que se você usar map_chr() será um vetor de caractere nomeado e se você usar map_dbl() será um vetor numérico nomeado.\n\nt.test_results %&gt;% \n  map_dbl(\"p.value\")   # retorna o p-valor como um vetor numérico com nome\n\n          age         wt_kg         ht_cm      ct_blood          temp \n 2.350374e-96 2.664367e-182 3.515713e-144  4.473498e-01  5.735923e-01 \n\n\nVocê pode ler mais sobre pluck() em sua documentação purrr. Ele tem uma função irmã chuck() que retornará um erro em vez de NULL se um elemento não existir.\n\n\n\nConvertendo uma lista em um data frame\nEste é um tópico complexo - consulte a seção Recursos para tutoriais mais completos. No entanto, demonstraremos a conversão da lista de resultados do teste t em um data frame. Criaremos um data frame com colunas para a variável, seu p-valor e as médias dos dois grupos (masculino e feminino).\nAqui estão algumas das novas abordagens e funções que serão usadas:\n\nA função tibble() será usada para criar um tibble (como um data frame)\n\nEnvolvemos a função tibble() com chaves { } para evitar que todo o t.test_results seja armazenado como a primeira coluna do tibble\n\nDentro de tibble(), cada coluna é criada explicitamente, semelhante à sintaxe de mutate():\n\nO . representa t.test_results\nPara criar uma coluna com os nomes das variáveis do teste t (os nomes de cada elemento da lista) usamos names() conforme descrito acima\nPara criar uma coluna com os p-valores, usamos map_dbl() conforme descrito acima para extrair os elementos p.value e convertê-los em um vetor numérico\n\n\n\nt.test_results %&gt;% {\n  tibble(\n    variables = names(.),\n    p         = map_dbl(., \"p.value\"))\n  }\n\n# A tibble: 5 × 2\n  variables         p\n  &lt;chr&gt;         &lt;dbl&gt;\n1 age       2.35e- 96\n2 wt_kg     2.66e-182\n3 ht_cm     3.52e-144\n4 ct_blood  4.47e-  1\n5 temp      5.74e-  1\n\n\nMas agora vamos adicionar colunas contendo as médias para cada grupo (masculino e feminino).\nPrecisaríamos extrair o elemento estimate, mas na verdade ele contém dois elementos dentro dele (média no grupo f e média no grupo m). Portanto, não pode ser simplificado em um vetor com map_chr() ou map_dbl(). Em vez disso, usamos map(), que usado dentro de tibble() criará uma coluna da lista de classes dentro do tibble! Sim, isso é possível!\n\nt.test_results %&gt;% \n  {tibble(\n    variables = names(.),\n    p = map_dbl(., \"p.value\"),\n    means = map(., \"estimate\"))}\n\n# A tibble: 5 × 3\n  variables         p means       \n  &lt;chr&gt;         &lt;dbl&gt; &lt;named list&gt;\n1 age       2.35e- 96 &lt;dbl [2]&gt;   \n2 wt_kg     2.66e-182 &lt;dbl [2]&gt;   \n3 ht_cm     3.52e-144 &lt;dbl [2]&gt;   \n4 ct_blood  4.47e-  1 &lt;dbl [2]&gt;   \n5 temp      5.74e-  1 &lt;dbl [2]&gt;   \n\n\nDepois de ter essa coluna de lista, há várias funções tidyr (parte do tidyverse) que ajudam a “retangular” ou “desaninhar” essas colunas de “lista aninhada”. Leia mais sobre eles aqui, ou executando vignette(\"rectangle\"). Em resumo:\n\nunnest_wider() - dá a cada elemento de uma coluna de lista sua própria coluna\nunnest_longer() - dá a cada elemento de uma coluna de lista sua própria linha\nhoist() - funciona como unnest_wider() mas você especifica quais elementos serão desaninhados\n\nAbaixo, passamos o tibble para unnest_wider() especificando a coluna means do tibble (que é uma lista aninhada). O resultado é que means é substituído por duas novas colunas, cada uma refletindo os dois elementos que estavam anteriormente em cada célula means.\n\nt.test_results %&gt;% \n  {tibble(\n    variables = names(.),\n    p = map_dbl(., \"p.value\"),\n    means = map(., \"estimate\")\n    )} %&gt;% \n  unnest_wider(means)\n\n# A tibble: 5 × 4\n  variables         p `mean in group f` `mean in group m`\n  &lt;chr&gt;         &lt;dbl&gt;             &lt;dbl&gt;             &lt;dbl&gt;\n1 age       2.35e- 96              12.7              19.6\n2 wt_kg     2.66e-182              45.8              59.6\n3 ht_cm     3.52e-144             109.              142. \n4 ct_blood  4.47e-  1              21.2              21.2\n5 temp      5.74e-  1              38.6              38.6\n\n\n\n\nDescartar, manter e compactar listas\nComo trabalhar com purrr geralmente envolve listas, exploraremos brevemente algumas funções do purrr para modificar listas. Consulte a seção Recursos para tutoriais mais completos sobre as funções purrr.\n\nlist_modify() tem muitos usos, um dos quais pode ser remover um elemento da lista\nkeep() retém os elementos especificados para .p =, ou onde uma função fornecida para .p = é avaliada como TRUE\ndiscard() remove os elementos especificados para .p, ou onde uma função fornecida para .p = é avaliada como TRUE\ncompact() remove todos os elementos vazios\n\nAqui estão alguns exemplos usando a lista combined criada na seção acima em usando map() para importar e combinar vários arquivos (contém 6 data frames de linelist):\nElementos podem ser removidos por nome com list_modify() e definindo o nome igual a NULL.\n\ncombined %&gt;% \n  list_modify(\"Central Hospital\" = NULL)   # remove elemento da lista por nome\n\nVocê também pode remover elementos por critérios, fornecendo uma equação de “predicado” para .p = (uma equação que avalia como TRUE ou FALSE). Coloque um til ~ antes da função e use .x para representar o elemento da lista. Usando keep() os elementos da lista que forem avaliados como TRUE serão mantidos. Inversamente, se estiver usando discard(), os elementos da lista que forem avaliados como TRUE serão removidos.\n\n# mantenha apenas elementos de lista com mais de 500 linhas\ncombined %&gt;% \n  keep(.p = ~nrow(.x) &gt; 500)  \n\nNo exemplo abaixo, os elementos da lista são descartados se suas classes não forem data frames.\n\n# descartando elementos que não são data frame\ncombined %&gt;% \n  discard(.p = ~class(.x) != \"data.frame\")\n\nSua função de predição também pode referenciar elementos/colunas dentro de cada item da lista. Por exemplo, abaixo, os elementos da lista onde a média da coluna ct_blood é superior a 25 são descartados.\n\n# mantenha apenas elementos onde a média da coluna ct_blood é maior que 25\ncombined %&gt;% \n  discard(.p = ~mean(.x$ct_blood) &gt; 25)  \n\nEste comando remove todos os elementos vazios da lista:\n\n# remove todos os elementos vazios da lista\ncombined %&gt;% \n  compact()\n\n\n\npmap()\nESTA SEÇÃO ESTÁ EM CONSTRUÇÃO",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Iterações, loops e listas</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.pt.html#funções-apply",
    "href": "new_pages/iteration.pt.html#funções-apply",
    "title": "16  Iterações, loops e listas",
    "section": "16.4 funções Apply",
    "text": "16.4 funções Apply\nA família de funções “apply” é uma alternativa do R base ao purrr para operações iterativas. Você pode ler mais sobre eles aqui.",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Iterações, loops e listas</span>"
    ]
  },
  {
    "objectID": "new_pages/iteration.pt.html#recursos",
    "href": "new_pages/iteration.pt.html#recursos",
    "title": "16  Iterações, loops e listas",
    "section": "16.5 Recursos",
    "text": "16.5 Recursos\npara loops com Data Carpentry\nA página R for Data Science sobre iteração\nVinheta sobre gravação/leitura de arquivos Excel\nUm tutorial purrr por jennybc\nOutro purrr tutorial por Rebecca Barter\nUm tutorial purrr para map, pmap e imap\npurrr cheatsheet\ndicas e truques do purrr\nmanter e descartar",
    "crumbs": [
      "Gerenciamento de Dados",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Iterações, loops e listas</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.pt.html",
    "href": "new_pages/tables_descriptive.pt.html",
    "title": "17  Tabelas descritivas",
    "section": "",
    "text": "17.1 Preparação",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Tabelas descritivas</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.pt.html#preparação",
    "href": "new_pages/tables_descriptive.pt.html#preparação",
    "title": "17  Tabelas descritivas",
    "section": "",
    "text": "Carregue os pacotes R\nO código abaixo realiza o carregamento dos pacotes necessários para a análise dos dados. Neste manual, enfatizamos o uso da função p_load(), do pacman, que instala os pacotes, caso não estejam instalados, e os carrega no R para utilização. Também é possível carregar pacotes instalados utilizando a função library(), do r base. Para mais informações sobre os pacotes do R, veja a página Introdução ao R.\n\npacman::p_load(\n  rio,          # importa arquivos\n  here,         # localiza arquivos\n  skimr,        # gera visualização dos dados\n  tidyverse,    # gestão dos dados + gráficos no ggplot2 \n  gtsummary,    # resumo estatísticos e testes\n  rstatix,      # resumo e testes estatísticos\n  janitor,      # adiciona números absolutos e porcentagens às tabelas\n  scales,       # facilmente converte proporções para porcentagens\n  flextable     # converte tabelas para o formato de imagens\n  )\n\n\n\nImporte os dados no R\nNós iremos importar o banco de dados de casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar os passos abaixo, clique aqui para fazer o download do banco de dados ‘limpo’ (como arquivo .rds). Importe seus dados utilizando a função import() do pacote rio (esta função importa muitos tipos de arquivos, como .xlsx, .rds, .csv - veja a página Importar e exportar para detalhes).\n\n# importe o banco de dados limpo\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nAs primeiras 50 linhas do banco de dados são mostradas abaixo.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Tabelas descritivas</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.pt.html#explore-seus-dados",
    "href": "new_pages/tables_descriptive.pt.html#explore-seus-dados",
    "title": "17  Tabelas descritivas",
    "section": "17.2 Explore seus dados",
    "text": "17.2 Explore seus dados\n\nPacote skimr\nAo utilizar o pacote skimr, você pode obter um resumo detalhado e esteticamente agradável de cada variável do seu banco de dados. Leia mais sobre o skimr na sua página no github.\nAbaixo, a função skim() é aplicada a todos os dados do objeto linelist, criado no código acima. Após execução do código, uma visão geral dos dados e um resumo de cada coluna (por classe) são gerados.\n\n## obtenha informações sobre cada variável no banco de dados\nskim(linelist)\n\n\nData summary\n\n\nName\nlinelist\n\n\nNumber of rows\n5888\n\n\nNumber of columns\n30\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n13\n\n\nDate\n4\n\n\nfactor\n2\n\n\nnumeric\n11\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\ncase_id\n0\n1.00\n6\n6\n0\n5888\n0\n\n\noutcome\n1323\n0.78\n5\n7\n0\n2\n0\n\n\ngender\n278\n0.95\n1\n1\n0\n2\n0\n\n\nage_unit\n0\n1.00\n5\n6\n0\n2\n0\n\n\nhospital\n0\n1.00\n5\n36\n0\n6\n0\n\n\ninfector\n2088\n0.65\n6\n6\n0\n2697\n0\n\n\nsource\n2088\n0.65\n5\n7\n0\n2\n0\n\n\nfever\n249\n0.96\n2\n3\n0\n2\n0\n\n\nchills\n249\n0.96\n2\n3\n0\n2\n0\n\n\ncough\n249\n0.96\n2\n3\n0\n2\n0\n\n\naches\n249\n0.96\n2\n3\n0\n2\n0\n\n\nvomit\n249\n0.96\n2\n3\n0\n2\n0\n\n\ntime_admission\n765\n0.87\n5\n5\n0\n1072\n0\n\n\n\nVariable type: Date\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nmedian\nn_unique\n\n\n\n\ndate_infection\n2087\n0.65\n2014-03-19\n2015-04-27\n2014-10-11\n359\n\n\ndate_onset\n256\n0.96\n2014-04-07\n2015-04-30\n2014-10-23\n367\n\n\ndate_hospitalisation\n0\n1.00\n2014-04-17\n2015-04-30\n2014-10-23\n363\n\n\ndate_outcome\n936\n0.84\n2014-04-19\n2015-06-04\n2014-11-01\n371\n\n\n\nVariable type: factor\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nordered\nn_unique\ntop_counts\n\n\n\n\nage_cat\n86\n0.99\nFALSE\n8\n0-4: 1095, 5-9: 1095, 20-: 1073, 10-: 941\n\n\nage_cat5\n86\n0.99\nFALSE\n17\n0-4: 1095, 5-9: 1095, 10-: 941, 15-: 743\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\ngeneration\n0\n1.00\n16.56\n5.79\n0.00\n13.00\n16.00\n20.00\n37.00\n▁▆▇▂▁\n\n\nage\n86\n0.99\n16.07\n12.62\n0.00\n6.00\n13.00\n23.00\n84.00\n▇▅▁▁▁\n\n\nage_years\n86\n0.99\n16.02\n12.64\n0.00\n6.00\n13.00\n23.00\n84.00\n▇▅▁▁▁\n\n\nlon\n0\n1.00\n-13.23\n0.02\n-13.27\n-13.25\n-13.23\n-13.22\n-13.21\n▅▃▃▆▇\n\n\nlat\n0\n1.00\n8.47\n0.01\n8.45\n8.46\n8.47\n8.48\n8.49\n▅▇▇▇▆\n\n\nwt_kg\n0\n1.00\n52.64\n18.58\n-11.00\n41.00\n54.00\n66.00\n111.00\n▁▃▇▅▁\n\n\nht_cm\n0\n1.00\n124.96\n49.52\n4.00\n91.00\n129.00\n159.00\n295.00\n▂▅▇▂▁\n\n\nct_blood\n0\n1.00\n21.21\n1.69\n16.00\n20.00\n22.00\n22.00\n26.00\n▁▃▇▃▁\n\n\ntemp\n149\n0.97\n38.56\n0.98\n35.20\n38.20\n38.80\n39.20\n40.80\n▁▂▂▇▁\n\n\nbmi\n0\n1.00\n46.89\n55.39\n-1200.00\n24.56\n32.12\n50.01\n1250.00\n▁▁▇▁▁\n\n\ndays_onset_hosp\n256\n0.96\n2.06\n2.26\n0.00\n1.00\n1.00\n3.00\n22.00\n▇▁▁▁▁\n\n\n\n\n\nVocê também pode usar a função summary(), do R base, para obter informações sobre o banco de dados inteiro, mas os resultados obtidos podem ser mais difíceis de visualizar do que utilizando o skimr. O resultado da análise com summary() não é mostrado abaixo, visando poupar espaço na página.\n\n## obtenha informações sobre cada coluna no banco de dados\nsummary(linelist)\n\n\n\nResumos estatísticos\nVocê pode utilizar as funções do R base para obter resumos estatísticos de uma coluna com dados numéricos. Boa parte das análises estatísticas mais úteis com este tipo de coluna pode ser obtido utilizando a função summary(), como mostrado abaixo. Observe que o nome da tabela de dados e da coluna (linelist) precisam ser especificados como mostrado abaixo.\n\nsummary(linelist$age_years)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00    6.00   13.00   16.02   23.00   84.00      86 \n\n\nVocê pode obter e salvar uma parte específica da análise utilizando o indexador com colchetes [ ]:\n\nsummary(linelist$age_years)[[2]] # obtém apenas o resultado da análise no índice [2]\n\n[1] 6\n\n# alternativa equivalente ao indexador [2], utilizando o nome do campo:\n# summary(linelist$age_years)[[\"1st Qu.\"]]  \n\nVocê pode obter estatísticas individuais com outras funções do R base, como max(), min(), median(), mean(), quantile(), sd(), e range(). Veja a página Introdução ao R para uma lista completa.\nCUIDADO: Caso seus dados contenham campos em branco, o R quer que você saiba disso e irá gerar NA na análise. Isso só não irá ocorrer caso você ‘peça’ para o R ignorar esses campos em branco nas funções matemáticas acima. Isso pode ser realizado com o argumentona.rm = TRUE.\nVocê pode usar a função get_summary_stats(), do rstatix, para obter o resumo estatístico em formato de quadro de dados (data frame). Isso pode ser útil na execução de comandos posteriores ou para criação de gráficos com os valores. Veja a página Testes estatísticos simples para mais detalhes do pacote rstatix e suas funções.\n\nlinelist %&gt;% \n  get_summary_stats(\n    age, wt_kg, ht_cm, ct_blood, temp,  # variáveis para realizar o cálculo\n    type = \"common\")                    # tipo do resumo estatístico a ser gerado\n\n# A tibble: 5 × 10\n  variable     n   min   max median   iqr  mean     sd    se    ci\n  &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 age       5802   0    84     13      17  16.1 12.6   0.166 0.325\n2 wt_kg     5888 -11   111     54      25  52.6 18.6   0.242 0.475\n3 ht_cm     5888   4   295    129      68 125.  49.5   0.645 1.26 \n4 ct_blood  5888  16    26     22       2  21.2  1.69  0.022 0.043\n5 temp      5739  35.2  40.8   38.8     1  38.6  0.977 0.013 0.025",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Tabelas descritivas</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.pt.html#tbl_janitor",
    "href": "new_pages/tables_descriptive.pt.html#tbl_janitor",
    "title": "17  Tabelas descritivas",
    "section": "17.3 Pacote janitor",
    "text": "17.3 Pacote janitor\nO pacote janitor contém a função tabyl(), que gera tabulações simples e tabulações cruzadas que podem ser modificadas com funções auxiliares para mostrarem porcentagens, proporções, contagens, etc.\nAbaixo, nós utilizamos as funções do janitor no banco de dados linelist, criado anteriormente, e visualizamos o resultado da análise. Se necessário, é possível salvar as tabelas geradas utilizando o operador &lt;-, e atribuindo elas a um novo objeto no R.\n\nBásico do tabyl\nO uso do tabyl(), no modo padrão, em uma coluna específica produz uma tabela com os valores únicos desta coluna, suas contagens, e “porcentagens” (proporções, na realidade). Como as proporções podem ter muitos dígitos, é possível ajustar o número de casas decimais com a função adorn_rounding(), descrita abaixo.\n\nlinelist %&gt;% tabyl(age_cat)\n\n age_cat    n     percent valid_percent\n     0-4 1095 0.185971467   0.188728025\n     5-9 1095 0.185971467   0.188728025\n   10-14  941 0.159816576   0.162185453\n   15-19  743 0.126188859   0.128059290\n   20-29 1073 0.182235054   0.184936229\n   30-49  754 0.128057065   0.129955188\n   50-69   95 0.016134511   0.016373664\n     70+    6 0.001019022   0.001034126\n    &lt;NA&gt;   86 0.014605978            NA\n\n\nComo observado acima, se existirem campos em branco na coluna analisada, eles são mostrados em uma linha chamada &lt;NA&gt;. Você pode omitir estes campos com o atributo show_na = FALSE. Se não existirem campos em branco, essa linha não irá aparecer. Se estes campos existirem, todas as proporções são geradas como ‘brutas’ (coluna ‘percent’ gerada, em que a quantidade de campos NA está inclusa no denominador) e ‘válidas’ (coluna ‘valid_percent’, onde a quantidade de campos NA não é considerada no cálculo).\nSe a coluna for um fator (da classe Factor) e apenas alguns níveis dessa classe estiverem presentes em seus dados, todos os níveis desta classe serão mostrados na tabela de análise. Você pode omitir essa característica ao usar o atributo show_missing_levels = FALSE. Leia mais na página Fatores.\n\n\nTabulação cruzada (tabela de contingência)\nAs quantidades absolutas das tabulações cruzadas são obtidas ao adicionarmos uma ou mais variáveis dentro da função tabyl(). Observe que agora apenas os números absolutos são obtidos - proporções e porcentagens podem ser adicionadas à análise com etapas adicionais mostradas abaixo.\n\nlinelist %&gt;% tabyl(age_cat, gender)\n\n age_cat   f   m NA_\n     0-4 640 416  39\n     5-9 641 412  42\n   10-14 518 383  40\n   15-19 359 364  20\n   20-29 468 575  30\n   30-49 179 557  18\n   50-69   2  91   2\n     70+   0   5   1\n    &lt;NA&gt;   0   0  86\n\n\n\n\nPersonalizando o tabyl\nUse as funções “adorn”, do janitor, para adicionar ao resultado da análise as colunas de números absolutos assim como converter para proporções, percentuais, ou ajustar o formato de gerado. Você utilizar essas funções nas tabelas geradas pelo tabyl frequentemente.\n\n\n\n\n\n\n\nFunção\nResultado\n\n\n\n\nadorn_totals()\nAdiciona uma linha/coluna com os totais (where = “row”, “col”, or “both”). “row”: linhas; “col”: colunas; “both”: ambas. Atribua ao campo name = o nome “Total”.\n\n\nadorn_percentages()\nConverte contagens absolutas para proporções, escolhendo o denominator = “row”, “col”, or “all”.\n\n\nadorn_pct_formatting()\nConverte proporções para percentuais. Especifique o número de casas decimais com o atributo digits =. Remova o símbolo “%” com o atributo affix_sign = FALSE.\n\n\nadorn_rounding()\nArredonde as proporções utilizando digits = nº de casas decimais. Para arredondar percentuais, utilize a função adorn_pct_formatting() com digits =.\n\n\nadorn_ns()\nAdicione a tabela as quantidades absolutas com as proporções ou porcentagens. Utilize o atributo position = “rear” para mostrar as quantidades em parênteses, ou “front” para colocar as porcentagens em parênteses.\n\n\nadorn_title()\nAdiciona títulos à tabela gerada através dos argumentos row_name = e/ou col_name =\n\n\n\nPreste atenção na ordem em que você utiliza estas funções. Abaixo estão alguns exemplos:\nUma tabela simples com porcentagens no lugar das proporções, que são padrão.\n\nlinelist %&gt;%               # fonte dos dados\n  tabyl(age_cat) %&gt;%       # tabula números absolutos e proporções por idade\n  adorn_pct_formatting()   # converte as proporções para porcentagens\n\n age_cat    n percent valid_percent\n     0-4 1095   18.6%         18.9%\n     5-9 1095   18.6%         18.9%\n   10-14  941   16.0%         16.2%\n   15-19  743   12.6%         12.8%\n   20-29 1073   18.2%         18.5%\n   30-49  754   12.8%         13.0%\n   50-69   95    1.6%          1.6%\n     70+    6    0.1%          0.1%\n    &lt;NA&gt;   86    1.5%             -\n\n\nUma tabela cruzada com os números absolutos e porcentagens de cada linha.\n\nlinelist %&gt;%                                  \n  tabyl(age_cat, gender) %&gt;%                  # contagens absolutas e proporções cruzando idade e gênero\n  adorn_totals(where = \"row\") %&gt;%             # adiciona uma linha chamada 'Total', com os totais\n  adorn_percentages(denominator = \"row\") %&gt;%  # converte os números absolutos para proporções\n  adorn_pct_formatting(digits = 1)            # converte as proporções para porcentagens\n\n age_cat     f     m    NA_\n     0-4 58.4% 38.0%   3.6%\n     5-9 58.5% 37.6%   3.8%\n   10-14 55.0% 40.7%   4.3%\n   15-19 48.3% 49.0%   2.7%\n   20-29 43.6% 53.6%   2.8%\n   30-49 23.7% 73.9%   2.4%\n   50-69  2.1% 95.8%   2.1%\n     70+  0.0% 83.3%  16.7%\n    &lt;NA&gt;  0.0%  0.0% 100.0%\n   Total 47.7% 47.6%   4.7%\n\n\nO código abaixo modifica uma tabela cruzada de dados de forma que as quantidades absolutas e os percentuais sejam mostrados.\n\nlinelist %&gt;%                                  # fonte dos dados\n  tabyl(age_cat, gender) %&gt;%                  # geração da tabela cruzada\n  adorn_totals(where = \"row\") %&gt;%             # adiciona uma linha \"Total\", com os totais\n  adorn_percentages(denominator = \"col\") %&gt;%  # converte as quantidades absolutas para proporções\n  adorn_pct_formatting() %&gt;%                  # converte as proporções para porcentagens\n  adorn_ns(position = \"front\") %&gt;%            # mostra os dados como: \"n° absoluto (porcentagem)\"\n  adorn_title(                                # nomeia os títulos das colunas e linhas\n    row_name = \"Age Category\",\n    col_name = \"Gender\")\n\n                      Gender                            \n Age Category              f              m          NA_\n          0-4   640  (22.8%)   416  (14.8%)  39  (14.0%)\n          5-9   641  (22.8%)   412  (14.7%)  42  (15.1%)\n        10-14   518  (18.5%)   383  (13.7%)  40  (14.4%)\n        15-19   359  (12.8%)   364  (13.0%)  20   (7.2%)\n        20-29   468  (16.7%)   575  (20.5%)  30  (10.8%)\n        30-49   179   (6.4%)   557  (19.9%)  18   (6.5%)\n        50-69     2   (0.1%)    91   (3.2%)   2   (0.7%)\n          70+     0   (0.0%)     5   (0.2%)   1   (0.4%)\n         &lt;NA&gt;     0   (0.0%)     0   (0.0%)  86  (30.9%)\n        Total 2,807 (100.0%) 2,803 (100.0%) 278 (100.0%)\n\n\n\n\nConvertendo a tabela do tabyl para uma imagem\nPor padrão, o tabyl vai gerar uma tabela ‘crua’ no seu console do R.\nAdicionalmente, você pode obter a tabela no tabyl e utiliza-la nas funções do pacote flextable, ou outros pacotes similares, para gerar uma tabela no formato de imagem no RStudio Viewer, que pode ser exportada nos formatos .png, .jpeg, .html, etc. Isto é discutido na página Tabelas para apresentação. Observe que, caso você gere a tabela desta forma e utilize a função adorn_titles(), você precisa aplicar o atributo placement = \"combined\".\n\nlinelist %&gt;%                                  # fonte dos dados\n  tabyl(age_cat, gender) %&gt;%                  # geração da tabela cruzada\n  adorn_totals(where = \"row\") %&gt;%             # adiciona uma linha \"Total\", com os totais\n  adorn_percentages(denominator = \"col\") %&gt;%  # converte as quantidades absolutas para proporções\n  adorn_pct_formatting() %&gt;%                  # converte as proporções para porcentagens\n  adorn_ns(position = \"front\") %&gt;% \n  adorn_title(\n    row_name = \"Age Category\",\n    col_name = \"Gender\",\n    placement = \"combined\") %&gt;% # isto é necessário para gerar a tabela como imagem\n  flextable::flextable() %&gt;%    # converte a tabela em imagem\n  flextable::autofit()          # formata a tabela em linha por coluna\n\nAge Category/GenderfmNA_0-4640  (22.8%)416  (14.8%)39  (14.0%)5-9641  (22.8%)412  (14.7%)42  (15.1%)10-14518  (18.5%)383  (13.7%)40  (14.4%)15-19359  (12.8%)364  (13.0%)20   (7.2%)20-29468  (16.7%)575  (20.5%)30  (10.8%)30-49179   (6.4%)557  (19.9%)18   (6.5%)50-692   (0.1%)91   (3.2%)2   (0.7%)70+0   (0.0%)5   (0.2%)1   (0.4%)0   (0.0%)0   (0.0%)86  (30.9%)Total2,807 (100.0%)2,803 (100.0%)278 (100.0%)\n\n\n\n\nPersonalizando outras tabelas com funções ‘adorn’\nVocê pode utilizar as funções adorn_*(), do pacote janitor, em outras tabelas, como as criadas pelas funções summarise() e count() do pacote dplyr, ou table() do R base. Simplesmente aplique a tabela gerada à função desejada do pacote janitor. Por exemplo:\n\nlinelist %&gt;% \n  count(hospital) %&gt;%   # função do pacote dplyr\n  adorn_totals()        # função do pacote janitor\n\n                             hospital    n\n                              Ausente 1469\n                     Central Hospital  454\n                    Military Hospital  896\n                                Other  885\n                        Port Hospital 1762\n St. Mark's Maternity Hospital (SMMH)  422\n                                Total 5888\n\n\n\n\nSalvando a tabela do tabyl\nSe você converteu a tabela para uma imagem ‘bonita’ utilizando um pacote como flextable, você pode salvar ela com as funções desse pacote - utilizando as funções save_as_html(), save_as_word(), save_as_ppt(), e save_as_image() do flextable (discutido em detalhes na página Tabelas para apresentação). No código abaixo, a tabela é salva em um documento Word, onde poderá ser editada manualmente.\n\nlinelist %&gt;%\n  tabyl(age_cat, gender) %&gt;% \n  adorn_totals(where = \"col\") %&gt;% \n  adorn_percentages(denominator = \"col\") %&gt;% \n  adorn_pct_formatting() %&gt;% \n  adorn_ns(position = \"front\") %&gt;% \n  adorn_title(\n    row_name = \"Faixa-Etária\",\n    col_name = \"Gênero\",\n    placement = \"combined\") %&gt;% \n  flextable::flextable() %&gt;%                     # converte para imagem\n  flextable::autofit() %&gt;%                       # garante apenas uma linha por coluna\n  flextable::save_as_docx(path = \"tabyl.docx\")   # salva a imagem como um documento Word no endereço do documento (filepath)\n\n\n\n\n\n\n\n\n\n\n\n\nAnálises estatísticas\nComo mostrado abaixo, você pode aplicar testes estatísticos nas tabelas dos tabyls, como chisq.test() ou fisher.test() do pacote stats. Observe que campos em branco não são permitidos, devendo serem excluídos do tabyl com o atributo show_na = FALSE.\n\nage_by_outcome &lt;- linelist %&gt;% \n  tabyl(age_cat, outcome, show_na = FALSE) \n\nchisq.test(age_by_outcome)\n\n\n    Pearson's Chi-squared test\n\ndata:  age_by_outcome\nX-squared = 6.4931, df = 7, p-value = 0.4835\n\n\nVeja a página Testes estatísticos simples para mais códigos e dicas sobre estatística.\n\n\nOutras dicas\n\nUtilize o argumento na.rm = TRUE para excluir campos em brancos de qualquer um dos cálculos acima.\n\nSe utilizar qualquer função adorn_*() em tabelas criadas com outra função além do tabyl(), você pode especificar a(s) coluna(s) para aplicar o “adorn”, como em adorn_percentage(,,,c(cases,deaths)) (onde a porcentagem será adicionada somente no quarto argumento da análise). Como a sintaxe não é simples, considere utilizar a função summarise() em seu lugar.\n\nVocê pode obter mais detalhes na página do janitor e nesse resumo do tabyl.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Tabelas descritivas</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.pt.html#pacote-dplyr",
    "href": "new_pages/tables_descriptive.pt.html#pacote-dplyr",
    "title": "17  Tabelas descritivas",
    "section": "17.4 Pacote dplyr",
    "text": "17.4 Pacote dplyr\ndplyr faz parte dos pacotes tidyverse, sendo uma ferramenta de gestão de dados muito comum. Criar tabelas com as funções summarise() e count() do dplyr é uma abordagem útil para obter resumos estatísticos, resumos por grupos, ou para utilizá-las no ggplot().\nA função summarise() cria uma nova tabela resumo dos dados. Se os dados não são agrupados, esta função gera uma tabela de dados de uma linha com os resumos estatísticos desejados do banco de dados inteiro. Se os dados são agrupados, a nova tabela terá um linha por grupo (veja a página Agrupando dados).\nDentro dos parênteses da função summarise(), você pode incluir os nomes de cada nova coluna, seguido pelo sinal de igual e uma função estatística a ser utilizada.\nDICA: A função summarise pode ser escrita na forma do inglês britânico e americano (summarise() e summarize()).\n\nObtendo as quantidades absolutas\nA função mais simples para utilizar dentro de summarise() é a função n(). Não insira nada dentro dos parênteses para a função contar o total de linhas.\n\nlinelist %&gt;%                 # inicia com o banco de dados 'linelist'\n  summarise(n_rows = n())    # gera uma nova tabela com uma coluna contendo o número de linhas\n\n  n_rows\n1   5888\n\n\nEsta análise é mais interessante se agruparmos os dados antes.\n\nlinelist %&gt;% \n  group_by(age_cat) %&gt;%     # agrupe os dados por valores únicos da coluna 'age_cat'\n  summarise(n_rows = n())   # gera o número de linhas *por grupo*\n\n# A tibble: 9 × 2\n  age_cat n_rows\n  &lt;fct&gt;    &lt;int&gt;\n1 0-4       1095\n2 5-9       1095\n3 10-14      941\n4 15-19      743\n5 20-29     1073\n6 30-49      754\n7 50-69       95\n8 70+          6\n9 &lt;NA&gt;        86\n\n\nO código acima pode ser encurtado ao utilizar a função count() em vez de summarise() e n(). A função count() faz o seguinte:\n\nAgrupa os dados de acordo com as colunas escolhidas\n\nGera um resumo destes grupos utilizando a função n() (criando a coluna n)\n\nDesagrupa os dados\n\n\nlinelist %&gt;% \n  count(age_cat)\n\n  age_cat    n\n1     0-4 1095\n2     5-9 1095\n3   10-14  941\n4   15-19  743\n5   20-29 1073\n6   30-49  754\n7   50-69   95\n8     70+    6\n9    &lt;NA&gt;   86\n\n\nVocê pode mudar o nome da coluna resultante n para um diferente, ao especificar o novo nome com o atributo name =.\nOs resultados das contagens de duas ou mais colunas usadas para agrupar os dados são gerados no formato “longo”, com as contagens na coluna n. Veja a página sobre Pivotando dados para aprender sobre as tabelas nos formatos “longos” e “amplos”.\n\nlinelist %&gt;% \n  count(age_cat, outcome)\n\n   age_cat outcome   n\n1      0-4   Death 471\n2      0-4 Recover 364\n3      0-4    &lt;NA&gt; 260\n4      5-9   Death 476\n5      5-9 Recover 391\n6      5-9    &lt;NA&gt; 228\n7    10-14   Death 438\n8    10-14 Recover 303\n9    10-14    &lt;NA&gt; 200\n10   15-19   Death 323\n11   15-19 Recover 251\n12   15-19    &lt;NA&gt; 169\n13   20-29   Death 477\n14   20-29 Recover 367\n15   20-29    &lt;NA&gt; 229\n16   30-49   Death 329\n17   30-49 Recover 238\n18   30-49    &lt;NA&gt; 187\n19   50-69   Death  33\n20   50-69 Recover  38\n21   50-69    &lt;NA&gt;  24\n22     70+   Death   3\n23     70+ Recover   3\n24    &lt;NA&gt;   Death  32\n25    &lt;NA&gt; Recover  28\n26    &lt;NA&gt;    &lt;NA&gt;  26\n\n\n\n\nMostre todos os níveis da classe factor\nSe você estiver tabelando uma coluna da classe factor, é possível fazer com que todos os níveis dessa classe sejam mostrados (não apenas os níveis presentes nos dados) ao adicionar o atributo .drop = FALSE dentro das funções summarise() ou count().\nEstá técnica é útil para padronizar suas tabelas/gráficos. Por exemplo, se você estiver criando figuras para diferentes sub-grupos, ou precisar criar um mesmo tipo de figura para relatórios de rotina. Em cada uma dessas circuntâncias, os valores nos dados podem variar, mas é possível definir níveis que continuem constantes.\nVeja a página sobre Fatores para mais informações.\n\n\nProporções\nColunas com proporções podem ser criadas ao canalizar (pipe) a tabela gerada para a função mutate(). A partir disso, as proporções podem ser calculadas através da divisão das quantidades absolutas geradas na coluna de contagem (n por padrão), divididos pela soma (sum()) de todas as contagens nessa coluna.\nObserve que, neste caso, utilizar a função sum() dentro do mutate() irá gerar a soma da coluna n inteira, e utilizá-la como denominador no cálculo das proporções. Como explicado na página de agrupamento de dados, se sum() for utilizada em dados agrupados (por exemplo, se o mutate() for imediatamente seguido pela função group_by()), as somas serão realizadas por grupos. Como dito acima, a função count() termina as suas ações realizando o desagrupamento dos dados. Assim, neste cenário, nós obtemos as proporções da coluna inteira, e não apenas dos grupos.\nPara facilmente mostrar os percentuais, é possível incorporar a proporção gerada dentro da função percent(), do pacote scales (tenha em mente que isso converte a porcentagem para a classe character).\n\nage_summary &lt;- linelist %&gt;% \n  count(age_cat) %&gt;%                     # agrupe e conte por gênero (produz a coluna 'n'), finaliza desagrupando os dados\n  mutate(                                # cria a porcentagem da coluna - observe o denominador\n    percent = scales::percent(n / sum(n))) \n\n# print\nage_summary\n\n  age_cat    n percent\n1     0-4 1095  18.60%\n2     5-9 1095  18.60%\n3   10-14  941  15.98%\n4   15-19  743  12.62%\n5   20-29 1073  18.22%\n6   30-49  754  12.81%\n7   50-69   95   1.61%\n8     70+    6   0.10%\n9    &lt;NA&gt;   86   1.46%\n\n\nAbaixo, um método para calcular proporções dentro dos grupos é mostrado. Esta metodologia utiliza os diferentes níveis de agrupamento e desagrupamento de dados. Primeiro, os dados são agrupados de acordo com o outcome, utilizando a função group_by(). Então, a função count() é aplicada. Essa função realiza mais agrupamentos dos dados utilizando a variável age_cat, e gera contagens para cada combinação outcome-age-cat. Lembre-se que, ao finalizar o processo, a função count() também desagrupa os grupos age_cat. Assim, o único grupo de dados restante é o agrupamento inicial pelo outcome. Assim, a etapa final em que as proporções são calculadas (denominador sum(n)) é realizada com o grupo outcome.\n\nage_by_outcome &lt;- linelist %&gt;%                  # inicie com os dados do linelist\n  group_by(outcome) %&gt;%                         # agrupe por outcome \n  count(age_cat) %&gt;%                            # agrupe e conte por age_cat, e então remova os grupos age_cat\n  mutate(percent = scales::percent(n / sum(n))) # calcule as porcentagem - repare que o denominador é o grupo outcome\n\n\n\n\n\n\n\n\n\nVisualização dos dados\nUtilizar a função ggplot() com os dados de uma tabela no formato “longo”, como a mostrada acima, é relativamente simples. Esses dados, no formato “longo”, são facilmente aceitos pelo ggplot(). Veja mais exemplos nas páginas básico do ggplot e dicas do ggplot.\n\nlinelist %&gt;%                      # inicie com a linelist\n  count(age_cat, outcome) %&gt;%     # agrupe e tabule as contagens utilizando duas variáveis\n  ggplot()+                       # utilize a tabulação gerada no ggplot\n    geom_col(                     # crie um gráfico de barras\n      mapping = aes(   \n        x = outcome,              # mapeie o grupo outcome para o eixo x\n        fill = age_cat,           # mapeie o grupo age_cat para o fill\n        y = n))                   # mapeie as contagens (coluna 'n') para o eixo y\n\n\n\n\n\n\n\n\n\n\nResumo estatístico\nUma das principais vantagens do pacote dplyr e da função summarise() é a habilidade deles gerarem resumos estatísticos mais avançados, como median(), mean(), max(), min(), sd() (desvio padrão), e percentis. Você também pode utilizar a função sum() para contar o número de linhas que cumprem certos critérios lógicos. Como mostrado acima, essas informações podem ser obtidas com todo o banco de dados, ou por grupos.\nA sintaxe é a mesma - dentro dos parênteses da função summarise(), você adiciona os nomes de cada nova coluna resumo, seguido pelos sinais de igual e a função estatística a ser realizada. Dentro da função estatística, escolha a(s) coluna(s) para serem utilizadas no cálculo, e qualquer outro argumento relevante (exemplo: na.rm = TRUE para boa parte das funções matemáticas).\nComo dito acima, a função sum() também pode ser utilizada para obter o número de linhas que cumprem certos critérios lógicos. São contadas apenas as linhas que forem verdade (TRUE) para os critérios em parênteses. Por exemplo:\n\nsum(age_years &lt; 18, na.rm=T)\n\nsum(gender == \"male\", na.rm=T)\n\nsum(response %in% c(\"Likely\", \"Very Likely\"))\n\nAbaixo, os dados do linelist são analisados para avaliar os dias entre o início dos sintomas e a admissão no hospital (coluna days_onset_hosp), de acordo com o hospital.\n\nsummary_table &lt;- linelist %&gt;%                                        # inicie com o linelist, salvando os novos dados como um novo objeto\n  group_by(hospital) %&gt;%                                             # agrupe todos os cálculos por hospital\n  summarise(                                                         # apenas as colunas abaixo serão geradas\n    cases       = n(),                                                # n° de casos por grupo\n    delay_max   = max(days_onset_hosp, na.rm = T),                    # tempo máximo entre o ínicio dos sintomas e a admissão\n    delay_mean  = round(mean(days_onset_hosp, na.rm=T), digits = 1),  # tempo médio, arredondado\n    delay_sd    = round(sd(days_onset_hosp, na.rm = T), digits = 1),  # desvio padrão do intervalo de tempo, arredondado\n    delay_3     = sum(days_onset_hosp &gt;= 3, na.rm = T),               # n° de acsos com intervalo igual ou maior à 3 dias\n    pct_delay_3 = scales::percent(delay_3 / cases)                    # gera nova coluna convertendo o delay_3 em porcentagem\n  )\n\nsummary_table  # exporte a tabela\n\n# A tibble: 6 × 7\n  hospital               cases delay_max delay_mean delay_sd delay_3 pct_delay_3\n  &lt;chr&gt;                  &lt;int&gt;     &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;   &lt;int&gt; &lt;chr&gt;      \n1 Ausente                 1469        22        2.1      2.3     399 27%        \n2 Central Hospital         454        12        1.9      1.9     108 24%        \n3 Military Hospital        896        15        2.1      2.4     253 28%        \n4 Other                    885        18        2        2.2     234 26%        \n5 Port Hospital           1762        16        2.1      2.2     470 27%        \n6 St. Mark's Maternity …   422        18        2.1      2.3     116 27%        \n\n\nAlgumas dicas:\n\nUse a função sum() com uma expressão lógica para quantificar linhas que cumprem certos critérios (==)\n\nRepare no uso do argumento na.rm = TRUE dentro de funções matemáticas como sum(). Seu uso impede que NA seja gerado caso existam campos em branco\n\nUse a função percent(), do pacote scales, para facilmente obter as porcentagens\n\nEscolha accuracy = para 0.1 ou 0.01 para garantir 1 ou 2 vírgulas decimais, respectivamente\n\n\nUse a função round(), do pacote R base, para arredondar e especificar quantidade de casas decimais\n\nPara obter dados estatísticos do banco de dados completo, utilize a função summarise() sem a função group_by()\n\nVocê pode criar colunas para realizar cálculos futuros (ex.: como denominadores), que podem ser, posteriormente, retiradas da sua tabela de dados com a função select().\n\n\n\nEstatísticas condicionais\nVocê pode querer realizar análises estatísticas condicionais - por exemplo, a quantidade de linhas que cumprem certos critérios. Isto pode ser feito ao utilizar os colchetes [ ] para especificar os grupos desejados dentro de uma coluna. No código abaixo, a temperatura máxima dos pacientes com e sem febre é obtida. Entranto, neste caso, é melhor criar uma nova coluna utilizando as funções group_by() e pivot_wider() (como demonstrado abaixo).\n\nlinelist %&gt;% \n  group_by(hospital) %&gt;% \n  summarise(\n    max_temp_fvr = max(temp[fever == \"yes\"], na.rm = T),\n    max_temp_no = max(temp[fever == \"no\"], na.rm = T)\n  )\n\n# A tibble: 6 × 3\n  hospital                             max_temp_fvr max_temp_no\n  &lt;chr&gt;                                       &lt;dbl&gt;       &lt;dbl&gt;\n1 Ausente                                      40.6        38  \n2 Central Hospital                             40.4        38  \n3 Military Hospital                            40.5        38  \n4 Other                                        40.8        37.9\n5 Port Hospital                                40.6        38  \n6 St. Mark's Maternity Hospital (SMMH)         40.6        37.9\n\n\n\n\nUnindo colunas\nA função str_glue(), do pacote stringr, é útil para combinar valores de diferentes colunas em uma nova coluna. Geralmente, essa função é aplicada após utilizar a função summarise().\nNa página sobre Caracteres e strings, várias opções para combinar colunas são discutidas, incluindo as funções unite() e paste0(). Entretanto, nós recomendamos a função str_glue() por ser mais flexível do que unite() e possuir uma sintaxe mais simples do que paste0().\nAbaixo, a tabela summary_table (criada acima) é modificada de forma que as colunas delay_mean e delay_sd sejam combinadas. A nova coluna é gerada com os dados formatados utilizando parênteses, e as colunas utilizadas são removidas.\nEntão, para tornar a coluna mais apresentável, uma linha com os totais é adicionada com a função adorn_totals(), do pacote janitor (que ignora colunas não-numéricas). Finalmente, nós utilizamos a função select(), do pacote dplyr, para reordenar as colunas e renomeá-las como desejado.\nTambém é possível utilizar as funções do flextable para exportar a tabela para Word, .png, .jpeg, .html, Powerpoint, RMarkdown, etc.! (veja a página Tabelas para apresentações).\n\nsummary_table %&gt;% \n  mutate(delay = str_glue(\"{delay_mean} ({delay_sd})\")) %&gt;%  # crie uma nova coluna ao combinar e formatar valores de outras colunas\n  select(-c(delay_mean, delay_sd)) %&gt;%                       # remova as duas colunas utilizadas   \n  adorn_totals(where = \"row\") %&gt;%                            # adiciona uma linha com os totais\n  select(                                                    # reorganize e renomeie as colunas\n    \"Nome do Hospital\"   = hospital,\n    \"Casos\"           = cases,\n    \"Atraso máximo\"       = delay_max,\n    \"Média (dp)\"       = delay,\n    \"Atraso 3+ dias\"   = delay_3,\n    \"% atrasos 3+ dias\" = pct_delay_3\n    )\n\n                     Nome do Hospital Casos Atraso máximo Média (dp)\n                              Ausente  1469            22  2.1 (2.3)\n                     Central Hospital   454            12  1.9 (1.9)\n                    Military Hospital   896            15  2.1 (2.4)\n                                Other   885            18    2 (2.2)\n                        Port Hospital  1762            16  2.1 (2.2)\n St. Mark's Maternity Hospital (SMMH)   422            18  2.1 (2.3)\n                                Total  5888           101          -\n Atraso 3+ dias % atrasos 3+ dias\n            399               27%\n            108               24%\n            253               28%\n            234               26%\n            470               27%\n            116               27%\n           1580                 -\n\n\n\nPercentis\nO cálculo dos percentis e quantis no dplyr merece uma menção especial. Para obter os quantis, utilize a função quantile() com os intervalos padrões, ou especifique os valores alterando o atributo probs =.\n\n# obtenha os percentis padrões da variável age (0%, 25%, 50%, 75%, 100%)\nlinelist %&gt;% \n  summarise(age_percentiles = quantile(age_years, na.rm = TRUE))\n\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\nℹ Please use `reframe()` instead.\nℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n\n\n  age_percentiles\n1               0\n2               6\n3              13\n4              23\n5              84\n\n# obtenha os percentis em diferentes níveis da mesma variável (5%, 50%, 75%, 98%)\nlinelist %&gt;% \n  summarise(\n    age_percentiles = quantile(\n      age_years,\n      probs = c(.05, 0.5, 0.75, 0.98), \n      na.rm=TRUE)\n    )\n\nWarning: Returning more (or less) than 1 row per `summarise()` group was deprecated in\ndplyr 1.1.0.\nℹ Please use `reframe()` instead.\nℹ When switching from `summarise()` to `reframe()`, remember that `reframe()`\n  always returns an ungrouped data frame and adjust accordingly.\n\n\n  age_percentiles\n1               1\n2              13\n3              23\n4              48\n\n\nSe você quiser obter os quantis por grupos, é mais viável utilizar a função group_by() e criar novas colunas, uma vez que isso irá gerar dados mais claros em relação ao método acima, onde seriam obtidos resultados longos e menos úteis. Desta forma, experimente essa abordagem: crie um coluna para cada nível de quantil desejado.\n\n# obtenha os valores de percentis nos níveis desejados de acordo com a variável age (5%, 50%, 75%, 98%), agrupando os dados por hospital\nlinelist %&gt;% \n  group_by(hospital) %&gt;% \n  summarise(\n    p05 = quantile(age_years, probs = 0.05, na.rm=T),\n    p50 = quantile(age_years, probs = 0.5, na.rm=T),\n    p75 = quantile(age_years, probs = 0.75, na.rm=T),\n    p98 = quantile(age_years, probs = 0.98, na.rm=T)\n    )\n\n# A tibble: 6 × 5\n  hospital                               p05   p50   p75   p98\n  &lt;chr&gt;                                &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Ausente                                  1    13    23  48.2\n2 Central Hospital                         1    12    21  48  \n3 Military Hospital                        1    13    24  45  \n4 Other                                    1    13    23  50  \n5 Port Hospital                            1    14    24  49  \n6 St. Mark's Maternity Hospital (SMMH)     2    12    22  50.2\n\n\nEnquanto a função summarise() do dplyr certamente possibilita mais controle das alterações, todos os resumos estatísticos de que precisa podem ser produzidos com a função get_summary_stat(), do pacote rstatix. Ao ser utilizado em dados agrupados, esta função vai retornar percentis de 0%, 25%, 50%, 75%, e 100%. Se utilizado em dados não agrupados, você pode especificar os percentis com o atributo probs = c(.05, .5, .75, .98).\n\nlinelist %&gt;% \n  group_by(hospital) %&gt;% \n  rstatix::get_summary_stats(age, type = \"quantile\")\n\n# A tibble: 6 × 8\n  hospital                         variable     n  `0%` `25%` `50%` `75%` `100%`\n  &lt;chr&gt;                            &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1 Ausente                          age       1441     0     6    13    23     76\n2 Central Hospital                 age        445     0     6    12    21     58\n3 Military Hospital                age        884     0     6    14    24     72\n4 Other                            age        873     0     6    13    23     69\n5 Port Hospital                    age       1739     0     6    14    24     68\n6 St. Mark's Maternity Hospital (… age        420     0     7    12    22     84\n\n\n\nlinelist %&gt;% \n  rstatix::get_summary_stats(age, type = \"quantile\")\n\n# A tibble: 1 × 7\n  variable     n  `0%` `25%` `50%` `75%` `100%`\n  &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;\n1 age       5802     0     6    13    23     84\n\n\n\n\n\nObtenha um resumo dos dados agregados\nSe você iniciar sua análise com dados agregados, ao utilizar a função n() você irá obter o número de linhas, não a soma das contagens agregadas. Para obter as somas, use a função sum() na coluna de contagens.\nPor exemplo, suponha que você está iniciando com a tabela de contagens abaixo, chamada linelist_agg - ela mostra no formato “longo” as contagens do número de casos por outcome e gender.\nPara fins de exemplificação, abaixo, nós criamos uma tabela de dados com a quantidade de casos por outcome e gender dos dados do linelist (campos em branco foram removidos para facilitar o entendimento).\n\nlinelist_agg &lt;- linelist %&gt;% \n  drop_na(gender, outcome) %&gt;% \n  count(outcome, gender)\n\nlinelist_agg\n\n  outcome gender    n\n1   Death      f 1227\n2   Death      m 1228\n3 Recover      f  953\n4 Recover      m  950\n\n\nPara somar as contagens (da coluna n) por grupo, você pode usar a função summarise() e ajustar a nova coluna para ser igual à sum(n, na.rm=T). Para adicionar um elemento condicional à essa operação, você pode selecionar, na coluna de contagem (n), uma parte dos dados utilizando os colchetes [ ].\n\nlinelist_agg %&gt;% \n  group_by(outcome) %&gt;% \n  summarise(\n    total_cases  = sum(n, na.rm=T),\n    male_cases   = sum(n[gender == \"m\"], na.rm=T),\n    female_cases = sum(n[gender == \"f\"], na.rm=T))\n\n# A tibble: 2 × 4\n  outcome total_cases male_cases female_cases\n  &lt;chr&gt;         &lt;int&gt;      &lt;int&gt;        &lt;int&gt;\n1 Death          2455       1228         1227\n2 Recover        1903        950          953\n\n\n\n\nacross() em mais de uma coluna\nVocê pode utilizar a função summarise() em mais de uma coluna utilizado a função across(). Isto torna o trabalho mais fácil quando você quer obter a mesma estatística de muitas colunas. Coloque across() dentro de summarise() e especifique o seguinte:\n\n.cols = vetor com o nome das colunas c() ou funções auxiliares do “tidyselect” (explicado abaixo)\n\n.fns = a função a ser aplicada (sem parênteses) - você pode fornecer múltiplas funções dentro de uma list()\n\nAbaixo, a função mean() é aplicada para diferentes colunas numéricas. Um vetor com as colunas é dado explicitamente para o atributo .cols = e uma função simples (mean) é especificada (sem parênteses) em .fns =. Quaisquer argumentos adicionais para a função (por ex.: na.rm=TRUE) são colocados após .fns =, separados por uma vírgula.\nPode ser difícil acertar a ordem dos parênteses e vírgulas ao utilizar across(). Lembre que, dentro do across(), você deve incluir as colunas, as funções, e qualquer argumento extra que seja necessário para as funções.\n\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm),  # colunas utilizadas\n                   .fns = mean,                               # função aplicada\n                   na.rm=T))                                  # argumentos extras\n\nWarning: There was 1 warning in `summarise()`.\nℹ In argument: `across(...)`.\nℹ In group 1: `outcome = \"Death\"`.\nCaused by warning:\n! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\nSupply arguments directly to `.fns` through an anonymous function instead.\n\n  # Previously\n  across(a:b, mean, na.rm = TRUE)\n\n  # Now\n  across(a:b, \\(x) mean(x, na.rm = TRUE))\n\n\n# A tibble: 3 × 5\n  outcome age_years  temp wt_kg ht_cm\n  &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 Death        15.9  38.6  52.6  125.\n2 Recover      16.1  38.6  52.5  125.\n3 &lt;NA&gt;         16.2  38.6  53.0  125.\n\n\nFunções múltiplas podem ser executadas de uma vez. Abaixo, o atributo .fns = recebe as funções mean e sd dentro de uma list(). Você tem a oportunidade de escolher nomes das características (ex.: “mean” e “sd”) que serão colocadas inseridas ao nome das novas colunas.\n\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm), # colunas\n                   .fns = list(\"mean\" = mean, \"sd\" = sd),    # múltiplas funções\n                   na.rm=T))                                 # argumentos extras\n\n# A tibble: 3 × 9\n  outcome age_years_mean age_years_sd temp_mean temp_sd wt_kg_mean wt_kg_sd\n  &lt;chr&gt;            &lt;dbl&gt;        &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;\n1 Death             15.9         12.3      38.6   0.962       52.6     18.4\n2 Recover           16.1         13.0      38.6   0.997       52.5     18.6\n3 &lt;NA&gt;              16.2         12.8      38.6   0.976       53.0     18.9\n# ℹ 2 more variables: ht_cm_mean &lt;dbl&gt;, ht_cm_sd &lt;dbl&gt;\n\n\nAqui são as funções auxiliares “tidyselect”, que você pode utilizar em .cols = para selecionar colunas:\n\neverything() - todas as outras colunas não mencionadas\n\nlast_col() - a última coluna\n\nwhere() - aplica uma função à todas as colunas, e seleciona apenas aquelas que são verdadeiras (TRUE)\n\nstarts_with() - seleciona colunas cujos nomes iniciam com determinado prefixo. Exemplo: starts_with(\"date\")\nends_with() - seleciona colunas cujos normes terminam com determinado sufixo. Exemplo: ends_with(\"_end\")\n\ncontains() - colunas que contêm determinada sequência de caracteres. Exemplo: contains(\"time\")\nmatches() - aplica a sintaxe de uma expressão regular (regex). Exemplo: contains(\"[pt]al\")\n\nnum_range() -\nany_of() - seleciona colunas com certos nomes. Útil caso o nome buscado não exista. Exemplo: any_of(date_onset, date_death, cardiac_arrest)\n\nPor exemplo, para obter a média de cada coluna numérica, use a função where() e aplique a função as.numeric() (sem os parêntesese) para escolher as colunas numéricas, e então obtenha a média com mean. Tudo isso dentro da função across().\n\nlinelist %&gt;% \n  group_by(outcome) %&gt;% \n  summarise(across(\n    .cols = where(is.numeric),  # all numeric columns in the data frame\n    .fns = mean,\n    na.rm=T))\n\n# A tibble: 3 × 12\n  outcome generation   age age_years   lon   lat wt_kg ht_cm ct_blood  temp\n  &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;\n1 Death         16.7  15.9      15.9 -13.2  8.47  52.6  125.     21.3  38.6\n2 Recover       16.4  16.2      16.1 -13.2  8.47  52.5  125.     21.1  38.6\n3 &lt;NA&gt;          16.5  16.3      16.2 -13.2  8.47  53.0  125.     21.2  38.6\n# ℹ 2 more variables: bmi &lt;dbl&gt;, days_onset_hosp &lt;dbl&gt;\n\n\n\n\nUtilizando o pivot_wider()\nSe você preferir sua tabela no formato “largo”, você pode transformar ela utilizando a função pivot_wider(), do pacote tidyr. Você provavelmente precisará renomear as colunas com a função rename(). Para mais informações, veja a página sobre Pivoteando os dados.\nO exemplo abaixo utiliza a tabela age_by_outcome com formato “longo”, da seção de proporções. Para faciliar o entendimento, nós criamos essa tabela novamente, e mostramos como é seu formato “longo”:\n\nage_by_outcome &lt;- linelist %&gt;%                  # inicie com o linelist\n  group_by(outcome) %&gt;%                         # agrupe por outcome \n  count(age_cat) %&gt;%                            # agrupe e conte por age_cat, e então remova o agrupamento age_cat\n  mutate(percent = scales::percent(n / sum(n))) # calcule a porcentagem - observe que o denominador é o grupo outcome\n\n\n\n\n\n\n\nPara realizar o pivoteamento para a tabela criada fique no formato “largo”, nós criamos as novas colunas a partir dos valores na coluna existente age_cat (ao configurar names_from = age_cat). Nós também especificamos que os valores da nova tabela virão da coluna existente n, utilizando o atributo values_from = n. As colunas não mencionadas no nosso comando de pivoteamento (outcome) continuarão sem alterações na extremidade esquerda da tabela final.\n\nage_by_outcome %&gt;% \n  select(-percent) %&gt;%   # para não complicar, mantenha apenas as contagens\n  pivot_wider(names_from = age_cat, values_from = n)  \n\n# A tibble: 3 × 10\n# Groups:   outcome [3]\n  outcome `0-4` `5-9` `10-14` `15-19` `20-29` `30-49` `50-69` `70+`  `NA`\n  &lt;chr&gt;   &lt;int&gt; &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;\n1 Death     471   476     438     323     477     329      33     3    32\n2 Recover   364   391     303     251     367     238      38     3    28\n3 &lt;NA&gt;      260   228     200     169     229     187      24    NA    26\n\n\n\n\nAdicionando as linhas com os totais\nQuando a função summarise() é utilizada em dados agrupados, a linha com os “totais” não é produzida automaticamente. Abaixo, duas abordagens para adicionar esta linha são mostrados:\n\nFunção adorn_totals() do pacote janitor\nSe sua tabela contém apenas contagens ou proporções/porcentagens, que podem ser somados para obter os totais, então é possível realizar essa soma utilizando a função adorn_totals(), do pacote janitor, como descrito na seção acima. Observe que esta função consegue somar apenas as colunas numéricas - se você quiser calcular outros resumos estatísticos, veja a próxima abordagem com o pacote dplyr.\nAbaixo, os dados do linelist são agrupados por gênero e resumidos em uma tabela que descreve o número de casos com evolução conhecida (outcome), mortes (deaths) ou recuperados (recovered). Ao canalizar a tabela para a função adorn_totals(), uma linha com os totais é adicionada no final para refletir a soma de cada coluna. As próximas funções adorn_*() ajustam o design, como comentado no código.\n\nlinelist %&gt;% \n  group_by(gender) %&gt;%\n  summarise(\n    known_outcome = sum(!is.na(outcome)),           # N° de linhas em que o outcome não é desconhecido\n    n_death  = sum(outcome == \"Death\", na.rm=T),    # N° de linhas em que o outcome é Death\n    n_recover = sum(outcome == \"Recover\", na.rm=T), # N° de linhas em que o outcome é Recovered\n  ) %&gt;% \n  adorn_totals() %&gt;%                                # Adiciona a linha 'total' (soma de cada coluna numérica)\n  adorn_percentages(\"col\") %&gt;%                      # Obtenha as proporções\n  adorn_pct_formatting() %&gt;%                        # Converta as proporções para porcentagens\n  adorn_ns(position = \"front\")                      # mostra % e n° absolutos juntos (com n° absoluto na frente)\n\n gender  known_outcome        n_death      n_recover\n      f 2,180  (47.8%) 1,227  (47.5%)   953  (48.1%)\n      m 2,178  (47.7%) 1,228  (47.6%)   950  (47.9%)\n   &lt;NA&gt;   207   (4.5%)   127   (4.9%)    80   (4.0%)\n  Total 4,565 (100.0%) 2,582 (100.0%) 1,983 (100.0%)\n\n\n\n\nUso da função summarise() nos dados “totais” seguido por bind_rows()\nSe sua tabela consistir for feita de resumos estatísticos como median(), mean(), etc, a funçãoadorn_totals() utilizada acima não será suficiente. Assim, para obter o resumo estatístico de todo o banco de dados, você precisa calcular eles com uma função summarise() separada e, então, conectar os resultados à tabela resumo inicial. Para fazer essa conexão, você pode usar a função bind_rows(), do pacote dplyr, descrito na página Agrupando dados. Abaixo está um exemplo:\nVocê pode criar uma tabela resumo com os resultados da intersecção por hospital, com as funções group_by() e summarise() da seguinte forma:\n\nby_hospital &lt;- linelist %&gt;% \n  filter(!is.na(outcome) & hospital != \"Missing\") %&gt;%  # Remova os casos sem resultado (outcome) ou nome do hospital\n  group_by(hospital, outcome) %&gt;%                      # Agrupe os dados\n  summarise(                                           # Crie um novo resumo com as colunas com os indicadores de interesse\n    N = n(),                                           # N° de linhas por grupo hospital-outcome     \n    ct_value = median(ct_blood, na.rm=T))              # Obtenha a média dos valores CT por grupo\n  \nby_hospital # exporte a tabela\n\n# A tibble: 12 × 4\n# Groups:   hospital [6]\n   hospital                             outcome     N ct_value\n   &lt;chr&gt;                                &lt;chr&gt;   &lt;int&gt;    &lt;dbl&gt;\n 1 Ausente                              Death     611       21\n 2 Ausente                              Recover   514       21\n 3 Central Hospital                     Death     193       22\n 4 Central Hospital                     Recover   165       22\n 5 Military Hospital                    Death     399       21\n 6 Military Hospital                    Recover   309       22\n 7 Other                                Death     395       22\n 8 Other                                Recover   290       21\n 9 Port Hospital                        Death     785       22\n10 Port Hospital                        Recover   579       21\n11 St. Mark's Maternity Hospital (SMMH) Death     199       22\n12 St. Mark's Maternity Hospital (SMMH) Recover   126       22\n\n\nPara obter os totais, execute a mesma função summarise(), mas com os dados agrupados apenas por outcome (não por hospital), da seguinte forma:\n\ntotals &lt;- linelist %&gt;% \n      filter(!is.na(outcome) & hospital != \"Missing\") %&gt;%\n      group_by(outcome) %&gt;%                            # Agrupado apenas por outcome, não por hospital    \n      summarise(\n        N = n(),                                       # Essas estatísticas são apenas por outcome\n        ct_value = median(ct_blood, na.rm=T))\n\ntotals # exporte a tabela gerada\n\n# A tibble: 2 × 3\n  outcome     N ct_value\n  &lt;chr&gt;   &lt;int&gt;    &lt;dbl&gt;\n1 Death    2582       22\n2 Recover  1983       21\n\n\nAgora, nós podemos unir as duas tabelas geradas. Observe que a tabela by_hospital tem 4 colunas, enquanto a tabela totals tem 3 colunas. Ao utilizar a função bind_rows(), as colunas são combinadas por nome, onde cada espaço extra (linhas a mais) são preenchidos com NA (ex.: na coluna hospital os campos das duas novas linhas de totals). Após unir as linhas, nós iremos converter esses espaços em branco para “Total” utilizando a função replace_na() (veja a página Limpando os dados e funções essenciais).\n\ntable_long &lt;- bind_rows(by_hospital, totals) %&gt;% \n  mutate(hospital = replace_na(hospital, \"Total\"))\n\nAqui está a nova tabela com as linhas “Total” no final.\n\n\n\n\n\n\nEsta tabela está no formato “longo/comprido”, que pode ser o desejado. Opcionalmente, você pode mudar essa tabela para o formato largo, de forma a torná-la mais fácil de interpretar. Veja a seção acima sobre como transformar a tabela para o formato “largo”, ou na página Pivoteando dados. Você também pode adicionar mais colunas, e ajustá-las de forma que considere mais agradável. Segue o código:\n\ntable_long %&gt;% \n  \n  # Muda para o formato amplo e formata a tabela\n  ########################\n  mutate(hospital = replace_na(hospital, \"Total\")) %&gt;% \n  pivot_wider(                                         # Mude de \"longo\" para \"largo\"\n    values_from = c(ct_value, N),                       # novos valores provenientes das colunas ct e de contagen (n)\n    names_from = outcome) %&gt;%                           # novos nomes das colunas proveniente dos outcomes\n  mutate(                                              # adiciona novas colunas\n    N_Known = N_Death + N_Recover,                               # casos com evolução (outcome) conhecido\n    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # percentual de casos que evoluíram para óbito (até 1ª casa decimal)\n    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %&gt;% # percentual de casos que recuperaram (até a 1ª casa decimal)\n  select(                                              # Reordena as colunas\n    hospital, N_Known,                                   # Coluna introdutórias\n    N_Recover, Pct_Recover, ct_value_Recover,            # Colunas dos recuperados\n    N_Death, Pct_Death, ct_value_Death)  %&gt;%             # Colunas de óbitos\n  arrange(N_Known)                                  # Organize as linhas do menor para o maior (linha com totais por último)\n\n# A tibble: 7 × 8\n# Groups:   hospital [7]\n  hospital      N_Known N_Recover Pct_Recover ct_value_Recover N_Death Pct_Death\n  &lt;chr&gt;           &lt;int&gt;     &lt;int&gt; &lt;chr&gt;                  &lt;dbl&gt;   &lt;int&gt; &lt;chr&gt;    \n1 St. Mark's M…     325       126 38.8%                     22     199 61.2%    \n2 Central Hosp…     358       165 46.1%                     22     193 53.9%    \n3 Other             685       290 42.3%                     21     395 57.7%    \n4 Military Hos…     708       309 43.6%                     22     399 56.4%    \n5 Ausente          1125       514 45.7%                     21     611 54.3%    \n6 Port Hospital    1364       579 42.4%                     21     785 57.6%    \n7 Total            4565      1983 43.4%                     21    2582 56.6%    \n# ℹ 1 more variable: ct_value_Death &lt;dbl&gt;\n\n\nApós isso, você pode exportar essa tabela como uma imagem - abaixo, o resultado é exportado com o pacote flextable. Para mais detalhes sobre esse exemplo, e sobre como produzir uma imagem dessa forma, leia a página Tabelas para apresentações.\n\n\nHospitalTotal cases with known outcomeRecoveredDiedTotal% of casesMedian CT valuesTotal% of casesMedian CT valuesSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Tabelas descritivas</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.pt.html#tbl_gt",
    "href": "new_pages/tables_descriptive.pt.html#tbl_gt",
    "title": "17  Tabelas descritivas",
    "section": "17.5 Pacote gtsummary",
    "text": "17.5 Pacote gtsummary\nSe você quer exportar seu resumo estatístico em um gráfico ‘bonito’, pronto para publicação, você pode usar o pacote gtsummary e sua função tbl_summary(). Em um primeiro momento, o código pode parecer complexo, mas as tabelas geradas são lindas e exportadas para o seu painel do RStudio Viewer como uma imagem HTML. Veja um tutorial mais detalhado aqui.\nVocê também pode adicionar os resultados dos testes estatísticos nas tabelas geradas pelo gtsummary. Este processo está decrito na seção do gtsummary, da página testes estatísticos simples.\nPara introduzir a função tbl_summary(), nós vamos primeiro demostrar seu funcionamento básico, que produz uma tabela bonita e extensa. Então, examinaremos em detalhes como fazer ajustes finos e tabelas mais customizadas.\n\nTabela resumo\nO comportamento padrão do tbl_summary() é incrível - ele utiliza as colunas fornecidas e cria uma tabela resumo em apenas um comando. Esta função realiza as estatísticas apropriadas de acordo com a classe da coluna: média e intervalo interquartil (IQR) para colunas numéricas, e contagens (%) para colunas categóricas. Valores em branco são convertidos para “Unknown”. Notas de rodapé são adicionadas para explicar as estatísticas utilizadas, enquanto a quantidade total N é mostrada no topo.\n\n# Use a função abaixo para que a tabela saia em portugês\n\ntheme_gtsummary_language(\"pt\")\n\nlinelist %&gt;% \n  select(age_years, gender, outcome, fever, temp, hospital) %&gt;%  # mantenha apenas as colunas de interesse\n  tbl_summary()                                                  # função no modo padrão\n\n\n\n\n\n\n\n\n\n\n\n\nCaracterísticas\nN = 5,8881\n\n\n\n\nage_years\n13 (6, 23)\n\n\n    Desconhecido\n86\n\n\ngender\n\n\n\n\n    f\n2,807 (50%)\n\n\n    m\n2,803 (50%)\n\n\n    Desconhecido\n278\n\n\noutcome\n\n\n\n\n    Death\n2,582 (57%)\n\n\n    Recover\n1,983 (43%)\n\n\n    Desconhecido\n1,323\n\n\nfever\n4,549 (81%)\n\n\n    Desconhecido\n249\n\n\ntemp\n38.80 (38.20, 39.20)\n\n\n    Desconhecido\n149\n\n\nhospital\n\n\n\n\n    Ausente\n1,469 (25%)\n\n\n    Central Hospital\n454 (7.7%)\n\n\n    Military Hospital\n896 (15%)\n\n\n    Other\n885 (15%)\n\n\n    Port Hospital\n1,762 (30%)\n\n\n    St. Mark's Maternity Hospital (SMMH)\n422 (7.2%)\n\n\n\n1 Mediana (AIQ); n (%)\n\n\n\n\n\n\n\n\n\n\n\nAjustes\nAgora iremos explicar como esta função funciona e como fazer ajustes. Os argumentos chave estão detalhados abaixo:\nby =\nVocê pode estratificar a sua tabela utilizando uma coluna (ex.: outcome), ao criar uma tabela de duas vias.\nstatistic =\nUse as equações para especificar quais estatísticas mostrar e como mostrá-las. Existem dois lados para essa equação, separados por um til ~. Do lado direito, entre aspas, é colocado o teste estatístico desejado, e no lado esquerdo são colocadas as colunas em que esse teste será aplicado.\n\nO lado direito da equação utiliza a sintaxe da função str_glue(), do pacote stringr (veja mais em Caractéres e Strings), com o texto a ser mostrado entre aspas e o teste estatístico dentro de colchetes encaracolados { }. Você pode incluir estatísticas como “n” (para contagens), “N” (para denominador), “mean” (média), “median” (mediana), “sd” (desvio padrão), “max” (valor máximo), “min” (valor mínimo), percentis “p##” como “p25”, ou percentual do total como “p”. Utilize o comando ?tbl_summary para mais detalhes.\n\nNo lado esquerdo da equação, você pode especificar colunas por nome (ex.: age ou c(age, gender)) ou utilizando funções auxiliares como all_continuous(), all_categorical(), contains(), starts_with(), etc.\n\nUma exemplo simples da equação statistic = é mostrado abaixo, onde apenas a média da coluna age_years é obtida:\n\nlinelist %&gt;% \n  select(age_years) %&gt;%         # mantenha apenas as colunas de interesse\n  tbl_summary(                  # crie uma tabela resumo\n    statistic = age_years ~ \"{mean}\") # calcule a média de idades (age)\n\n\n\n\n\n\n\n\nCaracterísticas\nN = 5,8881\n\n\n\n\nage_years\n16\n\n\n    Desconhecido\n86\n\n\n\n1 Média\n\n\n\n\n\n\n\n\n\nUma equação um pouco mais complexa é obtida \"({min}, {max})\", incorporando os valores mínimos e máximos dentro de parênteses e separados por vírgula:\n\nlinelist %&gt;% \n  select(age_years) %&gt;%                       # mantenha apenas as colunas de interesse\n  tbl_summary(                                # crie uma tabela resumo\n    statistic = age_years ~ \"({min}, {max})\") # calcule o min e max da idade (age)\n\n\n\n\n\n\n\n\nCaracterísticas\nN = 5,8881\n\n\n\n\nage_years\n(0, 84)\n\n\n    Desconhecido\n86\n\n\n\n1 (Amplitude)\n\n\n\n\n\n\n\n\n\nVocê também pode utilizar uma sintaxe diferente para colunas distintas ou diferentes tipos de colunas. Em um exemplo mais complexo, mostrado abaixo, o argumento dado à statistic = é uma list (list) indicando que para todas as colunas com valores contínuos, a tabela deve gerar a média com o desvio padrão em parênteses, enquanto que, para colunas categóricas, ela deve gerar o n, o denominador, e o percentual.\ndigits =\nAjuste a quantidade de dígitos e de arredondamento. Opcionalmente, isto pode ser limitado à colunas contínuas apenas (como mostrado abaixo).\nlabel =\nAjuste como o rótulo da coluna deve ser mostrado. Forneça o nome da coluna e o rótulo desejado, separado por um til ~. O padrão do rótulo é o nome da coluna.\nmissing_text =\nAjuste como os campos em branco são mostrados. A opção padrão é “Unknown”.\ntype =\nIsto é utilizado para ajustar quantos níveis das estatísticas são mostradas. A sintaxe é similar ao atributo statistic =, pois você fornece uma equação com colunas no lado esquerdo, e um valor no lado direito. Dois cenários comuns incluem:\n\ntype = all_categorical() ~ \"categorical\" Força colunas dicotômicas (ex.: fever sim/não) a mostrar todos os níveis em vez de apenas a linha “sim”\n\ntype = all_continuous() ~ \"continuous2\" Permite a realização de estatísticas em múltiplas linha (“multi-line”) por variável, como mostrado em seção posterior\n\nNo exemplo abaixo, cada um desses argumentos é utilizado para modificar a tabela resumo original:\n\nlinelist %&gt;% \n  select(age_years, gender, outcome, fever, temp, hospital) %&gt;% # utilize apenas as colunas de interesse\n  tbl_summary(     \n    by = outcome,                                               # estratifique a tabela inteira pelo outcome\n    statistic = list(all_continuous() ~ \"{mean} ({sd})\",        # estatísticas e formatação para colunas contínuas\n                     all_categorical() ~ \"{n} / {N} ({p}%)\"),   # estatísticas e formatação para colunas categóricas\n    digits = all_continuous() ~ 1,                              # arredondamento para colunas contínuas\n    type   = all_categorical() ~ \"categorical\",                 # force todos os níveis de colunas categóricas a serem mostrados\n    label  = list(                                              # mostre etiquetas de acordo com o nome das colunas\n      outcome   ~ \"Outcome\",                           \n      age_years ~ \"Age (years)\",\n      gender    ~ \"Gender\",\n      temp      ~ \"Temperature\",\n      hospital  ~ \"Hospital\"),\n    missing_text = \"Missing\"                                    # como valores em branco devem ser mostrados\n  )\n\n1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCaracterísticas\nDeath, N = 2,5821\nRecover, N = 1,9831\n\n\n\n\nAge (years)\n15.9 (12.3)\n16.1 (13.0)\n\n\n    Missing\n32\n28\n\n\nGender\n\n\n\n\n\n\n    f\n1,227 / 2,455 (50%)\n953 / 1,903 (50%)\n\n\n    m\n1,228 / 2,455 (50%)\n950 / 1,903 (50%)\n\n\n    Missing\n127\n80\n\n\nfever\n\n\n\n\n\n\n    no\n458 / 2,460 (19%)\n361 / 1,904 (19%)\n\n\n    yes\n2,002 / 2,460 (81%)\n1,543 / 1,904 (81%)\n\n\n    Missing\n122\n79\n\n\nTemperature\n38.6 (1.0)\n38.6 (1.0)\n\n\n    Missing\n60\n55\n\n\nHospital\n\n\n\n\n\n\n    Ausente\n611 / 2,582 (24%)\n514 / 1,983 (26%)\n\n\n    Central Hospital\n193 / 2,582 (7.5%)\n165 / 1,983 (8.3%)\n\n\n    Military Hospital\n399 / 2,582 (15%)\n309 / 1,983 (16%)\n\n\n    Other\n395 / 2,582 (15%)\n290 / 1,983 (15%)\n\n\n    Port Hospital\n785 / 2,582 (30%)\n579 / 1,983 (29%)\n\n\n    St. Mark's Maternity Hospital (SMMH)\n199 / 2,582 (7.7%)\n126 / 1,983 (6.4%)\n\n\n\n1 Média (Desvio Padrão); n / N (%)\n\n\n\n\n\n\n\n\n\n\n\nEstatísticas de múltiplas linhas (“multi-line”) para variáveis contínuas\nSe você quiser obter múltiplas linhas de estatísticas para variáveis contínuas, é possível indicar isto ao ajustar o atributo type = para “continuous2”. É possível combinar todos os elementos mostrados anteriormente em uma tabela, ao escolher quais estatísticas quer mostrar. Para fazer isso, é necessário ‘dizer’ para a função que você quer a tabela de volta ao inserir seu tipo como “continous2”. A quantidade de campos em braco é mostrado como “Unknown”.\n\nlinelist %&gt;% \n  select(age_years, temp) %&gt;%                      # mantenha apenas colunas de interesse\n  tbl_summary(                                     # crie tabelas resumo\n    type = all_continuous() ~ \"continuous2\",       # indique que você quer obter mais de uma estatística\n    statistic = all_continuous() ~ c(\n      \"{mean} ({sd})\",                             # linha 1: média e desvio padrão\n      \"{median} ({p25}, {p75})\",                   # linha 2: média e IQR\n      \"{min}, {max}\")                              # linha 3: min e max\n    )\n\n\n\n\n\n\n\n\n\n\n\n\nCaracterísticas\nN = 5,888\n\n\n\n\nage_years\n\n\n\n\n    Média (Desvio Padrão)\n16 (13)\n\n\n    Mediana (AIQ)\n13 (6, 23)\n\n\n    Amplitude\n0, 84\n\n\n    Desconhecido\n86\n\n\ntemp\n\n\n\n\n    Média (Desvio Padrão)\n38.56 (0.98)\n\n\n    Mediana (AIQ)\n38.80 (38.20, 39.20)\n\n\n    Amplitude\n35.20, 40.80\n\n\n    Desconhecido\n149\n\n\n\n\n\n\n\n\nExistem diversas formas de modificar essas tabelas, como adicionar valores do p, ajustar cores e títulos, etc. Muitas destas modificações estão descritas na documentação (digite ?tbl_summary no Console), e algumas destas são mostradas na seção sobre testes estatísticos.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Tabelas descritivas</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.pt.html#pacote-r-base",
    "href": "new_pages/tables_descriptive.pt.html#pacote-r-base",
    "title": "17  Tabelas descritivas",
    "section": "17.6 Pacote R base",
    "text": "17.6 Pacote R base\nVocê pode usar a função table() para tabular e realizar tabulações cruzadas das colunas. Diferente das opções acima, você precisa especificar o quadro de dados cada vez que o nome de uma coluna é apontado, como mostrado abaixo.\nCUIDADO: NA valores em branco não serão tabulados a não ser que você coloque o argumento useNA = \"always\" (que também pode ser ajustado para “no” ou “ifany”).\nDICA: É possível usar o %$% do pacote magrittr para remover a necessidade de repetir a quantidade de vezes que o quadro de dados é chamado dentro das funções do pacote R base. Por exemplo, o código abaixo poderia ser reescrito como linelist %$% table(outcome, useNA = \"always\")\n\ntable(linelist$outcome, useNA = \"always\")\n\n\n  Death Recover    &lt;NA&gt; \n   2582    1983    1323 \n\n\nMúltiplas colunas podem ser utilizadas para tabulação cruzada ao listá-las uma após a outra, separadas por vírgulas. Opcionalmente, você pode dar um “nome” a cada coluna, como em Outcome = linelist$outcome.\n\nage_by_outcome &lt;- table(linelist$age_cat, linelist$outcome, useNA = \"always\") # salve a tabela como objeto\nage_by_outcome   # exporte a tabela\n\n       \n        Death Recover &lt;NA&gt;\n  0-4     471     364  260\n  5-9     476     391  228\n  10-14   438     303  200\n  15-19   323     251  169\n  20-29   477     367  229\n  30-49   329     238  187\n  50-69    33      38   24\n  70+       3       3    0\n  &lt;NA&gt;     32      28   26\n\n\n\nProporções\nPara obter proporções, utilize a tabela acima na função prop.table(). Use o argumento margins = para especificar caso você queira que as proporções sejam calculadas das linhas (1), colunas (2), ou da tabela inteira (3). No código abaixo, encadeamos (“piped”) a tabela com a função round(), do R base, especificando 2 dígitos.\n\n# obtenhas as proporções da tabela definida acima, por linhas, arredondado\nprop.table(age_by_outcome, 1) %&gt;% round(2)\n\n       \n        Death Recover &lt;NA&gt;\n  0-4    0.43    0.33 0.24\n  5-9    0.43    0.36 0.21\n  10-14  0.47    0.32 0.21\n  15-19  0.43    0.34 0.23\n  20-29  0.44    0.34 0.21\n  30-49  0.44    0.32 0.25\n  50-69  0.35    0.40 0.25\n  70+    0.50    0.50 0.00\n  &lt;NA&gt;   0.37    0.33 0.30\n\n\n\n\nTotais\nPara adicionar colunas e linhas com totais, passe a tabela gerada para a função addmargins(). Isto funciona para contagens e proporções.\n\naddmargins(age_by_outcome)\n\n       \n        Death Recover &lt;NA&gt;  Sum\n  0-4     471     364  260 1095\n  5-9     476     391  228 1095\n  10-14   438     303  200  941\n  15-19   323     251  169  743\n  20-29   477     367  229 1073\n  30-49   329     238  187  754\n  50-69    33      38   24   95\n  70+       3       3    0    6\n  &lt;NA&gt;     32      28   26   86\n  Sum    2582    1983 1323 5888\n\n\n\n\nConverta para um quadro de dados\nConverter um objeto table() diretamente para um quadro de dado (data frame)s não é simples. Uma possível abordagem é mostrada abaixo:\n\nCrie a tabela, sem utilizar useNA = \"always\". Em vez disso, converta os valores NA para “(Missing)” com a função fct_explicit_na(), do pacote forcats.\n\nAdicione os totais (opcional) ao aplicar a tabela na função addmargins()\n\nUtilize a tabela na função do R base as.data.frame.matrix()\n\nTransforme a tabela utilizando a função do pacote tibble, rownames_to_column(), especificando o nome da primeira coluna\n\nExporte, Visualize, ou exporte como desejado. Neste exemplo, nós utilizamos a função flextable(), do pacote flextable, como descrito na página Tabelas para apresentação. Isto irá exportar a tabela para o RStudio viewer como uma linda imagem HTML.\n\n\ntable(fct_explicit_na(linelist$age_cat), fct_explicit_na(linelist$outcome)) %&gt;% \n  addmargins() %&gt;% \n  as.data.frame.matrix() %&gt;% \n  tibble::rownames_to_column(var = \"Age Category\") %&gt;% \n  flextable::flextable()\n\nAge CategoryDeathRecover(Missing)Sum0-44713642601,0955-94763912281,09510-1443830320094115-1932325116974320-294773672291,07330-4932923818775450-693338249570+3306(Missing)32282686Sum2,5821,9831,3235,888",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Tabelas descritivas</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_descriptive.pt.html#recursos-extras",
    "href": "new_pages/tables_descriptive.pt.html#recursos-extras",
    "title": "17  Tabelas descritivas",
    "section": "17.7 Recursos extras",
    "text": "17.7 Recursos extras\nMuitas das informações desta página foram adaptadas destes recursos e tutoriais online:\ngtsummary\ndplyr",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Tabelas descritivas</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.pt.html",
    "href": "new_pages/stat_tests.pt.html",
    "title": "18  Testes estatísticos simples",
    "section": "",
    "text": "18.1 Preparação",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Testes estatísticos simples</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.pt.html#preparação",
    "href": "new_pages/stat_tests.pt.html#preparação",
    "title": "18  Testes estatísticos simples",
    "section": "",
    "text": "Carregue os pacotes\nEste pequeno código carrega os pacotes necessários para as análises. Neste manual, nós estimulamos o uso da função p_load(), do pacman, que instala os pacotes, caso necessários, e os carrega para utilização. Também é possível carregar pacotes já instalados com a função library() do pacote R base. Veja a página sobre Introdução ao R para mais informações sobre pacotes do R.\n\npacman::p_load(\n  rio,          # Importa arquivos\n  here,         # Localiza arquivos\n  skimr,        # visualize os dados\n  tidyverse,    # gerenciamento dos dados + gráficos no ggplot2, \n  gtsummary,    # resumo estatístico e testes\n  rstatix,      # estatísticas\n  corrr,        # análise de correlação entre variáveis numéricas\n  janitor,      # adicione totais e porcentagens às tabelas\n  flextable     # converte tabelas para o formato HTML\n  )\n\n\n\nImportando os dados\nNós iremos importar o banco de dados dos casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar, clique para baixar o banco “limpo” (como arquivo .rds). Importe os dados com a função import(), do pacote rio (ela aceita muitos formatos de arquivos, como .xlsx, .rds, .csv - veja a página Importar e exportar para detalhes).\n\n# importa o 'linelist'\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nAs primeiras 50 linhas dos dados são mostradas abaixo.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Testes estatísticos simples</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.pt.html#pacote-r-base",
    "href": "new_pages/stat_tests.pt.html#pacote-r-base",
    "title": "18  Testes estatísticos simples",
    "section": "18.2 Pacote R base",
    "text": "18.2 Pacote R base\nVocê pode utilizar as funções do pacote R base para realizar testes estatísticos. Os comandos são relativamente simples, e os resultados são exportados para o terminal do R para visualização. Entretanto, normalmente os resultados são gerados no formato de listas, o que dificulta a manipulação, caso queira utilizá-los posteriormente.\n\nTestes T\nO teste t, também chamando de “Teste t de Student”, é tipicamente utilizado para determinar se existem diferenças significativas entre as médias de variáveis numéricas de dois grupos distintos. Aqui, nós iremos mostrar duas sintaxes para realizar esse teste, de acordo com a presença ou não das colunas no mesmo quadro de dados.\nSintaxe 1: Esta é a sintaxe utilizada quando as colunas numéricas e categóricas estão no mesmo quadro de dados (data frame). Especifique a coluna numérica no lado esquerdo da equação, e a coluna categórica no lado direito. Coloque o nome do banco de dados no argumento data =. Opcionalmente, ajuste os argumentos paired = TRUE, conf.level = para (0.95 default), e alternative = para (“two.sided”, “less”, ou “greater”). Digite ?t.test para mais detalhes.\n\n## compare a média das idades de acordo com o sexo com um teste t\nt.test(age_years ~ gender, data = linelist)\n\n\n    Welch Two Sample t-test\n\ndata:  age_years by gender\nt = -21.344, df = 4902.3, p-value &lt; 2.2e-16\nalternative hypothesis: true difference in means between group f and group m is not equal to 0\n95 percent confidence interval:\n -7.571920 -6.297975\nsample estimates:\nmean in group f mean in group m \n       12.60207        19.53701 \n\n\nSintaxe 2: Você pode comparar dois vetores numéricos separados com essa sintaxe. Por exemplo, se as duas colunas estão em bancos de dados distintos.\n\nt.test(df1$age_years, df2$age_years)\n\nTambém é possível utilizar o teste t para determinar se a média de uma amostra é significativamente diferente de algum valor específico. Aqui, nós aplicamos o teste t entre uma amostra e uma média conhecida/suposta de uma população (mu =):\n\nt.test(linelist$age_years, mu = 45)\n\n\n\nTeste de Shapiro-Wilk\nO teste de Shapiro-Wilk pode ser utilizado para determinar se uma amostra foi obtida de uma população com distribuição normal (um pré-requisito de muitos outros testes e análises, como o teste t). Entretanto, isto só pode ser utilizado em uma amostra de 3 a 5000 observações. Para amostras maiores, um gráfico de Quantil-Quantil é recomendado.\n\nshapiro.test(linelist$age_years)\n\n\n\nTeste de Wilcoxon\nO teste de Wilcoxon, também chamado de teste U de Mann–Whitney, é frequentemente utilizado para determinar se duas amostras numéricas possuem a mesma distribuição, mesmo quando suas populações não possuem distribuição normal ou possuem variância independente (desiguais).\n\n## compare a distribuição da idade de acordo com o grupo 'outcome' utilizando o teste wilcox\nwilcox.test(age_years ~ outcome, data = linelist)\n\n\n    Wilcoxon rank sum test with continuity correction\n\ndata:  age_years by outcome\nW = 2501868, p-value = 0.8308\nalternative hypothesis: true location shift is not equal to 0\n\n\n\n\nTeste de Kruskal-Wallis\nO tesde de Kruskal-Wallis é uma extensão do teste de Wilcoxon que pode ser utilizado para verificar diferenças na distribuição de mais de duas amostras. Quando apenas duas amostras são utilizadas, os resultados são idênticos ao teste de Wilcoxon.\n\n## compare a distribuição da idade de acordo com o grupo 'outcome' utilizando o teste de kruskal-wallis\nkruskal.test(age_years ~ outcome, linelist)\n\n\n    Kruskal-Wallis rank sum test\n\ndata:  age_years by outcome\nKruskal-Wallis chi-squared = 0.045675, df = 1, p-value = 0.8308\n\n\n\n\nTeste de qui-quadrado\nO teste do qui-quadrado de Pearson é utilizado para verificar se existem diferenças significativas entre grupos categóricos.\n\n## compare as proporções em cada grupo utilizando o teste do qui-quadrado\nchisq.test(linelist$gender, linelist$outcome)\n\n\n    Pearson's Chi-squared test with Yates' continuity correction\n\ndata:  linelist$gender and linelist$outcome\nX-squared = 0.0011841, df = 1, p-value = 0.9725",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Testes estatísticos simples</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.pt.html#pacote-rstatix",
    "href": "new_pages/stat_tests.pt.html#pacote-rstatix",
    "title": "18  Testes estatísticos simples",
    "section": "18.3 Pacote rstatix",
    "text": "18.3 Pacote rstatix\nO pacote rstatix realiza testes estatísticos e gera os resultados de forma que possam ser manipulados (“pipe-friendly”). Os resultados são gerados automaticamente em um quadro de dados (data frame), sendo possível realizar operações posteriores com eles. Também é fácil agrupar os dados utilizados nas funções, podendo as estatísticas serem executadas por cada grupo.\n\nEstatísticas resumo\nA função get_summary_stats() é uma maneira rápida de gerar resultados estatísticos. Simplesmente aplique seu banco de dados nessa função, e escolha as colunas para analisar. Se nenhuma coluna for especificada, as estatísticas são calculadas com todas as colunas.\nPor padrão, um resumo estatístico completo é gerado: n, max, min, mediana, 25%ile, 75%ile, IQR, desvio absoluto mediano (mad), média, desvio padrão, erro padrão, e o intervalo de confiança da média.\n\nlinelist %&gt;%\n  rstatix::get_summary_stats(age, temp)\n\n# A tibble: 2 × 13\n  variable     n   min   max median    q1    q3   iqr    mad  mean     sd    se\n  &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 age       5802   0    84     13     6    23      17 11.9    16.1 12.6   0.166\n2 temp      5739  35.2  40.8   38.8  38.2  39.2     1  0.741  38.6  0.977 0.013\n# ℹ 1 more variable: ci &lt;dbl&gt;\n\n\nVocê pode especificar um sub-grupo do resumo estatístico a ser gerado, ao fornecer um dos seguintes valores ao argumento type =: “full”, “common”, “robust”, “five_number”, “mean_sd”, “mean_se”, “mean_ci”, “median_iqr”, “median_mad”, “quantile”, “mean”, “median”, “min”, “max”.\nEsta função também pode ser utilizada com dados agrupados, de forma que uma linha é gerada por cada variável agrupável:\n\nlinelist %&gt;%\n  group_by(hospital) %&gt;%\n  rstatix::get_summary_stats(age, temp, type = \"common\")\n\n# A tibble: 12 × 11\n   hospital     variable     n   min   max median   iqr  mean     sd    se    ci\n   &lt;chr&gt;        &lt;fct&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 Ausente      age       1441   0    76     13    17    16.0 12.9   0.339 0.665\n 2 Ausente      temp      1431  35.8  40.6   38.9   1    38.6  0.97  0.026 0.05 \n 3 Central Hos… age        445   0    58     12    15    15.7 12.5   0.591 1.16 \n 4 Central Hos… temp       450  35.2  40.4   38.8   1    38.5  0.964 0.045 0.089\n 5 Military Ho… age        884   0    72     14    18    16.1 12.4   0.417 0.818\n 6 Military Ho… temp       873  35.3  40.5   38.8   1    38.6  0.952 0.032 0.063\n 7 Other        age        873   0    69     13    17    16.0 12.5   0.422 0.828\n 8 Other        temp       862  35.7  40.8   38.8   1.1  38.5  1.01  0.034 0.067\n 9 Port Hospit… age       1739   0    68     14    18    16.3 12.7   0.305 0.598\n10 Port Hospit… temp      1713  35.5  40.6   38.8   1.1  38.6  0.981 0.024 0.046\n11 St. Mark's … age        420   0    84     12    15    15.7 12.4   0.606 1.19 \n12 St. Mark's … temp       410  35.9  40.6   38.8   1.1  38.5  0.983 0.049 0.095\n\n\nO pacote rstatix também pode ser utilizado para realizar testes estatísticos:\n\n\nTeste t\nUtilize a sintaxe para especificar as colunas numérica e categórica:\n\nlinelist %&gt;% \n  t_test(age_years ~ gender)\n\n# A tibble: 1 × 10\n  .y.   group1 group2    n1    n2 statistic    df        p    p.adj p.adj.signif\n* &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;int&gt; &lt;int&gt;     &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;       \n1 age_… f      m       2807  2803     -21.3 4902. 9.89e-97 9.89e-97 ****        \n\n\nOu utilize ~ 1 e especifique mu = para realizar o teste t de uma amostra. Isto também pode ser realizado por grupos.\n\nlinelist %&gt;% \n  t_test(age_years ~ 1, mu = 30)\n\n# A tibble: 1 × 7\n  .y.       group1 group2         n statistic    df     p\n* &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;      &lt;int&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 age_years 1      null model  5802     -84.2  5801     0\n\n\nSe necessário, os testes estatísticos podem ser realizados por grupos, como mostrado abaixo:\n\nlinelist %&gt;% \n  group_by(gender) %&gt;% \n  t_test(age_years ~ 1, mu = 18)\n\n# A tibble: 3 × 8\n  gender .y.       group1 group2         n statistic    df         p\n* &lt;chr&gt;  &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;      &lt;int&gt;     &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;\n1 f      age_years 1      null model  2807    -29.8   2806 7.52e-170\n2 m      age_years 1      null model  2803      5.70  2802 1.34e-  8\n3 &lt;NA&gt;   age_years 1      null model   192     -3.80   191 1.96e-  4\n\n\n\n\nTesde de Shapiro-Wilk\nComo dito acima, o tamanho da amostra precisa estar entre 3 e 5000.\n\nlinelist %&gt;% \n  head(500) %&gt;%            # primeiras 500 linhas dos dados em linelist, para exemplificação apenas\n  shapiro_test(age_years)\n\n# A tibble: 1 × 3\n  variable  statistic        p\n  &lt;chr&gt;         &lt;dbl&gt;    &lt;dbl&gt;\n1 age_years     0.917 6.67e-16\n\n\n\n\nTesde de Wilcoxon\n\nlinelist %&gt;% \n  wilcox_test(age_years ~ gender)\n\n# A tibble: 1 × 9\n  .y.       group1 group2    n1    n2 statistic        p    p.adj p.adj.signif\n* &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt;  &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;       \n1 age_years f      m       2807  2803   2829274 3.47e-74 3.47e-74 ****        \n\n\n\n\nTeste de Kruskal-Wallis\nTambém conhecido como teste U de Mann-Whitney.\n\nlinelist %&gt;% \n  kruskal_test(age_years ~ outcome)\n\n# A tibble: 1 × 6\n  .y.           n statistic    df     p method        \n* &lt;chr&gt;     &lt;int&gt;     &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;         \n1 age_years  5888    0.0457     1 0.831 Kruskal-Wallis\n\n\n\n\nTeste do Qui-quadrado\nA função do teste do Qui-quadrado pode utilizar uma tabela, então primeiro criamos uma tabulação cruzada. Existem diversas formas de realizar isto (veja página de Tabelas descritivas), mas aqui utilizamos a função tabyl(), do pacote janitor, e então removemos a coluna mais a esquerda (com os nomes) antes de utilizá-la na função chisq_test().\n\nlinelist %&gt;% \n  tabyl(gender, outcome) %&gt;% \n  select(-1) %&gt;% \n  chisq_test()\n\n# A tibble: 1 × 6\n      n statistic     p    df method          p.signif\n* &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt;           &lt;chr&gt;   \n1  5888      3.53 0.473     4 Chi-square test ns      \n\n\nMuitas outras funções e testes estatísticos podem ser realizados com as funções do rstatix. Veja a documentação do rstatix online aqui ou digite ?rstatix.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Testes estatísticos simples</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.pt.html#stats_gt",
    "href": "new_pages/stat_tests.pt.html#stats_gt",
    "title": "18  Testes estatísticos simples",
    "section": "18.4 Pacote gtsummary",
    "text": "18.4 Pacote gtsummary\nUse o gtsummary se você quiser adicionar os resultados de um teste estatístico em uma tabela criada com esse pacote (como descrito na seção do gtsummary na página de Tabelas descritivas).\nPara realizar testes estatísticos de comparação com a função tbl_summary, basta adicionar a função add_p na tabela e especificar qual teste utilizar. É possível obter os p-valores corrigidos para testes múltiplos ao utilizar a função add_q. Utilize o comando ?tbl_summary para mais detalhes.\n\nTeste Qui-quadrado\nCompare as proporções de uma variável categórica em dois grupos. O teste estatístico padrão para a função add_p() para uma variável categórica é o teste Qui-quadrado de independência com correção de continuidade. Entretanto, caso alguma contagem seja abaixo de 5, o teste exato de Fisher é utilizado em seu lugar.\n\ntheme_gtsummary_language(\"pt\") # acrescentando tradução para o portugues\n\nSetting theme `language: pt`\n\nlinelist %&gt;% \n  select(gender, outcome) %&gt;% # selecione as variáveis de interesse\n  mutate(outcome=ifelse(outcome==\"Death\", \"Óbito\",\n                        ifelse(outcome==\"Recover\", \"Recuperado\",outcome))) %&gt;%  #só traduzindo \n  tbl_summary(by = outcome, # produza uma tabela resumo e especifique a variável de agrupamento\n              label = list( gender ~\"gênero\")) %&gt;% # traduzindo o rótulo\n  add_p()                        # especifique qual teste estatístico realizar %&gt;% \n\n1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCaracterísticas\nRecuperado, N = 1,9831\nÓbito, N = 2,5821\nValor p2\n\n\n\n\ngênero\n\n\n\n\n&gt;0.9\n\n\n    f\n953 (50%)\n1,227 (50%)\n\n\n\n\n    m\n950 (50%)\n1,228 (50%)\n\n\n\n\n    Desconhecido\n80\n127\n\n\n\n\n\n1 n (%)\n\n\n2 Teste qui-quadrado de independência\n\n\n\n\n\n\n\n\n\n\n\nTestes t\nCompare a diferença média de uma variável contínua em dois grupos. Por exemplo, compare a média das idades de acordo com a evolução clínica do paciente.\n\nlinelist %&gt;% \n  select(age_years, outcome) %&gt;%             # selecione as variáveis de interesse\n  mutate(outcome=ifelse(outcome==\"Death\", \"Óbito\",\n                        ifelse(outcome==\"Recover\", \"Recuperado\",outcome))) %&gt;%  #só traduzindo \n  tbl_summary(                               # produza uma tabela resumo\n    statistic = age_years ~ \"{mean} ({sd})\", # especifique quais estatísticas mostrar\n    by = outcome, # especifique a variável de agrupamento\n    label = list(age_years ~ \"idade\")) %&gt;%   # traduzindo                     \n  add_p(age_years ~ \"t.test\")                # especifique quais testes realizar\n\n1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCaracterísticas\nRecuperado, N = 1,9831\nÓbito, N = 2,5821\nValor p2\n\n\n\n\nidade\n16 (13)\n16 (12)\n0.6\n\n\n    Desconhecido\n28\n32\n\n\n\n\n\n1 Média (Desvio Padrão)\n\n\n2 Teste t com correção de Welch\n\n\n\n\n\n\n\n\n\n\n\nTeste de Wilcoxon\nCompare a distribuição de uma variável contínua em dois grupos. O padrão é utilizar o teste de Wilcoxon e a mediana (IQR) quando comparar dois grupos. Entretanto, para dados sem distribuição normal ou ao comparar grupos múltiplos, o teste de Kruskal-Wallis é o mais apropriado.\n\nlinelist %&gt;% \n  select(age_years, outcome) %&gt;%                       # selecione as variáveis de interesse\n  mutate(outcome=ifelse(outcome==\"Death\", \"Óbito\",\n                        ifelse(outcome==\"Recover\", \"Recuperado\",outcome))) %&gt;% # traduzindo\n  tbl_summary(                                         # produz uma tabela resumo\n    statistic = age_years ~ \"{median} ({p25}, {p75})\", # especifique quais estatísticas mostrar (estes valores são padrão e podem ser removidos)\n    by = outcome, # especifique a variável de agrupamento\n    label = list( age_years ~ \"idade\")) %&gt;%    # traduxindo                              \n  add_p(age_years ~ \"wilcox.test\")                     # especifique qual teste realizar (existem testes padrão, então é possível deixar os parênteses em branco)\n\n1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCaracterísticas\nRecuperado, N = 1,9831\nÓbito, N = 2,5821\nValor p2\n\n\n\n\nidade\n13 (6, 23)\n13 (6, 23)\n0.8\n\n\n    Desconhecido\n28\n32\n\n\n\n\n\n1 Mediana (AIQ)\n\n\n2 Teste de soma de postos de Wilcoxon\n\n\n\n\n\n\n\n\n\n\n\nTeste de Kruskal-wallis\nCompare a distribuição de uma variável contínua em dois ou mais grupos, independentemente dos dados terem distribuição normal ou não.\n\nlinelist %&gt;% \n  select(age_years, outcome) %&gt;%                       # selecione as variáveis de interesse\n  mutate(outcome=ifelse(outcome==\"Death\", \"Óbito\",\n                        ifelse(outcome==\"Recover\", \"Recuperado\",outcome))) %&gt;% # traduzindo\n  tbl_summary(                                         # produza tabelas resumo\n    statistic = age_years ~ \"{median} ({p25}, {p75})\", # especifique quais estatísticas mostrar (existem valores padrão, então pode-se deixar os parênteses em branco)\n    by = outcome, # especifique a variável de agrupamento\n    label = list(age_years ~ \"idade\")) %&gt;%     # traduzindo                             \n  add_p(age_years ~ \"kruskal.test\")                    # especifique qual teste realizar\n\n1323 observations missing `outcome` have been removed. To include these observations, use `forcats::fct_na_value_to_level()` on `outcome` column before passing to `tbl_summary()`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCaracterísticas\nRecuperado, N = 1,9831\nÓbito, N = 2,5821\nValor p2\n\n\n\n\nidade\n13 (6, 23)\n13 (6, 23)\n0.8\n\n\n    Desconhecido\n28\n32\n\n\n\n\n\n1 Mediana (AIQ)\n\n\n2 Teste de Kruskal-Wallis",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Testes estatísticos simples</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.pt.html#correlações",
    "href": "new_pages/stat_tests.pt.html#correlações",
    "title": "18  Testes estatísticos simples",
    "section": "18.5 Correlações",
    "text": "18.5 Correlações\nCorrelações entre variáveis numéricas podem ser investigadas utilizando os pacotes tidyverse corrr. Assim, é possível realizar os testes de correlação de Pearson, tau (\\(\\tau\\)) de Kendall ou rho (\\(\\rho\\)) de Spearman. O pacote cria uma tabela e tem uma função para gerar um gráfico os valores automaticamente.\n\ncorrelation_tab &lt;- linelist %&gt;% \n  select(generation, age, ct_blood, days_onset_hosp, wt_kg, ht_cm) %&gt;%   # selecione as variáveis numéricas de interesse\n  correlate()      # cria uma tabela de correlação (utilizando o teste padrão pearson)\n\ncorrelation_tab    # exporte a tabela para o terminal \n\n# A tibble: 6 × 7\n  term            generation      age ct_blood days_onset_hosp    wt_kg    ht_cm\n  &lt;chr&gt;                &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;           &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n1 generation        NA       -2.22e-2  0.179         -0.288    -0.0302  -0.00942\n2 age               -0.0222  NA        0.00849       -0.000635  0.833    0.877  \n3 ct_blood           0.179    8.49e-3 NA             -0.600    -0.00636  0.0181 \n4 days_onset_hosp   -0.288   -6.35e-4 -0.600         NA         0.0153  -0.00953\n5 wt_kg             -0.0302   8.33e-1 -0.00636        0.0153   NA        0.884  \n6 ht_cm             -0.00942  8.77e-1  0.0181        -0.00953   0.884   NA      \n\n## remove entradas duplicadas (a tabela acima é espelhada) \ncorrelation_tab &lt;- correlation_tab %&gt;% \n  shave()\n\n## visualize a a tabela de correlação\ncorrelation_tab\n\n# A tibble: 6 × 7\n  term            generation       age ct_blood days_onset_hosp  wt_kg ht_cm\n  &lt;chr&gt;                &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;           &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n1 generation        NA       NA        NA              NA       NA        NA\n2 age               -0.0222  NA        NA              NA       NA        NA\n3 ct_blood           0.179    0.00849  NA              NA       NA        NA\n4 days_onset_hosp   -0.288   -0.000635 -0.600          NA       NA        NA\n5 wt_kg             -0.0302   0.833    -0.00636         0.0153  NA        NA\n6 ht_cm             -0.00942  0.877     0.0181         -0.00953  0.884    NA\n\n## plote as correlações\nrplot(correlation_tab)",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Testes estatísticos simples</span>"
    ]
  },
  {
    "objectID": "new_pages/stat_tests.pt.html#recursos",
    "href": "new_pages/stat_tests.pt.html#recursos",
    "title": "18  Testes estatísticos simples",
    "section": "18.6 Recursos",
    "text": "18.6 Recursos\nMuitas informações dessa página foram adaptadas dos recursos e tutoriais online abaixo:\ngtsummary dplyr corrr sthda correlation",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Testes estatísticos simples</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.pt.html",
    "href": "new_pages/regression.pt.html",
    "title": "19  Regressão simples e múltipla",
    "section": "",
    "text": "19.1 Preparação",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Regressão simples e múltipla</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.pt.html#preparação",
    "href": "new_pages/regression.pt.html#preparação",
    "title": "19  Regressão simples e múltipla",
    "section": "",
    "text": "Carregue os pacotes\nEste código realiza o carregamento dos pacotes necessários para as análises. Neste manual, nós enfatizamos o uso da função p_load(), do pacote pacman, que instala os pacotes, caso necessário, e os carrega para utilização. Você também pode utilizar a função library(), do pacote R base , para carregar pacotes instalados. Veja a página sobre o Introdução ao R](#basics) para mais informações sobre os pacotes R.\n\npacman::p_load(\n  rio,          # Importa arquivos\n  here,         # Localiza arquivos\n  tidyverse,    # gestão dos dados + gráficos no ggplot2\n  stringr,      # manipulação de textos em formato string\n  purrr,        # explore os objetos de forma organizada\n  gtsummary,    # resumos estatísticos e testes\n  broom,        # organize os resultados das regressões\n  lmtest,       # testes de relação de verosimilhança\n  parameters,   # alternativa para organizar os resultados das regressões\n  see           # alternativa para visualizar os gráficos em floresta\n  )\n\n\n\nImporte os dados\nNós iremos importar o banco de dados dos casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar os passos abaixo, clique aqui para fazer o download do banco de dados ‘limpo’ (como arquivo .rds). Importe seus dados utilizando a função import(), do pacote rio (esta função importa muitos tipos de arquivos, como .xlsx, .rds, .csv - veja a página Importar e exportar para detalhes).\n\n# importe os dados no R no objeto linelist\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nAs primeiras 50 linhas do linelist são mostradas abaixo.\n\n\n\n\n\n\n\n\nLimpando os dados\n\nArmazene as variáveis explicativas\nNo código abaixo, os nomes das colunas explicativas são salvos como um vetor de caracteres. Eles serão utilizados posteriormente.\n\n## escolha as variáveis de interesse\nexplanatory_vars &lt;- c(\"gender\", \"fever\", \"chills\", \"cough\", \"aches\", \"vomit\")\n\n\n\nConverta para 1s e 0s\nAbaixo, as colunas de variáveis explicativas com as opções binárias “yes”/“no”, “m”/“f”, e “dead”/“alive” são convertidas para 1 / 0, visando serem utilizadas nos modelos de regressão. Para fazer isso de forma eficiente, utilize a função across(), do dplyr, para transformar múltiplas colunas de uma vez. A função case_when() (também do dplyr) utiliza argumentos lógicos para converter valores específicos para 1s ou 0s. Veja as seções das funções across() e case_when() na página de limpando dados e funções essenciais).\nNota: o “.” abaixo representa a coluna que está sendo processada pela função across() no momento.\n\n## converte variáveis dicotômicas para 0/1 \nlinelist &lt;- linelist %&gt;%  \n  mutate(across(                                      \n    .cols = all_of(c(explanatory_vars, \"outcome\")),  ## para cada coluna listada e \"outcome\"\n    .fns = ~case_when(                              \n      . %in% c(\"m\", \"yes\", \"Death\")   ~ 1,           ## transforma male/yes/death em 1\n      . %in% c(\"f\", \"no\",  \"Recover\") ~ 0,           ## transforma female/no/recover em 0\n      TRUE                            ~ NA_real_)    ## do contrário, transforma em 'missing'\n    )\n  )\n\n\n\nExclua linhas com valores em branco\nPara excluir linhas com valores em branco, é possível utilizar a função drop_na(), do pacote tidyr. Entretanto, nós queremos que isso aconteça apenas nas linhas com campos em branco nas colunas de interesse.\nA primeira coisa a fazer é garantir que o nosso vetor explanatory_vars contenha a coluna age (age deve ter gerado um erro na operação anterior utilizando case_when(), que era apenas para variáveis dicotômicas). Então, nós utilizamos o objeto linelist na função drop_na() para remover qualquer linha com campos em branco na coluna outcome ou em qualquer uma das colunas salvas em explanatory_vars.\nAntes de executar o código, o número de linhas no objeto linelist é obtido por nrow(linelist).\n\n## adiciona a coluna age_category no vetor explanatory_vars \nexplanatory_vars &lt;- c(explanatory_vars, \"age_cat\")\n\n## exclua linhas com campos em branco nas variáveis de interesse\nlinelist &lt;- linelist %&gt;% \n  drop_na(any_of(c(\"outcome\", explanatory_vars)))\n\nO número de linhas restante no linelist é nrow(linelist).",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Regressão simples e múltipla</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.pt.html#univariado",
    "href": "new_pages/regression.pt.html#univariado",
    "title": "19  Regressão simples e múltipla",
    "section": "19.2 Univariado",
    "text": "19.2 Univariado\nAssim como na página sobre Tabelas descritivas, os seus objetivos irão determinar quais pacotes R utilizar. Aqui, nós apresentamos duas opções para realizar análises univariadas:\n\nUtilize as funções disponíveis no pacote R base para rapidamente obter os resultados no terminal. Utilize o pacote broom para organizar os resultados.\nUtilize o pacote gtsummary para modelar e obter resultados prontos para publicação\n\n\n\nPacote R base\n\nRegressão linear\nA função lm(), do R base, executa regressões lineares, avaliando a relação entre respostas numéricas e variáveis explanatórias (independentes), que se presume terem uma relação linear.\nForneça a equação como uma fórmula, com os nomes das colunas contendo as respostas numéricas e as variáveis explanatórias separadas por um til ~. Adicionalmente, especifique qual o banco de dados em data =. Para utiliza-los posteriormente, atribua os resultados da modelagem a um objeto R.\n\nlm_results &lt;- lm(ht_cm ~ age, data = linelist)\n\nVocê pode executar a função summary() nos resultados obtidos para visualizar os coeficientes (Estimates), p-valor, resíduos, e outras medições.\n\nsummary(lm_results)\n\n\nCall:\nlm(formula = ht_cm ~ age, data = linelist)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-128.579  -15.854    1.177   15.887  175.483 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  69.9051     0.5979   116.9   &lt;2e-16 ***\nage           3.4354     0.0293   117.2   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 23.75 on 4165 degrees of freedom\nMultiple R-squared:  0.7675,    Adjusted R-squared:  0.7674 \nF-statistic: 1.375e+04 on 1 and 4165 DF,  p-value: &lt; 2.2e-16\n\n\nAlternativamente, é possível utilizar a função tidy(), do pacote broom, para organizar os resultados em uma tabela. O que os resultados nos mostram é que, a cada ano, a altura aumenta em 3.5 cm, e isto é estatisticamente significativo.\n\ntidy(lm_results)\n\n# A tibble: 2 × 5\n  term        estimate std.error statistic p.value\n  &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;\n1 (Intercept)    69.9     0.598       117.       0\n2 age             3.44    0.0293      117.       0\n\n\nVocê também pode adicionar essa regressão na função ggplot. Para tanto, primeiro plotamos os dados observados e a linha de tendência da regressão linear em um quadro de dados utilizando a função augment(), do pacote broom.\n\n## coloque os pontos da regressão e os dados observados em um banco de dados\npoints &lt;- augment(lm_results)\n\n## trace um gráfico dos dados utilizando a variável 'age' no eixo x\nggplot(points, aes(x = age)) + \n  ## inclua os pontos para a altura\n  geom_point(aes(y = ht_cm)) + \n  ## inclua a linha de tendência da regressão linear\n  geom_line(aes(y = .fitted), colour = \"red\")\n\n\n\n\n\n\n\n\nTambém é possível adicionar uma linha simples de regressão linear diretamente no ggplot, utilizando a função geom_smooth().\n\n## coloque seus dados em um gráfico\n ggplot(linelist, aes(x = age, y = ht_cm)) + \n  ## mostre os pontos\n  geom_point() + \n  ## inclua uma regressão linear\n  geom_smooth(method = \"lm\", se = FALSE)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nVeja a seção sobre Recursos extras no final deste capítulo para mais tutoriais detalhados.\n\n\nRegressão logística\nA função glm(), do pacote stats (parte do pacote R base), é utilizada para ajustar Modelos Lineares Generalizados (GLM).\nglm() pode ser utilizada para regressões logísticas univariadas e multivariadas (ex.: para obter probabilidades). Aqui estão as partes principais:\n\n# argumentos utilizados na função glm()\nglm(formula, family, data, weights, subset, ...)\n\n\nformula = o modelo é fornecido ao glm() como uma equação, com o resultado no lado esquerdo e as variáveis explicativas no lado direito de um til ~.\nfamily = Isto determina o tipo de modelo a ser executado. Para regressão logística, utilize family = \"binomial\", para o modelo log-linear de poisson utilize family = \"poisson\". Outros exemplos estão na tabela abaixo.\ndata = Especifique sua fonte de dados\n\nSe necessário, você pode especificar o link da função utilizando a sintaxe family = familytype(link = \"linkfunction\")). Você pode obter mais informações sobre outras famílias e argumentos opcionais, como weights = e subset = (?glm), na documentação.\n\n\n\nFamília\nLink padrão da função\n\n\n\n\n\"binomial\"\n(link = \"logit\")\n\n\n\"gaussian\"\n(link = \"identity\")\n\n\n\"Gamma\"\n(link = \"inverse\")\n\n\n\"inverse.gaussian\"\n(link = \"1/mu^2\")\n\n\n\"poisson\"\n(link = \"log\")\n\n\n\"quasi\"\n(link = \"identity\", variance = \"constant\")\n\n\n\"quasibinomial\"\n(link = \"logit\")\n\n\n\"quasipoisson\"\n(link = \"log\")\n\n\n\nAo executar a funçaõ glm(), é comum salvar os resultados em um objeto R. Assim, você pode visualizar os resultados em seu terminal utilizando a função summary(), como mostrado abaixo, ou realizar outras operações com os resultados (ex.: potenciação).\nSe você precisa executar uma regressão binominal negativa, é possível utilizar o pacote MASS; a função glm.nb() utiliza a mesma sintaxe que glm(). Para um passo a passo sobre os diferentes modelos de regressão, acesse a página sobre estatística da UCLA.\n\n\nFunção glm() univariada\nNeste exemplo, nós iremos avaliar a associação entre diferentes categorias de idades e a evolução para óbito (codificado como 1 na seção de Preparação). Abaixo está um modelo univariado de outcome por age_cat. Os resultados do modelo são savos como model, e mostrados no terminal com a função summary(). Observe que as estimativas fornecidas são as probabilidades em log, onde o nível base é o primeiro Factor (classe Factor) da variável age_cat(“0-4”).\n\nmodel &lt;- glm(outcome ~ age_cat, family = \"binomial\", data = linelist)\nsummary(model)\n\n\nCall:\nglm(formula = outcome ~ age_cat, family = \"binomial\", data = linelist)\n\nCoefficients:\n              Estimate Std. Error z value Pr(&gt;|z|)   \n(Intercept)   0.233738   0.072805   3.210  0.00133 **\nage_cat5-9   -0.062898   0.101733  -0.618  0.53640   \nage_cat10-14  0.138204   0.107186   1.289  0.19726   \nage_cat15-19 -0.005565   0.113343  -0.049  0.96084   \nage_cat20-29  0.027511   0.102133   0.269  0.78765   \nage_cat30-49  0.063764   0.113771   0.560  0.57517   \nage_cat50-69 -0.387889   0.259240  -1.496  0.13459   \nage_cat70+   -0.639203   0.915770  -0.698  0.48518   \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 5712.4  on 4166  degrees of freedom\nResidual deviance: 5705.1  on 4159  degrees of freedom\nAIC: 5721.1\n\nNumber of Fisher Scoring iterations: 4\n\n\nPara alterar o nível base de comparação de dada variável, garanta que a coluna é da classe Factor e altere a primeira posição ao nível desejado utilizando a função fct_relevel() (veja a página sobre Fatores). Por exemplo, abaixo nós adaptamos a coluna age_cat e escolhemos “20-29” como nível base antes de aplicar estes dados na função glm().\n\nlinelist %&gt;% \n  mutate(age_cat = fct_relevel(age_cat, \"20-29\", after = 0)) %&gt;% \n  glm(formula = outcome ~ age_cat, family = \"binomial\") %&gt;% \n  summary()\n\n\nCall:\nglm(formula = outcome ~ age_cat, family = \"binomial\", data = .)\n\nCoefficients:\n             Estimate Std. Error z value Pr(&gt;|z|)    \n(Intercept)   0.26125    0.07163   3.647 0.000265 ***\nage_cat0-4   -0.02751    0.10213  -0.269 0.787652    \nage_cat5-9   -0.09041    0.10090  -0.896 0.370220    \nage_cat10-14  0.11069    0.10639   1.040 0.298133    \nage_cat15-19 -0.03308    0.11259  -0.294 0.768934    \nage_cat30-49  0.03625    0.11302   0.321 0.748390    \nage_cat50-69 -0.41540    0.25891  -1.604 0.108625    \nage_cat70+   -0.66671    0.91568  -0.728 0.466546    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 5712.4  on 4166  degrees of freedom\nResidual deviance: 5705.1  on 4159  degrees of freedom\nAIC: 5721.1\n\nNumber of Fisher Scoring iterations: 4\n\n\n\n\nVizualizando os resultados\nNa maioria das vezes, diferentes modificações precisam ser feitas nos resultados acima. A função tidy(), do pacote broom, é conveniente para transformar os resultados em um formato apresentável.\nAqui, nós demonstramos como combinar o resultado da modelagem com uma tabela de contagens.\n\nObtenha as probabilidades em log na forma exponencial e os intervalos de confiança ao aplicar o modelo na função tidy(), e ajustar os atributos exponentiate = TRUE e conf.int = TRUE.\n\n\nmodel &lt;- glm(outcome ~ age_cat, family = \"binomial\", data = linelist) %&gt;% \n  tidy(exponentiate = TRUE, conf.int = TRUE) %&gt;%        # realize a potenciação e produza intervalos de confiança\n  mutate(across(where(is.numeric), round, digits = 2))  # arredonde todas as colunas numéricas\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `across(where(is.numeric), round, digits = 2)`.\nCaused by warning:\n! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\nSupply arguments directly to `.fns` through an anonymous function instead.\n\n  # Previously\n  across(a:b, mean, na.rm = TRUE)\n\n  # Now\n  across(a:b, \\(x) mean(x, na.rm = TRUE))\n\n\nAbaixo é o objeto model mostrado de forma organizada:\n\n\n\n\n\n\n\nCombine os resultados dessa modelagem com uma tabela de contagens. Abaixo, nós criamos uma tabela cruzada de contagens com a função tabyl() do pacote janitor, como descrito na página sobre Tabelas descritivas:\n\n\ncounts_table &lt;- linelist %&gt;% \n  janitor::tabyl(age_cat, outcome)\n\n\n\n\n\n\n\n\n\n\n\nAqui está como os dados em counts_table ficam quando tabelados:\n\n\n\n\n\n\nAgora nós podemos ligar os resultados dos objetos counts_table e model horizontalmente com a função bind_cols() (dplyr). Lembre que, com a função bind_cols(), as linhas dos dois objetos precisam estar alinhadas perfeitamente. Neste código, porque estamos ligando uma cadeia de comandos, nós utilizamos o . para representar o objeto de counts_table enquanto o ligamos ao model. Para finalizar o processo, a função select() é utilizada para selecionar colunas de interesse e sua ordem, e finalmente aplicar a função round(), do R base, em todas as colunas numéricas para até duas casas decimais.\n\ncombined &lt;- counts_table %&gt;%           # inicie com uma tabela de contagens\n  bind_cols(., model) %&gt;%              # combine ela com os resultados da regressão\n  select(term, 2:3, estimate,          # selecione e organize as colunas\n         conf.low, conf.high, p.value) %&gt;% \n  mutate(across(where(is.numeric), round, digits = 2)) # arredonde para 2 casas decimais\n\nAqui está o resultado da combinação de duas tabelas, exportado como um bela imagem utilizando uma função do flextable. A página Tabelas para apresentação explica como customizar tais tabelas com o flextable, mas você pode utilizar outros inúmeros pacotes do R, como knitr ou GT.\n\ncombined &lt;- combined %&gt;% \n  flextable::qflextable()\n\n\n\nRodando múltiplos modelos univariados\nAbaixo, nós mostramos um método usando glm()e tidy(). Para uma abordagem mais simples, veja a seção sobre o gtsummary.\nPara rodar os modelos com diferentes variáveis e produzir probabilidades univariadas (ex.: sem dependência entre elas), você pode utilizar a abordagem abaixo. Ela utiliza a função str_c(), do pacote stringr, para criar fórmulas univaridas (veja a página caracteres e strings), e rodar a regressão glm()com cada fórmula, aplicando cada resultado glm() no tidy(), e, finalmente, unindo todos os resultados dos modelos com a função bind_rows(), do pacote tidyr. Esta abordagem utiliza a função map(), do pacote purrr, para repetir as funções - veja a página sobre Iteração, loops, e listas para mais informações sobre essa ferramenta.\n\nCrie um vetor com o nome das colunas com as variáveis explicativas. Nós já criamos este vetor como explanatory_vars na seção Preparação desta página.\nUtilize a função str_c() para criar múltiplas fórmulas em texto, com o outcome no lado esquerdo, e o nome de uma coluna do explanatory_varsno lado direito. O ponto final ‘.’ é substituído pelo nome da coluna em explanatory_vars.\n\n\nexplanatory_vars %&gt;% str_c(\"outcome ~ \", .)\n\n[1] \"outcome ~ gender\"  \"outcome ~ fever\"   \"outcome ~ chills\" \n[4] \"outcome ~ cough\"   \"outcome ~ aches\"   \"outcome ~ vomit\"  \n[7] \"outcome ~ age_cat\"\n\n\n\nUtilize essas fórmulas na função map() e ajuste ~glm() como a função a ser utilizada com cada entrada. Dentro da função glm(), ajuste a fórmula de regressão para as.formula(.x), onde .x será substituído pela fórmula definida na etapa acima. A função map()irá rodar com cada uma das fórmulas, executando regressões para cada uma.\nOs resultados deste primeiro map() são utilizados em um segundo comando map(), que aplica tidy() nos resultados das regressões.\nFinalmente, o resultado do segundo map() (uma lista de quadros de dados organizados) é condensado com a função bind_rows(), resultando em um quadro de dados com todos os resultados univariados.\n\n\nmodels &lt;- explanatory_vars %&gt;%       # inicie com as variáveis de interesse\n  str_c(\"outcome ~ \", .) %&gt;%         # combine cada variável na fórmula (\"outcome ~ variável de interesse\")\n  \n  # repita as etapas para cada fórmula univariável\n  map(                               \n    .f = ~glm(                       # utilize as fórmulas uma por uma no glm()\n      formula = as.formula(.x),      # dentro do glm(), a formula é representada por .x\n      family = \"binomial\",           # especifique o tipo do glm (logístico)\n      data = linelist)) %&gt;%          # indique o banco de dados\n  \n  # organize cada um dos resultados das regressões acima\n  map(\n    .f = ~tidy(\n      .x, \n      exponentiate = TRUE,           # realize a exponenciação\n      conf.int = TRUE)) %&gt;%          # obtenha os intervalos de confiança\n  \n  # condensa a lista dos resultados das regressões em um único quadro de dados\n  bind_rows() %&gt;% \n  \n  # arredonde todas as colunas numéricas\n  mutate(across(where(is.numeric), round, digits = 2))\n\nDesta vez, o objeto final models é maior porque agora representa os resultados combinados de diferentes regressões univariadas. Clique na tabela para visualizar todas as linhas do model.\n\n\n\n\n\n\nComo antes, nós podemos criar uma tabela de contagem do objeto linelist para cada variável explicativa, ligar ela no objeto models, e fazer uma bela tabela. Nós podemos começar com as variáveis, e repetir os processos com a função map(). Nós repetimos a execução de uma função definida pelo usuário, que envolve a criação de uma tabela de contagem utilizando as funções do dplyr. Então, os resultados são combinados e ligados com os resultados de models.\n\n## para cada variável explanatória\nuniv_tab_base &lt;- explanatory_vars %&gt;% \n  map(.f = \n    ~{linelist %&gt;%                ## inicie com o linelist\n        group_by(outcome) %&gt;%     ## agrupe os dados por outcome\n        count(.data[[.x]]) %&gt;%    ## produza contagens das variáveis de interesse\n        pivot_wider(              ## transforme para o formato amplo (wide), como em uma tabulação cruzada\n          names_from = outcome,\n          values_from = n) %&gt;% \n        drop_na(.data[[.x]]) %&gt;%         ## exclua as linhas com campos em branco\n        rename(\"variable\" = .x) %&gt;%      ## altere a coluna com a variável de interesse para \"variable\"\n        mutate(variable = as.character(variable))} ## converta para caractéres, do contrário as variáveis não dicotômicas (categóricas) geram a classe factor e não podem ser unidas\n      ) %&gt;% \n  \n  ## condensa a lista com o resultado das contagens em um único quadro de dados\n  bind_rows() %&gt;% \n  \n  ## une com os resultados da regressão\n  bind_cols(., models) %&gt;% \n  \n  ## mantenha apenas as colunas de interesse\n  select(term, 2:3, estimate, conf.low, conf.high, p.value) %&gt;% \n  \n  ## arredonde as casas decimais\n  mutate(across(where(is.numeric), round, digits = 2))\n\nAbaixo é como o quadro de dados fica após a execução do código. Veja a página sobre Tabelas para apresentação para ideias de como converter essa tabela para um formato bonito em HTML (ex.: com flextable).\n\n\n\n\n\n\n\n\n\n\nPacote gtsummary\nAbaixo, nós apresentamos o uso da função tbl_uvregression() do pacote gtsummary. Assim como na página sobre Tabelas descritivas, as funções do gtsummary fazem um bom trabalho executando estatísticas e produzindo resultados com aparência profissional. A função tbl_uvregression() produz uma tabela com os resultados de uma regressão univariada.\nPrimeiro, nós selecionamos apenas as colunas de interesse do objeto linelist (variáveis explanatórias e a variável de evolução clínica [outcome]), e as aplicamos na função tbl_uvregression(). Então, iremos executar uma regressão univariada em cada uma das colunas definidas no vetor explanatory_vars, previamente criado na seção sobre Preparação dos dados (colunas gender, fever, chills, cough, aches, vomit, e age_cat).\nDentro da função, os atributos serão modificados, como em method = ao glm (sem aspas), o y = com a coluna de evolução dos casos (outcome), especificar para o method.args = que queremos rodar uma regressão logística através do atributo family = binomial, e então finalizamos com um comando para realizar a exponenciação dos resultados.\nO resultado é gerado no formado HTML, e contém as contagens\n\nuniv_tab &lt;- linelist %&gt;% \n  dplyr::select(explanatory_vars, outcome) %&gt;% ## selecione as variáveis de interesse\n\n  tbl_uvregression(                         ## produz uma tabela univariável\n    method = glm,                           ## define qual regressão será rodada (glm)\n    y = outcome,                            ## define a variável da evolução clínica (outcome)\n    method.args = list(family = binomial),  ## define qual tipo de glm será rodador (logístico)\n    exponentiate = TRUE                     ## realiza a exponenciação para produzir as probabilidades (em vez de probabilidaes em log)\n  )\n\n## visualize a tabela com os resultados da análise univariada\nuniv_tab\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nN\nOR1\n95% CI1\np-value\n\n\n\n\ngender\n4,167\n1.00\n0.88, 1.13\n&gt;0.9\n\n\nfever\n4,167\n1.00\n0.85, 1.17\n&gt;0.9\n\n\nchills\n4,167\n1.03\n0.89, 1.21\n0.7\n\n\ncough\n4,167\n1.15\n0.97, 1.37\n0.11\n\n\naches\n4,167\n0.93\n0.76, 1.14\n0.5\n\n\nvomit\n4,167\n1.09\n0.96, 1.23\n0.2\n\n\nage_cat\n4,167\n\n\n\n\n\n\n\n\n    0-4\n\n\n—\n—\n\n\n\n\n    5-9\n\n\n0.94\n0.77, 1.15\n0.5\n\n\n    10-14\n\n\n1.15\n0.93, 1.42\n0.2\n\n\n    15-19\n\n\n0.99\n0.80, 1.24\n&gt;0.9\n\n\n    20-29\n\n\n1.03\n0.84, 1.26\n0.8\n\n\n    30-49\n\n\n1.07\n0.85, 1.33\n0.6\n\n\n    50-69\n\n\n0.68\n0.41, 1.13\n0.13\n\n\n    70+\n\n\n0.53\n0.07, 3.20\n0.5\n\n\n\n1 OR = Odds Ratio, CI = Confidence Interval\n\n\n\n\n\n\n\n\n\nExitem muitas modificações que podem ser feitas com a tabela gerada, como ajustar os rótulos em texto, destacar linhas pelo seu valor de p, etc. Veja tutoriais aqui e em outras fontes online.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Regressão simples e múltipla</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.pt.html#análise-estratificada",
    "href": "new_pages/regression.pt.html#análise-estratificada",
    "title": "19  Regressão simples e múltipla",
    "section": "19.3 Análise estratificada",
    "text": "19.3 Análise estratificada\nA seção sobre análise estratificada ainda está sendo trabalhada no gtsummary. Esta página será atualizada quando possível.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Regressão simples e múltipla</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.pt.html#multivariada",
    "href": "new_pages/regression.pt.html#multivariada",
    "title": "19  Regressão simples e múltipla",
    "section": "19.4 Multivariada",
    "text": "19.4 Multivariada\nPara a análise multivariada, novamente apresentamos duas abordagens:\n\nglm() e tidy()\n\npacote gtsummary\n\nO fluxo de trabalho é similar para cada uma das abordagens, sendo apenas a última diferente quando a tabela final é obtida.\n\nConduza a análise multivariada\nAqui nós utilizamos a função glm(), mas adicionaremos mais variáveis no lado direito da equação, separadas pelos símbolos de mais (+).\nPara rodar o modelo com todas as nossas variáveis exploratórias, nós executamos o seguinte código:\n\nmv_reg &lt;- glm(outcome ~ gender + fever + chills + cough + aches + vomit + age_cat, family = \"binomial\", data = linelist)\n\nsummary(mv_reg)\n\n\nCall:\nglm(formula = outcome ~ gender + fever + chills + cough + aches + \n    vomit + age_cat, family = \"binomial\", data = linelist)\n\nCoefficients:\n              Estimate Std. Error z value Pr(&gt;|z|)\n(Intercept)   0.069054   0.131726   0.524    0.600\ngender        0.002448   0.065133   0.038    0.970\nfever         0.004309   0.080522   0.054    0.957\nchills        0.034112   0.078924   0.432    0.666\ncough         0.138584   0.089909   1.541    0.123\naches        -0.070705   0.104078  -0.679    0.497\nvomit         0.086098   0.062618   1.375    0.169\nage_cat5-9   -0.063562   0.101851  -0.624    0.533\nage_cat10-14  0.136372   0.107275   1.271    0.204\nage_cat15-19 -0.011074   0.113640  -0.097    0.922\nage_cat20-29  0.026552   0.102780   0.258    0.796\nage_cat30-49  0.059569   0.116402   0.512    0.609\nage_cat50-69 -0.388964   0.262384  -1.482    0.138\nage_cat70+   -0.647443   0.917375  -0.706    0.480\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 5712.4  on 4166  degrees of freedom\nResidual deviance: 5700.2  on 4153  degrees of freedom\nAIC: 5728.2\n\nNumber of Fisher Scoring iterations: 4\n\n\nSe você quiser incluir duas variáveis e uma interação entre elas, é possível separá-las com um asterisco * em vez do +. Separe eles com dois pontos : se você está especificando apenas a interação. Por exemplo:\n\nglm(outcome ~ gender + age_cat * fever, family = \"binomial\", data = linelist)\n\nOpcionalmente, você pode utilizar este código para nivelar o vetor pré-definido com os nomes das colunas, e re-criar o comando acima utilizando a função str_c(). Isto pode ser útil caso os nomes das suas variáveis explicativas estiverem mudando, ou se você não quiser digitar todas elas novamente.\n\n## rode uma regressão com todas as variáveis de interesse\nmv_reg &lt;- explanatory_vars %&gt;%  ## inicie com um vetor contendo o nome das colunas explicativas\n  str_c(collapse = \"+\") %&gt;%     ## combine todos os nomes das variáveis de interesse separados por um 'mais'\n  str_c(\"outcome ~ \", .) %&gt;%    ## combine os nomes das variáveis de interesse com o 'outcome' no estilo de fórmula\n  glm(family = \"binomial\",      ## defina o tipo de glm como logístico,\n      data = linelist)          ## defina seu banco de dados\n\n\nConstruíndo o modelo\nÉ possível construir seu modelo passo a passo, salvando diferentes modelos que incluem certas variáveis explicativas. Esses modelos podem ser comparados com os testes de probabilidade utilizando a função lrtest(), do pacote lmtest, como mostrado abaixo:\nNOTA: Utilizar o teste anova(model1, model2, test = \"Chisq) do R base produz os mesmos resultados \n\nmodel1 &lt;- glm(outcome ~ age_cat, family = \"binomial\", data = linelist)\nmodel2 &lt;- glm(outcome ~ age_cat + gender, family = \"binomial\", data = linelist)\n\nlmtest::lrtest(model1, model2)\n\nLikelihood ratio test\n\nModel 1: outcome ~ age_cat\nModel 2: outcome ~ age_cat + gender\n  #Df  LogLik Df Chisq Pr(&gt;Chisq)\n1   8 -2852.6                    \n2   9 -2852.6  1 2e-04     0.9883\n\n\nOutra opção é utilizar o objeto modelado diretamente na função step(), do pacote stats. Especifique qual a direção da seleção das variáveis que quer utilizar quando for construir o modelo.\n\n## escolha um modelo utilizando a seleção 'foward' baseada no AIC\n## você também pode escolher \"backward\" ou \"both\" ao ajustar a direção\nfinal_mv_reg &lt;- mv_reg %&gt;%\n  step(direction = \"forward\", trace = FALSE)\n\nPara facilitar a visualização, é possível desativar a notação científica na sua sessão do R:\n\noptions(scipen=999)\n\nComo descrito na seção sobre análise univariada, aplique o resultado da modelagem na função tidy() para potencializar as probabilidades em log e os intervalos de confiança. Finalmente, todas as colunas numéricas são arredondadads para duas casas decimais. Role o cursor para visualizar todas as linhas.\n\nmv_tab_base &lt;- final_mv_reg %&gt;% \n  broom::tidy(exponentiate = TRUE, conf.int = TRUE) %&gt;%  ## obtenha um quadro de dados organizado das estimativas\n  mutate(across(where(is.numeric), round, digits = 2))          ## arredonde \n\nAqui está o quadro de dados final:\n\n\n\n\n\n\n\n\n\n\nCombine as análises univariadas e multivariadas\n\nCombine com o gtsummary\nO pacote gtsummary possui a função tbl_regression(), que utiliza os resultados de uma regressão (glm() neste caso) e produz uma linda tabela resumo.\n\n## mostra a tabela de resultados de uma regressão\nmv_tab &lt;- tbl_regression(final_mv_reg, exponentiate = TRUE)\n\nVamos visualizar a tabela:\n\nmv_tab\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nOR1\n95% CI1\np-value\n\n\n\n\ngender\n1.00\n0.88, 1.14\n&gt;0.9\n\n\nfever\n1.00\n0.86, 1.18\n&gt;0.9\n\n\nchills\n1.03\n0.89, 1.21\n0.7\n\n\ncough\n1.15\n0.96, 1.37\n0.12\n\n\naches\n0.93\n0.76, 1.14\n0.5\n\n\nvomit\n1.09\n0.96, 1.23\n0.2\n\n\nage_cat\n\n\n\n\n\n\n\n\n    0-4\n—\n—\n\n\n\n\n    5-9\n0.94\n0.77, 1.15\n0.5\n\n\n    10-14\n1.15\n0.93, 1.41\n0.2\n\n\n    15-19\n0.99\n0.79, 1.24\n&gt;0.9\n\n\n    20-29\n1.03\n0.84, 1.26\n0.8\n\n\n    30-49\n1.06\n0.85, 1.33\n0.6\n\n\n    50-69\n0.68\n0.40, 1.13\n0.14\n\n\n    70+\n0.52\n0.07, 3.19\n0.5\n\n\n\n1 OR = Odds Ratio, CI = Confidence Interval\n\n\n\n\n\n\n\n\n\nTambém é possível combinar diferentes tabelas de resultados produzidas pelo gtsummary com a função tbl_merge(). Assim, podemos combinar os resultados multivariados com os resultados univariados do gtsummary que criamos acima:\n\n## combine com os resultados univariados\ntbl_merge(\n  tbls = list(univ_tab, mv_tab),                          # combine as tabelas\n  tab_spanner = c(\"**Univariate**\", \"**Multivariable**\")) # escolha o nome dos cabeçalhos\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nUnivariate\nMultivariable\n\n\nN\nOR1\n95% CI1\np-value\nOR1\n95% CI1\np-value\n\n\n\n\ngender\n4,167\n1.00\n0.88, 1.13\n&gt;0.9\n1.00\n0.88, 1.14\n&gt;0.9\n\n\nfever\n4,167\n1.00\n0.85, 1.17\n&gt;0.9\n1.00\n0.86, 1.18\n&gt;0.9\n\n\nchills\n4,167\n1.03\n0.89, 1.21\n0.7\n1.03\n0.89, 1.21\n0.7\n\n\ncough\n4,167\n1.15\n0.97, 1.37\n0.11\n1.15\n0.96, 1.37\n0.12\n\n\naches\n4,167\n0.93\n0.76, 1.14\n0.5\n0.93\n0.76, 1.14\n0.5\n\n\nvomit\n4,167\n1.09\n0.96, 1.23\n0.2\n1.09\n0.96, 1.23\n0.2\n\n\nage_cat\n4,167\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    0-4\n\n\n—\n—\n\n\n—\n—\n\n\n\n\n    5-9\n\n\n0.94\n0.77, 1.15\n0.5\n0.94\n0.77, 1.15\n0.5\n\n\n    10-14\n\n\n1.15\n0.93, 1.42\n0.2\n1.15\n0.93, 1.41\n0.2\n\n\n    15-19\n\n\n0.99\n0.80, 1.24\n&gt;0.9\n0.99\n0.79, 1.24\n&gt;0.9\n\n\n    20-29\n\n\n1.03\n0.84, 1.26\n0.8\n1.03\n0.84, 1.26\n0.8\n\n\n    30-49\n\n\n1.07\n0.85, 1.33\n0.6\n1.06\n0.85, 1.33\n0.6\n\n\n    50-69\n\n\n0.68\n0.41, 1.13\n0.13\n0.68\n0.40, 1.13\n0.14\n\n\n    70+\n\n\n0.53\n0.07, 3.20\n0.5\n0.52\n0.07, 3.19\n0.5\n\n\n\n1 OR = Odds Ratio, CI = Confidence Interval\n\n\n\n\n\n\n\n\n\n\n\nCombine com o pacote dplyr\nUma alternativa para combinar os resultados univariados e multivariados do glm()/tidy() é com as funções de união do dplyr.\n\nUna os resultados univariados anteriores (univ_tab_base, com contagens) com os resultados multivariados organizados mv_tab_base\n\nUse a função select() para manter apenas as colunas de interesse, especificar a sua ordem, e renomear elas\nUse a função round() com duas casas decimais em todas as colunas da classe Double\n\n\n## combine tabelas univariadas e multivariadas \nleft_join(univ_tab_base, mv_tab_base, by = \"term\") %&gt;% \n  ## escolha as colunas e as renomeie\n  select( # new name =  old name\n    \"characteristic\" = term, \n    \"recovered\"      = \"0\", \n    \"dead\"           = \"1\", \n    \"univ_or\"        = estimate.x, \n    \"univ_ci_low\"    = conf.low.x, \n    \"univ_ci_high\"   = conf.high.x,\n    \"univ_pval\"      = p.value.x, \n    \"mv_or\"          = estimate.y, \n    \"mvv_ci_low\"     = conf.low.y, \n    \"mv_ci_high\"     = conf.high.y,\n    \"mv_pval\"        = p.value.y \n  ) %&gt;% \n  mutate(across(where(is.double), round, 2))   \n\n# A tibble: 20 × 11\n   characteristic recovered  dead univ_or univ_ci_low univ_ci_high univ_pval\n   &lt;chr&gt;              &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;     &lt;dbl&gt;\n 1 (Intercept)          909  1168    1.28        1.18         1.4       0   \n 2 gender               916  1174    1           0.88         1.13      0.97\n 3 (Intercept)          340   436    1.28        1.11         1.48      0   \n 4 fever               1485  1906    1           0.85         1.17      0.99\n 5 (Intercept)         1472  1877    1.28        1.19         1.37      0   \n 6 chills               353   465    1.03        0.89         1.21      0.68\n 7 (Intercept)          272   309    1.14        0.97         1.34      0.13\n 8 cough               1553  2033    1.15        0.97         1.37      0.11\n 9 (Intercept)         1636  2114    1.29        1.21         1.38      0   \n10 aches                189   228    0.93        0.76         1.14      0.51\n11 (Intercept)          931  1144    1.23        1.13         1.34      0   \n12 vomit                894  1198    1.09        0.96         1.23      0.17\n13 (Intercept)          338   427    1.26        1.1          1.46      0   \n14 age_cat5-9           365   433    0.94        0.77         1.15      0.54\n15 age_cat10-14         273   396    1.15        0.93         1.42      0.2 \n16 age_cat15-19         238   299    0.99        0.8          1.24      0.96\n17 age_cat20-29         345   448    1.03        0.84         1.26      0.79\n18 age_cat30-49         228   307    1.07        0.85         1.33      0.58\n19 age_cat50-69          35    30    0.68        0.41         1.13      0.13\n20 age_cat70+             3     2    0.53        0.07         3.2       0.49\n# ℹ 4 more variables: mv_or &lt;dbl&gt;, mvv_ci_low &lt;dbl&gt;, mv_ci_high &lt;dbl&gt;,\n#   mv_pval &lt;dbl&gt;",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Regressão simples e múltipla</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.pt.html#gráfico-em-floresta-forest-plot",
    "href": "new_pages/regression.pt.html#gráfico-em-floresta-forest-plot",
    "title": "19  Regressão simples e múltipla",
    "section": "19.5 Gráfico em floresta (Forest Plot)",
    "text": "19.5 Gráfico em floresta (Forest Plot)\nEsta seção mostra como produzir um gráfico com os resultados da sua regressão. Existem duas opções. Você pode construir uma plotagem utilizando o ggplot2 ou utilizando um pacote-meta (um pacote que incluí muitos pacotes) chamado easystats.\nVeja a página sobre básico do ggplot se você não é familiar com o pacote de plotagem ggplot2.\n\n\nPacote ggplot2\nÉ possível construir um gráfico em floresta com a função ggplot() ao plotar os resultados de uma regressão multivariada. Adicione as camadas das plotagens com estas funções “geoms”:\n\nrealize estimativas com geom_point()\n\nobtenha intervalos de confiança com geom_errorbar()\n\numa linha vertical em OU = 1 com geom_vline()\n\nAntes de traçar o gráfico, é interessante utilizar a função fct_relevel(), do pacote forcats, para escolher a ordem das variáveis/níveis no eixo y. ggplot() pode mostrar elas em uma ordem alfa-numérica que pode não funcionar bem com os valores da variável ‘age category’ (“30” apareceria antes de “5”). Veja a página sobre fatores para mais detalhes.\n\n## remove o termo da intercepção dos seus resultados multivariados\nmv_tab_base %&gt;% \n  \n  # escolhe a ordem dos níveis que aparecem no eixo y\n  mutate(term = fct_relevel(\n    term,\n    \"vomit\", \"gender\", \"fever\", \"cough\", \"chills\", \"aches\",\n    \"age_cat5-9\", \"age_cat10-14\", \"age_cat15-19\", \"age_cat20-29\",\n    \"age_cat30-49\", \"age_cat50-69\", \"age_cat70+\")) %&gt;%\n  \n  # remove a linha \"intercept\" do gráfico\n  filter(term != \"(Intercept)\") %&gt;% \n  \n  ## trace um gráfico no eixo y e/ou as estimativas no eixo x\n  ggplot(aes(x = estimate, y = term)) +\n  \n  ## mostre a estimativa como um ponto\n  geom_point() + \n  \n  ## adicione uma barra de erro para os intervalos de confiança\n  geom_errorbar(aes(xmin = conf.low, xmax = conf.high)) + \n  \n  ## mostre a linha. OR = 1 é referência para uma linha tracejada\n  geom_vline(xintercept = 1, linetype = \"dashed\")\n\n\n\n\n\n\n\n\n\n\n\nPacotes easystats\nUma alternativa, caso você não queira realizar os ajustes finos no ggplot2, é utilizar uma combinação dos pacotes do easystats.\nA função model_parameters(), do pacote parameters, faz o equivalente da função tidy() do pacote broom. O pacote see aceita estes resultados e cria uma plotagem em floresta padrão, como se fosse um objeto ggplot().\n\npacman::p_load(easystats)\n\n## remove a intercepção dos seus resultados multivariados\nfinal_mv_reg %&gt;% \n  model_parameters(exponentiate = TRUE) %&gt;% \n  plot()",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Regressão simples e múltipla</span>"
    ]
  },
  {
    "objectID": "new_pages/regression.pt.html#recursos",
    "href": "new_pages/regression.pt.html#recursos",
    "title": "19  Regressão simples e múltipla",
    "section": "19.6 Recursos",
    "text": "19.6 Recursos\nO conteúdo desta página foi adaptado destes recursos e tutoriais onlines:\nRegressão linear no R\ngtsummary\nPágina sobre estatística da UCLA\nRegressão gradual sthda",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Regressão simples e múltipla</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.pt.html",
    "href": "new_pages/missing_data.pt.html",
    "title": "20  Campos em branco/faltantes",
    "section": "",
    "text": "20.1 Preparando o ambiente R",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Campos em branco/faltantes</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.pt.html#preparando-o-ambiente-r",
    "href": "new_pages/missing_data.pt.html#preparando-o-ambiente-r",
    "title": "20  Campos em branco/faltantes",
    "section": "",
    "text": "Carregue os pacotes\nO código abaixo realiza o carregamento dos pacotes necessários para a análise dos dados. Neste manual, enfatizamos o uso da função p_load(), do pacman, que instala os pacotes, caso não estejam instalados, e os carrega no R para utilização. Também é possível carregar pacotes instalados utilizando a função library(), do R base. Para mais informações sobre os pacotes do R, veja a página Introdução ao R.\n\npacman::p_load(\n  rio,           # importar/exportar\n  tidyverse,     # gerenciamento e visualização dos dados\n  naniar,        # avaliar e visualizar campos em branco\n  mice           # atribuir valores aos campos em branco\n)\n\n\n\nImporte os dados\nNós iremos importar o banco de dados de casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar os passos abaixo, clique aqui para fazer o download do banco de dados ‘limpo’ (como arquivo .rds). Importe seus dados utilizando a função import() do pacote rio (esta função importa muitos tipos de arquivos, como .xlsx, .rds, .csv - veja a página Importar e exportar para detalhes).\n\n# importe os dados no R\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nAs primeiras 50 linhas do banco são mostradas abaixo\n\n\n\n\n\n\n\n\nPadronize os dados dos campos em branco durante a importação\nAo importar os seus dados, esteja ciente de valores que deveriam ser classificados como campos em branco. Por exemplo, 99, 999, “Missing”, células em branco (““), ou céluas com um espaço em branco (” “). Você pode converter esses tipos de campos em branco (e outros) para NA (formato de campos em branco no R) ainda no código usado para importar os dados. Veja a seção sobre como importar os dados na página Campos em branco para mais detalhes, uma vez que a sintaxe muda de acordo com o tipo de arquivo.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Campos em branco/faltantes</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.pt.html#campos-em-branco-no-r",
    "href": "new_pages/missing_data.pt.html#campos-em-branco-no-r",
    "title": "20  Campos em branco/faltantes",
    "section": "20.2 Campos em branco no R",
    "text": "20.2 Campos em branco no R\nAbaixo, nós exploramos as formas como os campos em branco são mostrados e analisados no R, assim como valores e funções adjacentes.\n\nNA\nNo R, campos em branco são representados por um valor especial e reservado - NA. Notar que é escrito sem as aspas. Já “NA”, com aspas, é diferente, sendo apenas um caractere normal no R (além de ser parte da letra de Hey Jude dos Beatles).\nOs campos em branco nos seus dados podem estar representados com outras formas, como “99”, ou “Missing”, ou “Unknown” - ou até como um caractere vazio ““, parecido com um campo em branco, ou um espaço simples” “. Esteja ciente disto, e verifique a possibilidade de converte-los para NA durante a importação ou durante a limpeza dos dados, com a função na_if().\nDurante a limpeza dos dados, você também pode realizar o oposto - alterando todos os NA para “Missing”, ou algo similar, utilizando a função replace_na() ou fct_explicit_na(), para valores da classe Factor.\n\n\nVersões de NA\nPara boa parte dos casos, NA representa os campos em branco e tudo funciona bem. Entretanto, em algumas circunstâncias você pode precisar de variações do NA, específicas para uma classe de objeto (caractere, numérico, etc). Isto será raro, mas esteja ciente dessa possibilidade. O cenário típico para isso ocorre ao criar uma nova coluna com a função case_when(), do pacote dplyr. Como descrito na página sobre Limpeza dos dados e principais funções, esta função verifica cada linha do banco de dados, avalia se cumprem regras lógicas (lado direito do código), e atribuem um novo valor correto (lado esquerdo do código). Importante: todos os valores no lado direito da fórmula precisam ser da mesma classe.\n\nlinelist &lt;- linelist %&gt;% \n  \n  # Cria uma nova coluna chamada \"age_years\", utilizando a coluna \"age\"\n  mutate(age_years = case_when(\n    age_unit == \"years\"  ~ age,       # se a idade (age) é dada em anos, este valor é mantido\n    age_unit == \"months\" ~ age/12,    # se a idade é dada em meses, o valor é dividido por 12\n    is.na(age_unit)      ~ age,       # se a unidade da idade não é informada, assume-se que sejam em anos\n    TRUE                 ~ NA_real_)) # para qualquer outra circunstância, o valor de campo em branco é atribuído\n\nSe você quiser NA no lado direito, é necessário especificar uma das opções especiais da NA, listadas abaixo. Para valores em caracteres, utilize “Missing” em vez de NA, ou NA_character_. Se todos os valores são numéricos, utilize a opção NA_real_. Se todos os valores são formato de datas ou lógicos, utilize NA.\n\nNA - utilize para datas ou valores lógicos TRUE/FALSE\nNA_character_ - utilize para caracteres\nNA_real_ - utilize para valores numéricos\n\nNovamente, é improvável que você encontre essas variações, a não ser que você esteja utilizando a função case_when()para criar uma nova coluna. Veja a documentação do R sobre NA para mais informações.\n\n\nNULL\nNULL é outro valor reservado (especial) no R. É a representação lógica de uma declaração que não é nem verdadeira (true), tampouco falsa (false). Ele é gerado por expressões ou funções em que os valores são indefinidos. Geralemnte, não atribua NULL como um valor, exceto ao escrever funções ou, talvez, uma [aplicação em shiny][Dashboards com Shiny] para gerar NULL em cenários específicos.\nPara avaliar se é um valor NULL, é só utilizar a função is.null(), e conversões podem ser feitas com a função as.null().\nVeja essa postagem detalhando as diferenças entre NULL e NA.\n\n\nNaN\nValores impossíveis são representados pelo valor especial NaN. Um exemplo disso é quando você força o R a dividir 0 por 0. Você pode verificar se algo é impossível com a função is.nan(). Você também pode encontrar funções complementares, incluindo is.infinite() e is.finite().\n\n\nInf\nInf representa um valor infinito, como o obtido ao dividir um número por 0.\nUm exemplo de como isto pode impactar seu trabalho: digamos que você possua um vetor/coluna z que contém estes valores: z &lt;- c(1, 22, NA, Inf, NaN, 5)\nSe você utilizar a função max() nesta coluna para encontrar o maior valor, é possível utilizar o atributo na.rm = TRUE para remover o NA da análise, mas os valores Inf e NaN continuarão e Inf será o resultado desta análise. Para resolver isto, você pode utilizar colchetes quadrados [ ] e a função is.finite() para analisar apenas o subconjunto de dados com apenas valores finitos: max(z[is.finite(z)]).\n\nz &lt;- c(1, 22, NA, Inf, NaN, 5)\nmax(z)                           # retorna NA\nmax(z, na.rm=T)                  # retorna Inf\nmax(z[is.finite(z)])             # retorna 22\n\n\n\nExemplos\n\n\n\n\n\n\n\nComando R\nResultado\n\n\n\n\n5 / 0\nInf\n\n\n0 / 0\nNaN\n\n\n5 / NA\nNA\n\n\n5 / Inf |0NA - 5|NAInf / 5|Infclass(NA)| \"logical\"class(NaN)| \"numeric\"class(Inf)| \"numeric\"class(NULL)`\n“NULL”\n\n\n\n“NAs introduzidos forçadamente” (“NAs introduced by coercion”) é uma mensagem de aviso comum. Isto pode acontecer se você tentar realizar uma conversão ilegal, como inserir um valor do tipo caractere em um vetor numérico.\n\nas.numeric(c(\"10\", \"20\", \"thirty\", \"40\"))\n\nWarning: NAs introduced by coercion\n\n\n[1] 10 20 NA 40\n\n\nNULL é ignorado em um vetor.\n\nmy_vector &lt;- c(25, NA, 10, NULL)  # defina\nmy_vector                         # print\n\n[1] 25 NA 10\n\n\nVariação de um número resulta em NA.\n\nvar(22)\n\n[1] NA",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Campos em branco/faltantes</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.pt.html#funções-úteis",
    "href": "new_pages/missing_data.pt.html#funções-úteis",
    "title": "20  Campos em branco/faltantes",
    "section": "20.3 Funções úteis",
    "text": "20.3 Funções úteis\nAbaixo são elencadas funções úteis do R base para avaliar e trabalhar com campos em branco:\n\nis.na() e !is.na()\nUtilize a função is.na() para identificar campos em branco, ou utilize o oposto desta função (com ! na frente) para identificar campos preenchidos. Ambas funções retornam um valor lógico (TRUE ou FALSE). Lembre que você pode somar (sum()) o vetor resultante para contar a quantidade de TRUE, ex.: sum(is.na(linelist$date_outcome)).\n\nmy_vector &lt;- c(1, 4, 56, NA, 5, NA, 22)\nis.na(my_vector)\n\n[1] FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE\n\n!is.na(my_vector)\n\n[1]  TRUE  TRUE  TRUE FALSE  TRUE FALSE  TRUE\n\nsum(is.na(my_vector))\n\n[1] 2\n\n\n\n\nna.omit()\nEsta função, se aplicada em um conjunto de dados, irá remover linhas com qualquer campo em branco. Esta função também é do pacote R base.\nSe aplicada em um vetor, os valores NA neste vetor serão removidos. Por exemplo:\n\nna.omit(my_vector)\n\n[1]  1  4 56  5 22\nattr(,\"na.action\")\n[1] 4 6\nattr(,\"class\")\n[1] \"omit\"\n\n\n\n\ndrop_na()\nEsta é uma função do pacote tidyr, que é útil em um pipeline de limpeza de dados. Se executada com os parênteses vazios, ela remove linhas com qualquer um dos campos esteja em brancos. Se o nome das colunas são especificados em parênteses, linhas com campos em branco apenas nestas colunas serão excluídas. Você pode também utilizar a sintaxe do “tidyselect” para especificar as colunas.\n\nlinelist %&gt;% \n  drop_na(case_id, date_onset, age) # exclui linhas com campos em branco em alguma dessas colunas\n\n\n\nna.rm = TRUE\nQuando você executa uma função matemática, como max(), min(), sum() ou mean(), se existir quaisquer valores NA presentes, o resultado da análise será NA. Este comportamento padrão é intencional, de forma que você seja alertado no caso de seus dados estarem em branco.\nVocê pode evitar isto ao remover os campos em branco dos cálculos. Para fazer isto, inclua o argumento na.rm = TRUE (“na.rm” significa “remova os NA”).\n\nmy_vector &lt;- c(1, 4, 56, NA, 5, NA, 22)\n\nmean(my_vector)     \n\n[1] NA\n\nmean(my_vector, na.rm = TRUE)\n\n[1] 17.6",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Campos em branco/faltantes</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.pt.html#avalie-os-campos-em-branco-no-conjunto-de-dados",
    "href": "new_pages/missing_data.pt.html#avalie-os-campos-em-branco-no-conjunto-de-dados",
    "title": "20  Campos em branco/faltantes",
    "section": "20.4 Avalie os campos em branco no conjunto de dados",
    "text": "20.4 Avalie os campos em branco no conjunto de dados\nVocê pode utilizar o pacote naniar para avaliar e visualizar os campos em brancos no seu conjunto de dados presente no objeto linelist.\n\n# instale e/ou carregue o pacote\npacman::p_load(naniar)\n\n\nQuantificando os campos em branco\nPara encontrar o percentual da quantidade de campos em branco, utilize a função pct_miss(). Utilize n_miss() para obter o número absoluto de campos em branco.\n\n# percentual de TODOS os campos em branco no banco de dados\npct_miss(linelist)\n\n[1] 6.688745\n\n\nAs duas funções abaixo retornam o percentual de linhas com qualquer campo em branco, ou que estão com todos os campos preenchidos, respectivamente. Lembre que NA significa perdido/em branco, e que \"\" ou \" \" não serão considerados campos em branco.\n\n# Percentual de linhas com algum campo em branco\npct_miss_case(linelist)   # utilize n_complete() para obter quantidades absolutas\n\n[1] 69.12364\n\n\n\n# Percentual de linhas com todos os campos preenchidos (sem campos em branco)\npct_complete_case(linelist) # utilize n_complete() para obter quantidades absolutas\n\n[1] 30.87636\n\n\n\n\nVisualizando as quantidades de campos em branco\nA função gg_miss_var() irá gerar o número absoluto (ou %) de campos em branco em cada coluna. Seguem alguns detalhes:\n\nVocê pode adicionar um nome de coluna (sem as aspas) ao atributo facet = para visualizar o gráfico por grupos\nPor padrão, contagens absolutas são mostradas no lugar dos percentuais. Altere isso com o atributo show_pct = TRUE\n\nVocê pode adicionar etiquetas aos eixos e títulos utilizando + labs(...), como no ggplot()\n\n\ngg_miss_var(linelist, show_pct = TRUE)\n\n\n\n\n\n\n\n\nAqui, os dados são encadeados %&gt;% (do inglês pipe) na função. O atributo facet = também é utilizado para dividir os dados.\n\nlinelist %&gt;% \n  gg_miss_var(show_pct = TRUE, facet = outcome)\n\n\n\n\n\n\n\n\nVocê pode utilizar a função vis_miss() para visualizar os dados como um mapa de calor, mostrando se algum campo está em branco ou não. Também é possível utilizar o select() para escolher colunas específicas do banco de dados, e trabalhar apenas com elas.\n\n# Mapa de calor dos campos em branco no banco de dados inteiro\nvis_miss(linelist)\n\n\n\n\n\n\n\n\n\n\nExplore e visualize as relações entre os campos em branco\nComo você visualiza algo que não existe??? Por padrão, o ggplot() remove pontos sem valores dos gráficos.\nO pacote naniar oferece uma solução com a função geom_miss_point(). Ao criar um gráfico de dispersão de duas colunas, uma delas é construída sem os valores em branco, e a outra com estes pontos, onde valores 10% menores do que o menor valor da coluna são atribuídos a estes campos em branco, que são então coloridos de forma distinta dos demais pontos.\nNo gráfico de dispersão abaixo, os pontos vermelhos são os que foram adicionados, estando presentes em uma coluna, mas não na outra. Isto permite visualizar a distribuição de campos em branco em relação aos campos preenchidos.\n\nggplot(\n  data = linelist,\n  mapping = aes(x = age_years, y = temp)) +     \n  geom_miss_point()\n\n\n\n\n\n\n\n\nPara analisar os campos em branco nos dados, estratificados por outra coluna, utilize a função gg_miss_fct(), que gera um mapa de calor com o percentual de campos em brancos no banco de dados utilizando uma coluna da classe factor/categórica (ou por datas):\n\ngg_miss_fct(linelist, age_cat5)\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `age_cat5 = (function (x) ...`.\nCaused by warning:\n! `fct_explicit_na()` was deprecated in forcats 1.0.0.\nℹ Please use `fct_na_value_to_level()` instead.\nℹ The deprecated feature was likely used in the naniar package.\n  Please report the issue at &lt;https://github.com/njtierney/naniar/issues&gt;.\n\n\n\n\n\n\n\n\n\nEsta função também pode ser utilizada com uma coluna com datas, para visualizar como a quantidade de campos em branco alterou de acordo com o tempo:\n\ngg_miss_fct(linelist, date_onset)\n\nWarning: Removed 29 rows containing missing values or values outside the scale range\n(`geom_tile()`).\n\n\n\n\n\n\n\n\n\n\n\nColunas Sombra “Shadow”\nOutra forma de visualizar os campos em branco em uma coluna, de acordo com os valores de uma segunda coluna, é utilizando o “shadow” que o pacote naniar consegue criar. A função bind_shadow() cria uma nova coluna com os valores binários NA/not NA para cada coluna existente, e então conecta todas essas colunas novas ao banco de dados original utilizando o sufixo “_NA” em seus nomes. Isto duplica o número de colunas:\n\nshadowed_linelist &lt;- linelist %&gt;% \n  bind_shadow()\n\nnames(shadowed_linelist)\n\n [1] \"case_id\"                 \"generation\"             \n [3] \"date_infection\"          \"date_onset\"             \n [5] \"date_hospitalisation\"    \"date_outcome\"           \n [7] \"outcome\"                 \"gender\"                 \n [9] \"age\"                     \"age_unit\"               \n[11] \"age_years\"               \"age_cat\"                \n[13] \"age_cat5\"                \"hospital\"               \n[15] \"lon\"                     \"lat\"                    \n[17] \"infector\"                \"source\"                 \n[19] \"wt_kg\"                   \"ht_cm\"                  \n[21] \"ct_blood\"                \"fever\"                  \n[23] \"chills\"                  \"cough\"                  \n[25] \"aches\"                   \"vomit\"                  \n[27] \"temp\"                    \"time_admission\"         \n[29] \"bmi\"                     \"days_onset_hosp\"        \n[31] \"case_id_NA\"              \"generation_NA\"          \n[33] \"date_infection_NA\"       \"date_onset_NA\"          \n[35] \"date_hospitalisation_NA\" \"date_outcome_NA\"        \n[37] \"outcome_NA\"              \"gender_NA\"              \n[39] \"age_NA\"                  \"age_unit_NA\"            \n[41] \"age_years_NA\"            \"age_cat_NA\"             \n[43] \"age_cat5_NA\"             \"hospital_NA\"            \n[45] \"lon_NA\"                  \"lat_NA\"                 \n[47] \"infector_NA\"             \"source_NA\"              \n[49] \"wt_kg_NA\"                \"ht_cm_NA\"               \n[51] \"ct_blood_NA\"             \"fever_NA\"               \n[53] \"chills_NA\"               \"cough_NA\"               \n[55] \"aches_NA\"                \"vomit_NA\"               \n[57] \"temp_NA\"                 \"time_admission_NA\"      \n[59] \"bmi_NA\"                  \"days_onset_hosp_NA\"     \n\n\nEstas colunas “shadow” podem ser utilizadas para traçar um gráfico da proporção de campos em branco, em relação à qualquer outra coluna.\nPor exemplo, o gráfico abaixo mostra a proporção de campos em branco na coluna days_onset_hosp (número de dias entre o início dos sintomas e a hospitalização), de acordo com o campo em date_hospitalisation. Essencialmente, você está criando um gráfico da densidade da coluna no eixo x, mas estratificando os resultados (color =) pela coluna “shadow” de interesse. Esta análise funciona melhor se o eixo x é uma coluna numérica ou com dados cronológicos.\n\nggplot(data = shadowed_linelist,          # banco de dados com as colunas \"shadow\"\n  mapping = aes(x = date_hospitalisation, # colunas numéricas ou cronológicas\n                colour = age_years_NA)) + # coluna \"shadow\" de interesse\n  geom_density()                          # adição das curvas de densidade\n\n\n\n\n\n\n\n\nVocê pode também utilizar as colunas “shadow” para estratificar um resumo estatístico, como mostrado abaixo:\n\nlinelist %&gt;%\n  bind_shadow() %&gt;%                # cria as colunas \"shadow\"\n  group_by(date_outcome_NA) %&gt;%    # coluna \"shadow\" escolhida para estratificar\n  summarise(across(\n    .cols = age_years,             # variável de interesse para realizar os cálculos\n    .fns = list(\"mean\" = mean,     # estatísticas calculadas\n                \"sd\" = sd,\n                \"var\" = var,\n                \"min\" = min,\n                \"max\" = max),  \n    na.rm = TRUE))                 # outros argumentos para o cálculo das estatísticas\n\nWarning: There was 1 warning in `summarise()`.\nℹ In argument: `across(...)`.\nℹ In group 1: `date_outcome_NA = !NA`.\nCaused by warning:\n! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\nSupply arguments directly to `.fns` through an anonymous function instead.\n\n  # Previously\n  across(a:b, mean, na.rm = TRUE)\n\n  # Now\n  across(a:b, \\(x) mean(x, na.rm = TRUE))\n\n\n# A tibble: 2 × 6\n  date_outcome_NA age_years_mean age_years_sd age_years_var age_years_min\n  &lt;fct&gt;                    &lt;dbl&gt;        &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n1 !NA                       16.0         12.6          158.             0\n2 NA                        16.2         12.9          167.             0\n# ℹ 1 more variable: age_years_max &lt;dbl&gt;\n\n\nUma forma alternativa para traçar um gráfico da proporção de campos em branco em uma coluna de acordo com o tempo é mostrada abaixo. Esta forma não involve o pacote naniar. Este exemplo mostra a porcentagem de observações semanais que estão em branco.\n\nAgregue os dados em uma unidade de tempo útil (dias, semanas, etc.), resumindo a proporção de observações com NA(e/ou qualquer outro valor de interesse)\nFaça um gáfico da proporção de campos em brancos como uma linha, utilizando o ggplot()\n\nAbaixo, nós trabalhamos com a linelist, adicionamos uma nova coluna contendo a semana, então agrupamos os dados por semana, e calculamos o percentual de registros em branco de acordo com a semana. (nota: se você quisesse obter a % por 7 dias, o cálculo seria sutilmente diferente).\n\noutcome_missing &lt;- linelist %&gt;%\n  mutate(week = lubridate::floor_date(date_onset, \"week\")) %&gt;%   # crie uma coluna com as semanas\n  group_by(week) %&gt;%                                             # agrupe as linhas por semana\n  summarise(                                                     # faça o resumo por cada semana\n    n_obs = n(),                                                  # número absoluto de registros\n    \n    outcome_missing = sum(is.na(outcome) | outcome == \"\"),        # número de registros com campos em branco\n    outcome_p_miss  = outcome_missing / n_obs,                    # proporção de registros em branco\n  \n    outcome_dead    = sum(outcome == \"Death\", na.rm=T),           # número de registros com evolução para óbito\n    outcome_p_dead  = outcome_dead / n_obs) %&gt;%                   # proporção de registros com evolução para óbito\n  \n  tidyr::pivot_longer(-week, names_to = \"statistic\") %&gt;%         # para utilizar o ggplot, altere todas as colunas, exceto a coluna com as semanas, para o formato longo\n  filter(stringr::str_detect(statistic, \"_p_\"))                  # mantenha apenas os valores proporcionais\n\nEntão nóstraçamos um gráfico das proporções dos campos em branco como uma linha, de acordo com a semana. A página sobre básico do ggplot pode ser utilizada se você não tiver familiaridade com o pacote ggplot2 de visuzalização de dados.\n\nggplot(data = outcome_missing)+\n    geom_line(\n      mapping = aes(x = week, y = value, group = statistic, color = statistic),\n      size = 2,\n      stat = \"identity\")+\n    labs(title = \"Weekly outcomes\",\n         x = \"Week\",\n         y = \"Proportion of weekly records\") + \n     scale_color_discrete(\n       name = \"\",\n       labels = c(\"Died\", \"Missing outcome\"))+\n    scale_y_continuous(breaks = c(seq(0,1,0.1)))+\n  theme_minimal()+\n  theme(legend.position = \"bottom\")",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Campos em branco/faltantes</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.pt.html#utilizando-dados-com-campos-em-branco",
    "href": "new_pages/missing_data.pt.html#utilizando-dados-com-campos-em-branco",
    "title": "20  Campos em branco/faltantes",
    "section": "20.5 Utilizando dados com campos em branco",
    "text": "20.5 Utilizando dados com campos em branco\n\nExclua linhas com campos em branco\nPara rapidamente excluir linhas com valores em branco, utilize a função drop_na(), do pacote dplyr.\nO objeto linelist original possui nrow(linelist) linhas. O número ajustado de linhas, após exclusão das que possuíam campos em branco, é mostrado abaixo:\n\nlinelist %&gt;% \n  drop_na() %&gt;%     # excluí linhas com QUALQUER campo em branco\n  nrow()\n\n[1] 1818\n\n\nVocê pode especificar para excluir linhas com campos em branco apenas em colunas específicas:\n\nlinelist %&gt;% \n  drop_na(date_onset) %&gt;% # exclua as linhas com campos em branco na coluna date_onset \n  nrow()\n\n[1] 5632\n\n\nVocê pode listar as colunas uma após a outra, ou utilizar as funções auxiliares do “tidyselect”:\n\nlinelist %&gt;% \n  drop_na(contains(\"date\")) %&gt;% # exclua linhas com campos em branco em qualquer coluna que contenha \"date\" no nome\n  nrow()\n\n[1] 3029\n\n\n\n\n\nTrabalhando com NA no ggplot()\nFrequentemente, é sábio mostrar a quantidade de valores excluídos na confeção de um gráfico em sua legenda. Abaixo é um exemplo:\nNo ggplot(), você pode adicionar etiquetas com labs(), e dentro da função utilizar o atributo caption =. Neste atributo, você pode utilizar a função str_glue(), do pacote stringr, para unir os valores em uma senteça, de forma que eles são ajustados automaticamente. Um exemplo é mostrado abaixo:\n\nObserve o uso do \\n para adicionar uma nova linha\nObserve que, caso colunas múltiplas contribuam para a exclusão dos valores do gráfico (ex.: age ou sex se estes interferirem no gráfico), então você precisa filtrar por estas colunas assim como calcular o número de registros não mostrados de forma correta.\n\n\nlabs(\n  title = \"\",\n  y = \"\",\n  x = \"\",\n  caption  = stringr::str_glue(\n  \"n = {nrow(central_data)} do Hospital Central;\n  {nrow(central_data %&gt;% filter(is.na(date_onset)))} registros sem as datas de início dos sintomas não são mostrados.\"))  \n\nAs vezes, pode ser mais fácil salvar o texto em um objeto em comandos anteriores a função ggplot(), e, simplesmente, referenciar o objeto criado dentro da função str_glue().\n\n\n\nNA na classe factors\nSe a sua coluna de interesse for um fator (da classe factors), utilize a função fct_explicit_na(), do pacote forcats, para converter os valores do tipo NA para valores do tipo caractere. Veja mais detalhes na página Fatores. Por padrão, o novo valor atribuído é “(Missing)”, mas pode ser ajustado através do argumento na_level =.\n\npacman::p_load(forcats)   # carregue o pacote\n\nlinelist &lt;- linelist %&gt;% \n  mutate(gender = fct_explicit_na(gender, na_level = \"Missing\"))\n\nlevels(linelist$gender)\n\n[1] \"f\"       \"m\"       \"Missing\"",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Campos em branco/faltantes</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.pt.html#imputação-de-dados-nos-campos-em-branco",
    "href": "new_pages/missing_data.pt.html#imputação-de-dados-nos-campos-em-branco",
    "title": "20  Campos em branco/faltantes",
    "section": "20.6 Imputação de dados nos campos em branco",
    "text": "20.6 Imputação de dados nos campos em branco\nAs vezes, ao analisar os dados, será importante “preencher as lacunas” e atribuir valores nos campos vazios. Mesmo que você possa analisar os dados após remover todos os campos em branco, isto pode causar diversos problemas. Aqui estão dois exemplos:\n\nAo remover todas as observações com campos em branco, ou variáveis com uma quantidade elevada de dados em branco, você pode reduzir seu poder de amostra ou capacidade para realizar algumas análises. Por exemplo, como descobrimos anteriormente, apenas uma pequena fração das observações no nosso banco de dados no linelist não possui campos em branco em todas as variáveis. Se nós removessemos a maioria dessas linhas, estaríamos perdendo muita informação! Também vimos que boa parte das nossas variáveis possui alguma quantidade de dados em branco – assim, para boa parte da análise, provavelmente não é razoável excluir todas as variáveis que possuem muitos campos vazios.\nDependendo do motivo de seus dados estarem em branco, realizar a análise apenas de dados completos pode levar a resultados enviesados ou incorretos. Por exemplo, anteriormente, nós descobrimos que estamos sem dados de alguns pacientes no que tange à presença de sintomas importantes, como febre e tosse. Mas, como uma possibilidade, talvez essa informação não foi registrada para pessoas que, obviamente, não estavam muito doentes. Neste caso, se nós apenas removermos essas observações, estaremos excluindo algumas das pessoas mais saudáveis do nosso banco de dados, o que iria enviesar nossos resultados.\n\nÉ importante pensar sobre o porque seus dados podem estar em branco, além de avaliar a quantidade de campos em branco. Fazer isto pode ajudá-lo a decidir o quão importante será atribuir valores nos campos em branco, e qual o melhor método de imputação para a sua situação.\n\nTipos de dados em branco\nAqui estão três tipos gerais de dados em branco:\n\nDados faltantes completamente de forma aleatória (MCAR, do inglês Missing Comnpletely at Random). Isto significa que não existe relação entre os dados em branco e qualquer outra variável dos seus dados. A probabilidade dos dados estarem em branco são as mesmas para todos os casos. Isto é uma situação rara. Mas, se você tiver uma forte razão para acreditar que seus dados são do tipo MCAR, analisar apenas os dados completos sem atribuir valores não irá enviesar seus resultados (apesar de que você pode perder algum poder de amostra). [A fazer: considere discutir testes estatísticos para MCAR]\nDados faltantes aleatoriamente (MAR, do inglês Missing at Random). Este nome é, na verdade, um pouco incorreto, uma vez que dados do tipo MAR não estão perdidos de forma alearória, e sim de forma sistemática e previsível, baseado em outras informações que você tem. Por exemplo, talvez cada observação em branco do seu banco de dados para febre não foi registrada porque assumiram que todos os pacientes com calafrios e dores estavam com febre, e, então, suas temperaturas não foram medidas. Se verdade, nós poderíamos facilmente predizer que cada observação em branco em que o paciente tivesse calafrios e dores, ele também teve febre, e utilizar essa informação para atribuir dados. Na prática, existe um espectro de possibilidades. Talvez, se um paciente sem a temperatura medida tivesse tanto calafrios quanto dores, ele provavelmente também teria febre, mas nem sempre. Isto ainda é previsível, embora não seja perfeitamente previsível. Este é um tipo comum de perda de dados.\nDados faltantes de forma não aleatória (MNAR, do inglês Missing not at Random). As vezes, também chamado de Não perdidos aleatoriamente (NMAR). Esta situação considera que a probabilidade de um campo estar em branco NÃO é sistemática ou previsível utilizando as outras informações que temos, mas também não foram perdidos de forma aleatória. Assim, os dados foram perdidos por razões desconhecidas ou por motivos que você não tem informações sobre. Por exemplo, em nosso banco de dados, talvez as informações sobre as idades estejam em branco porque alguns pacientes muito idosos ou não sabiam a idade, ou recusaram informar a idade. Nesta situação, os dados perdidos de idade estão relacionados à idade diretamente (e, assim, não são perdas aleatórias), e não são dados previsíveis através de outras informações que temos. MNAR é complexo e, frequentemente, a melhor forma de trabalhar com isso é tentar coletar mais dados ou informações sobre o porque os dados estão faltando, em vez de atribuir valores.\n\nConcluindo, geralmente, atribuir valores em dados MCAR é simples, enquanto em dados MNAR é desafiador, senão impossível. Muitos dos métodos de imputação de valores assumem dados MAR.\n\n\nPacotes úteis\nAlguns pacotes úteis para imputar dados perdidos são Mmisc, missForest (que utiliza o modelo de florestas aleatórias para imputar dados perdidos), e mice (Imputação Multivariada por Equações em Cadeia). Para essa seção, nós iremos utilizar apenas o pacote mice, que implementa uma variedade de técnicas. O mantenedor do pacote mice publicou um livro online com mais detalhes sobre como imputar dados perdidos (https://stefvanbuuren.name/fimd/).\nSegue o código para carregar o pacote mice:\n\npacman::p_load(mice)\n\n\n\nImputação por média\nAs vezes, se você está realizando uma análise simples, ou possui uma forte razão para pensar que pode assumir os dados perdidos como MCAR, é possível simplesmente atribuir a média daquela variável nos campos em branco. Talvez possamos assumir que a perda de medições de temperatura em nosso banco de dados foi MCAR ou apenas valores normais. Aqui está o código para criar uma nova variável que substitui os valores faltantes pela temperatura média do nosso banco de dados. Entretanto, em muitas situações, substituir dados com o valor médio pode gerar resultados enviesados, então seja cuidadoso.\n\nlinelist &lt;- linelist %&gt;%\n  mutate(temp_replace_na_with_mean = replace_na(temp, mean(temp, na.rm = T)))\n\nVocê pode também realizar um processo similar para substituir dados categóricos por um valor específico. Para o nosso banco de dados, imagine que você soubesse que todas observações com um campo em branco na variável outcome (evolução clínica, que pode ser “Death” ou “Recover”) foram de pessoas que evoluíram para óbito (nota: isto não é verdade para o nosso banco de dados):\n\nlinelist &lt;- linelist %&gt;%\n  mutate(outcome_replace_na_with_death = replace_na(outcome, \"Death\"))\n\n\n\nImputação por regressão\nOutro método de certa forma mais avançado para imputar valores é utilizar algum tipo de modelo estatístico para prever o que um valor perdido é. Aqui está um exemplo onde os valores preditos são criados para todos os campos sem a temperatura, mas com os campos de age (idade) e fever (febre) preenchidos, utilizando estas variáveis como preditoras em uma regressão linear simples. Na prática, você iria querer utilizar um modelo melhor do que este, que é mais simples.\n\nsimple_temperature_model_fit &lt;- lm(temp ~ fever + age_years, data = linelist)\n\n#utilizando o nosso simples modelo de temperatura para predizer valores de temperatura apenas para os campos em branco\npredictions_for_missing_temps &lt;- predict(simple_temperature_model_fit,\n                                        newdata = linelist %&gt;% filter(is.na(temp))) \n\nOu, utilizando a mesma abordagem de modelagem com o pacote mice para imputar valores de temperatura nos campos em branco:\n\nmodel_dataset &lt;- linelist %&gt;%\n  select(temp, fever, age_years)  \n\ntemp_imputed &lt;- mice(model_dataset,\n                            method = \"norm.predict\",\n                            seed = 1,\n                            m = 1,\n                            print = F)\n\nWarning: Number of logged events: 1\n\ntemp_imputed_values &lt;- temp_imputed$imp$temp\n\nEste é o mesmo tipo de abordagem feita por alguns métodos mais avançados, como utilizando o pacote missForest para substituir os campos em branco pelos valores preditos. Neste caso, o modelo de predição utilizado é o de florestas aleatórias (random forest) em vez de uma regressão linear. Você pode utilizar outros tipos de modelos para fazer isso. Entretanto, enquanto esta abordagem funciona bem com dados MCAR, você deve ser cuidadoso se acredita que seus dados perdidos sejam do tipo MAR ou MNAR. A qualidade da imputação irá depender no quão bom o seu modelo de predição é, e, mesmo com um modelo muito bom, a variedade dos dados imputados pode ser subestimada.\n\n\nLOCF e BOCF\nÚltima observação levada adiante (LOCF, do inglês “Last observation carried forward”) e observação de base levada adiante (BOCF, do inglês “baseline observation carried forward”) são métodos de imputação para séries temporais/dados longitudinais. A ideia é utilizar o último valor observado para atribuir nos campos em branco. Quando valores múltiplos são perdidos sucessivamente, o método busca pelo último valor observado.\nA função fill(), do pacote tidyr, pode ser utilizada para realizar imputação por LOCF e BOCF (entretanto, outros pacotes como HMISC, zoo, e data.table também incluem métodos para fazer isto). Para mostrar a sintaxe do fill(), nós iremos criar um simples banco de dados com série temporal contendo o número de casos de uma doença para cada quadrimestre dos anos 2000 e 2001. Entretanto, os valores para os quadrimestres após Q1 estão faltando, então nós iremos imputá-los. A sintaxe do fill() também é demonstrada na página sobre Pivoteamento dos dados.\n\n#criando um banco de dados simples\ndisease &lt;- tibble::tribble(\n  ~quarter, ~year, ~cases,\n  \"Q1\",    2000,    66013,\n  \"Q2\",      NA,    69182,\n  \"Q3\",      NA,    53175,\n  \"Q4\",      NA,    21001,\n  \"Q1\",    2001,    46036,\n  \"Q2\",      NA,    58842,\n  \"Q3\",      NA,    44568,\n  \"Q4\",      NA,    50197)\n\n#imputando os valores perdidos dos anos\ndisease %&gt;% fill(year)\n\n# A tibble: 8 × 3\n  quarter  year cases\n  &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;\n1 Q1       2000 66013\n2 Q2       2000 69182\n3 Q3       2000 53175\n4 Q4       2000 21001\n5 Q1       2001 46036\n6 Q2       2001 58842\n7 Q3       2001 44568\n8 Q4       2001 50197\n\n\nNota: tenha certeza de que seus dados estão ordenados corretamente antes de utilizar a função fill(). Por padrão, fill() irá preencher de cima para baixo, mas você também pode imputar valores em direções diferentes ao mudar o parâmetro .direction. Nós podemos criar um banco de dados similar onde os valores dos anos estão registrados apenas no ano final, e ausentes para quadrimestres anteriores:\n\n#criando um banco de dados sutilmente diferente\ndisease &lt;- tibble::tribble(\n  ~quarter, ~year, ~cases,\n  \"Q1\",      NA,    66013,\n  \"Q2\",      NA,    69182,\n  \"Q3\",      NA,    53175,\n  \"Q4\",    2000,    21001,\n  \"Q1\",      NA,    46036,\n  \"Q2\",      NA,    58842,\n  \"Q3\",      NA,    44568,\n  \"Q4\",    2001,    50197)\n\n#impute os anos nos campos em branco na direção para 'cima' (\"up\"):\ndisease %&gt;% fill(year, .direction = \"up\")\n\n# A tibble: 8 × 3\n  quarter  year cases\n  &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;\n1 Q1       2000 66013\n2 Q2       2000 69182\n3 Q3       2000 53175\n4 Q4       2000 21001\n5 Q1       2001 46036\n6 Q2       2001 58842\n7 Q3       2001 44568\n8 Q4       2001 50197\n\n\nNeste exemplo, LOCF e BOCF são claramente os métodos corretos para se fazer, mas, em situações mais complicadas, pode ser mais difícil decidir se estes métodos são apropriados. Por exemplo, você pode ter valores em branco dos dados laboratoriais de um paciente do hospital após o primeiro dia. As vezes, isto quer dizer que os resultados laboratoriais não mudaram após o primeiro dia…mas também pode significar que o paciente se recuperou e seus valores seriam muito diferentes em relação ao primeiro dia! Utilize estes métodos com cautela.\n\n\nImputação múltipla\nO livro online que mencionamos anteriormente, do autor do pacote mice (https://stefvanbuuren.name/fimd/), contém uma explicação detalhada da imputação múltipla e porque você gostaria de utilizá-la. Mas aqui está uma explicação básica do método:\nQuando você faz uma imputação múltipla, múltiplos bancos de dados com valores plausíveis imputados nos campos em branco são criados (dependendo dos seus dados de pesquisa, você pode querer criar mais ou menos desses bancos de dados, mas o pacote mice produz 5 bancos de dados por padrão). A diferença é que, ao invés de um valor único e específico, cada valor imputado é retirado de uma distribuição estimada (então inclui alguma aleatoridade). Como resultado, cada um desses bancos de dados terá valores imputados ligeiramente diferentes (entretanto, os dados que não estavam em branco continuarão os mesmos nos diferentes bancos de dados). Você irá utilizar algum tipo de modelo preditivo para realizar a imputação em cada um dos novos bancos de dados (o pacote mice possui muitas opções para cada método de predição, incluíndo Correspondência Média Preditiva, regressão logística, e florestas aleatórias), mas o pacote mice cuida de muitos dos detalhes da modelagem.\nEntão, assim que você tiver criado estes novos bancos de dados com os valores imputados, é possível aplicar quaisquer modelos estatísticos ou análises que estava planejando realizar em cada um dos bancos, e então unir os resultados destes modelos. Isto funciona muito bem para reduzir o enviesamento dos resultados nas situações de MCAR e MAR, e, frequentemente, os resultados são mais acurados.\nAqui está um exemplo da aplicação da Imputação Múltipla para predizer as temperaturas em nosso banco de dados do linelist, utilizando as variáveis idade (age) e status da febre (fever) (nosso simples model_dataset anterior):\n\n# imputando valores perdidos para todas as variáveis em nosso model_dataset, criando 10 novos bancos de dados com valores imputados\nmultiple_imputation = mice(\n  model_dataset,\n  seed = 1,\n  m = 10,\n  print = FALSE) \n\nWarning: Number of logged events: 1\n\nmodel_fit &lt;- with(multiple_imputation, lm(temp ~ age_years + fever))\n\nbase::summary(mice::pool(model_fit))\n\n         term     estimate    std.error    statistic        df       p.value\n1 (Intercept) 3.703143e+01 0.0270863456 1.367162e+03  26.83673  1.583113e-66\n2   age_years 3.867829e-05 0.0006090202 6.350905e-02 171.44363  9.494351e-01\n3    feveryes 1.978044e+00 0.0193587115 1.021785e+02 176.51325 5.666771e-159\n\n\nAqui nós utilizamos o método padrão do mice para imputação, que é a Correspondência Média Preditiva. Nós, então, utilizamos os bancos de dados gerados para, separadamente, estimar resultados com regressões lineares simples, e então uni-los. Existem muitos detalhes que não discutimos e muitas configurações que podem ser ajustadas durante o processo de Imputação Múltipla utilizando o pacote mice. Por exemplo, você nem sempre terá dados numéricos e pode precisar usar outros métodos de imputação (você ainda pode utilizar o pacote mice para muitos outros tipos de dados e métodos). Mas, para uma análise mais robusta quando os campos em branco são uma preocupação significativa, o método de Imputação Múltipla é uma boa solução que, quase sempre, não é muito mais trabalhosa do que realizar uma análise completa dos casos.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Campos em branco/faltantes</span>"
    ]
  },
  {
    "objectID": "new_pages/missing_data.pt.html#recursos",
    "href": "new_pages/missing_data.pt.html#recursos",
    "title": "20  Campos em branco/faltantes",
    "section": "20.7 Recursos",
    "text": "20.7 Recursos\nManual sobre o pacote naniar\nGaleria com a visualização dos valores perdidos\nLivro online sobre imputação múltipla no R, escrito pelo mantenedor do pacote mice",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Campos em branco/faltantes</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.pt.html",
    "href": "new_pages/standardization.pt.html",
    "title": "21  Normalização de taxas",
    "section": "",
    "text": "21.1 Visão geral\nExistem duas principais formas de normalizar: normalização direta e indireta. Digamos que gostaríamos de normalizar as taxas de mortalidade por idade e sexo, nos países A e B, e, então, comparar as taxas entre esses países.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Normalização de taxas</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.pt.html#visão-geral",
    "href": "new_pages/standardization.pt.html#visão-geral",
    "title": "21  Normalização de taxas",
    "section": "",
    "text": "Para realizar a normalização direta, você precisa saber o número da população sob-risco, e o número de mortes para cada faixa etária por sexo, tanto para o país A, quanto para o B. Uma faixa etária em nosso exemplo poderia ser mulheres entre 15-44 anos.\nPara realizar a normalizaçaõ de forma indireta, você apenas precisa saber o número total de mortes, e a composição da população por sexo e idade em cada país. Logo, está opção é viável quando as taxas de mortalidade específicas por idade e sexo, ou números da população, não estão disponíveis. A normalização indireta também é preferida nos casos de pequenas quantidades por estrato, uma vez que estimativas com a normalização direta seriam influenciadas pela variação amostral.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Normalização de taxas</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.pt.html#preparação",
    "href": "new_pages/standardization.pt.html#preparação",
    "title": "21  Normalização de taxas",
    "section": "21.2 Preparação",
    "text": "21.2 Preparação\nPara mostrar como a normalização é feita, nós iremos utilizar dados ficcionais com a quantidade populacional e quantidade de mortes dos países A e B, por idade (em categorias de 5 anos) e sexo (mulheres, homens). Para criar conjuntos de dados prontos para uso, nós iremos executar as seguintes etapas de preparação:\n\nCarregar os pacotes\nCarregar os conjuntos dos dados\nUnir os dados populacionais e de óbitos dos dois países\nTransformar para o formato longo, de forma que haja apenas uma linha por estrato idade-sexo\nLimpar a população de referência (população mundial padrão) e uni-la aos dados dos países\n\nNo seu cenário, os dados podem estar em um formato diferente. Talvez seus dados sejam por províncias, cidades, ou outros tipos de área. Talvez você tenha uma linha para cada óbito, e informações (ou uma proporção significante) sobre idade e sexo para cada um desses óbitos. Neste caso, veja as páginas sobre Agrupando dados, Pivoteando os dados, e Tabelas descritivas para criar um conjunto de dados com quantidades de eventos e população por estrato idade-sexo.\nNós também precisamos de uma população de referência, a população padrão. Para os propósitos deste exercício, nós iremos utilizar o world_standard_population_by_sex. A “população padrão mundial” é baseada nas populações de 46 países e foi criada em 1960. Existem muitas populações “padrão” - por exemplo, o site do NHS Scotland possui muitas informações sobre a População Padrão Européia, População Padrão Mundial, e População Padrão Escocesa.\n\n\nCarregue os pacotes R\nO código abaixo realiza o carregamento dos pacotes necessários para a análise dos dados. Neste manual, enfatizamos o uso da função p_load(), do pacman, que instala os pacotes, caso não estejam instalados, e os carrega no R para utilização. Também é possível carregar pacotes instalados utilizando a função library(), do R base. Para mais informações sobre os pacotes do R, veja a página Introdução ao R.\n\npacman::p_load(\n     rio,                 # importar/exportar dados\n     here,                # localizar arquivos\n     stringr,             # limpar caracteres e strings\n     frailtypack,         # necessário para dsr, para modelos de fragilidade\n     PHEindicatormethods, # alternativa para padronização das taxas\n     tidyverse)           # gerenciamento e visualização dos dados\n\npacman::p_load_gh(\"cran/dsr\") # foi removido do CRAN\n\nCUIDADO: Se você tem uma versão mais nova do R, o pacote dsr não pode ser diretamente baixado do CRAN. Entretanto, ainda está disponível do arquivo do CRAN. Você pode instalar e utilizar esta versão do arquivo. \nPara os que não utilizam Mac:\n\npackageurl &lt;- \"https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz\"\ninstall.packages(packageurl, repos=NULL, type=\"source\")\n\n\n# Outra solução que pode funcionar\nrequire(devtools)\ndevtools::install_version(\"dsr\", version=\"0.2.2\", repos=\"http:/cran.us.r.project.org\")\n\nPara usuários de Mac:\n\nrequire(devtools)\ndevtools::install_version(\"dsr\", version=\"0.2.2\", repos=\"https://mac.R-project.org\")\n\n\n\nCarregue os dados populacionais\nVeja a página Download do manual e dados para instruções sobre como baixar todos os dados de exemplos utilizados neste manual. Você pode importar os dados da página de Padronização dos dados diretamente no R, do nosso repositório Github, ao executar os comandos import() abaixo:\n\n# importe dados demográficos do país A diretamente do Github\nA_demo &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics.csv\")\n\n# importe dados de óbitos do país A diretamente do Github\nA_deaths &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryA.csv\")\n\n# importe dados demográficos do país B diretamente do Github\nB_demo &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics_2.csv\")\n\n# importe dados de óbitos do país B diretamente do Github\nB_deaths &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryB.csv\")\n\n# importe dados demográficos da População padrão mundial diretamente do Github\nstandard_pop_data &lt;- import(\"https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/world_standard_population_by_sex.csv\")\n\nPrimeiro, nós carregamos os dados demográficos (contanges de homens e mulheres por categorias de 5 em 5 anos) para os países que iremos comparar, “País A” e “País B”.\n\n# País A\nA_demo &lt;- import(\"country_demographics.csv\")\n\n\n\n\n\n\n\n\n# País B\nB_demo &lt;- import(\"country_demographics_2.csv\")\n\n\n\n\n\n\n\n\n\nCarregue a quantidade de óbitos\nConvenientemente, a quantidade de óbitos, por idade e sexo durante o período de interesse, também está disponível. Cada contagem por país está em arquivos separados, como mostrado abaixo.\nÓbitos no país A\n\n\n\n\n\n\nÓbitos no país B\n\n\n\n\n\n\n\n\nLimpe os dados populacionais e de óbitos\nNós precisamos unir e transformar estes dados da seguinte maneira:\n\nCombine as populações dos países em um conjunto de dados e o transforme para o formato “longo”, de forma que cada estrato idade-sexo esteja em uma linha\nCombine a quantidade de óbitos dos países em um conjunto de dados e o transforme para o formato “longo”, de forma que cada estrato idade-sexo esteja em uma linha\nUna os óbitos com as populações\n\nPrimeiro, nós iremos unir os dados de população por país, transformar para o formato longo, e realizar uma limpeza mínima dos dados. Veja a página sobre Pivoteando os dados para mais detalhes.\n\npop_countries &lt;- A_demo %&gt;%  # inicie com os dados do país A\n     bind_rows(B_demo) %&gt;%        # una as linhas, uma vez que as colunas têm o mesmo nome\n     pivot_longer(                       # transforme (pivot) para o formato longo\n          cols = c(m, f),                   # colunas para combinar em uma\n          names_to = \"Sex\",                 # nome para a nova coluna contendo a categoria (\"m\" ou \"f\") \n          values_to = \"Population\") %&gt;%     # nome para a nova coluna contendo os valores numéricos transformados (pivoted)\n     mutate(Sex = recode(Sex,            # re-codifique os valores para clareza\n          \"m\" = \"Male\",\n          \"f\" = \"Female\"))\n\nAgora, os dados populacionais combinados estão assim (clique para ver os países A e B)\n\n\n\n\n\n\nE, agora, nós iremos realizar operações similares nos dois bancos de óbitos.\n\ndeaths_countries &lt;- A_deaths %&gt;%    # inicie com os dados de óbitos do país A\n     bind_rows(B_deaths) %&gt;%        # una as linhas com os dados do país B, uma vez que o nome das colunas é igual\n     pivot_longer(                  # transforme para formato longo\n          cols = c(Male, Female),        # colunas para transformar em uma\n          names_to = \"Sex\",              # nome da nova coluna contendo a categoria (\"m\" ou \"f\") \n          values_to = \"Deaths\") %&gt;%      # nome da nova coluna contendo os valores numéricos transformados\n     rename(age_cat5 = AgeCat)      # renomeie para mais clareza\n\nAgora, os dados de óbitos estão da seguinte forma, e contêm dados de ambos países:\n\n\n\n\n\n\nAgora, nós uniremos os dados populacionais e de óbitos, baseado nas colunas em comum Country, age_cat5, e Sex. O processo também adiciona a coluna Deaths.\n\ncountry_data &lt;- pop_countries %&gt;% \n     left_join(deaths_countries, by = c(\"Country\", \"age_cat5\", \"Sex\"))\n\nEntão, podemos classificar Sex, age_cat5, e Country como factors, e ajustar a ordem dos níveis com a função fct_relevel() do pacote forcats, como descrito na página Fatores. Nota, visivelmente, classificar os níveis dos factors não altera os dados, mas o comando arrange() ordena os dados por país (Country), categoria de idade (age), e sexo (sex).\n\ncountry_data &lt;- country_data %&gt;% \n  mutate(\n    Country = fct_relevel(Country, \"A\", \"B\"),\n      \n    Sex = fct_relevel(Sex, \"Male\", \"Female\"),\n        \n    age_cat5 = fct_relevel(\n      age_cat5,\n      \"0-4\", \"5-9\", \"10-14\", \"15-19\",\n      \"20-24\", \"25-29\",  \"30-34\", \"35-39\",\n      \"40-44\", \"45-49\", \"50-54\", \"55-59\",\n      \"60-64\", \"65-69\", \"70-74\",\n      \"75-79\", \"80-84\", \"85\")) %&gt;% \n          \n  arrange(Country, age_cat5, Sex)\n\n\n\n\n\n\n\nCUIDADO: Se você possuir poucos óbitos por estrato, considere utilizar categorias com intervalos de 10 ou 15 anos, em vez de 5 anos.\n\n\nCarregue os dados populacionais de referência\nPor último, para realizar a padronização direta, nós iremos importar a população de referência (“população mundial de referência” por sexo)\n\n# População de referência\nstandard_pop_data &lt;- import(\"world_standard_population_by_sex.csv\")\n\n\n\n\n\n\n\n\n\n\nLimpe os dados da população de referência\nOs valores por categorias de idade nos conjuntos de dados country_data e standard_pop_data precisam ser alinhados.\nNo momento, os valores da coluna age_cat5, do conjunto standard_pop_data, contém as palavras “years” e “plus”, enquanto os dados em country_data não possuem essas palavras. Nós precisamos garantir que os valores da categoria “age” coincidam. Para tanto, utilizaremos a função str_replace_all(), do pacote stringr, como descrito na página sobre Caracteres e strings, para substituir estes padrões para “sem espaço” \"\".\nAlém disso, o pacote dsr espera que, na população de referência, a coluna contendo as contagens será chamada de \"pop\". Então, iremos renomear essa coluna desta forma.\n\n# Remova palavras específicas da coluna valores (\"values\")\nstandard_pop_clean &lt;- standard_pop_data %&gt;%\n     mutate(\n          age_cat5 = str_replace_all(age_cat5, \"years\", \"\"),   # remova \"year\"\n          age_cat5 = str_replace_all(age_cat5, \"plus\", \"\"),    # remova \"plus\"\n          age_cat5 = str_replace_all(age_cat5, \" \", \"\")) %&gt;%   # remova \" \" espaço\n     \n     rename(pop = WorldStandardPopulation)   # mude o nome da coluna para \"pop\", como o pacote dsr solicita\n\nCUIDADO: Se você tentar utilizar a função str_replace_all() para remover o símbolo de adição, ele não irá funcionar pois é um símbolo especial. “Ignore” o caráter especial ao colocar duas barras invertidas na frente, como em str_replace_call(column, \"\\\\+\", \"\"). \n\n\nCrie um conjunto de dados com uma população padrão\nFinalmente, o pacote PHEindicatormethods, detalhado abaixo, trabalha com as populações padrões unidas aos dados dos países e contagens da população. Então, nós iremos criar um banco de dados chamado all_data para isto.\n\nall_data &lt;- left_join(country_data, standard_pop_clean, by=c(\"age_cat5\", \"Sex\"))\n\nO conjunto de dados inteiro ficou assim:",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Normalização de taxas</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.pt.html#pacote-dsr",
    "href": "new_pages/standardization.pt.html#pacote-dsr",
    "title": "21  Normalização de taxas",
    "section": "21.3 pacote dsr",
    "text": "21.3 pacote dsr\nAbaixo, nós demonstramos como calcular e comparar taxas normalizadas diretamente, utilizando o pacote dsr. O pacote dsr permite o cálculo e comparação de taxas normalizadas diretamente (mas não taxas normalizadas indiretamente!).\nNa seção sobre Preparação dos dados, nós construímos diferentes conjuntos de dados para contagens dos países e da população padrão:\n\no objeto country_data contém uma tabela populacional com a quantidade da população e o número de mortes por estrato por país\no objeto standard_pop_clean contém o número da população por estrato da população padrão, a População Mundial Padrão\n\nNós iremos utilizar estes dados separados na abordagem do dsr.\n\n\nTaxas normalizadas\nAbaixo, nós calculamos as taxas por país normalizadas diretamente para idade e sexo. Nós utilizamos a função dsr().\nDe nota - a função dsr() espera uma tabela de dados para as populações do país e as contagens dos eventos (mortes), e um data frame separado contendo a população padrão. Ela também considera que no banco de dados da população padrão, o nome da coluna com a unidade-tempo é “pop” (nós garantimos isto na seção sobre Preparação de dados).\nExistem muitos argumentos possíveis, como anotado no código abaixo. Notavelmente, a coluna Deaths está selecionada em event =, e a coluna Population está selecionada para fu = (“acompanhamento”). Nós selecionamos os subgrupos de comparação como sendo da coluna Country, e padronizamos baseado em age_cat5 e Sex. Estas últimas duas colunas não foram utilizadas em nenhum argumento em particular. Veja ?dsr para detalhes.\n\n# Calcula as taxas por país normalizadas diretamente por idade (age) e sexo (sex)\nmortality_rate &lt;- dsr::dsr(\n     data = country_data,  # especifique o objeto contendo o número de mortes por estrato\n     event = Deaths,       # coluna contendo o número de mortes por estrato\n     fu = Population,      # coluna contendo o número da população por estrato\n     subgroup = Country,   # unidades que gostaríamos de comparar\n     age_cat5,             # outras colunas - taxas serão normalizadas por estas colunas\n     Sex,\n     refdata = standard_pop_clean, # data frame contendo a população de referência, com a coluna chamada pop\n     method = \"gamma\",      # método para calcular o IC 95%\n     sig = 0.95,            # nível de significância\n     mp = 100000,           # nós queremos taxas por 100.000 habitantes\n     decimals = 2)          # quantidade de decimais\n\n\n# Printa o output como uma tabela em HTML\nknitr::kable(mortality_rate) # mostra as taxas de mortalidade antes e após padronização direta\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSubgroup\nNumerator\nDenominator\nCrude Rate (per 1e+05)\n95% LCL (Crude)\n95% UCL (Crude)\nStd Rate (per 1e+05)\n95% LCL (Std)\n95% UCL (Std)\n\n\n\n\nA\n11344\n86790567\n13.07\n12.83\n13.31\n23.57\n23.08\n24.06\n\n\nB\n9955\n52898281\n18.82\n18.45\n19.19\n19.33\n18.46\n20.22\n\n\n\n\n\nAcima, nós vemos que enquanto o país A possui uma menor taxa de mortalidade bruta do que o país B, ele possui uma maior taxa normalizada de mortalidade após normalizar utilizando a idade e o sexo.\n\n\n\nRelação entre taxas normalizadas\n\n# Calcule a razão entre as taxas (rates ratio)\nmortality_rr &lt;- dsr::dsrr(\n     data = country_data, # especifique o objeto que contém o número de mortes por estrato\n     event = Deaths,      # coluna contendo o número de óbitos por estrato\n     fu = Population,     # coluna contendo o número da população por estrato\n     subgroup = Country,  # unidades que queremos comparar\n     age_cat5,\n     Sex,                 # características para as quais gostaríamos de normalizar\n     refdata = standard_pop_clean, # população de referência, com números em uma coluna chamada pop\n     refgroup = \"B\",      # referência para comparação\n     estimate = \"ratio\",  # tipo de estimativa\n     sig = 0.95,          # nível de significância\n     mp = 100000,         # nós queremos taxas por 100.000 habitantes\n     decimals = 2)        # quantidade de decimais\n\n# Printa a tabela\nknitr::kable(mortality_rr) \n\n\n\n\n\n\n\n\n\n\n\n\nComparator\nReference\nStd Rate (per 1e+05)\nRate Ratio (RR)\n95% LCL (RR)\n95% UCL (RR)\n\n\n\n\nA\nB\n23.57\n1.22\n1.17\n1.27\n\n\nB\nB\n19.33\n1.00\n0.94\n1.06\n\n\n\n\n\nA taxa de mortalidade normalizada é 1.22 vezes maior no país A em relação ao país B (IC 95% 1.17-1.27).\n\n\n\nDiferença entre taxas normalizadas\n\n# Calcule a diferença entre taxas normalizadas (Rates Difference)\nmortality_rd &lt;- dsr::dsrr(\n     data = country_data,       # especifique o objeto contendo o número de mortes por estrato\n     event = Deaths,            # coluna contendo o número de óbitos por estrato\n     fu = Population,           # coluna contendo a quantidade de população por estrato\n     subgroup = Country,        # unidades que gostaríamos de comparar\n     age_cat5,                  # características para as quais gostaríamos de normalizar\n     Sex,                        \n     refdata = standard_pop_clean, # população de referência, com números na coluna chamada pop\n     refgroup = \"B\",            # refência para comparação\n     estimate = \"difference\",   # tipo de estimativa\n     sig = 0.95,                # nível de significância\n     mp = 100000,               # nós queremos taxas por 100.000 habitantes\n     decimals = 2)              # quantidade de decimais\n\n# Printa a tabela\nknitr::kable(mortality_rd) \n\n\n\n\n\n\n\n\n\n\n\n\nComparator\nReference\nStd Rate (per 1e+05)\nRate Difference (RD)\n95% LCL (RD)\n95% UCL (RD)\n\n\n\n\nA\nB\n23.57\n4.24\n3.24\n5.24\n\n\nB\nB\n19.33\n0.00\n-1.24\n1.24\n\n\n\n\n\nQuando comparado ao país B, o país A possui 4.24 óbitos adicionais por 100.000 habitantes (IC 95% 3.24-5.24).",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Normalização de taxas</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.pt.html#standard_phe",
    "href": "new_pages/standardization.pt.html#standard_phe",
    "title": "21  Normalização de taxas",
    "section": "21.4 pacote PHEindicatormethods",
    "text": "21.4 pacote PHEindicatormethods\nOutra forma de calcular as taxas normalizadas é com o pacote PHEindicatormethods. Este pacote permite calcular tanto taxas normalizadas diretamente, como taxas normalizadas indiretamente. Nós iremos mostrar como realizar ambos cálculos.\nNeste seção, iremos utilizar os dados no objeto all_data, criado no fim da seção de Preparação. Estes dados possuem a população dos países, quantidade de mortes, e a população padrão mundial. Você pode vê-lo aqui.\n\n\nTaxas normalizadas diretamente\nAbaixo, primeiro agrupamos os dados por País, e então aplicamos a função phe_dsr() para obter taxas diretamente normalizadas por país.\nDe nota - a população de referência (padrão) pode ser fornecida como uma coluna dentro de uma tabela de dados específica para cada país ou como um vetor separado. Se fornecida dentro de uma tabela específica para um país, você precisa ajustar stdpoptype = \"field\". Se fornecido como um vetor, ajuste stdpoptype = \"vector\". Neste último caso, você precisa garantir que a ordem das linhas por estrato é similar em ambas tabelas dos países e população de referência, pois os registros serão ligados por posição. No exemplo abaixo, fornecemos a população de referência como uma coluna dentro de uma tabela específica de um páís.\nPara mais informações, utilize ?phr_dsr, ou acesse os links na seção de Referências.\n\n# Calcule as taxas por país diretamente normalizadas para idade e sexo\nmortality_ds_rate_phe &lt;- all_data %&gt;%\n     group_by(Country) %&gt;%\n     PHEindicatormethods::phe_dsr(\n          x = Deaths,                 # coluna com o número observado de eventos\n          n = Population,             # coluna com a população não-normalizada para cada estrato\n          stdpop = pop,               # populações padronizadas para cada estrato\n          stdpoptype = \"field\")       # ou \"vector\" para vetor autônomo ou \"field\" para populações padronizadas nos dados\n\n# Printa a tabela\nknitr::kable(mortality_ds_rate_phe)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCountry\ntotal_count\ntotal_pop\nvalue\nlowercl\nuppercl\nconfidence\nstatistic\nmethod\n\n\n\n\nA\n11344\n86790567\n23.56686\n23.08107\n24.05944\n95%\ndsr per 100000\nDobson\n\n\nB\n9955\n52898281\n19.32549\n18.45516\n20.20882\n95%\ndsr per 100000\nDobson\n\n\n\n\n\n\n\n\nTaxas normalizadas indiretamente\nPara normalização indireta, você precisa de uma população de referência com o número de óbitos e a quantidade da população por estrato. Neste exemplo, nós iremos calcular as taxas para o país A utilizando o país B como população de referência, uma vez que a população de referência em standard_pop_clean não possui a quantidade de mortes por estrato.\nAbaixo, primeiro criamos a população de referência do país B. Então, passamos os dados populacionais e de mortalidade do país A, combinamos ele com a população de referência, e passamos para a função calculate_ISRate(), para obter taxas indiretamente normalizadas. Claro, você pode fazer isto vice versa.\nDe nota - no exemplo abaixo, a população de referência é fornecida como um data frame separado. Neste caso, nós garantimos que os vetores x =, n =, x_ref = e n_ref = são todos ordenados pelos mesmos valores da categoria de padronização (estrato) como nos nossos dados específicos dos países, uma vez que os registros serão ligados pela posição na tabela.\nPara mais informações, utilize ?phr_isr, ou acesse os links na seção de Referências.\n\n# Crie a população de referência\nrefpopCountryB &lt;- country_data %&gt;% \n  filter(Country == \"B\") \n\n# Calcule taxas para o país A indiretamente normalizada por idade e sexo\nmortality_is_rate_phe_A &lt;- country_data %&gt;%\n     filter(Country == \"A\") %&gt;%\n     PHEindicatormethods::calculate_ISRate(\n          x = Deaths,                 # coluna com o número observado de eventos\n          n = Population,             # coluna com população não padronizada para cada estrato\n          x_ref = refpopCountryB$Deaths,  # quantidade referência de mortes  para cada estrato\n          n_ref = refpopCountryB$Population)  # população de referência para cada estrato\n\n# Printa a tabela\nknitr::kable(mortality_is_rate_phe_A)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nobserved\nexpected\nref_rate\nvalue\nlowercl\nuppercl\nconfidence\nstatistic\nmethod\n\n\n\n\n11344\n15847.42\n18.81914\n13.47123\n13.22446\n13.72145\n95%\nindirectly standardised rate per 100000\nByars",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Normalização de taxas</span>"
    ]
  },
  {
    "objectID": "new_pages/standardization.pt.html#recursos",
    "href": "new_pages/standardization.pt.html#recursos",
    "title": "21  Normalização de taxas",
    "section": "21.5 Recursos",
    "text": "21.5 Recursos\nSe você quiser ver outros exemplos reproduzíveis utilizando dsr, por favor veja esse tutorial\nPara outro exemplo utilizando PHEindicatormethods, por favor vá a esse website\nVeja o arquivo de referência do PHEindicatormethods em pdf",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Normalização de taxas</span>"
    ]
  },
  {
    "objectID": "new_pages/moving_average.pt.html",
    "href": "new_pages/moving_average.pt.html",
    "title": "22  Médias móveis",
    "section": "",
    "text": "22.1 Preparação",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Médias móveis</span>"
    ]
  },
  {
    "objectID": "new_pages/moving_average.pt.html#preparação",
    "href": "new_pages/moving_average.pt.html#preparação",
    "title": "22  Médias móveis",
    "section": "",
    "text": "Carregue os pacotes\nO código abaixo realiza o carregamento dos pacotes necessários para a análise dos dados. Neste manual, enfatizamos o uso da função p_load(), do pacman, que instala os pacotes, caso não estejam instalados, e os carrega no R para utilização. Também é possível carregar pacotes instalados utilizando a função library(), do R base. Para mais informações sobre os pacotes do R, veja a página Introdução ao R.\n\npacman::p_load(\n  tidyverse,      # para gerenciamento e visualização dos dados\n  slider,         # para calcular médias móveis\n  tidyquant       # para calcular médias móveis dentro do ggplot\n)\n\n\n\nImporte os dados para R\nNós iremos importar o banco de dados de casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar os passos abaixo, clique aqui para fazer o download do banco de dados ‘limpo’ (como arquivo .rds). Importe seus dados utilizando a função import() do pacote rio (esta função importa muitos tipos de arquivos, como .xlsx, .rds, .csv - veja a página Importar e exportar para detalhes).\n\n# importe o *linelist*\nlinelist &lt;- import(\"linelist_cleaned.xlsx\")\n\nAs primeiras 50 linhas do banco de dados são mostradas abaixo.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Médias móveis</span>"
    ]
  },
  {
    "objectID": "new_pages/moving_average.pt.html#calculando-com-o-pacote-slider",
    "href": "new_pages/moving_average.pt.html#calculando-com-o-pacote-slider",
    "title": "22  Médias móveis",
    "section": "22.2 Calculando com o pacote slider",
    "text": "22.2 Calculando com o pacote slider\nUtilize esta abordagem para calcular uma média móvel em um conjunto de dados antes de traçar o gráfico.\nO pacote slider fornece diferentes funções que utilizam a abordagem de “janelas deslizantes” (do inglês, sliding window) para calcular médias móveis, somas cumulativas, regressões móveis, etc. Este pacote trata o conjunto de dados como um vetor de linhas, permitindo a iteração entre as linhas do conjunto de dados.\nAqui estão algumas das funções mais comuns:\n\nslide_dbl() - realiza a iteração de uma coluna numérica (logo “_dbl”) enquanto executa uma operação usando o protocolo das janelas deslizantes\n\nslide_sum() - função atalho para realizar a soma móvel para a função slide_dbl()\n\nslide_mean() - função atalho para realizar a média móvel para a função slide_dbl()\n\nslide_index_dbl() - aplica as janelas deslizantes em uma coluna numérica, utilizando uma coluna separada para indexar a progressão das janelas (útil se a progressão estiver sendo por datas e algumas estiverem ausentes)\n\nslide_index_sum() - função atalho para realizar a soma móvel usando indexador\n\nslide_index_mean() - função atalho para realizar a média móvel usando indexador\n\n\nO pacote slider possui muitas outras funções que são cobertas na seção sobre Recursos extras desta página. Aqui, nós abordamos brevemente as funções mais comuns.\nArgumentos essenciais\n\n.x, por padrão, o primeiro argumento é o vetor sobre o qual serão realizadas as iterarações e sobre o qual será aplicada a função\n\n.i = para as versões “index” das funções do pacote slider - indique a coluna para “indexar” o “delizamento” (veja a seção abaixo)\n\n.f =, por padrão, o segundo argumento é:\n\nUma função, escrita sem parênteses, como mean, ou\n\nUma fórmula, que será convertida em uma função. Por exemplo, ~ .x - mean(.x) irá gerar o resultado do valor corrente menos a média do valor da janela\n\nPara mais detalhes, veja esse material de referência\n\nTamanho da janela\nEspecifique a extensão da janela ao usar .before, .after, ou ambos argumentos:\n\n.before = - Forneça um número inteiro\n\n.after = - Forneça um número inteiro\n\n.complete = - Ajuste isso para TRUE se você apenas quiser realizar os cálculos em janelas completas\n\nPor exemplo, para atingir uma janela de 7 dias incluindo o valor corrente e os seis anteriores, utilize .before = 6. Para obter uma janela “central”, forneça o mesmo número tanto para .before = quanto para .after =.\nPor padrão, .complete = será FALSE. Então, se a janela inteira de linhas não existir, as funções irão utilizar linhas disponíveis para executar os cálculos. Alterar para TRUE restringue isso, de forma que os cálculos serão realizados apenas em janelas completas.\nJanelas em expansão\nPara obter operações cumulativas, ajuste o argumento .before = para Inf. Isto irá realizar a operação no valor corrente e em todos os valores anteriores.\n\nDeslizando por data\nA aplicação mais provável de cálculos móveis em epidemiologia aplicada é para examinar um indicador ao longo do tempo. Por exemplo, uma medida móvel da incidência de casos, baseado na contagem diária dos casos.\nSe você possuir dados com séries cronológicas limpas, com valores para cada data, você pode estar OK para utilizar a função slide_dbl(), como demonstrado aqui na página sobre Séries temporais e detecção de surtos.\nEntretanto, em muitas situações da epidemiologia aplicada, você pode não ter algumas datas nos seus dados, em que os eventos não foram registrados. Nestes casos, é melhor utilizar as versões “index” das funções do slider.\n\n\nDados indexados\nAbaixo, nós mostramos um exemplo utilizando a função slide_index_dbl() no objeto linelist criado acima. Digamos que nosso objetivo é calcular uma incidência móvel de 7 dias - a soma dos casos utilizando uma janela de 7 dias. Se você estiver procurando por um exemplo de média móvel, veja a seção abaixo sobre deslocamento agrupado.\nPara iniciar, o conjunto de dados daily_counts é criado para refletir a contagem diária de casos do linelist, sendo calculado com a função count() do dplyr.\n\n# crie um conjunto de dados das contagens diárias\ndaily_counts &lt;- linelist %&gt;% \n  count(date_hospitalisation, name = \"new_cases\")\n\nAqui estão os dados do daily_counts - existem nrow(daily_counts) linhas, onde cada dia é representado por uma linha mas, especialmente no início da epidemia, alguns dias não estão presentes (não existem casos admitidos nestes dias).\n\n\n\n\n\n\nÉ crucial reconhecer que uma função móvel padrão (como slide_dbl()) iria utilizar uma janela de 7 linhas, não de 7 dias. Logo, se existirem datas ausentes, algumas janelas irão abrangir mais do que 7 dias de um calendário!\nUma janela móvel “inteligente” pode ser obtida com a função slide_index_dbl(). O “index” significa que a função utiliza uma coluna separada como “indexador” para a janela deslizante. Assim, a janela não é simplesmente baseada nas linhas do conjunto de dados.\nSe a coluna indexadora for uma data, você possui a habilidade para especificar a extensão da janela em .before = e/ou .after = em diferentes unidades, utilizando as funções days() ou months() do pacote lubridate. Se você fizer isto, a função irá incluir os dias ausentes nas janelas como se lá estivessem (com valores NA).\nVamos mostrar uma comparação. Abaixo, nós calculamos a incidência móvel de casos por 7 dias, utilizando uma janela regular e uma indexada.\n\nrolling &lt;- daily_counts %&gt;% \n  mutate(                                # crie novas colunas\n    # Utilizando slide_dbl()\n    ###################\n    reg_7day = slide_dbl(\n      new_cases,                         # calcule utilizando new_cases\n      .f = ~sum(.x, na.rm = T),          # função sum() com os campos em branco removidos\n      .before = 6),                      # a janela é a LINHA corrente e as 6 LINHAS anteriores\n    \n    # Utilizando slide_index_dbl()\n    #########################\n    indexed_7day = slide_index_dbl(\n        new_cases,                       # calcule com new_cases\n        .i = date_hospitalisation,       # indexado com date_onset \n        .f = ~sum(.x, na.rm = TRUE),     # função sum() com os campos em branco removidos\n        .before = days(6))               # a janela é o DIA e os 6 DIAS anteriores\n    )\n\nObserve como, na coluna regular, a contagem aumenta constantemente nas primeiras 7 linhas, mesmo com estas linhas estando fora do intervalo de 7 dias entre elas! A coluna adjacente “indexada” leva em consideração estes dias ausentes do calendário, então suas somas móveis de 7 dias são muito menores, pelo menos neste período da epidemia, quando os casos estão mais distantes uns dos outros.\n\n\n\n\n\n\nAgora você pode traçar um gráfico desses dados utilizando o ggplot():\n\nggplot(data = rolling)+\n  geom_line(mapping = aes(x = date_hospitalisation, y = indexed_7day), size = 1)\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDeslizando por grupo\nSe você agrupar seus dados antes de utilizar uma função do slider, as janelas deslizantes serão aplicadas por grupos. Tenha cuidado para organizar suas linhas na ordem desejada por grupo.\nA cada momento que um novo grupo se inicia, as janelas deslizantes irão reiniciar. Logo, um detalhe para se ter em mente é, se seus dados são agrupados e você realizou o ajuste .complete = TRUE, você terá valores em branco a cada transição entre os grupos. Enquanto a função se desloca para baixo ao longo das linhas, cada transição na coluna de agrupamento irá reiniciar o acúmulo do tamanho mínimo da janela, de forma a permitir a realização do cálculo.\nVeja a página sobre Agrupamento dos dados, deste manual, para detalhes sobre agrupamento dos dados.\nAbaixo, nós contamos os casos do linelist por dia e por hospital. Então, ordenamos as linhas em ordem ascendente, primeiro ordenando por hospital, e então por dia (dentro da ordem dos hospitais). Por fim, nós ajustamos a função group_by(), e assim criamos a nossa nova média móvel.\n\ngrouped_roll &lt;- linelist %&gt;%\n\n  count(hospital, date_hospitalisation, name = \"new_cases\") %&gt;% \n\n  arrange(hospital, date_hospitalisation) %&gt;%   # organize as linhas por hospital, e então por datas\n  \n  group_by(hospital) %&gt;%              # agrupe por hospital\n    \n  mutate(                             # média móvel\n    mean_7day_hosp = slide_index_dbl(\n      .x = new_cases,                 # a contagem de casos por hospital-dia\n      .i = date_hospitalisation,      # indexe por dia de admissão\n      .f = mean,                      # utilize mean()                   \n      .before = days(6)               # utilize o dia corrente e os 6 dias anteriores\n      )\n  )\n\nAqui está o novo conjunto de dados:\n\n\n\n\n\n\nAgora, nós podemos traçar os gráficos das médias móveis, mostrando os dados por grupo ao especificar ~ hospital para facet_wrap() no ggplot(). Por diversão, incluímos dois tipos de visualização - uma geom_col(), mostrando a contagem diária de casos, e uma geom_line(), mostrando a média móvel de 7 dias.\n\nggplot(data = grouped_roll)+\n  geom_col(                       # adicione a contagem diária de casos como barras cinzas\n    mapping = aes(\n      x = date_hospitalisation,\n      y = new_cases),\n    fill = \"grey\",\n    width = 1)+\n  geom_line(                      # adicione a média móvel como linhas coloridas por hospital\n    mapping = aes(\n      x = date_hospitalisation,\n      y = mean_7day_hosp,\n      color = hospital),\n    size = 1)+\n  facet_wrap(~hospital, ncol = 2)+ # crie pequenos gráficos por hospital\n  theme_classic()+                 # simplifique o plano de fundo\n  theme(legend.position = \"none\")+ # remova a legenda\n  labs(                            # adicione legendas aos eixos e título do gráfico\n    title = \"7-day rolling average of daily case incidence\",\n    x = \"Date of admission\",\n    y = \"Case incidence\")\n\n\n\n\n\n\n\n\nPERIGO: Se você obtiver um erro dizendo “slide() was deprecated in tsibble 0.9.0 and is now defunct. Please use slider::slide() instead.”, significa que a função slide(), do pacote tsibble, está mascarando a função slide(), do pacote slider. Corrija isso ao especificar o pacote no comando, como em slider::slide_dbl().",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Médias móveis</span>"
    ]
  },
  {
    "objectID": "new_pages/moving_average.pt.html#calcule-com-o-pacote-tidyquant-dentro-da-função-ggplot",
    "href": "new_pages/moving_average.pt.html#calcule-com-o-pacote-tidyquant-dentro-da-função-ggplot",
    "title": "22  Médias móveis",
    "section": "22.3 Calcule com o pacote tidyquant dentro da função ggplot()",
    "text": "22.3 Calcule com o pacote tidyquant dentro da função ggplot()\nO pacote tidyquant oferece outra abordagem para calcular médias móveis - desta vez, de dentro de um comando ggplot().\nAbaixo, os dados do linelist são contados por dia do início de sintomas, e isto é adicionado ao gráfico como uma linha desbotada (alpha &lt; 1). Em frente à essa linha, está uma outra linha criada com a função geom_ma(), do pacote tidyquant, com uma janela de 7 dias (n = 7), cor e espessura especificados.\nPor padrão, geom_ma() utiliza uma média móvel simples (ma_fun = \"SMA\"), mas outros tipos podem ser especificados, como:\n\n“EMA” - média móvel exponencial (mais peso para observações recentes)\n\n“WMA” - média móvel ponderada (wts são utilizadas para ponder observações na média móvel)\n\nOutros tipos podem ser encontrados na documentação da função\n\n\nlinelist %&gt;% \n  count(date_onset) %&gt;%                 # conte os casos por dia\n  drop_na(date_onset) %&gt;%               # remova casos sem a data de início dos sintomas\n  ggplot(aes(x = date_onset, y = n))+   # inicie o ggplot\n    geom_line(                          # adicione uma linha com os valores brutos\n      size = 1,\n      alpha = 0.2                       # linha semi-transparente\n      )+             \n    tidyquant::geom_ma(                 # adicione a média móvel\n      n = 7,           \n      size = 1,\n      color = \"blue\")+ \n  theme_minimal()                       # plano de fundo simples\n\nWarning: Using the `size` aesthetic in this geom was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` in the `default_aes` field and elsewhere instead.\n\n\n\n\n\n\n\n\n\nVeja esse tutorial para mais detalhes das opções disponíveis dentro do pacote tidyquant.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Médias móveis</span>"
    ]
  },
  {
    "objectID": "new_pages/moving_average.pt.html#recursos-extras",
    "href": "new_pages/moving_average.pt.html#recursos-extras",
    "title": "22  Médias móveis",
    "section": "22.4 Recursos extras",
    "text": "22.4 Recursos extras\nVeja este útil tutorial online do pacote slider\nA página do pacote slider no github\nUm tutorial do slider\nTutorial do tidyquant\nSe seus casos necessitam que você “pule” fins de semana, ou até mesmo feriados, você pode gostar do pacote almanac.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Médias móveis</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.pt.html",
    "href": "new_pages/time_series.pt.html",
    "title": "23  Séries temporais e detecção de surtos",
    "section": "",
    "text": "23.1 Visão geral do tópico\nEsta página demonstra o uso de diferentes pacotes para analisar séries temporais. São utilizados, principalmente, os pacotes da família tidyverts , mas também o pacote RECON trending para aprimorar modelos mais apropriados para epidemiologia de doenças infecciosas.\nObserve que, no exemplo abaixo, nós utilizamos um banco de dados do pacote surveillance sobre a Campylobacter na Alemanha (veja o capítulo sobre dados, deste manual para mais detalhes). Entretanto, se você quiser executar o mesmo código em um banco de dados com múltiplos países, ou outros estratos, então aqui está um exemplo de código para isto no repositório do r4epis no github.\nTópicos abordados incluem:",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Séries temporais e detecção de surtos</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.pt.html#visão-geral-do-tópico",
    "href": "new_pages/time_series.pt.html#visão-geral-do-tópico",
    "title": "23  Séries temporais e detecção de surtos",
    "section": "",
    "text": "Dados com séries temporais\nAnálise descritiva\nAjustando regressões\nRelação de duas séries temporais\nDetecção de surtos\nSéries temporais interrompidas",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Séries temporais e detecção de surtos</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.pt.html#preparação",
    "href": "new_pages/time_series.pt.html#preparação",
    "title": "23  Séries temporais e detecção de surtos",
    "section": "23.2 Preparação",
    "text": "23.2 Preparação\n\nCarregue os pacotes R\nO código abaixo realiza o carregamento dos pacotes necessários para a análise dos dados. Neste manual, enfatizamos o uso da função p_load(), do pacman, que instala os pacotes, caso não estejam instalados, e os carrega no R para utilização. Também é possível carregar pacotes instalados utilizando a função library(), do R base. Para mais informações sobre os pacotes do R, veja a página Introdução ao R.\n\npacman::p_load(rio,          # Importar arquivos\n               here,         # Localizar arquivos\n               tidyverse,    # gerenciamento de dados + gráficos ggplot2\n               tsibble,      # trabalhe com dados de séries temporais\n               slider,       # para calcular médias móveis\n               imputeTS,     # para preencher campos em branco\n               feasts,       # para decomposição de séries temporais e autocorrelações\n               forecast,     # ajusta senos e cosenos nos dados (nota: precisa ser carregado após pacote feasts)\n               trending,     # ajusta e visualizada modelos\n               tmaptools,    # para obter coordenadas geográficas (long/lat) baseado no nome dos locais\n               ecmwfr,       # para interagir com o satélite copernicus CDS API\n               stars,        # para ler arquivos em .nc (dados climáticos)\n               units,        # para definir unidades de medida (dados climáticos)\n               yardstick,    # para avaliar a acurácia do modelo\n               surveillance, # para detecção de aberrações\n               ncmeta        # ler arquivos .nc\n               )\n\n\n\nCarregue os dados no R\nVocê pode baixar todos os dados utilizados neste manual através das instruções na página de download do manual e dos dados.\nOs dados utilizados nessa seção para fins de exemplificação são as contagens semanais de casos de campylobacter notificados na Alemanha entre 2001 e 2011.  Você pode clicar aqui para baixar este arquivo de dados (.xlsx).\nEste banco de dados é uma versão reduzida do banco de dados disponível no pacote surveillance. (para mais detalhes, carregue o pacote surveillance e veja ?campyDE)\nImporte estes dados com a função import() do pacote rio (ele manipula muitos tipos de arquivos, como .xlsx, .csv, .rds - veja a página sobre Importar e exportar para mais detalhes).\n\n# importe as contagens para o R\ncounts &lt;- rio::import(\"campylobacter_germany.xlsx\")\n\nAs primeiras 10 linhas da contagem são mostradas abaixo.\n\n\n\n\n\n\n\n\nLimpe os dados\nO código abaixo garante que a coluna de datas esteja no formato apropriado. Nesta página, iremos utilizar o pacote tsibble com funções yearweek que serão usadas para criar uma variável com um calendário de semanas. Existem outras maneiras de fazer isso (veja a página trabalhando com datas para mais detalhes), entretanto, para séries temporais é melhor nos mantermos dentro de um único tipo de abordagem (tsibble).\n\n## garanta que a coluna com datas estejam no formato apropriado\ncounts$date &lt;- as.Date(counts$date)\n\n## crie uma variável com semanas do calendário\n## ajuste definições ISO de semanas iniciando na segunda\ncounts &lt;- counts %&gt;% \n     mutate(epiweek = yearweek(date, week_start = 1))\n\n\n\nBaixe (download) os dados climáticos\nNa seção sobre a relação de duas séries temporais nesta página, nós iremos comparar contagens de casos de campylobacter com dados climáticos.\nDados climáticos de qualquer lugar do mundo podem ser baixados do Satélite Copernicus da União Européia Estas não são medições exatas, mas baseadas em um modelo (similar a interpolação). Entretanto, o benefício é a cobertura global a cada hora, bem como previsões.\nVocê pode baixar cada um desses arquivos de dados climáticos da página Download do manual e dos dados.\nPara fins de demonstração, nós iremos mostrar códigos em R que utilizam o pacote ecmwfr para baixar esses dados do repositório do Copernicus. Você precisa criar uma conta gratuita para que isto funcione. O website do pacote tem um passo a passo útil de como fazer isto. Quando tiver as chaves API apropriadas, o código abaixo é um exemplo de como proceder. Você precisa substituir o X abaixo com o ID da sua conta. Você só pode baixar um ano de dados por vez. Do contrário, o tempo do servidor expira.\nSe você não tiver certeza das coordenadas de uma localização que quer baixar os dados, é possível utilizar o pacote tmaptools para baixar as coordenadas de um mapa open street. Outra alternativa é o pacote photon, entretanto ele ainda não foi liberado no CRAN; algo interessante do\nphoton é que ele fornece mais dados contextuais caso existam diferentes resultados para o que se busca.\n\n## recupere as coordenadas de localização\ncoords &lt;- geocode_OSM(\"Germany\", geometry = \"point\")\n\n## baixe as long/lats juntas no formado para busca no ERA-5 (caixa de delimitação) \n## (como só quer um único ponto, pode repetir as coordenadas)\nrequest_coords &lt;- str_glue_data(coords$coords, \"{y}/{x}/{y}/{x}\")\n\n\n## Baixando dados modelados do satélite copernicus (reanálise ERA-5)\n## https://cds.climate.copernicus.eu/cdsapp#!/software/app-era5-explorer?tab=app\n## https://github.com/bluegreen-labs/ecmwfr\n\n## configure uma chave para os dados climáticos\nwf_set_key(user = \"XXXXX\",\n           key = \"XXXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXX\",\n           service = \"cds\") \n\n## para cada ano de interesse, execute o código (do contrário o tempo do servidor expira)\nfor (i in 2002:2011) {\n  \n  ## monte uma requisição (*Query*)\n  ## veja aqui para como fazer isso: https://bluegreen-labs.github.io/ecmwfr/articles/cds_vignette.html#the-request-syntax\n  ## altere o pedido para uma lista utilizando o botão *addin* acima (python para lista)\n  ## O alvo é o nome do arquivo de saída!!\n  request &lt;- request &lt;- list(\n    product_type = \"reanalysis\",\n    format = \"netcdf\",\n    variable = c(\"2m_temperature\", \"total_precipitation\"),\n    year = c(i),\n    month = c(\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\"),\n    day = c(\"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"10\", \"11\", \"12\",\n            \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\",\n            \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\"),\n    time = c(\"00:00\", \"01:00\", \"02:00\", \"03:00\", \"04:00\", \"05:00\", \"06:00\", \"07:00\",\n             \"08:00\", \"09:00\", \"10:00\", \"11:00\", \"12:00\", \"13:00\", \"14:00\", \"15:00\",\n             \"16:00\", \"17:00\", \"18:00\", \"19:00\", \"20:00\", \"21:00\", \"22:00\", \"23:00\"),\n    area = request_coords,\n    dataset_short_name = \"reanalysis-era5-single-levels\",\n    target = paste0(\"germany_weather\", i, \".nc\")\n  )\n  \n  ## baixe o aquivo e armazene-o no diretório de trabalho atual\n  file &lt;- wf_request(user     = \"XXXXX\",  # ID do usuário (para autenticação)\n                     request  = request,  # o pedido\n                     transfer = TRUE,     # baixe o arquivo\n                     path     = here::here(\"data\", \"weather\")) ## diretório para salvar os dados\n  }\n\n\n\nCarregue os dados climáticos\nSe você baixou os dados climáticos seguindo o nosso manual, ou se utilizou o código acima, agora você deve ter 10 anos de arquivos com dados climáticos “.nc” armazenados na mesma pasta do seu computador.\nUtilize o código abaixo para importar estes arquivos no R com o pacote stars.\n\n## defina o diretório para a pasta de clima\nfile_paths &lt;- list.files(\n  here::here(\"data\", \"time_series\", \"weather\"), # substitua com o seu próprio endereço de arquivos\n  full.names = TRUE)\n\n\n## mantenha apenas os arquivos que tenham o nome de interesse atual\n file_paths &lt;- file_paths[str_detect(file_paths, \"germany\")]\n## leia todos os arquivos como um objeto stars\n data &lt;- stars::read_stars(file_paths)\n\nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \nt2m, tp, \n\n\nUma vez que estes arquivos foram importados como o objeto data, nós iremos convertê-los para um quadro de dados (data frame).\n\n## mude para um quadro de dados (*data frame*)\ntemp_data &lt;- as_tibble(data) %&gt;% \n  ## adicione variáveis e corrija unidades\n  mutate(\n    ## crie uma variável com um calendário semanal\n    epiweek = tsibble::yearweek(time), \n    ## crie uma variável de data (início do calendário semanal)\n    date = as.Date(epiweek),\n    ## mude a temperatura de kelvin para celsius\n    t2m = set_units(t2m, celsius), \n    ## altere a precipitação de metros para milímetros\n    tp  = set_units(tp, mm)) %&gt;% \n  ## agrupe por semana (mantenha a semana também)\n  group_by(epiweek, date) %&gt;% \n  ## obtenha a média por semana\n  summarise(t2m = as.numeric(mean(t2m)), \n            tp = as.numeric(mean(tp)))\n\n`summarise()` has grouped output by 'epiweek'. You can override using the\n`.groups` argument.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Séries temporais e detecção de surtos</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.pt.html#dados-de-séries-temporais",
    "href": "new_pages/time_series.pt.html#dados-de-séries-temporais",
    "title": "23  Séries temporais e detecção de surtos",
    "section": "23.3 Dados de séries temporais",
    "text": "23.3 Dados de séries temporais\nExistem diferentes pacotes para estruturar e manipular dados de séries temporais. Como dito, nós iremos focar nos pacotes da família tidyverts, e, assim, utilizar o pacote tsibble para definir nosso objeto de séries temporais. Definir os dados como um objeto de séries temporais significa que é muito mais fácil estruturar a nossa análise.\nPara fazer isso, nós utilizamos a função tsibble() e especificamos o “index”. Por exemplo, a variável especificando a unidade de tempo de interesse. No nosso caso, esta é a variável epiweek.\nSe nós tivéssemos dados com contagens semanais por províncias, por exemplo, também seríamos capazes de especificar a variável de agrupamento utilizando o argumento key =. Isto iria nos permitir realizar a análise para cada grupo.\n\n## defina o objeto da série temporal\ncounts &lt;- tsibble(counts, index = epiweek)\n\nAo executar class(counts) nota-se que, além de ser um quadro de dados (data frame) organizado (“tbl_df”, “tbl”, “data.frame”), ele tem propriedades adicionais de um quadro de dados de uma série temporal (“tbl_ts”).\nVocê pode analisar rapidamente os seus dados ao utilizar o ggplot2. Nós vemos pelo gráfico que existe um padrão sazonal óbvio, e que não existem campos em branco. Entretanto, parece existir um erro para notificar os casos no começo de cada ano; o número de casos cai na última semana do ano, e então aumenta na primeira semana do ano seguinte.\n\n## trace um gráfico de linha de casos por semana\nggplot(counts, aes(x = epiweek, y = case)) + \n     geom_line()\n\n\n\n\n\n\n\n\nPERIGO: Boa parte dos bancos de dados não são limpos como o deste exemplo. Você irá precisar checar por duplicatas e campos em branco como mostrado abaixo. \n\n\nDados duplicados\ntsibble não permite observações duplicadas. Então, cada linha precisa ser única, ou única dentro de um grupo (variável key). O pacote tem algumas funções que ajudam a identificar duplicatas. Estes incluem a função are_duplicated(), que gera um vetor TRUE/FALSE caso a linha seja uma duplicata, e a função duplicates() que gera um quadro de dados com as linhas duplicadas.\nVeja a página sobre Eliminando duplicidades para mais detalhes sobre como selecionar as linhas que você quer.\n\n## obtenha um vetor de TRUE/FALSE caso as linhas sejam duplicatas\nare_duplicated(counts, index = epiweek) \n\n## obtenha um quadro de dados (*data frame*) das linhas duplicadas\nduplicates(counts, index = epiweek)\n\n\n\n\nCampos em branco\nPor meio da breve inspeção demonstrada acima, nós vimos que não existem campos em branco em nossos dados, mas também notamos que existe um problema com atrasos de notificação próximo ao ano novo. Uma forma de abordar isto seria atribuir campos vazios a esses valores, e então inserir novos valores. A forma mais simples de iserção (input) em uma série temporal é desenhar uma linha reta entre o último valor preenchido e o próximo valor preenchido (entre os campos em branco). Para fazer isso, nós iremos utilizar a função na_interpolation() do pacote imputeTS.\nVeja a página sobre Dados faltantes para mais informações sobre imputação.\nOutra alternativa seria calcular a média móvel, para tentar suavizar esses problemas aparentes de notificação (veja a próxima seção, e a página sobre médias móveis).\n\n## crie uma variálvel com campos em branco em vez das semanas com problemas na notificação\ncounts &lt;- counts %&gt;% \n     mutate(case_miss = if_else(\n          ## se as semanas epidemilógicas contém 52, 53, 1 or 2\n          str_detect(epiweek, \"W51|W52|W53|W01|W02\"), \n          ## então troque para missing\n          NA_real_, \n          ## do contrário mantenha o valor do campo\n          case\n     ))\n\n## alternativamente interpole os campos em branco por uma tendência linear\n## entre os dois pontos adjacentes mais próximos\ncounts &lt;- counts %&gt;% \n  mutate(case_int = imputeTS::na_interpolation(case_miss)\n         )\n\n## para checar quais valores foram imputados comparados com os originais\nggplot_na_imputations(counts$case_miss, counts$case_int) + \n  ## crie um gráfico tradicional (com eixos negros e fundo branco)\n  theme_classic()",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Séries temporais e detecção de surtos</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.pt.html#análise-descritiva",
    "href": "new_pages/time_series.pt.html#análise-descritiva",
    "title": "23  Séries temporais e detecção de surtos",
    "section": "23.4 Análise descritiva",
    "text": "23.4 Análise descritiva\n\n\nMédias móveis\nSe os dados apresentam muitos ruídos (contagens pulando para cima e para baixo), então pode ser útil calcular a média móvel. No exemplo abaixo, para cada semana nós calculamos o número médio de casos das quatro semanas anteriores. Isto suaviza os dados para torná-los mais fáceis de interpretar. No nosso caso, isto não traz grandes vantagens, então nós iremos manter os dados interpolados para mais análises. Veja a página sobre Médias móveis para mais detalhes.\n\n## crie uma variável de média móvel (o que resolve o problema dos campos em branco)\ncounts &lt;- counts %&gt;% \n     ## crie a variável ma_4w \n     ## passe por cada linha da variável dos casos\n     mutate(ma_4wk = slider::slide_dbl(case, \n                               ## para cada linha, calcule a média\n                               ~ mean(.x, na.rm = TRUE),\n                               ## use as quatro semanas anteriores\n                               .before = 4))\n\n## faça uma visualização rápida da diferença\nggplot(counts, aes(x = epiweek)) + \n     geom_line(aes(y = case)) + \n     geom_line(aes(y = ma_4wk), colour = \"red\")\n\n\n\n\n\n\n\n\n\n\n\nPeridiocidade\nAbaixo, nós definimos uma função customizada para criar um periodograma. Veja a página sobre Escrevendo funções para informações sobre como escrever funções no R.\nPrimeiro, a função é definida. Seus argumentos incluem um banco de dados com uma coluna counts, start_week = que é a primeira semana do banco de dados, um número para indicar quantos períodos por ano (ex.: 52, 12), e, por último, o estilo da saída da análise (veja detalhes no código abaixo).\n\n## Argumentos da função\n#####################\n## x é um banco de dados\n## counts é uma variável com dados contados ou com taxas em x\n## start_week é a primeira semana do banco de dados\n## period são quantas unidades em um ano\n## output é caso você queira retornar um periodograma espectral, ou as semanas de pico\n  ## \"periodogram\" ou \"weeks\"\n\n# Defina a função\nperiodogram &lt;- function(x, \n                        counts, \n                        start_week = c(2002, 1), \n                        period = 52, \n                        output = \"weeks\") {\n  \n\n    ## garanta que não é uma classe tsibble, filtre por projeto e mantenha apenas as colunas de interesse\n    prepare_data &lt;- dplyr::as_tibble(x)\n    \n    # prepare_data &lt;- prepare_data[prepare_data[[strata]] == j, ]\n    prepare_data &lt;- dplyr::select(prepare_data, {{counts}})\n    \n    ## crie uma zona intermediária de série temporal para permitir a utilização no spec.pgram\n    zoo_cases &lt;- zoo::zooreg(prepare_data, \n                             start = start_week, frequency = period)\n    \n    ## obtenha um periodograma espectral sem utilizar a transformação fast fourier \n    periodo &lt;- spec.pgram(zoo_cases, fast = FALSE, plot = FALSE)\n    \n    ## retorne as semanas com picos de casos\n    periodo_weeks &lt;- 1 / periodo$freq[order(-periodo$spec)] * period\n    \n    if (output == \"weeks\") {\n      periodo_weeks\n    } else {\n      periodo\n    }\n    \n}\n\n## obtenha um periodograma espectral para extrair semanas com as maiores frequências\n## (checando para sazonalidade) \nperiodo &lt;- periodogram(counts, \n                       case_int, \n                       start_week = c(2002, 1),\n                       output = \"periodogram\")\n\n## coloque o espectro e a frequência em um quadro de dados para plotagem\nperiodo &lt;- data.frame(periodo$freq, periodo$spec)\n\n## trace um periodograma mostrando a peridiocidade que ocorre mais frequentemente\nggplot(data = periodo, \n                aes(x = 1/(periodo.freq/52),  y = log(periodo.spec))) + \n  geom_line() + \n  labs(x = \"Period (Weeks)\", y = \"Log(density)\")\n\n\n\n\n\n\n\n## obtenha as semanas em vetor em ordem ascendente\npeak_weeks &lt;- periodogram(counts, \n                          case_int, \n                          start_week = c(2002, 1), \n                          output = \"weeks\")\n\nNOTA: É possível utilizar as semanas acima para adicioná-las aos termos de seno e coseno. Entretanto, nós iremos utilizar uma função para gerar esses termos (veja a seção sobre regressão abaixo) \n\n\n\nDecomposição\nPara dividir a série temporal em diferentes partes, a decomposição clássica é utilizada, pois quando analisadas juntas, é possível verificar um padrão. Estas partes distintas são:\n\nO ciclo-tendência (a tendência dos dados no longo prazo)\nA sazonalidade (repetição dos padrões)\nO aleatório (o que resta após remover a tendência e a sazonalidade)\n\n\n## decomponha os dados de contagem\ncounts %&gt;% \n  # utilizando um modelo clássico de decomposição aditiva\n  model(classical_decomposition(case_int, type = \"additive\")) %&gt;% \n  ## extraia a informação importante do modelo\n  components() %&gt;% \n  ## gere um gráfico\n  autoplot()\n\n\n\n\n\n\n\n\n\n\n\nAutocorrelação\nAutocorrelação mostra a relação entre as contagens de cada semana e das semanas anteriores a la (chamado de lags).\nAo utilizar a função ACF(), nós podemos gerar um gráfico que mostra o número de linhas em relação aos diferentes defasagens (lags). Quando o lag for 0 (x = 0), esta linha deve ser sempre 1 pois mostra a relação entre uma observação e ela mesma (não mostrado aqui). A primeira linha mostrada aqui (x = 1) mostra a relação entre cada observação e a última observação antes dela (lag de 1), a segunda mostra a relação entre cada observação e a penúltima observação anterior a ela (lag de 2) e assim por diante, até o lag de 52, que mostra a relação entre cada observação e a observação de 1 ano (52 semanas antes).\nA função PACF() (para autocorrelação parcial) mostra o mesmo tipo de relação mas ajustado para todas as outras semanas no intervalo. Isto é menos útil para determinar a peridiocidade.\n\n## utilizando os dados de contagem\ncounts %&gt;% \n  ## calcule a autocorrelação utilizando defasagens (lags) que cobrem anos completos\n  ACF(case_int, lag_max = 52) %&gt;% \n  ## mostre um gráfico\n  autoplot()\n\n\n\n\n\n\n\n## utilizando os dados de contagem\ncounts %&gt;% \n  ## calcule a autocorrelação parcial utilizando lags que cobrem anos completos\n  PACF(case_int, lag_max = 52) %&gt;% \n  ## mostre um gráfico\n  autoplot()\n\n\n\n\n\n\n\n\nVocê pode testar formalmente a hipótese nula de independência em uma série temporal (i.e.: ausência de autocorrelação) utilizando o teste de Ljung-Box (no pacote stats). Um p-valor significantivo sugere que exista uma autocorrelação nos dados.\n\n## avalia a existência de autocorrelação\nBox.test(counts$case_int, type = \"Ljung-Box\")\n\n\n    Box-Ljung test\n\ndata:  counts$case_int\nX-squared = 462.65, df = 1, p-value &lt; 2.2e-16",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Séries temporais e detecção de surtos</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.pt.html#ajustando-regressões",
    "href": "new_pages/time_series.pt.html#ajustando-regressões",
    "title": "23  Séries temporais e detecção de surtos",
    "section": "23.5 Ajustando regressões",
    "text": "23.5 Ajustando regressões\nÉ possível ajustar uma vasta quantidade de diferentes regressões em uma série temporal. Entretanto, aqui nós iremos demonstrar como ajustar uma regressão binominal negativa - uma\nvez que frequentemente esta é a mais apropriada para dados de contagem em doenças infecciosas.\n\n\nTermos de Fourier\nTermos de Fourier são os equivalentes de curvas seno e coseno. A diferença é que estes são ajustados com base na identificação da combinação mais apropriada das curvas para explicar seus dados.\nO ajuste de apenas um termo de Fourier equivale a ajustar um seno e um coseno para a defasagem (lag) que ocorre mais frequentemente em seu periodograma (no nosso caso, de 52 semanas). Para isso, nós utilizamos a função fourier() do pacote forecast.\nNo código abaixo, a atribuição é feita utilizando o $, uma vez que fourier() retorna duas colunas (uma\npara seno, outra para coseno) que são adicionadas aos dados como uma lista, chamada “fourier”, que pode então ser utilizada normalmente como uma variável na regressão.\n\n## adicione os termos de Fourier utilizando as variáveis epiweek e case_int\ncounts$fourier &lt;- select(counts, epiweek, case_int) %&gt;% \n  fourier(K = 1)\n\n\n\n\nBinominal negativa\nÉ possível ajustar regressões utilizando funções básicas do stats ou MASS (ex.: lm(), glm() e glm.nb()). Entretanto, nós iremos utilizar as funções do pacote trending, pois ele permite o cálculo apropriado dos intervalos de confiança e de predição (que de outra forma não estão disponíveis). A sintaxe é a mesma, em que você especifica uma variável para atribuir o resultado, um til (~), e então adiciona as variáveis de interesse separadas por um sinal de mais (+).\nA outra diferença é que nós primeiro definimos o modelo e então o ajustamos fit() (ajustamos) para os dados. Isto é útil porque permite a comparação de diferentes modelos com a mesma sintaxe.\nDICA: Se você quiser utilizar taxas, em vez de contagens, é possível incluir a variável população como um termo logaritmo de compensação, ao adicionar\noffset(log(population). Para calcular uma taxa, você então precisaria ajustar a população para ser 1, antes de utilizar a função predict(). \nDICA: Para ajustar modelos mais complexos como ARIMA ou profeta (prophet), veja o pacote fable. \n\n## escolha o modelo que você quer ajustar (binominal negativa)\nmodel &lt;- glm_nb_model(\n  ## escolha o número de casos como resultado de interesse\n  case_int ~\n    ## utilize a variável epiweek para levar em consideração a tendência\n    epiweek +\n    ## utilize os termos de Fourier para levar em consideração a sazonalidade\n    fourier)\n\n## ajuste seu modelo utilizando os dados de contagem\nfitted_model &lt;- trending::fit(model, data.frame(counts))\n\n## calcule os intervalos de confiança e predição\nobserved &lt;- predict(fitted_model, simulate_pi = FALSE)\n\nestimate_res &lt;- data.frame(observed$result)\n\n## faça um gráfico da sua regressão\nggplot(data = estimate_res, aes(x = epiweek)) + \n  ## adicione uma linha para a estimativa do modelo\n  geom_line(aes(y = estimate),\n            col = \"Red\") + \n  ## adicione uma faixa sombreada dos intervalos de predição\n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## adicione uma linha para o número de casos\n  geom_line(aes(y = case_int), \n            col = \"black\") + \n  ## faça um gráfico tradicional (com eixos pretos e fundo branco)\n  theme_classic()\n\n\n\n\n\n\n\n\n\n\n\nResíduos\nPara avaliar o quão bem nosso modelo se ajusta aos dados observados, precisamos checar os resíduos. Os resíduos são a diferença entre as contagens observadas e as contagens estimadas pelo modelo. Nós podemos calcular isto de forma simples, utilizando case_int - estimate, mas a função residuals() extrai isso diretamente da regressão para nós.\nO que vemos abaixo é que não estamos explicando toda a variabilidade dos dados com o nosso modelo. Uma possibilidade seria ajustar mais termos de Fourier, e verificar a amplitude. Entretanto, para este exemplo, nós iremos deixar da forma que está. Os gráficos mostram que nosso modelo possui pior desempenho nos picos e nas baixas (quando as contagens estão nas maiores ou nas menores quantidades). Sendo assim, ele provavelmente irá subestimar as contagens observadas.\n\n## calcule os resíduos\nestimate_res &lt;- estimate_res %&gt;% \n  mutate(resid = fitted_model$result[[1]]$residuals)\n\n## os resíduos são razoavelmente constantes ao longo do tempo (se não: surtos? mudanças na prática?)\nestimate_res %&gt;%\n  ggplot(aes(x = epiweek, y = resid)) +\n  geom_line() +\n  geom_point() + \n  labs(x = \"epiweek\", y = \"Residuals\")\n\n\n\n\n\n\n\n## existe autocorrelação nos resíduos (existe um padrão para os erros?)\nestimate_res %&gt;% \n  as_tsibble(index = epiweek) %&gt;% \n  ACF(resid, lag_max = 52) %&gt;% \n  autoplot()\n\n\n\n\n\n\n\n## os resíduos estão distribuídos de forma normal (estão sendo sub ou super estimados?)\nestimate_res %&gt;%\n  ggplot(aes(x = resid)) +\n  geom_histogram(binwidth = 100) +\n  geom_rug() +\n  labs(y = \"count\") \n\n\n\n\n\n\n\n## compare as contagens observadas com os resíduos\n  ## não deve haver padrão\nestimate_res %&gt;%\n  ggplot(aes(x = estimate, y = resid)) +\n  geom_point() +\n  labs(x = \"Fitted\", y = \"Residuals\")\n\n\n\n\n\n\n\n## teste formalmente a autocorrelação dos resíduos\n## H0 é que os resíduos são ruídos brancos (i.e.: aleatórios)\n## teste de independência\n## se p-valor for significantivo, então não é aleatório\nBox.test(estimate_res$resid, type = \"Ljung-Box\")\n\n\n    Box-Ljung test\n\ndata:  estimate_res$resid\nX-squared = 336.25, df = 1, p-value &lt; 2.2e-16",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Séries temporais e detecção de surtos</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.pt.html#relação-entre-duas-séries-temporais",
    "href": "new_pages/time_series.pt.html#relação-entre-duas-séries-temporais",
    "title": "23  Séries temporais e detecção de surtos",
    "section": "23.6 Relação entre duas séries temporais",
    "text": "23.6 Relação entre duas séries temporais\nAqui nós vemos como utilizar dados climáticos (especificamente a temperatura) para explicar a quantidade de casos de campylobacter.\n\n\nUnindo bancos de dados\nNós podemos unir nossos bancos de dados utilizando a variável de semana. Para mais informações sobre junção de dados, veja no manual a seção sobre unindo dados.\n\n## junção à esquerda, de forma que nós teremos apenas as linhas existentes na tabela de contagens\n## exclua a variável date do temp_data (do contrário, ficará duplicada)\ncounts &lt;- left_join(counts, \n                    select(temp_data, -date),\n                    by = \"epiweek\")\n\n\n\n\nAnálise descritiva\nPrimeiro, faça um gráfico de seus dados para ver se existe alguma relação óbvia. O gráfico abaixo mostra que existe uma relação clara na sazonalidade das duas variáveis, e que a temperatura pode aumentar algumas semanas antes da contagem de casos. Para mais sobre o pivoteamento dos dados, veja a seção sobre pivoteando dados neste manual.\n\ncounts %&gt;% \n  ## mantenha as variáveis de interesse\n  select(epiweek, case_int, t2m) %&gt;% \n  ## mude seus dados para o formato longo\n  pivot_longer(\n    ## use a epiweek como \"chave\" para união\n    !epiweek,\n    ## move o nome das colunas para a nova coluna \"measure\"\n    names_to = \"measure\", \n    ## move os valores das células para a nova coluna \"values\"\n    values_to = \"value\") %&gt;% \n  ## crie um gráfico com os dados acima\n  ## trace um gráifco com a epiweek no eixo x e os valores (contagens/temperatura) no eixo y\n  ggplot(aes(x = epiweek, y = value)) + \n    ## crie um gráfico separado para temperaturas e contagens dos casos\n    ## deixe a escala do eixo y livre\n    facet_grid(measure ~ ., scales = \"free_y\") +\n    ## adiciona as informações como uma linha no gráfico\n    geom_line()\n\n\n\n\n\n\n\n\n\n\n\nLags e correlação cruzada\nPara formalmente testar quais semanas estão mais relacionadas com os casos e temperatura. Nós podemos utilizar a função de correlação cruzada (CCF()) do pacote feasts. Você pode também visualizar (em vez de utilizar arrange) os dados com a função autoplot().\n\ncounts %&gt;% \n  ## calcule a correlação cruzada entre as contagens e temperaturas interpoladas\n  CCF(case_int, t2m,\n      ## ajuste o lag máximo para 52 semanas\n      lag_max = 52, \n      ## retorne o coeficiente de correlação\n      type = \"correlation\") %&gt;% \n  ## organize pela ordem decrescente do coeficiente de correlação\n  ## mostre as defasagens de tempo com maior associação\n  arrange(-ccf) %&gt;% \n  ## apenas mostre os dez maiores coeficientes\n  slice_head(n = 10)\n\n# A tsibble: 10 x 2 [1W]\n        lag   ccf\n   &lt;cf_lag&gt; &lt;dbl&gt;\n 1      -4W 0.749\n 2      -5W 0.745\n 3      -3W 0.735\n 4      -6W 0.729\n 5      -2W 0.727\n 6      -7W 0.704\n 7      -1W 0.695\n 8      -8W 0.671\n 9       0W 0.649\n10      47W 0.638\n\n\nA partir disso, nós vemos que uma defasagem (lag) de 4 semanas é o mais altamente correlacionado. Então, nós criamos uma variável de temperatura com esse lag para incluir em nossa regressão.\nPERIGO: Observe que as quatro primeiras semanas dos nossos dados na variável de temperatura com lag estão em branco (NA) - como não existem quatro semanas anteriores para obter os dados. Para utilizar esses dados com a função predict(),\ndo pacote trending, nós precisamos usar o argumento simulate_pi = FALSE dentro de predict() nas etapas posteriores. Se nós quiséssemos utilizar a opção de simular, então precisaríamos excluir esses campos em branco, e salvar um novo conjunto de dados ao adicionar drop_na(t2m_lag4) ao código abaixo. \n\ncounts &lt;- counts %&gt;% \n  ## crie uma nova variável para temperatura com lag de quatro semanas\n  mutate(t2m_lag4 = lag(t2m, n = 4))\n\n\n\n\nBinominal negativa com duas variáveis\nNós ajustamos uma regressão binominal negativa como feito anteriormente. Desta vez, adicionamos a variável temperatura com uma defasagem de tempo (lag) de quatro semanas.\nCUIDADO: Observe o uso do argumento simulate_pi = FALSE dentro da função predict(). Isto se deve porque o comportamento padrão de trending é usar o pacote ciTools para estimar um intervalo de predição. Isto não funciona se existirem contagen NA, e também produz intervalos mais granulares. Veja ?trending::predict.trending_model_fit para mais detalhes. \n\n## defina o modelo que você quer ajustar (binominal negativa)\nmodel &lt;- glm_nb_model(\n  ## ajuste o número de casos como resultado de interesse\n  case_int ~\n    ## use epiweek para levar em conta a tendência\n    epiweek +\n    ## use os termos fourier para levar em conta a sazonalidade\n    fourier + \n    ## use a temperatura com lag de quatro semanas\n    t2m_lag4\n    )\n\n## ajuste seu modelo utilizando os dados de contagem\nfitted_model &lt;- trending::fit(model, counts)\n\n## calcule os intervalos de confiança e de predição\nobserved &lt;- predict(fitted_model, simulate_pi = FALSE)\n\nPara investigar os termos individual, nós podemos retomar a regressão binominal negativa original do formato trending utilizando a função get_model() e aplica-la na função tidy() function do pacote broom para obter estimativas exponencializadas e intervalos de confiança associados.\nO que isso nos mostra é que a temperatura defasada, depois de controlar o modelo para tendência e sazonalidade, é similar a contagem dos casos (estimativa ~ 1) e significativamente associada com os casos. Isto sugere que esta possa ser uma boa variável para prever a quantidade de casos futura (conforme a previsão do tempo é disponibilizada).\n\nfitted_model %&gt;% \n  ## extraia a regressão negativa binominal original\n  get_fitted_model() #%&gt;% \n\n[[1]]\n\nCall:  glm.nb(formula = case_int ~ epiweek + fourier + t2m_lag4, data = counts, \n    init.theta = 32.80689607, link = log)\n\nCoefficients:\n (Intercept)       epiweek  fourierS1-52  fourierC1-52      t2m_lag4  \n   5.825e+00     8.464e-05    -2.850e-01    -1.954e-01     6.672e-03  \n\nDegrees of Freedom: 504 Total (i.e. Null);  500 Residual\n  (4 observations deleted due to missingness)\nNull Deviance:      2015 \nResidual Deviance: 508.2    AIC: 6784\n\n  ## obtenha um quadro de dados organizado dos resultados\n  # tidy(exponentiate = TRUE, \n  #      conf.int = TRUE)\n\nUm inspeção visual rápida do modelo mostra que ele pode fazer um trabalho melhor em estimar a quantidade de casos observada.\n\nestimate_res &lt;- data.frame(observed$result)\n\n## faça um gráfico da sua regressão\nggplot(data = estimate_res, aes(x = epiweek)) + \n  ## adicione uma linha com a estimativa do modelo\n  geom_line(aes(y = estimate),\n            col = \"Red\") + \n  ## adicione uma faixa sombreada dos intervalos de predição\n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## adicione uma linha com a quantidade de casos observada\n  geom_line(aes(y = case_int), \n            col = \"black\") + \n  ## faça uma gráfico tradicional (com eixos pretos e fundo branco)\n  theme_classic()\n\n\n\n\n\n\n\n\n\nResíduos\nAqui, novamente avaliaremos os resíduos para ver o quão bem o nosso modelo se ajusta aos dados observados. Os resultados e a interpretação são similares àqueles da regressão anterior, então pode ser mais viável continuar com o modelo mais simples, sem a temperatura.\n\n## calcule os resíduos\nestimate_res &lt;- estimate_res %&gt;% \n  mutate(resid = case_int - estimate)\n\n## os resíduos são razoavelmente constantes ao longo do tempo (caso não: surtos? mudanças na prática?)\nestimate_res %&gt;%\n  ggplot(aes(x = epiweek, y = resid)) +\n  geom_line() +\n  geom_point() + \n  labs(x = \"epiweek\", y = \"Residuals\")\n\n\n\n\n\n\n\n## existe uma autocorrelação nos resíduos (existe um padrão para o erro?)\nestimate_res %&gt;% \n  as_tsibble(index = epiweek) %&gt;% \n  ACF(resid, lag_max = 52) %&gt;% \n  autoplot()\n\n\n\n\n\n\n\n## os resíduos são normalmente distribuídos (estão sub ou super estimando?)?\nestimate_res %&gt;%\n  ggplot(aes(x = resid)) +\n  geom_histogram(binwidth = 100) +\n  geom_rug() +\n  labs(y = \"count\") \n\n\n\n\n\n\n\n## compare as contagens observadas com os seus resíduos\n  ## também não deve haver padrão\nestimate_res %&gt;%\n  ggplot(aes(x = estimate, y = resid)) +\n  geom_point() +\n  labs(x = \"Fitted\", y = \"Residuals\")\n\n\n\n\n\n\n\n## formalmente avalie a autocorrelação dos resíduos\n## H0 é que os resíduos são uma série de ruídos brancos (i.e.: aleatórios)\n## teste de independência\n## se o p-valor for signficativo, então os resíduos não são aleatórios\nBox.test(estimate_res$resid, type = \"Ljung-Box\")\n\n\n    Box-Ljung test\n\ndata:  estimate_res$resid\nX-squared = 339.52, df = 1, p-value &lt; 2.2e-16",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Séries temporais e detecção de surtos</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.pt.html#detecção-de-surtos",
    "href": "new_pages/time_series.pt.html#detecção-de-surtos",
    "title": "23  Séries temporais e detecção de surtos",
    "section": "23.7 Detecção de surtos",
    "text": "23.7 Detecção de surtos\nAqui, nós iremos demonstrar dois métodos similares para detecção de surtos. O primeiro tem como base as seções acima. Nós usamos o pacote trending para ajustar regressões para os anos anteriores, e então predizer o que esperar para o próximo ano. Se as contagens observadas estão acima do esperado, é possível que exista um surto. O segundo método é baseado em princípios similares, mas utiliza o pacote surveillance, que possui uma variedade de algoritmos diferentes para detecção de anomalias.\nCUIDADO: Normalmente, você tem interesse no ano corrente (onde você apenas conhece contagens até a semana atual). Então, neste exemplo, nós fingiremos estar na semana 39 de 2011.\n\n\nPacote trending\nPara este método, nós definimos uma base de referência (usualmente 5 anos de dados). Nós ajustamos uma regressão com esses dados, e então usamos isto para prever as estimativas para o próximo ano.\n\n\nData limite\nÉ mais fácil definir suas datas em um local, e então utiliza-las no resto do seu código.\nAqui, nós definimos uma data de início (quando suas observações começaram) e uma data limite (o final do seu período de referência - e quando o período que nós queremos prever começa). ~Nós também definimos quantas semanas estão no nosso ano de interesse (o ano que iremos fazer previsões)~. E também definimos quantas semanas estão entre o limite do nosso período de referência, e a data final que estamos interessados em fazer previsões.\nNOTA: Neste exemplo, nós fingimos estar no final de setembro de 2011 (“2011 W39”).\n\n## defina data de início (quando as observações foram iniciadas)\nstart_date &lt;- min(counts$epiweek)\n\n## defina uma semana limite (final do período de referência, início do período de previsão)\ncut_off &lt;- yearweek(\"2010-12-31\")\n\n## defina a última data de interesse (i.e.: final da previsão)\nend_date &lt;- yearweek(\"2011-12-31\")\n\n## encontre quantas semanas no período (ano) de interesse\nnum_weeks &lt;- as.numeric(end_date - cut_off)\n\n\n\n\nAdicione linhas\nPara ser capaz de prever no formato tidyverse, nós precisamos ter o número correto de linhas em nosso banco de dados, i.e.: uma linha para cada semana até a data final (end_date) definida acima. O código abaixo permite adicionar essas linhas de acordo com uma variável de agrupamento - por exemplo, se nós tivéssemos múltiplos países em um conjunto de dados, poderíamos agrupar por país e então adicionar linhas apropriadas para cada um. A função group_by_key(), do pacote tsibble, nos permite fazer esse agrupamento e então passar os dados agrupados para as funções do dplyr, group_modify() e add_row(). Então, nós especificamos a sequência de semanas entre a primeira e a última semana atualmente disponíveis nos dados e a semana final.\n\n## adicione semanas em branco até o final do ano\ncounts &lt;- counts %&gt;%\n  ## agrupe por região\n  group_by_key() %&gt;%\n  ## para cada grupo, adicione linhas da maior semana epidemiológica até o final do ano\n  group_modify(~add_row(.,\n                        epiweek = seq(max(.$epiweek) + 1, \n                                      end_date,\n                                      by = 1)))\n\n\n\n\nTermos de Fourier\nNós precisamos redefinir nossos termos de fourier - uma vez que queremos ajustá-los apenas ao período de referência, e então prever (extrapolar) esses termos para o próximo ano. Para fazer isso, nós precisamos combinar duas listas geradas da função fourier(); a primeira se trata dos dados que são a base de referência, e a segunda a previsão para o ano de interesse (ao definir o argumento h).\nN.b. para unir linhas, nós temos que usar rbind() (em vez da função bind_rows do tidyverse) pois as colunas fourier estão em forma de lista (logo, não são nomeadas individualmente).\n\n## defina os termos de fourier (senos e cosenos) \ncounts &lt;- counts %&gt;% \n  mutate(\n    ## combine os termos de fourier para semanas antes e após a data limite de 2010\n    ## (termos de fourier para 2011 e antes são estimados)\n    fourier = rbind(\n      ## obtenha termos de fourier dos anos anteriores\n      fourier(\n        ## mantenha apenas as linhas anteriores à 2011\n        filter(counts, \n               epiweek &lt;= cut_off), \n        ## inclua um conjunto de termos seno e coseno\n        K = 1\n        ), \n      ## preveja os termos de fourier para 2011 (utilizando os dados base de referência)\n      fourier(\n        ## mantenha apenas as linhas que estejam dentro do período de interesse\n        filter(counts, \n               epiweek &lt;= cut_off),\n        ## inclua um conjunto de termos seno e coseno\n        K = 1, \n        ## preveja as 52 semanas seguintes\n        h = num_weeks\n        )\n      )\n    )\n\n\n\n\nDivida os dados e ajuste a regressão\nAgora nós precisamos dividir o nosso banco de dados entre o período de referência e o período a ser previsto. Isto é feito utilizando a função group_split() do pacote dplyr, após utilizar group_by(), e irá criar uma lista com dois conjuntos de dados, um para antes do período da previsão, e outro com esse período.\nEntão nós utilizamos a função pluck() do pacote purrr, para extrair o conjunto de dados da lista (equivalente de utilizar os colchetes quadrados, ex.: dat[[1]]), e então ajustar o nosso modelo para os dados de referência, e então aplicar a função predict() para as nossas datas de interesse após a data limite do período de referência.\nVeja a página sobre Iteração, loops, e listas para aprender mais sobre o pacote purrr.\nCUIDADO: Observe o uso do argumento simulate_pi = FALSE dentro de predict(). Isto é porque o comportamento padrão de trending é utilizar o pacote ciTools para estimar o intervalo de previsão. Entretanto, isto não funciona se existirem contagens de NA, além de produzir mais intervalos granulares. Veja ?trending::predict.trending_model_fit para mais detalhes. \n\n# divida os dados para ajustes e previsões\ndat &lt;- counts %&gt;% \n  group_by(epiweek &lt;= cut_off) %&gt;%\n  group_split()\n\n## defina o modelo que você quer ajustar (binominal negativo)\nmodel &lt;- glm_nb_model(\n  ## ajuste o número de casos como resultado de interesse da análise\n  case_int ~\n    ## use as semanas epidemiológicas ('epiweek') para considerar a tendência\n    epiweek +\n    ## use os termos de fourier para considerar a sazonalidade\n    fourier\n)\n\n# defina quais dados utilizar para ajustar o modelo e quais para predizer\nfitting_data &lt;- pluck(dat, 2)\npred_data &lt;- pluck(dat, 1) %&gt;% \n  select(case_int, epiweek, fourier)\n\n# ajuste o modelo\nfitted_model &lt;- trending::fit(model, fitting_data)\n\n# obtenha os intervalos de confiança e estimativas para os dados ajustados\nobserved &lt;- fitted_model %&gt;% \n  predict(simulate_pi = FALSE)\n\n# faça as previsões com os dados a serem preditos\nforecasts &lt;- fitted_model %&gt;% \n  predict(pred_data, simulate_pi = FALSE)\n\n## combine os bancos de dados de referência e os dados preditos\nobserved &lt;- bind_rows(observed$result, forecasts$result)\n\nComo anteriormente, nós podemos visualizar nosso modelo com o ggplot. Nós destacamos os alertas de surtos com pontos vermelhos, para contagens observadas acima de 95% do intervalo de predição. Desta vez, nós também adicionamos uma linha vertical para indicar onde o período de previsão começa.\n\n## faça gráficos da sua regressão\nggplot(data = observed, aes(x = epiweek)) + \n  ## adicione uma linha para as estimativas do modelo\n  geom_line(aes(y = estimate),\n            col = \"grey\") + \n  ## adicione uma faixa sombreada com os intervalos de predição\n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## adiciona uma linha para os as contagens de caso observadas\n  geom_line(aes(y = case_int), \n            col = \"black\") + \n  ## crie pontos para as contagens observadas acima do esperado\n  geom_point(\n    data = filter(observed, case_int &gt; upper_pi), \n    aes(y = case_int), \n    colour = \"red\", \n    size = 2) + \n  ## adicione linha vertical e a nomeie para indicar onde a previsão dos casos começou \n  geom_vline(\n           xintercept = as.Date(cut_off), \n           linetype = \"dashed\") + \n  annotate(geom = \"text\", \n           label = \"Forecast\", \n           x = cut_off, \n           y = max(observed$upper_pi) - 250, \n           angle = 90, \n           vjust = 1\n           ) + \n  ## crie um gráfico tradicional (com eixos pretos e fundo branco)\n  theme_classic()\n\nWarning: Removed 13 rows containing missing values or values outside the scale range\n(`geom_line()`).\n\n\n\n\n\n\n\n\n\n\n\n\nValidando a previsão do número de casos\nAlém de inspecionar os resíduos, é importante investigar o quão bom o seu modelo é em prever casos no futuro. Isto te dá uma ideia sobre o quão fidedignos os seus patamares para alertas são.\nA forma tradicional de validar é verificar quão bem você consegue prever o último ano antes do ano atual (porque você ainda desconhece as contagens para o “ano corrente”). Por exemplo, em nosso conjunto de dados, nós iríamos utilizar os dados de 2002 a 2009 para prever 2010, e então ver o quão acuradas estas previsões são. A partir disto, reajustar o modelo para incluir dados de 2010 e usar para prever as contagens de 2011.\nComo pode ser visto na figura abaixo, de Hyndman et al em “Princípios e práticas de previsão” .\n figura reproduzida com permissão dos autores\nO ponto negativo desta abordagem é que você não está utilizando todos os dados disponíveis, além de não ser o modelo final o utilizado para realizar as previsões.\nUma alternativa é utilizar um método chamado de validação cruzada. Neste cenário, você passa por todos os dados disponíveis para ajustar diferentes modelos para prever um ano à frente. Você utiliza mais e mais dados em cada modelo, como visto na figura abaixo do mesmo [texto de Hyndman et al]((https://otexts.com/fpp3/). Por exemplo, o primeiro modelo utiliza dados de 2002 para prever 2003, o segundo usa dados de 2002 e 2003 para prever 2004, e assim por diante.  figura reproduzida com permissão dos autores\nAbaixo, nós utilizamos a função map() do pacote purrr para passar por cada conjunto de dados. Nós então colocamos estimativas em um banco de dados, e unimos com o número de casos original, para utilizar o pacote yardstick para calcular medidas de acurácia. Nós calculamos quatro medidas, incluindo: We compute four measures including: erro quadrático médio (RMSE, do inglês Root mean squared error), erro médio absoluto\n(MAE), erro médio absoluto em escala (MASE), erro médio percentual absoluto (MAPE).\nCUIDADO: observe o uso do argumento simulate_pi = FALSE dentro de predict(). Isto é porque o comportamento padrão de trending é utilizar o pacote ciTools para estimar um intervalo de previsão. Isto não funciona caso existam contagens de NA, e também produz mais intervalos granulares. Veja ?trending::predict.trending_model_fit para detalhes. \n\n## Validação cruzada: prevendo semana(s) à frente baseado na técnica da janela deslizante\n\n## expanda seus dados, trabalhando com janelas de 52 semanas (antes + depois)\n## para predizer as 52 semanas seguintes\n## (cria correntes de observação mais e mais longas - mantém dados antigos)\n\n## defina o tamanho da janela a ser trabalhada\nroll_window &lt;- 52\n\n## define weeks ahead want to predict \nweeks_ahead &lt;- 52\n\n## crie um conjunto de dados com dados repetindo e aumentando\n## nomeie cada conjunto de dados com um id único\n## utilize apenas os casos antes do ano de interesse (i.e.: 2011)\ncase_roll &lt;- counts %&gt;% \n  filter(epiweek &lt; cut_off) %&gt;% \n  ## mantenha apenas as variáveis de semana e quantidade de casos\n  select(epiweek, case_int) %&gt;% \n    ## exclua as últimas x observações\n    ## dependendo quantas semanas à frente estão sendo previstas\n    ## (do contrário será uma previsão real para \"desconhecida\")\n    slice(1:(n() - weeks_ahead)) %&gt;%\n    as_tsibble(index = epiweek) %&gt;% \n    ## role por cada semana após x janelas para para criar um ID de agrupamento\n    ## de acordo com qual janela rolante especificar\n    stretch_tsibble(.init = roll_window, .step = 1) %&gt;% \n  ## exclua a primeira dupla - pois não existem casos \"antes\"\n  filter(.id &gt; roll_window)\n\n\n## para cada um dos conjuntos de dados, execute o código abaixo\nforecasts &lt;- purrr::map(unique(case_roll$.id), \n                        function(i) {\n  \n  ## mantenha apenas a janela atual sendo ajustada no modelo\n  mini_data &lt;- filter(case_roll, .id == i) %&gt;% \n    as_tibble()\n  \n  ## crie um conjunto de dados vazio para fazer as previsões\n  forecast_data &lt;- tibble(\n    epiweek = seq(max(mini_data$epiweek) + 1,\n                  max(mini_data$epiweek) + weeks_ahead,\n                  by = 1),\n    case_int = rep.int(NA, weeks_ahead),\n    .id = rep.int(i, weeks_ahead)\n  )\n  \n  ## adicione os dados previstos aos originais\n  mini_data &lt;- bind_rows(mini_data, forecast_data)\n  \n  ## defina o limite de corte baseado nos últimos dados de contagem, com exceção dos dados em branco\n  cv_cut_off &lt;- mini_data %&gt;% \n    ## mantenha apenas as linhas sem campos em branco\n    drop_na(case_int) %&gt;% \n    ## obtenha a última semana\n    summarise(max(epiweek)) %&gt;% \n    ## extraia os dados de forma que não estejam como quadro de dados\n    pull()\n  \n  ## crie a variável mini_data de volta como um tsibble\n  mini_data &lt;- tsibble(mini_data, index = epiweek)\n  \n  ## defina os termos de fourier (sincos) \n  mini_data &lt;- mini_data %&gt;% \n    mutate(\n    ## combine os termos de fourier para semanas antes e após a data limite\n    fourier = rbind(\n      ## obtenha termos de fourier para anos anteriores\n      forecast::fourier(\n        ## matenha as linhas até a data limite\n        filter(mini_data, \n               epiweek &lt;= cv_cut_off), \n        ## inclua um conjunto de termos seno e coseno\n        K = 1\n        ), \n      ## preveja os termos courier para o ano seguinte (utilizando os dados base de referências)\n      fourier(\n        ## matenha apenas as linhas antes da data limite\n        filter(mini_data, \n               epiweek &lt;= cv_cut_off),\n        ## inclua um conjunto de termos seno e coseno\n        K = 1, \n        ## preveja as 52 semanas à frente\n        h = weeks_ahead\n        )\n      )\n    )\n  \n  \n  # divida os dados para ajustar e prever\n  dat &lt;- mini_data %&gt;% \n    group_by(epiweek &lt;= cv_cut_off) %&gt;%\n    group_split()\n\n  ## defina o modelo que você quer ajustar (negativo binominal)\n  model &lt;- glm_nb_model(\n    ## ajuste o número de casos como resultado de interesse\n    case_int ~\n      ## utilize a epiweek para levar em consideração a tendência\n      epiweek +\n      ## utilize os termos furier para levar em consideração a sazonalidade\n      fourier\n  )\n\n  # defina quais dados utilizar para ajustar e quais para prever\n  fitting_data &lt;- pluck(dat, 2)\n  pred_data &lt;- pluck(dat, 1)\n  \n  # ajuste o modelo\n  fitted_model &lt;- trending::fit(model, fitting_data)\n  \n  # prejeva com os dados que você quer utilizar para prever\n  forecasts &lt;- fitted_model %&gt;% \n    predict(pred_data, simulate_pi = FALSE) \n  forecasts &lt;- data.frame(forecasts$result[[1]]) %&gt;% \n    ## mantenha apenas a semana e os dados estimados\n    select(epiweek, estimate)\n    \n  }\n  )\n\n## transforme a lista gerada em um quadro de dados com todas as estimativas\nforecasts &lt;- bind_rows(forecasts)\n\n## una as previsões com os dados observados\nforecasts &lt;- left_join(forecasts, \n                       select(counts, epiweek, case_int),\n                       by = \"epiweek\")\n\n## utilize {yardstick} para calcular métricas\n  ## RMSE: Erro quadrático médio\n  ## MAE:  Erro médio absoluto\n  ## MASE: Erro médio absoluto escalonado\n  ## MAPE: Erro médio absoluto percentual\nmodel_metrics &lt;- bind_rows(\n  ## no seu conjunto de dados previstos, compare o observado com o estimado\n  rmse(forecasts, case_int, estimate), \n  mae( forecasts, case_int, estimate),\n  mase(forecasts, case_int, estimate),\n  mape(forecasts, case_int, estimate),\n  ) %&gt;% \n  ## mantenha apenas o tipo métrico e o resultado\n  select(Metric  = .metric, \n         Measure = .estimate) %&gt;% \n  ## crie no formato amplo de forma que seja possível unir as linhas posteriormente\n  pivot_wider(names_from = Metric, values_from = Measure)\n\n## retorne as métricas do modelo\nmodel_metrics\n\n# A tibble: 1 × 4\n   rmse   mae  mase  mape\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1  252.  199.  1.96  17.3\n\n\n\n\n\n\nPacote surveillance\nNesta seção, nós utilizamos o pacote surveillance para criar alertas de acordo com limites baseados em algorítmos de detecção de surtos. Existem diferentes métodos disponíveis no pacote. Entretanto, aqui nós iremos focar em duas opções. Para detalhes, veja esses artigos sobre a aplicação e teoria dos algorítmos utilizados.\nA primeira opção utiliza o método Farrington melhorado. Isto ajusta uma glm binominal negativa (incluíndo tendências) e diminui o peso de surtos passados (pontos fora do normal) para criar um nível de limiar.\nA segunda opção utiliza o método glrnb. Isto também ajusta uma glm binominal negativa mas inclui tendências e termos de fourier (então é a favorita aqui). A regressão é utilizada para calcular o “controle médio” (~valores ajustados) - ele então utiliza uma razão estatística generalizada de verosimilhança para avaliar se existe uma mudança na média de cada semana. Observe que o limiar para cada semana leva em conta semanas anteriores, então se as mudanças persistirem, um alarme será ativado. (Adicionalmente, observe que após cada alarme, o algoritmo é reinicilizado)\nPara trabalhar com o pacote surveillance, nós primeiro precisamos definir um objeto de “séries temporais de vigilância” (utilizando a função sts()) para ajustar dentro do quadro.\n\n## defina um objeto de série temporal de vigilância\n## nb. você pode incluir um denominador com o objeto que contém a população (veja ?sts)\ncounts_sts &lt;- sts(observed = counts$case_int[!is.na(counts$case_int)],\n                  start = c(\n                    ## subconjunto para manter apenas o ano da variável start_date\n                    as.numeric(str_sub(start_date, 1, 4)), \n                    ## subconjunto para manter apenas a semana da variável start_date\n                    as.numeric(str_sub(start_date, 7, 8))), \n                  ## defina o tipo/frequência dos dados (neste caso, semanal)\n                  freq = 52)\n\n## defina o intervalo de semanas que você quer incluir (ex.: período de previsão)\n## nb. o objto sts apenas contabiliza observações sem identificar uma semana ou\n## ano a eles - assim, nós utilizamos nossos dados para definir as observações apropriadas\nweekrange &lt;- cut_off - start_date\n\n\n\nMétodo Farrington\nNós então definimos cada um dos nossos parâmetros para o método Farrington em uma list (lista). Então, nós executamos o algoritmo utilizando a função farringtonFlexible() e então podemos extrair o limiar para um alerta utilizando farringtonmethod@upperbound para incluir isto em nosso banco de dados. Também é possível extrair um booleano TRUE/FALSE (VERDADEIRO/FALSO) para cada semana no caso do alerta ter sido ativado (semana com casos acima do limiar) utilizando farringtonmethod@alarm.\n\n## defina o controle\nctrl &lt;- list(\n  ## defina qual período de tempo que quer utilizar o limiar (i.e.: 2011)\n  range = which(counts_sts@epoch &gt; weekrange),\n  b = 9, ## quantos anos anteriores para considerar com os dados de referência\n  w = 2, ## tamanho da janela flutuante em semanas\n  weightsThreshold = 2.58, ## reponderando surtos passados (método melhorado de noufaily - método original sugere 1)\n  ## pastWeeksNotIncluded = 3, ## utilize todas as semanas disponíveis (noufaily suggests drop 26)\n  trend = TRUE,\n  pThresholdTrend = 1, ## 0.05 normalmente, entretanto 1 é recomendado no método melhorado (i.e.: sempre mantenha)\n  thresholdMethod = \"nbPlugin\",\n  populationOffset = TRUE\n  )\n\n## aplique o método flexível de farrington\nfarringtonmethod &lt;- farringtonFlexible(counts_sts, ctrl)\n\n## Crie uma nova variável no conjunto de dados original chamado \"threshold\"\n## contendo o limite superior do farrington \n## nb. isto é apenas para as semanas em 2011 (então é necessário subdividir as linhas)\ncounts[which(counts$epiweek &gt;= cut_off & \n               !is.na(counts$case_int)),\n              \"threshold\"] &lt;- farringtonmethod@upperbound\n\nNós podemos, então, visualizar os resultados no ggplot como feito anteriormente.\n\nggplot(counts, aes(x = epiweek)) + \n  ## adicione as quantidades de casos observada como uma linha\n  geom_line(aes(y = case_int, colour = \"Observed\")) + \n  ## adicione o limite superior do algoritmo de aberrações\n  geom_line(aes(y = threshold, colour = \"Alert threshold\"), \n            linetype = \"dashed\", \n            size = 1.5) +\n  ## defina as cores\n  scale_colour_manual(values = c(\"Observed\" = \"black\", \n                                 \"Alert threshold\" = \"red\")) + \n  ## crie um gráfico tradicional (com eixos pretos e fundo branco)\n  theme_classic() + \n  ## remova o título da legenda\n  theme(legend.title = element_blank())\n\n\n\n\n\n\n\n\n\n\n\nMétodo GLRNB\nDe forma similar, para o método GLRNB nós definimos cada um dos nossos parâmetros para em uma list (lista), então ajuste o algoritmo e extraia os limites superiores.\nCUIDADO: Este método utiliza “força bruta” (similar ao bootstrapping) para calcular os limiares, então pode levar muito tempo!\nVeja o tutorial sobre GLRNB para detalhes.\n\n## defina as opções de controle\nctrl &lt;- list(\n  ## defina qual período de tempo que quer utilizar o limiar (i.e.: 2011)\n  range = which(counts_sts@epoch &gt; weekrange),\n  mu0 = list(S = 1,    ## número de termos de fourier (harmônicos) para incluir\n  trend = TRUE,   ## incluir tendências ou não\n  refit = FALSE), ## reajustar o modelo após cada alarme ou não\n  ## cARL = limiar para estatísticas GLR (arbitrário)\n     ## 3 ~ meio-termo para minimizar os falsos positivos\n     ## 1 ajusta para os 99% de intervalo de previsão do glm.nb - com mudanças após picos (limiar diminuído para alertas)\n   c.ARL = 2,\n   # theta = log(1.5), ## equivale a um aumento de 50% nos casos em um surto\n   ret = \"cases\"     ## retorne os limites superiores como contagem de casos\n  )\n\n## aplique o método glrnb\nglrnbmethod &lt;- glrnb(counts_sts, control = ctrl, verbose = FALSE)\n\n## crie uma nova variável no conjunto de dados original chamada \"threshold\"\n## contendo o limite superior do glrnb \n## nb. isto é apenas para as semanas em 2011 (então é necessário subdividir as linhas)\ncounts[which(counts$epiweek &gt;= cut_off & \n               !is.na(counts$case_int)),\n              \"threshold_glrnb\"] &lt;- glrnbmethod@upperbound\n\nVisualize os resultados das análises como mostrado anteriormente.\n\nggplot(counts, aes(x = epiweek)) + \n  ## adicione as quantidades de casos observadas como uma linha\n  geom_line(aes(y = case_int, colour = \"Observed\")) + \n  ## adicione o limite superior do algoritmo de aberração\n  geom_line(aes(y = threshold_glrnb, colour = \"Alert threshold\"), \n            linetype = \"dashed\", \n            size = 1.5) +\n  ## defina as cores\n  scale_colour_manual(values = c(\"Observed\" = \"black\", \n                                 \"Alert threshold\" = \"red\")) + \n  ## crie um gráfico tradicional (com eixos pretos e fundo branco)\n  theme_classic() + \n  ## remova o título da legenda\n  theme(legend.title = element_blank())",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Séries temporais e detecção de surtos</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.pt.html#séries-temporais-interrompidas",
    "href": "new_pages/time_series.pt.html#séries-temporais-interrompidas",
    "title": "23  Séries temporais e detecção de surtos",
    "section": "23.8 Séries temporais interrompidas",
    "text": "23.8 Séries temporais interrompidas\nSéries temporais interrompidas (também chamadas de regressão segmentada ou análise de intervenção), são usadas frequentemente para avaliar o impacto de vacinas na incidência de doenças. Mas também pode ser utilizada para avaliar o impacto de uma variedade de intervenções ou introduções. Por exemplo, alterações nos procedimentos de um hopital, ou introdução de uma nova doença para a população. Neste exemplo, nós iremos pretender que uma nova cepa de Campylobacter foi introduzida na Alemanha no final de 2008, e ver se isso afeta o número de casos. Iremos utilizar a regressão binominal negativa novamente. Desta vez, a regressão será dividida em duas partes, uma antes da intervenção (ou introdução da nova cepa neste caso) e uma após (os períodos pré e pós intervenção/introdução). Isto nos permite calcular uma razão da taxa de incidência comparando os dois períodos de tempo. Explicar a equação pode clarear isso (se não, somente ignore!).\nA regressão negativa binominal pode ser definida da seguinte forma:\n\\[\\log(Y_t)= β_0 + β_1 \\times t+ β_2 \\times δ(t-t_0) + β_3\\times(t-t_0 )^+ + log(pop_t) + e_t\\]\nOnde: \\(Y_t\\)é o número de casos observado naquele momento \\(t\\)\n\\(pop_t\\) é o tamanho da população em 100,000s naquele momento \\(t\\) (não utilizado aqui)\n\\(t_0\\) é o último ano do pré-período (incluindo o tempo de transição, se existir) \\(δ(x\\) é a função indicadora (será 0 se x≤0 e 1 se x&gt;0)\n\\((x)^+\\) é o operador de corte de acordo com o limite (é x se x&gt;0 e 0 de outra forma)\n\\(e_t\\) denota os resíduos Termos adicionais sobre tendência e sazonalidade podem ser adicionadas conforme necessário.\n\\(β_2 \\times δ(t-t_0) + β_3\\times(t-t_0 )^+\\) é a parte linear generalizada do pós-período e é zero no pré-período. Isto significa que as estimativas \\(β_2\\) e \\(β_3\\) são efeitos da intervenção.\nNós precisamos recalcular os termos de fourier sem realizar a previsão aqui, uma vez que iremos utilizar todos os dados disponíveis para nós (i.e.: retrospectivamente). Adicionalmente, nós precisamos calcular os termos extras necessários para a regressão.\n\n## adicione os termos de fourier utilizando as variáveis epiweek e case_int\ncounts$fourier &lt;- select(counts, epiweek, case_int) %&gt;% \n  as_tsibble(index = epiweek) %&gt;% \n  fourier(K = 1)\n\n## defina a semana de intervenção \nintervention_week &lt;- yearweek(\"2008-12-31\")\n\n## defina as variáveis para a regressão\ncounts &lt;- counts %&gt;% \n  mutate(\n    ## corresponde ao t na fórmula\n      ## contagem das semanas (provavelmente poderia também utilizar diretamente a variável epiweeks (semanas epidemiológicas))\n    # linear = row_number(epiweek), \n    ## corresponde ao delta(t-t0) na fórmula\n      ## período pré ou pós intervenção\n    intervention = as.numeric(epiweek &gt;= intervention_week), \n    ## corresponde a (t-t0)^+ na fórmula\n      ## contagem de semenas após a intervenção\n      ## (escolha o maior número entre 0 e o que resultar do cálculo)\n    time_post = pmax(0, epiweek - intervention_week + 1))\n\nNós então utilizamos estes termos para ajustar uma regressão binominal negativa, e produz uma tabela com a mudança dos percentuais. O que este exemplo mostra é que não existe mudanças significativas.\nCUIDADO: Observe o uso do argumento simulate_pi = FALSE dentro de predict(). Isto ocorre porque o comportamento padrão de trending é utilizar o pacote ciTools para estimar o intervalo de previsão. Isto não funciona se existirem contagens NA, e também produz mais intervalos granulares. Veja ?trending::predict.trending_model_fit para detalhes. \n\n## defina o modelo que você quer ajustar (binominal negativo)\nmodel &lt;- glm_nb_model(\n  ## defina o número de casos como resultado de interesse da análise\n  case_int ~\n    ## utilize a epiweek para levar em consideração a tendência\n    epiweek +\n    ## utilize os termos de fourier para levar em consideração a sazonalidade\n    fourier + \n    ## adicione o clima nos pré- e pós- períodos\n    intervention + \n    ## adicione o tempo após a intervenção\n    time_post\n    )\n\n## ajuste seu modelo utilizando os dados de contagem\nfitted_model &lt;- trending::fit(model, counts)\n\n## calcule os intervalos de confiança e de previsão\nobserved &lt;- predict(fitted_model, simulate_pi = FALSE)\n\n\n## mostre as estimativas e mudanças percentuais em uma tabela\nfitted_model %&gt;% \n  ## extraia a regressão original negativa binominal\n  get_result() %&gt;% \n  \n  ## extrair o primeiro elemento da lista, consequência das alterações de pacotes de tendências.\n  simplify() %&gt;% \n  first() %&gt;% \n  \n  ## obtenha um quadro de dados organizado dos resultados\n  tidy(exponentiate = TRUE, \n       conf.int = TRUE) %&gt;% \n  ## mantenha apenas o valor da intervenção\n  filter(term == \"intervention\") %&gt;% \n  ## altere o IRR para diferença de porcentagem para estimativas e invervalos de confiança (CI)\n  mutate(\n    ## para cada uma das colunas de interesse - crie uma uma nova coluna\n    across(\n      all_of(c(\"estimate\", \"conf.low\", \"conf.high\")), \n      ## aplique a fórmula para calcular a mudança de porcentagem\n            .f = function(i) 100 * (i - 1), \n      ## adicione ao nome das novas colunas o sufixo \"_perc\"\n      .names = \"{.col}_perc\")\n    ) %&gt;% \n  ## apenas mantenha (e renomeie) certas colunas\n  select(\"IRR\" = estimate, \n         \"95%CI low\" = conf.low, \n         \"95%CI high\" = conf.high,\n         \"Percentage change\" = estimate_perc, \n         \"95%CI low (perc)\" = conf.low_perc, \n         \"95%CI high (perc)\" = conf.high_perc,\n         \"p-value\" = p.value)\n\nComo anteriormente, nós podemos visualizar os resultados da regressão.\n\nestimate_res &lt;- data.frame(observed$result)\n\nggplot(estimate_res, aes(x = epiweek)) + \n  ## adicione as quantidades de casos observadas como uma linha\n  geom_line(aes(y = case_int, colour = \"Observed\")) + \n  ## adicione uma linha para a estimativa do modelo\n  geom_line(aes(y = estimate, col = \"Estimate\")) + \n  ## adicione uma banda para os intervalos de previsão\n  geom_ribbon(aes(ymin = lower_pi, \n                  ymax = upper_pi), \n              alpha = 0.25) + \n  ## adicione uma linha vertical e uma etiqueta para mostrar onde a previsão começou\n  geom_vline(\n           xintercept = as.Date(intervention_week), \n           linetype = \"dashed\") + \n  annotate(geom = \"text\", \n           label = \"Intervention\", \n           x = intervention_week, \n           y = max(observed$upper_pi), \n           angle = 90, \n           vjust = 1\n           ) + \n  ## defina as cores\n  scale_colour_manual(values = c(\"Observed\" = \"black\", \n                                 \"Estimate\" = \"red\")) + \n  ## faça um gráfico tradicional (com eixos pretos e fundo branco)\n  theme_classic()\n\nWarning: Unknown or uninitialised column: `upper_pi`.\n\n\nWarning in max(observed$upper_pi): no non-missing arguments to max; returning\n-Inf",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Séries temporais e detecção de surtos</span>"
    ]
  },
  {
    "objectID": "new_pages/time_series.pt.html#recursos",
    "href": "new_pages/time_series.pt.html#recursos",
    "title": "23  Séries temporais e detecção de surtos",
    "section": "23.9 Recursos",
    "text": "23.9 Recursos\nprevisões: texto sobre princípios e práticas\nEstudos de caso EPIET sobre séries temporais\nCurso da Penn State Artigo sobre o pacote surveillance",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Séries temporais e detecção de surtos</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.pt.html",
    "href": "new_pages/epidemic_models.pt.html",
    "title": "24  Modelagem de epidemias",
    "section": "",
    "text": "24.1 Visão geral do tópico\nExiste um conjunto crescente de ferramentas para modelagem em epidemiologia que nos permite desenvolver análises complexas com esforço mínimo. Este capítulo apresenta uma síntese sobre como usar essas ferramentas para:\nTenha em mente que esta página não é uma revisão das metodologias e métodos estatísticos empregados por estas ferramentas. Para tanto, utilize os links disponíveis no subtópico Recursos extras para encontrar artigos detalhando essas metodologias. Antes de utilizar as ferramentas a seguir, garanta que você compreenda os métodos subjacentes empregados; isto garantirá que você possa interpretar adequadamente os resultados.\nAbaixo está um exemplo de uma das análises que construíremos neste capítulo.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Modelagem de epidemias</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.pt.html#visão-geral-do-tópico",
    "href": "new_pages/epidemic_models.pt.html#visão-geral-do-tópico",
    "title": "24  Modelagem de epidemias",
    "section": "",
    "text": "estimar o número efetivo de reprodução Rt e estatísticas relacionadas como tempo de duplicação\nproduzir projeções de curto prazo da incidência futura",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Modelagem de epidemias</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.pt.html#preparação",
    "href": "new_pages/epidemic_models.pt.html#preparação",
    "title": "24  Modelagem de epidemias",
    "section": "24.2 Preparação",
    "text": "24.2 Preparação\nIremos utilizar dois métodos e pacotes diferentes para estimar o Rt, chamados de EpiNow e EpiEstim, assim como o pacote projections para fazer previsões da incidência de casos.\nEste pedaço de código mostra o carregamento dos pacotes necessários para as análises. Neste manual, enfatizamos o uso de p_load(), do pacote pacman, que instala o pacote, caso necessário, e o inicia para uso. Você também pode carregar pacotes instalados com library(), do R base. Veja a página sobre Introdução ao R para mais informações sobre pacotes no R.\n\npacman::p_load(\n   rio,          # Importar arquivos\n   here,         # Localizar arquivos\n   tidyverse,    # Gerenciamento dos dados + gráficos ggplot2\n   epicontacts,  # Analisar as redes de transmissão\n   EpiNow2,      # Estimar o Rt\n   EpiEstim,     # Estimar Rt\n   projections,  # Projeções da incidência\n   incidence2,   # Trabalhando com dados de incidência\n   epitrix,      # Funções uteis de epi\n   distcrete     # Distribuições discretas .;\n)\n\nNesta seção, iremos utilizar a linelist dos casos limpa para todas as análises. Se você quiser acomapnhar, clique para baixar a linelist “limpa” (como arquivo .rds). Veja a página Download do manual e dados para baixar todos os dados utilizados como exemplo neste manual.\n\n# importe a linelist limpa\nlinelist &lt;- import(\"linelist_cleaned.rds\")",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Modelagem de epidemias</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.pt.html#estimando-o-rt",
    "href": "new_pages/epidemic_models.pt.html#estimando-o-rt",
    "title": "24  Modelagem de epidemias",
    "section": "24.3 Estimando o Rt",
    "text": "24.3 Estimando o Rt\n\nEpiNow2 vs. EpiEstim\nO número de reprodução R é uma medida da capacidade de transmissão de uma doença e é definido como a quantidade esperada de casos secundários para cada caso infectado. Em uma população totalmente susceptível, este valor representa o número básico de reprodução R0. Entretanto, conforme o número de indivíduos susceptíveis em uma população muda no decorrer de um surto ou pandemia, e conforme várias medidas de resposta e controle são implementadas, a medida mais comumente utilizada de transmissibilidade é o número efetivo de reprodução Rt; este é definido como a quantidade de casos secundários por cada caso infectado em um determinando ponto no tempo t.\nO pacote EpiNow2 fornece a estrutura mais sofisticada para estimar o Rt. Ele tem duas vantagens chave sobre o outro pacote comumente utilizado, EpiEstim:\n\nEle leva em consideração as demoras nas notificações ao estimar o Rt, mesmo quando dados recentes são incompletos.\nEle estima o Rt a partir das datas de infecção, em vez das datas de início das notificações, o que significa que o efeito de uma intervenção irá imediatamente refletir em mudanças no Rt, em vez de demorar para alterar.\n\nEntretanto, ele também possuí duas desvantagens chave:\n\nEle necessita de conhecimento da distribuição do tempo de geração (ex.: distribuição dos intervalos de infecção entre casos primários e secundários), distribuição do tempo de incubação (ex.: distribuição dos intervalos entre a infecção e o início dos sintomas) e qualquer outra distribuição de intervalos relevante para os seus dados (ex.: se você tiver datas de notificação, você precisa da distribuição dos intervalos entre início dos sintomas e notificação dos casos). Enquanto isto irá permitir estimativas mais acuradas do Rt, EpiEstim apenas requer a distribuição seriada dos intervalos (ex.: a distribuição de intervalos entre o início dos sintomas de casos primários e secundários), que pode ser a única distribuição disponível para você.\nEpiNow2 é significamente mais devagar do que EpiEstim, por fatores entre 100-1000 mais lento! Por exemplo, estimar o Rt para a amostra do surto trabalhada nesta seção levou por volta de quatro horas (esta estimativa rodou por um elevado número de iterações para garantir elevada acurácia, e provavelmente poderia ser reduzida caso necessário. Entretanto, o ponto é que este algoritmo é mais devagar, no geral). Logo, este pacote pode ser inviável caso você esteja atualizando regularmente suas estimativas do Rt.\n\nQual pacote você irá escolher irá depender dos seus dados, tempo e recursos computacionais disponíveis.\n\n\nEpiNow2\n\nEstimando a distribuição dos intervalos\nAs distribuições dos intervalos necessárias para utilizar o EpiNow2 variam de acordo com os seus dados. Essencialmente, você precisar ser capaz de descrever o intervalo entre a data de infecção e a data do evento que você quer utilizar para estimar o Rt. Caso você esteha utilizando as datas de início dos sintomas, isto seria simplesmente a distribuição do período de incubação. Se você estiver utilizando as datas de notificação, você utiliza o intervalo entre infecção à notificação. Como é improvável que esta distribuição seja conhecida diretamente, EpiNow2 permite conectar múltiplas distribuições de intervalo; neste caso, os intervalos entre a infecção e o aparecimento dos sintomas (ex.: o período de incubação, que provavelmente é conhecido) e entre o início dos sintomas e a notificação (que você pode frequentemente estimar a partir dos seus dados).\nComo temos as datas de início dos sintomas para todos os nossos casos em nossa linelist de exemplo, nós apenas precisamos da distribuição do período de incubação para conectar os nossos dados (ex.: datas de início dos sintomas) para a data de infecção. Nós podemos ou estimar esta distribuição a partir dos dados, ou utilizar valores da literatura.\nUma estimativa do período de incubação da Ebola encontrada na literatura (obtida deste artigo) possuí uma média de 9.1, desvio padrão de 7.3, e o valor máximo de 30. Isto pode ser especificado no R como mostrado a seguir:\n\nincubation_period_lit &lt;- list(\n  mean = log(9.1),\n  mean_sd = log(0.1),\n  sd = log(7.3),\n  sd_sd = log(0.1),\n  max = 30\n)\n\nObserve que o EpiNow2 pede que a distribuição destes intervalos seja fornecida em uma escala log (logarítmica), por isso chamamos log ao redor de cada valor (exceto o parâmetro max que, de forma confusa, precisa ser fornecido em uma escala natural). Os mean_sd e sd_sd definem o desvio padrão da média e as estimativas do desvio padrão. Como neste caso estes valores não são conhecidos, nós escolhemos um valor bastante arbitrário, 0.1.\nNesta análise, nós estimamos a distribuição do período de incubação a partir da própria linelist utilizando a função bootstrapped_dist_fit, que irá ajustar uma distribuição log-normal para os intervalos observados entre a infecção e o aparecimento dos sintomas na linelist.\n\n## estime o período de incubação\nincubation_period &lt;- bootstrapped_dist_fit(\n  linelist$date_onset - linelist$date_infection,\n  dist = \"lognormal\",\n  max_value = 100,\n  bootstraps = 1\n)\n\nA outra distribuição que precisamos é o tempo de geração. Como temos dados sober os tempos de infecção and os links de transmissão, nós podemos estimar esta distribuição a partir da linelist ao calcular o intervalo entre o tempo de infecção de pares infectores-infectados. Para fazer isto, nós utilizamos a função get_pairwise do pacote epicontacts, que nos permite calcular diferenças entre os pares a partir das propriedades da linelist sobre os pares de transmissão. Nós primeiro criamos um objeto epicontact (veja a página Cadeias de transmissão para mais detalhes):\n\n## gere o objeto contatos\ncontacts &lt;- linelist %&gt;%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %&gt;%\n  drop_na()\n\n## gere o objeto epicontact\nepic &lt;- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n\nEntão, ajustamos a diferença no tempo de incubação entre os pares da transmissão, calculado com get_pairwise, em uma distribuição gamma:\n\n## estime o tempo de geração gamma\ngeneration_time &lt;- bootstrapped_dist_fit(\n  get_pairwise(epic, \"date_infection\"),\n  dist = \"gamma\",\n  max_value = 20,\n  bootstraps = 1\n)\n\n\n\nExecutando o EpiNow2\nAgora nós só precisamos calcular a incidência diária a partir da linelist, que podemos fazer facilmente com as funções group_by() e n(), do dplyr. Note que o EpiNow2 requer que os nomes das colunas sejam date e confirm.\n\n## obtenha a incidência a partir da data de início dos sintomas\ncases &lt;- linelist %&gt;%\n  group_by(date = date_onset) %&gt;%\n  summarise(confirm = n())\n\nPodemos, então, estimar o Rt utilizando a função epinow. Algumas notas sobre os dados usados:\n\nNós podemos fornecer qualquer quantidade de distribuições de intervalos ‘encadeados’ para o argumento delays; simplesmente iríamos inserí-los junto com o objeto incubation_period dentro da função delay_opts.\nreturn_output garante que o resultado da análise é obtido dentro do R, e não apenas salvo em um arquivo.\nverbose especifica que queremos uma leitura/update do progresso.\nhorizon indica em quantos dias queremos estimar a incidência futura.\nNós adicionamos outras opções no argumento stan para especificar por quanto tempo queremos executar a inferência. Aumentar o samples e chains irá te dar uma estimativa mais precisa que melhor caracteriza a incerteza, entretanto irá demorar mais para ser calculada.\n\n\n## execute o epinow\nepinow_res &lt;- epinow(\n  reported_cases = cases,\n  generation_time = generation_time,\n  delays = delay_opts(incubation_period),\n  return_output = TRUE,\n  verbose = TRUE,\n  horizon = 21,\n  stan = stan_opts(samples = 750, chains = 4)\n)\n\n\n\nAnalisando o resultado da análise\nAssim que o código terminar de ser executado, nós podemos criar um resumo da análise facilmente, da seguinte maneira. Role a imagem para ver a sua real extensão.\n\n## faça uma figura do sumário da análise\nplot(epinow_res)\n\n\n\n\n\n\n\n\nNós também podemos olher diferentes resumos estatísticos:\n\n## tabela resumo\nepinow_res$summary\n\n                                 measure                  estimate\n                                  &lt;char&gt;                    &lt;char&gt;\n1: New confirmed cases by infection date                4 (2 -- 6)\n2:        Expected change in daily cases                    Unsure\n3:            Effective reproduction no.        0.88 (0.73 -- 1.1)\n4:                        Rate of growth -0.012 (-0.028 -- 0.0052)\n5:          Doubling/halving time (days)          -60 (130 -- -25)\n    numeric_estimate\n              &lt;list&gt;\n1: &lt;data.table[1x9]&gt;\n2:              0.56\n3: &lt;data.table[1x9]&gt;\n4: &lt;data.table[1x9]&gt;\n5: &lt;data.table[1x9]&gt;\n\n\nPara mais análise e customização do gráfico, você pode acessar as estimativas diárias resumidas através de $estimates$summarised. Nós iremos converter isto do padrão data.table para um tibble, facilitando o uso com dplyr.\n\n## extraia o resumo e converta para formato tibble\nestimates &lt;- as_tibble(epinow_res$estimates$summarised)\nestimates\n\n\n\n\n\n\n\nComo um exemplo, vamos criar um gráfico do tempo de duplicação e do Rt. Nós iremos apenas olhar os primeiros meses do surto, quando o Rt está bem acima de um, para evitar traçar tempos de duplicação extremamente elevados.\nNós utilizamos a fórmula log(2)/growth_rate para calcular o tempo de duplicação a partir da taxa de crescimento estimada.\n\n## crie amplas df para um gráfico mediano\ndf_wide &lt;- estimates %&gt;%\n  filter(\n    variable %in% c(\"growth_rate\", \"R\"),\n    date &lt; as.Date(\"2014-09-01\")\n  ) %&gt;%\n  ## converta as taxas de crescimento para o tempo de duplicação\n  mutate(\n    across(\n      c(median, lower_90:upper_90),\n      ~ case_when(\n        variable == \"growth_rate\" ~ log(2)/.x,\n        TRUE ~ .x\n      )\n    ),\n    ## renomeie a variável para refletir na transformação de taxa de crescimento para tempo de duplicação\n    variable = replace(variable, variable == \"growth_rate\", \"doubling_time\")\n  )\n\n## crie um data frame longo para criar gráfico de quantis\ndf_long &lt;- df_wide %&gt;%\n  ## aqui nós combinamos quantis correspondentes (ex.: lower_90 para upper_90)\n  pivot_longer(\n    lower_90:upper_90,\n    names_to = c(\".value\", \"quantile\"),\n    names_pattern = \"(.+)_(.+)\"\n  )\n\n## crie um gráfico\nggplot() +\n  geom_ribbon(\n    data = df_long,\n    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = date, y = median)\n  ) +\n  ## utilize label_parsed para conseguir subscrever o rótulo\n  facet_wrap(\n    ~ variable,\n    ncol = 1,\n    scales = \"free_y\",\n    labeller = as_labeller(c(R = \"R[t]\", doubling_time = \"Doubling~time\"), label_parsed),\n    strip.position = 'left'\n  ) +\n  ## defina manualmente a transparência do quantil\n  scale_alpha_manual(\n    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = NULL,\n    alpha = \"Credibel\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    strip.background = element_blank(),\n    strip.placement = 'outside'\n  )\n\n\n\n\n\n\n\n\n\n\n\n\nEpiEstim\nPara executar EpiEstim, nós precisamos fornecer dados de incidência diária, e especificar o intervalo seriado (i.e.: a distribuição dos intervalos entre o início dos sintomas dos casos primários e secundários).\nDados de incidência podem ser fornecidos para o EpiEstim como um vetor, um quadro de dados, ou um objeto incidence do pacote original incidence. Você consegue até distinguir entre importados e infecções adquiridas localmente; veja a documentação em ?estimate_R para mais detalhes.\nNós iremos criar a entrada de dados usando incidence2. Veja a página sobre Curvas epidêmicas para mais exemplos com o pacote incidence2. Já que existem updates no pacote incidence2 que não fornecem a entrada necessária do estimateR(), existem algumas pequenas etapas adicionais necessárias. O objeto incidence consiste de uma tabela tibble com as datas e as respectivas contagens. Nós usamos complete(), do pacote tidyr, para garantir que todas as datas sejam incluídas (até as datas sem casos), e então rename() as colunas para gerarem o que é esperado pela função estimate_R() em uma etapa posterior.\n\n## obtenha a incidência a partir da data de início dos sintomas\ncases &lt;- incidence2::incidence(linelist, date_index = \"date_onset\") %&gt;% # obtenha a quantidade de casos por dia\n  tidyr::complete(date_index = seq.Date(                              # garanta que todas as datas estão presentes\n    from = min(date_index, na.rm = T),\n    to = max(date_index, na.rm=T),\n    by = \"day\"),\n    fill = list(count = 0)) %&gt;%                                       # converta contagens NA para 0\n  rename(I = count,                                                   # renomeie para os nomes utilizados no estimateR\n         dates = date_index)\n\nO pacote fornece diferentes opções para especificar os intervalos seriados, os detalhes são fornecidos na documentação em ?estimate_R. Nós iremos cobrir duas das opções aqui.\n\nUtilizando estimativas de intervalos seriados da literatura\nAo usar a opção method = \"parametric_si\", podemos especificar manualmente a média e desvio padrão do intervalo seriado em um objeto config criado usando a função make_config. Nós usamos uma média e um desvio padrão de 12.0 e 5.2, respectivamente, definidos neste artigo:\n\n## crie o config\nconfig_lit &lt;- make_config(\n  mean_si = 12.0,\n  std_si = 5.2\n)\n\nEntão, nós podemos estimar o Rt com a função estimate_R:\n\ncases &lt;- cases %&gt;% \n     filter(!is.na(date))\n#create a dataframe for the function estimate_R()\ncases_incidence &lt;- data.frame(dates = seq.Date(from = min(cases$dates),\n                               to = max(cases$dates), \n                               by = 1))\ncases_incidence &lt;- left_join(cases_incidence, cases) %&gt;% \n     select(dates, I) %&gt;% \n     mutate(I = ifelse(is.na(I), 0, I))\n\nJoining with `by = join_by(dates)`\n\nepiestim_res_lit &lt;- estimate_R(\n  incid = cases_incidence,\n  method = \"parametric_si\",\n  config = config_lit\n)\n\nDefault config will estimate R on weekly sliding windows.\n    To change this change the t_start and t_end arguments. \n\n\ne criar um gráfico resumindo os resultados da análise:\n\nplot(epiestim_res_lit)\n\n\n\n\n\n\n\n\n\n\nUtilizando estimativas de intervalos seriados dos dados\nConforme obtemos dados sobre as datas de início dos sintomas and e links de transmissão, nós podemos também estimar o intervalo seriado a partir da linelist ao calcular o intervalo entre as datas de início dos sintomas dos pares infectante-infectado.Como fizemos na seção do EpiNow2, nós iremos agora utilizar a função get_pairwise, do pacote epicontacts, que nos permite calcular as diferenças entre os pares de transmissão nas características na linelsit. Primeiro, criamos um objeto epicontact (veja a página Cadeias de transmissão para mais detalhes):\n\n## gere os contatos\ncontacts &lt;- linelist %&gt;%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %&gt;%\n  drop_na()\n\n## gere um objeto epicontact\nepic &lt;- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n\nEntão ajustamos a diferença entre as datas de início dos sintomas dos pares de transmissão, calculado usando get_pairwise, para uma distribuição gamma. Utilizamos a função fit_disc_gamma, do pacote epitrix, para fazer este procedimento de ajuste, uma vez que precisamos de uma distribuição discreta.\n\n## estime o intervalo seriado gamma\nserial_interval &lt;- fit_disc_gamma(get_pairwise(epic, \"date_onset\"))\n\nEntão aplicamos esta informação no objeto config, executamos o EpiEstim novamente, e criamos um gráfico dos resultados:\n\n## crie o config\nconfig_emp &lt;- make_config(\n  mean_si = serial_interval$mu,\n  std_si = serial_interval$sd\n)\n\n## execute o epiestim\nepiestim_res_emp &lt;- estimate_R(\n  incid = cases_incidence,\n  method = \"parametric_si\",\n  config = config_emp\n)\n\nDefault config will estimate R on weekly sliding windows.\n    To change this change the t_start and t_end arguments. \n\n## crie um gráfico dos resultados\nplot(epiestim_res_emp)\n\n\n\n\n\n\n\n\n\n\nEspecificando as janelas de estimação do tempo\nEstas opções padrão irão fornecer uma estimativa semanal móvel, e podem atuar como um aviso que você está estimando o Rt mutio precocemente no surto, para uma estimativa precisa. Você pode mudar isto ao ajustar uma data de início posterior para a estimativa, como mostrado abaixo. Infelizmente, o EpiEstim apenas fornece um método bem desajeitado de especificar estes tempos de estimativas, em que você precisa fornecer um vetor de números inteiros referentes as datas de início e fim para cada intervalo de tempo.\n\n## defina um vetor de datas iniciando em 1o de junho\nstart_dates &lt;- seq.Date(\n  as.Date(\"2014-06-01\"),\n  max(cases$dates) - 7,\n  by = 1\n) %&gt;%\n  ## substraia a data de início para converto para numérico\n  `-`(min(cases$dates)) %&gt;%\n  ## converta para número inteiro\n  as.integer()\n\n## adicione seis dias para um intervalo móvel de uma semana\nend_dates &lt;- start_dates + 6\n  \n## crie o config\nconfig_partial &lt;- make_config(\n  mean_si = 12.0,\n  std_si = 5.2,\n  t_start = start_dates,\n  t_end = end_dates\n)\n\nAgora re-executamos o EpiEstim, e podemos ver as estimativas apenas a partir de junho:\n\n## rode o epiestim\nepiestim_res_partial &lt;- estimate_R(\n  incid = cases_incidence,\n  method = \"parametric_si\",\n  config = config_partial\n)\n\n## crie um gráfico dos resultados\nplot(epiestim_res_partial)\n\n\n\n\n\n\n\n\n\n\nAnalisando os resultados\nOs principais resultados podem ser acessados através de $R. Como um exemplo, nós iremos criar um gráfico do Rt e uma medida de “potencial de transmissão”, dada pelo produto de Rt e o número de casos notificados naquele dia; isto representa o número esperado de casos na próxima geração da infecção.\n\n## crie um quadro de dados amplo para a mediana\ndf_wide &lt;- epiestim_res_lit$R %&gt;%\n  rename_all(clean_labels) %&gt;%\n  rename(\n    lower_95_r = quantile_0_025_r,\n    lower_90_r = quantile_0_05_r,\n    lower_50_r = quantile_0_25_r,\n    upper_50_r = quantile_0_75_r,\n    upper_90_r = quantile_0_95_r,\n    upper_95_r = quantile_0_975_r,\n    ) %&gt;%\n  mutate(\n    ## extraia a data média de t_start e t_end\n    dates = epiestim_res_emp$dates[round(map2_dbl(t_start, t_end, median))],\n    var = \"R[t]\"\n  ) %&gt;%\n  ## una com os dados de incidência diária\n  left_join(cases, \"dates\") %&gt;%\n  ## calcule o risco através de todas as estimativas de r\n  mutate(\n    across(\n      lower_95_r:upper_95_r,\n      ~ .x*I,\n      .names = \"{str_replace(.col, '_r', '_risk')}\"\n    )\n  ) %&gt;%\n  ## separe as estimativas de r e as estimativas de risco\n  pivot_longer(\n    contains(\"median\"),\n    names_to = c(\".value\", \"variable\"),\n    names_pattern = \"(.+)_(.+)\"\n  ) %&gt;%\n  ## atribua os níveis do fator\n  mutate(variable = factor(variable, c(\"risk\", \"r\")))\n\n## crie um data frame longo a partir dos quantis\ndf_long &lt;- df_wide %&gt;%\n  select(-variable, -median) %&gt;%\n  ## separe o r/estimativas de risco e níveis de quantis\n  pivot_longer(\n    contains(c(\"lower\", \"upper\")),\n    names_to = c(\".value\", \"quantile\", \"variable\"),\n    names_pattern = \"(.+)_(.+)_(.+)\"\n  ) %&gt;%\n  mutate(variable = factor(variable, c(\"risk\", \"r\")))\n\n## crie o gráfico\nggplot() +\n  geom_ribbon(\n    data = df_long,\n    aes(x = dates, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = dates, y = median),\n    alpha = 0.2\n  ) +\n  ## use label_parsed para permitir rótulos subescritos\n  facet_wrap(\n    ~ variable,\n    ncol = 1,\n    scales = \"free_y\",\n    labeller = as_labeller(c(r = \"R[t]\", risk = \"Transmission~potential\"), label_parsed),\n    strip.position = 'left'\n  ) +\n  ## defina manualmente a transparência do quantil\n  scale_alpha_manual(\n    values = c(`50` = 0.7, `90` = 0.4, `95` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = NULL,\n    alpha = \"Credible\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    strip.background = element_blank(),\n    strip.placement = 'outside'\n  )",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Modelagem de epidemias</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.pt.html#projeções-da-incidência",
    "href": "new_pages/epidemic_models.pt.html#projeções-da-incidência",
    "title": "24  Modelagem de epidemias",
    "section": "24.4 Projeções da incidência",
    "text": "24.4 Projeções da incidência\n\nEpiNow2\nAlém de estimar o Rt, EpiNow2 também é capaz de prever o Rt e projetar o número de casos ao ser integrado com o pacote EpiSoon. Tudo o que você precisa fazer é especificar o argumento horizon ao usar a função epinow, indicando quantos dias você quer projetar no futuro; veja a seção do EpiNow2 em “Estimando o Rt” para detalhes sobre como configurar e executar o EpiNow2. Nesta seção, nós iremos apenas fazer o gráfico dos resultados desta análise, salvos no objeto epinow_res.\n\n## defina a data mínima do gráfico\nmin_date &lt;- as.Date(\"2015-03-01\")\n\n## extraia as estimativas resumidas\nestimates &lt;-  as_tibble(epinow_res$estimates$summarised)\n\n## extraia os dados brutos da incidência de casos\nobservations &lt;- as_tibble(epinow_res$estimates$observations) %&gt;%\n  filter(date &gt; min_date)\n\n## extraia as estimativas previstas do número de caso\ndf_wide &lt;- estimates %&gt;%\n  filter(\n    variable == \"reported_cases\",\n    type == \"forecast\",\n    date &gt; min_date\n  )\n\n## converta para o formato longo para criar o gráfico de quantil\ndf_long &lt;- df_wide %&gt;%\n  ## aqui combinamos os quantis correspondentes (ex.: lower_90 to upper_90)\n  pivot_longer(\n    lower_90:upper_90,\n    names_to = c(\".value\", \"quantile\"),\n    names_pattern = \"(.+)_(.+)\"\n  )\n\n## crie o gráfico\nggplot() +\n  geom_histogram(\n    data = observations,\n    aes(x = date, y = confirm),\n    stat = 'identity',\n    binwidth = 1\n  ) +\n  geom_ribbon(\n    data = df_long,\n    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),\n    color = NA\n  ) +\n  geom_line(\n    data = df_wide,\n    aes(x = date, y = median)\n  ) +\n  geom_vline(xintercept = min(df_long$date), linetype = 2) +\n  ## defina manualmente a transparência do quantil\n  scale_alpha_manual(\n    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),\n    labels = function(x) paste0(x, \"%\")\n  ) +\n  labs(\n    x = NULL,\n    y = \"Casos notificados diariamente\",\n    alpha = \"Credible\\ninterval\"\n  ) +\n  scale_x_date(\n    date_breaks = \"1 month\",\n    date_labels = \"%b %d\\n%Y\"\n  ) +\n  theme_minimal(base_size = 14)\n\n\n\n\n\n\n\n\n\n\nPacote projections\nO pacote projections, desenvolvido pela RECON, torna bem fácil o ato de prever incidências no curto prazo, requerindo apenas conhecimento do número efetivo de reprodução Rt, e o intervalo seriado. Aqui, nós iremos abordar como usar estimativas seriadas de intervalo da literatura e como usar nossas próprias estimativas baseadas na linelist.\n\nUtilizando estimativas de intervalo seriado da literatura\nO pacote projections precise de uma distribuição seriada discreta de intervalos da classe distcrete, do pacote distcrete. Nós iremos utilizar uma distribuição gamma com uma média de 12.0 e desvio padrão de 5.2 definido neste artigo. Para converter estes valores para os parâmetros de formato e escala requiridos para a distribuição gamma, iremos utilizar a função gamma_mucv2shapescale do pacote epitrix.\n\n## obtenha os parâmetros de formato e escala da média mu e o coeficiente de\n## variação (ex.: a razão do desvio padrão para a média)\nshapescale &lt;- epitrix::gamma_mucv2shapescale(mu = 12.0, cv = 5.2/12)\n\n## crie um objeto do tipo *distcrete*\nserial_interval_lit &lt;- distcrete::distcrete(\n  name = \"gamma\",\n  interval = 1,\n  shape = shapescale$shape,\n  scale = shapescale$scale\n)\n\nAqui está uma checagem rápida para garantir que o intervalo seriado está correto. Nós acessamos a densidade da distribuição gamma que acabamos de definir com $d, que é equivalente a chamar dgamma:\n\n## cheque para garantir que o intervalo seriado está correto\nqplot(\n  x = 0:50, y = serial_interval_lit$d(0:50), geom = \"area\",\n  xlab = \"Intervalo seriado\", ylab = \"Densidade\"\n)\n\nWarning: `qplot()` was deprecated in ggplot2 3.4.0.\n\n\n\n\n\n\n\n\n\n\n\nUtilizando estivamitvas de intervalo seriadas a partir dos dados\nComo temos dados com as datas de início dos sintomas e links de transmissão, nós podemos também estimar o intervalo seriado a partir da linelist ao calcular o intervalo entre as datas de início dos sintomas dos pares infectante-infectado. Como fizemos na seção do EpiNow2, nós iremos utilizar a função get_pairwise do pacote epicontacts, que nos permite calcular diferenças em pares das propriedades da linelist nos pares de transmissão. Primeiro, criamos um objeto epicontact (veja a página Cadeias de transmissão para mais detalhes):\n\n## crie os contacts\ncontacts &lt;- linelist %&gt;%\n  transmute(\n    from = infector,\n    to = case_id\n  ) %&gt;%\n  drop_na()\n\n## crie o objeto epicontacts\nepic &lt;- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts, \n  directed = TRUE\n)\n\nEntão ajustamos a diferença no início de sintomas entre os pares de transmissão, calculando usando get_pairwise, para uma distriuição gamma. Nós usamos a função fit_disc_gamma, do pacote epitrix, para realizar este procedimento de ajuste, uma vez que precisamos de uma distribuição discreta.\n\n## estime o intervalo seriado gamma\nserial_interval &lt;- fit_disc_gamma(get_pairwise(epic, \"date_onset\"))\n\n## inspecione a estimativa\nserial_interval[c(\"mu\", \"sd\")]\n\n$mu\n[1] 11.51047\n\n$sd\n[1] 7.696056\n\n\n\n\nProjeções da incidência\nPara prever a incidência futura, nós ainda precisamos fornecer a incidência histórica na forma de um objeto incidence, assim como uma amostra de valores plausíveis de Rt. Nós iremos gerar estes valores utilizando as estimativas de Rt geradas pelo EpiEstim na seção anterior (na subseção “Estimando Rt”) e salvo no objeto epiestim_res_emp. No código abaixo, nós extraímos a média e as estimativas de desvio padrão do Rt para a última janela de tempo do surto (usando a função tail para acessar o último elemento em um vetor), e simulamos 1000 valores de uma distribuição gamma utilizando rgamma. Você também pode fornecer seu própria vetor de valores Rt que você quer usar para projeções futuras.\n\n## crie um objeto incidence a partir das datas de início dos sintomas\ninc &lt;- incidence::incidence(linelist$date_onset)\n\n256 missing observations were removed.\n\n## extraia valores plausíveis de r para maior parte das estimativas recentes\nmean_r &lt;- tail(epiestim_res_emp$R$`Mean(R)`, 1)\nsd_r &lt;- tail(epiestim_res_emp$R$`Std(R)`, 1)\nshapescale &lt;- gamma_mucv2shapescale(mu = mean_r, cv = sd_r/mean_r)\nplausible_r &lt;- rgamma(1000, shape = shapescale$shape, scale = shapescale$scale)\n\n## cheque a distribuição\nqplot(x = plausible_r, geom = \"histogram\", xlab = expression(R[t]), ylab = \"Contagens\")\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nNós então usamos a função project() para criar a previsão atual. Nós especificamos quantos dias queremos prever através dos argumentos n_days, e especificamos o número de simulações usando o argumento n_sim.\n\n## crie a projeção\nproj &lt;- project(\n  x = inc,\n  R = plausible_r,\n  si = serial_interval$distribution,\n  n_days = 21,\n  n_sim = 1000\n)\n\nNós podemos, então, criar um gráfico da incidência e projeções usando as funções plot() e add_projections(). Nós podemos facilmente criar subconjuntos do objeto incidence para apenas mostrar os casos mais recentes ao utilizar o operador de colchetes retos.\n\n## crie um gráfico da incidência e projeções\nplot(inc[inc$dates &gt; as.Date(\"2015-03-01\")]) %&gt;%\n  add_projections(proj)\n\n\n\n\n\n\n\n\nVocê pode também facilmente extrair as novas estimativas brutas do número diário de casos ao converter o resultado da análise para um quadro de dados.\n\n## converta para um quadro de dados os dados brutos\nproj_df &lt;- as.data.frame(proj)\nproj_df",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Modelagem de epidemias</span>"
    ]
  },
  {
    "objectID": "new_pages/epidemic_models.pt.html#recursos-extras",
    "href": "new_pages/epidemic_models.pt.html#recursos-extras",
    "title": "24  Modelagem de epidemias",
    "section": "24.5 Recursos extras",
    "text": "24.5 Recursos extras\n\nAqui está o artigo descrevendo a metodologia empregada no EpiEstim.\nAqui está o artigo descrevendo a metodologia implementada no EpiNow2.\nAqui está um artigo descrevendo diferentes considerações dos metodológicas e práticas para estimar o Rt.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Modelagem de epidemias</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.pt.html",
    "href": "new_pages/contact_tracing.pt.html",
    "title": "25  Rastreamento de contatos",
    "section": "",
    "text": "25.1 Preparação",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Rastreamento de contatos</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.pt.html#preparação",
    "href": "new_pages/contact_tracing.pt.html#preparação",
    "title": "25  Rastreamento de contatos",
    "section": "",
    "text": "Carregar pacotes\nEsta chunck mostra o carregamento dos pacotes necessários para as análises. Neste manual damos ênfase a função p_load() do pacman, que instala o pacote se necessário e carrega-o para utilização. Também se pode carregar pacotes instalados com library() a partir do R base. Veja a página Introdução ao R para mais informações sobre pacotes R.\n\npacman::p_load(\n  rio,          # importar dados  \n  here,         # caminhos relativos de arquivos \n  janitor,      # limpeza dos dados e tabelas\n  lubridate,    # trabalhar com datas\n  epikit,       # função age_categories()\n  apyramid,     # piramides etárias\n  tidyverse,    # manipulação e visualização de dados\n  RColorBrewer, # paletas de cores\n  formattable,  # formatação de tabelas\n  kableExtra    # formatação de tabelas\n)\n\n\n\nImportação de dados\nImportaremos amostras de conjuntos de dados de contatos e de seus “acompanhamentos”. Estes dados foram recuperados e separados da API Go.Data e armazenados como arquivos “.rds”.\nVocê pode fazer o download de todos os dados de exemplo para este manual a partir da página Download do manual e dados.\nSe desejar fazer o download do exemplo de dados de rastreio de contatos específicos para esta página, utilize os três links de download abaixo:\n Clique para fazer o download dos dados da investigação do caso (arquivo .rds) \n Clique para fazer o download dos dados de registo de contato (arquivo .rds) \n Clique para fazer o download dos dados de acompanhamento dos contatos (arquivo .rds) \n\n\n\nNa sua forma original nos arquivos passíveis de download, os dados são exibidos como fornecidos pela API do Go.Data (saiba mais sobre APIs aqui). Para fins de exemplo, aqui vamos limpar os dados para facilitar a leitura nesta página. Se estiver usando uma extensão Go.Data, pode ver instruções completas sobre como recuperar os seus dados aqui.\nAbaixo, os conjuntos de dados são importados utilizando a função import() do pacote rio. Veja a página Importar e exportar para várias formas de importação de dados. Utilizamos here() para especificar o caminho do arquivo - forneça o caminho específico do arquivo para o seu computador. Em seguida, utilizamos select() para selecionar apenas certas colunas dos dados, simplificando para efeitos de demonstração.\n\nDados do caso\nEstes dados são uma tabela com informações sobre os casos.\n\ncases &lt;- import(here(\"data\", \"godata\", \"cases_clean.rds\")) %&gt;% \n  select(case_id, firstName, lastName, gender, age, age_class,\n         occupation, classification, was_contact, hospitalization_typeid)\n\nAqui estão os casos nrow(cases):\n\n\n\n\n\n\n\n\nDados de contatos\nEstes dados são uma tabela de todos os contatos e suas informações. Mais uma vez, forneça o seu próprio caminho para o arquivo. Após a importação, realizamos alguns passos preliminares de limpeza de dados, incluindo:\n\nDefinir a age_class (faixa-etária) como fator e inverter a ordem desses níveis, de modo que as idades menores sejam as primeiras a aparecer;\nSelecionar apenas algumas colunas específicas, ao mesmo tempo que se renomeia uma delas;\nAtribuir artificialmente às linhas cuja coluna admin_2_name estiver o nome “Djembe”, melhorando a clareza da visualização de alguns exemplos;\n\n\ncontacts &lt;- import(here(\"data\", \"godata\", \"contacts_clean.rds\")) %&gt;% \n  mutate(age_class = forcats::fct_rev(age_class)) %&gt;% \n  select(contact_id, contact_status, firstName, lastName, gender, age,\n         age_class, occupation, date_of_reporting, date_of_data_entry,\n         date_of_last_exposure = date_of_last_contact,\n         date_of_followup_start, date_of_followup_end, risk_level, was_case, admin_2_name) %&gt;% \n  mutate(admin_2_name = replace_na(admin_2_name, \"Djembe\"))\n\nAqui estão as linhas nrow(contacts) da base de dados contacts:\n\n\n\n\n\n\n\n\nDados de acompanhamento\nEsses dados são registros das interações de “acompanhamento” (follow-up) com os contatos. Espera-se que cada contato tenha um encontro de onitoramento a cada dia durante 14 dias após sua exposição.\nImportamos a base e executamos algumas etapas de limpeza. Selecionamos certas colunas e também convertemos uma coluna de caracteres em todos os valores em minúsculas.\n\nfollowups &lt;- rio::import(here::here(\"data\", \"godata\", \"followups_clean.rds\")) %&gt;% \n  select(contact_id, followup_status, followup_number,\n         date_of_followup, admin_2_name, admin_1_name) %&gt;% \n  mutate(followup_status = str_to_lower(followup_status))\n\nAqui estão as primeiras 50 linhas do conjunto de dados da fila de acompanhamento (nrow(followups)). Cada linha é uma interação de acompanhamento, com o status do resultado na coluna followup_status:\n\n\n\n\n\n\n\n\nDados de relação\nAqui importamos os dados mostrando a relação entre os casos e contatos. Selecionamos certas colunas para demonstrar.\n\nrelationships &lt;- rio::import(here::here(\"data\", \"godata\", \"relationships_clean.rds\")) %&gt;% \n  select(source_visualid, source_gender, source_age, date_of_last_contact,\n         date_of_data_entry, target_visualid, target_gender,\n         target_age, exposure_type)\n\nAbaixo estão as primeiras 50 linhas da base de dados relationships, que contém todas as relações entre casos e contatos.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Rastreamento de contatos</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.pt.html#análises-descritivas",
    "href": "new_pages/contact_tracing.pt.html#análises-descritivas",
    "title": "25  Rastreamento de contatos",
    "section": "25.2 Análises descritivas",
    "text": "25.2 Análises descritivas\nVocê pode utilizar as técnicas abordadas em outras páginas deste manual para realizar análises descritivas dos seus casos, contatos e respectivas relações. Abaixo estão alguns exemplos.\n\nDemográficos\nComo demonstrado neste manual Pirâmides demográficas, é possível visualizar a idade e a distribuição por sexo (aqui utilizamos o pacote apyramid).\n\nIdade e Gênero dos contatos\nA pirâmide abaixo compara a distribuição etária dos contatos, por sexo. Note que contatos com idades faltosas (missing) estão inclusos em uma barra no topo. Você pode alterar este comportamento padrão, mas depois considere listar os valores ausentes (“missing”) em uma legenda.\n\napyramid::age_pyramid(\n  data = contacts,                                   # usar base de dados de contatos\n  age_group = \"age_class\",                           # coluna de faixa-etária\n  split_by = \"gender\") +                             # lados da pirâmide divididos por gênero\n  labs(\n    fill = \"Gender\",                                 # título da legenda\n    title = \"Age/Sex Pyramid of COVID-19 contacts\")+ # título da figura\n  theme_minimal()                                    # plano de fundo simples\n\n\n\n\n\n\n\n\nCom a estrutura de dados Go.Data, o conjunto de dados relationships contém as idades de ambos os casos e contatos, para que você pudesse utilizar esse conjunto de dados e criar uma pirâmide de idades mostrando as diferenças entre esses dois grupos de pessoas. A base relationships será alterada para transformar as colunas numéricas de idade em categorias, ou seja, faixas-etárias (veja a página Dados de limpeza e principais funções). Também pivotamos a base de dados de forma mais longa, para facilitar a criaçãodo gráfico com ggplot2 (ver Pivotando dados).\n\nrelation_age &lt;- relationships %&gt;% \n  select(source_age, target_age) %&gt;% \n  transmute(                              # transmute é como a função mutate(), mas remove todas as outras colunas não mencionadas\n    source_age_class = epikit::age_categories(source_age, breakers = seq(0, 80, 5)),\n    target_age_class = epikit::age_categories(target_age, breakers = seq(0, 80, 5)),\n    ) %&gt;% \n  pivot_longer(cols = contains(\"class\"), names_to = \"category\", values_to = \"age_class\")# pivotação longa\n\n\nrelation_age\n\n# A tibble: 200 × 2\n   category         age_class\n   &lt;chr&gt;            &lt;fct&gt;    \n 1 source_age_class 80+      \n 2 target_age_class 15-19    \n 3 source_age_class &lt;NA&gt;     \n 4 target_age_class 50-54    \n 5 source_age_class &lt;NA&gt;     \n 6 target_age_class 20-24    \n 7 source_age_class 30-34    \n 8 target_age_class 45-49    \n 9 source_age_class 40-44    \n10 target_age_class 30-34    \n# ℹ 190 more rows\n\n\nAgora podemos traçar este conjunto de dados transformados com a função age_pyramid() como antes, mas substituindo gênder por category (Caso, ou Contato).\n\napyramid::age_pyramid(\n  data = relation_age,                               # usar a base de dados modificada `reltionship`\n  age_group = \"age_class\",                           # coluna categórica de idade\n  split_by = \"category\") +                           # dividir por casos e contatos\n  scale_fill_manual(\n    values = c(\"orange\", \"purple\"),                  # para especificar cores E nomes\n    labels = c(\"Caso\", \"Contato\"))+\n  labs(\n    fill = \"Legend\",                                           # título da legenda\n    title = \"Pirâmide Idade/Sexo de casos e contatos de COVID-19\")+ # título da figura\n  theme_minimal()                                              # plano de fundo simples\n\n\n\n\n\n\n\n\nTambém podemos ver outras características, como a discriminação por ocupação (ex. em forma de gráfico de setores).\n\n# Limpar a base de dados e contar as ocupações\nocc_plot_data &lt;- cases %&gt;% \n  mutate(occupation = forcats::fct_explicit_na(occupation),  # fazer valores NA e vazios uma categoria\n         occupation = forcats::fct_infreq(occupation)) %&gt;%   # ordenar em níveis, em ordem de frequência\n  count(occupation)                                          # contagens por ocupação\n  \n# fazer gráfico de setores\nggplot(data = occ_plot_data, mapping = aes(x = \"\", y = n, fill = occupation))+\n  geom_bar(width = 1, stat = \"identity\") +\n  coord_polar(\"y\", start = 0) +\n  labs(\n    fill = \"Ocupação\",\n    title = \"Ocupações conhecidadas de casos de COVID-19\")+\n  theme_minimal() +                    \n  theme(axis.line = element_blank(),\n        axis.title = element_blank(),\n        axis.text = element_blank())\n\n\n\n\n\n\n\n\n\n\n\nContatos por caso\nO número de contatos por caso pode ser uma métrica importante para avaliar qualidade da contagem de contatos e a conformidade da população para uma resposta de saúde pública.\nDependendo de sua estrutura de dados, isto pode ser avaliado com um conjunto de dados que contém todos os casos e contatos. Nos conjuntos de dados Go.Data, os links entre os casos (“fontes”) e os contatos (“alvos”) é armazenado no conjunto de dados relationships.\nNeste conjunto de dados, cada linha é um contato, e o caso da fonte é listado em uma linha. Não há contatos que tenham relações com múltiplos casos, mas se isso existir, você pode precisar computá-los antes de criar o gráfico.\nComeçamos contando o número de linhas (contatos) por caso de origem. Isto é salvo como um data frame.\n\ncontacts_per_case &lt;- relationships %&gt;% \n  count(source_visualid)\n\ncontacts_per_case\n\n   source_visualid  n\n1   CASE-2020-0001 13\n2   CASE-2020-0002  5\n3   CASE-2020-0003  2\n4   CASE-2020-0004  4\n5   CASE-2020-0005  5\n6   CASE-2020-0006  3\n7   CASE-2020-0008  3\n8   CASE-2020-0009  3\n9   CASE-2020-0010  3\n10  CASE-2020-0012  3\n11  CASE-2020-0013  5\n12  CASE-2020-0014  3\n13  CASE-2020-0016  3\n14  CASE-2020-0018  4\n15  CASE-2020-0022  3\n16  CASE-2020-0023  4\n17  CASE-2020-0030  3\n18  CASE-2020-0031  3\n19  CASE-2020-0034  4\n20  CASE-2020-0036  1\n21  CASE-2020-0037  3\n22  CASE-2020-0045  3\n23            &lt;NA&gt; 17\n\n\nPodemos usar geom_histogram() para fazer um histograma a partir desses dados.\n\nggplot(data = contacts_per_case)+        # começar com a contagem da base de dados criada anteriormente\n  geom_histogram(mapping = aes(x = n))+  # criar o histograma do número de contatos por caso\n  scale_y_continuous(expand = c(0,0))+   # remover o espaço em excesso abaixo de 0 no eixo y\n  theme_light()+                         # simplificar o plano de fundo\n  labs(\n    title = \"Número de contatos por caso\",\n    y = \"Casus\",\n    x = \"Contatos por caso\"\n  )",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Rastreamento de contatos</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.pt.html#acompanhamento-de-contato",
    "href": "new_pages/contact_tracing.pt.html#acompanhamento-de-contato",
    "title": "25  Rastreamento de contatos",
    "section": "25.3 Acompanhamento de contato",
    "text": "25.3 Acompanhamento de contato\nOs dados de rastreamento de contatos geralmente contêm dados de “acompanhamento”, que registram resultados das verificações diárias dos sintomas das pessoas em quarentena. Análises destes dados podem informar a estratégia de resposta, identificar contatos em risco de perda no acompanhamento ou risco de desenvolver doenças.\n\nLimpeza do dados\nEstes dados podem existir em uma variedade de formatos, como um formato Excel “largo/amplo”, com uma linha por contato e uma coluna por dia de acompanhamento. Veja Pivoteando dados para descrições de dados “longos” e “largos”, e como pivotar dados mais amplos/largos ou mais longos.\nEm nosso exemplo com Go.Data, estes dados são armazenados nos dados de acompanhamento (followups), em um formato “longo”, com uma linha por acompanhamento interação. As primeiras 50 filas são dessa forma:\n\n\n\n\n\n\nCUIDADO: Cuidado com as duplicatas ao lidar com dados de acompanhamento; podem haver vários seguimentos errôneos no mesmo dia para um determinado contato. Talvez pareça um erro, mas reflete a realidade - por exemplo, um investigador poderia submeter um formulário de acompanhamento no início do dia, quando não foi possível contactar o indivíduo e, mais tarde, submeter um segundo formulário quando conseguir contato. Dependerá do contexto operacional a forma como você quer lida com duplicatas - apenas certifique-se de documentar sua abordagem claramente.\nVamos ver quantas linhas “duplicadas” nós temos:\n\nfollowups %&gt;% \n  count(contact_id, date_of_followup) %&gt;%   # obter valores únicos para dias de contato (contact_days)\n  filter(n &gt; 1)                             # ver registros onde a contagem é maior que 1\n\n  contact_id date_of_followup n\n1       &lt;NA&gt;       2020-09-03 2\n2       &lt;NA&gt;       2020-09-04 2\n3       &lt;NA&gt;       2020-09-05 2\n\n\nEm nossos dados de exemplo, os únicos registros aos quais isto se aplica são os que faltam um ID! Podemos removê-los. Mas, para fins de demonstração vamos mostrar os passos para remoção de duplicidades, de forma que haja apenas um acompanhamento por pessoa por dia. Para mais detalhes, veja a página Eliminando duplicidades. Vamos supor que o registro mais recente é o correto. Também aproveitamos a oportunidade para limpar a coluna followup_number (o “dia” de acompanhamento que deve variar de 1 - 14).\n\nfollowups_clean &lt;- followups %&gt;%\n  \n  # Remover duplicidades\n  group_by(contact_id, date_of_followup) %&gt;%        # agrupar linhas por dia de contato (contact-day)\n  arrange(contact_id, desc(date_of_followup)) %&gt;%   # organizar linhas por dia de contato, data de acompanhamento (date of follow-up), trazendo o mais recente para o topo\n  slice_head() %&gt;%                                  # manter apenas a primeira linha por valor único de ID do contato (contact id)\n  ungroup() %&gt;% \n  \n  # Outras limpezas\n  mutate(followup_number = replace(followup_number, followup_number &gt; 14, NA)) %&gt;% # limpar dados errados\n  drop_na(contact_id)                               # remover linhas com valor em branco para contact_id\n\nPara cada encontro de acompanhamento, temos um status de acompanhamento (por exemplo se o encontro ocorreu e se o contato teve sintomas ou não). Para ver todos os valores, podemos executar um rápido tabyl() (do janitor) ou table() (do R Base) (ver Tabelas descritivas) por ‘followup_status’ para ver a frequência de cada um dos resultados.\nNeste conjunto de dados, “seen_not_ok” significa “visto com sintomas” e “seen_ok” significa “visto sem sintomas”\n\nfollowups_clean %&gt;% \n  tabyl(followup_status)\n\n followup_status   n    percent\n          missed  10 0.02325581\n   not_attempted   5 0.01162791\n   not_performed 319 0.74186047\n     seen_not_ok   6 0.01395349\n         seen_ok  90 0.20930233\n\n\n\n\nGráfico ao longo do tempo\nComo os dados das datas são contínuos, usaremos um histograma para representá-los com a data de acompanhamento (date_of_followup) atribuída ao eixo x. Podemos produzir um histograma “empilhado”, especificando um argumento fill = dentro de aes(), que atribuímos à coluna de status do acompanhamento (followup_status). Consequentemente, você pode definir o título da legenda utilizando o argumento fill = do labs().\nPodemos ver que os contatos foram identificados em ondas (presumivelmente correspondente às ondas epidêmicas de casos), e que a conclusão do acompanhamento não parece ter melhorado ao longo do curso da epidemia.\n\nggplot(data = followups_clean)+\n  geom_histogram(mapping = aes(x = date_of_followup, fill = followup_status)) +\n  scale_fill_discrete(drop = FALSE)+   # exibir todos os níveis de fatores (followup_status) na legenda, mesmo os não utilizados\n  theme_classic() +\n  labs(\n    x = \"\",\n    y = \"Número de contatos\",\n    title = \"Status de acompanhamento de contato diário\",\n    fill = \"Status de acompanhamento\",\n    subtitle = str_glue(\"Dados de {max(followups$date_of_followup, na.rm=T)}\"))   # subtítulo dinâmico subtitle\n\n\n\n\n\n\n\n\nCUIDADO: Se você estiver preparando muitos gráficos (por exemplo, para múltiplas jurisdições) é preferível que as legendas apareçam de forma idêntica, mesmo com diferentes níveis de preenchimento ou composição de dados. Podem haver gráficos para os quais nem todos os status de acompanhamento estão presentes nos dados, mas você ainda quer que essas categorias apareçam nas legendas. Em ggplots (como acima), você pode especificar o argumento drop = FALSE do scale_fill_discrete(). Nas tabelas, utilize tabyl() que mostra contagens para todos os níveis de fatores, ou se utilizandocount() do dplyr adicione o argumento .drop = FALSE para incluir contagens para todos os níveis de fatores.\n\n\nRastreamento individual diário\nSe seu surto for pequeno o suficiente, pode ser interessante olhar para cada contato individualmente e ver seu status ao longo de seu acompanhamento. Felizmente, este conjunto de dados followups já contém uma coluna com o “número” do dia de acompanhamento (de 1 a 14). Se isto não existir em seus dados, você poderia criá-lo calculando a diferença entre a data do contato e a data que o acompanhamento foi planejado para começar.\nUm mecanismo de visualização conveniente (se o número de casos não for muito grande) pode ser um gráfico de calor, feito com geom_tile(). Veja mais detalhes na página Gráfico de calor.\n\nggplot(data = followups_clean)+\n  geom_tile(mapping = aes(x = followup_number, y = contact_id, fill = followup_status),\n            color = \"grey\")+       # linhas de grade na cor cinza\n  scale_fill_manual( values = c(\"yellow\", \"grey\", \"orange\", \"darkred\", \"darkgreen\"))+\n  theme_minimal()+\n  scale_x_continuous(breaks = seq(from = 1, to = 14, by = 1))\n\n\n\n\n\n\n\n\n\n\nAnálises por grupo\nTalvez esses dados de acompanhamento estejam sendo vistos diariamente ou semanalmente para a tomada de decisões operacionais. Você pode considerar mais significativo a desagregação por área geográfica ou por equipe de rastreamento de contatos. Podemos fazer isso ajustando as colunas fornecidas no group_by().\n\nplot_by_region &lt;- followups_clean %&gt;%        # começar com a base de dados de acompanhamento\n  count(admin_1_name, admin_2_name, followup_status) %&gt;% # contagem por valores únicos no \"region-status\" (cria coluna 'n' com a contagem )\n  \n  # iniciar o ggplot()\n  ggplot(                                         # iniciar o ggplot\n    mapping = aes(x = reorder(admin_2_name, n),   # reordenar os níveis dos fatores de administração pelos valores numéricos na coluna 'n'\n                  y = n,                            # altura das barras segundo coluna 'n'\n                  fill = followup_status,           # cor da barra empilhada segundo seu status\n                  label = n))+                      # transição para o geom_label()              \n  geom_col()+                              # barras empilhadas, vindo do mapeamento anterior\n  geom_text(                               # adicionar texto, vindo do mapeamento anterior\n    size = 3,                                         \n    position = position_stack(vjust = 0.5), \n    color = \"white\",           \n    check_overlap = TRUE,\n    fontface = \"bold\")+\n  coord_flip()+\n  labs(\n    x = \"\",\n    y = \"Número de contatos\",\n    title = \"Status do acompanhamento do contato, por Região\",\n    fill = \"Status do acompanhamento\",\n    subtitle = str_glue(\"Dados de {max(followups_clean$date_of_followup, na.rm=T)}\")) +\n  theme_classic()+                                               # Plano de fundo simplificado\n  facet_wrap(~admin_1_name, strip.position = \"right\", scales = \"free_y\", ncol = 1) # introduzir facetas \n\nplot_by_region",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Rastreamento de contatos</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.pt.html#tabelas-kpi",
    "href": "new_pages/contact_tracing.pt.html#tabelas-kpi",
    "title": "25  Rastreamento de contatos",
    "section": "25.4 Tabelas KPI",
    "text": "25.4 Tabelas KPI\nHá uma série de diferentes indicadores-Chave de Desempenho (KPIs, de Key Performance Indicators em inglês) que podem ser calculados e rastreados em diferentes níveis de desagregação e ao longo de diferentes períodos de tempo para monitorar o desempenho do rastreamento de contatos. Uma vez que você tenha os cálculos e o formato básico da tabela; é bastante fácil trocar por diferentes KPIs.\nExistem várias fontes de rastreamento de contatos KPIs, tais como este (de ResolveToSaveLives.org).A maior parte do trabalho será caminhar através de sua estrutura de dados e pensar em todos os critérios de inclusão/exclusão. Mostramos alguns exemplos abaixo; usando a estrutura de metadados Go.Data:\n\n\n\n\n\n\n\n\n\nCategoria\nIndicador\nNumerador Go.Data\nDenominador Go.Data\n\n\n\n\nIndicador de processo (Velocidade de rastreio do contato)\n% casos entrevistados e isolados em até 24h da informação\nCOUNT OF case_id WHERE (date_of_reporting - da te_of_data_entry) &lt; 1 dia E (is olation_startdate - da te_of_data_entry) &lt; 1 day\nCOUNT OF case_id\n\n\nIndicador de processo - velocidade de rastreio do contato\n% de contatos notificados e em quarentena em até 24h da exposição\nCOUNT OF contact_id WHERE followup_status == “SEEN_NOT_OK” OR “SEEN_OK” AND date_of_followup - date_of_reporting &lt; 1 day\nCOUNT OF contact_id\n\n\nIndicador de processo - Completude da testagem\n% de novos casos sintomaticos testados e entrevistados em até 3 dias do início de sintomas\nCOUNT OF case_id WHERE (date_of_reporting - date_of_onset) &lt; =3 days\nCOUNT OF case_id\n\n\nIndicador de resultados - Geral\n% novos casos entre lista de contatos existente\nCOUNT OF case_id WHERE was_contact == “TRUE”\nCOUNT OF case_id\n\n\n\nAbaixo, iremos passar por um exercício de exemplo de criação de uma tabela que mostra o acompanhamento dos contatos ao longo de áreas administrativas. No final, tornaremos essa tabela apresentável com o pacote formattable (mas você poderia usar outros pacotes, como flextable - veja Tabelas para apresentação).\nA criação de tabelas como esta, dependerá da sua estrutura de dados de rastreamento de contatos. Visite a página Tabelas descritivas para aprender como resumir os dados usando as funções do dplyr.\nCriaremos uma tabela que será dinâmica e mudará de acordo com a mudança dos dados. Para tornar os resultados interessantes, estabeleceremos uma data de relato (report_date), que nos permite simular o funcionamento da tabela em um determinado dia (escolhemos 10 de Junho de 2020). Os dados são filtrados até essa data.\n\n# Criar a \"Report date\" para simular simular a execução do relatório com dados \"a partir\" desta data\nreport_date &lt;- as.Date(\"2020-06-10\")\n\n# Criar dados de acompanhamento para refletir a data do relatório\ntable_data &lt;- followups_clean %&gt;% \n  filter(date_of_followup &lt;= report_date)\n\nAgora, com base em nossa estrutura de dados, faremos o seguinte:\n\nComece com os followups e use o summarise para que contenha, em cada contato único:\n\n\nA data do último registro (não importa o status do encontro)\nA data do último encontro em que o contato foi “visto”\nO status do encontro naquela última vez em que o contato foi “visto” (por exemplo, com sintomas ou sem sintomas)\n\n\nJunte estes dados aos dados de contato, que contêm outras informações como o status geral de contato, data do último exposição a um caso, etc. Também calcularemos as métricas de interesse para cada contato, tais como dias desde a última exposição\nAgrupamos os dados de contato melhorados por região geográfica (admin_2_name) e calculamos estatísticas resumidas por região\nFinalmente, formatamos a tabela para apresentação\n\nPrimeiro resumimos os dados de acompanhamento para obter as informações de interesse:\n\nfollowup_info &lt;- table_data %&gt;% \n  group_by(contact_id) %&gt;% \n  summarise(\n    date_last_record   = max(date_of_followup, na.rm=T),\n    date_last_seen     = max(date_of_followup[followup_status %in% c(\"seen_ok\", \"seen_not_ok\")], na.rm=T),\n    status_last_record = followup_status[which(date_of_followup == date_last_record)]) %&gt;% \n  ungroup()\n\nAqui vemos os dados:\n\n\n\n\n\n\nAgora vamos adicionar essas informações à base de dados contacts e calcular algumas colunas adicionais\n\ncontacts_info &lt;- followup_info %&gt;% \n  right_join(contacts, by = \"contact_id\") %&gt;% \n  mutate(\n    database_date       = max(date_last_record, na.rm=T),\n    days_since_seen     = database_date - date_last_seen,\n    days_since_exposure = database_date - date_of_last_exposure\n    )\n\nAqui vemos a aparência dos dados. Observe a coluna contacts à direita e a nova coluna calculada na extrema direita.\n\n\n\n\n\n\nA seguir, resumimos os dados de contato por região, para obter uma base concisa de colunas estatísticas resumidas.\n\ncontacts_table &lt;- contacts_info %&gt;% \n  \n  group_by(`Admin 2` = admin_2_name) %&gt;%\n  \n  summarise(\n    `Registered contacts` = n(),\n    `Active contacts`     = sum(contact_status == \"UNDER_FOLLOW_UP\", na.rm=T),\n    `In first week`       = sum(days_since_exposure &lt; 8, na.rm=T),\n    `In second week`      = sum(days_since_exposure &gt;= 8 & days_since_exposure &lt; 15, na.rm=T),\n    `Became case`         = sum(contact_status == \"BECAME_CASE\", na.rm=T),\n    `Lost to follow up`   = sum(days_since_seen &gt;= 3, na.rm=T),\n    `Never seen`          = sum(is.na(date_last_seen)),\n    `Followed up - signs` = sum(status_last_record == \"Seen_not_ok\" & date_last_record == database_date, na.rm=T),\n    `Followed up - no signs` = sum(status_last_record == \"Seen_ok\" & date_last_record == database_date, na.rm=T),\n    `Not Followed up`     = sum(\n      (status_last_record == \"NOT_ATTEMPTED\" | status_last_record == \"NOT_PERFORMED\") &\n        date_last_record == database_date, na.rm=T)) %&gt;% \n    \n  arrange(desc(`Registered contacts`))\n\n\n\n\n\n\n\nE agora aplicamos estilos dos pacotes formattable e knitr, incluindo uma nota de rodapé que mostra a data “a partir de”.\n\ncontacts_table %&gt;%\n  mutate(\n    `Admin 2` = formatter(\"span\", style = ~ formattable::style(\n      color = ifelse(`Admin 2` == NA, \"red\", \"grey\"),\n      font.weight = \"bold\",font.style = \"italic\"))(`Admin 2`),\n    `Followed up - signs`= color_tile(\"white\", \"orange\")(`Followed up - signs`),\n    `Followed up - no signs`= color_tile(\"white\", \"#A0E2BD\")(`Followed up - no signs`),\n    `Became case`= color_tile(\"white\", \"grey\")(`Became case`),\n    `Lost to follow up`= color_tile(\"white\", \"grey\")(`Lost to follow up`), \n    `Never seen`= color_tile(\"white\", \"red\")(`Never seen`),\n    `Active contacts` = color_tile(\"white\", \"#81A4CE\")(`Active contacts`)\n  ) %&gt;%\n  kable(\"html\", escape = F, align =c(\"l\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\",\"c\")) %&gt;%\n  kable_styling(\"hover\", full_width = FALSE) %&gt;%\n  add_header_above(c(\" \" = 3, \n                     \"Contatos atualmente em acompanhamento\" = 5,\n                     \"Status na última visita\" = 3)) %&gt;% \n  kableExtra::footnote(general = str_glue(\"Data are current to {format(report_date, '%b %d %Y')}\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nContatos atualmente em acompanhamento\n\n\nStatus na última visita\n\n\n\nAdmin 2\nRegistered contacts\nActive contacts\nIn first week\nIn second week\nBecame case\nLost to follow up\nNever seen\nFollowed up - signs\nFollowed up - no signs\nNot Followed up\n\n\n\n\nDjembe \n59\n30\n44\n0\n2\n15\n22\n0\n0\n0\n\n\nTrumpet\n3\n1\n3\n0\n0\n0\n0\n0\n0\n0\n\n\nVenu \n2\n0\n0\n0\n2\n0\n2\n0\n0\n0\n\n\nCongas \n1\n0\n0\n0\n1\n0\n1\n0\n0\n0\n\n\nCornet \n1\n0\n1\n0\n1\n0\n1\n0\n0\n0\n\n\n\nNote: \n\n\n\n\n\n\n\n\n\n\n\n\n Data are current to Jun 10 2020",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Rastreamento de contatos</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.pt.html#matrizes-de-transmissão",
    "href": "new_pages/contact_tracing.pt.html#matrizes-de-transmissão",
    "title": "25  Rastreamento de contatos",
    "section": "25.5 Matrizes de transmissão",
    "text": "25.5 Matrizes de transmissão\nComo foi discutido na página Gráficos de calor, você pode criar uma matriz de “quem infectou quem” utilizando geom_tile().\nQuando novos contatos são criados, o Go.Data armazena essa informação de relações no ponto final da API relationships; e podemos ver o primeiras 50 filas deste conjunto de dados abaixo. Isto significa que podemos criar um gráfico de calor com relativamente poucas etapas, dado que cada contato já está unido ao seu caso de origem.\n\n\n\n\n\n\nComo feito anteriormente para a pirâmide etária comparando casos e contatos, podemos selecionar as poucas variáveis necessárias e criar colunas com faixas etárias categóricas, tanto para fontes (casos) quanto para alvos (contatos).\n\nheatmap_ages &lt;- relationships %&gt;% \n  select(source_age, target_age) %&gt;% \n  mutate(   # a função transmute é como a função mutate(), mas remove todas as outras colunas\n    source_age_class = epikit::age_categories(source_age, breakers = seq(0, 80, 5)),\n    target_age_class = epikit::age_categories(target_age, breakers = seq(0, 80, 5))) \n\nComo descrito anteriormente, criamos uma tabulação cruzada;\n\ncross_tab &lt;- table(\n  source_cases = heatmap_ages$source_age_class,\n  target_cases = heatmap_ages$target_age_class)\n\ncross_tab\n\n            target_cases\nsource_cases 0-4 5-9 10-14 15-19 20-24 25-29 30-34 35-39 40-44 45-49 50-54\n       0-4     0   0     0     0     0     0     0     0     0     1     0\n       5-9     0   0     1     0     0     0     0     1     0     0     0\n       10-14   0   0     0     0     0     0     0     0     0     0     0\n       15-19   0   0     0     0     0     0     0     0     0     0     0\n       20-24   1   1     0     1     2     0     2     1     0     0     0\n       25-29   1   2     0     0     0     0     0     0     0     0     0\n       30-34   0   0     0     0     0     0     0     0     1     1     0\n       35-39   0   2     0     0     0     0     0     0     0     1     0\n       40-44   0   0     0     0     1     0     2     1     0     3     1\n       45-49   1   2     2     0     0     0     3     0     1     0     3\n       50-54   1   2     1     2     0     0     1     0     0     3     4\n       55-59   0   1     0     0     1     1     2     0     0     0     0\n       60-64   0   0     0     0     0     0     0     0     0     0     0\n       65-69   0   0     0     0     0     0     0     0     0     0     0\n       70-74   0   0     0     0     0     0     0     0     0     0     0\n       75-79   0   0     0     0     0     0     0     0     0     0     0\n       80+     1   0     0     2     1     0     0     0     1     0     0\n            target_cases\nsource_cases 55-59 60-64 65-69 70-74 75-79 80+\n       0-4       1     0     0     0     0   0\n       5-9       1     0     0     0     0   0\n       10-14     0     0     0     0     0   0\n       15-19     0     0     0     0     0   0\n       20-24     1     0     0     0     0   1\n       25-29     0     0     0     0     0   0\n       30-34     1     0     0     0     0   0\n       35-39     0     0     0     0     0   0\n       40-44     1     0     0     0     1   1\n       45-49     2     1     0     0     0   1\n       50-54     1     0     1     0     0   1\n       55-59     0     0     0     0     0   0\n       60-64     0     0     0     0     0   0\n       65-69     0     0     0     0     0   0\n       70-74     0     0     0     0     0   0\n       75-79     0     0     0     0     0   0\n       80+       0     0     0     0     0   0\n\n\nconverter em formato longo com proporções;\n\nlong_prop &lt;- data.frame(prop.table(cross_tab))\n\ne criar um gráfico de calor para a idade.\n\nggplot(data = long_prop)+       # usar dados longos, com proporção como Freq\n  geom_tile(                    # visualizar quadrantes\n    aes(\n      x = target_cases,         # eixo X é a idade do Alvo\n      y = source_cases,         # eixo Y é a idade da Fonte\n      fill = Freq))+            # cor dos quadrantes é de acordo com a coluna Freq da base de dados\n  scale_fill_gradient(          # ajustar a cor de enchimento das quadrantes\n    low = \"blue\",\n    high = \"orange\")+\n  theme(axis.text.x = element_text(angle = 90))+\n  labs(                         # rótulos\n    x = \"Idade dos casos alvo\",\n    y = \"Idade dos casos fonte\",\n    title = \"Quem infectou quem\",\n    subtitle = \"Matriz de frequências de eventos de transmissão\",\n    fill = \"Porporção de todos\\neventos de transmissão\"     # título da legenda\n  )",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Rastreamento de contatos</span>"
    ]
  },
  {
    "objectID": "new_pages/contact_tracing.pt.html#fontes",
    "href": "new_pages/contact_tracing.pt.html#fontes",
    "title": "25  Rastreamento de contatos",
    "section": "25.6 Fontes",
    "text": "25.6 Fontes\nhttps://github.com/WorldHealthOrganization/godata/tree/master/analytics/r-reporting\nhttps://worldhealthorganization.github.io/godata/\nhttps://community-godata.who.int/",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Rastreamento de contatos</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.pt.html",
    "href": "new_pages/survey_analysis.pt.html",
    "title": "26  Analises de pesquisa de questionários (survey)",
    "section": "",
    "text": "26.1 Visão Geral\nEsta página demonstra o uso de vários pacotes para análise de pesquisas de questionários (do tipo survey).\nA maioria dos pacotes de pesquisa R depende do pacote survey para fazer análises ponderadas. Utilizaremos survey assim como srvyr(que funciona como uma roupagem (wrapper) para o pacote survey, isto é, simplificando seu uso e permitindo uma codificação em estilo “tidyverse”) e gtsummary (que funciona como uma roupagem (wrapper) para o pacote survey, permitindo a publicação de tabelas prontas).\nEmbora o pacote original de survey não permita uma codificação em estilo “tidyverse”, ele tem o benefício adicional de permitir modelos lineares generalizados ponderados (que serão adicionados a esta página posteriormente). Também demonstraremos usando uma função do pacote sitrep, para criar pesos de amostragem (n.b este pacote ainda não está atualmente no CRAN, mas pode ser instalado a partir do github).\nA maior parte desta página é baseada no trabalho feito para o projeto “R4Epis”; para obter o código detalhado e modelos R-markdown veja a página do github “R4Epis”. Alguns dos códigos survey baseados em pacotes são baseados nas primeiras versões do EPIET case studies.\nNo momento, esta página não aborda os cálculos de tamanho de amostra ou amostragem. Para uma calculadora de tamanho de amostra simples de usar, consulte OpenEpi. A página Introdução do GIS (https://epirhandbook.com/gis-basics.html) do manual terá eventualmente uma seção sobre amostragem espacial aleatória, e esta página terá eventualmente uma seção sobre estruturas de amostragem, bem como cálculos de tamanho de amostra.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Analises de pesquisa de questionários (*survey*)</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.pt.html#visão-geral",
    "href": "new_pages/survey_analysis.pt.html#visão-geral",
    "title": "26  Analises de pesquisa de questionários (survey)",
    "section": "",
    "text": "Dados da pesquisa\nTempo de observação\nPonderação\nObjetos de projeto de pesquisa\nAnálise descritiva\nProporções ponderadas\nTaxas ponderadas",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Analises de pesquisa de questionários (*survey*)</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.pt.html#preparação",
    "href": "new_pages/survey_analysis.pt.html#preparação",
    "title": "26  Analises de pesquisa de questionários (survey)",
    "section": "26.2 Preparação",
    "text": "26.2 Preparação\n\nPacotes\nEste trecho de código mostra o carregamento dos pacotes necessários para as análises. Neste manual, enfatizamos p_load() do pacman, que instala o pacote se necessário e o carrega para utilização. Você também pode carregar pacotes usando library() do R Base. Veja a página Introdução ao R para mais informações sobre os pacotes R. Aqui também demonstramos utilizando a função p_load_gh() de pacman para instalar e carregar pacote do github que ainda não foi publicado no CRAN.\n\n## carregar pacotes do CRAN\npacman::p_load(rio,          # Importar arquivo\n               here,         # Local do arquivo\n               tidyverse,    # manipulação de dados + gráficos com ggplot2\n               tsibble,      # manipulação de bases de séries temporais\n               survey,       # funções de pesquisa\n               srvyr,        # roupagem (wraper) para o pacote survey\n               gtsummary,    # wrapper para o pacote survey, para produzir tabelas\n               apyramid,     # pacote destinado a criação de pirâmides etárias\n               patchwork,    # combinação de gráficos ggplots\n               ggforce       # para diagramas aluviais e de sankey\n               ) \n\n## carregar pacotes do github\npacman::p_load_gh(\n     \"R4EPI/sitrep\"          # para funções de tempo de observação / ponderação\n)\n\n\n\nCarregar dados\nO conjunto de dados de exemplo utilizado nesta seção:\n\ndados fictícios da pesquisa de mortalidade.\npopulação fictícia conta para a área de pesquisa.\ndicionário de dados para os dados fictícios da pesquisa de mortalidade.\n\nIsto é baseado na pesquisa pré-aprovada pelo conselho de análise ética da MSF OCA. O conjunto de dados fictício foi produzido como parte do projeto “R4Epis”. Baseado em dados coletados usando KoboToolbox, que é um software de coleta de dados baseado em Open Data Kit.\nKobo lhe permite exportar tanto os dados coletados quanto o dicionário para esse conjunto de dados. Recomendamos fortemente que se faça isso, pois simplifica a limpeza de dados e é útil para a pesquisa devariáveis/questões.\nDICA: O dicionário de dados Kobo tem nomes de variáveis na coluna”name” da planilha de pesquisa. Os valores possíveis para cada variável são especificado na planilha de escolhas. Na planilha de escolhas, a coluna “name” tem o nome abreviado e as colunas “label::english” e “label::french” têm nome completo. Use o pacote epidict, função msf_dict_survey() para importar um arquivo excel do dicionário Kobo e formatá-lo para que possa ser usado facilmente em uma recodificação.\nCUIDADO: O conjunto de dados do exemplo não é o mesmo que uma exportação (como em Kobo você exporta diferentes níveis de questionários individualmente) - veja o seção de dados da pesquisa abaixo para fundir as diferentes níveis\nO conjunto de dados é importado utilizando a função import() do pacote rio. Veja a página Importar e exportação para outrasmaneiras de importar dados.\n\n# importar os dados da pesquisa\nsurvey_data &lt;- rio::import(\"survey_data.xlsx\")\n\n# importar o dicionário para o R\nsurvey_dict &lt;- rio::import(\"survey_dict.xlsx\") \n\nAs primeiras 10 linhas da pesquisa são exibidas abaixo.\n\n\n\n\n\n\nTambém queremos importar os dados sobre a população de amostragem para que possamos produzir pesos adequados. Estes dados podem estar em diferentes formatos, no entanto, sugerimos que seja como visto abaixo (podendo ser apenas digitado numa planilha).\n\n# importar os dados da população\npopulation &lt;- rio::import(\"population.xlsx\")\n\nAs primeiras 10 linhas da pesquisa são exibidas abaixo.\n\n\n\n\n\n\nPara pesquisas de cluster (grupos, agregados) você pode querer adicionar pesos de pesquisa no nível do cluster. Você poderia ler estes dados como acima. Alternativamente, se houver apenas algumas contagens, estas poderiam ser inseridas como abaixo em um tibble (data frame com alguns ajustes para deixá-lo mais amigável). Em qualquer caso você precisará ter uma coluna com um identificador de cluster, que corresponde aos dados de sua pesquisa, e outra coluna com o número de agregados familiares em cada grupo.\n\n## definir o número de agregados familiares em cada cluster\ncluster_counts &lt;- tibble(cluster = c(\"village_1\", \"village_2\", \"village_3\", \"village_4\", \n                                     \"village_5\", \"village_6\", \"village_7\", \"village_8\",\n                                     \"village_9\", \"village_10\"), \n                         households = c(700, 400, 600, 500, 300, \n                                        800, 700, 400, 500, 500))\n\n\n\nLimpar dados\nAbaixo, garantimos que a coluna de datas esteja no formato apropriado. Há várias outras maneiras de fazer isso (veja a página Trabalhando com datas para mais detalhes), porém a utilização do dicionário para definir datas é rápida e fácil.\nTambém criamos uma variável de faixa etária utilizando a função age_categories() do pacote epikit - veja a seção limpeza de dados para mais detalhes. Além disso, criamos uma variável do tipo caractere, que define em qual distrito se encontram os vários agrupamentos.\nFinalmente, recodificamos todas as variáveis yes/no (sim/não) para variáveis TRUE/FALSE (Verdadeiro/Falso) - caso contrário, estas não poderão ser utilizadas pelas funções de proporção survey.\n\n## selecione os nomes das variáveis de data no dicionário \nDATEVARS &lt;- survey_dict %&gt;% \n  filter(type == \"date\") %&gt;% \n  filter(name %in% names(survey_data)) %&gt;% \n  ## filtro para corresponder aos nomes das colunas de seus dados\n  pull(name) # selecione variáveis de data\n  \n## mudança para data\nsurvey_data &lt;- survey_data %&gt;%\n  mutate(across(all_of(DATEVARS), as.Date))\n\n\n## adicionar aqueles com apenas idade em meses à variável ano (dividir por doze)\nsurvey_data &lt;- survey_data %&gt;% \n  mutate(age_years = if_else(is.na(age_years), \n                             age_months / 12, \n                             age_years))\n\n## definir a variável de faixa etária\nsurvey_data &lt;- survey_data %&gt;% \n     mutate(age_group = epikit::age_categories(age_years, \n                                    breakers = c(0, 3, 15, 30, 45)\n                                    ))\n\n\n## criar uma variável do tipo caractere baseada em grupos de uma variável diferente\nsurvey_data &lt;- survey_data %&gt;% \n  mutate(health_district = case_when(\n    cluster_number %in% c(1:5) ~ \"district_a\", \n    TRUE ~ \"district_b\"\n  ))\n\n\n## selecionar nomes de variáveis yes/no do dicionário\nYNVARS &lt;- survey_dict %&gt;% \n  filter(type == \"yn\") %&gt;% \n  filter(name %in% names(survey_data)) %&gt;% \n  ## filtro para corresponder aos nomes das colunas de seus dados\n  pull(name) # selecionar variáveis yn (yes/no)\n  \n## recodificação\nsurvey_data &lt;- survey_data %&gt;%\n  mutate(across(all_of(YNVARS), \n                str_detect, \n                pattern = \"yes\"))\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `across(all_of(YNVARS), str_detect, pattern = \"yes\")`.\nCaused by warning:\n! The `...` argument of `across()` is deprecated as of dplyr 1.1.0.\nSupply arguments directly to `.fns` through an anonymous function instead.\n\n  # Previously\n  across(a:b, mean, na.rm = TRUE)\n\n  # Now\n  across(a:b, \\(x) mean(x, na.rm = TRUE))",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Analises de pesquisa de questionários (*survey*)</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.pt.html#dados-da-pesquisa",
    "href": "new_pages/survey_analysis.pt.html#dados-da-pesquisa",
    "title": "26  Analises de pesquisa de questionários (survey)",
    "section": "26.3 Dados da pesquisa",
    "text": "26.3 Dados da pesquisa\nExistem inúmeras técnicas de amostragem que podem ser usados para pesquisas. Aqui demonstraremos o código para: - Estratificado - Conglomerados (Cluster) - Estratificado e Conglomerados\nComo descrito acima (dependendo de como você projeta seu questionário) os dados para cada nível seriam exportados como um conjunto separado de dados do Kobo. Em nosso exemplo, há um nível para domicílio e um nível para indivíduos dentro desses domicílios.\nEstes dois níveis estão ligados por um identificador único. Para um conjunto de dados Kobo esta variável é “_index” a nível de domicílios, que corresponde ao “_parent_index” a nível individual. Isto criará novas linhas para domicílio com cada indivíduo correspondente. Para maiores detalhes, veja a seção do manual sobre união de bases (https://epirhandbook.com/joining-data.html).\n\n## juntar os dados individuais e de domicílio para formar um conjunto completo de dados\nsurvey_data &lt;- left_join(survey_data_hh, \n                         survey_data_indiv,\n                         by = c(\"_index\" = \"_parent_index\"))\n\n\n## criar um identificador único, combinando as peças dos dois níveis \nsurvey_data &lt;- survey_data %&gt;% \n     mutate(uid = str_glue(\"{index}_{index_y}\"))",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Analises de pesquisa de questionários (*survey*)</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.pt.html#tempo-de-observação",
    "href": "new_pages/survey_analysis.pt.html#tempo-de-observação",
    "title": "26  Analises de pesquisa de questionários (survey)",
    "section": "26.4 Tempo de observação",
    "text": "26.4 Tempo de observação\nPara pesquisas de mortalidade, queremos agora saber quanto tempo cada indivíduo esteve presente no local, para podermos calcular um taxa de mortalidade para nosso período de interesse. Isto não é relevante para todas, mas particularmente para pesquisas de mortalidade, isso é importante, pois são conduzidas frequentemente entre populações móveis ou deslocadas.\nPara isso, definimos primeiro nosso período de tempo de interesse, também conhecido como período de retordo, ou período de recall (i.e. o tempo que os participantes são instruídos a se reportarem quando respondem as perguntas). Podemos então utilizar este período para definir datas inadequadas para o ausência, ou seja, se as mortes forem relatadas fora do período de interesse.\n\n## definir o início/fim do período de recall\n## pode ser alterado para variáveis de data do conjunto de dados \n## (por exemplo, questionário de data de chegada e data)\nsurvey_data &lt;- survey_data %&gt;% \n  mutate(recall_start = as.Date(\"2018-01-01\"), \n         recall_end   = as.Date(\"2018-05-01\")\n  )\n\n\n# estabelecer datas inadequadas para NA com base em regras \n## por exemplo, chegadas antes do início, partidas após o fim\nsurvey_data &lt;- survey_data %&gt;%\n      mutate(\n           arrived_date = if_else(arrived_date &lt; recall_start, \n                                 as.Date(NA),\n                                  arrived_date),\n           birthday_date = if_else(birthday_date &lt; recall_start,\n                                  as.Date(NA),\n                                  birthday_date),\n           left_date = if_else(left_date &gt; recall_end,\n                              as.Date(NA),\n                               left_date),\n           death_date = if_else(death_date &gt; recall_end,\n                               as.Date(NA),\n                               death_date)\n           )\n\nPodemos usar nossas variáveis de data para definir datas de inicio e fim para cada individuo. Usamos a função find_start_date() do sitrep para apurar as causas para as datas e depois usar isso para calcular a diferença entre os dias (pessoa - tempo).\nData de início: Primeiro evento de chegada apropriado dentro de seu período de recall, ou o início de seu período de recall (que você define em previamente), ou uma data após o início do recall, se aplicável (por exemplo chegadas ou nascimentos).\nData final: Primeiro evento de partida apropriado dentro de seu período de recall, ou o final de seu período de recall, ou uma data antes do final do recall se aplicável (por exemplo, partidas e mortes).\n\n## criar novas variáveis para datas/causas de início e fim\nsurvey_data &lt;- survey_data %&gt;% \n     ## escolher a data mais próxima informada na pesquisa\n     ## de nascimentos, chegadas ao domicílio e chegadas ao local\n     find_start_date(\"birthday_date\",\n                  \"arrived_date\",\n                  period_start = \"recall_start\",\n                  period_end   = \"recall_end\",\n                  datecol      = \"startdate\",\n                  datereason   = \"startcause\" \n                 ) %&gt;%\n     ## escolher a data mais próxima informada na pesquisa\n     ## das partidas do local, morte e fim do estudo\n     find_end_date(\"left_date\",\n                \"death_date\",\n                period_start = \"recall_start\",\n                period_end   = \"recall_end\",\n                datecol      = \"enddate\",\n                datereason   = \"endcause\" \n               )\n\n\n## rotular aqueles que estavam presentes no início/fim (exceto nascimentos/mortes)\nsurvey_data &lt;- survey_data %&gt;% \n     mutate(\n       ## preencher a data de início para ser o início do período de recall (para aqueles vazios) \n       startdate = if_else(is.na(startdate), recall_start, startdate), \n       ## definir a causa inicial para apresentar no início se for igual ao período de recall \n       ## a menos que seja igual à data de nascimento \n       startcause = if_else(startdate == recall_start & startcause != \"birthday_date\",\n                              \"Present at start\", startcause), \n       ## preencher a data final para ser o fim do período de recall (para aqueles vazios) \n       enddate = if_else(is.na(enddate), recall_end, enddate), \n       ## definir a causa final a apresentar ao fim se for igual ao recall final \n       ## a menos que seja igual à data da morte\n       endcause = if_else(enddate == recall_end & endcause != \"death_date\", \n                            \"Present at end\", endcause))\n\n\n## Define o tempo de observação em dias\nsurvey_data &lt;- survey_data %&gt;% \n  mutate(obstime = as.numeric(enddate - startdate))",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Analises de pesquisa de questionários (*survey*)</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.pt.html#ponderação",
    "href": "new_pages/survey_analysis.pt.html#ponderação",
    "title": "26  Analises de pesquisa de questionários (survey)",
    "section": "26.5 Ponderação",
    "text": "26.5 Ponderação\nÉ importante que você remova observações errôneas antes de acrescentar pesos à pesquisa. Por exemplo, se você tiver registros com tempos de observação negativos, precisará verificá-los (você pode fazer isso com a funçãoassert_positive_timespan() do pacote sitrep. Outra questão é se você quiser eliminar linhas vazias (por exemplo, com drop_na(uid)) ou remover duplicidades (consulte a seção do manual sobre Eliminando duplicidades para maiores detalhes). Aqueles sem consentimento também precisarão ser removidos.\nNeste exemplo, filtramos para os casos que queremos remover e os armazenamos em um data frame separado - desta forma podemos descrever aqueles que foram excluídos da pesquisa. Em seguida, utilizamos a função anti_join() do dplyr para remover estes casos descartados de nossos dados de pesquisa.\nPERIGO: Você não pode ter valores ausentes em sua variável de peso, ou qualquer uma das variáveis relevantes para o projeto de sua pesquisa (por exemplo, idade, sexo, estratos ou variáveis de agrupamento).\n\n## armazene os casos que deseja remover para que possa descrevê-los (por exemplo, sem consentimento) \n## ou local/cluster errados)\ndropped &lt;- survey_data %&gt;% \n  filter(!consent | is.na(startdate) | is.na(enddate) | village_name == \"other\")\n\n## usar os casos descartados para remover as linhas não utilizadas do conjunto de dados da pesquisa \nsurvey_data &lt;- anti_join(survey_data, dropped, by = names(dropped))\n\nComo mencionado acima, demonstramos como adicionar pesos para as três formas de amostragem (estratificado, conglomerado e conglomerado estratificado). Estas exigem informações sobre a população de origem e/ou os aglomerados pesquisados. Usaremos o código do “conglomerado estratificado” para este exemplo, mas escolha o que for mais apropriado para seu modelo de estudo.\n\n# estratificado ----------------------------------------------------------------\n# criar uma variável chamada \"surv_weight_strata\n# contém pesos para cada indivíduo - por faixa etária, sexo e distrito de saúde\nsurvey_data &lt;- add_weights_strata(x = survey_data,\n                                         p = population,\n                                         surv_weight = \"surv_weight_strata\",\n                                         surv_weight_ID = \"surv_weight_ID_strata\",\n                                         age_group, sex, health_district)\n\n## por conglomerados (cluster) ---------------------------------------------------------------------\n\n# obter o número de pessoas entrevistadas por domicílio\n# adiciona uma variável com contagens da variável de índice doméstico\nsurvey_data &lt;- survey_data %&gt;%\n  add_count(index, name = \"interviewed\")\n\n\n## criar pesos para o conglomerados (cluster)\nsurvey_data &lt;- add_weights_cluster(x = survey_data,\n                                          cl = cluster_counts,\n                                          eligible = member_number,\n                                          interviewed = interviewed,\n                                          cluster_x = village_name,\n                                          cluster_cl = cluster,\n                                          household_x = index,\n                                          household_cl = households,\n                                          surv_weight = \"surv_weight_cluster\",\n                                          surv_weight_ID = \"surv_weight_ID_cluster\",\n                                          ignore_cluster = FALSE,\n                                          ignore_household = FALSE)\n\n\n# estratificado e conglomerado (cluster) ------------------------------------------------------\n# criar um peso de pesquisa para o cluster e os estratos\nsurvey_data &lt;- survey_data %&gt;%\n  mutate(surv_weight_cluster_strata = surv_weight_strata * surv_weight_cluster)",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Analises de pesquisa de questionários (*survey*)</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.pt.html#objetos-de-delineamento-de-pesquisa",
    "href": "new_pages/survey_analysis.pt.html#objetos-de-delineamento-de-pesquisa",
    "title": "26  Analises de pesquisa de questionários (survey)",
    "section": "26.6 Objetos de delineamento de pesquisa",
    "text": "26.6 Objetos de delineamento de pesquisa\nCrie um objeto de pesquisa de acordo com seu projeto de estudo. Utilizado da mesma forma que os data frames para calcular as proporções de peso etc. Certifique-se de que todas as variáveis necessárias sejam criadas antes disso.\nHá quatro opções, comente aquelas que você não utiliza: - Aleatório simples - Estratificado - Conglomerado (cluster) - Conglomerado estratificado\nPara este modelo - vamos fingir que agrupamos as pesquisas em dois estratos separados (distritos de saúde A e B). Portanto, para obter estimativas gerais, precisamos ter pesos combinados de conglomerados e estratos.\nComo mencionado anteriormente, há dois pacotes disponíveis para fazer isto. O clássico é o survey e depois há um pacote de “roupagem” (wrapper) chamado srvyr que torna os objetos e funções mais fáceis de arrumar. Demonstraremos ambos, mas observe que a maioria dos códigos neste capítulo utilizará objetos baseados no srvyr. A única exceção é que o pacote gtsummary só aceita objetos do survey.\n\n26.6.1 Pacote survey\nO pacote survey utiliza, do forma eficaz, codificação em R base, e por isso não é possível utilizar os pipes (%&gt;%) ou outra sintaxe do dplyr. Com o pacote survey, utilizamos a função svydesign() para definir um objeto de pesquisa com agrupamentos (cluster), pesos e estratificações apropriados.\nNOTA: precisamos utilizar o til (~) em frente às variáveis, pois o pacote usa a sintaxe R base para atribuição variáveis baseada em fórmulas.\n\n# aleatório simples ------------------------------------------------------------\nbase_survey_design_simple &lt;- svydesign(ids = ~1, # 1 para nenhuma identificação de cluster\n                   weights = NULL,               # sem adição de pesos\n                   strata = NULL,                # amostragem simples (não estratificada)\n                   data = survey_data            # especificar a base de dados\n                  )\n\n## estratificado ---------------------------------------------------------------\nbase_survey_design_strata &lt;- svydesign(ids = ~1,  # 1 para nenhuma identificação de cluster\n                   weights = ~surv_weight_strata, # variável de peso criada acima\n                   strata = ~health_district,     # amostragem estratificada por distrito\n                   data = survey_data             # especificar a base de dados\n                  )\n\n# conglomerado ---------------------------------------------------------------------\nbase_survey_design_cluster &lt;- svydesign(ids = ~village_name, # identificação do cluster\n                   weights = ~surv_weight_cluster, # variável de peso criada acima\n                   strata = NULL,                 # amostragem simples (não estratificada)\n                   data = survey_data              # especificar a base de dados\n                  )\n\n# conglomerado estratificado --------------------------------------------------------\nbase_survey_design &lt;- svydesign(ids = ~village_name,      # identificação do conglomerado\n                   weights = ~surv_weight_cluster_strata, # variável de peso criada acima\n                   strata = ~health_district,             # amostragem estratificada por distrito\n                   data = survey_data                     # especificar a base de dados\n                  )\n\n\n\n26.6.2 Pacote srvyr\nCom o pacote srvyr* podemos utilizar a função as_survey_design(), que tem os mesmos argumentos exemplificados acima, mas permite pipes (%&gt;%), e assim não precisamos utilizar o til (~).\n\n# aleatório simples ------------------------------------------------------------\nsurvey_design_simple &lt;- survey_data %&gt;% \n  as_survey_design(ids = 1, # 1 para nenhuma identificação de cluster\n                   weights = NULL, # sem adição de pesos\n                   strata = NULL # amostragem simples (não estratificada)\n                  )\n## estratificado ---------------------------------------------------------------\nsurvey_design_strata &lt;- survey_data %&gt;%\n  as_survey_design(ids = 1, # 1 para nenhuma identificação de cluster\n                   weights = surv_weight_strata, # variável de peso criada acima\n                   strata = health_district # amostragem estratificada por distrito\n                  )\n## cluster ---------------------------------------------------------------------\nsurvey_design_cluster &lt;- survey_data %&gt;%\n  as_survey_design(ids = village_name, # identificação do cluster\n                   weights = surv_weight_cluster, # variável de peso criada acima\n                   strata = NULL # amostragem simples (não estratificada)\n                  )\n\n# cluster estratificado --------------------------------------------------------\nsurvey_design &lt;- survey_data %&gt;%\n  as_survey_design(ids = village_name, # identificação do cluster\n                   weights = surv_weight_cluster_strata, # variável de peso criada acima\n                   strata = health_district # amostragem estratificada por distrito\n                  )",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Analises de pesquisa de questionários (*survey*)</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.pt.html#análise-descritiva",
    "href": "new_pages/survey_analysis.pt.html#análise-descritiva",
    "title": "26  Analises de pesquisa de questionários (survey)",
    "section": "26.7 Análise descritiva",
    "text": "26.7 Análise descritiva\nA análise descritiva básica e a visualização são amplamente cobertas em outros capítulos do manual, portanto, não vamos nos deter aqui. Para detalhes veja os capítulos Tabelas Descritivas, Testes Estatísticos, Tabelas para Apresentação,Introdução ao ggplot e Relatórios em R markdown.\nNesta seção, vamos nos concentrar em como investigar o viés em sua amostra e em como visualizá-lo. Também vamos visualizar o fluxo populacional em um ambiente de pesquisa usando diagramas aluviais/sankey.\nEm geral, você deve considerar incluir as seguintes análises descritivas:\n\nNúmero final de agrupamentos, domicílios e indivíduos incluídos.\nNúmero de indivíduos excluídos e os motivos de exclusão\nNúmero médio (intervalo) de domicílios por agrupamento e de indivíduos por doméstico\n\n\n26.7.1 Viés de amostras\nCompare as proporções em cada faixa etária entre sua amostra e a população de origem. Isto é importante para poder destacar um potencial viés de amostragem. Da mesma forma, você poderia repetir esta análise nas distribuições por sexo.\nNote que estes p-valores são apenas indicativos e uma discussão descritiva (ou visualização em pirâmides etárias abaixo) dadistribuições de sua amostra de estudo, em comparação com a população de origem, é mais importante do que o próprio teste binomial. Isto se deve ao fato de que o tamanho da amostra levará, na maioria das vezes, a diferenças que podem ser irrelevantes após a ponderação dos dados.\n\n## contagem e proporção da população estudada\nag &lt;- survey_data %&gt;% \n  group_by(age_group) %&gt;% \n  drop_na(age_group) %&gt;% \n  tally() %&gt;% \n  mutate(proportion = n / sum(n), \n         n_total = sum(n))\n\n## contagem e proporção da população original\npropcount &lt;- population %&gt;% \n  group_by(age_group) %&gt;%\n    tally(population) %&gt;%\n    mutate(proportion = n / sum(n))\n\n## unir as colunas de duas tabelas, agrupar por idade, e executar um \n## teste binomial para ver se n/total é significativamente diferente da \n## proporção populacional.\n  ## sufixo aqui adicionado ao texto no final das colunas em cada um dos dois \n  ## conjuntos de dados\nleft_join(ag, propcount, by = \"age_group\", suffix = c(\"\", \"_pop\")) %&gt;%\n  group_by(age_group) %&gt;%\n  ## broom::tidy(binom.test()) faz um data frame a partir do teste binomial e\n  ## adicionará as variáveis p.value (p-valor), parameter (parâmetro), \n  ## conf.low (intervalo de confiança inferior), method (método, o tipo de teste),\n  ## conf.high (intervalo de confiança superior) e alternative (alternativa à hipotese nula).\n  ## Aqui usaremos apenas p.value. Você pode incluir outras colunas se quiser\n  ## informar intervalos de confiança\n  mutate(binom = list(broom::tidy(binom.test(n, n_total, proportion_pop)))) %&gt;%\n  unnest(cols = c(binom)) %&gt;% # important for expanding the binom.test data frame\n  mutate(proportion_pop = proportion_pop * 100) %&gt;%\n  ## Ajustando os p-valor para corrigir os falsos positivos \n  ## (testando várias faixas etárias). Isto só fará diferença\n  ## se você tem muitas categorias etárias\n  mutate(p.value = p.adjust(p.value, method = \"holm\")) %&gt;%\n                      \n  ## somente mostrar o p-valor acima de  0.001 (inferiores, mostrar como 0.001)\n  mutate(p.value = ifelse(p.value &lt; 0.001, \n                          \"&lt;0.001\", \n                          as.character(round(p.value, 3)))) %&gt;% \n  \n  ## renomear as colunas de forma apropriada\n  select(\n    \"Faixa-etária\" = age_group,\n    \"População de estudo (n)\" = n,\n    \"População de estudo (%)\" = proportion,\n    \"População fonte (n)\" = n_pop,\n    \"População fonte (%)\" = proportion_pop,\n    \"P-valor\" = p.value\n  )\n\n# A tibble: 5 × 6\n# Groups:   Faixa-etária [5]\n  `Faixa-etária` `População de estudo (n)` `População de estudo (%)`\n  &lt;chr&gt;                              &lt;int&gt;                     &lt;dbl&gt;\n1 0-2                                   12                    0.0256\n2 3-14                                  42                    0.0896\n3 15-29                                 64                    0.136 \n4 30-44                                 52                    0.111 \n5 45+                                  299                    0.638 \n# ℹ 3 more variables: `População fonte (n)` &lt;dbl&gt;, `População fonte (%)` &lt;dbl&gt;,\n#   `P-valor` &lt;chr&gt;\n\n\n\n\n26.7.2 Pirâmides demográficas\nAs pirâmides demográficas (ou de idade-sexo) são uma maneira fácil de visualizar a distribuição em sua população pesquisada. Também vale a pena considerar a criação de Tabelas Descritivas de idade e sexo por estratos de pesquisa. Demonstraremos utilizando o pacote apyramid, pois ele permite proporções ponderadas utilizando nosso objeto de pesquisa criado acima. Outras opções para criar Pirâmides Demográficas são amplamente cobertas nesse capítulo do manual. Também utilizaremos uma função wrapper da apyramid chamada age_pyramid() que economiza algumas linhas de código para produzir um gráfico comproporções.\nComo no teste binomial formal de diferença, visto acima na seção de viés de amostragem, estamos interessados aqui em visualizar se nossa população amostrada é substancialmente diferente da população original e se a ponderação corrige esta diferença. Para isso, usaremos o pacote patchwork para mostrar nossas visualizações ggplot lado a lado; para detalhes, veja a seção sobre combinação de lotes no capítulo dicas ggplot do manual. Visualizaremos nossa população original, nossa população não ponderada de pesquisa e nossa população ponderada de pesquisa. Você também pode considerar a visualização por cada estrato de sua pesquisa - em nosso exemplo aqui, isso seria utilizando o argumento stack_by = \"health_district\" (veja `?age_pyramid’ para detalhes).\nNOTA: Os eixos x e y são invertidos em pirâmides\n\n## definir limites e rótulos do eixo x -----------------------------------------\n## (atualize estes números para serem os valores adequado ao seu gráfico)\nmax_prop &lt;- 35      # escolha a maior proporção que quer mostrar\nstep &lt;- 5           # escolha o espaço que quer mostrar entre as legendas\n\n## esta parte define o vetor usando os números acima com quebras de eixo\nbreaks &lt;- c(\n    seq(max_prop/100 * -1, 0 - step/100, step/100), \n    0, \n    seq(0 + step / 100, max_prop/100, step/100)\n    )\n\n## esta parte define o vetor usando os números acima com limites de eixo\nlimits &lt;- c(max_prop/100 * -1, max_prop/100)\n\n## esta parte define o vetor usando os números acima com legendas de eixo\nlabels &lt;-  c(\n      seq(max_prop, step, -step), \n      0, \n      seq(step, max_prop, step)\n    )\n\n\n## criar gráficos individualmente ---------------------------------------------\n\n## Traçar a população de original \n## nb: precisa de ser comprimido para a população em geral (isto é, removendo distritos de saúde)\nsource_population &lt;- population %&gt;%\n  ## garantir que a idade e o sexo sejam fatores\n  mutate(age_group = factor(age_group, \n                            levels = c(\"0-2\", \n                                       \"3-14\", \n                                       \"15-29\",\n                                       \"30-44\", \n                                       \"45+\")), \n         sex = factor(sex)) %&gt;% \n  group_by(age_group, sex) %&gt;% \n  ## somar as contagens para cada distrito sanitário em conjunto\n  summarise(population = sum(population)) %&gt;% \n  ## remover o agrupamento para poder calcular a proporção total\n  ungroup() %&gt;% \n  mutate(proportion = population / sum(population)) %&gt;% \n  ## exibir a pirâmide \n  age_pyramid(\n            age_group = age_group, \n            split_by = sex, \n            count = proportion, \n            proportional = TRUE) +\n  ## mostrar apenas a legenda do eixo y (caso contrário será repetida nos três gráficos)\n  labs(title = \"População de origem\", \n       y = \"\", \n       x = \"Faixa-etária (anos)\") + \n  ## fazer o eixo x o mesmo para todas os gráfcos\n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n  \n  \n## Traçar a população não ponderada da amostra \nsample_population &lt;- age_pyramid(survey_data, \n                 age_group = \"age_group\", \n                 split_by = \"sex\",\n                 proportion = TRUE) + \n  ## mostrar apenas a legenda do eixo x (caso contrário será repetida nos três gráficos)\n  labs(title = \"População amostrada sem ponderação\", \n       y = \"Proporção (%)\", \n       x = \"\") + \n  ## fazer o eixo x o mesmo para todas os gráfcos\n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n\n\n## Traçar a população de amostra ponderada \nweighted_population &lt;- survey_design %&gt;% \n  ## garantir que as variáveis sejam fatores\n  mutate(age_group = factor(age_group), \n         sex = factor(sex)) %&gt;%\n  age_pyramid(\n    age_group = \"age_group\",\n    split_by = \"sex\", \n    proportion = TRUE) +\n  ## mostrar apenas a legenda do eixo x (caso contrário será repetida nos três gráficos)\n  labs(title = \"População amostrada ponderada\", \n       y = \"\", \n       x = \"\")  + \n  ## fazer o eixo x o mesmo para todas os gráfcos\n  scale_y_continuous(breaks = breaks, \n    limits = limits, \n    labels = labels)\n\n## ccombinar os três gráficos   ------------------------------------------------\n## combinar três gráficos próximos uns aos outros usando + \nsource_population + sample_population + weighted_population + \n  ## mostrar apenas uma legenda e definir o tema\n  ## observe o uso de & para combinar o tema com o plot_layout()\n  plot_layout(guides = \"collect\") & \n  theme(legend.position = \"bottom\",                    # mover legenda para baixo\n        legend.title = element_blank(),                # remover o título\n        text = element_text(size = 18),                # dimensionar o texto\n        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1) # girar texto do eixo x\n       )\n\n\n\n\n\n\n\n\n\n\n26.7.3 Diagrama aluvial/sankey\nA visualização de pontos de partida e resultados para indivíduos pode ser muito útil para se ter uma visão geral. Há uma aplicação bastante óbvia para populações móveis, porém existem inúmeras outras aplicações, tais como coortes ou qualquer outra situação em que há transições nos estados para indivíduos. Estes diagramas são conhecidos por vários nomes diferentes, incluindo aluvial, sankey e conjuntos paralelos - os detalhes estão no capítulo sobre Diagramas e Gráficos.\n\n## resuma os dados \nflow_table &lt;- survey_data %&gt;%\n  count(startcause, endcause, sex) %&gt;%  # faz contagem\n  gather_set_data(x = c(\"startcause\", \"endcause\"))     # muda o formato para gráfico\n\n\n## trace um gráfico \n  ## no eixo x estão as causas do início e fim\n  ## a função gather_set_datagera um ID para cada combinação\n  ## dividindo (splitting) pelo y te da um combo de possibilidades de início/fim \n  ## valor (value) como \"n\" fornece a contagem (também pode ser usado com proporção)\nggplot(flow_table, aes(x, id = id, split = y, value = n)) +\n  ##linhas coloridas segundo sexo\n  geom_parallel_sets(aes(fill = sex), alpha = 0.5, axis.width = 0.2) +\n  ## preenche as caixas de rotulagem com cinza\n  geom_parallel_sets_axes(axis.width = 0.15, fill = \"grey80\", color = \"grey80\") +\n  ## muda a cor do tetxo e ângulo (precisa ser ajustado)\n  geom_parallel_sets_labels(color = \"black\", angle = 0, size = 5) +\n  ## remove rótulos dos eixos\n  theme_void()+\n  ## move a legenda para baixo\n  theme(legend.position = \"bottom\")",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Analises de pesquisa de questionários (*survey*)</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.pt.html#proporções-ponderadas",
    "href": "new_pages/survey_analysis.pt.html#proporções-ponderadas",
    "title": "26  Analises de pesquisa de questionários (survey)",
    "section": "26.8 Proporções ponderadas",
    "text": "26.8 Proporções ponderadas\nEsta seção detalha como produzir tabelas para contagens e proporções ponderadas, com os intervalos de confiança associados e delineamento. Existem quatro opções diferentes, utilizando funções dos seguintes pacotes: survey, srvyr, sitrep e gtsummary. Para para produzir uma tabela de estilo epidemiológico padrão com mínimo de código, nós recomendamos a função sitrep - que é um wrapper para códigos srvyr; note, entretanto, que isso ainda não está no CRAN e pode mudar no futuro. Caso contrário, o código survey será provavelmente o mais estável a longo prazo, enquanto srvyr caberá melhor dentro do fluxos de trabalho. Embora as funções gtsummary tenham um grande potencial, elas parecem ser experimentais e incompletas no momento em que da escrita deste manual.\n\n26.8.1 Pacote survey\nPodemos utilizar a função svyciprop() do survey para obter proporções ponderadas e intervalos de confiança de 95%. Um delineamento apropriado pode ser extraído utilizando o svymean() em vez da função svyprop(). Vale notar que a função svyprop() parece apenas aceitar variáveis entre 0 e 1 (ou TRUE/FALSE), então, variáveis categóricas não funcionarão.\nNOTA: Funções do survey também aceitam objetos srvyr mas aqui usamos o objeto de delineamento survey apenas por uma questão de consistência\n\n##  produção contagens ponderadas \nsvytable(~died, base_survey_design)\n\ndied\n     FALSE       TRUE \n1406244.43   76213.01 \n\n##  produção proporções ponderadas \nsvyciprop(~died, base_survey_design, na.rm = T)\n\n              2.5% 97.5%\ndied 0.0514 0.0208  0.12\n\n## obtem o efeito de delineamento  \nsvymean(~died, base_survey_design, na.rm = T, deff = T) %&gt;% \n  deff()\n\ndiedFALSE  diedTRUE \n 3.755508  3.755508 \n\n\nPodemos combinar as funções de survey mostradas acima em um função chamada svy_prop; e podemos então utilize essa função junto com o map() do pacote purrr para repetir sobre várias variáveis e criar uma tabela. Veja o capítulo Iterações e loops para mais detalhes do pacote purrr.\n\n# Definir função para calcular contagens ponderadas, proporções, IC e efeito de delineamento\n# x é a variável entre aspas \n# O delineamento é seu objeto de desenho de pesquisa\n\nsvy_prop &lt;- function(design, x) {\n  \n  ## colocar as variáveis de interesse em uma fórmula\n  form &lt;- as.formula(paste0( \"~\" , x))\n  ## manter apenas a coluna TRUE do svytable\n  weighted_counts &lt;- svytable(form, design)[[2]]\n  ## calcular proporções (multiplicar por 100 para obter porcentagens)\n  weighted_props &lt;- svyciprop(form, design, na.rm = TRUE) * 100\n  ## extrair os intervalos de confiança e multiplicar para obter porcentagens\n  weighted_confint &lt;- confint(weighted_props) * 100\n  ## use svymean para calcular o efeito do delinemanto e mantenha apenas a coluna TRUE\n  design_eff &lt;- deff(svymean(form, design, na.rm = TRUE, deff = TRUE))[[TRUE]]\n  \n  ## combinar em um único dataframe\n  full_table &lt;- cbind(\n    \"Variável\"        = x,\n    \"Contagens\"           = weighted_counts,\n    \"Proporção\"      = weighted_props,\n    weighted_confint, \n    \"Efeito de delineamento\"   = design_eff\n    )\n  \n  ## retorna tabela como um dataframe\n  full_table &lt;- data.frame(full_table, \n             ## remover os nomes das variáveis das linhas (é uma coluna separada agora)\n             row.names = NULL)\n  \n  ## mudar números de volta ao formato numérico\n  full_table[ , 2:6] &lt;- as.numeric(full_table[, 2:6])\n  \n  ## retornar o dataframe\n  full_table\n}\n\n## repetir em diversar variáveis para criar uma tabela  \npurrr::map(\n  ## definir variáveis de interesse\n  c(\"left\", \"died\", \"arrived\"), \n  ## função de estado usando e argumentos para essa função (delineamento)\n  svy_prop, design = base_survey_design) %&gt;% \n  ## fundir lista em um único data frame\n  bind_rows() %&gt;% \n  ## arredondar \n  mutate(across(where(is.numeric), round, digits = 1))\n\n  Variável Contagens Proporção X2.5. X97.5. Efeito.de.delineamento\n1     left  701199.1      47.3  39.2   55.5                    2.4\n2     died   76213.0       5.1   2.1   12.1                    3.8\n3  arrived  761799.0      51.4  40.9   61.7                    3.9\n\n\n\n\n26.8.2 Pacote srvyr\nCom srvyr podemos usar a sintaxe dplyr para criar uma tabela. Note que a função survey_mean() é utilizada e o argumento da proporção é especificado, e também que a mesma função é utilizada para calcular o efeito do delineamento. Isto porque srvyr envolve ambas as funções do pacote survey svyciprop() e svymean(), que são utilizadas na seção acima.\nNOTA: Não parece ser possível obter proporções a partir de variáveis categóricas utilizando srvyr, se você precisar disto então verifique a seção abaixo usando sitrep\n\n## usar o objeto delineado srvyr\nsurvey_design %&gt;% \n  summarise(\n    ## produzir as contagens ponderadas\n    counts = survey_total(died), \n    ## produzir proporções ponderadas e intervalos de confiança \n    ## multiplicar por 100 para obter uma porcentagem \n    props = survey_mean(died, \n                        proportion = TRUE, \n                        vartype = \"ci\") * 100, \n    ## produzir o efeito de delineamento\n    deff = survey_mean(died, deff = TRUE)) %&gt;% \n  ## manter apenas as fileiras de interesse\n  ## (remove erros padrão e repete o cálculo de proporção)\n  select(counts, props, props_low, props_upp, deff_deff)\n\n# A tibble: 1 × 5\n  counts props props_low props_upp deff_deff\n   &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1 76213.  5.14      2.08      12.1      3.76\n\n\nTambém aqui poderíamos escrever uma função para então reiterar sobre múltiplas variáveis usando o pacote purrr. Veja o capítulo do manual Iterações e loops para detalhes sobre purrr.\n\n# definir função para calcular contagens ponderadas, proporções, IC e delineamento\n# o desenho é seu objeto de desenho de pesquisa\n# x é a variável entre aspas \n\n\nsrvyr_prop &lt;- function(design, x) {\n  \n  summarise(\n    ## usando o objeto delimitado de pesquisa\n    design, \n    ## produzir as contagens ponderadas\n    counts = survey_total(.data[[x]]), \n    ## produzir as proporções e intervalos de confiaça ponderados\n    ## multiplicar por 100 para obter uma porcentagem \n    props = survey_mean(.data[[x]], \n                        proportion = TRUE, \n                        vartype = \"ci\") * 100, \n    ## produzir o efeito de delineamento\n    deff = survey_mean(.data[[x]], deff = TRUE)) %&gt;% \n  ## adicionar na variável de nome\n  mutate(variable = x) %&gt;% \n  ## manter apenas as linhas de interesse\n  ## (remove erros padrão e repete o cálculo de proporção)\n  select(variable, counts, props, props_low, props_upp, deff_deff)\n  \n}\n  \n\n## reitera em diferentes variáveis para criar uma tabela\npurrr::map(\n  ## define  as variáveis de interesse\n  c(\"left\", \"died\", \"arrived\"), \n  ## função *state* e argumentos para essa função (delineamento)\n  ~srvyr_prop(.x, design = survey_design)) %&gt;% \n  ## unificar lista em uma única data frame\n  bind_rows()\n\n# A tibble: 3 × 6\n  variable  counts props props_low props_upp deff_deff\n  &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n1 left     701199. 47.3      39.2       55.5      2.38\n2 died      76213.  5.14      2.08      12.1      3.76\n3 arrived  761799. 51.4      40.9       61.7      3.93\n\n\n\n\n26.8.3 Pacote sitrep\nA função tab_survey() de sitrep é um wrapper para srvyr, permitindo a criação de tabelas ponderadas com codificação mínima. Também permite calcular proporções ponderadas para variáveis categóricas.\n\n    ## usando o objeto delimitado de pesquisa\nsurvey_design %&gt;% \n  ## passe os nomes das variáveis de interesse não cotadas\n  tab_survey(arrived, left, died, education_level,\n             deff = TRUE,   # calcular o efeito de delineamento\n             pretty = TRUE  # fundir proporção e intervalo de confiança 95%\n             )\n\nWarning: removing 257 missing value(s) from `education_level`\n\n\n# A tibble: 9 × 5\n  variable        value            n  deff ci               \n  &lt;chr&gt;           &lt;chr&gt;        &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;            \n1 arrived         TRUE       761799.  3.93 51.4% (40.9-61.7)\n2 arrived         FALSE      720658.  3.93 48.6% (38.3-59.1)\n3 left            TRUE       701199.  2.38 47.3% (39.2-55.5)\n4 left            FALSE      781258.  2.38 52.7% (44.5-60.8)\n5 died            TRUE        76213.  3.76 5.1% (2.1-12.1)  \n6 died            FALSE     1406244.  3.76 94.9% (87.9-97.9)\n7 education_level higher     171644.  4.70 42.4% (26.9-59.7)\n8 education_level primary    102609.  2.37 25.4% (16.2-37.3)\n9 education_level secondary  130201.  6.68 32.2% (16.5-53.3)\n\n\n\n\n26.8.4 Pacote gtsummary\nCom gtsummary não parece haver ainda funções embutidas para acrescentar intervalos de confiança ou efeito de delineamento. Aqui mostramos como definir uma função para adicionar intervalos de confiança e depois adicionar intervalos de confiança a uma tabela gtsummary criada utilizando a função tbl_svysummary().\n\nconfidence_intervals &lt;- function(data, variable, by, ...) {\n  \n  ## extrair os intervalos de confiança e multiplicar para obter porcentagens\n  props &lt;- svyciprop(as.formula(paste0( \"~\" , variable)),\n              data, na.rm = TRUE)\n  \n  ## extrair os intervalos de confiança \n  as.numeric(confint(props) * 100) %&gt;% ## transformar em número e multiplicar para obter o percentual\n    round(., digits = 1) %&gt;%           ## arredondar para um dígito\n    c(.) %&gt;%                           ## ## extrair os números da matriz\n    paste0(., collapse = \"-\")          ## combinar para caracter único\n}\n\n## usando o objeto delimitado do pacote survey\ntbl_svysummary(base_survey_design, \n               include = c(arrived, left, died),   ## definir variáveis a serem incluídas\n               statistic = list(everything() ~ c(\"{n} ({p}%)\"))) %&gt;% ## definir estatísticas de interesse\n  add_n() %&gt;%  ## adicionar o peso total\n  add_stat(fns = everything() ~ confidence_intervals) %&gt;% ## adicionar intervalos de confiança\n  ## modificar títulos das colunas\n  modify_header(\n    list(\n      n ~ \"**Total ponderado (N)**\",\n      stat_0 ~ \"**Contagem ponderada**\",\n      add_stat_1 ~ \"**95%IC**\"\n    )\n    )\n\n\n\n\n\n\n\n\nCharacteristic\nTotal ponderado (N)\nContagem ponderada1\n95%IC\n\n\n\n\narrived\n1,482,457\n761,799 (51%)\n40.9-61.7\n\n\nleft\n1,482,457\n701,199 (47%)\n39.2-55.5\n\n\ndied\n1,482,457\n76,213 (5.1%)\n2.1-12.1\n\n\n\n1 n (%)",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Analises de pesquisa de questionários (*survey*)</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.pt.html#razões-ponderadas",
    "href": "new_pages/survey_analysis.pt.html#razões-ponderadas",
    "title": "26  Analises de pesquisa de questionários (survey)",
    "section": "26.9 Razões ponderadas",
    "text": "26.9 Razões ponderadas\nDa mesma forma, para relações ponderadas (como para relações de mortalidade) você pode usar o pacote survey ou o pacote srvyr. Você poderia escrever funções (semelhantes àquelas acima) para iterar sobre várias variáveis. Você também poderá criar uma função para o pacote gtsummary, como acima, mas atualmente ela não tem nenhuma funcionalidade embutida.\n\n26.9.1 Pacote survey\n\nratio &lt;- svyratio(~died, \n         denominator = ~obstime, \n         design = base_survey_design)\n\nci &lt;- confint(ratio)\n\ncbind(\n  ratio$ratio * 10000, \n  ci * 10000\n)\n\n      obstime    2.5 %   97.5 %\ndied 5.981922 1.194294 10.76955\n\n\n\n\n26.9.2 Pcaote srvyr\n\nsurvey_design %&gt;% \n  ## razão de pesquisa usada para contabilizar o tempo de observação \n  summarise(\n    mortality = survey_ratio(\n      as.numeric(died) * 10000, \n      obstime, \n      vartype = \"ci\")\n    )\n\n# A tibble: 1 × 3\n  mortality mortality_low mortality_upp\n      &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n1      5.98         0.349          11.6",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Analises de pesquisa de questionários (*survey*)</span>"
    ]
  },
  {
    "objectID": "new_pages/survey_analysis.pt.html#referência",
    "href": "new_pages/survey_analysis.pt.html#referência",
    "title": "26  Analises de pesquisa de questionários (survey)",
    "section": "26.10 Referência",
    "text": "26.10 Referência\nPágina de estatísticas da UCLA\nAnalise dados de questioários gratuitamente\nPacote srvyr\nPacote gtsummary\nEstudo de caso da pesquisa EPIET",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Analises de pesquisa de questionários (*survey*)</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.pt.html",
    "href": "new_pages/survival_analysis.pt.html",
    "title": "27  Análise de sobrevivência",
    "section": "",
    "text": "27.1 Visão Geral\nA análise de sobrevivência centra-se na descrição, para um determinado indivíduo ou grupo de indivíduos, de um ponto definido de evento chamado a falha (ocorrência de uma doença, cura de uma doença, óbito, recaída após resposta ao tratamento…) que ocorre após um período de tempo chamado tempo de falha (ou tempo de seguimento em estudos baseados em coorte/população) durante o qual os indivíduos são observados. Para determinar o tempo de falha, é então necessário definir um tempo de origem (que pode ser a data de inclusão, a data de diagnóstico…).\nO alvo de inferência para a análise de sobrevivência é então o tempo entre uma origem e um evento. Na investigação médica actual, é amplamente utilizado em estudos clínicos para avaliar o efeito de um tratamento, por exemplo, ou na epidemiologia do câncer para avaliar uma grande variedade de medidas de sobrevivência ao câncer.\nÉ normalmente expressa através da probabilidade de sobrevivência que é a probabilidade de o evento de interesse não ter ocorrido por uma duração t.\nCensura: A censura ocorre quando no final do seguimento, alguns dos indivíduos não tiveram o evento de interesse, e assim o seu verdadeiro tempo para o evento é desconhecido. Aqui focaremos principalmente na censura correta, mas para mais detalhes sobre a censura e a análise de sobrevivência em geral, é possível ver referências.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Análise de sobrevivência</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.pt.html#preparação",
    "href": "new_pages/survival_analysis.pt.html#preparação",
    "title": "27  Análise de sobrevivência",
    "section": "27.2 Preparação",
    "text": "27.2 Preparação\n\nCarregar Pacotes\nPara realizar análises de sobrevivência em R, um dos pacotes mais utilizados é o pacote survival. Primeiro o instalamos e depois o carregamos, bem como os outros pacotes que serão utilizados nesta secção:\nNeste manual enfatizamos p_load() do pacman, que instala o pacote se necessário e carrega-o para utilização. Pode também carregar os pacotes instalados com library() do R base . Veja a página em Introdução ao R para mais informações sobre os pacotes R.\nEsta página explora análises de sobrevivência usando a linelist usada na maioria das páginas anteriores e na qual aplicamos algumas alterações para termos dados de sobrevivência adequados.\nImportar conjunto de dados\nImportamos o conjunto de dados de casos de uma epidemia simulada de Ebola. Se quiser acompanhar, clique para fazer o download da linelist “limpa”  (as .rds file). Importe os dados com a função import() do pacote rio (suporta muitos formatos de arquivos .xlsx, .csv, .rds - veja a página Importar e exportar para mais detalhes).\n\n# importar linelist\nlinelist_case_data &lt;- rio::import(\"linelist_cleaned.rds\")\n\n\n\nGestão e transformação de dados\nEm suma, os dados de sobrevivência podem ser descritos como tendo as três características seguintes:\n\na variável ou resposta dependente é o tempo de espera até à ocorrência de um evento bem definido,\nas observações são censuradas, no sentido de que para algumas unidades o evento de interesse não ocorreu no momento em que os dados são analisados, e\nexistem preditores ou variáveis explicativas cujo efeito sobre o tempo de espera desejamos avaliar ou controlar.\n\nAssim, criaremos diferentes variáveis necessárias para respeitar essa estrutura e executar a análise de sobrevivência.\nDefinimos:\n\num novo data frame linelist_surv para esta análise\no nosso evento de interesse como sendo “óbito” (nossa probabilidade de sobrevivência será a probabilidade de estar vivo um certo tempo após o tempo de origem),\no tempo de seguimento (futime) como o tempo entre o tempo de início e o tempo do resultado em dias,\npacientes censurados como aqueles que recuperaram ou para os quais o resultado final não é conhecido, ou seja, o evento “morte” não foi observado (evento=0).\n\nCUIDADO: Uma vez que num estudo de coorte real, a informação sobre a hora de origem e o fim do seguimento é conhecida, dado que são observados indivíduos, removeremos as observações onde a data de início ou a data do desfecho é desconhecida. Também os casos em que a data de início é posterior à data do resultado serão removidos, uma vez que são considerados errados\nDICA: Dado que filtrar para maior que (&gt;) ou menor que (&lt;) uma data pode remover linhas sem valores, aplicar o filtro nas datas erradas também removerá as linhas sem datas.\nDepois utilizamos case_when() para criar uma coluna age_cat_small na qual existem apenas 3 categorias de idade.\n\n#criar um novo dado chamado linelist_surv a partir do linelist_case_data\n\nlinelist_surv &lt;-  linelist_case_data %&gt;% \n     \n  dplyr::filter(\n       # remover observações com datas de início ou desfecho erradas ou vazias\n       date_outcome &gt; date_onset) %&gt;% \n  \n  dplyr::mutate(\n       # criar o evento var que é 1 se o paciente morreu e 0 se ele foi censurado correctamente\n       event = ifelse(is.na(outcome) | outcome == \"Recover\", 0, 1), \n    \n       # criar o var sobre o tempo de seguimento em dias\n       futime = as.double(date_outcome - date_onset), \n    \n       # criar uma nova variável de categoria de idade com apenas 3 níveis de estratos\n       age_cat_small = dplyr::case_when( \n            age_years &lt; 5  ~ \"0-4\",\n            age_years &gt;= 5 & age_years &lt; 20 ~ \"5-19\",\n            age_years &gt;= 20   ~ \"20+\"),\n       \n       # passo anterior criou age_cat_small var como caractere\n       # agora o converte em fator e especifica os níveis.\n       # note que os valores NA continuam a ser NA e não são colocados num nível \"desconhecido\", por exemplo,\n       # uma vez que nas análises seguintes tem de ser removidas.\n       age_cat_small = fct_relevel(age_cat_small, \"0-4\", \"5-19\", \"20+\")\n       )\n\nDICA: Podemos verificar as novas colunas que criamos fazendo um resumo sobre o futime e uma tabulação cruzada entre o evento e o resultado de onde foi criado. Para além desta verificação, é um bom hábito comunicar o tempo médio de seguimento ao interpretar os resultados da análise de sobrevivência.\n\nsummary(linelist_surv$futime)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00    6.00   10.00   11.98   16.00   64.00 \n\n# tabulação cruzada das novas variáveis modificadas \"event\" e \"outcome\" (desfecho) \n# para garantir que o código fazia o que se pretendia\nlinelist_surv %&gt;% \n  tabyl(outcome, event)\n\n outcome    0    1\n   Death    0 1952\n Recover 1547    0\n    &lt;NA&gt; 1040    0\n\n\nAgora fazemos uma tabulação cruzada da nova variável “age_cat_small” e da antiga coluna “age_cat” para garantir atribuições corretas\n\nlinelist_surv %&gt;% \n  tabyl(age_cat_small, age_cat)\n\n age_cat_small 0-4 5-9 10-14 15-19 20-29 30-49 50-69 70+ NA_\n           0-4 834   0     0     0     0     0     0   0   0\n          5-19   0 852   717   575     0     0     0   0   0\n           20+   0   0     0     0   862   554    69   5   0\n          &lt;NA&gt;   0   0     0     0     0     0     0   0  71\n\n\nAgora revisamos as 10 primeiras observações dos dados da linelist_surv, olhando para variáveis específicas (incluindo aquelas recentemente criadas).\n\nlinelist_surv %&gt;% \n  select(case_id, age_cat_small, date_onset, date_outcome, outcome, event, futime) %&gt;% \n  head(10)\n\n   case_id age_cat_small date_onset date_outcome outcome event futime\n1   8689b7           0-4 2014-05-13   2014-05-18 Recover     0      5\n2   11f8ea           20+ 2014-05-16   2014-05-30 Recover     0     14\n3   893f25           0-4 2014-05-21   2014-05-29 Recover     0      8\n4   be99c8          5-19 2014-05-22   2014-05-24 Recover     0      2\n5   07e3e8          5-19 2014-05-27   2014-06-01 Recover     0      5\n6   369449           0-4 2014-06-02   2014-06-07   Death     1      5\n7   f393b4           20+ 2014-06-05   2014-06-18 Recover     0     13\n8   1389ca           20+ 2014-06-05   2014-06-09   Death     1      4\n9   2978ac          5-19 2014-06-06   2014-06-15   Death     1      9\n10  fc15ef          5-19 2014-06-16   2014-07-09 Recover     0     23\n\n\nTambém podemos fazer tabulações cruzadas entre as colunas age_cat_small e gender para obter mais detalhes acercada distribuição dessas novas colunas por gênero. Usamos tabyl() e a função adorn do pacote janitor, como descrito na página Tabelas descritivas.\n\n\nlinelist_surv %&gt;% \n  tabyl(gender, age_cat_small, show_na = F) %&gt;% \n  adorn_totals(where = \"both\") %&gt;% \n  adorn_percentages() %&gt;% \n  adorn_pct_formatting() %&gt;% \n  adorn_ns(position = \"front\")\n\n gender         0-4          5-19           20+          Total\n      f 482 (22.4%) 1,184 (54.9%)   490 (22.7%) 2,156 (100.0%)\n      m 325 (15.0%)   880 (40.6%)   960 (44.3%) 2,165 (100.0%)\n  Total 807 (18.7%) 2,064 (47.8%) 1,450 (33.6%) 4,321 (100.0%)",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Análise de sobrevivência</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.pt.html#noções-básicas-de-análise-de-sobrevivência",
    "href": "new_pages/survival_analysis.pt.html#noções-básicas-de-análise-de-sobrevivência",
    "title": "27  Análise de sobrevivência",
    "section": "27.3 Noções básicas de análise de sobrevivência",
    "text": "27.3 Noções básicas de análise de sobrevivência\n\nConstruir um objeto do tipo sobrevivente\nUtilizaremos primeiro a função Surv() do pacote survival para construir um objeto de sobrevivência a partir das colunas de tempo e evento seguintes.\nO resultado de tal passo é produzir um objeto do tipo Surv que condensa a informação do tempo e se o evento de interesse (óbito) foi observado. Este objeto acabará por ser utilizado no lado direito das fórmulas do modelo subsequente (ver documentação).\n\n# Use a sintaxe Suv() para dados censurados\nsurvobj &lt;- Surv(time = linelist_surv$futime,\n                event = linelist_surv$event)\n\n\n\n\n\n\nPara rever, aqui estão as primeiras 10 linhas dos dados da linelist_surv, visualizando apenas algumas colunas importantes.\n\nlinelist_surv %&gt;% \n  select(case_id, date_onset, date_outcome, futime, outcome, event) %&gt;% \n  head(10)\n\n   case_id date_onset date_outcome futime outcome event\n1   8689b7 2014-05-13   2014-05-18      5 Recover     0\n2   11f8ea 2014-05-16   2014-05-30     14 Recover     0\n3   893f25 2014-05-21   2014-05-29      8 Recover     0\n4   be99c8 2014-05-22   2014-05-24      2 Recover     0\n5   07e3e8 2014-05-27   2014-06-01      5 Recover     0\n6   369449 2014-06-02   2014-06-07      5   Death     1\n7   f393b4 2014-06-05   2014-06-18     13 Recover     0\n8   1389ca 2014-06-05   2014-06-09      4   Death     1\n9   2978ac 2014-06-06   2014-06-15      9   Death     1\n10  fc15ef 2014-06-16   2014-07-09     23 Recover     0\n\n\nE aqui estão os primeiros 10 elementos do survobj. Imprime essencialmente como um vetor de tempo de seguimento, com “+” para representar se uma observação foi bem censurada. Veja como os números se alinham acima e abaixo.\n\n#imprime os 50 primeiros elementos do vetor para ver como ele se apresenta\nhead(survobj, 10)\n\n [1]  5+ 14+  8+  2+  5+  5  13+  4   9  23+\n\n\n\n\nRodando análises iniciais\nIniciamos então a nossa análise utilizando a função survfit() para produzir um objeto survfit, que se ajusta aos cálculos padrões de estimativas da curva de sobrevivência global (marginal) Kaplan Meier (KM) , que são na verdade uma função com saltos em tempos de eventos observados. O objeto final survfit contém uma ou mais curvas de sobrevivência e são criadas usando o objeto Surv como uma resposta variável na fórmula do modelo.\nNOTA: A estimativa de Kaplan-Meier é uma estimativa não paramétrica da máxima probabilidade (MLE na sigla em inglês) da função de sobrevivência. . (ver recursos para mais informações)\nO resumo deste objeto survfit dará o que se chama uma tabela de vida. Para cada passo do seguimento (tempo) em que um evento aconteceu (em ordem ascendente):\n\no número de pessoas que estavam em risco de desenvolver o evento (pessoas que ainda não tinham o evento nem foram censuradas: n.risk)\naqueles que desenvolveram o evento (n.event)\ne do acima exposto: a probabilidade de não desenvolver o evento (probabilidade de não morrer, ou de sobreviver depois desse tempo específico)\nfinalmente, o erro padrão e o intervalo de confiança para essa probabilidade são derivados e exibidos\n\nEncaixamos as estimativas KM usando a fórmula em que o objeto anteriormente Surv “survobj” é a variável de resposta. “~ 1” precisa que executamos o modelo para a sobrevivência global.\n\n# encaixa nas estimativas KM usando uma fórmula onde o objeto Surv \"sobrevivente\" é a variável de resposta.\n# \"~ 1\" significa que executamos o modelo para a sobrevivência global   \nlinelistsurv_fit &lt;-  survival::survfit(survobj ~ 1)\n\n# imprime o resumo para mais detalhes\nsummary(linelistsurv_fit)\n\nCall: survfit(formula = survobj ~ 1)\n\n time n.risk n.event survival std.err lower 95% CI upper 95% CI\n    1   4539      30    0.993 0.00120        0.991        0.996\n    2   4500      69    0.978 0.00217        0.974        0.982\n    3   4394     149    0.945 0.00340        0.938        0.952\n    4   4176     194    0.901 0.00447        0.892        0.910\n    5   3899     214    0.852 0.00535        0.841        0.862\n    6   3592     210    0.802 0.00604        0.790        0.814\n    7   3223     179    0.757 0.00656        0.745        0.770\n    8   2899     167    0.714 0.00700        0.700        0.728\n    9   2593     145    0.674 0.00735        0.660        0.688\n   10   2311     109    0.642 0.00761        0.627        0.657\n   11   2081     119    0.605 0.00788        0.590        0.621\n   12   1843      89    0.576 0.00809        0.560        0.592\n   13   1608      55    0.556 0.00823        0.540        0.573\n   14   1448      43    0.540 0.00837        0.524        0.556\n   15   1296      31    0.527 0.00848        0.511        0.544\n   16   1152      48    0.505 0.00870        0.488        0.522\n   17   1002      29    0.490 0.00886        0.473        0.508\n   18    898      21    0.479 0.00900        0.462        0.497\n   19    798       7    0.475 0.00906        0.457        0.493\n   20    705       4    0.472 0.00911        0.454        0.490\n   21    626      13    0.462 0.00932        0.444        0.481\n   22    546       8    0.455 0.00948        0.437        0.474\n   23    481       5    0.451 0.00962        0.432        0.470\n   24    436       4    0.447 0.00975        0.428        0.466\n   25    378       4    0.442 0.00993        0.423        0.462\n   26    336       3    0.438 0.01010        0.419        0.458\n   27    297       1    0.436 0.01017        0.417        0.457\n   29    235       1    0.435 0.01030        0.415        0.455\n   38     73       1    0.429 0.01175        0.406        0.452\n\n\nEnquanto usamos summary() podemos adicionar a opção times e especificar certos tempos em que queremos ver informações de sobrevivência.\n\n#imprime o resumo de tempos específicos\nsummary(linelistsurv_fit, times = c(5,10,20,30,60))\n\nCall: survfit(formula = survobj ~ 1)\n\n time n.risk n.event survival std.err lower 95% CI upper 95% CI\n    5   3899     656    0.852 0.00535        0.841        0.862\n   10   2311     810    0.642 0.00761        0.627        0.657\n   20    705     446    0.472 0.00911        0.454        0.490\n   30    210      39    0.435 0.01030        0.415        0.455\n   60      2       1    0.429 0.01175        0.406        0.452\n\n\nPodemos também utilizar a função print(). O argumento print.rmean = TRUE é utilizado para obter o tempo médio de sobrevivência e o seu erro padrão (SE na sigla em inglês).\nNOTA: O tempo médio de sobrevivência restrito (RMST na sigla em inglês) é uma medida de sobrevivência específica cada vez mais utilizada na análise de sobrevivência ao câncer e que é frequentemente definida como a área sob a curva de sobrevivência, dado que observamos pacientes até ao tempo restrito T (mais detalhes na seção Recursos).\n\n# imprimir objeto linelistsurv_fit com tempo médio de sobrevivência e sua SE.\nprint(linelistsurv_fit, print.rmean = TRUE)\n\nCall: survfit(formula = survobj ~ 1)\n\n        n events rmean* se(rmean) median 0.95LCL 0.95UCL\n[1,] 4539   1952   33.1     0.539     17      16      18\n    * restricted mean with upper limit =  64 \n\n\nDICA: Podemos criar o objeto surv diretamente na função survfit() e economizar uma linha de código. Ficará então: linelistsurv_quick &lt;-  survfit(Surv(futime, event) ~ 1, data=linelist_surv).\n\n\nRisco acumulado\nAlém da função summary(), também podemos utilizar a função str() que dá mais detalhes sobre a estrutura do objeto survfit(). É uma lista de 16 elementos.\nEntre estes elementos é um importante: cumhaz, que é um vetor numérico. Este pode ser traçado para permitir mostrar o risco cumulativo, sendo o risco o índice instantâneo de ocorrência de eventos (ver referências).\n\nstr(linelistsurv_fit)\n\nList of 16\n $ n        : int 4539\n $ time     : num [1:59] 1 2 3 4 5 6 7 8 9 10 ...\n $ n.risk   : num [1:59] 4539 4500 4394 4176 3899 ...\n $ n.event  : num [1:59] 30 69 149 194 214 210 179 167 145 109 ...\n $ n.censor : num [1:59] 9 37 69 83 93 159 145 139 137 121 ...\n $ surv     : num [1:59] 0.993 0.978 0.945 0.901 0.852 ...\n $ std.err  : num [1:59] 0.00121 0.00222 0.00359 0.00496 0.00628 ...\n $ cumhaz   : num [1:59] 0.00661 0.02194 0.05585 0.10231 0.15719 ...\n $ std.chaz : num [1:59] 0.00121 0.00221 0.00355 0.00487 0.00615 ...\n $ type     : chr \"right\"\n $ logse    : logi TRUE\n $ conf.int : num 0.95\n $ conf.type: chr \"log\"\n $ lower    : num [1:59] 0.991 0.974 0.938 0.892 0.841 ...\n $ upper    : num [1:59] 0.996 0.982 0.952 0.91 0.862 ...\n $ call     : language survfit(formula = survobj ~ 1)\n - attr(*, \"class\")= chr \"survfit\"\n\n\n\n\n\nTraçando curvas Kaplan-Meir\nUma vez encaixadas as estimativas KM, podemos visualizar a probabilidade de estarmos vivos durante um determinado tempo utilizando a função básica plot() que desenha a “curva Kaplan-Meier”. Em outras palavras, a curva abaixo é uma ilustração convencional da experiência de sobrevivência em todo o grupo de pacientes.\nPodemos verificar rapidamente o tempo de seguimento mínimo e máximo na curva.\nUma maneira fácil de interpretar é dizer que no tempo zero, todos os participantes ainda estão vivos e a probabilidade de sobrevivência é então de 100%. Esta probabilidade diminui com o tempo, à medida que os pacientes morrem. A proporção de participantes que sobrevivem nos últimos 60 dias de seguimento é de cerca de 40%.\n\nplot(linelistsurv_fit, \n     xlab = \"Days of follow-up\",    # nome eixo X\n     ylab=\"Survival Probability\",   # nome eixo Y\n     main= \"Overall survival curve\" # título da figura\n     )\n\n\n\n\n\n\n\n\nO intervalo de confiança das estimativas de sobrevivência do KM também são traçados por padrão e podem ser descartados adicionando a opção conf.int = FALSE ao comando plot().\nUma vez que o evento de interesse é “óbito”, desenhar uma curva descrevendo os complementos das proporções de sobrevivência levará a desenhar as proporções de mortalidade acumulada. Isto pode ser feito com lines(), o que acrescenta informação a uma parcela existente.\n\n# gráfico original\nplot(\n  linelistsurv_fit,\n  xlab = \"Dias de seguimento\",       \n  ylab = \"Probabilidade de Sobrevivência\",       \n  mark.time = TRUE,               # marcar eventos na curva: um \"+\" é impresso em cada evento\n  conf.int = FALSE,              # não traçar o intervalo de confiança\n  main = \"Curva geral de sobrevivência e mortalidade acumulada\"\n  )\n\n# desenhar uma curva adicional ao gráfico anterior\nlines(\n  linelistsurv_fit,\n  lty = 3,             # usar tipo de linha diferente para maior clareza\n  fun = \"event\",       # desenhar os eventos cumulativos em vez da sobrevivência\n  mark.time = FALSE,\n  conf.int = FALSE\n  )\n\n# adiciona legenda ao gráfico\nlegend(\n  \"topright\",                                       # posição da legenda\n  legend = c(\"Sobrevivência\", \"Mortalidade Acum.\"), # texto da legenda\n  lty = c(1, 3),                                    # tipos de linha a serem usados na legenda\n  cex = .85,                                        # parâmetros que definem o tamanho do texto da legenda\n  bty = \"n\"                                         # nenhum tipo de caixa a ser desenhada para a legenda\n  )",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Análise de sobrevivência</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.pt.html#comparação-de-curvas-de-sobrevivência",
    "href": "new_pages/survival_analysis.pt.html#comparação-de-curvas-de-sobrevivência",
    "title": "27  Análise de sobrevivência",
    "section": "27.4 Comparação de curvas de sobrevivência",
    "text": "27.4 Comparação de curvas de sobrevivência\nPara comparar a sobrevivência dentro de diferentes grupos dos nossos participantes ou pacientes observados, podemos ter de olhar primeiro para as suas respectivas curvas de sobrevivência e depois fazer testes para avaliar a diferença entre grupos independentes. Esta comparação pode dizer respeito a grupos baseados no sexo, idade, tratamento, comorbidade…\n\nTeste de classificação de registo\nO teste de log-rank é um teste popular que compara toda a experiência de sobrevivência entre dois ou mais grupos independentes e pode ser pensado como um teste para verificar se as curvas de sobrevivência são idênticas (sobreposição) ou não (hipótese nula de não haver diferença na sobrevivência entre os grupos). A função survdiff() do pacote survival permite executar o teste de log-rank quando especificamos rho = 0 (que é o padrão). Os resultados do teste dão uma estatística de qui-quadrado juntamente com um p-valor, uma vez que a estatística de classificação logarítmica é distribuída aproximadamente como uma estatística de teste de qui-quadrado.\nTentamos primeiro comparar as curvas de sobrevivência por grupo de gênero. Para tal, tentamos primeiro visualizá-la (verificar se as duas curvas de sobrevivência estão sobrepostas). Um novo objeto survfit será criado com uma fórmula ligeiramente diferente. Depois será criado o objeto survdiff.\nAo fornecer ~ gender como o lado direito da fórmula, deixamos de traçar a sobrevivência global e passamos a fazê-lo por gênero.\n\n# criar um novo objeto do tipo survfit baseado no gênero\nlinelistsurv_fit_sex &lt;-  survfit(Surv(futime, event) ~ gender, data = linelist_surv)\n\nAgora podemos traçar as curvas de sobrevivência por gênero. Veja a ordem dos níveis de estratos na coluna do gênero antes de definir as suas cores e legendas.\n\n# padrão de cor\ncol_sex &lt;- c(\"lightgreen\", \"darkgreen\")\n\n# cria a impressão\nplot(\n  linelistsurv_fit_sex,\n  col = col_sex,\n  xlab = \"Days of follow-up\",\n  ylab = \"Survival Probability\")\n\n# adiciona legenda\nlegend(\n  \"topright\",\n  legend = c(\"Feminino\",\"Masculino\"),\n  col = col_sex,\n  lty = 1,\n  cex = .9,\n  bty = \"n\")\n\n\n\n\n\n\n\n\nE agora podemos calcular o teste da diferença entre as curvas de sobrevivência usando survdiff ()\n\n# calcula o teste da diferença entre as curvas de sobrevivência\nsurvival::survdiff(\n  Surv(futime, event) ~ gender, \n  data = linelist_surv\n  )\n\nCall:\nsurvival::survdiff(formula = Surv(futime, event) ~ gender, data = linelist_surv)\n\nn=4321, 218 observations deleted due to missingness.\n\n            N Observed Expected (O-E)^2/E (O-E)^2/V\ngender=f 2156      924      909     0.255     0.524\ngender=m 2165      929      944     0.245     0.524\n\n Chisq= 0.5  on 1 degrees of freedom, p= 0.5 \n\n\nVemos que a curva de sobrevivência das mulheres e a dos homens se sobrepõem e o teste do log-rank não dá provas de uma diferença de sobrevivência entre mulheres e homens.\nAlguns outros pacotes de R permitem ilustrar curvas de sobrevivência para diferentes grupos e testar a diferença de uma só vez. Utilizando a função ggsurvplot() do pacote survminer, podemos também incluir na nossa curva as tabelas de risco impressas para cada grupo, bem como o valor p do teste de log-rank.\n[CUIDADO: funções survminer requerem que se especifique o objeto de sobrevivência e novamente os dados utilizados para encaixar o objeto de sobrevivência. Lembre-se de fazer isto para evitar mensagens de erro não específicas].{style=“color: orange;”}\n\nsurvminer::ggsurvplot(\n    linelistsurv_fit_sex, \n    data = linelist_surv,          # novamente especificar o dado usado para encaixar linelistsurv_fit_sex \n    conf.int = FALSE,              # não mostrar o intervalo de confiança da estimativa KM\n    surv.scale = \"percent\",        # apresentar probabilidades no eixo Y em %\n    break.time.by = 10,            # apresentar o eixo de tempo com um incremento de 10 dias\n    xlab = \"Follow-up days\",\n    ylab = \"Survival Probability\",\n    pval = T,                      # adicionar o p-valor do teste Log-rank \n    pval.coord = c(40,.91),        # adicionar o p-valor às coordenadas especificadas\n    risk.table = T,                # imprimir a tabela de risco no fundo  \n    legend.title = \"Gender\",       # características da legenda\n    legend.labs = c(\"Female\",\"Male\"),\n    font.legend = 10, \n    palette = \"Dark2\",             # especificar paleta de cores \n    surv.median.line = \"hv\",       # desenhar linhas horizontais e verticais para a mediana de sobrevivência\n    ggtheme = theme_light()        # simplificar o plano de fundo da impressão\n)\n\n\n\n\n\n\n\n\nTambém podemos querer testar diferenças na sobrevivência pela fonte de infecção (fonte de contaminação).\nNeste caso, o teste de Log rank dá provas suficientes de uma diferença nas probabilidades de sobrevivência em alpha= 0,005. As probabilidades de sobrevivência de pacientes que foram infectados em funerais são superiores às probabilidades de sobrevivência de pacientes que foram infectados em outros locais, sugerindo um benefício de sobrevivência.\n\nlinelistsurv_fit_source &lt;-  survfit(\n  Surv(futime, event) ~ source,\n  data = linelist_surv\n  )\n\n# impressão\nggsurvplot( \n  linelistsurv_fit_source,\n  data = linelist_surv,\n  size = 1, linetype = \"strata\",   # tipos de linhas\n  conf.int = T,\n  surv.scale = \"percent\",  \n  break.time.by = 10, \n  xlab = \"Follow-up days\",\n  ylab= \"Survival Probability\",\n  pval = T,\n  pval.coord = c(40,.91),\n  risk.table = T,\n  legend.title = \"Source of \\ninfection\",\n  legend.labs = c(\"Funeral\", \"Other\"),\n  font.legend = 10,\n  palette = c(\"#E7B800\",\"#3E606F\"),\n  surv.median.line = \"hv\", \n  ggtheme = theme_light()\n)\n\nWarning in geom_segment(aes(x = 0, y = max(y2), xend = max(x1), yend = max(y2)), : All aesthetics have length 1, but the data has 2 rows.\nℹ Did you mean to use `annotate()`?\nAll aesthetics have length 1, but the data has 2 rows.\nℹ Did you mean to use `annotate()`?\nAll aesthetics have length 1, but the data has 2 rows.\nℹ Did you mean to use `annotate()`?\nAll aesthetics have length 1, but the data has 2 rows.\nℹ Did you mean to use `annotate()`?",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Análise de sobrevivência</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.pt.html#análise-de-regressão-de-cox",
    "href": "new_pages/survival_analysis.pt.html#análise-de-regressão-de-cox",
    "title": "27  Análise de sobrevivência",
    "section": "27.5 Análise de regressão de Cox",
    "text": "27.5 Análise de regressão de Cox\nO modelo de riscos proporcionais de Cox é uma das técnicas de regressão mais populares para a análise de sobrevivência. Outros modelos também podem ser utilizados, uma vez que o modelo Cox requer importantes pressupostos que precisam ser verificados para uma utilização adequada, tal como o pressuposto dos riscos proporcionais: ver referências.\nNum modelo de riscos proporcionais de Cox, a medida do efeito é a taxa de risco ou razão de riscos(HR na sigla Hazard Ratio em inglês), que é o risco de fracasso (ou o risco de morte no nosso exemplo), dado que o participante sobreviveu até um tempo específico. Normalmente, estamos interessados em comparar grupos independentes com respeito aos seus perigos, e utilizamos uma taxa de risco, que é análoga a uma taxa de probabilidade no estabelecimento de uma análise de regressão logística múltipla. A função cox.ph() do pacote survival é utilizada para se adequar ao modelo. A função cox.zph() do pacote survival pode ser utilizada para testar a hipótese de riscos proporcionais para um ajuste do modelo de regressão Cox.\nNOTA: A probabilidade deve estar no intervalo de 0 a 1. No entanto, o perigo representa o número esperado de eventos por uma unidade de tempo.\n\nSe a razão de perigo para um preditor for próxima de 1, então esse preditor não afeta a sobrevivência,\nse o HR for inferior a 1, então o preditor é protetor (ou seja, associado a uma melhor sobrevivência),\ne se a FC for superior a 1, então o preditor está associado ao aumento do risco (ou diminuição da sobrevivência).\n\n\nAjuste de um modelo Cox\nPodemos primeiro ajustar um modelo para avaliar o efeito da idade e do gênero na sobrevivência. Ao imprimir apenas o modelo, temos a informação sobre:\n\nos coeficientes de regressão estimados “coef” que quantificam a associação entre os preditores e o resultado,\na sua exponencial (para interpretabilidade, exp(coef)) que produz a razão de riscos HR,\no seu erro padrão se(coef),\no z-score: quantos erros padrão é o coeficiente estimado a partir de 0,\ne o p-valor: a probabilidade de o coeficiente estimado poder ser 0.\n\nA função summary() aplicada ao objeto modelo Cox dá mais informações, tais como o intervalo de confiança do HR estimado e os diferentes resultados do teste.\nO efeito da primeira covariável “gênero” é apresentado na primeira linha. O genderm (masculino) é mostrado indicando que o primeiro nível de estratos (“f”), ou seja, o grupo feminino, é o grupo de referência para as comparações dentro do gênero. Assim, a interpretação do parâmetro de teste é a dos homens em comparação com a das mulheres. O p-valor indica que não havia evidências suficientes de um efeito do gênero sobre o risco esperado ou de uma associação entre o gênero e a mortalidade por todas as causas.\nA mesma falta de evidências é notada no que diz respeito ao grupo etário.\n\n# ajustando o modelo cox\nlinelistsurv_cox_sexage &lt;-  survival::coxph(\n              Surv(futime, event) ~ gender + age_cat_small, \n              data = linelist_surv\n              )\n\n\n#imprimindo o modelo ajustado\nlinelistsurv_cox_sexage\n\nCall:\nsurvival::coxph(formula = Surv(futime, event) ~ gender + age_cat_small, \n    data = linelist_surv)\n\n                      coef exp(coef) se(coef)      z     p\ngenderm           -0.03149   0.96900  0.04767 -0.661 0.509\nage_cat_small5-19  0.09400   1.09856  0.06454  1.456 0.145\nage_cat_small20+   0.05032   1.05161  0.06953  0.724 0.469\n\nLikelihood ratio test=2.8  on 3 df, p=0.4243\nn= 4321, number of events= 1853 \n   (218 observations deleted due to missingness)\n\n#resumo do modelo\nsummary(linelistsurv_cox_sexage)\n\nCall:\nsurvival::coxph(formula = Surv(futime, event) ~ gender + age_cat_small, \n    data = linelist_surv)\n\n  n= 4321, number of events= 1853 \n   (218 observations deleted due to missingness)\n\n                      coef exp(coef) se(coef)      z Pr(&gt;|z|)\ngenderm           -0.03149   0.96900  0.04767 -0.661    0.509\nage_cat_small5-19  0.09400   1.09856  0.06454  1.456    0.145\nage_cat_small20+   0.05032   1.05161  0.06953  0.724    0.469\n\n                  exp(coef) exp(-coef) lower .95 upper .95\ngenderm               0.969     1.0320    0.8826     1.064\nage_cat_small5-19     1.099     0.9103    0.9680     1.247\nage_cat_small20+      1.052     0.9509    0.9176     1.205\n\nConcordance= 0.514  (se = 0.007 )\nLikelihood ratio test= 2.8  on 3 df,   p=0.4\nWald test            = 2.78  on 3 df,   p=0.4\nScore (logrank) test = 2.78  on 3 df,   p=0.4\n\n\nFoi interessante executar o modelo e olhar para os resultados, mas um primeiro olhar para verificar se os pressupostos de riscos proporcionais são respeitados poderia ajudar a poupar tempo.\n\ntest_ph_sexage &lt;- survival::cox.zph(linelistsurv_cox_sexage)\ntest_ph_sexage\n\n              chisq df    p\ngender        0.454  1 0.50\nage_cat_small 0.838  2 0.66\nGLOBAL        1.399  3 0.71\n\n\nNOTA: Um segundo argumento da função chamado method pode ser especificado ao calcular o modelo cox, que determina como os empates são tratados. O padrão é “efron”, e as outras opções são “breslow” e “exact”.\nNum outro modelo, adicionamos mais fatores de risco, tais como a fonte da infecção e o número de dias entre a data de início e a admissão. Desta vez, verificamos primeiro a hipótese de riscos proporcionais antes de avançarmos.\nNeste modelo, incluímos um preditor contínuo (days_onset_hosp). Neste caso, interpretamos as estimativas dos parâmetros como o aumento do registo esperado do risco relativo para cada aumento de uma unidade no preditor, mantendo constantes outros preditores. Primeiro verificamos a suposição de perigos proporcionais.\n\n#cria o modelo\nlinelistsurv_cox &lt;-  coxph(\n                        Surv(futime, event) ~ gender + age_years+ source + days_onset_hosp,\n                        data = linelist_surv\n                        )\n\n\n#testa o modelo de risco proporcional\nlinelistsurv_ph_test &lt;- cox.zph(linelistsurv_cox)\nlinelistsurv_ph_test\n\n                   chisq df       p\ngender           0.45062  1    0.50\nage_years        0.00199  1    0.96\nsource           1.79622  1    0.18\ndays_onset_hosp 31.66167  1 1.8e-08\nGLOBAL          34.08502  4 7.2e-07\n\n\nA verificação gráfica desta hipótese pode ser realizada com a função ggcoxzph() do pacote survminer.\n\nsurvminer::ggcoxzph(linelistsurv_ph_test)\n\n\n\n\n\n\n\n\nOs resultados do modelo indicam a existência de uma associação negativa entre o início da duração da admissão e a mortalidade por todas as causas. O risco esperado é 0,9 vezes menor numa pessoa que é admitida um dia mais tarde do que outra, mantendo constante o gênero. Ou, numa explicação mais direta, um aumento de uma unidade na duração do início da admissão está associado a uma diminuição de 10,7% (coef *100) no risco de morte.\nOs resultados mostram também uma associação positiva entre a fonte da infecção e a mortalidade por todas as causas. Ou seja, há um aumento do risco de morte (1,21x) para os pacientes que têm outra fonte de infecção.\n\n#resumo do modelo\nsummary(linelistsurv_cox)\n\nCall:\ncoxph(formula = Surv(futime, event) ~ gender + age_years + source + \n    days_onset_hosp, data = linelist_surv)\n\n  n= 2772, number of events= 1180 \n   (1767 observations deleted due to missingness)\n\n                     coef exp(coef)  se(coef)      z Pr(&gt;|z|)    \ngenderm          0.004710  1.004721  0.060827  0.077   0.9383    \nage_years       -0.002249  0.997753  0.002421 -0.929   0.3528    \nsourceother      0.178393  1.195295  0.084291  2.116   0.0343 *  \ndays_onset_hosp -0.104063  0.901169  0.014245 -7.305 2.77e-13 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n                exp(coef) exp(-coef) lower .95 upper .95\ngenderm            1.0047     0.9953    0.8918    1.1319\nage_years          0.9978     1.0023    0.9930    1.0025\nsourceother        1.1953     0.8366    1.0133    1.4100\ndays_onset_hosp    0.9012     1.1097    0.8764    0.9267\n\nConcordance= 0.566  (se = 0.009 )\nLikelihood ratio test= 71.31  on 4 df,   p=1e-14\nWald test            = 59.22  on 4 df,   p=4e-12\nScore (logrank) test = 59.54  on 4 df,   p=4e-12\n\n\nPodemos verificar essa relação com a tabela:\n\nlinelist_case_data %&gt;% \n  tabyl(days_onset_hosp, outcome) %&gt;% \n  adorn_percentages() %&gt;%  \n  adorn_pct_formatting()\n\n days_onset_hosp Death Recover   NA_\n               0 44.3%   31.4% 24.3%\n               1 46.6%   32.2% 21.2%\n               2 43.0%   32.8% 24.2%\n               3 45.0%   32.3% 22.7%\n               4 41.5%   38.3% 20.2%\n               5 40.0%   36.2% 23.8%\n               6 32.2%   48.7% 19.1%\n               7 31.8%   38.6% 29.5%\n               8 29.8%   38.6% 31.6%\n               9 30.3%   51.5% 18.2%\n              10 16.7%   58.3% 25.0%\n              11 36.4%   45.5% 18.2%\n              12 18.8%   62.5% 18.8%\n              13 10.0%   60.0% 30.0%\n              14 10.0%   50.0% 40.0%\n              15 28.6%   42.9% 28.6%\n              16 20.0%   80.0%  0.0%\n              17  0.0%  100.0%  0.0%\n              18  0.0%  100.0%  0.0%\n              22  0.0%  100.0%  0.0%\n              NA 52.7%   31.2% 16.0%\n\n\nTeríamos de considerar e investigar porque é que esta associação existe nos dados. Uma explicação possível poderia ser que os pacientes que vivem o tempo suficiente para serem admitidos mais tarde, tem uma doença menos grave. Outra explicação talvez mais provável é que, uma vez que utilizámos um conjunto de dados falso simulado, este padrão não reflete a realidade!\n\n\n\nGráficos em floresta (Forest plots)\nPodemos visualizar os resultados do modelo Cox usando “forest plots” com a função ggforest() do pacote survminer.\n\nggforest(linelistsurv_cox, data = linelist_surv)",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Análise de sobrevivência</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.pt.html#covariáveis-dependentes-do-tempo-em-modelos-de-sobrevivência",
    "href": "new_pages/survival_analysis.pt.html#covariáveis-dependentes-do-tempo-em-modelos-de-sobrevivência",
    "title": "27  Análise de sobrevivência",
    "section": "27.6 Covariáveis dependentes do tempo em modelos de sobrevivência",
    "text": "27.6 Covariáveis dependentes do tempo em modelos de sobrevivência\nAlgumas das seções seguintes foram adaptadas com permissão de uma excelente introdução à análise de sobrevivência em R pela Dra. Emily Zabor\nNa última seção usamos a regressão Cox para examinar associações entre covariáveis de interesse e resultados de sobrevivência. Mas estas análises dependem da covariância ser medida na linha de base, ou seja, antes do tempo de seguimento do evento começar.\nO que acontece se estiver interessado em uma covariável que é medida após o início do tempo de seguimento? Ou, e se uma dessas covariáveis possa mudar ao longo do tempo?\nPor exemplo, talvez esteja trabalhando com dados clínicos onde repetiu medidas de valores laboratoriais hospitalares que podem mudar ao longo do tempo. Este é um exemplo de uma Covariável Dependente do Tempo. Para resolver este problema é necessário uma configuração especial, mas felizmente o modelo cox é muito flexível e este tipo de dados também pode ser modelado com ferramentas do pacote survival.\n\nConfiguração de covariável dependente do tempo\nA análise de covariáveis dependentes do tempo em R requer a configuração de um conjunto de dados especial. Se estiver interessado, ver o artigo mais detalhado sobre este assunto do autor do pacote survival Using Time Dependent Covariates and Time Dependent Coefficients in the Cox Model.\nPara tal, utilizaremos um novo conjunto de dados do pacote SemiCompRisks' chamadoBMT’, que inclui dados sobre 137 pacientes de transplante de medula óssea. As variáveis em que nos vamos concentrar são:\n\nT1 - tempo (em dias) até à morte ou último seguimento\n\ndelta1 - indicador de óbito; 1-Óbito, 0-Vivos\n\nTA - tempo (em dias) até à doença aguda de enxerto-versus-hospedeiro\n\ndeltaA - indicador de doença aguda de enxerto-versus-hospedeiro;\n\n1 - desenvolveu a doença aguda de enxerto-versus-hospedeiro\n\n0 - Nunca desenvolveu doença aguda de enxerto-versus-hospedeiro\n\n\nVamos carregar este conjunto de dados a partir do pacote survival utilizando o comando do R base data(), que pode ser utilizado para carregar dados que já estão incluídos num pacote R que é carregado. A moldura de dados BMT irá aparecer no seu ambiente R.\n\ndata(BMT, package = \"SemiCompRisks\")\n\n\nAdicionar identificador único de doente\nNão existe uma coluna de ID única nos dados BMT, que é necessária para criar o tipo de conjunto de dados que desejamos. Assim, utilizamos a função rowid_to_column() do pacote tidyverse para criar uma nova coluna de id chamada my_id (adiciona coluna no início do Data Frame com ids sequenciais de linha, começando em 1). Nomeamos o data frame como bmt.\n\nbmt &lt;- rowid_to_column(BMT, \"my_id\")\n\nO conjunto de dados tem agora este aspecto:\n\n\n\n\n\n\n\n\nExpandir as linhas de pacientes\nA seguir, utilizaremos a função tmerge() com as funções auxiliares event() e tdc() helper para criar o conjunto de dados reestruturado. Neste caso, cada paciente pode ter no máximo duas linhas, dependendo se desenvolveu doença aguda de enxerto-versus-hospedeiro durante o período de coleta de dados. Vamos chamar o nosso novo indicador para o desenvolvimento da doença aguda de enxerto-versus-hospedeiro agvhd.\n\ntmerge() cria um longo conjunto de dados com múltiplos intervalos de tempo para os diferentes valores covariados para cada paciente\nevent() cria o novo indicador de evento para combinar com os intervalos de tempo recém-criados\ntdc() cria a coluna covariada dependente do tempo, agvhd, para combinar com os intervalos de tempo recém-criados\n\n\ntd_dat &lt;- \n  tmerge(\n    data1 = bmt %&gt;% select(my_id, T1, delta1), \n    data2 = bmt %&gt;% select(my_id, T1, delta1, TA, deltaA), \n    id = my_id, \n    death = event(T1, delta1),\n    agvhd = tdc(TA)\n    )\n\nPara ver o que foi feito, vamos olhar os dados dos primeiros 5 pacientes.\nAs variáveis de interesse do dado original terão essa aparência:\n\nbmt %&gt;% \n  select(my_id, T1, delta1, TA, deltaA) %&gt;% \n  filter(my_id %in% seq(1, 5))\n\n  my_id   T1 delta1   TA deltaA\n1     1 2081      0   67      1\n2     2 1602      0 1602      0\n3     3 1496      0 1496      0\n4     4 1462      0   70      1\n5     5 1433      0 1433      0\n\n\nO novo conjunto de dados para esses pacientes terá essa aparência:\n\ntd_dat %&gt;% \n  filter(my_id %in% seq(1, 5))\n\n  my_id   T1 delta1 tstart tstop death agvhd\n1     1 2081      0      0    67     0     0\n2     1 2081      0     67  2081     0     1\n3     2 1602      0      0  1602     0     0\n4     3 1496      0      0  1496     0     0\n5     4 1462      0      0    70     0     0\n6     4 1462      0     70  1462     0     1\n7     5 1433      0      0  1433     0     0\n\n\nAgora alguns dos nossos pacientes têm duas linhas no conjunto de dados correspondentes a intervalos em que têm um valor diferente da nossa nova variável, agvhd. Por exemplo, o Paciente 1 tem agora duas linhas com um valor agvhd de zero do tempo 0 ao tempo 67, e um valor de 1 do tempo 67 ao tempo 2081.\n\n\n\nRegressão Cox com covariáveis dependentes do tempo\nAgora que remodelamos os nossos dados e acrescentamos a nova variável dependente do tempo aghvd , vamos encaixar um modelo simples de regressão de uma única variável cox. Podemos utilizar a mesma função coxph() como antes, só precisamos alterar a nossa função Surv() para especificar tanto o tempo de início como o tempo de paragem para cada intervalo utilizando os argumentos time1 = e time2 =.\n\nbmt_td_model = coxph(\n  Surv(time = tstart, time2 = tstop, event = death) ~ agvhd, \n  data = td_dat\n  )\n\nsummary(bmt_td_model)\n\nCall:\ncoxph(formula = Surv(time = tstart, time2 = tstop, event = death) ~ \n    agvhd, data = td_dat)\n\n  n= 163, number of events= 80 \n\n        coef exp(coef) se(coef)    z Pr(&gt;|z|)\nagvhd 0.3351    1.3980   0.2815 1.19    0.234\n\n      exp(coef) exp(-coef) lower .95 upper .95\nagvhd     1.398     0.7153    0.8052     2.427\n\nConcordance= 0.535  (se = 0.024 )\nLikelihood ratio test= 1.33  on 1 df,   p=0.2\nWald test            = 1.42  on 1 df,   p=0.2\nScore (logrank) test = 1.43  on 1 df,   p=0.2\n\n\nNovamente vamos visualizar o resultado do nosso modelo cox usando a função ggforest() do pacote survminer.:\n\nggforest(bmt_td_model, data = td_dat)\n\n\n\n\n\n\n\n\nComo se pode ver pela “forest plot”, intervalo de confiança e p-valor, não parece haver forte associação entre ocorrência de óbito e a doença aguda do enxerto-versus-hospedeiro no contexto do nosso modelo simples.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Análise de sobrevivência</span>"
    ]
  },
  {
    "objectID": "new_pages/survival_analysis.pt.html#referências",
    "href": "new_pages/survival_analysis.pt.html#referências",
    "title": "27  Análise de sobrevivência",
    "section": "27.7 Referências",
    "text": "27.7 Referências\nSurvival Analysis Part I: Basic concepts and first analyses\nAnálise de sobrevivência no R\nSurvival analysis in infectious disease research: Describing events in time\nChapter on advanced survival models Princeton\nUsing Time Dependent Covariates and Time Dependent Coefficients in the Cox Model\nCheatsheet (cola) de análise de sobrevivência\nCheatsheet (cole) do Survminer\nPaper on different survival measures for cancer registry data with Rcode provided as supplementary materials",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Análise de sobrevivência</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.pt.html",
    "href": "new_pages/gis.pt.html",
    "title": "28  Introdução ao GIS",
    "section": "",
    "text": "28.1 Visão Geral\nOs aspectos especiais dos seus dados podem trazer vários insights à situação de um surto, e pode responder perguntas como:\nO foco dessa página sobre GIS é atender às necessidades dos epidemiologistas na resposta aos surtos. Iremos explorar métodos básicos de visualização de dados espaciais utilizando os pacotes tmap e ggplot2. Também vamos caminhar por métodos básicos de gerenciamento e consulta de dados espaciais com o pacote sf. Por fim, vamos dar uma olhada em conceitos de estatística espacial tais como relações espaciais, autocorrelação espacial e regressão espacial utilizando o pacote spdep.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Introdução ao GIS</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.pt.html#visão-geral",
    "href": "new_pages/gis.pt.html#visão-geral",
    "title": "28  Introdução ao GIS",
    "section": "",
    "text": "Onde estão os hotspots da doença?\nComo os hotspots mudaram ao longo do tempo?\nComo é o acesso às unidades de saúdo? Melhorias são necessárias?",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Introdução ao GIS</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.pt.html#terminologia",
    "href": "new_pages/gis.pt.html#terminologia",
    "title": "28  Introdução ao GIS",
    "section": "28.2 Terminologia",
    "text": "28.2 Terminologia\nAbaixo introduziremos a terminologia principal. Para uma introdução mais profunda ao GIS e à análise espacial, sugerimos que você revise algum dos tutoriais maiores ou cursos listados na seção de Referências.\nGeographic Information System (GIS) (Sistema de Informação Geográfica) - Um GIS é um framework ou ambiente para reunir, gerenciar, analisar e visualizar dados espaciais.\n\nSoftwares GIS\nAlguns Softwares GIS mais conhecidos permitem interação do tipo “apontar-e-clicar” (point-and-click) para o desenvolvimento de mapas e análises espaciais. Essas ferramentas vêm com as vantagens de não precisar aprender código e com a facilidade de selecionar e posicionar manualmente ícones e outras características em um mapa. Aqui temos dois dos mais conhecidos:\nArcGIS - Um software GIS comercial desenvolvido pela empresa ESRI, que é muito famoso mas bastante caro.\nQGIS - Um software GIS gratuito e open-source que pode fazer praticamente qualquer coisa que o ArcGIS também pode. Você pode baixar o QGIS aqui\nUtilizar o R como um GIS pode parecer mais intimidador no início, pois em vez do “apontar-e-clicar”, ele tem uma interface de linha de comando (você precisa escrever código para chegar no resultado esperado). No entanto, essa é uma grande vantagem se você precisa produzir mapas repetitivamente ou criar análises que sejam reprodutíveis.\n\n\nDados espaciais\nAs duas formas primordiais de dados espaciais utilizados no GIS são dados vetoriais e rasterizados.\nDados Vetoriais - O formato de dados espaciais mais comum utilizado no GIS. Dados vetoriais compreendem as propriedades geométricas de vértices e trajetos (paths). Os dados vetoriais espaciais também podem se subdividir em três tipos amplamente utilizados:\n\nPontos - Um ponto consiste em um par ordenado (x,y) representando um local específico em um sistema de coordenadas. Pontos são a forma mais básica de dados espaciais e podem ser utilizados para representar um caso (casa de um paciente) ou um local (hospital) em um mapa.\nLinhas - Uma linha é composta de dois pontos conectados. Linhas possuem um comprimento, e podem ser utilizadas para representar coisas como rodovias ou rios.\nPolígonos - Um polígono é composto de pelo menos três segmentos de linha conectados por pontos. As propriedades de um Polígono são comprimento (o perímetro da área) bem como a própria medida da área. Polígonos podem ser utilizado para demarcar uma área (uma vila) ou uma estrutura (a área de um hospita ).\n\nDados Rasterizados - Um formato alternativo para dados espaciais, dados rasterizados são uma matriz de células (por exemplo, pixels) em que cada célula contém informações como altura, temperatura, inclinação, cobertura florestal, etc. Essas geralmente são fotos aéreas, imagens de satélite, etc. Os “Rasters” também podem ser utilizados como “mapas base” sob dados vetoriais.\n\n\nVisualizando dados espaciais\nPara representar visualmente os dados espaciais em um mapa, os softwares GIS exigem que você forneça informação suficiente sobre onde posicionar cada característica em relação umas às outras. Se você estiver utilizando dados vetoriais, o que vai acontecer na maioria dos casos, essas informações normalmente estarão armazenadas em um “shapefile”.\nShapefiles - Um shapefile é um formato de dado comum para armazenar dados espaciais “vetoriais” que consistem de linhas, pontos ou polígonos. Um único shapefile na verdade é um conjunto de pelo menos três arquivos - .shp, .shx, e .dbf. Todos esses sub-componentes devem estar presente em um mesmo diretório (pasta) para que o shapefile possa ser lido. Esses arquivos associados podem ser comprimidos em uma pasta ZIP para ser enviado por email ou baixado de um site.\nO shapefile vai conter informação sobre as propriedades propriamente ditas, bem como onde encontrá-las na superfície da Terra. Isso é importante pois apesar da Terra ser um globo, os mapas são tipicamente bidimensionais; escolhas sobre como “achatar” os dados espaciais podem ter grande impactos no visual e na interpretação do mapa produzido.\nCoordinate Reference Systems (CRS) (Sistemas de Referências de Coordenadas) - Um SRC é um sistema baseado em coordenadas utilizado para localizar propriedades geográficas na superfície da Terra. Ele possui alguns componentes principais:\n\nSistema de Coordenadas - Existem muitos tipos diferentes de sistemas de coordenadas, então certifique-se de qual dos tipos suas coordenadas fazem parte. Graus de latitude/longitude são comuns, mas você pode também ver coordenadas UTM.\nUnidades - Saiba qual são as unidades para o seu sistema de coordenadas (exemplo: graus decimais, metros)\nDatum - Uma versão modelada específica da Terra. Essa versão vem sendo revisada ao longo dos anos, então certifique-se de que as camadas do seu mapa utilizam o mesmo datum.\nProjeção - Uma referência à equação matemática que foi utilizada para projetar a verdadeiramente redonda Terra em uma superfície plana (mapa).\n\nLembre-se que você pode resumir dados espaciais sem utilizar as ferramentas de mapas mostradas abaixo. Às vezes, uma simples tabela por dados geográficos (distritos, países, etc.) é todo o necessário!",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Introdução ao GIS</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.pt.html#iniciando-com-gis",
    "href": "new_pages/gis.pt.html#iniciando-com-gis",
    "title": "28  Introdução ao GIS",
    "section": "28.3 Iniciando com GIS",
    "text": "28.3 Iniciando com GIS\nExistem alguns itens importantes que você precisará ter ou pensar a respeito para fazer um mapa. Esses incluem:\n\nUma base de dados – pode ser em formato de dados espaciais (tais como shapefiles, como mostrado acima) ou pode não ser em formato espacial (apenas um csv).\nSe sua base de dados não estiver em um formato espacial você também vai precisar de uma base de dados de referência. Dados de referência consistem nas representações espaciais de dados e seus atributos relacionados, que deverão incluir material contendo o local e informações sobre o endereço de propriedades específicas.\n\nSe você estiver trabalhando com fronteiras geográficas pré-definidas (por examplo, regiões administrativas), shapefiles de referências geralmente estão disponíveis gratuitamente para download nos sites das agências governamentais ou organizações de compartilhamento de dados. Se estiver em dúvida, um bom jeito de começar é buscar no Google por “[região] shapefile”\nSe você tiver informação sobre endereços, mas não tiver latitude e longitude, talvez você precisa utilizar um motor de geocodificação (geocoding engine) para coletar os dados de referências espaciais para seus regristros.\n\nUma ideia sobre como você quer apresentar a informação em suas bases para seu público alvo. Existem muitos tipos diferentes de mapas, e é importante pensar sobre qual se encaixa melhor à suas necessidades.\n\n\nTipos de mapas para visualizar seus dados\nMapa coroplético (Choropleth map) - um tipo de mapa temático onde cores, sombreamento ou padrões são utilizados para representar regiões geográficas de acordo com seus valores de um atributo. Por exemplo, um valor maior pode ser indicado por uma cor mais escura que um valor menor. Esse tipo de mapa é particularmente útil quando estamos visualizando uma variável e como seu valor muda através de regiões definidas ou áreas geopolíticas.\n\n\n\n\n\n\n\n\n\nMapa de calor de densidade de casos (Case density heatmap) - um tipo de mapa temático em que as cores são utilizada para representar a intensidade de um valor, no entanto, ele não utiliza regiões definidas ou fronteiras geopolíticas para agrupar os dados. Esse tipo de mapa é tipicamente utilizado para mostrar ‘hot spots’ ou áreas com uma alta densidade ou concentração de pontos.\n\n\n\n\n\n\n\n\n\nMapa de densidade de pontos (Dot density map) - um tipo de mapa temático que usa pontos para reprensentar valores de atributos nos seus dados. Esse tipo de mapa é melhor utilizado para visualizar o espalhamento dos dados e permitir um “escaneamento” visual de agrupamentos (clusters).\nMapa de símbolos proporcionais (mapa de símbolos graduados) (Proportional symbols map (graduated symbols map)) - um mapa temático similar ao mapa de coroplético mas, em vez de utilizar cores para indicar o valor de um atributo, ele utiliza um símbolo (geralmente um círculo) de acordo com o valor. Por exemplo, um valor maior pode ser indicado por um símbolo maior que um valor menor. Esse tipo de mapa é melhor utilizado quando se quer visualizar o tamanho ou quantidade dos seus dados através de regiões geográficas.\nVocê também pode combinar vários tipos diferentes de visualização para mostrar padrões geográficos complexos. Por exemplo, os casos (pontos) no mapa abaixo estão coloridos de acordo com a unidade de saúde mais próxima (veja a legenda). Os círculos maiores mostram áreas de alcance das unidades de saúde a partir de um certo raio e os pontos vermelho-vivo mostram os casos fora do alcance de qualquer uma das unidades de saúde mostradas:\n\n\n\n\n\n\n\n\n\nNota: O foco principal dessa página sobre GIS é baseado no contexo de uma resposta de campo a um surto. Por isso, os conteúdos da página irão cobrir o básico de manipulação, visualização e análise de dados espaciais.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Introdução ao GIS</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.pt.html#preparação",
    "href": "new_pages/gis.pt.html#preparação",
    "title": "28  Introdução ao GIS",
    "section": "28.4 Preparação",
    "text": "28.4 Preparação\n\nCarregue os pacotes R\nO código abaixo realiza o carregamento dos pacotes necessários para a análise dos dados. Neste manual, enfatizamos o uso da função p_load(), do pacman, que instala os pacotes, caso não estejam instalados, e os carrega no R para utilização. Também é possível carregar pacotes instalados utilizando a função library(), do R base. Para mais informações sobre os pacotes do R, veja a página Introdução ao R.\n\npacman::p_load(\n  rio,           # para importar os dados\n  here,          # para localizar arquivos \n  tidyverse,     # para limpar, manipular e gerar gráficos com os dados (inclui o pacote ggplot2)\n  sf,            # para gerenciar dados espaciais utilizando o formato Simple Feature \n  stars,          # para produzir mapas simples, funciona tanto para mapas interativos quanto estáticos \n  janitor, # para limpar nomes das colunas \n  terra, #dependencia tmap\n  tmap,\n  OpenStreetMap, # para adicionar o mapa-base do OpenStreeMap ao mapa do ggplot\n  tmaptools,\n  spdep\n  \n  ) \n\nVocê pode ter uma visão geral de todos os pacotes do R que lidam com dados espaciais em CRAN “Spatial Task View”.\n\n\nAmostra de dados dos casos\nPara fins de demonstração, iremos trabalhar com uma amostra aleatória de 1000 casos do dataframe da linelist de uma epidemia simulada de Ebola (computacionalmente, trabalhar com menos casos é mais fácil para mostrar nesse handbook). Se você quiser acompanhar a análise, clique aqui para baixar a linelist “limpa” (como um arquivo .rds).\nUma vez que estamos tomando uma amostra aleatória dos casos, seus resultados podem parecer ligeiramente diferentes do que está demonstrado aqui quando você rodar os códigos por conta própria.\nImporte os dados com a função import() do pacote rio (ela lida com vários tipos de arquivo como .xlsx, .csv, .rds - veja a página Importar and exportar para mais detalhes).\n\n# importa a linelist de casos limpa \nlinelist &lt;- rio::import(here::here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))  \n\nNext we select a random sample of 1000 rows using sample() from base R.\n\n# gera 1000 números aleatórios de linhas, a partir do número de linhas da linelist\nsample_rows &lt;- sample(nrow(linelist), 1000)\n\n# gera um subconjunto da linelist para manter apenas as linhas da amostra, e todas as colunas\nlinelist &lt;- linelist[sample_rows,]\n\nQueremos converter essa linelist, que possui a classe dataframe, para um objeto da classe “sf” (spatial features). Dado que a linelist possui duas colunas “lon” e “lat” representando a longitude e latitude da casa de cada caso, isso será fácil.\nUtilizamos o pacote sf (spatial features) e sua função st_as_sf() para criar um novo objeto que chamaremos de linelist_sf. Esse novo objeto parece essencialmente a mesma coisa que a linelist, mas as colunas lon e lat foram designadas como colunas de coordenadas, e um sistema de referência de coordenadas (SRC) foi atribuído para quando os pontos forem mostrados. O número 4326 identifica nossas coordenadas de acordo com o World Geodetic System 1984 (WGS84) - que é o padrão para coordenadas de GPS.\n\n# Cria um objeto do tipo sf\nlinelist_sf &lt;- linelist %&gt;%\n     sf::st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326)\n\nO dataframe da linelist original tem esta forma. Nesta demonstração, iremos utilizar apenas a coluna date_onset e geometry (que foi construída a partir dos campos de longitude e latitude acima e são as últimas colunas no dataframe).\n\nDT::datatable(head(linelist_sf, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )\n\n\n\n\n\n\n\nShapefiles das fronteiras administrativas\nSerra Leoa: Shapefiles das fronteiras administrativas\nDe antemão, já baixamos todas as fronteiras administrativas de Serra Leoa do site da Humanitarian Data Exchange (HDX) que você encontra aqui. Caso prefira, você pode baixar esse e todos os outros dados de exemplos para esse manual através de nosso pacote de R, conforme explicado na página Download dos dados no manual.\nAgora faremos o seguinte para salvar no R o shapefile do nível administrativo 3\n\nImportar o shapefile\n\nLimpar o nome das colunas\nFiltar linhas para manter apenas as áreas de interesse\n\nPara importar um shapefile usamos a função read_sf() do pacote sf. À ela é fornecido o caminho do arquivo através da função here(). - em nosso caso o arquivo está em nosso projeto R, nas subpastas “data”, “gis”, e “shp”, com o nome de arquivo “sle_adm3.shp” (veja as páginas Importar e exportar e Projetos R para mais informações). Você precisará fornecer seu próprio caminho de arquivo.\nEm seguida usamos a função clean_names() do pacote janitor para padronizar os nomes das colunas do shapefile. Também utilizamos filter() para manter apenas as linhas com a área administrativa 2 (admin2name) chamada “Western Area Urban” ou “Western Area Rural”.\n\n# nível ADM3 limpo\nsle_adm3 &lt;- sle_adm3_raw %&gt;%\n  janitor::clean_names() %&gt;% # padronizar o nome das colunas\n  filter(admin2name %in% c(\"Western Area Urban\", \"Western Area Rural\")) # filtrar para manter certas áreas\n\nAbaixo, podemos ver como fica o shapefile depois da importação e limpeza. Role para a direita para ver como há colunas com nível administrativo 0 (país), nível administrativo 1, nível administrativo 2, e finalmente nível administrativo 3. Cada nível tem um nome composto de letras e um identificador único chamado “pcode”. O pcode expande com cada nível administrativo que aumenta ex: SL (Serra Leoa) -&gt; SL04 (Oeste) -&gt; SL0410 (Area Rural do Oeste) -&gt; SL040101 (Koya Rural).\n\n\n\n\n\n\n\n\nDados populacionais\nSerra Leoa: População por ADM3\nNovamente, esses dados podem ser baixadados do site da HDX (link aqui) ou pelo pacote epirhandbook explicado nessa página. Usamos import() para carregar o arquivo .csv. Também passamos o arquivo importado para clean_names() para padronizar a sintaxe dos nomes das colunas.\n\n# População por nível ADM3\nsle_adm3_pop &lt;- import(here(\"data\", \"gis\", \"population\", \"sle_admpop_adm3_2020.csv\")) %&gt;%\n  janitor::clean_names()\n\nEssa é a aparência do arquivo de população. Role para a direita para ver como cada jurisdição tem colunas com a população masculina (male), feminina (female), e a população total, e as subdivisões nas colunas columns por grupo de idade.\n\n\n\n\n\n\n\n\nUnidades de Saúde\nSerra Leoa: Dados das Unidades de Saúde do OpenStreetMap\nNovamente, baixamos os locais das unidades de saúde do HDX aqui ou por meio das instruções na página manual de Download e dados.\nNós importamos o shapefile dos pontos das unidades com read_sf(), e novamente limpamos os nomes das colunas, e depois, filtramos para manter apenas os pontos marcados com “hospital”, clínica (“clinic”), ou doutores (“doctors”).\n\n# shapefile das unidades de saúde do OSM (open street map) \nsle_hf &lt;- sf::read_sf(here(\"data\", \"gis\", \"shp\", \"sle_hf.shp\")) %&gt;% \n  janitor::clean_names() %&gt;%\n  filter(amenity %in% c(\"hospital\", \"clinic\", \"doctors\"))\n\nAqui está o dataframe resultante - role para a direita para ver o nome da unidade e as coordenadas de geometria (geometry).",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Introdução ao GIS</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.pt.html#criando-gráficos-das-coordenadas",
    "href": "new_pages/gis.pt.html#criando-gráficos-das-coordenadas",
    "title": "28  Introdução ao GIS",
    "section": "28.5 Criando gráficos das coordenadas",
    "text": "28.5 Criando gráficos das coordenadas\nA forma mais fácil de criar um gráfico de coordenadas X-Y (longitude/latitude, pontos), nessa situação dos casos, é desenhenhá-los como pontos diretamente do objeto linelist_sf que criamos na seção de preparação.\nO pacote tmap oferece algumas capacidades simples de fazer mapas tanto de forma estática ( modo “plot”) quanto interativa ( modo de visualização - “view”) com apenas algumas linhas de código. A sintaxe do tmap é parecida com a do ggplot2, de forma que os comandos são somados uns aos outros com o operador +. Veja mais detalhes nessa vignette.\n\nDefina o modo do tmap. Neste caso iremos utilizar o modo “plot”, que produz saídas estáticas.\n\n\ntmap_mode(\"plot\") # escolha entre \"view\" ou \"plot\"\n\nAbaixo, os pontos são projetados sozinhos. A função tm_shape() é disponibilizada com os objetos linelist_sf. Em seguida, adicionamos pontos via tm_dots(), especificando o tamanho e a cor. Pelo fato de linelist_sf ser um objeto do tipo sf, nós já temos as duas colunas designadas que contêm as coordenadas de latitude e longitude e o sistema de referência de coordenadas (CRS):\n\n# Apenas os casos (pontos)\ntm_shape(linelist_sf) + tm_dots(size=0.08, col='blue')\n\n\n\n\n\n\n\n\nSozinhos os pontos não nos dizem muita coisa. Então devemos também projetar as fronteiras administrativas:\nNovamente, utilizaremos tm_shape() (veja a documentação) mas em vez de fornecer o shapefile com os pontos dos casos, forneceremos o shapefile das fronteiras administrativas (polygons).\nCom o argumento bbox = (bbox significa “bounding box”) podemos especificar as coordenadas das fronteiras. Primeiro mostramos o mapa sem bbox, e depois com ele.\n\n# Apenas as fronteiras administrativas (polígonos)\ntm_shape(sle_adm3) +               # shapefile das fronteiras administrativas\n  tm_polygons(col = \"#F7F7F7\") +    # exibir os polígonos em cinza claro \n  tm_borders(col = \"#000000\",      # exibir as bordas com cor e peso de linha\n             lwd = 2) +\n  tm_text(\"admin3name\")            # coluna de texto para mostrar para cada polígono\n\n\n# Mesmo que acima, mas com zoom à partir do bounding box\ntm_shape(sle_adm3,\n         bbox = c(-13.3, 8.43,    # vértice (do bounding box) \n                  -13.2, 8.5)) +  # vértice (do bounding box)\n  tm_polygons(col = \"#F7F7F7\") +\n  tm_borders(col = \"#000000\", lwd = 2) +\n  tm_text(\"admin3name\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nE agora ambos, pontos e polígonos juntos:\n\n# Todos juntos \ntm_shape(sle_adm3, bbox = c(-13.3, 8.43, -13.2, 8.5)) +     #\n  tm_polygons(col = \"#F7F7F7\") +\n  tm_borders(col = \"#000000\", lwd = 2) +\n  tm_text(\"admin3name\")+\ntm_shape(linelist_sf) +\n  tm_dots(size=0.08, col='blue', alpha = 0.5) +\n  tm_layout(title = \"Distribution of Ebola cases\")   # Dá título ao gráfico \n\n\n\n\n\n\n\n\nPara ler uma boa comparação das diferentes opções de criação de mapas no R, leia esse blog post.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Introdução ao GIS</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.pt.html#joins-espaciais",
    "href": "new_pages/gis.pt.html#joins-espaciais",
    "title": "28  Introdução ao GIS",
    "section": "28.6 “Joins” Espaciais",
    "text": "28.6 “Joins” Espaciais\nVocê deve estar familiarizado com o conceito de fazer join dos dados de uma base em outra. Vários métodos são discutidos na página Juntando dados desse manual. Um “join espacial” tem um propósito similar, mas lidando com os relacionamentos espaciais dos dados. Em vez de utilizar valores comuns às colunas para parear corretamente as observações, você pode utilizar as relações espaciais deles, tais como o fato de uma característica estar contida em outra, ou de um ponto ser o vizinho mais próximo de outro, ou contido na área de influência (buffer) de um certo raio de outro, etc.\nO pacote sf oferece vários métodos para fazer joins espaciais. Veja mais na documentação sobre o métodos st_join e outros tipos de join espaciais nessa referência.\n\nPontos no polígono\nRelaciona unidades administrativas aos casos\nAqui temos um dilema interessante: a linelist dos casos não contém nenhuma informação sobre as unidades administrativas dos casos. Apesar do ideal ser coletar esse tipo de informação nas fases iniciais da coleta de dados, nós também podemos relacionar as unidades administrativas aos casos individuais baseado em seus relacionamentos espaciais (ex: pontos que intersectam com um polígono).\nAbaixo, vamos fazer a intersecção espacial dos locais de nossos casos (pontos) com as fronteiras ADM3 (polígonos):\n\nComece com a linelist (pontos)\n\nFaça o join espacial com as fronteiras, defina o tipo do join em “st_intersects”\n\nUtilize select() para manter apenas algumas das novas colunas das fronteiras administrativas\n\n\nlinelist_adm &lt;- linelist_sf %&gt;%  # faça join do arquivo com as fronteiras administrativas com o da linelist, baseado na intersecção espacial\n  sf::st_join(sle_adm3, join = st_intersects)\n\nTodas as colunas de sle_adms foram adicionadas à linelist! Agora cada caso possui colunas detalhando os níveis administativos onde eles se encontram. Nesse exemplo, queremos manter apenas duas das novas colunas (admin level 3), então usamos select() nos nomes das colunas antigas e apenas nas duas novas que temos interesse:\n\nlinelist_adm &lt;- linelist_sf %&gt;%   # faça join do arquivo com as fronteiras administrativas com o da linelist, baseado na intersecção espacial\n  sf::st_join(sle_adm3, join = st_intersects) %&gt;% \n   # Mantém os nomes das colunas antigas e as duas novas de interessa das áreas administrativas\n  select(names(linelist_sf), admin3name, admin3pcod)\n\nVocê pode ver abaixo, apenas para fins de conferência, os primeiros dez casos e as jurisdições de seus níveis administrativos 3 (ADM3) que foram anexadas baseados em onde o ponto intersectou espacialmente com as formas dos polígonos.\n\n# Agora você verá os nomes AD3 anexados a cada caso.\nlinelist_adm %&gt;% select(case_id, admin3name, admin3pcod)\n\nSimple feature collection with 1000 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -13.27117 ymin: 8.448447 xmax: -13.20698 ymax: 8.490944\nGeodetic CRS:  WGS 84\nFirst 10 features:\n     case_id     admin3name admin3pcod                   geometry\n711   5295cb        West II   SL040207 POINT (-13.24849 8.465759)\n7     07e3e8        West II   SL040207 POINT (-13.23315 8.462729)\n4071  342054       West III   SL040208 POINT (-13.25897 8.456651)\n986   2b883d       West III   SL040208 POINT (-13.25968 8.453271)\n2407  80fdfb Mountain Rural   SL040102 POINT (-13.21994 8.477752)\n1249  fe2b09       West III   SL040208  POINT (-13.26255 8.48072)\n2358  b56b84        West II   SL040207   POINT (-13.23095 8.4644)\n2752  59eb95       West III   SL040208  POINT (-13.26567 8.46054)\n3696  02b80b Mountain Rural   SL040102 POINT (-13.21571 8.463513)\n1268  a76671        West II   SL040207 POINT (-13.23777 8.468819)\n\n\nAgora podemos descrever nossos casos por unidade administrativa - algo que não era possível antes do join espacial!\n\n# Cria um novo dataframe contendo as contagens de casos por unidade administrativa\ncase_adm3 &lt;- linelist_adm %&gt;%          # inicia com a lineliste contendo as novas colunas administrativas \n  as_tibble() %&gt;%                      # converte para tibble para melhor exibição\n  filter(!is.na(admin3pcod))%&gt;%\n  group_by(admin3pcod, admin3name) %&gt;% # agrupa por unidade administrativa, por nome e pcode \n  summarise(cases = n()) %&gt;%           # resume e conta as linhas \n  arrange(desc(cases))                 # organiza em ordem descentente \n\ncase_adm3\n\n# A tibble: 9 × 3\n# Groups:   admin3pcod [9]\n  admin3pcod admin3name     cases\n  &lt;chr&gt;      &lt;chr&gt;          &lt;int&gt;\n1 SL040102   Mountain Rural   323\n2 SL040208   West III         221\n3 SL040207   West II          157\n4 SL040204   East II          103\n5 SL040201   Central I         62\n6 SL040203   East I            52\n7 SL040206   West I            38\n8 SL040202   Central II        25\n9 SL040205   East III          16\n\n\nTambém podemos criar um gráfico de barras com as contagens dos casos por unidade administrativa.\nNesse exemplo, iniciamos o ggplot() com linelist_adm, de forma que podemos aplicar as funções de fatores como fct_infreq() que ordena as barras por frequência (veja a página de Fatores para dicas).\n\nggplot(\n    data = linelist_adm,                     # inicia com linelist contendo informações das unidades administrativas \n    mapping = aes(\n      x = fct_rev(fct_infreq(admin3name))))+ # eixo x são unidades administrativas, ordenadas por frequência (reversa) \n  geom_bar()+                                # cria as barras, altura é o número de linhas \n  coord_flip()+                              # inverte os eixos X e Y para facilitar a leitura das unidades administrativas\n  theme_classic()+                           # simplifica a cor de fundo do gráfico \n  labs(                                      # títulos e rótulos \n    x = \"Admin level 3\",\n    y = \"Number of cases\",\n    title = \"Number of cases, by adminstative unit\",\n    caption = \"As determined by a spatial join, from 1000 randomly sampled cases from linelist\"\n  )\n\n\n\n\n\n\n\n\n\n\n\nVizinho mais próximo\nAchando a unidade de saúde / área de influência mais próxima\nPode ser útil saber onde as unidades de saúde estão localizadas em relação aos hotspots das doenças.\nPodemos utilizar o método de join st_nearest_feature da função st_join() (do pacote sf) para visualizar as unidades de saude mais próximas aos casos individuais.\n\nIniciamos com o shapefile da linelist: linelist_sf\n\nFazemos o join espacial com sle_hf, que possui os locais das unidades de saúde e clínicas (pontos)\n\n\n# Unidade de saúde mais próxima a cada caso\nlinelist_sf_hf &lt;- linelist_sf %&gt;%                  # inicia com o shapefile da linelist \n  st_join(sle_hf, join = st_nearest_feature) %&gt;%   # dados da clínica mais próxima com join nos dados dos casos \n  select(case_id, osm_id, name, amenity) %&gt;%       # mantém as colunas de interesse, incluindo id, nome, tipo, e geometria da unidade de saúde\n  rename(\"nearest_clinic\" = \"name\")                # renomeia para uma maior clareza\n\nPodemos ver abaixo (primeiras 50 linhas) que cada caso agora possui dados sobre as clínicas/hospitais mais próximos\n\n\n\n\n\n\nPodemos ver que “Den Clinic” é a unidade de saúde mais próxima de cerca de 30% dos casos.\n\n# Conta os casos por unidade de saúde\nhf_catchment &lt;- linelist_sf_hf %&gt;%   # inicia com a linelist incluindo os dados das clínicas mais próximas \n  as.data.frame() %&gt;%                # converte o shapefile em dataframe \n  count(nearest_clinic,              # conta linhas por nome (da clínica) \n        name = \"case_n\") %&gt;%         # define a nova coluna de contagens como \"case_n\"\n  arrange(desc(case_n))              # organiza em ordem descrescente\n\nhf_catchment                         # imprime no console\n\n                         nearest_clinic case_n\n1       Shriners Hospitals for Children    354\n2                            Den Clinic    344\n3         GINER HALL COMMUNITY HOSPITAL    171\n4                             panasonic     54\n5 Princess Christian Maternity Hospital     32\n6                     ARAB EGYPT CLINIC     21\n7                                  &lt;NA&gt;     14\n8                  MABELL HEALTH CENTER     10\n\n\nPara visualizar os resultados, podemos utilizar tmap - dessa vez, no modo interativo para facilitar a visualização\n\ntmap_mode(\"view\")   # define o modo do tmap para interativo \n\n# gera o gráfico dos pontos dos casos e clínicas \ntm_shape(linelist_sf_hf) +            # gera o gráfico dos casos \n  tm_dots(size=0.08,                  # colore os casos pelas clínicas mais próximas \n          col='nearest_clinic') +    \ntm_shape(sle_hf) +                    # adiciona as clínicas ao gráfico como grandes pontos pretos\n  tm_dots(size=0.3, col='black', alpha = 0.4) +      \n  tm_text(\"name\") +                   # sobrepõe com o nome \ntm_view(set.view = c(-13.2284, 8.4699, 13), # ajusta o zoom (centra as coordenadas, e define o zoom)\n        set.zoom.limits = c(13,14))+\ntm_layout(title = \"Cases, colored by nearest clinic\")\n\n\n\n\n\n\n\nÁreas de Influência (Buffers)\nTambém podemos explorar quantos casos estão localizados em uma distância a pé de 2.5km (~30 min) da unidade de saúde mais próxima.\nNota: Para cálculos de distância mais precisos, é melhor re-projetar seu objeto sf ao sistema de projeção do local respectivo, tal como UTM (Terra projetada sobre uma superfície plana). Nesse exemplo, para fins de simplicidade vamos nos ater ao sistema de coordenadas do Sistema Geodésico Mundial (WGS84) (Terra representada em uma superfície esférica / redonda, portanto, as unidades estão em graus decimais). Utilizaremos uma conversão geral de: 1 grau decimal = ~111km.\nVeja mais informações sobre projeções de mapas e sistemas de coordenadas nesse artigo da esri. Esse blog fala sobre diferentes tipos de projeções de mapas e como cada uma delas pode ser escolhida dependendo da área de interesse e o contexto do seu mapa / análise.\nPrimeiro, crie uma área de influência circular com um raio de ~2.5km ao redor de cada unidade de saúde. Isso é feito com a função st_buffer() do pacote tmap. Pelo fato das unidades do mapa estarem em lat/long em graus decimais, é assim que “0.02” será interpretado. Se o sistema de coordenadas do seu mapa for em metros, o número deve ser fornecido em metros.\n\nsle_hf_2k &lt;- sle_hf %&gt;%\n  st_buffer(dist=0.02)       # graus decimais representando aprox. 2.5km \n\nAbaixo criamos o gráfico das zonas de influência propriamente ditas, com:\n\ntmap_mode(\"plot\")\n# Cria as zonas de influência circulares\ntm_shape(sle_hf_2k) +\n  tm_borders(col = \"black\", lwd = 2)+\ntm_shape(sle_hf) +                    # adiciona as clínicas ao gráfico como grandes pontos vermelhos \n  tm_dots(size=0.3, col='black')      \n\n\n\n\n\n\n\n\nSegundo, intersectamos essas áreas de influência com os casos (pontos) utilizando st_join() e com o tipo de join st_intersects. Ou seja, join dos dados das áreas de influência com os pontos que eles intersectam.\n\n# Intersecta os casos com as áreas de influência\nlinelist_sf_hf_2k &lt;- linelist_sf_hf %&gt;%\n  st_join(sle_hf_2k, join = st_intersects, left = TRUE) %&gt;%\n  filter(osm_id.x==osm_id.y | is.na(osm_id.y)) %&gt;%\n  select(case_id, osm_id.x, nearest_clinic, amenity.x, osm_id.y)\n\nAgora podemos contar os resultados: nrow(linelist_sf_hf_2k[is.na(linelist_sf_hf_2k$osm_id.y), ]) dos 1000 casos não intersectam com nenhuma área de influência (esses valores estão faltando), e então residem a mais de 30 min a pé da da unidade de saúde mais próxima.\n\n# Casos que não intesectaram com nenhuma das áreas de influência das unidades de saúde\nlinelist_sf_hf_2k %&gt;% \n  filter(is.na(osm_id.y)) %&gt;%\n  nrow()\n\n[1] 1000\n\n\nPodemos visualizar os resultados de forma que os casos que não intersectam apareçam em vermelho.\n\ntmap_mode(\"view\")\n\n# Primeiro mostra os casos como pontos\ntm_shape(linelist_sf_hf) +\n  tm_dots(size=0.08, col='nearest_clinic') +\n\n# adiciona as clínicas como grandes pontos pretos\ntm_shape(sle_hf) +                    \n  tm_dots(size=0.3, col='black')+   \n\n# Depois sobrepõe as áreas de influência das unidades de saúde como polilinhas\ntm_shape(sle_hf_2k) +\n  tm_borders(col = \"black\", lwd = 2) +\n\n# Destaca os casos que não são parte de nenhuma área de influência das unidades de saúde\n# como pontos vermelhos\ntm_shape(linelist_sf_hf_2k %&gt;%  filter(is.na(osm_id.y))) +\n  tm_dots(size=0.1, col='red') +\ntm_view(set.view = c(-13.2284,8.4699, 13), set.zoom.limits = c(13,14))+\n\n# adiciona título  \ntm_layout(title = \"Cases by clinic catchment area\")\n\n\n\n\n\n\n\nOutros joins espaciais\nValores alternativos para o argumento join incluem (a partir da documentação)\n\nst_contains_properly\n\nst_contains\n\nst_covered_by\n\nst_covers\n\nst_crosses\n\nst_disjoint\n\nst_equals_exact\n\nst_equals\n\nst_is_within_distance\n\nst_nearest_feature\n\nst_overlaps\n\nst_touches\n\nst_within",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Introdução ao GIS</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.pt.html#mapas-coropléticos",
    "href": "new_pages/gis.pt.html#mapas-coropléticos",
    "title": "28  Introdução ao GIS",
    "section": "28.7 Mapas coropléticos",
    "text": "28.7 Mapas coropléticos\nMapas coropléticos podem ser úteis para visualizar seus dados por áreas pré-definidas, geralmente unidades administrativas ou de saúde. Nas respostas aos surtos isso pode ajudar a direcionar a alocação de recursos para áreas específicas com altas taxas de incidência, por exemplo.\nAgora que já temos os nomes das unidades administrativas associadas a todos os casos (veja a seção sobre joins espaciais, acima), podemos começar a mapear as contagens dos casos por área (mapas coropléticos)\nUma vez que também temos dados de população por ADM3, podemos adicionar essas informações à tabela case_adm3 criada anteriormente.\nVamos começar com o dataframe case_adm3 criado no passo anterior, que é uma tabela resumo com cada unidade administrativa e seus números de casos.\n\nOs dados populacionais sle_adm3_pop são obtidos utilizando left_join() do pacote dplyr com base nos valores comuns ao longo das colunas admin3pcod no dataframe case_adm3, e coluna adm_pcode no dataframe sle_adm3_pop. Veja a página Juntando dados).\n\nselect() é aplicado ao novo dataframe, para manter apenas as colunas úteis - total é a população total\nCasos por 10,000 é calculado como uma nova coluna com mutate()\n\n\n# Adiciona dados populacionais e calcula casos por 10mil \ncase_adm3 &lt;- case_adm3 %&gt;% \n     left_join(sle_adm3_pop,                             # adiciona colunas da base 'pop' \n               by = c(\"admin3pcod\" = \"adm3_pcode\")) %&gt;%  # faz join baseado nos valores comum ao longo dessas duas colunas \n     select(names(case_adm3), total) %&gt;%                 # mantém apenas as colunas importantes, incluindo população total\n     mutate(case_10kpop = round(cases/total * 10000, 3)) # cria uma nova coluna com taxa de casos por 10000, arredondando para 3 casas decimais\n\ncase_adm3                                                # imprime no console para visualização\n\n# A tibble: 9 × 5\n# Groups:   admin3pcod [9]\n  admin3pcod admin3name     cases  total case_10kpop\n  &lt;chr&gt;      &lt;chr&gt;          &lt;int&gt;  &lt;int&gt;       &lt;dbl&gt;\n1 SL040102   Mountain Rural   323  33993       95.0 \n2 SL040208   West III         221 210252       10.5 \n3 SL040207   West II          157 145109       10.8 \n4 SL040204   East II          103  99821       10.3 \n5 SL040201   Central I         62  69683        8.90\n6 SL040203   East I            52  68284        7.62\n7 SL040206   West I            38  60186        6.31\n8 SL040202   Central II        25  23874       10.5 \n9 SL040205   East III          16 500134        0.32\n\n\nFaz join dessa tabela com os polígonos do shapefile de ADM3 para poder mapeá-los\n\ncase_adm3_sf &lt;- case_adm3 %&gt;%                 # inicia com casos e taxas por unidade administrativa\n  left_join(sle_adm3, by=\"admin3pcod\") %&gt;%    # faz join dos dados do shapefile por coluna comum\n  select(objectid, admin3pcod,                # mantém apenas algumas colunas de interesse\n         admin3name = admin3name.x,           # limpa o nome de uma coluna\n         admin2name, admin1name,\n         cases, total, case_10kpop,\n         geometry) %&gt;%                        # mantém a geometria de forma que os polígonos possam ser adicionados ao gráfico\n  st_as_sf()                                  # converte para shapefile\n\nMapeando os resultados\n\n# modo do tmap \ntmap_mode(\"plot\")               # visualiza o mapa estático \n\n# adiciona os polígonos\ntm_shape(case_adm3_sf) + \n        tm_polygons(\"cases\") +  # colore pela coluna de número de casos\n        tm_text(\"admin3name\")   # nome exibido\n\n\n\n\n\n\n\n\nTambém podemos mapear as taxas de incidência\n\n# Casos por 10mil \ntmap_mode(\"plot\")             # modo de visualização estática\n\n# gráfico\ntm_shape(case_adm3_sf) +                # adiciona polígonos ao mapa \n  tm_polygons(\"case_10kpop\",            # colore pelas colunas contendo a taxa de casos\n              breaks=c(0, 10, 50, 100), # define os pontos de quebra para as cores \n              palette = \"Purples\"       # utiliza uma paleta de cor roxa\n              ) +\n  tm_text(\"admin3name\")                 # exibe o texto",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Introdução ao GIS</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.pt.html#criando-mapas-com-ggplot2",
    "href": "new_pages/gis.pt.html#criando-mapas-com-ggplot2",
    "title": "28  Introdução ao GIS",
    "section": "28.8 Criando mapas com ggplot2",
    "text": "28.8 Criando mapas com ggplot2\nSe você já está familiarizado em usar o ggplot2, você pode usar esse pacote para criar mapas estáticos de seus dados. A função geom_sf() vai desenhar diferentes objetos baseados em quais características (pontos, linhas ou polígonos) estão em seus dados. Por exemplo, você pode usar geom_sf() em um ggplot() utilizando dados sf com geometria de polígonos para criar um mapa coroplético.\nPara ilustrar como isso funciona, podemos iniciar com os polígonos do shapefile de ADM3 que utilizamos anteriormente. Lembre-se que esses são regiões de Níveis Administrativos 3 em Serra Leoa:\n\nsle_adm3\n\nSimple feature collection with 12 features and 19 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -13.29894 ymin: 8.094272 xmax: -12.91333 ymax: 8.499809\nGeodetic CRS:  WGS 84\n# A tibble: 12 × 20\n   objectid admin3name   admin3pcod admin3ref_n admin2name admin2pcod admin1name\n *    &lt;dbl&gt; &lt;chr&gt;        &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;     \n 1      155 Koya Rural   SL040101   Koya Rural  Western A… SL0401     Western   \n 2      156 Mountain Ru… SL040102   Mountain R… Western A… SL0401     Western   \n 3      157 Waterloo Ru… SL040103   Waterloo R… Western A… SL0401     Western   \n 4      158 York Rural   SL040104   York Rural  Western A… SL0401     Western   \n 5      159 Central I    SL040201   Central I   Western A… SL0402     Western   \n 6      160 East I       SL040203   East I      Western A… SL0402     Western   \n 7      161 East II      SL040204   East II     Western A… SL0402     Western   \n 8      162 Central II   SL040202   Central II  Western A… SL0402     Western   \n 9      163 West III     SL040208   West III    Western A… SL0402     Western   \n10      164 West I       SL040206   West I      Western A… SL0402     Western   \n11      165 West II      SL040207   West II     Western A… SL0402     Western   \n12      167 East III     SL040205   East III    Western A… SL0402     Western   \n# ℹ 13 more variables: admin1pcod &lt;chr&gt;, admin0name &lt;chr&gt;, admin0pcod &lt;chr&gt;,\n#   date &lt;date&gt;, valid_on &lt;date&gt;, valid_to &lt;date&gt;, shape_leng &lt;dbl&gt;,\n#   shape_area &lt;dbl&gt;, rowcacode0 &lt;chr&gt;, rowcacode1 &lt;chr&gt;, rowcacode2 &lt;chr&gt;,\n#   rowcacode3 &lt;chr&gt;, geometry &lt;MULTIPOLYGON [°]&gt;\n\n\nPodemos utilizar a função left_join() do pacote dplyr para adicionar dados que queremos mapear ao objeto shapefile. Nesse caso, vamos utilizar o dataframe case_adm3 que criamos anterioremente para resumir a contagem de casos por regiões administrativas; no entanto, podemos utilizar essa mesma abordagem para mapear qualquer dado armazenado no dataframe.\n\nsle_adm3_dat &lt;- sle_adm3 %&gt;% \n  inner_join(case_adm3, by = \"admin3pcod\") # inner join = mantém apenas se existir em ambos os objetos\n\nselect(sle_adm3_dat, admin3name.x, cases) # imprime as variáveis selecionadas no console\n\nSimple feature collection with 9 features and 2 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -13.29894 ymin: 8.384533 xmax: -13.12612 ymax: 8.499809\nGeodetic CRS:  WGS 84\n# A tibble: 9 × 3\n  admin3name.x   cases                                                  geometry\n  &lt;chr&gt;          &lt;int&gt;                                        &lt;MULTIPOLYGON [°]&gt;\n1 Mountain Rural   323 (((-13.21496 8.474341, -13.21479 8.474289, -13.21465 8.4…\n2 Central I         62 (((-13.22646 8.489716, -13.22648 8.48955, -13.22644 8.48…\n3 East I            52 (((-13.2129 8.494033, -13.21076 8.494026, -13.21013 8.49…\n4 East II          103 (((-13.22653 8.491883, -13.22647 8.491853, -13.22642 8.4…\n5 Central II        25 (((-13.23154 8.491768, -13.23141 8.491566, -13.23144 8.4…\n6 West III         221 (((-13.28529 8.497354, -13.28456 8.496497, -13.28403 8.4…\n7 West I            38 (((-13.24677 8.493453, -13.24669 8.493285, -13.2464 8.49…\n8 West II          157 (((-13.25698 8.485518, -13.25685 8.485501, -13.25668 8.4…\n9 East III          16 (((-13.20465 8.485758, -13.20461 8.485698, -13.20449 8.4…\n\n\nPara fazer um gráfico de colunas com contagem de casos por região, utilizando ggplot2, podemos então utilizar geom_col() dessa forma:\n\nggplot(data=sle_adm3_dat) +\n  geom_col(aes(x=fct_reorder(admin3name.x, cases, .desc=T), # reordena o eixo x 'cases' de forma decrescente \n               y=cases)) +                                  # eixo y é o número de casos por região\n  theme_bw() +\n  labs(                                                     # define o texto da figura \n    title=\"Number of cases, by administrative unit\",\n    x=\"Admin level 3\",\n    y=\"Number of cases\"\n  ) + \n  guides(x=guide_axis(angle=45))                            # angula os rótulos do eixo x para 45 graus para caber melhor\n\n\n\n\n\n\n\n\nSe quisermos utilizar o ggplot2 para fazer um mapa coroplético da contagem dos casos, podemos utilizar uma sintaxe parecida para chamar a função geom_sf():\n\nggplot(data=sle_adm3_dat) + \n  geom_sf(aes(fill=cases))    # define a cor de preenchimento (fill) para variar de acordo com a variável de contagem dos casos \n\n\n\n\n\n\n\n\nPodemos customizar a aparência de nosso mapa utilizando a gramática que é consistente no ggplot2, por exemplo:\n\nggplot(data=sle_adm3_dat) +                           \n  geom_sf(aes(fill=cases)) +                        \n  scale_fill_continuous(high=\"#54278f\", low=\"#f2f0f7\") + # muda a cor do gradiente\n  theme_bw() +\n  labs(title = \"Number of cases, by administrative unit\",    # define o texto da figura \n       subtitle = \"Admin level 3\"\n  )\n\n\n\n\n\n\n\n\nPara usuários de R que estão confortáveis em trabalhar com ggplot2, a função geom_sf() oferece uma implementação simples e direta que é adequada para visualizações básicas de mapas. Para aprender mais, leia a vinheta do geom_sf() ou o livro do ggplot2.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Introdução ao GIS</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.pt.html#mapas-base-basemaps",
    "href": "new_pages/gis.pt.html#mapas-base-basemaps",
    "title": "28  Introdução ao GIS",
    "section": "28.9 Mapas Base (Basemaps)",
    "text": "28.9 Mapas Base (Basemaps)\n\nOpenStreetMap\nDescrevemos abaixo como gerar um mapa base (basemap) para um mapa do ggplot2 utilizando funcionalidades do OpenStreetMap. Métodos alternativos incluem utilizar o ggmap que requer um cadastro gratuito via Google (detalhes).\nOpenStreetMap é um projeto colaborativo para criar um mapa do mundo editável e gratuito. Os dados de geolocalização fundamentais (ex: localidades de cidades, estradas, características naturais, aeroportos, escolas, hospitais, etc) são considerados as saídas (outputs) principais do projeto.\nPrimeiro carregamos o pacote OpenStreetMap, de onde pegaremos nosso mapa base.\nDepois, criamos o objeto map, o qual definimos utilizando a função openmap() do pacote OpenStreetMap (documentação). Passaremos os seguintes argumentos para função:\n\nupperLeft e lowerRight dois pares de coordenadas especificando os limites do tile do mapa base\n\nNesse caso inserimos o max e min das linhas da linelist, para que o mapa responda dinamicamente aos dados\n\nzoom = (se não for preenchido será determinado automaticamente)\n\ntype = qual tipo de mapa base - listamos várias possibilidades aqui e o código está utilizando a primeira delas ([1]) “osm”\n\nmergeTiles = optamos por TRUE para que os tiles base sejam mesclados em um só\n\n\n# carrega o pacote \npacman::p_load(OpenStreetMap)\n\n# Ajusta o mapa base pelo intervalo das coordenadas de lat/long. Define o tipo do tile \nmap &lt;- openmap(\n  upperLeft = c(max(linelist$lat, na.rm=T), max(linelist$lon, na.rm=T)),   # limites do tile do mapa base\n  lowerRight = c(min(linelist$lat, na.rm=T), min(linelist$lon, na.rm=T)),\n  zoom = NULL,\n  type = c(\"osm\", \"stamen-toner\", \"stamen-terrain\", \"stamen-watercolor\", \"esri\",\"esri-topo\")[1])\n\nSe executarmos esse mapa base nesse momento, utilizando autoplot.OpenStreetMap() do pacote OpenStreetMap, você verá que as unidades nos eixos não são coordenadas de latitude/longitude. Ele está utilizando um sistema de coordenadas diferente. Para mostrar corretamente as residências dos casos (que estão armazenados em lat/long), isso precisa ser modificado.\n\nautoplot.OpenStreetMap(map)\n\n\n\n\n\n\n\n\nAssim, nossa intenção é converter o mapa para latitude/longitude com a função openproj() do pacote OpenStreetMap. Nós passamos para a função o mapa base map e também o Sistema de Referência de Coordenadas (SRC) que queremos. Fazemos isso passando a string do tipo “proj.4” para a projeção WGS 1984, mas você pode passar o SRC de outras formas também. (veja esta página para compreender melhor do que se trata uma string do tipo proj.4)\n\n# Projeção WGS84\nmap_latlon &lt;- openproj(map, projection = \"+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs\")\n\nAgora, quando executamos o mapa, vemos que ao longo dos eixos estão as coordenadas de latitude e longitude. O sistema de coordenadas foi convertido. Agora todos os nossos casos serão mostrados corretamente se sobrepostos ao mapa!\n\n# Gera o mapa. É necessário usar \"autoplot\" para funcionar com o ggplot\nautoplot.OpenStreetMap(map_latlon)\n\n\n\n\n\n\n\n\nVeja os tutoriais aqui e aqui para mais informações.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Introdução ao GIS</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.pt.html#mapas-de-calor-de-densidade-com-contornos",
    "href": "new_pages/gis.pt.html#mapas-de-calor-de-densidade-com-contornos",
    "title": "28  Introdução ao GIS",
    "section": "28.10 Mapas de calor de densidade com contornos",
    "text": "28.10 Mapas de calor de densidade com contornos\nAbaixo descrevemos como gerar um mapa de calor de densidade com contornos para os dados dos casos, sobre um mapa base, a partir de uma linelist (uma linha por caso).\n\nCria o tile do mapa base a partir do OpenStreetMap, como descrito acima.\nAdiciona os casos da linelist utilizando as colunas de latitude e longitude\nConverte os pontos para um mapa de calor de densidade com stat_density_2d() do ggplot2,\n\nQuando temos um mapa base com coordenadas lat/long, podemos sobrepor nossos casos utilizando as coordenadas lat/long de suas residências.\nUtilizando a função autoplot.OpenStreetMap() para criar o mapa base, as funções do ggplot2 podem facilmente sobrepor camadas sobre ele, como mostrado com geom_point() abaixo:\n\n# Gera o mapa. É necessário usar \"autoplot\" para funcionar com o ggplot\nautoplot.OpenStreetMap(map_latlon)+                 # inicia com o mapa base\n  geom_point(                                       # adiciona os pontos xy a partir das colunas lo e lat da linelist\n    data = linelist,                                \n    aes(x = lon, y = lat),\n    size = 1, \n    alpha = 0.5,\n    show.legend = FALSE) +                          # remove a legenda completamente \n  labs(x = \"Longitude\",                             # títulos e rótulos \n       y = \"Latitude\",\n       title = \"Cumulative cases\")\n\n\n\n\n\n\n\n\nO mapa acima pode ser difícil de interpretar, principalmente pelos pontos se soprepondo. Então, você pode, ao invés, gerar um mapa de densidade 2d utilizando a função stat_density_2d() do ggplot2. Você ainda estará utilizando as coordenadas lat/lon da linelist, mas uma estimativa de densidade por kernel 2D será calculada e os resultados serão mostrados como linhas de contorno - como em um mapa topográfico. Leia a documentação aqui.\n\n# inicia com um mapa base\nautoplot.OpenStreetMap(map_latlon)+\n  \n  # adiciona o mapa de densidade \n  ggplot2::stat_density_2d(\n        data = linelist,\n        aes(\n          x = lon,\n          y = lat,\n          fill = ..level..,\n          alpha = ..level..),\n        bins = 10,\n        geom = \"polygon\",\n        contour_var = \"count\",\n        show.legend = F) +                          \n  \n  # especifica a escala de cores \n  scale_fill_gradient(low = \"black\", high = \"red\")+\n  \n  # rótulos \n  labs(x = \"Longitude\",\n       y = \"Latitude\",\n       title = \"Distribution of cumulative cases\")\n\n\n\n\n\n\n\n\n\n\nMapa de calor de séries temporais\nO mapa de calor de densidade acima mostra os casos cumulativos. Podemos investigar o surto ao longo do tempo e espaço dividindo o mapa de calor em facetas baseadas no mês de início dos sintomas (symptom onset), derivado da linelist.\nComeçamos com a linelist, criando uma nova coluna com o Ano (Year) e Mês (Month) do início. A função format() do R base modifica a forma como a data é exibida. Nesse caso, queremos o formato “YYYY-MM”.\n\n# Extrai o mês de início\nlinelist &lt;- linelist %&gt;% \n  mutate(date_onset_ym = format(date_onset, \"%Y-%m\"))\n\n# Investiga os valores \ntable(linelist$date_onset_ym, useNA = \"always\")\n\n\n2014-05 2014-06 2014-07 2014-08 2014-09 2014-10 2014-11 2014-12 2015-01 2015-02 \n     13      13      35      88     196     179     135      87      76      64 \n2015-03 2015-04    &lt;NA&gt; \n     38      32      44 \n\n\nAgora, nós simplesmente adicionamos as facetas via ggplot2 ao mapa de calor de densidade. Aplicamos a função facet_wrap(), utilizando a nova coluna como linhas. Nós definimos o número de colunas das facetas para 4, para fins de clareza.\n\n# pacotes \npacman::p_load(OpenStreetMap, tidyverse)\n\n# inicia com o mapa base\nautoplot.OpenStreetMap(map_latlon)+\n  \n  # adiciona o mapa de densidade \n  ggplot2::stat_density_2d(\n        data = linelist,\n        aes(\n          x = lon,\n          y = lat,\n          fill = ..level..,\n          alpha = ..level..),\n        bins = 10,\n        geom = \"polygon\",\n        contour_var = \"count\",\n        show.legend = F) +                          \n  \n  # especifica a escala de cores \n  scale_fill_gradient(low = \"black\", high = \"red\")+\n  \n  # rótulos \n  labs(x = \"Longitude\",\n       y = \"Latitude\",\n       title = \"Distribution of cumulative cases over time\")+\n  \n  # gera as facetas do gráfico por mês-ano de início \n  facet_wrap(~ date_onset_ym, ncol = 4)",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Introdução ao GIS</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.pt.html#estatística-espacial",
    "href": "new_pages/gis.pt.html#estatística-espacial",
    "title": "28  Introdução ao GIS",
    "section": "28.11 Estatística espacial",
    "text": "28.11 Estatística espacial\nGrande parte de nossa discussão até aqui estava focada na visualização de dados espaciais. Em alguns casos, você também pode estar interessado em estatística espacial para quantificar as relações espaciais entre os atributotos de seu dados. Essa seção vai passar uma visão global sobre alguns conceitos chave da estatística espacial, e sugerir alguns recursos que podem explorados caso você deseje fazer uma análise espacial mais aprofundada.\n\nRelações espaciais\nAntes de calcularmos qualquer estatística espacial, precisamos especificar as relações entre as características de nossos dados. Existem várias formas de conceituar relações espaciais, mas uma forma simples e um modelo comumente aplicado é utilizar o conceito de adjacência - especificamente, o fato de esperarmos uma relação geográfica entre áreas que compartilham uma fronteira ou são vizinhos uns dos outros.\nPodemos quantificar relações de adjacências entre polígonos de regiões administrativas da base que viemos utilizando (sle_adm3) com o pacote spdep. Iremos especificar contiguidade do tipo queen (rainha), o que significa que as regiões serão vizinhas se compartilharem pelo menos um ponto ao longo de suas fronteiras. O método alternativo seria contiguidade do tipo rook (torre), que requer que as regiões compartilhem uma aresta - em nosso caso, com polígonos irregulares, a diferença é trivial, mas em alguns casos a escolha entre queen e rook pode fazer diferença. (Nota do tradutor: Os termos queen (rainha) e rook (torre) correspondem à peças do xadrez e o tipo de vizinhança que representam descritas acima estão relacionadas aos movimentos que fazem no referido jogo: na diagonal para rainha, ou seja apenas com um ponto de contato com a casa vizinha, e para frente ou para os lados com a torre, ou seja com uma aresta -a lateral do quadrado- completa de contato com a casa vizinha).\n\nsle_nb &lt;- spdep::poly2nb(sle_adm3_dat, queen=T) # cria vizinhos\nsle_adjmat &lt;- spdep::nb2mat(sle_nb)    # cria uma matriz resumindo os relacionamentos entre vizinhos\nsle_listw &lt;- spdep::nb2listw(sle_nb)   # cria um um objeto listw (lista de pesos (weights) ) -- iremos precisar disso posteriormente\n\nsle_nb\n\nNeighbour list object:\nNumber of regions: 9 \nNumber of nonzero links: 30 \nPercentage nonzero weights: 37.03704 \nAverage number of links: 3.333333 \n\nround(sle_adjmat, digits = 2)\n\n  [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n1 0.00 0.20 0.00 0.20 0.00  0.2 0.00 0.20 0.20\n2 0.25 0.00 0.00 0.25 0.25  0.0 0.00 0.25 0.00\n3 0.00 0.00 0.00 0.50 0.00  0.0 0.00 0.00 0.50\n4 0.25 0.25 0.25 0.00 0.00  0.0 0.00 0.00 0.25\n5 0.00 0.33 0.00 0.00 0.00  0.0 0.33 0.33 0.00\n6 0.50 0.00 0.00 0.00 0.00  0.0 0.00 0.50 0.00\n7 0.00 0.00 0.00 0.00 0.50  0.0 0.00 0.50 0.00\n8 0.20 0.20 0.00 0.00 0.20  0.2 0.20 0.00 0.00\n9 0.33 0.00 0.33 0.33 0.00  0.0 0.00 0.00 0.00\nattr(,\"call\")\nspdep::nb2mat(neighbours = sle_nb)\n\n\nA matriz exibida acima mostra as relações entre as 9 regiões de nossa base sle_adm3. Um score de 0 indica duas regiões que não são vizinhas, enquanto quaisquer outros valores diferentes de zero indicam uma relação de vizinhança. Os valores na matriz estão escalados de forma que a linha de cada região tenha um peso total de 1.\nUma melhor forma de visualizar essas relações de vizinhança é gerando um gráfico para elas:\n\nplot(sle_adm3_dat$geometry) +                                           # cria gráficos com as fronteiras das regiões \n  spdep::plot.nb(sle_nb,as(sle_adm3_dat, 'Spatial'), col='grey', add=T) # adiciona relações de vizinhança\n\n\n\n\n\n\n\n\nUtilizamos uma abordagem de adjacência para identificar polígonos vizinhos; os vizinhos identificados também podem ser chamados de vizinhos baseados em contiguidade (contiguity-based neighbors). Mas, essa é apenas um das formas de escolher quais regiões são esperadas de possuírem uma relação geográfica. As abordagens alternativas mais comuns para identificar relações geográficas geram vizinhos baseados em distância (distance-based neighbors); basicamente, eles são:\n\nK-vizinhos mais próximos (K-nearest neighbors) - Baseados nas distâncias entre centróides (centros geograficamente-pesados dos polígonos de cada região), seleciona as n regiões mais próximas como vizinhas. Um limite de proximidade de máxima-distância também pode ser especificado. Em spdep, você pode usar knearneigh() (veja documentação).\nVizinhos por limite de distância - Seleciona todos os vizinhos contidos em um limite de distância. Em spdep, essa relação de vizinhos pode ser identificada utilizando a função dnearneigh() (veja documentação).\n\n\n\nAutocorrelação espacial\nA conhecida primeira lei da geografia de Tobler diz que “todas as coisas estão relacionadas com todas as outras, mas coisas próximas estão mais relacionadas do que coisas distantes.” Na epidemiologia, isso geralmente significa que o risco de um certo desfecho de saúde em uma dada região é mais similar ao de suas regiões vizinhas que daquelas regiões mais longínquas. Esse conceito foi formalizado como autocorrelação espacial - a propridedade estatística em que características geográficas com valores similares são agregados no espaço. Medidas estatísticas de autocorrelação espacial podem ser utilizadas para quantificar a extensão da agregação espacial em seus dados, localizar onde a agregação ocorre, e identificar padrões compartilhados da autocorrelação espacial entre diferentes variáveis dos seus dados. Essa seção te dá uma visão global de algumas medidas de autocorrelação espacial mais comuns e como calculá-las no R.\nI de Moran - Esta é uma estatística resumo global da correlação entre o valor de uma varíavel em uma região e os valores da mesma variável em regiões vizinhas. O I de Moran geralmente varia entre -1 e 1. O valor 0 indica que não há nenhum padrão de correlação espacial, enquanto valores próximos a 1 ou -1 indicam uma autocorrelação espacial mais forte (valores similares próximos de si) ou dispersão espacial (valores dissimilares próximoas de si), respectivamente.\nPor exemplo, podemos calcular o I de Moran para quantificar a autocorrelação espacial nos casos de Ebola que mapeamos mais cedo (lembre-se, esse é um subset dos casos do dataframe da linelist da epidemia simulada). O pacote spdep tem uma função moran.test, que pode fazer esse cálculo para nós:\n\nmoran_i &lt;-spdep::moran.test(sle_adm3_dat$cases,    # vetor numérico com a variável de interesse\n                            listw=sle_listw)       # objeto listw resumindo as relações entre vizinhos\n\nmoran_i                                            # imprime os resultados do teste do I de Moran\n\n\n    Moran I test under randomisation\n\ndata:  sle_adm3_dat$cases  \nweights: sle_listw    \n\nMoran I statistic standard deviate = 1.5721, p-value = 0.05796\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n       0.17845312       -0.12500000        0.03725625 \n\n\nA saída da função moran.test() nos mostra um valor do I de Moran de round(moran_i$estimate[1],2). Isso indica a presença de autocorrelação espacial em nossos dados - especificamente, que regiões com números parecidos de casos de Ebola estão potencialmente próximos entre si. O p-valor fornecido por moran.test() é gerado por comparação à expectativa, sob a hipótese nula, de não haver autocorrelação espacial, e pode ser utilizado caso você precise mostrar os resultados de um teste de hipóteses formal.\nI de Moran Local - Podemos decompor o I de Moran (global) calculado acima para identificar uma autocorrelação espacial localizada; ou seja, para identificar agrupamentos específicos em nossos dados. Essa estatística, que as vezes é chamada de Indicador Local de Associação Espacial Local Indicator of Spatial Association (LISA), resume a extensão da autocorrelação espacial sobre cada região individual. Ela pode ser útil para achar regiões “quentes” ou “frias” no mapa.\nPara mostrar um exemplo, podemos calcular e mapear I’s de Moran locais para as contagens de casos de Ebola utilizados acima, com a função local_moran() do pacote spdep:\n\n# calcula o I de Moran local\nlocal_moran &lt;- spdep::localmoran(                  \n  sle_adm3_dat$cases,                              # variável de interesse\n  listw=sle_listw                                  # objeto listw com pesos para os vizinhos\n)\n\n# faz join dos resultados aos dados do sf (shapefile)\nsle_adm3_dat&lt;- cbind(sle_adm3_dat, local_moran)    \n\n# gera o mapa\nggplot(data=sle_adm3_dat) +\n  geom_sf(aes(fill=Ii)) +\n  theme_bw() +\n  scale_fill_gradient2(low=\"#2c7bb6\", mid=\"#ffffbf\", high=\"#d7191c\",\n                       name=\"Local Moran's I\") +\n  labs(title=\"Local Moran's I statistic for Ebola cases\",\n       subtitle=\"Admin level 3 regions, Sierra Leone\")\n\n\n\n\n\n\n\n\nGi (ou G) de Getis-Ord - Essa é outra estatística comumente utilizada para análises de hotspots; em grande parte, a popularidade dessa estatística está relacionada à sua utilização na ferramenta de análise de hotspots no ArcGIS. Isso é baseado na premissa de que tipicamente, a diferença entre os valores de uma variável entre regiões vizinhas deve seguir uma distribuição normal. Ela usa a abordagem do z-score para identificar regiões que possuem valores de uma dada variável que sejam significativamente mais altas (hot spot) ou significativamente mais baixas (cold spot), comparados aos seus vizinhos.\nPodemos calcular e mapear a estatística Gi* utilizando a função localG() do spdep:\n\n# Faz uma análise G \ngetis_ord &lt;- spdep::localG(\n  sle_adm3_dat$cases,\n  sle_listw\n)\n\n# faz join dos resultados aos dados do sf\nsle_adm3_dat$getis_ord &lt;- as.numeric(getis_ord)\n\n# gera o mapa\nggplot(data=sle_adm3_dat) +\n  geom_sf(aes(fill=getis_ord)) +\n  theme_bw() +\n  scale_fill_gradient2(low=\"#2c7bb6\", mid=\"#ffffbf\", high=\"#d7191c\",\n                       name=\"Gi*\") +\n  labs(title=\"Getis-Ord Gi* statistic for Ebola cases\",\n       subtitle=\"Admin level 3 regions, Sierra Leone\")\n\n\n\n\n\n\n\n\nComo você pode ver, o mapa de Gi* de Getis-Ord tem um visual ligeiramente diferente do mapa de I de Moran Local produzido anteriormente. Isso demonstra que o método utilizado para calcular essas duas estatísticas são ligeiramente diferentes; aquele que você vai utilizar depende do seu caso de uso específico e sua pergunta experimental de interesse.\nTest L de Lee - Esse é um teste estatístico para correlação espacial bivariada. Ele permite que você teste se um padrão espacial para uma dada variável x é similar ao padrão espacial de outra variável y, cuja hipótese é que seja espacialmente relacionada com x.\nPara dar um exemplo, vamos testar se um padrão espacial dos casos de Ebola da epidemia simulada é correlacionado com o padrão espacial da população. Para iniciar, precisamos de uma variável population em nossa base sle_adm3. Podemos utilizar a variável total do dataframe sle_adm3_pop que carregamos anteriormente.\n\nsle_adm3_dat &lt;- sle_adm3_dat %&gt;% \n  rename(population = total)                          # renomeia 'total' para 'population'\n\nPodemos visualizar rapidamente os padrões espaciais das duas variáveis lado a lado, para ver se eles se parecem:\n\ntmap_mode(\"plot\")\n\ncases_map &lt;- tm_shape(sle_adm3_dat) + tm_polygons(\"cases\") + tm_layout(main.title=\"Cases\")\npop_map &lt;- tm_shape(sle_adm3_dat) + tm_polygons(\"population\") + tm_layout(main.title=\"Population\")\n\ntmap_arrange(cases_map, pop_map, ncol=2)   # organiza em facetas 2x1 \n\n\n\n\n\n\n\n\nVisualmente, os padrões parecem dissimilares. Podemos utilizar a função lee.test() do pacote spdep para testar estatisticamente se o padrão de autocorrelação espacial nas duas variáveis é relacionado. A estística L será próxima de 0 se não houver correlação entre os padrões, e próxima de 1 se tiver uma forte correlação positiva (ou seja, os padrões são similares), e próximo de -1 se houver uma forma correlação negativa (ou seja, os padrões são inversos).\n\nlee_test &lt;- spdep::lee.test(\n  x=sle_adm3_dat$cases,          # variável 1 para comparar \n  y=sle_adm3_dat$population,     # variável 2 para comparar \n  listw=sle_listw                # objeto listw com peso dos vizinhos\n)\n\nlee_test\n\n\n    Lee's L statistic randomisation\n\ndata:  sle_adm3_dat$cases ,  sle_adm3_dat$population \nweights: sle_listw  \n\nLee's L statistic standard deviate = -0.91507, p-value = 0.8199\nalternative hypothesis: greater\nsample estimates:\nLee's L statistic       Expectation          Variance \n      -0.15344204       -0.05189907        0.01231389 \n\n\nA saída acima mostra que a estatística L de Lee para as nossas duas variáveis é round(lee_test$estimate[1],2), o que indica uma fraca correlação negativa. Isso confirma nossa avaliação visual de que o padrão dos casos e população não estão relacionados entre si, e traz evidência de que o padrão espacial dos casos não é estritamente um resultado da densidade populacional em áreas de alto risco.\nA estatística L de Lee pode ser útil para fazer esses tipos de inferência sobre a relação entre variáveis espacialmente distribuídas; no entanto, para descrever a natureza do relacionamento entre duas variáveis com mais detalhes, ou ajustar para fatores de confusão, técnicas de regressão espacial serão necessárias. Essas são descritas brevemente na seção seguinte.\n\n\nRegressão espacial\nTalvez você queira fazer inferências estatísticas a respeito dos relacionamentos entre variáveis nos seus dados espaciais. Nesses casos, pode ser útil considerar técnicas de regressão espacial - ou seja, abordagens para regressão que consideram explicitamente a organização espacial das unidades dos seus dados. Algumas razões que podem fazer você considerar modelos de regressão espacial, em vez de modelos de regressão padrão tais como GLMs, incluem:\n\nModelos padrão de regressão assumem que os resíduos são independentes uns dos outros. Na presença de fortes autocorrelações espaciais, os resíduos de um modelo padrão de regressão têm a potencialidade de estarem espacialmente autocorrelacionados também, portanto, violando essa premissa. Isso pode levar a problemas com a interpretação dos resultados do modelo, o que para o caso, um modelo espacial seria mais adequado.\nModelos de regressão também assumem, tipicamente, que o efeito de uma variável x é constante sobre todas as observações. No caso de heterogeneidade espacial, os efeitos que queremos estimar podem variar sobre o espaço, e podemos estar interessados em quantificar essas diferenças. Nesse caso, modelos de regressão espacial oferecem mais flexibilidade para estimar e interpretar os efeitos.\n\nOs detalhes das abordagens de regressão espacial estão além do escopo desse manual. Essa seção vai, ao invés, passar uma visão global dos modelos de regressão espacial mais comuns e seus usos, e sugerir referências que podem ser úteis caso você queira explorar essa área mais a fundo.\nModelos de Erro Espacial - Esses modelos assumem que os termos de erro ao longo de unidades espaciais são correlacionados, sendo esse o caso, os dados violariam as premissas de um modelo OLS padrão. Modelos de Erro Espacial também podem ser chamados de modelos autorregressivos simultâneos (simultaneous autoregressive (SAR) models). Eles podem ser ajustados utilizando a função errorsarlm() do pacote spatialreg (funções de regressão espacial que costumavam fazer parte do pacote spdep).\nModelos de Defasagem Espacial (spacial lag models) - Esses modelos assumem que a variável dependente para uma região i é influenciada não apenas pelo valor das variáveis independentes em i, mas também pelos valores daquelas variáveis em regiões vizinhas a i. Assim como os modelos de erro espacial, modelos de defasagem espacial também são descritos algumas vezes como modelos autorregressivos simultâneos (simultaneous autoregressive (SAR) models). Eles podem ser ajustados utilizando a função lagsarlm() do pacote spatialreg.\nO pacote spdep contém vários testes diagnóstico úteis para decidir entre os modelos OLS padrão, de defasagem espacial ou de erro espacial. Esses testes, chamados diagnósticos de Multiplicador de (Lagrange Multiplier diagnostics), podem ser utilizados para identificar o tipo de dependência espacial em seus dados e escolher qual modelo é mais apropriado. A função lm.LMtests() pode ser utilizada para calcular todos os testes de Multiplicador de Lagrange. Anselin (1988) também demonstra uma ferramenta de fluxogramas para decidir qual modelo de regressão espacial a ser utilizado baseado nos resultados dos testes de Multiplicador de Lagrange:\n\n\n\n\n\n\n\n\n\nModelos Hierárquicos Bayesianos - Abordagens Bayesianas são comumente utilizadas para algumas aplicação em análise espacial, principalmente para mapeamento de doenças. Elas são preferidas em ocasiões onde os dados dos casos estão esparçamente distribuídas (por exemplo, no caso de um desfecho raro) ou com muito “ruído” estatístico, de forma que elas podem ser utilizadas para gerar estimativas “suavizadas” do risco de doenças ao considerar processos espaciais subjacentes que estavam latentes. Isso pode aumentar a qualidade das estimativas. Elas também permitem ao investigador a pre-especificação (via escolha de uma priori) de complexos padrões de correlação espaciais que podem existir nos dados, o que pode considerar variações espaço-dependente e -independente tanto nas variáveis independentes quanto nas dependentes. No R, Modelos Hierarquicos Bayesianos podem ser ajustados utilizando o pacote CARbayes (veja documentação) ou R-INLA (veja website e livro). R também pode ser utilizado para chamar softwares externos que fazem estimativas Bayesianas, tais como JAGS ou WinBUGS.",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Introdução ao GIS</span>"
    ]
  },
  {
    "objectID": "new_pages/gis.pt.html#recursos",
    "href": "new_pages/gis.pt.html#recursos",
    "title": "28  Introdução ao GIS",
    "section": "28.12 Recursos",
    "text": "28.12 Recursos\n\nPacote Simple Features vignette\nPacote tmap vignette\nggmap: Visualização Espacial com ggplot2\nIntrodução à produção de mapas com R, visão geral de diferentes pacotes\n\nDados Espaciais no R (EarthLab course)\nAnálise de Dados Espaciais Aplicada com R livro\nSpatialEpiApp - um Shiny app que pode ser baixado como um pacote R, permitindo que você insira seus próprios dados e faça a criação de mapas, análises de agrupamento (clusters) e estatísticas espaciais.\n\nIntrodução à Economoetria Espacial com R workshop",
    "crumbs": [
      "Análise dos Dados",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Introdução ao GIS</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.pt.html",
    "href": "new_pages/tables_presentation.pt.html",
    "title": "29  Tabelas para apresentação",
    "section": "",
    "text": "29.1 Preparação",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Tabelas para apresentação</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.pt.html#preparação",
    "href": "new_pages/tables_presentation.pt.html#preparação",
    "title": "29  Tabelas para apresentação",
    "section": "",
    "text": "Carregando pacotes\nInstalar e carregar o pacote flextable. Neste manual, nós destacamos o p_load() do pacman, o qual instala o pacote, se necessário, e o carrega para ser utilizado. Você também pode carregar os pacotes com library() presente no R base. Veja a seção sobre Introdução ao R para obter mais informações sobre os pacotes “R”.\n\npacman::p_load(\n  rio,            # importar/exportar\n  here,           # caminho do arquivo\n  flextable,      # fazer tabelas HTML \n  officer,        # Funções auxiliares para tabelas\n  tidyverse)      # visualização, resumo e gerenciamento dos dados \n\n\n\nImportando dados\nPara começar, nós importamos a linelist dos casos que simulam uma epidemia de Ebola. Se você quiser acompanhar,  clique para baixar o “clean”linelist  (como arquivo .rds). Importe dados com a função import() do pacote rio (ele trabalho com vários tipos de arquivo, tais como: .xlsx, .csv, .rds - você pode visualizar a seção Importar e exportar para outros detalhes).\n\n# importar a linelist\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nAs primeiras 50 linhas da linelist estão exibidas abaixo:\n\n\n\n\n\n\n\n\nPreparar a tabela\nAntes de começar a utilizar o pacote flextable você precisará criar a sua tabela como um data frame. Veja a seção em Tabelas descritivas e Pivotando dados para aprender a criar um quadro de dados utilizando pacotes como janitor* e dplyr. Você deverá organizar o conteúdo em linhas e colunas conforme você queira que seja exibido. Então, o conjunto de dados será passado para o comando flextable para ser exibido com cores, cabeçalhos, fontes, etc.\nAbaixo está um exemplo da página Tabelas descritivas de conversão dos casos na linelist dentro de um conjunto de dados que resume os resultados dos pacientes e os valores de CT (limiar de detecção, da sigla em inglês “cycle threshold”) por hospital, com uma linha de Totais na parte inferior. A saída é salva como o objeto table.\n\ntable &lt;- linelist %&gt;% \n  \n  # Obter valores resumidos por grupo hospital-resultado\n  ###############################################\n  group_by(hospital, outcome) %&gt;%                      # Dados por grupo\n  summarise(                                           # Criar novas colunas resumidas de indicadores de interessse\n    N = n(),                                           # Numero de linhas por grupo hospital-resultado   \n    ct_value = median(ct_blood, na.rm=T)) %&gt;%          # mediana do valor de TC por grupo\n\n  \n  # add totals\n  ############\n  bind_rows(                                           # Vincular as tabelas prévias com esta mini-tabela de totais    \n  linelist %&gt;% \n      filter(!is.na(outcome) & hospital != \"Missing\") %&gt;%\n      group_by(outcome) %&gt;%                            # Agrupar somente pelo resultado, não pelo hospital    \n      summarise(\n        N = n(),                                       # Número de linhas para conjunto de dados total     \n        ct_value = median(ct_blood, na.rm=T))) %&gt;%     # Mediana de CT para conjunto de dados total\n  \n   # Pivot wider and format\n  ########################\n  mutate(hospital = replace_na(hospital, \"Total\")) %&gt;% \n  pivot_wider(                                         # Colunas longas e amplas\n    values_from = c(ct_value, N),                      # novos valores de CT e colunas de contagem\n    names_from = outcome) %&gt;%                          # novos nomes da colunas são de resultados\n  mutate(                                              # Adicionar novas colunas\n    N_Known = N_Death + N_Recover,                               # número com resultados conhecidos\n    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # porcentagem de casos de óbitos (com 1 casa decimal)\n    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %&gt;% # porcentagem dos reuperados (com 1 casa decimal)\n  select(                                              # Reordenar as colunas\n    hospital, N_Known,                                   # Colunas introdutórias\n    N_Recover, Pct_Recover, ct_value_Recover,            # Coluna dos recuperados\n    N_Death, Pct_Death, ct_value_Death)  %&gt;%             # Coluna de óbitos\n  arrange(N_Known)                                    # Organizar linhas da mais alta para mais baixa (linha superior a linha Total)\n\ntable  # impressão\n\n# A tibble: 7 × 8\n# Groups:   hospital [7]\n  hospital      N_Known N_Recover Pct_Recover ct_value_Recover N_Death Pct_Death\n  &lt;chr&gt;           &lt;int&gt;     &lt;int&gt; &lt;chr&gt;                  &lt;dbl&gt;   &lt;int&gt; &lt;chr&gt;    \n1 St. Mark's M…     325       126 38.8%                     22     199 61.2%    \n2 Central Hosp…     358       165 46.1%                     22     193 53.9%    \n3 Other             685       290 42.3%                     21     395 57.7%    \n4 Military Hos…     708       309 43.6%                     22     399 56.4%    \n5 Ausente          1125       514 45.7%                     21     611 54.3%    \n6 Port Hospital    1364       579 42.4%                     21     785 57.6%    \n7 Total            4565      1983 43.4%                     21    2582 56.6%    \n# ℹ 1 more variable: ct_value_Death &lt;dbl&gt;",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Tabelas para apresentação</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.pt.html#básico-do-flextable",
    "href": "new_pages/tables_presentation.pt.html#básico-do-flextable",
    "title": "29  Tabelas para apresentação",
    "section": "29.2 Básico do flextable",
    "text": "29.2 Básico do flextable\n\nCriar um flextable\nPara criar e gerenciar os objetos do comando flextable, passamos primeiro o conjunto de dados por meio da função flextable(). Nós salvamos os resultados como my_table.\n\nmy_table &lt;- flextable(table) \nmy_table\n\nhospitalN_KnownN_RecoverPct_Recoverct_value_RecoverN_DeathPct_Deathct_value_DeathSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22\n\n\nApós ter feito isso, podemos progresssivamente vincular o objeto my_table por meio de outras funções de formatação flextable.\nNesta página, por uma questão de clareza, nós devemos salvar a tabela em níveis intermediários como my_table, e adicionando as funções flextable uma a uma. Se você quiser ver uma parte de todos os comandos escritos do início ao fim, visite a seção logo abaixo Todos os códigos juntos.\nA sintaxe geral de cada linha de comando flextable* é a seguinte:\n\nfunção(tabela, i = X, j = X, part = \"X\"), onde:\n\nA ‘função’ pode ser uma das das muitas funções diferentes, tais como width() para determinar a largura de colunas, bg() para definir as cores do plano de fundo, align() para ajustar o alinhamento do texto centro/direita/esquerda, e assim por diante.\ntabela = é o nome do seu conjunto de dados, embora não precise estar explícita, se a sua data frame estiver escadeada com um pipe (%&gt;%) à função.\npart = se refere em qual parte da tabela a função deverá ser aplicada. Por exemplo, “cabeçalho”, “corpo” ou “todos”, (“header”, “body” ou “all”).\ni = especifica a linha (row) para aplicar a função, onde ‘X’ é o número da linha. Se há linhas múltiplas, por exemplo, da primeira a terceira linha, pode especificar: i = c(1:3). Observe que se o corpo estiver selecionado (‘body’), a primeira linha começa a ser contada abaixo do cabeçalho.\n`j = ` especifica a coluna a qual aplicar função, onde 'x' é o número ou nome das colunas. Se houver colunas multiplas, por exemplo, da quinta e à sexta colunas, pode-se especificar: `j = c(5,6)`. \n\n\nVocê pode encontrar a lista completa das funções de formatação do comando flextable clique aqui ou revisar a documentação inserindo ?flextable.\n\n\nLargura das colunas\nNós podemos usar a função autofit(), para expandir a tabela para que cada célula tenha somente uma linha de texto. A função qflextable() é uma abreviação mais simples para flextable() and autofit().\n\nmy_table %&gt;% autofit()\n\nhospitalN_KnownN_RecoverPct_Recoverct_value_RecoverN_DeathPct_Deathct_value_DeathSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22\n\n\nNo entanto, nem sempre isto poderá ser apropriado, principalmente se houver valores muito longos dentro das células, o que significa que a tabela pode não ter o tamanho da página.\nPor isso, podemos especificar larguras com a função width (). Isto pode ser feito arredondando um pouco para saber qual valor de largura inserir. No exemplo abaixo, especificamos larguras diferentes para cada coluna 1, coluna 2 e colunas 4 a 8.\n\nmy_table &lt;- my_table %&gt;% \n  width(j=1, width = 2.7) %&gt;% \n  width(j=2, width = 1.5) %&gt;% \n  width(j=c(4,5,7,8), width = 1)\n\nmy_table\n\nhospitalN_KnownN_RecoverPct_Recoverct_value_RecoverN_DeathPct_Deathct_value_DeathSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22\n\n\n\n\nCabeçalhos/Títulos das colunas\nQueremos cabeçalhos mais simples para facilitar a interpretação do conteúdo das tabelas.\nPara esta tabela, queremos acrescentar uma segunda camada do cabeçalho para que as colunas que cobrem os mesmos subgrupos possam ser agrupadas. Nós fazemos isto usando a função add_header_row() com top = TRUE. Nós colocamos o novo nome de cada coluna para valores usando o comando values =, e para deixar colunas com valores vazios use \"\" que sabemos que iremos mesclar mais tarde.\nNós também podemos renomear os nomes do cabeçalho em um segundo nível de cabeçalho usando um comando separado set_header_labels().\nFinalmente, para “combinar” certos cabeçalhos das colunas no cabeçalho superior, utilizamos o comando merge_at() para mesclar os cabeçalhos da coluna na linha do cabeçalho superior.\n\nmy_table &lt;- my_table %&gt;% \n  \n  add_header_row(\n    top = TRUE,                # Novo cabeçalho posicionado acima da linha do cabeçalho existente\n    values = c(\"Hospital\",     # Valores dos cabeçalhos para cada coluna abaixo\n               \"Total de casos com desfecho conhecido\", \n               \"Recuperado\",    # este será o nome desta coluna e das duas seguintes \n               \"\",\n               \"\",\n               \"Óbitos\",         # este será o nome desta coluna e das duas seguintes \n               \"\",             # Deixar em branco, essa coluna sera mesclada com a coluna óbitos \n               \"\")) %&gt;% \n    \n  set_header_labels(         # Renomear as colunas na linha original do cabeçalho\n   \n      hospital = \"\", \n      N_Known = \"\",                  \n      N_Recover = \"Total\",\n      Pct_Recover = \"% de casos\",\n      ct_value_Recover = \"Mediana dos valores CT\",\n      N_Death = \"Total\",\n      Pct_Death = \"% de casos\",\n      ct_value_Death = \"Mediana dos valores C\")  %&gt;% \n  \n  merge_at(i = 1, j = 3:5, part = \"header\") %&gt;%   # Mesclar horizontalmente colunas 3 a 5 na nova linha do cabeçalho\n  merge_at(i = 1, j = 6:8, part = \"header\")       # Mesclar horizontalmente colunas 6 a 8 na nova linha do cabeçalho\n\nmy_table  # visualizar\n\nHospitalTotal de casos com desfecho conhecidoRecuperadoÓbitosTotal% de casosMediana dos valores CTTotal% de casosMediana dos valores CSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22\n\n\n\n\nBordas e plano de fundo\nVocê pode ajustar as bordas, linhas internas, entre outros, com várias funções do comando flextable. Freqüentemente, é mais fácil começar removendo todas as bordas existentes com border_remove().\nDepois, você pode aplicar os temas de borda padrão com as funções theme_box(), theme_booktabs(), ou theme_alafoli().\nLinhas verticais e horizontais poderão ser adicionadas com uma variedade de funções. Os comandos hline() e vline() , adicionam linhas a uma linha ou coluna especificada, respectivamente. Dentro de cada uma, você deve especificar a part = como “all” (tudo), “body” (corpo da tabela), ou “header” (cabeçalho). Para linhas verticais, especificar a coluna para j =, e para linhas horizontais, a linha para i =. Outras funções como vline_right(), vline_left(), hline_top(), e hline_bottom() adicionam linhas apenas na parte externa da tabela.\nEm todas estas funções, o estilo atual para linha deve ser especificado para border = e deve ser a saída de um comando separado utilizando a função fp_border() do pacote officer. Esta função vai ajudá-lo a definir a largura e a cor da linha. Você poderá definir isto acima dos comandos da tabela, conforme apresentado no script abaixo.\n\n# definir estilo pa linha da borda\nborder_style = officer::fp_border(color=\"black\", width=1)\n\n# adicionar linhas de bordas na tabela\nmy_table &lt;- my_table %&gt;% \n\n  # Remover todas as bordas existentes\n  border_remove() %&gt;%  \n  \n  # adicionar linhas por meio de configurações de temas pré-determinados\n  theme_booktabs() %&gt;% \n  \n  # adcionar linhas verticais para separar seção de Recuperados e Óbitos\n  vline(part = \"all\", j = 2, border = border_style) %&gt;%   # na coluna 2 \n  vline(part = \"all\", j = 5, border = border_style)       # na coluna 5\n\nmy_table\n\nHospitalTotal de casos com desfecho conhecidoRecuperadoÓbitosTotal% de casosMediana dos valores CTTotal% de casosMediana dos valores CSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22\n\n\n\n\nFonte e Alinhamento\nAlinhamos todas as colunas ao centro, em paralelo a coluna mais à esquerda com os nomes dos hospitais, utilizando a função align() de flextable**.\n\nmy_table &lt;- my_table %&gt;% \n   flextable::align(align = \"center\", j = c(2:8), part = \"all\") \nmy_table\n\nHospitalTotal de casos com desfecho conhecidoRecuperadoÓbitosTotal% de casosMediana dos valores CTTotal% de casosMediana dos valores CSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22\n\n\nAdemais, podemos aumentar o tamanho da fonte de cabeçalho e alterá-la para negrito. Também podemos alterar a linha total para negrito.\n\nmy_table &lt;-  my_table %&gt;%  \n  fontsize(i = 1, size = 12, part = \"header\") %&gt;%   # ajustar o tamanho da fonte do cabeçalho\n  bold(i = 1, bold = TRUE, part = \"header\") %&gt;%     # colocar o cabeçalho em negrito\n  bold(i = 7, bold = TRUE, part = \"body\")           # ajustar a linha de totais para negrito\n\nmy_table\n\nHospitalTotal de casos com desfecho conhecidoRecuperadoÓbitosTotal% de casosMediana dos valores CTTotal% de casosMediana dos valores CSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22\n\n\nPodemos assegurar que as colunas de proporção exibam somente uma casa decimal utilizando a função colformat_num(). Observe que isto também poderia ter sido feito na fase de gerenciamento de dados com a função round().\n\nmy_table &lt;- colformat_num(my_table, j = c(4,7), digits = 1)\nmy_table\n\nHospitalTotal de casos com desfecho conhecidoRecuperadoÓbitosTotal% de casosMediana dos valores CTTotal% de casosMediana dos valores CSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22\n\n\n\n\nCélulas Mescladas\nDa mesma forma que mesclamos as células horizontalmente na linha de cabeçalho, também podemos mesclar as células verticalmente utilizando merge_at() e especificando as linhas (i) e coluna (j). Aqui mesclamos os valores “Hospital” e “Total de casos com desfecho conhecido” verticalmente para lhes dar mais espaço.\n\nmy_table &lt;- my_table %&gt;% \n  merge_at(i = 1:2, j = 1, part = \"header\") %&gt;% \n  merge_at(i = 1:2, j = 2, part = \"header\")\n\nmy_table\n\nHospitalTotal de casos com desfecho conhecidoRecuperadoÓbitosTotal% de casosMediana dos valores CTTotal% de casosMediana dos valores CSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22\n\n\n\n\nCor do plano de fundo\nPara distinguir o conteúdo dos cabeçalhos da tabela, podemos acrescentar uma formatação adicional. Por exemplo, mudar a cor do plano de fundo. Neste exemplo, alteramos o corpo da tabela para cinza.\n\nmy_table &lt;- my_table %&gt;% \n    bg(part = \"body\", bg = \"gray95\")  \n\nmy_table \n\nHospitalTotal de casos com desfecho conhecidoRecuperadoÓbitosTotal% de casosMediana dos valores CTTotal% de casosMediana dos valores CSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Tabelas para apresentação</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.pt.html#formatação-condicional",
    "href": "new_pages/tables_presentation.pt.html#formatação-condicional",
    "title": "29  Tabelas para apresentação",
    "section": "29.3 Formatação condicional",
    "text": "29.3 Formatação condicional\nPodemos destacar todos os valores em uma coluna que atendam a uma determinada regra, por exemplo, onde mais de 55% dos casos morreram. Simplesmente insira os critérios no argumento i = ou j =, precedido por um til ~. Referencie aos nomes da coluna como são no data frame, não aos valores do cabeçalho que criou para exibição.\n\nmy_table %&gt;% \n  bg(j = 7, i = ~ Pct_Death &gt;= 55, part = \"body\", bg = \"red\") \n\nHospitalTotal de casos com desfecho conhecidoRecuperadoÓbitosTotal% de casosMediana dos valores CTTotal% de casosMediana dos valores CSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22\n\n\nOu podemos destacar a linha inteira que cumpra a critério determinado, tais como um hospital de interesse. Para fazer isto, removeremos a especificação da coluna (j) para que os critérios sejam aplicados a todas as colunas.\n\nmy_table %&gt;% \n  bg(., i= ~ hospital == \"Military Hospital\", part = \"body\", bg = \"#91c293\") \n\nHospitalTotal de casos com desfecho conhecidoRecuperadoÓbitosTotal% de casosMediana dos valores CTTotal% de casosMediana dos valores CSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Tabelas para apresentação</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.pt.html#tbl_pres_all",
    "href": "new_pages/tables_presentation.pt.html#tbl_pres_all",
    "title": "29  Tabelas para apresentação",
    "section": "29.4 Todos os comandos juntos",
    "text": "29.4 Todos os comandos juntos\nAbaixo apresentamos todos os comandos abordados nesta seção:\n\nborder_style = officer::fp_border(color=\"black\", width=1)\n\npacman::p_load(\n  rio,            # importar/exportar\n  here,           # caminho do arquivo\n  flextable,      # fazer tabelas HTML \n  officer,        # Funções auxiliares para tabelas\n  tidyverse)      # visualização, resumo e gerenciamento dos dados\n\ntable &lt;- linelist %&gt;% \n  # filtro\n  ########\n  #filtro(!is.na(outcome) & hospital != \"Missing\") %&gt;%  # Remove casos com desfecho ou hospital vazios\n  \n  # Obter valores resumidos por grupo hospital-resultado\n  ###############################################\n  group_by(hospital, outcome) %&gt;%                      # Dados por grupo\n  summarise(                                           # Criar novas colunas resumidas de indicadores de interesse\n    N = n(),                                           # Numero de linhas por grupo hospital-resultado     \n    ct_value = median(ct_blood, na.rm=T)) %&gt;%          # mediana do valor de CT por grupo\n  \n  # Adicionando Totais\n  ############\n  bind_rows(                                           # Vincular as tabelas prévias com esta mini-tabela de totais\n    linelist %&gt;% \n      filter(!is.na(outcome) & hospital != \"Missing\") %&gt;%\n      group_by(outcome) %&gt;%                            # Agrupar somente pelo resultado, não pelo hospital    \n      summarise(\n        N = n(),                                       # Número de linhas para conjunto de dados total     \n        ct_value = median(ct_blood, na.rm=T))) %&gt;%     # Mediana de CT para conjunto de dados total  \n  \n  # Dados dinâmicos \n  ########################\n  mutate(hospital = replace_na(hospital, \"Total\")) %&gt;% \n  pivot_wider(                                         # Colunas longas e largas\n    values_from = c(ct_value, N),                       # novos valores de CT e colunas de contagem\n    names_from = outcome) %&gt;%                           # novos nomes da colunas são de resultados\n  mutate(                                              # Adicionar novas colunas\n    N_Known = N_Death + N_Recover,                               # número com resultados conhecidos\n    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # porcentagem de casos de óbitos (com 1 casa decimal)\n    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %&gt;% # porcentagem dos reuperados (com 1 casa decimal)\n  select(                                              # Reordenar as colunas\n    hospital, N_Known,                                   # Colunas introdutórias\n    N_Recover, Pct_Recover, ct_value_Recover,            # Coluna dos recuperados\n    N_Death, Pct_Death, ct_value_Death)  %&gt;%             # Coluna de óbitos\n  arrange(N_Known) %&gt;%                                 # Organizar linhas da mais alta para mais baixa (linha superior a linha Total)\n\n  # formatação\n  ############\n  flextable() %&gt;% \n  add_header_row(\n    top = TRUE,                # Novo cabeçalho colocado acima da linha do cabeçalho existente\n    values = c(\"Hospital\",     # Valores dos cabeçalhos para cada coluna abaixo\n               \"Total de casos com desfecho conhecido\", \n               \"Recuperados\",    \n               \"\",\n               \"\",\n               \"Óbito\",        \n               \"\",             # Deixar em branco, essa coluna sera mesclada com a coluna de óbito\n               \"\")) %&gt;% \n    set_header_labels(         # Renomear as colunas na linha original do cabeçalho\n      hospital = \"\", \n      N_Known = \"\",                  \n      N_Recover = \"Total\",\n      Pct_Recover = \"% de casos\",\n      ct_value_Recover = \"Mediana de valores CT\",\n      N_Death = \"Total\",\n      Pct_Death = \"% of cases\",\n      ct_value_Death = \"Mediana de valores CT\")  %&gt;% \n  merge_at(i = 1, j = 3:5, part = \"header\") %&gt;% # Mesclar horizontalmente colunas 3 a 5 in nova linha do cabeçalho\n  merge_at(i = 1, j = 6:8, part = \"header\") %&gt;%  \n  border_remove() %&gt;%  \n  theme_booktabs() %&gt;% \n  vline(part = \"all\", j = 2, border = border_style) %&gt;%   # na coluna 2 \n  vline(part = \"all\", j = 5, border = border_style) %&gt;%   # na coluna 5\n  merge_at(i = 1:2, j = 1, part = \"header\") %&gt;% \n  merge_at(i = 1:2, j = 2, part = \"header\") %&gt;% \n  width(j=1, width = 2.7) %&gt;% \n  width(j=2, width = 1.5) %&gt;% \n  width(j=c(4,5,7,8), width = 1) %&gt;% \n  flextable::align(., align = \"center\", j = c(2:8), part = \"all\") %&gt;% \n  bg(., part = \"body\", bg = \"gray95\")  %&gt;% \n  #bg(., j=c(1:8), i= ~ hospital == \"Military Hospital\", part = \"body\", bg = \"#91c293\") %&gt;% \n  bg(j = 7, i = ~ Pct_Death &gt;= 55, part = \"body\", bg = \"red\") %&gt;% \n  colformat_num(., j = c(4,7), digits = 1) %&gt;%\n  bold(i = 1, bold = TRUE, part = \"header\") %&gt;% \n  bold(i = 7, bold = TRUE, part = \"body\")\n\n`summarise()` has grouped output by 'hospital'. You can override using the\n`.groups` argument.\n\ntable\n\nHospitalTotal de casos com desfecho conhecidoRecuperadosÓbitoTotal% de casosMediana de valores CTTotal% of casesMediana de valores CTSt. Mark's Maternity Hospital (SMMH)32512638.8%2219961.2%22Central Hospital35816546.1%2219353.9%22Other68529042.3%2139557.7%22Military Hospital70830943.6%2239956.4%21Ausente1,12551445.7%2161154.3%21Port Hospital1,36457942.4%2178557.6%22Total4,5651,98343.4%212,58256.6%22",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Tabelas para apresentação</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.pt.html#como-salvar-sua-tabela",
    "href": "new_pages/tables_presentation.pt.html#como-salvar-sua-tabela",
    "title": "29  Tabelas para apresentação",
    "section": "29.5 Como salvar sua tabela",
    "text": "29.5 Como salvar sua tabela\nHá diferentes caminhos para que sua tabela seja integrada em uma saída (output).\n\nComo salvar uma tabela única\nVocê pode exportar as tabelas como arquivos para Word, PowerPoint ou HTML ou como arquivo de imagem (PNG). Para fazer isto, você pode usar uma das seguintes funções:\n\nsave_as_docx()\n\nsave_as_pptx()\n\nsave_as_image()\n\nsave_as_html()\n\nPor exemplo, abaixo salvamos nossa tabela como um documento do word. Observe a sintaxe do primeiro argumento - você pode apenas fornecer o nome do seu objeto flextable, por exemplo my_table, ou poderá dar um “nome” como apresentado a seguir (o nome é “my table”). Se for nome, este aparecerá como o título da tabela no Word. Também demonstramos comando para salvar como imagem PNG.\n\n# Editar a 'my table' como necessário para adicionar o título na tabela\n.  \nsave_as_docx(\"my table\" = my_table, path = \"file.docx\")\n\nsave_as_image(my_table, path = \"file.png\")\n\nObserve que os pacotes webshot or webshot2 são necessários para a “flextable” como uma imagem. As imagens poderá sair com fundo transparente.\nSe quiser ver uma versão ‘ao vivo’ da saída flexível no formato de documento pretendido, utilize print() e especifique uma das seguintes opções abaixo para preview =. O documento será aberto uma “pop-up” em um programa de software especificado no seu computador, mas não será salvo. Isto pode ser útil para verificar se a tabela cabe numa página/slide ou para que possa copiar rapidamente dentro de outro documento. Você pode, por exemplo, utilizar esse método com o argumento preview = definido para “pptx” ou “docx” como mostrado abaixo.\n\nprint(my_table, preview = \"docx\") # Exemplo documento do Word\nprint(my_table, preview = \"pptx\") # Exemplo Powerpoint \n\n\n\nImprimir a tabela no R markdown\nEsta tabela poderá ser integrada em um documento automatizado, uma saída R markdown, se o objeto tabela for chamado dentro do chunk do R markdown. Isto significa que a tabela poderá ser atualizada como parte de um relatório em que os dados podem ser alterados, e os números podem ser atualizados.\nVeja detalhes na seção Relatórios com R Markdown deste manual.",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Tabelas para apresentação</span>"
    ]
  },
  {
    "objectID": "new_pages/tables_presentation.pt.html#recursoa",
    "href": "new_pages/tables_presentation.pt.html#recursoa",
    "title": "29  Tabelas para apresentação",
    "section": "29.6 Recursoa",
    "text": "29.6 Recursoa\nO manual completo flextable se encontra aqui\nO site Github pode ser encontrado aqui\nO manual com todas a funções usadas no pacote flextable poderá ser encontrada aqui\nUma galeria com bons modelos de tabela flextable com códigos pode ser acessada aqui",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Tabelas para apresentação</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.pt.html",
    "href": "new_pages/ggplot_basics.pt.html",
    "title": "30  O básico do ggplot",
    "section": "",
    "text": "30.1 Preparação",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>O básico do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.pt.html#preparação",
    "href": "new_pages/ggplot_basics.pt.html#preparação",
    "title": "30  O básico do ggplot",
    "section": "",
    "text": "Carregar pacotes\nEste trecho de código mostra o carregamento dos pacotes necessários para as análises. Neste manual, enfatizamos p_load() de pacman, que instala o pacote se necessário e o carrega para utilização. Você também pode carregar os pacotes instalados com library() do R base*. Veja a página em Introdução ao R para mais informações sobre os pacotes R.\n\npacman::p_load(\n  tidyverse,      # inclui ggplot2 e outras ferramentas de manipular dados\n  janitor,        # limpeza de dados\n  ggforce,        # extensão ggplot\n  rio,            # importar/exportar\n  here,           # localizador de arquivos\n  stringr         # trabalhando com caracteres\n)\n\n\n\nImportar datos\nImportamos o conjunto de dados de casos de uma epidemia simulada de Ebola. Se você quiser acompanhar,  clique para baixar a linelist “limpa”  (como arquivo .rds). Importe seus dados com a função import() do pacote rio (ele aceita muitos tipos de arquivos como .xlsx, .rds, .csv - veja a página Importar and exportar para detalhes).\n\nlinelist &lt;- rio::import(\"linelist_cleaned.rds\")\n\nAs primeiras 50 linhas da linelist são exibidas abaixo. Vamos nos concentrar nas variáveis contínuas age, wt_kg (peso em quilos), ct_blood (valores de CT) e days_onset_hosp (diferença entre data de início e hospitalização).\n\n\n\n\n\n\n\n\nLimpeza geral\nAo preparar os dados para traçar o gráfico, é melhor fazer com que os dados adiram aos padrões de dados “arrumados” (do inglês tidy) na medida do possível. Como conseguir isto é explicado com mais detalhes nas páginas de gerenciamento de dados deste manual, tais como Dados de limpeza e principais funções.\nAlgumas maneiras simples de prepararmos nossos dados para torná-los melhores para a visualização podem incluir tornar o conteúdo dos dados melhor para exibição - o que não necessariamente equivale a melhor para a manipulação de dados. Por exemplo:\n\nSubstituir os valores NA em uma coluna do tipo caracteres pela string “Desconhecido”.\n\nConsiderar converter a coluna para classe fator para que seus valores tenham níveis em uma ordem específica.\nLimpar algumas colunas para que os valores adequados à manipulações (“data friendly”), tais como valores que possuam sublinhado (“underline”), por exemplo, sejam alterados para texto normal ou padrão título (ver Caracteres e strings)\n\nAqui estão alguns exemplos disso em ação.\n\n#faça uma versão visualizaçãi das colunas com nomes mais amigáveis \n\nlinelist &lt;- linelist %&gt;%\n  mutate(\n    gender_disp = case_when(gender == \"m\" ~ \"Male\",        # m para Male\n                            gender == \"f\" ~ \"Female\",      # f para Femimino,\n                            is.na(gender) ~ \"Desconhecido\"),    # NA para Desconhecido\n    \n    outcome_disp = replace_na(outcome, \"Desconhecido\")          # substituir na por \"Desconhecido\" \n  )\n\n\n\nPivoteamento para “mais longo”\nPor uma questão de estrutura de dados, para ggplot2 muitas vezes também queremos pivotar nossos dados para formatos mais longos. Leia mais sobre isto na página em Pivoteando dados.\n\n\n\n\n\n\n\n\n\nPor exemplo, digamos que queremos fazer um gráfico de dados que estão em um formato “largo”, como para cada caso na linelist e seus sintomas. Abaixo criamos uma mini-linelist chamada symptoms_data que contém apenas as colunas case_id e sintomas.\n\nsymptoms_data &lt;- linelist %&gt;% \n  rename(tosse=cough,\n         febre=fever, \n         vômito=vomit,\n         dores=aches,\n         calafrio=chills) %&gt;%  #traduzindo\n  select(c(case_id, febre, calafrio, tosse, dores, vômito)) \n\nVeja como são as primeiras 50 linhas desta mini-linelist - veja como elas são formatadas de forma “larga” com cada sintoma como uma coluna:\n\n\n\n\n\n\nSe quisermos traçar um gráfico com o número de casos com sintomas específicos, estamos limitados pelo fato de que cada sintoma é uma coluna específica. Entretanto, podemos pivotar as colunas de sintomas para um formato mais longo como este:\n\nsymptoms_data_long &lt;- symptoms_data %&gt;%    # comece com a \"mini\" linelist chamada symptoms_data\n  \n  pivot_longer(\n    cols = -case_id,                       # pivote todas as colunas exceto case_id \n    names_to = \"nome_sintoma\",             # dê o nome para a nova coluna que contém os sintomas \n    values_to = \"sintoma_esta_presente\") %&gt;%  # dê o nome para a coluna que diz se o sintoma está presente \n\n  \n  mutate(sintoma_esta_presente = replace_na(sintoma_esta_presente, \"desconhecido\")) # converte NA para \"desconhecido\"\n\nAqui estão as primeiras 50 linhas. Observe que o caso tem 5 fileiras - uma para cada sintoma possível. As novas colunas nome_sintoma e sintoma_esta_presente são o resultado do pivoteamento. Note que este formato pode não ser muito útil para outras operações, mas é útil para a criação do gráfico.",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>O básico do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.pt.html#básico-do-ggplot",
    "href": "new_pages/ggplot_basics.pt.html#básico-do-ggplot",
    "title": "30  O básico do ggplot",
    "section": "30.2 Básico do ggplot",
    "text": "30.2 Básico do ggplot\n“Gramática dos gráficos” - ggplot2\nA criação de gráficos com o ggplot2 é baseada na “adição” de camadas de gráficos e de design uns sobre os outros, com cada comando adicionado aos anteriores com um símbolo de mais (+). O resultado é um objeto do tipo gráfico com várias camadas que pode ser salvo, modificado, impresso, exportado, etc.\nOs objetos de ggplot podem ser altamente complexos, mas a ordem básica das camadas geralmente será assim:\n\nComece com o comando de base ggplot() - isto “abre” o ggplot e permite que funções subseqüentes sejam adicionadas com +. Tipicamente, o conjunto de dados também é especificado neste comando\n\nAdicionar camadas “geom” - estas funções visualizam os dados como geometrias (formas), por exemplo, como um gráfico de barras, gráfico de linhas, gráfico de dispersão, histograma (ou uma combinação!). Todas estas funções começam com geom_ como um prefixo.\n\nAdicione elementos de desenho ao gráfico, como etiquetas de eixos, título, fontes, tamanhos, esquemas de cores, legendas ou rotação de eixos.\n\nUm exemplo simples de código esqueleto é o seguinte. Vamos explicar cada componente nas seções abaixo.\n\n# plote os dados das colunas do objeto my_data como pontos vermelhos\n\n\nggplot(data = my_data)+                   # use a base de dados \"my_data\"\n  geom_point(                             # adicione uma camada de pontos \n\n    mapping = aes(x = col1, y = col2),    # mapeie as colunas para os eixos\n    color = \"red\")+                       # outras especificações para o geom\n  labs()+                                 # aqui você pode adicionar títulos, rótulos dos eixos, etc. \n  theme()                                 # aqui você pode ajustar a cor, fonte, tamanho, de elementos que não são orindos dos dados (eixo, título, etc.)",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>O básico do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.pt.html#ggplot",
    "href": "new_pages/ggplot_basics.pt.html#ggplot",
    "title": "30  O básico do ggplot",
    "section": "30.3 ggplot()",
    "text": "30.3 ggplot()\nO comando de abertura de qualquer gráfico ggplot2 é ggplot(). Este comando simplesmente cria uma tela em branco sobre a qual se pode adicionar camadas. Ele “abre” o caminho para que outras camadas sejam adicionadas com um símbolo +.\nNormalmente, o comando ggplot() inclui o dados = argumento para o gráfico. Isto define o conjunto de dados padrão a ser utilizado para as camadas subsequentes do gráfico.\nEste comando terminará com um + após seus parênteses de fechamento. Isto deixa o comando “aberto”. O ggplot só será executado/aparecerá quando o comando completo incluir uma camada final sem um + no final.\n\n# Isso irá criar um gráfco que é um painel em branco \nggplot(data = linelist)",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>O básico do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.pt.html#geoms",
    "href": "new_pages/ggplot_basics.pt.html#geoms",
    "title": "30  O básico do ggplot",
    "section": "30.4 Geoms",
    "text": "30.4 Geoms\nUma tela em branco certamente não é suficiente - precisamos criar geometrias (formas) a partir de nossos dados (por exemplo, gráficos de barra, histogramas, gráficos de dispersão, gráficos de caixa).\nIsto é feito adicionando camadas “geoms” ao comando inicial ggplot(). Há muitas funções do ggplot2 que criam “geoms”. Cada uma destas funções começa com “geom_”, portanto, vamos nos referir a elas genericamente como geom_XXXX(). Há mais de 40 geoms em ggplot2 e muitos outros criados por fãs e contribuidores. Veja-os na galeria ggplot2. Alguns geoms comuns estão listados abaixo:\n\nHistogramas - geom_histogram()\n\nGráficos de barras - geom_bar() ou geom_col() (veja “Bar plot” seção)\n\nDiagrama de caixas - geom_boxplot()\n\nPontos (por exemplo, gráficos de dispersão) - geom_point()\n\nGráficos de linhas - geom_line() ou geom_path()\n\nLinhas de tendência - geom_smooth()\n\nEm um gráfico você pode exibir um ou vários geoms. Cada um é adicionado aos comandos anteriores ggplot2 com um +, e eles são plotados sequencialmente de forma que os geoms posteriores sejam plotados sobre os anteriores.",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>O básico do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.pt.html#ggplot_basics_mapping",
    "href": "new_pages/ggplot_basics.pt.html#ggplot_basics_mapping",
    "title": "30  O básico do ggplot",
    "section": "30.5 Mapeando dados ao gráfico",
    "text": "30.5 Mapeando dados ao gráfico\nA maioria das “funções geom” devem ser informadas do que usar para criar suas formas - portanto, você deve dizer-lhes como devem mapear (atribuir) colunas em seus dados aos componentes do gráfico como os eixos, cores das formas, tamanhos das formas, etc. Para a maioria dos geoms, os componentes essenciais que devem ser mapeados para colunas nos dados são o eixo x, e (se necessário) o eixo y.\nEste “mapeamento” ocorre com o argumento mapping =. Os mapeamentos que você fornece ao mapping devem ser envolvidos na função aes(), assim você escreveria algo como mapping = aes(x = col1, y = col2), como mostrado abaixo.\nAbaixo, no comando ggplot(), os dados são definidos como o caso linelist. No argumento mapping = aes() a coluna age é mapeada para o eixo x, e a coluna wt_kg é mapeada para o eixo y.\nDepois de um +, os comandos de plotagem continuam. Uma forma é criada com a função “geom” geom_point(). Este geom herda os mapeamentos do comando ggplot() anterior - ele conhece as atribuições eixo-coluna e procede para visualizar essas relações como pontos na área do gráfico.\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+\n  geom_point()\n\n\n\n\n\n\n\n# o nome dos eixos fica automaticamente com o nome da variável na base\n# que está em inglês. É possível traduzir na base ou usando a camada\n# labs() para escrever o nome dos eixos como se quer\n\nComo outro exemplo, os seguintes comandos utilizam os mesmos dados, um mapeamento um pouco diferente e um geom diferente. A função geom_histogram() requer apenas uma coluna mapeada para o eixo x, pois as contagens do eixo y são geradas automaticamente.\n\nggplot(data = linelist, mapping = aes(x = age))+\n  geom_histogram()\n\n\n\n\n\n\n\n\n\nAs estéticas do gráfico\nNa terminologia ggplot, uma “estética” do gráfico tem um significado específico. Ela se refere a uma propriedade visual de dados plotados. Note que “estético” aqui se refere aos dados que estão sendo plotados em geometrias/formas - não ao display ao redor, como títulos, etiquetas de eixos, cor de fundo, que você pode associar com a palavra “estética”. No ggplot, esses detalhes são chamados de “themes” (temas) e são ajustados dentro de um comando theme() (veja esta seção).\nPortanto, os objetos aesthetics podem ser cores, tamanhos, transparências, posição, etc. dos dados traçados. Nem todos os geoms terão as mesmas opções de aesthetics, mas muitos podem ser usados pela maioria dos geoms. Aqui estão alguns exemplos:\n\nshape = Mostra um ponto de geom_point() como um círculo, estrela, triângulo…\n\nfill = A cor de preenchimento (ex. de uma barra ou boxplot)\n\ncolor = A linha exterior de uma barra ou boxplot, ou a cor do ponto se usar o geom_point()\nsize = tamanho (ex. grossura da linha, tamanho do ponto)\n\nalpha = Transparencia (1 = opaco, 0 = invisível)\n\nbinwidth = Largura das classes do histograma\nwidth = Largura das barras do gráfico de barras\nlinetype = Tipo de linha (ex. sólida, tracejada, pontilhada)\n\nA esses objetos do gráfico podem ser atribuídos valores de duas maneiras:\n\nAtribuindo um valor estático (por exemplo, color = \"blue\") a ser aplicado em todas as observações plotadas\n\nAtribuído a uma coluna de dados (por exemplo, “color = hospital”) de tal forma que a exibição de cada observação depende de seu valor nessa coluna\n\n\n\n\nConfigurar para um valor estático\nSe você quiser que a estética do objeto do gráfico seja estática, ou seja - para ser a mesma para cada observação nos dados, você escreve sua atribuição dentro do geom desejado mas fora de qualquer mapping = aes(). Essas atribuições poderiam ser size = 1 ou color = \"blue\". Aqui estão dois exemplos:\n\nNo primeiro exemplo, o mapping = aes() está no comando ggplot() e os eixos são mapeados para as colunas de idade e peso nos dados. A estética do gráfico color =, size =, e alpha = (transparência) são atribuídos a valores estáticos. Para maior clareza, isto é feito na função geom_point(), pois você pode adicionar outras geometrias posteriormente que levariam valores diferentes.\nNo segundo exemplo, o histograma requer apenas o eixo x mapeado para uma coluna. O histograma binwidth =, color =, fill = (cor de preenchimento), e alpha = são novamente definidos dentro do geom para valores estáticos.\n\n\n# gráfico de dispersão\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  # configurar mapeamento dos dados e eixos \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)   # configurar a estética estática dos pontos\n\n# histograma\nggplot(data = linelist, mapping = aes(x = age))+       # configurar mapeamento dos dados e eixos \n\n  geom_histogram(              # mostra o histograma\n    binwidth = 7,                # largura das classes\n    color = \"red\",               # cor da linha da classe\n    fill = \"blue\",               # cor de preenchimento da barra\n    alpha = 0.1)                 # transparência da barra\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nResponsivo a valores de uma coluna\nA alternativa é mapear os argumentos da estética de um gráfico a uma coluna (variável) do seus dados. Nesta abordagem, a exibição deste aesthetics dependerá do valor desta observação naquela coluna dos dados. Se os valores da coluna forem contínuos, a escala de exibição (legenda) para aquele aesthetics será contínua. Se os valores da coluna forem discretos, a legenda exibirá cada valor e os dados plotados aparecerão “agrupados” de forma distinta (leia mais na seção agrupamento desta página).\nPara conseguir isso, você mapeia esse aesthetics do gráfico para um nome de coluna (não entre aspas). Isto deve ser feito *em uma função mapping = aes() (nota: há vários lugares no código que você pode fazer estas atribuições de mapeamento, como discutido abaixo)).\nDois exemplos estão abaixo.\n\nNo primeiro exemplo, a aesthetics color = (de cada ponto) é mapeada para a coluna age - e uma escala de cores apareceu na legenda! Por enquanto, basta observar que a escala existe - mostraremos como modificá-la em seções posteriores.\n\nNo segundo exemplo, duas novas aesthetics do gráfico também são mapeados para colunas (color = e size =), enquanto a aesthetics do gráfico shape = e alpha = são mapeados para valores estáticos fora de qualquer função mapping = aes().\n\n\n# gráfico de dispersão\n\nggplot(data = linelist,   # escolha os dados\n       mapping = aes(     # mapeie as aesthetics para coluna de valores\n         x = age,           # mapeie o eixo x para idade (coluna age)       \n\n         y = wt_kg,         # mapeie o eixo y para peso (wt_kg)      \n\n         color = age) # mapeie a cor segundo a idade\n\n       )+     \n  geom_point()         # mostre como pontos\n\n# gráfico de dispersão\nggplot(data = linelist,   # escolha os dados\n       mapping = aes(     # mapeie as aesthetics para coluna de valores\n         x = age,           # mapeie o eixo x para idade (coluna age)    \n\n         y = wt_kg,         # mapeie o eixo y para peso (wt_kg) \n\n         color = age,       # mapeie a cor segundo a idade\n\n         size = age))+      # mapeie o tamanho segundo a idade\n\n  geom_point(             # mostre como pontos\n    shape = \"diamond\",      # pontos como losangos (diamantes)\n    alpha = 0.3)            # transparência do ponto a 30%\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNota: Os argumentos referentes aos eixos são sempre atribuídos a colunas dos dados (não a valores estáticos), e isto é sempre feito dentro de mapping = aes().\nTorna-se importante acompanhar as camadas e a aesthetics de seus gráficos à medida que vão ficando mais complexos - por exemplo, gráficos com múltiplos geoms. No exemplo abaixo, a aesthetic size = é atribuída duas vezes - uma para geom_point() e outra para geom_smooth() - ambas as vezes como um valor estático.\n\nggplot(data = linelist,\n       mapping = aes(           # mapeia a aesthetics para as colunas\n         x = age,\n         y = wt_kg,\n         color = age_years)\n       ) + \n  geom_point(                   # addiciona pontos para cada linha de dados\n    size = 1,\n    alpha = 0.5) +  \n  geom_smooth(                  # adiciona uma linha de tendência \n\n    method = \"lm\",              # com um método linear\n    size = 2)                   # tamanho (grossura da linha) de 2\n\n\n\n\n\n\n\n\n\n\nOnde incluir os atributos de mapeamento\nO mapeamento das aesthetics dentro de mapping = aes() pode ser escrito em vários lugares em seus comandos para criar o gráfico, podendo até mesmo ser escrito mais de uma vez. Isto pode ser escrito no comando superior ggplot(), e/ou para cada geom individual abaixo. As nuances incluem:\n\nAs atribuições de mapeamento feitas no primeiro comando ggplot() serão herdadas como padrão em qualquer geom abaixo, da mesma forma como x = e y = são herdadas\nOutros mapeamentos feitos dentro de um geom se aplicam somente a esse geom\n\nDa mesma forma, o parâmetro data = (do inglês dados) especificado no primeiro comando ggplot() será aplicado por padrão a qualquer geom abaixo, mas você também poderia especificar dados novos para cada geom (mas isto é mais complicado).\nAssim, cada um dos seguintes comandos irá criar o mesmo gráfico:\n\n# Esses comandos irão criar o mesmo gráfico\n\nggplot(data = linelist, mapping = aes(x = age))+\n  geom_histogram()\n\nggplot(data = linelist)+\n  geom_histogram(mapping = aes(x = age))\n\nggplot()+\n  geom_histogram(data = linelist, mapping = aes(x = age))\n\n\n\nGrupos\nVocê pode facilmente agrupar os dados e “plotar por grupo”. Na verdade, você já fez isso!\nAtribua a coluna de “agrupamento” à aesthetic apropriada do gráfico, dentro de um mapping = aes(). Acima, demonstramos isso utilizando valores contínuos quando atribuímos o ponto size = à coluna age (idade). Entretanto, isto funciona da mesma forma para colunas discretas/categóricas.\nPor exemplo, se você quiser que os pontos sejam exibidos por gênero, você definiria mapping = aes(color = gender). Uma legenda aparece automaticamente. Esta atribuição pode ser feita dentro do comando mapping = aes() no ggplot() do topo (e ser herdada pelo geom), ou pode ser definida em um mapping = aes() separado dentro do geom. Ambas as abordagens são mostradas abaixo:\n\nggplot(data = linelist,\n       mapping = aes(x = age, y = wt_kg, color = gender))+\n  geom_point(alpha = 0.5)\n\n\n\n\n\n\n\n\n\n# Este código alternativo produz o mesmo gráfico \nggplot(data = linelist,\n       mapping = aes(x = age, y = wt_kg))+\n  geom_point(\n    mapping = aes(color = gender),\n    alpha = 0.5)\n\nObserve que, dependendo do geom, será necessário utilizar argumentos diferentes para agrupar os dados. Para geom_point() você provavelmente utilizará color =, shape = ou size =. Enquanto para geom_bar() é mais provável que você utilize fill =. Isto depende apenas do geom e do tipo de aesthetic do gráfico que você deseja usar para refletir os agrupamentos.\nPara sua informação - a forma mais básica de agrupar os dados é utilizando apenas o argumento group = dentro do mapping = aes(). Entretanto, isto por si só não mudará as cores, o preenchimento ou as formas. Tampouco criará uma legenda. No entanto, os dados são agrupados, de modo que as exibições estatísticas poderão ser afetadas.\nPara ajustar a ordem dos grupos em um gráfico, veja a página Dicas para o ggplot ou a página em Fatores. Há muitos exemplos de gráficos agrupados nas seções abaixo sobre a plotagem de dados contínuos e categóricos.",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>O básico do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.pt.html#ggplot_basics_facet",
    "href": "new_pages/ggplot_basics.pt.html#ggplot_basics_facet",
    "title": "30  O básico do ggplot",
    "section": "30.6 Facetas / Pequenos-Múltiplos",
    "text": "30.6 Facetas / Pequenos-Múltiplos\nFacetas, ou “pequenos-múltiplos”, são usadas para dividir uma parcela em uma figura de vários painéis, com um painel (“faceta”) por grupo de dados. O mesmo tipo de gráfico é criado várias vezes, cada um usando um subgrupo do mesmo conjunto de dados.\nO Facetamento (Faceting) é uma funcionalidade que vem com ggplot2, portanto as legendas e eixos dos “painéis” de faceta são automaticamente alinhados. Há outros pacotes discutidos na página Dicas para o ggplot que são usados para combinar gráficos completamente diferentes (cowplot e patchwork) em uma única figura.\nO facetamento é feito com uma das seguintes funções ggplot2:\n\nfacet_wrap() Para mostrar um painel diferente para cada nível de uma variável única. Um exemplo disso poderia ser mostrar uma curva epidêmica diferente para cada hospital de uma região. As facetas são ordenadas alfabeticamente, a menos que a variável seja um fator com outra ordenação definida.\n\n\n\nVocê pode invocar certas opções para determinar o layout das facetas, por exemplo nrow = 1 ou ncol = 1 para controlar o número de linhas ou colunas dentro das quais as facetas estão dispostas.\n\n\nfacet_grid() Isto é utilizado quando se deseja trazer uma segunda variável para a disposição das facetas. Aqui cada painel de uma “grade” (grid) mostra a interseção entre os valores em duas colunas. Por exemplo, curvas epidêmicas para cada combinação hospital-idade com hospitais ao longo do topo (colunas) e faixas etárias ao longo dos lados (linhas).\n\n\n“nrow” e “ncol” não são relevantes, pois os subgrupos são apresentados em um grid\n\nCada uma destas funções aceita uma sintaxe de fórmula para especificar a(s) coluna(s) de faceta(s). Ambas aceitam até duas colunas, uma de cada lado de um til `~’.\n\nPara facet_wrap() na maioria das vezes você escreverá apenas uma coluna precedida por um til ~ como facet_wrap(~hospital). Entretanto, você pode escrever duas colunas facet_wrap(outcome ~ hospital) - cada combinação única será exibida em um painel separado, mas não serão dispostas em um grid. Os cabeçalhos mostrarão termos combinados e estes não terão uma lógica específica para as colunas vs. linhas. Se você estiver fornecendo apenas uma variável facetada, um ponto . é utilizado como um espaço reservado no outro lado da fórmula - veja os exemplos de código.\nPara facet_grid() você também pode especificar uma ou duas colunas para a fórmula (grid linhas ~ colunas). Se você quiser especificar apenas uma, você pode colocar um ponto . no outro lado do til como facet_grid(. ~ hospital) ou facet_grid(hospital ~ .).\n\nAs facetas podem rapidamente conter uma quantidade avassaladora de informações - é bom garantir que você não tenha muitos níveis de cada variável que você escolher facetar. Aqui estão alguns exemplos rápidos com o conjunto de dados sobre malária (ver Baixar manual e dados) que consiste em contagens diárias de casos de malária para estabelecimentos, por faixa etária.\nA seguir, importamos e fazemos algumas modificações rápidas para simplificar:\n\n# Esses dados correspondem a contagens diárias de malária, por estabelecimento-dia \nmalaria_data &lt;- import(here(\"data\", \"malaria_facility_count_data.rds\")) %&gt;%  # importar\n  select(-submitted_date, -Province, -newid)                                 # remove colunas desnecessárias\n\nAs primeiras 50 filas dos dados sobre a malária estão abaixo. Observe que existe uma coluna malaria_tot, mas também colunas para contagens por faixa etária (estas serão utilizadas no segundo exemplo referente ao facet_grid() ).\n\n\n\n\n\n\n\nfacet_wrap()\nNo momento, vamos nos concentrar nas colunas malaria_tot e District. Ignore por enquanto as colunas de contagem por idade. Vamos traçar curvas epidêmicas com geom_col(), que produz uma coluna para cada dia com a altura do eixo y sendo especificada com o valor obtido na coluna malaria_tot (os dados já são contagens diárias, então utilizamos geom_col() - veja a seção “Bar plot” abaixo).\nQuando adicionamos o comando facet_wrap(), especificamos um til e depois a coluna para facetar sobre (neste caso, District). Você pode colocar outra coluna no lado esquerdo do til - isto criará uma faceta para cada combinação - mas recomendamos que você faça isto com facet_grid() em seu lugar. Neste caso de uso, uma faceta é criada para cada valor único de District.\n\n# Um gráfico com facetas por distrito \n\nggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1, fill = \"darkred\") +       # plote a contagem como colunas \n  theme_minimal()+                              # simplifique os paineis de fundo\n  labs(                                         # aficione rótulos, títulos, etc. \n    x = \"Data dos registros\",\n    y = \"Casos de malária\",\n    title = \"Casos de malária por distrito\") +\n  facet_wrap(~District)                       # As facetas são criadas\n\n\n\n\n\n\n\n\n\n\nfacet_grid()\nPodemos utilizar uma abordagem facet_grid() para cruzar duas variáveis. Digamos que queremos cruzar o Distrito (District) e a idade (age). Bem, precisamos fazer algumas transformações de dados nas colunas de idade para obter esses dados no formato “longo”, preferido pelo ggplot. Todos os grupos etários têm suas próprias colunas - queremo-los em uma única coluna chamada faixa_etaria e outra chamada num_casos. Consulte a página em Pivoteamento de dados para obter mais informações sobre este processo.\n\nmalaria_age &lt;- malaria_data %&gt;%\n  select(-malaria_tot) %&gt;% \n  pivot_longer(\n    cols = c(starts_with(\"malaria_rdt_\")),  # escolha as colunas que quer pivotear para o formato longo\n    names_to = \"faixa_etaria\",      # column names become age group\n    values_to = \"num_casos\"      # values to a single column (num_casos)\n  ) %&gt;%\n  mutate(\n    faixa_etaria = str_replace(faixa_etaria, \"malaria_rdt_\", \"\"),\n    faixa_etaria = forcats::fct_relevel(faixa_etaria, \"5-14\", after = 1))\n\nAgora as primeiras 50 linhas dos dados aparecem assim:\n\n\n\n\n\n\nQuando você passa as duas variáveis para facet_grid(), o mais fácil é utilizar notação de fórmula (por exemplo x ~ y) onde x corresponde às linhas e y às colunas. Aqui está o gráfico, utilizando facet_grid() para mostrar os gráficos para cada combinação das colunas faixa_etaria e District.\n\nggplot(malaria_age, aes(x = data_date, y = num_casos)) +\n  geom_col(fill = \"darkred\", width = 1) +\n  theme_minimal()+\n  labs(\n    x = \"Data dos registros\",\n    y = \"Casos de malária\",\n    title = \"Casos de malária por distrito e faixa etária\"\n  ) +\n  facet_grid(District ~ faixa_etaria)\n\n\n\n\n\n\n\n\n\n\nEixos livres ou fixos\nAs escalas de eixos exibidas quando realizamos o facetamento é por padrão a mesma (ou seja, fixa) em todas as facetas. Isto é útil para a comparação cruzada, mas nem sempre apropriado.\nAo utilizar facet_wrap() ou facet_grid(), podemos adicionar scales = \"free_y\" para “liberar” os eixos y dos painéis para escalar adequadamente seu subconjunto de dados. Isto é particularmente útil se as contagens reais forem pequenas para uma das subcategorias e se as tendências forem difíceis de se observar de outra forma. Em vez de “free_y” também podemos escrever “free_x” para fazer o mesmo para o eixo x (por exemplo, para datas) ou apenas “free” para ambos os eixos. Note que em facet_grid, a escala y será a mesma para facetas na mesma linha, e a escala x será a mesma para facetas na mesma coluna.\nAo utilizar somente facet_grid, podemos adicionar space = \"free_y\" ou space = \"free_x\" para que a altura ou largura real da faceta seja ponderada para os valores da figura dentro. Isto só funciona se scales = \"free\" (y ou x) já estiver aplicado.\n\n# Eixo y livre\n\n\nggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1, fill = \"darkred\") +       # plote os dados de contagem como colunas\n  theme_minimal()+                              # simplifique os painel de fundo\n  labs(                                         # adicione rótulos, título, etc.\n\n    x = \"Data de registro\",\n    y = \"Casos de malária\",\n    title = \"Casos de malária por distrito - Eixos x e y 'livres'\") +\n  facet_wrap(~District, scales = \"free\")        # as facetas são criadas\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOrdem dos fatores nas facetas\nVeja este post sobre como reordenar os níveis de um fator dentro de cada faceta.",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>O básico do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.pt.html#armazenando-gráficos",
    "href": "new_pages/ggplot_basics.pt.html#armazenando-gráficos",
    "title": "30  O básico do ggplot",
    "section": "30.7 Armazenando gráficos",
    "text": "30.7 Armazenando gráficos\n\nSalvando gráficos\nPor padrão, quando você executa um comando ’ggplot(), o gráfico será apresentado no painel Plots do RStudio. Entretanto, você também pode salvar o gráfico como um objeto utilizando o operador de atribuição&lt;-e dando-lhe um nome. Então, ele não será exibido a menos que o próprio nome do objeto seja executado. Você também pode imprimi-lo envolvendo o nome do gráfico comprint()`, mas isto só é necessário em certas circunstâncias, como se o gráfico for criado dentro de um loop utilizado para imprimir vários gráficos de uma vez (veja a página Iteração, laços e listas).\n\n# Atribua o gráfico a um objeto\n\n\nage_by_wt &lt;- ggplot(data = linelist, mapping = aes(x = age_years, y = wt_kg, color = age_years))+\n  geom_point(alpha = 0.1)\n\n# exiba\nage_by_wt    \n\n\n\n\n\n\n\n\n\n\nModificando gráficos salvos\nUma coisa legal sobre ggplot2 é que você pode definir um gráfico (como acima), e depois adicionar camadas a ele começando com seu nome. Você não precisa repetir todos os comandos que criaram o gráfico original!\nPor exemplo, para modificar o gráfico age_by_wt que foi definida acima, para incluir uma linha vertical aos 50 anos de idade, basta adicionar um + e começar a adicionar camadas adicionais ao gráfico.\n\nage_by_wt+\n  geom_vline(xintercept = 50)\n\n\n\n\n\n\n\n\n\n\nExportando gráficos\nA exportação de gráficos feitos no ggplot é facilitada com a função ggsave() de ggplot2. Ela pode funcionar de duas maneiras:\n\nEspecifique o nome do objeto do gráfico, depois o caminho do arquivo e o nome com extensão\n\nPor exemplo: ggsave(my_plot, here(\"plots\", \"my_plot.png\"))\n\n\nExecute o comando com apenas o parâmetro do caminho de arquivo, para salvar o último gráfico que foi feito\n\nPor exemplo: ggsave(here(\"plots\", \"my_plot.png\"))\n\n\nVocê pode exportar como png, pdf, jpeg, tiff, bmp, svg, ou vários outros tipos de arquivo, especificando a extensão do arquivo no caminho do arquivo.\nVocê também pode especificar os argumentos width =, (largura) height = (altura), e units = (ou “in”, “cm”, ou “mm”). Você também pode especificar dpi = com um número para a resolução da imagem a ser salva (por exemplo, 300). Veja os detalhes da função digitando ?ggsave ou lendo a documentação online.\nLembre-se de que você pode utilizar a sintaxe da função here() para fornecer o caminho de arquivo desejado. Consulte a página Importar e exportar para obter mais informações.",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>O básico do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.pt.html#rótulos",
    "href": "new_pages/ggplot_basics.pt.html#rótulos",
    "title": "30  O básico do ggplot",
    "section": "30.8 Rótulos",
    "text": "30.8 Rótulos\nCertamente você vai querer adicionar ou ajustar os rótulos (elementos de texto) do gráfico. Estes ajustes são mais facilmente feitos dentro da função labs() que é adicionada ao gráfico com + tal como os geoms eram.\nDentro de labs() você pode fornecer strings para estes parâmetros:\n\nx = e y = O título do eixo x e do eixo y (etiquetas)\n\ntitle = O título principal do gráfico\nsubtitle = O subtítulo do gráfico, em texto menor abaixo do título\n\ncaption = A legenda do gráfico, na parte inferior direita por padrão\n\nAqui está um gráfico que fizemos anteriormente, mas com rótulos mais bonitos:\n\nage_by_wt &lt;- ggplot(\n  data = linelist,   # especifique o objeto com os dados\n  mapping = aes(     # mapeie as aesthetics para colunas desses dados\n         x = age,           # mapeie o eixo x para idade (coluna age)            \n         y = wt_kg,         # mapeie o eixo x para peso (coluna wt_kg)       \n         color = age))+     # mapeie a cor para a idade\n  geom_point()+           # mostre os dados como pontos\n  labs(\n    title = \"Distribuição de idade e peso\",\n\n    subtitle = \"Surto de Ebola fictício, 2014\",\n    x = \"Idade em anos\",\n    y = \"Peso em quilos\",\n    color = \"Idade\",\n    caption = stringr::str_glue(\"Dados como em {max(linelist$date_hospitalisation, na.rm=T)}\"))\n\nage_by_wt\n\n\n\n\n\n\n\n\nObserve como na atribuição do título utilizamos str_glue() do pacote stringr para implantar código R dinâmico dentro do texto da string. O legenda mostrará os “Dados a partir de”: “data que reflete a data máxima de hospitalização na linelist”. Leia mais sobre isto na página em Caracteres e strings.\nUma nota sobre a especificação do título da legenda: Não há nenhum argumento de “título da legenda”, pois você poderia ter múltiplas escalas em sua legenda. Dentro de labs(), você pode escrever o argumento da aesthetic do gráfico utilizada para criar a legenda, e fornecer o título desta forma. Por exemplo, acima atribuímos color = age para criar a legenda. Portanto, fornecemos color = a labs() e atribuímos o título da legenda desejada (“Idade” com I maiúsculo). Se você criar a legenda com aes(fill = COLUMN), então em labs() você escreveria fill = para ajustar o título dessa legenda. A seção sobre escalas de cores na página Dicas para o ggplot fornece mais detalhes sobre edição de legendas, e uma abordagem alternativa utilizando funções scales_().",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>O básico do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.pt.html#ggplot_basics_themes",
    "href": "new_pages/ggplot_basics.pt.html#ggplot_basics_themes",
    "title": "30  O básico do ggplot",
    "section": "30.9 Temas",
    "text": "30.9 Temas\nUma das melhores partes do ggplot2 é a quantidade de controle que você tem sobre o gráfico - você pode definir qualquer coisa! Como mencionado acima, o desenho do gráfico que não está relacionado às formas/geometrias dos dados são ajustados dentro da função theme(). Por exemplo, a cor de fundo do gráfico, presença/ausência de linhas de grade e a fonte/tamanho/cor/alinhamento do texto (títulos, subtítulos, legendas, texto do eixo…). Estes ajustes podem ser feitos de uma de duas maneiras:\n*Adicionar um tema completo theme_()função para fazer ajustes de varredura - estes incluem theme_classic(), theme_minimal(), theme_dark(), theme_light()theme_grey(),theme_bw()` entre outros\n\nAjuste cada pequeno aspecto do gráfico individualmente dentro de theme()\n\n\nTemas completos\nComo eles são bastante diretos, demonstraremos as funções temáticas completas abaixo e não as descreveremos mais aqui. Note que quaisquer micro-ajustes com theme() devem ser feitos após a utilização de um tema completo.\nEscreva-os com parênteses vazios.\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Tema classic\")+\n  theme_classic()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Tema bw\")+\n  theme_bw()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Tema minimal\")+\n  theme_minimal()\n\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  \n  geom_point(color = \"darkgreen\", size = 0.5, alpha = 0.2)+\n  labs(title = \"Tema gray\")+\n  theme_gray()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModifique o tema\nA função theme() pode levar um grande número de argumentos, cada um dos quais edita um aspecto muito específico do gráfico. Não há como cobrir todos os argumentos, mas vamos descrever o padrão geral para eles e mostrar-lhe como encontrar o nome do argumento que você precisa. A sintaxe básica é esta:\n\nDentro de theme() escreva o nome do argumento para o elemento do gráfico que você deseja editar, como plot.title =\n\nFornecer uma função element_() para o argumento\n\n\n\nNa maioria das vezes, utilize element_text(), mas outros incluem element_rect() para cores de fundo de tela, ou element_blank() para remover os elementos do gráfico\n\n\nDentro da função element_(), escreva atribuições de argumentos para fazer os ajustes finos que você deseja\n\nEssa descrição foi bastante abstrata, portanto, aqui estão alguns exemplos.\nO gráfico abaixo parece bastante tolo, mas serve para mostrar uma variedade de maneiras de ajustar seu gráfico.\n\nComeçamos com o gráfico age_by_wt definido logo acima e acrescentamos theme_classic()\n\nPara ajustes mais finos, adicionamos theme() e incluímos um argumento para cada elemento do gráfico a ser ajustado\n\nPode ser bom organizar os argumentos em seções lógicas. Para descrever apenas alguns dos utilizados abaixo:\n\nlegend.position = é único no sentido de aceitar valores simples como “bottom”, “top”, “left”, e “right”. Mas geralmente, os argumentos relacionados ao texto exigem que você coloque os detalhes no element_text().\n\ntamanho do título com element_text(size = 30).\n\nO alinhamento horizontal do título com element_text(hjust = 0) (da direita para a esquerda)\n\nO subtítulo está em itálico com element_text(face = \"italic\")\n\n\nage_by_wt + \n  theme_classic()+                                 # ajustes de tema pré-definidos\n  theme(\n    legend.position = \"bottom\",                    # move a legenda  para baixo\n    \n    plot.title = element_text(size = 30),          # ajusta o tamanho do título para 30\n    plot.caption = element_text(hjust = 0),        # alinha a Legenda da figura a esquerda\n    plot.subtitle = element_text(face = \"italic\"), # deixa subtítulo em itálico\n\n    \n    axis.text.x = element_text(color = \"red\", size = 15, angle = 90), # ajusta o texto o eixo x \n    axis.text.y = element_text(size = 15),         # ajusta o texto o eixo y\n    \n    axis.title = element_text(size = 20)           # ajusta o texto de ambos os eixos\n    )     \n\n\n\n\n\n\n\n\nAqui estão alguns argumentos especialmente comuns em theme(). Você reconhecerá alguns padrões, tais como acrescentar .x' ou.y’ para aplicar a mudança somente em um eixo.\n\n\n\n\n\n\n\nArgumento theme()\nO que é ajustado\n\n\n\n\nplot.title = element_text()\nO título\n\n\nplot.subtitle = element_text()\nO subtítulo\n\n\nplot.caption = element_text()\nA legenda da figura (parâmetros: family, face, color, size, angle,…)\n\n\naxis.title = element_text()\nTítulos e ambos eixos (ambos x e y) (parâmetros: size, face, color…)\n\n\naxis.title.x = element_text()\nTítulo do eixo x (use .y para apenas eixo Y)\n\n\naxis.text = element_text()\nTexto do eixo x (ambos x and y)\n\n\naxis.text.x = element_text()\nTexto do eixo x (use .y para apenas eixo Y)\n\n\n\naxis.ticks = element_blank() |Remove marcações de escalas do eixo axis.line = element_line() |Linhas do eixo (parâmetros: colour, linetype: solid dashed dotted etc) strip.text = element_text() |Texto do rótulo da faceta (parâmetros: colour, face, size, angle…) strip.background = element_rect()|Rótulo da faceta (parâmetros: fill, colour, size…)\nMas há tantos argumentos para temas! Como eu poderia me lembrar de todos eles? Não se preocupe - é impossível lembrar-se de todos eles. Felizmente, existem algumas ferramentas para ajudá-lo:\nA documentação sobre modificação do tema, que tem uma lista completa.\nDICA: Rode theme_get() do ggplot2 para listar os mais de 90 argumentos da função theme() no console .\nDICA: Se você em algum momento quiser remover um elemento do gráfico, você também o pode fazer com o theme(). Apenas passe o parâmetro element_blank() para um argumento para que ele desapareca completamente. Para legendas, configure legend.position = \"none\".",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>O básico do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.pt.html#cores",
    "href": "new_pages/ggplot_basics.pt.html#cores",
    "title": "30  O básico do ggplot",
    "section": "30.10 Cores",
    "text": "30.10 Cores\nPor favor veja a seção sobre escala de cores na página de dicas do ggplot.",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>O básico do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.pt.html#usando-o-pipe-no-ggplot2",
    "href": "new_pages/ggplot_basics.pt.html#usando-o-pipe-no-ggplot2",
    "title": "30  O básico do ggplot",
    "section": "30.11 Usando o pipe (%>%) no ggplot2",
    "text": "30.11 Usando o pipe (%&gt;%) no ggplot2\nAo utilizar pipes (%&gt;%) para limpar e transformar seus dados, é fácil passar os dados transformados em ggplot().\nOs pipes que passam o conjunto de dados de função para função passarão a ser um símbolo de mais + assim que a função ggplot() for chamada. Observe que, neste caso, não há necessidade de especificar o argumento data = (data), pois este é automaticamente definido como o conjunto de dados que vinha sendo usado no pipe.\nEsta é a aparência que pode ter:\n\nlinelist %&gt;%   # comece com a linelist\n rename(tosse=cough,\n         febre=fever, \n         vômito=vomit,\n         dores=aches,\n         calafrio=chills) %&gt;%  #traduzindo o nome dos sintomas pois a base está em inglês\n  select(c(case_id, febre, calafrio, tosse, dores, vômito)) %&gt;%   # selecione as colunas\n  \n  pivot_longer(                                                  # faça o pivotamento para ficar mais longo\n    cols = -case_id,                                  \n    names_to = \"nome_sintoma\",\n    values_to = \"sintoma_esta_presente\") %&gt;%\n  mutate(                                                        # substitua valores faltantes\n    sintoma_esta_presente = replace_na(sintoma_esta_presente, \"desconhecido\")) %&gt;% \n  \n  ggplot(                                                        # comece o gráfico!\n    mapping = aes(x = nome_sintoma, fill = sintoma_esta_presente))+\n  geom_bar(position = \"fill\", col = \"black\") +                    \n  theme_classic() +\n  labs(\n    x = \"Sintoma\",\n    y = \"Status do sintoma (proporção)\"\n  )",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>O básico do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.pt.html#fazer-gráficos-de-dados-contínuos",
    "href": "new_pages/ggplot_basics.pt.html#fazer-gráficos-de-dados-contínuos",
    "title": "30  O básico do ggplot",
    "section": "30.12 Fazer gráficos de dados contínuos",
    "text": "30.12 Fazer gráficos de dados contínuos\nAo longo desta página, você já viu muitos exemplos de gráficos de dados contínuos. Aqui nós os consolidamos brevemente e apresentamos algumas variações.\nAs visualizações aqui abordadas incluem:\nGráficos para uma variável contínua:\n Histograma, um gráfico clássico para apresentar a distribuição de uma variável contínua. * Diagramas de caixa (box-plots), para mostrar os percentis 25%, 50% e 75%, pontas de cauda da distribuição e outliers (limitações importantes).\n* Gráfico Jitter, para mostrar todos os valores como pontos que estão ‘tremidos’ para que possam (principalmente) ser todos vistos, mesmo onde dois têm o mesmo valor.\n* Gráfico Violino, mostrar a distribuição de uma variável contínua com base na largura simétrica do ‘violino’. * Gráfico Sina, são uma combinação de gráficos de jitter e violino, onde são mostrados pontos individuais mas na forma simétrica da distribuição (via ggforce pacote). (Nota do Tradutor: Jitter em inglês significa “agitado, nervoso” e se remete ao fato dos pontos, nesse gráfico ficarem mais “espalhados” de forma a não ficarem sobrepostos ) * Gráfico de dispersão Para duas variáveis contínuas.\n* Gráficos de calor para três variáveis contínuas (ligados à página gráficos de calor)\n\nHistogramas\nOs histogramas podem parecer gráficos de barras, mas são distintos porque medem a distribuição de uma variável contínua. Não há espaços entre as “barras”, e apenas uma coluna é fornecida ao geom_histogram().\nAbaixo está o código para gerar histogramas, que agrupam dados contínuos em intervalos e exibem em barras adjacentes de altura variável. Isto é feito utilizando o geom_histogram(). Ver a secção “Gráfico de barra” da página básico do ggplot para compreender a diferença entre geom_histogram(), geom_bar(), e geom_col().\nMostraremos a distribuição das idades dos casos. Dentro de mapping = aes() especifique a coluna de que deseja ver a distribuição. Pode atribuir esta coluna ao eixo x ou ao eixo y.\nAs linhas serão atribuídas a “caixas/classes” com base na sua idade numérica, e estas classes serão representadas graficamente por barras. Se especificar um número de classes com a aesthetic bins =, os pontos de quebra são uniformemente espaçados entre os valores mínimo e máximo do histograma. Se bins = não estiver especificado, será adivinhado um número apropriado de classes e esta mensagem será exibida após o gráfico:\n## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\nSe não quiser especificar um número de classes para bins =, pode, em alternativa, especificar binwidth = nas unidades do eixo. Apresentamos alguns exemplos que mostram diferentes quantidades e larguras de classes:\n\n# A) Histograma regular\nggplot(data = linelist, aes(x = age))+  # forneça a variável do eixo x\n  geom_histogram()+\n  labs(title = \"A) Histograma padrão (30 classes)\")\n\n# B) Mais classes\nggplot(data = linelist, aes(x = age))+  # forneça a variável do eixo x\n  geom_histogram(bins = 50)+\n  labs(title = \"B) Ajustado para 50 classes\")\n\n# C) Menos classes\nggplot(data = linelist, aes(x = age))+  # forneça a variável do eixo x\n  geom_histogram(bins = 5)+\n  labs(title = \"C) Ajustado para 5 classes\")\n\n\n# D) Mais classes\nggplot(data = linelist, aes(x = age))+  # forneça a variável do eixo x\n  geom_histogram(binwidth = 1)+\n  labs(title = \"D) Largura da classe = 1\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPara obter proporções suavizadas, pode utilizar geom_density():\n\n# Frequencia com eixos de proporção, suavizadas. \nggplot(data = linelist, mapping = aes(x = age)) +\n  geom_density(size = 2, alpha = 0.2)+\n  labs(title = \"Densidade proporcional\")\n\n# Frequência empilhada com eixo proporcional, suavizada \n\nggplot(data = linelist, mapping = aes(x = age, fill = gender)) +\n  geom_density(size = 2, alpha = 0.2, position = \"stack\")+\n  labs(title = \" Densidades proporcionais 'empilhada'\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPara obter um histograma “empilhado” (de uma coluna contínua de dados), você pode fazer uma das seguintes ações:\n\nUtilize geom_histogram() com o fill = argumento dentro de aes() e atribuído à coluna de agrupamento, ou\n\nUtilize geom_freqpoly(), que provavelmente é mais fácil de ler (você ainda pode definir binwidth =)\n\nPara ver as proporções de todos os valores, defina o y = after_stat(density) (utilize esta sintaxe exatamente - não alterada para seus dados). Nota: estas proporções mostrarão por grupo.\n\nCada uma delas é mostrada abaixo (*notar a utilização de color = vs. fill = em cada uma):\n\n# Histograma *empilhado*\n\nggplot(data = linelist, mapping = aes(x = age, fill = gender)) +\n  geom_histogram(binwidth = 2)+\n  labs(title = \"histograma 'empilhado'\")\n\n# Frequência\nggplot(data = linelist, mapping = aes(x = age, color = gender)) +\n  geom_freqpoly(binwidth = 2, size = 2)+\n  labs(title = \"Polígono de frequência\")\n\n# Freqüência com eixo de proporção \nggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), color = gender)) +\n  geom_freqpoly(binwidth = 5, size = 2)+\n  labs(title = \"Polígono de frequência proporcional\")\n\n# Freqüência com eixo de proporção , suavizado\nggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), fill = gender)) +\n  geom_density(size = 2, alpha = 0.2)+\n  labs(title = \"Proportional, suavizado com geom_density()\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSe você quiser se divertir, tente ‘geom_density_ridges’ do pacote ggridges* (vinheta aqui.\nLeia mais em detalhes sobre histogramas no tidyverse página em geom_histogram().\n\n\nBox plots\nOs bos-plots são comuns, mas têm limitações importantes. Elas podem obscurecer a distribuição real - por exemplo, uma distribuição bi-modal. Veja este galeria de gráficos R e este artigo data-to-viz para mais detalhes. Entretanto, eles exibem bem a faixa inter-quartil e aberturas - de modo que podem ser sobrepostos em cima de outros tipos de gráficos que mostram a distribuição em mais detalhes.\nAbaixo lembramos os vários componentes de um boxplot:\n\n\n\n\n\n\n\n\n\nAo utilizar geom_boxplot() para criar diagrama de caixas (box-plot), você geralmente mapeia apenas um eixo (x ou y) dentro de aes(). O eixo especificado determina se as parcelas são horizontais ou verticais.\nNa maioria dos geoms, você cria um gráfico por grupo mapeando uma estética como color = ou fill = para uma coluna dentro de aes(). Entretanto, para box-plots, isso é conseguido atribuindo a coluna de agrupamento ao eixo não atribuído (x ou y). Abaixo está o código para um boxplot de todos os valores de idade no conjunto de dados, e o segundo é o código para exibir um box plot para cada sexo (não-faltante) no conjunto de dados. Observe que os valores NA (ausentes) aparecerão como um gráfico de caixa separado, a menos que seja removido. Neste exemplo, também definimos o fill para a coluna outcome, para que cada gráfico seja de uma cor diferente - mas isto não é necessário.\n\n# A) Boxplot geral\nggplot(data = linelist)+  \n  geom_boxplot(mapping = aes(y = age))+   # apenas o y é mapeado\n  labs(title = \"A) Boxplot geral\")\n\n# B) Box plot por grupo\nggplot(data = linelist, mapping = aes(y = age, x = gender, fill = gender)) + \n  geom_boxplot()+                     \n  theme(legend.position = \"none\")+   # remove a legenda\n  labs(title = \"B) Box plot por sexo\")      \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPara obter o código para adicionar um boxplot às bordas de um gráfico de dispersão (gráficos “marginais”) veja a página [Dicas para o ggplot].\n\n\nGráficos: Violino, jitter, sina\nBelow is code for creating violin plots (geom_violin) and jitter plots (geom_jitter) to show distributions. You can specify that the fill or color is also determined by the data, by inserting these options within aes().\n\n# A) Gráfico de jitter por grupo\n\nggplot(data = linelist %&gt;% drop_na(outcome),      # remove valores faltantes\n       mapping = aes(y = age,                     # variável contínua escolhida\n           x = outcome,                           # variável de agrupamento\n           color = outcome))+                     # variável para cor\n  geom_jitter()+                                  # criar o gráfico ´Jitter\n  labs(title = \"A) Um grafico 'jitter' por gênero\" )  \n\n\n\n# B) Gráfico de violino\nggplot(data = linelist %&gt;% drop_na(outcome),       # remove valores faltantes\n       mapping = aes(y = age,                      # Variável contínua\n           x = outcome,                            # Variável de agrupamento\n           fill = outcome))+                       # variável de cor para preenchimento\n  geom_violin()+                                   # criar o gráfico de violino\n  labs(title = \"B) Gráfico de violino por gênero\")    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVocê pode combinar os dois utilizando a função geom_sina() do pacote ggforce. Esse gráfico traça os pontos do gráfico jitter na forma do gráfico de violino. Quando sobrepostos (ajustando as transparências), isto pode ser mais fácil de interpretar visualmente.\n\n# Um gráfico Sina por grupo\nggplot(\n  data = linelist %&gt;% drop_na(outcome), \n  aes(y = age,           # variável numérica\n      x = outcome)) +    # variável de agrupamento\n  geom_violin(\n    aes(fill = outcome), # mapeie o preenchimento (cor do fundo do violino) segundo uma coluna\n    color = \"white\",     # borda exterior branca\n    alpha = 0.2)+        # transparencia\n  geom_sina(\n    size=1,                # Mude o tamanho do \"jitter\"\n    aes(color = outcome))+ # cor dos pontos\n  scale_fill_manual(       # defina as cores de preenchimento do violino\n    values = c(\"Death\" = \"#bf5300\", #óbito\n              \"Recover\" = \"#11118c\")) + # recuperado\n  scale_color_manual(      # defina as cores de preenchimento dos pontos\n    values = c(\"Death\" = \"#bf5300\", \n              \"Recover\" = \"#11118c\")) + \n  theme_minimal() +                                # Remove o fundo cinza\n  theme(legend.position = \"none\") +                # Remove legendas desnecessárias\n  labs(title = \"Gráfico Sina e Violino por gênero, com formtações extras\")      \n\n\n\n\n\n\n\n\n\n\nDuas variáveis contínuas\nSeguindo uma sintaxe semelhante, geom_point() permitirá traçar duas variáveis contínuas uma contra a outra em uma gráfico de dispersão. Isto é útil para mostrar os valores reais ao invés de suas distribuições. Um gráfico básico de dispersão de idade vs peso é mostrado em (A). Em (B) utilizamos novamente facet_grid() para mostrar a relação entre duas variáveis contínuas na linelist.\n\n#Gráfico de dispersão básico para idade e peso\nggplot(data = linelist, \n       mapping = aes(y = wt_kg, x = age))+\n  geom_point() +\n  labs(title = \"A) Gráfico de dispesão para idade e peso\")\n\n# Gráfico de dispersão de peso e idade por gênero e desfecho para o Ebola \nggplot(data = linelist %&gt;% drop_na(gender, outcome), # filtro mantém apenas gênero e desfecho não faltantes\n       mapping = aes(y = wt_kg, x = age))+\n  geom_point() +\n  labs(title = \"B) Gráfico de dispersão do peso por idade facetado para gênero e desfecho\")+\n  facet_grid(gender ~ outcome) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTrês variáveis contínuas\nVocê pode exibir três variáveis contínuas utilizando o argumento fill = para criar um gráfico de calor. A cor de cada “célula” irá refletir o valor da terceira coluna contínua de dados. Veja a página Dicas para o ggplot e a página em Gráficos de calor para mais detalhes e vários exemplos.\nExistem maneiras de fazer gráficos 3D em R, mas para a epidemiologia aplicada, estes são freqüentemente difíceis de interpretar e, portanto, menos úteis para a tomada de decisões.",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>O básico do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.pt.html#gráficos-de-dados-categóricos",
    "href": "new_pages/ggplot_basics.pt.html#gráficos-de-dados-categóricos",
    "title": "30  O básico do ggplot",
    "section": "30.13 Gráficos de dados categóricos",
    "text": "30.13 Gráficos de dados categóricos\nDados categóricos podem ser variáveis do tipo caractere ou variáveis lógicas (TRUE/FALSE. VERDADEIRO/FALSO), ou ainda fatores (veja a página Fatores).\n\nPreparação\n\nEstrutura dos dados\nA primeira coisa a entender sobre seus dados categóricos é se eles em sua forma bruta existem observações como uma lista de casos, ou como um quadro resumido ou agregados que contém contagens ou proporções. O estado de seus dados terá impacto na função de gráficos que você utiliza:\n\nSe seus dados forem observações em bruto com uma linha por observação, você provavelmente utilizará geom_bar()\n\nSe seus dados já estiverem agregados em contagens ou proporções, você provavelmente utilizará geom_col()\n\n\n\nClasse da coluna e ordenamento dos valores\nEm seguida, examine a classe das colunas que você deseja traçar. Examinamos hospital, primeiro com a função class() do R base, e com tabyl() dO pacote janitor.\n\n# Veja a classe da coluna hospital - podemos ver que é um caracter\nclass(linelist$hospital)\n\n[1] \"character\"\n\n# Veja os valores e proporções dentro dessa coluna \"hospital\" \nlinelist %&gt;% \n  tabyl(hospital)\n\n                             hospital    n    percent\n                              Ausente 1469 0.24949049\n                     Central Hospital  454 0.07710598\n                    Military Hospital  896 0.15217391\n                                Other  885 0.15030571\n                        Port Hospital 1762 0.29925272\n St. Mark's Maternity Hospital (SMMH)  422 0.07167120\n\n\nPodemos ver que os valores dentro são caracteres, pois se tratam de nomes de hospitais, e por padrão são ordenados alfabeticamente. Existem também “outros” e “faltam” valores, que preferimos que sejam as últimas subcategorias ao apresentarmos as subdivisões. Portanto, transformamos esta coluna em um fator e a reordenamos. Isto é tratado com mais detalhes na página Fatores.\n\n# Converte para fator e define a ordem dos níveis para que \"Other\" (outros) e \"Missing\" (faltantes) sejam os últimos a aparecer \nlinelist &lt;- linelist %&gt;% \n  mutate(\n    hospital = fct_relevel(hospital, \n      \"St. Mark's Maternity Hospital (SMMH)\",\n      \"Port Hospital\", \n      \"Central Hospital\",\n      \"Military Hospital\",\n      \"Other\",\n      \"Missing\"))\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `hospital = fct_relevel(...)`.\nCaused by warning:\n! 1 unknown level in `f`: Missing\n\n\n\nlevels(linelist$hospital)\n\n[1] \"St. Mark's Maternity Hospital (SMMH)\"\n[2] \"Port Hospital\"                       \n[3] \"Central Hospital\"                    \n[4] \"Military Hospital\"                   \n[5] \"Other\"                               \n[6] \"Ausente\"                             \n\n\n\n\n\ngeom_bar()\nUtilize geom_bar() se você quiser que a altura da barra (ou a altura dos componentes da barra empilhada) reflita o número de linhas relevantes nos dados. Essas barras terão espaços entre elas, a menos que a aesthetic largura ( width = ) esteja ajustada.\n\nForneça apenas uma atribuição de coluna de um eixo (tipicamente eixo x). Se você fornecer x e y, você receberá Error: stat_count() só pode ter uma estética x ou y.\n\nVocê pode criar barras empilhadas, adicionando uma atribuição de fill = coluna dentro de mapping = aes().\n\nO eixo oposto será intitulado “count” por padrão, pois representa o número de linhas\n\nA seguir, designamos o resultado para o eixo y, mas poderia ser igualmente fácil no eixo x. Se você tiver valores de caracteres mais longos, às vezes pode parecer melhor virar as barras para o lado e colocar a legenda embaixo. Isto pode ter impacto na forma como os níveis do seu fator são ordenados - neste caso os revertemos com fct_rev() para colocar “Other” e “Missing” na parte inferior.\n\n# A) Desfecho em todos os casos\nggplot(linelist %&gt;% drop_na(outcome)) + \n  geom_bar(aes(y = fct_rev(hospital)), width = 0.7) +\n  theme_minimal()+\n  labs(title = \"A) Número de casos por hospital\",\n       y = \"Hospital\")\n\n\n# B) Desfecho em todos os casos por hospital\nggplot(linelist %&gt;% drop_na(outcome)) + \n  geom_bar(aes(y = fct_rev(hospital), fill = outcome), width = 0.7) +\n  theme_minimal()+\n  theme(legend.position = \"bottom\") +\n  labs(title = \"B) Número de casos de Ebola recuperados e de óbitos,   por hospital\",\n       y = \"Hospital\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngeom_col()\nUtilize geom_col() se você quiser que a altura da barra (ou altura dos componentes da barra empilhados) reflita os valores pré-calculados que existem nos dados. Muitas vezes, estas são contagens sumárias ou “agregadas”, ou proporções.\nForneça atribuições de colunas para ambos eixos para geom_col(). Normalmente, sua coluna do eixo x é discreta e sua coluna do eixo y é numérica.\nDigamos que temos este conjunto de dados “resultados”:\n\n\n# A tibble: 2 × 3\n  outcome        n proporcao\n  &lt;chr&gt;      &lt;int&gt;     &lt;dbl&gt;\n1 Recuperado   796      43.8\n2 Óbito       1022      56.2\n\n\nAbaixo está o código utilizando geom_col para criar gráficos de barras simples para mostrar a distribuição dos resultados dos pacientes com Ebola. Com o geom_col, tanto x como y precisam ser especificados. Aqui x é a variável categórica ao longo do eixo x, e y é a coluna de proporções geradas proporcao.\n\n# Desfecho em todos os casos\nggplot(outcomes) + \n  geom_col(aes(x=outcome, y = proporcao)) +\n  labs(subtitle = \"Número de casos recuperados e óbitos de Ebola\")\n\n\n\n\n\n\n\n\nPara mostrarmos as detalhamentos por hospital, precisaríamos que nossa tabela contivesse mais informações e que estivesse em formato “longo”. Criamos esta tabela com as freqüências das categorias combinadas outcome (Desfecho) e hospital (ver página Agrupando dados para dicas de agrupamento).\n\noutcomes2 &lt;- linelist %&gt;% \n  drop_na(outcome) %&gt;% \n  count(hospital, outcome) %&gt;%  # obtém contagens para hospital e desfecho \n\n  group_by(hospital) %&gt;%        # Agrupa para que proporção esteja fora do total do hospital \n  mutate(proportion = n/sum(n)*100) # Calcula as proporções\n\n\nhead(outcomes2) # Veja uma prévia dos dados\n\n# A tibble: 6 × 4\n# Groups:   hospital [3]\n  hospital                             outcome     n proportion\n  &lt;fct&gt;                                &lt;chr&gt;   &lt;int&gt;      &lt;dbl&gt;\n1 St. Mark's Maternity Hospital (SMMH) Death     199       61.2\n2 St. Mark's Maternity Hospital (SMMH) Recover   126       38.8\n3 Port Hospital                        Death     785       57.6\n4 Port Hospital                        Recover   579       42.4\n5 Central Hospital                     Death     193       53.9\n6 Central Hospital                     Recover   165       46.1\n\n\nCriamos então o ggplot com alguma formatação adicional:\n\nRotação do eixo: Trocamos o eixo com coord_flip() para que pudéssemos ler os nomes dos hospitais.\nColunas lado a lado: Acrescentou o argumento position = \"dodge\" para que as barras de óbitos e recuperação sejam apresentadas lado a lado em vez de empilhadas. Note que as barras empilhadas são o padrão.\nLargura da coluna: Largura especificada, de modo que as colunas são agora metade da largura normal.\nOrdem das colunas: Inverteu a ordem das categorias no eixo y para que ‘Other’ (Outros) e ‘Missing’ (Faltantes) estejam na parte inferior, com scale_x_discrete(limits=rev). Note que utilizamos isso em vez de scale_y_discrete porque o hospital é indicado no argumento ‘x’ de ’aes()`, mesmo que visualmente esteja no eixo y. Fazemos isso porque ggplot parece apresentar categorias ao contrário, a menos que digamos lhe o contrário.\n\nOutros detalhes: Etiquetas/títulos e cores adicionadas dentro de labs e scale_fill_color respectivamente.\n\n\n# Desfecho em todos os casos por hospital\nggplot(outcomes2) +  \n  geom_col(\n    mapping = aes(\n      x = proportion,                 # apresenta os dados calculados previamente\n      y = fct_rev(hospital),          # reordenas os níveis do fator, colocando na base os desejados \n      fill = outcome),                # empilhados por desfecho\n    width = 0.5)+                     # barras mais finas (valores menores que 1)\n  theme_minimal() +                   # Tema mínimo\n  theme(legend.position = \"bottom\")+\n  labs(subtitle = \"Número de casos recuperados e óbitos por Ebola, por hospital\",\n       fill = \"Desfecho\",             # título da legenda\n       y = \"Contagem\",                # título do eixo y\n       x = \"Hospital de admissão\")+   # título do eixo x\n  scale_fill_manual(                 # escolhendo as cores manualmente\n    values = c(\"Death\"= \"#3B1c8C\",   # para óbito\n               \"Recover\" = \"#21908D\" )) # para recuperado\n\n\n\n\n\n\n\n\nNote que as proporções são binárias, por isso podemos preferir abandonar a “recuperação” e apenas mostrar a proporção de quem morreu. Isto é apenas para fins ilustrativos.\nSe utilizar geom_col() com dados de datas (por exemplo, uma epicurva a partir de dados agregados) - você vai querer ajustar o argumento width = (largura) para remover as linhas de “espaço” entre as barras. Se utilizar o conjunto de dados diário, ajuste width = 1. Se for semanal, ajuste width = 7. Os meses não são possíveis de serem visualizados dessa forma, porque cada mês tem um número de dias diferente.\n\n\ngeom_histogram()\nOs histogramas podem parecer gráficos de barras, mas são distintos porque medem a distribuição de uma variável contínua. Não há espaços entre as “barras”, e apenas uma coluna é fornecida para geom_histogram(). Há argumentos específicos para histogramas como bin_width = e breaks = para especificar como os dados devem ser cdivididos em classes. A seção acima sobre dados contínuos e a página sobre Curvas Epidemiológicas fornecem detalhes adicionais.",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>O básico do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_basics.pt.html#recursos",
    "href": "new_pages/ggplot_basics.pt.html#recursos",
    "title": "30  O básico do ggplot",
    "section": "30.14 Recursos",
    "text": "30.14 Recursos\nHá uma enorme quantidade de ajuda online, especialmente com o ggplot. Veja:\n\nCheat sheet (cola) do ggplot2\nOutra cheat sheet\nPágina do básico do ggplot do tidyverse\n\nPlatando variáveis contínuas\n\nR for Data Science pages on visualização de dados\ngráficos para comunicação",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>O básico do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.pt.html",
    "href": "new_pages/ggplot_tips.pt.html",
    "title": "31  Dicas do ggplot",
    "section": "",
    "text": "31.1 Preparando o ambiente R",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Dicas do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.pt.html#preparando-o-ambiente-r",
    "href": "new_pages/ggplot_tips.pt.html#preparando-o-ambiente-r",
    "title": "31  Dicas do ggplot",
    "section": "",
    "text": "Carregue os pacotes\nO código abaixo realiza o carregamento dos pacotes necessários para a análise dos dados. Neste manual, enfatizamos o uso da função p_load(), do pacman, que instala os pacotes, caso não estejam instalados, e os carrega no R para utilização. Também é possível carregar os pacotes instalados utilizando a função library(), do R base. Para mais informações sobre pacotes do R, veja a página Introdução ao R.\n\npacman::p_load(\n  tidyverse,      # inclue ggplot2 e outros pacotes\n  rio,            # importar/exportar\n  here,           # localizador de arquivos\n  stringr,        # trabalhando com caracteres\n  scales,         # transforme números\n  ggrepel,        # etiquetas colocadas de forma inteligente\n  gghighlight,    # destaque uma parte do gráfico\n  RColorBrewer    # escalas de cores\n)\n\n\n\nImporte os dados\nNesta página, nós importamos um conjunto de dados de casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar, clique para baixar a linelist “limpa” (as .rds file). Importe os dados com a função import(), do pacote rio (ela trabalha com uma variedade de tipos de arquivos, como .xlsx, .csv, .rds - veja a página Importar e exportar para detalhes).\n\nlinelist &lt;- rio::import(\"linelist_cleaned.rds\")\n\nAs primeiras 50 linhas da linelist são mostradas abaixo.",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Dicas do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.pt.html#ggplot_tips_colors",
    "href": "new_pages/ggplot_tips.pt.html#ggplot_tips_colors",
    "title": "31  Dicas do ggplot",
    "section": "31.2 Escalas para as cores, preenchimentos, eixos, etc.",
    "text": "31.2 Escalas para as cores, preenchimentos, eixos, etc.\nNo ggplot2, quando a aparência dos dados no gráfico (ex.: tamanho, cor, formato, preenchimento, eixo do gráfico) é mapeada para colunas nos dados, a visualização exata pode ser ajustada com o comando de “escala” correspondente. Nesta seção, nós explicamos alguns ajustes comuns de escalas.\n\n31.2.1 Esquemas de cores\nUma coisa que pode ser inicialmente difícil de entender com o ggplot2, é o controle dos esquemas de cores. Observe que esta seção discute a cor dos objetos no gráfico (geometrias/formatos), como pontos, barras, linhas, bases, etc. Para ajustar a cor de textos adicionais, títulos, ou plano de fundo, veja a seção Temas da página sobre Básico do ggplot.\nPara controlar a “cor” dos objetos no gráfico, você irá ajustar o argumento color = (a cor exterior do item) ou o fill = (a cor interior do item). Uma exceção a esse padrão é o geom_point(), em que você realmente só consegue ajustar color =, que ajusta a cor do ponto inteiro (interior e exterior).\nAo ajustar a cor ou preenchimento (fill), você pode utilizar o nome das cores reconhecidas pelo R, como \"red\" (vermelho) (veja a lista completa ou digite ?colors), ou um código hexadecimal específico para uma cor, como \"#ff0505\".\n\n# histograma - \nggplot(data = linelist, mapping = aes(x = age))+       # ajuste os dados e eixos\n  geom_histogram(              # mostre o histograma\n    binwidth = 7,                # largura dos containers\n    color = \"red\",               # cor da linha dos containers\n    fill = \"lightblue\")          # cor interior dos containers (preenchimento)\n\n\n\n\n\n\n\n\nComo explicado na seção mapeando os dados para o gráfico, da página Básico do ggplot, aspectos estéticos como fill = e color = podem ser definidos fora do comando mapping = aes(), ou dentro dele. Se fora de aes(), o valor atribuído deve ser estático (ex.: color = \"blue\") e irá ser aplicado para todos os dados colocados no gráfico pelo geom. Se dentro, a aparência estética deve ser mapeada para uma variável, como color = hospital, e a expressão irá variar de acordo com o valor desta linha nos dados. Alguns exemplos:\n\n# Cor estática para pontos e para a linha\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     \n  geom_point(color = \"purple\")+\n  geom_vline(xintercept = 50, color = \"orange\")+\n  labs(title = \"Cor estática para os pontos e linha\")\n\n# Cor mapeada para uma coluna contínua\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     \n  geom_point(mapping = aes(color = temp))+         \n  labs(title = \"Cor mapeada para uma coluna contínua\")\n\n# Cor mapeada para uma coluna discreta\nggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     \n  geom_point(mapping = aes(color = gender))+         \n  labs(title = \"Cor mapeada para uma coluna discreta\")\n\n# gráfico de barras, preenchimento com uma coluna discreta, cor para um valor estático\nggplot(data = linelist, mapping = aes(x = hospital))+     \n  geom_bar(mapping = aes(fill = gender), color = \"yellow\")+         \n  labs(title = \"Preenchimento mapeado para uma coluna discreta, cor estática\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEscalas\nQuando você mapear uma coluna para uma aparência estética do gráfico (ex.: x =, y =, fill =, color =…), seu gráfico irá ganhar uma escala/legenda. Veja acima como a escala pode ter valores contínuos, discretos, datas, etc. dependendo na classe da coluna atribuída. Se você tiver múltiplas estéticas mapeadas para as colunas, seu gráfico terá múltiplas escalas.\nVocê pode controlar as escalas com a função scales_() apropriada. As funções de escala do ggplot() têm 3 partes, que são escritas assim: scale_AESTHETIC_METHOD().\n\nA primeira parte, scale_(), é fixa.\nA segunda parte, o AESTHETIC, deve ser a estética que você quer ajustar a escala para (_fill_, _shape_, _color_, _size_, _alpha_…) - as opções aqui também incluem _x_ e _y_.\n\nA terceira parte, o METHOD, será ou _discrete(), continuous(), _date(), _gradient(), ou _manual(), de acordo com a classe da coluna e como você quer controlar ela. Existem outras classes, mas estes são frequentemente os mais utilizados.\n\nCertifique-se de utilizar a função correta para a escala! Do contrário, seu comando de escala não mudará nada no gráfico. Se você tiver múltiplas escalas, pode utilizar múltiplas funções de escala para ajusta-las! Por exemplo:\n\n\nArgumentos de escala\nCada tipo de escala possui seus próprios argumentos, embora existam alguns em comum. Busque uma função no R, como ?scale_color_discrete, para ver a documentação dos argumentos dessa função.\nPara escalas contínuas, utilize breaks = para fornecer uma sequência de valores com seq() (use to =, from =, e by = como mostrado no exemplo abaixo). Ajuste expand = c(0,0) para eliminar espaços extras ao redor dos eixos (isto pode ser utilizado em qualquer escala _x_ ou _y_).\nPara escalas discretas, você pode ajustar a ordem de aparecimento dos fatores com breaks = e também ajustar os rótulos desses fatores com o argumento labels =. Forneça um vetor de caractere para cada um desses argumentos (veja exemplos abaixo). Você também pode excluir NA facilmente ao ajustar na.translate = FALSE.\nAs nuances de escalas de datas são abordados mais extensivamente na página Curvas epidêmicas.\n\n\nAjustes manuais\nUm dos truques mais úteis é utilizar funções que alteram as escalas de forma “manual”, de forma a explicitamente atribuir cores conforme você desejar. Estas são funções com a sintaxe scale_xxx_manual() (ex.: scale_colour_manual() ou scale_fill_manual()). Cada um dos argumentos a seguir são utilizados no exemplo abaixo.\n\nAtribua cores para os valores dos dados com o argumento values =\n\nEspecifique uma cor para NA com na.value =\n\nMude como os valores são escritos na legenda com o argumento labels =\n\nMude o título da legenda com name =\n\nA seguir, nós criamos um gráfico de barras, mostramos como ele é por padrão, e, então, mostramos como fica após ajustarmos três escalas - a escala contínua do eixo y, a escala discreta do eixo x, e o ajuste manual do preenchimento (cor interior das barras).\n\n# PADRÃO - sem ajuste de escalas\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = outcome, fill = gender))+\n  labs(title = \"Padrão - sem ajuste de escalas\")\n\n\n\n\n\n\n\n# ESCALAS AJUSTADAS\nggplot(data = linelist)+\n  \n  geom_bar(mapping = aes(x = outcome, fill = gender), color = \"black\")+\n  \n  theme_minimal()+                   # simplifique o fundo do gráfico\n  \n  scale_y_continuous(                # escala contínua para o eixo y (contagens)\n    expand = c(0,0),                 # sem espaços extras\n    breaks = seq(from = 0,\n                 to = 3000,\n                 by = 500))+\n  \n  scale_x_discrete(                   # escala discreta para o eixo x (gênero)\n    expand = c(0,0),                  # sem espaços extras\n    drop = FALSE,                     # mostre todos os níveis de factor (mesmo que não estejam nos dados)\n    na.translate = FALSE,             # remove desfechos clínicos desconhecidos (NA) do gráfico\n    labels = c(\"Died\", \"Recovered\"))+ # Mude a visualização dos valores\n    \n  \n  scale_fill_manual(                  # Especifique manualmente o preenchimento (cor interior da barra)\n    values = c(\"m\" = \"violetred\",     # valores de referência nos dados para atribuir cores\n               \"f\" = \"aquamarine\"),\n    labels = c(\"m\" = \"Homem\",          # renomeie a legenda (use \"=\" para fazer atribuições e evitar erros)\n              \"f\" = \"Mulher\",\n              \"Desconhecido\"),\n    name = \"Gênero\",                  # título da legenda\n    na.value = \"grey\"                 # atribua uma cor para dados em branco\n  )+\n  labs(title = \"Com as escalas ajustadas\") # Ajuste o título da legenda do preenchimento\n\n\n\n\n\n\n\n\n\n\nEscalas contínuas dos eixos\nQuando os dados são mapeados para os eixos do gráfico, estes também podem ser ajustados com comandos de escala. Um exemplo simples é ajustar a visualização de um eixo (ex.: eixo y) que é mapeado para uma coluna com dados contínuos.\nNo caso de querermos ajustar as quebras ou visualização dos valores no gráfico, podemos utilizar o scale_y_continuous(), do ggplot. Como observado acima, utilize o argumento breaks = para fornecer uma sequência de valores que irão servir como “quebras” na escala. Estes são os intervalos em que os números serão mostrados. Para este argumento, você pode fornecer um vetor c() contendo os valores dos intervalos desejados, ou você pode fornecer uma sequência regular de números utilizando a função seq() do R base. Esta função aceita to =, from =, e by =.\n\n# PADRÃO - sem ajuste da escala\nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = outcome, fill = gender))+\n  labs(title = \"Padrão - sem ajuste da escala\")\n\n# \nggplot(data = linelist)+\n  geom_bar(mapping = aes(x = outcome, fill = gender))+\n  scale_y_continuous(\n    breaks = seq(\n      from = 0,\n      to = 3000,\n      by = 100)\n  )+\n  labs(title = \"Intervalo do eixo y ajustado\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMostre as porcentagens\nCaso os seus dados originais sejam proporções, você pode facilmente mostra-los como porcentagens com “%” ao adicionar labels = scales::percent nos seus comandos de escala, como mostrado abaixo.\nEmbora uma alternativa seria converter os valores para caracteres, e, então, adicionar o “%” como caracter no final, esta abordagem irá causar problemas uma vez que seus dados não serão mais variáveis numéricas contínuas.\n\n# Proporções originais do eixo y\n#############################\nlinelist %&gt;%                                   # inicie com a linelist\n  group_by(hospital) %&gt;%                       # agrupe os dados por hospital\n  summarise(                                   # crie uma coluna de resumo dos dados\n    n = n(),                                     # total de casos (linhas) em um grupo\n    deaths = sum(outcome == \"Death\", na.rm=T),   # número de mortes nos grupos\n    prop_death = deaths/n) %&gt;%                   # proporção de mortes por grupo\n  ggplot(                                      # inicie o gráfico\n    mapping = aes(\n      x = hospital,\n      y = prop_death))+ \n  geom_col()+\n  theme_minimal()+\n  labs(title = \"Mostre as proporções originais do eixo y\")\n\n\n\n# Mostre as proporções do eixo y como porcentagens\n########################################\nlinelist %&gt;%         \n  group_by(hospital) %&gt;% \n  summarise(\n    n = n(),\n    deaths = sum(outcome == \"Death\", na.rm=T),\n    prop_death = deaths/n) %&gt;% \n  ggplot(\n    mapping = aes(\n      x = hospital,\n      y = prop_death))+\n  geom_col()+\n  theme_minimal()+\n  labs(title = \"Mostre o eixo y como porcentagem (%)\")+\n  scale_y_continuous(\n    labels = scales::percent                    # mostre as proporções como porcentagens\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEscala logarítmica\nPara transformar um eixo contínuo em uma escala logarítmica, adicione trans = \"log2\" no comando da escala. Para os propósitos deste exemplo, criamos um quadro de dados de regiões com seus respectivos preparedness_index e valores de casos acumulados.\n\nplot_data &lt;- data.frame(\n  region = c(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\"),\n  preparedness_index = c(8.8, 7.5, 3.4, 3.6, 2.1, 7.9, 7.0, 5.6, 1.0),\n  cases_cumulative = c(15, 45, 80, 20, 21, 7, 51, 30, 1442)\n)\n\nplot_data\n\n  region preparedness_index cases_cumulative\n1      A                8.8               15\n2      B                7.5               45\n3      C                3.4               80\n4      D                3.6               20\n5      E                2.1               21\n6      F                7.9                7\n7      G                7.0               51\n8      H                5.6               30\n9      I                1.0             1442\n\n\nOs casos acumulados para a região “I” são drasticamente maiores do que todas as outras regiões. Em circunstâncias como esta, você pode optar por mostrar o eixo y utilizando uma escala logarítmica, de forma que o leitor possa ver diferenças entre as regiões com menos casos acumulados.\n\n# Eixo y original\npreparedness_plot &lt;- ggplot(data = plot_data,  \n       mapping = aes(\n         x = preparedness_index,\n         y = cases_cumulative))+\n  geom_point(size = 2)+            # pontos para cada região\n  geom_text(\n    mapping = aes(label = region),\n    vjust = 1.5)+                  # adicione os rótulos em texto\n  theme_minimal()\n\npreparedness_plot                  # visualize o gráfico original\n\n\n# visualize o eixo y transformado\npreparedness_plot+                   # inicie com o gráfico salvo acima\n  scale_y_continuous(trans = \"log2\") # adicione a transformação para o eixo y\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEscalas em gradiente\nO preenchimento de escadas em gradiente de cores pode envolver detalhes adicionais. Normalmente, os ajustes padrões são bons, mas você pode querer ajustar os valores, limites de corte, etc.\nPara demonstrar como ajustar uma escala contínua de cor, nós iremos utilizar um conjunto de dados da página Rastreamento de contatos, que contém as idades dos casos e dos seus casos-fonte.\n\ncase_source_relationships &lt;- rio::import(here::here(\"data\", \"godata\", \"relationships_clean.rds\")) %&gt;% \n  select(source_age, target_age) \n\nAbaixo, produzimos um arquivo “raster” de um gráfico de densidade de calor. Não iremos discorrer sobre como criar o gráfico (veja o link no parágrafo acima), mas sim como ajustar a escala de cor. Veja mais sobre a função stat_density2d() do ggplot2 aqui. Observe como a escala fill é contínua.\n\ntrans_matrix &lt;- ggplot(\n    data = case_source_relationships,\n    mapping = aes(x = source_age, y = target_age))+\n  stat_density2d(\n    geom = \"raster\",\n    mapping = aes(fill = after_stat(density)),\n    contour = FALSE)+\n  theme_minimal()\n\nA seguir, mostramos algumas variações na escala de preenchimento:\n\ntrans_matrix\ntrans_matrix + scale_fill_viridis_c(option = \"plasma\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAgora veremos alguns exemplos de como ajustar os pontos de quebra da escala:\n\nscale_fill_gradient() aceita duas cores (alta/baixa)\nscale_fill_gradientn() aceita um vetor com qualquer quantidade de cores para values = (valores intermediários serão intercalados)\n\nUse scales::rescale() para ajustar como as cores serão posicionadas no decorrer do gradiente; ele reajusta o seu vetor de posições para ser entre 0 e 1.\n\n\ntrans_matrix + \n  scale_fill_gradient(     # escala de gradiente com 2 cores\n    low = \"aquamarine\",    # valor baixo\n    high = \"purple\",       # valor alto\n    na.value = \"grey\",     # valor para NA\n    name = \"Densidade\")+     # Título da legenda\n  labs(title = \"Especifique manualmente as cores para valores altos/baixos\")\n\n# 3+ cores na escala\ntrans_matrix + \n  scale_fill_gradientn(    # escala de 3-cores (baixo/médio/alto)\n    colors = c(\"blue\", \"yellow\",\"red\") # forneça cores no vetor\n  )+\n  labs(title = \"Escala de 3 cores\")\n\n# Uso de rescale() para ajustar a posição de cores na escala\ntrans_matrix + \n  scale_fill_gradientn(    # forneça qualquer número de cores\n    colors = c(\"blue\", \"yellow\",\"red\", \"black\"),\n    values = scales::rescale(c(0, 0.05, 0.07, 0.10, 0.15, 0.20, 0.3, 0.5)) # a posições para as cores é reescalado entre 0 e 1\n    )+\n  labs(title = \"Cores não são posicionadas igualmente\")\n\n# uso de limites para os valores de corte que recebem a cor de preenchimento\ntrans_matrix + \n  scale_fill_gradientn(    \n    colors = c(\"blue\", \"yellow\",\"red\"),\n    limits = c(0, 0.0002))+\n  labs(title = \"Restrinja os limites dos valores, resultando em um espaço cinza\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPaletas de cores\n\nColorbrewer e Viridis\nGeralmente, se você quiser paletas pré-definidas, pode usar as funções scale_xxx_brewer ou scale_xxx_viridis_y.\nAs funções ‘brewer’ colorem a partir das paletas do colorbrewer.org.\nAs funções ‘viridis’ colorem das paletas viridis (amigável para deficientes visuais!), que “fornece mapas de cores que são uniformes, tanto nas cores quanto no preto-e-branco. Elas também foram desenhadas para serem percebidas por usuários com formas comuns de cegueiras de cor.” (leia mais aqui e aqui). Defina se a paleta é discreta, contínua, ou contida ao especificar isto no final da função (ex.: discreta é scale_xxx_viridis_d).\nÉ recomendado que você teste as cores de seu gráfico neste simulador de daltonismo. Se você tiver um esquema de cores vermelho/verde, tente um esquema “quente-frio” (vermelho-azul) no lugar, como descrito aqui\nAqui é um exemplo da página Básico do ggplot, utilizando diferentes esquemas de cores.\n\nsymp_plot &lt;- linelist %&gt;%                                         # inicie com a linelist\n  select(c(case_id, fever, chills, cough, aches, vomit)) %&gt;%     # selecione as colunas\n  pivot_longer(                                                  # faça o pivoteamento longo\n    cols = -case_id,                                  \n    names_to = \"symptom_name\",\n    values_to = \"symptom_is_present\") %&gt;%\n  mutate(                                                        # substitua os campos em branco\n    symptom_is_present = replace_na(symptom_is_present, \"unknown\")) %&gt;% \n  ggplot(                                                        # inicie o ggplot!\n    mapping = aes(x = symptom_name, fill = symptom_is_present))+\n  geom_bar(position = \"fill\", col = \"black\") +                    \n  theme_classic() +\n  theme(legend.position = \"bottom\")+\n  labs(\n    x = \"Sintoma\",\n    y = \"Status do sintoma (proporção)\"\n  )\n\nsymp_plot  # visualize com as cores padrão\n\n#################################\n# visualize com cores especificadas manualmente\nsymp_plot +\n  scale_fill_manual(\n    values = c(\"yes\" = \"black\",         # defina as cores de forma explícita\n               \"no\" = \"white\",\n               \"unknown\" = \"grey\"),\n    breaks = c(\"yes\", \"no\", \"unknown\"), # ordene os fatores corretamente\n    name = \"\"                           # configure a legenda para não ter título\n\n  ) \n\n#################################\n# visualize com as cores discretas do pacote viridis\nsymp_plot +\n  scale_fill_viridis_d(\n    breaks = c(\"yes\", \"no\", \"unknown\"),\n    name = \"\"\n  )",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Dicas do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.pt.html#altere-a-ordem-das-variáveis-discretas",
    "href": "new_pages/ggplot_tips.pt.html#altere-a-ordem-das-variáveis-discretas",
    "title": "31  Dicas do ggplot",
    "section": "31.3 Altere a ordem das variáveis discretas",
    "text": "31.3 Altere a ordem das variáveis discretas\nGeralmente, alterar a ordem em que as variáveis discretas aparecem no gráfico é difícil de entender para novatos no ggplot2. Entretanto, ao compreender o mecanismo que o ggplot2 usa para trabalhar com variáveis discretas, fica mais fácil de entender como alterar. No geral, se uma variável discreta é utilizada, ela é automaticamente convertida para a classe factor- que, por padrão, ordena os factors por ordem alfabética. Para trabalhar com isso, você simplesmente precisa reordenar os níveis de factor para refletirem na ordem que você gostaria que eles aparecessem no gráfico. Para informações mais detalhadas sobre como reordenar objetos da classe factor, veja a seção sobre factor neste guia.\nNós podemos utilizar um exemplo comum com grupos de idade - por padrão, o grupo de 5-9 anos será colocado no meio dos grupos ordenados (considerando a ordem alfanumérica), mas nós podemos movê-lo para atrás do grupo de 0-4 anos do gráfico ao renivelar os factors.\n\nggplot(\n  data = linelist %&gt;% drop_na(age_cat5),                         # remova as linhas em que age_cat5 está ausente\n  mapping = aes(x = fct_relevel(age_cat5, \"5-9\", after = 1))) +  # renivele os factors\n\n  geom_bar() +\n  \n  labs(x = \"Grupo de idade\", y = \"Número de hospitalizações\",\n       title = \"Quantidade total de hospitalizações por grupo de idade\") +\n  \n  theme_minimal()\n\n\n\n\n\n\n\n\n\n31.3.0.1 Pacote ggthemr\nAdicionalmente, considere utilizar o pacote ggthemr, que pode ser baixado do Github utilizando essas instruções. Ele oferece paletas de cores muito agradáveis estéticamente, mas tenha ciência de que estas geralmente possuem um número máximo de valores, o que é um fator limitante caso você queira mais de 7 ou 8 cores.",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Dicas do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.pt.html#linhas-de-contorno",
    "href": "new_pages/ggplot_tips.pt.html#linhas-de-contorno",
    "title": "31  Dicas do ggplot",
    "section": "31.4 Linhas de contorno",
    "text": "31.4 Linhas de contorno\nGráficos de contorno são úteis quando você tem muitos pontos que podem se sobrepor (“overplotting”). Iremos utilizar os dados sobre as fontes dos casos utilizados acima para fazer um gráfico, mas de forma mais simples utilizando stat_density2d() e stat_density2d_filled() para produzir níveis discretos de contorno - como um mapa topográfico. Veja mais sobre as estatísticas utilizadas aqui.\n\ncase_source_relationships %&gt;% \n  ggplot(aes(x = source_age, y = target_age))+\n  stat_density2d()+\n  geom_point()+\n  theme_minimal()+\n  labs(title = \"stat_density2d() + geom_point()\")\n\n\ncase_source_relationships %&gt;% \n  ggplot(aes(x = source_age, y = target_age))+\n  stat_density2d_filled()+\n  theme_minimal()+\n  labs(title = \"stat_density2d_filled()\")",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Dicas do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.pt.html#distribuições-marginais",
    "href": "new_pages/ggplot_tips.pt.html#distribuições-marginais",
    "title": "31  Dicas do ggplot",
    "section": "31.5 Distribuições marginais",
    "text": "31.5 Distribuições marginais\nPara mostrar as distribuições nas extremidades de um gráfico de dispersão criado com geom_point(), você pode utilizar o pacote ggExtra e sua função ggMarginal(). Salve seu ggplot original como um objeto, e então o utilize com ggMarginal(), como mostrado abaixo. Aqui estão os argumentos chave:\n\nVocê precisa especificar type = como “histogram”, “density” “boxplot”, “violin”, ou “densigram”.\n\nPor padrão, gráficos de dispersão marginal irão aparecer para ambos eixos. Você pode ajustar margins = para “x” ou “y” se quiser apenas um deles.\nOutros argumentos opcionais incluem fill = (cor da barra), color = (cor da linha), size = (tamanho do gráfico relativo ao tamanho da margem, de forma que números maiores criam um gráfico de dispersão marginal menor).\n\nVocê pode fornecer outros argumentos específicos para os eixos em xparams = e yparams =. Por exemplo, para obter diferentes tamanhos dos containers do histograma, como mostrado abaixo.\n\nOs gráficos de dispersão marginal podem refletir os grupos (colunas que foram atribuídas a color = no seu mapa estético do ggplot()). Se este for o caso, ajuste os argumentos groupColour = ou groupFill =, do ggMarginal(), para TRUE, como mostrado abaixo.\nLeia mais neste resumo, na galeria de gráficos em R ou a documentação da função no R, com ?ggMarginal.\n\n# Instale/carregue o pacote ggExtra\npacman::p_load(ggExtra)\n\n# Gráfico básico de distribuição de peso e idade\nscatter_plot &lt;- ggplot(data = linelist)+\n  geom_point(mapping = aes(y = wt_kg, x = age)) +\n  labs(title = \"Gráfico de distribuição de peso e idade\")\n\nPara adicionar histogramas marginais, utilize type = \"histogram\". Opcionalmente, você pode ajustar groupFill = TRUE para obter histogramas empilhados.\n\n# com histogramas\nggMarginal(\n  scatter_plot,                     # adicione histogramas marginais\n  type = \"histogram\",               # especifique histogram\n  fill = \"lightblue\",               # preenchimento das barras\n  xparams = list(binwidth = 10),    # outros parâmetros para a dispersão marginal do eixo x\n  yparams = list(binwidth = 5))     # outros parâmetros para a dispersão marginal do eixo y\n\n\n\n\n\n\n\n\nGráfico de densidade marginal com valores agrupados/coloridos:\n\n# Gráfico de dispersão, colorido de acordo com o desfecho clínico (outcome) do paciente\n# Coluna de desfecho é atribuída como cor no ggplot. groupFill no ggMarginal ajustado para TRUE\nscatter_plot_color &lt;- ggplot(data = linelist %&gt;% drop_na(gender))+\n  geom_point(mapping = aes(y = wt_kg, x = age, color = gender)) +\n  labs(title = \"Gráfico de dispersão por peso e idade\")+\n  theme(legend.position = \"bottom\")\n\nggMarginal(scatter_plot_color, type = \"density\", groupFill = TRUE)\n\n\n\n\n\n\n\n\nColoque o argumento size = para ajustar o tamanho relativo do gráfico de dispersão marginal. Números menores criam gráficos de dispersão marginal maiores. Você também ajusta color =. A seguir, um diagrama de caixa (boxplot) marginal, com a demonstração do argumento margins =, de forma que apareça apenas em um eixo:\n\n# com boxplot \nggMarginal(\n  scatter_plot,\n  margins = \"x\",      # mostre apenas o gráfico de dispersão marginal do eixo x\n  type = \"boxplot\")",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Dicas do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.pt.html#rotulagem-inteligente",
    "href": "new_pages/ggplot_tips.pt.html#rotulagem-inteligente",
    "title": "31  Dicas do ggplot",
    "section": "31.6 Rotulagem inteligente",
    "text": "31.6 Rotulagem inteligente\nNo ggplot2, também é possível adicionar texto aos gráficos. Entretanto, a limitação disto é a sobreposição dos rótulos de texto com os dados no gráfico, ficando com aparência confusa e difícil de interpretar. Não existe forma ideal de lidar com issso no pacote básico, mas existe um complemento do ggplot2, chamado de ggrepel, que lida com isso de forma bem simples!\nO pacote ggrepel fornece duas novas funções, geom_label_repel() e geom_text_repel(), que substituem geom_label() e geom_text(). Simplesmente utilize estas funções, em vez das originais do ggplot2, para produzir rótulos claros e bonitos. Dentro da função, mapeie a estética aes() como sempre, mas inclua o argumento label =, onde você fornece a coluna com os valores que quer mostrar (ex.: id do paciente, ou nome, etc). Você pode criar mais rótulos complexos ao combinar colunas e linhas novas (\\n) dentro de str_glue(), como mostrado abaixo.\nAlgumas dicas:\n\nUse min.segment.length = 0 para sempre desenhar segmentos de linhas, ou min.segment.length = Inf para nunca desenhá-los\nUse size = fora de aes() para ajustar o tamanho do texto\nUse force = para mudar o grau de repulsão entre os rótulos e seus respectivos pontos (padrão é 1)\nInclua fill = dentro de aes() para ter os rótulos coloridos de acordo com os valores\n\nA letra “a” pode aparecer na legenda - adicione guides(fill = guide_legend(override.aes = aes(color = NA)))+ para removê-la\n\n\nVeja esse detalhado tutorial para mais detalhes.\n\npacman::p_load(ggrepel)\n\nlinelist %&gt;%                                               # comece com a linelist\n  group_by(hospital) %&gt;%                                   # agrupe por hospital\n  summarise(                                               # crie um novo conjunto de dados com o resumo dos valores por hospital\n    n_cases = n(),                                           # número de casos por hospital\n    delay_mean = round(mean(days_onset_hosp, na.rm=T),1),    # demora média por hospital\n  ) %&gt;% \n  ggplot(mapping = aes(x = n_cases, y = delay_mean))+      # envie o quadro de dados para o ggplot\n  geom_point(size = 2)+                                    # adicione os pontos\n  geom_label_repel(                                        # adicione os rótulos dos pontos\n    mapping = aes(\n      label = stringr::str_glue(\n        \"{hospital}\\n{n_cases} casos, {delay_mean} dias\")  # como o rótulo é mostrado\n      ), \n    size = 3,                                              # tamanho do texto nos rótulos\n    min.segment.length = 0)+                               # mostre todos os segmentos de linhas\n  labs(                                                    # adicione os rótulos dos eixos\n    title = \"Tempo médio de espera para admissão, por hospital\",\n    x = \"Número de casos\",\n    y = \"Tempo médio de espera (dias)\")\n\n\n\n\n\n\n\n\nVocê pode rotular apenas um subconjunto dos dados - ao utilizar a sintaxe padrão do ggplot() para fornecer diferentes data = para cada camada geom do gráfico. Abaixo, todos os casos são colocados no gráfico, mas apenas alguns são rotulados.\n\nggplot()+\n  # Todos os pontos em cinza\n  geom_point(\n    data = linelist,                                   # todos os dados fornecidos para essa camada\n    mapping = aes(x = ht_cm, y = wt_kg),\n    color = \"grey\",\n    alpha = 0.5)+                                              # cinza e semi-transparente\n  \n  # Poucos pontos em preto\n  geom_point(\n    data = linelist %&gt;% filter(days_onset_hosp &gt; 15),  # dados filtrados nesta camada\n    mapping = aes(x = ht_cm, y = wt_kg),\n    alpha = 1)+                                                # padrão preto e não transparente\n  \n  # rótulos de pontos para alguns pontos\n  geom_label_repel(\n    data = linelist %&gt;% filter(days_onset_hosp &gt; 15),  # filtre os dados para os rótulos\n    mapping = aes(\n      x = ht_cm,\n      y = wt_kg,\n      fill = outcome,                                          # cor dos rótulos por desfecho\n      label = stringr::str_glue(\"Demora: {days_onset_hosp}d\")), # rótulo criado com str_glue()\n    min.segment.length = 0) +                                  # mostre os segmentos de linha para todos\n  \n  # remova a letra \"a\" de dentro das caixas de legenda\n  guides(fill = guide_legend(override.aes = aes(color = NA)))+\n  \n  # rótulos dos eixos\n  labs(\n    title = \"Casos com longa demora até admissão\",\n    y = \"peso (kg)\",\n    x = \"altura (cm)\")",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Dicas do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.pt.html#eixos-de-tempo",
    "href": "new_pages/ggplot_tips.pt.html#eixos-de-tempo",
    "title": "31  Dicas do ggplot",
    "section": "31.7 Eixos de tempo",
    "text": "31.7 Eixos de tempo\nTrabalhar com eixos de tempo no ggplot pode ser cansativo, mas é mais fácil com algumas funções chave. Lembre que, ao trabalhar com tempo ou datas, você deve garantir que as variáveis corretas estejam formatadas como das classes date ou datetime - veja a página Trabalhando com datas para mais informações, ou a página Curvas epidêmicas, na seção sobre o ggplot, para exemplos.\nO conjunto de funções mais útil para trabalhar com datas no ggplot2 são as funções de escala (scale_x_date(), scale_x_datetime(), e os seus cognatos do eixo y). Estas funções permitem definir a frequência dos rótulos dos eixos, e como formatar esses rótulos. Para descobrir como formatar datas, veja a seção working with dates novamente! Você pode utilizar os argumentos date_breaks e date_labels para especificar como as datas devem aparecer:\n\ndate_breaks permite especificar a frequência das quebras dos eixos - você pode utilizar uma string (ex.: \"3 months\", ou “2 days\")\ndate_labels permite definir o formato das datas mostradas. Você pode utilizar uma string de formatação de datas (ex.: \"%b-%d-%Y\"):\n\n\n# crie uma epicurva por data de início dos sintomas, quando disponível\nggplot(linelist, aes(x = date_onset)) +\n  geom_histogram(binwidth = 7) +\n  scale_x_date(\n    # 1 quebra a cada mês\n    date_breaks = \"1 months\",\n    # rótulos devem mostrar o mês, então a data\n    date_labels = \"%b %d\"\n  ) +\n  theme_classic()",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Dicas do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.pt.html#destacando",
    "href": "new_pages/ggplot_tips.pt.html#destacando",
    "title": "31  Dicas do ggplot",
    "section": "31.8 Destacando",
    "text": "31.8 Destacando\nDestacar elementos específicos em um gráfico é uma forma útil de chamar a atenção para algo nos dados, enquanto também fornece informação na distribuição dos dados no conjunto inteiro. Embora isto não seja feito de forma fácil no ggplot2 básico, existe um pacote externo que pode ajudar nisso, conhecido como gghighlight. Ele é fácil de usar dentro da sintaxe do ggplot.\nO pacote gghighlight utiliza a função gghighlight() para realizar os destaques. Para usar esta função, forneça um argumento lógico - o que pode ter muitos desfechos, mas iremos mostrar um exemplo da distribuição de idade dos casos em nosso linelist, ao destacar pelo desfecho clínico.\n\n# carregue o pacote gghighlight\nlibrary(gghighlight)\n\n# substitua os valores NA por \"unknown\" na variável de desfecho\nlinelist &lt;- linelist %&gt;%\n  mutate(outcome = replace_na(outcome, \"Unknown\"))\n\n# produza um histograma de todos os casos de acordo com a idade\nggplot(\n  data = linelist,\n  mapping = aes(x = age_years, fill = outcome)) +\n  geom_histogram() + \n  gghighlight::gghighlight(outcome == \"Death\")     # destaque as situações onde o desfecho do paciente foi óbito.\n\n\n\n\n\n\n\n\nIsto também funciona bem com as funções de facetas - ele permite a produção de gráficos facetados com os dados no fundo em destaque, mas que não se aplica à faceta! Abaixo, nós contamos os casos por semana e criamos uma curva epidêmica por hospital (color = e facet_wrap() ajustado para a coluna hospital).\n\n# produz um histograma de todos os casos por idade\nlinelist %&gt;% \n  count(week = lubridate::floor_date(date_hospitalisation, \"week\"),\n        hospital) %&gt;% \n  ggplot()+\n  geom_line(aes(x = week, y = n, color = hospital))+\n  theme_minimal()+\n  gghighlight::gghighlight() +                      # destaque as situações em que o paciente morreu\n  facet_wrap(~hospital)                              # crie facetas de acordo com o desfecho",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Dicas do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.pt.html#criando-gráficos-de-múltiplos-conjuntos-de-dados",
    "href": "new_pages/ggplot_tips.pt.html#criando-gráficos-de-múltiplos-conjuntos-de-dados",
    "title": "31  Dicas do ggplot",
    "section": "31.9 Criando gráficos de múltiplos conjuntos de dados",
    "text": "31.9 Criando gráficos de múltiplos conjuntos de dados\nObserve que alinhar adequadamente os eixos para criar gráficos de conjuntos de dados múltilos no mesmo gráfico pode ser difícil. Considere uma das seguintes estratégias:\n\nUna os dados antes de criar o gráfico, e então converta para o formato “longo” com uma coluna associando os dados\nUse cowplot ou um pacote similar para combinar dois gráficos (veja abaixo)",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Dicas do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.pt.html#combine-os-gráficos",
    "href": "new_pages/ggplot_tips.pt.html#combine-os-gráficos",
    "title": "31  Dicas do ggplot",
    "section": "31.10 Combine os gráficos",
    "text": "31.10 Combine os gráficos\nDois pacotes bem úteis para combinar gráficos são o cowplot e o patchwork. Nesta página, iremos focar no cowplot, e, ocasionalmente, usaremos o patchwork.\nAqui está uma introdução ao cowplot. Você pode ler a documentação mais extensa para cada função aqui. Nós iremos mostrar alguns dos casos de uso e funções mais comuns a seguir.\nO pacote cowplot funciona em tandem com ggplot2 - essencialmente, você o utiliza para organizar e combinar ggplots e suas legendas em figuras compostas. Este pacote também aceita gráficos do R base.\n\npacman::p_load(\n  tidyverse,      # manipulação e visualização de dados\n  cowplot,        # combine os gráficos\n  patchwork       # combine os gráficos\n)\n\nEnquanto facetear (descrito na página Básico do ggplot) é uma abordagem conveniente para criar gráficos, as vezes não é possível obter os resultados desejados com essa abordagem. Aqui, você pode escolher combinar os gráficos ao uni-los em um gráfico maior. Existem três pacotes bem conhecidos, que são ótimos para isso - cowplot, gridExtra, e patchwork. Entretanto, estes pacotes fazem basicamente a mesma coisa, de forma que iremos focar no cowplot nesta seção.\n\nplot_grid()\nO pacote cowplot tem uma grande variedade de funções, mas o uso mais fácil dele é com plot_grid(). Isto é, efetivamente, uma forma de organizar gráficos pré-definidos em forma de uma rede. Nós podemos aplicar em outro exemplo com os dados de malária - aqui nós fizemos um gráfico com o total de casos por distrito, e também mostramos a curva epidêmica pelo tempo.\n\nmalaria_data &lt;- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\")) \n\n# gráfico do total de casos por distrito\np1 &lt;- ggplot(malaria_data, aes(x = District, y = malaria_tot)) +\n  geom_bar(stat = \"identity\") +\n  labs(\n    x = \"Distrito\",\n    y = \"Número total de casos\",\n    title = \"Quantidade total de casos de malária por distrito\"\n  ) +\n  theme_minimal()\n\n# curva epidêmica pelo tempo\np2 &lt;- ggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +\n  geom_col(width = 1) +\n  labs(\n    x = \"Data de envio dos dados\",\n    y =  \"número de casos\"\n  ) +\n  theme_minimal()\n\ncowplot::plot_grid(p1, p2,\n                  # 1 coluna e duas linhas - empilhadas uma sobre a outra\n                   ncol = 1,\n                   nrow = 2,\n                   # gráfico de cima é 2/3 da altura do segundo\n                   rel_heights = c(2, 3))\n\n\n\n\n\n\n\n\n\n\nCombine as legendas\nCaso os seus gráficos tenham a mesma legenda, combina-las é relativamente fácil. Simplesmente use a abordagem acima do cowplot para combinar os gráficos, mas remova a legenda de um deles (de-duplique).\nCaso seus gráficos tenham legendas diferentes, você precisa usar uma abordagem alternativa:\n\nCrie e salve seus gráficos sem as legendas utilizando theme(legend.position = \"none\")\n\nExtraia as legendas de cada gráfico utilizando get_legend(), como mostrado abaixo - mas extraia as legendas dos gráficos modificados para, na verdade, mostrar a legenda\n\nCombine as legendas em um painel de legendas\nCombine os gráficos e o painel de legendas\n\nPara fins de demonstração, primeiro mostramos os dois gráficos separados, e, então organizados em uma grade com suas próprias legendas (feio e uso ineficiente de espaço):\n\np1 &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %&gt;% \n  count(hospital, outcome) %&gt;% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+\n  scale_fill_brewer(type = \"qual\", palette = 4, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  labs(title = \"Casos por desfecho clínico\")\n\n\np2 &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %&gt;% \n  count(hospital, age_cat) %&gt;% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+\n  scale_fill_brewer(type = \"qual\", palette = 1, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  theme(axis.text.y = element_blank())+\n  labs(title = \"Casos por idade\")\n\nAqui esta como os dois gráficos ficam quando combinados usando plot_grid(), mas sem combinar as suas legendas:\n\ncowplot::plot_grid(p1, p2, rel_widths = c(0.3))\n\n\n\n\n\n\n\n\nE agora nós mostramos como combinar as legendas. Essencialmente, o que fazemos é criar cada gráfico sem sua legenda (theme(legend.position = \"none\"), e então definimos cada legenda dos gráficos separadamente, usando a função get_legend() do cowplot. Quando extraimos a legenda do gráfico salvo, precisamos adicionar + a legenda de volta, incluindo o argumento de posição (“right”) e ajustes menores para alinhar as legendas e seus títulos. Então, combinamos as legendas verticalmente, e os dois gráficos com a nova legenda combinada. Voilà!\n\n# Crie o gráfico 1 sem a legenda\np1 &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %&gt;% \n  count(hospital, outcome) %&gt;% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+\n  scale_fill_brewer(type = \"qual\", palette = 4, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  theme(legend.position = \"none\")+\n  labs(title = \"Casos por desfecho clínico\")\n\n\n# Crie o gráfico 2 sem a legenda\np2 &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %&gt;% \n  count(hospital, age_cat) %&gt;% \n  ggplot()+\n  geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+\n  scale_fill_brewer(type = \"qual\", palette = 1, na.value = \"grey\")+\n  coord_flip()+\n  theme_minimal()+\n  theme(\n    legend.position = \"none\",\n    axis.text.y = element_blank(),\n    axis.title.y = element_blank()\n  )+\n  labs(title = \"Casos por idade\")\n\n\n# extraia a legenda do gráfico 1 (de gráfico1 + legenda)\nleg_p1 &lt;- cowplot::get_legend(p1 +\n                                theme(legend.position = \"right\",        # extraia a legenda vertical\n                                      legend.justification = c(0,0.5))+ # de forma que as legendas alinhem\n                                labs(fill = \"Desfecho\"))                 # título da legenda\n# extraia a legenda do gráfico 2 (de gráfico 2 + legend)\nleg_p2 &lt;- cowplot::get_legend(p2 + \n                                theme(legend.position = \"right\",         # extraia a legenda vertical\n                                      legend.justification = c(0,0.5))+  # de forma que as legendas alinhem\n                                labs(fill = \"Categoria de idade\"))             # título da legenda\n\n# crie um gráfico em branco para alinhar a legenda\n#blank_p &lt;- patchwork::plot_spacer() + theme_void()\n\n# crie um painel de legendas, pode ser um sobre o outro (ou utilize o espaçados comentado acima)\nlegends &lt;- cowplot::plot_grid(leg_p1, leg_p2, nrow = 2, rel_heights = c(.3, .7))\n\n# combine os dois gráficos e o painel de legendas criado\ncombined &lt;- cowplot::plot_grid(p1, p2, legends, ncol = 3, rel_widths = c(.4, .4, .2))\n\ncombined  # visualize o gráfico\n\n\n\n\n\n\n\n\nEsta solução foi apresentada neste post com pequenos ajustes para alinhar as legendas deste post.\nDICA: Nota interessante - o “cow” no cowplot vem do nome do criador do pacote - Claus O. Wilke.\n\n\nInserção de gráficos\nVocê pode inserir um gráfico em outros utilizando cowplot. Aqui estão pontos para estar ciente:\n\nDefina o gráfico principal com theme_half_open(), do cowplot; é recomendado colocar a legenda no topo ou na base do gráfico\nDefina o gráfico a ser inserido. O melhor é usar um gráfico que não precise de legenda. Você pode remover os elementos de tema deste gráfico com element_blank(), como mostrado abaixo.\nOs combine ao aplicar a função ggdraw() no gráfico principal, e então adicionando draw_plot() no gráfico a ser inserido, e especificando as coordenadas (x e y da extremidade baixa a esquerda), altura e comprimento proporcionais ao tamanho do gráfico principal.\n\n\n# Defina o gráfico principal\nmain_plot &lt;- ggplot(data = linelist)+\n  geom_histogram(aes(x = date_onset, fill = hospital))+\n  scale_fill_brewer(type = \"qual\", palette = 1, na.value = \"grey\")+ \n  theme_half_open()+\n  theme(legend.position = \"bottom\")+\n  labs(title = \"Curva epidêmica e desfechos clínicos por hospital\")\n\n\n# Crie o gráfico a ser inserido\ninset_plot &lt;- linelist %&gt;% \n  mutate(hospital = recode(hospital, \"St. Mark's Maternity Hospital (SMMH)\" = \"St. Marks\")) %&gt;% \n  count(hospital, outcome) %&gt;% \n  ggplot()+\n    geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+\n    scale_fill_brewer(type = \"qual\", palette = 4, na.value = \"grey\")+\n    coord_flip()+\n    theme_minimal()+\n    theme(legend.position = \"none\",\n          axis.title.y = element_blank())+\n    labs(title = \"Casos por desfecho\") \n\n\n# Combine o gráfico principal com o gráfico a ser inserido\ncowplot::ggdraw(main_plot)+\n     draw_plot(inset_plot,\n               x = .6, y = .55,    #x = .07, y = .65,\n               width = .4, height = .4)\n\n\n\n\n\n\n\n\nEsta técnica é melhor explicada nestes dois resumos:\nWilke lab\nDocumentação do draw_plot()",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Dicas do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.pt.html#eixos-duplos",
    "href": "new_pages/ggplot_tips.pt.html#eixos-duplos",
    "title": "31  Dicas do ggplot",
    "section": "31.11 Eixos duplos",
    "text": "31.11 Eixos duplos\nUm segundo eixo y é, frequentemente, solicitado em um gráfico ggplot2. Embora existam fortes debates sobre a validade destes gráficos na comunidade de visualização de dados, em que geralmente não são recomendados, o seu chefe pode requisitá-los. Abaixo, apresentamos um método para obtê-los: utilizando o pacote cowplot para combinar dois gráficos separados.\nEsta abordagem envolve criar dois gráficos distintos - um com um eixo y na esquerda, e outro com o eixo y na direita. Ambos utilizarão um específico theme_cowplot() e terão o mesmo eixo x. Então, em um terceiro comando, os dois gráficos serão alinhados e sobrepostos. As funcionalidades do cowplot, das quais esta é apenas uma delas, são descritas em detalhes neste site.\nPara demonstrar esta técnica, iremos sobrepor uma curva epidêmica com uma linha de porcentagem semanal de pacientes que morreram. Nós usamos este exemplo pois o alinhamento de datas no eixo x é mais complexo do que, digamos, alinhar um gráfico de barras com outro gráfico. Algumas coisas a serem observadas:\n\nA epicurva e a linha são agregadas em semanas antes de criarmos os gráficos, e os date_breaks e date_labels são idênticos - nós fizemos isto de forma que os eixos x dos dois gráficos é o mesmo quando sobrepostos.\nO eixo y é movido para o lado direito, no gráfico 2, com o argumento position = de scale_y_continuous().\n\nAmbos gráficos fazem uso do theme_cowplot()\n\nNote que existe outro exemplo dessa técnica na página Curvas epidêmicas - a sobreposição da incidência acumulada acima da epicurva.\nCrie o primeiro gráfico\nEste é, essencialmente, uma epicurva. Nós utilizamos geom_area() apenas para demonstrar o seu uso (área abaixo de uma linha, por padrão)\n\npacman::p_load(cowplot)            # carregue/instale o cowplot\n\np1 &lt;- linelist %&gt;%                 # salve o gráfico como um objeto\n     count(\n       epiweek = lubridate::floor_date(date_onset, \"week\")) %&gt;% \n     ggplot()+\n          geom_area(aes(x = epiweek, y = n), fill = \"grey\")+\n          scale_x_date(\n               date_breaks = \"month\",\n               date_labels = \"%b\")+\n     theme_cowplot()+\n     labs(\n       y = \"Casos semanais\"\n     )\n\np1                                      # veja o gráfico \n\n\n\n\n\n\n\n\nCrie o segundo gráfico\nCrie o segundo gráfico mostrando uma linha com a porcentagem semanal de óbitos.\n\np2 &lt;- linelist %&gt;%         # salve seu gráfico como um objeto\n     group_by(\n       epiweek = lubridate::floor_date(date_onset, \"week\")) %&gt;% \n     summarise(\n       n = n(),\n       pct_death = 100*sum(outcome == \"Death\", na.rm=T) / n) %&gt;% \n     ggplot(aes(x = epiweek, y = pct_death))+\n          geom_line()+\n          scale_x_date(\n               date_breaks = \"month\",\n               date_labels = \"%b\")+\n          scale_y_continuous(\n               position = \"right\")+\n          theme_cowplot()+\n          labs(\n            x = \"Semana epidemiológica de aparecimento dos sintomas\",\n            y = \"Percentual semanal de mortes\",\n            title = \"Incidência semanal de casos e percentual de mortes\"\n          )\n\np2     # veja o gráfico\n\n\n\n\n\n\n\n\nAgora alinhamos o gráfico usando a função align_plots(), especificando os alinhamentos horizontal e vertical (“hv”, poderia também ser “h”, “v”, “none”). Também especificamos o alinhamento de todos os eixos (“top”, “bottom”, “left”, e “right”) com “tblr”. O resultado é da classe list (2 elementos).\nEntão, desenhamos os dois gráficos juntos utilizando ggdraw() (do cowplot) e referenciando as outras duas partes do objeto aligned_plots.\n\naligned_plots &lt;- cowplot::align_plots(p1, p2, align=\"hv\", axis=\"tblr\")         # alinhe os dois gráficos e os salve como uma lista\naligned_plotted &lt;- ggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])  # sobreponha os gráficos e salve o gráfico visualizado\naligned_plotted                                                                # visualize os gráficos sobrepostos",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Dicas do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.pt.html#pacotes-para-te-ajudar",
    "href": "new_pages/ggplot_tips.pt.html#pacotes-para-te-ajudar",
    "title": "31  Dicas do ggplot",
    "section": "31.12 Pacotes para te ajudar",
    "text": "31.12 Pacotes para te ajudar\nExistem ótimos pacotes do R desenhados especificamente para ajudar a navegar no ggplot2:\n\nAponte-e-clique no ggplot2 com equisse\n“Este complemento permite que você explore seus dados de forma interativa, ao visualiza-los com o pacote ggplot2. Ele permite desenhar gráficos de barras, curvas, gráficos de dispersão, hsitogramas, boxplots e objetos sf, e, então, exportar o gráfico e gerar o código de geração do gráfico.”\nInstale e então o execute o pacote por meio do menu do RStudio ou com esquisse::esquisser().\nVeja a página do Github\nDocumentação",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Dicas do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.pt.html#dicas-diversas",
    "href": "new_pages/ggplot_tips.pt.html#dicas-diversas",
    "title": "31  Dicas do ggplot",
    "section": "31.13 Dicas diversas",
    "text": "31.13 Dicas diversas\n\nExibição dos números\nVocê pode desabilitar a notação científica ao executar este comando antes de criar o gráfico.\n\noptions(scipen=999)\n\nOu aplicar number_format(), do pacote scales, para um valor ou coluna específica, como mostrado abaixo.\nUse funções do pacote scales para facilmente ajustar como os números são mostrados. Isto pode ser aplicado para colunas em seus dados, mas aqui são mostrados em números individuais para fins de exemplo.\n\nscales::number(6.2e5)\n\n[1] \"620 000\"\n\nscales::number(1506800.62,  accuracy = 0.1,)\n\n[1] \"1 506 800.6\"\n\nscales::comma(1506800.62, accuracy = 0.01)\n\n[1] \"1,506,800.62\"\n\nscales::comma(1506800.62, accuracy = 0.01,  big.mark = \".\" , decimal.mark = \",\")\n\n[1] \"1.506.800,62\"\n\nscales::percent(0.1)\n\n[1] \"10%\"\n\nscales::dollar(56)\n\n[1] \"$56\"\n\nscales::scientific(100000)\n\n[1] \"1e+05\"",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Dicas do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/ggplot_tips.pt.html#recursos-extras",
    "href": "new_pages/ggplot_tips.pt.html#recursos-extras",
    "title": "31  Dicas do ggplot",
    "section": "31.14 Recursos extras",
    "text": "31.14 Recursos extras\nPara inspiração, galeria de gráficos do ggplot\nRecomendação de formas de apresentação de dados Centro Europeu de Prevenção e Controle de Doenças Recomendações para apresentação de dados de vigilância\nFacetas e rotuladores Utilizando rotuladores para feixes de facetas Rotuladores\nAjustando a ordem com factors fct_reorder\nfct_inorder\nComo reordenar um boxplot\nReordene uma variável no ggplot2\nR para Ciência dos Dados - Factors\nLegendas\nAjuste a ordem da legenda\nTítulos Alinhamento do título\nRótulos\nggrepel\nColinhas Lindos gráficos com ggplot2",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Dicas do ggplot</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.pt.html",
    "href": "new_pages/epicurves.pt.html",
    "title": "32  Curvas epidêmicas",
    "section": "",
    "text": "32.1 Preparação",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Curvas epidêmicas</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.pt.html#preparação",
    "href": "new_pages/epicurves.pt.html#preparação",
    "title": "32  Curvas epidêmicas",
    "section": "",
    "text": "Carregue os pacotes necessários\nO código abaixo realiza o carregamento dos pacotes necessários para a análise dos dados. Neste manual, enfatizamos o uso da função p_load(), do pacman, que instala os pacotes, caso não estejam instalados, e os carrega no R para utilização. Também é possível carregar pacotes instalados utilizando a função library(), do R base. Para mais informações sobre os pacotes do R, veja a página Introdução ao R.\n\npacman::p_load(\n  rio,          # importar/exportar arquivos\n  here,         # caminhos de arquivos relativos \n  lubridate,    # trabalhando com datas/semanas epidemiológicas\n  aweek,        # pacote alternativo para trabalhar com datas/semanas epidemiológicas\n  incidence2,   # epicurvas de dados em uma linelist\n  i2extras,     # suplemento para o pacote incidence2\n  stringr,      # procure e manipule strings de caracteres\n  forcats,      # trabalhando com fators\n  RColorBrewer, # paleta de cores do colorbrewer2.org\n  tidyverse     # gerenciamento de dados + gráficos no ggplot2\n) \n\n\n\nImporte os dados\nDois exemplos de conjuntos de dados são utilizados nesta seção:\n\nLista de linhas (linelist) com casos individuais de uma simulação de epidemia\nContagens agregadas por hospital da mesma epidemia simulada\n\nOs conjuntos de dados são importados utilizando a função import() do pacote rio. Veja a página sobre Importar e exportar para conhecer as diferentes formas de importar dados.\nLista de linhas de casos\nNós importamos o conjunto de dados de casos de uma simulação de epidemia de Ebola. Se você quiser baixar os dados para acompanhar etapa-por-etapa, veja instruções na página sobre Download do manual e dados. Aqui, nós assumimos que o arquivo está no diretório de trabalho. Logo, nenhuma sub-pasta é especificada no endereço do arquivo.\n\nlinelist &lt;- import(\"linelist_cleaned.xlsx\")\n\nAs primeiras 50 linhas são mostradas abaixo.\n\n\n\n\n\n\nCasos agregados por hospital\nPara atingir os propósitos deste manual, o conjunto de dados de contagens semanais de casos agregados por hospital é criado a partir da linelist, com o seguinte código.\n\n# cria os dados de contagem no R\ncount_data &lt;- linelist %&gt;% \n  group_by(hospital, date_hospitalisation) %&gt;% \n  summarize(n_cases = dplyr::n()) %&gt;% \n  filter(date_hospitalisation &gt; as.Date(\"2013-06-01\")) %&gt;% \n  ungroup()\n\nAs primeiras 50 linhas são mostradas abaixo:\n\n\n\n\n\n\n\n\nAjuste os parâmetros\nPara produzir um relatório, você pode querer ajustar parâmetros modificáveis, como a data para a qual os dados são atuais (a “data dos dados”). Você pode, então, referenciar o objeto data_date em seu código ao aplicar filtros ou em legendas dinâmicas.\n\n## ajuste a data do relatório para o relatório\n## nota: pode ser ajustada para Sys.Date() para a data atual\ndata_date &lt;- as.Date(\"2015-05-15\")\n\n\n\nVerifique as datas\nPerceba que cada coluna de datas relevantes é da classe Date e tem um intervalo apropriado de valores. Você pode fazer isso simplesmente utilizando hist(), para histograma, ou range() com na.rm=TRUE, ou com o ggplot(), como mostrado abaixo.\n\n# cheque o intervalo das datas de início dos sintomas\nggplot(data = linelist)+\n  geom_histogram(aes(x = date_onset))",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Curvas epidêmicas</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.pt.html#epicurvas-no-ggplot2",
    "href": "new_pages/epicurves.pt.html#epicurvas-no-ggplot2",
    "title": "32  Curvas epidêmicas",
    "section": "32.2 Epicurvas no ggplot2",
    "text": "32.2 Epicurvas no ggplot2\nUtilizar o ggplot() para criar sua epicurva permite mais flexibilidade e customização. Entretanto, é necessário mais esforço e entendimento sobre como o ggplot() funciona.\nDiferente do pacote incidence2, no ggplot você precisa controlar manualmente a agregação dos casos pelo tempo (em semanas, meses, etc) e os intervalos dos rótulos no eixo de data. Isto precisa ser cuidadosamente gerenciado.\nOs exemplos abaixo utilizam um subconjunto do banco de dados linelist - apenas os casos do Hospital Central.\n\ncentral_data &lt;- linelist %&gt;% \n  filter(hospital == \"Central Hospital\")\n\nPara produzir uma epicurva com o ggplot(), existem três elementos principais:\n\nUm histograma, com os casos da linelist agregados em “classes” (Nota do tradutor: tradução livre de ´bins´, que em inglês significa caixa, ou container) separados por pontos “de quebra” específicos\nEscalas para os eixos e seus rótulos\nTemas para a aparência do gráfico, incluindo títulos, rótulos, legendas, etc.\n\n\nEspecifique as classes de casos\nAqui nós mostramos como especificar a maneira em que os casos serão agregados nas classes do histogramas (“barras”). É importante reconhecer que o agrupamento dos casos nessas classes do histograma não será necessariamente nos mesmos intervalos das datas que irão aparecer no eixo x.\nA seguir é mostrado, provavelmente, o código mais simples para produzir epicurvas diárias ou semanais.\nNo comando global ggplot(), o conjunto de dados é fornecido em data =. A partir disto, a geometria do histrograma é adicionada com um +. Dentro de geom_histogram(), nós mapeamos a aparência do gráfico de forma que a coluna date_onset é mapeada para o eixo x. Também dentro de geom_histogram(), mas não dentro de aes(), nós ajustamos o binwidth = dos containers do histobrama, em dias. Se essa sintaxe do ggplot2 é confusa, revise a página sobre básico do ggplot.\nCUIDADO: Criar um gráfico de casos semanas ao utilizar binwidth = 7 inicia o primeiro container de 7-dias no primeiro caso, que pode ser em qualquer dia da semana! Para criar semanas específicas, veja a seção abaixo.\n\n# diariamente \nggplot(data = central_data) +          # escolha os dados\n  geom_histogram(                      # adicione o histograma\n    mapping = aes(x = date_onset),     # mapeia a coluna de data para o eixo x\n    binwidth = 1)+                     # casos unidos por 1 dia\n  labs(title = \"Hospital Central - Diariamente\")                # título\n\n# semanal\nggplot(data = central_data) +          # escolha os dados \n  geom_histogram(                      # adicione o histograma\n      mapping = aes(x = date_onset),   # mapeia a coluna de data para o eixo x\n      binwidth = 7)+                   # casos unidos a cada 7 dias, iniciando no primeiro caso (!)\n  labs(title = \"Hospital Central - classes de 7-dias, iniciando no primeiro caso\") # título\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDeixe-nos observar que o primeiro caso neste conjunto de dados do Hospital Central teve o início dos sintomas em:\n\nformat(min(central_data$date_onset, na.rm=T), \"%A %d %b, %Y\")\n\n[1] \"Thursday 01 May, 2014\"\n\n\nPara especificar manualmente as quebras das classes do histograma, não utilize o argumento binwidth =, e, em vez disso, forneça um vetor de datas para breaks =.\nCrie o vetor de datas com a função seq.Date() do R base. Esta função precisa dos argumentos to =, from =, e by =. Por exemplo, o comando abaixo retorna datas mensais começando em 15 de janeiro e terminando em 28 de junho.\n\nmonthly_breaks &lt;- seq.Date(from = as.Date(\"2014-02-01\"),\n                           to = as.Date(\"2015-07-15\"),\n                           by = \"months\")\n\nmonthly_breaks   # exporta para o console\n\n [1] \"2014-02-01\" \"2014-03-01\" \"2014-04-01\" \"2014-05-01\" \"2014-06-01\"\n [6] \"2014-07-01\" \"2014-08-01\" \"2014-09-01\" \"2014-10-01\" \"2014-11-01\"\n[11] \"2014-12-01\" \"2015-01-01\" \"2015-02-01\" \"2015-03-01\" \"2015-04-01\"\n[16] \"2015-05-01\" \"2015-06-01\" \"2015-07-01\"\n\n\nEste vetor pode ser fornecido para geom_histogram() como breaks =:\n\n# mensalmente \nggplot(data = central_data) +  \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    breaks = monthly_breaks)+         # forneça um vetor pré-definido de quebras\n  labs(title = \"Classe de casos mensais\")   # título\n\n\n\n\n\n\n\n\nUma sequência semanal simples pode ser obtida ao ajustar by = \"week\". Por exemplo:\n\nweekly_breaks &lt;- seq.Date(from = as.Date(\"2014-02-01\"),\n                          to = as.Date(\"2015-07-15\"),\n                          by = \"week\")\n\nUma alternativa para o fornecimento de datas específicas de início e fim, é escrever um código dinâmico de forma que classes semanais iniciem na segunda antes do primeiro caso. Nós iremos utilizar estes vetores de data nos exemplos abaixo.\n\n# Sequência de datas semanais iniciando nas Segundas para o HOSPITAL CENTRAL\nweekly_breaks_central &lt;- seq.Date(\n  from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 1), # segunda anterior\n  to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # segunda após o último caso\n  by   = \"week\")\n\nVamos destrinchar o código complicado mostrado acima:\n\nO valor “from” (data mais antiga da sequência) é criado da seguinte forma: a menor data (min() com na.rm=TRUE) na coluna date_onset é atribuída a floor_date(), do pacote lubridate. floor_date() é ajustada para gerar “semanas” a partir da data de início dos casos da “semana” em questão, considerando que o dia de início de cada semana é segunda (week_start = 1).\n\nDa mesma forma, o valor “to” (data final da sequência) é criado utilizando a função inversa ceiling_date() para retornar a segunda após o último caso.\nO argumento “by” de seq.Date() pode ser ajustado para qualquer número de dias, semanas, ou meses.\nUtilize week_start = 7 para semanas que iniciem no Domingo\n\nComo iremos utilizar estes vetores de data nesta página, nós também definimos um vetor para o surto inteiro (o vetor acima é apenas para os casos do Hospital Central).\n\n# Sequência para o surto inteiro\nweekly_breaks_all &lt;- seq.Date(\n  from = floor_date(min(linelist$date_onset, na.rm=T),   \"week\", week_start = 1), # segunda antes do primeiro caso\n  to   = ceiling_date(max(linelist$date_onset, na.rm=T), \"week\", week_start = 1), # segunda após o último caso\n  by   = \"week\")\n\nEstas saídas do seq.Date() podem ser usadas para criar quebras de classes do histogramas, assim como as quebras para os rótulos de data, que podem ser independentes das primeiras. Leia mais sobre os rótulos de datas em seções posteriores.\nDICA: Para um comando ggplot() mais simples, salve as quebras das classes e as quebras dos rótulos de datas como vetores nomeados no começo, e simplesmente os forneça em breaks =.\n\n\nExemplo de epicurva semanal\nAbaixo esta detalhado um exemplo de código utilizado para produzir epicurvas semanais para semanas que iniciam nas segundas, com barras alinhadas, rótulos de data, e linhas de grade verticais. Esta seção é para o usuário que precisa rapidamente de um código. Para entender cada aspecto (temas, rótulos de datas, etc.) profundamente, continue para as seções subsequentes. De nota:\n\nAs quebras dos containers do histograma são definidas com seq.Date(), como explicado acima, para iniciar na segunda anterior ao primeiro caso, e para terminar na segunda posterior ao último caso\nO intervalo dos rótulos de data é especificado por date_breaks = dentro de scale_x_date()\n\nO intervalo de linhas da grade vertical menores entre os rótulos de data é especificado em date_minor_breaks =\n\nexpand = c(0,0) nas escalas de x e y remove o excesso de espaço em cada lado dos eixos, o que também garante que os rótulos de data iniciem a partir da primeira barra.\n\n\n# ALINHAMENTO TOTAL A PARTIR DAS SEGUNDAS-FEIRAS\n#############################\n# Defina a sequência de quebras semanais\nweekly_breaks_central &lt;- seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 1), # Segunda antes do primeiro caso\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 1), # Segunda após último caso\n      by   = \"week\")    # containers são de 7-dias\n\n\nggplot(data = central_data) + \n  \n  # crie o histograma: especifique os pontos de quebra do container: inicie na segunda antes do primeiro caso, termine na segunda após o último caso\n  geom_histogram(\n    \n    # mapeando a estética do gráfico\n    mapping = aes(x = date_onset),  # coluna de data mapeada para o eixo x\n    \n    # quebras da classe do histograma\n    breaks = weekly_breaks_central, # quebras do container do histograma definidas anteriormente\n    \n    # barras\n    color = \"darkblue\",     # cor das linhas ao redor das barras\n    fill = \"lightblue\"      # cor do preenchimento das barras\n  )+ \n    \n  # rótulos do eixo x\n  scale_x_date(\n    expand            = c(0,0),           # remove o espaço em excesso do eixo x antes e após as barras de casos\n    date_breaks       = \"4 weeks\",        # rótulos de data e principais linhas de grade verticais aparecem a cada 3 semanas iniciando nas segundas\n    date_minor_breaks = \"week\",           # linhas de grade menores aparecem a cada semana iniciando na segunda\n    date_labels       = \"%a\\n%d %b\\n%Y\")+ # formato dos rótulos de data\n  \n  # eixo y\n  scale_y_continuous(\n    expand = c(0,0))+             # remove o excesso de espaço do eixo y abaixo de 0 (alinha o histograma nivelado com o eixo x)\n  \n  # temas estéticos\n  theme_minimal()+                # simplifique o fundo do gráfico\n  \n  theme(\n    plot.caption = element_text(hjust = 0,        # legenda no lado esquerdo\n                                face = \"italic\"), # legenda em itálico\n    axis.title = element_text(face = \"bold\"))+    # título dos eixos em negrito\n  \n  # rótulos incluindo legendas dinâmicas\n  labs(\n    title    = \"Incidência semanal de casos (Semanas iniciadas na segunda)\",\n    subtitle = \"Observe o alinhamento das barras, linhas de grade verticais, e rótulos dos eixos nas semanas iniciadas na segunda\",\n    x        = \"Semana de aparecimetno dos sintomas\",\n    y        = \"Incidência semanal dos casos notificados\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} do Hospital Central; Aparecimento dos casos varia de {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} a {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %&gt;% filter(is.na(date_onset)))} casos sem a data de aparecimento dos sintomas e não mostrados neste gráfico\"))\n\n\n\n\n\n\n\n\n\nSemanas iniciando no domingo\nPara obter o gráfico acima para semanas que iniciam no domingo, algumas poucas modificações são necessárias, uma vez que o date_breaks = \"weeks\" funciona apenas para semanas iniciando às segundas.\n\nOs pontos de quebra das classes do histograma precisam serem ajustados para os domingos (week_start = 7)\n\nDentro de scale_x_date(), as datas de quebra similares devem ser fornecidas para breaks = e minor_breaks =, visando garantir que os rótulos de data e linhas de grade verticais alinhem nos domingos.\n\nPor exemplo, o comando scale_x_date(), para semanas iniciando nos domingos, pode ser semelhante ao seguinte:\n\nscale_x_date(\n    expand = c(0,0),\n    \n    # especifique o intervalo do rótulo de datas e das linhas de grade principais\n    breaks = seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7), # Domingo antes do primeiro caso\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # Domingo após o último caso\n      by   = \"4 weeks\"),\n    \n    # especifique o intervalo das linhas de grade vertical secundárias\n    minor_breaks = seq.Date(\n      from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7), # Domingo antes do primeiro caso\n      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7), # Domingo após o último caso\n      by   = \"week\"),\n   \n    # formato do rótulo de data\n    #date_labels = \"%a\\n%d %b\\n%Y\")+         # dia, mês acima abreviado, sobre o ano com 2-dígitos\n    label = scales::label_date_short())\n\n\n\n\nGrupo/cor por valor\nAs barras do histograma podem ser coloridas por grupo e podem ser “empilhadas” (o inglês stacked). Para designar a coluna de agrupamento, faça as seguintes modificações. Veja a página sobre básico do ggplot para mais detalhes.\n\nDentro do mapeamento estético do histograma, aes(), mapeie o nome da coluna para os argumentos group = e fill =\n\nRemova qualquer argumento de fill = fora de aes(), uma vez que irá sobrepor-se ao argumentos que estão dentro\nArgumentos dentro de aes() serão aplicados por grupo, enquanto qualquer argumento fora será aplicado para todas as barras (ex.: você pode querer color = fora, de forma que cada barra tenha a mesma borda)\n\nAqui é mostrado como o comando aes() pode ser utilizado para agrupar e colorir as barras de acordo com o gênero:\n\naes(x = date_onset, group = gender, fill = gender)\n\nA seguir, ele sendo aplicado:\n\nggplot(data = linelist) +     # comece com o linelist (muitos hospitais)\n  \n  # crie o histograma: especifique os pontos de ruptura dos containers: começe na segunda anterior ao primeiro caso, e finalize na segunda após o último caso\n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = hospital,       # ajuste os dados para serem agrupados por hospital\n      fill = hospital),       # preenchimento da barra (cor de dentro) de acordo com o hospital\n    \n    # quebras dos contentores são nas semanas iniciadas nas segundas\n    breaks = weekly_breaks_all,   # sequência de quebras semanais iniciadas nas segundas para o surto inteiro, como definido em código anterior\n    \n    # Cor ao redor das barras\n    color = \"black\")\n\n\n\n\n\n\n\n\n\n\nAjuste as cores\n\nPara manualmente ajustar o preenchimento de cada grupo, utilize scale_fill_manual() (nota: scale_color_manual() é diferente!).\n\nUse o argumetno values = para aplicar um vetor de cores.\nUse o argumetno na.value = para especificar uma cor para os valores NA.\n\nUse o argumento labels = para mudar o texto dos itens da legenda. Por segurança, forneça como um vetor nomeado, como c(\"old\" = \"new\", \"old\" = \"new\") ou ajuste os valores nos próprios dados.\nUse name = para dar um título adequado à legenda\n\nPara mais dicas sobre escalas de cor e paletas, veja a página sobre básico do ggplot.\n\n\nggplot(data = linelist)+           # inicie com a linelist (muitos hospitais)\n  \n  # crie um histograma\n  geom_histogram(\n    mapping = aes(x = date_onset,\n        group = hospital,          # casos agrupados por hospital\n        fill = hospital),          # barras preenchidas por hospital\n    \n    # quebra dos containers\n    breaks = weekly_breaks_all,        # sequência de quebras semanais iniciadas nas segundas, como definido em código anterior\n    \n    # Cor ao redor das barras\n    color = \"black\")+              # cor da borda para cada barra\n  \n  # especificação manual das cores\n  scale_fill_manual(\n    values = c(\"black\", \"orange\", \"grey\", \"beige\", \"blue\", \"brown\"),\n    labels = c(\"St. Mark's Maternity Hospital (SMMH)\" = \"St. Mark's\"),\n    name = \"Hospital\") # especifique as cores de preenchimento (\"values\") - atenção à ordem!\n\n\n\n\n\n\n\n\n\n\nAjuste a ordem dos níveis\nA ordem em que as barras agrupadas estão empilhadas é melhor ajustada ao se classificar a coluna de agrupamento como sendo da classe fator (Factor). Você poderá, então, designar a ordem dos níveis desse fator (e os rótulos mostrados). Veja a página sobre Fatores ou dicas do ggplot para mais detalhes.\nAntes de criar o gráfico, utilize a função fct_relevel() do pacote forcats para converter a coluna de agrupamento para a classe factor, e manualmente ajustar a ordem dos níveis, como detalhado na página sobre Fatores.\n\n# carregue o pacote forcats para trabalhar com fators\npacman::p_load(forcats)\n\n# Defina um novo conjunto de dados com o hospital como fator\nplot_data &lt;- linelist %&gt;% \n  mutate(hospital = fct_relevel(hospital, c(\"Missing\", \"Other\"))) # Converta para fator e ajuste \"Missing\" e \"Other\" como níveis do topo para aparecerem no topo da epicurva\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `hospital = fct_relevel(hospital, c(\"Missing\", \"Other\"))`.\nCaused by warning:\n! 1 unknown level in `f`: Missing\n\nlevels(plot_data$hospital) # gere os níveis em ordem\n\n[1] \"Other\"                               \n[2] \"Ausente\"                             \n[3] \"Central Hospital\"                    \n[4] \"Military Hospital\"                   \n[5] \"Port Hospital\"                       \n[6] \"St. Mark's Maternity Hospital (SMMH)\"\n\n\nNo gráfico abaixo, a única diferença do gráfico anterior é que a coluna hospital foi consolidada como mostrado acima, e nós utilizamos guides() para reverter a ordem da legenda, de forma que “Missing” está no fim da legenda.\n\nggplot(plot_data) +                     # Utilize um NOVO conjunto de dados com hospital reordenado como fator\n  \n  # crie o histograma\n  geom_histogram(\n    mapping = aes(x = date_onset,\n        group = hospital,               # casos agrupados por hospital\n        fill = hospital),               # preenchimento da barra (cor) por hospital\n    \n    breaks = weekly_breaks_all,         # sequência de quebras semanais iniciadas nas segundas para o surto inteiro, como definido no topo da seção sobre ggplot\n    \n    color = \"black\")+                   # cor da borda ao redor de cada barra\n    \n  # rótulos do eixo x\n  scale_x_date(\n    expand            = c(0,0),         # remova o excesso de espaço do eixo x antes e após as barras de casos\n    date_breaks       = \"3 weeks\",      # rótulos aparecem a cada 3 semanas que iniciam nas segundas\n    date_minor_breaks = \"week\",         # linhas verticais aparecem a cada semana iniciada na segunda\n    label = scales::label_date_short()) + # efficient date label\n  \n  # eixo y\n  scale_y_continuous(\n    expand = c(0,0))+                   # remova o espaço em excesso do eixo y abaixo de 0\n  \n  # especificação manual das cores, atenção para a ordem!\n  scale_fill_manual(\n    values = c(\"grey\", \"beige\", \"black\", \"orange\", \"blue\", \"brown\"),\n    labels = c(\"St. Mark's Maternity Hospital (SMMH)\" = \"St. Mark's\"),\n    name = \"Hospital\")+ \n  \n  # temas estéticos\n  theme_minimal()+                      # simplifique o fundo do gráfico\n  \n  theme(\n    plot.caption = element_text(face = \"italic\", # legenda no lado esquerdo em itálico\n                                hjust = 0), \n    axis.title = element_text(face = \"bold\"))+   # títulos dos eixos em negrito\n  \n  # rótulos\n  labs(\n    title    = \"Incidência semanal de casos por hospital\",\n    subtitle = \"Hospital como um factor re-ordenado\",\n    x        = \"Semana de aparecimento dos sintomas\",\n    y        = \"Casos semanais\")\n\n\n\n\n\n\n\n\nDICA: Para reverter apenas a ordem da legenda, adicione o seguinte no comando ggplot2: guides(fill = guide_legend(reverse = TRUE)).\n\n\nAjuste a legenda\nLeia mais sobre legendas e escalas no página sobre dicas do ggplot. Aqui estão alguns destaques:\n\nEdite o título da legenda por meio da função de escala ou com labs(fill = \"Legend title\") (se você estiver estilizando com color =, utilize labs(color = \"\"))\n\ntheme(legend.title = element_blank()) para não ter título de legenda\ntheme(legend.position = \"top\") para a legenda acima do gráfico. Pode-se também escolher também “bottom” , “left”, “right” ou “none” para as posições embaixo, à esqueda, à direita ou para remover a legenda, respectivamente.\ntheme(legend.direction = \"horizontal\") legenda horizontal\nguides(fill = guide_legend(reverse = TRUE)) para reverter a ordem da legenda\n\n\n\nBarras lado-a-lado\nA visualização do grupo de barras lado-a-lado (oposto à posição de barras empilhadas) é especificado dentro de geom_histogram(), com o argumento position = \"dodge\" fora de aes()(Nota do tradutor: dodge vem do inglês “esquivar”).\nSe existirem mais de dois grupos de valores, estes podem ser difíceis de ler. Em vez disso, considere utilizar um gráfico facetado (pequenos múltiplos). Para melhorar a visualização do gráfico neste exemplo, campos sem a informação do gênero foram removidos.\n\nggplot(central_data %&gt;% drop_na(gender))+   # inicie com casos do Hospital Central, excluindo as linhas sem dados do gênero\n    geom_histogram(\n        mapping = aes(\n          x = date_onset,\n          group = gender,         # casos agrupados por gênero\n          fill = gender),         # barras preenchidas de acordo com o gênero\n        \n        # quebras dos containers do histrograma\n        breaks = weekly_breaks_central,   # sequência de datas semanais para o surto no Central - definido no topo da seção sobre ggplot\n        \n        color = \"black\",          # cor do contorno das barras\n        \n        position = \"dodge\")+      # barras LADO-A-LADO\n                      \n  \n  # Os rótulos no eixo x\n  scale_x_date(expand            = c(0,0),         # remova os espaços em excesso abaixo do eixo x e após as barras de casos\n               date_breaks       = \"3 weeks\",      # rótulos aparecem a cada 3 semanas iniciadas nas segundas\n               date_minor_breaks = \"week\",         # linhas verticais aparecem a cada semana iniciada nas segundas\n               label = scales::label_date_short()) + # efficient label formatting\n  \n  # eixo y\n  scale_y_continuous(expand = c(0,0))+             # remove o espaço extra nos eixos y entre a base das barras e os rótulos\n  \n  # escala de cores e rótulos de legendas\n  scale_fill_manual(values = c(\"brown\", \"orange\"),  # especifique as cores de preenchimento (\"values\") - atenção na ordem!\n                    na.value = \"grey\" )+     \n\n  # temas estéticos\n  theme_minimal()+                                               # um conjunto de temas para simplificar o gráfico\n  theme(plot.caption = element_text(face = \"italic\", hjust = 0), # título no lado esquerdo em itálico\n        axis.title = element_text(face = \"bold\"))+               # título dos eixos em negrito\n  \n  # rótulos\n  labs(title    = \"Incidência semanal de casos, por gênero\",\n       subtitle = \"Legenda\",\n       fill     = \"Gênero\",                                      # forneça novos títulos para os eixos\n       x        = \"Semana de início dos sintomas\",\n       y        = \"Incidência semanal dos casos notificados\")\n\n\n\n\n\n\n\n\n\n\nLimite dos eixos\nExistem duas formas de limitar a extensão dos valores dos eixos.\nGeralmente, o método indicado é utilizar o comando coord_cartesian(), que aceita xlim = c(min, max) e ylim = c(min, max) (onde você fornece os valores mínimos e máximos). Esta ferramenta age como um “zoom” sem, na realidade, remover qualquer dado, o que é importante para estatísticas e resumos das medidas.\nAlternativamente, você pode ajustar os valores mínimos e máximos das datas utilizando limits = c() dentro de scale_x_date(). Por exemplo:\n\nscale_x_date(limits = c(as.Date(\"2014-04-01\"), NA)) # escolhe uma data mínima mas deixa a data máxima em aberto.\n\nDa mesma forma, se você quiser que o eixo x se estenda até uma data específica (ex.: data atual), mesmo que novos casos não sejam notificados, você pode utilizar:\n\nscale_x_date(limits = c(NA, Sys.Date()) # garante que o eixo da data se estenda até a data atual\n\nPERIGO: Tenha cuidado ao ajustar as quebras ou limites da escala do eixo y (ex.: 0 a 30 por 5: seq(0, 30, 5)). Estes números estáticos podem cortar o seu gráfico casos seus dados mudem e ultrapassem os limites!\n\n\nRótulos/linha de grade do eixo de data\nDICA: Lembre que os rótulos do eixo das datas são independentes da agregação das datas em barras, mas visualmente podem ser importantes para alinhar as classes, rótulos de data, e linhas de grade verticais.\nPara modificar os rótulos de data e as linhas de grade, utilize a função scale_x_date() em uma das seguintes formas:\n\nSe as suas classes do histograma são dias, semanas iniciadas em segundas, meses, ou anos:\n\nUtilize date_breaks = para especificar o intervalo de rótulos e linhas de grade principais (ex.: “day” (dia), “week” (semana), “3 weeks” (3 semanas), “month” (mês), ou “year” (ano))\nUtilize date_minor_breaks = para especificar o intervalo das linhas de grade verticais secundárias (entre os rótulos)\nAdicione expand = c(0,0) para iniciar os rótulos na primeira barra\nUtilize date_labels = para especificar o formato dos rótulos de data - veja a página sobre Datas para dicas (utilize \\n para uma nova linha)\n\n\nSe as suas classes do histograma são semanas iniciadas nos domingos:\n\nUtilize breaks = e minor_breaks = ao fornecer uma sequência de quebras de datas para cada um\nVocê ainda pode utilizar date_labels = e expand = para formatação, como decrito acima\n\n\nAlgumas notas:\n\nVeja a seção de abertura do ggplot para instruções sobre como criar uma sequência de datas utilizando seq.Date().\n\nVeja esta página ou a página Trabalhando com datas para dicas sobre como criar rótulos de data.\n\n\nDemonstrações\nAbaixo está uma demonstração de gráficos onde as cásses e os rótulos/linhas de grade do gráfico estão alinhados e desalinhados:\n\n# classes de 7-dias + rótulos de Segunda\n#############################\nggplot(central_data) +\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    binwidth = 7,                 # classes de 7-dias com início no primeiro caso\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n  \n  scale_x_date(\n    expand = c(0,0),               # remova o excesso de espaço do eixo x abaixo e após as barras de caso\n    date_breaks = \"3 weeks\",       # Segunda a cada 3 semanas\n    date_minor_breaks = \"week\",    # Semanas iniciadas na segunda\n    label = scales::label_date_short())+ # automatic label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+              # remova o espaço em excesso abaixo do eixo x, fazendo um nivelamento\n  \n  labs(\n    title = \"DESALINHADO\",\n    subtitle = \"! CUIDADO: barras de 7-dias iniciam nas quintas-feiras no primeiro caso\\nRótulos de data e linhas de grade nas segundas-feiras\\nObserve como os traços não alinham com as barras\")\n\n\n\n# classes de 7-dias + meses\n#####################\nggplot(central_data) +\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    binwidth = 7,\n    color = \"darkblue\",\n    fill = \"lightblue\") +\n  \n  scale_x_date(\n    expand = c(0,0),                  # remova o espaço em excesso abaixo e após as barras de casos\n    date_breaks = \"months\",           # primeiro do mês\n    date_minor_breaks = \"week\",       # semanas iniciadas nas segundas\n    label = scales::label_date_short())+ # automatic label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remova o espaço em excesso abaixo do eixo x, faça um nivelamento\n  \n  labs(\n    title = \"DESALINHADO\",\n    subtitle = \"! CUIDADO: Barras de 7-dias iniciam nas quintas-feiras com o primeiro caso\\nLinhas de grade principais e rótulos de data no primeiro de cada mês\\nLinhas de grade secundárias semanalmente nas segundas\\nObserve o espaçamento diferente de algumas das linhas de grade e traços desalinhados com as barras\")\n\n\n# ALINHAMENTO TOTAL NAS SEGUNDAS: especifique manualmente as quebras das classes para serem nas segundas\n#################################################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # quebras do histograma ajustadas para 7 dias iniciando na Segunda antes do primeiro caso\n    breaks = weekly_breaks_central,    # definido anteriormente nesta página\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),                   # remova o excesso de espaço do eixo x abaixo e após as barras de caso\n    date_breaks = \"4 weeks\",           # Segunda-feira a cada 4 semanas\n    date_minor_breaks = \"week\",        # Semanas iniciadas na segunda\n    label = scales::label_date_short())+ # automatic label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remova o excesso de espaço abaixo do eixo x, faça o nivelamento\n  \n  labs(\n    title = \"Segunda ALINHADAS\",\n    subtitle = \"Classes de 7-dias manualmente ajustados para iniciarem na segunda antes do primeiro caso (28 de abril)\\nRótulos de data e linhas de grade também nas segundas\")\n\n\n# ALINHAMENTO TOTAL NA SEGUNDA COM RÓTULOS DE MESES:\n############################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # quebras do histograma ajustaddas para 7 dias iniciando na segunda antes do primeiro caso\n    breaks = weekly_breaks_central,            # definido anteriormente nesta página\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),                   # remova o excesso de espaço no eixo x abaixo e após as barras de casos\n    date_breaks = \"months\",            # Segunda a cada 4 semanas\n    date_minor_breaks = \"week\",        # Semanas iniciadas nas segundas\n    label = scales::label_date_short())+ # label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remova o excesso de espaço abaixo do eixo x, faça um nivelamento\n  \n  theme(panel.grid.major = element_blank())+  # Remove as linhas de grade principais )caem no primeiro dia do mês)\n          \n  labs(\n    title = \"ALINHADO nas segundas com rótulos MENSAIS\",\n    subtitle = \"Classes de 7-dias manualmente ajustado para iniciar na segunda antes do primeiro caso (28 de abril)\\nRótulo de datas no primeiro dia do mês\\nPrincipais linhas de grade mensais removidas\")\n\n\n# ALINHAMENTO TOTAL NO DOMINGO: especifique manualmente as quebras das classes E rótulos para serem nos domingos\n############################################################################\nggplot(central_data) + \n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    # quebra do histograma ajustadas para serem de 7 dias, iniciando no Domingo antes do primeiro caso\n    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                      by   = \"7 days\"),\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") + \n  \n  scale_x_date(\n    expand = c(0,0),\n    # quebras dos rótulos de datas e principais linhas de grade ajustadas para ocorrerem a cada 3 semanas iniciando no domingo antes do primeiro caso\n    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                      by   = \"3 weeks\"),\n    \n    # linhas de grade secundárias ajustadas para iniciarem semanalmente no domingo antes do primeiro caso\n    minor_breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   \"week\", week_start = 7),\n                            to   = ceiling_date(max(central_data$date_onset, na.rm=T), \"week\", week_start = 7),\n                            by   = \"7 days\"),\n    \n    label = scales::label_date_short())+ # automatic label formatting\n  \n  scale_y_continuous(\n    expand = c(0,0))+                # remova o espaço em excesso abaixo do eixo x, faça um nivelamento\n  \n  labs(title = \"ALINHAMENTO nos domingos\",\n       subtitle = \"Classes de 7-dias manualmente ajustados para iniciarem no domingo antes do primeiro caso (27 de abril)\\nRótulo de datas e linhas de grade manualmente ajustadas também para os domingos\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDados agregados\nFrequentemente, ao invés de uma linelist, você inicia com contagens agregadas de unidades, distritos, etc. Você pode criar uma epicurva com o ggplot(), mas o código será levemente diferente. Esta seção irá utilizar o conjunto de dados do count_data que foi importado anteriormente, na seção de preparação dos dados. Este conjunto de dados é o linelist agregado para contagens diárias por hospital. As primeiras 50 linhas são mostradas abaixo.\n\n\n\n\n\n\n\nCriando um gráfico de contagens diárias\nNós podemos criar um gráfico de uma epicurva diária destas contagens diárias. Aqui estão as diferenças no código:\n\nDentro do mapeamento estético aes(), especifique y = como a coluna de contagem (neste caso, o nome da coluna é n_cases)\nAdicione o argumento stat = \"identity\" dentro de geom_histogram(), que especifica que a altura da barra deve ser o valor y = , e não o número de linhas, como é o padrão\nAdicione o argumento width = para evitar linhas verticais brancas entre as barras. Para contagens diárias o ajuste é 1. Para contagens semanais o ajuste é 7. Para contagens mensais, linhas brancas são um problema (cada M~es possui diferente número de dias) - considere transformar seu eixo x para um factor ordenado categoricamente (meses) e utilizando geom_col().\n\n\nggplot(data = count_data)+\n  geom_histogram(\n   mapping = aes(x = date_hospitalisation, y = n_cases),\n   stat = \"identity\",\n   width = 1)+                # para contagens diárias, ajuste width = 1 para evitar o espaço braco entre as barras\n  labs(\n    x = \"Data de notificação\", \n    y = \"Número de casos\",\n    title = \"Incidência diária de casos, a partir dos dados de contagem diária\")\n\n\n\n\n\n\n\n\n\n\nCriando um gráfico de contagens semanais\nSe os seus casos já estão contados por semana, eles podem parecer como o seguinte conjunto de dados (chamado count_data_weekly):\nAs primeiras 50 linhas de count_data_weekly são mostradas abaixo. Você pode ver que as contagens foram agregadas por semanas. Cada semana é mostrada pelo primeiro dia da semana (segunda-feira, por padrão).\n\n\n\n\n\n\nAgora crie o gráfico de forma que x = a coluna da semana epidemiológica. Lembre de adicionar y = a coluna de contagens para o mapeamento estético, e adicione stat = \"identity\", como explicado acima.\n\nggplot(data = count_data_weekly)+\n  \n  geom_histogram(\n    mapping = aes(\n      x = epiweek,           # eixo x é a semana epidemiológica (variável da classe Data)\n      y = n_cases_weekly,    # altura do eixo y nas contagens de casos semanais\n      group = hospital,      # nós estamos agrupando as barras e colorindo por hospital\n      fill = hospital),\n    stat = \"identity\")+      # isto também é requerido quando criar um gráfico dos dados de contagem\n     \n  # rótulos para o eixo x\n  scale_x_date(\n    date_breaks = \"2 months\",      # rótulos a cada 2 meses\n    date_minor_breaks = \"1 month\", # linhas de grade a cada mês\n    label = scales::label_date_short())+ # label formatting\n     \n  # Escolha a paleta de cor (utiliza o pacote RColorBrewer)\n  scale_fill_brewer(palette = \"Pastel2\")+ \n  \n  theme_minimal()+\n  \n  labs(\n    x = \"Semana de início\", \n    y = \"Incidência semanal de casos\",\n    fill = \"Hospital\",\n    title = \"Incidência semanal de casos, a partir dos dados de casos agregados por hospital\")\n\n\n\n\n\n\n\n\n\n\n\nMédia móvel\nVeja a página sobre médias móveis para uma descrição detalhada e diferentes opções. Abaixo, uma alternativa para calcular as médias móveis com o pacote slider é utilizada. Nesta abordagem, a média móvel é calculada no conjunto de dados antes de criar os gráficos:\n\nAgregue os dados em contagens conforme necessário (diárias, semanais, etc.) (veja a página Agrupando dados)\n\nCrie uma nova coluna para salvar a média móvel, criada com slide_index() do pacote slider\n\nCrie um gráfico da média móvel como uma geom_line() acima do (após) o histograma da epicurva\n\nVeja este útil resumo online do pacote slider\n\n# carregue o pacote\npacman::p_load(slider)  # slider utilizado para calcular as médias móveis\n\n# crie um conjunto de dados de contagens diárias e média móvel de 7-dias\n#######################################################\nll_counts_7day &lt;- linelist %&gt;%    # inicie com o objeto linelist\n  \n  ## conte os casos por dia\n  count(date_onset, name = \"new_cases\") %&gt;%   # crie uma nova coluna com as contagens, chamada \"new_cases\"\n  drop_na(date_onset) %&gt;%                     # remova os casos sem a informação do dia de início dos sintomas (date_onset)\n  \n  ## calcule o número médio de casos em uma janela de 7 dias\n  mutate(\n    avg_7day = slider::slide_index(    # crie uma nova coluna\n      new_cases,                       # calcule baseado nos valores da coluna new_cases\n      .i = date_onset,                 # o indexador é a coluna de date_onset, de forma que as contagens sem datas são incluídas na janela de análise\n      .f = ~mean(.x, na.rm = TRUE),    # a função utilizada é mean() com os valores em branco removidos\n      .before = 6,                     # a janela de análise é o dia e os 6-dias anteriores\n      .complete = FALSE),              # precisa ser FALSE para unlist() funcionar na próxima etapa\n    avg_7day = unlist(avg_7day))       # converta da classe \"list\" para a classe \"numeric\"\n\n\n# crie o gráfico\n######\nggplot(data = ll_counts_7day) +  # inicie com o novo conjunto de dados criado acima\n    geom_histogram(              # crie uma epicurva em histograma\n      mapping = aes(\n        x = date_onset,          # coluna de datas no eixo x\n        y = new_cases),          # a altura é o número de novos casos diários\n        stat = \"identity\",       # altura da coluna é o valor de y\n        fill=\"#92a8d1\",          # cor legal para as barras\n        colour = \"#92a8d1\",      # mesma cor para a borda das barras\n        )+ \n    geom_line(                   # crie uma linha para a média móvel\n      mapping = aes(\n        x = date_onset,          # coluna de data para o eixo x\n        y = avg_7day,            # valor de y ajustado para a coluna de média móvel\n        lty = \"Média móvel \\nde 7-dias\"), # nome da linha na legenda\n      color=\"red\",               # cor da linha\n      size = 1) +                # espessura da linha\n    scale_x_date(                # escala da data\n      date_breaks = \"1 month\",\n      label = scales::label_date_short(), # label formatting\n      expand = c(0,0)) +\n    scale_y_continuous(          # escala do eixo y\n      expand = c(0,0),\n      limits = c(0, NA)) +       \n    labs(\n      x=\"\",\n      y =\"Número de casos confirmados\",\n      fill = \"Legenda\")+ \n    theme_minimal()+\n    theme(legend.title = element_blank())  # remove o título da legenda\n\n\n\n\n\n\n\n\n\n\nFacetas/múltiplos pequenos\nComo em outros ggplots, você pode criar gráficos facetados (“múltiplos pequenos”). Como explicado na página dicas do ggplot deste manual, você pode utilizar tanto facet_wrap() quanto facet_grid(). Aqui, nós demonstramos com o facet_wrap(). Para epicurvas, facet_wrap() é tipicamente mais fácil, uma vez que provavelmente você só precisa facetar uma coluna.\nA sintaxe geral é facet_wrap(rows ~ cols), em que no lado esquerdo do til (~) é o nome da coluna a ser espalhada através das “linhas” do gráfico facetado, e no lado direito do til é o nome de uma coluna a ser espalhada através das “colunas” do gráfico facetado. De forma mais simples, só utilize um nome de coluna, no lado direito do til: facet_wrap(~age_cat).\nEixos livres\nVocê precisará decidir se as escalas dos eixos para cada faceta são “fixas” para as mesmas dimensões (padrão), ou “livres” (significando que irão mudar baseado nos dados dentro da faceta). Faça isso com o argumento scales = dentro de facet_wrap() ao especificar “free_x” ou “free_y”, ou “free”.\nNúmero de colunas e linhas das facetas\nIsto pode ser especificado com ncol = e nrow = dentro de facet_wrap().\nOrdem dos painéis\nPara alterar a ordem de aparecimento, altere a ordem dos níveis da coluna de factor utilizada para criar as facetas.\nEstética\nTamanho da fonte e face, cor da tira, etc. podem ser modificados através de theme() com argumentos como:\n\nstrip.text = element_text() (tamanho, cor, face, ângulo…)\nstrip.background = element_rect() (ex.: element_rect(fill=“grey”))\n\nstrip.position = (posição da tira “bottom” (embaixo), “top” (em cima), “left” (à esquerda), ou “right” (à direita))\n\nRótulos das tiras\nRótulos dos gráficos facetados podem ser modificados por meio de “rótulos” da coluna como um factor, ou pelo uso de um “rotulador”.\nCrie um rotulador como este, utilizando a função as_labeller() do ggplot2. Então, forneça o rotulador para o argumento labeller = de facet_wrap(), como mostrado abaixo.\n\nmy_labels &lt;- as_labeller(c(\n     \"0-4\"   = \"Ages 0-4\",\n     \"5-9\"   = \"Ages 5-9\",\n     \"10-14\" = \"Ages 10-14\",\n     \"15-19\" = \"Ages 15-19\",\n     \"20-29\" = \"Ages 20-29\",\n     \"30-49\" = \"Ages 30-49\",\n     \"50-69\" = \"Ages 50-69\",\n     \"70+\"   = \"Over age 70\"))\n\nUm exemplo de gráfico facetado - facetado pela coluna age_cat.\n\n# crie o gráfico\n###########\nggplot(central_data) + \n  \n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = age_cat,\n      fill = age_cat),    # argumentos dentro de aes() aplicam-se ao grupo\n      \n    color = \"black\",      # argumentos fora de aes() aplicam-se a todos os dados\n        \n    # quebras do histograma\n    breaks = weekly_breaks_central)+  # vetor pré-definido de datas (veja mais acima nesta página)\n                      \n  # Os rótulos no eixo x\n  scale_x_date(\n    expand            = c(0,0),         # remove o espaço em excesso do eixo x abaixo e após as barras de casos\n    date_breaks       = \"2 months\",     # rótulos aparecem a cada 2 meses\n    date_minor_breaks = \"1 month\",      # linhas verticais aparecem a cada mês\n    label = scales::label_date_short())+ # label formatting\n  \n  # eixo y\n  scale_y_continuous(expand = c(0,0))+                       # remove o espaço em excesso do eixo y entre os fundos das barras e os rótulos\n  \n  # temas estéticos\n  theme_minimal()+                                           # um conjunto de temas para simplificar a plotagem\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # título no lado esquerdo em itálico\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    strip.text = element_text(face = \"bold\", size = 10),\n    strip.background = element_rect(fill = \"grey\"))+         # títulos dos eixos em negrito\n  \n  # crie as facetas\n  facet_wrap(\n    ~age_cat,\n    ncol = 4,\n    strip.position = \"top\",\n    labeller = my_labels)+             \n  \n  # rótulos\n  labs(\n    title    = \"Incidência semanal de casos, por categoria de idade\",\n    subtitle = \"Legenda\",\n    fill     = \"Categoria de idade\",                                      # forneça um novo título para a legenda\n    x        = \"Semana de início dos sintomas\",\n    y        = \"Incidência semanal dos casos notificados\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} do Hospital Central; Aparecimento dos casos varia entre {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} a {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %&gt;% filter(is.na(date_onset)))} casos sem a data de início dos sintomas e não mostrados no gráfico\"))\n\n\n\n\n\n\n\n\nVeja este link para mais informações sobre os rotuladores.\n\nEpidemia total no fundo da faceta\nPara mostrar o total da epidemia no fundo de cada faceta, adicione a função gghighlight() com parênteses vazios ao ggplot. Isto é do pacote gghighlight. Observe que o máximo do eixo y em todas as facetas é agora baseado no pico da epidemia inteira. Existem mais exemplos deste pacote na página sobre dicas do ggplot.\n\nggplot(central_data) + \n  \n  # epicurvas por grupo\n  geom_histogram(\n    mapping = aes(\n      x = date_onset,\n      group = age_cat,\n      fill = age_cat),  # argumentos dentro de aes() são aplicados por grupo\n    \n    color = \"black\",    # argumentos fora de aes() são aplicados a todos os dados\n    \n    # quebras do histograma\n    breaks = weekly_breaks_central)+     # vetor de datas pré-definidas (veja o topo da seção sobre ggplot)\n  \n  # adicione a epidemia total em cinza em cada faceta\n  gghighlight::gghighlight()+\n  \n  # rótulos no eixo x\n  scale_x_date(\n    expand            = c(0,0),         # remova o espaço em excesso do eixo x abaixo e após as barras de casos\n    date_breaks       = \"2 months\",     # rótulos aparecem a cada 2 meses\n    date_minor_breaks = \"1 month\",      # linhas verticais aparecem a cada 1 mês\n    label = scales::label_date_short())+ # label formatting\n  \n  # eixo y\n  scale_y_continuous(expand = c(0,0))+  # remove o excesso de espaço do eixo y abaixo de 0\n  \n  # temas estéticos\n  theme_minimal()+                                           # um conjunto de temas para simplificar o gráfico\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # título no lado esquerdo em itálico\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\",\n    strip.text = element_text(face = \"bold\", size = 10),\n    strip.background = element_rect(fill = \"white\"))+        # títulos dos eixos em negrito\n  \n  # crie as facetas\n  facet_wrap(\n    ~age_cat,                          # cada gráfico é um valor de age_cat\n    ncol = 4,                          # número de colunas\n    strip.position = \"top\",            # posição do título/tira da faceta\n    labeller = my_labels)+             # rotulador definido acima\n  \n  # rótulos\n  labs(\n    title    = \"Incidência semanal de casos, por categoria de idade\",\n    subtitle = \"Legenda\",\n    fill     = \"Categoria de idade\",                                      # forneça um novo título para a legenda\n    x        = \"Semana de início dos sintomas\",\n    y        = \"Incidência semanal dos casos notificados\",\n    caption  = stringr::str_glue(\"n = {nrow(central_data)} do Hospital Central; Surgimento dos casos foi de {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} a {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %&gt;% filter(is.na(date_onset)))} casos sem a data de início dos sintomas e não mostrados no gráfico\"))\n\n\n\n\n\n\n\n\n\n\nUma faceta com dados\nSe você quer ter uma caixa de faceta que contem todos os dados, duplique o conjunto de dados inteiro e trate as duplicatas como um valor de facetas. Uma função “auxiliar”, CreateAllFacet(), abaixo pode auxiliar nisso (agradecimento a esse post). Quando é executado, o número de linhas duplica, e então terá uma nova coluna chamada facet, em que as linhas duplicadas terão o valor “all”, e as linhas originais terão o valor original da coluna de facetas. Agora você só precisa facetear com a coluna facet.\nAqui está a função auxiliar. Execute ela de forma que esteja disponível para você.\n\n# Defina uma função auxiliar\nCreateAllFacet &lt;- function(df, col){\n     df$facet &lt;- df[[col]]\n     temp &lt;- df\n     temp$facet &lt;- \"all\"\n     merged &lt;-rbind(temp, df)\n     \n     # garanta que o valor da faceta é um fator\n     merged[[col]] &lt;- as.factor(merged[[col]])\n     \n     return(merged)\n}\n\nAgora aplique a função auxiliar para o conjunto de dados, na coluna age_cat:\n\n# Crie um conjunto de dados que é duplicado e com a nova coluna \"facet\" para mostrar \"all\" (todas) as categorias de idade como outro nível da faceta\ncentral_data2 &lt;- CreateAllFacet(central_data, col = \"age_cat\") %&gt;%\n  \n  # ajuste os níveis do fator\n  mutate(facet = fct_relevel(facet, \"all\", \"0-4\", \"5-9\",\n                             \"10-14\", \"15-19\", \"20-29\",\n                             \"30-49\", \"50-69\", \"70+\"))\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `facet = fct_relevel(...)`.\nCaused by warning:\n! 1 unknown level in `f`: 70+\n\n# verifique os níveis\ntable(central_data2$facet, useNA = \"always\")\n\n\n  all   0-4   5-9 10-14 15-19 20-29 30-49 50-69  &lt;NA&gt; \n  454    84    84    82    58    73    57     7     9 \n\n\nAlterações notáveis no comando ggplot() são:\n\nOs dados utilizados agora são central_data2 (duplique as linhas, com a nova coluna “facet”)\nRotulador precisará ser atualizado, caso usado\nOpcional: para obter facetas empilhadas verticalmente: a coluna facetada é movida para o lado das linhas na equação e no lado esquerdo é substituído por “.” (facet_wrap(facet~.)), e ncol = 1. Você também pode precisar ajustar o comprimento e altura da imagem do gráfico salvo (veja ggsave() no dicas do ggplot).\n\n\nggplot(central_data2) + \n  \n  # epicurvas atuais por grupo\n  geom_histogram(\n        mapping = aes(\n          x = date_onset,\n          group = age_cat,\n          fill = age_cat),  # argumentos dentro de aes() são aplicados por grupo\n        color = \"black\",    # argumentos fora de aes() são aplicados a todos os dados\n        \n        # quebras do histograma\n        breaks = weekly_breaks_central)+    # vetor de datas pré-definidos (veja o topo da seção sobre o ggplot)\n                     \n  # Rótulos no eixo x\n  scale_x_date(\n    expand            = c(0,0),         # remova o excesso de espaço no eixo x abaixo e após as barras de casos\n    date_breaks       = \"2 months\",     # rótulos aparecem a cada 2 meses\n    date_minor_breaks = \"1 month\",      # linhas verticais aparecem a cada mês\n    label = scales::label_date_short())+ # label formatting\n  \n  # eixo y\n  scale_y_continuous(expand = c(0,0))+  # remove o espaço em excesso do eixo y entre a base das barras e os rótulos\n  \n  # temas estéticos\n  theme_minimal()+                                           # um conjunto de temas para simplificar o gráfico\n  theme(\n    plot.caption = element_text(face = \"italic\", hjust = 0), # título no lado esquerdo em itálico\n    axis.title = element_text(face = \"bold\"),\n    legend.position = \"bottom\")+               \n  \n  # crie as facetas\n  facet_wrap(facet~. ,                            # cada gráfico é um valor da faceta\n             ncol = 1)+            \n\n  # rótulos\n  labs(title    = \"Incidência semanal de casos, por categoria de idade\",\n       subtitle = \"Legenda\",\n       fill     = \"Categoria de idade\",                                      # forneça um novo título para a legenda\n       x        = \"Semana de início dos sintomas\",\n       y        = \"Incidência semanal dos casos notificados\",\n       caption  = stringr::str_glue(\"n = {nrow(central_data)} do Hospital Central; Surgimento dos casos foi de {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} a {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\\n{nrow(central_data %&gt;% filter(is.na(date_onset)))} casos sem a data de aparecimento dos sintomas e não mostrados no gráfico\"))",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Curvas epidêmicas</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.pt.html#dados-preliminares",
    "href": "new_pages/epicurves.pt.html#dados-preliminares",
    "title": "32  Curvas epidêmicas",
    "section": "32.3 Dados preliminares",
    "text": "32.3 Dados preliminares\nOs dados mais recentes mostrados em epicurvas precisam, frequentemente, serem marcados como preliminares, ou sujeitos à demoras na notificação. Isto pode ser feito ao adicionar uma linha vertical e/ou retângulo sobre um número específico de dias. Aqui estão duas opções:\n\nUtilize annotate():\n\nPara utilizar uma linha, use annotate(geom = \"segment\"). Forneça x, xend, y, e yend. Ajuste o tamanho, tipo de linha (lty), e cor.\nPara utilizar um retângulo, use annotate(geom = \"rect\"). Forneça xmin/xmax/ymin/ymax. Ajuste a cor e o alfa.\n\nAgrupe os dados por status da tentativa e utilize cores diferentes para essas barras\n\nCUIDADO: Você pode querer experimentar geom_rect() para desenhar um retângulo, mas ajustar a transparência não funciona no contexto de uma linelist. Esta função sobrepõe um retângulo para cada observação/linha!. Utilize ou um alfa muito baixo (ex.: 0.01), ou outra abordagem.\n\nUtilizando annotate()\n\nDentro de annotate(geom = \"rect\"), os argumentos xmin e xmax precisam ser dados como valores da classe Date (data).\nNote que, devido ao fato destes dados serem agregados em barras semanais, e a última barra extender para a segunda após o último caso, a região sombreada pode parecer cobrir 4 semanas\nAqui é um exemplo online de annotate()\n\n\nggplot(central_data) + \n  \n  # histograma\n  geom_histogram(\n    mapping = aes(x = date_onset),\n    \n    breaks = weekly_breaks_central,   # vetor de data pré-definido - veja o topo da seção sobre o ggplot\n    \n    color = \"darkblue\",\n    \n    fill = \"lightblue\") +\n\n  # escalas\n  scale_y_continuous(expand = c(0,0))+\n  scale_x_date(\n    expand = c(0,0),                   # remove o excesso de espaço do eixo x abaixo e após as barras de casos\n    date_breaks = \"1 month\",           # Primeiro do mês\n    date_minor_breaks = \"1 month\",     # Primeiro do mês\n    label = scales::label_date_short())+ # label formatting\n  \n  # rótulos e tema\n  labs(\n    title = \"Utilizando annotate()\\nRetângulo e linha mostrando que os dados dos últimos 21 dias são preliminares\",\n    x = \"Semana de início de sintomas\",\n    y = \"Incidência semanal de casos\")+ \n  theme_minimal()+\n  \n  # adicione um retângulo vermelho semi-transparente nos dados preliminares\n  annotate(\n    \"rect\",\n    xmin  = as.Date(max(central_data$date_onset, na.rm = T) - 21), # a nota precisa ser englobada dentro de as.Date()\n    xmax  = as.Date(Inf),                                          # a nota precisa ser englobada dentro de as.Date()\n    ymin  = 0,\n    ymax  = Inf,\n    alpha = 0.2,          # alfa fácil e intuitivo para ajustar usando annotate()\n    fill  = \"red\")+\n  \n  # adicione uma linha preta vertical no topo das outras camadas\n  annotate(\n    \"segment\",\n    x     = max(central_data$date_onset, na.rm = T) - 21, # 21 dias antes dos últimos dados\n    xend  = max(central_data$date_onset, na.rm = T) - 21, \n    y     = 0,         # linha inicia em y = 0\n    yend  = Inf,       # linha no topo do gráfico\n    size  = 2,         # tamanho da linha\n    color = \"black\",\n    lty   = \"solid\")+   # tipo de linha ex.: \"solid\", \"dashed\"\n\n  # adicione texto no retângulo\n  annotate(\n    \"text\",\n    x = max(central_data$date_onset, na.rm = T) - 15,\n    y = 15,\n    label = \"Sujeito à atrasos nas notificações\",\n    angle = 90)\n\n\n\n\n\n\n\n\nA mesma linha preta vertical pode ser obtida com o código abaixo, mas, utilizando geom_vline(), você perde a capacidade de controlar a altura:\n\ngeom_vline(xintercept = max(central_data$date_onset, na.rm = T) - 21,\n           size = 2,\n           color = \"black\")\n\n\n\nCor das barras\nUma abordagem alternativa pode ser ajustar a cor ou exibição das dos dados preliminares. Você pode criar uma nova coluna no estágio de preparação dos dados, e utiliza-la para agrupar os dados, de forma que o aes(fill = ) dos dados preliminares possa ter uma cor ou alfa diferente das outras barras.\n\n# adiciona uma coluna\n############\nplot_data &lt;- central_data %&gt;% \n  mutate(tentative = case_when(\n    date_onset &gt;= max(date_onset, na.rm=T) - 7 ~ \"Tentative\", # preliminares e estiverem dentro dos últimos 7 dias\n    TRUE                                       ~ \"Reliable\")) # todos os demais são confiáveis\n\n# crie o gráfico\n######\nggplot(plot_data, aes(x = date_onset, fill = tentative)) + \n  \n  # histograma\n  geom_histogram(\n    breaks = weekly_breaks_central,   # vetor de datas pré-definido, veja o topo da página sobre o ggplot\n    color = \"black\") +\n\n  # escalas\n  scale_y_continuous(expand = c(0,0))+\n  scale_fill_manual(values = c(\"lightblue\", \"grey\"))+\n  scale_x_date(\n    expand = c(0,0),                   # remove o espaço em excesso do eixo x, abaixo e após as barras de casos\n    date_breaks = \"3 weeks\",           # segundas a cada 3 semanas\n    date_minor_breaks = \"week\",        # semanas iniciadas nas segundas\n    label = scales::label_date_short())+ # label formatting\n  \n  # rótulos e temas\n  labs(title = \"Mostra os dias que possuem notificações preliminares\",\n    subtitle = \"\")+ \n  theme_minimal()+\n  theme(legend.title = element_blank())                 # remove o título da legenda",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Curvas epidêmicas</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.pt.html#etiquetas-multiníveis-de-data",
    "href": "new_pages/epicurves.pt.html#etiquetas-multiníveis-de-data",
    "title": "32  Curvas epidêmicas",
    "section": "32.4 Etiquetas multiníveis de data",
    "text": "32.4 Etiquetas multiníveis de data\nSe você quiser etiquetas multiníveis de datas (ex.: mês e ano) sem duplicar as etiquetas de níveis mais baixos, utilize uma das abordagens abaixo:\nLembre - você pode utilizar ferramentas como \\n dentro dos argumentos de date_labels ou labels para colocar partes de cada etiqueta em uma nova linha abaixo da atual. Entretanto, o código abaixo o ajuda a colocar anos ou meses (por exemplo) em uma linha abaixo e apenas uma vez. Algumas notas sobre o código abaixo:\n\nContagem de casos são agregados em semanas por razões estéticas. Veja a página sobre epicurvas (parte sobre a separação dos dados agregados) para mais detalhes.\nUma linha geom_area() é utilizada no lugar de um histograma, uma vez que a abordagem de faceteamento abaixo não funciona bem com histogramas.\n\nAgregue para contagens semanais\n\n# Crie o conjunto de dados de contagens de casos por semana\n#######################################\ncentral_weekly &lt;- linelist %&gt;%\n  filter(hospital == \"Central Hospital\") %&gt;%   # filtre a linelist\n  mutate(week = lubridate::floor_date(date_onset, unit = \"weeks\")) %&gt;%  \n  count(week) %&gt;%                              # faça um resumo das contagens de casos semanais\n  drop_na(week) %&gt;%                            # remova os casos sem a informação de onset_date\n  complete(                                    # preencha todas as semanas com nenhum caso notificado\n    week = seq.Date(\n      from = min(week),   \n      to   = max(week),\n      by   = \"week\"),\n    fill = list(n = 0))                        # converta novos campos NA (faltantes) para contagens de 0\n\nCrie os gráficos\n\n# crie um gráfico com a borda da caixa no ano\n##############################\nggplot(central_weekly) +\n  geom_area(aes(x = week, y = n),    # crie uma linha, especificando x e y\n            stat = \"identity\") +             # a altura da linha é o número da contagem\n  scale_x_date(date_labels=\"%b\",             # formato do rótulo de data mostra o mês\n               date_breaks=\"month\",          # rótulos de data no primeiro dia de cada mês\n               expand=c(0,0)) +              # remove o espaço em excesso em cada extremidade\n  scale_y_continuous(\n    expand  = c(0,0))+                       # remove o espaço em excesso abaixo do eixo x\n  facet_grid(~lubridate::year(week), # crie uma faceta com o ano (da coluna da classe Date (Data))\n             space=\"free_x\",                \n             scales=\"free_x\",                # eixo x se adapta para o intervalo dos dados (não é fixo)\n             switch=\"x\") +                   # etiquetas de faceta (ano) na base\n  theme_bw() +\n  theme(strip.placement = \"outside\",         # posicionamento das etiquetas das facetas\n        strip.background = element_rect(fill = NA, # rótulos das facetas sem preenchimento e com bordas cinzas\n                                        colour = \"grey50\"),\n        panel.spacing = unit(0, \"cm\"))+      # sem espaço entre os painéis das facetas\n  labs(title = \"Etiquetas de ano aninhadas, com borda cinza\")\n\n\n\n\n\n\n\n# crie o gráfico sem a borda de caixa no ano\n#################################\nggplot(central_weekly,\n       aes(x = week, y = n)) +              # estabeleça o x e y para o gráfico inteiro\n  geom_line(stat = \"identity\",              # crie a linha, em que a altura da linha é o número da contagem\n            color = \"#69b3a2\") +            # cor da linha\n  geom_point(size=1, color=\"#69b3a2\") +     # crie pontos nos pontos de data semanais\n  geom_area(fill = \"#69b3a2\",               # preencha a área abaixo da linha\n            alpha = 0.4)+                   # preencha a transparência\n  scale_x_date(date_labels=\"%b\",            # formato do rótulo de data mostra o mês\n               date_breaks=\"month\",         # rótulos de data no primeiro dia de cada mês\n               expand=c(0,0)) +             # remova o espaço em excesso\n  scale_y_continuous(\n    expand  = c(0,0))+                      # remova o espaço em excesso abaixo do eixo x\n  facet_grid(~lubridate::year(week),        # faça a faceta no ano (da coluna de classe Date (data))\n             space=\"free_x\",                \n             scales=\"free_x\",               # eixo x se adapta ao intervalo de dados (não é fixo)\n             switch=\"x\") +                  # rótulos da faceta (ano) na base\n  theme_bw() +\n  theme(strip.placement = \"outside\",                     # posicionamento do rótulo da faceta\n          strip.background = element_blank(),            # rótulo da faceta sem fundo\n          panel.grid.minor.x = element_blank(),          \n          panel.border = element_rect(colour=\"grey40\"),  # borda cinza para o painel da faceta\n          panel.spacing=unit(0,\"cm\"))+                   # sem espaço entre os painéis da faceta\n  labs(title = \"Etiquetas de ano aninhadas - pontos, sombreamento, e sem borda no rótulo\")\n\n\n\n\n\n\n\n\nAs técnicas acima foram adaptadas desta e desta postagem no stackoverflow.com.",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Curvas epidêmicas</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.pt.html#eixo-duplo",
    "href": "new_pages/epicurves.pt.html#eixo-duplo",
    "title": "32  Curvas epidêmicas",
    "section": "32.5 Eixo duplo",
    "text": "32.5 Eixo duplo\nEmbora existam discussões intensas sobre a validade de eixos duplos na comunidade de visualização de dados, muitos supervisores de epidemiologia ainda querem ver uma epicurva ou gráfico similar com um percentual sobreposto com um segundo eixo. Isto é discutido mais extensivamente na página dicas do ggplot, mas um exemplo utilizando o método de cowplot é mostrado abaixo:\n\nDois gráficos distintos são feitos, e então combinados com o pacote cowplot.\n\nOs gráficos precisam ter exatamente o mesmo eixo x (ajuste os limites). Do contrário, os dados e rótulos não serão alinhados\nCada um utiliza theme_cowplot() e um deles tem o eixo y movido para o lado direito do gráfico\n\n\n# carregue o pacote\npacman::p_load(cowplot)\n\n# Crie o primeiro gráfico de histograma de uma epicurva\n#######################################\nplot_cases &lt;- linelist %&gt;% \n  \n  # crie o gráfico com casos por semana\n  ggplot()+\n  \n  # crie o histograma\n  geom_histogram(\n    \n    mapping = aes(x = date_onset),\n    \n    # quebras das classes a cada semana, iniciando na segunda antes do primeiro caso, e indo até a segunda após o último caso\n    breaks = weekly_breaks_all)+  # vetor pré-definido de datas semanais (veja o topo da seção sobre o ggplot)\n        \n  # especifique o início e o fim do eixo da data para alinhar com o outro gráfico\n  scale_x_date(\n    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # mín/máx das quebras semanais pré-definidas do histograma\n  \n  # rótulos\n  labs(\n      y = \"Casos diários\",\n      x = \"Data de aparecimento dos sintomas\"\n    )+\n  theme_cowplot()\n\n\n# crie um segundo gráfico com o percentual de óbitos por semana\n###########################################\nplot_deaths &lt;- linelist %&gt;%                        # inicie com a linelist\n  group_by(week = floor_date(date_onset, \"week\")) %&gt;%  # crie a coluna week (semana)\n  \n  # utilize summarise para obter o percentual semanal de casos que morreram\n  summarise(n_cases = n(),\n            died = sum(outcome == \"Death\", na.rm=T),\n            pct_died = 100*died/n_cases) %&gt;% \n  \n  # inicie o gráfico\n  ggplot()+\n  \n  # linha com o percentual semanal de óbitos\n  geom_line(                                # crie um linha com o percentual de mortos\n    mapping = aes(x = week, y = pct_died),  # especifique o y-altura como sendo da coluna pct_died\n    stat = \"identity\",                      # ajuste a altura da linha para o valor na coluna pct_death, e não a quantidade de linhas (que é o padrão)\n    size = 2,\n    color = \"black\")+\n  \n  # Mesmos limites no eixo de datas como no outro gráfico - alinhamento perfeito\n  scale_x_date(\n    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # mín/máx das quebras semanais pré-definidas do histograma\n  \n  \n  # ajustes no eixo y\n  scale_y_continuous(                # ajuste o eixo y\n    breaks = seq(0,100, 10),         # ajuste os intervalos de quebra do eixo da porcentagem\n    limits = c(0, 100),              # ajuste a extensão do eixo de porcentagem\n    position = \"right\")+             # mova o eixo de porcentagem para a direita\n  \n  # rótulo do eixo y, sem rótulo no eixo x\n  labs(x = \"\",\n       y = \"Percentual de óbitos\")+      # rótulo do eixo de porcentagem\n  \n  theme_cowplot()                   # adicione isto para unir os dois gráficos\n\nAgora, use o cowplot para sobrepor os dois gráficos. A atenção precisa ser dada ao alinhamento do eixo x, ao lado do eixo y, e ao uso de theme_cowplot().\n\naligned_plots &lt;- cowplot::align_plots(plot_cases, plot_deaths, align=\"hv\", axis=\"tblr\")\nggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Curvas epidêmicas</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.pt.html#incidência-acumulada",
    "href": "new_pages/epicurves.pt.html#incidência-acumulada",
    "title": "32  Curvas epidêmicas",
    "section": "32.6 Incidência acumulada",
    "text": "32.6 Incidência acumulada\nNota: Caso esteja utilizando o pacote incidence2, veja a seção sobre como você pode produzir incidência acumulada com uma simples função. Esta página irá ensinar como calcular a incidência acumulada e fazer um gráfico dela utilizando ggplot().\nSe estiver iniciando com os casos em uma linelist, crie uma nova coluna contendo o número acumulado de casos por dia em um surto utilizando a função cumsum() do R base:\n\ncumulative_case_counts &lt;- linelist %&gt;% \n  count(date_onset) %&gt;%                # contagem de linhas por dia (salvo na coluna \"n\")\n  mutate(                         \n    cumulative_cases = cumsum(n)       # nova coluna com a quantidade de linhas acumuladas em cada data\n    )\n\nAs primeiras 10 linhas são mostradas abaixo:\n\n\n\n\n\n\nEsta coluna de casos acumulados pode então ser utilizada para fazer um gráfico com a data de início dos sintomas, date_onset, utilizando geom_line():\n\nplot_cumulative &lt;- ggplot()+\n  geom_line(\n    data = cumulative_case_counts,\n    aes(x = date_onset, y = cumulative_cases),\n    size = 2,\n    color = \"blue\")\n\nplot_cumulative\n\n\n\n\n\n\n\n\nEla também pode ser sobreposta em uma epicurva, com dois eixos, utilizando o método cowplot descrito acima e na página dicas do ggplot:\n\n# carregue o pacote\npacman::p_load(cowplot)\n\n# crie primeiro o histograma de uma epicurva\nplot_cases &lt;- ggplot()+\n  geom_histogram(          \n    data = linelist,\n    aes(x = date_onset),\n    binwidth = 1)+\n  labs(\n    y = \"Casos diários\",\n    x = \"Data de início dos sintomas\"\n  )+\n  theme_cowplot()\n\n# crie um segundo gráfico com uma linha de casos acumulados\nplot_cumulative &lt;- ggplot()+\n  geom_line(\n    data = cumulative_case_counts,\n    aes(x = date_onset, y = cumulative_cases),\n    size = 2,\n    color = \"blue\")+\n  scale_y_continuous(\n    position = \"right\")+\n  labs(x = \"\",\n       y = \"Casos acumulados\")+\n  theme_cowplot()+\n  theme(\n    axis.line.x = element_blank(),\n    axis.text.x = element_blank(),\n    axis.title.x = element_blank(),\n    axis.ticks = element_blank())\n\nAgora, use cowplot para sobrepor os dois gráficos. Atenção ao alinhamento do eixo x, o lado do eixo y, e o uso de theme_cowplot().\n\naligned_plots &lt;- cowplot::align_plots(plot_cases, plot_cumulative, align=\"hv\", axis=\"tblr\")\nggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Curvas epidêmicas</span>"
    ]
  },
  {
    "objectID": "new_pages/epicurves.pt.html#recursos",
    "href": "new_pages/epicurves.pt.html#recursos",
    "title": "32  Curvas epidêmicas",
    "section": "32.7 Recursos",
    "text": "32.7 Recursos",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Curvas epidêmicas</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.pt.html",
    "href": "new_pages/age_pyramid.pt.html",
    "title": "33  Pirâmides demográficas e escalas Likert",
    "section": "",
    "text": "33.1 Preparação",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Pirâmides demográficas e escalas Likert</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.pt.html#preparação",
    "href": "new_pages/age_pyramid.pt.html#preparação",
    "title": "33  Pirâmides demográficas e escalas Likert",
    "section": "",
    "text": "Carregar pacotes\nEste pedaço de código mostra o carregamento de pacotes necessários para as análises. Neste manual, enfatizamos p_load() de pacman, que instala o pacote se necessário e o carrega para uso. Você também pode carregar pacotes instalados com library() de R base. Veja a página em Introdução ao R para mais informações sobre pacotes R.\n\npacman::p_load(rio, # para importar dados\n               here, # para localizar arquivos\n               tidyverse, # para limpar, manipular e plotar os dados (inclui o pacote ggplot2)\n               apyramid, # um pacote dedicado à criação de pirâmides de idades\n               janitor, # tabelas e dados de limpeza\n               stringr) # trabalhando com strings para títulos, legendas, etc.\n\n\n\nImportar dados\nPara começar, importamos a lista (linelist) limpa de casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar,  clique para baixar o linelist “clean”  (como um arquivo .rds). Importe dados com a função import() do pacote rio (ele lida com muitos tipos de arquivo como .xlsx, .csv, .rds - veja a página Importar e exportar para detalhes).\n\n# import case linelist \nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nAs primeiras 50 linhas da linelist são exibidas abaixo.\n\n\n\n\n\n\n\n\nLimpeza\nPara fazer uma pirâmide demográfica tradicional de idade / sexo, os dados devem primeiro ser limpos das seguintes maneiras:\n\nA coluna de gênero deve ser limpa.\n\nDependendo do seu método, a idade deve ser armazenada como um número ou em uma coluna de categoria de idade.\n\nSe estiver usando categorias de idade, os valores da coluna devem ser corrigidos em ordem, seja alfanumérico padrão ou definido intencionalmente pela conversão para o fator de classe.\nAbaixo, usamos tabyl() de janitor para inspecionar as colunas gender e age_cat5.\n\nlinelist %&gt;% \n  tabyl(age_cat5, gender)\n\n age_cat5   f   m NA_\n      0-4 640 416  39\n      5-9 641 412  42\n    10-14 518 383  40\n    15-19 359 364  20\n    20-24 305 316  17\n    25-29 163 259  13\n    30-34 104 213   9\n    35-39  42 157   3\n    40-44  25 107   1\n    45-49   8  80   5\n    50-54   2  37   1\n    55-59   0  30   0\n    60-64   0  12   0\n    65-69   0  12   1\n    70-74   0   4   0\n    75-79   0   0   1\n    80-84   0   1   0\n      85+   0   0   0\n     &lt;NA&gt;   0   0  86\n\n\nTambém executamos um histograma rápido na coluna idade para garantir que esteja limpo e classificado corretamente:\n\nhist(linelist$age)",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Pirâmides demográficas e escalas Likert</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.pt.html#pacote-apyramid",
    "href": "new_pages/age_pyramid.pt.html#pacote-apyramid",
    "title": "33  Pirâmides demográficas e escalas Likert",
    "section": "33.2 Pacote apyramid",
    "text": "33.2 Pacote apyramid\nO pacote apyramid é um produto do projeto R4Epis. Você pode ler mais sobre este pacote aqui. Ele permite que você crie rapidamente uma pirâmide de idades. Para situações mais sutis, veja a seção abaixo usando ggplot(). Você pode ler mais sobre o pacote apyramid em sua página de Ajuda inserindo ?Age_pyramid em seu console R.\n\nDados linelist\nUsando o conjunto de dados linelist limpo, podemos criar uma pirâmide de idade com um simples comando age_pyramid(). Neste comando:\n\nO argumento data = é definido como o quadro de dados (data frame) linelist\n\nO argumento age_group = (para o eixo y) é definido como o nome da coluna categórica de idade (entre aspas)\n\nO argumento split_by = (para o eixo x) é definido para a coluna de gênero\n\n\n\n\n\n\n\n\n\n\nA pirâmide pode ser exibida com a porcentagem de todos os casos no eixo x, em vez de contagens, incluindo proporcional = VERDADEIRO.\n\n\n\n\n\n\n\n\n\nAo usar o pacote agepyramid, se a coluna split_by for binária (por exemplo, masculino / feminino ou sim / não), o resultado aparecerá como uma pirâmide. No entanto, se houver mais de dois valores na coluna split_by (não incluindo NA), a pirâmide aparecerá como um gráfico de barra facetada com barras cinza no “fundo” indicando o intervalo dos dados não facetados para aquele grupo de idade. Nesse caso, os valores de split_by = aparecerão como rótulos na parte superior de cada painel de faceta. Por exemplo, abaixo está o que ocorre se split_by = é atribuído à coluna hospital.\n\n\n\n\n\n\n\n\n\n\nValores faltantes\nAs linhas que têm valores faltantes NA nas colunas split_by = ou age_group =, se codificadas como NA, não irão acionar o facetamento mostrado acima. Por padrão, essas linhas não serão mostradas. No entanto, você pode especificar que eles apareçam em um gráfico de barras adjacente e como uma faixa etária separada no topo, especificando na.rm = FALSE.\n\n\n\n\n\n\n\n\n\n\n\nProporções, cores e estética\nPor padrão, as barras exibem contagens (não %), uma linha intermediária tracejada para cada grupo é mostrada e as cores são verde / roxo. Cada um desses parâmetros pode ser ajustado, conforme mostrado abaixo:\nVocê também pode adicionar comandos ggplot() adicionais ao gráfico usando a sintaxe ggplot() “+” padrão, como temas estéticos e ajustes de rótulo:\n\n\n\n\n\n\n\n\n\n\n\n\nDados agregados\nOs exemplos acima assumem que seus dados estão em um formato de linelist, com cada linha correspondendo a uma observação. Se seus dados já estão agregados em contagens por categoria de idade, você ainda pode usar o pacote apyramid, conforme mostrado abaixo.\nPara demonstração, agregamos os dados da linelist em contagens por categoria de idade e sexo, em um formato “amplo” ou “wide”. Isso simulará como se seus dados estivessem em contagens para começar. Saiba mais sobre agrupamento de dados e pivoteamento de dados em suas respectivas páginas.\n… o que faz com que o conjunto de dados tenha a seguinte aparência: com colunas para categoria de idade e contagens masculinas, contagens femininas e contagens ausentes.\n\n\n\n\n\n\nPara configurar esses dados para a pirâmide de idade, vamos organizar os dados no formato “longo” com a função pivot_longer() de dplyr. Isso ocorre porque ggplot() geralmente prefere dados “longos”, e apyramid está usando ggplot().\n\n\n\n\n\n\nEm seguida, use os argumentos split_by = e count = de age_pyramid() para especificar as respectivas colunas nos dados:\n\n\n\n\n\n\n\n\n\nObserve acima, que a ordem dos fatores de “m” e “f” é diferente (pirâmide invertida). Para ajustar a ordem, você deve redefinir o gênero nos dados agregados como um fator e ordenar os níveis conforme desejado. Veja a página Fatores.",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Pirâmides demográficas e escalas Likert</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.pt.html#demo_pyr_gg",
    "href": "new_pages/age_pyramid.pt.html#demo_pyr_gg",
    "title": "33  Pirâmides demográficas e escalas Likert",
    "section": "33.3 ggplot()",
    "text": "33.3 ggplot()\nUsar ggplot() para construir sua pirâmide de idade permite mais flexibilidade, mas requer mais esforço e compreensão de como ggplot() funciona. Também é mais fácil cometer erros acidentalmente.\nPara usar ggplot() para fazer pirâmides demográficas, você cria dois gráficos de barra (um para cada gênero), converte os valores em um gráfico para negativo e, finalmente, vira os eixos x e y para exibir os gráficos de barra verticalmente, suas bases encontro no meio da trama.\n\nPreparação\nEssa abordagem usa a coluna numérica idade, não a coluna categórica de age_cat5. Portanto, vamos verificar se a classe desta coluna é realmente numérica.\n\nclass(linelist$age)\n\n[1] \"numeric\"\n\n\nVocê poderia usar a mesma lógica abaixo para construir uma pirâmide de dados categóricos usando geom_col() ao invés de geom_histogram().\n\n\n\nConstruindo o gráfico\nPrimeiro, entenda que para fazer essa pirâmide usando ggplot() a abordagem é a seguinte:\n\nDentro de ggplot(), crie dois histogramas usando a coluna numérica de idade. Crie um para cada um dos dois valores de agrupamento (neste caso, gêneros masculino e feminino). Para fazer isso, os dados de cada histograma são especificados em seus respectivos comandos geom_histogram(), com os respectivos filtros aplicados à linelist.\nUm gráfico terá valores de contagem positivos, enquanto o outro terá suas contagens convertidas em valores negativos - isso cria a “pirâmide” com o valor 0 no meio do gráfico. Os valores negativos são criados usando um termo especial do ggplot2 ..count.. e multiplicando por -1.\nO comando coord_flip() muda os eixos X e Y, resultando na viragem dos gráficos na vertical e na criação da pirâmide.\nPor último, os rótulos de valor do eixo de contagem devem ser alterados para que apareçam como contagens “positivas” em ambos os lados da pirâmide (apesar dos valores subjacentes em um lado serem negativos).\n\nUma versão simples disso, usando geom_histogram(), está abaixo:\n\n\n\n\n\n\n\n\n\n **_ PERIGO: _** Se os limites do seu eixo de contagem forem definidos muito baixos e uma barra de contagem ultrapassá-los, a barra desaparecerá totalmente ou será reduzida artificialmente ! Observe isso ao analisar dados que são atualizados rotineiramente. Evite que os limites do eixo de contagem se ajustem automaticamente aos seus dados, conforme abaixo. \nHá muitas coisas que você pode alterar / adicionar a esta versão simples, incluindo:\n\nAjuste automático da escala do eixo de contagem aos seus dados (evite os erros discutidos no aviso abaixo)\n\nEspecifique manualmente as cores e rótulos de legenda\n\nConverta contagens em porcentagens\nPara converter contagens em porcentagens (do total), faça isso em seus dados antes de plotar. Abaixo, temos as contagens de idade e gênero, então ungroup(), e então mutate() para criar novas colunas de porcentagem. Se você quiser porcentagens por gênero, pule a etapa de desagrupamento.\nÉ importante ressaltar que salvamos os valores máximos e mínimos para que saibamos quais devem ser os limites da escala. Eles serão usados no comando ggplot() abaixo.\n\nmax_per &lt;- max(pyramid_data$percent, na.rm = T)\nmin_per &lt;- min(pyramid_data$percent, na.rm = T)\n\nmax_per\n\n[1] 10.9\n\nmin_per\n\n[1] -7.1\n\n\nFinalmente, fazemos o ggplot() nos dados de porcentagem. Especificamos scale_y_continuous() para estender os comprimentos predefinidos em cada direção (positivo e “negativo”). Usamos floor() e ceiling() para arredondar decimais na direção apropriada (para baixo ou para cima) para o lado do eixo.\n\n\n\n\n\n\n\n\n\n\n\n\nCompare com a linha de base\nCom a flexibilidade de ggplot(), você pode ter uma segunda camada de barras no fundo que representam a pirâmide populacional “verdadeira” ou “linha de base”. Isso pode fornecer uma boa visualização para comparar o observado com a linha de base.\nImporte e visualize os dados populacionais (consulte a página Baixar manual e dados):\n\n# importar os dados demográficos da população\npop &lt;- rio::import(\"country_demographics.csv\")\n\n\n\n\n\n\n\nPrimeiro, algumas etapas de gerenciamento de dados:\nAqui gravamos a ordem das categorias de idade que queremos que apareçam. Devido a algumas peculiaridades na forma como o ggplot() é implementado, neste cenário específico é mais fácil armazená-los como um vetor de caracteres e usá-los posteriormente na função de gráfico.\n\n# registrar níveis corretos de gatos com idade\nage_levels &lt;- c(\"0-4\",\"5-9\", \"10-14\", \"15-19\", \"20-24\",\n                \"25-29\",\"30-34\", \"35-39\", \"40-44\", \"45-49\",\n                \"50-54\", \"55-59\", \"60-64\", \"65-69\", \"70-74\",\n                \"75-79\", \"80-84\", \"85+\")\n\nCombine a população e os dados do caso por meio da função dplyr bind_rows():\n\nPrimeiro, certifique-se de que eles tenham os mesmos nomes de coluna, valores de categorias de idade e valores de gênero\n\nFaça com que tenham a mesma estrutura de dados: colunas de categoria de idade, sexo, contagens e porcentagem do total\n\nUna-os, um em cima do outro (bind_rows())\n\nRevise o conjunto de dados de população alterado\n\n\n\n\n\n\nAgora implemente o mesmo para a linelist do caso. Um pouco diferente porque começa com linhas de caso, não conta.\nRevise o conjunto de dados de caso alterado\n\n\n\n\n\n\nAgora os dois data frames estão combinados, um em cima do outro (eles têm os mesmos nomes de coluna). Podemos “nomear” cada frame de dados e usar o argumento .id = para criar uma nova coluna “data_source” que indicará de qual frame de dados cada linha se originou. Podemos usar esta coluna para filtrar no ggplot().\nArmazene os valores percentuais máximos e mínimos, usados na função de plotagem para definir a extensão da plotagem (e não encurte nenhuma barra!)\n\n# Defina a extensão do eixo percentual, usado para os limites do gráfico\nmax_per &lt;- max(pyramid_data$percent, na.rm = T)\nmin_per &lt;- min(pyramid_data$percent, na.rm = T)\n\nAgora o gráfico é feito com ggplot():\n\nUm gráfico de barras de dados populacionais (barras mais largas e transparentes)\nUm gráfico de barras de dados do caso (barras pequenas e mais sólidas)",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Pirâmides demográficas e escalas Likert</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.pt.html#escala-de-likert",
    "href": "new_pages/age_pyramid.pt.html#escala-de-likert",
    "title": "33  Pirâmides demográficas e escalas Likert",
    "section": "33.4 Escala de Likert",
    "text": "33.4 Escala de Likert\nAs técnicas usadas para fazer uma pirâmide populacional com ggplot() também podem ser usadas para fazer gráficos de dados de pesquisa em escala Likert.\nImporte os dados (consulte a página Baixar manual e dados se desejar).\n\n# importar os dados de resposta da pesquisa likert\nlikert_data &lt;- rio::import(\"likert_data.csv\")\n\nComece com dados parecidos com estes, com uma classificação categórica de cada entrevistado (status) e suas respostas a 8 perguntas em uma escala do tipo Likert de 4 pontos (“Muito ruim”, “Ruim”, “Bom”, “Muito bom”).\n\n\n\n\n\n\nPrimeiro, algumas etapas de gerenciamento de dados:\n\nDinamizar os dados por mais tempo\n\nCrie uma nova coluna direção dependendo se a resposta foi geralmente “positiva” ou “negativa”\n\nDefina a ordem do nível de fator para a coluna status e a coluna Resposta\n\nArmazene o valor de contagem máxima para que os limites do gráfico sejam apropriados\n\nAgora faça o gráfico. Como nas pirâmides de idades acima, estamos criando dois gráficos de barra e invertendo os valores de um deles para negativo.\nUsamos geom_bar() porque nossos dados são uma linha por observação, não contagens agregadas. Usamos o termo especial ggplot2 ..count.. em um dos gráficos de barra para inverter os valores negativos (* -1) e definimos position = \"stack\" para que os valores sejam empilhados no topo de cada um.",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Pirâmides demográficas e escalas Likert</span>"
    ]
  },
  {
    "objectID": "new_pages/age_pyramid.pt.html#recursos",
    "href": "new_pages/age_pyramid.pt.html#recursos",
    "title": "33  Pirâmides demográficas e escalas Likert",
    "section": "33.5 Recursos",
    "text": "33.5 Recursos\nDocumentação do pacote apyramid",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Pirâmides demográficas e escalas Likert</span>"
    ]
  },
  {
    "objectID": "new_pages/heatmaps.pt.html",
    "href": "new_pages/heatmaps.pt.html",
    "title": "34  Gráficos de calor",
    "section": "",
    "text": "34.1 Preparação",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Gráficos de calor</span>"
    ]
  },
  {
    "objectID": "new_pages/heatmaps.pt.html#preparação",
    "href": "new_pages/heatmaps.pt.html#preparação",
    "title": "34  Gráficos de calor",
    "section": "",
    "text": "Carregar pacotes\nEste pedaço de código mostra o carregamento de pacotes necessários para as análises. Neste manual, enfatizamos p_load() do pacman, que instala o pacote se necessário e o carrega para uso. Você também pode carregar pacotes instalados com library() do R base. Veja a página em Introdução ao R para mais informações sobre pacotes R.\n\npacman :: p_load(\n  tidyverse, # manipulação e visualização de dados\n  rio, # importando dados \n  lubridate # trabalhando com datas\n  )\n\nConjuntos de dados\nEsta página utiliza a lista de casos de um surto simulado para a seção de matriz de transmissão e um conjunto de dados separado de contagens diárias de casos de malária por instalação para a seção de rastreamento de métricas. Eles são carregados e limpos em suas seções individuais.",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Gráficos de calor</span>"
    ]
  },
  {
    "objectID": "new_pages/heatmaps.pt.html#matriz-de-transmissão",
    "href": "new_pages/heatmaps.pt.html#matriz-de-transmissão",
    "title": "34  Gráficos de calor",
    "section": "34.2 Matriz de transmissão",
    "text": "34.2 Matriz de transmissão\nOs quadrados de um mapa de calor podem ser úteis para visualizar matrizes. Um exemplo é exibir “quem infectou quem” em um surto. Isso pressupõe que você tenha informações sobre os eventos de transmissão.\nObserve que a página Rastreamento de contato contém outro exemplo de criação de uma matriz de contato de do tipo blocos/quadrados térmicos, usando um conjunto de dados diferente (talvez até mais simples) onde as idades dos casos e suas fontes estão perfeitamente alinhadas na mesma linha de observação do quadro de dados (data frame). Esses mesmos dados são usados para fazer um mapa de densidade na página dicas do ggplot. O exemplo abaixo começa com uma linelist de caso e, portanto, envolve uma manipulação considerável de dados antes de obter um data frame que possa ser utilizado em um gráfico. Portanto, existem muitos cenários para escolher…\nComeçamos com a lista de casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar,  clique para baixar o “clean” linelist  (as .rds file). Importe dados com a função import() do pacote rio (ele lida com muitos tipos de arquivo como .xlsx, .csv, .rds - veja a página Importar e exportar para detalhes).\nAs primeiras 50 linhas da linelist são mostradas abaixo para demonstração:\n\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nNesta linelist:\n\nExiste uma linha por caso, conforme identificado por case_id\n\nExiste uma coluna posterior infector que contém ocase_id do infectador, que também é um caso na linelist\n\n\n\n\n\n\n\n\nPreparação\nObjetivo: Precisamos alcançar um data frame de estilo “longo” que contenha uma linha por rota de transmissão de idade a idade possível, com uma coluna com valores numéricos contendo a proporção dessa linha de todos os eventos de transmissão observados na linelist.\nIsso exigirá várias etapas de manipulação de dados para alcançar:\n\nCriar um data frame dos casos\nPara começar, criamos um data frame dos casos, suas idades e seus infectantes - chamamos o data frame de idades_de_caso. As primeiras 50 linhas são exibidas abaixo.\n\ncase_ages &lt;- linelist%&gt;% \n  select(case_id, infector, age_cat)%&gt;% \n  rename(\"case_age_cat\" = \"age_cat\")\n\n\n\n\n\n\n\n\n\nCriar um data frame de infectantes\nA seguir, criamos um data frame dos infectantes - no momento, ele consiste em uma única coluna. Estas são as IDs de infecção da linelist. Nem todos os casos têm um infectante conhecido, por isso removemos os valores ausentes. As primeiras 50 linhas são exibidas abaixo.\n\ninfectors &lt;- linelist %&gt;% \n  select(infector) %&gt;% \n  drop_na(infector)\n\n\n\n\n\n\n\nEm seguida, usamos junções para obter as idades dos infectantes. Isso não é simples, pois na linelist, as idades do infectador não são listadas como tal. Alcançamos esse resultado juntando a ‘linelist’ dos casos a dos infectantes. Começamos com os infectantes e fazemos um left_join() ( ou seja, o adicionamos) com o linelist, de forma que o data frame de infectates seja a “linha de base” e a coluna infector id do lado esquerdo se junte à coluna case_id na linelist a direita.\nAssim, os dados do registro do caso do infectante na linelist (incluindo a idade) são adicionados à linha do infectante. As 50 primeiras linhas são exibidas abaixo.\n\ninfector_ages &lt;- infectors%&gt;% # começam com infectores\n  left_join(# adiciona os dados da linelist para cada infectador  \n    linelist,\n    by = c(\"infector\" = \"case_id\"))%&gt;% # corresponde ao infector às suas informações como um caso\n  select(infector, age_cat)%&gt;% # mantém apenas as colunas de interesse\n  rename(\"infector_age_cat\" = \"age_cat\")   # rename for clarity\n\n\n\n\n\n\n\nEm seguida, combinamos os casos e suas idades com os infectantes e suas idades. Cada um desses data frame tem a coluna infector, então ela é usada para a junção. As primeiras linhas são exibidas abaixo:\n\nages_complete &lt;- case_ages%&gt;%  \n  left_join(\n    infector_ages,\n    by = \"infector\")%&gt;% # utilizando a coluna `infector`coomo chave para a junção\n  drop_na() # excluir linhas com qualquer dado faltante\n\nWarning in left_join(., infector_ages, by = \"infector\"): Detected an unexpected many-to-many relationship between `x` and `y`.\nℹ Row 1 of `x` matches multiple rows in `y`.\nℹ Row 6 of `y` matches multiple rows in `x`.\nℹ If a many-to-many relationship is expected, set `relationship =\n  \"many-to-many\"` to silence this warning.\n\n\n\n\n\n\n\n\nAbaixo, uma tabulação cruzada simples de contagens entre os casos e os grupos de idade dos infectantes. Rótulos foram adicionadas para maior clareza.\n\ntable(cases = ages_complete$case_age_cat,\n      infectors = ages_complete$infector_age_cat)\n\n       infectors\ncases   0-4 5-9 10-14 15-19 20-29 30-49 50-69 70+\n  0-4   105 156   105   114   143   117    13   0\n  5-9   102 132   110   102   117    96    12   5\n  10-14 104 109    91    79   120    80    12   4\n  15-19  85 105    82    39    75    69     7   5\n  20-29 101 127   109    80   143   107    22   4\n  30-49  72  97    56    54    98    61     4   5\n  50-69   5   6    15     9     7     5     2   0\n  70+     1   0     2     0     0     0     0   0\n\n\nPodemos converter esta tabela em um dataframe com data.frame() do R base, que também converte automaticamente para o formato “longo”, que é desejado para o ggplot(). As primeiras linhas são mostradas abaixo.\n\nlong_counts &lt;- data.frame(table(\n    cases = ages_complete$case_age_cat,\n    infectors = ages_complete$infector_age_cat))\n\n\n\n\n\n\n\nAgora fazemos o mesmo, mas aplicamos prop.table() do R base para a tabela de forma que, em vez de contagens, obtenhamos proporções do total. As primeiras 50 linhas são mostradas abaixo.\n\nlong_prop &lt;- data.frame(prop.table(table(\n    cases = ages_complete$case_age_cat,\n    infectors = ages_complete$infector_age_cat)))\n\n\n\n\n\n\n\n\n\n\nCriar gráfico de calor\nAgora, finalmente, podemos criar o gráfico de calor com o pacote ggplot2, usando a função geom_tile(). Veja a página de dicas do ggplot para aprender mais extensivamente sobre as escalas de cor / preenchimento, especialmente a função scale_fill_gradient().\n\nNa estética aes() de geom_tile() defina x e y como a idade do caso e idade infectante\n\nTambém em aes() defina o argumento fill = para a coluna Freq - este é o valor que será convertido para uma cor de bloco\n\nDefina uma cor de escala com scale_fill_gradient() - você pode especificar as cores altas / baixas\n\nObserve que scale_color_gradient() é diferente! Neste caso, você quer o preenchimento\n\n\nComo a cor é feita por meio de “preenchimento”, você pode usar o argumento fill = em labs() para alterar o título da legenda\n\n\nggplot(data = long_prop) + # usa um dataframe no formato longo, com proporções como Freq\n  geom_tile(# visualizar em quadrados\n    aes(\n      x = cases, # eixo x é a idade do caso\n      y = infectors, # eixo y é a idade do infectador\n      fill = Freq)) + # cor de cada quadrado é a coluna Freq nos dados\n  scale_fill_gradient(# ajusta a cor de preenchimento dos quadrados\n    low = \"blue\",\n    high = \"orange\")+\n  labs(# rótulos\n    x = \"Idade do caso\",\n    y = \"Idade do infectador\",\n    title = \"Quem infectou quem\",\n    subtitle = \"Matriz de frequência de eventos de transmissão\",\n    fill = \"Proporção de todos os eventos de \\ ntranmsission\" # título da legenda\n  )",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Gráficos de calor</span>"
    ]
  },
  {
    "objectID": "new_pages/heatmaps.pt.html#métricas-de-relatório-ao-longo-do-tempo",
    "href": "new_pages/heatmaps.pt.html#métricas-de-relatório-ao-longo-do-tempo",
    "title": "34  Gráficos de calor",
    "section": "34.3 Métricas de relatório ao longo do tempo",
    "text": "34.3 Métricas de relatório ao longo do tempo\nFrequentemente, na saúde pública, um objetivo é avaliar as tendências ao longo do tempo para muitas entidades (instalações, jurisdições, etc.). Uma maneira de visualizar essas tendências ao longo do tempo é um gráfico de calor em que o eixo x é o tempo e no eixo y estão as várias entidades.\n\nPreparação\nComeçamos importando um conjunto de dados de relatórios diários da malária de muitos estabelecimentos. Os relatórios contêm uma data, província, distrito e contagens de malária. Consulte a página em Baixar manual e dados para obter informações sobre como baixar esses dados. Abaixo estão as primeiras 30 linhas:\n\nfacility_count_data &lt;- import(\"malaria_facility_count_data.rds\")\n\n\n\n\n\n\n\n\nAgregar e resumir\nO objetivo neste exemplo é transformar as contagens diárias de casos de malária total dos estabelecimentos (visto na guia anterior) em estatísticas resumidas semanais de desempenho de relatórios das instalações - neste caso a proporção de dias por semana que a instalação/estabelecimento relatou quaisquer dados. Para este exemplo, mostraremos dados apenas para Spring District.\nPara conseguir isso, faremos as seguintes etapas de gerenciamento de dados:\n\nFiltre os dados conforme apropriado (por local, data)\n\nCrie uma coluna de semana usando floor_date() do pacote lubridate\n\nEsta função retorna a data de início da semana de uma determinada data, usando uma data de início especificada de cada semana (por exemplo, “Segundas”)\n\n\nOs dados são agrupados pelas colunas “local” e “semana” para criar unidades de análise de “semana-estabelecimento”\n\nA função resumir() cria novas colunas para refletir as estatísticas de resumo por grupo de semana-estabelecimento:\n\nNúmero de dias por semana (7 - um valor estático)\n\nNúmero de relatórios recebidos da semana-estabelecimento (pode ser mais de 7!)\n\nSoma dos casos de malária relatados pela semana-estabelecimento (apenas por interesse)\n\nNúmero de dias únicos na semana-estabelecimento para os quais há dados relatados\n\nPorcentagem dos 7 dias por semana-estabelecimento para os quais os dados foram relatados\n\n\nOdata frame é unido com right_join() a uma lista abrangente de todas as combinações possíveis de semana-estabelecimento, para tornar o conjunto de dados completo. A matriz de todas as combinações possíveis é criada aplicando expand() a essas duas colunas dodata frame, como está naquele momento na cadeia de pipes (representado por .). Como um right_join() é usado, todas as linhas no data frame expand() são mantidas e adicionadas a agg_weeks se necessário. Essas novas linhas aparecem com valores resumidos NA (ausentes).\n\nAbaixo, demonstramos passo a passo:\n\n# Crie um conjunto de dados de resumo semanal\nagg_weeks &lt;- facility_count_data%&gt;% \n  \n  # filtrar os dados conforme apropriado\n  filter(\n    District == \"Spring\",\n    data_date &lt; as.Date(\"2020-08-01\")) \n\nAgora o conjunto de dados tem nrow(agg_weeks) linhas, quando anteriormente tinha nrow(facility_count_data).\nEm seguida, criamos uma coluna semana refletindo a data de início da semana para cada registro. Isso é obtido com o pacote lubridate e a função floor_date(), que é definida como “semana” e para as semanas com início às segundas-feiras (dia 1 da semana - domingos seria 7). As linhas superiores são mostradas abaixo.\n\nagg_weeks &lt;- agg_weeks %&gt;% \n  # Crie a coluna da semana a partir de data_date\n  mutate(\n    week = lubridate::floor_date(# criar uma nova coluna de semanas\n      data_date,  # date\n      unit = \"week\", # dá o início da semana\n      week_start = 1)) # semanas para começar às segundas-feiras \n\nA nova coluna da semana pode ser vista na extremidade direita do quadro de dados\n\n\n\n\n\n\nAgora agrupamos os dados em semana-instalação e os resumimos para produzir estatísticas por semana-instalação. Consulte a página em Tabelas descritivas para dicas. O próprio agrupamento não altera o quadro de dados, mas impacta como as estatísticas de resumo subsequentes são calculadas.\nAs linhas superiores são mostradas abaixo. Observe como as colunas mudaram completamente para refletir as estatísticas de resumo desejadas. Cada linha reflete uma semana-instalação.\n\nagg_weeks &lt;- agg_weeks %&gt;%   \n\n  # Grupo em semana-estabelecimento\n  group_by(location_name, week) %&gt;%\n  \n  # Crie colunas de estatísticas de resumo nos dados agrupados\n  summarise(\n    n_days = 7, # 7 dias por semana           \n    n_reports = dplyr::n(), # número de relatórios recebidos por semana (pode ser&gt; 7)\n    malaria_tot = sum (malaria_tot, na.rm = T), # total de casos de malária relatados\n    n_days_reported = length(unique (data_date)), # número de dias únicos de relatórios por semana\n    p_days_reported = round(100*(n_days_reported / n_days))) # por cento de relatórios de dias\n\n\n\n\n\n\n\nPor fim, executamos o comando abaixo para garantir que TODAS as semanas-estabelecimento possíveis estejam presentes nos dados, mesmo que não existissem antes.\nEstamos usando um right_join() em si mesmo (o conjunto de dados é representado por “.”), Mas foi expandido para incluir todas as combinações possíveis das colunas semana e localização_nome. Veja a documentação sobre a função expand() na página Pivoteando Dados. Antes de executar este código, o conjunto de dados contém linhas nrow(agg_weeks).\n\n# Crie um dataframe com todas as possibilidades de combinação semana-estabelecimento\nexpanded_weeks &lt;- agg_weeks%&gt;% \n  tidyr::expand(week) # expanda data frame para incluir todas as combinações possíveis de semana-estabelecimento\n\nAqui está expanded_weeks:\n\n\n\n\n\n\nAntes de executar este código, agg_weeks contém linhas nrow(agg_weeks).\n\n# Use uma junção à direita com a lista expandida semana-estabelecimento para preencher as lacunas que faltam nos dados\nagg_weeks &lt;- agg_weeks %&gt;%      \n  right_join(expanded_weeks)%&gt;% # Certifique-se de que todas as combinações possíveis de estabelecimento-semana apareçam nos dados\n  mutate(p_days_reported = replace_na(p_days_reported, 0)) # converter valores ausentes para 0                           \n\nJoining with `by = join_by(location_name, week)`\n\n\nDepois de executar este código, agg_weeks contém linhas nrow(agg_weeks).\n\n\n\n\nCriar gráfico de calor\nO ggplot() é feito usando geom_tile() do pacote ggplot2:\n\nSemanas no eixo x são transformadas em datas, permitindo o uso de scale_x_date()\n\nlocation_name no eixo y mostrará todos os nomes de estabelecimentos\nO fill é p_days_reported, o desempenho para aquela semana-estabelecimento(numérico)\n\nscale_fill_gradient() é usado no preenchimento numérico, especificando cores para alto, baixo e NA\n\nscale_x_date() é usado no eixo x especificando rótulos a cada 2 semanas e seu formato\n\nTemas de exibição e rótulos podem ser ajustados conforme necessário\n\n\n\n\nBásico\nUm gráfico de calor básico é produzido abaixo, usando as cores e escalas padrão. Como explicado acima, dentro de aes() para geom_tile() você deve fornecer uma coluna do eixo x, coluna do eixo y e uma coluna para o fill =. O preenchimento é o valor numérico apresentado como cor do bloco.\n\nggplot(data = agg_weeks)+\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported))\n\n\n\n\n\n\n\n\n\n\nGráfico limpo\nPodemos fazer esse gráfico parecer melhor adicionando funções ggplot2 adicionais, conforme mostrado abaixo. Veja a página em dicas do ggplot para detalhes.\n\nggplot(data = agg_weeks)+ \n  \n  # mostrar dados como quadrados\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported),      \n    color = \"white\") + # linhas de grade brancas\n  \n  scale_fill_gradient(\n    low = \"orange\",\n    high = \"darkgreen\",\n    na.value = \"grey80\")+\n  \n  # eixo de data\n  scale_x_date(\n    expand = c(0,0), # remove espaço extra nas laterais\n    date_breaks = \"2 weeks\", # rótulos a cada 2 semanas\n    date_labels = \"%d\\n%b\") + # formato é dia após mês (\\n em nova linha)\n  \n  # temas estéticos\n  theme_minimal() + # fundo simplificado\n  \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1, \"cm\"), # altura da chave da legenda\n    legend.key.width = grid::unit(0.6, \"cm\"), # largura da chave da legenda\n    \n    axis.text.x = element_text(size=12),              # axis text size\n    axis.text.y = element_text(vjust = 0.2), # alinhamento do texto do eixo\n    axis.ticks = element_line(size=0.4),               \n    axis.title = element_text(size = 12, face = \"bold\"), # tamanho do título do eixo e negrito\n    \n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),  # title right-aligned, large, bold\n    plot.caption = element_text(hjust = 0, face = \"italic\") # legenda alinhado à direita e itálico\n    )+\n  \n  # rótulos de gráfico\n  labs(x = \"Semana\",\n       y = \"Nome da instalação\",\n       fill = \"Relatório de \\ndesempenho(%)\", # título da legenda, porque a legenda mostra preenchimento\n       title = \"Porcentagem de dias por semana em que a instalação relatou dados\",\n       subtitle = \"Estabelecimentos de saúde distritais, maio-julho de 2020\",\n       caption = \"semanas de 7 dias começando às segundas-feiras.\")\n\n\n\n\n\n\n\n\n\n\n\nEixo y ordenado\nAtualmente, as instalações são ordenadas “alfanumericamente” de baixo para cima. Se você quiser ajustar a ordem das facilidades do eixo y, converta-as em fator de classe e forneça a ordem. Veja a página em Fatores para dicas.\nUma vez que existem muitos recursos e não queremos escrevê-los todos, tentaremos outra abordagem - ordenar os recursos em um data frame e usar a coluna de nomes resultante como a ordem dos níveis do fator. Abaixo, a coluna location_name é convertida em um fator, e a ordem de seus níveis é definida com base no número total de dias de relatório arquivados pela instalação/estabelecimento ao longo de todo o período de tempo.\nPara fazer isso, criamos um data frame que representa o número total de relatórios por instalação, organizados em ordem crescente. Podemos usar este vetor para ordenar os níveis dos fatores no gráfico.\n\nfacility_order &lt;- agg_weeks %&gt;% \n  group_by(location_name)%&gt;% \n  summarize(tot_reports = sum(n_days_reported, na.rm=T)) %&gt;% \n  arrange(tot_reports) # ordem crescente\n\nVeja o data frame abaixo:\n\n\n\n\n\n\nAgora use uma coluna do data frame acima (facility_order$location_name) para ser a ordem dos níveis de fator de location_name no quadro de dados agg_weeks:\nE agora os dados são adicionados a um gráfico novamente, com location_name sendo um fator ordenado:\n\nggplot(data = agg_weeks)+ \n  # mostrar dados como quadrados\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported),      \n    color = \"white\") + # linhas de grade brancas\n  \n  scale_fill_gradient(\n    low = \"orange\",\n    high = \"darkgreen\",\n    na.value = \"grey80\")+\n  \n  # eixo de data\n  scale_x_date(\n    expand = c(0,0), # remove espaço extra nas laterais\n    date_breaks = \"2 weeks\", # rótulos a cada 2 semanas\n    date_labels = \"%d\\n%b\") + # formato é dia após mês (\\n em nova linha)\n  \n  # temas estéticos\n  theme_minimal() + # fundo simplificado\n  \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1, \"cm\"), # altura da chave da legenda\n    legend.key.width = grid::unit(0.6, \"cm\"), # largura da chave da legenda\n    \n    axis.text.x = element_text(size=12),              # axis text size\n    axis.text.y = element_text(vjust = 0.2), # alinhamento do texto do eixo\n    axis.ticks = element_line(size=0.4),               \n    axis.title = element_text(size = 12, face = \"bold\"), # tamanho do título do eixo e negrito\n    \n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),  # title right-aligned, large, bold\n    plot.caption = element_text(hjust = 0, face = \"italic\") # legenda alinhado à direita e itálico\n    )+\n  \n  # rótulos de gráfico\n  labs(x = \"Semana\",\n       y = \"Nome da instalação\",\n       fill = \"Relatório de \\ndesempenho(%)\", # título da legenda, porque a legenda mostra preenchimento\n       title = \"Porcentagem de dias por semana em que a instalação relatou dados\",\n       subtitle = \"Estabelecimentos de saúde distritais, maio-julho de 2020\",\n       caption = \"semanas de 7 dias começando às segundas-feiras.\")\n\n\n\n\n\n\n\n\n\n\nValores expostos\nVocê pode adicionar uma camada geom_text() no topo dos quadrados, para exibir os números reais de cada quadrado. Esteja ciente de que isso pode não parecer muito elegante se você tiver muitos quadradinhos pequenos!\nO seguinte código foi adicionado: geom_text(aes(label = p_days_reported)). Isso adiciona texto a cada bloco. O texto exibido é o valor atribuído ao argumento label =, que neste caso foi definido para a mesma coluna numérica p_days_reported que também é usada para criar o gradiente de cor.\n\nggplot(data = agg_weeks)+ \n  # mostrar dados como quadrados\n  geom_tile(\n    aes(x = week,\n        y = location_name,\n        fill = p_days_reported),      \n    color = \"white\") + # linhas de grade brancas\n  \n  # texto\n  geom_text(\n    aes(\n      x = week,\n      y = location_name,\n      label = p_days_reported)) + # adicionar texto no topo do quadrado\n  \n  # escala de preenchimento\n  scale_fill_gradient(\n    low = \"orange\",\n    high = \"darkgreen\",\n    na.value = \"grey80\")+\n  \n  # eixo de data\n  scale_x_date(\n    expand = c(0,0), # remove espaço extra nas laterais\n    date_breaks = \"2 weeks\", # rótulos a cada 2 semanas\n    date_labels = \"%d\\n%b\") + # formato é dia após mês (\\n em nova linha)\n  \n  # temas estéticos\n  theme_minimal() + # fundo simplificado\n  \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1, \"cm\"), # altura da chave da legenda\n    legend.key.width = grid::unit(0.6, \"cm\"), # largura da chave da legenda\n    \n    axis.text.x = element_text(size=12),              # axis text size\n    axis.text.y = element_text(vjust = 0.2), # alinhamento do texto do eixo\n    axis.ticks = element_line(size=0.4),               \n    axis.title = element_text(size = 12, face = \"bold\"), # tamanho do título do eixo e negrito\n    \n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),  # title right-aligned, large, bold\n    plot.caption = element_text(hjust = 0, face = \"italic\") # legenda alinhado à direita e itálico\n    )+\n  \n  # rótulos de gráfico\n  labs(x = \"Semana\",\n       y = \"Nome da instalação\",\n       fill = \"Relatório de \\ndesempenho(%)\", # título da legenda, porque a legenda mostra preenchimento\n       title = \"Porcentagem de dias por semana em que a instalação relatou dados\",\n       subtitle = \"Estabelecimentos de saúde distritais, maio-julho de 2020\",\n       caption = \"semanas de 7 dias começando às segundas-feiras.\")",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Gráficos de calor</span>"
    ]
  },
  {
    "objectID": "new_pages/heatmaps.pt.html#recursos",
    "href": "new_pages/heatmaps.pt.html#recursos",
    "title": "34  Gráficos de calor",
    "section": "34.4 Recursos",
    "text": "34.4 Recursos\nscale_fill_gradient()\nGaleria de gráfico R - mapa de calor",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Gráficos de calor</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.pt.html",
    "href": "new_pages/diagrams.pt.html",
    "title": "35  Diagramas e gráficos",
    "section": "",
    "text": "Carregar pacotes\nEste chunk mostra o carregamento dos pacotes necessárias para as análises. Neste manual damos ênfase à função p_load() do pacote pacman, que instala o pacote se necessário e carrega-o para utilização. Outra opção é carregar os pacotes instalados utilizando library() a partir de R base. Ver a página em Introdução ao R para mais informações sobre pacotes R.\npacman::p_load(\n  DiagrammeR,     # para diagrama de fluxo\n  networkD3,      # para diagrama aluvial/Sankey \n  tidyverse)      # exploração (gestão) e visualização de dados",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Diagramas e gráficos</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.pt.html#diagramas-de-fluxos",
    "href": "new_pages/diagrams.pt.html#diagramas-de-fluxos",
    "title": "35  Diagramas e gráficos",
    "section": "35.1 Diagramas de fluxos",
    "text": "35.1 Diagramas de fluxos\nPode-se usar o pacote R DiagrammeR para criar gráficos ou gráficos de fluxo. Esses podem ser estáticos, ou podem ser ajustados de forma dinâmica, a partir das mudanças ou alterações do conjunto de dados utilizado.\nFerramentas\nA função grViz() é utilizada para criar um diagrama “Graphviz”. Esta função aceita uma entrada de cadeia de caracteres contendo instruções para produção do diagrama. Dentro dessa cadeia, as instruções são escritas numa linguagem diferente, chamada DOT - mas muito fácil de aprender a estrutura básica necessária.\nEstrutura básica\n\nAbra as instruções grViz(\"\nEspecifique a direcionalidade e o nome do gráfico, e abra colchetes, por exemplo digraph my_flow_chart {\nDeclaração do gráfico (layout, direção de classificação)\nDeclarações de nós (criar os nós)\nDeclarações Bordas (fornece links entre os nós)\nFeche as instruções }\")\n\n\nExemplos simples\nA seguir será usado dois exemplos simples\nUm exemplo mínimo:\n\n# plotar o mínimo\nDiagrammeR::grViz(\"digraph {\n  \ngraph[layout = dot, rankdir = LR]\n\na\nb\nc\n\na -&gt; b -&gt; c\n}\")\n\n\n\n\n\nUm exemplo mais aplicado ao contexto de saúde pública:\n\ngrViz(\"                           # Todas as instruções estão dentro de uma grande cadeia de caracteres\ndigraph surveillance_diagram {    # 'digraph' significa 'grafico direcional', depois o nome do gráfico\n  \n  # declaração gráfica\n  #################\n  graph [layout = dot,\n         rankdir = TB,\n         overlap = true,\n         fontsize = 10]\n  \n  # nos(nodea)\n  #######\n  node [shape = circle,           # forma (shape) = circulo\n       fixedsize = true\n       width = 1.3]               # Largura dos círculos\n  \n  Primary                         # nome dos nós\n  Secondary\n  Tertiary\n\n  # edges\n  #######\n  Primary   -&gt; Secondary [label = ' case transfer']\n  Secondary -&gt; Tertiary [label = ' case transfer']\n}\n\")\n\n\n\n\n\n\n\nSintaxe\nSintaxe básica\nOs nomes de nós, ou declarações de borda, podem ser separados por espaços, ponto e vírgula ou novas linhas.\nDireção da classificação\nUm gráfico pode ser reorientado para se mover da esquerda para a direita, ajustando o rankdir argumento dentro da instrução do gráfico. O padrão é TB (da cigla em inglês top-to-bottom - de cima para baixo), mas pode ser LR (da cigla em inglês left-to-right - da esquerda para a direita), RL (da cigla em inglês right-to-left - da direita para esquerda) ou BT (da cigla em inglês bottom-to-top - baixo para cima).\nNomes dos nós\nOs nomes dos nós podem ser palavras únicas, como no exemplo simples acima. Para usar nomes com várias palavras ou caracteres especiais (por exemplo, parênteses, travessões), coloque o nome do nó entre aspas simples (’ ’). Pode ser mais fácil ter um nome de nó curto e atribuir um rótulo label, como mostrado abaixo entre colchetes [ ]. Se você quiser ter uma nova linha no nome do nó, deve fazê-lo por meio de um rótulo - use \\n rótulo do nó entre aspas simples, conforme mostrado abaixo.\nSubgrupos\nDentro das declarações de borda, podem ser criados subgrupos em ambos os lados da borda com chaves ({ }). A borda aplica-se então a todos os nós do parêntese - é uma abreviação.\nLayouts\n\n\ndot (set rankdir to either TB, LR, RL, BT, )\nneato\n\ntwopi\n\ncirco\n\nNós - atributos editáveis\n\nlabel (Rótulo - texto, entre aspas simples, se houver várias palavras)\nfillcolor (Cor do preenchimento - muitas cores possíveis)\nfontcolor (Cor da fonte - muitas cores possíveis)\nalpha (Alfa - transparência 0-1)\nshape (Formato - ellipse, oval, diamond, egg, plaintext, point, square, triangle)\nstyle (Estilo)\nsides (Tamanhos)\nperipheries (Margens)\nfixedsize (Tamanho fixo - h x w)\nheight (Altura)\nwidth (Largura)\ndistortion (Distorção)\npenwidth (Largura/espessura da linha - largura da borda da forma)\nx (deslocamento para a esquerda e direita - left/right\ny (ddeslocamento para cima e para baixo - up/down\nfontname (Nome da fonte)\nfontsize (Tamanho da fonte)\nicon (Ícone)\n\nBordas - atributos editáveis\n\narrowsize (Tamanho da seta)\narrowhead (Ponta da seta - normal, box, crow, curve, diamond, dot, inv, none, tee, vee)\narrowtail (Base da seta)\ndir (Direção)\nstyle (Estilo “dashed”, para tracejadas …)\ncolor (Cor)\nalpha (Alfa)\nheadport (texto na ponta da seta)\ntailport (texto na da base da seta)\nfontname (Nome da fonte)\nfontsize (Tamanho da fonte)\nfontcolor(Cor da fonte)\npenwidth (Largura da linha)\nminlen (Comprimento minímo)\n\nNomes das cores: usa-se valores hexadecimais ou os nomes de cores ‘X11’, consulte detalhes X11\n\n\nExemplos complexos\nO exemplo abaixo, expande o diagrama de vigilância, adicionando nomes de nós complexos, de bordas agrupadas, com cores e estilo\n    DiagrammeR::grViz(\"               # Todas as instruções estão dentro de uma grande cadeia de caracteres\n    digraph surveillance_diagram {    # 'digraph' significa 'gráfico direcional', depois vem o nome do gráfico\n      \n      # Declaração gráfica\n      #################\n      graph [layout = dot,\n             rankdir = TB,            # layout top-to-bottom (de cima para baixo)\n             fontsize = 10]\n      \n\n      # nós (em círculos)\n      #################\n      node [shape = circle,           # shape = circulos\n           fixedsize = true\n           width = 1.3]                      \n      \n      Primary   [label = 'Primary\\nFacility'] \n      Secondary [label = 'Secondary\\nFacility'] \n      Tertiary  [label = 'Tertiary\\nFacility'] \n      SC        [label = 'Surveillance\\nCoordination',\n                 fontcolor = darkgreen] \n      \n      # Bordas/margens\n      #######\n      Primary   -&gt; Secondary [label = ' case transfer',\n                              fontcolor = red,\n                              color = red]\n      Secondary -&gt; Tertiary [label = ' case transfer',\n                              fontcolor = red,\n                              color = red]\n      \n      # Bordas agrugapas\n      {Primary Secondary Tertiary} -&gt; SC [label = 'case reporting',\n                                          fontcolor = darkgreen,\n                                          color = darkgreen,\n                                          style = dashed]\n}\n\")\n\n\n\n\n\n\nClusters de sub-graficos\nPara agrupar nós em caixas de clusters, coloque-os dentro do mesmo subgráfico nomeado (subgraph name {}). Para ter cada subgráfico identificado dentro de uma caixa delimitadora, comece o nome do subgráfico com “cluster”, como exemplificado com as 4 caixas abaixo\nDiagrammeR::grViz(\"             # Todas as instruções estão dentro de uma grande cadeia de caracteres\ndigraph surveillance_diagram {  # 'digraph' significa 'gráfico direcional', depois vem o nome do gráfico\n      \n      # Demonstração gráfica\n      #################\n      graph [layout = dot,\n             rankdir = TB,            \n             overlap = true,\n             fontsize = 10]\n      \n\n      # nós (círculos)\n      #################\n      node [shape = circle,                  # shape = círculos\n           fixedsize = true\n           width = 1.3]                      # largura dos círculos\n      \n      subgraph cluster_passive {\n        Primary   [label = 'Primary\\nFacility'] \n        Secondary [label = 'Secondary\\nFacility'] \n        Tertiary  [label = 'Tertiary\\nFacility'] \n        SC        [label = 'Surveillance\\nCoordination',\n                   fontcolor = darkgreen] \n      }\n      \n      # nós (boxes)\n      ###############\n      node [shape = box,                     # formas dos nós (Box - Caixa)\n            fontname = Helvetica]            # fonte do texto no nó\n      \n      subgraph cluster_active {\n        Active [label = 'Active\\nSurveillance'] \n        HCF_active [label = 'HCF\\nActive Search']\n      }\n      \n      subgraph cluster_EBD {\n        EBS [label = 'Event-Based\\nSurveillance (EBS)'] \n        'Social Media'\n        Radio\n      }\n      \n      subgraph cluster_CBS {\n        CBS [label = 'Community-Based\\nSurveillance (CBS)']\n        RECOs\n      }\n\n      \n      # Bordas\n      #######\n      {Primary Secondary Tertiary} -&gt; SC [label = 'case reporting']\n\n      Primary   -&gt; Secondary [label = 'case transfer',\n                              fontcolor = red]\n      Secondary -&gt; Tertiary [label = 'case transfer',\n                              fontcolor = red]\n      \n      HCF_active -&gt; Active\n      \n      {'Social Media' Radio} -&gt; EBS\n      \n      RECOs -&gt; CBS\n    }\n    \")\n\n\n\n\n\n\n\nFormas dos nós\nO exemplo abaixo, emprestado deste tutoriall, mostra exemplos de formas de nós (nodes) aplicadas e uma abreviatura para conexões seriais de borda\n\nDiagrammeR::grViz(\"digraph {\n\ngraph [layout = dot, rankdir = LR]\n\n# definir os estilos globais dos nós. Podemos anulá-los em caixa, se essa for a opção escolhida.\nnode [shape = rectangle, style = filled, fillcolor = Linen]\n\ndata1 [label = 'Dataset 1', shape = folder, fillcolor = Beige]\ndata2 [label = 'Dataset 2', shape = folder, fillcolor = Beige]\nprocess [label =  'Process \\n Data']\nstatistical [label = 'Statistical \\n Analysis']\nresults [label= 'Results']\n\n# Definições de bordas com as identificações dos nós\n{data1 data2}  -&gt; process -&gt; statistical -&gt; results\n}\")\n\n\n\n\n\n\n\nSaídas\nComo lidar e salvar resultados\n\nAs saídas aparecerão no painel Viewer do RStudio, por padrão no canto inferior direito ao lado de Files, Plots, Packages e Help.\nPara exportar, você pode “Salvar como imagem” ou “Copiar para a área de transferência” do Visualizador. O gráfico se ajustará ao tamanho especificado.\n\n\n\nFiguras parametrizadas\nAqui temos uma citação do tutorial: https://mikeyharper.uk/flowcharts-in-r-using-diagrammer/\n“Figuras parametrizadas: um grande benefício de projetar figuras dentro de R é que somos capazes de conectar as figuras diretamente com nossa análise, lendo os valores de R diretamente em nossos fluxogramas. Por exemplo, suponha que você tenha criado um processo de filtragem que remove valores após cada estágio de um processo, você pode ter uma figura mostrando o número de valores restantes no conjunto de dados após cada estágio de seu processo. Para fazer isso, você pode usar o símbolo @@X diretamente na figura e, em seguida, referir-se a ele no rodapé do gráfico usando [X]:, onde X é um índice numérico único.”\nRecomenda-se rever este este tutorial se a parametrização é algo que você esteja interessado",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Diagramas e gráficos</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.pt.html#diagramas-aluviaissankey",
    "href": "new_pages/diagrams.pt.html#diagramas-aluviaissankey",
    "title": "35  Diagramas e gráficos",
    "section": "35.2 Diagramas Aluviais/Sankey",
    "text": "35.2 Diagramas Aluviais/Sankey\n\nCarregar pacotes\nEsta parte de código mostra o carregamento de pacotes necessários para as análises. Neste manual enfatiza-se o p_load() do pacman, que instala o pacote se necessário e carrega-o para uso. Você também pode carregar pacotes instalados usando a biblioteca library() a partir da base R. Consulte a página sobre o [Introdução ao] (#basics) para obter mais informações sobre os pacotes R.\nCarregou-se o pacote networkD3 para a construção do diagrama, e o pacote tidyverse para as etapas de preparação dos dados.\n\npacman::p_load(\n  networkD3,\n  tidyverse)\n\n\n\nMapeamento do conjunto de dados\nMapeamento das ligações de um conjunto de dados. Abaixo é apresentado a utilização deste pacote sobre o caso linelist. O tutorial está disponível online para consulta. Tutorial.\nInicia-se obtendo a contagem de casos para cada categoria etária e a combinação por hospital. Os valores sem categoria de idade são removidos para maior clareza. Também foi realizado uma nova rotulagem (renomeadas), o hospital como fonte (source) e categorias de idades age_cat como alvo (target). Estes serão os dois lados do diagrama aluvial.\n\n# Contar por hospital e categoria de idade\nlinks &lt;- linelist %&gt;% \n  drop_na(age_cat) %&gt;% \n  select(hospital, age_cat) %&gt;%\n  count(hospital, age_cat) %&gt;% \n  rename(source = hospital,\n         target = age_cat)\n\nO conjunto de dados tem agora este aspecto:\n\n\n\n\n\n\nAgora cria-se um Data Frame, de todos os nós do diagrama, sob a coluna name. Isso consiste em todos os valores para hospital e age_cat. Observe que garantiu-se que todos eles pertecem a classe Character antes de combiná-los. E ajustou-se as colunas de ID para que fossem números em vez de rótulos:\n\n# O nome único para os nós\nnodes &lt;- data.frame(\n  name=c(as.character(links$source), as.character(links$target)) %&gt;% \n    unique()\n  )\n\nnodes  # Exibir\n\n                                   name\n1                               Ausente\n2                      Central Hospital\n3                     Military Hospital\n4                                 Other\n5                         Port Hospital\n6  St. Mark's Maternity Hospital (SMMH)\n7                                   0-4\n8                                   5-9\n9                                 10-14\n10                                15-19\n11                                20-29\n12                                30-49\n13                                50-69\n14                                  70+\n\n\nNa sequência editou-se o Data Frame links, criado anteriormente com o count(). Duas novas colunas númericas então foram adicionadas IDsource e IDtarget que irão refletir/criar os linques entre os nós. Essas colunas manterão os números das linhas (posição) dos nós tanto de origem como o do destino. O 1 é subtraído, para que estes números de posição comecem em 0 (não em 1).\n\n# corresponder a números e  não a nomes\nlinks$IDsource &lt;- match(links$source, nodes$name)-1 \nlinks$IDtarget &lt;- match(links$target, nodes$name)-1\n\nO conjunto de dados Links agora tem este aspecto:\n\n\n\n\n\n\nAgora, hora de traçar o diagrama Sankey com sankeyNetwork(). Você pode ler mais sobre cada argumento correndo ?sankeyNetwork no console. Note que, a menos que defina iterations = 0 a ordem dos seus nós pode não ser a esperada.\n\n# traçar o diagrama\n######\np &lt;- sankeyNetwork(\n  Links = links,\n  Nodes = nodes,\n  Source = \"IDsource\",\n  Target = \"IDtarget\",\n  Value = \"n\",\n  NodeID = \"name\",\n  units = \"TWh\",\n  fontSize = 12,\n  nodeWidth = 30,\n  iterations = 0)        # assegurar que a ordem dos nós é como nos dados\np\n\n\n\n\n\nAqui está um exemplo em que o resultado do paciente também é incluído. Na etapa de preparação dos dados, é necessário calcular as contagens de casos entre a idade e o hospital, e separadamente entre o hospital e o resultado, e depois ligar todas estas contagens juntamente com bind_rows().\n\n# conta por hospital e categoria de idade\nage_hosp_links &lt;- linelist %&gt;% \n  drop_na(age_cat) %&gt;% \n  select(hospital, age_cat) %&gt;%\n  count(hospital, age_cat) %&gt;% \n  rename(source = age_cat,          # renomear\n         target = hospital)\n\nhosp_out_links &lt;- linelist %&gt;% \n    drop_na(age_cat) %&gt;% \n    select(hospital, outcome) %&gt;% \n    count(hospital, outcome) %&gt;% \n    rename(source = hospital,       # renomear\n           target = outcome)\n\n# combinar links\nlinks &lt;- bind_rows(age_hosp_links, hosp_out_links)\n\n# Nome único para os nós\nnodes &lt;- data.frame(\n  name=c(as.character(links$source), as.character(links$target)) %&gt;% \n    unique()\n  )\n\n# Criar números de identificação\nlinks$IDsource &lt;- match(links$source, nodes$name)-1 \nlinks$IDtarget &lt;- match(links$target, nodes$name)-1\n\n# exibir\n######\np &lt;- sankeyNetwork(Links = links,\n                   Nodes = nodes,\n                   Source = \"IDsource\",\n                   Target = \"IDtarget\",\n                   Value = \"n\",\n                   NodeID = \"name\",\n                   units = \"TWh\",\n                   fontSize = 12,\n                   nodeWidth = 30,\n                   iterations = 0)\np\n\n\n\n\n\nConsulte: https://www.displayr.com/sankey-diagrams-r/",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Diagramas e gráficos</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.pt.html#cronograma-de-eventos",
    "href": "new_pages/diagrams.pt.html#cronograma-de-eventos",
    "title": "35  Diagramas e gráficos",
    "section": "35.3 Cronograma de eventos",
    "text": "35.3 Cronograma de eventos\nPara fazer uma linha do tempo mostrando eventos específicos, você pode usar o pacote vistime.\nVeja vignette\n\n# Carregando  o pacote\npacman::p_load(vistime,  # criando a linha do tempo\n               plotly    # para visualização interativa\n               )\n\nAqui está um conjunto de dados de eventos para começar\n\n\n\n\n\n\n\np &lt;- vistime(data)    # aplicar  o vistime\n\nlibrary(plotly)\n\n# passo 1: transformar em lista\npp &lt;- plotly_build(p)\n\n# passo 2: Tamanho do marcador\nfor(i in 1:length(pp$x$data)){\n  if(pp$x$data[[i]]$mode == \"markers\") pp$x$data[[i]]$marker$size &lt;- 10\n}\n\n# passo 3: tamanho do texto\nfor(i in 1:length(pp$x$data)){\n  if(pp$x$data[[i]]$mode == \"text\") pp$x$data[[i]]$textfont$size &lt;- 10\n}\n\n\n# passo 4: posição do texto\nfor(i in 1:length(pp$x$data)){\n  if(pp$x$data[[i]]$mode == \"text\") pp$x$data[[i]]$textposition &lt;- \"right\"\n}\n\n#exibir\npp",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Diagramas e gráficos</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.pt.html#gráficos-cíclicos-direcionados---dags",
    "href": "new_pages/diagrams.pt.html#gráficos-cíclicos-direcionados---dags",
    "title": "35  Diagramas e gráficos",
    "section": "35.4 Gráficos cíclicos direcionados - DAGs",
    "text": "35.4 Gráficos cíclicos direcionados - DAGs\nVocê pode construir um DAG manualmente usando o pacote DiagammeR e a linguagem DOT conforme descrito acima.\nUma outra alternativa é usar os pacotes como ggdag e daggity\nIntrodução DAGs ggdag vignette\nCausal Inferência com dags no R",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Diagramas e gráficos</span>"
    ]
  },
  {
    "objectID": "new_pages/diagrams.pt.html#recursos",
    "href": "new_pages/diagrams.pt.html#recursos",
    "title": "35  Diagramas e gráficos",
    "section": "35.5 Recursos",
    "text": "35.5 Recursos\nMuito do que foi dito acima em relação à linguagem DOT é adaptado do tutorial nesta página\nOutro tutorial mais aprofundado tutorial on DiagammeR\nConsulte esta página Sankey diagrams",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Diagramas e gráficos</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.pt.html",
    "href": "new_pages/combination_analysis.pt.html",
    "title": "36  Análise de Combinações",
    "section": "",
    "text": "36.1 Preparação",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Análise de Combinações</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.pt.html#preparação",
    "href": "new_pages/combination_analysis.pt.html#preparação",
    "title": "36  Análise de Combinações",
    "section": "",
    "text": "Carregue os pacotes R\nO código abaixo realiza o carregamento dos pacotes necessários para a análise dos dados. Neste manual, enfatizamos o uso da função p_load(), do pacman, que instala os pacotes, caso não estejam instalados, e os carrega no R para utilização. Também é possível carregar pacotes instalados utilizando a função library(), do R base. Para mais informações sobre os pacotes do R, veja a página Introdução ao R.\n\npacman::p_load(\n  tidyverse,     # manupulação de dados e visualização\n  UpSetR,        # pacote especial para gráficos de combinção \n  ggupset)       # pacote especial para gráficos de combinção \n\n\n\n\nImporte os dados\nPara iniciar, importaremos a linelist dos casos de uma epidemia simulada do Ebola. Se você quiser acompanhar, clique para baixar a linelist “limpa” (como um arquivo .rds). Importe os dados com a função import() do pacote rio (a função suporta vários tipos de arquivo como .xlsx, .csv, .rds - cheque a página Importar e exportar para mais detalhes).\n\n# importe a linelit de casos \nlinelist_sym &lt;- import(\"linelist_cleaned.rds\")\n\nEssa linelist inclui cinco variáveis do tipo “sim/não” (“sim/no”) a respeito dos sintomas relatados. Nós vamos precisar transformar essas variáveis um pouco para poder utilizar o pacote ggupset para fazer nosso gráfico. Confira os dados (role para a direita para ver as variáveis dos sintomas).\n\n\n\n\n\n\n\n\n\nReformate os valores\nPara estarmos alinhados com o formato esperado pelo pacote ggupset vamos converter os “sim” e “não” para o real nome do sintoma utilizando a função case_when() do pacote dplyr. Caso seja “não”, definiremos o valor como vazio, então os valores serão NA ou o nome do sintoma.\n\n# criar uma coluna com todos os sintomas separados por ponto-vírgula \nlinelist_sym_1 &lt;- linelist_sym %&gt;% \n  rename(febre=fever, # só traduzindo\n         calafrio=chills,\n         tosse=cough,\n         dores=aches,\n         vômito = vomit) %&gt;% \n  # converte os valores de \"yes\" e \"no\" no nome do sintoma\n  mutate(\n    febre = case_when(\n      febre == \"yes\" ~ \"febre\",          #se o valor era \"sim\", o novo valor é \"febre\"\n      TRUE           ~ NA_character_),   # se o valor era diferente de \"sim\", o novo valor é NA\n         \n    calafrio = case_when(\n       calafrio == \"yes\" ~ \"calafrio\",\n       TRUE           ~ NA_character_),\n    \n    tosse = case_when(\n      tosse == \"yes\" ~ \"tosse\",\n      TRUE           ~ NA_character_),\n         \n    dores = case_when(\n      dores == \"yes\" ~ \"dores\",\n      TRUE           ~ NA_character_),\n         \n    vômito = case_when(\n      vômito == \"yes\" ~ \"vômito\",\n      TRUE           ~ NA_character_)\n    )\n\nAgora nós geramos duas colunas finais:\n\nConcatenando (unindo) todos os sintomas do paciente (uma coluna de caracteres)\n\nConvertendo a coluna acima para a classe list, para que ela possa ser passada ao pacote ggupset para fazer o gráfico.\n\nVeja a página de Caracteres e strings para aprender mais sobre a função unite() do pacote stringr\n\nlinelist_sym_1 &lt;- linelist_sym_1 %&gt;% \n  unite(col = \"all_symptoms\",\n        c(febre, calafrio, tosse, dores, vômito), \n        sep = \"; \",\n        remove = TRUE,\n        na.rm = TRUE) %&gt;% \n  mutate(\n    # faz uma cópia de da coluna all_symptoms, mas na classe lista (que é requisito do ggupset() no próximo passo)\n    all_symptoms_list = as.list(strsplit(all_symptoms, \"; \"))\n    )\n\nVeja a nova tabela. Note as duas colunas na extremidade da direta - os valores combinados, e a lista",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Análise de Combinações</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.pt.html#ggupset",
    "href": "new_pages/combination_analysis.pt.html#ggupset",
    "title": "36  Análise de Combinações",
    "section": "36.2 ggupset",
    "text": "36.2 ggupset\nCarregue o pacote\n\npacman::p_load(ggupset)\n\nCrie o gráfico. Vamos começar com um ggplot() e a função geom_bar(), mas depois vamos adicionar a função scale_x_upset() do pacote ggupset.\n\nggplot(\n  data = linelist_sym_1,\n  mapping = aes(x = all_symptoms_list)) +\ngeom_bar() +\nscale_x_upset(\n  reverse = FALSE,\n  n_intersections = 10,\n  sets = c(\"febre\", \"calafrio\", \"tosse\", \"dores\", \"vômito\"))+\nlabs(\n  title = \"Sinais e Sintomas\",\n  subtitle = \"10 combinações mais frequentes de sinais e sintomas\",\n  caption = \"Rodapé aqui\",\n  x = \"Combinação de Sintomas\",\n  y = \"Frequência na base de dados\")\n\n\n\n\n\n\n\n\nMais informações sobre ggupset podem ser vistas online ou offline na documentação do pacote na aba de Ajuda do seu RStudio após digitar ?ggupset no console.",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Análise de Combinações</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.pt.html#upsetr",
    "href": "new_pages/combination_analysis.pt.html#upsetr",
    "title": "36  Análise de Combinações",
    "section": "36.3 UpSetR",
    "text": "36.3 UpSetR\nO pacote UpSetR permite mais personalizações do gráfico, mas pode ser mais difícil de executar.\nCarregue o pacote\n\npacman::p_load(UpSetR)\n\nLimpando os dados\nPrecisamos converter os valores dos sintomas da linelist para 1 / 0.\n\n# Make using upSetR\n\nlinelist_sym_2 &lt;- linelist_sym %&gt;% \n  rename(febre=fever, # só traduzindo\n         calafrio=chills,\n         tosse=cough,\n         dores=aches,\n         vômito = vomit) %&gt;% # só traduzindo\n  # converte os valores de \"sim\" e \"não\" nos nomes dos sintomas\n  mutate(\n    febre = case_when(\n      febre == \"yes\" ~ 1,    # se o valor antigo era \"yes\", então o novo valor é 1\n      TRUE           ~ 0),   # se o valor era qualquer coisa diferente de \"yes\", o novo valor é 0\n         \n    calafrio = case_when(\n      calafrio == \"yes\" ~ 1,\n      TRUE           ~ 0),\n         \n    tosse = case_when(\n      tosse == \"yes\" ~ 1,\n      TRUE           ~ 0),\n         \n    dores = case_when(\n      dores == \"yes\" ~ 1,\n      TRUE           ~ 0),\n         \n    vômito = case_when(\n      vômito == \"yes\" ~ 1,\n      TRUE           ~ 0)\n    )\n\nAgora vamos fazer o gráfico utilizando a função upset() - utilizando apenas as colunas de sintomas. Você deve definir quais “conjuntos” serão comparados (passe os nomes das colunas de sintomas). Ou então, utilize nsets = e order.by = \"freq\" para mostrar apenas as maiores X combinações.\n\n# Make the plot\nUpSetR::upset(\n  select(linelist_sym_2, febre, calafrio, tosse, dores, vômito),\n  sets = c(\"febre\", \"calafrio\", \"tosse\", \"dores\", \"vômito\"),\n  order.by = \"freq\",\n  sets.bar.color = c(\"blue\", \"red\", \"yellow\", \"darkgreen\", \"orange\"), # cores opcionais\n  empty.intersections = \"on\",\n  # nsets = 3,\n  number.angles = 0,\n  point.size = 3.5,\n  line.size = 2, \n  mainbar.y.label = \"Combinação de sintomas\",\n  sets.x.label = \"Pacientes com Sintomas\")",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Análise de Combinações</span>"
    ]
  },
  {
    "objectID": "new_pages/combination_analysis.pt.html#recursos",
    "href": "new_pages/combination_analysis.pt.html#recursos",
    "title": "36  Análise de Combinações",
    "section": "36.4 Recursos",
    "text": "36.4 Recursos\nPágina do github do UpSetR\nUma versão em Shiny App - você pode fazer upload de seus próprios dados\n*documentação - difícil de interpretar",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>36</span>  <span class='chapter-title'>Análise de Combinações</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.pt.html",
    "href": "new_pages/transmission_chains.pt.html",
    "title": "37  Cadeias de Transmissão",
    "section": "",
    "text": "37.1 Visão Geral\nA ferramenta primária para manipular, analisar e visualizar dados de cadeias de transmissão e rastreamento de contatos é o pacote epicontacts, desenvolvido por membros do RECON. Experimente o gráfico interativo abaixo passando o mouse sobre os nós para ver mais informações, arrastando para movê-los e clicando para destacar os casos subjacentes.\nWarning in epicontacts::make_epicontacts(linelist = linelist, contacts =\ncontacts, : Cycle(s) detected in the contact network: this may be unwanted",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Cadeias de Transmissão</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.pt.html#preparação",
    "href": "new_pages/transmission_chains.pt.html#preparação",
    "title": "37  Cadeias de Transmissão",
    "section": "37.2 Preparação",
    "text": "37.2 Preparação\n\nCarregue os pacotes R\nPrimeiro carregue os pacotes padrão necessários para importar e manipular os dados. Neste manual, enfatizamos o uso da função p_load(), do *pacman, que instala os pacotes, caso não estejam instalados, e os carrega no R para utilização. Também é possível carregar pacotes instalados utilizando a função library(), do R base**. Para mais informações sobre os pacotes do R, veja a página Introdução ao R.\n\npacman::p_load(\n  rio, # Importação de arquivos\n  here, # Localizador de arquivos\n  tidyverse, # Gerenciamento de dados + gráficos do ggplot2\n  remotes # Instalação de pacotes do ggplot2\n)\n\nVocê vai instalar a versão de desenvolvimento do epicontacts, que pode ser instalado diretamente do github utilizando a função p_install_github() do pacote pacman. Você precisa rodar esse comando abaixo apenas uma vez, e não todas as vezes que usar o pacote (daí em diante, você pode utilizar p_load() como de costume).\n\npacman::p_install_gh(\"reconhub/epicontacts@timeline\")\n\n\n\nImportando os dados\nVamos importar a base de dados de casos da epidemia simulada de Ebola. Se você quiser fazer download dos dados para seguir o passo a passo, veja as instruções na página Baixando dados do manual. A base será importada utilizando a função import() do pacote rio. Veja a página sobre Importação e exportação para aprender várias formas de importar dados.\n\n# import the linelist\nlinelist &lt;- import(\"linelist_cleaned.xlsx\")\n\nAs primeiras 50 linhas da linelist são mostradas abaixo. As colunas de especial interesse são case_id, generation, infector, e source.\n\n\n\n\n\n\n\n\nCriando um objeto do tipo epicontacts\nDepois, precisamos criar um objeto epicontacts, que requer dois tipos de dados:\n\numa linelist documentando casos onde colunas são variáveis e colunas correspondem a casos únicos\numa lista de arestas definindo as ligações entre os casos com base em seus IDs únicos (esses podem ser contatos, eventos de transmissão, etc.)\n\nComo já temos uma linelist, precisamos apenas criar a lista de arestas entre os casos, mais especificamente entre seus IDs. Podemos extrair relações de transmição da linelist ao relacionar a coluna infector com a coluna case_id. Nesse ponto podemos também adicionar “propriedades das arestas”, que seriam quaisquer variáveis que descrevem a relação entre os dois casos, e não os casos em si. Para ilustrar, vamos adicionar uma variável location que descreve o local do evento de transmissão, e uma variável de duração, que descreve a duração do contato em dias.\nNo código abaixo, a função transmute do dplyr atua de forma semelhante à mutate, com a diferença que ela mantém apenas as colunas que especificamos na chamada. A função drop_na vai filtrar quaisquer linhas cujas colunas especificadas tenham o valor NA; nesse caso, queremos manter apenas as linhas cujo transmissor (infector) é conhecido.\n\n## gera os contatos\ncontacts &lt;- linelist %&gt;%\n  transmute(\n    infector = infector,\n    case_id = case_id,\n    location = sample(c(\"Community\", \"Nosocomial\"), n(), TRUE),\n    duration = sample.int(10, n(), TRUE)\n  ) %&gt;%\n  drop_na(infector)\n\nAgora podemos criar o objeto epicontacts utilizando a função make_epicontacts. Precisamos especificar qual coluna da linelist aponta para o identificador único dos casos, bem como quais colunas dos contatos apontam para os identificadores únicos dos casos envolvidos em cada relação. Essas relações são direcionadas pois a transmissão vai do (from) transmissor para (to) o caso, então precisamos especificar os argumentos from e to de acordo. Nós também definimos o argumento directed (direcionado) para TRUE, o que vai afetar as operações no futuro.\n\n## gera o objeto epicontacts\nepic &lt;- make_epicontacts(\n  linelist = linelist,\n  contacts = contacts,\n  id = \"case_id\",\n  from = \"infector\",\n  to = \"case_id\",\n  directed = TRUE\n)\n\nWarning in make_epicontacts(linelist = linelist, contacts = contacts, id =\n\"case_id\", : Cycle(s) detected in the contact network: this may be unwanted\n\n\nAo examinarmos objetos do tipo epicontacts, podemos ver que a coluna case_id na linelist foi renomeada para id e as colunas case_id e infector nos contatos foram renomeadas para from e to. Isso garante a consistência nas operações de manipulação, visualização e análise subsequentes.\n\n## visualiza o objeto epicontacts\nepic\n\n\n/// Epidemiological Contacts //\n\n  // class: epicontacts\n  // 5,888 cases in linelist; 3,800 contacts; directed \n\n  // linelist\n\n# A tibble: 5,888 × 30\n   id     generation date_infection date_onset date_hospitalisation date_outcome\n   &lt;chr&gt;       &lt;dbl&gt; &lt;date&gt;         &lt;date&gt;     &lt;date&gt;               &lt;date&gt;      \n 1 5fe599          4 2014-05-08     2014-05-13 2014-05-15           NA          \n 2 8689b7          4 NA             2014-05-13 2014-05-14           2014-05-18  \n 3 11f8ea          2 NA             2014-05-16 2014-05-18           2014-05-30  \n 4 b8812a          3 2014-05-04     2014-05-18 2014-05-20           NA          \n 5 893f25          3 2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n 6 be99c8          3 2014-05-03     2014-05-22 2014-05-23           2014-05-24  \n 7 07e3e8          4 2014-05-22     2014-05-27 2014-05-29           2014-06-01  \n 8 369449          4 2014-05-28     2014-06-02 2014-06-03           2014-06-07  \n 9 f393b4          4 NA             2014-06-05 2014-06-06           2014-06-18  \n10 1389ca          4 NA             2014-06-05 2014-06-07           2014-06-09  \n# ℹ 5,878 more rows\n# ℹ 24 more variables: outcome &lt;chr&gt;, gender &lt;chr&gt;, age &lt;dbl&gt;, age_unit &lt;chr&gt;,\n#   age_years &lt;dbl&gt;, age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;, hospital &lt;chr&gt;, lon &lt;dbl&gt;,\n#   lat &lt;dbl&gt;, infector &lt;chr&gt;, source &lt;chr&gt;, wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;,\n#   ct_blood &lt;dbl&gt;, fever &lt;chr&gt;, chills &lt;chr&gt;, cough &lt;chr&gt;, aches &lt;chr&gt;,\n#   vomit &lt;chr&gt;, temp &lt;dbl&gt;, time_admission &lt;chr&gt;, bmi &lt;dbl&gt;,\n#   days_onset_hosp &lt;dbl&gt;\n\n  // contacts\n\n# A tibble: 3,800 × 4\n   from   to     location   duration\n   &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;         &lt;int&gt;\n 1 f547d6 5fe599 Community         3\n 2 f90f5f b8812a Community         1\n 3 11f8ea 893f25 Community         4\n 4 aec8ec be99c8 Community         3\n 5 893f25 07e3e8 Community         2\n 6 133ee7 369449 Community         1\n 7 996f3a 2978ac Nosocomial        4\n 8 133ee7 57a565 Nosocomial        8\n 9 37a6f6 fc15ef Nosocomial        4\n10 9f6884 2eaa9a Nosocomial        4\n# ℹ 3,790 more rows",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Cadeias de Transmissão</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.pt.html#manipulando",
    "href": "new_pages/transmission_chains.pt.html#manipulando",
    "title": "37  Cadeias de Transmissão",
    "section": "37.3 Manipulando",
    "text": "37.3 Manipulando\n\nSubsetting (subconjuntos)\nO método subset() dos objetos epicontacts permitem, entre outras coisas, filtrar as redes baseadas nas propriedades da linelist (“node attributes”) e da base de contatos (“edge attributes”). Esses valores devem ser passados como listas nomeadas ao argumento respectivo. Por exemplo, no código abaixo estamos mantendo apenas os casos masculinos da linelist que possuem data da infecção entre abril e julho de 2014 (datas são especificadas como intervalos), e relações de transmissão que ocorreram no hospital.\n\nsub_attributes &lt;- subset(\n  epic,\n  node_attribute = list(\n    gender = \"m\",\n    date_infection = as.Date(c(\"2014-04-01\", \"2014-07-01\"))\n  ),\n  edge_attribute = list(location = \"Nosocomial\")\n)\nsub_attributes\n\n\n/// Epidemiological Contacts //\n\n  // class: epicontacts\n  // 69 cases in linelist; 1,864 contacts; directed \n\n  // linelist\n\n# A tibble: 69 × 30\n   id     generation date_infection date_onset date_hospitalisation date_outcome\n   &lt;chr&gt;       &lt;dbl&gt; &lt;date&gt;         &lt;date&gt;     &lt;date&gt;               &lt;date&gt;      \n 1 5fe599          4 2014-05-08     2014-05-13 2014-05-15           NA          \n 2 893f25          3 2014-05-18     2014-05-21 2014-05-22           2014-05-29  \n 3 2978ac          4 2014-05-30     2014-06-06 2014-06-08           2014-06-15  \n 4 57a565          4 2014-05-28     2014-06-13 2014-06-15           NA          \n 5 fc15ef          6 2014-06-14     2014-06-16 2014-06-17           2014-07-09  \n 6 99e8fa          7 2014-06-24     2014-06-28 2014-06-29           2014-07-09  \n 7 f327be          6 2014-06-14     2014-07-12 2014-07-13           2014-07-14  \n 8 90e5fe          5 2014-06-18     2014-07-13 2014-07-14           2014-07-16  \n 9 a47529          5 2014-06-13     2014-07-17 2014-07-18           2014-07-26  \n10 da8ecb          5 2014-06-20     2014-07-18 2014-07-20           2014-08-01  \n# ℹ 59 more rows\n# ℹ 24 more variables: outcome &lt;chr&gt;, gender &lt;chr&gt;, age &lt;dbl&gt;, age_unit &lt;chr&gt;,\n#   age_years &lt;dbl&gt;, age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;, hospital &lt;chr&gt;, lon &lt;dbl&gt;,\n#   lat &lt;dbl&gt;, infector &lt;chr&gt;, source &lt;chr&gt;, wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;,\n#   ct_blood &lt;dbl&gt;, fever &lt;chr&gt;, chills &lt;chr&gt;, cough &lt;chr&gt;, aches &lt;chr&gt;,\n#   vomit &lt;chr&gt;, temp &lt;dbl&gt;, time_admission &lt;chr&gt;, bmi &lt;dbl&gt;,\n#   days_onset_hosp &lt;dbl&gt;\n\n  // contacts\n\n# A tibble: 1,864 × 4\n   from   to     location   duration\n   &lt;chr&gt;  &lt;chr&gt;  &lt;chr&gt;         &lt;int&gt;\n 1 996f3a 2978ac Nosocomial        4\n 2 133ee7 57a565 Nosocomial        8\n 3 37a6f6 fc15ef Nosocomial        4\n 4 9f6884 2eaa9a Nosocomial        4\n 5 4802b1 bbfa93 Nosocomial        6\n 6 a75c7f 7f5a01 Nosocomial       10\n 7 8e104d ddddee Nosocomial        2\n 8 ab634e 99e8fa Nosocomial        3\n 9 5d9e4d 8bd1e8 Nosocomial        7\n10 567136 8ebf6e Nosocomial        7\n# ℹ 1,854 more rows\n\n\nPodemos utilizar a função thin para filtrar a linelist para incluir casos encontrados nos contatos definindo o argumento what = \"linelist\", ou filtrar os contatos para incluir casos enontrados na linelist definindo o argumento what = \"contacts\". No código abaixo, vamos continuar filtrando o objeto epicontacts para manter apenas as relações de transmissão que envolvam os casos masculinos infectados entre abril e julho que já filtramos acima. Podemos ver que apenas duas relações de transmissão se encaixam nessa especificação.\n\nsub_attributes &lt;- thin(sub_attributes, what = \"contacts\")\nnrow(sub_attributes$contacts)\n\n[1] 5\n\n\nAlém de gerar os subconjuntos a partir dos atributos dos nós (node) e arestas (edges), as redes podem ser aparadas para incluir apenas componentes que estejam conectados com certos nós. O argumento cluster_id recebe um vetor dos IDs dos casos e retorna uma linelist dos indivíduos que estão relacionados, direta ou indiretamente, a esses a IDs. No código abaixo, podemos ver que um total de 13 casos da linelist estão envolvididos nos agrupamentos (clusters) contendo 2ae019 e 71577a.\n\nsub_id &lt;- subset(epic, cluster_id = c(\"2ae019\", \"71577a\"))\nnrow(sub_id$linelist)\n\n[1] 13\n\n\nO método subset() para os objetos epicontacts também permite filtrar pelo tamanho do agrupamento utilizando os argumentos cs, cs_min e cs_max. No código abaixo, estamos mantendo apenas os casos relacionados aos agrupamentos com 10 casos ou mais, e podemos ver que 271 casos da linelist estão envolvidos nesses agrupamentos.\n\nsub_cs &lt;- subset(epic, cs_min = 10)\nnrow(sub_cs$linelist)\n\n[1] 271\n\n\n\n\nAcessando os IDs\nA função get_id() recupera informações dos IDs dos casos na base de dados, e pode ser parametrizada como:\n\nlinelist: IDs nos dados da linelist\ncontacts: IDs na base de contatos (“from” e “to” combinados)\nfrom: IDs na coluna “from” da base de contatos\nto IDs na coluna “to” da base de contatos\nall: IDs que aparecem em qualquer coluna e em qualquer base\ncommon: IDs que aparecem tanto na linelist quanto nos contatos\n\nPor exemplo, quais são os primeiros dez IDs na base de contatos?\n\ncontacts_ids &lt;- get_id(epic, \"contacts\")\nhead(contacts_ids, n = 10)\n\n [1] \"f547d6\" \"f90f5f\" \"11f8ea\" \"aec8ec\" \"893f25\" \"133ee7\" \"996f3a\" \"37a6f6\"\n [9] \"9f6884\" \"4802b1\"\n\n\nQuantos IDs são encontratos tanto na linelist quanto nos contatos?\n\nlength(get_id(epic, \"common\"))\n\n[1] 4352",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Cadeias de Transmissão</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.pt.html#visualização",
    "href": "new_pages/transmission_chains.pt.html#visualização",
    "title": "37  Cadeias de Transmissão",
    "section": "37.4 Visualização",
    "text": "37.4 Visualização\n\nGeração de gráficos básicos\nTodas as visualizações dos objetos epicontacts são tratadas pela função plot. Primeiro vamos filtrar o objeto epicontacts para incluir apenas os casos com as datas de início em junho de 2014 utilizando a função subset, e então, incluir apenas os contatos relacionados a esses casos com a função thin.\n\n## subconjunto (subset) do objeto epicontacts\nsub &lt;- epic %&gt;%\n  subset(\n    node_attribute = list(date_onset = c(as.Date(c(\"2014-06-30\", \"2014-06-01\"))))\n  ) %&gt;%\n  thin(\"contacts\")\n\nPodemos criar o gráfico básico e interativo de forma muito simples, como mostrado a seguir:\n\n## cria o gráfico do objeto epicontacts\nplot(\n  sub,\n  width = 700,\n  height = 700\n)\n\n\n\n\n\nVocê pode mover os nós arrastando-os, passar o mouse sobre eles para mais informações ou clicar neles para destacar os casos conectados.\nExistem inúmeros argumentos para fazer modificações a esse gráfico. Iremos cobrir os principais aqui, mas confira a documentação via ?vis_epicontacts (a função chamada ao utilizar plot em um objeto epicontacts) para ver uma descrição completa dos argumentos da função.\n\nVisualizando atributos dos nós\nCor, forma e tamanho dos nós podem ser mapeados a uma dada coluna na linelist utilizando respectivamente os argumentos node_color, node_shape e node_size. Isso é parecido com a sintaxe da função aes, que você deve reconhecer, do pacote ggplot2.\nAs cores, formas e tamanhos dos nós podem ser especificados da seguinte forma:\n\nCores: via argumento col_pal, seja pelo fornecimento de uma lista nomeda, para especificação manual da cada cor, como fizemos abaixo, ou pelo fornecimento de uma função de paleta de cor tal como colorRampPalette(c(\"black\", \"red\", \"orange\")), que irá fornecer um degradê de cores entre as especificadas.\nFormas: passando uma lista nomeada ao argumento shapes, especificando uma forma para cada elemento único da coluna da linelist especificado pelo argumento node_shape. Veja codeawesome para as formas disponíveis.\nTamanho: passando um intervalo de tamanhos dos nós para o argumento size_range.\n\nAqui vemos um exemplo, onde a cor representa o desfecho, forma representa o gênero e tamanho a idade:\n\nplot(\n  sub,\n  node_color = \"outcome\",\n  node_shape = \"gender\",\n  node_size = \"age\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  shapes = c(f = \"female\", m = \"male\"),\n  size_range = c(40, 60),\n  height = 700,\n  width = 700\n)\n\n\n\n\n\n\n\nVisualizando atributos das arestas\nEdge color, width and linetype can be mapped to a given column in the contacts dataframe using the edge_color, edge_width and edge_linetype arguments. The specific colors and widths of the edges can be specified as follows: Cor, espessura e tipo de linha das arestas podem ser mepeados a uma dada coluna do dataframe de contatos utilizando, respectivamente, os argumentos edge_color, edge_width e edge_linetype. As cores e espessuras, em específico, podem ser passadas como abaixo:\n\nCores: via argumento edge_col_pal, da mesma maneira utilizada para col_pal.\nEspessuras passando um intervalo de espessura para o argumento width_range.\n\nAqui temos um exemplo:\n\nplot(\n  sub,\n  node_color = \"outcome\",\n  node_shape = \"gender\",\n  node_size = \"age\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  shapes = c(f = \"female\", m = \"male\"),\n  size_range = c(40, 60),\n  edge_color = \"location\",\n  edge_linetype = \"location\",\n  edge_width = \"duration\",\n  edge_col_pal = c(Community = \"orange\", Nosocomial = \"purple\"),\n  width_range = c(1, 3),\n  height = 700,\n  width = 700\n)\n\n\n\n\n\n\n\n\nEixo Temporal\nTambém podemos visualizar a rede ao longo do eixo temporal ao mapear o argumento x_axis a alguma coluna na linelist. No exemplo abaixo, o eixo x representa a data de início dos sintomas. Também especificamos o argumento arrow_size para nos certificar que as setas não serão muito grandes, e definimos label = FALSE para deixar a figura menos congestionada.\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n\n\n\n\n\nExistem inúmeros outros argumentos para especificar como essa rede pode ser visualizada ao longo de um eixo temporal, você pode conferi-los via ?vis_temporal_interactive (a função que é chamada ao utilizar plot em um objeto epicontacts com o argumento x_axis especificado). Vamos ver algumas formas abaixo.\n\nEspecificando a forma de uma árvore de transmissão\nAs árvores de transmissão podem assumir duas formas principais, especificadas utilizando o argumento network_shape. A primeira é a forma branching como mostrada acima, em que uma aresta reta conecta dois nós. Essa é a representação mais intuitiva, no entanto pode resultar em arestas sobrepostas em uma rede densamente conectada. A segunda forma é um rectangle, que produz uma árvore que se parece com uma filogenia. Por exemplo:\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n\n\n\n\n\nCada caso pode ser associado a uma posição vertical única ao se modificar o argumento position_dodge. A posição dos casos não-conectados (ex: sem nenhum contato reportado) é especificada utilizando o argumento unlinked_pos.\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  position_dodge = TRUE,\n  unlinked_pos = \"bottom\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n\n\n\n\n\nA posição dos nós pais em relação aos nós filhos pode ser especificada utilizando o argumento parent_pos. A opção padrão é posicionar o nó pai no meio, porém ele pode ser posicionado na parte de baixo (parent_pos = 'bottom') ou na parte de cima (parent_pos = 'top').\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  parent_pos = \"top\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n)\n\n\n\n\n\n\n\nSalvando os gráficos e figuras\nVocê pode salvar um mapa como um arquivo html interativo e auto-contido com a função visSave do pacote VisNetwork:\n\nplot(\n  sub,\n  x_axis = \"date_onset\",\n  network_shape = \"rectangle\",\n  node_color = \"outcome\",\n  col_pal = c(Death = \"firebrick\", Recover = \"green\"),\n  parent_pos = \"top\",\n  arrow_size = 0.5,\n  node_size = 13,\n  label = FALSE,\n  height = 700,\n  width = 700\n) %&gt;%\n  visNetwork::visSave(\"network.html\")\n\nSalvar essas saídas de redes como imagens, infelizmente não é tão simples e requer que você salve o arquivo como html e depois tire um screenshot do arquivo utilizando o pacote webshot. No código abaixo, estamos convertendo o arquivo html salvo acima em um PNG:\n\nwebshot(url = \"network.html\", file = \"network.png\")\n\n\n\n\nLinhas do Tempo\nVocê também pode incluir linhas do tempo à rede, que são representadas no eixo x de cada caso. Elas pode ser utilizadas para visualizar locais dos casos, por exemplo, ou o tempo até o desfecho. Para gerar uma linha do tempo, precisamos criar um data frame de pelo menos 3 colunas, indicadno o ID do caso, a data de início do “evento” e a data de fim do “evento”. Você também pode adicionar inúmeras outras colunas que depois podem ser mapeadas para as propriedades de nós ou arestas da linha do tempo. No código abaixo,nós geramos uma linha do tempo que vai da data de início dos sintomas até a data do desfecho, e mantemos as variáveis do desfecho e hospital que utilizamos para definir a forma e cor do nó. Note que você pode ter, por caso, mais do que uma linha do dataframe ou evento na linha do tempo, por exemplo, se um caso for transferido entre multiplos hospitais.\n\n## cria a linha do tempo\ntimeline &lt;- linelist %&gt;%\n  transmute(\n    id = case_id,\n    start = date_onset,\n    end = date_outcome,\n    outcome = outcome,\n    hospital = hospital\n  )\n\nDepois, passamos o elemento da linha do tempo para o argumento timeline. Podemos mapear os atributos da linha do tempo a cores, formas e tamanhos da mesma forma que definimos nas seções anteriores, exceto que temos dois nós: os nós de início de fim de cada timeline, que possuem argumentos separados. Por exemplo, tl_start_node_color define qual a coluna da linha do tempo está mapeada à cor do nó de início, enquanto tl_end_node_shape define qual a coluna da linha do tempo está mapeada à forma do nó final. Também podemos mapear cor, tamanho, tipo de linha e rótulos à aresta da linha do tempo via argumentos do tipo tl_edge_*.\nConfira ?vis_temporal_interactive (a função chamada ao criar um gráfico de um objeto epicontacts) para documentação detalhada dos argumentos. Cada argumento está anotado no código abaixo:\n\n## define as formas\nshapes &lt;- c(\n  f = \"female\",\n  m = \"male\",\n  Death = \"user-times\",\n  Recover = \"heartbeat\",\n  \"NA\" = \"question-circle\"\n)\n\n## define cores\ncolours &lt;- c(\n  Death = \"firebrick\",\n  Recover = \"green\",\n  \"NA\" = \"grey\"\n)\n\n## gera o gráfico\nplot(\n  sub,\n  ## mapeia a coordenada x à data de início\n  x_axis = \"date_onset\",\n  ## rede na forma retangular\n  network_shape = \"rectangle\",\n  ## mapeia a forma dos nós à coluna de gênero\n  node_shape = \"gender\",\n  ## não queremos mapear o cor do nó a nenhuma coluna - esse argumento é importante\n  ## pois o padrão é mapear ao id do nó, o que vai bagunçar o esquema de cores\n  node_color = NULL,\n  ## define o tamanho do nó dos casos como 30 (como não é uma característica dos dados, node_size não\n  ## é mapeado para nenhum coluna, mas interpretado como o real tamanho do nó)\n  node_size = 30,\n  ## define a espessura da relação como 4 (como não é uma característica dos dados, edge_width não\n  ## é mapeado para nenhum coluna, mas interpretado como a real espessura da aresta)\n  edge_width = 4,\n  ## passa o objeto da linha do tempo\n  timeline = timeline,\n  ## mapeia a forma do nó final à coluna de desfecho do objeto da linha do tempo\n  tl_end_node_shape = \"outcome\",\n  ## define o tamanho do nó final como 15 (como não é uma característica dos dados, esse\n  ## argumento não é mapeado para nenhum coluna, mas interpretado como o real\n  ## tamanho do nó)\n  tl_end_node_size = 15,\n  ## mapeia a cor da aresta da linha do tempo à coluna hospital\n  tl_edge_color = \"hospital\",\n  ## define a espessura da aresta da linha do tempo como 2 (como não é uma característica dos dados, esse\n  ## argumento não é mapeado para nenhum coluna, mas interpretado como a real\n  ## espessura da aresta)\n  tl_edge_width = 2,\n  ## mapeia os rótulos das arestas à variável hospital\n  tl_edge_label = \"hospital\",\n  ## especifica a forma para cada atributo dos nós (definido acima)\n  shapes = shapes,\n  ## especifica a paleta de cor (definido acima)\n  col_pal = colours,\n  ## define o tamanho da seta para 0.5\n  arrow_size = 0.5,\n  ## utiliza as duas colunas na legenda\n  legend_ncol = 2,\n  ## define o tamanho da fonte\n  font_size = 15,\n  ## define a o formato da data\n  date_labels = c(\"%d %b %Y\"),\n  ## não exibe os rótulos de ID abaixo dos nós\n  label = FALSE,\n  ## especifica a altura\n  height = 1000,\n  ## especifica a espessura\n  width = 1200,\n  ## garante que cada nó dos casos tenha um coordenada y única - isso é muito importante\n  ## para linhas do tempo, caso contrário você terá linhas do tempo sobrepostas para\n  ## casos diferentes\n  position_dodge = TRUE\n)\n\nWarning in assert_timeline(timeline, x, x_axis): 5865 timeline row(s) removed\nas ID not found in linelist or start/end date is NA",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Cadeias de Transmissão</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.pt.html#análise",
    "href": "new_pages/transmission_chains.pt.html#análise",
    "title": "37  Cadeias de Transmissão",
    "section": "37.5 Análise",
    "text": "37.5 Análise\n\nResumindo\nPodemos ter uma visão gerão de algumas propriedades da rede utilizando a função summary.\n\n## resume o objeto epicontacts\nsummary(epic)\n\n\n/// Overview //\n  // number of unique IDs in linelist: 5888\n  // number of unique IDs in contacts: 5511\n  // number of unique IDs in both: 4352\n  // number of contacts: 3800\n  // contacts with both cases in linelist: 56.868 %\n\n/// Degrees of the network //\n  // in-degree summary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.0000  0.0000  1.0000  0.5392  1.0000  1.0000 \n\n  // out-degree summary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.0000  0.0000  0.0000  0.5392  1.0000  6.0000 \n\n  // in and out degree summary:\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   1.000   1.000   1.078   1.000   7.000 \n\n/// Attributes //\n  // attributes in linelist:\n generation date_infection date_onset date_hospitalisation date_outcome outcome gender age age_unit age_years age_cat age_cat5 hospital lon lat infector source wt_kg ht_cm ct_blood fever chills cough aches vomit temp time_admission bmi days_onset_hosp\n\n  // attributes in contacts:\n location duration\n\n\nPor exemplo, podemos ver que apenas 57% dos contatos possuem ambos os casos na linelist; isso significa que nós não temos dados da linelist sobre um número significativo de casos envolvidos nessas cadeias de transmissão.\n\n\nCaracterísticas por pares\nA função get_pairwise() permite o processamento de variáveis na linelist de acordo com cada par na base de dados de contatos. Para o seguinte exemplo, a data de início da doença é extraída da linelist para calcular a diferença entre a data de início para cada par. O valor produzido a partir dessa comparação representa o intervalo serial (si)\n\nsi &lt;- get_pairwise(epic, \"date_onset\")\nsummary(si)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n   0.00    5.00    9.00   11.01   15.00   99.00    1820 \n\ntibble(si = si) %&gt;%\n  ggplot(aes(si)) +\n  geom_histogram() +\n  labs(\n    x = \"Serial interval\",\n    y = \"Frequency\"\n  )\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\nWarning: Removed 1820 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\nA get_pairwise() vai interpretar a classe da coluna sendo utilizada para comparação e vai ajustar o seu método de comparar os valores de acordo. Para números e datas (como si do exemplo acima), a função vai subtrair os valores. Quando aplicado a colunas de caracteres ou categóricas, get_pairwise() vai colar (paste) os valores. Pelo fato da função também permitir processamentos arbitrários (veja o argumento “f”), essas combinações discretas podem ser facilmente tabuladas e analisadas.\n\nhead(get_pairwise(epic, \"gender\"), n = 10)\n\n [1] \"f -&gt; m\" NA       \"m -&gt; m\" NA       \"m -&gt; f\" \"f -&gt; f\" NA       \"f -&gt; m\"\n [9] NA       \"m -&gt; f\"\n\nget_pairwise(epic, \"gender\", f = table)\n\n           values.to\nvalues.from   f   m\n          f 464 516\n          m 510 468\n\nfisher.test(get_pairwise(epic, \"gender\", f = table))\n\n\n    Fisher's Exact Test for Count Data\n\ndata:  get_pairwise(epic, \"gender\", f = table)\np-value = 0.03758\nalternative hypothesis: true odds ratio is not equal to 1\n95 percent confidence interval:\n 0.6882761 0.9892811\nsample estimates:\nodds ratio \n 0.8252575 \n\n\nAqui observamos uma associação significativa entra as relações de transmissão e gênero.\n\n\nIdentificando agrupamentoss\nA função get_clusters() pode ser utilizada para identificar componentes conectados em um objeto epicontacts. Primeiro, utilizamos para recuperar um data.frame contendo a informação dos agrupamentos:\n\nclust &lt;- get_clusters(epic, output = \"data.frame\")\ntable(clust$cluster_size)\n\n\n   1    2    3    4    5    6    7    8    9   10   11   12   13   14 \n1536 1680 1182  784  545  342  308  208  171  100   99   24   26   42 \n\nggplot(clust, aes(cluster_size)) +\n  geom_bar() +\n  labs(\n    x = \"Cluster size\",\n    y = \"Frequency\"\n  )\n\n\n\n\n\n\n\n\nLet us look at the largest clusters. For this, we add cluster information to the epicontacts object and then subset it to keep only the largest clusters: Vamos dar uma olhada nos maiores agrupamentos. Para isso, vamos adicionar informações de agrupamentos ao objeto epicontacts e depois fazer um subconjunto para manter apenas os maiores agrupamentos:\n\nepic &lt;- get_clusters(epic)\nmax_size &lt;- max(epic$linelist$cluster_size)\nplot(subset(epic, cs = max_size))\n\n\n\n\n\n\n\nCalculando graus\nO grau de um nó corresponde ao seu número de arestas ou conexões com outros nós. get_degree() disponibiliza um método fácil para calcular esse valor para redes de epicontacts. Um grau alto nesse contexo indica um indivíduo que esteve em contato com vários outros. O argumento type indica que nós queremos contar tanto o grau de entrada (in-degree) quanto o de saída (out-degree) e o argumento only_linelist indica que queremos calcular apenas o grau para os casos que estejam na linelist.\n\ndeg_both &lt;- get_degree(epic, type = \"both\", only_linelist = TRUE)\n\nQuais os primeiros 10 indivíduos com a maior quantidade de contatos?\n\nhead(sort(deg_both, decreasing = TRUE), 10)\n\n916d0a 858426 6833d7 f093ea 11f8ea 3a4372 38fc71 c8c4d5 a127a7 02d8fd \n     7      6      6      6      5      5      5      5      5      5 \n\n\nQual o número médio de contatos?\n\nmean(deg_both)\n\n[1] 1.078473",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Cadeias de Transmissão</span>"
    ]
  },
  {
    "objectID": "new_pages/transmission_chains.pt.html#recursos",
    "href": "new_pages/transmission_chains.pt.html#recursos",
    "title": "37  Cadeias de Transmissão",
    "section": "37.6 Recursos",
    "text": "37.6 Recursos\nA página epicontacts disponibiliza uma visão geral das funções do pacote e inclui algumas outras vignettes mais aprofundadas.\nA páginad do github pode ser utilizada para registrar problemas (issues) e solicitar funcionalidades.",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>37</span>  <span class='chapter-title'>Cadeias de Transmissão</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.pt.html",
    "href": "new_pages/phylogenetic_trees.pt.html",
    "title": "38  Árvores filogenéticas",
    "section": "",
    "text": "38.1 Visão Geral\nÁrvores filogenéticas são utilizados para visualizar e descrever a relação e evolução dos organismos com base no sequenciamento de seu código genético.\nElas podem ser construídos a partir de seqüências genéticas usando métodos baseados na distância (como o método de união de vizinhos) ou métodos baseados em caracteres (como o método de máxima verossimilhança e o método Baysiano de Monte Carlo via Cadeias de Markov ). O sequenciamento de próxima geração (NGS) tornou-se mais acessível e está se tornando mais amplamente utilizado na saúde pública para descrever patógenos causadores de doenças infecciosas. Os dispositivos portáteis de seqüenciamento diminuem o tempo de retorno e mantêm promessas de disponibilizar dados para o apoio à investigação de surtos em tempo real. Os dados da NGS podem ser usados para identificar a origem ou fonte de uma variante de surto e sua propagação, bem como determinar a presença de genes de resistência antimicrobiana. Para visualizar a relação genética entre as amostras, é construída uma árvore filogenética.\nNesta página aprenderemos como utilizar o pacote ggtree, que permite a visualização combinada de árvores filogenéticas com dados adicionais de amostras sob a forma de um data frame. Isto nos permitirá observar padrões e melhorar a compreensão da dinâmica do surto.",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Árvores filogenéticas</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.pt.html#preparação",
    "href": "new_pages/phylogenetic_trees.pt.html#preparação",
    "title": "38  Árvores filogenéticas",
    "section": "38.2 Preparação",
    "text": "38.2 Preparação\n\nCarregar pacotes\nEste trecho de código mostra o carregamento dos pacotes necessárias. Neste manual, enfatizamos p_load() de pacman, que instala o pacote se necessário e o carrega para utilização. Você também pode carregar os pacotes instalados com library() do R base. Veja a página em Introdução ao R para mais informações sobre os pacotes R.\n\npacman::p_load(\n  rio,             # importar/exportar\n  here,            # caminhos relativos dos arquivos\n  tidyverse,       # manipulações e visualizações gerais de dados\n  ape,             # para importar e exportar dados de árvores filogenéticas\n  ggtree,          # para visualizar dados de árvores filogenéticas \n  treeio,          # para visualizar dados de árvores filogenéticas \n  ggnewscale)      # adicionar camadas de esquema de cores \n\n\n\nImportar dados\nOs dados para esta página podem ser baixados com as instruções na página Baixar manual e dados.\nHá vários formatos diferentes nos quais uma árvore filogenética pode ser armazenada (por exemplo, Newick, NEXUS, Phylip). Um muito comum é o formato de arquivo Newick (.nwk), que é o padrão para representar árvores em formato legível por computador. Isto significa que uma árvore inteira pode ser expressa em formato de string como “((t2:0.04,t1:0.34):0.89,(t5:0.37,(t4:0.03,t3:0.67):0.9):0.59);”, listando todos os nós e ápices e a relação (comprimento do ramo) entre si.\nNota: É importante entender que o arquivo de árvore filogenética em si não contém dados de sequenciamento, mas é meramente o resultado das distâncias genéticas entre as seqüências. Portanto, não podemos extrair dados de seqüenciamento de um arquivo de árvore.\nPrimeiro, utilizamos a função read.tree() do pacote ape para importar um arquivo de árvore filogenética Newick em formato .txt, e armazená-lo em uma lista de objetos da classe “phylo”. Se necessário, utilize a função here() do pacote here para especificar o caminho relativo do arquivo.\nNota: Neste caso, a árvore newick é salva como um arquivo .txt para facilitar o manuseio e o download do Github.\n\ntree &lt;- ape::read.tree(\"Shigella_tree.txt\")\n\nInspecionamos nosso objeto árvore e vemos que ele contém 299 ápices/pontas (ou amostras) e 236 nós.\n\ntree\n\n\nPhylogenetic tree with 299 tips and 236 internal nodes.\n\nTip labels:\n  SRR5006072, SRR4192106, S18BD07865, S18BD00489, S17BD08906, S17BD05939, ...\nNode labels:\n  17, 29, 100, 67, 100, 100, ...\n\nRooted; includes branch lengths.\n\n\nSegundo, importamos uma tabela armazenada como um arquivo .csv com informações adicionais para cada amostra sequenciada, como sexo, país de origem e atributos de resistência antimicrobiana, utilizando a função import() do pacote rio:\n\nsample_data &lt;- import(\"sample_data_Shigella_tree.csv\")\n\nAbaixo estão as primeiras 50 linhas de observação dos dados:\n\n\n\n\n\n\n\n\nLimpar e inspecionar\nNós limpamos e inspecionamos nossos dados: A fim de atribuir os dados da amostra correta à árvore filogenética, os valores na coluna Sample_ID no data frame sample_data precisam corresponder aos valores tip.labels do arquivo tree:\nVerificamos a formatação das tip.labels no arquivo tree observando as primeiras 6 entradas utilizando com head() do R base.\n\nhead(tree$tip.label) \n\n[1] \"SRR5006072\" \"SRR4192106\" \"S18BD07865\" \"S18BD00489\" \"S17BD08906\"\n[6] \"S17BD05939\"\n\n\nTambém nos certificamos de que a primeira coluna em nosso data frame “Sample_data” seja “Sample_ID”. Olhamos os nomes das colunas de nosso data frame utilizando colnames() dm R base.\n\ncolnames(sample_data)   \n\n [1] \"Sample_ID\"                  \"serotype\"                  \n [3] \"Country\"                    \"Continent\"                 \n [5] \"Travel_history\"             \"Year\"                      \n [7] \"Belgium\"                    \"Source\"                    \n [9] \"Gender\"                     \"gyrA_mutations\"            \n[11] \"macrolide_resistance_genes\" \"MIC_AZM\"                   \n[13] \"MIC_CIP\"                   \n\n\nOlhamos para os Sample_IDs no data frame para ter certeza de que a formatação é a mesma do que na tip.label (por exemplo, todas as letras são maiúsculas, sem sublinhados extras `_’ entre letras e números, etc.)\n\nhead(sample_data$Sample_ID) # novamente inspecionamos os primeiros 6 usando head()\n\n[1] \"S17BD05944\" \"S15BD07413\" \"S18BD07247\" \"S19BD07384\" \"S18BD07338\"\n[6] \"S18BD02657\"\n\n\nTambém podemos comparar se todas as amostras estão presentes no arquivo “tree” e vice-versa, gerando um vetor lógico de VERDADEIRO ou FALSO onde elas coincidem ou não. Estas não são impressas aqui, por simplicidade.\n\nsample_data$Sample_ID %in% tree$tip.label\n\ntree$tip.label %in% sample_data$Sample_ID\n\nPodemos usar estes vetores para mostrar qualquer identificação de amostra que não esteja na árvore (não há nenhuma).\n\nsample_data$Sample_ID[!tree$tip.label %in% sample_data$Sample_ID]\n\ncharacter(0)\n\n\nApós a inspeção, podemos ver que o formato do Sample_ID no data frame corresponde ao formato dos nomes das amostras nas tip.labels. Estas não precisam ser classificadas na mesma ordem para serem combinadas.\nEstamos prontos para ir!",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Árvores filogenéticas</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.pt.html#visualização-simples-da-árvore",
    "href": "new_pages/phylogenetic_trees.pt.html#visualização-simples-da-árvore",
    "title": "38  Árvores filogenéticas",
    "section": "38.3 Visualização simples da árvore",
    "text": "38.3 Visualização simples da árvore\n\nDiferente layouts para a árvore\nggtree* oferece muitos formatos de layout diferentes e alguns podem ser mais adequados para seu propósito específico do que outros. Abaixo estão algumas demonstrações. Para outras opções, veja este livro online.\nAqui estão alguns exemplos de layouts de árvores:\n\nggtree(tree)                                            # árvore linear simples\nggtree(tree,  branch.length = \"none\")                   # árvore linear simples com todas as pontas alinhadas\nggtree(tree, layout=\"circular\")                         # árvore circular simples\nggtree(tree, layout=\"circular\", branch.length = \"none\") # árvore circular simples com todas as pontas alinhadas\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nÁrvore simples com dados de amostras\nO operador %&lt;+%* é utilizado para conectar o data frame sample_data ao arquivo tree. A anotação mais fácil de sua árvore é a adição dos nomes das amostras nas pontas, assim como a coloração dos pontos da ponta e, se desejado, dos ramos:\nAqui está um exemplo de uma árvore circular:\n\nggtree(tree, layout = \"circular\", branch.length = 'none') %&lt;+% sample_data + # %&lt;+% unifica o datarframe com os dados de amostras à arvore\n  aes(color = Belgium)+                       # colore os ramos de acordo com a variável no seu dataframe c\n  scale_color_manual(\n    name = \"Sample Origin\",                      # nome do seu esquema de cotes (irá aparecer assim na legenda) \n    breaks = c(\"Yes\", \"No\"),                     # as diferentes opções na sua variável\n    labels = c(\"NRCSS Belgium\", \"Other\"),        # como você quer que as diferentes opções sejam nomeadas na sua legenda, permite formatação \n    values = c(\"blue\", \"black\"),                  # a cor que você atribuir à variável\n    na.value = \"black\")+                        # colore valores NA como preto também\n  new_scale_color()+                             # permite adicionar um novo esquema de cores para uma nova variável\n    geom_tippoint(\n      mapping = aes(color = Continent),          # cor das pontas por continente. Você pode mudar o formato adicionando \"shape = \"\n      size = 1.5)+                               # define o tamanho do ponto na ponta \n  scale_color_brewer(\n    name = \"Continent\",                    # nome do seu esquema de cotes (irá aparecer assim na legenda) \n    palette = \"Set1\",                      #  escolhemos uma paleta de cores do pacote Brewer \n    na.value = \"grey\")+                    # para valores NA escolhemos o cinza \n  geom_tiplab(                             # adiciona o nome da amostra para a ponta do ramo \n    color = 'black',                       # (adiciona quantas linhas de texto desejar, mas talvez precise ajustar o valor de partida para coloca-los proximos uns aos outros. \n    offset = 1,\n    size = 1,\n    geom = \"text\",\n    #align = TRUE\n    )+\n  ggtitle(\"Árvore filogenética de Shigella sonnei\")+       # título do seu gráfico\n  theme(\n    axis.title.x = element_blank(), # remove título de eixo x\n    axis.title.y = element_blank(), # remove título de eixo y\n    legend.title = element_text(    # define o tamanho da fonte e formata a o título da legenda\n      face = \"bold\",\n      size = 12),   \n    legend.text=element_text(       # define o tamanho da fonte e formata o texto da legenda\n      face = \"bold\",\n      size = 10),  \n    plot.title = element_text(      # define o tamanho da fonte e formata o título do gráfico\n      size = 12,\n      face = \"bold\"),  \n    legend.position = \"bottom\",     # define a posição da legenda\n    legend.box = \"vertical\",        # define o posicionamento da legenda\n    legend.margin = margin())   \n\n\n\n\n\n\n\n\nVocê pode exportar seu gráfico de árvore com ggsave() como qualquer outro objeto ggplot’. Escrito desta forma, ggsave() salva a última imagem produzida para o caminho do arquivo que você especificar. Lembre-se de que você pode utilizar here() e caminhos de arquivo relativos para salvar facilmente em subpastas, etc.\n\nggsave(\"example_tree_circular_1.png\", width = 12, height = 14)",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Árvores filogenéticas</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.pt.html#manipulação-da-árvore",
    "href": "new_pages/phylogenetic_trees.pt.html#manipulação-da-árvore",
    "title": "38  Árvores filogenéticas",
    "section": "38.4 Manipulação da árvore",
    "text": "38.4 Manipulação da árvore\nÀs vezes você pode ter uma árvore filogenética muito grande e só está interessado em uma parte da árvore. Por exemplo, se você produziu uma árvore incluindo amostras históricas ou internacionais para obter uma grande visão geral de onde seu conjunto de dados pode se encaixar no quadro geral. Mas então, para olhar mais de perto seus dados, você quer inspecionar apenas aquela parte da árvore maior.\nComo o arquivo filogenético da árvore é apenas a saída da análise sequencial de dados, não podemos manipular a ordem dos nós e ramos no próprio arquivo. Estes já foram determinados em análises anteriores a partir dos dados brutos do NGS. No entanto, somos capazes de fazer zoom em partes, esconder partes e até mesmo subdividir parte da árvore.\n\nAumentar o zoom\nSe você não quiser “cortar” sua árvore, mas apenas inspecionar parte dela mais de perto, você pode ampliar para ver uma parte específica.\nPrimeiro, plotamos a árvore inteira em formato linear e adicionamos etiquetas numéricas a cada nó da árvore.\n\np &lt;- ggtree(tree,) %&lt;+% sample_data +\n  geom_tiplab(size = 1.5) + # adicionamos rótulos às pontas de todos os ramos como nome da amostra no arquivo \n  geom_text2(\n    mapping = aes(subset = !isTip,\n                  label = node),\n    size = 5,\n    color = \"darkred\",\n    hjust = 1,\n    vjust = 1)                            # adiciona rótulos em todos os nós\n\np  # printa\n\n\n\n\n\n\n\n\nPara aumentar o zoom para um ramo em particular (à direita), utilize viewClade() no objeto ggtree p e forneça o número do nó para obter uma visão mais detalhada:\n\nviewClade(p, node = 452)\n\n\n\n\n\n\n\n\n\n\nColapsando ramos\nNo entanto, podemos querer ignorar este ramo e podemos colapsa-lo naquele mesmo nó (nó nº 452) utilizando collapse(). Esta árvore é definida como p_collapsed.\n\np_collapsed &lt;- collapse(p, node = 452)\np_collapsed\n\n\n\n\n\n\n\n\nPara maior clareza, quando imprimimos p_collapsed', adicionamos umgeom_point2()` (um diamante azul) no nó do ramo colapsado.\n\np_collapsed + \ngeom_point2(aes(subset = (node == 452)),  # adicionamos um símbolo ao nó colapsado \n            size = 5,                     # define o tamanho do símbolo  \n            shape = 23,                   # define a forma do símbolo  \n            fill = \"steelblue\")           # define a cor do símbolo \n\n\n\n\n\n\n\n\n\n\nSubdividindo uma árvore\nSe quisermos fazer uma mudança mais permanente e criar uma árvore nova e reduzida para trabalhar com ela, podemos separar parte dela com tree_subset(). Então você pode salvá-la como novo arquivo newick tree ou arquivo .txt.\nPrimeiro, inspecionamos os nós de árvore e os rótulos das pontas a fim de decidir como subdividi-la.\n\nggtree(\n  tree,\n  branch.length = 'none',\n  layout = 'circular') %&lt;+% sample_data +               # adicionamos os dados das amostras usando o operdor  %&lt;+% \n  geom_tiplab(size = 1)+                                # rotula as pontas dos ramos com o nome da amostra \n  geom_text2(\n    mapping = aes(subset = !isTip, label = node),\n    size = 3,\n    color = \"darkred\") +                                # rotula todos os nós na árvore \n theme(\n   legend.position = \"none\",                            # remove a legenda completamente\n   axis.title.x = element_blank(),\n   axis.title.y = element_blank(),\n   plot.title = element_text(size = 12, face=\"bold\"))\n\n\n\n\n\n\n\n\nAgora, digamos que decidimos dividir a árvore no nó 528 (manter apenas as pontas dentro deste ramo após o nó 528) e a salvamos como um novo objeto sub_tree1:\n\nsub_tree1 &lt;- tree_subset(\n  tree,\n  node = 528)                                            # subdividimos a árvore no nó 528 \n\nVamos dar uma olhada na árvore do subconjunto 1 (subset tree 1):\n\nggtree(sub_tree1) +\n  geom_tiplab(size = 3) +\n  ggtitle(\"Subset tree 1\")\n\n\n\n\n\n\n\n\nVocê também pode dividir com base em uma amostra específica, especificando quantos nós “para trás” você deseja incluir. Vamos subdividir a mesma parte da árvore com base em uma amostra, neste caso S17BD07692, retrocedendo 9 nós e a salvamos como um novo objeto sub_tree2:\n\nsub_tree2 &lt;- tree_subset(\n  tree,\n  \"S17BD07692\",\n  levels_back = 9) #  levels_back define quantos nós você quer retroceder da ponta da amostra  \n\nVamos dar uma olhada na árvore do subconjunto 2:\n\nggtree(sub_tree2) +\n  geom_tiplab(size =3)  +\n  ggtitle(\"Subset tree 2\")\n\n\n\n\n\n\n\n\nVocê também pode salvar sua nova árvore como um tipo Newick ou mesmo um arquivo de texto utilizando a função write.tree() do pacote ape:\n\n# salvar no formato .nwk \nape::write.tree(sub_tree2, file='data/phylo/Shigella_subtree_2.nwk')\n\n# salvar no formato .txt \nape::write.tree(sub_tree2, file='data/phylo/Shigella_subtree_2.txt')\n\n\n\nRotacionando nós em uma árvore\nComo mencionado anteriormente, não podemos mudar a ordem das pontas ou nós na árvore, pois isto se baseia em sua relação genética e não está sujeito a manipulação visual. Mas podemos girar ramos em torno dos nós se isso facilitar nossa visualização.\nPrimeiro, traçamos nossa nova árvore “sub_tree2” com etiquetas de nós para escolher o nó que queremos manipular e armazená-lo como um objeto do tipo gráfico ggtree p.\n\np &lt;- ggtree(sub_tree2) +  \n  geom_tiplab(size = 4) +\n  geom_text2(aes(subset=!isTip, label=node), # rotula todos os nós em uma árvore\n             size = 5,\n             color = \"darkred\", \n             hjust = 1, \n             vjust = 1) \np\n\n\n\n\n\n\n\n\nPodemos então manipular os nós aplicando ggtree::rotate() ou ggtree::flip(): Nota: para ilustrar quais nós estamos manipulando, aplicamos primeiro a função geom_hilight() de ggtree para destacar as amostras nos nós em que estamos interessados e armazenar esse objeto ggtree em um novo objeto p1.\n\np1 &lt;- p + geom_hilight(  # destaca o nó 39 em azul, \"extend =\" nos permite definir a cor do bloco \n  node = 39,\n  fill = \"steelblue\",\n  extend = 0.0017) +  \ngeom_hilight(            # destaca o nó 37 em amarelo \n  node = 37,\n  fill = \"yellow\",\n  extend = 0.0017) +               \nggtitle(\"Árvore Original\")\n\n\np1 # printa\n\n\n\n\n\n\n\n\nAgora podemos girar o nó 37 no objeto p1 para que as amostras no nó 38 se movam para o topo. Armazenamos a árvore rotacionada em um novo objeto p2.\n\np2 &lt;- ggtree::rotate(p1, 37) + \n      ggtitle(\"Nó 37 rotacionado\")\n\n\np2   # printa\n\n\n\n\n\n\n\n\nOu podemos usar a função flip() para rotacuonar o nó 36 do objeto p1 e mudar o nó 37 para o topo e o nó 39 para o fundo. Armazenamos a árvore invertida em um novo objeto p3.\n\np3 &lt;- ggtree::flip(p1, 39, 37) +\n      ggtitle(\"Nó 36 rotacionado\")\n\n\np3   # printa\n\n\n\n\n\n\n\n\n\n\nExamplo de sub-árvore com informações das amostras\nDigamos que estamos investigando o conjunto de casos com expansão clonal que ocorreram em 2017 e 2018 no nó 39 de nossa sub-árvore. Acrescentamos o ano de isolamento da linhagem, bem como o histórico de viagem e a cor por país para ver a origem de outras linhagens intimamente relacionadas:\n\nggtree(sub_tree2) %&lt;+% sample_data +     # Usamos o operador %&lt;+% para juntar com sample_data\n  geom_tiplab(                          # rotula as pontas dos ramos com  os nomes das amotras \n    size = 2.5,\n    offset = 0.001,\n    #align = TRUE\n    ) + \n  theme_tree2()+\n  xlim(0, 0.015)+                       # configura os limite do eixo x \n  geom_tippoint(aes(color=Country),     # colore a ponta de acordo com o continente  \n                size = 1.5)+ \n  scale_color_brewer(\n    name = \"Country\", \n    palette = \"Set1\", \n    na.value = \"grey\")+\n  geom_tiplab(                          #  adiciona o ano de isolamento como um rótulo de texto nas pontas a\n    aes(label = Year),\n    color = 'blue',\n    offset = 0.0045,\n    size = 3,\n    linetype = \"blank\" ,\n    geom = \"text\",\n    #align = TRUE\n    )+ \n  geom_tiplab(                          # adiciona histórico de viagem nas pontas em vermelho \n    aes(label = Travel_history),\n    color = 'red',\n    offset = 0.006,\n    size = 3,\n    linetype = \"blank\",\n    geom = \"text\",\n    #align = TRUE\n    )+ \n  ggtitle(\"Árvore filogenética de de estirpes de Belgian S. sonnei com histórico de viagens\")+  # adiciona título \n  xlab(\"distância genética (0.001 = 4 nucleotídeos de diferença)\")+   # adiciona legenda do eixo x\n  theme(\n    axis.title.x = element_text(size = 10),\n    axis.title.y = element_blank(),\n    legend.title = element_text(face = \"bold\", size = 12),\n    legend.text = element_text(face = \"bold\", size = 10),\n    plot.title = element_text(size = 12, face = \"bold\"))\n\n\n\n\n\n\n\n\nNossa observação aponta para um evento de importação de cepas da Ásia, que então circularam na Bélgica ao longo dos anos e parecem ter causado nosso último surto.",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Árvores filogenéticas</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.pt.html#árvores-mais-complexas-adição-de-heatmaps-de-dados-de-amostra",
    "href": "new_pages/phylogenetic_trees.pt.html#árvores-mais-complexas-adição-de-heatmaps-de-dados-de-amostra",
    "title": "38  Árvores filogenéticas",
    "section": "Árvores mais complexas: adição de heatmaps de dados de amostra",
    "text": "Árvores mais complexas: adição de heatmaps de dados de amostra\nPodemos acrescentar informações mais complexas, como a presença categórica de genes de resistência antimicrobiana e valores numéricos para resistência realmente medida a antimicrobianos na forma de um mapa térmico usando a função ggtree::gheatmap().\nPrimeiro precisamos traçar nossa árvore (esta pode ser linear ou circular) e armazená-la em um novo objeto de traçado ggtree p: Utilizaremos a sub-árvore da parte 3).\n\np &lt;- ggtree(sub_tree2, branch.length='none', layout='circular') %&lt;+% sample_data +\n  geom_tiplab(size =3) + \n theme(\n   legend.position = \"none\",\n    axis.title.x = element_blank(),\n    axis.title.y = element_blank(),\n    plot.title = element_text(\n      size = 12,\n      face = \"bold\",\n      hjust = 0.5,\n      vjust = -15))\np\n\n\n\n\n\n\n\n\nEm segundo lugar, preparamos nossos dados. Para visualizar as diferentes variáveis com novos esquemas de cores, nós subdividimos nosso dataframe para a variável desejada. É importante adicionar o Sample_ID como nomes das linhas, caso contrário, ele não pode fazer a correspondência dos dados com a árvore tip.labels:\nEm nosso exemplo, queremos analisar o gênero e as mutações que poderiam conferir resistência à Ciprofloxacina, um importante antibiótico de primeira linha utilizado para tratar as infecções por Shigella.\nCriamos um dataframe para gênero:\n\ngender &lt;- data.frame(\"gender\" = sample_data[,c(\"Gender\")])\nrownames(gender) &lt;- sample_data$Sample_ID\n\nCriamos um dataframe para mutações no gene gyrA, que confere resistência à Ciprofloxacina:\n\ncipR &lt;- data.frame(\"cipR\" = sample_data[,c(\"gyrA_mutations\")])\nrownames(cipR) &lt;- sample_data$Sample_ID\n\nCriamos um dataframe para a concentração inibitória mínima medida (MIC) de Ciprofloxacina do laboratório:\n\nMIC_Cip &lt;- data.frame(\"mic_cip\" = sample_data[,c(\"MIC_CIP\")])\nrownames(MIC_Cip) &lt;- sample_data$Sample_ID\n\nCriamos um primeiro gráfico adicionando um heatmap binário para gênero à árvore filogenética e armazenando-o em um novo objeto do tipo gráfico ggtree h1:\n\nh1 &lt;-  gheatmap(p, gender,                                 # adicionamos uma camada \"heatmap\" de gênero ao gráfico\n                offset = 10,                               # \"offset\" muda o heatmap para a direita,\n                width = 0.10,                              # \"width\" define ta largura da coluna do heatmap,\n                color = NULL,                              # \"color\"  define a borda da coluna do  heatmap \n         colnames = FALSE) +                               # esconde a coluna de nomes do heatmap\n  scale_fill_manual(name = \"Gender\",                       # define o esquema de cores e a legenda do gênero \n                    values = c(\"#00d1b1\", \"purple\"),\n                    breaks = c(\"Male\", \"Female\"),\n                    labels = c(\"Male\", \"Female\")) +\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\nh1\n\n\n\n\n\n\n\n\nDepois adicionamos informações sobre mutações no gene gyrA, que conferem resistência ao Ciprofloxacina:\nNota: A presença de mutações cromossômicas pontuais nos dados do WGS foi previamente determinada usando a ferramenta PointFinder desenvolvida por Zankari et al. (ver referência na seção de referências adicionais)\nPrimeiro, atribuímos um novo esquema de cores ao nosso objeto do tipo gráfico existente emh1 e o armazenamos em um objeto agora h2. Isto nos permite definir e mudar as cores para nossa segunda variável no heatmap.\n\nh2 &lt;- h1 + new_scale_fill() \n\nDepois adicionamos a segunda camada do heatmap ao h2 e armazenamos os gráficos combinados em um novo objeto h3:\n\nh3 &lt;- gheatmap(h2, cipR,  # adiciona uma segunda linha de heatmap descrevendo a mutação de resistência da Ciprofloxacina\n               offset = 12, \n               width = 0.10, \n               colnames = FALSE) +\n  scale_fill_manual(name = \"Mutações que conferem \\n resistência a Ciprofloxacina\",\n                    values = c(\"#fe9698\",\"#ea0c92\"),\n                    breaks = c( \"gyrA D87Y\", \"gyrA S83L\"),\n                    labels = c( \"gyrA d87y\", \"gyrA s83l\")) +\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())+\n  guides(fill = guide_legend(nrow = 2,byrow = TRUE))\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\nh3\n\n\n\n\n\n\n\n\nRepetimos o processo acima, primeiro adicionando uma nova camada de escala de cor ao nosso objeto existente h3, e depois adicionando os dados contínuos sobre a concentração inibitória mínima (MIC) de Ciprofloxacina para cada estirpe ao objeto resultante h4 para produzir o objeto final h5:\n\n# Primeiro adicionamos o novo esquema de cores\nh4 &lt;- h3 + new_scale_fill()\n\n# e então combinamos os dois em um novo gráfico:\nh5 &lt;- gheatmap(h4, MIC_Cip,  \n               offset = 14, \n               width = 0.10,\n                colnames = FALSE)+\n  scale_fill_continuous(name = \"MIC para Ciprofloxacina\",  # definimos uma cor em gradiente para a variável contínua MIC \n                      low = \"yellow\", high = \"red\",\n                      breaks = c(0, 0.50, 1.00),\n                      na.value = \"white\") +\n   guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\nh5\n\n\n\n\n\n\n\n\nPodemos fazer o mesmo exercício para uma árvore linear:\n\np &lt;- ggtree(sub_tree2) %&lt;+% sample_data +\n  geom_tiplab(size = 3) + # rotupa as pontas\n  theme_tree2()+\n  xlab(\"distância gentética (0.001 = 4 nucleotídeos de diferença)\")+\n  xlim(0, 0.015)+\n theme(legend.position = \"none\",\n      axis.title.y = element_blank(),\n      plot.title = element_text(size = 12, \n                                face = \"bold\",\n                                hjust = 0.5,\n                                vjust = -15))\np\n\n\n\n\n\n\n\n\nPrimeiro, adicionamos o gênero:\n\nh1 &lt;-  gheatmap(p, gender, \n                offset = 0.003,\n                width = 0.1, \n                color=\"black\", \n         colnames = FALSE)+\n  scale_fill_manual(name = \"Gender\",\n                    values = c(\"#00d1b1\", \"purple\"),\n                    breaks = c(\"Male\", \"Female\"),\n                    labels = c(\"Male\", \"Female\"))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\nh1\n\n\n\n\n\n\n\n\nDepois adicionamos as mutações de resistência Ciprofloxacina depois de adicionar outra camada de esquema de cores:\n\nh2 &lt;- h1 + new_scale_fill()\nh3 &lt;- gheatmap(h2, cipR,   \n               offset = 0.004, \n               width = 0.1,\n               color = \"black\",\n                colnames = FALSE)+\n  scale_fill_manual(name = \"Mutações que conferem \\n resistência a Ciprofloxacina\",\n                    values = c(\"#fe9698\",\"#ea0c92\"),\n                    breaks = c( \"gyrA D87Y\", \"gyrA S83L\"),\n                    labels = c( \"gyrA d87y\", \"gyrA s83l\"))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 12),\n        legend.text = element_text(size = 10),\n        legend.box = \"vertical\", legend.margin = margin())+\n  guides(fill = guide_legend(nrow = 2,byrow = TRUE))\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\n h3\n\n\n\n\n\n\n\n\nEm seguida, adicionamos a concentração inibitória mínima determinada pelo laboratório (MIC):\n\nh4 &lt;- h3 + new_scale_fill()\nh5 &lt;- gheatmap(h4, MIC_Cip, \n               offset = 0.005,  \n               width = 0.1,\n               color = \"black\", \n                colnames = FALSE)+\n  scale_fill_continuous(name = \"MIC para Ciprofloxacina\",\n                      low = \"yellow\", high = \"red\",\n                      breaks = c(0,0.50,1.00),\n                      na.value = \"white\")+\n   guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+\n   theme(legend.position = \"bottom\",\n        legend.title = element_text(size = 10),\n        legend.text = element_text(size = 8),\n        legend.box = \"horizontal\", legend.margin = margin())+\n  guides(shape = guide_legend(override.aes = list(size = 2)))\n\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n\nh5",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Árvores filogenéticas</span>"
    ]
  },
  {
    "objectID": "new_pages/phylogenetic_trees.pt.html#resources",
    "href": "new_pages/phylogenetic_trees.pt.html#resources",
    "title": "38  Árvores filogenéticas",
    "section": "38.5 Resources",
    "text": "38.5 Resources\nhttp://hydrodictyon.eeb.uconn.edu/eebedia/index.php/Ggtree# Clade_Colors https://bioconductor.riken.jp/packages/3.2/bioc/vignettes/ggtree/inst/doc/treeManipulation.html https://guangchuangyu.github.io/ggtree-book/chapter-ggtree.html https://bioconductor.riken.jp/packages/3.8/bioc/vignettes/ggtree/inst/doc/treeManipulation.html\nEa Zankari, Rosa Allesøe, Katrine G Joensen, Lina M Cavaco, Ole Lund, Frank M Aarestrup, PointFinder: a novel web tool for WGS-based detection of antimicrobial resistance associated with chromosomal point mutations in bacterial pathogens, Journal of Antimicrobial Chemotherapy, Volume 72, Issue 10, October 2017, Pages 2764–2768, https://doi.org/10.1093/jac/dkx217",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>38</span>  <span class='chapter-title'>Árvores filogenéticas</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.pt.html",
    "href": "new_pages/interactive_plots.pt.html",
    "title": "39  Gráficos interativos",
    "section": "",
    "text": "39.1 Preparação",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Gráficos interativos</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.pt.html#preparação",
    "href": "new_pages/interactive_plots.pt.html#preparação",
    "title": "39  Gráficos interativos",
    "section": "",
    "text": "Carregando os pacotes\nEsta parte de código(chunk) mostra o carregamento de pacotes necessários para as análises, com destaque p_load() do pacman, que instala o pacote se necessário e o carrega para uso. Você também pode carregar utilizando a função library() - “R base”. Para mais informações sobre pacotes consulte o capítulo Introdução ao R.\n\npacman::p_load(\n  rio,       # importar e exportar dados\n  here,      # especificar caminho dos dados\n  lubridate, # trabalhar dados\n  plotly,    # graficos interativos\n  scales,    # percents\n  tidyverse, # manuseio e visualização\n  incidence2,# gráfico epicurva\n  magrittr)  # pipe %&gt;%\n# Verificar a versão do R, o pacote pacman e o rio  foi construido na versão 4.1.2\n\n\n\nComece com um ggplot()\nNessa seção, assumimos que que você está começando com um gráfico ggplot() que pretende tornar interativo. Vamos contruir então, vários gráficos usando o linelist de casos, exemplo utilizado em outros capítulos deste manual.\n\n\nImportar os dados\nPara começar, importe a lista de casos (limpa/organizada) de uma epidemia simulada de Ebola. Se quiser acompanhar o script, &lt;ahref=‘https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds’ class=‘download-button’&gt; clique para baixar a linelist “limpa” (como arquivo .rds). Importe dados com a função import() do pacote rio (ele lida com vários tipos de arquivos como .xlsx, .csv, .rds - veja a página Importar e exportar para mais detalhes).\n\n# Importar os casos linelist (Ébola)\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nAs primeiras 50 linhas da lista de linhas são exibidas abaixo.",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Gráficos interativos</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.pt.html#gráfico-com-ggplotly",
    "href": "new_pages/interactive_plots.pt.html#gráfico-com-ggplotly",
    "title": "39  Gráficos interativos",
    "section": "39.2 Gráfico com ggplotly()",
    "text": "39.2 Gráfico com ggplotly()\nA função ggplotly() do pacote plotly facilita a conversão de um ggplot() para ser interativo. Só precisa salvar o seu ggplot() e na sequência direciona-lo para a função do ggplotly().\nAbaixo, é traçada uma linha simples no gráfico representando a proporção de casos que morreram em uma determinada semana:\nPara começar, necessário cria um conjunto de dados resumido de cada semana epidemiológica e a porcentagem de casos com desfecho conhecido que morreram.\n\nweekly_deaths &lt;- linelist %&gt;%\n  group_by(epiweek = floor_date(date_onset, \"week\")) %&gt;%  # criar e agrupar dados por coluna *epiweek*\n  summarise(                                              # criar um novo da Data Frame resumido\n    n_known_outcome = sum(!is.na(outcome), na.rm=T),      # número de casos por grupo(com resultados conhecidos)\n    n_death  = sum(outcome == \"Death\", na.rm=T),          # número de casos que foram a óbitos\n    pct_death = 100*(n_death / n_known_outcome)           # percentual de casos que foram a obitos com resultados conhecidos\n  )\n\nAqui estão as primeiras 50 linhas do conjunto weekly_deaths.\n\n\n\n\n\n\nNa sequência criamos o gráfico com ggplot2, usando o geom_line().\n\ndeaths_plot &lt;- ggplot(data = weekly_deaths)+            # começar com o registro de óbito semanal\n  geom_line(mapping = aes(x = epiweek, y = pct_death))  # criar a linha no gráfico\n\ndeaths_plot   # visualizar\n\n\n\n\n\n\n\n\nPara torná-lo interativo, basta passar esse gráfico para ggplotly(), como abaixo. Passe o mouse sobre a linha para mostrar os valores x e y. Você pode ampliar o gráfico e arrastá-lo. Você também pode ver os ícones no canto superior direito do gráfico. Em ordem, eles permitem que você:\n\nBaixar a visualização atual como uma imagem PNG\n\nAmpliar com uma caixa de seleção\n\nGire, ou mova-se pelo gráfico clicando e arrastando\n\nAmpliar, reduzir ou retornar ao zoom padrão\nRedefinir os eixos para os padrões\nAtive/desative as “Spike Lines” que são linhas pontilhadas do ponto interativo que se estendem até os eixos x e y\nAjustes para mostrar os dados quando você não está navegando na linha\n\n\ndeaths_plot %&gt;% plotly::ggplotly()\n\n\n\n\n\nDados agrupados também funcionam com o ggplotly(). Abaixo, é feita uma epicurva semanal, agrupada por resultado. As barras empilhadas são interativas. Tente clicar nos diferentes itens da legenda (eles irão aparecer/desaparecer).\n\n#Produzir a curva com o pacote incidence2 verificar se tem instalado\np &lt;- incidence2::incidence(\n  linelist,\n  date_index = date_onset,\n  interval = \"weeks\",\n  groups = outcome) %&gt;% #não esquecer de chamar o pacote %&gt;% (magrittr)\n  plot(fill = outcome)\n\n\n# Gráfico interativo \np %&gt;% plotly::ggplotly()",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Gráficos interativos</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.pt.html#modificações",
    "href": "new_pages/interactive_plots.pt.html#modificações",
    "title": "39  Gráficos interativos",
    "section": "39.3 Modificações",
    "text": "39.3 Modificações\n\nTamanho do arquivo\nAo exportar em HTML gerado pelo R Markdown (como este livro!), você irá desejar o gráfico com o menor tamanho de dados possível (sem efeitos colaterais negativos na maioria dos casos). Para isso, basta direcionar a plotagem interativa para partial_bundle(), também do plotly.\n\np &lt;- p %&gt;% \n  plotly::ggplotly() %&gt;%\n  plotly::partial_bundle()\n\n\n\nBotões\nAlguns dos botões em uma plotagem padrão são supérfluos e podem ser uma distração, então você pode removê-los. Você pode fazer isso simplesmente direcionando a saída config() do plotly e especificando quais botões devem ser removidos. No exemplo abaixo, os nomes dos botões a serem removidos foram expecificados previamente e fornecido o argumento modeBarButtonsToRemove =. Também definiu-se a remoção do logotipo do plotly com o displaylogo = FALSE.\n\n##Esses botões são distrações e podem ser removidos\nplotly_buttons_remove &lt;- list('zoom2d','pan2d','lasso2d', 'select2d','zoomIn2d',\n                              'zoomOut2d','autoScale2d','hoverClosestCartesian',\n                              'toggleSpikelines','hoverCompareCartesian')\n\np &lt;- p %&gt;%          # redefinir o grafico interativo com esses botões\n  plotly::config(displaylogo = FALSE, modeBarButtonsToRemove = plotly_buttons_remove)",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Gráficos interativos</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.pt.html#gráfico--blocos-de-calor",
    "href": "new_pages/interactive_plots.pt.html#gráfico--blocos-de-calor",
    "title": "39  Gráficos interativos",
    "section": "39.4 Gráfico -Blocos de calor",
    "text": "39.4 Gráfico -Blocos de calor\nVocê pode tornar quase qualquer gráfico do ggplot() interativo, incluindo o gráfico de calor. No exemplo, a seguir mostra a proporção de dias por semana que certas instalações reportaram dados de malária à sua província.\nAqui está o código, embora não descrito em profundidade neste tópico.\n\n# Importar os dados de malária\nfacility_count_data &lt;- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\"))\n\n# Dados agregados por semana para o distrito durante a primavera\nagg_weeks &lt;- facility_count_data %&gt;% \n  filter(District == \"Spring\",\n         data_date &lt; as.Date(\"2020-08-01\")) %&gt;% \n  mutate(week = aweek::date2week(\n    data_date,\n    start_date = \"Monday\",\n    floor_day = TRUE,\n    factor = TRUE)) %&gt;% \n  group_by(location_name, week, .drop = F) %&gt;%\n  summarise(\n    n_days          = 7,\n    n_reports       = n(),\n    malaria_tot     = sum(malaria_tot, na.rm = T),\n    n_days_reported = length(unique(data_date)),\n    p_days_reported = round(100*(n_days_reported / n_days))) %&gt;% \n  ungroup(location_name, week) %&gt;% \n  right_join(tidyr::expand(., week, location_name)) %&gt;% \n  mutate(week = aweek::week2date(week))\n\n# Criar gráfico\nmetrics_plot &lt;- ggplot(agg_weeks,\n       aes(x = week,\n           y = location_name,\n           fill = p_days_reported))+\n  geom_tile(colour=\"white\")+\n  scale_fill_gradient(low = \"orange\", high = \"darkgreen\", na.value = \"grey80\")+\n  scale_x_date(expand = c(0,0),\n               date_breaks = \"2 weeks\",\n               date_labels = \"%d\\n%b\")+\n  theme_minimal()+ \n  theme(\n    legend.title = element_text(size=12, face=\"bold\"),\n    legend.text  = element_text(size=10, face=\"bold\"),\n    legend.key.height = grid::unit(1,\"cm\"),\n    legend.key.width  = grid::unit(0.6,\"cm\"),\n    axis.text.x = element_text(size=12),\n    axis.text.y = element_text(vjust=0.2),\n    axis.ticks = element_line(size=0.4),\n    axis.title = element_text(size=12, face=\"bold\"),\n    plot.title = element_text(hjust=0,size=14,face=\"bold\"),\n    plot.caption = element_text(hjust = 0, face = \"italic\")\n    )+\n  labs(x = \"Semana\",\n       y = \"Nome do Estabelecimento\",\n       fill = \"Performance de \\n reporte (%)\",\n       title = \"Porcentagem de dia por semana que o estabelecimento \\n reportou dados\",\n       subtitle = \"Estabelecimento de saúdes distritais, Abril-Maio 2019\",\n       caption = \"Semanas de 7 diad começando às segundas\")\n\nmetrics_plot # mostrar gráfico\n\n\n\n\n\n\n\n\nAbaixo, o gráfico foi transformado no modo interativo e o tamanho do arquivo, assim como os botões modificados para formas mais simples.\n\nmetrics_plot %&gt;% \n  plotly::ggplotly() %&gt;% \n  plotly::partial_bundle() %&gt;% \n  plotly::config(displaylogo = FALSE, modeBarButtonsToRemove = plotly_buttons_remove)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n–&gt;",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Gráficos interativos</span>"
    ]
  },
  {
    "objectID": "new_pages/interactive_plots.pt.html#recursos",
    "href": "new_pages/interactive_plots.pt.html#recursos",
    "title": "39  Gráficos interativos",
    "section": "39.5 Recursos",
    "text": "39.5 Recursos\nPlotly não é apenas para R, também funciona bem com Python (e qualquer linguagem de ciência de dados, por ser construído em JavaScript). Você pode ler mais sobre o tema no Website plotly",
    "crumbs": [
      "Visualização de Dados",
      "<span class='chapter-number'>39</span>  <span class='chapter-title'>Gráficos interativos</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.pt.html",
    "href": "new_pages/rmarkdown.pt.html",
    "title": "40  Relatórios com R Markdown",
    "section": "",
    "text": "40.1 Preparação\nIdeias preliminares ao R Markdown\nPara explicar alguns dos conceitos e pacotes envolvidos:\n(Fonte: https://rmarkdown.rstudio.com/authoring_quick_tour.html):\nInstalação\nPara criar um produto R Markdown, é necessário ter os seguintes instalados:\npacman::p_load(tinytex)     # instala o pacote tinytex\ntinytex::install_tinytex()  # Comando de R para instalar o software TinyTeX",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Relatórios com R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.pt.html#preparação",
    "href": "new_pages/rmarkdown.pt.html#preparação",
    "title": "40  Relatórios com R Markdown",
    "section": "",
    "text": "Markdown é uma “linguagem” que permite escrever um documento usando texto comum, que pode ser convertido para html e outros formatos. Não é específico de R e arquivos escritos nessa “linguagem” tem extensão ‘.md’.\nR Markdown: é uma variação de markdown que é específica de R - permite escrever um documento usando markdown para produzir código, mas também incluir código em R e expor seus resultados.\n\nrmarkdown - o pacote: é usado pelo R para renderizar o arquivo .Rmd para a exportação desejada. Seu foco é converter a sintaxe markdown (texto), então também precisamos de…\nknitr: Esse pacote do R lerá os blocos de código, executá-los e costurá-los (do inglês knit, tricotar) de volta ao documento.\nPandoc: Finalmente, pandoc converte o objeto final em um documento word/pdf/powerpoint, etc. É um software separado do R, mas é instalado automaticamente com o RStudio.\n\n\n\n\n\n\nO pacote rmarkdown (knitr será automaticamente instalado também)\n\nPandoc, que deve ter vindo instalado com RStudio. Se você não está usando RStudio, é possível baixar o Pandoc aqui: http://pandoc.org.\nSe quiser gerar um arquivo PDF (um pouquinho mais complicado), será necessário instalar o LaTeX. Para usuários de R Markdown que nunca instalaram o LaTeX antes, recomendamos que instale o TinyTeX (https://yihui.name/tinytex/). Para isso, use os seguintes comandos:",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Relatórios com R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.pt.html#começando",
    "href": "new_pages/rmarkdown.pt.html#começando",
    "title": "40  Relatórios com R Markdown",
    "section": "40.2 Começando",
    "text": "40.2 Começando\n\nInstalação do pacote rmarkdown para R\nInstale o pacote rmarkdown. Neste livro enfatizamos p_load() de pacman, que instala o pacote se necessário e o carrega para ser usado. É possível também carregar pacotes instalados com library() do R base. Vera a pagina em Introdução ao R para mais informação sobre os pacotes de R.\n\n\npacman::p_load(rmarkdown)\n\n\n\nComeçando um novo arquivo Rmd\nNo Rstudio, abra um novo arquivo R markdown, começando em ‘Arquivo’, depois ‘Novo arquivo’, depois em ‘R markdown…’.\n\n\n\n\n\n\n\n\n\nRstudio lhe dará opções de output para selecionar. No exemplo abaixo, escolhemos “HTML” porque queremos criar um documento html. O título e o nome do autor não são importantes. Se o tipo do documento de saída desejado não é nenhum desses, não se preocupe - é possível escolher qualquer um e alterar posteriormente.\n\n\n\n\n\n\n\n\n\nIsso abrirá um novo script .Rmd.\n\n\nImportante saber\nO diretório de trabalho\nO diretório de trabalho de um arquivo markdown é o local onde o próprio arquivo Rmd é salvo. Por exemplo, se o projeto R estiver dentro de ~/Documents/projectX e o próprio arquivo Rmd estiver em uma subpasta~/Documents/projectX/markdownfiles/markdown.Rmd, o código read.csv(\"data.csv\") Dentro do markdown irá procurar por um arquivo csv na pasta markdownfiles, e não na pasta raiz do projeto onde os scripts dentro dos projetos normalmente procurariam automaticamente.\nPara se referir a arquivos em outro lugar, você precisará usar o caminho completo do arquivo ou usar o pacote here. O pacote here define o diretório de trabalho para a pasta raiz do projeto R e é explicado em detalhes nas páginas Projetos R e [Importar e exportar])(#importing) deste manual. Por exemplo, para importar um arquivo chamado “data.csv” de dentro da pasta projectX, o código seria import(here(“data.csv”)).\nObserve que o uso de setwd() em scripts R Markdown não é recomendado - ele se aplica apenas ao trecho de código em que está escrito.\nTrabalhando em uma unidade vs no seu computador\nComo o R Markdown pode ter problemas de pandoc ao ser executado em uma unidade de rede compartilhada, é recomendado que sua pasta esteja em sua máquina local, por exemplo, em um projeto em ‘Meus Documentos’. Se você usa Git (muito recomendado!), Isso será familiar. Para obter mais detalhes, consulte as páginas do manual em R em unidades de rede e Erros e ajuda.",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Relatórios com R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.pt.html#componentes-do-r-markdown",
    "href": "new_pages/rmarkdown.pt.html#componentes-do-r-markdown",
    "title": "40  Relatórios com R Markdown",
    "section": "40.3 Componentes do R Markdown",
    "text": "40.3 Componentes do R Markdown\nUm documento R Markdown pode ser editado no RStudio da mesma forma que um script R padrão. Quando você inicia um novo script R Markdown, o RStudio tenta ser útil mostrando um modelo que explica as diferentes seções de um script R Markdown.\nA seguir está o que aparece ao iniciar um novo script Rmd destinado a produzir uma saída html (conforme a seção anterior).\n\n\n\n\n\n\n\n\n\nComo você pode ver, existem três componentes básicos em um arquivo Rmd: YAML, texto Markdown e blocos de código R.\nEles irão criar e se tornar a saída do seu documento. Veja o diagrama abaixo:\n\n\n\n\n\n\n\n\n\n\nMetadados YAML\nReferido como ‘metadados YAML’ ou apenas ‘YAML’, isso está no topo do documento R Markdown. Esta seção do script dirá ao seu arquivo Rmd que tipo de saída produzir, preferências de formatação e outros metadados, como título do documento, autor e data. Existem outros usos não mencionados aqui (mas mencionados em ‘Produção de uma saída’). Observe que o recuo é importante; tabulações não são aceitas, mas espaços, sim.\nEsta seção deve começar com uma linha contendo apenas três traços --- e deve fechar com uma linha contendo apenas três traços ---. Os parâmetros YAML vêm em pares chave: valor. A colocação dos dois pontos em YAML é importante - os pares chave: valor são separados por dois pontos (e não sinais de igual!).\nO YAML deve começar com metadados para o documento. A ordem desses parâmetros YAML primários (não recuados) não importa. Por exemplo:\ntitle: \"My document\"\nauthor: \"Me\"\ndate: \"2024-05-08\"\nYou can use R code in YAML values by writing it as in-line code (preceded by r within back-ticks) but also within quotes (see above example for date:).\nIn the image above, because we clicked that our default output would be an html file, we can see that the YAML says output: html_document. However we can also change this to say powerpoint_presentation or word_document or even pdf_document.\nVocê pode usar o código R em valores YAML escrevendo-o como código in-line (precedido por r dentro de crases), mas também entre aspas (veja o exemplo acima para date:).\nNa imagem acima, como clicamos que nossa saída padrão seria um arquivo html, podemos ver que o YAML diz output: html_document. No entanto, também podemos alterar isso para dizer powerpoint_presentationouword_document ou mesmo pdf_document.\n\n\n40.3.1 Texto\nEsta é a narrativa do seu documento, incluindo os títulos e cabeçalhos. Ele é escrito na linguagem “markdown”, que é usada em muitos softwares diferentes.\nAbaixo estão as principais maneiras de escrever este texto. Consulte a documentação mais extensa disponível na “cheatsheet” do R Markdown no site do RStudio.\n\nNovas linhas\nExclusivamente no R Markdown, para iniciar uma nova linha, insira dois espaços no final da linha anterior e pressione Enter / Return.\n\n\nCase\nCerque seu texto normal com esses caracteres para alterar como ele aparece na saída.\n\nSublinhados (_text_) ou asterisco único (*texto*) para itálico\nAsteriscos duplos (**texto**) para texto em negrito\nCrases (text) para exibir o texto como código\n\nA aparência real da fonte pode ser definida usando modelos específicos (especificados nos metadados YAML; consulte as guias de exemplo).\n\n\n40.3.1.1 Cor\nNão existe um mecanismo simples para alterar a cor do texto no R Markdown. Uma solução alternativa, SE sua saída for um arquivo HTML, é adicionar uma linha HTML ao texto markdown. O código HTML abaixo imprimirá uma linha de texto em vermelho negrito.\n&lt;span style=\"color: red;\"&gt;**_DANGER:_** This is a warning.&lt;/span&gt;  \n[PERIGO: Este é um aviso.] {style = “color: red;”}\n\n\nTítulos e cabeçalhos\nUm símbolo hash (#) em uma parte do texto de um script R Markdown cria um título. Isso é diferente de um pedaço de código R no script, no qual um símbolo hash é um mecanismo para comentar / anotar / desativar, como em um script R normal.\nDiferentes níveis de título são estabelecidos com diferentes números de símbolos hash no início de uma nova linha. Um símbolo de hash é um título ou cabeçalho principal. Dois símbolos hash são um título de segundo nível. Os cabeçalhos de terceiro e quarto níveis podem ser feitos com mais símbolos hash sucessivamente.\n# First-level heading / title\n\n## Second level heading  \n\n### Third-level heading\n\n\nMarcadores e numeração\nUse asteriscos (*) para criar uma lista de marcadores. Conclua a frase anterior, insira dois espaços, Enter/Return duas vezes e, em seguida, inicie seus marcadores. Inclua um espaço entre o asterisco e o texto do marcador. Após cada marcador, insira dois espaços e pressione Enter/Return. Os submarcadores funcionam da mesma maneira, mas são recuados. Os números funcionam da mesma maneira, mas em vez de um asterisco, escreva 1), 2), etc. Abaixo está a aparência do texto do script R Markdown.\nHere are my bullets (there are two spaces after this colon):  \n\n* Bullet 1 (followed by two spaces and Enter/Return)  \n* Bullet 2 (followed by two spaces and Enter/Return)  \n  * Sub-bullet 1 (followed by two spaces and Enter/Return)  \n  * Sub-bullet 2 (followed by two spaces and Enter/Return)  \n  \n\n\nComente o texto\nVocê pode “comentar” o texto do R Markdown da mesma forma que pode usar o “#” para comentar uma linha do código R em um bloco R. Basta destacar o texto e pressionar Ctrl+Shift+c (Cmd+Shift+c para Mac). O texto será circundado por setas e ficará verde. Ele não aparecerá na sua saída.\n\n\n\n\n\n\n\n\n\n\n\n\nBlocos de código\nAs seções do script que são dedicadas à execução do código R são chamadas de “blocos”. É aqui que você pode carregar pacotes, importar dados e realizar o gerenciamento e visualização de dados reais. Pode haver muitos blocos de código, então eles podem ajudá-lo a organizar seu código R em partes, talvez intercaladas com texto. Note: Esses ‘pedaços’ parecerão ter uma cor de fundo ligeiramente diferente da parte narrativa do documento.\nCada pedaço é aberto com uma linha que começa com três crases e chaves que contêm parâmetros para o pedaço ({}). O pedaço termina com mais três crases.\nVocê pode criar um novo bloco digitando-o você mesmo, usando o atalho de teclado “Ctrl+Alt+i” (ou Cmd+Shift+r no Mac) ou clicando no ícone verde ‘inserir um novo bloco de código’ no topo do seu editor de script.\nAlgumas notas sobre o conteúdo das chaves {}:\n\nEles começam com ‘r’ para indicar que o nome do idioma dentro do bloco é R\nApós o r, você pode opcionalmente escrever um “nome” de trecho – eles não são necessários, mas podem ajudá-lo a organizar seu trabalho. Observe que se você nomear seus blocos, você deve SEMPRE usar nomes exclusivos ou então R reclamará quando você tentar renderizar.\n\nAs chaves também podem incluir outras opções, escritas como tag = value, como:\n\neval = FALSE para não executar o código R\n\necho = FALSE para não imprimir o código-fonte R do trecho no documento de saída\n\naviso = FALSO para não imprimir avisos produzidos pelo código R\n\nmensagem = FALSO para não imprimir nenhuma mensagem produzida pelo código R\n\nincluir = VERDADEIRO / FALSO se incluir saídas em partes (por exemplo, gráficos) no documento\nout.width = e out.height = - fornecer no estilo out.width =\"75%\"\n\nfig.align = \"center\" ajustar como uma figura é alinhada na página\n\nfig.show = 'hold' se o seu pedaço imprimir várias figuras e você quiser que elas sejam impressas lado a lado (par com out.width = c(\"33%\", \"67%\"). Também pode ser definido como fig.show = 'asis' para mostrá-los abaixo do código que os gera,'hide' para ocultar ou 'animate' para concatenar múltiplos em uma animação.\n\nUm cabeçalho de bloco deve ser escrito em uma linha\n\nTente evitar pontos, sublinhados e espaços. Use hifens ( - ) se precisar de um separador.\n\nLeia mais extensivamente sobre as opções do knitr aqui.\nAlgumas das opções acima podem ser configuradas com apontar e clicar usando os botões de configuração no canto superior direito do bloco. Aqui, você pode especificar quais partes do pedaço você deseja que o documento renderizado inclua, a saber, o código, as saídas e os avisos. Isso sairá como preferências escritas dentro das chaves, por exemplo, echo = FALSE se você especificar que deseja ‘Mostrar apenas a saída’.\n\n\n\n\n\n\n\n\n\nTambém há duas setas no canto superior direito de cada fragmento, que são úteis para executar o código dentro de um fragmento ou todo o código em blocos anteriores. Passe o mouse sobre eles para ver o que fazem.\nPara que as opções globais sejam aplicadas a todos os fragmentos do script, você pode configurar isso em seu primeiro bloco de código R no script. Por exemplo, para que apenas as saídas sejam mostradas para cada bloco de código e não o código em si, você pode incluir este comando no fragmento de código R:\n\nknitr::opts_chunk$set(echo = FALSE) \n\n\nCódigo R no texto\nVocê também pode incluir código R mínimo dentro de crases. Dentro dos crases, comece o código com “r” e um espaço, para que o RStudio saiba avaliar o código como código R. Veja o exemplo abaixo.\nO exemplo abaixo mostra vários níveis de título, marcadores e usa o código R para a data atual (Sys.Date ()) para avaliar em uma data impressa.\n\n\n\n\n\n\n\n\n\nO exemplo acima é simples (mostrando a data atual), mas usando a mesma sintaxe, você pode exibir valores produzidos por códigos R mais complexos (por exemplo, para calcular o mínimo, a mediana, o máximo de uma coluna). Você também pode integrar objetos R ou valores que foram criados em blocos de código R anteriormente no script.\nComo exemplo, o script abaixo calcula a proporção de casos com menos de 18 anos, usando as funções tidyverse, e cria os objetos less18,total e less18prop. Este valor dinâmico é inserido no texto subsequente. Vemos como fica quando imprimimos um documento do Word.\n\n\n\n\n\n\n\n\n\n\n\n\n40.3.2 Imagens\nVocê pode incluir imagens em seu R Markdown de duas maneiras:\n\n![](\"path/to/image.png\")  \n\nSe o acima não funcionar, tente usar knitr::include_graphics()\n\nknitr::include_graphics(\"path/to/image.png\")\n\n(lembre-se, o caminho do seu arquivo pode ser escrito usando o pacote here)\n\nknitr::include_graphics(here::here(\"path\", \"to\", \"image.png\"))\n\n\n\n40.3.3 Tabelas\nCrie uma tabela usando hifens ( - ) e barras ( | ). O número de hifens antes/entre as barras permite o número de espaços na célula antes que o texto comece a quebrar.\nColumn 1 |Column  2 |Column 3\n---------|----------|--------\nCell A   |Cell B    |Cell C\nCell D   |Cell E    |Cell F\nO código acima produz a tabela abaixo:\n\n\n\nColumn 1\nColumn 2\nColumn 3\n\n\n\n\nCell A\nCell B\nCell C\n\n\nCell D\nCell E\nCell F\n\n\n\n\n\n40.3.4 Seções com guias\nPara saídas HTML, você pode organizar as seções em “guias”. Basta adicionar .tabset nas chaves {}que são colocadas * após um título *. Quaisquer subtítulos abaixo desse título (até outro título do mesmo nível) aparecerão como guias nas quais o usuário pode clicar. Leia mais aqui\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVocê pode adicionar uma opção adicional .tabset-pills após .tabset para dar às próprias guias uma aparência de pastilha. Esteja ciente de que, ao visualizar a saída HTML com guias, a funcionalidade de pesquisa Ctrl+f pesquisará apenas guias “ativas”, não guias ocultas.",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Relatórios com R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.pt.html#estrutura-do-arquivo",
    "href": "new_pages/rmarkdown.pt.html#estrutura-do-arquivo",
    "title": "40  Relatórios com R Markdown",
    "section": "40.4 Estrutura do arquivo",
    "text": "40.4 Estrutura do arquivo\nExistem várias maneiras de estruturar seu R Markdown e quaisquer scripts R associados. Cada um tem vantagens e desvantagens:\n\nR Markdown independente - tudo o que é necessário para o relatório é importado ou criado dentro do R Markdown\nFonte de outros arquivos - Você pode executar scripts R externos com o comando source() e usar suas saídas no Rmd\nScripts filhos - um mecanismo alternativo para source()\nUtilizar um “runfile” - Executar comandos em um script R antes de renderizar o R Markdown\n\n\n40.4.1 Rmd independente {.não numerado}\nPara um relatório relativamente simples, você pode optar por organizar seu script R Markdown de forma que seja “independente” e não envolva nenhum script externo.\nTudo que você precisa para executar o markdown R é importado ou criado dentro do arquivo Rmd, incluindo todos os pedaços de código e carregamento de pacote. Esta abordagem “independente” é apropriada quando você não precisa fazer muito processamento de dados (por exemplo, traz um arquivo de dados limpo ou semilimpeza) e a renderização do R Markdown não demora muito.\nNeste cenário, uma organização lógica do script R Markdown pode ser:\n\nDefina as opções globais do knitr\nCarregar pacotes\nImportar dados\nDados do processo\nProduza resultados (tabelas, gráficos, etc.)\nSalve as saídas, se aplicável (.csv, .png, etc.)\n\n\nFonte de outros arquivos\nUma variação da abordagem “independente” é fazer com que os pedaços de código do R Markdown “originem” (executem) outros scripts R. Isso pode tornar seu script R Markdown menos confuso, mais simples e mais fácil de organizar. Também pode ajudar se você deseja exibir os valores finais no início do relatório. Nesta abordagem, o script final R Markdown simplesmente combina saídas pré-processadas em um documento.\nUma maneira de fazer isso é fornecendo os scripts R (caminho e nome do arquivo com extensão) para o comando R base source().\n\nsource(\"your-script.R\", local = knitr::knit_global())\n# or sys.source(\"your-script.R\", envir = knitr::knit_global())\n\nObserve que ao usar source() dentro do R Markdown, os arquivos externos ainda serão executados durante o curso de renderização de seu arquivo Rmd. Portanto, cada script é executado sempre que você renderiza o relatório. Portanto, ter esses comandos source() dentro do R Markdown não acelera seu tempo de execução, nem ajuda muito na eliminação de bugs, pois o erro produzido ainda será impresso ao produzir o R Markdown.\nUma alternativa é utilizar a opção child = knitr. EXPLIQUE MAIS A FAZER\nVocê deve estar ciente dos vários ambientes R. Os objetos criados dentro de um ambiente não estarão necessariamente disponíveis para o ambiente usado pelo R Markdown.\n\n\n\nRunfile\nEsta abordagem envolve a utilização do script R que contém o (s) comando (s) render() para pré-processar objetos que alimentam o markdown R.\nPor exemplo, você pode carregar os pacotes, carregar e limpar os dados e até mesmo criar os gráficos de interesse antes de render(). Essas etapas podem ocorrer no script R ou em outros scripts originados via source. Contanto que esses comandos ocorram na mesma sessão RStudio e os objetos sejam salvos no ambiente, os objetos podem ser chamados dentro do conteúdo Rmd. Em seguida, o próprio markdown R será usado apenas para a etapa final - para produzir a saída com todos os objetos pré-processados. Isso é muito mais fácil de corrigir se algo der errado.\nEssa abordagem é útil pelos seguintes motivos:\n\nMensagens de erro mais informativas - essas mensagens serão geradas a partir do script R, não do R Markdown. R Erros de Markdown tendem a dizer qual pedaço teve um problema, mas não revelam qual linha.\nSe aplicável, você pode executar longas etapas de processamento antes do comando render() - elas serão executadas apenas uma vez.\n\nNo exemplo abaixo, temos um script R separado no qual pré-processamos um objeto data no ambiente R e então renderizamos o “create_output.Rmd” usando render().\n\ndata &lt;- import(\"datafile.csv\") %&gt;%       # Load data and save to environment\n  select(age, hospital, weight)          # Select limited columns\n\nrmarkdown::render(input = \"create_output.Rmd\")   # Create Rmd file\n\n\n\n40.4.2 Estrutura da pasta\nO fluxo de trabalho também diz respeito à estrutura geral da pasta, como ter uma pasta de ‘saída’ para documentos e figuras criados e pastas de ‘dados’ ou ‘entradas’ para dados limpos. Não entramos em maiores detalhes aqui, mas verifique a página Organizando relatórios de rotina.",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Relatórios com R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.pt.html#produzindo-o-documento",
    "href": "new_pages/rmarkdown.pt.html#produzindo-o-documento",
    "title": "40  Relatórios com R Markdown",
    "section": "40.5 Produzindo o documento",
    "text": "40.5 Produzindo o documento\nVocê pode produzir o documento das seguintes maneiras:\n\nManualmente pressionando o botão “Knit” na parte superior do editor de script RStudio (rápido e fácil)\n\nExecute o comando render() (executado fora do script R Markdown)\n\n\n40.5.1 Opção 1: Botão “Knit”\nQuando você tiver o arquivo Rmd aberto, pressione o ícone / botão ‘Knit’ na parte superior do arquivo.\nR Studio mostrará o progresso em uma guia ‘R Markdown’ perto do console R. O documento será aberto automaticamente quando concluído.\nO documento será salvo na mesma pasta que seu script markdown R e com o mesmo nome de arquivo (exceto a extensão). Obviamente, isso não é ideal para o controle de versão (será sobrescrito a cada vez que você exportar, a menos que movido manualmente), pois você pode precisar renomear o arquivo (por exemplo, adicionar uma data).\nEste é o botão de atalho do RStudio para a função render() de rmarkdown. Essa abordagem é compatível apenas com um R markdown autocontido, onde todos os componentes necessários existem ou são originados no arquivo.\n\n\n\n\n\n\n\n\n\n\n\nOpção 2: comando render()\nOutra maneira de produzir a saída do R Markdown é rodar a função render() (do pacote rmarkdown). Você deve executar este comando fora do script R Markdown - ou em um script R separado (geralmente chamado de “arquivo de execução”) ou como um comando independente no R Console.\n\nrmarkdown::render(input = \"my_report.Rmd\")\n\nTal como acontece com “knit”, as configurações padrão salvarão a saída Rmd na mesma pasta do script Rmd, com o mesmo nome de arquivo (além da extensão do arquivo). Por exemplo, “my_report.Rmd” quando exportado criará “my_report.docx” se você estiver exportando para um documento do Word. No entanto, usando render() você tem a opção de usar configurações diferentes. render() pode aceitar argumentos, incluindo:\n\noutput_format = Este é o formato de saída para converter (por exemplo, \"html_document\", \"pdf_document\", \"word_document\" ou \"all\"). Você também pode especificar isso no YAML dentro do script R Markdown.\n\noutput_file = Este é o nome do arquivo de saída (e caminho do arquivo). Isso pode ser criado por meio de funções R como here() ou str_glue() conforme demonstrado abaixo.\n\noutput_dir = Este é um diretório de saída (pasta) para salvar o arquivo. Isso permite que você escolha uma alternativa diferente do diretório em que o arquivo Rmd é salvo.\n\noutput_options = Você pode fornecer uma lista de opções que irão sobrescrever aquelas no script YAML (por exemplo)\noutput_yaml = Você pode fornecer o caminho para um arquivo .yml que contém especificações YAML\n\nparams = Veja a seção sobre parâmetros abaixo\n\nVeja a lista completa aqui\n\nComo um exemplo, para melhorar o controle de versão, o comando a seguir salvará o arquivo de saída dentro de uma subpasta ‘outputs’, com a data atual no nome do arquivo. Para criar o nome do arquivo, a função str_glue() do pacote stringr é usada para ‘colar’ strings estáticas (escritas de forma simples) com código R dinâmico (escrito entre colchetes). Por exemplo, se for 10 de abril de 2021, o nome do arquivo abaixo será “Report_2021-04-10.docx”. Veja a página em Caracteres e strings para mais detalhes sobre str_glue().\n\nrmarkdown::render(\n  input = \"create_output.Rmd\",\n  output_file = stringr::str_glue(\"outputs/Report_{Sys.Date()}.docx\")) \n\nÀ medida que o arquivo é renderizado, o console do RStudio mostrará o andamento da renderização em até 100% e uma mensagem final para indicar que a renderização foi concluída.\n\n\nOpções 3: pacote reportfactory\nO pacote R reportfactory oferece um método alternativo de organização e compilação de relatórios R Markdown voltados para cenários onde você executa relatórios rotineiramente (por exemplo, diariamente, semanalmente …). Facilita a compilação de vários arquivos R Markdown e o organização de seus resultados. Em essência, ele fornece uma “fábrica” a partir da qual você pode executar os relatórios R Markdown, obter pastas com carimbo de data e hora automaticamente para as saídas e ter controle de versão “leve”.\nLeia mais sobre esse fluxo de trabalho na página Organização de relatórios de rotina.",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Relatórios com R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.pt.html#relatórios-parametrizados",
    "href": "new_pages/rmarkdown.pt.html#relatórios-parametrizados",
    "title": "40  Relatórios com R Markdown",
    "section": "40.6 Relatórios parametrizados",
    "text": "40.6 Relatórios parametrizados\nVocê pode usar a parametrização para tornar um relatório dinâmico, de modo que possa ser executado com uma configuração específica (por exemplo, uma data ou local específico ou com certas opções de knit). Abaixo, nos concentramos no básico, mas há mais detalhes online sobre relatórios parametrizados.\nUsando a lista de linha do Ebola como exemplo, digamos que queremos executar um relatório de vigilância padrão para cada hospital a cada dia. Mostramos como fazer isso usando parâmetros.\nImportante: relatórios dinâmicos também são possíveis sem a estrutura formal de parâmetros (sem params:), usando objetos R simples em um script R adjacente. Isso é explicado no final desta seção.\n\nConfigurando parâmetros\nVocê tem várias opções para especificar valores de parâmetro para sua saída R Markdown.\n\nOpção 1: Defina os parâmetros em YAML\nEdite o YAML para incluir uma opção params:, com declarações recuadas para cada parâmetro que você deseja definir. Neste exemplo, criamos os parâmetros data ehospital, para os quais especificamos valores. Esses valores estão sujeitos a alterações cada vez que o relatório é executado. Se você usar o botão “Knit” para produzir a saída, os parâmetros terão esses valores padrão. Da mesma forma, se você usar render() os parâmetros terão esses valores padrão, a menos que seja especificado de outra forma no comando render().\n---\ntitle: Surveillance report\noutput: html_document\nparams:\n date: 2021-04-10\n hospital: Central Hospital\n---\nEm segundo plano, esses valores de parâmetro estão contidos em uma lista somente leitura chamada params. Assim, você pode inserir os valores dos parâmetros no código R da mesma forma que faria com outro objeto / valor R em seu ambiente. Simplesmente digite params$ seguido do nome do parâmetro. Por exemplo, params$hospital para representar o nome do hospital (“Hospital Central” por padrão).\nObserve que os parâmetros também podem conter valores true ou false e, portanto, podem ser incluídos nas opções do knitr para um bloco R. Por exemplo, você pode definir {r, eval = params$run} em vez de {r, eval = FALSE}, e agora se o trecho é executado ou não depende do valor de um parâmetro run:.\nObserve que para os parâmetros que são datas, eles serão inseridos como uma string. Portanto, para que params$date seja interpretado no código R, ele provavelmente precisará ser empacotado com as.Date() ou uma função semelhante para converter para a classe Date.\n\n\nOpção 2: Defina os parâmetros em render()\nComo mencionado acima, uma alternativa para pressionar o botão “Knit” para produzir a saída é executar a função render() a partir de um script separado. Neste último caso, você pode especificar os parâmetros a serem usados naquela renderização para o argumento params = de render().\nObserve que quaisquer valores de parâmetro fornecidos aqui irão sobrescrever seus valores padrão se escritos dentro do YAML. Escrevemos os valores entre aspas, pois neste caso eles devem ser definidos como valores de caractere / string.\nO comando abaixo renderiza “monitoramento_report.Rmd”, especifica um nome de arquivo de saída dinâmica e pasta, e fornece uma list() de dois parâmetros e seus valores para o argumento params =.\n\nrmarkdown::render(\n  input = \"surveillance_report.Rmd\",  \n  output_file = stringr::str_glue(\"outputs/Report_{Sys.Date()}.docx\"),\n  params = list(date = \"2021-04-10\", hospital  = \"Central Hospital\"))\n\n\n\nOpção 3: Defina os parâmetros usando uma interface gráfica do usuário\nPara uma sensação mais interativa, você também pode usar a Interface Gráfica do Usuário (GUI) para selecionar manualmente os valores dos parâmetros. Para fazer isso, podemos clicar no menu suspenso ao lado do botão ‘Knit’ e escolher ‘Knit com parâmetros’.\nUm pop-up aparecerá permitindo que você digite valores para os parâmetros que são estabelecidos no YAML do documento.\n\n\n\n\n\n\n\n\n\nVocê pode conseguir o mesmo por meio de um comando render() especificando params = \"ask \", como demonstrado abaixo.\n\nrmarkdown::render(\n  input = \"surveillance_report.Rmd\",  \n  output_file = stringr::str_glue(\"outputs/Report_{Sys.Date()}.docx\"),\n  params = “ask”)\n\nNo entanto, digitar valores nesta janela pop-up está sujeito a erros e erros ortográficos. Você pode preferir adicionar restrições aos valores que podem ser inseridos nos menus suspensos. Você pode fazer isso adicionando no YAML várias especificações para cada entrada params:.\n\nlabel: é como o título para aquele menu suspenso específico\nvalue: é o valor padrão (inicial)\ninput: definido como select para o menu suspenso\nchoices: Dê os valores elegíveis no menu suspenso\n\nAbaixo, essas especificações são escritas para o parâmetro hospital.\n---\ntitle: Surveillance report\noutput: html_document\nparams:\n date: 2021-04-10\n hospital: \n  label: “Town:”\n  value: Central Hospital\n  input: select\n  choices: [Central Hospital, Military Hospital, Port Hospital, St. Mark's Maternity Hospital (SMMH)]\n---\nAo exportar (através do botão ‘knit com parâmetros’ ou por render()), a janela pop-up terá opções suspensas para selecionar.\n\n\n\n\n\n\n\n\n\n\n\n\nExemplo parametrizado\nO código a seguir cria parâmetros para data ehospital, que são usados no R Markdown como params$date e params$hospital, respectivamente.\nNa saída do relatório resultante, veja como os dados são filtrados para o hospital específico e o título do gráfico se refere ao hospital e à data corretos. Usamos o arquivo “linelist_cleaned.rds” aqui, mas seria particularmente apropriado se a própria lista de linha também tivesse um carimbo de data para alinhar com a data parametrizada.\n\n\n\n\n\n\n\n\n\nExportar isso produz a saída final com a fonte e o layout padrão.\n\n\n\n\n\n\n\n\n\n\n\nParametrização sem params\nSe você estiver renderizando um arquivo R Markdown com render() de um script separado, você pode criar o impacto da parametrização sem usar a funcionalidade params:.\nPor exemplo, no script R que contém o comando render(), você pode simplesmente definir hospital e date como dois objetos R (valores) antes do comando render(). No R Markdown, você não precisaria ter uma seção params: no YAML, e nos referiríamos ao objeto date ao invés de params$date e hospital ao invés deparams$hospital.\n\n# This is a R script that is separate from the R Markdown\n\n# define R objects\nhospital &lt;- \"Central Hospital\"\ndate &lt;- \"2021-04-10\"\n\n# Render the R markdown\nrmarkdown::render(input = \"create_output.Rmd\") \n\nSeguir essa abordagem significa que você não pode “tricotar com parâmetros”, usar a GUI ou incluir opções de knit dentro dos parâmetros. No entanto, permite um código mais simples, o que pode ser vantajoso.",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Relatórios com R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.pt.html#reiterando-relatórios",
    "href": "new_pages/rmarkdown.pt.html#reiterando-relatórios",
    "title": "40  Relatórios com R Markdown",
    "section": "40.7 Reiterando relatórios",
    "text": "40.7 Reiterando relatórios\nPodemos querer executar um relatório várias vezes, variando os parâmetros de entrada, para produzir um relatório para cada jurisdição / unidade. Isso pode ser feito usando ferramentas para iteração, que são explicadas em detalhes na página Iteração, loops e listas. As opções incluem o pacote purrr ou o uso de um for loop conforme explicado abaixo.\nAbaixo, usamos um simples for loop para gerar um relatório de vigilância para todos os hospitais de interesse. Isso é feito com um comando (em vez de alterar manualmente o parâmetro do hospital um por vez). O comando para renderizar os relatórios deve existir em um script separado fora do relatório Rmd. Este script também conterá objetos definidos para “fazer um loop” - a data de hoje e um vetor de nomes de hospitais para fazer o loop.\n\nhospitals &lt;- c(\"Central Hospital\",\n                \"Military Hospital\", \n                \"Port Hospital\",\n                \"St. Mark's Maternity Hospital (SMMH)\") \n\nEm seguida, alimentamos esses valores um de cada vez no comando render() usando um loop, que executa o comando uma vez para cada valor no vetor hospitais. A letra i representa a posição do índice (1 a 4) do hospital que está sendo usado nessa iteração, de modo que hospital_list[1] seria “Hospital Central”. Esta informação é fornecida em dois lugares no comando render():\n\nPara o nome do arquivo, de forma que o nome do arquivo da primeira iteração, se produzido em 10 de abril de 2021, seria “Report_Central Hospital_2021-04-10.docx”, salvo na subpasta ‘output’ do diretório de trabalho.\n\nPara params = tal que o Rmd use o nome do hospital internamente sempre que o valor params$hospital é chamado (por exemplo, para filtrar o conjunto de dados para o hospital específico apenas). Neste exemplo, quatro arquivos seriam criados - um para cada hospital.\n\n\nfor(i in 1:length(hospitals)){\n  rmarkdown::render(\n    input = \"surveillance_report.Rmd\",\n    output_file = str_glue(\"output/Report_{hospitals[i]}_{Sys.Date()}.docx\"),\n    params = list(hospital  = hospitals[i]))\n}       \n\n\n\n\n\n&lt;! - output_file = paste0 (“output / Report_”, hospital_list [i], refdate, “.docx”) -&gt;\n\n\n&lt;! - O texto dentro da marcação precisaria então se referir a hospital_list [i] e refdate. -&gt;",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Relatórios com R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.pt.html#modelos",
    "href": "new_pages/rmarkdown.pt.html#modelos",
    "title": "40  Relatórios com R Markdown",
    "section": "40.8 Modelos",
    "text": "40.8 Modelos\nUsando um documento de modelo que contém qualquer formatação desejada, você pode ajustar a estética de como a saída Rmd ficará. Você pode criar, por exemplo, um arquivo MS Word ou PowerPoint que contenha páginas / slides com as dimensões, marcas d’água, planos de fundo e fontes desejados.\n\n40.8.1 Documentos do Word\nPara criar um modelo, inicie um novo documento do Word (ou use uma saída existente com a formatação que mais lhe convier) e edite as fontes definindo os Estilos. Em Estilo, os títulos 1, 2 e 3 referem-se aos vários níveis de cabeçalho de redução (# Cabeçalho 1, ## Cabeçalho 2 e ### Cabeçalho 3 respectivamente). Clique com o botão direito no estilo e clique em ‘modificar’ para alterar a formatação da fonte, bem como o parágrafo (por exemplo, você pode introduzir quebras de página antes de certos estilos que podem ajudar com o espaçamento). Outros aspectos do documento do Word, como margens, tamanho da página, cabeçalhos, etc., podem ser alterados como um documento do Word normal no qual você está trabalhando diretamente.\n\n\n\n\n\n\n\n\n\n\n\n40.8.2 Documentos do PowerPoint\nComo acima, crie um novo conjunto de slides ou use um arquivo PowerPoint existente com a formatação desejada. Para outras edições, clique em ‘Exibir’ e ‘Slide Master’. A partir daqui, você pode alterar a aparência do slide ‘mestre’ editando a formatação do texto nas caixas de texto, bem como as dimensões do plano de fundo / página para a página geral.\n\n\n\n\n\n\n\n\n\nInfelizmente, editar arquivos PowerPoint é um pouco menos flexível:\n\nUm cabeçalho de primeiro nível (# Cabeçalho 1) se tornará automaticamente o título de um novo slide,\nUm texto de ## Header 2 não aparecerá como uma legenda, mas como um texto dentro da caixa de texto principal do slide (a menos que você encontre uma maneira de manipular a visualização mestre).\nPlotagens e tabelas geradas irão automaticamente para novos slides. Você precisará combiná-los, por exemplo, a função patchwork para combinar ggplots, de modo que apareçam na mesma página. Veja esta postagem no blog sobre como usar o pacote patchwork para colocar várias imagens em um slide.\n\nVeja o pacote officer para uma ferramenta para trabalhar mais a fundo com apresentações em PowerPoint.\n\n\nIntegração de modelos no YAML\nUma vez que um modelo é preparado, o detalhe disso pode ser adicionado no YAML do Rmd abaixo da linha de ‘output’ e abaixo de onde o tipo de documento é especificado (que vai para uma linha separada). Nota reference_doc pode ser usado para modelos de slides do PowerPoint.\nÉ mais fácil salvar o modelo na mesma pasta onde está o arquivo Rmd (como no exemplo abaixo) ou em uma subpasta.\n---\ntitle: Surveillance report\noutput: \n word_document:\n  reference_docx: \"template.docx\"\nparams:\n date: 2021-04-10\n hospital: Central Hospital\ntemplate:\n \n---\n\n\nFormatando arquivos HTML\nOs arquivos HTML não usam modelos, mas podem ter os estilos configurados no YAML. HTMLs são documentos interativos e são particularmente flexíveis. Cobrimos algumas opções básicas aqui.\n\nÍndice: Podemos adicionar um índice com toc: true abaixo, e também especificar que ele permanece visível (“floats”) conforme você rola, com toc_float: true.\nTemas: Podemos nos referir a alguns temas pré-fabricados, que vêm de uma biblioteca de temas Bootswatch. No exemplo abaixo, usamos cerulean. Outras opções incluem: diário, plano, escuro, legível, laboratório espacial, unido, cosmo, lúmen, papel, arenito, simplex e yeti. No original, journal, flatly, darkly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, e yeti\nRealçar: Configurar isso muda a aparência do texto destacado (por exemplo, código dentro dos pedaços que são mostrados). Os estilos suportados incluem default, tango, pygments, kate, monochrome, espresso, zenburn, haddock, breezedark, e textmate.\n\nAqui está um exemplo de como integrar as opções acima no YAML.\n---\ntitle: \"HTML example\"\noutput:\n  html_document:\n    toc: true\n    toc_float: true\n    theme: cerulean\n    highlight: kate\n    \n---\nAbaixo estão dois exemplos de saídas HTML, ambas com índices flutuantes, mas diferentes temas e estilos de destaque selecionados:",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Relatórios com R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.pt.html#conteúdo-dinâmico",
    "href": "new_pages/rmarkdown.pt.html#conteúdo-dinâmico",
    "title": "40  Relatórios com R Markdown",
    "section": "40.9 Conteúdo dinâmico",
    "text": "40.9 Conteúdo dinâmico\nEm uma saída HTML, o conteúdo do seu relatório pode ser dinâmico. Abaixo estão alguns exemplos:\n\n40.9.1 Tabelas\nEm um relatório HTML, você pode imprimir quadros / tabelas de dados de forma que o conteúdo seja dinâmico, com filtros e barras de rolagem. Existem vários pacotes que oferecem esse recurso.\nPara fazer isso com o pacote DT, como é usado em todo este manual, você pode inserir um trecho de código como este:\n\n\n\n\n\n\n\n\n\nA função datatable() imprimirá o quadro de dados fornecido como uma tabela dinâmica para o leitor. Você pode definir rownames = FALSE para simplificar o lado esquerdo da tabela. filter = \"top\" fornece um filtro para cada coluna. No argumento option() forneça uma lista de outras especificações. Abaixo, incluímos dois: pageLength = 5 define o número de linhas que aparecem como 5 (as linhas restantes podem ser visualizadas através das setas), e scrollX = TRUE habilita uma barra de rolagem na parte inferior da tabela (para colunas que se estendem muito para a direita).\nSe seu conjunto de dados for muito grande, considere mostrar apenas as primeiras X linhas envolvendo o quadro de dados em head().\n\n\nWidgets HTML\n[HTML widgets for R] (http://www.htmlwidgets.org/) são uma classe especial de pacotes R que permitem maior interatividade utilizando bibliotecas JavaScript. Você pode embuti-los nas saídas HTML R Markdown.\nAlguns exemplos comuns desses widgets incluem:\n\nPlotly (usado nesta página do manual e na página Gráficos interativos)\nvisNetwork (usado na página Cadeias de transmissão deste manual)\nFolheto (usado na página Noções básicas de GIS deste manual)\ndygraphs (úteis para mostrar dados de séries temporais de forma interativa)\nDT (datatable()) (usado para mostrar tabelas dinâmicas com filtro, classificação, etc.)\n\nA função ggplotly() de plotly é particularmente fácil de usar. Veja a página Gráficos interativos.",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Relatórios com R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/rmarkdown.pt.html#recursos",
    "href": "new_pages/rmarkdown.pt.html#recursos",
    "title": "40  Relatórios com R Markdown",
    "section": "40.10 Recursos",
    "text": "40.10 Recursos\nMais informações podem ser encontradas em:\n\nhttps://bookdown.org/yihui/rmarkdown/\nhttps://rmarkdown.rstudio.com/articles_intro.html\n\nUma boa explicação de markdown vs knitr vs Rmarkdown está aqui: https://stackoverflow.com/questions/40563479/relationship-between-r-markdown-knitr-pandoc-and-bookdown",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>40</span>  <span class='chapter-title'>Relatórios com R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.pt.html",
    "href": "new_pages/reportfactory.pt.html",
    "title": "41  Organização de relatórios de rotina",
    "section": "",
    "text": "41.1 Preparação",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Organização de relatórios de rotina</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.pt.html#preparação",
    "href": "new_pages/reportfactory.pt.html#preparação",
    "title": "41  Organização de relatórios de rotina",
    "section": "",
    "text": "Carregar pacotes\nDe dentro do RStudio, instale a versão mais recente do pacote reportfactory do Github.\nVocê pode fazer isso através do pacote pacman com p_load_current_gh () que forçará a instalação da última versão do Github. Forneça a cadeia de caracteres “reconverse/reportfactory”, que especifica a organização Github (reconverse) e o repositório (reportfactory). Você também pode usar install_github () do pacote remotes, como alternativa.\n\n# Instale e carregue a última versão do pacote do Github\npacman::p_load_current_gh(\"reconverse/reportfactory\")\n#remotes::install_github(\"reconverse/reportfactory\") # alternative",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Organização de relatórios de rotina</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.pt.html#nova-fábrica",
    "href": "new_pages/reportfactory.pt.html#nova-fábrica",
    "title": "41  Organização de relatórios de rotina",
    "section": "41.2 Nova fábrica",
    "text": "41.2 Nova fábrica\nPara criar uma nova fábrica, execute a função new_factory(). Isso criará uma nova pasta de projeto R independente. Por padrão:\n\nA fábrica será adicionada ao seu diretório de trabalho\nO nome do projeto de fábrica R será denominado “new_factory.Rproj”\n\nSua sessão RStudio irá “mover-se” para este projeto R\n\n\n# Isso criará a fábrica no diretório de trabalho\nnew_factory()\n\nOlhando dentro da fábrica, você pode ver que as subpastas e alguns arquivos foram criados automaticamente.\n\n\n\n\n\n\n\n\n\n\nA pasta report_sources manterá seus scripts R Markdown, que geram seus relatórios\n\nA pasta * outputs * conterá os resultados do relatório (por exemplo, HTML, Word, PDF, etc.)\n\nA pasta scripts pode ser usada para armazenar outros scripts R (por exemplo, que são fornecidos por seus scripts Rmd)\n\nA pasta data pode ser usada para armazenar seus dados (subpastas “brutas” e “limpas” estão incluídas)\n\nUm arquivo .here, para que você possa usar o pacote here para chamar arquivos em subpastas por sua relação com esta pasta raiz (consulte a página Projetos R para obter detalhes)\n\nUm arquivo gitignore foi criado no caso de você vincular este projeto R a um repositório Github (consulte Controle de versão e colaboração com Github)\n\nUm arquivo README vazio, se você usar um repositório Github\n\n **_ CUIDADO: _** dependendo da configuração do seu computador, arquivos como “.here” podem existir, mas são invisíveis. \nDas configurações padrão, abaixo estão várias que você pode querer ajustar dentro do comando new_factory ():\n\nfactory = - Fornece um nome para a pasta de fábrica (o padrão é “new_factory”)\n\npath = - Designa um caminho de arquivo para a nova fábrica (o padrão é o diretório de trabalho)\n\nreport_sources = Fornece um nome alternativo para a subpasta que contém os scripts R Markdown (o padrão é “report_sources”)\n\noutputs = Fornece um nome alternativo para a pasta que contém os resultados do relatório (o padrão é “outputs”)\n\nVeja ?New_factory para uma lista completa dos argumentos.\nQuando você cria a nova fábrica, sua sessão R é transferida para o novo projeto R, então você deve carregar novamente o pacote reportfactory.\n\npacman::p_load(reportfactory)\n\nAgora você pode executar o comando factory_overview() para ver a estrutura interna (todas as pastas e arquivos) na fábrica.\n\nfactory_overview() # imprime visão geral da fábrica para o console\n\nA seguinte “árvore” das pastas e arquivos da fábrica é impressa no console R. Observe que na pasta “dados” existem subpastas para dados “brutos” e “limpos” e dados CSV de exemplo. Também existe “example_report.Rmd” na pasta “report_sources”.",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Organização de relatórios de rotina</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.pt.html#crie-um-relatório",
    "href": "new_pages/reportfactory.pt.html#crie-um-relatório",
    "title": "41  Organização de relatórios de rotina",
    "section": "41.3 Crie um relatório",
    "text": "41.3 Crie um relatório\nDe dentro do projeto R de fábrica, crie um relatório R Markdown como faria normalmente e salve-o na pasta “report_sources”. Consulte a página R Markdown para obter instruções. Para fins de exemplo, adicionamos o seguinte à fábrica:\n\nUm novo script de markdown R intitulado “daily_sitrep.Rmd”, salvo na pasta “report_sources”\n\nDados para o relatório (“linelist_cleaned.rds”), salvos na subpasta “clean” dentro da pasta “data”\n\nPodemos ver usando factory_overview() nosso R Markdown na pasta “report_sources” e o arquivo de dados na pasta de dados “clean” (destacado):\n\n\n\n\n\n\n\n\n\nAbaixo está uma captura de tela do início do R Markdown “daily_sitrep.Rmd”. Você pode ver que o formato de saída é definido como HTML, por meio do cabeçalho YAML output: html_document.\n\n\n\n\n\n\n\n\n\nNeste script simples, existem comandos para:\n\nCarregar os pacotes necessários\n\nImportar os dados de lista de linha usando um caminho de arquivo do pacote here (leia mais na página em Importar e exportar)\n\n\nlinelist &lt;- import(here(\"data\", \"clean\", \"linelist_cleaned.rds\"))\n\n\nImprima uma tabela de resumo de casos e exporte-a com export() como um arquivo .csv\n\nImprima uma epicurva e exporte-a com ggsave() como um arquivo .png\n\nVocê pode revisar apenas a lista de relatórios R Markdown na pasta “report_sources” com este comando:\n\nlist_reports()",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Organização de relatórios de rotina</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.pt.html#compilar",
    "href": "new_pages/reportfactory.pt.html#compilar",
    "title": "41  Organização de relatórios de rotina",
    "section": "41.4 Compilar",
    "text": "41.4 Compilar\nEm uma fábrica de relatórios, “compilar” um relatório R Markdown significa que o script .Rmd será executado e a saída será produzida (conforme especificado no script YAML, por exemplo, como HTML, Word, PDF, etc).\nA fábrica criará automaticamente uma pasta com carimbo de data e hora para as saídas na pasta “saídas”.\nO próprio relatório e todos os arquivos exportados produzidos pelo script (por exemplo, csv, png, xlsx) serão salvos nesta pasta. Além disso, o próprio script Rmd será salvo nesta pasta, então você tem um registro dessa versão do script.\nIsso contrasta com o comportamento normal de um R Markdown “knitado” ou “tricotado”, que salva as saídas no local do script Rmd. Esse comportamento padrão pode resultar em pastas lotadas e confusas. A fábrica visa melhorar a organização quando é necessário executar relatórios com frequência.\n\nCompilar por nome\nVocê pode compilar um relatório específico executando compile_reports() e fornecendo o nome do script Rmd (sem extensão .Rmd) para reports =. Para simplificar, você pode pular o reports = e apenas escrever o nome R Markdown entre aspas, como abaixo.\n\n\n\n\n\n\n\n\n\nEste comando compilaria apenas o relatório “daily_sitrep.Rmd”, salvando o relatório HTML e as exportações da tabela .csv e epicurva .png para uma subpasta com carimbo de data e hora específica para o relatório, dentro da pasta “outputs”.\nObserve que se você optar por fornecer a extensão .Rmd, deverá digitar corretamente a extensão conforme ela é salva no nome do arquivo (.rmd vs. .Rmd).\nObserve também que, ao compilar, você pode ver vários arquivos aparecerem temporariamente na pasta “report_sources” - mas eles irão desaparecer em breve, pois são transferidos para a pasta “outputs” correta.\n\n\nCompilar por número\nVocê também pode especificar o script Rmd para compilar, fornecendo um número ou vetor de números para relatórios =. Os números devem estar alinhados com a ordem em que os relatórios aparecem quando você executa list_reports().\n\n# Compile o segundo e o quarto Rmds na pasta \"report_sources\"\ncompile_reports(reports = c(2, 4))\n\n\n\nCompilar todos\nVocê pode compilar todos os relatórios R Markdown na pasta “report_sources” definindo o argumento reports = para TRUE.\n\n\n\n\n\n\n\n\n\n\n\nCompilar da subpasta\nVocê pode adicionar subpastas à pasta “report_sources”. Para executar um relatório R Markdown de uma subpasta, simplesmente forneça o nome da pasta para subpasta =. Abaixo está um exemplo de código para compilar um relatório Rmd que reside em uma subpasta de “report_sources”.\n\ncompile_reports(\n     reports = \"summary_for_partners.Rmd\",\n     subfolder = \"for_partners\")\n\nVocê pode compilar todos os relatórios Rmd dentro de uma subpasta fornecendo o nome da subpasta para reports =, com uma barra no final, como abaixo.\n\ncompile_reports(reports = \"for_partners/\")\n\n\n\nParametrização\nConforme observado na página em Relatórios com R Markdown, você pode executar relatórios com parâmetros especificados. Você pode passar esses parâmetros como uma lista para compile_reports() através do argumento params =. Por exemplo, neste relatório fictício, há três parâmetros fornecidos para os relatórios R Markdown.\n\ncompile_reports(\n  reports = \"daily_sitrep.Rmd\",\n  params = list(most_recent_data = TRUE,\n                region = \"NORTHERN\",\n                rates_denominator = 10000),\n  subfolder = \"regional\"\n)\n\n\n\nUsando um “arquivo de execução”\nSe você tiver vários relatórios para executar, considere a criação de um script R que contenha todos os comandos de compile_reports (). Um usuário pode simplesmente executar todos os comandos neste script R e todos os relatórios serão compilados. Você pode salvar este “arquivo de execução” na pasta “scripts”.",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Organização de relatórios de rotina</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.pt.html#saídas",
    "href": "new_pages/reportfactory.pt.html#saídas",
    "title": "41  Organização de relatórios de rotina",
    "section": "41.5 Saídas",
    "text": "41.5 Saídas\nDepois de termos compilado os relatórios algumas vezes, a pasta “outputs” pode ter a seguinte aparência (destaques adicionados para maior clareza):\n\n\n\n\n\n\n\n\n\n\nDentro de “saídas”, subpastas foram criadas para cada relatório Rmd\n\nDentro delas, outras subpastas foram criadas para cada compilação única\n\nEstes são marcados com data e hora (“2021-04-23_T11-07-36” significa 23 de abril de 2021 às 11:07:36)\n\nVocê pode editar o formato do carimbo de data / hora. Veja ?Compile_reports\n\nDentro de cada pasta compilada de data / hora, a saída do relatório é armazenada (por exemplo, HTML, PDF, Word) junto com o script Rmd (controle de versão!) e quaisquer outros arquivos exportados (por exemplo, table.csv, epidemic_curve.png)\n\nAqui está uma visão dentro de uma das pastas com carimbo de data / hora, para o relatório “daily_sitrep”. O caminho do arquivo é destacado em amarelo para ênfase.\n\n\n\n\n\n\n\n\n\nFinalmente, abaixo está uma captura de tela da saída do relatório HTML.\n\n\n\n\n\n\n\n\n\nVocê pode usar list_outputs() para revisar uma lista das saídas.",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Organização de relatórios de rotina</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.pt.html#diversos",
    "href": "new_pages/reportfactory.pt.html#diversos",
    "title": "41  Organização de relatórios de rotina",
    "section": "41.6 Diversos",
    "text": "41.6 Diversos\n\n41.6.1 Knit\nVocê ainda pode “tricotar” um de seus relatórios R Markdown pressionando o botão “Knit”, se desejar. Se você fizer isso, como padrão, as saídas aparecerão na pasta onde o Rmd foi salvo - a pasta “report_sources”. Nas versões anteriores do reportfactory, ter qualquer arquivo não-Rmd em “report_sources” impedia a compilação, mas não é mais o caso. Você pode executar compile_reports() e nenhum erro ocorrerá.\n\n\nScripts\nIncentivamos você a utilizar a pasta “scripts” para armazenar “arquivos de execução” ou scripts .R originados de seus scripts .Rmd. Consulte a página em R Markdown para dicas sobre como estruturar seu código em vários arquivos.\n\n\nExtras\n\nCom reportfactory, você pode usar a função list_deps() para listar todos os pacotes necessários em todos os relatórios em toda a fábrica.\nHá um pacote de acompanhamento em desenvolvimento chamado rfextras que oferece mais funções auxiliares para auxiliá-lo na construção de relatórios, como:\n\nload_scripts() - origina / carrega todos os scripts .R em uma determinada pasta (a pasta “scripts” por padrão)\n\nfind_latest() - encontra a versão mais recente de um arquivo (por exemplo, o conjunto de dados mais recente)",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Organização de relatórios de rotina</span>"
    ]
  },
  {
    "objectID": "new_pages/reportfactory.pt.html#recursos",
    "href": "new_pages/reportfactory.pt.html#recursos",
    "title": "41  Organização de relatórios de rotina",
    "section": "41.7 Recursos",
    "text": "41.7 Recursos\nVeja o pacote reportfactory página Github\nVeja o pacote rfextras página Github",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>41</span>  <span class='chapter-title'>Organização de relatórios de rotina</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.pt.html",
    "href": "new_pages/flexdashboard.pt.html",
    "title": "42  Painéis (Dashboards) com R Markdown",
    "section": "",
    "text": "42.1 Preparação",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Painéis (Dashboards) com R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.pt.html#preparação",
    "href": "new_pages/flexdashboard.pt.html#preparação",
    "title": "42  Painéis (Dashboards) com R Markdown",
    "section": "",
    "text": "Carregar pacotes\nNeste manual, enfatizamos p_load() de pacman, que instala o pacote se necessário e o carrega para uso. Você também pode carregar pacotes instalados com library() de base R. Veja a página em Introdução ao R para mais informações sobre pacotes R.\n\npacman :: p_load(\n  rio, # importação / exportação de dados     \n  here, # localize arquivos\n  tidyverse, # gerenciamento e visualização de dados\n  flexdashboard, # versões de painel de relatórios R Markdown\n  shiny, # figuras interativas\n  plotly # figuras interativas\n)\n\n\n\nImportar dados\nImportamos o conjunto de dados de casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar,  clique para baixar o “clean” linelist  (as .rds file). Importe dados com a função import() do pacote rio (ele lida com muitos tipos de arquivo como .xlsx, .csv, .rds - veja a página Importar e exportar para detalhes).\n\n# importar a linelist\nlinelist &lt;- import(\"linelist_cleaned.rds\")\n\nAs primeiras 50 linhas da linelist são exibidas abaixo.",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Painéis (Dashboards) com R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.pt.html#criar-novo-r-markdown",
    "href": "new_pages/flexdashboard.pt.html#criar-novo-r-markdown",
    "title": "42  Painéis (Dashboards) com R Markdown",
    "section": "42.2 Criar novo R Markdown",
    "text": "42.2 Criar novo R Markdown\nDepois de instalar o pacote, crie um novo arquivo R Markdown clicando em Arquivo&gt; Novo arquivo&gt; R Markdown.\n\n\n\n\n\n\n\n\n\nNa janela que se abre, selecione “Do modelo” (From template) e selecione o modelo “Flex Dashboard”. Em seguida, você será solicitado a nomear o documento. No exemplo desta página, nomearemos nosso R Markdown como “outbreak_dashboard.Rmd”.",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Painéis (Dashboards) com R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.pt.html#o-script",
    "href": "new_pages/flexdashboard.pt.html#o-script",
    "title": "42  Painéis (Dashboards) com R Markdown",
    "section": "42.3 O script",
    "text": "42.3 O script\nO script é um script R Markdown e, portanto, tem os mesmos componentes e organização descritos na página Relatórios com R Markdown. Nós os revisamos brevemente e destacamos as diferenças de outros formatos de saída do R Markdown.\n\nYAML\nNo topo do script está o cabeçalho “YAML”. Isso deve começar com três traços --- e deve fechar com três traços ---. Os parâmetros YAML vêm em pares chave: valor. O recuo e a colocação dos dois pontos em YAML são importantes - os pares chave: valor são separados por dois pontos (e não sinais de igual!).\nO YAML deve começar com metadados para o documento. A ordem desses parâmetros YAML primários (não recuados) não importa. Por exemplo:\n\ntitle: \"Meu documento\"\nauthor: \"Eu\"\ndate: \"` r Sys.Date() `\"\n\nVocê pode usar o código R em valores YAML escrevendo-o como código in-line (precedido por r dentro de crases), mas também entre aspas (veja o exemplo acima para date:).\nUm parâmetro YAML necessário é output:, que especifica o tipo de arquivo a ser produzido (por exemplo, html_document,pdf_document, word_document oupowerpoint_presentation). Para flexdashboard este valor de parâmetro é um pouco confuso - ele deve ser definido como output: flexdashboard :: flex_dashboard. Observe os dois pontos simples e duplos e o sublinhado. Este parâmetro de saída YAML é frequentemente seguido por dois pontos adicionais e subparâmetros indentados (veja os parâmetros orientação: e vertical_layout: abaixo).\n\ntitle: \"Meu painel\"\nauthor: \"Eu\"\ndate: \"` r Sys.Date() `\"\noutput:\n  flexdashboard::flex_dashboard:\n    orientation: rows\n    vertical_layout: scroll\n\nConforme mostrado acima, recuos (2 espaços) são usados para subparâmetros. Neste caso, não se esqueça de colocar dois pontos adicionais após o primário, como chave: valor:.\nSe apropriado, os valores lógicos devem ser fornecidos em YAML em letras minúsculas (true,false, null). Se dois pontos fizerem parte do seu valor (por exemplo, no título), coloque o valor entre aspas. Veja os exemplos nas seções abaixo.\n\n\nBlocos de código\nUm script R Markdown pode conter vários “pedaços” (chunks) de código - essas são áreas do script onde você pode escrever código R de várias linhas e funcionam como mini scripts R.\nOs trechos de código são criados com três marcas invertidas e chaves com um “r” minúsculo dentro. O pedaço é fechado com três crases. Você pode criar um novo bloco digitando-o você mesmo, usando o atalho de teclado “Ctrl+Alt+i” (ou Cmd+Shift+r no Mac) ou clicando no ícone verde ‘inserir um novo bloco de código’ no topo do seu editor de script. Muitos exemplos são fornecidos a seguir.\n\n\nTexto narrativo\nFora de um “bloco” de código R, você pode escrever um texto narrativo. Conforme descrito na página em Relatórios com R Markdown, você pode colocar o texto em itálico circundando-o com um asterisco (*) ou em negrito circundando-o com dois asteriscos (**). Lembre-se de que os marcadores e os esquemas de numeração são sensíveis a novas linhas, recuo e acabamento de uma linha com dois espaços.\nVocê também pode inserir o código R nas próprias linhas de texto (in-line), conforme descrito na página Relatórios com R Markdown, circundando o código com crases e iniciando o comando com “r”: `1 + 1`(veja o exemplo com data acima).\n\n\nTítulos\nDiferentes níveis de título são estabelecidos com diferentes números de símbolos hash ou jogo da velha, conforme descrito na página Relatórios com R Markdown.\nEm flexdashboard, um título principal (#) cria uma “página” do painel. Títulos de segundo nível (##) criam uma coluna ou uma linha dependendo do seu parâmetro orientação: (veja os detalhes abaixo). Títulos de terceiro nível (###) criam painéis para plotagens, gráficos, tabelas, texto, etc.\n# Título de primeiro nível (página)\n\n## Título de segundo nível (linha ou coluna)  \n\n### Cabeçalho de terceiro nível (painel para plot, gráfico, etc.)",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Painéis (Dashboards) com R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.pt.html#atributos-da-seção",
    "href": "new_pages/flexdashboard.pt.html#atributos-da-seção",
    "title": "42  Painéis (Dashboards) com R Markdown",
    "section": "42.4 Atributos da seção",
    "text": "42.4 Atributos da seção\nComo em uma marcação R normal, você pode especificar atributos a serem aplicados a partes do seu painel, incluindo opções key = value após um título, entre chaves {}. Por exemplo, em um relatório HTML R Markdown típico, você pode organizar subtítulos em guias com ## Meu título {.tabset}.\nObserve que esses atributos são escritos após um título em uma parte do texto do script. Elas são diferentes das opções do knitr inseridas no topo dos blocos de código R, como out.height =.\nOs atributos de seção específicos para flexdashboard incluem:\n\n{data-orientation=} Defina para linhas oucolunas. Se o seu painel tiver várias páginas, adicione este atributo a cada página para indicar a orientação (mais explicado em seção de layout).\n\n{data-width =} e {data-height =} definem o tamanho relativo dos gráficos, colunas, linhas dispostas na mesma dimensão (horizontal ou vertical). Tamanhos absolutos são ajustados para melhor preencher o espaço em qualquer dispositivo de exibição graças ao mecanismo flexbox.\n\nA altura dos gráficos também depende de você definir o parâmetro YAML vertical_layout: fill ou vertical_layout: scroll. Se configurado para rolar, a altura da figura refletirá a opção tradicional fig.height = no fragmento do código R.\n\nConsulte a documentação de tamanho completa no site do flexdashboard\n\n\n{.hidden} Use isto para excluir uma página específica da barra de navegação\n\n{data-navbar =} Use isso em um título de nível de página para aninhá-lo dentro de um menu suspenso da barra de navegação. Forneça o nome (entre aspas) do menu suspenso. Veja o exemplo abaixo.",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Painéis (Dashboards) com R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.pt.html#layout",
    "href": "new_pages/flexdashboard.pt.html#layout",
    "title": "42  Painéis (Dashboards) com R Markdown",
    "section": "42.5 Layout",
    "text": "42.5 Layout\nAjuste o layout do seu painel (dashboard) das seguintes maneiras:\n\nAdicione páginas, colunas / linhas e gráficos com títulos R Markdown (por exemplo, #, ## ou ###)\n\nAjuste o parâmetro YAML orientation: para rows oucolumns\n\nEspecifique se o layout preenche o navegador ou permite rolagem\n\nAdicionar guias a um título de seção específico\n\n\n42.5.1 Imagens\nOs títulos de primeiro nível (#) no R Markdown representarão as “páginas” do painel. Por padrão, as páginas aparecerão em uma barra de navegação na parte superior do painel.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVocê pode agrupar páginas em um “menu” na barra de navegação superior adicionando o atributo {data-navmenu =} ao título da página. Tenha cuidado - não inclua espaços ao redor do sinal de igual, caso contrário, não funcionará!\n\n\n\n\n\n\n\n\n\nAqui está o que o script produz:\n\n\n\n\n\n\n\n\n\nVocê também pode converter uma página ou coluna em uma “barra lateral” no lado esquerdo do painel, adicionando o atributo {.sidebar}. Ele pode conter texto (visualizável em qualquer página) ou, se você tiver uma interatividade shiny integrada, pode ser útil manter os controles de entrada do usuário, como controles deslizantes ou menus suspensos.\n\n\n\n\n\n\n\n\n\nAqui está o que o script produz:\n\n\n\n\n\n\n\n\n\n\n\nOrientação\nDefina o parâmetro orientation: yaml para indicar como os cabeçalhos do R Markdown de segundo nível (##) devem ser interpretados - como orientation: columns ou orientação: rows.\nTítulos de segundo nível (##) serão interpretados como novas colunas ou linhas com base nesta configuração de orientation.\nSe você definir orientation: columns, os cabeçalhos de segundo nível criarão novas colunas no painel. O painel abaixo possui uma página, contendo duas colunas, com um total de três painéis. Você pode ajustar a largura relativa das colunas com {data-width =} conforme mostrado abaixo.\n\n\n\n\n\n\n\n\n\nAqui está o que o script produz:\n\n\n\n\n\n\n\n\n\nSe você definir orientation: rows, os cabeçalhos de segundo nível criarão novas linhas em vez de colunas. Abaixo está o mesmo script acima, mas com orientation: rows para que os títulos de segundo nível produzam linhas em vez de colunas. Você pode ajustar a altura relativa das linhas com {data-height =} conforme mostrado abaixo.\n\n\n\n\n\n\n\n\n\nAqui está o que o script produz:\n\n\n\n\n\n\n\n\n\nSe o seu painel tiver várias páginas, você pode designar a orientação de cada página específica adicionando o atributo {data -idance =} ao cabeçalho de cada página (especifique rows oucolumns sem aspas).\n\n\nTabs\nVocê pode dividir o conteúdo em guias com o atributo {.tabset}, como em outras saídas HTML R Markdown.\nBasta adicionar este atributo após o título desejado. Os subtítulos sob esse título serão exibidos como guias. Por exemplo, no script de exemplo abaixo da coluna 2 à direita (##) é modificado para que a curva epidêmica e os painéis da tabela (###) sejam exibidos em guias.\nVocê pode fazer o mesmo com linhas se sua orientação for linhas.\n\n\n\n\n\n\n\n\n\nAqui está o que o script produz:",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Painéis (Dashboards) com R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.pt.html#adicionando-conteúdo",
    "href": "new_pages/flexdashboard.pt.html#adicionando-conteúdo",
    "title": "42  Painéis (Dashboards) com R Markdown",
    "section": "42.6 Adicionando conteúdo",
    "text": "42.6 Adicionando conteúdo\nVamos começar a construir um painel (dashboard). Nosso painel simples terá 1 página, 2 colunas e 4 painéis. Vamos construir os painéis peça por peça para demonstração.\nVocê pode incluir facilmente saídas R padrão, como texto, ggplots e tabelas (consulte a página Tabelas para apresentação). Simplesmente codifique-os dentro de um fragmento de código R, como faria para qualquer outro script R Markdown.\nObservação: você pode baixar o script Rmd finalizado e a saída do painel HTML - consulte a página Baixar manual e dados.\n\nTexto\nVocê pode digitar o texto do Markdown e incluir o código in-line como para qualquer outra saída do R Markdown. Consulte a página Relatórios com R Markdown para obter detalhes.\nNeste painel (dashboard), incluímos um painel de texto de resumo que inclui um texto dinâmico mostrando a última data de hospitalização e o número de casos relatados no surto.\n\n\nTabelas\nVocê pode incluir blocos de código R que imprimem saídas, como tabelas. Mas a saída terá uma aparência melhor e responderá ao tamanho da janela se você usar a função kable() do knitr para exibir suas tabelas. As funções flextable podem produzir tabelas que são reduzidas / cortadas.\nPor exemplo, abaixo, alimentamos linelist() por meio de um comando count() para produzir uma tabela de resumo de casos por hospital. Por fim, a tabela é direcionada para knitr :: kable() e o resultado tem uma barra de rolagem à direita. Você pode ler mais sobre como personalizar sua tabela com kable() e kableExtra [aqui] (https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html).\n\n\n\n\n\n\n\n\n\nAqui está o que o script produz:\n\n\n\n\n\n\n\n\n\nSe você deseja mostrar uma tabela dinâmica que permite ao usuário filtrar, classificar e / ou clicar nas “páginas” do quadro de dados, use o pacote DT e sua função datatable(), como no código abaixo.\nO código de exemplo abaixo, a linelist do quadro de dados é impressa. Você pode definir rownames = FALSE para conservar espaço horizontal efilter = \"top\"para ter filtros no topo de cada coluna. Uma lista de outras especificações pode ser fornecida para options =. Abaixo, definimos pageLength = para que 5 linhas apareçam e scrollX = para que o usuário possa usar uma barra de rolagem na parte inferior para rolar horizontalmente. O argumento class = 'white-space: nowrap' garante que cada linha seja uma linha (não várias linhas). Você pode ler sobre outros argumentos e valores possíveis aqui ou inserindo ?Datatable\n\nDT :: datatable(linelist, \n              rownames = FALSE,\n              options = list(pageLength = 5, scrollX = TRUE),\n              class = 'white-space: nowrap' )\n\n\n\nGráficos\nVocê pode imprimir gráficos em um painel de controle como faria em um script R. Em nosso exemplo, usamos o pacote incidence2 para criar uma “epicurva” por faixa etária com dois comandos simples (consulte a página Curvas epidêmicas). No entanto, você pode usar ggplot() e imprimir um gráfico da mesma maneira.\n\n\n\n\n\n\n\n\n\nAqui está o que o script produz:\n\n\n\n\n\n\n\n\n\n\n\nGráficos interativos\nVocê também pode passar um ggplot padrão ou outro objeto de gráfico para ggplotly() do pacote plotly (consulte a página Gráficos Interativos). Isso tornará seu gráfico interativo, permitirá que o leitor “amplie” e mostre o valor de cada ponto de dados (neste cenário, o número de casos por semana e a faixa etária na curva).\n\nage_outbreak &lt;- incidence(linelist, date_onset, \"week\", groups = age_cat)\nplot(age_outbreak, fill = age_cat, col_pal = muted, title = \"\") %&gt;% \n  plotly::ggplotly()\n\nAqui está a aparência disso no painel (gif). Essa funcionalidade interativa ainda funcionará mesmo se você enviar por e-mail o painel como um arquivo estático (não online em um servidor).\n\n\n\n\n\n\n\n\n\n\n\nFerramentas (Widgets) HTML\nHTML widgets for R são uma classe especial de pacotes R que permitem maior interatividade utilizando bibliotecas JavaScript. Você pode incorporá-los nas saídas do R Markdown (como um flexdashboard) e nos painéis do Shiny.\nAlguns exemplos comuns desses widgets incluem:\n\nPlotly (usado nesta página do manual e na página Gráficos interativos)\nvisNetwork (usado na página Cadeias de transmissão deste manual)  \nLeaflet (usado na página Noções básicas de GIS deste manual)  \ndygraphs (úteis para mostrar dados de séries temporais de forma interativa)  \nDT (datatable()) (usado para mostrar tabelas dinâmicas com filtro, classificação, etc.)\n\nAbaixo, demonstramos como adicionar uma cadeia de transmissão epidêmica que usa visNetwork ao painel. O script mostra apenas o novo código adicionado à seção “Coluna 2” do script R Markdown. Você pode encontrar o código na página Cadeias de transmissão deste manual.\n\n\n\n\n\n\n\n\n\nAqui está o que o script produz:",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Painéis (Dashboards) com R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.pt.html#organização-de-código",
    "href": "new_pages/flexdashboard.pt.html#organização-de-código",
    "title": "42  Painéis (Dashboards) com R Markdown",
    "section": "42.7 Organização de código",
    "text": "42.7 Organização de código\nVocê pode optar por ter todo o código dentro do script R Markdown flexdashboard. Como alternativa, para ter um script de painel mais limpo e conciso, você pode optar por chamar códigos / figuras que são hospedados ou criados em scripts R externos. Isso é descrito com mais detalhes na página Relatórios com R Markdown.",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Painéis (Dashboards) com R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.pt.html#shiny",
    "href": "new_pages/flexdashboard.pt.html#shiny",
    "title": "42  Painéis (Dashboards) com R Markdown",
    "section": "42.8 Shiny",
    "text": "42.8 Shiny\nA integração do pacote R shiny pode tornar seus painéis (dashboards) ainda mais reativos à entrada do usuário. Por exemplo, você pode fazer com que o usuário selecione uma jurisdição ou um intervalo de datas e os painéis reajam à sua escolha (por exemplo, filtrar os dados exibidos). Para incorporar a reatividade shiny ao flexdashboard, você só precisa fazer algumas alterações no script R Markdown do flexdashboard.\nVocê pode usar shiny para produzir aplicativos / painéis sem flexdashboard também. A página do manual em Dashboards with Shiny oferece uma visão geral dessa abordagem, incluindo instruções sobre sintaxe shiny, estrutura de arquivo de aplicativo e opções para compartilhamento / publicação (incluindo opções de servidor gratuitas). Essa sintaxe e dicas gerais também se traduzem no contexto do flexdashboard.\nIncorporar shiny em flexdashboard é, no entanto, uma mudança fundamental em seu flexdashboard. Ele não produzirá mais uma saída HTML que você pode enviar por e-mail e qualquer pessoa pode abrir e visualizar. Em vez disso, será um “aplicativo”. O botão “Knit” na parte superior do script será substituído por um ícone “Executar documento”, que abrirá uma instância do painel interativo localmente em seu computador.\nCompartilhar seu painel agora exigirá que você:\n\nEnvie o script Rmd para o visualizador, ele o abre em R no computador e executa o aplicativo ou\n\nO aplicativo / painel é hospedado em um servidor acessível ao visualizador\n\nPortanto, há benefícios em integrar shiny, mas também complicações. Se o compartilhamento fácil por e-mail for uma prioridade e você não precisar de recursos reativos shiny, considere a interatividade reduzida oferecida por ggplotly() conforme demonstrado acima.\nAbaixo, damos um exemplo muito simples usando o mesmo “outbreak_dashboard.Rmd” acima. A documentação extensa sobre a integração do Shiny no flexdashboard está disponível online aqui.\n\nConfigurações\nHabilite shiny em um flexdashboard adicionando o parâmetro YAML runtime: shiny no mesmo nível de indentação queoutput:, como abaixo:\n---\ntitle: \"Painel de controle do Outbreak (demonstração Shiny)\"\noutput: \n  flexdashboard::flex_dashboard:\n    orientation: columns\n    vertical_layout: fill\nruntime: shiny\n---\nTambém é conveniente habilitar uma “barra lateral” para conter os widgets de entrada shiny que coletarão informações do usuário. Como explicado acima, crie uma coluna e indique a opção {.sidebar} para criar uma barra lateral no lado esquerdo. Você pode adicionar texto e pedaços R contendo os comandos shiny entrada dentro desta coluna.\nSe seu aplicativo / painel está hospedado em um servidor e pode ter vários usuários simultâneos, nomeie o primeiro fragmento de código R como global. Inclua os comandos para importar / carregar seus dados neste bloco. Esse fragmento com nome especial é tratado de maneira diferente e os dados importados dentro dele são importados apenas uma vez (não continuamente) e estão disponíveis para todos os usuários. Isso melhora a velocidade de inicialização do aplicativo.\n\n\nExemplo trabalhado\nAqui, adaptamos o script flexdashboard “outbreak_dashboard.Rmd” para incluir shiny. Adicionaremos a capacidade de o usuário selecionar um hospital em um menu suspenso e fazer com que a curva de epidemia reflita apenas os casos desse hospital, com um título de gráfico dinâmico. Fazemos o seguinte:\n\nAdicione runtime: shiny ao YAML\n\nRenomeie o trecho de configuração como global\n\nCrie uma barra lateral contendo:\n\nCódigo para criar um vetor de nomes de hospitais exclusivos\n\nUm comando selectInput() (menu suspenso shiny) com a escolha de nomes de hospitais. A seleção é salva como hospital_choice, que pode ser referenciada no código posterior comoinput$hospital_choice\n\n\nO código da curva epidêmica (coluna 2) está dentro de renderPlot({}), incluindo:\n\nUm filtro no conjunto de dados restringindo a coluna hospital ao valor atual de input$hospital_choice\n\nUm título de um gráfico dinâmico que incorpora input$hospital_choice\n\n\nObserve que qualquer código que faça referência a um valor input$ deve estar dentro de uma função render({}) (para ser reativo).\nAqui está o topo do script, incluindo YAML, parte global e barra lateral:\n\n\n\n\n\n\n\n\n\nAqui está a Coluna 2, com o gráfico de epicurva reativa:\n\n\n\n\n\n\n\n\n\nE aqui está o painel:\n\n\n\n\n\n\n\n\n\n\n\nOutros exemplos\nPara ler um exemplo relacionado à saúde de um Shiny - flexdashboard usando a interatividade shiny e o widget de mapeamento de leaflet, consulte este capítulo do livro online Dados de saúde geoespaciais: Modelagem e Visualização com R-INLA e Shiny.",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Painéis (Dashboards) com R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.pt.html#compartilhamento",
    "href": "new_pages/flexdashboard.pt.html#compartilhamento",
    "title": "42  Painéis (Dashboards) com R Markdown",
    "section": "42.9 Compartilhamento",
    "text": "42.9 Compartilhamento\nOs painéis que não contêm elementos Shiny produzirão um arquivo HTML (.html), que pode ser enviado por e-mail (se o tamanho permitir). Isso é útil, pois você pode enviar o relatório de “painel” e não precisa configurar um servidor para hospedá-lo como um site.\nSe você tiver incorporado shiny, não poderá enviar uma saída por e-mail, mas pode enviar o próprio script para um usuário R ou hospedar o painel em um servidor conforme explicado acima.",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Painéis (Dashboards) com R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/flexdashboard.pt.html#recursos",
    "href": "new_pages/flexdashboard.pt.html#recursos",
    "title": "42  Painéis (Dashboards) com R Markdown",
    "section": "42.10 Recursos",
    "text": "42.10 Recursos\nExcelentes tutoriais que informaram esta página podem ser encontrados abaixo. Se você revisar isso, provavelmente dentro de uma hora poderá ter seu próprio painel.\nhttps://bookdown.org/yihui/rmarkdown/dashboards.html\nhttps://rmarkdown.rstudio.com/flexdashboard/\nhttps://rmarkdown.rstudio.com/flexdashboard/using.html\nhttps://rmarkdown.rstudio.com/flexdashboard/examples.html",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>42</span>  <span class='chapter-title'>Painéis (Dashboards) com R Markdown</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.pt.html",
    "href": "new_pages/shiny_basics.pt.html",
    "title": "43  Painéis com Shiny",
    "section": "",
    "text": "43.1 Preparação",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Painéis com Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.pt.html#preparação",
    "href": "new_pages/shiny_basics.pt.html#preparação",
    "title": "43  Painéis com Shiny",
    "section": "",
    "text": "Carregar pacotes\nNeste manual, enfatizamos p_load() de pacman, que instala o pacote se necessário e o carrega para uso. Você também pode carregar pacotes instalados com library() do R base. Veja a página em Introdução ao R para mais informações sobre pacotes R.\nComeçamos instalando o pacote R shiny:\n\npacman::p_load(\"shiny\")\n\n\n\nImportar dados\nSe você gostaria de acompanhar esta página, consulte esta seção do Baixar manual e dados. Existem links para baixar os scripts R e arquivos de dados que produzem o aplicativo Shiny final.\nSe você tentar reconstruir o aplicativo usando esses arquivos, esteja ciente da estrutura de pastas do projeto R que é criada durante a demonstração (por exemplo, pastas para “dados” e para “funções”).",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Painéis com Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.pt.html#a-estrutura-de-um-aplicativo-shiny",
    "href": "new_pages/shiny_basics.pt.html#a-estrutura-de-um-aplicativo-shiny",
    "title": "43  Painéis com Shiny",
    "section": "43.2 A estrutura de um aplicativo shiny",
    "text": "43.2 A estrutura de um aplicativo shiny\n\nEstruturas de arquivo básicas\nPara entender shiny, primeiro precisamos entender como funciona a estrutura de arquivos de um aplicativo! Devemos fazer um novo diretório antes de começar. Na verdade, isso pode ser facilitado escolhendo Novo projeto em Rstudio e escolhendo Shiny Web Application. Isso criará a estrutura básica de um aplicativo shiny para você.\nAo abrir este projeto, você notará que já existe um arquivo .R chamado app.R. É essencial que tenhamos uma das duas estruturas básicas de arquivo:\n\nUm arquivo chamado app.R, ou\n\nDois arquivos, um denominado ui.R e o outro server.R\n\nNesta página, usaremos a primeira abordagem de ter um arquivo chamado app.R. Aqui está um script de exemplo:\n\n# um exemplo de app.R\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n\n    # Título do aplicativo\n    titlePanel(\"Meu aplicativo\"),\n\n    # Barra lateral com um widget de entrada deslizante\n    sidebarLayout(\n        sidebarPanel(\n            sliderInput(\"input_1\")\n        ),\n\n        # Mostrar um gráfico \n        mainPanel(\n           plotOutput(\"my_plot\")\n        )\n    )\n)\n\n# Defina a lógica do servidor necessária para desenhar um histograma\nserver &lt;- function(input, output) {\n     \n     plot_1 &lt;- reactive({\n          plot_func(param = input_1)\n     })\n     \n    output$my_plot &lt;- renderPlot({\n       plot_1()\n    })\n}\n\n\n# Execute o aplicativo \nshinyApp(ui = ui, server = server)\n\nSe você abrir este arquivo, você notará que dois objetos são definidos - um chamado ui e outro chamado servidor. Esses objetos devem ser definidos em todos os aplicativos shiny e são centrais para a estrutura do próprio aplicativo! Na verdade, a única diferença entre as duas estruturas de arquivo descritas acima é que na estrutura 1, ui e server são definidos em um arquivo, enquanto na estrutura 2 eles são definidos em arquivos separados. Nota: nós também podemos (e devemos se tiver um aplicativo maior) ter outros arquivos .R em nossa estrutura que podemos source() em nosso aplicativo.\n\n\nO servidor e a ui\nEm seguida, precisamos entender o que os objetos server e ui realmente do. Simplificando, esses são dois objetos que estão interagindo entre si sempre que o usuário interage com o aplicativo shiny.\nO elemento UI de um aplicativo shiny é, em um nível básico, o código R que cria uma interface HTML. Isso significa tudo o que é exibido na IU de um aplicativo. Isso geralmente inclui:\n\n“Widgets” - menus suspensos, caixas de seleção, controles deslizantes etc. com os quais o usuário pode interagir\nPlots, tabelas, etc - saídas que são geradas com o código R\nAspectos de navegação de um aplicativo - guias, painéis, etc.\nTexto genérico, hiperlinks, etc.\nElementos HTML e CSS (abordado posteriormente)\n\nO mais importante a entender sobre a IU é que ela recebe entradas do usuário e exibe saídas do servidor. Não há código ativo em execução na interface do usuário a qualquer momento - todas as alterações vistas na interface do usuário são passadas pelo servidor (mais ou menos). Portanto, temos que fazer nossos gráficos, downloads, etc no servidor\nO servidor do aplicativo shiny é onde todo o código está sendo executado assim que o aplicativo é inicializado. A maneira como isso funciona é um pouco confusa. A função de servidor irá efetivamente reagir à interface do usuário com a IU e executar pedaços de código em resposta. Se as coisas mudarem no servidor, elas serão repassadas para a interface do usuário, onde as mudanças podem ser vistas. É importante ressaltar que o código no servidor será executado não consecutivamente (ou é melhor pensar dessa forma). Basicamente, sempre que uma entrada da interface do usuário afetar um pedaço de código no servidor, ela será executada automaticamente e essa saída será produzida e exibida.\nIsso tudo provavelmente parece muito abstrato por agora, então teremos que mergulhar em alguns exemplos para ter uma ideia clara de como isso realmente funciona.\n\n\nAntes de começar a construir um aplicativo\nAntes de começar a construir um aplicativo, é extremamente útil saber o que você deseja construir. Uma vez que sua IU será escrita em código, você não pode realmente visualizar o que está construindo, a menos que esteja visando algo específico. Por esse motivo, é extremamente útil olhar muitos exemplos de aplicativos shiny para ter uma ideia do que você pode fazer - ainda melhor se você puder olhar o código-fonte por trás desses aplicativos! Alguns ótimos recursos para isso são:\n\nA galeria de aplicativos Rstudio\n\nDepois de ter uma ideia do que é possível, também é útil mapear como você quer que o seu fique - você pode fazer isso no papel ou em qualquer software de desenho (PowerPoint, MS Paint etc.). É útil começar de forma simples para seu primeiro aplicativo! Também não há vergonha em usar o código que você encontra online de um bom aplicativo como modelo para o seu trabalho - é muito mais fácil do que construir algo do zero!",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Painéis com Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.pt.html#construindo-uma-iu",
    "href": "new_pages/shiny_basics.pt.html#construindo-uma-iu",
    "title": "43  Painéis com Shiny",
    "section": "43.3 Construindo uma IU",
    "text": "43.3 Construindo uma IU\nAo construir nosso aplicativo, é mais fácil trabalhar na IU primeiro, para que possamos ver o que estamos fazendo e não correr o risco de o aplicativo falhar devido a erros do servidor. Como mencionado anteriormente, geralmente é bom usar um modelo ao trabalhar na IU. Existem vários layouts padrão que podem ser usados com o shiny que estão disponíveis no pacote base shiny, mas é importante notar que também há várias extensões de pacote como shinydashboard. Usaremos um exemplo da base shiny para começar.\nUma IU shiny é geralmente definida como uma série de funções aninhadas, na seguinte ordem\n\nUma função que define o layout geral (a mais básica é fluidPage(), mas há mais disponíveis)\nPainéis dentro do layout, como:\n\numa barra lateral (sidebarPanel())\num painel “principal” (mainPanel())\numa guia (tabPanel())\numa “coluna” genérica (coluna())\n\nFerramentas (Widgets) e saídas - podem conferir entradas para o servidor (widgets) ou saídas do servidor (saídas)\n\nOs widgets geralmente são estilizados como xxxInput(), por exemplo selectInput ()\nAs saídas são geralmente estilizadas como xxxOutput(), por exemplo plotOutput()\n\n\nVale a pena reafirmar que eles não podem ser visualizados facilmente de forma abstrata, então é melhor dar uma olhada em um exemplo! Vamos considerar a criação de um aplicativo básico que visualiza os dados de contagem de nossas instalações para malária por distrito. Esses dados têm muitos parâmetros diferentes, então seria ótimo se o usuário final pudesse aplicar alguns filtros para ver os dados por faixa etária / distrito como achar melhor! Podemos usar um layout shiny muito simples para começar - o layout da barra lateral. Este é um layout onde os widgets são colocados em uma barra lateral à esquerda e o gráfico é colocado à direita.\nVamos planejar nosso aplicativo - podemos começar com um seletor que nos permite escolher o bairro onde queremos visualizar os dados, e outro para nos permitir visualizar a faixa etária que nos interessa. Nosso objetivo é usar esses filtros para mostrar uma epicurva que reflete esses parâmetros. Então, para isso, precisamos:\n\nDois menus suspensos que nos permitem escolher o distrito que desejamos e a faixa etária em que estamos interessados.\nUma área onde podemos mostrar nossa epicurva resultante.\n\nIsso pode ser parecido com isto:\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n\n  titlePanel (\"Aplicativo de visualização de instalação para malária\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # seletor para distrito\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Selecionar distrito\",\n              escolhas = c(\n                   \"Tudo\",\n                   \"Primavera\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selecionado = \"Tudo\",\n              múltiplo = TRUE\n         ),\n         # seletor para faixa etária\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Selecionar faixa etária\",\n              escolhas = c(\n                   \"Todas as idades\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ),\n              selecionado = \"Tudo\",\n              múltiplo = FALSE\n         )\n\n    ),\n\n    mainPanel(\n      # epicurva vai aqui\n      plotOutput(\"malaria_epicurve\")\n    )\n    \n  )\n)\n\nQuando app.R é executado com o código de IU acima (sem nenhum código ativo na parte server de app.R), o layout aparece assim - observe que não haverá um gráfico se não houver servidor para renderizá-lo, mas nossas entradas estão funcionando!\n\n\n\n\n\n\n\n\n\nEsta é uma boa oportunidade para discutir como os widgets funcionam - observe que cada widget está aceitando um inputId, umlabel e uma série de outras opções que são específicas para o tipo de widget. Este inputId é extremamente importante - esses são os IDs usados para passar informações da IU para o servidor. Por esse motivo, eles devem ser exclusivos. Você deve fazer um esforço para nomeá-los de algo sensato e específico para o que estão interagindo em casos de aplicativos maiores.\nVocê deve ler a documentação cuidadosamente para obter detalhes completos sobre o que cada um desses widgets faz. Os widgets passarão tipos específicos de dados para o servidor, dependendo do tipo de widget, e isso precisa ser totalmente compreendido. Por exemplo, selectInput() passará um tipo de caractere para o servidor:\n\nSe selecionarmos Spring para o primeiro widget aqui, ele passará o objeto de caractere \"Spring\" para o servidor.\nSe selecionarmos dois itens no menu suspenso, eles aparecerão como um vetor de caracteres (por exemplo, c(\" Spring \",\" Bolo \")).\n\nOutros widgets irão passar diferentes tipos de objetos para o servidor! Por exemplo:\n\nnumericInput() passará um objeto de tipo numérico para o servidor\ncheckboxInput() passará um objeto de tipo lógico para o servidor (TRUE ouFALSE)\n\nTambém vale a pena notar o vetor nomeado que usamos para os dados de idade aqui. Para muitos widgets, usar um vetor nomeado como as escolhas exibirá os nomes do vetor como as opções de exibição, mas passará o valor selecionado do vetor para o servidor. Ou seja, aqui, alguém pode selecionar “15+” no menu suspenso e a IU passará \"malaria_rdt_15\" para o servidor - que por acaso é o nome da coluna em que estamos interessados!\nExistem muitos widgets que você pode usar para fazer muitas coisas com seu aplicativo. Os widgets também permitem que você carregue arquivos em seu aplicativo e baixe saídas. Existem também algumas extensões shiny excelentes que fornecem acesso a mais widgets do que o básico shiny - o pacote shinyWidgets é um ótimo exemplo disso. Para ver alguns exemplos, você pode ver os seguintes links:\n\ngaleria de widgets shiny de base\nshinyWidgets gallery",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Painéis com Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.pt.html#carregando-dados-em-nosso-aplicativo",
    "href": "new_pages/shiny_basics.pt.html#carregando-dados-em-nosso-aplicativo",
    "title": "43  Painéis com Shiny",
    "section": "43.4 Carregando dados em nosso aplicativo",
    "text": "43.4 Carregando dados em nosso aplicativo\nA próxima etapa no desenvolvimento de nosso aplicativo é colocar o servidor em funcionamento. Para fazer isso, no entanto, precisamos colocar alguns dados em nosso aplicativo e descobrir todos os cálculos que faremos. Um aplicativo shiny não é simples de depurar, já que geralmente não fica claro de onde vêm os erros, então é ideal para fazer com que todo o nosso processamento de dados e código de visualização funcionem antes de começarmos a fazer o próprio servidor.\nPortanto, como queremos fazer um aplicativo que mostra curvas epi que mudam com base na entrada do usuário, devemos pensar sobre o código de que precisaríamos para executá-lo em um script R normal. Precisamos:\n\nCarregue nossos pacotes\nCarregue nossos dados\nTransforme nossos dados\nDesenvolva uma função para visualizar nossos dados com base nas entradas do usuário\n\nEsta lista é bastante direta e não deve ser muito difícil de fazer. Agora é importante pensar sobre quais partes desse processo precisam ser feitas apenas uma vez e quais partes precisam ser executadas em resposta às entradas do usuário. Isso ocorre porque os aplicativos shiny geralmente executam algum código antes de serem executados, o que é executado apenas uma vez. Isso ajudará no desempenho de nosso aplicativo se o máximo de nosso código puder ser movido para esta seção. Para este exemplo, só precisamos carregar nossos dados / pacotes e fazer as transformações básicas uma vez, para que possamos colocar esse código fora do servidor. Isso significa que a única coisa de que precisaremos no servidor é o código para visualizar nossos dados. Vamos desenvolver todos esses componentes em um script primeiro. No entanto, como estamos visualizando nossos dados com uma função, também podemos colocar o código para a função fora do servidor para que nossa função esteja no ambiente quando o aplicativo for executado!\nPrimeiro, vamos carregar nossos dados. Como estamos trabalhando com um novo projeto e queremos torná-lo limpo, podemos criar um novo diretório chamado data e adicionar nossos dados de malária nele. Podemos executar o código abaixo em um script de teste que excluiremos ao limpar a estrutura de nosso aplicativo.\n\npacman::p_load(\"tidyverse\", \"lubridate\")\n\n# dados lidos\nmalaria_data &lt;- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\")) %&gt;% \n  as_tibble()\n\nprint(malaria_data)\n\n# A tibble: 3,038 × 10\n   location_name data_date  submitted_date Province District `malaria_rdt_0-4`\n   &lt;chr&gt;         &lt;date&gt;     &lt;date&gt;         &lt;chr&gt;    &lt;chr&gt;                &lt;int&gt;\n 1 Facility 1    2020-08-11 2020-08-12     North    Spring                  11\n 2 Facility 2    2020-08-11 2020-08-12     North    Bolo                    11\n 3 Facility 3    2020-08-11 2020-08-12     North    Dingo                    8\n 4 Facility 4    2020-08-11 2020-08-12     North    Bolo                    16\n 5 Facility 5    2020-08-11 2020-08-12     North    Bolo                     9\n 6 Facility 6    2020-08-11 2020-08-12     North    Dingo                    3\n 7 Facility 6    2020-08-10 2020-08-12     North    Dingo                    4\n 8 Facility 5    2020-08-10 2020-08-12     North    Bolo                    15\n 9 Facility 5    2020-08-09 2020-08-12     North    Bolo                    11\n10 Facility 5    2020-08-08 2020-08-12     North    Bolo                    19\n# ℹ 3,028 more rows\n# ℹ 4 more variables: `malaria_rdt_5-14` &lt;int&gt;, malaria_rdt_15 &lt;int&gt;,\n#   malaria_tot &lt;int&gt;, newid &lt;int&gt;\n\n\nSerá mais fácil trabalhar com esses dados se usarmos padrões de dados organizados, então também devemos transformar em um formato de dados mais longo, em que a faixa etária é uma coluna e os casos é outra coluna. Podemos fazer isso facilmente usando o que aprendemos na página Pivoteando dados.\n\nmalaria_data &lt;- malaria_data%&gt;%\n  select (-newid)%&gt;%\n  pivot_longer(cols = starts_with(\"malaria_\"), names_to = \"age_group\", values_to = \"cases_reported\")\n\nprint(malaria_data)\n\n# A tibble: 12,152 × 7\n   location_name data_date  submitted_date Province District age_group       \n   &lt;chr&gt;         &lt;date&gt;     &lt;date&gt;         &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;           \n 1 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_rdt_0-4 \n 2 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_rdt_5-14\n 3 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_rdt_15  \n 4 Facility 1    2020-08-11 2020-08-12     North    Spring   malaria_tot     \n 5 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_rdt_0-4 \n 6 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_rdt_5-14\n 7 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_rdt_15  \n 8 Facility 2    2020-08-11 2020-08-12     North    Bolo     malaria_tot     \n 9 Facility 3    2020-08-11 2020-08-12     North    Dingo    malaria_rdt_0-4 \n10 Facility 3    2020-08-11 2020-08-12     North    Dingo    malaria_rdt_5-14\n# ℹ 12,142 more rows\n# ℹ 1 more variable: cases_reported &lt;int&gt;\n\n\nE com isso terminamos de preparar nossos dados! Isso cruza os itens 1, 2 e 3 de nossa lista de coisas a desenvolver para nosso “script de teste R”. A última e mais difícil tarefa será construir uma função para produzir uma epicurva baseada em parâmetros definidos pelo usuário. Como mencionado anteriormente, é altamente recomendado que qualquer pessoa que esteja aprendendo algo shiny primeiro dê uma olhada na seção sobre programação funcional (Escrevendo funções) para entender como isso funciona!\nAo definir nossa função, pode ser difícil pensar sobre quais parâmetros queremos incluir. Para programação funcional com shiny, cada parâmetro relevante geralmente terá um widget associado a ele, então pensar sobre isso geralmente é bem fácil! Por exemplo, em nosso aplicativo atual, queremos ser capazes de filtrar por distrito e ter um widget para isso, para que possamos adicionar um parâmetro de distrito para refletir isso. Nós não temos nenhuma funcionalidade de aplicativo para filtrar por instalação (por enquanto), portanto, não precisamos adicionar isso como um parâmetro. Vamos começar criando uma função com três parâmetros:\n\nO conjunto de dados principal\nO distrito de escolha\nA faixa etária de escolha\n\n\nplot_epicurve &lt;- function(data, district = \"All\", agegroup = \"malaria_tot\") {\n  \n  if (!(\"All\" %in% district)) {\n    data &lt;- data %&gt;%\n      filter(District %in% district)\n    \n    plot_title_district &lt;- stringr::str_glue(\"{paste0(district, collapse = ', ')} districts\")\n    \n  } else {\n    \n    plot_title_district &lt;- \"all districts\"\n    \n  }\n  \n  # se não houver dados restantes, retorna NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  data &lt;- data %&gt;%\n    filter(age_group == agegroup)\n  \n  \n  # se não houver dados restantes, retorna NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  if (agegroup == \"malaria_tot\") {\n      agegroup_title &lt;- \"All ages\"\n  } else {\n    agegroup_title &lt;- stringr::str_glue(\"{str_remove(agegroup, 'malaria_rdt')} years\")\n  }\n  \n  \n  ggplot(data, aes(x = data_date, y = cases_reported)) +\n    geom_col(width = 1, fill = \"darkred\") +\n    theme_minimal () +\n    labs(\n      x = \"date\",\n      y = \"number of cases\",\n      title = stringr::str_glue(\"Malaria cases - {plot_title_district}\"),\n      subtitle = agegroup_title\n    )\n  \n  \n  \n}\n\nNão entraremos em muitos detalhes sobre essa função, pois é relativamente simples em como funciona. Uma coisa a se notar, entretanto, é que tratamos os erros retornando NULL quando, de outra forma, resultaria em um erro. Isso ocorre porque quando um servidor shiny produz um objeto NULL em vez de um objeto de gráfico, nada será mostrado na interface do usuário! Isso é importante, pois, caso contrário, os erros geralmente farão com que seu aplicativo pare de funcionar.\nOutra coisa a se notar é o uso do operador %in% ao avaliar a entrada district. Como mencionado acima, isso pode chegar como um vetor de caracteres com vários valores, então usar %in% é mais flexível do que dizer, ==.\nVamos testar nossa função!\n\nplot_epicurve(malaria_data, district = \"Bolo\", agegroup = \"malaria_rdt_0-4\")\n\n\n\n\n\n\n\n\nCom nossa função funcionando, agora temos que entender como tudo isso vai se encaixar em nosso aplicativo shiny. Mencionamos o conceito de código de inicialização antes, mas vamos ver como podemos realmente incorporar isso à estrutura de nosso aplicativo. Podemos fazer isso de duas maneiras!\n\nColoque este código em seu arquivo app.R no início do script (acima da IU), ou\n\nCrie um novo arquivo no diretório do seu aplicativo chamado global.R e coloque o código de inicialização neste arquivo.\n\nÉ importante notar neste ponto que geralmente é mais fácil, especialmente com aplicativos maiores, usar a segunda estrutura de arquivo, pois permite separar sua estrutura de arquivo de uma forma simples. Vamos desenvolver totalmente um script global.R agora. Pode ser assim:\n\n# global.R script\n\npacman::p_load(\"tidyverse\", \"lubridate\", \"shiny\")\n\n# dados lidos\nmalaria_data &lt;- rio::import(here::here(\"data\", \"malaria_facility_count_data.rds\")) %&gt;% \n  as_tibble()\n\n# limpe os dados e gire por mais tempo\nmalaria_data &lt;- malaria_data%&gt;%\n  select (-newid)%&gt;%\n  pivot_longer(cols = starts_with(\"malaria_\"), names_to = \"age_group\", values_to = \"cases_reported\")\n\n\n# define a função de criação de um gráfico\nplot_epicurve &lt;- function(data, district = \"All\", agegroup = \"malaria_tot\") {\n  \n  # criar título do enredo\n  if (!(\"All\" %in% district)) {            \n    data &lt;- data %&gt;%\n      filter(District %in% district)\n    \n    plot_title_district &lt;- stringr::str_glue(\"{paste0(district, collapse = ', ')} districts\")\n    \n  } else {\n    \n    plot_title_district &lt;- \"all districts\"\n    \n  }\n  \n  # se não houver dados restantes, retorna NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  # filtro para faixa etária\n  data &lt;- data %&gt;%\n    filter(age_group == agegroup)\n  \n  \n  # se não houver dados restantes, retorna NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  if (agegroup == \"malaria_tot\") {\n      agegroup_title &lt;- \"All ages\"\n  } else {\n    agegroup_title &lt;- stringr::str_glue(\"{str_remove(agegroup, 'malaria_rdt')} years\")\n  }\n  \n  \n  ggplot(data, aes(x = data_date, y = cases_reported)) +\n    geom_col(width = 1, fill = \"darkred\") +\n    theme_minimal () +\n    labs(\n      x = \"date\",\n      y = \"number of cases\",\n      title = stringr::str_glue(\"Malaria cases - {plot_title_district}\"),\n      subtitle = agegroup_title\n    )\n  \n  \n  \n}\n\nFácil! Um grande recurso do shiny é que ele entenderá para que servem os arquivos chamados app.R, server.R, ui.R e global.R, portanto, não há necessidade de conectá-los entre si por meio de qualquer código. Portanto, apenas por ter esse código em global.R no diretório, ele será executado antes de iniciarmos nosso aplicativo!\nDevemos também observar que melhoraria a organização de nosso aplicativo se movêssemos a função de plotagem para seu próprio arquivo - isso será especialmente útil à medida que os aplicativos se tornam maiores. Para fazer isso, poderíamos criar outro diretório chamado funcs e colocar essa função em um arquivo chamado plot_epicurve.R. Poderíamos então ler essa função por meio do seguinte comando em global.R\n\nsource(here(\"funcs\", \"plot_epicurve.R\"), local = TRUE)\n\nObserve que você deve sempre especificar local = TRUE em aplicativos shiny, uma vez que afetará o fornecimento quando / se o aplicativo for publicado em um servidor.",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Painéis com Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.pt.html#desenvolvendo-um-servidor-de-aplicativos",
    "href": "new_pages/shiny_basics.pt.html#desenvolvendo-um-servidor-de-aplicativos",
    "title": "43  Painéis com Shiny",
    "section": "43.5 Desenvolvendo um servidor de aplicativos",
    "text": "43.5 Desenvolvendo um servidor de aplicativos\nAgora que temos a maior parte do nosso código, só precisamos desenvolver nosso servidor. Esta é a parte final de nosso aplicativo e provavelmente a mais difícil de entender. O servidor é uma grande função R, mas é útil pensar nele como uma série de funções menores ou tarefas que o aplicativo pode executar. É importante entender que essas funções não são executadas em uma ordem linear. Há uma ordem para eles, mas não é totalmente necessário entender quando se começa com o shiny. Em um nível muito básico, essas tarefas ou funções serão ativadas quando houver uma mudança nas entradas do usuário que as afete, a menos que o desenvolvedor as tenha configurado para que se comportem de maneira diferente. Novamente, tudo isso é bastante abstrato, mas vamos primeiro examinar os três tipos básicos de objetos shiny\n\nFontes reativas - este é outro termo para entradas do usuário. O servidor shiny tem acesso às saídas da IU por meio dos widgets que programamos. Cada vez que os valores para estes são alterados, isso é passado para o servidor.\nCondutores reativos - são objetos que existem apenas dentro do servidor shiny. Na verdade, não precisamos deles para aplicativos simples, mas eles produzem objetos que só podem ser vistos dentro do servidor e usados em outras operações. Eles geralmente dependem de fontes reativas.\nResultados (Endpoints) - são saídas que são passadas do servidor para a IU. Em nosso exemplo, essa seria a curva epi que estamos produzindo.\n\nCom isso em mente vamos construir nosso servidor passo a passo. Mostraremos nosso código de IU novamente aqui apenas para referência:\n\nui &lt;- fluidPage(\n\n  titlePanel (\"Aplicativo de visualização de instalação para malária\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # seletor para distrito\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Selecionar distrito\",\n              escolhas = c(\n                   \"Tudo\",\n                   \"Primavera\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selecionado = \"Tudo\",\n              múltiplo = TRUE\n         ),\n         # seletor para faixa etária\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Selecionar faixa etária\",\n              escolhas = c(\n                   \"Todas as idades\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ),\n              selecionado = \"Tudo\",\n              múltiplo = FALSE\n         )\n\n    ),\n\n    mainPanel(\n      # epicurva vai aqui\n      plotOutput(\"malaria_epicurve\")\n    )\n    \n  )\n)\n\nA partir desta IU de código, temos:\n\nDuas entradas:\n\nSeletor de distrito (com um inputId de select_district)\nSeletor de faixa etária (com um inputId de select_agegroup)\n\nUma saída:\n\nA epicurva (com outputId de malaria_epicurve)\n\n\nConforme declarado anteriormente, esses nomes exclusivos que atribuímos às nossas entradas e saídas são cruciais. Eles devem ser exclusivos e são usados para passar informações entre a interface do usuário e o servidor. Em nosso servidor, acessamos nossas entradas através da sintaxe input $ inputID e saídas e passadas para a interface do usuário através da sintaxeoutput $ output_name Vamos dar uma olhada em um exemplo, porque novamente é difícil entender de outra forma!\n\nserver &lt;- function(input, output, session) {\n  \n  output$malaria_epicurve &lt;- renderPlot(\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  )\n  \n}\n\nO servidor para um aplicativo simples como esse é bastante direto! Você notará que o servidor é uma função com três parâmetros - input, output e session - isso não é tão importante entender agora, mas é importante seguir esta configuração! Em nosso servidor, temos apenas uma tarefa - isso renderiza um gráfico com base em nossa função que criamos anteriormente e nas entradas do servidor. Observe como os nomes dos objetos de entrada e saída correspondem exatamente aos da interface do usuário.\nPara entender os fundamentos de como o servidor reage às entradas do usuário, você deve observar que a saída saberá (por meio do pacote subjacente) quando as entradas mudam e execute novamente esta função para criar um gráfico sempre que mudam. Observe que também usamos a função renderPlot() aqui - esta é uma de uma família de funções específicas de classe que passam esses objetos para uma saída da interface do usuário. Existem várias funções que se comportam de maneira semelhante, mas você precisa garantir que a função usada corresponda à classe de objeto que você está passando para a interface do usuário! Por exemplo:\n\nrenderText() - envia texto para a interface do usuário\nrenderDataTable - envia uma tabela interativa para a interface do usuário.\n\nLembre-se de que eles também precisam corresponder à função de saída usada na ui - então renderPlot() é pareado com plotOutput(), e renderText() é pareado com textOutput().\nEntão, finalmente criamos um aplicativo funcional! Podemos executá-lo pressionando o botão Executar aplicativo no canto superior direito da janela do script no Rstudio. Você deve observar que pode optar por executar seu aplicativo em seu navegador padrão (em vez de Rstudio), que refletirá com mais precisão a aparência do aplicativo para outros usuários.\n\n\n\n\n\n\n\n\n\nÉ divertido notar que no console R, o aplicativo está “ouvindo”! É a tal da reatividade!\n\n\n\n\n\n\n\n\n\n&lt;! – A FAZER: ADICIONE ALGO AO BAIXAR UM ARQUIVO ZIP DO APLICATIVO? –&gt;",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Painéis com Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.pt.html#adicionando-mais-funcionalidades",
    "href": "new_pages/shiny_basics.pt.html#adicionando-mais-funcionalidades",
    "title": "43  Painéis com Shiny",
    "section": "43.6 Adicionando mais funcionalidades",
    "text": "43.6 Adicionando mais funcionalidades\nNeste ponto, finalmente temos um aplicativo em execução, mas temos muito poucas funcionalidades. Até agora só vimos a “ponta do iceberg” do que shiny pode fazer, então há muito mais para aprender! Vamos continuar a construir nosso aplicativo existente, adicionando alguns recursos extras. Algumas coisas que podem ser interessantes de adicionar são:\n\nAlgum texto explicativo\nUm botão de download para nosso gráfico - isso forneceria ao usuário uma versão de alta qualidade da imagem que está gerando no aplicativo\nUm seletor para instalações específicas\nOutra página do painel - isso pode mostrar uma tabela de nossos dados.\n\nIsso é muito a acrescentar, mas podemos usá-lo para aprender sobre um monte de recursos shiny diferentes no caminho. Há muito o que aprender sobre shiny (ele pode ficar muito avançado, mas esperamos que, assim que os usuários tiverem uma ideia melhor de como usá-lo, eles possam se sentir mais confortáveis usando fontes externas de aprendizagem também).\n\nAdicionando texto estático\nVamos primeiro discutir a adição de texto estático ao nosso aplicativo shiny. Adicionar texto ao nosso aplicativo é extremamente fácil, uma vez que você tenha um domínio básico sobre ele. Visto que o texto estático não muda no aplicativo shiny (se você gostaria que ele mudasse, você pode usar funções de renderização de texto no servidor!), todo o texto estático shiny é geralmente adicionado na interface do usuário do aplicativo. Não examinaremos isso em grandes detalhes, mas você pode adicionar vários elementos diferentes à sua interface do usuário (e até mesmo alguns personalizados) fazendo a interface de R com HTML e css.\nHTML e css são linguagens que estão explicitamente envolvidas no design da interface do usuário. Não precisamos entender isso muito bem, mas HTML cria objetos na IU (como uma caixa de texto ou uma tabela) e css geralmente é usado para alterar o estilo e a estética desses objetos. O Shiny tem acesso a uma grande variedade de HTML tags - presentes para objetos que se comportam de uma maneira específica, como cabeçalhos, parágrafos de texto, quebras de linha, tabelas, etc. Podemos usar alguns desses exemplos como este:\n\nh1() - esta é uma tag de header, que tornará o texto fechado automaticamente maior, e mudará os padrões conforme eles pertencem à face da fonte, cor etc. (dependendo do tema geral do seu aplicativo). Você pode acessar_menos e menor_subtítulo com h2() até h6() também. O uso se parece com:\n\nh1(\" meu cabeçalho - seção 1\")\n\np() - esta é uma tag de parágrafo, que tornará o texto fechado semelhante ao texto em um corpo de texto. Este texto será quebrado automaticamente e terá um tamanho relativamente pequeno (os rodapés podem ser menores, por exemplo). Pense nisso como o corpo do texto de um documento do Word. O uso se parece com:\n\np(\" Este é um corpo de texto maior onde estou explicando a função do meu aplicativo\")\n\ntags$b() e tags$i() - são usadas para criar tags $b() em negrito e tags$i() em itálico com qualquer texto que esteja incluído!\ntags$ul(), tags$ol() e tags$li() - são tags usadas na criação de * listas *. Todos eles são usados na sintaxe abaixo e permitem ao usuário criar uma lista ordenada (tags$ol(); ou seja, numerada) ou lista não ordenada (tags$ul(), ou seja, marcadores). tags$li() é usado para denotar itens na lista, independentemente do tipo de lista usado. Por exemplo:\n\n\ntags$ol(\n  \n  tags$li(\"Item 1\"),\n  \n  tags$li(\"Item 2\"),\n  \n  tags$li(\"Item 3\")\n  \n)\n\n\nbr() e hr() - essas tags criam quebras de linha e linhas horizontais (com uma quebra de linha) respectivamente. Use-os para separar as seções de seu aplicativo e texto! Não há necessidade de passar nenhum item para essas tags (os parênteses podem permanecer vazios).\ndiv() - esta é uma tag genérica que pode conter qualquer coisa, e pode ser nomeada qualquer coisa. Depois de progredir com o design da interface do usuário, você pode usá-los para compartimentar sua interface do usuário, fornecer estilos específicos a seções específicas e criar interações entre o servidor e os elementos da interface do usuário. Não entraremos em detalhes, mas vale a pena estar ciente deles!\n\nNote que cada um desses objetos pode ser acessado através de tags$... ou para alguns, apenas a função. Estes são efetivamente sinônimos, mas pode ajudar usar o estilo tags$... se você preferir ser mais explícito e não sobrescrever as funções acidentalmente. Esta também não é, de forma alguma, uma lista exaustiva de tags disponíveis. Há uma lista completa de todas as tags disponíveis em shiny aqui e ainda mais podem ser usadas inserindo HTML diretamente em sua interface do usuário!\nSe você se sentir confiante, também pode adicionar quaisquer elementos de estilo css às suas tags HTML com o argumento style em qualquer um deles. Não entraremos em detalhes sobre como isso funciona, mas uma dica para testar mudanças estéticas em uma IU é usar o modo inspetor HTML em cromo (do seu aplicativo shiny que você está executando no navegador) e editar o estilo dos objetos você mesmo!\nVamos adicionar algum texto ao nosso aplicativo\n\nui &lt;- fluidPage(\n\n  titlePanel (\"Aplicativo de visualização de instalação para malária\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         h4 (\"Opções\"),\n         # seletor para distrito\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Selecionar distrito\",\n              escolhas = c(\n                   \"Tudo\",\n                   \"Primavera\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selecionado = \"Tudo\",\n              múltiplo = TRUE\n         ),\n         # seletor para faixa etária\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Selecionar faixa etária\",\n              escolhas = c(\n                   \"Todas as idades\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ),\n              selecionado = \"Tudo\",\n              múltiplo = FALSE\n         ),\n    ),\n\n    mainPanel(\n      # epicurva vai aqui\n      plotOutput(\"malaria_epicurve\"),\n      br(),\n      hr(),\n      p(\"Bem-vindo ao aplicativo de visualização de instalações para malária! Para usar este aplicativo, manipule os widgets ao lado para alterar a curva epidêmica de acordo com suas preferências! Para baixar uma imagem de alta qualidade do plot que você criou, você também pode baixá-la com o botão de download. Para ver os dados brutos, use a guia de dados brutos para uma forma interativa da tabela. O dicionário de dados é o seguinte:\"),\n    tags$ul(\n      tags$li(tags$b(\"location_name\"), \"- a instalação onde os dados foram coletados\"),\n      tags$li(tags$b(\"data_date\"), \"- a data em que os dados foram coletados\"),\n      tags$li(tags$b(\"submitted_daate\"), \"- a data em que os dados foram enviados\"),\n      tags$li(tags$b(\"Província\"), \"- a província onde os dados foram coletados (todo 'Norte' para este conjunto de dados)\"),\n      tags$li(tags$b(\"Distrito\"), \"- o distrito onde os dados foram coletados\"),\n      tags$li(tags$b(\"age_group\"), \"- a faixa etária para a qual os dados foram coletados (0-5, 5-14, 15+ e todas as idades)\"),\n      tags$li(tags$b(\"cases_reported\"), \"- o número de casos relatados para o estabelecimento / faixa etária na data fornecida\")\n    )\n    \n  )\n)\n)\n\n\n\n\n\n\n\n\n\n\n\n\nAdicionando um link\nPara adicionar um link para um site, use tags$a() com o link e exiba o texto conforme mostrado abaixo. Para ter um parágrafo independente, coloque-o dentro de p(). Para ter apenas algumas palavras de uma frase ligada, divida a frase em partes e use tags$a() para a parte com hiperlink. Para garantir que o link seja aberto em uma nova janela do navegador, adicione target =\" _blank\" como um argumento.\n\ntags$a(href = \"www.epiRhandbook.com\", \"Visite nosso site!\")\n\n\n\nAdicionando um botão de download\nVamos passar para o segundo dos três recursos. Um botão de download é algo bastante comum para adicionar a um aplicativo e é bastante fácil de fazer. Precisamos adicionar outro widget à nossa interface do usuário e precisamos adicionar outra saída ao nosso servidor para anexar a ele. Também podemos introduzir condutores reativos neste exemplo!\nVamos atualizar nossa interface do usuário primeiro - isso é fácil, pois o shiny vem com um widget chamado downloadButton() - vamos dar a ele um inputId e um rótulo.\n\nui &lt;- fluidPage(\n\n  titlePanel (\"Aplicativo de visualização de instalação para malária\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # seletor para distrito\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Selecionar distrito\",\n              escolhas = c(\n                   \"Tudo\",\n                   \"Primavera\",\n                   \"Bolo\",\n                   \"Dingo\",\n                   \"Barnard\"\n              ),\n              selecionado = \"Tudo\",\n              múltiplo = FALSE\n         ),\n         # seletor para faixa etária\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Selecionar faixa etária\",\n              escolhas = c(\n                   \"Todas as idades\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ),\n              selecionado = \"Tudo\",\n              múltiplo = FALSE\n         ),\n         # linha horizontal\n         hr(),\n         downloadButton(\n           outputId = \"download_epicurve\",\n           label = \"Baixar plot\"\n         )\n\n    ),\n\n    mainPanel(\n      # epicurva vai aqui\n      plotOutput(\"malaria_epicurve\"),\n      br(),\n      hr(),\n      p(\"Bem-vindo ao aplicativo de visualização de instalações para malária! Para usar este aplicativo, manipule os widgets ao lado para alterar a curva epidêmica de acordo com suas preferências! Para baixar uma imagem de alta qualidade do plot que você criou, você também pode baixá-la com o botão de download. Para ver os dados brutos, use a guia de dados brutos para uma forma interativa da tabela. O dicionário de dados é o seguinte:\"),\n      tags$ul(\n        tags$li(tags$b(\"location_name\"), \"- a instalação onde os dados foram coletados\"),\n        tags$li(tags$b(\"data_date\"), \"- a data em que os dados foram coletados\"),\n        tags$li(tags$b(\"submitted_daate\"), \"- a data em que os dados foram enviados\"),\n        tags$li(tags$b(\"Província\"), \"- a província onde os dados foram coletados (todo 'Norte' para este conjunto de dados)\"),\n        tags$li(tags$b(\"Distrito\"), \"- o distrito onde os dados foram coletados\"),\n        tags$li(tags$b(\"age_group\"), \"- a faixa etária para a qual os dados foram coletados (0-5, 5-14, 15+ e todas as idades)\"),\n        tags$li(tags$b(\"cases_reported\"), \"- o número de casos relatados para o estabelecimento / faixa etária na data fornecida\")\n      )\n      \n    )\n    \n  )\n)\n\nObserve que também adicionamos uma tag hr() - isso adiciona uma linha horizontal separando nossos widgets de controle de nossos widgets de download. Esta é outra das tags HTML que discutimos anteriormente.\nAgora que temos nossa interface do usuário pronta, precisamos adicionar o componente do servidor. Os downloads são feitos no servidor com a função downloadHandler(). Semelhante ao nosso gráfico, precisamos anexá-lo a uma saída que tenha o mesmo inputId do botão de download. Esta função leva dois argumentos - nome do arquivo e conteúdo - ambos são funções. Como você pode adivinhar, filename é usado para especificar o nome do arquivo baixado, e content é usado para especificar o que deve ser baixado. content contém uma função que você usaria para salvar dados localmente - então se você estivesse baixando um arquivo csv você poderia usar rio :: export(). Já que estamos baixando um gráfico, usaremos ggplot2 :: ggsave(). Vamos ver como o programamos (não o adicionaremos ao servidor ainda).\n\nserver &lt;- function(input, output, session) {\n  \n  output$malaria_epicurve &lt;- renderPlot(\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  )\n  \n  output $ download_epicurve &lt;- downloadHandler (\n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n}\n\nObserve que a função content sempre recebe um argumento file, que colocamos onde o nome do arquivo de saída é especificado. Você também pode notar que estamos repetindo código aqui - estamos usando nossa função plot_epicurve() duas vezes neste servidor, uma para o download e uma vez para a imagem exibida no aplicativo. Embora isso não afete maciçamente o desempenho, isso significa que o código para gerar este gráfico terá que ser executado quando o usuário alterar os widgets especificando o distrito e a faixa etária, e novamente quando você quiser fazer o download do gráfico. Em aplicativos maiores, decisões subótimas como esta irão desacelerar as coisas cada vez mais, então é bom aprender como tornar nosso aplicativo mais eficiente neste sentido. O que faria mais sentido é se tivéssemos uma maneira de executar o código epicurva quando os distritos / grupos de idade são alterados, e permitir que isso seja usado pelas funções renderPlot() e downloadHandler(). É aqui que entram os condutores reativos!\nCondutores reativos são objetos que são criados no servidor shiny de uma forma reativa, mas não são emitidos - eles podem apenas ser usados por outras partes do servidor. Existem vários tipos diferentes de condutores reativos, mas examinaremos os dois básicos.\n1.reactive()- este é o condutor reativo mais básico - ele reagirá sempre que qualquer entrada usada dentro dele mudar (então nossos widgets de distrito / faixa etária)\n2. eventReactive() - este condutor reativo funciona da mesma forma que reactive(), exceto que o usuário pode especificar quais entradas fazem com que ele seja executado novamente. Isso é útil se o seu condutor reativo demorar muito para processar, mas isso será explicado mais tarde.\nVejamos os dois exemplos:\n\nmalaria_plot_r &lt;- reactive({\n  \n  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  \n})\n\n\n# só funciona quando o seletor de distrito muda!\nmalaria_plot_er &lt;- eventReactive(input$select_district, {\n  \n  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  \n})\n\nQuando usamos a configuração eventReactive(), podemos especificar quais entradas fazem com que esse pedaço de código seja executado - isso não é muito útil para nós no momento, então podemos deixar por enquanto. Observe que você pode incluir várias entradas com c()\nVamos ver como podemos integrar isso em nosso código de servidor:\n\nserver &lt;- function(input, output, session) {\n  \n  malaria_plot &lt;- reactive({\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)\n  })\n  \n  \n  \n  output$malaria_epicurve &lt;- renderPlot(\n    malaria_plot()\n  )\n  \n  output $ download_epicurve &lt;- downloadHandler (\n    \n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             malaria_plot(),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n}\n\nVocê pode ver que estamos apenas chamando a saída de nosso reativo, que definimos em ambas as funções de download e de renderização de gráficos. Uma coisa a notar, e que muitas vezes confunde as pessoas, é que você precisa usar os resultados dos reativos como se fossem funções - então você deve adicionar parênteses vazios no final deles (ou seja, malaria_plot() está correto, e malaria_plot não está). Agora que adicionamos essa solução, nosso aplicativo está um pouco mais arrumado, mais rápido e mais fácil de alterar, pois todo o nosso código que executa a função da epicurva está em um só lugar.\n\n\n\n\n\n\n\n\n\n\n\nAdicionando um seletor de instalação\nVamos passar para o nosso próximo recurso - um seletor para instalações específicas. Implementaremos outro parâmetro em nossa função para que possamos informar isso como um argumento de nosso código. Vamos ver como fazer isso primeiro - ele apenas opera com os mesmos princípios que os outros parâmetros que já configuramos. Vamos atualizar e testar nossa função.\n\nplot_epicurve &lt;- function(data, district = \"All\", agegroup = \"malaria_tot\", facility = \"All\") {\n  \n  if (!(\"All\" %in% district)) {\n    data &lt;- data %&gt;%\n      filter(District %in% district)\n    \n    plot_title_district &lt;- stringr::str_glue(\"{paste0(district, collapse = ', ')} districts\")\n    \n  } else {\n    \n    plot_title_district &lt;- \"all districts\"\n    \n  }\n  \n  # se não houver dados restantes, retorna NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  data &lt;- data %&gt;%\n    filter(age_group == agegroup)\n  \n  \n  # se não houver dados restantes, retorna NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n  \n  if (agegroup == \"malaria_tot\") {\n      agegroup_title &lt;- \"All ages\"\n  } else {\n    agegroup_title &lt;- stringr::str_glue(\"{str_remove(agegroup, 'malaria_rdt')} years\")\n  }\n  \n    if(! (\"All\" %in% facility)) {\n    data &lt;- data %&gt;%\n      filter(location_name == facility)\n    \n    plot_title_facility &lt;- facility\n    \n  } else {\n    \n    plot_title_facility &lt;- \"todas as instalações\"\n    \n  }\n  \n  # se não houver dados restantes, retorna NULL\n  if (nrow(data) == 0) {\n    \n    return(NULL)\n  }\n\n  \n  \n  ggplot(data, aes(x = data_date, y = cases_reported)) +\n    geom_col(width = 1, fill = \"darkred\") +\n    theme_minimal () +\n    labs(\n      x = \"date\",\n      y = \"number of cases\",\n      title = stringr::str_glue(\"Malaria cases - {plot_title_district}; {plot_title_facility}\"),\n      subtitle = agegroup_title\n    )\n  \n  \n  \n}\n\nVamos testar:\n\n\n\n\n\n\n\n\n\nCom todas as instalações em nossos dados, não está muito claro quais instalações correspondem a quais distritos - e o usuário final também não saberá. Isso pode tornar o uso do aplicativo pouco intuitivo. Por esse motivo, devemos fazer com que as opções de instalação na IU mudem dinamicamente à medida que o usuário muda o distrito - para que uma filtre a outra! Uma vez que temos tantas variáveis que estamos usando nas opções, também podemos querer gerar algumas de nossas opções para a interface do usuário em nosso arquivo global.R _ a partir dos dados_. Por exemplo, podemos adicionar este fragmento de código a global.R depois de lermos nossos dados em:\n\n\n`summarise()` has grouped output by 'location_name'. You can override using the\n`.groups` argument.\n\n\nVamos dar uma olhada neles:\n\nall_districts\n\n[1] \"All\"     \"Spring\"  \"Bolo\"    \"Dingo\"   \"Barnard\"\n\n\n\ninstallation_list\n\n# A tibble: 65 × 2\n   location_name District\n   &lt;chr&gt;         &lt;chr&gt;   \n 1 Facility 1    Spring  \n 2 Facility 10   Bolo    \n 3 Facility 11   Spring  \n 4 Facility 12   Dingo   \n 5 Facility 13   Bolo    \n 6 Facility 14   Dingo   \n 7 Facility 15   Barnard \n 8 Facility 16   Barnard \n 9 Facility 17   Barnard \n10 Facility 18   Bolo    \n# ℹ 55 more rows\n\n\nPodemos passar essas novas variáveis para a interface do usuário sem nenhum problema, pois elas são visíveis globalmente pelo servidor e pela interface do usuário! Vamos atualizar nossa IU:\n\nui &lt;- fluidPage(\n\n  titlePanel (\"Aplicativo de visualização de instalação para malária\"),\n\n  sidebarLayout(\n\n    sidebarPanel(\n         # seletor para distrito\n         selectInput(\n              inputId = \"select_district\",\n              label = \"Selecionar distrito\",\n              choices = all_districts,\n              selecionado = \"Tudo\",\n              múltiplo = FALSE\n         ),\n         # seletor para faixa etária\n         selectInput(\n              inputId = \"select_agegroup\",\n              label = \"Selecionar faixa etária\",\n              escolhas = c(\n                   \"Todas as idades\" = \"malaria_tot\",\n                   \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                   \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                   \"15+ yrs\" = \"malaria_rdt_15\"\n              ),\n              selecionado = \"Tudo\",\n              múltiplo = FALSE\n         ),\n         # seletor para instalação\n         selectInput(\n           inputId = \"select_facility\",\n           label = \"Selecionar Instalação\",\n           choices = c(\"All\", facility_list$location_name),\n           selecionado = \"All\"\n         ),\n         \n         # linha horizontal\n         hr(),\n         downloadButton(\n           outputId = \"download_epicurve\",\n           label = \"Baixar plot\"\n         )\n\n    ),\n\n    mainPanel(\n      # epicurva vai aqui\n      plotOutput(\"malaria_epicurve\"),\n      br(),\n      hr(),\n      p(\"Bem-vindo ao aplicativo de visualização de instalações para malária! Para usar este aplicativo, manipule os widgets ao lado para alterar a curva epidêmica de acordo com suas preferências! Para baixar uma imagem de alta qualidade do gráfico que você criou, você também pode baixá-la com o botão de download. Para ver os dados brutos, use a guia de dados brutos para uma forma interativa da tabela. O dicionário de dados é o seguinte:\"),\n      tags$ul(\n        tags$li(tags$b(\"location_name\"), \"- a instalação onde os dados foram coletados\"),\n        tags$li(tags$b(\"data_date\"), \"- a data em que os dados foram coletados\"),\n        tags$li(tags$b(\"submitted_daate\"), \"- a data em que os dados foram enviados\"),\n        tags$li(tags$b(\"Província\"), \"- a província onde os dados foram coletados (todo 'Norte' para este conjunto de dados)\"),\n        tags$li(tags$b(\"Distrito\"), \"- o distrito onde os dados foram coletados\"),\n        tags$li(tags$b(\"age_group\"), \"- a faixa etária para a qual os dados foram coletados (0-5, 5-14, 15+ e todas as idades)\"),\n        tags$li(tags$b(\"cases_reported\"), \"- o número de casos relatados para o estabelecimento / faixa etária na data fornecida\")\n      )\n      \n    )\n    \n  )\n)\n\nObserve como agora estamos informando variáveis para nossas escolhas em vez de codificá-las permanentemente na interface do usuário! Isso pode tornar nosso código mais compacto também! Por último, teremos que atualizar o servidor. Será fácil atualizar nossa função para incorporar nossa nova entrada (só temos que passá-la como um argumento para nosso novo parâmetro), mas devemos lembrar que também queremos que a interface do usuário seja atualizada dinamicamente quando o usuário muda o distrito selecionado. É importante entender aqui que podemos alterar os parâmetros e o comportamento dos widgets enquanto o aplicativo está em execução, mas isso precisa ser feito no servidor. Precisamos entender uma nova forma de saída para o servidor para aprender como fazer isso.\nAs funções que precisamos entender como fazer isso são conhecidas como funções de observador e são semelhantes às funções reativas no modo como se comportam. No entanto, eles têm uma diferença fundamental:\n\nAs funções reativas não afetam diretamente as saídas e produzem objetos que podem ser vistos em outros locais no servidor\nAs funções do observador podem afetar as saídas do servidor, mas fazem isso por meio de efeitos colaterais de outras funções. (Eles também podem fazer outras coisas, mas esta é sua função principal na prática)\n\nSemelhante às funções reativas, existem dois tipos de funções de observador, e eles são divididos pela mesma lógica que divide as funções reativas:\n\nobserve() - esta função é executada sempre que qualquer entrada usada dentro dela muda\nobserveEvent() - esta função é executada quando uma entrada especificada pelo usuário muda\n\nTambém precisamos entender as funções fornecidas de forma shiny que atualizam widgets. Eles são bastante simples de executar - eles primeiro pegam o objeto sessão da função do servidor (isso não precisa ser entendido por enquanto), e então o inputId da função a ser alterado. Em seguida, passamos novas versões de todos os parâmetros que já são obtidos por selectInput() - eles serão atualizados automaticamente no widget.\nVejamos um exemplo isolado de como poderíamos usar isso em nosso servidor. Quando o usuário muda o distrito, queremos filtrar nossa tabela de instalações por distrito e atualizar as opções para refletir apenas aquelas que estão disponíveis naquele distrito (e uma opção para todas as instalações)\n\nobserve({\n  \n  if (input$select_district == \"All\") {\n    new_choices &lt;- facility_list$location_name\n  } else {\n    new_choices &lt;- facility_list%&gt;%\n      filter(District == input$select_district) %&gt;%\n      pull(location_name)\n  }\n  \n  new_choices &lt;- c(\"All\", new_choices)\n  \n  updateSelectInput(session, inputId = \"select_facility\",\n                    choices = new_choices)\n  \n})\n\nE é isso! podemos adicioná-lo ao nosso servidor, e esse comportamento agora funcionará. Esta é a aparência de nosso novo servidor:\n\nserver &lt;- function(input, output, session) {\n  \n  malaria_plot &lt;- reactive({\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)\n  })\n  \n  \n  \n  observe({\n    \n    if (input$select_district == \"All\") {\n      new_choices &lt;- facility_list$location_name\n    } else {\n      new_choices &lt;- facility_list%&gt;%\n        filter(District == input$select_district) %&gt;%\n        pull(location_name)\n    }\n    \n    new_choices &lt;- c(\"All\", new_choices)\n    \n    updateSelectInput(session, inputId = \"select_facility\",\n                      choices = new_choices)\n    \n  })\n  \n  \n  output$malaria_epicurve &lt;- renderPlot(\n    malaria_plot()\n  )\n  \n  output $ download_epicurve &lt;- downloadHandler (\n    \n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             malaria_plot(),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n  \n  \n}\n\n\n\n\n\n\n\n\n\n\n\n\nAdicionando outra guia com uma tabela\nAgora vamos passar para o último componente que queremos adicionar ao nosso aplicativo. Queremos separar nossa interface do usuário em duas guias, uma das quais terá uma tabela interativa onde o usuário pode ver os dados com os quais está fazendo a curva epidêmica. Para fazer isso, podemos usar os elementos da interface do usuário, que já vêm no pacote shiny, que relevantes para a elaboração de guias. Em um nível básico, podemos incluir a maior parte de nosso painel principal nesta estrutura geral:\n\n# ... o resto da interface do usuário\n\nmainPanel(\n  \n  tabsetPanel(\n    type = \"tabs\",\n    tabPanel(\n      \"Curvas epidêmicas\",\n      ...\n    ),\n    tabPanel(\n      \"Dados\",\n      ...\n    )\n  )\n)\n\nVamos aplicar isso à nossa interface do usuário. Também queremos usar o pacote DT aqui - este é um ótimo pacote para fazer tabelas interativas a partir de dados pré-existentes. Podemos ver que está sendo usado para DT :: datatableOutput() neste exemplo.\n\nui &lt;- fluidPage(\n     \n     titlePanel (\"Aplicativo de visualização de instalação para malária\"),\n     \n     sidebarLayout(\n          \n          sidebarPanel(\n               # seletor para distrito\n               selectInput(\n                    inputId = \"select_district\",\n                    label = \"Selecionar distrito\",\n                    choices = all_districts,\n                    selecionado = \"Tudo\",\n                    múltiplo = FALSE\n               ),\n               # seletor para faixa etária\n               selectInput(\n                    inputId = \"select_agegroup\",\n                    label = \"Selecionar faixa etária\",\n                    escolhas = c(\n                         \"Todas as idades\" = \"malaria_tot\",\n                         \"0-4 yrs\" = \"malaria_rdt_0-4\",\n                         \"5-14 yrs\" = \"malaria_rdt_5-14\",\n                         \"15+ yrs\" = \"malaria_rdt_15\"\n                    ),\n                    selecionado = \"Tudo\",\n                    múltiplo = FALSE\n               ),\n               # seletor para instalação\n               selectInput(\n                    inputId = \"select_facility\",\n                    label = \"Selecionar Instalação\",\n                    choices = c(\"All\", facility_list$location_name),\n                    selecionado = \"All\"\n               ),\n               \n               # linha horizontal\n               hr(),\n               downloadButton(\n                    outputId = \"download_epicurve\",\n                    label = \"Baixar plot\"\n               )\n               \n          ),\n          \n          mainPanel(\n               tabsetPanel(\n                    type = \"tabs\",\n                    tabPanel(\n                         \"Curvas epidêmicas\",\n                         plotOutput(\"malaria_epicurve\")\n                    ),\n                    tabPanel(\n                         \"Dados\",\n                         DT::dataTableOutput(\"raw_data\")\n                    )\n               ),\n               br(),\n               hr(),\n               p(\"Bem-vindo ao aplicativo de visualização de instalações para malária! Para usar este aplicativo, manipule os widgets ao lado para alterar a curva epidêmica de acordo com suas preferências! Para baixar uma imagem de alta qualidade do gráfico que você criou, você também pode baixá-la com o botão de download. Para ver os dados brutos, use a guia de dados brutos para uma forma interativa da tabela. O dicionário de dados é o seguinte:\"),\n               tags$ul(\n                    tags$li(tags$b(\"location_name\"), \"- a instalação onde os dados foram coletados\"),\n                    tags$li(tags$b(\"data_date\"), \"- a data em que os dados foram coletados\"),\n                    tags$li(tags$b(\"submitted_daate\"), \"- a data em que os dados foram enviados\"),\n                    tags$li(tags$b(\"Província\"), \"- a província onde os dados foram coletados (todo 'Norte' para este conjunto de dados)\"),\n                    tags$li(tags$b(\"Distrito\"), \"- o distrito onde os dados foram coletados\"),\n                    tags$li(tags$b(\"age_group\"), \"- a faixa etária para a qual os dados foram coletados (0-5, 5-14, 15+ e todas as idades)\"),\n                    tags$li(tags$b(\"cases_reported\"), \"- o número de casos relatados para o estabelecimento / faixa etária na data fornecida\")\n               )\n               \n               \n          )\n     )\n)\n\nAgora nosso aplicativo está organizado em guias! Vamos fazer as edições necessárias no servidor também. Como não precisamos manipular nosso conjunto de dados antes de renderizá-lo, isso é na verdade muito simples - apenas renderizamos o conjunto de dados malaria_data via DT :: renderDT() para a interface do usuário!\n\nserver &lt;- function(input, output, session) {\n  \n  malaria_plot &lt;- reactive({\n    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)\n  })\n  \n  \n  \n  observe({\n    \n    if (input$select_district == \"All\") {\n      new_choices &lt;- facility_list$location_name\n    } else {\n      new_choices &lt;- facility_list%&gt;%\n        filter(District == input$select_district) %&gt;%\n        pull(location_name)\n    }\n    \n    new_choices &lt;- c(\"All\", new_choices)\n    \n    updateSelectInput(session, inputId = \"select_facility\",\n                      choices = new_choices)\n    \n  })\n  \n  \n  output$malaria_epicurve &lt;- renderPlot(\n    malaria_plot()\n  )\n  \n  output $ download_epicurve &lt;- downloadHandler (\n    \n    filename = function() {\n      stringr::str_glue(\"malaria_epicurve_{input$select_district}.png\")\n    },\n    \n    content = function(file) {\n      ggsave(file, \n             malaria_plot(),\n             width = 8, height = 5, dpi = 300)\n    }\n    \n  )\n  \n  # renderiza a tabela de dados para ui\n  output$raw_data &lt;- DT::renderDT(\n    malaria_data\n  )\n  \n  \n}",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Painéis com Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.pt.html#compartilhando-aplicativos-shiny",
    "href": "new_pages/shiny_basics.pt.html#compartilhando-aplicativos-shiny",
    "title": "43  Painéis com Shiny",
    "section": "43.7 Compartilhando aplicativos shiny",
    "text": "43.7 Compartilhando aplicativos shiny\nAgora que você desenvolveu seu aplicativo, provavelmente deseja compartilhá-lo com outras pessoas - afinal, essa é a principal vantagem do shiny! Podemos fazer isso compartilhando o código diretamente ou podemos publicá-lo em um servidor. Se compartilharmos o código, outros poderão ver o que você fez e construir sobre ele, mas isso negará uma das principais vantagens do shiny - pode eliminar a necessidade dos usuários finais de manter uma instalação R . Por esse motivo, se você estiver compartilhando seu aplicativo com usuários que não se sentem confortáveis com R, é muito mais fácil compartilhar um aplicativo que foi publicado em um servidor.\nSe você preferir compartilhar o código, pode fazer um arquivo .zip do aplicativo, ou melhor ainda, publicar seu aplicativo no github e adicionar colaboradores. Você pode consultar a seção no github para obter mais informações aqui.\nNo entanto, se estamos publicando o aplicativo online, precisamos trabalhar um pouco mais. Em última análise, queremos que seu aplicativo possa ser acessado por meio de um URL da web para que outras pessoas possam ter acesso rápido e fácil a ele. Infelizmente, para publicar seu aplicativo em um servidor, você precisa ter acesso a um servidor para publicá-lo! Existem várias opções de hospedagem quando se trata disso:\n\nshinyapps.io: este é o lugar mais fácil para publicar aplicativos shiny, pois tem a menor quantidade de trabalho de configuração necessária e tem algumas licenças gratuitas, mas limitadas.\nRStudio Connect: esta é uma versão muito mais poderosa de um servidor R, que pode realizar muitas operações, incluindo a publicação de aplicativos shiny. No entanto, é mais difícil de usar e menos recomendado para usuários iniciantes.\n\nPara os fins deste documento, usaremos shinyapps.io, pois é mais fácil para usuários iniciantes. Você pode criar uma conta gratuita aqui para começar - também existem diferentes planos de preços para licenças de servidor, se necessário. Quanto mais usuários você espera ter, mais caro seu plano de preços terá que ser, portanto, mantenha isso em consideração. Se você está procurando criar algo para um pequeno grupo de indivíduos usar, uma licença gratuita pode ser perfeitamente adequada, mas um aplicativo voltado ao público pode precisar de mais licenças.\nPrimeiro, devemos nos certificar de que nosso aplicativo é adequado para publicação em um servidor. Em seu aplicativo, você deve reiniciar sua sessão R e garantir que ela seja executada sem executar nenhum código extra. Isso é importante, pois um aplicativo que requer carregamento de pacote ou a leitura de dados não definida no código do aplicativo não será executado em um servidor. Observe também que você não pode ter nenhum caminho de arquivo explícito em seu aplicativo - eles serão inválidos na configuração do servidor - usar o pacote here resolve este problema muito bem. Finalmente, se você estiver lendo dados de uma fonte que requer autenticação do usuário, como os servidores da sua organização, isso geralmente não funcionará em um servidor. Você precisará entrar em contato com seu departamento de TI para descobrir como colocar o servidor shiny na lista de permissões aqui.\ninscrevendo-se em uma conta\nDepois de ter sua conta, você pode navegar até a página de tokens em Contas. Aqui você desejará adicionar um novo token - ele será usado para implantar seu aplicativo.\nA partir daqui, você deve observar que o url da sua conta refletirá o nome do seu aplicativo - portanto, se o seu aplicativo se chamar my_app, o url será anexado como xxx.io/my_app/. Escolha o nome do seu aplicativo com sabedoria! Agora que você está pronto, clique em implantar - se for bem-sucedido, seu aplicativo será executado no url da web que você escolheu!\nalgo sobre como fazer aplicativos em documentos?",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Painéis com Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.pt.html#leitura-adicional",
    "href": "new_pages/shiny_basics.pt.html#leitura-adicional",
    "title": "43  Painéis com Shiny",
    "section": "43.8 Leitura adicional",
    "text": "43.8 Leitura adicional\nAté agora, cobrimos muitos aspectos do shiny e mal arranhamos a superfície do que é oferecido ele. Embora este guia sirva como uma introdução, há muito mais coisas para aprender para entender completamente o shiny. Você deve começar a fazer aplicativos e adicionar gradualmente mais e mais funcionalidades",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Painéis com Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.pt.html#pacotes-de-extensão-recomendados",
    "href": "new_pages/shiny_basics.pt.html#pacotes-de-extensão-recomendados",
    "title": "43  Painéis com Shiny",
    "section": "43.9 Pacotes de extensão recomendados",
    "text": "43.9 Pacotes de extensão recomendados\nO que segue representa uma seleção de extensões shiny de alta qualidade que podem ajudá-lo a obter muito mais brilho (trocadilho com o nome shiny que em inglês significa “brilhante”). Em nenhuma ordem particular:\n\nBrightWidgets - este pacote oferece muitos, muitos mais widgets que podem ser usados em seu aplicativo. Execute shinyWidgets::shinyWidgetsGallery() para ver uma seleção de widgets disponíveis com este pacote. Veja exemplos aqui\nBrightjs - este é um excelente pacote que dá ao usuário a habilidade de estender muito a utilidade do shiny por meio de uma série de javascript. Os aplicativos deste pacote variam de muito simples a altamente avançado, mas você pode querer usá-lo primeiro para manipular a interface do usuário de maneiras simples, como ocultar / mostrar elementos ou habilitar / desabilitar botões. Saiba mais aqui\nBrightdashboard - este pacote expande enormemente a interface do usuário disponível que pode ser usada em shiny, permitindo especificamente que o usuário crie um painel complexo com uma variedade de layouts complexos. Veja mais aqui\nBrightdashboardPlus - obtenha ainda mais recursos da estrutura do Brightdashboard! Veja mais aqui\nBrightthemes - mude o tema CSS padrão para seu aplicativo shiny com uma ampla gama de modelos predefinidos! Veja mais aqui\n\nExistem também vários pacotes que podem ser usados para criar saídas interativas compatíveis com o shiny.\n\nDT é semi-incorporado em base shiny, mas fornece um grande conjunto de funções para criar tabelas interativas.\nplotly é um pacote para a criação de gráficos interativos que o usuário pode manipular no aplicativo. Você também pode converter seu gráfico para versões interativas via plotly::ggplotly()! Como alternativas, dygraphs e highcharter também são excelentes.",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Painéis com Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/shiny_basics.pt.html#recursos-recomendados",
    "href": "new_pages/shiny_basics.pt.html#recursos-recomendados",
    "title": "43  Painéis com Shiny",
    "section": "43.10 Recursos recomendados",
    "text": "43.10 Recursos recomendados",
    "crumbs": [
      "Relatórios e dashboards",
      "<span class='chapter-number'>43</span>  <span class='chapter-title'>Painéis com Shiny</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.pt.html",
    "href": "new_pages/writing_functions.pt.html",
    "title": "44  Escrevendo funções",
    "section": "",
    "text": "44.1 Preparação",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Escrevendo funções</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.pt.html#preparação",
    "href": "new_pages/writing_functions.pt.html#preparação",
    "title": "44  Escrevendo funções",
    "section": "",
    "text": "Carregar pacotes\nEste “chuk” (pedaço) de código mostra o carregamento de pacotes necessários para as análises. Neste manual, enfatizamos p_load() de pacman, que instala o pacote, se necessário, e carrega ele para ser utilizado. Você também pode carregar pacotes instalados com library() do R base. Veja em Introdução ao R para mais informações sobre pacotes R.\n\n\nImportar dados\nImportamos os dados de casos de uma simulação de epidemia de Ebola. Se desejar fazer o download dos dados para seguir passo a passo, veja as instruções na página Baixar livro e dados. O conjunto de dados é importado usando a função import () do pacote rio. Consulte a página Importar e exportar para várias maneiras de importar dados.\nTambém usaremos na última parte desta página alguns dados sobre a gripe H7N9 de 2013.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Escrevendo funções</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.pt.html#funções",
    "href": "new_pages/writing_functions.pt.html#funções",
    "title": "44  Escrevendo funções",
    "section": "44.2 Funções",
    "text": "44.2 Funções\nAs funções são úteis na programação, pois permitem tornar os códigos mais fáceis de entender, de alguma forma mais curtos e menos sujeitos a erros (dado que não haja erros na própria função).\nSe você chegou até aqui neste manual, significa que encontrou inúmeras funções, uma vez que no R toda operação é uma chamada de função +, for, if, [, $, { …. Por exemplo x + y é o mesmo que '+'(x, y)\nR é uma das linguagens que oferece a maior possibilidade de trabalhar com funções e dar ferramentas suficientes para que o usuário as escreva facilmente. Não devemos pensar nas funções como fixas no topo ou no final da cadeia de programação, o R oferece a possibilidade de usá-las como se fossem vetores e até mesmo dentro de outras funções, listas …\nExistem muitos recursos muito avançados sobre programação de funções e só daremos aqui uma visão para ajudá-lo a começar com breves exemplos práticos. Em seguida, você é incentivado a visitar os links de referências para ler mais sobre o assunto.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Escrevendo funções</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.pt.html#por-que-você-usaria-uma-função",
    "href": "new_pages/writing_functions.pt.html#por-que-você-usaria-uma-função",
    "title": "44  Escrevendo funções",
    "section": "44.3 Por que você usaria uma função?",
    "text": "44.3 Por que você usaria uma função?\nAntes de responder a esta pergunta, é importante observar que você já recebeu dicas para escrever suas primeiras funções R na página Iteração, loops e listas deste manual. Na verdade, o uso de “if / else” e loops costuma ser uma parte central de muitas de nossas funções, pois ajudam a ampliar a aplicação do nosso código, permitindo várias condições, ou a iterar códigos para tarefas repetidas.\n\nEstou repetindo várias vezes o mesmo bloco de código para aplicá-lo a uma variável ou dado diferente?\nLivrar-se dele irá encurtar substancialmente meu código e torná-lo executado mais rápido?\nÉ possível que o código que escrevi seja usado novamente, mas com um valor diferente em muitos lugares do código?\n\nSe a resposta a uma das perguntas anteriores for “SIM”, provavelmente você precisará escrever uma função",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Escrevendo funções</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.pt.html#como-o-r-cria-funções",
    "href": "new_pages/writing_functions.pt.html#como-o-r-cria-funções",
    "title": "44  Escrevendo funções",
    "section": "44.4 Como o R cria funções?",
    "text": "44.4 Como o R cria funções?\nAs funções em R têm três componentes principais:\n\nformals (), que é a lista de argumentos que controla como podemos rodar a função\nbody (), que é o código dentro da função, ou seja, entre colchetes ou após o parêntese, dependendo de como o escrevemos\n\ne,\n\nenvironment () que ajudará a localizar as variáveis da função e determina como a função encontra o valor.\n\nDepois de criar sua função, você pode verificar cada um desses componentes chamando a função associada.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Escrevendo funções</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.pt.html#sintaxe-e-estrutura-básicas",
    "href": "new_pages/writing_functions.pt.html#sintaxe-e-estrutura-básicas",
    "title": "44  Escrevendo funções",
    "section": "44.5 Sintaxe e estrutura básicas",
    "text": "44.5 Sintaxe e estrutura básicas\n\nUma função precisará ser nomeada corretamente para que sua tarefa seja facilmente compreensível assim que lermos seu nome. Na verdade, este já é o caso com a maioria da arquitetura do R base. Funções como mean (), print (), summary () têm nomes que são muito diretos\nUma função precisará de argumentos, como os dados nos quais trabalhar e outros objetos que podem ser valores estáticos entre outras opções\nE, finalmente, uma função fornecerá uma saída com base em sua tarefa principal e nos argumentos fornecidos. Normalmente usaremos funções embutidas como print (), return () … para produzir a saída. A saída pode ser um valor lógico, um número, um caractere, um quadro de dados … em suma, qualquer tipo de objeto R.\n\nBasicamente, esta é a composição de uma função:\n\nnome_da_funcao &lt;- function(argumento_1, argumento_2, argumento_3){\n  \n           function_task\n  \n           return(output)\n}\n\nPodemos criar nossa primeira função que será chamada conter_covid19 ().\n\nconter_covid19 &lt;- function(distanciamento_social, usar_mascara, vacinacao){\n  \n                            if(distanciamento_social == \"sim\" & usar_mascara == \"sim\" & vacinacao == \"sim\" ) \n       \n                            return(\"successo\")\n  \n  else(\"Certifique-se de que todos sejam 'sim', esta pandemia tem que acabar!\")\n}\n\nPodemos então verificar os componentes de nossa função recém-criada.\n\nformals(conter_covid19)\n\n$distanciamento_social\n\n\n$usar_mascara\n\n\n$vacinacao\n\nbody(conter_covid19)\n\n{\n    if (distanciamento_social == \"sim\" & usar_mascara == \"sim\" & \n        vacinacao == \"sim\") \n        return(\"successo\")\n    else (\"Certifique-se de que todos sejam 'sim', esta pandemia tem que acabar!\")\n}\n\nenvironment(conter_covid19)\n\n&lt;environment: R_GlobalEnv&gt;\n\n\nAgora vamos testar nossa função. Para rodar nossa função escrita, você a usa da mesma forma que usa todas as funções R, ou seja, escrevendo o nome da função e adicionando os argumentos necessários.\n\nconter_covid19(distanciamento_social = \"sim\", usar_mascara = \"sim\", vacinacao = \"sim\")\n\n[1] \"successo\"\n\n\nPodemos escrever novamente o nome de cada argumento por razões de precaução. Mas o código deve funcionar mesmo sem especificá-los, uma vez que o R tem na memória o posicionamento de cada argumento. Portanto, desde que você coloque os valores dos argumentos na ordem correta, você pode pular a escrita dos nomes dos argumentos ao rodar as funções.\n\nconter_covid19(\"sim\", \"sim\", \"sim\")\n\n[1] \"successo\"\n\n\nEntão, vamos ver o que acontece se um dos valores for \"não\" ou diferente de \"sim\".\n\nconter_covid19(distanciamento_social = \"sim\", usar_mascara = \"sim\", vacinacao = \"não\")\n\n[1] \"Certifique-se de que todos sejam 'sim', esta pandemia tem que acabar!\"\n\n\nSe fornecermos um argumento que não é reconhecido, obteremos um erro:\n\nconter_covid19(distanciamento_social = \"às vezes\", usar_mascara = \"sim\", vacinacao = \"não\")\n\nError in conter_covid19(distanciamento_social = \"às vezes\", usar_mascara = \"sim\",  :    could not find function \"conter_covid19\"\nNOTA: Algumas funções (na maioria das vezes muito curtas e diretas) podem não precisar de um nome e podem ser usadas diretamente em uma linha de código, ou dentro de outra função, para fazer tarefa rápida. Elas são chamadas de funções anônimas. \nPor exemplo, abaixo está uma primeira função anônima que mantém apenas variáveis de caracteres no conjunto de dados.\n\nlinelist %&gt;% \n  dplyr::slice_head(n=10) %&gt;%  # Equivalente à função \"head\" do R base, que retorna as primeiras n observações do conjunto de dados\n    select(function(x) is.character(x)) \n\n\n\n\n\n\n\nOutra função poderia selecionar o segundo registro realizado no nosso conjunto de dados. Pode ser relevante quando temos dados longitudinais com muitos registros por paciente, por exemplo, após ter solicitado por data ou visita). Nesse caso, a função apropriada para escrever fora do dplyr seria function (x) (x %% 2 == 0) para aplicar ao vetor contendo todos os números de linha.\n\nlinelist %&gt;%   \n   slice_head(n=20) %&gt;% \n   tibble::rownames_to_column() %&gt;% # Adiciona índices de cada registro como rownames para ver claramente a seleção final\n   filter(row_number() %%2 == 0)\n\n\n\n\n\n\n\nUm possível código do R base para a mesma tarefa seria:\n\nlinelist_firstobs &lt;- head(linelist, 20)\n\nlinelist_firstobs[base::Filter(function(x) (x%%2 == 0), seq(nrow(linelist_firstobs))),]\n\n\n\n\n\n\n\nCUIDADO: Se por um lado é verdade que o uso de funções pode nos ajudar com nosso código, também pode ser demorado escrever ou mesmo consertá-las se não tiver sido pensada completamente, escrita de forma adequada ou estiver retornando erros como resultado. Por esse motivo, geralmente é recomendado escrever primeiro o código R, certificar-se de que ele faz o que pretendemos fazer e, em seguida, transformá-lo em uma função com seus três componentes principais, conforme listado acima.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Escrevendo funções</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.pt.html#exemplos",
    "href": "new_pages/writing_functions.pt.html#exemplos",
    "title": "44  Escrevendo funções",
    "section": "44.6 Exemplos",
    "text": "44.6 Exemplos\n\nRetorna tabelas de proporção para várias colunas\nSim, já temos funções interessantes em muitos pacotes, permitindo resumir informações de uma forma muito fácil e agradável. Mas ainda vamos tentar fazer o nosso próprio, em nossos primeiros passos para nos acostumarmos a escrever funções.\nNeste exemplo, queremos mostrar como escrever uma função simples evitaria que você copiasse e colasse o mesmo código várias vezes.\n\nproptab_multiple &lt;- function(my_data, var_to_tab){\n  \n  # Grava o nome de cada variável de interesse antes de fazer a tabulação\n  print(var_to_tab)\n\n  with(my_data,\n       rbind( # Vincula os resultados das duas funções seguintes por linha\n        # Tabula a variável de interesse: fornece apenas números\n          table(my_data[[var_to_tab]], useNA = \"no\"),\n          # Calcula as proporções para cada variável de interesse e arredonda o resultado para 2 decimais\n         round(prop.table(table(my_data[[var_to_tab]]))*100,2)\n         )\n       )\n}\n\n\nproptab_multiple(linelist, \"gender\")\n\n[1] \"gender\"\n\n\n           f       m\n[1,] 2807.00 2803.00\n[2,]   50.04   49.96\n\nproptab_multiple(linelist, \"age_cat\")\n\n[1] \"age_cat\"\n\n\n         0-4     5-9  10-14  15-19   20-29 30-49 50-69 70+\n[1,] 1095.00 1095.00 941.00 743.00 1073.00   754 95.00 6.0\n[2,]   18.87   18.87  16.22  12.81   18.49    13  1.64 0.1\n\nproptab_multiple(linelist, \"outcome\")\n\n[1] \"outcome\"\n\n\n       Death Recover\n[1,] 2582.00 1983.00\n[2,]   56.56   43.44\n\n\nDICA: Como mostrado acima, é muito importante comentar suas funções como você faria para a programação geral. Lembre-se de que o objetivo de uma função é deixar um código pronto para ser lido, mais curto e mais eficiente. Então, deve-se ser capaz de entender o que a função faz apenas lendo seu nome e encontrar mais detalhes lendo os comentários.\nUma segunda opção é usar a função dentro de outra, por meio de um loop para fazer o processo de uma vez:\n\nfor(var_to_tab in c(\"gender\",\"age_cat\",  \"outcome\")){\n  \n  print(proptab_multiple(linelist, var_to_tab))\n  \n}\n\n[1] \"gender\"\n           f       m\n[1,] 2807.00 2803.00\n[2,]   50.04   49.96\n[1] \"age_cat\"\n         0-4     5-9  10-14  15-19   20-29 30-49 50-69 70+\n[1,] 1095.00 1095.00 941.00 743.00 1073.00   754 95.00 6.0\n[2,]   18.87   18.87  16.22  12.81   18.49    13  1.64 0.1\n[1] \"outcome\"\n       Death Recover\n[1,] 2582.00 1983.00\n[2,]   56.56   43.44\n\n\nUma maneira mais simples poderia ser usar o “apply” do R base em vez de um “for loop”, conforme abaixo:\nDICA: R é frequentemente definido como uma linguagem de programação funcional e quase sempre que você executa uma linha de código, está usando algumas funções integradas. Um bom hábito para ficar mais confortável com funções de escrita é frequentemente dar uma olhada interna em como as funções básicas que você usa diariamente são criadas. O atalho para isso é selecionar o nome da função e clicar emCtrl+F2 ou fn+F2 ou Cmd+F2 (dependendo do seu computador) .",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Escrevendo funções</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.pt.html#usando-purrr-escrevendo-funções-que-podem-ser-aplicadas-iterativamente",
    "href": "new_pages/writing_functions.pt.html#usando-purrr-escrevendo-funções-que-podem-ser-aplicadas-iterativamente",
    "title": "44  Escrevendo funções",
    "section": "44.7 Usando purrr: Escrevendo funções que podem ser aplicadas iterativamente",
    "text": "44.7 Usando purrr: Escrevendo funções que podem ser aplicadas iterativamente\n\nModificar a classe de várias colunas em um conjunto de dados\nDigamos que muitas variáveis do tipo caractere nos dados originais da linelist precisem ser alteradas para “fator” para fins de análise e plotagem. Em vez de repetir a etapa várias vezes, podemos apenas usar lapply () para fazer a transformação de todas as variáveis envolvidas em uma única linha de código.\nCUIDADO: lapply() retorna uma lista, portanto, seu uso pode exigir uma modificação adicional como última etapa.\nO mesmo passo pode ser feito usando a função map_if () do pacote purr\n\nlinelist_factor2 &lt;- linelist %&gt;%\n  purrr::map_if(is.character, as.factor)\n\n\nlinelist_factor2 %&gt;%\n        glimpse()\n\nList of 30\n $ case_id             : Factor w/ 5888 levels \"00031d\",\"00086d\",..: 2134 3022 396 4203 3084 4347 179 1241 5594 430 ...\n $ generation          : num [1:5888] 4 4 2 3 3 3 4 4 4 4 ...\n $ date_infection      : Date[1:5888], format: \"2014-05-08\" NA ...\n $ date_onset          : Date[1:5888], format: \"2014-05-13\" \"2014-05-13\" ...\n $ date_hospitalisation: Date[1:5888], format: \"2014-05-15\" \"2014-05-14\" ...\n $ date_outcome        : Date[1:5888], format: NA \"2014-05-18\" ...\n $ outcome             : Factor w/ 2 levels \"Death\",\"Recover\": NA 2 2 NA 2 2 2 1 2 1 ...\n $ gender              : Factor w/ 2 levels \"f\",\"m\": 2 1 2 1 2 1 1 1 2 1 ...\n $ age                 : num [1:5888] 2 3 56 18 3 16 16 0 61 27 ...\n $ age_unit            : Factor w/ 2 levels \"months\",\"years\": 2 2 2 2 2 2 2 2 2 2 ...\n $ age_years           : num [1:5888] 2 3 56 18 3 16 16 0 61 27 ...\n $ age_cat             : Factor w/ 8 levels \"0-4\",\"5-9\",\"10-14\",..: 1 1 7 4 1 4 4 1 7 5 ...\n $ age_cat5            : Factor w/ 18 levels \"0-4\",\"5-9\",\"10-14\",..: 1 1 12 4 1 4 4 1 13 6 ...\n $ hospital            : Factor w/ 6 levels \"Ausente\",\"Central Hospital\",..: 4 1 6 5 3 5 1 1 1 1 ...\n $ lon                 : num [1:5888] -13.2 -13.2 -13.2 -13.2 -13.2 ...\n $ lat                 : num [1:5888] 8.47 8.45 8.46 8.48 8.46 ...\n $ infector            : Factor w/ 2697 levels \"00031d\",\"002e6c\",..: 2594 NA NA 2635 180 1799 1407 195 NA NA ...\n $ source              : Factor w/ 2 levels \"funeral\",\"other\": 2 NA NA 2 2 2 2 2 NA NA ...\n $ wt_kg               : num [1:5888] 27 25 91 41 36 56 47 0 86 69 ...\n $ ht_cm               : num [1:5888] 48 59 238 135 71 116 87 11 226 174 ...\n $ ct_blood            : num [1:5888] 22 22 21 23 23 21 21 22 22 22 ...\n $ fever               : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n $ chills              : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n $ cough               : Factor w/ 2 levels \"no\",\"yes\": 2 NA NA 1 2 2 NA 2 2 2 ...\n $ aches               : Factor w/ 2 levels \"no\",\"yes\": 1 NA NA 1 1 1 NA 1 1 1 ...\n $ vomit               : Factor w/ 2 levels \"no\",\"yes\": 2 NA NA 1 2 2 NA 2 2 1 ...\n $ temp                : num [1:5888] 36.8 36.9 36.9 36.8 36.9 37.6 37.3 37 36.4 35.9 ...\n $ time_admission      : Factor w/ 1072 levels \"00:10\",\"00:29\",..: NA 308 746 415 514 589 609 297 409 387 ...\n $ bmi                 : num [1:5888] 117.2 71.8 16.1 22.5 71.4 ...\n $ days_onset_hosp     : num [1:5888] 2 1 2 2 1 1 2 1 1 2 ...\n\n\n\n\nProduzir gráficos iterativamente para diferentes níveis de uma variável\nVamos produzir um gráfico de pizza para observar a distribuição dos resultados dos pacientes na China durante o surto de H7N9 para cada província. Em vez de repetir o código para cada um deles, apenas aplicaremos uma função que criaremos.\n\n# Opções precisas para o uso do highchart\noptions(highcharter.theme =   highcharter::hc_theme_smpl(tooltip = list(valueDecimals = 2)))\n\n\n# Criar uma função chamada \"chart_outcome_province\" que leva como argumento o conjunto de dados e o nome da província para a qual plotar a distribuição do resultado.\n\nchart_outcome_province &lt;- function(data_used, prov){\n  \n  tab_prov &lt;- data_used %&gt;% \n    filter(province == prov,\n           !is.na(outcome))%&gt;% \n    group_by(outcome) %&gt;% \n    count() %&gt;%\n    adorn_totals(where = \"row\") %&gt;% \n    adorn_percentages(denominator = \"col\", )%&gt;%\n    mutate(\n        perc_outcome= round(n*100,2),\n        outcome=ifelse(outcome==\"Death\", \"Óbito\",  #só traduzindo para ficar com rótulos\n                       ifelse(outcome==\"Recover\",\"Recuperado\", outcome))) # em português\n \n\n  \n  \n  tab_prov %&gt;%\n    filter(outcome != \"Total\") %&gt;% \n  highcharter::hchart(\n    \"pie\", hcaes(x = outcome, y = perc_outcome),\n    name = paste0(\"Distribuição do desfecho em:\", prov)\n    )\n  \n}\n\nchart_outcome_province(flu_china, \"Shanghai\")\n\n\n\n\nchart_outcome_province(flu_china,\"Zhejiang\")\n\n\n\n\nchart_outcome_province(flu_china,\"Jiangsu\")\n\n\n\n\n\n\n\nProduzir tabelas iterativamente para diferentes níveis de uma variável\nAqui criaremos três indicadores para resumir em uma tabela e gostaríamos de produzir esta tabela para cada uma das províncias. Nossos indicadores são o atraso entre o início e a internação, o percentual de recuperação e a idade mediana dos casos.\n\nindic_1 &lt;- flu_china %&gt;% \n  group_by(province) %&gt;% \n  mutate(\n    date_hosp= strptime(date_of_hospitalisation, format = \"%m/%d/%Y\"),\n    date_ons= strptime(date_of_onset, format = \"%m/%d/%Y\"), \n    delay_onset_hosp= as.numeric(date_hosp - date_ons)/86400,\n    mean_delay_onset_hosp = round(mean(delay_onset_hosp, na.rm=TRUE ), 0)) %&gt;%\n  select(province, mean_delay_onset_hosp)  %&gt;% \n  distinct()\n     \n\nindic_2 &lt;-  flu_china %&gt;% \n            filter(!is.na(outcome)) %&gt;% \n            group_by(province, outcome) %&gt;% \n            count() %&gt;%\n            pivot_wider(names_from = outcome, values_from = n) %&gt;% \n    adorn_totals(where = \"col\") %&gt;% \n    mutate(\n        perc_recovery= round((Recover/Total)*100,2))%&gt;% \n  select(province, perc_recovery)\n    \n    \n    \nindic_3 &lt;-  flu_china %&gt;% \n            group_by(province) %&gt;% \n            mutate(\n                    median_age_cases = median(as.numeric(age), na.rm = TRUE)\n            ) %&gt;% \n  select(province, median_age_cases)  %&gt;% \n  distinct()\n\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `median_age_cases = median(as.numeric(age), na.rm = TRUE)`.\nℹ In group 11: `province = \"Shanghai\"`.\nCaused by warning in `median()`:\n! NAs introduced by coercion\n\n# Junte os três conjuntos de dados de indicadores\n\ntable_indic_all &lt;- indic_1 %&gt;% \n  dplyr::left_join(indic_2, by = \"province\") %&gt;% \n        left_join(indic_3, by = \"province\")\n\n\n# Imprima os indicadores em uma flextable\n\n\nprint_indic_prov &lt;-  function(table_used, prov){\n  \n  # Primeiro, transforme um pouco o quadro de dados para facilitar a visualização\n indic_prov &lt;- table_used %&gt;%\n    filter(province==prov) %&gt;%\n    pivot_longer(names_to = \"Indicadores\", cols = 2:4)%&gt;% \n   mutate( indic_label = factor(Indicadores,\n   levels= c(\"mean_delay_onset_hosp\",\"perc_recovery\",\"median_age_cases\"),\n   labels=c(\"Atraso entre início e internação\", \"Percentual de recuperação\", \"Idade mediana dos casos\"))\n   ) %&gt;% \n    ungroup(province) %&gt;% \n    select(indic_label, value)\n  \n\n  tab_print &lt;- flextable(indic_prov)  %&gt;%\n    theme_vanilla() %&gt;% \n    flextable::fontsize(part = \"body\", size = 10) \n    \n    \n     tab_print &lt;- tab_print %&gt;% \n                  autofit()   %&gt;%\n                  set_header_labels( \n                indic_label= \"Indicadores\", value= \"Estimativa\") %&gt;%\n    flextable::bg( bg = \"darkblue\", part = \"header\") %&gt;%\n    flextable::bold(part = \"header\") %&gt;%\n    flextable::color(color = \"white\", part = \"header\") %&gt;% \n    add_header_lines(values = paste0(\"Indicadores para a província de:\", prov)) %&gt;% \nbold(part = \"header\")\n \n tab_print &lt;- set_formatter_type(tab_print,\n   fmt_double = \"%.2f\",\n   na_str = \"-\")\n\ntab_print \n    \n}\n\n\n\n\nprint_indic_prov(table_indic_all, \"Shanghai\")\n\nIndicadores para a província de:ShanghaiIndicadoresEstimativaAtraso entre início e internação4.0Percentual de recuperação46.7Idade mediana dos casos67.0\n\nprint_indic_prov(table_indic_all, \"Jiangsu\")\n\nIndicadores para a província de:JiangsuIndicadoresEstimativaAtraso entre início e internação6.0Percentual de recuperação71.4Idade mediana dos casos55.0",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Escrevendo funções</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.pt.html#dicas-e-práticas-recomendadas-para-o-bom-funcionamento-das-funções",
    "href": "new_pages/writing_functions.pt.html#dicas-e-práticas-recomendadas-para-o-bom-funcionamento-das-funções",
    "title": "44  Escrevendo funções",
    "section": "44.8 Dicas e práticas recomendadas para o bom funcionamento das funções",
    "text": "44.8 Dicas e práticas recomendadas para o bom funcionamento das funções\nA programação de funções visa facilitar o código e facilitar sua leitura. Deve produzir o contrário. As dicas abaixo irão ajudá-lo a ter um código limpo e fácil de ler.\n\nNomenclatura e sintaxe\n\nEvite usar caracteres que poderiam facilmente ter sido contemplados em outras funções já existentes em seu ambiente\nRecomenda-se que o nome da função seja curto e fácil de entender\nÉ preferível usar verbos como o nome da função e substantivos para os nomes dos argumentos.\n\n\n\nNomes de coluna e avaliação organizada\nSe você quiser saber como fazer referência a nomes de coluna fornecidos em seu código como argumentos, leia tidyverse programming guidance.Entre os tópicos cobertos estão avaliação arrumada (de tidy evaluation) e uso de embrace { } “Colchetes duplos”\nPor exemplo, aqui está um esqueleto rápido de código modelo da página do tutorial mencionado acima:\n\nvar_summary &lt;- function(data, var) {\n  data %&gt;%\n    summarise(n = n(), min = min({{ var }}), max = max({{ var }}))\n}\nmtcars %&gt;% \n  group_by(cyl) %&gt;% \n  var_summary(mpg)\n\n\n\nTeste e tratamento de erros\nQuanto mais complicada a tarefa de uma função, maior a possibilidade de erros. Portanto, às vezes é necessário adicionar alguma verificação na função para ajudar a entender rapidamente de onde vem o erro e encontrar uma maneira de corrigi-lo.\n\nPode ser mais do que recomendado introduzir uma verificação sobre a falta de um argumento usando missing(argumento). Esta verificação simples pode retornar um valor “TRUE” (verdadeiro) ou “FALSE” (falso).\n\n\nconter_covid19_missing &lt;- function(distanciamento_social, usar_mascara, vacinacao){\n  \n  if (missing(distanciamento_social)) (print(\"Por favor, forneça o arg1\"))\n  if (missing(usar_mascara)) print(\"Por favor, forneça o arg2\")\n  if (missing(vacinacao)) print(\"Por favor, forneça o arg3\")\n\n\n  if (!distanciamento_social == \"sim\" | usar_mascara ==\"sim\" | vacinacao == \"sim\" ) \n       \n       return (\"Você pode fazer melhor\")\n  \n  else(\"Certifique-se de que todos estejam 'sim', esta pandemia tem que acabar!\")\n}\n\n\nconter_covid19_missing(vacinacao = \"sim\")\n\n[1] \"Por favor, forneça o arg1\"\n[1] \"Por favor, forneça o arg2\"\n\n\nError in conter_covid19_missing(vacinacao = \"sim\"): argument \"distanciamento_social\" is missing, with no default\n\n\n\nUse stop() para mais erros detectáveis.\n\n\nconter_covid19_stop &lt;- function(distanciamento_social, usar_mascara, vacinacao){\n  \n  if(!is.character(distanciamento_social)) (stop(\"arg1 deve ser um caractere, digite o valor com` sim`, `não` ou` às vezes\"))\n  \n  if (distanciamento_social == \"sim\" & usar_mascara ==\"sim\" & vacinacao == \"sim\" ) \n       \n       return (\"successo\")\n  \n  else(\"Certifique-se de que todos estejam 'sim', esta pandemia tem que acabar!\")\n}\n\n\nconter_covid19_stop(distanciamento_social=1, usar_mascara=\"sim\", vacinacao = \"não\")\n\nError in conter_covid19_stop(distanciamento_social = 1, usar_mascara = \"sim\", : arg1 deve ser um caractere, digite o valor com` sim`, `não` ou` às vezes\n\n\n\nComo vemos quando executamos a maioria das funções integradas, existem mensagens e avisos que podem aparecer em certas condições. Podemos integrá-los na escrita de nossas funções usando as funções message() e warning().\nTambém podemos lidar com erros usando safely(), que pega uma função como um argumento e a executa de maneira segura. Na verdade, a função será executada sem parar se encontrar um erro. safely() retorna como resultado uma list com dois objetos, que são os resultados e o erro “pulado”.\n\nPodemos verificar executando primeiro a mean() como função e, em seguida, executando com secure ().\n\nmap(linelist, mean)\n\n$case_id\n[1] NA\n\n$generation\n[1] 16.56165\n\n$date_infection\n[1] NA\n\n$date_onset\n[1] NA\n\n$date_hospitalisation\n[1] \"2014-11-03\"\n\n$date_outcome\n[1] NA\n\n$outcome\n[1] NA\n\n$gender\n[1] NA\n\n$age\n[1] NA\n\n$age_unit\n[1] NA\n\n$age_years\n[1] NA\n\n$age_cat\n[1] NA\n\n$age_cat5\n[1] NA\n\n$hospital\n[1] NA\n\n$lon\n[1] -13.23381\n\n$lat\n[1] 8.469638\n\n$infector\n[1] NA\n\n$source\n[1] NA\n\n$wt_kg\n[1] 52.64487\n\n$ht_cm\n[1] 124.9633\n\n$ct_blood\n[1] 21.20686\n\n$fever\n[1] NA\n\n$chills\n[1] NA\n\n$cough\n[1] NA\n\n$aches\n[1] NA\n\n$vomit\n[1] NA\n\n$temp\n[1] NA\n\n$time_admission\n[1] NA\n\n$bmi\n[1] 46.89023\n\n$days_onset_hosp\n[1] NA\n\n\n\nsafe_mean &lt;- safely(mean)\nlinelist %&gt;% \n  map(safe_mean)\n\n$case_id\n$case_id$result\n[1] NA\n\n$case_id$error\nNULL\n\n\n$generation\n$generation$result\n[1] 16.56165\n\n$generation$error\nNULL\n\n\n$date_infection\n$date_infection$result\n[1] NA\n\n$date_infection$error\nNULL\n\n\n$date_onset\n$date_onset$result\n[1] NA\n\n$date_onset$error\nNULL\n\n\n$date_hospitalisation\n$date_hospitalisation$result\n[1] \"2014-11-03\"\n\n$date_hospitalisation$error\nNULL\n\n\n$date_outcome\n$date_outcome$result\n[1] NA\n\n$date_outcome$error\nNULL\n\n\n$outcome\n$outcome$result\n[1] NA\n\n$outcome$error\nNULL\n\n\n$gender\n$gender$result\n[1] NA\n\n$gender$error\nNULL\n\n\n$age\n$age$result\n[1] NA\n\n$age$error\nNULL\n\n\n$age_unit\n$age_unit$result\n[1] NA\n\n$age_unit$error\nNULL\n\n\n$age_years\n$age_years$result\n[1] NA\n\n$age_years$error\nNULL\n\n\n$age_cat\n$age_cat$result\n[1] NA\n\n$age_cat$error\nNULL\n\n\n$age_cat5\n$age_cat5$result\n[1] NA\n\n$age_cat5$error\nNULL\n\n\n$hospital\n$hospital$result\n[1] NA\n\n$hospital$error\nNULL\n\n\n$lon\n$lon$result\n[1] -13.23381\n\n$lon$error\nNULL\n\n\n$lat\n$lat$result\n[1] 8.469638\n\n$lat$error\nNULL\n\n\n$infector\n$infector$result\n[1] NA\n\n$infector$error\nNULL\n\n\n$source\n$source$result\n[1] NA\n\n$source$error\nNULL\n\n\n$wt_kg\n$wt_kg$result\n[1] 52.64487\n\n$wt_kg$error\nNULL\n\n\n$ht_cm\n$ht_cm$result\n[1] 124.9633\n\n$ht_cm$error\nNULL\n\n\n$ct_blood\n$ct_blood$result\n[1] 21.20686\n\n$ct_blood$error\nNULL\n\n\n$fever\n$fever$result\n[1] NA\n\n$fever$error\nNULL\n\n\n$chills\n$chills$result\n[1] NA\n\n$chills$error\nNULL\n\n\n$cough\n$cough$result\n[1] NA\n\n$cough$error\nNULL\n\n\n$aches\n$aches$result\n[1] NA\n\n$aches$error\nNULL\n\n\n$vomit\n$vomit$result\n[1] NA\n\n$vomit$error\nNULL\n\n\n$temp\n$temp$result\n[1] NA\n\n$temp$error\nNULL\n\n\n$time_admission\n$time_admission$result\n[1] NA\n\n$time_admission$error\nNULL\n\n\n$bmi\n$bmi$result\n[1] 46.89023\n\n$bmi$error\nNULL\n\n\n$days_onset_hosp\n$days_onset_hosp$result\n[1] NA\n\n$days_onset_hosp$error\nNULL\n\n\nComo dito anteriormente, comentar bem nossos códigos já é uma boa forma de termos documentação em nosso trabalho.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Escrevendo funções</span>"
    ]
  },
  {
    "objectID": "new_pages/writing_functions.pt.html#recursos",
    "href": "new_pages/writing_functions.pt.html#recursos",
    "title": "44  Escrevendo funções",
    "section": "44.9 Recursos",
    "text": "44.9 Recursos\nlink para o livro R para Ciência de Dados\nCheatsheet (cola) em programação avançada em R\nCheatsheet (cola) do Pacote purr\nVideo-ACM palesta por Hadley Wickham: A alegria da programação funcional (como map_dbl funciona)",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>44</span>  <span class='chapter-title'>Escrevendo funções</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.pt.html",
    "href": "new_pages/directories.pt.html",
    "title": "45  Interações de diretório",
    "section": "",
    "text": "45.1 Preparação",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Interações de diretório</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.pt.html#preparação",
    "href": "new_pages/directories.pt.html#preparação",
    "title": "45  Interações de diretório",
    "section": "",
    "text": "Pacote fs\nO fs é um pacote do tidyverse que facilita as interações de diretório, melhorando algumas das funções do R base. Nas seções a seguir, usaremos frequentemente as funções do fs.\n\npacman::p_load(\n  fs,             # Interações de arquivo / diretório\n  rio,            # Importar / Exportar\n  here,           # Caminhos de arquivo respectivos\n  tidyverse)      # Gerenciamento e visualização de dados\n\n\n\nImprimir diretório como uma árvore de dendrograma\nUse a função dir_tree() do fs.\nForneça o caminho da pasta do arquivo para path = e decida se deseja mostrar apenas um nível (recurse = FALSE) ou todos os arquivos em todos os subníveis (recurse = TRUE). Abaixo, usamos here() como uma abreviação para o projeto R e especificamos sua subpasta “data” (dados), que contém todos os dados usados para este manual de R. Nós o configuramos para exibir todos os arquivos na pasta supra citada e suas subpastas (por exemplo, “cache”, “epidemic models”, “population”, “shp”, and “weather”).\n\nfs::dir_tree(path = here(\"data\"), recurse = TRUE)\n\nC:/Users/ngulu864/AppData/Local/Temp/RtmpINQh8o/file624410067b06/data\n├── africa_countries.geo.json\n├── cache\n│   └── epidemic_models\n│       ├── 2015-04-30\n│       │   ├── estimated_reported_cases_samples.rds\n│       │   ├── estimate_samples.rds\n│       │   ├── latest_date.rds\n│       │   ├── reported_cases.rds\n│       │   ├── summarised_estimated_reported_cases.rds\n│       │   ├── summarised_estimates.rds\n│       │   └── summary.rds\n│       ├── epinow_res.rds\n│       ├── epinow_res_small.rds\n│       ├── generation_time.rds\n│       └── incubation_period.rds\n├── case_linelists\n│   ├── cleaning_dict.csv\n│   ├── fluH7N9_China_2013.csv\n│   ├── linelist_cleaned.rds\n│   ├── linelist_cleaned.xlsx\n│   └── linelist_raw.xlsx\n├── country_demographics.csv\n├── covid_example_data\n│   ├── covid_example_data.xlsx\n│   └── covid_shapefile\n│       ├── FultonCountyZipCodes.cpg\n│       ├── FultonCountyZipCodes.dbf\n│       ├── FultonCountyZipCodes.prj\n│       ├── FultonCountyZipCodes.sbn\n│       ├── FultonCountyZipCodes.sbx\n│       ├── FultonCountyZipCodes.shp\n│       ├── FultonCountyZipCodes.shp.xml\n│       └── FultonCountyZipCodes.shx\n├── covid_incidence.csv\n├── covid_incidence_map.R\n├── district_count_data.xlsx\n├── example\n│   ├── Central Hospital.csv\n│   ├── district_weekly_count_data.xlsx\n│   ├── fluH7N9_China_2013.csv\n│   ├── hospital_linelists.xlsx\n│   ├── linelists\n│   │   ├── 20201007linelist.csv\n│   │   ├── case_linelist20201006.csv\n│   │   ├── case_linelist_2020-10-02.csv\n│   │   ├── case_linelist_2020-10-03.csv\n│   │   ├── case_linelist_2020-10-04.csv\n│   │   ├── case_linelist_2020-10-05.csv\n│   │   └── case_linelist_2020-10-08.xlsx\n│   ├── Military Hospital.csv\n│   ├── Missing.csv\n│   ├── Other.csv\n│   ├── Port Hospital.csv\n│   └── St. Mark's Maternity Hospital (SMMH).csv\n├── facility_count_data.rds\n├── flexdashboard\n│   ├── outbreak_dashboard.html\n│   ├── outbreak_dashboard.Rmd\n│   ├── outbreak_dashboard_shiny.Rmd\n│   ├── outbreak_dashboard_test.html\n│   └── outbreak_dashboard_test.Rmd\n├── fluH7N9_China_2013.csv\n├── gis\n│   ├── africa_countries.geo.json\n│   ├── covid_incidence.csv\n│   ├── covid_incidence_map.R\n│   ├── linelist_cleaned_with_adm3.rds\n│   ├── population\n│   │   ├── sle_admpop_adm3_2020.csv\n│   │   └── sle_population_statistics_sierraleone_2020.xlsx\n│   └── shp\n│       ├── README.txt\n│       ├── sle_adm3.CPG\n│       ├── sle_adm3.dbf\n│       ├── sle_adm3.prj\n│       ├── sle_adm3.sbn\n│       ├── sle_adm3.sbx\n│       ├── sle_adm3.shp\n│       ├── sle_adm3.shp.xml\n│       ├── sle_adm3.shx\n│       ├── sle_hf.CPG\n│       ├── sle_hf.dbf\n│       ├── sle_hf.prj\n│       ├── sle_hf.sbn\n│       ├── sle_hf.sbx\n│       ├── sle_hf.shp\n│       └── sle_hf.shx\n├── godata\n│   ├── cases_clean.rds\n│   ├── contacts_clean.rds\n│   ├── followups_clean.rds\n│   └── relationships_clean.rds\n├── likert_data.csv\n├── linelist_cleaned.rds\n├── linelist_cleaned.xlsx\n├── linelist_raw.xlsx\n├── make_evd_dataset-DESKTOP-JIEUMMI.R\n├── make_evd_dataset.R\n├── malaria_app\n│   ├── app.R\n│   ├── data\n│   │   └── facility_count_data.rds\n│   ├── funcs\n│   │   └── plot_epicurve.R\n│   ├── global.R\n│   ├── malaria_app.Rproj\n│   ├── server.R\n│   └── ui.R\n├── malaria_facility_count_data.rds\n├── phylo\n│   ├── sample_data_Shigella_tree.csv\n│   ├── Shigella_subtree_2.nwk\n│   ├── Shigella_subtree_2.txt\n│   └── Shigella_tree.txt\n├── rmarkdown\n│   ├── outbreak_report.docx\n│   ├── outbreak_report.html\n│   ├── outbreak_report.pdf\n│   ├── outbreak_report.pptx\n│   ├── outbreak_report.Rmd\n│   ├── report_tabbed_example.html\n│   └── report_tabbed_example.Rmd\n├── standardization\n│   ├── country_demographics.csv\n│   ├── country_demographics_2.csv\n│   ├── deaths_countryA.csv\n│   ├── deaths_countryB.csv\n│   └── world_standard_population_by_sex.csv\n├── surveys\n│   ├── population.xlsx\n│   ├── survey_data.xlsx\n│   └── survey_dict.xlsx\n└── time_series\n    ├── campylobacter_germany.xlsx\n    └── weather\n        ├── germany_weather2002.nc\n        ├── germany_weather2003.nc\n        ├── germany_weather2004.nc\n        ├── germany_weather2005.nc\n        ├── germany_weather2006.nc\n        ├── germany_weather2007.nc\n        ├── germany_weather2008.nc\n        ├── germany_weather2009.nc\n        ├── germany_weather2010.nc\n        └── germany_weather2011.nc",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Interações de diretório</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.pt.html#listar-arquivos-em-um-diretório",
    "href": "new_pages/directories.pt.html#listar-arquivos-em-um-diretório",
    "title": "45  Interações de diretório",
    "section": "45.2 Listar arquivos em um diretório",
    "text": "45.2 Listar arquivos em um diretório\nPara listar apenas os nomes dos arquivos em um diretório, você pode usar dir() do R base. Por exemplo, este comando lista os nomes dos arquivos na subpasta “população” da pasta “dados” em um projeto R. O caminho de arquivo respectivo é fornecido usando here() (sobre o qual você pode ler mais na página Importar e exportar).\n\n# Nomes de arquivos\ndir(here(\"data\", \"gis\", \"population\"))\n\n[1] \"sle_admpop_adm3_2020.csv\"                       \n[2] \"sle_population_statistics_sierraleone_2020.xlsx\"\n\n\nPara listar os caminhos completos dos arquivos do diretório, você pode usar dir_ls() de fs. Uma alternativa é list.files() do R base .\n\n# Caminhos de arquivos\ndir_ls(here(\"data\", \"gis\", \"population\"))\n\nC:/Users/ngulu864/AppData/Local/Temp/RtmpINQh8o/file624410067b06/data/gis/population/sle_admpop_adm3_2020.csv\nC:/Users/ngulu864/AppData/Local/Temp/RtmpINQh8o/file624410067b06/data/gis/population/sle_population_statistics_sierraleone_2020.xlsx\n\n\nPara obter todas as informações de metadados sobre cada arquivo em um diretório (por exemplo, caminho, data de modificação, etc.), você pode usar dir_info() de fs.\nIsso pode ser particularmente útil se você deseja extrair a hora da última modificação do arquivo, por exemplo, se deseja importar a versão mais recente. Para obter um exemplo disso, consulte a página Importar e exportar.\n\n# Informações do arquivo\ndir_info(here(\"data\", \"gis\", \"population\"))\n\nAqui está o dataframe que retorna. Role para a direita para ver todas as colunas.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Interações de diretório</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.pt.html#informações-do-arquivo",
    "href": "new_pages/directories.pt.html#informações-do-arquivo",
    "title": "45  Interações de diretório",
    "section": "45.3 Informações do arquivo",
    "text": "45.3 Informações do arquivo\nPara extrair informações de metadados sobre um arquivo específico, você pode usar file_info() de fs (ou file.info() do R base).\n\nfile_info(here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))\n\n\n\n\n\n\n\nAqui usamos o $ para indexar o resultado e retornar apenas o valor modify_time.\n\nfile_info(here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))$modification_time\n\n[1] \"2024-05-08 12:15:45 CEST\"",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Interações de diretório</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.pt.html#verifique-se-existe",
    "href": "new_pages/directories.pt.html#verifique-se-existe",
    "title": "45  Interações de diretório",
    "section": "45.4 Verifique se existe",
    "text": "45.4 Verifique se existe\n\nObjetos R\nVocê pode usar exists() do R base para verificar se um objeto existe dentro do R (forneça o nome do objeto entre aspas).\n\nexists(\"linelist\")\n\n[1] FALSE\n\n\nObserve que alguns pacotes do R base usam nomes de objetos genéricos como “data” (que significa “dados” em inglês) nos bastidores, que aparecerão como TRUE a menos que inherit = FALSE seja especificado. Este é um dos motivos para não nomear o conjunto de dados como “data”.\n\nexists(\"data\")\n\n[1] TRUE\n\nexists(\"data\", inherit = FALSE)\n\n[1] FALSE\n\n\nSe você está escrevendo uma função, deve usar missing() do R base para verificar se um argumento está presente ou não, ao invés de exists().\n\n\nDiretórios\nPara verificar se existe um diretório, forneça o caminho do arquivo (e nome do arquivo) para is_dir() de fs. Role para a direita para ver que retorna TRUE.\n\nis_dir(here(\"data\"))\n\nC:/Users/ngulu864/AppData/Local/Temp/RtmpINQh8o/file624410067b06/data \n                                                                 TRUE \n\n\nUma alternativa é file.exists() do R base.\n\n\nArquivos\nPara verificar se um arquivo específico existe, use is_file() de fs. Role para a direita para ver que retorna TRUE.\n\nis_file(here(\"data\", \"case_linelists\", \"linelist_cleaned.rds\"))\n\nC:/Users/ngulu864/AppData/Local/Temp/RtmpINQh8o/file624410067b06/data/case_linelists/linelist_cleaned.rds \n                                                                                                     TRUE \n\n\nUma alternativa no R base é file.exists().",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Interações de diretório</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.pt.html#criar",
    "href": "new_pages/directories.pt.html#criar",
    "title": "45  Interações de diretório",
    "section": "45.5 Criar",
    "text": "45.5 Criar\n\nDiretórios\nPara criar um novo diretório (pasta), você pode usar dir_create() de fs. Se o diretório já existir, ele não será criado novamente e não será retornado nenhum erro.\n\ndir_create(here(\"data\", \"test\"))\n\nUma alternativa é dir.create() do R base, que mostrará um erro se o diretório já existir. Em contraste, dir_create() neste cenário será silencioso.\n\n\nArquivos\nVocê pode criar um arquivo (vazio) com file_create() de fs. Se o arquivo já existir, ele não será criado novamente ou alterado.\n\nfile_create(here(\"data\", \"test.rds\"))\n\nfile.create() é uma alternativa no R base. Mas se o arquivo já existe, esta opção irá truncá-lo. Se você usar file_create() o arquivo não será alterado.\n\n\nCriar se não existir\nEM CONSTRUÇÃO",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Interações de diretório</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.pt.html#deletar",
    "href": "new_pages/directories.pt.html#deletar",
    "title": "45  Interações de diretório",
    "section": "45.6 Deletar",
    "text": "45.6 Deletar\n\nObjetos R\nUse rm() do R base para remover um objeto R.\n\n\nDiretórios\nUse dir_delete() de fs.\n\n\nArquivos\nVocê pode excluir arquivos com file_delete() de fs.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Interações de diretório</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.pt.html#executando-outros-arquivos",
    "href": "new_pages/directories.pt.html#executando-outros-arquivos",
    "title": "45  Interações de diretório",
    "section": "45.7 Executando outros arquivos",
    "text": "45.7 Executando outros arquivos\n\nsource()\nPara executar um script R a partir de outro script R, você pode usar o comando source() (do R base).\n\nsource(here(\"scripts\", \"cleaning_scripts\", \"clean_testing_data.R\"))\n\nIsso é equivalente a visualizar o script R acima e clicar no botão “Source” (Fonte) no canto superior direito do script. Isso executará o script, mas silenciosamente (sem saída para o console do R), a menos que seja especificada esta intenção. Veja a página [Console interativo] para exemplos de uso da source() para interagir com um usuário através do console R no modo pergunta e resposta.\n\n\n\n\n\n\n\n\n\n\n\nrender()\nrender() é uma variação de source() mais frequentemente usada para scripts R markdown. Você fornece o input = que é o arquivo Rmarkdown (.Rmd), e também o output_format = (normalmente “html_document”, “pdf_document”, “word_document”, ““)\nConsulte a página Relatórios com R Markdown para obter mais detalhes. Veja também a documentação para render() aqui ou inserindo ?render.\n\n\nExecutar arquivos em um diretório\nVocê pode criar um for loop e usá-lo em source() para todos os arquivos em um diretório, identificado com dir(). with dir().\n\nfor(script in dir(here(\"scripts\"), pattern = \".R$\")) {   # Para cada nome de script na pasta \"scripts\" do Projeto R (com extensão .R)\n  source(here(\"scripts\", script))                        # Fonte dos arquivos com nomes correspondentes aos encontrados na pasta de scripts\n}\n\nSe você deseja apenas executar determinados scripts, pode identificá-los pelos nomes da seguinte forma:\n\nscripts_to_run &lt;- c(\n     \"epicurves.R\",\n     \"demographic_tables.R\",\n     \"survival_curves.R\"\n)\n\nfor(script in scripts_to_run) {\n  source(here(\"scripts\", script))\n}\n\nAqui está uma comparação das funções de fs e R base.\n\n\nImportar arquivos em um diretório\nConsulte a página Importar e exportar para importar e exportar arquivos individuais.\nConsulte também a página Importar e exportar para métodos que importem automaticamente o arquivo mais recente, com base em uma data no nome do arquivo ou nos metadados do arquivo.\nVeja na página Iteração, loops e listas um exemplo com o pacote purrr demonstrando:\n\nDividir um dataframe e salvá-lo como vários arquivos CSV\nDividir um dataframe e salvar cada parte em uma planilha separada dentro de uma pasta de trabalho do Excel\nImportar vários arquivos CSV e combiná-los em um dataframe\nImportar uma pasta de trabalho do Excel com várias planilhas e combiná-las em um único dataframe",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Interações de diretório</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.pt.html#r-base",
    "href": "new_pages/directories.pt.html#r-base",
    "title": "45  Interações de diretório",
    "section": "45.8 R base",
    "text": "45.8 R base\nVeja abaixo as funções list.files() e dir(), que realizam a mesma operação de listar arquivos dentro de um diretório especificado. Você pode especificar ignore.case = ou um padrão específico para procurar.\n\nlist.files(path = here(\"data\"))\n\nlist.files(path = here(\"data\"), pattern = \".csv\")\n# dir(path = here(\"data\"), pattern = \".csv\")\n\nlist.files(path = here(\"data\"), pattern = \"evd\", ignore.case = TRUE)\n\nSe um arquivo estiver “aberto” no momento, ele será exibido em sua pasta com um til na frente, como “~$hospital_linelists.xlsx”.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Interações de diretório</span>"
    ]
  },
  {
    "objectID": "new_pages/directories.pt.html#recursos",
    "href": "new_pages/directories.pt.html#recursos",
    "title": "45  Interações de diretório",
    "section": "45.9 Recursos",
    "text": "45.9 Recursos\nhttps://cran.r-project.org/web/packages/fs/vignettes/function-comparisons.html",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>45</span>  <span class='chapter-title'>Interações de diretório</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.pt.html",
    "href": "new_pages/collaboration.pt.html",
    "title": "46  Controle de versão e colaboração com Git e Github",
    "section": "",
    "text": "46.1 O que é o Git?\nGit é um software de controle de versões que permite rastrear alterações em uma pasta. Pode ser usado como a opção de “controle de alterações” no Word, LibreOffice ou Google docs, mas para todos os tipos de arquivos. É uma das opções mais poderosas e mais usadas para controle de versões.\nPor que eu nunca ouvi falar disso? Enquanto pessoas com formação em programação aprendem rotineiramente a usar softwares de controle de versões (Git, Mercurial, Subversion ou outros), poucos de nós das disciplinas quantitativas aprendem essas habilidades. Consequentemente, a maioria dos epidemiologistas nunca ouviu falar dele durante seus estudos, e tem que aprender repentinamente.\nEspera, já ouvi falar do Github, é a mesma coisa? - Não exatamente, mas costumamos usá-los juntos. E nós mostraremos como fazer. Resumidamente:\nPortanto, você pode usar o cliente ou a interface Github Desktop, que usa Git em segundo plano para gerenciar seus arquivos, tanto localmente em seu computador quanto remotamente em um servidor Github.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Controle de versão e colaboração com Git e Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.pt.html#o-que-é-o-git",
    "href": "new_pages/collaboration.pt.html#o-que-é-o-git",
    "title": "46  Controle de versão e colaboração com Git e Github",
    "section": "",
    "text": "Git é o sistema de controle de versão, um software. Você pode usá-lo localmente em seu computador ou para sincronizar uma pasta com um site hospedeiro. Por padrão, usa-se um terminal para fornecer instruções Git na linha de comando.\nVocê pode usar um cliente / uma interface Git para evitar a linha de comando e executar as mesmas ações (pelo menos para as simples e supercomuns).\nSe você deseja armazenar sua pasta em um site hospedeiro para colaborar com outras pessoas, você pode criar uma conta no Github, Gitlab, Bitbucket ou outros.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Controle de versão e colaboração com Git e Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.pt.html#por-que-usar-o-combo-git-e-github",
    "href": "new_pages/collaboration.pt.html#por-que-usar-o-combo-git-e-github",
    "title": "46  Controle de versão e colaboração com Git e Github",
    "section": "46.2 Por que usar o combo Git e Github?",
    "text": "46.2 Por que usar o combo Git e Github?\nUsar o Git facilita:\n\nArquivar versões documentadas com mudanças adicionais para que você possa recuperar facilmente qualquer versão anterior;\nTer ramos ( do inglês branches) paralelos, ou seja, desenvolver / “trabalhar” diferentes versões com formas estruturadas de integrar as mudanças após a revisão.\n\nIsso pode ser feito localmente em seu computador, mesmo se você não colaborar com outras pessoas. Você já:\n\nlamentou ter excluído uma seção do código, para perceber apenas dois meses depois que você realmente precisava dela?\nvoltou em um projeto que estava parado e tentou lembrar se você fez aquela modificação complicada em um dos modelos?\nteve um arquivo modelo_1.R , outro arquivo modelo_1_teste.R e ainda um outro arquivo modelo_1_nao_funciona.R para testar diferentes soluções?\nteve um arquivo relatorio.Rmd, um arquivo relatorio_completo.Rmd , um arquivo relatorio_verdadeiro_final.Rmd, um arquivo relatorio_final_20210304.Rmd, um arquivo relatorio_final_20210402.Rmd  e amaldiçoou suas habilidades de backup?\n\nGit vai ajudar com tudo isso, e vale a pena aprender só por isso.\nNo entanto, ele se torna ainda mais poderoso quando usado com um repositório online para oferecer suporte a projetos colaborativos, como o Github. Isso facilita: - Colaboração: outras pessoas podem revisar, comentar e aceitar/recusar as alterações;\n\nCompartilhar seu código, dados e resultados e solicitar feedback em público (ou em particular, com sua equipe).\n\nE evita:\n\n“Opa, esqueci de enviar a última versão e agora você precisa refazer dois dias de trabalho neste novo arquivo”;\nPatrícia, Ruanna e Nathalie trabalharam ao mesmo tempo em um script e precisam mesclar manualmente suas alterações;\nDuas pessoas tentam modificar o mesmo arquivo no Dropbox e no Sharepoint e isso cria um erro de sincronização.\n\n\nIsso parece complicado, não sou um programador\nPode ser. Exemplos de usos avançados podem ser bastante assustadores. No entanto, assim como no R, ou mesmo no Excel, você não precisa se tornar um especialista para aproveitar os benefícios da ferramenta. Aprender um pequeno número de funções e noções permite rastrear suas alterações, sincronizar seus arquivos em um repositório online e colaborar com seus colegas em um período de tempo muito curto.\nDevido à curva de aprendizado, o contexto de emergência pode não ser o melhor momento para aprender essas ferramentas. Mas o aprendizado pode ser alcançado por etapas. Depois de adquirir algumas noções, seu fluxo de trabalho pode ser bastante eficiente e rápido.\nUm bom momento para adquirir confiança no uso do Git, na verdade, é quando você não está trabalhando em um projeto que precise dele, quando trabalhar em colaboração não é uma necessidade.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Controle de versão e colaboração com Git e Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.pt.html#configuração",
    "href": "new_pages/collaboration.pt.html#configuração",
    "title": "46  Controle de versão e colaboração com Git e Github",
    "section": "46.3 Configuração",
    "text": "46.3 Configuração\n\nInstale o Git\nGit é o mecanismo por trás dos bastidores do seu computador, que rastreia alterações, ramos (versões), mesclagens e reversões. Você deve primeiro instalar o Git em https://git-scm.com/downloads.\n\n\nInstale uma interface (opcional, mas recomendado)\nGit tem sua própria linguagem de comandos, que pode ser digitada em um terminal de linha de comando. No entanto, existem muitos clientes / interfaces e, não sendo um desenvolvedor, você raramente precisará interagir diretamente com o Git na sua rotina. As interfaces geralmente fornecem boas ferramentas de visualização para modificações ou ramificações de arquivos.\nExistem muitas opções, em todos os sistemas operacionais, desde iniciantes até os mais complexos. Boas opções para iniciantes incluem o painel RStudio Git e Github Desktop, que mostraremos neste capítulo. Opções intermediárias (mais poderosas, mas mais complexas) incluem Source Tree, Gitkracken, Smart Git e outras.\nExplicação rápida sobre Clientes Git.\nObservação: como todas as interfaces usam o Git internamente, você pode tentar várias delas, alternar de uma para outra em um determinado projeto, usar o console pontualmente para uma ação que sua interface não suporta ou até mesmo realizar algumas ações online no Github.\nConforme observado abaixo, você pode ocasionalmente ter que escrever comandos Git em um terminal, como o painel RStudio (uma aba do Console R) ou o terminal Git Bash.\n\n\nConta Github\nInscreva-se para uma conta gratuita em github.com.\nPode ser solicitado que você configure a autenticação de dois fatores com um aplicativo em seu telefone. Leia mais em nos documentos de ajuda do Github.\nSe você usa o Github Desktop, pode inserir suas credenciais do Gitub após a instalação seguindo estas etapas. Se você não fizer isso agora, as credenciais serão solicitadas mais tarde, quando você tentar clonar um projeto do Github.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Controle de versão e colaboração com Git e Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.pt.html#vocabulário-conceitos-e-funções-básicas",
    "href": "new_pages/collaboration.pt.html#vocabulário-conceitos-e-funções-básicas",
    "title": "46  Controle de versão e colaboração com Git e Github",
    "section": "46.4 Vocabulário, conceitos e funções básicas",
    "text": "46.4 Vocabulário, conceitos e funções básicas\nAssim como ao aprender R, há um pouco de vocabulário que você precisará lembrar para entender o Git. Aqui estão os princípios básicos para você começar e um tutorial interativo. Nas próximas seções, mostraremos como usar interfaces, mas é bom ter o vocabulário do Git e os conceitos em mente, para construir seu modelo mental. Você precisará deles ao usar interfaces de qualquer maneira.\n\nRepositório\nUm repositório Git (“repo”) é uma pasta que contém todas as subpastas e arquivos do seu projeto (dados, códigos, imagens etc.), além dos seus históricos de revisão. Quando você começar a rastrear as alterações no repositório com o Git, ele criará uma pasta oculta que contém todas as informações de rastreamento. Um repositório Git típico é a pasta Projeto R (consulte a página do manual em Projetos R).\nMostraremos como criar (inicializar) um repositório Git a partir do Github, Github Desktop ou Rstudio nas próximas seções.\n\n\nCommits ()\nUm commit é um snapshot do projeto, ou seja, uma foto instantânea de um determinado momento. Ao fazer uma alteração no projeto, você fará um novo commit para rastrear as alterações (o delta) feitas em seus arquivos. Por exemplo, talvez você tenha editado algumas linhas de código e atualizado um conjunto de dados. Depois que suas alterações forem salvas, você pode agrupar essas alterações em um “commit”.\nCada commit possui um ID exclusivo (um hash). Para fins de controle de versão, você pode recuperar seu projeto no tempo com base em commits, então é melhor mantê-los relativamente pequenos e coerentes. Você também anexará uma breve descrição das mudanças, chamada de “mensagem de confirmação”.\nMudanças graduais? Preparar mudanças é adicioná-las à área de teste, em preparação para o próximo commit. A ideia é que você possa decidir com precisão quais alterações incluir em um determinado commit. Por exemplo, se você trabalhou na especificação do modelo em um script e, posteriormente, trabalhou em uma figura em outro script, faria sentido ter dois commits diferentes (seria mais fácil no caso de você querer reverter as mudanças na figura, mas não o modelo).\n\n\nBranches (Ramos)\nUm branch representa uma linha independente de mudanças em seu repo, uma versão paralela e alternativa de seus arquivos de projeto.\nBranches são úteis para testar mudanças antes de serem incorporadas ao branch principal, que geralmente é a versão primária / final / “ativa” do seu projeto. Quando você terminar de experimentar em um branch, você pode trazer as alterações para o seu branch principal, mesclando, ou excluí-lo, se as alterações não foram tão bem-sucedidas.\nObservação: você não precisa colaborar com outras pessoas para usar branches, nem precisa ter um repositório online remoto.\n\n\nRepositórios locais e remotos\nClonar é criar uma cópia de um repositório Git em outro lugar.\nPor exemplo, você pode clonar um repositório online do Github localmente em seu computador, ou começar com um repositório local e cloná-lo online para Github.\nQuando você clona um repositório, os arquivos do projeto ficam em dois lugares:\n\nno repositório LOCAL, em seu computador físico. É aqui que você faz as mudanças reais nos arquivos / códigos.\nno repositório online REMOTO: versões dos seus arquivos de projeto no repositório Github (ou em qualquer outro site hospedeiro).\n\nPara sincronizar esses repositórios, usaremos mais funções. Na verdade, ao contrário do Sharepoint, Dropbox ou outro software de sincronização, o Git não atualiza automaticamente seu repositório local baseado naquele que está online ou vice-versa. Você pode escolher quando e como sincronizar.\n\ngit fetch baixa as novas mudanças do repositório remoto, mas não muda seu repositório local. Pense nela como uma verificação de estado do repositório remoto.\ngit pull baixa as novas mudanças dos repositórios remotos e atualiza seu repositório local.\nQuando você tiver feito um ou vários commits localmente, você pode usar git push para atualizar os commits no repositório remoto. Isso envia suas alterações no Github para que outras pessoas possam vê-las e acessá-las, se quiserem.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Controle de versão e colaboração com Git e Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.pt.html#começar-crie-um-novo-repositório",
    "href": "new_pages/collaboration.pt.html#começar-crie-um-novo-repositório",
    "title": "46  Controle de versão e colaboração com Git e Github",
    "section": "46.5 Começar: crie um novo repositório",
    "text": "46.5 Começar: crie um novo repositório\nExistem muitas maneiras de criar novos repositórios. Você pode fazer isso no console, no Github, em uma interface.\nDuas abordagens gerais são:\n\nCriar um novo Projeto R a partir de um repositório Github novo ou existente (sugerido para iniciantes);\nCriar um repositório Github para um projeto R existente.\n\n\nArquivos iniciais\nAo criar um novo repositório, você pode opcionalmente criar todos os arquivos abaixo ou pode adicioná-los ao seu repositório em um estágio posterior. Eles normalmente ficam na pasta “raiz” do repositório.\n-Um arquivo README é um arquivo que alguém pode ler para entender por que seu projeto existe e o que mais precisar saber para usá-lo. Ele estará vazio no início, mas você deve preenchê-lo mais tarde.\n\nUm arquivo .gitignore é um arquivo de texto em que cada linha contém pastas ou arquivos que o Git deve ignorar (não rastrear alterações). Leia mais sobre ele e veja exemplos aqui.\nVocê pode escolher uma licença para o seu trabalho, para que outras pessoas saibam em quais condições podem usar ou reproduzir ele. Para obter mais informações, consulte as Licenças Creative Commons.\n\n\n\nCriar um novo repositório no Githubb\nPara criar um novo repositório, faça login no Github e procure o botão verde para criar um novo repositório. Este repositório agora vazio pode ser clonado localmente em seu computador (consulte a próxima seção).\n\n\n\n\n\n\n\n\n\nVocê deve escolher se deseja que seu repositório seja público, ou seja, visível para todos na internet, ou privado, visível apenas para aqueles com permissão. Isso tem implicações importantes se seus dados forem confidenciais. Se o seu repositório for privado, você encontrará certas circunstâncias especiais avançadas, como se estiver usando as actions do Github para executar automaticamente o seu código na nuvem.\n\n\nClonar de um repositório Github\nVocê pode clonar um repositório Github existente para criar um novo projeto R local em seu computador.\nO repositório Github pode ser algum que já existe (com conteúdo) ou pode ser um repositório vazio que você acabou de criar. Neste último caso, você está essencialmente criando o repositório Github e o projeto R local ao mesmo tempo (consulte as instruções acima).\nObservação: se você não possui direitos de contribuição em um repositório Github, é possível primeiro bifurcar o repositório para o seu perfil, e então prosseguir com as outras ações. A bifurcação é explicada no final deste capítulo, mas recomendamos que você leia as outras seções primeiro.\nEtapa 1: no Github, navegue até o repositório, clique no botão verde “Code” e copie a URL clone HTTPS (veja a imagem abaixo)\n\n\n\n\n\n\n\n\n\nA próxima etapa pode ser realizada em qualquer interface. Vamos ilustrar com o Rstudio desktop e com o Github.\n\nNo Rstudio\nNo RStudio, comece um novo projeto R clicando em File&gt;New Project&gt;Version Control&gt;Git\n\nQuando for solicitada a “URL do repositório”, cole a URL HTTPS do Github\n\nAtribua ao projeto R um nome curto e informativo\n\nEscolha onde o novo Projeto R será salvo localmente\n\nMarque “Abrir em nova sessão” e clique em “Criar projeto”\n\nAgora você está em um novo projeto RStudio local que é um clone do repositório Github. O projeto local e o repositório Github agora estão vinculados.\n\n\nNo Github Desktop\n\nClique em Arquivo &gt; Clonar um repositório\nSelecione a guia URL\nCole a URL HTTPS do Github na primeira caixa\nSelecione a pasta na qual deseja ter seu repositório local\nClique em “CLONE”\n\n\n\n\n\n\n\n\n\n\n\n\n\nNovo repositório Github a partir de um projeto R existente\nOutro cenário de configuração alternativo ocorre quando você tem um projeto R existente com conteúdo e deseja criar um repositório Github para ele.\n\nCrie um novo repositório Github vazio para o projeto (consulte as instruções acima)\n\nClone este repositório localmente (consulte as instruções HTTPS acima)\n\nCopie todo o conteúdo de seu projeto R pré-existente (códigos, dados, etc.) para este novo repositório vazio e local (Ex.: use copiar e colar).\n\nAbra seu novo projeto no RStudio e vá para o painel Git. Os novos arquivos devem estar registrados como alterações de arquivo, agora rastreados pelo Git. Portanto, você pode agrupar essas alterações como um commit e enviar para o Github. Uma vez enviado, o repositório no Github refletirá todos os arquivos.\n\nConsulte a seção de fluxo de trabalho do Github abaixo para obter detalhes sobre esse processo.\n\n\nComo aparecem agora?\n\nNo RStudio\nDepois de clonar um repositório Github para um novo projeto R, você verá no RStudio uma guia “Git”. Esta guia aparece no mesmo painel RStudio que seu “ambiente”Environment” R:\n\n\n\n\n\n\n\n\n\nObserve os botões circulados na imagem acima, pois eles serão comentados a seguir (da esquerda para a direita):\n\nBotão commit para confirmar as alterações do arquivo salvo no branch local (isso abrirá uma nova janela)\nSeta azul para extrair (atualize sua versão local do branch com quaisquer alterações feitas na versão Github (remota) desse branch)\nSeta verde para enviar (atualize quaisquer commits / alterações da sua versão local do branch para a versão Github (remota) desse branch)\nA guia Git no RStudio\nBotão para criar um NOVO branch usando qualquer branch local (mostrado à direita como base). Quase sempre você criará um branch a partir do branch principal (depois de extrair pela primeira vez para atualizar o branch principal)\nO branch que você está trabalhando no momento\nAlterações feitas no código ou em outros arquivos aparecerão abaixo\n\n\n\nNo Github Desktop\nGithub Desktop é um aplicativo independente que permite gerenciar todos os seus repositórios. Ao abri-lo, a interface permite que você escolha o repositório no qual deseja trabalhar e, a seguir, executar ações básicas do Git a partir dele.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Controle de versão e colaboração com Git e Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.pt.html#fluxo-de-trabalho-git-github",
    "href": "new_pages/collaboration.pt.html#fluxo-de-trabalho-git-github",
    "title": "46  Controle de versão e colaboração com Git e Github",
    "section": "46.6 Fluxo de trabalho Git + Github",
    "text": "46.6 Fluxo de trabalho Git + Github\n\nVisão geral do processo\nDepois de concluir a configuração (descrita acima), você terá um repositório Github conectado (clonado) a um projeto R local. O branch principal (criado por padrão) é a versão chamada “ao vivo” de todos os arquivos. Quando você quiser fazer modificações, é uma boa prática criar um novo branch a partir do branch principal (“Fazer uma cópia”). Este é um fluxo de trabalho típico no Git porque criar um branch é fácil e rápido.\nUm fluxo de trabalho típico é o seguinte:\n\nCertifique-se de que seu repositório local está atualizado e, se não estiver, atualize;\nVá para o branch em que você estava trabalhando anteriormente ou crie um novo branch para testar algumas coisas\nTrabalhe nos arquivos localmente em seu computador, faça um ou vários commits para este branch\nAtualize a versão remota da filial com suas alterações (enviar)\nQuando estiver satisfeito com seu branch, você pode mesclar a versão online do branch que trabalhou para o branch “principal” on-line e, assim, transferir suas alterações\n\nOutros membros da equipe podem estar fazendo a mesma coisa com seus próprios branches, ou talvez contribuindo com commits no branch que você está trabalhando também.\nVamos repassar passo a passo do processo acima com mais detalhes abaixo. Aqui está um esquema que desenvolvemos - está no formato de uma tabela dois-por-dois, portanto, deve ajudar os epidemiologistas a entender.\n\n\n\n\n\n\n\n\n\nAqui está outro diagrama.\nObservação: até recentemente, o termo branch “master” era usado, mas agora é chamado de branch “main” (principal).\n\n\n\n\n\n\n\n\n\nFonte da imagem",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Controle de versão e colaboração com Git e Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.pt.html#crie-um-novo-branch",
    "href": "new_pages/collaboration.pt.html#crie-um-novo-branch",
    "title": "46  Controle de versão e colaboração com Git e Github",
    "section": "46.7 Crie um novo branch",
    "text": "46.7 Crie um novo branch\nQuando você seleciona um branch para trabalhar, Git redefine seu diretório de trabalho do jeito que estava da última vez que você esteve neste branch.\n\nNo painel Git no Rstudio\nCertifique-se de que está no branch “principal” e clique no ícone roxo para criar um novo branch (veja a imagem acima).\n\nVocê deverá nomear seu branch com uma única palavra (pode usar sublinhado, se necessário).\nVocê verá que localmente está no mesmo projeto R, mas não está mais trabalhando no branch “main”.\nDepois de criado, o novo branch também aparecerá no site do Github como um branch.\n\nVocê pode visualizar branches no painel Git no Rstudio depois de clicar em “Histórico”\n\n\n\n\n\n\n\n\n\n\n\nNo Github Desktop\nO processo é muito semelhante, você deverá dar um nome ao seu branch. Depois, você será solicitado a “Publicar seu branch no Github” para fazer o novo branch aparecer no repositório remoto também.\n\n\n\n\n\n\n\n\n\n\n\nNo console\nO que realmente está acontecendo nos bastidores é que você cria um novo branch com git branch, então vai para o branch comgit checkout (_isto é, diga ao Git que seus próximos commits ocorrerão lá). Do seu repositório git:\n\ngit branch my-new-branch  # Cria o novo branch\ngit checkout my-new-branch # Vai para o branch\ngit checkout -b my-new-branch # Os dois ao mesmo tempo (atalho)\n\nPara obter mais informações sobre como usar o console, consulte a seção sobre comandos Git no final.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Controle de versão e colaboração com Git e Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.pt.html#confirmar-alterações",
    "href": "new_pages/collaboration.pt.html#confirmar-alterações",
    "title": "46  Controle de versão e colaboração com Git e Github",
    "section": "46.8 Confirmar alterações",
    "text": "46.8 Confirmar alterações\nAgora você pode editar o código, adicionar novos arquivos, atualizar conjuntos de dados, etc.\nCada uma de suas alterações será rastreada, uma vez que o respectivo arquivo for salvo. Os arquivos alterados irão aparecer na aba Git do RStudio, no Github , ou usando o comando git status no terminal (veja abaixo).\nSempre que você fizer alterações substanciais (Ex.:, adicionar ou atualizar uma seção de código), pare e confirme essas alterações (commit). Pense em um commit como um “lote” de mudanças relacionadas a um propósito comum. Você poderá continuar revisan um arquivo mesmo após ter confirmado as alterações nele.\nConselhos sobre commits: geralmente, é melhor fazer pequenos commits, que podem ser facilmente revertidos se um problema surgir, para confirmar modificações diferentes relacionadas a um mesmo propósito. Para isso, você descobrirá que deve criar commits com frequência. No início, você provavelmente vai esquecer, mas logo desenvolverá o hábito.\n\nNo Rstudio\nO exemplo abaixo mostra que, desde o último commit, o script R Markdown “Collaboration.Rmd” mudou, e várias imagens PNG foram adicionadas.\n\n\n\n\n\n\n\n\n\nVocê pode estar se perguntando o que representam os quadrados amarelos, azuis, verdes e vermelhos próximos aos nomes dos arquivos. Aqui está uma parte do Cheatsheet RStudio que explica seu significado. Mudanças com o quadrado amarelo (“?”) ainda podem ser preparadas, confirmadas e enviadas.\n\n\n\n\n\n\n\n\n\n\nPressione o botão “Commit” na guia Git, que abrirá uma nova janela (reproduzida abaixo)\nClique no nome de um arquivo na caixa superior esquerda\nRevise as alterações feitas no arquivo (destacadas abaixo em verde ou vermelho)\n“Prepare” o arquivo, que incluirá essas mudanças no commit. Faça isso marcando a caixa ao lado do nome do arquivo. Como alternativa, você pode destacar vários nomes de arquivo e clicar em “Stage”\nEscreva uma mensagem de confirmação que seja curta, mas descritiva (obrigatório)\nPressione o botão “Commit”. Uma caixa pop-up aparecerá mostrando o sucesso ou uma mensagem de erro.\n\nAgora você pode fazer mais alterações e mais commits, quantas vezes quiser\n\n\n\n\n\n\n\n\n\n\n\nNo Github Desktop\nVocê pode ver a lista dos arquivos que foram alterados à esquerda. Se você selecionar um arquivo de texto, verá um resumo das modificações feitas no painel direito (a visualização não funcionará em arquivos mais complexos como .docs ou .xlsx).\nPara fazer as alterações, basta marcar a caixa ao lado dos nomes dos arquivos. Quando você tiver selecionado os arquivos que deseja adicionar a este commit, dê um nome ao commit, uma descrição (opcional) e clique no botão commit.\n\n\n\n\n\n\n\n\n\n\n\nNo console\nSão usadas as funções git add para selecionar / preparar arquivos egit commit para realmente fazer o commit.\n\ngit status #veja as mudanças \n\ngit add new_pages/collaboration.Rmd  # selecione arquivos para o commit (= \"stage\" mudanças)\n\ngit commit -m \"Describe commit from Github Desktop\" # confirme mudanças com uma mensagem\n\ngit log  # veja informações sobre commits anteriores\n\n\n\nCorrigir um commit anterior\nO que acontece se você fizer o commit de algumas alterações, continuar trabalhando e perceber que fez alterações que deveriam “pertencer” ao commit anterior (na sua opinião)? Está tudo bem! Você pode anexar essas alterações ao seu commit anterior.\nNo Rstudio há uma caixa “Corrigir commit anterior” na mesma linha do botão COMMIT.\nPor alguma razão, esta funcionalidade não foi implementada da mesma forma no Github Desktop, mas há uma maneira de contornar (estranha, mas fácil!). Se você tiver confirmado suas alterações mas não enviado ainda, um botão “UNDO” aparecerá logo abaixo do botão COMMIT. Clique nele e ele irá reverter seu commit (mas mantenha seus arquivos preparados e sua mensagem de commit). Salve suas mudanças, adicione novos arquivos ao commit se necessário e faça o commit novamente.\nNo console:\n\ngit add [SEUS ARQUIVOS] # Prepare suas novas mudanças\n\ngit commit --amend  # Corrija o commit anteriororrigir o commit anterior\n\ngit commit --amend -m \"An updated commit message\"  # Corrija o commit anterior E atualize a mensagem de commit\n\nObservação: pense antes de modificar commits que já são públicos e compartilhados com seus colaboradores.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Controle de versão e colaboração com Git e Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.pt.html#pull-baixarextrair-e-push-enviarsubir-alterações-para-o-github",
    "href": "new_pages/collaboration.pt.html#pull-baixarextrair-e-push-enviarsubir-alterações-para-o-github",
    "title": "46  Controle de versão e colaboração com Git e Github",
    "section": "46.9 Pull (baixar/extrair) e Push (enviar/subir) alterações para o Github",
    "text": "46.9 Pull (baixar/extrair) e Push (enviar/subir) alterações para o Github\n“Primeiro PULL, depois PUSH”\nÉ uma boa prática fetch (buscar) e pull (baixar) antes de começar a trabalhar no seu projeto, para atualizar a versão do branch em seu computador local com quaisquer alterações que tenham sido feitas na versão remota / Github.\nPULL frequentemente. Não hesite. Sempre faça um pull antes de fazer um push.\nQuando suas mudanças forem feitas e confirmadas e você estiver feliz com o seu projeto, você pode fazer um push dos seus commits para a versão remota / Github de seu branch.\nObservação: é muito mais fácil desfazer alterações que foram confirmadas, mas não enviadas (ou seja, ainda são locais) do que alterações que foram enviadas para o repositório remoto (e talvez já extraídas por outra pessoa), por isso é melhor enviar quando terminar de introduzir mudanças no estava trabalhando.\n\nNo Rstudio\nPULL - Primeiro, clique no ícone “Pull” (seta azul para baixo) que busca e extrai ao mesmo tempo.\nPUSH - Clique no ícone “Pull” (seta verde para cima). Pode ser necessário inserir seu nome de usuário e senha do Github. Na primeira vez que você for solicitado, pode ser necessário inserir duas linhas de comando Git no Terminal:\n\ngit config –global user.email “voce@exemplo.com” (seu endereço de email Github), e\n\ngit config –global user.name “Seu nome de usuário Github”\n\nPara saber mais sobre como inserir esses comandos, consulte a seção abaixo sobre comandos Git.\nDICA: Sua senha está sendo solicitada com muita frequência? Veja os capítulos 10 e 11 deste tutorial para se conectar a um repositório usando uma chave SSH (mais complicado)\n\n\nNo Github Desktop\nClique no botão “Buscar origem” para verificar se há novos commits no repositório remoto.\n\n\n\n\n\n\n\n\n\nSe o Git encontrar novos commits no repositório remoto, o botão mudará para um botão “Pull”. Como o mesmo botão é usado para fazer o pull (baixar/extrair) e fazer o push (subir/enviar), você não pode enviar suas alterações se não fizer o pull antes.\n\n\n\n\n\n\n\n\n\nVocê pode ir para a guia “Histórico” (perto da guia “Alterações”) para ver todos os commits (seus e dos outros). Essa é uma ótima maneira de se familiarizar com o que seus colaboradores fizeram. Você pode ler a mensagem de confirmação, a descrição, se houver, e comparar o código dos dois arquivos usando o painel diff.\n\n\n\n\n\n\n\n\n\nUma vez que todas as mudanças remotas tenham sido extraídas, e pelo menos uma mudança local tenha sido confirmada, você pode enviar clicando no mesmo botão.\n\n\n\n\n\n\n\n\n\n\n\nConsole\nComo esperado, os comandos são fetch, pull e push .\n\ngit fetch  # Existem novos commits no diretório remoto?\ngit pull   # Traga commits remotos para seu branch local\ngit push   # Envie commits locais deste branch para o branch remoto\n\n\n\nQuero fazer um pull, mas tenho trabalho local\nIsso pode acontecer às vezes: você fez algumas mudanças em seu repositório local, mas o repositório remoto tem commits que você não extraiu.\nO Git se recusará a fazer um pull porque pode sobrescrever suas alterações. Existem várias estratégias para manter suas mudanças, bem descritas em Happy Git with R, entre as quais as duas principais são:\n\nconfirme suas alterações, busque alterações remotas, extraia elas, resolva conflitos, se necessário (consulte a seção abaixo), e coloque tudo online\nstash suas alterações, que meio que as armazena à parte, extrai, restaura (“unstash”) e então efetua o commit, resolvendo quaisquer conflitos e envia.\n\nSe não houver sobreposição entre os arquivos das mudanças remotas e os arquivos das mudanças locais, o Git pode resolver os conflitos automaticamente.\nNo Github Desktop, isso pode ser feito com botões. Para isso, vá até Branch&gt; Stash all changes.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Controle de versão e colaboração com Git e Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.pt.html#mesclar-no-branch-principal",
    "href": "new_pages/collaboration.pt.html#mesclar-no-branch-principal",
    "title": "46  Controle de versão e colaboração com Git e Github",
    "section": "46.10 Mesclar no branch principal",
    "text": "46.10 Mesclar no branch principal\nSe você concluiu as alterações, pode iniciar o processo de mesclagem dessas alterações no branch principal. Dependendo da situação, isso pode ser rápido ou contemplar etapas acordadas de revisão e aprovação envolvendo colegas da sua equipe.\n\nLocalmente no Github Desktop\nÉ possível mesclar branches localmente usando o Github Desktop. Primeiro, vá até o branch que será o destinatário dos commits, ou seja, o branch que você deseja atualizar. Em seguida, clique em Branch &gt; Merge into current branch. Uma caixa permitirá que você selecione o branch que deseja importar.\n\n\n\n\n\n\n\n\n\n\n\nNo console\nPrimeiro, volte para o branch que receberá as alterações. Geralmente é o master, mas pode ser outro branch. Em seguida, mescle seu branch de trabalho no master.\n\ngit checkout master  # Volte para o master (ou para o branch que você deseja mover)\ngit merge this_fancy_new_branch\n\nEsta página mostra um exemplo mais avançado de branching e explica um pouco como funciona nos bastidores.\n\n\nNo Github: submeter uma requisição de pull\nEmbora seja totalmente possível mesclar dois branches localmente, ou sem informar ninguém, uma mesclagem pode ser discutida ou investigada por várias pessoas antes de ser integrada ao branch master. Para ajudar no processo, o Github oferece alguns recursos de discussão sobre a mesclagem: a solicitação de pull.\nUma solicitação de pull (um “PR”, do inglês pull request) é uma solicitação para mesclar um branch em outro (em outras palavras, uma solicitação para que _seu branch de trabalho seja extraído para o branch “main”). Uma solicitação de extração geralmente envolve vários commits e inicia uma conversa, um processo de revisão, antes de ser aceita e o branch ser mesclado. Por exemplo, você pode ler as discussões de solicitação de extração no github do dplyr.\nVocê pode enviar uma solicitação de pull (PR) diretamente do site (conforme ilustrado abaixo) ou do Github Desktop.\n\nVá para o repositório Github (online)\nVisualize a guia “Solicitações de pull” e clique no botão “Nova solicitação de pull”\nSelecione no menu suspenso para mesclar seu branch no branch principal (main)\nEscreva um comentário detalhado sobre o Pull Request e clique em “Criar Pull Request”.\n\n\n\n\n\n\n\n\n\n\nAgora você será capaz de ver a solicitação pull (exemplo na imagem abaixo):\n\nRevise a guia “Arquivos alterados” para ver como o branch “main” mudaria se o branch fosse mesclado.\n\nÀ direita, você pode solicitar uma revisão dos colaboradores da sua equipe marcando seus IDs no Github. Se desejar, você pode definir as configurações do repositório para exigir uma revisão de aprovação antes de mesclar com o main.\n\nAssim que a solicitação pull for aprovada, um botão para “Mesclar solicitação pull” ficará ativo. Clique nele.\n\nDepois de concluído, exclua seu branch conforme explicado abaixo.\n\n\n\n\n\n\n\n\n\n\n\n\nResolvendo conflitos\nQuando duas pessoas modificam a (s) mesma (s) linha (s) ao mesmo tempo, surge um conflito de mesclagem. Na verdade, o Git se recusa a tomar uma decisão sobre qual versão manter, mas ajuda a descobrir onde está o conflito. NÃO ENTRE EM PÂNICO. Na maioria das vezes, é muito simples de resolver.\nPor exemplo, no Github:\n\n\n\n\n\n\n\n\n\nApós a mesclagem gerar um conflito, abra o arquivo em seu editor favorito. O conflito será indicado por uma série de caracteres:\n\n\n\n\n\n\n\n\n\nO texto entre &lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD e ======= vem do seu repositório local, já o texto entre ======= e &gt;&gt;&gt;&gt;&gt;&gt;&gt; vem do outro branch (que pode ser o original, o master ou qualquer branch de sua escolha).\nVocê precisa decidir qual versão do código prefere (ou até mesmo escrever uma terceira, incluindo alterações de ambos os lados, se pertinente), excluir o resto e remover todas as marcas que o Git adicionou (&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD,=======,&gt;&gt;&gt;&gt;&gt;&gt;&gt;origin/master/your_branch_name).\nEntão, salve, prepare e submeta o arquivo: este é o commit que torna a versão mesclada “oficial”. Não se esqueça de enviar depois.\nQuanto mais você e seus colaboradores puxarem e empurrarem, menores serão os conflitos.\nObservação: se você se sentir à vontade com o console, há mais opções avançadas de mesclagem (Ex.: ignorando espaços em branco, dando prioridade a um colaborador, etc.). \n\n\nDelete seu branch\nDepois que um branch foi mesclado com o master e não for mais necessário, você pode excluí-lo.\n\n46.10.0.1 Github + Rstudio\nVá até o repositório no Github e clique no botão para ver todos os branches (próximo ao menu suspenso para selecionar branches). Agora encontre seu branch e clique no ícone de lixeira próximo a ele. Leia mais detalhes sobre como excluir um branch aqui.\nCertifique-se de excluir também o branch local no seu computador. Isso não acontecerá automaticamente.\n\nNo RStudio, certifique-se de estar no branch principal\nPasse a digitar comandos Git no “Terminal” do RStudio (a guia adjacente ao console R) e digite: git branch -d nome_do_branch , onde “nome_do_branch” é o nome do seu branch a ser excluído\nAtualize sua guia Git e o branch terá desaparecido\n\n\n\n46.10.0.2 No Github Desktop\nBasta verificar o branch que deseja excluir e ir até o menu Branch&gt;Delete.\n\n\n\nForking\nVocê pode bifurcar um projeto (fork) se desejar contribuir com ele mas não tiver os direitos ou se desejar modificá-lo apenas para seu uso pessoal. Uma breve descrição da bifurcação pode ser encontrada aqui.\nNo Github, clique no botão “Fork”:\n\n\n\n\n\n\n\n\n\nIsso irá clonar o repositório original no seu próprio perfil. Agora, existem duas versões do repositório no Github: a original, que você não pode modificar, e a versão clonada no seu perfil.\nEm seguida, você pode clonar sua versão do repositório online localmente no seu computador, usando qualquer um dos métodos descritos nas seções anteriores. A partir de então, você poderá criar um novo branch, fazer mudanças, submetê-las e enviá-las para o seu repositório remoto.\nQuando estiver satisfeito com o resultado, você pode criar um “Pull Request” do Github ou Github Desktop para iniciar a conversa com os proprietários / responsáveis pelo repositório original.\nE se você precisar de alguns commits mais recentes do repositório original?\nImagine que alguém faça uma modificação substancial no repositório oficial, que você deseja incluir em sua versão clonada. É possível sincronizar sua bifurcação (fork) com o repositório oficial. Envolve o uso do terminal, mas não é tão complicado. Você precisa se lembrar principalmente que: - upstream = repositório oficial, aquele que você não pode modificar - origin = sua versão do repositório em seu perfil Github\nVocê pode ler este tutorial ou seguir o caminho abaixo:\nPrimeiro, digite seu terminal Git (dentro de seu reposositório):\n\ngit remote -v\n\nSe você ainda não configurou o repositório upstream, deverá ver duas linhas, começando por origin. Eles mostram o repositório remoto para o qual fetch epush estão direcionados. Lembre-se, por convenção, origin é sua própria versão do repositório no Github. Por exemplo:\n\n\n\n\n\n\n\n\n\nAgora, adicione um novo repositório remoto:\n\ngit remote add upstream https://github.com/appliedepi/epirhandbook_eng.git\n\nAqui, o site é o endereço que o Github gera quando você clona um repositório (consulte a seção sobre clonagem). Agora você terá quatro ponteiros remotos:\n\n\n\n\n\n\n\n\n\nAgora que a configuração está feita, sempre que você quiser obter as alterações do repositório original (upstream), você só precisa ir (checkout) ao branch que deseja atualizar e digitar:\n\ngit fetch upstream # Para obter os novos commits do repositório remoto\ngit checkout the_branch_you_want_to_update\ngit merge upstream/the_branch_you_want_to_update  # Para mesclar o branch upstream em seu branch\ngit push # Para atualizar sua própria versão do repositório remoto\n\nSe houver conflitos, você terá que resolvê-los, conforme explicado na seção Resolvendo conflitos.\nResumo: bifurcar é clonar, mas no servidor Github. O restante das ações são ações típicas do fluxo de trabalho de colaboração (clonar, enviar, puxar, confirmar, mesclar, enviar solicitações pull …).\nObservação: a bifurcação é um conceito, não um comando Git, e também existe em outros sites de hospedagem, como Bitbucket.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Controle de versão e colaboração com Git e Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.pt.html#o-que-aprendemos",
    "href": "new_pages/collaboration.pt.html#o-que-aprendemos",
    "title": "46  Controle de versão e colaboração com Git e Github",
    "section": "46.11 O que aprendemos",
    "text": "46.11 O que aprendemos\nVocê aprendeu como:\n\nconfigurar o Git para rastrear modificações em suas pastas,\nconectar seu repositório local a um repositório online remoto,\nconfirmar alterações,\nsincronizar seus repositórios locais e remotos.\n\nIsso deve ajudá-lo e ser suficiente para a maioria de suas demandas como epidemiologista. Normalmente não temos um uso tão avançado quanto os desenvolvedores.\nNo entanto, se você quiser (ou precisar) ir além, o Git oferece funcionalidades para simplificar históricos de commits, reverter um ou vários commits, selecionar commits, etc. Alguns deles podem soar como pura magia, mas agora que você já sabe o básico, será mais fácil avançar.\nObserve que embora o painel Git no Rstudio e no Github Desktop sejam bons para iniciantes ou para uso diário no trabalho, eles não oferecem interface para algumas das funções intermediárias e avançadas do Git. Algumas interfaces mais completas permitem fazer mais com cliques (geralmente ao custo de um layout mais complexo).\nLembre-se que você pode usar qualquer ferramenta para rastrear seu repositório, então pode instalar uma outra interface para experimentá-la algumas vezes, ou para realizar alguma tarefa complexa não tão comum no seu trabalho, e continuar usando uma interface simplificada para o resto do tempo (por exemplo, usando Github Desktop na maioria das vezes e mudando para SourceTree ou Gitbash para algumas tarefas específicas).",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Controle de versão e colaboração com Git e Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.pt.html#git",
    "href": "new_pages/collaboration.pt.html#git",
    "title": "46  Controle de versão e colaboração com Git e Github",
    "section": "46.12 Comandos Git",
    "text": "46.12 Comandos Git\n\nAprendizados recomendados\nPara aprender os comandos Git em um tutorial interativo, consulte este site.\n\n\nOnde inserir comandos\nVocê insere comandos em um shell Git.\nOpção 1 Você pode abrir um novo Terminal no RStudio. Esta guia está ao lado do R Console. Se você não conseguir digitar nenhum texto nele, clique no menu suspenso abaixo de “Terminal” e selecione “Novo terminal”. Digite os comandos no espaço em frente do cifrão “$”.\n\n\n\n\n\n\n\n\n\nOpção 2 Você também pode abrir um shell (um terminal para inserir comandos) clicando no ícone azul “engrenagens” na guia Git (próximo ao ambiente RStudio). Selecione “Shell” no menu suspenso. Uma nova janela será aberta onde você pode digitar os comandos após o cifrão “$”.\nOpção 3 Clique com o botão direito para abrir o “Git Bash aqui”, que abrirá o mesmo tipo de terminal, ou abra o Git Bash da sua lista de aplicativos. Mais informações para iniciantes no Git Bash, como encontrá-lo e alguns comandos bash que você precisará.\n\n\nAmostra de comandos\nAbaixo, apresentamos alguns comandos git comuns. Ao usá-los, lembre-se de qual branch está ativo (com check-out), pois isso mudará a ação!\nNos comandos abaixo,  representa o nome de um branch.  representa o ID de hash de um commit específico.  representa um número. Não digite os símbolos &lt; ou &gt;.\n\n\n\n\n\n\n\nComando Git\nAção\n\n\n\n\ngit branch &lt;nome&gt;\nCrie uma nova ramificação com o nome \n\n\ngit checkout &lt;nome&gt;\nMude o branch (ramificação) atual para \n\n\ngit checkout -b &lt;nome&gt;\nAtalho para criar um novo branch e mudar para ele\n\n\ngit status\nVeja as alterações não rastreadas\n\n\ngit add &lt;file&gt;\nPrepare um arquivo\n\n\ngit commit -m &lt;message&gt;\nConfirme as alterações (commit) preparadas para o branch atual com a mensagem\n\n\ngit fetch\nObter commits do repositório remoto\n\n\ngit pull\nExtraia commits do repositório remoto no branch atual\n\n\ngit push\nEnvie commits locais para o diretório remoto\n\n\ngit switch\nUma alternativa ao git checkout que está sendo implementado no Git\n\n\ngit merge &lt;nome&gt;\nMescle o branch  no branch atual\n\n\ngit rebase &lt;nome&gt;\nAnexar commits do branch atual para o branch",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Controle de versão e colaboração com Git e Github</span>"
    ]
  },
  {
    "objectID": "new_pages/collaboration.pt.html#recursos",
    "href": "new_pages/collaboration.pt.html#recursos",
    "title": "46  Controle de versão e colaboração com Git e Github",
    "section": "46.13 Recursos",
    "text": "46.13 Recursos\nGrande parte desta página foi baseada no site “Happy Git with R” de Jenny Bryan. Há uma seção muito útil neste site que ajuda a solucionar erros comuns relacionados ao Git e ao R.\nDocumentação do Github.com e guia de inicialização.\n“IDE” cheatsheet do RStudio que inclui dicas sobre o uso do Git com RStudio.\nhttps://ohi-science.org/news/github-going-back-in-time\nComandos Git para iniciantes\nUm tutorial interativo para aprender os comandos Git.\nhttps://www.freecodecamp.org/news/an-introduction-to-git-for-absolute-beginners-86fa1d32ff71/: “básico do básico” para rastrear alterações em uma pasta no seu próprio computador.\nEsquemas legais para entender os branches: https://speakerdeck.com/alicebartlett/git-for-humans\nTutoriais de assuntos básicos e avançados\nhttps://tutorialzine.com/2016/06/learn-git-in-30-minutes\nhttps://dzone.com/articles/git-tutorial-commands-and-operations-in-git\nhttps://swcarpentry.github.io/git-novice/ (short course)\nhttps://rsjakob.gitbooks.io/git/content/chapter1.html\n\nO livro Pro Git é considerado uma referência oficial. Mas embora alguns capítulos estejam ok, ele pode parecer um pouco técnico. Certamente será um bom recurso se você já tiver usado um pouco o Git e quiser aprender um pouco mais precisamente sobre o que acontece e como ir mais longe.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>46</span>  <span class='chapter-title'>Controle de versão e colaboração com Git e Github</span>"
    ]
  },
  {
    "objectID": "new_pages/errors.pt.html",
    "href": "new_pages/errors.pt.html",
    "title": "47  Erros comuns",
    "section": "",
    "text": "47.1 Interpretando mensagens de erro\nOs erros no R podem ser enigmáticos às vezes, então use o Google como seu amigo. Pesquise a mensagem de erro com “R” e procure as postagens recentes em StackExchange.com, stackoverflow.com, community.rstudio.com, twitter (#rstats) e outros fóruns de perguntas e respostas usados por programadores. Tente encontrar postagens recentes que resolveram problemas semelhantes.\nSe você não conseguir encontrar uma resposta para o seu problema, mesmo depois de pesquisar muito, considere criar um exemplo reprodutível (“reprex”, ou um MRE para Minimal Reproducible Exemple ) e postar a pergunta você mesmo. Consulte a página Obtendo ajuda para dicas sobre como criar e postar um exemplo reprodutível em fóruns.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Erros comuns</span>"
    ]
  },
  {
    "objectID": "new_pages/errors.pt.html#erros-comuns",
    "href": "new_pages/errors.pt.html#erros-comuns",
    "title": "47  Erros comuns",
    "section": "47.2 Erros comuns",
    "text": "47.2 Erros comuns\nAbaixo, listamos alguns erros comuns e potenciais explicações / soluções. Some of these are borrowed from Noam Ross who analyzed the most common forum posts on Stack Overflow about R error messages (see analysis here)\n\nErros de digitação\nError: unexpected symbol in:\n\"  geom_histogram(stat = \"identity\")+\n  tidyquant::geom_ma(n=7, size = 2, color = \"red\" lty\"\nSe você vir um “unexpected symbol” (símbolo inesperado), verifique se há vírgulas faltando\n\n\nErros de pacote\ncould not find function \"x\"...\nIsso provavelmente significa que você digitou o nome da função incorretamente ou esqueceu de instalar / carregar um pacote.\nError in select(data, var) : unused argument (var)\nVocê acha que está usando dplyr :: select () mas a função select () foi mascarada por MASS::select () - especifique dplyr :: ou reorganize o carregamento do pacote para que dplyr venha depois de todos os outros.\nOutros erros comuns de mascaramento vêm de: plyr::summarise() and stats::filter(). Considere usar o pacote conflicted package.\nError in install.packages : ERROR: failed to lock directory ‘C:\\Users\\Name\\Documents\\R\\win-library\\4.0’ for modifying\nTry removing ‘C:\\Users\\Name\\Documents\\R\\win-library\\4.0/00LOCK’\nSe você receber um erro dizendo que precisa remover um arquivo “00LOCK”, vá para a biblioteca “R” no diretório do seu computador (por exemplo, R/win-library/) e procure uma pasta chamada “00LOCK”. Exclua isso manualmente e tente instalar o pacote novamente. Provavelmente isso aconteceu porque um processo de instalação anterior foi interrompido.\n\n\nErros de objeto\nNo such file or directory:\nSe você encontrar um erro como este na exportação ou importação: Verifique a ortografia do arquivo e do caminho do arquivo. Se o caminho contém barras, certifique-se de que estão para frente / e não para trás \\. Certifique-se também de usar a extensão de arquivo correta (por exemplo, .csv, .xlsx).\nobject 'x' not found \nIsso significa que o objeto não existe. Talvez o código acima não tenha funcionado corretamente?\nError in 'x': subscript out of bounds\nIsso significa que você tentou acessar algo (um elemento de um vetor ou uma lista) que não estava lá.\n\n\nErros de sintaxe de função\n# ran recode without re-stating the x variable in mutate(x = recode(x, OLD = NEW)\nError: Problem with `mutate()` input `hospital`.\nx argument \".x\" is missing, with no default\ni Input `hospital` is `recode(...)`.\nO erro acima (argument \".x\" is missing, with no default) é comum em mutate() se você estiver fornecendo uma função como recode () ou replace_na(), pois espera-se que você forneça a coluna nome como primeiro argumento. Isso é fácil de esquecer.\n\n\nErros lógicos\nError in if\nIsso provavelmente significa que uma instrução if foi aplicada a algo que não era VERDADEIRO ou FALSO.\n\n\nErros de fator\n#Tried to add a value (\"Missing\") to a factor (with replace_na operating on a factor)\nProblem with `mutate()` input `age_cat`.\ni invalid factor level, NA generated\ni Input `age_cat` is `replace_na(age_cat, \"Missing\")`.invalid factor level, NA generated\nSe você encontrar este erro sobre níveis de fator inválidos, provavelmente tem uma coluna com uma variável do tipo fator (níveis predefinidos) e tentou adicionar um novo valor a ela. Converta-o para o tipo caracter antes de adicionar um novo valor.\n\n\nErros de plotagem\nError: Insufficient values in manual scale. 3 needed but only 2 provided. ggplot() scale_fill_manual() values = c(“orange”, “purple”) … insufficient for number of factor levels … consider whether NA is now a factor level…\nCan't add x object\nProvavelmente tem um + extra no final de um comando ggplot que você precisa excluir.\n\n\nErros de R Markdown\nSe a mensagem de erro contiver algo como Error in options[[sprintf(\"fig.%s\", i)]], verifique se as opções do knitr no topo de cada bloco usam adequadamente out.width = ou out.height = e não fig.width= e fig.height=.\n\n\nDiversos\nConsidere se você reorganizou os verbos dplyr e esqueceu de substituir um pipe (%&gt;%) no meio do código ou se esqueceu um pipe na extremidade após reorganizar.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Erros comuns</span>"
    ]
  },
  {
    "objectID": "new_pages/errors.pt.html#recursos",
    "href": "new_pages/errors.pt.html#recursos",
    "title": "47  Erros comuns",
    "section": "47.3 Recursos",
    "text": "47.3 Recursos\nEsta é outra postagem do blog que lista erros de programação R enfrentados por iniciantes",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>47</span>  <span class='chapter-title'>Erros comuns</span>"
    ]
  },
  {
    "objectID": "new_pages/help.pt.html",
    "href": "new_pages/help.pt.html",
    "title": "48  Conseguindo ajuda",
    "section": "",
    "text": "48.1 Issues (problemas) do Github\nMuitos pacotes e projetos R têm seu código hospedado no site Github.com. Você pode se comunicar diretamente com os autores através do site, postando um “Problema”.\nLeia mais sobre como armazenar seu trabalho no Github na página Colaboração e Github.\nNo Github, cada projeto está contido em um repositório. Cada repositório contém código, dados, saídas, documentação de ajuda etc. Existe também um veículo de comunicação com os autores denominado “Problemas”.\nVeja abaixo a página do Github para o pacote incidence2 (usado para fazer curvas epidêmicas). Você pode ver a guia “Issues” (Problemas, em imglês) destacada em amarelo. Você pode ver que existem 5 questões em aberto.\nNesta guia Issues você pode ver os problemas em aberto. Revise-os para garantir que seu problema não foi resolvido ainda. Você pode abrir um novo problema clicando no botão verde à direita. Para fazer isso, será necessário ter uma conta Github.\nSiga as instruções abaixo para fornecer um exemplo mínimo e reproduzível do seu problema. Por favor, seja educado(a)! A maioria das pessoas que desenvolve pacotes e projetos R estão fazendo isso no seu tempo livre (como este manual!).\nPara ler materiais mais avançados sobre como lidar com problemas no seu repositório, verifique a documentação sobre problemas do Github.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Conseguindo ajuda</span>"
    ]
  },
  {
    "objectID": "new_pages/help.pt.html#exemplo-reprodutível",
    "href": "new_pages/help.pt.html#exemplo-reprodutível",
    "title": "48  Conseguindo ajuda",
    "section": "48.2 Exemplo reprodutível",
    "text": "48.2 Exemplo reprodutível\nFornecer um exemplo reprodutível (“reprex”) é a chave para obter ajuda com sua postagem ou problema no Github. As pessoas querem ajudá-lo, mas você precisa dar um exemplo com o qual elas possam trabalhar em seus próprios computadores. O exemplo deve:\n\nDemonstrar o problema que você encontrou\n\nSer o mais curto possível, incluindo apenas os dados e o código necessário para reproduzir o seu problema\nSer reprodutível, de modo que todos os objetos (por exemplo, dados), e pacotes sejam incluídos (por exemplo, library() ou p_load())\n\nAlém disso, certifique-se de não postar nenhum dado sensível com o reprex! Você pode criar dataframes de exemplo ou usar um dos dataframes embutidos no R (insira data() para abrir uma lista desses conjuntos de dados).\n\nO pacote reprex\nO pacote reprex pode ajudá-lo a fazer um exemplo reprodutível:\n\nreprex é instalado com tidyverse, então carregue qualquer um dos pacotes\n\n\n# intale/carregue o tidyverse (que inclui o reprex)\npacman::p_load(tidyverse)\n\n\nInicie um script R que gere seu problema, passo a passo, começando com o carregamento de pacotes e dados.\n\n\n# carregar pacotes\npacman::p_load(\n     tidyverse,  # manipulação de dados e visualização\n     outbreaks)  # exemplos de dados de surtos \n\n# linelist lista dos casos da epidemia de gripe\noutbreak_raw &lt;- outbreaks::fluH7N9_china_2013  #recuperar conjunto de dados do pacote de surtos\n\n# Limpar conjunto de dados\noutbreak &lt;- outbreak_raw %&gt;% \n     mutate(across(contains(\"date\"), as.Date))\n\n# Visualizar epidemia\nggplot(data = outbreak)+\n     geom_histogram(\n          mapping = aes(x = date_of_onset),\n          binwidth = 7\n     )+\n  scale_x_date(\n    date_format = \"%d %m\"\n  )\n\nCopie todo o código para a área de transferência e execute o seguinte comando:\n\nreprex::reprex()\n\nVocê verá uma saída HTML aparecer no painel RStudio Viewer. Ele conterá todo o seu código e quaisquer avisos, erros ou resultados de plotagem. Essa saída também é copiada para sua área de transferência, para que você possa publicá-la diretamente em um problema do Github ou em uma postagem do fórum.\n\n\n\n\n\n\n\n\n\n\nSe você definir session_info = TRUE, a saída de sessioninfo ::session_info() incluírá suas versões do R e dos pacotes R\nVocê pode fornecer um diretório de trabalho para wd =\nVocê pode ler mais sobre os argumentos e possíveis variações em documentation ou inserindo ?Reprex\n\nNo exemplo acima, o comando ggplot() não rodou porque o argumento date_format = não está correto - deveria ser date_labels =.\n\n\nDados mínimos\nAs pessoas que vão te ajudar precisam ser capazes de usar seus dados - de preferência, eles precisam ser capazes de criá-los com código.\nPara criar um conjunto de dados mínimos, considere anonimizar e usar apenas um subconjunto das observações.\nEM CONSTRUÇÃO - você também pode usar a função dput() para criar um conjunto mínimo de dados.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Conseguindo ajuda</span>"
    ]
  },
  {
    "objectID": "new_pages/help.pt.html#postar-em-um-fórum",
    "href": "new_pages/help.pt.html#postar-em-um-fórum",
    "title": "48  Conseguindo ajuda",
    "section": "48.3 Postar em um fórum",
    "text": "48.3 Postar em um fórum\nLeia muitas postagens do fórum. Entenda quais postagens são bem escritas e quais não são.\n\nPrimeiro, decida se deseja fazer a pergunta. Você revisou extensivamente o site do fórum, tentando vários termos de pesquisa, para ver se sua pergunta já foi feita?\nDê um título informativo à sua pergunta (não algo como “Socorro! Isso não está funcionando!”).\nEscreva sua pergunta:\n\n\nApresente sua situação e problema\nFaça um link com postagens de problemas semelhantes e explique porque eles não responderam à sua pergunta\nInclua qualquer informação relevante para ajudar alguém que não conhece o contexto do seu trabalho\nDê um exemplo reprodutível mínimo com as informações do seu trabalho\nUse ortografia, gramática e pontuação adequadas e divida sua pergunta em parágrafos para que seja mais fácil de ler\n\n\nDepois de postar, monitore sua pergunta para responder a qualquer pedido de esclarecimento. Seja educado(a) e cortês - muitas vezes as pessoas que respondem estão oferecendo seu tempo para ajudá-lo. Se você tiver uma pergunta de acompanhamento, considere se deve ser uma pergunta postada separada.\nMarque a pergunta como respondida, se obtiver uma resposta que atenda à solicitação original. Isso ajuda outras pessoas a reconhecerem rapidamente a solução mais tarde.\n\nLeia estas postagens sobre como fazer uma boa pergunta e sobre ocódigo de conduta do Stack overflow.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Conseguindo ajuda</span>"
    ]
  },
  {
    "objectID": "new_pages/help.pt.html#recursos",
    "href": "new_pages/help.pt.html#recursos",
    "title": "48  Conseguindo ajuda",
    "section": "48.4 Recursos",
    "text": "48.4 Recursos\nPágina do Tidyverse sobre como obter ajuda!\nDicas para produzir um conjunto mínimo de dados\nDocumentação para a função dput",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>48</span>  <span class='chapter-title'>Conseguindo ajuda</span>"
    ]
  },
  {
    "objectID": "new_pages/network_drives.pt.html",
    "href": "new_pages/network_drives.pt.html",
    "title": "49  R em drives (pastas) na rede",
    "section": "",
    "text": "49.1 Visão geral\nO uso do R em rede ou em pastas compartilhadas de uma instituição pode apresentar desafios adicionais. Esta página contém abordagens, erros comuns e sugestões sobre a solução de problemas obtidos a partir da nossa experiência de trabalho com estas questões. Isto inclui dicas para as situações particularmente delicadas envolvendo o R Markdown.\nUsando R em drives na rede: Princípios gerais",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>R em drives (pastas) na rede</span>"
    ]
  },
  {
    "objectID": "new_pages/network_drives.pt.html#visão-geral",
    "href": "new_pages/network_drives.pt.html#visão-geral",
    "title": "49  R em drives (pastas) na rede",
    "section": "",
    "text": "Você deve obter acesso de administrador para seu computador. Configure o RStudio especificamente para ser executado como administrador.\n\nSalve os pacotes em uma biblioteca (drive, pasta) com letras sempre que possível (por exemplo, “C:”). Evite usar uma biblioteca de pacotes cujo caminho comece com “\\”.\n\nO pacote rmarkdown não deve estar em uma biblioteca de pacotes “\\”, pois assim não poderá se conectar ao TinyTex ou ao Pandoc.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>R em drives (pastas) na rede</span>"
    ]
  },
  {
    "objectID": "new_pages/network_drives.pt.html#rstudio-como-administrador",
    "href": "new_pages/network_drives.pt.html#rstudio-como-administrador",
    "title": "49  R em drives (pastas) na rede",
    "section": "49.2 RStudio como administrador",
    "text": "49.2 RStudio como administrador\nPara abrir o RStudio, clique no ícone com o botão direito do mouse. Dependendo de sua máquina, você verá uma opção para “Run as Administrator” (Executar como administrador). Caso contrário, você verá uma opção para selecionar as Properties (Propriedades), e então deverá aparecer uma janela com a opção “Compatibility” (Compatibilidade), e você poderá selecionar uma caixa de seleção “Run as Administrator” (Executar como Administrador).",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>R em drives (pastas) na rede</span>"
    ]
  },
  {
    "objectID": "new_pages/network_drives.pt.html#comandos-úteis",
    "href": "new_pages/network_drives.pt.html#comandos-úteis",
    "title": "49  R em drives (pastas) na rede",
    "section": "49.3 Comandos úteis",
    "text": "49.3 Comandos úteis\nAbaixo estão alguns comandos úteis ao tentar solucionar problemas usando R em drives de rede.\nVocê pode retornar o(s) caminho(s) para as bibliotecas de pacotes que o R está usando. Eles serão listados na ordem em que R estiver usando para instalar/carregar/buscar por pacotes. Assim, se você quiser que R use uma biblioteca padrão diferente, você pode mudar a ordem destes caminhos (veja abaixo).\n\n# Encontrar bibliotecas\n.libPaths()                   #  Os caminhos de sua biblioteca, listados para que o R instale/selecione.. \n                              # Nota: todas as bibliotecas serão listadas, mas para instalar em algumas \n                              # (por exemplo, C:) você pode precisar executar o RStudio como administrador \n                              # (não aparecerá no menu suspenso de install.packages) \n\nVocê pode querer mudar a ordem das bibliotecas de pacotes usadas pelo R. Por exemplo, se o R estiver pegando um local de biblioteca que começa com “\\” e um que começa com uma letra, por exemplo, “D:”. Você pode ajustar a ordem de .libPaths() com o seguinte código.\n\n# Troca a ordem das bibliotecas\n# Isto pode afetar a prioridade do R encontrar um pacote. Por exemplo, você pode querer que sua biblioteca C: seja listada primeiro\nmyPaths &lt;- .libPaths() # obter os caminhos\nmyPaths &lt;- c(myPaths[2], myPaths[1]) # trocar os caminhos\n.libPaths(myPaths) # realocar os caminhos\n\nSe você estiver com dificuldades no para conectar o R Markdown ao Pandoc, comece com este código para descobrir onde RStudio entende que está sua instalação Pandoc.\n\n#Encontrar o Pandoc\nSys.getenv(\"RSTUDIO_PANDOC\")  # Descubra onde o RStudio entende que está sua instalação Pandoc\n\nSe você quiser ver de qual biblioteca um pacote está sendo carregado, tente o código abaixo:\n\n# Encontrar um pacote\n# Indica a primeira localização do pacote (Note a ordem de suas bibliotecas)\nfind.package(\"rmarkdown\", lib.loc = NULL, quiet = FALSE, verbose = getOption(\"verbose\"))",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>R em drives (pastas) na rede</span>"
    ]
  },
  {
    "objectID": "new_pages/network_drives.pt.html#resolução-de-problemas-e-erros-comuns",
    "href": "new_pages/network_drives.pt.html#resolução-de-problemas-e-erros-comuns",
    "title": "49  R em drives (pastas) na rede",
    "section": "49.4 Resolução de problemas e erros comuns",
    "text": "49.4 Resolução de problemas e erros comuns\n“Failed to compile…tex in rmarkdown”\n\nVerifique a instalação de TinyTex, ou instale TinyTex em C:. Veja na página Introdução ao R sobre como instalar o TinyTex.\n\n\n# Verificar/instalar tinytex em C:\ntinytex::install_tinytex()\ntinytex:::is_tinytex() # deve retornar TRUE (VERDADEIRO)\n\nAs rotinas da Internet não podem ser carregadas\nPor exemplo, Error in tools::startDynamicHelp() : internet routines cannot be loaded\n\nTente selecionar a versão de 32 bits do RStudio em Tools/Global Options (Ferramentas/Opções Globais).\n\nnota: se a versão de 32 bits não aparecer no menu, certifique-se de não estar usando o RStudio v1.2\n\nAlternativamente, tente desinstalar R e reinstalar com versão de bit diferente (32 em vez de 64).\n\nC: o pacote não aparece como opção quando tento instalar pacotes manualmente\n\nExecute o RStudio como administrador que esta opção vai aparecer\n\nPara executar o RStudio sempre como administrador, clique com o botão direito do mouse no ícone do Rstudio (opção vantajosa ao usar um projeto R, em que você não clica no ícone do RStudio para abrir).\n\nA imagem abaixo mostra como você pode selecionar manualmente a biblioteca para a instalação de um pacote. Esta janela aparece quando você abre o painel Packages (Pacotes) no RStudio e clica em “Install” (Instalar).\n\n\n\n\n\n\n\n\n\nErro Pandoc 1\nSe você estiver recebendo “pandoc error 1” ao criar scripts R Markdowns em drives de rede:\n\nDentre as muitas bibliotecas, tenha uma com letras listadas primeiro (ver códigos acima)\n\nA solução acima funcionou ao programar em uma unidade local, mas em uma conexão de Internet em rede\n\nVeja mais dicas aqui: https://ciser.cornell.edu/rmarkdown-knit-to-html-word-pdf/\n\nErro Pandoc 83\nO erro será algo parecido com: can't find file...rmarkdown...lua.... Isto significa que não foi possível encontrar este arquivo.\nVeja https://stackoverflow.com/questions/58830927/rmarkdown-unable-to-locate-lua-filter-when-knitting-to-word\nPossibilidades:\n\nO pacote Rmarkdown não está instalado\n\nO pacote Rmarkdown não pode ser encontrado\n\nUma questão de direitos do administrador.\n\nÉ possível que o R não seja capaz de encontrar o arquivo do pacote rmarkdown, portanto verifique qual biblioteca (pasta) o pacote rmarkdown se encontra (veja o código acima). Se o pacote foi instalado em uma biblioteca inacessível (por exemplo, que comece com “\\”), considere movê-lo manualmente para C: ou outra biblioteca que comece com uma letra. Esteja ciente de que o pacote rmarkdown tem que ser capaz de se conectar à instalação do TinyTex, portanto não pode estar em uma biblioteca em uma unidade de rede.\nErro Pandoc 61\nPor exemplo: Error: pandoc document conversion failed with error 61 ou Could not fetch...\n\nTente executar o RStudio como administrador (clique com o botão direito do mouse, selecione executar como administrador, veja as instruções acima)\n\nVeja também se o pacote específico que não pôde ser carregado pode ser movido para biblioteca C:.\n\nLaTex error (ver abaixo)\nUm erro como: ! Package pdftex.def Error: File 'cict_qm2_2020-06-29_files/figure-latex/unnamed-chunk-5-1.png' not found: using draft setting. ou Error: LaTeX failed to compile file_name.tex.\n\nVeja https://yihui.org/tinytex/r/#debugging para dicas de correção.\n\nVeja file_name.log para mais informações.\n\nErro Pandoc 127\nIsto pode ser uma questão de RAM (espaço). Reinicie novamente sua sessão R e tente novamente.\nMapeamento de drives na rede\nMapear uma unidade de rede pode ser arriscado. Consulte seu departamento de TI antes de tentar fazer isso.\nUma dica emprestada deste fórum de discussão:\nComo se abre um arquivo “através de uma unidade de rede mapeada”?\n\nPrimeiro, você precisará saber a localização da rede à qual está tentando acessar.\n\nEm seguida, no gerenciador de arquivos do Windows, você precisará clicar com o botão direito do mouse em “Este Computador” no painel à esquerda (ou direita, dependendo da sua configuração), e selecionar “Mapear uma unidade de rede”.\n\nPasse pelo diálogo para definir a localização da rede desde o início como um drive com letras de forma.\n\nAgora você tem duas maneiras de chegar ao arquivo que você está abrindo. O uso do caminho com letras deve funcionar.\n\nErro em install.packages()\nSe você receber um erro que inclua a menção de um diretório “lock”, por exemplo: Error in install.packages : ERROR: failed to lock directory...\nProcure em sua biblioteca de pacotes e verá uma pasta cujo nome começa com “00LOCK”. Tente as seguintes dicas:\n\nApague manualmente o diretório da pasta “00LOCK” de sua biblioteca de pacotes. Tente instalar o pacote de novo.\n\nVocê também pode tentar o comando pacman::p_unlock() (você também pode colocar este comando no Rprofile para que ele seja executado toda vez que o projeto abrir). Tente então instalar o pacote novamente. Pode ser necessário várias tentativas.\n\nTente executar o RStudio no modo administrador, e tente instalar os pacotes um a um.\n\ne tudo isso falhar, instale o pacote em outra biblioteca ou pasta (por exemplo, Temp) e depois copie manualmente a pasta do pacote para a biblioteca desejada.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>49</span>  <span class='chapter-title'>R em drives (pastas) na rede</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.pt.html",
    "href": "new_pages/data_table.pt.html",
    "title": "50  Data Table",
    "section": "",
    "text": "50.1 Introdução ao Data Table\nUma tabela de dados (data table) é uma estrutura de dados bidimensional como um data frame, que permite a realização de operações complexas de agrupamento. A sintaxe data.table é estruturada para que as operações possam ser realizadas em linhas, colunas e grupos.\nA estrutura é DT[i, j, by], separada por 3 partes; os argumentos i, j e by. O argumento i permite filtrar linhas, o argumento j permite operar em colunas e o argumento by permite operar em colunas por grupos.\nEsta página abordará os seguintes tópicos:",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Data Table</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.pt.html#introdução-ao-data-table",
    "href": "new_pages/data_table.pt.html#introdução-ao-data-table",
    "title": "50  Data Table",
    "section": "",
    "text": "Importação de dados e uso das funções fread() e fwrite()\nFiltragem de linhas utilizando o argumento i\nUtilização das funções de ajuda %like%, %chin% e %between%\nSeleção e operação com colunas utilizando o argumento j\nOperar por grupos utilizando o argumento by\nAdição de dados e atualização de data tables (tabelas de dados) utilizando :=",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Data Table</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.pt.html#carregar-pacotes-e-importar-dados",
    "href": "new_pages/data_table.pt.html#carregar-pacotes-e-importar-dados",
    "title": "50  Data Table",
    "section": "50.2 Carregar pacotes e importar dados",
    "text": "50.2 Carregar pacotes e importar dados\n\nCarregar pacotes\nUtilizando a função p_load() de pacman, carregamos (e instalamos, se necessário) os pacotes necessários para esta análise.\n\npacman::p_load(\n  rio,        # para importar dados\n  data.table, # para agrupar e limpar dados\n  tidyverse,  # permite o uso da função pipe (%&gt;%) neste capítulo\n  here \n  ) \n\n\n\nImportar dados\nEsta página vai explorar algumas das funções centrais do pacote data.table recorrendo à mesma linelist de casos utilizada ao longo do manual.\nImportamos o conjunto de dados dos casos de uma epidemia simulada de Ébola. Se você quiser baixar os dados para seguir passo a passo, veja as instruções na página Baixar livro e dados. O conjunto de dados é importado utilizando a função import() do pacote rio. Veja a página em Importar e exportar para várias formas de importação de dados. Em seguida, utilizamos data.table() para converter o quadro de dados em um data table.\n\nlinelist &lt;- rio::import(here(\"data\", \"linelist_cleaned.xlsx\")) %&gt;% data.table()\n\nA função fread() é utilizada para importar arquivos delimitados por caracteres, como arquivos .csv, diretamente para um formato de data table. Esta função, e sua contraparte fwrite(), utilizada para escrever data.tables como arquivos delimitados, são opções muito rápidas e computacionalmente eficientes para grandes bancos de dados.\nAs primeiras 20 linhas da linelist:\nComandos do R Base como dim() que são utilizados para data frames também podem ser utilizados para data tables (tabelas de dados).\n\ndim(linelist) #dispõe o número de linhas e colunas na tabela de dados\n\n[1] 5888   30",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Data Table</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.pt.html#o-argumento-i-selecionando-e-filtrando-linhas",
    "href": "new_pages/data_table.pt.html#o-argumento-i-selecionando-e-filtrando-linhas",
    "title": "50  Data Table",
    "section": "50.3 O argumento i: selecionando e filtrando linhas",
    "text": "50.3 O argumento i: selecionando e filtrando linhas\nRelembrando a estrutura DT[i, j, by], podemos filtrar linhas usando números de linha ou expressões lógicas. O argumento i é o primeiro; portanto, a sintaxe DT[i] ou DT[i,] pode ser usada.\nO primeiro exemplo recupera as primeiras 5 linhas do data table, o segundo exemplo retorna casos com 18 anos ou mais, e o terceiro exemplo gera um subconjunto de casos com 18 anos ou mais, mas não diagnosticados no Hospital Central:\n\nlinelist[1:5] # retorna da 1ª à 5ª fileira\nlinelist[age &gt;= 18] # subconjunto de casos com 18 anos ou mais\nlinelist[age &gt;= 18 & hospital != \"Central Hospital\"] # conjunto de casos com idade igual ou superior a 18 anos, mas não diagnosticados no Hospital Central\n\nO uso de .N no argumento i representa o número total de linhas no data table. Isto pode ser usado para criar subconjuntos com base nos números das linhas:\n\nlinelist[.N] # retorna a última linha\nlinelist[15:.N] # retorna da 15ª à última linha\n\n\nFunções de ajuda para filtragem\nData tables (tabelas de dados) utilizam funções de auxílio que facilitam a filtragem linhas. A função %like% é utilizada para corresponder a um padrão em uma coluna, %chin% é utilizada para corresponder a um caractere específico, e a função %between% é utilizada para corresponder a colunas numéricas dentro de uma faixa pré-especificada.\nNos exemplos a seguir, nós: * filtramos linhas em que a variável hospital contém “Hospital” * filtramos linhas em que o resultado é “Recover” ou “Death” * filtramos linhas em que a faixa etária (age) é 40-60 anos\n\nlinelist[hospital %like% \"Hospital\"] # filtrar linhas em que a variável hospital contém \"Hospital\"\nlinelist[outcome %chin% c(\"Recover\", \"Death\")] # filtrar linhas em que o resultado (outcome) é \"Recover\" ou \"Death\"\nlinelist[age %between% c(40, 60)] # filtrar linhas em que a faixa etária (age) é de 40-60 anos\n\n#%between% deve receber um vetor de comprimento 2, enquanto %chin% pode receber vetores de comprimento &gt;= 1",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Data Table</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.pt.html#o-argumento-j-seleção-e-cálculo-nas-colunas",
    "href": "new_pages/data_table.pt.html#o-argumento-j-seleção-e-cálculo-nas-colunas",
    "title": "50  Data Table",
    "section": "50.4 O argumento j: seleção e cálculo nas colunas",
    "text": "50.4 O argumento j: seleção e cálculo nas colunas\nUsando a estrutura DT[i, j, by], podemos selecionar colunas usando números ou nomes. O argumento j é o segundo; portanto, a sintaxe DT[, j] é usada. Para facilitar os cálculos no argumento j, a coluna é envolvida utilizando list() ou .().\n\nSeleção de colunas\nO primeiro exemplo recupera a primeira, terceira e quinta colunas do data table, o segundo exemplo seleciona todas as colunas, exceto as colunas gender, age, wt_kg e ht_cm. O terceiro exemplo utiliza o envelope .() para selecionar as colunas case_id e outcome.\n\nlinelist[ , c(1,3,5)]\nlinelist[ , -c(\"gender\", \"age\", \"wt_kg\", \"ht_cm\")]\nlinelist[ , list(case_id, outcome)] #linelist[ , .(case_id, outcome)] funciona tão bem quanto\n\n\n\nCálculo nas colunas\nCombinando os argumentos i e j é possível filtrar linhas e calcular colunas. Usar .N no argumento j também representa o número total de linhas no data table e pode ser útil para retornar o número de linhas após a filtragem.\nNos exemplos a seguir, nós: * contamos o número de casos que permaneceram mais de 7 dias no hospital * calculamos a idade média dos casos que vieram a óbito no hospital militar * calculamos o desvio padrão, mediana, e média da idade dos casos que se recuperaram no hospital central\n\nlinelist[days_onset_hosp &gt; 7 , .N]\n\n[1] 189\n\nlinelist[hospital %like% \"Military\" & outcome %chin% \"Death\", .(mean(age, na.rm = T))] #na.rm = T remove valores N/A\n\n        V1\n     &lt;num&gt;\n1: 15.9084\n\nlinelist[hospital == \"Central Hospital\" & outcome == \"Recover\", \n                 .(mean_age = mean(age, na.rm = T),\n                   median_age = median(age, na.rm = T),\n                   sd_age = sd(age, na.rm = T))] # esta sintaxe não utiliza as funções de ajuda, mas funciona tão bem quanto\n\n   mean_age median_age   sd_age\n      &lt;num&gt;      &lt;num&gt;    &lt;num&gt;\n1: 16.85185         14 12.93857\n\n\nLembre-se que usar o envelope .() no argumento j facilita o cálculo, retorna um data table e permite a nomeação de colunas.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Data Table</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.pt.html#the-by-argument-computing-by-groups",
    "href": "new_pages/data_table.pt.html#the-by-argument-computing-by-groups",
    "title": "50  Data Table",
    "section": "50.5 The by argument: computing by groups",
    "text": "50.5 The by argument: computing by groups\nO argumento by é o terceiro argumento na estrutura DT[i, j, by]. Ele aceita tanto um vetor de caracteres quanto a sintaxe list() ou .(). A utilização da sintaxe .() no argumento by permite renomear a coluna imediatamente.\nNos exemplos a seguir, nós: * agrupamos o número de casos por hospital * calculamos a altura média e o peso dos casos com 18 anos ou mais, de acordo com o sexo e desfecho (se eles se recuperaram ou vieram a óbito) * contamos o número de casos com tempo de internação &gt; 7 dias, de acordo com o mês e o hospital em que foram admitidos\n\nlinelist[, .N, .(hospital)] # número de casos por hospital\n\n                               hospital     N\n                                 &lt;char&gt; &lt;int&gt;\n1:                                Other   885\n2:                              Missing  1469\n3: St. Mark's Maternity Hospital (SMMH)   422\n4:                        Port Hospital  1762\n5:                    Military Hospital   896\n6:                     Central Hospital   454\n\nlinelist[age &gt; 18, .(mean_wt = mean(wt_kg, na.rm = T),\n                             mean_ht = mean(ht_cm, na.rm = T)), .(gender, outcome)] #NAs representam as categorias em que os dados estão faltando\n\n   gender outcome  mean_wt  mean_ht\n   &lt;char&gt;  &lt;char&gt;    &lt;num&gt;    &lt;num&gt;\n1:      m Recover 71.90227 178.1977\n2:      f   Death 63.27273 159.9448\n3:      m   Death 71.61770 175.4726\n4:      f    &lt;NA&gt; 64.49375 162.7875\n5:      m    &lt;NA&gt; 72.65505 176.9686\n6:      f Recover 62.86498 159.2996\n7:   &lt;NA&gt; Recover 67.21429 175.2143\n8:   &lt;NA&gt;   Death 69.16667 170.7917\n9:   &lt;NA&gt;    &lt;NA&gt; 70.25000 175.5000\n\nlinelist[days_onset_hosp &gt; 7, .N, .(month = month(date_hospitalisation), hospital)]\n\n    month                             hospital     N\n    &lt;num&gt;                               &lt;char&gt; &lt;int&gt;\n 1:     5                    Military Hospital     3\n 2:     6                        Port Hospital     4\n 3:     7                        Port Hospital     8\n 4:     8 St. Mark's Maternity Hospital (SMMH)     5\n 5:     8                    Military Hospital     9\n 6:     8                                Other    10\n 7:     8                        Port Hospital    10\n 8:     9                        Port Hospital    28\n 9:     9                              Missing    27\n10:     9                     Central Hospital    10\n11:     9 St. Mark's Maternity Hospital (SMMH)     6\n12:    10                              Missing     2\n13:    10                    Military Hospital     3\n14:     3                        Port Hospital     1\n15:     4                    Military Hospital     1\n16:     5                                Other     2\n17:     5                     Central Hospital     1\n18:     5                              Missing     1\n19:     6                              Missing     7\n20:     6 St. Mark's Maternity Hospital (SMMH)     2\n21:     6                    Military Hospital     1\n22:     7                    Military Hospital     3\n23:     7                                Other     1\n24:     7                              Missing     2\n25:     7 St. Mark's Maternity Hospital (SMMH)     1\n26:     8                     Central Hospital     2\n27:     8                              Missing     6\n28:     9                                Other     9\n29:     9                    Military Hospital    11\n30:    10                        Port Hospital     3\n31:    10                                Other     4\n32:    10 St. Mark's Maternity Hospital (SMMH)     1\n33:    10                     Central Hospital     1\n34:    11                              Missing     2\n35:    11                        Port Hospital     1\n36:    12                        Port Hospital     1\n    month                             hospital     N\n\n\nData.table também permite expressões em serquência:\n\nlinelist[, .N, .(hospital)][order(-N)][1:3] #1º seleciona todos os casos por hospital, 2º ordena os casos em ordem decrescente, 3º seleciona um subconjunto dos 3 hospitais com o maior número de casos\n\n            hospital     N\n              &lt;char&gt; &lt;int&gt;\n1:     Port Hospital  1762\n2:           Missing  1469\n3: Military Hospital   896\n\n\nNestes exemplos, estamos seguindo a suposição de que uma linha no data table é igual a um novo caso, e assim podemos usar o .N para representar o número de linhas no data table. Outra função útil para representar o número de casos únicos é uniqueN(), que retorna o número de valores únicos em uma determinada entrada. Como ilustrado aqui:\n\nlinelist[, .(uniqueN(gender))] # lembre que o envelope .() no argumento j retorna um data table\n\n      V1\n   &lt;int&gt;\n1:     3\n\n\nA resposta é 3, pois os valores únicos na coluna de gênero são m, f e N/A. Compare com a função unique() do R Base, que retorna todos os valores únicos em uma determinada entrada:\n\nlinelist[, .(unique(gender))]\n\n       V1\n   &lt;char&gt;\n1:      m\n2:      f\n3:   &lt;NA&gt;\n\n\nPara encontrar o número de casos únicos em um determinado mês, escrevemos o seguinte:\n\nlinelist[, .(uniqueN(case_id)), .(month = month(date_hospitalisation))]\n\n    month    V1\n    &lt;num&gt; &lt;int&gt;\n 1:     5    62\n 2:     6   100\n 3:     7   198\n 4:     8   509\n 5:     9  1170\n 6:    10  1228\n 7:    11   813\n 8:    12   576\n 9:     1   434\n10:     2   310\n11:     3   290\n12:     4   198",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Data Table</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.pt.html#adicionar-e-atualizar-data-tables-tabelas-de-dados",
    "href": "new_pages/data_table.pt.html#adicionar-e-atualizar-data-tables-tabelas-de-dados",
    "title": "50  Data Table",
    "section": "50.6 Adicionar e atualizar data tables (tabelas de dados)",
    "text": "50.6 Adicionar e atualizar data tables (tabelas de dados)\nO operador := é utilizado para adicionar ou atualizar dados em um data table. A adição de colunas pode ser feita das seguintes maneiras:\n\nlinelist[, adult := age &gt;= 18] # adiciona uma coluna\nlinelist[, c(\"child\", \"wt_lbs\") := .(age &lt; 18, wt_kg*2.204)] #para adicionar múltiplas colunas é necessário usar as sintaxes c(\"\"), list() ou .() syntax\nlinelist[, `:=` (bmi_in_range = (bmi &gt; 16 & bmi &lt; 40),\n                         no_infector_source_data = is.na(infector) | is.na(source))] #Este método utiliza `:=` como um operador funcional \nlinelist[, adult := NULL] # deleta a coluna\n\nOutras agregações complexas estão além do objetivo deste capítulo introdutório, mas a ideia é fornecer uma alternativa popular e viável ao dplyr para agrupamento e limpeza de dados. O pacote data.table é um grande pacote que permite um código limpo e legível.",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Data Table</span>"
    ]
  },
  {
    "objectID": "new_pages/data_table.pt.html#recursos",
    "href": "new_pages/data_table.pt.html#recursos",
    "title": "50  Data Table",
    "section": "50.7 Recursos",
    "text": "50.7 Recursos\nAqui estão alguns recursos úteis para maiores informações: * https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html * https://github.com/Rdatatable/data.table * https://s3.amazonaws.com/assets.datacamp.com/img/blog/data+table+cheat+sheet.pdf * https://www.machinelearningplus.com/data-manipulation/datatable-in-r-complete-guide/ * https://www.datacamp.com/community/tutorials/data-table-r-tutorial\nVocê pode realizar qualquer função de resumo sobre dados agrupados; veja a Cheat Sheet para mais informações: https://s3.amazonaws.com/assets.datacamp.com/blog_assets/datatable_Cheat_Sheet_R.pdf",
    "crumbs": [
      "Miscelânea",
      "<span class='chapter-number'>50</span>  <span class='chapter-title'>Data Table</span>"
    ]
  }
]