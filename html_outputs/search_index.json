[["_main.html", "The Epidemiologist R Handbook 1 output: bookdown::gitbook: R for applied epidemiology and public health How to use this handbook Acknowledgements Terms of Use and Contribution 2 Editorial and technical notes 2.1 Approach and style 2.2 Editorial decisions 2.3 Major revisions 2.4 Session info (R, RStudio, packages) 3 Download handbook and data 3.1 Download offline handbook 3.2 Download data to follow along 4 R Basics 4.1 Why use R? 4.2 Key terms 4.3 Resources for learning 4.4 Installation 4.5 RStudio 4.6 Functions 4.7 Packages 4.8 Scripts 4.9 Working directory 4.10 Objects 4.11 Piping (%&gt;%) 4.12 Key operators and functions 4.13 Errors &amp; warnings 5 Transition to R 5.1 From Excel 5.2 From Stata 5.3 From SAS 5.4 Data interoperability 6 Suggested packages 6.1 Packages from CRAN 6.2 Packages from Github 7 R projects 7.1 Suggested use 7.2 Creating an R project 7.3 Examples 7.4 Resources 8 Import and export 8.1 Overview 8.2 The rio package 8.3 The here package 8.4 File paths 8.5 Import data 8.6 Multiple files - import, export, split, combine 8.7 Import from Github 8.8 Manual data entry 8.9 Import most recent file 8.10 APIs 8.11 Export 8.12 RDS files 8.13 Rdata files and lists 8.14 Saving plots 8.15 Resources 9 Cleaning data and core functions 9.1 Cleaning pipeline 9.2 Load packages 9.3 Import data 9.4 Column names 9.5 Select or re-order columns 9.6 Deduplication 9.7 Column creation and transformation 9.8 Re-code values 9.9 Numeric categories 9.10 Add rows 9.11 Filter rows 9.12 Row-wise calculations 9.13 Arrange and sort 10 Working with dates 10.1 Preparation 10.2 Current date 10.3 Convert to Date 10.4 Excel dates 10.5 Messy dates 10.6 Working with date-time class 10.7 Working with dates 10.8 Date display 10.9 Epidemiological weeks 10.10 Converting dates/time zones 10.11 Lagging and leading calculations 10.12 Resources 11 Characters and strings 11.1 Preparation 11.2 Unite, split, and arrange 11.3 Clean and standardise 11.4 Handle by position 11.5 Patterns 11.6 Special characters 11.7 Regular expressions (regex) 11.8 Regex and special characters 11.9 Resources 12 Factors 12.1 Preparation 12.2 Convert to factor 12.3 Add or drop levels 12.4 Adjust level order 12.5 Missing values 12.6 Combine levels 12.7 Show all levels 12.8 Epiweeks 12.9 Resources 13 Pivoting data 13.1 Preparation 13.2 Wide-to-long 13.3 Long-to-wide 13.4 Fill 13.5 Resources 14 Grouping data 14.1 Preparation 14.2 Grouping 14.3 Un-group 14.4 Summarise 14.5 Counts and tallies 14.6 Grouping by date 14.7 Arranging grouped data 14.8 Filter on grouped data 14.9 Mutate on grouped data 14.10 Select on grouped data 14.11 Resources 15 Joining data 15.1 Preparation 15.2 dplyr joins 15.3 Probabalistic matching 15.4 Binding and aligning 15.5 Resources 16 De-duplication 16.1 Preparation 16.2 Deduplication 16.3 Slicing 16.4 Roll-up values 16.5 Probabilistic de-duplication 16.6 Resources 17 Iteration, loops, and lists 17.1 Preparation 17.2 for loops 17.3 purrr and lists 17.4 Apply functions 17.5 Resources 18 Descriptive tables 18.1 Preparation 18.2 Browse data 18.3 janitor package 18.4 dplyr package 18.5 gtsummary package 18.6 base R 18.7 Resources 19 Simple statistical tests 19.1 Preparation 19.2 base R 19.3 rstatix package 19.4 gtsummary package 19.5 Correlations 19.6 Resources 20 Univariate and multivariable regression 20.1 Preparation 20.2 Univariate 20.3 Stratified 20.4 Multivariable 20.5 Forest plot 20.6 Resources 21 Missing data 21.1 Preparation 21.2 Missing values in R 21.3 Useful functions 21.4 Assess missingness in a data frame 21.5 Using data with missing values 21.6 Imputation 21.7 Resources 22 Standardised rates 22.1 Overview 22.2 Preparation 22.3 dsr package 22.4 PHEindicatormethods package 22.5 Resources 23 Moving averages 23.1 Preparation 23.2 Calculate with slider 23.3 Calculate with tidyquant within ggplot() 23.4 Resources 24 Time series and outbreak detection 24.1 Overview 24.2 Preparation 24.3 Time series data 24.4 Descriptive analysis 24.5 Fitting regressions 24.6 Relation of two time series 24.7 Outbreak detection 24.8 Interrupted timeseries 24.9 Resources 25 Epidemic modeling 25.1 Overview 25.2 Preparation 25.3 Estimating Rt 25.4 Projecting incidence 25.5 Resources 26 Contact tracing 26.1 Preparation 26.2 Descriptive analyses 26.3 Contact Follow Up 26.4 KPI Tables 26.5 Transmission Matrices 26.6 Resources 27 Survey analysis 27.1 Overview 27.2 Preparation 27.3 Survey data 27.4 Observation time 27.5 Weighting 27.6 Survey design objects 27.7 Descriptive analysis 27.8 Weighted proportions 27.9 Weighted ratios 27.10 Resources 28 Survival analysis 28.1 Overview 28.2 Preparation 28.3 Basics of survival analysis 28.4 Comparison of survival curves 28.5 Cox regression analysis 28.6 Time-dependent covariates in survival models 28.7 Resources 29 GIS basics 29.1 Overview 29.2 Key terms 29.3 Getting started with GIS 29.4 Preparation 29.5 Plotting coordinates 29.6 Spatial joins 29.7 Choropleth maps 29.8 Mapping with ggplot2 29.9 Basemaps 29.10 Contoured density heatmaps 29.11 Spatial statistics 29.12 Resources 30 Tables for presentation 30.1 Preparation 30.2 Basic flextable 30.3 Conditional formatting 30.4 All code together 30.5 Saving your table 30.6 Resources 31 ggplot basics 31.1 Preparation 31.2 Basics of ggplot 31.3 ggplot() 31.4 Geoms 31.5 Mapping data to the plot 31.6 Facets / Small-multiples 31.7 Storing plots 31.8 Labels 31.9 Themes 31.10 Colors 31.11 Piping into ggplot2 31.12 Plot continuous data 31.13 Plot categorical data 31.14 Resources 32 ggplot tips 32.1 Preparation 32.2 Scales for color, fill, axes, etc. 32.3 Change order of discrete variables 32.4 Contour lines 32.5 Marginal distributions 32.6 Smart Labeling 32.7 Time axes 32.8 Highlighting 32.9 Plotting multiple datasets 32.10 Combine plots 32.11 Dual axes 32.12 Packages to help you 32.13 Miscellaneous 32.14 Resources 33 Epidemic curves 33.1 Preparation 33.2 Epicurves with ggplot2 33.3 Tentative data 33.4 Multi-level date labels 33.5 Dual-axis 33.6 Cumulative Incidence 33.7 Resources 34 Demographic pyramids and Likert-scales 34.1 Preparation 34.2 apyramid package 34.3 ggplot() 34.4 Likert scale 34.5 Resources 35 Heat plots 35.1 Preparation 35.2 Transmission matrix 35.3 Reporting metrics over time 35.4 Resources 36 Diagrams and charts 36.1 Preparation 36.2 Flow diagrams 36.3 Alluvial/Sankey Diagrams 36.4 Event timelines 36.5 DAGs 36.6 Resources 37 Combinations analysis 37.1 Preparation 37.2 ggupset 37.3 UpSetR 37.4 Resources 38 Transmission chains 38.1 Overview 38.2 Preparation 38.3 Handling 38.4 Visualization 38.5 Analysis 38.6 Resources 39 Phylogenetic trees 39.1 Overview 39.2 Preparation 39.3 Simple tree visualization 39.4 Tree manipulation More complex trees: adding heatmaps of sample data 39.5 Resources 40 Interactive plots 40.1 Preparation 40.2 Plot with ggplotly() 40.3 Modifications 40.4 Heat tiles 40.5 Resources 41 Reports with R Markdown 41.1 Preparation 41.2 Getting started 41.3 R Markdown components 41.4 File structure 41.5 Producing the document 41.6 Parameterised reports 41.7 Looping reports 41.8 Templates 41.9 Dynamic content 41.10 Resources 42 Organizing routine reports 42.1 Preparation 42.2 New factory 42.3 Create a report 42.4 Compile 42.5 Outputs 42.6 Miscellaneous 42.7 Resources 43 Dashboards with R Markdown 43.1 Preparation 43.2 Create new R Markdown 43.3 The script 43.4 Section attributes 43.5 Layout 43.6 Adding content 43.7 Code organization 43.8 Shiny 43.9 Sharing 43.10 Resources 44 Dashboards with Shiny 44.1 Preparation 44.2 The structure of a shiny app 44.3 Building a UI 44.4 Loading data into our app 44.5 Developing an app server 44.6 Adding more functionality 44.7 Sharing shiny apps 44.8 Further reading 44.9 Recommended extension packages 44.10 Recommended resources 45 Writing functions 45.1 Preparation 45.2 Functions 45.3 Why would you use a function? 45.4 How does R build functions? 45.5 Basic syntax and structure 45.6 Examples 45.7 Using purrr: writing functions that can be iteratively applied 45.8 Tips and best Practices for well functioning functions 45.9 Resources 46 Directory interactions 46.1 Preparation 46.2 List files in a directory 46.3 File information 46.4 Check if exists 46.5 Create 46.6 Delete 46.7 Running other files 46.8 base R 46.9 Resources 47 Version control and collaboration with Git and Github 47.1 What is Git? 47.2 Why use the combo Git and Github? 47.3 Setup 47.4 Vocabulary, concepts and basic functions 47.5 Get started: create a new repository 47.6 Git + Github workflow 47.7 Create a new branch 47.8 Commit changes 47.9 Pull and push changes up to Github 47.10 Merge branch into Main 47.11 What we learned 47.12 Git commands 47.13 Resources 48 Common errors 48.1 Interpreting error messages 48.2 Common errors 48.3 Resources 49 Getting help 49.1 Github issues 49.2 Reproducible example 49.3 Posting to a forum 49.4 Resources 50 R on network drives 50.1 Overview 50.2 RStudio as administrator 50.3 Useful commands 50.4 Troubleshooting common errors 51 Data Table 51.1 Intro to data tables 51.2 Load packages and import data 51.3 The i argument: selecting and filtering rows 51.4 The j argument: selecting and computing on columns 51.5 The by argument: computing by groups 51.6 Adding and updating to data tables 51.7 Resources", " The Epidemiologist R Handbook the handbook team 2023-07-18 1 output: bookdown::gitbook: Placeholder R for applied epidemiology and public health How to use this handbook Acknowledgements Contributors Funding and support Inspiration Terms of Use and Contribution License Citation Contribution 2 Editorial and technical notes Placeholder 2.1 Approach and style R packages Code style Nomenclature Notes 2.2 Editorial decisions 2.3 Major revisions 2.4 Session info (R, RStudio, packages) 3 Download handbook and data Placeholder 3.1 Download offline handbook Use download link Use our R package 3.2 Download data to follow along Use our R package Download one-by-one Case linelist Malaria count data Likert-scale data Flexdashboard Contact Tracing GIS Phylogenetic trees Standardization Time series and outbreak detection Survey analysis Shiny 4 R Basics Placeholder 4.1 Why use R? 4.2 Key terms 4.3 Resources for learning Resources within RStudio Cheatsheets Twitter Free online resources Languages other than English 4.4 Installation R and RStudio Other software you may need to install TinyTex Pandoc RTools phantomjs 4.5 RStudio RStudio orientation RStudio settings Keyboard shortcuts 4.6 Functions Simple functions Functions with multiple arguments Writing Functions 4.7 Packages Install and load Your library Install from CRAN How to install and load Code syntax Function help Update packages Delete packages Dependencies Masked functions Detach / unload Install older version Suggested packages 4.8 Scripts Commenting Style Example Script R markdown R notebooks Shiny Code folding 4.9 Working directory Recommended approach Set by command Set manually Within an R project Working directory in an R markdown Providing file paths 4.10 Objects Everything is an object Defining objects (&lt;-) Object structure Object classes Columns/Variables ($) Access/index with brackets ([ ]) Remove objects 4.11 Piping (%&gt;%) Pipes Define intermediate objects 4.12 Key operators and functions Assignment operators Relational and logical operators Missing values Mathematics and statistics Mathematical operators Mathematical functions Scientific notation Rounding Statistical functions Other useful functions %in% 4.13 Errors &amp; warnings Error versus Warning General syntax tips Code assists 5 Transition to R Placeholder 5.1 From Excel Benefits Tidy data Functions Scripts Excel-to-R resources R-Excel interaction 5.2 From Stata 5.3 From SAS 5.4 Data interoperability 6 Suggested packages Placeholder 6.1 Packages from CRAN 6.2 Packages from Github 7 R projects Placeholder 7.1 Suggested use 7.2 Creating an R project Switch projects Settings Organization Version control 7.3 Examples 7.4 Resources 8 Import and export Placeholder 8.1 Overview 8.2 The rio package 8.3 The here package 8.4 File paths “Relative” file paths “Absolute” file paths Select file manually 8.5 Import data Specific Excel sheets Missing values Skip rows Manage a second header row Remove the second header row Make a data dictionary Combine the two header rows Google sheets 8.6 Multiple files - import, export, split, combine 8.7 Import from Github CSV files XLSX files Shapefiles 8.8 Manual data entry Entry by rows Entry by columns Pasting from clipboard 8.9 Import most recent file Dates in file name Use the file info 8.10 APIs HTTP request Packages Publicly-available data Authentication required 8.11 Export With rio package To clipboard 8.12 RDS files 8.13 Rdata files and lists 8.14 Saving plots 8.15 Resources 9 Cleaning data and core functions Placeholder Core functions Nomenclature 9.1 Cleaning pipeline 9.2 Load packages 9.3 Import data Import Review 9.4 Column names Automatic cleaning Manual name cleaning Rename by column position Rename via select() and summarise() Other challenges Empty Excel column names Merged Excel column names and cells 9.5 Select or re-order columns Keep columns “tidyselect” helper functions Remove columns Standalone Add to the pipe chain 9.6 Deduplication 9.7 Column creation and transformation New columns Convert column class Grouped data Transform multiple columns across() column selection across() functions coalesce() Cumulative math Using base R Add to pipe chain 9.8 Re-code values Specific values By logic Simple logic replace() ifelse() and if_else() Complex logic Missing values Cleaning dictionary Add to pipe chain 9.9 Numeric categories Review distribution age_categories() cut() Quantile breaks Evenly-sized groups case_when() Add to pipe chain 9.10 Add rows One-by-one Bind rows 9.11 Filter rows Simple filter Filter out missing values Filter by row number Complex filter Examine the data How filters handle missing numeric and date values Design the filter Standalone Quickly review records Add to pipe chain 9.12 Row-wise calculations 9.13 Arrange and sort 10 Working with dates Placeholder 10.1 Preparation Load packages Import data 10.2 Current date 10.3 Convert to Date base R lubridate Combine columns 10.4 Excel dates 10.5 Messy dates 10.6 Working with date-time class Convert dates with times Convert times alone Extract time 10.7 Working with dates Extract date components Date math Date intervals 10.8 Date display format() Month-Year 10.9 Epidemiological weeks lubridate Weekly counts Epiweek alternatives 10.10 Converting dates/time zones 10.11 Lagging and leading calculations 10.12 Resources 11 Characters and strings Placeholder 11.1 Preparation Load packages Import data 11.2 Unite, split, and arrange Combine strings Dynamic strings Unite columns Split Split columns Arrange alphabetically base R functions 11.3 Clean and standardise Change case Pad length Truncate Standardize length Remove leading/trailing whitespace Remove repeated whitespace within Wrap into paragraphs 11.4 Handle by position Extract by character position Extract by word position Replace by character position Evaluate length 11.5 Patterns Detect a pattern Convert commas to periods Replace all Detect within logic Locate pattern position Extract a match Subset and count Regex groups 11.6 Special characters 11.7 Regular expressions (regex) 11.8 Regex and special characters 11.9 Resources 12 Factors Placeholder 12.1 Preparation Load packages Import data New categorical variable Create column Default value order 12.2 Convert to factor 12.3 Add or drop levels Add Drop 12.4 Adjust level order Manually Within a plot Reverse By frequency By appearance By summary statistic of another column By “end” value 12.5 Missing values 12.6 Combine levels Manually Reduce into “Other” Reduce by frequency 12.7 Show all levels In plots In tables 12.8 Epiweeks Epiweeks in a plot Epiweeks in the data 12.9 Resources 13 Pivoting data Placeholder 13.1 Preparation Load packages Import data Malaria count data Linelist case data 13.2 Wide-to-long “Wide” format pivot_longer() Standard pivoting Pivoting data of multiple classes 13.3 Long-to-wide Data Pivot wider 13.4 Fill Data fill() 13.5 Resources 14 Grouping data Placeholder 14.1 Preparation Load packages Import data 14.2 Grouping Unique groups New columns Add/drop grouping columns 14.3 Un-group 14.4 Summarise 14.5 Counts and tallies tally() count() Add counts Add totals 14.6 Grouping by date Linelist cases into days Linelist cases into weeks Linelist cases into months Daily counts into weeks Daily counts into months 14.7 Arranging grouped data 14.8 Filter on grouped data filter() Slice rows per group Filter on group size 14.9 Mutate on grouped data 14.10 Select on grouped data 14.11 Resources 15 Joining data Placeholder 15.1 Preparation Load packages Import data Example datasets “Miniature” case linelist Hospital information data frame Pre-cleaning 15.2 dplyr joins General syntax Left and right joins “Should I use a right join, or a left join?” Full join Inner join Semi join Anti join Simple anti_join() example Complex anti_join() example 15.3 Probabalistic matching Probabilistic matching Probabilistic deduplication 15.4 Binding and aligning Bind rows Bind columns Use match() to align ordering 15.5 Resources 16 De-duplication Placeholder 16.1 Preparation Load packages Import data Here is the data frame 16.2 Deduplication Examine duplicate rows Keep only unique rows Deduplicate elements in a vector Using base R 16.3 Slicing Slice with groups Keep all but mark them Calculate row completeness 16.4 Roll-up values Roll-up values into one row Overwrite values/hierarchy 16.5 Probabilistic de-duplication 16.6 Resources 17 Iteration, loops, and lists Placeholder 17.1 Preparation Load packages Import data 17.2 for loops for loops in R Core components Sequence Operations Container Printing Testing your for loop Looping plots Tracking progress of a loop 17.3 purrr and lists Load packages map() Example - import and combine Excel sheets Split dataset and export Split dataset More than one group_split() column Export as Excel sheets Export as CSV files Custom functions Mapping a function across columns Extract from lists Names of elements Elements by name or position pluck() Convert list to data frame Discard, keep, and compact lists pmap() 17.4 Apply functions 17.5 Resources 18 Descriptive tables Placeholder 18.1 Preparation Load packages Import data 18.2 Browse data skimr package Summary statistics 18.3 janitor package Simple tabyl Cross-tabulation “Adorning” the tabyl Printing the tabyl Use on other tables Saving the tabyl Statistics Other tips 18.4 dplyr package Get counts Show all levels Proportions Plotting Summary statistics Conditional statistics Glueing together Percentiles Summarise aggregated data across() multiple columns Pivot wider Total rows janitor’s adorn_totals() summarise() on “total” data and then bind_rows() 18.5 gtsummary package Summary table Adjustments Multi-line stats for continuous variables 18.6 base R Proportions Totals Convert to data frame 18.7 Resources 19 Simple statistical tests Placeholder 19.1 Preparation Load packages Import data 19.2 base R T-tests Shapiro-Wilk test Wilcoxon rank sum test Kruskal-Wallis test Chi-squared test 19.3 rstatix package Summary statistics T-test Shapiro-Wilk test Wilcoxon rank sum test Kruskal-Wallis test Chi-squared test 19.4 gtsummary package Chi-squared test T-tests Wilcoxon rank sum test Kruskal-wallis test 19.5 Correlations 19.6 Resources 20 Univariate and multivariable regression Placeholder 20.1 Preparation Load packages Import data Clean data Store explanatory variables Convert to 1’s and 0’s Drop rows with missing values 20.2 Univariate base R Linear regression Logistic regression Univariate glm() Printing results Looping multiple univariate models gtsummary package 20.3 Stratified 20.4 Multivariable Conduct multivariable Building the model Combine univariate and multivariable Combine with gtsummary Combine with dplyr 20.5 Forest plot ggplot2 package easystats packages 20.6 Resources 21 Missing data Placeholder 21.1 Preparation Load packages Import data Convert missing on import 21.2 Missing values in R NA Versions of NA NULL NaN Inf Examples 21.3 Useful functions is.na() and !is.na() na.omit() drop_na() na.rm = TRUE 21.4 Assess missingness in a data frame Quantifying missingness Visualizing missingness Explore and visualize missingness relationships “Shadow” columns 21.5 Using data with missing values Filter out rows with missing values Handling NA in ggplot() NA in factors 21.6 Imputation Types of missing data Useful packages Mean Imputation Regression imputation LOCF and BOCF Multiple Imputation 21.7 Resources 22 Standardised rates Placeholder 22.1 Overview 22.2 Preparation Load packages Load population data Load death counts Clean populations and deaths Load reference population Clean reference population Create dataset with standard population 22.3 dsr package Standardized rates Standardized rate ratios Standardized rate difference 22.4 PHEindicatormethods package Directly standardized rates Indirectly standardized rates 22.5 Resources 23 Moving averages Placeholder 23.1 Preparation Load packages Import data 23.2 Calculate with slider Rolling by date Indexed data Rolling by group 23.3 Calculate with tidyquant within ggplot() 23.4 Resources 24 Time series and outbreak detection Placeholder 24.1 Overview 24.2 Preparation Packages Load data Clean data Download climate data Load climate data 24.3 Time series data Duplicates Missings 24.4 Descriptive analysis Moving averages Periodicity Decomposition Autocorrelation 24.5 Fitting regressions Fourier terms Negative binomial Residuals 24.6 Relation of two time series Merging datasets Descriptive analysis Lags and cross-correlation Negative binomial with two variables Residuals 24.7 Outbreak detection trending package Cut-off date Add rows Fourier terms Split data and fit regression Prediction validation surveillance package Farrington method GLRNB method 24.8 Interrupted timeseries 24.9 Resources 25 Epidemic modeling Placeholder 25.1 Overview 25.2 Preparation 25.3 Estimating Rt EpiNow2 vs. EpiEstim EpiNow2 Estimating delay distributions Running EpiNow2 Analysing outputs EpiEstim Using serial interval estimates from the literature Using serial interval estimates from the data Specifying estimation time windows Analysing outputs 25.4 Projecting incidence EpiNow2 projections Using serial interval estimates from the literature Using serial interval estimates from the data Projecting incidence 25.5 Resources 26 Contact tracing Placeholder 26.1 Preparation Load packages Import data Case data Contacts data Follow-up data Relationships data 26.2 Descriptive analyses Demographics Age and Gender of contacts Contacts per case 26.3 Contact Follow Up Data cleaning Plot over time Daily individual tracking Analyse by group 26.4 KPI Tables 26.5 Transmission Matrices 26.6 Resources 27 Survey analysis Placeholder 27.1 Overview 27.2 Preparation Packages Load data Clean data 27.3 Survey data 27.4 Observation time 27.5 Weighting 27.6 Survey design objects 27.6.1 Survey package 27.6.2 Srvyr package 27.7 Descriptive analysis 27.7.1 Sampling bias 27.7.2 Demographic pyramids 27.7.3 Alluvial/sankey diagram 27.8 Weighted proportions 27.8.1 Survey package 27.8.2 Srvyr package 27.8.3 Sitrep package 27.8.4 Gtsummary package 27.9 Weighted ratios 27.9.1 Survey package 27.9.2 Srvyr package 27.10 Resources 28 Survival analysis Placeholder 28.1 Overview 28.2 Preparation Load packages Import dataset Data management and transformation 28.3 Basics of survival analysis Building a surv-type object Running initial analyses Cumulative hazard Plotting Kaplan-Meir curves 28.4 Comparison of survival curves Log rank test 28.5 Cox regression analysis Fitting a Cox model Forest plots 28.6 Time-dependent covariates in survival models Time-dependent covariate setup Add unique patient identifier Expand patient rows Cox regression with time-dependent covariates 28.7 Resources 29 GIS basics Placeholder 29.1 Overview 29.2 Key terms GIS software Spatial data Visualizing spatial data 29.3 Getting started with GIS Types of maps for visualizing your data 29.4 Preparation Load packages Sample case data Admin boundary shapefiles Population data Health Facilities 29.5 Plotting coordinates 29.6 Spatial joins Points in polygon Nearest neighbor Buffers Other spatial joins 29.7 Choropleth maps 29.8 Mapping with ggplot2 29.9 Basemaps OpenStreetMap 29.10 Contoured density heatmaps Time series heatmap 29.11 Spatial statistics Spatial relationships Spatial autocorrelation Spatial regression 29.12 Resources 30 Tables for presentation Placeholder 30.1 Preparation Load packages Import data Prepare table 30.2 Basic flextable Create a flextable Column width Column headers Borders and background Font and alignment Merge cells Background color 30.3 Conditional formatting 30.4 All code together 30.5 Saving your table Save single table Print table in R markdown 30.6 Resources 31 ggplot basics Placeholder 31.1 Preparation Load packages Import data General cleaning Pivoting longer 31.2 Basics of ggplot 31.3 ggplot() 31.4 Geoms 31.5 Mapping data to the plot Plot aesthetics Set to a static value Scaled to column values Where to make mapping assignments Groups 31.6 Facets / Small-multiples facet_wrap() facet_grid() Free or fixed axes Factor level order in facets 31.7 Storing plots Saving plots Modifying saved plots Exporting plots 31.8 Labels 31.9 Themes Complete themes Modify theme 31.10 Colors 31.11 Piping into ggplot2 31.12 Plot continuous data Histograms Box plots Violin, jitter, and sina plots Two continuous variables Three continuous variables 31.13 Plot categorical data Preparation Data structure Column class and value ordering geom_bar() geom_col() geom_histogram() 31.14 Resources 32 ggplot tips Placeholder 32.1 Preparation Load packages Import data 32.2 Scales for color, fill, axes, etc. 32.2.1 Color schemes Scales Scale arguments Manual adjustments Continuous axes scales Display percents Log scale Gradient scales Palettes Colorbrewer and Viridis 32.3 Change order of discrete variables 32.3.0.1 ggthemr 32.4 Contour lines 32.5 Marginal distributions 32.6 Smart Labeling 32.7 Time axes 32.8 Highlighting 32.9 Plotting multiple datasets 32.10 Combine plots plot_grid() Combine legends Inset plots 32.11 Dual axes 32.12 Packages to help you Point-and-click ggplot2 with equisse 32.13 Miscellaneous Numeric display 32.14 Resources 33 Epidemic curves Placeholder 33.1 Preparation Packages Import data Set parameters Verify dates 33.2 Epicurves with ggplot2 Specify case bins Weekly epicurve example Sunday weeks Group/color by value Adjust colors Adjust level order Adjust legend Bars side-by-side Axis limits Date-axis labels/gridlines Demonstrations Aggregated data Plotting daily counts Plotting weekly counts Moving averages Faceting/small-multiples Total epidemic in facet background One facet with data 33.3 Tentative data Using annotate() Bars color 33.4 Multi-level date labels 33.5 Dual-axis 33.6 Cumulative Incidence 33.7 Resources 34 Demographic pyramids and Likert-scales Placeholder 34.1 Preparation Load packages Import data Cleaning 34.2 apyramid package Linelist data Missing values Proportions, colors, &amp; aesthetics Aggregated data 34.3 ggplot() Preparation Constructing the plot Compare to baseline 34.4 Likert scale 34.5 Resources 35 Heat plots Placeholder 35.1 Preparation Load packages 35.2 Transmission matrix Data preparation Make cases data frame Make infectors data frame Create heat plot 35.3 Reporting metrics over time Data preparation Aggregate and summarize Create heat plot Basic Cleaned plot Ordered y-axis Display values 35.4 Resources 36 Diagrams and charts Placeholder 36.1 Preparation Load packages Import data 36.2 Flow diagrams Simple examples Syntax Complex examples Outputs Parameterized figures 36.3 Alluvial/Sankey Diagrams Load packages Plotting from dataset 36.4 Event timelines 36.5 DAGs 36.6 Resources 37 Combinations analysis Placeholder 37.1 Preparation Load packages Import data Re-format values 37.2 ggupset 37.3 UpSetR 37.4 Resources 38 Transmission chains 38.1 Overview The primary tool to handle, analyse and visualise transmission chains and contact tracing data is the package epicontacts, developed by the folks at RECON. Try out the interactive plot below by hovering over the nodes for more information, dragging them to move them and clicking on them to highlight downstream cases. 38.2 Preparation Load packages First load the standard packages required for data import and manipulation. In this handbook we emphasize p_load() from pacman, which installs the package if necessary and loads it for use. You can also load packages with library() from base R. See the page on R basics for more information on R packages. pacman::p_load( rio, # File import here, # File locator tidyverse, # Data management + ggplot2 graphics remotes # Package installation from github ) You will require the development version of epicontacts, which can be installed from github using the p_install_github() function from pacman. You only need to run this command below once, not every time you use the package (thereafter, you can use p_load() as usual). pacman::p_install_gh(&quot;reconhub/epicontacts@timeline&quot;) Import data We import the dataset of cases from a simulated Ebola epidemic. If you want to download the data to follow step-by-step, see instructions in the Download handbook and data page. The dataset is imported using the import() function from the rio package. See the page on Import and export for various ways to import data. # import the linelist linelist &lt;- import(&quot;linelist_cleaned.xlsx&quot;) The first 50 rows of the linelist are displayed below. Of particular interest are the columns case_id, generation, infector, and source. Creating an epicontacts object We then need to create an epicontacts object, which requires two types of data: a linelist documenting cases where columns are variables and rows correspond to unique cases a list of edges defining links between cases on the basis of their unique IDs (these can be contacts, transmission events, etc.) As we already have a linelist, we just need to create a list of edges between cases, more specifically between their IDs. We can extract transmission links from the linelist by linking the infector column with the case_id column. At this point we can also add “edge properties”, by which we mean any variable describing the link between the two cases, not the cases themselves. For illustration, we will add a location variable describing the location of the transmission event, and a duration variable describing the duration of the contact in days. In the code below, the dplyr function transmute is similar to mutate, except it only keeps the columns we have specified within the function. The drop_na function will filter out any rows where the specified columns have an NA value; in this case, we only want to keep the rows where the infector is known. ## generate contacts contacts &lt;- linelist %&gt;% transmute( infector = infector, case_id = case_id, location = sample(c(&quot;Community&quot;, &quot;Nosocomial&quot;), n(), TRUE), duration = sample.int(10, n(), TRUE) ) %&gt;% drop_na(infector) We can now create the epicontacts object using the make_epicontacts function. We need to specify which column in the linelist points to the unique case identifier, as well as which columns in the contacts point to the unique identifiers of the cases involved in each link. These links are directional in that infection is going from the infector to the case, so we need to specify the from and to arguments accordingly. We therefore also set the directed argument to TRUE, which will affect future operations. ## generate epicontacts object epic &lt;- make_epicontacts( linelist = linelist, contacts = contacts, id = &quot;case_id&quot;, from = &quot;infector&quot;, to = &quot;case_id&quot;, directed = TRUE ) Upon examining the epicontacts objects, we can see that the case_id column in the linelist has been renamed to id and the case_id and infector columns in the contacts have been renamed to from and to. This ensures consistency in subsequent handling, visualisation and analysis operations. ## view epicontacts object epic ## ## /// Epidemiological Contacts // ## ## // class: epicontacts ## // 5,888 cases in linelist; 3,800 contacts; directed ## ## // linelist ## ## # A tibble: 5,888 × 30 ## id generation date_infection date_onset date_hospitalisation date_outcome ## &lt;chr&gt; &lt;dbl&gt; &lt;date&gt; &lt;date&gt; &lt;date&gt; &lt;date&gt; ## 1 5fe599 4 2014-05-08 2014-05-13 2014-05-15 NA ## 2 8689b7 4 NA 2014-05-13 2014-05-14 2014-05-18 ## 3 11f8ea 2 NA 2014-05-16 2014-05-18 2014-05-30 ## 4 b8812a 3 2014-05-04 2014-05-18 2014-05-20 NA ## 5 893f25 3 2014-05-18 2014-05-21 2014-05-22 2014-05-29 ## 6 be99c8 3 2014-05-03 2014-05-22 2014-05-23 2014-05-24 ## 7 07e3e8 4 2014-05-22 2014-05-27 2014-05-29 2014-06-01 ## 8 369449 4 2014-05-28 2014-06-02 2014-06-03 2014-06-07 ## 9 f393b4 4 NA 2014-06-05 2014-06-06 2014-06-18 ## 10 1389ca 4 NA 2014-06-05 2014-06-07 2014-06-09 ## # ℹ 5,878 more rows ## # ℹ 24 more variables: outcome &lt;chr&gt;, gender &lt;chr&gt;, age &lt;dbl&gt;, age_unit &lt;chr&gt;, ## # age_years &lt;dbl&gt;, age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;, hospital &lt;chr&gt;, lon &lt;dbl&gt;, ## # lat &lt;dbl&gt;, infector &lt;chr&gt;, source &lt;chr&gt;, wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;, ## # ct_blood &lt;dbl&gt;, fever &lt;chr&gt;, chills &lt;chr&gt;, cough &lt;chr&gt;, aches &lt;chr&gt;, ## # vomit &lt;chr&gt;, temp &lt;dbl&gt;, time_admission &lt;chr&gt;, bmi &lt;dbl&gt;, ## # days_onset_hosp &lt;dbl&gt; ## ## // contacts ## ## # A tibble: 3,800 × 4 ## from to location duration ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 f547d6 5fe599 Nosocomial 6 ## 2 f90f5f b8812a Community 10 ## 3 11f8ea 893f25 Nosocomial 10 ## 4 aec8ec be99c8 Community 6 ## 5 893f25 07e3e8 Community 1 ## 6 133ee7 369449 Nosocomial 3 ## 7 996f3a 2978ac Community 2 ## 8 133ee7 57a565 Community 2 ## 9 37a6f6 fc15ef Community 4 ## 10 9f6884 2eaa9a Nosocomial 9 ## # ℹ 3,790 more rows 38.3 Handling Subsetting The subset() method for epicontacts objects allows for, among other things, filtering of networks based on properties of the linelist (“node attributes”) and the contacts database (“edge attributes”). These values must be passed as named lists to the respective argument. For example, in the code below we are keeping only the male cases in the linelist that have an infection date between April and July 2014 (dates are specified as ranges), and transmission links that occured in the hospital. sub_attributes &lt;- subset( epic, node_attribute = list( gender = &quot;m&quot;, date_infection = as.Date(c(&quot;2014-04-01&quot;, &quot;2014-07-01&quot;)) ), edge_attribute = list(location = &quot;Nosocomial&quot;) ) sub_attributes ## ## /// Epidemiological Contacts // ## ## // class: epicontacts ## // 69 cases in linelist; 1,905 contacts; directed ## ## // linelist ## ## # A tibble: 69 × 30 ## id generation date_infection date_onset date_hospitalisation date_outcome ## &lt;chr&gt; &lt;dbl&gt; &lt;date&gt; &lt;date&gt; &lt;date&gt; &lt;date&gt; ## 1 5fe599 4 2014-05-08 2014-05-13 2014-05-15 NA ## 2 893f25 3 2014-05-18 2014-05-21 2014-05-22 2014-05-29 ## 3 2978ac 4 2014-05-30 2014-06-06 2014-06-08 2014-06-15 ## 4 57a565 4 2014-05-28 2014-06-13 2014-06-15 NA ## 5 fc15ef 6 2014-06-14 2014-06-16 2014-06-17 2014-07-09 ## 6 99e8fa 7 2014-06-24 2014-06-28 2014-06-29 2014-07-09 ## 7 f327be 6 2014-06-14 2014-07-12 2014-07-13 2014-07-14 ## 8 90e5fe 5 2014-06-18 2014-07-13 2014-07-14 2014-07-16 ## 9 a47529 5 2014-06-13 2014-07-17 2014-07-18 2014-07-26 ## 10 da8ecb 5 2014-06-20 2014-07-18 2014-07-20 2014-08-01 ## # ℹ 59 more rows ## # ℹ 24 more variables: outcome &lt;chr&gt;, gender &lt;chr&gt;, age &lt;dbl&gt;, age_unit &lt;chr&gt;, ## # age_years &lt;dbl&gt;, age_cat &lt;fct&gt;, age_cat5 &lt;fct&gt;, hospital &lt;chr&gt;, lon &lt;dbl&gt;, ## # lat &lt;dbl&gt;, infector &lt;chr&gt;, source &lt;chr&gt;, wt_kg &lt;dbl&gt;, ht_cm &lt;dbl&gt;, ## # ct_blood &lt;dbl&gt;, fever &lt;chr&gt;, chills &lt;chr&gt;, cough &lt;chr&gt;, aches &lt;chr&gt;, ## # vomit &lt;chr&gt;, temp &lt;dbl&gt;, time_admission &lt;chr&gt;, bmi &lt;dbl&gt;, ## # days_onset_hosp &lt;dbl&gt; ## ## // contacts ## ## # A tibble: 1,905 × 4 ## from to location duration ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 f547d6 5fe599 Nosocomial 6 ## 2 11f8ea 893f25 Nosocomial 10 ## 3 133ee7 369449 Nosocomial 3 ## 4 9f6884 2eaa9a Nosocomial 9 ## 5 4802b1 bbfa93 Nosocomial 3 ## 6 8e104d ddddee Nosocomial 10 ## 7 a15e13 f327be Nosocomial 10 ## 8 894024 e56412 Nosocomial 3 ## 9 d6584f f5c142 Nosocomial 9 ## 10 52ea64 062638 Nosocomial 7 ## # ℹ 1,895 more rows We can use the thin function to either filter the linelist to include cases that are found in the contacts by setting the argument what = &quot;linelist&quot;, or filter the contacts to include cases that are found in the linelist by setting the argument what = &quot;contacts&quot;. In the code below, we are further filtering the epicontacts object to keep only the transmission links involving the male cases infected between April and July which we had filtered for above. We can see that only two known transmission links fit that specification. sub_attributes &lt;- thin(sub_attributes, what = &quot;contacts&quot;) nrow(sub_attributes$contacts) ## [1] 4 In addition to subsetting by node and edge attributes, networks can be pruned to only include components that are connected to certain nodes. The cluster_id argument takes a vector of case IDs and returns the linelist of individuals that are linked, directly or indirectly, to those IDs. In the code below, we can see that a total of 13 linelist cases are involved in the clusters containing 2ae019 and 71577a. sub_id &lt;- subset(epic, cluster_id = c(&quot;2ae019&quot;,&quot;71577a&quot;)) nrow(sub_id$linelist) ## [1] 13 The subset() method for epicontacts objects also allows filtering by cluster size using the cs, cs_min and cs_max arguments. In the code below, we are keeping only the cases linked to clusters of 10 cases or larger, and can see that 271 linelist cases are involved in such clusters. sub_cs &lt;- subset(epic, cs_min = 10) nrow(sub_cs$linelist) ## [1] 271 Accessing IDs The get_id() function retrieves information on case IDs in the dataset, and can be parameterized as follows: linelist: IDs in the line list data contacts: IDs in the contact dataset (“from” and “to” combined) from: IDs in the “from” column of contact datset to IDs in the “to” column of contact dataset all: IDs that appear anywhere in either dataset common: IDs that appear in both contacts dataset and line list For example, what are the first ten IDs in the contacts dataset? contacts_ids &lt;- get_id(epic, &quot;contacts&quot;) head(contacts_ids, n = 10) ## [1] &quot;f547d6&quot; &quot;f90f5f&quot; &quot;11f8ea&quot; &quot;aec8ec&quot; &quot;893f25&quot; &quot;133ee7&quot; &quot;996f3a&quot; &quot;37a6f6&quot; ## [9] &quot;9f6884&quot; &quot;4802b1&quot; How many IDs are found in both the linelist and the contacts? length(get_id(epic, &quot;common&quot;)) ## [1] 4352 38.4 Visualization Basic plotting All visualisations of epicontacts objects are handled by the plot function. We will first filter the epicontacts object to include only the cases with onset dates in June 2014 using the subset function, and only include the contacts linked to those cases using the thin function. ## subset epicontacts object sub &lt;- epic %&gt;% subset( node_attribute = list(date_onset = c(as.Date(c(&quot;2014-06-30&quot;, &quot;2014-06-01&quot;)))) ) %&gt;% thin(&quot;contacts&quot;) We can then create the basic, interactive plot very simply as follows: ## plot epicontacts object plot( sub, width = 700, height = 700 ) You can move the nodes around by dragging them, hover over them for more information and click on them to highlight connected cases. There are a large number of arguments to further modify this plot. We will cover the main ones here, but check out the documentation via ?vis_epicontacts (the function called when using plot on an epicontacts object) to get a full description of the function arguments. Visualising node attributes Node color, node shape and node size can be mapped to a given column in the linelist using the node_color, node_shape and node_size arguments. This is similar to the aes syntax you may recognise from ggplot2. The specific colors, shapes and sizes of nodes can be specified as follows: Colors via the col_pal argument, either by providing a name list for manual specification of each color as done below, or by providing a color palette function such as colorRampPalette(c(&quot;black&quot;, &quot;red&quot;, &quot;orange&quot;)), which would provide a gradient of colours between the ones specified. Shapes by passing a named list to the shapes argument, specifying one shape for each unique element in the linelist column specified by the node_shape argument. See codeawesome for available shapes. Size by passing a size range of the nodes to the size_range argument. Here an example, where color represents the outcome, shape the gender and size the age: plot( sub, node_color = &quot;outcome&quot;, node_shape = &quot;gender&quot;, node_size = &quot;age&quot;, col_pal = c(Death = &quot;firebrick&quot;, Recover = &quot;green&quot;), shapes = c(f = &quot;female&quot;, m = &quot;male&quot;), size_range = c(40, 60), height = 700, width = 700 ) Visualising edge attributes Edge color, width and linetype can be mapped to a given column in the contacts dataframe using the edge_color, edge_width and edge_linetype arguments. The specific colors and widths of the edges can be specified as follows: Colors via the edge_col_pal argument, in the same manner used for col_pal. Widths by passing a size range of the nodes to the width_range argument. Here an example: plot( sub, node_color = &quot;outcome&quot;, node_shape = &quot;gender&quot;, node_size = &#39;age&#39;, col_pal = c(Death = &quot;firebrick&quot;, Recover = &quot;green&quot;), shapes = c(f = &quot;female&quot;, m = &quot;male&quot;), size_range = c(40, 60), edge_color = &#39;location&#39;, edge_linetype = &#39;location&#39;, edge_width = &#39;duration&#39;, edge_col_pal = c(Community = &quot;orange&quot;, Nosocomial = &quot;purple&quot;), width_range = c(1, 3), height = 700, width = 700 ) Temporal axis We can also visualise the network along a temporal axis by mapping the x_axis argument to a column in the linelist. In the example below, the x-axis represents the date of symptom onset. We have also specified the arrow_size argument to ensure the arrows are not too large, and set label = FALSE to make the figure less cluttered. plot( sub, x_axis = &quot;date_onset&quot;, node_color = &quot;outcome&quot;, col_pal = c(Death = &quot;firebrick&quot;, Recover = &quot;green&quot;), arrow_size = 0.5, node_size = 13, label = FALSE, height = 700, width = 700 ) There are a large number of additional arguments to futher specify how this network is visualised along a temporal axis, which you can check out via ?vis_temporal_interactive (the function called when using plot on an epicontacts object with x_axis specified). We’ll go through some below. Specifying transmission tree shape There are two main shapes that the transmission tree can assume, specified using the network_shape argument. The first is a branching shape as shown above, where a straight edge connects any two nodes. This is the most intuitive representation, however can result in overlapping edges in a densely connected network. The second shape is rectangle, which produces a tree resembling a phylogeny. For example: plot( sub, x_axis = &quot;date_onset&quot;, network_shape = &quot;rectangle&quot;, node_color = &quot;outcome&quot;, col_pal = c(Death = &quot;firebrick&quot;, Recover = &quot;green&quot;), arrow_size = 0.5, node_size = 13, label = FALSE, height = 700, width = 700 ) Each case node can be assigned a unique vertical position by toggling the position_dodge argument. The position of unconnected cases (i.e. with no reported contacts) is specified using the unlinked_pos argument. plot( sub, x_axis = &quot;date_onset&quot;, network_shape = &quot;rectangle&quot;, node_color = &quot;outcome&quot;, col_pal = c(Death = &quot;firebrick&quot;, Recover = &quot;green&quot;), position_dodge = TRUE, unlinked_pos = &quot;bottom&quot;, arrow_size = 0.5, node_size = 13, label = FALSE, height = 700, width = 700 ) The position of the parent node relative to the children nodes can be specified using the parent_pos argument. The default option is to place the parent node in the middle, however it can be placed at the bottom (parent_pos = &#39;bottom&#39;) or at the top (parent_pos = &#39;top&#39;). plot( sub, x_axis = &quot;date_onset&quot;, network_shape = &quot;rectangle&quot;, node_color = &quot;outcome&quot;, col_pal = c(Death = &quot;firebrick&quot;, Recover = &quot;green&quot;), parent_pos = &quot;top&quot;, arrow_size = 0.5, node_size = 13, label = FALSE, height = 700, width = 700 ) Saving plots and figures You can save a plot as an interactive, self-contained html file with the visSave function from the VisNetwork package: plot( sub, x_axis = &quot;date_onset&quot;, network_shape = &quot;rectangle&quot;, node_color = &quot;outcome&quot;, col_pal = c(Death = &quot;firebrick&quot;, Recover = &quot;green&quot;), parent_pos = &quot;top&quot;, arrow_size = 0.5, node_size = 13, label = FALSE, height = 700, width = 700 ) %&gt;% visNetwork::visSave(&quot;network.html&quot;) Saving these network outputs as an image is unfortunately less easy and requires you to save the file as an html and then take a screenshot of this file using the webshot package. In the code below, we are converting the html file saved above into a PNG: webshot(url = &quot;network.html&quot;, file = &quot;network.png&quot;) Timelines You can also case timelines to the network, which are represented on the x-axis of each case. This can be used to visualise case locations, for example, or time to outcome. To generate a timeline, we need to create a data.frame of at least three columns indicating the case ID, the start date of the “event” and the end of date of the “event”. You can also add any number of other columns which can then be mapped to node and edge properties of the timeline. In the code below, we generate a timeline going from the date of symptom onset to the date of outcome, and keep the outcome and hospital variables which we use to define the node shape and colour. Note that you can have more than one timeline row/event per case, for example if a case is transferred between multiple hospitals. ## generate timeline timeline &lt;- linelist %&gt;% transmute( id = case_id, start = date_onset, end = date_outcome, outcome = outcome, hospital = hospital ) We then pass the timeline element to the timeline argument. We can map timeline attributes to timeline node colours, shapes and sizes in the same way defined in previous sections, except that we have two nodes: the start and end node of each timeline, which have seperate arguments. For example, tl_start_node_color defines which timeline column is mapped to the colour of the start node, while tl_end_node_shape defines which timeline column is mapped to the shape of the end node. We can also map colour, width, linetype and labels to the timeline edge via the tl_edge_* arguments. See ?vis_temporal_interactive (the function called when plotting an epicontacts object) for detailed documentation on the arguments. Each argument is annotated in the code below too: ## define shapes shapes &lt;- c( f = &quot;female&quot;, m = &quot;male&quot;, Death = &quot;user-times&quot;, Recover = &quot;heartbeat&quot;, &quot;NA&quot; = &quot;question-circle&quot; ) ## define colours colours &lt;- c( Death = &quot;firebrick&quot;, Recover = &quot;green&quot;, &quot;NA&quot; = &quot;grey&quot; ) ## make plot plot( sub, ## max x coordinate to date of onset x_axis = &quot;date_onset&quot;, ## use rectangular network shape network_shape = &quot;rectangle&quot;, ## mape case node shapes to gender column node_shape = &quot;gender&quot;, ## we don&#39;t want to map node colour to any columns - this is important as the ## default value is to map to node id, which will mess up the colour scheme node_color = NULL, ## set case node size to 30 (as this is not a character, node_size is not ## mapped to a column but instead interpreted as the actual node size) node_size = 30, ## set transmission link width to 4 (as this is not a character, edge_width is ## not mapped to a column but instead interpreted as the actual edge width) edge_width = 4, ## provide the timeline object timeline = timeline, ## map the shape of the end node to the outcome column in the timeline object tl_end_node_shape = &quot;outcome&quot;, ## set the size of the end node to 15 (as this is not a character, this ## argument is not mapped to a column but instead interpreted as the actual ## node size) tl_end_node_size = 15, ## map the colour of the timeline edge to the hospital column tl_edge_color = &quot;hospital&quot;, ## set the width of the timeline edge to 2 (as this is not a character, this ## argument is not mapped to a column but instead interpreted as the actual ## edge width) tl_edge_width = 2, ## map edge labels to the hospital variable tl_edge_label = &quot;hospital&quot;, ## specify the shape for everyone node attribute (defined above) shapes = shapes, ## specify the colour palette (defined above) col_pal = colours, ## set the size of the arrow to 0.5 arrow_size = 0.5, ## use two columns in the legend legend_ncol = 2, ## set font size font_size = 15, ## define formatting for dates date_labels = c(&quot;%d %b %Y&quot;), ## don&#39;t plot the ID labels below nodes label = FALSE, ## specify height height = 1000, ## specify width width = 1200, ## ensure each case node has a unique y-coordinate - this is very important ## when using timelines, otherwise you will have overlapping timelines from ## different cases position_dodge = TRUE ) ## Warning in assert_timeline(timeline, x, x_axis): 5865 timeline row(s) removed ## as ID not found in linelist or start/end date is NA 38.5 Analysis Summarising We can get an overview of some of the network properties using the summary function. ## summarise epicontacts object summary(epic) ## ## /// Overview // ## // number of unique IDs in linelist: 5888 ## // number of unique IDs in contacts: 5511 ## // number of unique IDs in both: 4352 ## // number of contacts: 3800 ## // contacts with both cases in linelist: 56.868 % ## ## /// Degrees of the network // ## // in-degree summary: ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.0000 0.0000 1.0000 0.5392 1.0000 1.0000 ## ## // out-degree summary: ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.0000 0.0000 0.0000 0.5392 1.0000 6.0000 ## ## // in and out degree summary: ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.000 1.000 1.000 1.078 1.000 7.000 ## ## /// Attributes // ## // attributes in linelist: ## generation date_infection date_onset date_hospitalisation date_outcome outcome gender age age_unit age_years age_cat age_cat5 hospital lon lat infector source wt_kg ht_cm ct_blood fever chills cough aches vomit temp time_admission bmi days_onset_hosp ## ## // attributes in contacts: ## location duration For example, we can see that only 57% of contacts have both cases in the linelist; this means that the we do not have linelist data on a significant number of cases involved in these transmission chains. Pairwise characteristics The get_pairwise() function allows processing of variable(s) in the line list according to each pair in the contact dataset. For the following example, date of onset of disease is extracted from the line list in order to compute the difference between disease date of onset for each pair. The value that is produced from this comparison represents the serial interval (si). si &lt;- get_pairwise(epic, &quot;date_onset&quot;) summary(si) ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## 0.00 5.00 9.00 11.01 15.00 99.00 1820 tibble(si = si) %&gt;% ggplot(aes(si)) + geom_histogram() + labs( x = &quot;Serial interval&quot;, y = &quot;Frequency&quot; ) ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. ## Warning: Removed 1820 rows containing non-finite values (`stat_bin()`). The get_pairwise() will interpret the class of the column being used for comparison, and will adjust its method of comparing the values accordingly. For numbers and dates (like the si example above), the function will subtract the values. When applied to columns that are characters or categorical, get_pairwise() will paste values together. Because the function also allows for arbitrary processing (see “f” argument), these discrete combinations can be easily tabulated and analyzed. head(get_pairwise(epic, &quot;gender&quot;), n = 10) ## [1] &quot;f -&gt; m&quot; NA &quot;m -&gt; m&quot; NA &quot;m -&gt; f&quot; &quot;f -&gt; f&quot; NA &quot;f -&gt; m&quot; ## [9] NA &quot;m -&gt; f&quot; get_pairwise(epic, &quot;gender&quot;, f = table) ## values.to ## values.from f m ## f 464 516 ## m 510 468 fisher.test(get_pairwise(epic, &quot;gender&quot;, f = table)) ## ## Fisher&#39;s Exact Test for Count Data ## ## data: get_pairwise(epic, &quot;gender&quot;, f = table) ## p-value = 0.03758 ## alternative hypothesis: true odds ratio is not equal to 1 ## 95 percent confidence interval: ## 0.6882761 0.9892811 ## sample estimates: ## odds ratio ## 0.8252575 Here, we see a significant association between transmission links and gender. Identifying clusters The get_clusters() function can be used for to identify connected components in an epicontacts object. First, we use it to retrieve a data.frame containing the cluster information: clust &lt;- get_clusters(epic, output = &quot;data.frame&quot;) table(clust$cluster_size) ## ## 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ## 1536 1680 1182 784 545 342 308 208 171 100 99 24 26 42 ggplot(clust, aes(cluster_size)) + geom_bar() + labs( x = &quot;Cluster size&quot;, y = &quot;Frequency&quot; ) Let us look at the largest clusters. For this, we add cluster information to the epicontacts object and then subset it to keep only the largest clusters: epic &lt;- get_clusters(epic) max_size &lt;- max(epic$linelist$cluster_size) plot(subset(epic, cs = max_size)) Calculating degrees The degree of a node corresponds to its number of edges or connections to other nodes. get_degree() provides an easy method for calculating this value for epicontacts networks. A high degree in this context indicates an individual who was in contact with many others. The type argument indicates that we want to count both the in-degree and out-degree, the only_linelist argument indicates that we only want to calculate the degree for cases in the linelist. deg_both &lt;- get_degree(epic, type = &quot;both&quot;, only_linelist = TRUE) Which individuals have the ten most contacts? head(sort(deg_both, decreasing = TRUE), 10) ## 916d0a 858426 6833d7 f093ea 11f8ea 3a4372 38fc71 c8c4d5 a127a7 02d8fd ## 7 6 6 6 5 5 5 5 5 5 What is the mean number of contacts? mean(deg_both) ## [1] 1.078473 38.6 Resources The epicontacts page provides an overview of the package functions and includes some more in-depth vignettes. The github page can be used to raise issues and request features. 39 Phylogenetic trees Placeholder 39.1 Overview 39.2 Preparation Load packages Import data Clean and inspect 39.3 Simple tree visualization Different tree layouts Simple tree plus sample data 39.4 Tree manipulation Zoom in Collapsing branches Subsetting a tree Rotating nodes in a tree Example subtree with sample data annotation More complex trees: adding heatmaps of sample data 39.5 Resources 40 Interactive plots Placeholder 40.1 Preparation Load packages Start with a ggplot() Import data 40.2 Plot with ggplotly() 40.3 Modifications File size Buttons 40.4 Heat tiles 40.5 Resources 41 Reports with R Markdown Placeholder 41.1 Preparation 41.2 Getting started Install rmarkdown R package Starting a new Rmd file Important to know 41.3 R Markdown components YAML metadata Text New lines Case Color Titles and headings Bullets and numbering Comment out text Code chunks In-text R code Images Tables Tabbed sections 41.4 File structure Self-contained Rmd Source other files Runfile Folder strucutre 41.5 Producing the document Option 1: “Knit” button Option 2: render() command Options 3: reportfactory package 41.6 Parameterised reports Setting parameters Option 1: Set parameters within YAML Option 2: Set parameters within render() Option 3: Set parameters using a Graphical User Interface Parameterized example Parameterisation without params 41.7 Looping reports 41.8 Templates Word documents Powerpoint documents Integrating templates into the YAML Formatting HTML files 41.9 Dynamic content Tables HTML widgets 41.10 Resources 42 Organizing routine reports Placeholder 42.1 Preparation Load packages 42.2 New factory 42.3 Create a report 42.4 Compile Compile by name Compile by number Compile all Compile from sub-folder Parameterization Using a “run-file” 42.5 Outputs 42.6 Miscellaneous Knit Scripts Extras 42.7 Resources 43 Dashboards with R Markdown Placeholder 43.1 Preparation Load packages Import data 43.2 Create new R Markdown 43.3 The script YAML Code chunks Narrative text Headings 43.4 Section attributes 43.5 Layout Pages Orientation Tabs 43.6 Adding content Text Tables Plots Interactive plots HTML widgets 43.7 Code organization 43.8 Shiny Settings Worked example Other examples 43.9 Sharing 43.10 Resources 44 Dashboards with Shiny Placeholder 44.1 Preparation Load packages Import data 44.2 The structure of a shiny app Basic file structures The server and the ui Before you start to build an app 44.3 Building a UI 44.4 Loading data into our app 44.5 Developing an app server 44.6 Adding more functionality Adding static text Adding a link Adding a download button Adding a facility selector Adding another tab with a table 44.7 Sharing shiny apps 44.8 Further reading 44.9 Recommended extension packages 44.10 Recommended resources 45 Writing functions Placeholder 45.1 Preparation Load packages Import data 45.2 Functions 45.3 Why would you use a function? 45.4 How does R build functions? 45.5 Basic syntax and structure 45.6 Examples Return proportion tables for several columns 45.7 Using purrr: writing functions that can be iteratively applied Modify class of multiple columns in a dataset Iteratively produce graphs for different levels of a variable Iteratively produce tables for different levels of a variable 45.8 Tips and best Practices for well functioning functions Naming and syntax Column names and tidy evaluation Testing and Error handling 45.9 Resources 46 Directory interactions Placeholder 46.1 Preparation fs package Print directory as a dendrogram tree 46.2 List files in a directory 46.3 File information 46.4 Check if exists R objects Directories Files 46.5 Create Directories Files Create if does not exists 46.6 Delete R objects Directories Files 46.7 Running other files source() render() Run files in a directory Import files in a directory 46.8 base R 46.9 Resources 47 Version control and collaboration with Git and Github Placeholder 47.1 What is Git? 47.2 Why use the combo Git and Github? This sounds complicated, I am not a programmer 47.3 Setup Install Git Install an interface (optional but recommended) Github account 47.4 Vocabulary, concepts and basic functions Repository Commits Branches Local and remote repositories 47.5 Get started: create a new repository Start-up files Create a new repository in Github Clone from a Github repository In Rstudio In Github Desktop New Github repo from existing R project What does it look like now? In RStudio In Github Desktop 47.6 Git + Github workflow Process overview 47.7 Create a new branch In Rstudio Git pane In Github Desktop In console 47.8 Commit changes In Rstudio In Github Desktop In console Amend a previous commit 47.9 Pull and push changes up to Github In Rstudio In Github Desktop Console I want to pull but I have local work 47.10 Merge branch into Main Locally in Github Desktop In console In Github: submitting pull requests Resolving conflicts Delete your branch 47.10.0.1 Github + Rstudio 47.10.0.2 In Github Desktop Forking 47.11 What we learned 47.12 Git commands Recommended learning Where to enter commands Sample commands 47.13 Resources 48 Common errors Placeholder 48.1 Interpreting error messages 48.2 Common errors Typo errors Package errors Object errors Function syntax errors Logic errors Factor errors Plotting errors R Markdown errors Miscellaneous 48.3 Resources 49 Getting help Placeholder 49.1 Github issues 49.2 Reproducible example The reprex package Minimal data 49.3 Posting to a forum 49.4 Resources 50 R on network drives Placeholder 50.1 Overview 50.2 RStudio as administrator 50.3 Useful commands 50.4 Troubleshooting common errors 51 Data Table Placeholder 51.1 Intro to data tables 51.2 Load packages and import data Load packages Import data 51.3 The i argument: selecting and filtering rows Using helper functions for filtering 51.4 The j argument: selecting and computing on columns Selecting columns Computing on columns 51.5 The by argument: computing by groups 51.6 Adding and updating to data tables 51.7 Resources "]]
