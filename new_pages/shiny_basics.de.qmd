# Dashboards mit Shiny { }

Dashboards sind oft eine gute Möglichkeit, um Ergebnisse von Analysen mit anderen zu teilen. Die Erstellung eines Dashboards mit **glänzenden** zu erstellen, erfordert relativ gute Kenntnisse der Sprache R, bietet aber unglaubliche Anpassungsmöglichkeiten.

<!-- Einer der größten Nachteile von `R` ist seine Nutzbarkeit für Menschen, die neu in der Programmiersprache sind oder keine Erfahrung damit haben. Obwohl diese Fähigkeiten sehr wertvoll sind, werden die meisten Menschen feststellen, dass dies ein Hindernis für den Austausch von Analysen darstellt, besonders in multidisziplinären Umgebungen. Es ist ein gewisser Aufwand, eine R-Installation zu pflegen, und nicht jeder wird sich wohl dabei fühlen, gemeinsamen Code auszuführen, selbst wenn er gut dokumentiert und leicht zu lesen ist. Das gilt vor allem dann, wenn die Benutzer/innen Parameter des Codes ändern müssen!  -->

<!-- R-basierte Dashboards haben auch den Vorteil, dass sie zentralisieren, wie der Code ausgeführt wird - wenn derselbe Code auf verschiedenen Rechnern ausgeführt wird, müssen die Leute oft mit unterschiedlichen Dateipfaden, unterschiedlichen R-Versionen und unterschiedlichen Paketinstallationen umgehen. Aus diesem Grund sind Dashboards eine großartige Möglichkeit, Code auf benutzerfreundliche Weise mit anderen zu teilen! -->

Es wird empfohlen, dass jemand, der Dashboards mit **shiny** über gute Kenntnisse in der Datentransformation und -visualisierung verfügt und mit dem Debuggen von Code und dem Schreiben von Funktionen vertraut ist. Die Arbeit mit Dashboards ist am Anfang nicht intuitiv und manchmal schwer zu verstehen, aber es ist eine großartige Fähigkeit, die mit etwas Übung viel einfacher wird!

Diese Seite gibt einen kurzen Überblick darüber, wie du Dashboards mit **shiny** und seinen Erweiterungen erstellt.
Eine alternative Methode zur Erstellung von Dashboards, die schneller und einfacher ist, aber vielleicht weniger anpassbar, findest du auf der Seite **flextable**([Dashboards mit R Markdown]).

## Vorbereitung

### Pakete laden {.unnumbered}

In diesem Handbuch betonen wir `p_load()` von **pacman**, der das Paket bei Bedarf installiert *und* lädt es zur Verwendung. Du kannst installierte Pakete auch laden mit `library()` von **base**R. Siehe die Seite über [R-Grundlagen] für weitere Informationen über R-Pakete.

Wir beginnen mit der Installation des **glänzenden** R-Paket:

```{r, eval=FALSE}
pacman::p_load(shiny)
```

### Daten importieren {.unnumbered}

Wenn du diese Seite weiterverfolgen möchtest, findest du in diesem Abschnitt der [Handbuch und Daten herunterladen](#data_shiny). Dort findest du Links zum Herunterladen der R-Skripte und Datendateien, die die endgültige Shiny-App erzeugen.

Wenn du versuchst, die App mit diesen Dateien zu rekonstruieren, beachte bitte die Ordnerstruktur des R-Projekts, die im Laufe der Demonstration erstellt wird (z. B. Ordner für "data" und für "funcs").

<!-- ======================================================= -->

## Die Struktur einer Shiny App {  }

### Grundlegende Dateistrukturen {.unnumbered}

Zu verstehen `shiny` zu verstehen, müssen wir zuerst verstehen, wie die Dateistruktur einer App funktioniert! Bevor wir anfangen, sollten wir ein neues Verzeichnis anlegen. Das geht einfacher, wenn du *Neues Projekt* in *Rstudio* und wählt *Shiny Web-Anwendung*. Dadurch wird die Grundstruktur einer Shiny App für dich erstellt.

Wenn du dieses Projekt öffnest, wirst du feststellen, dass es eine `.R` Datei bereits vorhanden ist, die *app.R*. Sie ist *wichtig* dass wir eine von zwei grundlegenden Dateistrukturen haben:

1. Eine Datei namens *app.R*, *oder*
2. Zwei Dateien, eine mit dem Namen *ui.R* und die andere *server.R*

Auf dieser Seite verwenden wir den ersten Ansatz mit einer Datei namens *app.R*. Hier ist ein Beispielskript:

```{r, eval=FALSE}
# an example of app.R

library(shiny)

ui <- fluidPage(

    # Application title
    titlePanel("My app"),

    # Sidebar with a slider input widget
    sidebarLayout(
        sidebarPanel(
            sliderInput("input_1")
        ),

        # Show a plot 
        mainPanel(
           plotOutput("my_plot")
        )
    )
)

# Define server logic required to draw a histogram
server <- function(input, output) {
     
     plot_1 <- reactive({
          plot_func(param = input_1)
     })
     
    output$my_plot <- renderPlot({
       plot_1()
    })
}


# Run the application 
shinyApp(ui = ui, server = server)


```

Wenn du diese Datei öffnest, wirst du feststellen, dass zwei Objekte definiert sind - eines heißt `ui` und ein weiteres namens `server`. Diese Objekte *müssen* definiert werden in *jeder* glänzenden App und sind zentral für die Struktur der App selbst! Der einzige Unterschied zwischen den beiden oben beschriebenen Dateistrukturen ist, dass in Struktur 1 beide `ui` und `server` in einer Datei definiert sind, während sie in Struktur 2 in separaten Dateien definiert sind. Hinweis: Wir können (und sollten, wenn wir eine größere Anwendung haben) auch andere .R-Dateien in unserer Struktur haben, die wir `source()` in unsere App integrieren.

### Der Server und die Benutzeroberfläche {.unnumbered}

Als nächstes müssen wir verstehen, was der `server` und `ui` Objekte eigentlich *tun*. *Einfach ausgedrückt sind dies zwei Objekte, die miteinander interagieren, wenn der Nutzer mit der Shiny App interagiert.*

Das UI-Element einer Shiny App ist, vereinfacht gesagt, R-Code, der eine HTML-Oberfläche erstellt. Das bedeutet, dass alles, was *angezeigt* in der Benutzeroberfläche einer App angezeigt wird. Dazu gehören im Allgemeinen:

- "Widgets" - Dropdown-Menüs, Kontrollkästchen, Schieberegler usw., mit denen der Nutzer interagieren kann
- Plots, Tabellen usw. - Ausgaben, die mit R-Code erzeugt werden
- Navigationsaspekte einer App - Registerkarten, Fenster usw.
- Allgemeiner Text, Hyperlinks, etc.
- HTML- und CSS-Elemente (wird später behandelt)

Das Wichtigste, was du über die Benutzeroberfläche wissen musst, ist, dass sie *Eingaben empfängt* vom Benutzer und *zeigt Ausgaben an* des Servers an. Es gibt keine *aktive* Code, der in der Benutzeroberfläche *zu jeder Zeit* - Alle Änderungen in der Benutzeroberfläche werden (mehr oder weniger) über den Server übertragen. Wir müssen also unsere Plots, Downloads usw. auf dem Server erstellen.

Der Server der Shiny App ist der Ort, an dem der gesamte Code ausgeführt wird, sobald die App gestartet wird. Die Art und Weise, wie das funktioniert, ist etwas verwirrend. Die Serverfunktion wird effektiv *reagieren* auf die Interaktion des Benutzers mit der Benutzeroberfläche und führt als Reaktion darauf Codeschnipsel aus. Wenn sich etwas auf dem Server ändert, wird dies an die Benutzeroberfläche weitergegeben, wo die Änderungen sichtbar sind. Wichtig ist, dass der Code auf dem Server ausgeführt wird *nicht aufeinanderfolgend* ausgeführt (oder man kann es sich am besten so vorstellen). Immer wenn eine UI-Eingabe einen Teil des Codes im Server beeinflusst, wird dieser automatisch ausgeführt und die entsprechende Ausgabe wird erzeugt und angezeigt.

Das hört sich jetzt wahrscheinlich alles sehr abstrakt an, also müssen wir uns ein paar Beispiele ansehen, um eine klare Vorstellung davon zu bekommen, wie das Ganze funktioniert.

### Bevor du mit der Entwicklung einer App beginnst {.unnumbered}

Bevor du mit der Entwicklung einer App beginnst, ist es sehr hilfreich zu wissen *was* du bauen willst. Da deine Benutzeroberfläche in Code geschrieben wird, kannst du dir nicht wirklich vorstellen, was du bauen willst, es sei denn, du hast ein bestimmtes Ziel. Aus diesem Grund ist es sehr hilfreich, sich viele Beispiele für glänzende Apps anzusehen, um eine Vorstellung davon zu bekommen, was du machen kannst - noch besser ist es, wenn du dir den Quellcode dieser Apps ansehen kannst! Einige gute Quellen dafür sind:

- Die [Rstudio App-Galerie](https://shiny.rstudio.com/gallery/)

Sobald du eine Vorstellung davon hast, was möglich ist, ist es auch hilfreich, eine Skizze zu machen, wie deine App aussehen soll - das kannst du auf Papier oder in einem beliebigen Zeichenprogramm (PowerPoint, MS Paint usw.) machen. Es ist hilfreich, bei deiner ersten App einfach anzufangen! Es ist auch keine Schande, den Code einer schönen App, die du online findest, als Vorlage für deine Arbeit zu verwenden - das ist viel einfacher, als etwas von Grund auf neu zu bauen!

## Eine Benutzeroberfläche bauen

Bei der Entwicklung unserer App ist es einfacher, zuerst an der Benutzeroberfläche zu arbeiten, damit wir sehen können, was wir machen, und nicht riskieren, dass die App aufgrund von Serverfehlern fehlschlägt. Wie bereits erwähnt, ist es oft gut, bei der Arbeit an der Benutzeroberfläche eine Vorlage zu verwenden. Es gibt eine Reihe von Standardlayouts, die mit Shiny verwendet werden können und die im Basispaket von Shiny enthalten sind. `shinydashboard`. Für den Anfang verwenden wir ein Beispiel aus dem Basispaket von Shiny.

Eine Shiny UI wird im Allgemeinen als eine Reihe von verschachtelten Funktionen in der folgenden Reihenfolge definiert

1. Eine Funktion, die das allgemeine Layout definiert (die grundlegendste ist `fluidPage()`, aber es gibt noch mehr)
2. Panels innerhalb des Layouts wie z. B:
  - eine Seitenleiste (`sidebarPanel()`)
  - ein "Haupt"-Panel (`mainPanel()`)
  - eine Registerkarte (`tabPanel()`)
  - eine generische "Spalte" (`column()`)
3. Widgets und Ausgaben - diese können Eingaben an den Server (Widgets) oder Ausgaben vom Server (Ausgaben) vermitteln
  - Widgets sind in der Regel gestylt als `xxxInput()` z.B. `selectInput()`
  - Die Ausgaben sind in der Regel gestylt als `xxxOutput()` z.B. `plotOutput()`

Es lohnt sich, noch einmal darauf hinzuweisen, dass diese nicht einfach auf abstrakte Weise visualisiert werden können, daher ist es am besten, sich ein Beispiel anzusehen! Stellen wir uns eine einfache App vor, die unsere Daten zur Anzahl der Malaria-Einrichtungen nach Bezirken visualisiert. Diese Daten haben viele verschiedene Parameter, also wäre es toll, wenn der Endnutzer einige Filter anwenden könnte, um die Daten nach Altersgruppen/Bezirken zu sehen, wie es ihm passt! Für den Anfang können wir ein sehr einfaches, glänzendes Layout verwenden - das Sidebar-Layout. Dabei handelt es sich um ein Layout, bei dem die Widgets in einer Seitenleiste auf der linken Seite und die Grafik auf der rechten Seite platziert sind.

Planen wir unsere App - wir können mit einem Selektor beginnen, mit dem wir den Bezirk auswählen können, in dem wir die Daten visualisieren wollen, und mit einem weiteren, mit dem wir die Altersgruppe visualisieren können, an der wir interessiert sind. Mit diesen Filtern wollen wir eine Epikurve anzeigen, die diese Parameter widerspiegelt. Dafür brauchen wir also:

1. Zwei Dropdown-Menüs, mit denen wir den gewünschten Bezirk und die gewünschte Altersgruppe auswählen können.
2. Ein Bereich, in dem wir unsere resultierende Epikurve anzeigen können.

Das könnte etwa so aussehen:

```{r, eval=FALSE}

library(shiny)

ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         # selector for district
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = c(
                   "All",
                   "Spring",
                   "Bolo",
                   "Dingo",
                   "Barnard"
              ),
              selected = "All",
              multiple = TRUE
         ),
         # selector for age group
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         )

    ),

    mainPanel(
      # epicurve goes here
      plotOutput("malaria_epicurve")
    )
    
  )
)


```

Wenn app.R mit dem obigen UI-Code ausgeführt wird (ohne aktiven Code in der `server` Teil von app.R), sieht das Layout so aus - beachte, dass es keinen Plot gibt, wenn es keinen Server gibt, der ihn rendert, aber unsere Eingaben funktionieren!

```{r, out.width=c("100%"), out.height=c("100%"), echo=F}
knitr::include_graphics(here::here("images", "shiny", "simple_UI_view.png"))
```

Dies ist eine gute Gelegenheit, um die Funktionsweise der Widgets zu besprechen - beachte, dass jedes Widget ein `inputId`, a `label` und eine Reihe anderer Optionen, die für den jeweiligen Widget-Typ spezifisch sind. Diese `inputId` ist sehr wichtig - mit diesen IDs werden Informationen von der Benutzeroberfläche an den Server weitergegeben. Aus diesem Grund müssen sie *müssen sie eindeutig sein*. Du solltest dich bemühen, ihnen einen sinnvollen Namen zu geben, der sich auf das bezieht, womit sie interagieren, wenn es sich um größere Apps handelt.

Du solltest die Dokumentation genau lesen, um zu erfahren, was die einzelnen Widgets tun. Je nach Widget-Typ übermitteln die Widgets bestimmte Arten von Daten an den Server, die du genau kennen musst. Zum Beispiel, `selectInput()` einen Zeichentyp an den Server weiter:

- Wenn wir wählen *Frühling* für das erste Widget hier auswählen, wird es das Zeichenobjekt `"Spring"` an den Server weiter.
- Wenn wir zwei Elemente aus dem Dropdown-Menü auswählen, werden sie als Zeichenvektor übermittelt (z. B. `c("Spring", "Bolo")`).

Andere Widgets übermitteln andere Objekttypen an den Server! Zum Beispiel:

- `numericInput()` übergibt ein numerisches Objekt an den Server
- `checkboxInput()` übergibt ein Objekt vom logischen Typ an den Server (`TRUE` oder `FALSE`)

Es ist auch erwähnenswert, dass die *benannter Vektor* den wir hier für die Altersdaten verwendet haben. Bei vielen Widgets werden bei der Verwendung eines benannten Vektors als Auswahlmöglichkeit die *Namen* des Vektors als Auswahlmöglichkeiten angezeigt, aber die ausgewählten *Wert* aus dem Vektor an den Server weiter. Hier kann jemand z. B. "15+" aus dem Dropdown-Menü auswählen, und die Benutzeroberfläche wird den Wert an den Server weitergeben. `"malaria_rdt_15"` an den Server weiter - was zufällig der Name der Spalte ist, die uns interessiert!

Es gibt viele Widgets, mit denen du viele Dinge in deiner App machen kannst. Mit Widgets kannst du auch Dateien in deine App hochladen und Ausgaben herunterladen. Es gibt auch einige hervorragende Shiny-Erweiterungen, die dir Zugriff auf mehr Widgets als das Basis-Shiny geben - die **shinyWidgets** Paket ist ein gutes Beispiel dafür. Einige Beispiele kannst du dir unter den folgenden Links ansehen:

- [base shiny widget gallery](https://shiny.rstudio.com/gallery/widget-gallery.html)
- [shinyWidgets Galerie](https://github.com/dreamRs/shinyWidgets)

## Daten in unsere App laden

Der nächste Schritt bei der Entwicklung unserer App ist, den Server zum Laufen zu bringen. Dazu müssen wir einige Daten in unsere App laden und uns überlegen, welche Berechnungen wir durchführen wollen. Eine glänzende App ist nicht einfach zu debuggen, da oft nicht klar ist, woher die Fehler kommen. Deshalb ist es ideal, wenn wir unseren gesamten Datenverarbeitungs- und Visualisierungscode zum Laufen bringen, bevor wir mit der Entwicklung des Servers selbst beginnen.

Wenn wir also eine App erstellen wollen, die Epi-Kurven anzeigt, die sich aufgrund von Benutzereingaben ändern, sollten wir uns überlegen, welchen Code wir benötigen, um dies in einem normalen R-Skript auszuführen. Das werden wir brauchen:

1. Unsere Pakete laden
2. Lade unsere Daten
3. Daten transformieren
4. Entwickeln Sie eine *Funktion* um unsere Daten auf der Grundlage von Benutzereingaben zu visualisieren

Diese Liste ist ziemlich überschaubar und sollte nicht allzu schwer zu bewerkstelligen sein. Jetzt ist es wichtig, darüber nachzudenken, welche Teile dieses Prozesses *nur einmal gemacht werden* und welche Teile *als Reaktion auf Benutzereingaben ausgeführt werden*. Das liegt daran, dass glänzende Apps in der Regel einen Teil des Codes vor der Ausführung ausführen, der nur einmal ausgeführt wird. Es hilft der Leistung unserer App, wenn wir so viel Code wie möglich in diesen Abschnitt verschieben können. In diesem Beispiel müssen wir unsere Daten/Pakete nur einmal laden und grundlegende Transformationen durchführen, also können wir diesen Code *außerhalb des Servers*. Das heißt, das Einzige, was wir auf dem Server brauchen, ist der Code zur Visualisierung unserer Daten. Lass uns all diese Komponenten zunächst in einem Skript entwickeln. Da wir unsere Daten jedoch mit einer Funktion visualisieren, können wir den Code auch *für die Funktion* außerhalb des Servers platzieren, damit unsere Funktion in der Umgebung ist, wenn die App läuft!

Laden wir zunächst unsere Daten. Da wir mit einem neuen Projekt arbeiten und es sauber machen wollen, können wir ein neues Verzeichnis mit dem Namen data erstellen und dort unsere Malaria-Daten hinzufügen. Wir können diesen Code unten in einem Testskript ausführen, das wir später löschen, wenn wir die Struktur unserer App bereinigt haben.

```{r, echo=TRUE}
pacman::p_load("tidyverse", "lubridate")

# read data
malaria_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) %>% 
  as_tibble()

print(malaria_data)


```

Es wird einfacher sein, mit diesen Daten zu arbeiten, wenn wir ordentliche Datenstandards verwenden, also sollten wir sie auch in ein längeres Datenformat umwandeln, in dem die Altersgruppe eine Spalte und die Fälle eine weitere Spalte sind. Das können wir ganz einfach mit dem machen, was wir im Kurs [Daten spiegeln] Seite gelernt haben.

```{r, echo=TRUE}

malaria_data <- malaria_data %>%
  select(-newid) %>%
  pivot_longer(cols = starts_with("malaria_"), names_to = "age_group", values_to = "cases_reported")

print(malaria_data)

```

Und damit sind wir mit der Vorbereitung unserer Daten fertig! Damit sind die Punkte 1, 2 und 3 auf unserer Liste der Dinge, die wir für unser "Test-R-Skript" entwickeln müssen, gestrichen. Die letzte und schwierigste Aufgabe besteht darin, eine Funktion zu entwickeln, die auf der Grundlage von benutzerdefinierten Parametern eine Epikurve erstellt. Wie bereits erwähnt, ist es *dringend empfohlen*dass jeder, der shiny lernt, sich zuerst den Abschnitt über funktionale Programmierung ansieht ([Funktionen schreiben]), um zu verstehen, wie das funktioniert!

Wenn wir unsere Funktion definieren, kann es schwierig sein, darüber nachzudenken, welche Parameter wir angeben wollen. Bei der funktionalen Programmierung mit Shiny ist jeder relevante Parameter in der Regel mit einem Widget verknüpft, so dass es normalerweise ganz einfach ist, darüber nachzudenken! In unserer aktuellen App wollen wir zum Beispiel nach Bezirken filtern und haben dafür ein Widget, also können wir einen Parameter für den Bezirk hinzufügen. Wir *haben keine* Wir haben (noch) keine App-Funktionen, um nach Einrichtungen zu filtern, also brauchen wir das nicht als Parameter hinzuzufügen. Beginnen wir damit, eine Funktion mit drei Parametern zu erstellen:

1. Der Kerndatensatz
2. Der Bezirk der Wahl
3. Die Altersgruppe der Wahl

```{r}

plot_epicurve <- function(data, district = "All", agegroup = "malaria_tot") {
  
  if (!("All" %in% district)) {
    data <- data %>%
      filter(District %in% district)
    
    plot_title_district <- stringr::str_glue("{paste0(district, collapse = ', ')} districts")
    
  } else {
    
    plot_title_district <- "all districts"
    
  }
  
  # if no remaining data, return NULL
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  data <- data %>%
    filter(age_group == agegroup)
  
  
  # if no remaining data, return NULL
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  if (agegroup == "malaria_tot") {
      agegroup_title <- "All ages"
  } else {
    agegroup_title <- stringr::str_glue("{str_remove(agegroup, 'malaria_rdt')} years")
  }
  
  
  ggplot(data, aes(x = data_date, y = cases_reported)) +
    geom_col(width = 1, fill = "darkred") +
    theme_minimal() +
    labs(
      x = "date",
      y = "number of cases",
      title = stringr::str_glue("Malaria cases - {plot_title_district}"),
      subtitle = agegroup_title
    )
  
  
  
}

```

Wir werden nicht weiter auf diese Funktion eingehen, da sie relativ einfach funktioniert. Eine Sache, die wir jedoch beachten sollten, ist, dass wir Fehler behandeln, indem wir `NULL` zurückgibt, wenn sie sonst einen Fehler auslösen würde. Das liegt daran, dass ein Shiny Server eine `NULL` Objekt statt eines Plot-Objekts erzeugt, wird in der Benutzeroberfläche nichts angezeigt! Das ist wichtig, da Fehler sonst oft dazu führen, dass deine App nicht mehr funktioniert.

Ein weiterer wichtiger Punkt ist die Verwendung des `%in%` Operators bei der Auswertung der `district` Eingabe. Wie oben erwähnt, könnte es sich um einen Zeichenvektor mit mehreren Werten handeln. `%in%` flexibler ist als z. B., `==`.

Lass uns unsere Funktion testen!

```{r, echo=TRUE, warning=FALSE}

plot_epicurve(malaria_data, district = "Bolo", agegroup = "malaria_rdt_0-4")

```

Da unsere Funktion funktioniert, müssen wir jetzt verstehen, wie das alles in unsere glänzende App passt. Wir erwähnten das Konzept der *Startup-Code* erwähnt, aber jetzt schauen wir uns an, wie wir ihn in die Struktur unserer App einbauen können. Es gibt zwei Möglichkeiten, wie wir das tun können!

1. Füge diesen Code in deine *app.R* Datei am Anfang des Skripts ein (oberhalb der Benutzeroberfläche), oder
2. Erstelle eine neue Datei im Verzeichnis deiner App mit dem Namen *global.R* und füge den Startcode in diese Datei ein.

An dieser Stelle sei angemerkt, dass es vor allem bei größeren Anwendungen einfacher ist, die zweite Dateistruktur zu verwenden, da du so deine Dateistruktur auf einfache Weise trennen kannst. Entwickeln wir nun das global.R-Skript vollständig. So könnte es aussehen:

```{r, eval=F}
# global.R script

pacman::p_load("tidyverse", "lubridate", "shiny")

# read data
malaria_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) %>% 
  as_tibble()

# clean data and pivot longer
malaria_data <- malaria_data %>%
  select(-newid) %>%
  pivot_longer(cols = starts_with("malaria_"), names_to = "age_group", values_to = "cases_reported")


# define plotting function
plot_epicurve <- function(data, district = "All", agegroup = "malaria_tot") {
  
  # create plot title
  if (!("All" %in% district)) {            
    data <- data %>%
      filter(District %in% district)
    
    plot_title_district <- stringr::str_glue("{paste0(district, collapse = ', ')} districts")
    
  } else {
    
    plot_title_district <- "all districts"
    
  }
  
  # if no remaining data, return NULL
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  # filter to age group
  data <- data %>%
    filter(age_group == agegroup)
  
  
  # if no remaining data, return NULL
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  if (agegroup == "malaria_tot") {
      agegroup_title <- "All ages"
  } else {
    agegroup_title <- stringr::str_glue("{str_remove(agegroup, 'malaria_rdt')} years")
  }
  
  
  ggplot(data, aes(x = data_date, y = cases_reported)) +
    geom_col(width = 1, fill = "darkred") +
    theme_minimal() +
    labs(
      x = "date",
      y = "number of cases",
      title = stringr::str_glue("Malaria cases - {plot_title_district}"),
      subtitle = agegroup_title
    )
  
  
  
}



```

Einfach! Eine großartige Funktion von Shiny ist, dass es versteht, welche Dateien mit dem Namen *app.R*, *server.R*, *ui.R*, und *global.R* sind für, so dass es nicht nötig ist, sie über irgendeinen Code miteinander zu verbinden. Wenn du also diesen Code in *global.R* im Verzeichnis wird er ausgeführt, bevor wir unsere App starten!

Wir sollten auch beachten, dass es die Organisation unserer App verbessern würde, wenn wir die Plotting-Funktion in eine eigene Datei verschieben würden - das ist besonders hilfreich, wenn die App größer wird. Dazu könnten wir ein weiteres Verzeichnis mit dem Namen *funcs* anlegen und diese Funktion in eine Datei namens *plot\_epicurve.R*. Wir können diese Funktion dann mit folgendem Befehl einlesen *global.R*

```{r, eval=F}

source(here("funcs", "plot_epicurve.R"), local = TRUE)

```

Beachte, dass du *immer* angeben. `local = TRUE` in Shiny Apps an, da es sich auf das Sourcing auswirkt, wenn die App auf einem Server veröffentlicht wird.

## Einen App-Server entwickeln

Jetzt, da wir den größten Teil unseres Codes haben, müssen wir nur noch unseren Server entwickeln. Das ist der letzte Teil unserer App und wahrscheinlich der am schwersten zu verstehende. Der Server ist eine große R-Funktion, aber es ist hilfreich, ihn sich als eine Reihe von kleineren Funktionen oder Aufgaben vorzustellen, die die App ausführen kann. Es ist wichtig zu verstehen, dass diese Funktionen nicht in einer linearen Reihenfolge ausgeführt werden. Es gibt zwar eine Reihenfolge, aber die muss man nicht unbedingt verstehen, wenn man mit Shiny anfängt. Ganz grundsätzlich werden diese Aufgaben oder Funktionen aktiviert, wenn sich die Eingaben des Nutzers ändern und sie beeinflussen, *es sei denn, der Entwickler hat sie so eingestellt, dass sie sich anders verhalten*. Auch das ist alles ziemlich abstrakt, aber gehen wir zunächst die drei Grundtypen von Shiny durch *Objekte*

1. Reaktive Quellen - das ist ein anderer Begriff für Benutzereingaben. Der Shiny Server hat über die Widgets, die wir programmiert haben, Zugriff auf die Ausgaben der Benutzeroberfläche. Jedes Mal, wenn die Werte für diese Widgets geändert werden, wird dies an den Server weitergegeben.

2. Reaktive Conductors - das sind Objekte, die existieren *nur* innerhalb des Shiny Servers existieren. Für einfache Anwendungen brauchen wir sie eigentlich nicht, aber sie erzeugen Objekte, die nur innerhalb des Servers zu sehen sind und in anderen Operationen verwendet werden. Sie sind in der Regel auf reaktive Quellen angewiesen.

3. Endpunkte - das sind die Ausgaben, die vom Server an die Benutzeroberfläche weitergegeben werden. In unserem Beispiel wäre das die Epi-Kurve, die wir erzeugen.

Mit diesem Wissen bauen wir unseren Server Schritt für Schritt auf. Zur Veranschaulichung zeigen wir hier noch einmal unseren UI-Code:

```{r, eval=FALSE}

ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         # selector for district
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = c(
                   "All",
                   "Spring",
                   "Bolo",
                   "Dingo",
                   "Barnard"
              ),
              selected = "All",
              multiple = TRUE
         ),
         # selector for age group
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         )

    ),

    mainPanel(
      # epicurve goes here
      plotOutput("malaria_epicurve")
    )
    
  )
)


```

In diesem Code haben wir eine UI:

- Zwei Eingänge:
  - Bezirksselektor (mit einer inputId von `select_district`)
  - Altersgruppen-Selektor (mit einer inputId von `select_agegroup`)
- Eine Ausgabe:
  - Die Epikurve (mit einer outputId von `malaria_epicurve`)

Wie bereits erwähnt, sind die eindeutigen Namen, die wir unseren Inputs und Outputs zugewiesen haben, entscheidend. Sie *müssen eindeutig sein* und werden verwendet, um Informationen zwischen der Benutzeroberfläche und dem Server zu übermitteln. In unserem Server greifen wir auf unsere Eingaben über die Syntax `input$inputID` und die Ausgaben und werden über die Syntax `output$output_name` Schauen wir uns ein Beispiel an, denn auch das ist sonst schwer zu verstehen!

```{r, eval=FALSE}

server <- function(input, output, session) {
  
  output$malaria_epicurve <- renderPlot(
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  )
  
}


```

Der Server für eine einfache App wie diese ist eigentlich ganz einfach! Du wirst feststellen, dass der Server eine Funktion mit drei Parametern ist - `input`, `output`, und `session` - Das ist im Moment nicht so wichtig zu verstehen, aber es ist wichtig, dass du dich an dieses Setup hältst! In unserem Server gibt es nur eine Aufgabe - sie rendert einen Plot auf der Grundlage unserer Funktion, die wir zuvor erstellt haben, und der Eingaben vom Server. Beachte, dass die Namen der Eingabe- und Ausgabeobjekte genau mit denen der Benutzeroberfläche übereinstimmen.

Um zu verstehen, wie der Server auf Benutzereingaben reagiert, solltest du beachten, dass die Ausgabe (durch das zugrunde liegende Paket) weiß, wenn sich die Eingaben ändern, und diese Funktion jedes Mal erneut ausführt, um ein Diagramm zu erstellen, wenn sie sich ändern. Beachte, dass wir auch die `renderPlot()` Funktion verwenden - sie gehört zu einer Familie von klassenspezifischen Funktionen, die diese Objekte an eine UI-Ausgabe weitergeben. Es gibt eine Reihe von Funktionen, die sich ähnlich verhalten, aber du musst sicherstellen, dass die verwendete Funktion zu der Klasse des Objekts passt, das du an die ui übergibst! Zum Beispiel:

- `renderText()` - Text an die Benutzeroberfläche senden
- `renderDataTable` - eine interaktive Tabelle an die Benutzeroberfläche senden.

Denk daran, dass diese auch mit der Ausgabe übereinstimmen müssen *Funktion* die in der Benutzeroberfläche verwendet wird - also `renderPlot()` ist gepaart mit `plotOutput()`, und `renderText()` wird gepaart mit `textOutput()`.

Wir haben also endlich eine funktionierende App erstellt! Wir können sie ausführen, indem wir auf die Schaltfläche App ausführen oben rechts im Skriptfenster in Rstudio klicken. Du kannst deine App auch in deinem Standardbrowser ausführen (und nicht in Rstudio), dann sieht die App für andere Benutzer besser aus.

```{r, out.width=c("100%"), out.height=c("100%"), echo=F}
knitr::include_graphics(here::here("images", "shiny", "app_simple_view.gif"))
```

Interessant ist, dass die App in der R-Konsole "zuhört"! Das nennt man Reaktivität!

```{r, echo=F}
knitr::include_graphics(here::here("images", "shiny", "listening.png"))
```

<!-- ZU TUN: *ETWAS ZUM HERUNTERLADEN EINER ZIP-DATEI DER APP HINZUFÜGEN?* -->

## Mehr Funktionalität hinzufügen

Jetzt haben wir endlich eine funktionierende App, aber wir haben nur sehr wenige Funktionen. Außerdem haben wir noch nicht einmal an der Oberfläche dessen gekratzt, was Shiny alles kann, es gibt also noch viel zu lernen! Lasst uns unsere App weiter ausbauen, indem wir einige zusätzliche Funktionen hinzufügen. Einige Dinge, die wir gerne hinzufügen würden, wären:

1. Einige erklärende Texte
2. Ein Download-Button für unseren Plot - damit erhält der Nutzer eine qualitativ hochwertige Version des Bildes, das er in der App erstellt
3. Ein Selektor für bestimmte Einrichtungen
4. Eine weitere Dashboard-Seite - diese könnte eine Tabelle mit unseren Daten zeigen.

Das ist eine Menge, aber wir können es nutzen, um auf dem Weg dorthin eine Menge über verschiedene Shiny-Features zu lernen. Es gibt so viel über Shiny zu lernen (es kann *sehr* (es kann sehr fortschrittlich sein, aber wenn die Nutzer/innen erst einmal wissen, wie man es benutzt, können sie hoffentlich auch externe Lernquellen nutzen).

### Hinzufügen von statischem Text {.unnumbered}

Zuerst wollen wir darüber sprechen, wie wir statischen Text zu unserer Shiny App hinzufügen. Das Hinzufügen von Text zu unserer App ist extrem einfach, wenn du erst einmal ein Grundverständnis dafür hast. Da sich statischer Text in der Shiny App nicht ändert (wenn du möchtest, dass er sich ändert, kannst du ihn mit *Textwiedergabe* Funktionen auf dem Server verwenden!), wird der gesamte statische Text von Shiny in der Regel in der Benutzeroberfläche der App hinzugefügt. Wir werden das hier nicht im Detail erklären, aber du kannst deiner Benutzeroberfläche eine Reihe verschiedener Elemente (und sogar eigene) hinzufügen, indem du R mit *HTML* und *css*.

HTML und css sind Sprachen, die explizit mit der Gestaltung von Benutzeroberflächen zu tun haben. Wir müssen sie nicht allzu gut verstehen, aber *HTML* erstellt Objekte in der Benutzeroberfläche (wie ein Textfeld oder eine Tabelle), und *css* wird im Allgemeinen verwendet, um den Stil und die Ästhetik dieser Objekte zu ändern. Shiny hat Zugriff auf eine große Anzahl von *HTML-Tags* - Diese sind für Objekte vorhanden, die sich auf eine bestimmte Art und Weise verhalten, wie z. B. Überschriften, Textabsätze, Zeilenumbrüche, Tabellen usw. Wir können einige dieser Beispiele wie folgt verwenden:

- `h1()` - dies a a *Kopfzeile* Tag, der den eingeschlossenen Text automatisch größer macht und die Standardeinstellungen für Schriftart, Farbe usw. ändert (je nach dem Gesamtthema deiner App). Du kannst auf *kleiner und kleiner* Zwischenüberschriften mit `h2()` bis hinunter zu `h6()` auch. Die Verwendung sieht so aus:
  
  - `h1("my header - section 1")`

- `p()` - Dies ist ein *Absatz* Tag, der den eingeschlossenen Text ähnlich wie den Text in einem Textkörper macht. Dieser Text wird automatisch umbrochen und hat eine relativ kleine Größe (Fußzeilen können z. B. kleiner sein.) Stell dir das wie den Textkörper eines Word-Dokuments vor. Die Verwendung sieht so aus:
  
  - `p("This is a larger body of text where I am explaining the function of my app")`

- `tags$b()` und `tags$i()` - diese werden verwendet, um fette `tags$b()` und kursiv `tags$i()` mit dem Text, der eingeschlossen ist!

- `tags$ul()`, `tags$ol()` und `tags$li()` - dies sind Tags, die bei der Erstellung von *Listen*. Sie werden alle in der folgenden Syntax verwendet und ermöglichen es dem Benutzer, entweder eine geordnete Liste zu erstellen (`tags$ol()`; d.h. nummeriert) oder eine ungeordnete Liste (`tags$ul()`, d.h. Aufzählungspunkte). `tags$li()` wird verwendet, um Elemente in der Liste zu kennzeichnen, unabhängig davon, welche Art von Liste verwendet wird. z.B.:

```{r, eval=F}

tags$ol(
  
  tags$li("Item 1"),
  
  tags$li("Item 2"),
  
  tags$li("Item 3")
  
)

```

- `br()` und `hr()` - diese Tags erzeugen *Zeilenumbrüche* und *horizontale Linien* (mit einem Zeilenumbruch). Verwende sie, um die Abschnitte deiner App und den Text voneinander zu trennen! Es ist nicht nötig, diesen Tags Elemente zu übergeben (Klammern können leer bleiben).

- `div()` - Dies ist ein *generische* Tag, der *alles enthalten* und kann sein *alles benennen*. Wenn du mit dem Design der Benutzeroberfläche fortschreitest, kannst du diese verwenden, um deine Benutzeroberfläche zu unterteilen, bestimmten Abschnitten bestimmte Stile zu geben und Interaktionen zwischen dem Server und den UI-Elementen zu erstellen. Wir werden hier nicht ins Detail gehen, aber es lohnt sich, sie zu kennen!

Auf jedes dieser Objekte kannst du über `tags$...` oder bei einigen nur über die Funktion. Sie sind praktisch synonym, aber es kann hilfreich sein, die `tags$...` Stil zu verwenden, wenn du lieber explizit sein möchtest und die Funktionen nicht versehentlich überschreiben willst. Dies ist keine vollständige Liste der verfügbaren Tags. Eine vollständige Liste aller verfügbaren Tags findest du in shiny [hier](https://shiny.rstudio.com/articles/tag-glossary.html) und noch mehr können verwendet werden, indem du HTML direkt in deine Benutzeroberfläche einfügst!

Wenn du dich sicher fühlst, kannst du auch beliebige *css-Styling-Elemente* zu deinen HTML-Tags mit der `style` Argument in jedem von ihnen. Wir werden nicht im Detail darauf eingehen, wie das funktioniert, aber ein Tipp, um ästhetische Änderungen an einer Benutzeroberfläche zu testen, ist die Verwendung des HTML-Inspektors in Chrome (deiner glänzenden App, die du im Browser ausführst) und die Bearbeitung des Stils der Objekte selbst!

Fügen wir unserer App etwas Text hinzu

```{r, eval=F}

ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         h4("Options"),
         # selector for district
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = c(
                   "All",
                   "Spring",
                   "Bolo",
                   "Dingo",
                   "Barnard"
              ),
              selected = "All",
              multiple = TRUE
         ),
         # selector for age group
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         ),
    ),

    mainPanel(
      # epicurve goes here
      plotOutput("malaria_epicurve"),
      br(),
      hr(),
      p("Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:"),
    tags$ul(
      tags$li(tags$b("location_name"), " - the facility that the data were collected at"),
      tags$li(tags$b("data_date"), " - the date the data were collected at"),
      tags$li(tags$b("submitted_daate"), " - the date the data were submitted at"),
      tags$li(tags$b("Province"), " - the province the data were collected at (all 'North' for this dataset)"),
      tags$li(tags$b("District"), " - the district the data were collected at"),
      tags$li(tags$b("age_group"), " - the age group the data were collected for (0-5, 5-14, 15+, and all ages)"),
      tags$li(tags$b("cases_reported"), " - the number of cases reported for the facility/age group on the given date")
    )
    
  )
)
)



```

```{r, echo=F}
knitr::include_graphics(here::here("images", "shiny", "app_text_view.png"))
```

### Hinzufügen eines Links {.unnumbered}

Um einen Link zu einer Website hinzuzufügen, benutze `tags$a()` mit dem Link und dem Anzeigetext wie unten gezeigt. Wenn du ihn als eigenständigen Absatz haben willst, füge ihn innerhalb von `p()`. Wenn nur einige Wörter eines Satzes verlinkt werden sollen, unterteile den Satz in Teile und verwende `tags$a()` für den verlinkten Teil. Um sicherzustellen, dass sich der Link in einem *neuen* Browserfenster geöffnet wird, füge `target = "_blank"` als Argument ein.

```{r, eval=F}
tags$a(href = "www.epiRhandbook.com", "Visit our website!")
```

### Hinzufügen einer Download-Schaltfläche {.unnumbered}

Kommen wir nun zur zweiten der drei Funktionen. Eine Download-Schaltfläche ist eine ziemlich gängige Funktion, die man einer App hinzufügen kann und die ziemlich einfach zu erstellen ist. Wir müssen nur ein weiteres Widget zu unserer Benutzeroberfläche hinzufügen und einen weiteren Ausgang zu unserem Server hinzufügen, um ihn zu verbinden. Wir können auch einen *reaktive Leiter* in diesem Beispiel!

Aktualisieren wir zuerst unsere Benutzeroberfläche - das ist ganz einfach, denn Shiny kommt mit einem Widget namens `downloadButton()` - Wir geben ihm eine inputId und ein Label.

```{r, eval=FALSE}

ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         # selector for district
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = c(
                   "All",
                   "Spring",
                   "Bolo",
                   "Dingo",
                   "Barnard"
              ),
              selected = "All",
              multiple = FALSE
         ),
         # selector for age group
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         ),
         # horizontal line
         hr(),
         downloadButton(
           outputId = "download_epicurve",
           label = "Download plot"
         )

    ),

    mainPanel(
      # epicurve goes here
      plotOutput("malaria_epicurve"),
      br(),
      hr(),
      p("Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:"),
      tags$ul(
        tags$li(tags$b("location_name"), " - the facility that the data were collected at"),
        tags$li(tags$b("data_date"), " - the date the data were collected at"),
        tags$li(tags$b("submitted_daate"), " - the date the data were submitted at"),
        tags$li(tags$b("Province"), " - the province the data were collected at (all 'North' for this dataset)"),
        tags$li(tags$b("District"), " - the district the data were collected at"),
        tags$li(tags$b("age_group"), " - the age group the data were collected for (0-5, 5-14, 15+, and all ages)"),
        tags$li(tags$b("cases_reported"), " - the number of cases reported for the facility/age group on the given date")
      )
      
    )
    
  )
)


```

Beachte, dass wir auch ein `hr()` Tag eingefügt haben - damit wird eine horizontale Linie hinzugefügt, die unsere Kontroll-Widgets von den Download-Widgets trennt. Dies ist ein weiteres der HTML-Tags, die wir zuvor besprochen haben.

Jetzt, wo wir unsere Benutzeroberfläche fertig haben, müssen wir die Serverkomponente hinzufügen. Die Downloads werden auf dem Server mit dem `downloadHandler()` Funktion. Ähnlich wie bei unserem Plot müssen wir sie an einen Output anhängen, der die gleiche inputId hat wie der Download-Button. Diese Funktion benötigt zwei Argumente - `filename` und `content` - das sind beides Funktionen. Wie du dir vielleicht denken kannst, `filename` den Namen der heruntergeladenen Datei an, und `content` wird verwendet, um anzugeben, was heruntergeladen werden soll. `content` enthält eine Funktion, die du zum lokalen Speichern von Daten verwenden würdest - wenn du also eine csv-Datei herunterlädst, könntest du verwenden `rio::export()`. Da wir einen Plot herunterladen, verwenden wir `ggplot2::ggsave()`. Schauen wir uns an, wie wir das programmieren würden (wir fügen es dem Server noch nicht hinzu).

```{r, eval=FALSE}

server <- function(input, output, session) {
  
  output$malaria_epicurve <- renderPlot(
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  )
  
  output$download_epicurve <- downloadHandler(
    filename = function() {
      stringr::str_glue("malaria_epicurve_{input$select_district}.png")
    },
    
    content = function(file) {
      ggsave(file, 
             plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup),
             width = 8, height = 5, dpi = 300)
    }
    
  )
  
}


```

Beachte, dass die `content` Funktion immer eine `file` Argument, das wir an die Stelle setzen, an der der Name der Ausgabedatei angegeben ist. Vielleicht fällt dir auch auf, dass wir den Code hier wiederholen - wir verwenden unsere `plot_epicurve()` Funktion in diesem Server zweimal: einmal für den Download und einmal für das Bild, das in der App angezeigt wird. Das hat zwar keine großen Auswirkungen auf die Leistung, aber es bedeutet, dass der Code zur Erstellung der Grafik ausgeführt werden muss, wenn der Nutzer die Widgets für den Bezirk und die Altersgruppe ändert, *und* erneut ausgeführt werden muss, wenn du das Diagramm herunterladen möchtest. In größeren Apps verlangsamen suboptimale Entscheidungen wie diese die Dinge immer mehr, daher ist es gut zu lernen, wie wir unsere App in dieser Hinsicht effizienter machen können. Noch sinnvoller wäre es, wenn wir eine Möglichkeit hätten, den Epikurvencode auszuführen, wenn die Bezirke/Altersgruppen geändert werden, *und das von der App genutzt werden könnte* die renderPlot()- und downloadHandler()-Funktionen. Hier kommen die reaktiven Dirigenten ins Spiel!

Reaktive Conductors sind Objekte, die auf dem Shiny Server in einer *reaktiven* erstellt werden, aber nicht ausgegeben werden - sie können einfach von anderen Teilen des Servers verwendet werden. Es gibt eine Reihe von verschiedenen Arten von *reaktiven Leitern* Wir gehen hier nur die beiden wichtigsten durch.

1\.`reactive()` - Dies ist der einfachste reaktive Leiter - er reagiert immer dann, wenn sich die darin verwendeten Eingaben ändern (also unsere Bezirks-/Altersgruppen-Widgets).  
2\. `eventReactive()`\- Dieser reaktive Leiter funktioniert genauso wie `reactive()` mit dem Unterschied, dass der/die Nutzer/in festlegen kann, welche Eingaben eine erneute Ausführung bewirken sollen. Das ist nützlich, wenn dein reaktiver Dirigent viel Zeit für die Bearbeitung braucht, aber dazu später mehr.

Schauen wir uns die beiden Beispiele an:

```{r, eval=FALSE}

malaria_plot_r <- reactive({
  
  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  
})


# only runs when the district selector changes!
malaria_plot_er <- eventReactive(input$select_district, {
  
  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  
})



```

Wenn wir die `eventReactive()` verwenden, können wir angeben, welche Eingaben dazu führen, dass dieser Code ausgeführt wird - das ist im Moment nicht sehr nützlich für uns, also lassen wir es vorerst. Beachte, dass du mehrere Eingaben mit `c()`

Schauen wir uns an, wie wir das in unseren Servercode integrieren können:

```{r, eval=FALSE}

server <- function(input, output, session) {
  
  malaria_plot <- reactive({
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  })
  
  
  
  output$malaria_epicurve <- renderPlot(
    malaria_plot()
  )
  
  output$download_epicurve <- downloadHandler(
    
    filename = function() {
      stringr::str_glue("malaria_epicurve_{input$select_district}.png")
    },
    
    content = function(file) {
      ggsave(file, 
             malaria_plot(),
             width = 8, height = 5, dpi = 300)
    }
    
  )
  
}


```

Wie du siehst, rufen wir einfach die Ausgabe unserer Reactive auf, die wir sowohl in unseren Download- als auch in unseren Plot-Rendering-Funktionen definiert haben. Eine Sache, über die man oft stolpert, ist, dass man die Ausgaben von Reactives so verwenden muss, als wären sie Funktionen - du musst also *musst du leere Klammern am Ende der Funktionen hinzufügen* (d.h.. `malaria_plot()` ist korrekt, und `malaria_plot` ist nicht korrekt). Jetzt, wo wir diese Lösung hinzugefügt haben, ist unsere App etwas aufgeräumter, schneller und leichter zu ändern, da sich der gesamte Code, der die Epikurvenfunktion ausführt, an einer Stelle befindet.

```{r, echo=F}
knitr::include_graphics(here::here("images", "shiny", "download_button_view.png"))
```

### Hinzufügen eines Betriebsmittelselektors {.unnumbered}

Kommen wir zu unserer nächsten Funktion - einem Selektor für bestimmte Einrichtungen. Wir werden einen weiteren Parameter in unsere Funktion einbauen, damit wir diesen als Argument in unserem Code übergeben können. Schauen wir uns das erst einmal an - es funktioniert nach denselben Prinzipien wie die anderen Parameter, die wir eingerichtet haben. Aktualisieren und testen wir unsere Funktion.

```{r, echo=TRUE}

plot_epicurve <- function(data, district = "All", agegroup = "malaria_tot", facility = "All") {
  
  if (!("All" %in% district)) {
    data <- data %>%
      filter(District %in% district)
    
    plot_title_district <- stringr::str_glue("{paste0(district, collapse = ', ')} districts")
    
  } else {
    
    plot_title_district <- "all districts"
    
  }
  
  # if no remaining data, return NULL
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  data <- data %>%
    filter(age_group == agegroup)
  
  
  # if no remaining data, return NULL
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  if (agegroup == "malaria_tot") {
      agegroup_title <- "All ages"
  } else {
    agegroup_title <- stringr::str_glue("{str_remove(agegroup, 'malaria_rdt')} years")
  }
  
    if (!("All" %in% facility)) {
    data <- data %>%
      filter(location_name == facility)
    
    plot_title_facility <- facility
    
  } else {
    
    plot_title_facility <- "all facilities"
    
  }
  
  # if no remaining data, return NULL
  if (nrow(data) == 0) {
    
    return(NULL)
  }

  
  
  ggplot(data, aes(x = data_date, y = cases_reported)) +
    geom_col(width = 1, fill = "darkred") +
    theme_minimal() +
    labs(
      x = "date",
      y = "number of cases",
      title = stringr::str_glue("Malaria cases - {plot_title_district}; {plot_title_facility}"),
      subtitle = agegroup_title
    )
  
  
  
}
```

Testen wir sie:

```{r, warning=F, message=F}

plot_epicurve(malaria_data, district = "Spring", agegroup = "malaria_rdt_0-4", facility = "Facility 1")

```

Bei all den Einrichtungen in unseren Daten ist es nicht ganz klar, welche Einrichtungen welchen Bezirken entsprechen - und der Endnutzer wird es auch nicht wissen. Das könnte die Benutzung der App ziemlich unintuitiv machen. Aus diesem Grund sollten wir dafür sorgen, dass sich die Einrichtungsoptionen in der Benutzeroberfläche dynamisch ändern, wenn der Nutzer den Bezirk wechselt - so filtert eine die andere! Da wir so viele Variablen in den Optionen verwenden, möchten wir vielleicht auch einige unserer Optionen für die Benutzeroberfläche in unserer *global.R* Datei *aus den Daten*. Zum Beispiel können wir diesen Codeabschnitt hinzufügen zu *global.R* hinzufügen, nachdem wir unsere Daten eingelesen haben:

```{r, message=FALSE}

all_districts <- c("All", unique(malaria_data$District))

# data frame of location names by district
facility_list <- malaria_data %>%
  group_by(location_name, District) %>%
  summarise() %>% 
  ungroup()

```

Schauen wir sie uns an:

```{r}
all_districts
```

```{r}
facility_list
```

Wir können diese neuen Variablen problemlos an die Benutzeroberfläche übergeben, da sie sowohl für den Server als auch für die Benutzeroberfläche global sichtbar sind! Aktualisieren wir unser UI:

```{r, eval=FALSE}


ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         # selector for district
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = all_districts,
              selected = "All",
              multiple = FALSE
         ),
         # selector for age group
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         ),
         # selector for facility
         selectInput(
           inputId = "select_facility",
           label = "Select Facility",
           choices = c("All", facility_list$location_name),
           selected = "All"
         ),
         
         # horizontal line
         hr(),
         downloadButton(
           outputId = "download_epicurve",
           label = "Download plot"
         )

    ),

    mainPanel(
      # epicurve goes here
      plotOutput("malaria_epicurve"),
      br(),
      hr(),
      p("Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:"),
      tags$ul(
        tags$li(tags$b("location_name"), " - the facility that the data were collected at"),
        tags$li(tags$b("data_date"), " - the date the data were collected at"),
        tags$li(tags$b("submitted_daate"), " - the date the data were submitted at"),
        tags$li(tags$b("Province"), " - the province the data were collected at (all 'North' for this dataset)"),
        tags$li(tags$b("District"), " - the district the data were collected at"),
        tags$li(tags$b("age_group"), " - the age group the data were collected for (0-5, 5-14, 15+, and all ages)"),
        tags$li(tags$b("cases_reported"), " - the number of cases reported for the facility/age group on the given date")
      )
      
    )
    
  )
)


```

Beachte, dass wir jetzt Variablen für unsere Auswahlmöglichkeiten übergeben, anstatt sie in der Benutzeroberfläche fest zu codieren! Das könnte unseren Code auch kompakter machen! Zum Schluss müssen wir den Server aktualisieren. Es wird einfach sein, unsere Funktion zu aktualisieren, um unsere neue Eingabe zu integrieren (wir müssen sie nur als Argument an unseren neuen Parameter übergeben), aber wir sollten daran denken, dass wir auch wollen, dass die Benutzeroberfläche dynamisch aktualisiert wird, wenn der Nutzer den gewählten Bezirk ändert. Es ist wichtig zu verstehen, dass wir *die Parameter und das Verhalten der Widgets ändern können* ändern können, während die App läuft, aber das muss getan werden *auf dem Server*. Wir müssen einen neuen Weg für die Ausgabe auf dem Server finden, um zu lernen, wie man das macht.

Die Funktionen, die wir dazu verstehen müssen, sind bekannt als *Beobachter* Funktionen, die ähnlich sind wie *reaktiven* Funktionen, was ihr Verhalten angeht. Sie haben jedoch einen entscheidenden Unterschied:

- Reaktive Funktionen wirken sich nicht direkt auf die Ausgaben aus und erzeugen Objekte, die an anderen Stellen des Servers zu sehen sind
- Beobachterfunktionen *können* Sie können die Ausgaben des Servers beeinflussen, tun dies aber über Seiteneffekte anderer Funktionen. (Sie können auch andere Dinge tun, aber dies ist in der Praxis ihre Hauptfunktion)

Ähnlich wie bei den reaktiven Funktionen gibt es zwei Arten von Beobachterfunktionen, die durch dieselbe Logik unterteilt werden, die auch die reaktiven Funktionen unterteilt:

1. `observe()` - Diese Funktion wird immer dann ausgeführt, wenn sich die in ihr verwendeten Eingaben ändern.
2. `observeEvent()` - Diese Funktion wird ausgeführt, wenn ein *benutzerdefinierte* Eingabe ändert

Wir müssen auch die von Shiny bereitgestellten Funktionen verstehen, die Widgets aktualisieren. Diese sind ziemlich einfach auszuführen - sie nehmen zuerst die `session` Objekt von der Serverfunktion (das müssen wir vorerst nicht verstehen), und dann die `inputId` der zu ändernden Funktion. Dann übergeben wir die neuen Versionen aller Parameter, die bereits von der `selectInput()` - diese werden automatisch im Widget aktualisiert.

Schauen wir uns ein Beispiel an, wie wir dies in unserem Server nutzen können. Wenn der Nutzer den Bezirk wechselt, wollen wir unsere Liste der Einrichtungen nach dem Bezirk filtern und die Auswahlmöglichkeiten auf *nur die Einrichtungen anzuzeigen, die in diesem Bezirk verfügbar sind* (und eine Option für alle Einrichtungen)

```{r, eval=FALSE}

observe({
  
  if (input$select_district == "All") {
    new_choices <- facility_list$location_name
  } else {
    new_choices <- facility_list %>%
      filter(District == input$select_district) %>%
      pull(location_name)
  }
  
  new_choices <- c("All", new_choices)
  
  updateSelectInput(session, inputId = "select_facility",
                    choices = new_choices)
  
})


```

Und das war's! Wir können ihn in unseren Server einfügen, und das Verhalten wird nun funktionieren. So sollte unser neuer Server aussehen:

```{r, eval=FALSE}
server <- function(input, output, session) {
  
  malaria_plot <- reactive({
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)
  })
  
  
  
  observe({
    
    if (input$select_district == "All") {
      new_choices <- facility_list$location_name
    } else {
      new_choices <- facility_list %>%
        filter(District == input$select_district) %>%
        pull(location_name)
    }
    
    new_choices <- c("All", new_choices)
    
    updateSelectInput(session, inputId = "select_facility",
                      choices = new_choices)
    
  })
  
  
  output$malaria_epicurve <- renderPlot(
    malaria_plot()
  )
  
  output$download_epicurve <- downloadHandler(
    
    filename = function() {
      stringr::str_glue("malaria_epicurve_{input$select_district}.png")
    },
    
    content = function(file) {
      ggsave(file, 
             malaria_plot(),
             width = 8, height = 5, dpi = 300)
    }
    
  )
  
  
  
}

```

```{r, out.width=c("100%", "100%"), echo=F, fig.show="hold", fig.width=12, fig.height=9, message=F, warning=F}
knitr::include_graphics(here::here("images", "shiny", "app_menu_view.gif"))
```

### Hinzufügen einer weiteren Registerkarte mit einer Tabelle {.unnumbered}

Jetzt gehen wir zur letzten Komponente über, die wir unserer App hinzufügen wollen. Wir wollen unsere Benutzeroberfläche in zwei Registerkarten aufteilen, von denen eine eine interaktive Tabelle enthält, in der der Benutzer die Daten sehen kann, mit denen er die Epidemiekurve erstellt. Dazu können wir die gepackten UI-Elemente verwenden, die in Shiny für die Tabs enthalten sind. Grundsätzlich können wir den größten Teil unseres Hauptpanels in diese allgemeine Struktur einbetten:

```{r, eval=FALSE}


# ... the rest of ui

mainPanel(
  
  tabsetPanel(
    type = "tabs",
    tabPanel(
      "Epidemic Curves",
      ...
    ),
    tabPanel(
      "Data",
      ...
    )
  )
)


```

Wenden wir dies auf unsere Benutzeroberfläche an. Wir werden auch die **DT** Paket verwenden - das ist ein großartiges Paket, um interaktive Tabellen aus bereits vorhandenen Daten zu erstellen. Wir sehen, dass es verwendet wird für `DT::datatableOutput()` in diesem Beispiel.

```{r, echo=FALSE}
library(DT)
```

```{r, eval=FALSE}
ui <- fluidPage(
     
     titlePanel("Malaria facility visualisation app"),
     
     sidebarLayout(
          
          sidebarPanel(
               # selector for district
               selectInput(
                    inputId = "select_district",
                    label = "Select district",
                    choices = all_districts,
                    selected = "All",
                    multiple = FALSE
               ),
               # selector for age group
               selectInput(
                    inputId = "select_agegroup",
                    label = "Select age group",
                    choices = c(
                         "All ages" = "malaria_tot",
                         "0-4 yrs" = "malaria_rdt_0-4",
                         "5-14 yrs" = "malaria_rdt_5-14",
                         "15+ yrs" = "malaria_rdt_15"
                    ), 
                    selected = "All",
                    multiple = FALSE
               ),
               # selector for facility
               selectInput(
                    inputId = "select_facility",
                    label = "Select Facility",
                    choices = c("All", facility_list$location_name),
                    selected = "All"
               ),
               
               # horizontal line
               hr(),
               downloadButton(
                    outputId = "download_epicurve",
                    label = "Download plot"
               )
               
          ),
          
          mainPanel(
               tabsetPanel(
                    type = "tabs",
                    tabPanel(
                         "Epidemic Curves",
                         plotOutput("malaria_epicurve")
                    ),
                    tabPanel(
                         "Data",
                         DT::dataTableOutput("raw_data")
                    )
               ),
               br(),
               hr(),
               p("Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:"),
               tags$ul(
                    tags$li(tags$b("location_name"), " - the facility that the data were collected at"),
                    tags$li(tags$b("data_date"), " - the date the data were collected at"),
                    tags$li(tags$b("submitted_daate"), " - the date the data were submitted at"),
                    tags$li(tags$b("Province"), " - the province the data were collected at (all 'North' for this dataset)"),
                    tags$li(tags$b("District"), " - the district the data were collected at"),
                    tags$li(tags$b("age_group"), " - the age group the data were collected for (0-5, 5-14, 15+, and all ages)"),
                    tags$li(tags$b("cases_reported"), " - the number of cases reported for the facility/age group on the given date")
               )
               
               
          )
     )
)


```

Jetzt ist unsere App in Tabs gegliedert! Lass uns nun auch die notwendigen Änderungen am Server vornehmen. Da wir unseren Datensatz nicht bearbeiten müssen, bevor wir ihn rendern, ist das eigentlich sehr einfach - wir rendern den malaria\_data-Datensatz einfach über DT::renderDT() in die Benutzeroberfläche!

```{r, eval=FALSE}
server <- function(input, output, session) {
  
  malaria_plot <- reactive({
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)
  })
  
  
  
  observe({
    
    if (input$select_district == "All") {
      new_choices <- facility_list$location_name
    } else {
      new_choices <- facility_list %>%
        filter(District == input$select_district) %>%
        pull(location_name)
    }
    
    new_choices <- c("All", new_choices)
    
    updateSelectInput(session, inputId = "select_facility",
                      choices = new_choices)
    
  })
  
  
  output$malaria_epicurve <- renderPlot(
    malaria_plot()
  )
  
  output$download_epicurve <- downloadHandler(
    
    filename = function() {
      stringr::str_glue("malaria_epicurve_{input$select_district}.png")
    },
    
    content = function(file) {
      ggsave(file, 
             malaria_plot(),
             width = 8, height = 5, dpi = 300)
    }
    
  )
  
  # render data table to ui
  output$raw_data <- DT::renderDT(
    malaria_data
  )
  
  
}


```

```{r, out.width=c("100%", "100%"), fig.show="hold", echo=F, fig.width=12, fig.height=9, message=F, warning=F}
knitr::include_graphics(here::here("images", "shiny", "app_table_view.gif"))
```

## Shiny Apps teilen

Jetzt, wo du deine App entwickelt hast, willst du sie wahrscheinlich mit anderen teilen - das ist schließlich der Hauptvorteil von Shiny! Dazu können wir den Code direkt teilen oder auf einem Server veröffentlichen. Wenn wir den Code teilen, können andere sehen, was du gemacht hast, und darauf aufbauen, aber dadurch wird einer der Hauptvorteile von Shiny zunichte gemacht - *Die Endnutzer müssen keine R-Installation mehr unterhalten.*. Wenn du deine App mit Nutzern teilst, die mit R nicht vertraut sind, ist es daher viel einfacher, eine App zu teilen, die auf einem Server veröffentlicht wurde.

Wenn du lieber den Code weitergeben möchtest, kannst du eine .zip-Datei der App erstellen, oder noch besser, *veröffentliche deine App auf Github und füge Mitwirkende hinzu.* Weitere Informationen findest du in dem Abschnitt über github hier.

Wenn wir die App jedoch online veröffentlichen, müssen wir etwas mehr Arbeit leisten. Schließlich wollen wir, dass deine App über eine Web-URL zugänglich ist, damit andere schnell und einfach darauf zugreifen können. Um deine App auf einem Server zu veröffentlichen, musst du Zugang zu einem Server haben, auf dem du sie veröffentlichen kannst! Hierfür gibt es eine Reihe von Hosting-Optionen:

- *shinyapps.io*: Dies ist der einfachste Ort, um Shiny-Apps zu veröffentlichen, denn hier ist der geringste Konfigurationsaufwand nötig und es gibt einige kostenlose, aber begrenzte Lizenzen.

- *RStudio Connect* RStudio Connect: Dies ist eine viel leistungsfähigere Version eines R-Servers, der viele Operationen durchführen kann, einschließlich der Veröffentlichung von glänzenden Apps. Er ist jedoch schwieriger zu bedienen und für Einsteiger weniger zu empfehlen.

Für die Zwecke dieses Dokuments werden wir den *shinyapps.io* verwenden, da es für Erstnutzer einfacher ist. Du kannst dir hier ein kostenloses Konto einrichten, um anzufangen - es gibt auch verschiedene Preispläne für Server-Lizenzen, wenn du sie brauchst. Je mehr Nutzer du erwartest, desto teurer muss dein Preisplan sein, also bedenke das. Wenn du etwas für eine kleine Gruppe von Einzelpersonen erstellen willst, kann eine kostenlose Lizenz vollkommen ausreichend sein, aber für eine öffentlich zugängliche App brauchst du vielleicht mehr Lizenzen.

Zuerst sollten wir sicherstellen, dass unsere App für die Veröffentlichung auf einem Server geeignet ist. In deiner App solltest du deine R-Sitzung neu starten und sicherstellen, dass sie ohne zusätzlichen Code läuft. Das ist wichtig, denn eine App, die das Laden von Paketen oder das Lesen von Daten erfordert, die nicht in deinem App-Code definiert sind, läuft nicht auf einem Server. Beachte auch, dass du keine *explizite* Dateipfade in deiner App haben darfst - diese sind in der Servereinstellung ungültig - wenn du die `here` Paket löst dieses Problem sehr gut. Wenn du Daten aus einer Quelle ausliest, die eine Benutzerauthentifizierung erfordert, z. B. von den Servern deines Unternehmens, wird dies in der Regel nicht auf einem Server funktionieren. Du musst dich mit deiner IT-Abteilung in Verbindung setzen, um herauszufinden, wie du den Shiny Server auf die Whitelist setzen kannst.

*Anmeldung zum Konto*

Sobald du dein Konto eingerichtet hast, kannst du zur Token-Seite navigieren unter *Konten*. Hier fügst du ein neues Token hinzu - dieses wird für die Bereitstellung deiner App verwendet.

Ab hier solltest du beachten, dass die URL deines Kontos den Namen deiner App widerspiegelt - wenn deine App also heißt *meine\_app* heißt, wird die Url wie folgt angehängt *xxx.io/meine\_app/*. Wähle den Namen deiner App mit Bedacht! Jetzt bist du bereit und klickst auf "deploy" - wenn du erfolgreich bist, wird deine App auf der von dir gewählten Web-URL ausgeführt!

*etwas über das Erstellen von Apps in Dokumenten?*

## Weitere Lektüre

Bisher haben wir viele Aspekte von Shiny behandelt und kaum an der Oberfläche dessen gekratzt, was Shiny zu bieten hat. Auch wenn dieser Leitfaden als Einführung dient, gibt es noch viel mehr zu lernen, um Shiny vollständig zu verstehen. Du solltest mit der Erstellung von Apps beginnen und nach und nach immer mehr Funktionen hinzufügen

## Empfohlene Erweiterungspakete

Im Folgenden findest du eine Auswahl an hochwertigen Shiny-Erweiterungen, mit denen du noch viel mehr aus Shiny herausholen kannst. In keiner bestimmten Reihenfolge:

- **shinyWidgets** - Dieses Paket bietet dir viele weitere Widgets, die du in deiner App verwenden kannst. ausführen `shinyWidgets::shinyWidgetsGallery()` aus, um eine Auswahl der verfügbaren Widgets mit diesem Paket zu sehen. Siehe Beispiele [hier](https://github.com/dreamRs/shinyWidgets)

- **shinyjs** - Dies ist ein hervorragendes Paket, mit dem du den Nutzen von Shiny durch eine Reihe von Javascripts stark erweitern kannst. Die Anwendungsmöglichkeiten dieses Pakets reichen von sehr einfach bis sehr fortschrittlich, aber vielleicht möchtest du es zunächst nutzen, um die Benutzeroberfläche auf einfache Weise zu manipulieren, z. B. um Elemente ein- oder auszublenden oder Schaltflächen zu aktivieren oder zu deaktivieren. Erfahre mehr [hier](https://deanattali.com/shinyjs/basic)

- **shinydashboard** - Dieses Paket erweitert die verfügbare Benutzeroberfläche, die in Shiny verwendet werden kann, und ermöglicht es dem Benutzer, ein komplexes Dashboard mit einer Vielzahl von komplexen Layouts zu erstellen. Mehr sehen [hier](https://rstudio.github.io/shinydashboard/)

- **shinydashboardPlus** - erhalten Sie noch mehr Funktionen aus dem **shinydashboard** Framework! Mehr sehen [hier](https://rinterface.github.io/shinydashboardPlus/articles/shinydashboardPlus.html)

- **shinythemes** - Ändere das Standard-CSS-Theme für deine Shiny App mit einer großen Auswahl an voreingestellten Vorlagen! Mehr sehen [hier](https://rstudio.github.io/shinythemes/)

Es gibt auch eine Reihe von Paketen, mit denen du interaktive Ausgaben erstellen kannst, die mit Shiny kompatibel sind.

- **DT** ist teilweise in base-shiny integriert, bietet aber eine Reihe von Funktionen, um interaktive Tabellen zu erstellen.

- **plotly** ist ein Paket zur Erstellung interaktiver Diagramme, die der Nutzer in der App bearbeiten kann. Du kannst deinen Plot auch in interaktive Versionen umwandeln, indem du `plotly::ggplotly()`! Als Alternativen, **dygraphs** und **highcharter** sind ebenfalls ausgezeichnet.

## Empfohlene Ressourcen


