
# Текст и последовательности { }  

```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Characters_Strings_1500x500.png"))
```



На данной странице демонстрируется применение пакета **stringr** для оценки и работы с текстовыми значениями ("последовательностями").  

1. Объединение, упорядочивание, разделение, сортировка - `str_c()`, `str_glue()`, `str_order()`, `str_split()`  
2. Вычистка и стандартизация  
    * Корректировка длины - `str_pad()`, `str_trunc()`, `str_wrap()`  
    * Изменение регистра - `str_to_upper()`, `str_to_title()`, `str_to_lower()`, `str_to_sentence()`  
3. Оценка и извлечение по позиции - `str_length()`, `str_sub()`, `word()`  
4. Комбинации символов  
    * Поиск и обнаружение - `str_detect()`, `str_subset()`, `str_match()`, `str_extract()`  
    * Модификация и замена - `str_sub()`, `str_replace_all()`  
7. Регулярные выражения ("regex")


Для простоты отображения большинство примеров показаны с использованием краткого определенного текстового вектора, однако их можно легко адаптировать к столбцам в датафрейме.  

Эта страница во многом основана на идеях [виньетки по stringr](https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html).  



<!-- ======================================================= -->
## Подготовка { }

### Загрузка пакетов {.unnumbered}  

Установите или загрузите **stringr** и другие пакеты **tidyverse**.  

```{r}
# установка/загрузка пакетов
pacman::p_load(
  stringr,    # много функций для работы с последовательностями
  tidyverse,  # для опциональных манипуляций с данными
  tools)      # альтернативы для капитализации всех слов

```


### Импорт данных {.unnumbered}  


На этой странице мы иногда ссылаемся на вычищенный построчный список случаев `linelist` по имитационной эпидемии Эболы. Если вы хотите параллельно выполнять действия, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>кликните, чтобы скачать "чистый" построчный список</a> (as .rds file). Импортируйте данные с помощою функции `import()` из пакета **rio** (она может работать с разными типами файлов, такими как .xlsx, .csv, .rds - см. страницу [Импорт и экспорт](importing.ru.qmd) для получения детальной информации).  

```{r, echo=F}
# импорт построчного списка в R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# импорт построчного списка случаев 
linelist <- import("linelist_cleaned.rds")
```

Первые 50 строк построчного списка отображены ниже.

```{r, message=FALSE, echo=F}
# отображаем данные построчного списка в виде таблицы
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```




<!-- ======================================================= -->
## Объединение, разделение и упорядочивание { }


В этом разделе разбирается:  

* Использование `str_c()`, `str_glue()` и `unite()` для объединения последовательностей  
* Использование `str_order()` для упорядочивания последовательностей  
* Использование `str_split()` и `separate()` для разделения последовательностей  



<!-- ======================================================= -->
### Объединение последовательностей {.unnumbered}

Чтобы объединить или сцепить несколько последовательностей в одну, мы предлагаем использовать `str_c` из пакета **stringr**. Если у вас есть конкретные текстовые значения для объединения, просто задайте их как уникальные аргументы, разделенные запятыми.     

```{r}
str_c("String1", "String2", "String3")
```

Аргумент `sep = ` вставляет текстовое значение между каждым из аргументов, которые вы задали (например, вставляет запятую, пробел или новую строку `"\n"`)  

```{r}
str_c("String1", "String2", "String3", sep = ", ")
```

Аргумент `collapse = ` актуален, если вы закладываете несколько *векторов* в виде аргументов в `str_c()`. Он используется для разделения элементов того, что должно стать *выходным* вектором, так чтобы у выходного вектора был только один длинный текстовый элемент.   

Пример ниже показывает комбинирование двух векторов в один (имена и фамилии). Еще одним похожим примером могут быть юрисдикции и количество случаев. В данном примере:  

* Значение `sep = ` появляется между каждым именем и фамилией  
* Значение `collapse = ` появляется между каждым человеком  


```{r}
first_names <- c("abdul", "fahruk", "janice") 
last_names  <- c("hussein", "akinleye", "okeke")

# sep отображается между соответствующими входными последовательностями, а collapse отображается между созданными элементами
str_c(first_names, last_names, sep = " ", collapse = ";  ")
```

Примечание: В зависимости от желаемого контекста отображения при печати такой объединенной последовательности с новыми строками, вам может потребоваться обернуть всю фразу в `cat()`, чтобы новые строки правильно напечатались:  

```{r}
# Чтобы новые строки были напечатаны правильно, возможно, потребуется обернуть всю фразу в cat()
cat(str_c(first_names, last_names, sep = " ", collapse = ";\n"))
```



<!-- ======================================================= -->
### Динамические последовательности {.unnumbered}

Используйте `str_glue()`, чтобы вставить динамический код R в последовательность. Это очень полезная функция для создания динамических подписей к графикам, как показано ниже.  

* Все содержимое размещается внутри двойных кавычек `str_glue("")`  
* Любой динамический код или ссылки на заранее определенные значения размещаются в фигурных скобках `{}` внутри двойных кавычек. В одной команде `str_glue()` может быть много фигурных скобок.  
* Чтобы отобразить текстовые кавычки '', используйте *одинарные* кавычки внутри двойных кавычек (например, при указании формата даты - см. пример ниже)  
* Совет: вы можете использовать `\n`, чтобы принудительно перейти на новую строку  
* Совет: вы можете использовать `format()`, чтобы откорректировать отображение даты, и использовать `Sys.Date()`, чтобы отобразить текущую дату.  

Простой пример динамической подписи к графику:  

```{r}
str_glue("Data include {nrow(linelist)} cases and are current to {format(Sys.Date(), '%d %b %Y')}.")
```

Альтернативный формат - использовать заполнители внутри скобок, а код определить в отдельном аргументе в конце функции `str_glue()`, как показано ниже. Это может повысить читаемость кода, если текст длинный.

```{r}
str_glue("Linelist as of {current_date}.\nLast case hospitalized on {last_hospital}.\n{n_missing_onset} cases are missing date of onset and not shown",
         current_date = format(Sys.Date(), '%d %b %Y'),
         last_hospital = format(as.Date(max(linelist$date_hospitalisation, na.rm=T)), '%d %b %Y'),
         n_missing_onset = nrow(linelist %>% filter(is.na(date_onset)))
         )

```


**Извлечение из датафрейма**  

Иногда полезно взять данные датафрейма и вставить их последовательно вместе. Ниже приведен пример датафрейма. Мы используем его, чтобы создать сводное утверждение о юрисдикциях и количестве новых и общем количестве случаев.  

```{r}
# создаем датафрейм случаев
case_table <- data.frame(
  zone        = c("Zone 1", "Zone 2", "Zone 3", "Zone 4", "Zone 5"),
  new_cases   = c(3, 0, 7, 0, 15),
  total_cases = c(40, 4, 25, 10, 103)
  )
```

```{r, echo=F}
DT::datatable(case_table, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Используем `str_glue_data()`, которая специально создана для того, чтобы взять данные из строк датафрейма:  

```{r}
case_table %>% 
  str_glue_data("{zone}: {new_cases} ({total_cases} total cases)")
```


**Объединение последовательностей между строками**  

Если вы пытаетесь свести значения в столбце датафрейма, например, объединить значения из нескольких строк в одну строку, вставив их через разделитесь, см. раздел на странице [Дедупликация](deduplication.ru.qmd) по ["Сведение" значений](deduplication.ru.qmd#str_rollup).  

**Датафрейм в одну строку**  

Вы можете сделать так, чтобы утверждение появлялось одной строкой, используя `str_c()` (уточнив датафрейм и имена столбцов), а также задав аргументы `sep = ` и `collapse = `.  

```{r}
str_c(case_table$zone, case_table$new_cases, sep = " = ", collapse = ";  ")
```

Вы можете добавить текстовый префикс "New Cases:" в начало утверждение, обернув его в отдельную команду `str_c()` (если "New Cases:" было в оригинальной `str_c()`, эта фраза появится несколько раз).  

```{r}
str_c("New Cases: ", str_c(case_table$zone, case_table$new_cases, sep = " = ", collapse = ";  "))
```





### Объединение столбцов  {#str_unite .unnumbered}

Объединить текстовые значения из нескольких столбцов в датафрейме можно с помощью `unite()` из **tidyr**. Это действие, противоположное `separate()`.  

Задайте имя нового объединенного столбца. Затем задайте имена столбцов, которые вы хотите объединить.  

* По умолчанию разделителем, используемым в объединенном столбце, будет нижнее подчеркивание `_`, но его можно изменить в аргументе `sep = `.  
* `remove = ` удаляет входные столбцы из датафрейма (по умолчанию TRUE (истина))  
* `na.rm = ` удаляет отсутствующие значения при объединении (по умолчанию FALSE (ложь))  

Ниже мы определяем мини-датафрейм для демонстрации:  

```{r, message = F, warning=F}
df <- data.frame(
  case_ID = c(1:6),
  symptoms  = c("jaundice, fever, chills",     # пациент 1
                "chills, aches, pains",        # пациент 2 
                "fever",                       # пациент 3
                "vomiting, diarrhoea",         # пациент 4
                "bleeding from gums, fever",   # пациент 5
                "rapid pulse, headache"),      # пациент 6
  outcome = c("Recover", "Death", "Death", "Recover", "Recover", "Recover"))
```


```{r}
df_split <- separate(df, symptoms, into = c("sym_1", "sym_2", "sym_3"), extra = "merge")
```

Вот пример датафрейма:  

```{r, echo=F}
DT::datatable(df_split, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Ниже мы объединяем три столбца симптомов:  

```{r}
df_split %>% 
  unite(
    col = "all_symptoms",         # имя нового объединенного столбца
    c("sym_1", "sym_2", "sym_3"), # столбцы для объединения
    sep = ", ",                   # разделитель, который будет использован в объединенном столбце
    remove = TRUE,                # если TRUE (истина), удаляет входные столбцы из датафрейма
    na.rm = TRUE                  # если TRUE (истина), отсутствующие значения удаляются перед объединением
  )
```







<!-- ======================================================= -->
### Разделение {.unnumbered}  

Чтобы разделить последовательность на основе комбинации символов, используйте `str_split()`. Она оценивает последовательность(и) и выдает список текстовых векторов `list` для только что разделенных значений.

Простой пример ниже оценивает одну последовательность и разделяет ее на три. По умолчанию команда выдает объект класса `list` с одним элементом (текстовым вектором) для каждой изначально заданой последовательности. Если `simplify = TRUE` команда выдает текстовую матрицу.  

В данном примере задается одна последовательность, а функция выдает список с одним элементом - текстовым вектором с тремя значениями.  

```{r}
str_split(string = "jaundice, fever, chills",
          pattern = ",")
```

Если выходной продукт сохраняется, вы можете затем получить доступ к n-ному разделенному значению с помощью синтаксиса с квадратными скобками. Чтобы получить доступ к конкретному значению, вы можете использовать подобный синтаксис: `the_returned_object[[1]][2]`, который получит доступ ко второму значению из первой оцениваемой последовательности ("fever"). См. страницу [Основы R] для получения более детальной информации о доступе к элементам.    

```{r}
pt1_symptoms <- str_split("jaundice, fever, chills", ",")

pt1_symptoms[[1]][2]  # извлекает 2-е значение из 1-го (и только) элемента списка
```

Если в `str_split()` заданы несколько последовательностей, то будет выдано больше 1 элемента в получившемся списке.  

```{r}
symptoms <- c("jaundice, fever, chills",     # пациент 1
              "chills, aches, pains",        # пациент 2 
              "fever",                       # пациент 3
              "vomiting, diarrhoea",         # пациент 4
              "bleeding from gums, fever",   # пациент 5
              "rapid pulse, headache")       # пациент 6

str_split(symptoms, ",")                     # разделить симптомы каждого пациента
```


Чтобы вместо этого получить "текстовую матрицу", которая может быть полезна, если вы создаете столбцы датафрейма, задайте аргумент `simplify = TRUE`, как показано ниже:  

```{r}
str_split(symptoms, ",", simplify = TRUE)
```

Вы можете также скорректировать количество разделенных частей, которые вы создаете, с помощью аргумента `n = `. Например, это ограничивает количество разделенных частей до 2. Любые дополнительные запятые остаются во втором значении. 

```{r}
str_split(symptoms, ",", simplify = TRUE, n = 2)
```

*Примечание - те же выходные данные можно получить с помощью `str_split_fixed()`, где вы не задаете аргумент `simplify`, но вместо этого указываете количество столбцов (`n`).* 

```{r, eval=F}
str_split_fixed(symptoms, ",", n = 2)
```




### Разделение столбцов {.unnumbered}  

Если вы пытаетесь разделить столбец датафрейма, лучше использовать функцию `separate()` из **dplyr**. Она используется для разделения одного текстового столбца на другие столбцы.  

Представим, что у нас есть простой датафрейм `df` (определенный и объединенный в [разделе объединения](#str_unite)), содержащий столбец `case_ID`, один текстовый столбец с множеством симптомов, а также столбец исхода. Наша цель - разделить столбец `symptoms` на несколько столбцов - в каждом из которых будет один симптом.  


```{r, echo=F}
DT::datatable(df, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Если предположить, что данные передаются в отдельную функцию `separate()`, сначала задайте столбец, который нужно разделить. Затем задайте `into = ` как вектор `c( )`, содержащий *новые* имена столбцов, как показано ниже.  

* `sep = ` разделитесь, может быть текстовым знаком или числом (интерпретируется как позиция текстового знака, где происходит разделение) 
* `remove = ` по умолчанию FALSE (ложь), удаляет входной столбец  
* `convert = ` по умолчанию FALSE (ложь), превращает "NA" в последовательности в `NA`  
* `extra = ` контролирует, что происходит, если разделением создается больше значений, чем новых именованных столбцов.  
     * `extra = "warn"` означает, что вы увидите предупреждение, но система выкинет излишние значения (**по умолчанию**)  
     * `extra = "drop"` означает, что излишние значения будут выкинуты без предупреждения  
     * **`extra = "merge"` разделит только на количество новых столбцов, указанных в `into` - *эта опция сохранит все ваши данные***  


Пример с использованием `extra = "merge"` приведен ниже - никакие данные не теряются. Определены два новых столбца, но любые третьи симптомы остаются во втором новом столбце:  

```{r}
# третьи симптомы объединяются во втором новом столбце
df %>% 
  separate(symptoms, into = c("sym_1", "sym_2"), sep=",", extra = "merge")
```

Когда ниже используется значение по умолчанию `extra = "drop"`, выдается предупреждение, но третьи симптомы теряются:  

```{r}
# третьи симптомы теряются
df %>% 
  separate(symptoms, into = c("sym_1", "sym_2"), sep=",")
```


<span style="color: orange;">**_ВНИМАНИЕ:_** Если вы не зададите достаточное количество значений `into` для новых столбцов, ваши данные могут быть подрезаны.</span>  






<!-- ======================================================= -->
### Упорядочивание в алфавитном порядке {.unnumbered} 

Несколько последовательностей можно отсортировать в алфавитном порядке. `str_order()` выдает порядок, а `str_sort()` выдает последовательности в этом порядке.  

```{r}
# последовательности
health_zones <- c("Alba", "Takota", "Delta")

# выдает алфавитный порядок
str_order(health_zones)

# выдает последовательности в алфавитном порядке
str_sort(health_zones)
```

Чтобы использовать другой алфавит, добавьте аргумент `locale = `. См. полный список локалей, введя `stringi::stri_locale_list()` в консоли R.  





<!-- ======================================================= -->
### базовые функции R {.unnumbered}

Часто используются **базовые** функции R `paste()` и `paste0()`, которые сцепляют векторы после конвертации всех частей в текстовые. Они работают похожим на `str_c()` образом, но синтаксис считается более сложным - в скобках, где каждая часть отделена запятой. Части либо являются текстом (в кавычках), либо заранее определенными объектами кода (без кавычек). Например:

```{r}
n_beds <- 10
n_masks <- 20

paste0("Regional hospital needs ", n_beds, " beds and ", n_masks, " masks.")
```

Можно уточнить аргументы `sep = ` и `collapse = `. `paste()` - это просто `paste0()` с `sep = " "` по умолчанию (один пробел).  






## Вычистка и стандартизация  


<!-- ======================================================= -->
### Изменение регистра {.unnumbered}

Часто бывает необходимость менять капитализацию значения последовательности, например, названий юрисдикций. Используйте `str_to_upper()`, `str_to_lower()` и `str_to_title()` из **stringr**, как показано ниже:  

```{r}
str_to_upper("California")

str_to_lower("California")
```

Можно добиться того же, что и выше, с помощью функций `toupper()`, `tolower()` из *базового** R.  


**Капитализация всех слов**  

Трансформация последовательности таким образом, чтобы каждое слово было капитализировано, может быть выполнена с помощью `str_to_title()`:  

```{r}
str_to_title("go to the US state of california ")
```

Используйте `toTitleCase()` из пакета **tools** для более сложной капитализации (где не капитализируются такие слова, как "to", "the" и "of").  

```{r}
tools::toTitleCase("This is the US state of california")
```

Вы можете также использовать `str_to_sentence()`, которая капитализирует только первую букву последовательности.

```{r}
str_to_sentence("the patient must be transported")
```



### Наращивание длины  {#str_pad .unnumbered}

Используйте `str_pad()`, чтобы добавить знаки в последовательность до минимальной длины. По умолчанию добавляются пробелы, но вы можете наращивать и с помощью других знаков, используя аргумент `pad = `.  


```{r}
# Коды МКБ разной длины
ICD_codes <- c("R10.13",
               "R10.819",
               "R17")

# Коды МКБ наращиваются до 7 знаков с правой стороны
str_pad(ICD_codes, 7, "right")

# Наращивание точками вместо пробелов
str_pad(ICD_codes, 7, "right", pad = ".")
```

Например, чтобы нарастить числа нулями в начале (например, для часов или минут), вы можете нарастить число до минимальной длины в 2 знака с помощью `pad = "0"`.

```{r}
# Добавляем нули в начале до получения двух знаков (например, для минут/часов)
str_pad("4", 2, pad = "0") 

# пример использования числового столбца с именем "hours"
# hours <- str_pad(hours, 2, pad = "0")
```


### Укорачивание {.unnumbered} 

`str_trunc()` задает максимальную длину каждой последовательности. Если последовательность превышает эту длину, она обрезается (укорачивается) и добавляется многоточие (...), чтобы указать, что ранее последовательность была длиннее. Обратите внимание, что многоточие *считается* в длине. Знаки многоточия можно изменить с помощью аргумента `ellipsis = `.  Опциональный аргумент `side = ` указывает, где появится многоточие в укороченной последовательности ("left" (слева), "right" (справа), либо "center" (в центре)).  

```{r}
original <- "Symptom onset on 4/3/2020 with vomiting"
str_trunc(original, 10, "center")
```


### Стандартизация длины {.unnumbered}

Используйте `str_trunc()`, чтобы задать максимальную длину, а затем используйте `str_pad()`, чтобы расширить очень короткие последовательности до этой укороченной длины. В примере ниже, 6 задается как максимальная длина (одно значение укорачивается), а затем одно очень короткое значение наразивается до длины в 6 знаков.    

```{r}
# МКБ коды разной длины
ICD_codes   <- c("R10.13",
                 "R10.819",
                 "R17")

# укорачиваем до максимальной длины в 6 знаков
ICD_codes_2 <- str_trunc(ICD_codes, 6)
ICD_codes_2

# расширяем до минимальной длины в 6 знаков
ICD_codes_3 <- str_pad(ICD_codes_2, 6, "right")
ICD_codes_3
```


### Удаление пустого пространства в начале/в конце {.unnumbered}  

Используйте `str_trim()`, чтобы удалить пробелы, новые строки (`\n`) или отступы (`\t`) по бокам последовательности. Добавьте `"right"` (справа), `"left"` (слева), или `"both"` (оба) к команде, чтобы уточнить, какую сторону обрезать (например, `str_trim(x, "right")`. 

```{r}
# ID номера с лишними пробелами справа
IDs <- c("provA_1852  ", # два лишних пробела
         "provA_2345",   # ноль лишних пробелов
         "provA_9460 ")  # один лишний пробел

# ID номера укорачиваются, чтобы удалить лишние пробелы только с правой стороны
str_trim(IDs)
```


### Удаление повторяющихся пробелов внутри последовательности {.unnumbered}  

Используйте `str_squish()` для удаления повторяющихся пробелов *внутри* последовательности. Например, чтобы конвертировать двойные пробелы в одинарные пробелы. Эта команда также удаляет пробелы, новые строки или табуляцию на внешних концах последовательности, как `str_trim()`.  


```{r}
# в оригинале внутри последовательности есть лишние пробелы
str_squish("  Pt requires   IV saline\n") 
```

Введите `?str_trim`, `?str_pad` на консоли R для получения дополнительной информации.  


### Создание абзацев {.unnumbered}  

Используйте `str_wrap()`, чтобы из длинного неструктурированного текста создать структурированный абзац с фиксированной длиной строк. Укажите идеальную длину для каждой строки и функция применит алгоритм по вставке разрывов строк внутри абзаца, как показано в примере ниже.   

```{r}
pt_course <- "Symptom onset 1/4/2020 vomiting chills fever. Pt saw traditional healer in home village on 2/4/2020. On 5/4/2020 pt symptoms worsened and was admitted to Lumta clinic. Sample was taken and pt was transported to regional hospital on 6/4/2020. Pt died at regional hospital on 7/4/2020."

str_wrap(pt_course, 40)
```

Указанная выше команда может быть обернута в **Базовую** функцию `cat()`, чтобы напечатать получившийся результат, отображающий новые добавленные строки.  

```{r}
cat(str_wrap(pt_course, 40))
```












<!-- ======================================================= -->
## Работа с последовательностями на основе их позиции { }


### Извлечение по позиции текстового знака {.unnumbered}  

Используйте `str_sub()`, чтобы выдать только часть последовательности. Эта фукнция использует три основных аргумента:  

1) текстовый вектор(ы)  
2) стартовая позиция  
3) конечная позиция  

Несколько комментариев по числам позиции:  

* Если число позиции положительное, позиция считается, начиная с левой части последовательности.  
* Если число позиции отрицательное, она считается, начиная с правой части последовательности.  
* Числа позиции считаются включительно.  
* Позиции за пределами последовательности будут укорочены (удалены).  

Ниже приведены некоторые примеры применительно к последовательности "pneumonia":  

```{r}
# начало и окончание на третьем слева (3я буква слева)
str_sub("pneumonia", 3, 3)

# 0 не присутствует
str_sub("pneumonia", 0, 0)

# от 6го слева до 1го справа
str_sub("pneumonia", 6, -1)

# от 5го справа до 2го справа
str_sub("pneumonia", -5, -2)

# от 4го слева до позиции за пределами последовательности
str_sub("pneumonia", 4, 15)
```



### Извлечение по позиции слова {.unnumbered} 

Чтобы извлечь n-ое 'слово', используйте `word()`, также из пакета **stringr**. Укажите последовательность(и), затем первую позицию слова для извлечения, а также последнюю позицию слова для извлечения.  

По умолчанию разделителем между 'словами' считается пробел, если не указано иное в аргументе `sep = ` (например, `sep = "_"`, когда слова отделяются нижними подчеркиваниями.  


```{r}
# последовательности для оценки
chief_complaints <- c("I just got out of the hospital 2 days ago, but still can barely breathe.",
                      "My stomach hurts",
                      "Severe ear pain")

# извлечь с 1го по 3е слово каждой последовательности
word(chief_complaints, start = 1, end = 3, sep = " ")
```


### Замена по позиции текстового знака {.unnumbered} 

`str_sub()` вместе с оператором присваивания (`<-`) может быть использован для модификации части последовательности: 

```{r}
word <- "pneumonia"

# конвертирует третий и четвертый знаки в X 
str_sub(word, 3, 4) <- "XX"

# печать
word
```

Пример применения к нескольким последовательностям (например, к столбцу). Обратите внимание на длину "HIV".  

```{r}
words <- c("pneumonia", "tubercolosis", "HIV")

# конвертирует третий и четвертый знаки в X 
str_sub(words, 3, 4) <- "XX"

words
```



### Оценка длины  {.unnumbered}


```{r}
str_length("abc")
```

Альтернативно используйте `nchar()` из **базового** R







<!-- ======================================================= -->
## Комбинации символов { }

Многие функции **stringr** работают для обнаружения, поиска, извлечения, поиска соответствия, замены и разделения на основе указанной *комбинации символов*.  



<!-- ======================================================= -->
### Обнаружение комбинации символов {.unnumbered}

Используйте `str_detect()`, как показано ниже, чтобы обнаружить наличие/отсутствие комбинации символов внутри последовательности. Сначала задайте последовательность или вектор, в котором будет идти поиск (`string = `), а затем комбинацию символов, которую нужно искать (`pattern = `). Обратите внимание, что по умолчанию, этот поиск *чувствителен к регистру*!

```{r}
str_detect(string = "primary school teacher", pattern = "teach")
```

Можно включить аргумент `negate = ` и установить на `TRUE` (истина), если вы хотите узнать, что комбинации символов НЕТ.  
 
```{r}
str_detect(string = "primary school teacher", pattern = "teach", negate = TRUE)
```

Чтобы игнорировать регистр/капитализацию, оберните вокруг комбинации символов команду `regex()`, а *внутри* `regex()` добавьте аргумент `ignore_case = TRUE` (или `T` в качестве сокращения).  

```{r}
str_detect(string = "Teacher", pattern = regex("teach", ignore_case = T))
```

Когда применяется `str_detect()` к текстовому вектору или столбцу датафрейма, команда выдаст TRUE (истина) или FALSE (ложь) для каждого из значений. 

```{r}
# вектор/столбец рода занятий 
occupations <- c("field laborer",
                 "university professor",
                 "primary school teacher & tutor",
                 "tutor",
                 "nurse at regional hospital",
                 "lineworker at Amberdeen Fish Factory",
                 "physican",
                 "cardiologist",
                 "office worker",
                 "food service")

# Обнаружение наличия комбинации символов "teach" в каждой последовательности - выходным результатом будет вектор TRUE/FALSE
str_detect(occupations, "teach")
```

Если вам надо подсчитать количество значений `TRUE`, просто используйте `sum()` для выходных результатов. Команда подсчитает количество значений `TRUE`.  

```{r}
sum(str_detect(occupations, "teach"))
```

Чтобы искать включительно по нескольким терминам, включите их и разделите вертикальными чертами ИЛИ (`|`) внутри аргумента `pattern = `, как показано ниже:  

```{r}
sum(str_detect(string = occupations, pattern = "teach|professor|tutor"))
```

Если вам нужно построить длинный список условий поиска, вы можете объединить их, используя `str_c()` и `sep = |`, затем определите как текстовый объект, а затем позже вы можете ссылаться на вектор более кратким образом. Пример ниже включает возможные виды деятельности для поиска медицинских работников на передовой.     

```{r}
# условия поиска
occupation_med_frontline <- str_c("medical", "medicine", "hcw", "healthcare", "home care", "home health",
                                "surgeon", "doctor", "doc", "physician", "surgery", "peds", "pediatrician",
                               "intensivist", "cardiologist", "coroner", "nurse", "nursing", "rn", "lpn",
                               "cna", "pa", "physician assistant", "mental health",
                               "emergency department technician", "resp therapist", "respiratory",
                                "phlebotomist", "pharmacy", "pharmacist", "hospital", "snf", "rehabilitation",
                               "rehab", "activity", "elderly", "subacute", "sub acute",
                                "clinic", "post acute", "therapist", "extended care",
                                "dental", "dential", "dentist", sep = "|")

occupation_med_frontline
```

Эта команда выдает число видов деятельности, которые содержат одно из терминов поиска для передовых медицинских работников (`occupation_med_frontline`):  

```{r}
sum(str_detect(string = occupations, pattern = occupation_med_frontline))
```



**Функции поиска по последовательности в базовом R**  

Функция **базового** R `grepl()` работает аналогично `str_detect()`, в том плане, что она ищет соответствие комбинации символов и выдает логический вектор. Базовый синтаксис: `grepl(pattern, strings_to_search, ignore.case = FALSE, ...)`. Преимуществом является то, что аргумент `ignore.case` легче написать (нет необходимости использовать функцию `regex()`).  

Аналогично, **базовые** функции `sub()` и `gsub()` работают похожим на `str_replace()` образом. Их основной синтаксис: `gsub(pattern, replacement, strings_to_search, ignore.case = FALSE)`. `sub()` заменит первое совпадение по комбинации, а `gsub()` заменит все совпадения по комбинации.  


#### Конвертация запятых в точки {.unnumbered}  

Вот пример использования `gsub()` для конвертации запятых в точки в векторе чисел. Это может быть полезно, если вы получаете данные из регионов мира за пределами США или Великобритании.  

Внутренняя команда `gsub()`, которая сначала работает над `lengths` конвертирует любые точки в отсутствие пробелов "". Знак точки "." должен быть "изолирован" с помощью двух слэшей, чтобы он собственно означал точку, поскольку "." в регулярном выражении(regex) означает "любой знак". Затем результат (только с запятыми) передается во внешнюю функцию `gsub()`, в которой запятые заменяются на точки.   

```{r, eval=F}
lengths <- c("2.454,56", "1,2", "6.096,5")

as.numeric(gsub(pattern = ",",                # находит запятые     
                replacement = ".",            # меняет их на точки
                x = gsub("\\.", "", lengths)  # вектор с другими точками удаляется (точки изолируются)
                )
           )                                  # конвертация выходных данных в числовые
```





### Заменить все {.unnumbered}  

Используйте `str_replace_all()` в качестве инструмента "найти и заменить". Во-первых, задайте, какие последовательности будут оцениваться в аргументе `string = `, затем комбинацию, которую нужно заменить в `pattern = `, и затем на какое значение менять в `replacement = `. Пример ниже заменяет все случаи, когда встречается "dead" (мертвый) на "deceased" (скончавшийся). Обратите внимание, команда ЧУВСТВИТЕЛЬНА к регистру.  

```{r}
outcome <- c("Karl: dead",
            "Samantha: dead",
            "Marco: not dead")

str_replace_all(string = outcome, pattern = "dead", replacement = "deceased")
```

Примечания:  

* Чтобы заменить комбинацию на `NA`, используйте `str_replace_na()`.  
* Функция `str_replace()` заменяет только первое совпадение комбинации в каждой оцениваемой последовательности.  





<!-- ======================================================= -->
### Обнаружение в рамках логических функций {.unnumbered}


**В рамках `case_when()`**  

`str_detect()` часто используется в рамках `case_when()` (из **dplyr**). Представим, что в построчном списке есть столбец `occupations`. Функция `mutate()` ниже создает новый столбец под названием `is_educator`, используя условную логику с помощью `case_when()`. См. страницу вычистка данных для получения более подробной информации о `case_when()`.  


```{r, eval=F}
df <- df %>% 
  mutate(is_educator = case_when(
    # поиск по термину в роде деятельности, не чувствителен к регистру
    str_detect(occupations,
               regex("teach|prof|tutor|university",
                     ignore_case = TRUE))              ~ "Educator",
    # все прочие
    TRUE                                               ~ "Not an educator"))
```

Напоминаем, что может быть важным добавить критерии исключения в логику условий (`negate = F`):  

```{r, eval=F}
df <- df %>% 
  # значение в новом столбце is_educator основано на условной логике
  mutate(is_educator = case_when(
    
    # столбец род деятельности должен соответствовать 2 критериям, чтобы ему было присвоено значение "Educator":
    # он должен иметь термин из поиска и НЕ СООТВЕТСТВОВАТЬ условиям исключения
    
    # должен иметь термин из поиска
    str_detect(occupations,
               regex("teach|prof|tutor|university", ignore_case = T)) &              
    
    # И НЕ ДОЛЖЕН подпадать под критерии исключения
    str_detect(occupations,
               regex("admin", ignore_case = T),
               negate = TRUE                        ~ "Educator"
    
    # Все строки, не соответствующие указанным выше критериям
    TRUE                                            ~ "Not an educator"))
```





<!-- ======================================================= -->
### Поиск позиции комбинации {.unnumbered}  

Чтобы найти *первую* позицию комбинации, используйте `str_locate()`. В качестве результата вы получите стартовую и конечную позицию.   

```{r}
str_locate("I wish", "sh")
```

Как и другие фукнции `str`, существует версия "_all" (`str_locate_all()`), которая выдает позиции *всех* случаев, когда встречается комбинация в каждой последовательности. Выходным результатом будет `list`.  

```{r}
phrases <- c("I wish", "I hope", "he hopes", "He hopes")

str_locate(phrases, "h" )     # позиция *первого* случая комбинации
str_locate_all(phrases, "h" ) # позиция *каждого* случая комбинации
```





<!-- ======================================================= -->
### Извлечение совпадений {.unnumbered}  

`str_extract_all()` выдает сами совпадающие комбинации, что наиболее полезно, если вы предложили несколько комбинаций с условием "ИЛИ". Например, поиск по последовательности вектора рода занятий (см. предыдушую вкладку) *любого из вариантов* "teach", "prof" или "tutor".

`str_extract_all()` выдает список `list`, который содержит *все совпадения* для каждой оцениваемой последовательности. См. ниже, что у рода деятельности 3 имеется два соответствия по комбинациям.  

```{r}
str_extract_all(occupations, "teach|prof|tutor")
```


`str_extract()` извлекает *только первое совпадение* в каждой оцениваемой последовательности, создавая текстовый вектор с одним элементом для каждой оцениваемой последовательности. Команда выдает `NA` в тех случаях, где не было совпадений. `NA` можно удалить, если вы обернете полученный вектор в `na.exclude()`. Обратите внимание, что второе совпадение рода деятельности 3 не показано.  

```{r}
str_extract(occupations, "teach|prof|tutor")
```

<!-- ======================================================= -->
### Подмножество и подсчет {.unnumbered}  

Функции сопоставления включают `str_subset()` и `str_count()`.  

`str_subset()` выдает собственно значения, которые содержат комбинацию: 

```{r}
str_subset(occupations, "teach|prof|tutor")
```

`str_count()` выдает вектор чисел: **количество раз** появления поискового термина в каждом оцениваемом значении.  

```{r}
str_count(occupations, regex("teach|prof|tutor", ignore_case = TRUE))
```












<!-- ======================================================= -->
### Группы регулярных выражений {.unnumbered}

НАХОДИТСЯ В РАЗРАБОТКЕ






<!-- ======================================================= -->
## Специальные символы  

**Обратный слэш `\` для изолирования**  

Обратный слэш `\` используется для "изолирования" значения следующего знака. Таким образом, бэкслэш можно использовать, чтобы отобразить кавычку *внутри* других кавычек (`\"`) - кавычка в середине не "поломает" кавычки вокруг.  

Примечание - таким образом, если вам нужно *отобразить* обратный слэш, вы должны изолировать его значение *еще одним* обратным слэшем. То есть, вам нужно написать два обратных слэша, `\\` чтобы отобразить один.  

**Специальные символы**  

Специальный символ| Представляет собой  
----------------- | --------------------------------------------------------------    
`"\\"` | обратный слэш  
`"\n"` | новая строка   
`"\""` | двойные кавычки *внутри* двойных кавычек  
`'\''` | одинарная кавычка *внутри* одинарных кавычек  
`"\`"` | аксан грав  
`"\r"` | возврат каретки  
`"\t"` | tab  
`"\v"` | вертикальный tab 
`"\b"` | backspace  


Чтобы увидеть полный список этих специальных символов выполните `?"'"` в консоли R (он появится на панели RStudio Help (справка)). 



<!-- ======================================================= -->
## Регулярные выражения (regex) 


<!-- ======================================================= -->
## Регулярные выражения и специальные знаки { } 

Регулярные выражения, или "regex" - это краткий язык описания комбинаций в последовательностях. Если вы с ним не знакомы, регулярное выражение может выглядеть как незнакомый язык. Здесь мы постараемся немного раскрыть его тайны.  

*Этот раздел во многом заимствован из [этого самоучителя](https://towardsdatascience.com/a-gentle-introduction-to-regular-expressions-with-r-df5e897ca432) and [this cheatsheet](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)*. Мы включили сюда некоторые его части, понимая, что данное руководство могут просматривать пользователи без доступа к интернету и возможности просмотра других учебников.    


Регулярное выражение часто применяется для извлечения конкретных комбинаций из "неструктурированного" текста - например, медицинских записей, основных жалоб, анамнеза жизни или иных столбцов со свободным текстом в датафрейме.  

Вот четыре основных инструмента, которые можно использовать для создания простого регулярного выражения:  

1) Наборы символов  
2) Мета символы  
3) Квантификаторы  
4) Группы  


**Наборы символов**  

Наборы символов - способ выражения опций перечисления для совпадения по символам внутри скобок. Таким образом, будет определено совпадение, если любой из символов в скобках будет обнаружен в последовательности. НАпример, чтобы искать гласные буквы, можно использовать набор символов: "[aeiou]". Часто встречаются следующие наборы символов:  

Набор символов | Совпадение для  
----------------- | --------------------------------------------------------------    
`"[A-Z]"` | любая одна заглавная буква  
`"[a-z]"` | любая одна строчная буква  
`"[0-9]"` | любая цифра  
`[:alnum:]` | любой алфавитно-цифровой символ  
`[:digit:]` | любая числовая цифра  
`[:alpha:]` | любая буква (заглавная или строчная)  
`[:upper:]` | любая заглавная буква  
`[:lower:]` | любая строчная буква  


Наборы символов можно комбинировать в одних квадратных скобках (без пробелов!), например: `"[A-Za-z]"` (любая заглавная или строчная буква), еще один пример: `"[t-z0-5]"` (строчная буква от t до z ИЛИ цифра от 0 до 5).  



**Мета символы**  

Мета символы - сокращения для набора символов. Некоторые наиболее важные перечислены ниже:  

Мета символ | Представляет собой  
----------------- | --------------------------------------------------------------    
`"\\s"` | один пробел  
`"\\w"` | любой один алфавитно-цифровой знак (A-Z, a-z, or 0-9)  
`"\\d"` | любая одна цифра (0-9)  


**Квантификаторы**  

Как правило, вы не ищете совпадение только по одному символу. Квантификаторы позволяют вам определить длину букв/цифр, чтобы считать их совпадением.  

Квантификаторы - цифры, записанные в фигурных скобках `{ }` *после* знака, который они количественно определяют, например,  

* `"A{2}"` выдаст случаи **двух** заглавных букв A.  
* `"A{2,4}"` выдаст случаи, где **от двух до четырех** заглавных букв A *(не ставьте пробелы!)*.  
* `"A{2,}"` выдаст случаи **двух или более** заглавных букв A.  
* `"A+"` выдаст случаи **одной или более** заглавной буквы A (группа расширяется, пока не будет встречен другой символ).  
* Поставьте в начале звездочку `*`, чтобы получить **ноль или более** совпадений (полезно, если вы не уверены, есть ли совпадения по комбинации)  


Если вы используете знак плюс `+` как квантификатор, совпадение будет происходить, пока не будет встречен другой символ. Например, это выражение выдаст вам все *слова* (алфавитные символы: `"[A-Za-z]+"`  


```{r}
# проверка последовательности с квантификаторами
test <- "A-AA-AAA-AAAA"
```

Когда используется квантификатор {2}, выдаются только пары последовательно идущих A. В `AAAA` выявляется две пары.  

```{r}
str_extract_all(test, "A{2}")
```

Когда используется квантификатор {2,4}, выдаются группы последовательных A длиной от двух до четырех.  

```{r}
str_extract_all(test, "A{2,4}")
```

При использовании квантификатора `+`, выдаются группы **с одной или более**:  

```{r}
str_extract_all(test, "A+")
```

**Относительная позиция**  

Выражает требования к тому, что идет до или после комбинации. НАпример, чтобы извлечь предложения, "два числа, за которыми идет точка" (`""`).  (?<=\\.)\\s(?=[A-Z]) 

```{r}
str_extract_all(test, "")
```

Заявление о позиции | Соответствует  
----------------- | --------------------------------------------------------------    
`"(?<=b)a"` | "a" **перед которой стоит** "b"  
`"(?<!b)a"` | "a" **перед которой НЕ стоит** "b"  
`"a(?=b)"` | "a" **после которой идет** "b"  
`"a(?!b)"` | "a" **после которой НЕ идет** "b"  





**Группы**  

Учет групп в вашем регулярном выражении является способом получения более структурированных выходных данных после извлечения.  




**Примеры регулярных выражений**  

Ниже представлен свободный текст примера. Мы попробуем извлечь из него полезную информацию, используя поиск с помощью регулярного выражения.  

```{r}
pt_note <- "Patient arrived at Broward Hospital emergency ward at 18:00 on 6/12/2005. Patient presented with radiating abdominal pain from LR quadrant. Patient skin was pale, cool, and clammy. Patient temperature was 99.8 degrees farinheit. Patient pulse rate was 100 bpm and thready. Respiratory rate was 29 per minute."
```

Данное выражение ищет совпадения со всеми словами (любой символ, пока не наткнется на не-символ, например, пробел):  

```{r}
str_extract_all(pt_note, "[A-Za-z]+")
```

Выражение `"[0-9]{1,2}"` ищет совпадения с последовательно расположенными цифрами, длиной 1 или 2 знака. Его можно также записать как `"\\d{1,2}"`, либо `"[:digit:]{1,2}"`.  

```{r}
str_extract_all(pt_note, "[0-9]{1,2}")
```

<!-- Это выражение извлечет все предложения (при условии, что первая буква капитализирована, и предложение оканчивается точкой). Прочитать эту последовательность словами можно как: "Заглавная буква, после которой идет какое-то количество строчных букв, пробел, несколько букв, пробел,     -->

<!-- ```{r} -->
<!-- str_extract_all(pt_note, "[A-Z][a-z]+\\s\\w+\\s\\d{1,2}\\s\\w+\\s*\\w*") -->
<!-- ``` -->


Вы можете просмотреть полезный список выражений regex и советы на странице 2 [данной шпаргалки](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)  

Также посмотрите этот [самоучитель](https://towardsdatascience.com/a-gentle-introduction-to-regular-expressions-with-r-df5e897ca432).  




<!-- ======================================================= -->
## Ресурсы { }

Справочный лист по функциям **stringr** можно найти [тут](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)


Виньетку по **stringr** можно найти [тут](https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html)



