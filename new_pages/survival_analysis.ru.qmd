
<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Анализ выживаемости { }  


```{r out.width = c('75%'), fig.align='center', fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "survival_analysis.png"))
```

<!-- ======================================================= -->
## Обзор {}


*Анализ выживаемости* фокусируется на описании для отдельного лица или группы лиц определенной точки событий, называемой **_происшествие_** (возникновение заболевания, излечение от заболевания, смерть, рецидив после ответа на лечение...), которая происходит в период времени, называемый **_время происшествия_** (или  **_время отслеживания_** в когортных/популяционных исследованиях), во время которого ведется наблюдение за лицами. Чтобы определить время происшествия, необходимо определить отправную точку (это может быть дата включения, дата постановки диагноза...). 

В этом случае объектом вывода при анализе выживаемости является время между отправной точкой и событием.
В современных медицинских исследованиях оно широко используется, например, в клинических исследованиях для оценки эффекта лечения или в онкологической эпидемиологии для оценки большого числа показателей выживаемости при раке. 


Как правило, выражается в **_вероятности выживания_**, которая является вероятностью того, что интересующее событие не возникло до длительности t.


**_Цензурировуание_**: Цензурирование возникает в том случае, если в конце наблюдения у некоторых индивидуумов не произошло интересующее событие, и, таким образом, истинное время наступления события неизвестно. Здесь мы в основном рассматриваем правое цензурирование, но более подробную информацию о цензурировании и анализе выживаемости в целом можно найти в разделе Ресурсы. 


```{r echo=F, eval=F, out.width = "80%", out.height="80%", fig.align = "center"}
 
#Добавляем рисунок из следующих фрагментов для последней версии на странице
#не забывайте сохранять выходные рисунки в "images"
# knitr::include_graphics(here::here("images", "survanalysis.png"))

```  

<!-- ======================================================= -->
## Подготока {  }

### Загрузка пакетов {.unnumbered}  

Чтобы выполнить анализ выживаемости в R, одним из наиболее часто используемых пакетов является пакет **survival**. Сначала мы его установим, затем загрузим его и другие пакеты, которые используются в данном разделе:

В данном руководстве мы фокусируемся на использовании `p_load()` из пакета **pacman**, которая устанавливает пакет, если необходимо, *и* загружает его для использования. Вы можете также загрузить установленные пакеты с помощью `library()` из **базового** R. См. страницу [Основы R](basics.ru.qmd) для получения дополнительной информации о пакетах R.  

```{r, echo=F, message=FALSE, warning=FALSE}

# устанавливаем/загружаем разные пакеты, необходимые для этой страницы
pacman::p_load(
  survival,      # анализ выживаемости 
  survminer,     # анализ выживаемости
  rio,           # импорт данных  
  here,          # относительный путь к файлу  
  janitor,       # табуляция
  SemiCompRisks, # примеры набора данных и продвинутые инструменты для работы с Semi-Competing Risks data
  tidyverse,     # манипуляции с данными и визуализация
  Epi,           # статистический анализ в эпидемиологии
  survival,      # анализ выживаемости
  survminer      # анализ выживаемости: продвинутые кривые KM curves
)


```


На этой странице мы рассмотрим анализ выживаемости на примере построчного списка, использованного на большинстве предыдущих страниц, который мы немного изменим, чтобы иметь надлежащие данные о выживаемости.


### Импорт набора данных {.unnumbered}  

Мы импортируем набор данных о случаях из имитированной эпидемии Эболы. Если вы хотите выполнять действия параллельно, <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>кликните, чтобы скачать "чистый" построчный список</a> (как файл .rds). Импортируйте данные с помощью функции `import()` из пакета **rio** (она работает с разными типами файлов, такиим как .xlsx, .csv, .rds - см. детальную информацию на странице [Импорт и экспорт](importing.ru.qmd)).  

```{r echo=F}
# импортируем построчный список
linelist_case_data <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r eval=F}
# импортируем построчный список
linelist_case_data <- rio::import("linelist_cleaned.rds")
```

### Управление данными и преобразования {.unnumbered}

Если говорить кратко, данные о выживаемости можно описать как имеющие следующие три характеристики:

1) зависимая переменная или отклик - время ожидания до возникновения хорошо определенного события,
2) наблюдения цензурированы в том смысле, что для некоторых единиц интересующее событие не возникло на момент анализа данных, и 
3) существуют предикторы или независимые переменные, чей эффект на время ожидания мы хотим оценить или контролировать 

Следовательно, мы создаем разные переменные, необходимые для соблюдения этой структуры и выполнения анализа выживаемости.

Мы определяем:

- новый датафрейм `linelist_surv` для этого анализа  
- интересующее нас событие, как "смерть" (следовательно, вероятность выживания будет вероятностью того, что человек жив через определнный промежуток времени после отправной точки),
- время отслеживания (`futime`) как время от возникновения до времени исхода *в днях*,
- цензурированных пациентов, каак тех, кто выздоровел или по кому исход неизвестен, т.е. событие "смерть" не наблюдалось (`event=0`).

<span style="color: orange;">**_ВНИМАНИЕ:_** Поскольку в реальном когортном исследовании информация об отправной точке и окончании отслеживания известна, поскольку люди находятся под наблюдением, мы будем удалять наблюдения, в которых дата возникновения или дата исхода неизвестна. Также будут удалены случаи, когда дата возникновения заболевания позже даты исхода, так как они считаются ошибочными.</span>

<span style="color: darkgreen;">**_СОВЕТ:_** Учитывая, что фильтрация по дате больше чем (>) или меньше чем (<) позволяет удалить строки с пропущенными значениями, применение фильтра к неправильным датам также приведет к удалению строк с пропущенными датами.</span>

Затем используем `case_when()`, чтобы создать столбец `age_cat_small`, в котором будет только 3 возрастных категории.

```{r }
#создаем новые данные под названием linelist_surv из linelist_case_data

linelist_surv <-  linelist_case_data %>% 
     
  dplyr::filter(
       # удаляем наблюдения с неправильными или отсутствующими датами возникновения или датой исхода
       date_outcome > date_onset) %>% 
  
  dplyr::mutate(
       # создаем переменную event (событие), которая будет равна 1, если пациент умер и 0, если было применено правое цензурирование
       event = ifelse(is.na(outcome) | outcome == "Recover", 0, 1), 
    
       # создаем переменную по времени отслеживания в днях
       futime = as.double(date_outcome - date_onset), 
    
       # создаем новую переменную возрастной категории только с 3 уровнями страт
       age_cat_small = dplyr::case_when( 
            age_years < 5  ~ "0-4",
            age_years >= 5 & age_years < 20 ~ "5-19",
            age_years >= 20   ~ "20+"),
       
       # на предыдущем шаге переменная age_cat_small была создана как текстовая.
       # теперь конвертируем в фактор и задаем уровни
       # Обратите внимание, что значения NA остаются NA, а не размещаются, например, в уровень "unknown" (неизвестно),
       # поскольку при следующем анализе их нужно будет убрать
       age_cat_small = fct_relevel(age_cat_small, "0-4", "5-19", "20+")
       )
```


<span style="color: darkgreen;">**_СОВЕТ:_** Мы можем верифицировать новые столбцы, которые мы создали, посмотрев суммарную статистику по `futime` и кросс-табуляцию между `event` и `outcome`, из которых они были созданы. Кроме этой верификации полезной привычкой будет сообщение медианного времени отслеживания при интерпретации результатов анализа выживаемости.</span>

```{r }

summary(linelist_surv$futime)

# кросс-табуляция новой переменной event и переменной outcome, из которой она была создана
# чтобы проверить, что код сделал то, что нужно
linelist_surv %>% 
  tabyl(outcome, event)
```

Теперь проведем кросс-табуляцию новой переменной age_cat_small и старого столбца age_cat, чтобы убедиться в правильности присваивания  

```{r}
linelist_surv %>% 
  tabyl(age_cat_small, age_cat)
```

Рассмотрим первые 10 наблюдений из данных `linelist_surv`, рассматривая конкретные переменные (включая те, которые только что созданы).  


```{r}
linelist_surv %>% 
  select(case_id, age_cat_small, date_onset, date_outcome, outcome, event, futime) %>% 
  head(10)
```

Мы также можем провести кросс-табуляцию столбцов `age_cat_small` и `gender`, чтобы получить дополнительную информацию о распределении этого нового столбца по полу. Мы используем `tabyl()` и функции *adorn* из **janitor**, как описано на странице [Описательные таблицы]. 

<!-- Для этого мы используем функцию `stat.table()` из пакета **Epi**. -->

```{r}

linelist_surv %>% 
  tabyl(gender, age_cat_small, show_na = F) %>% 
  adorn_totals(where = "both") %>% 
  adorn_percentages() %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front")

```

<!-- Epi::stat.table(  -->
<!--   #задаем переменные для кросс-табуляции -->
<!--   list( -->
<!--     gender,  -->
<!--     age_cat_small -->
<!--     ), -->

<!--   #уточняем функцию, которую мы хотим вызвать (mean,count..) -->
<!--   list(  -->
<!--     count(), -->
<!--     percent(age_cat_small) -->
<!--     ),  -->

<!--   #добавляем границы -->
<!--   margins=T,  -->

<!--   #использованные данные -->
<!--   data = linelist_surv  -->
<!--   ) -->

<!-- ``` -->


<!-- ======================================================= -->
## Основы анализа выживаемости {}


### Построение объекта типа surv {.unnumbered}

Сначала мы используем `Surv()` из **survival**, чтобы построить объект выживаемости (survival) из столбцов времени отслеживания и события.  

В результате такого шага создается объект типа *Surv*, объединяющий информацию о времени и о том, наблюдалось ли интересующее нас событие (смерть). Этот объект в конечном итоге будет использоваться в правой части последующих формул модели (см. [документацию](https://cran.r-project.org/web/packages/survival/vignettes/survival.pdf)).  


```{r survobj }
# используем синтаксис Suv() для данных с правым цензурированием
survobj <- Surv(time = linelist_surv$futime,
                event = linelist_surv$event)
```

<!-- ```{r} -->
<!-- survobj <- with(linelist_surv, -->

<!--                 survival::Surv(futime, event) -->

<!--                 ) -->
<!-- ``` -->


Для рассмотрения представим первые 10 строк данных `linelist_surv`, и рассмотрим только некоторые важные столбцы.  

```{r}
linelist_surv %>% 
  select(case_id, date_onset, date_outcome, futime, outcome, event) %>% 
  head(10)
```

Вот первые 10 элементов `survobj`. Они печатаются по сути как вектор времени отслеживания с "+", который отражает, было ли проведено правое цензурирование для наблюдения. Посмотрите, как соотносятся числа выше и ниже.  

```{r}
#печать первых 50 элементов вектора, чтобы посмотреть, как он выглядит
head(survobj, 10)
```


### Проведение начального анализа {.unnumbered}

Затем мы начинаем наш анализ с использования функции `survfit()` для создания *объекта survfit*, который создает расчеты по умолчанию для оценок **_Каплана Мейера_** (КМ) для общей (предельной) кривой выживания, которые по факту являются ступенчатой функцией со скачками во время наблюдаемого события. Итоговый *объект survfit* содержит одну или более кривых выживания и создается, используя объект *Surv* как переменную отклика в формуле модели.  

<span style="color: black;">**_ПРИМЕЧАНИЕ:_** Оценка Каплана-Мейера представляет собой непараметрическую оценку максимального правдоподобия функции выживания. (см. дополнительную информацию в Ресурсах).</span>

Сводная информауия по этому *объекту survfit* выдаст то, что называется *таблица вероятности дожития*. Для каждого временного шага отслеживания (`time`), когда произошло событие (в возрастающем порядке):  

* количество людей, находящихся в группе риска по развитию события (люди, у которых событие еще не наступило и которые не подвергались цензурированию: `n.risk`)  
* те, у кого произошло событие  (`n.event`)  
* и из указанных выше: вероятность *не* развить событие (вероятность не умереть или выжить дольше определенного времени)  
* наконец, рассчитывается и отображается стандартная ошибка и доверительный интервал для этой вероятности  

Мы строим оценки КМ по формуле, где объект, ранее являвшийся Surv,  "survobj", является переменной отклика. "~ 1" уточняет, что мы выполняем модель для общей выживаемости.  

```{r fit}
# строим оценки КМ, используя формулу, где объект Surv "survobj" является переменной отклика.
# "~ 1" указывает, что мы выполняем модель для общей выживаемости  
linelistsurv_fit <-  survival::survfit(survobj ~ 1)

#печать сводной информации для большей детальности
summary(linelistsurv_fit)

```


При использовании `summary()` мы можем добавить опцию `times` и уточнить определенное время, для которого нам нужна информация о выживаемости 

```{r print_spec_times}

#печатаем сводную информацию на конкретные моменты времени
summary(linelistsurv_fit, times = c(5,10,20,30,60))

```


Мы можем также использовать функцию `print()`. Аргумент `print.rmean = TRUE` используется, чтобы получить среднее время выживания и его стандартную ошибку (se).

<span style="color: black;">**_ПРИМЕЧАНИЕ:_** Ограниченное среднее время выживания (RMST) - это специфическая мера выживаемости, которая все чаще используется в анализе выживаемости при раке и часто определяется как площадь под кривой выживания, если мы наблюдаем пациентов до ограниченного времени T (подробнее в разделе "Ресурсы")..


```{r, mean_survtime}
# печать объекта linelistsurv_fit со средним временем выживания и его стандартной ошибкой 
print(linelistsurv_fit, print.rmean = TRUE)

```


<span style="color: darkgreen;">**_СОВЕТ:_** Мы можем создать *объект surv* напрямую в функции `survfit()` и сохранить строку кода. Это будет выглядеть следующим образом: `linelistsurv_quick <-  survfit(Surv(futime, event) ~ 1, data=linelist_surv)`.</span>


### Совокупный риск {.unnumbered}  

Кроме функции `summary()` мы также можем использовать функцию `str()`, которая дает больше деталей о структуре объекта `survfit()`. Это список из 16 элементов.  

Среди этих элементов есть важный: `cumhaz`, который является числовым вектором. С ним можно построить график, чтобы показать **_совокупный моментный риск_**, где **_моментный риск_** - это **_моментнй коэффициент возникновения события_** (см. Ресурсы).

```{r fit_struct}

str(linelistsurv_fit)

```

<!-- ======================================================= -->
### Построение кривых Каплана-Мейера  {.unnumbered}

Как только построены оценки КМ, мы можем визуализировать вероятность быть живым через определенное время, используя базовую функцию `plot()`, которая рисует "Кривую Каплана-Мейера". Иными словами, кривая ниже является традиционной иллюстрацией опыта выживания в двух полных группах пациентов.

Мы можем быстро верифицировать минимум и максимум времени отслеживания на кривой.  

Простой способ интерпретации заключается в том, что в нулевой момент времени все участники еще живы, поэтому вероятность выживания равна 100%. С течением времени эта вероятность уменьшается, поскольку пациенты умирают. Доля участников, выживших после 60 дней отслеживания, составляет около 40%.

```{r }

plot(linelistsurv_fit, 
     xlab = "Days of follow-up",    # подпись оси x
     ylab="Survival Probability",   # подпись оси y
     main= "Overall survival curve" # заголовок рисунка
     )

```

Доверительный интервал оценок выживаемости КМ также строится по умолчанию и может быть отменен добавлением опции `conf.int = FALSE` в команду `plot()`.

Поскольку интересующее событие - это "смерть", построение кривой, описывающей дополнения долей выживаемости, приведет к построению кумулятивных долей смертности. Это можно сделать с помощью `lines()`, которая добавит информацию на существующий график.  


```{r}

# оригинальный график
plot(
  linelistsurv_fit,
  xlab = "Days of follow-up",       
  ylab = "Survival Probability",       
  mark.time = TRUE,              # отмечаем события на кривой: "+" печатается при каждом событии
  conf.int = FALSE,              # не наносить на график доверительный интервал
  main = "Overall survival curve and cumulative mortality"
  )

# рисуем дополнительную кривую к предыдущему графику
lines(
  linelistsurv_fit,
  lty = 3,             # используем другой тип линии для ясности
  fun = "event",       # рисуем кумулятивные события вместо выживания 
  mark.time = FALSE,
  conf.int = FALSE
  )

# добавляем легенду на график
legend(
  "topright",                               # положение легенды
  legend = c("Survival", "Cum. Mortality"), # текст легенды 
  lty = c(1, 3),                            # типы линий для использования в легенде
  cex = .85,                                # параметры, которые задают размер текст легенды
  bty = "n"                                 # тип без рамки для легенды
  )

```

<!-- ======================================================= -->
## Сравнение кривых выживаемости 

Для сравнения выживаемости в различных группах наблюдаемых нами участников или пациентов может потребоваться сначала рассмотреть соответствующие кривые выживаемости, а затем провести тесты для оценки различий между независимыми группами. Это сравнение может касаться групп по полу, возрасту, лечению, сопутствующим заболеваниям...

### Логарифмический ранговый критерий {.unnumbered}

Логарифмический ранговый критерий является популярным тестом, который сравнивает весь опыт выживания между двумя или более *независимыми* группами, его можно рассматривать как тест того, являются ли кривые выживаемости идентичными (накладывающимися) или нет (нулевая гипотеза - нет разницы в выживаемости между группами). Функция `survdiff()` из пакета **survival** позволяет применить логарифмический ранговый критерий, когда мы уточняем `rho = 0` (значение по умолчанию). Результаты теста дают статистику хи-квадрата и p-значение, поскольку статистика логарифмического ранга примерно распределена как статистика теста хи-квадрат.

Сначала мы попытаемся сравнить кривые выживаемости по гендерным группам. Для этого сначала попробуем визуализировать их (проверить, накладываются ли две кривые выживания друг на друга). Необходимо создать новый *объект survfit* с немного другой формулой. Затем будет создан *объект survdiff*.

Задав ` ~ gender` в качестве правой стороны формулы, мы строим уже не общую выживаемость, а выживаемость по полу.  


```{r comp_surv, warning=FALSE}

# создаем новый объект survfit на основе пола
linelistsurv_fit_sex <-  survfit(Surv(futime, event) ~ gender, data = linelist_surv)
```

Теперь мы можем построить график кривых выживания по полу. Посмотрите на *порядок* уровней страты в столбце пол до определения цветов и легенды.  

```{r}
# задаем цвета
col_sex <- c("lightgreen", "darkgreen")

# создаем график
plot(
  linelistsurv_fit_sex,
  col = col_sex,
  xlab = "Days of follow-up",
  ylab = "Survival Probability")

# добавляем легенду
legend(
  "topright",
  legend = c("Female","Male"),
  col = col_sex,
  lty = 1,
  cex = .9,
  bty = "n")
```

Теперь мы можем рассчитать тест разницы между кривыми выживаемости, используя `survdiff()`

```{r}
#рассчитываем тест разницы между кривыми выживаемости
survival::survdiff(
  Surv(futime, event) ~ gender, 
  data = linelist_surv
  )

```

Мы видим, что кривая выживаемости для женщин и кривая для мужчин накладываются друг на друга, а логарифмический ранговый критерий не дает доказательств различий в выживаемости между женщинами и мужчинами.

Некоторые другие пакеты R позволяют иллюстрировать кривые выживаемости для разных групп и тестировать разницу одновременно. Используя функцию `ggsurvplot()` из пакета **survminer**, мы также можем включить на нашу кривую напечатанные таблицы рисков для каждой группы, а также p-значение из логарифмического ранкового критерия. 

<span style="color: orange;">**_ВНИМАНИЕ:_** функции **survminer** требуют, чтобы вы задавали объект выживаемости *и* снова задавали данные, используемын для построения объекта выживаемости. Не забудьте это сделать, иначе получите неспецифическое сообщение об ошибке. </span>

```{r, warning=F, message=F}

survminer::ggsurvplot(
    linelistsurv_fit_sex, 
    data = linelist_surv,          # снова задаем данные, используемые для построения linelistsurv_fit_sex 
    conf.int = FALSE,              # не показывать доверительный интервал оценок КМ
    surv.scale = "percent",        # представляет вероятности на оси y в %
    break.time.by = 10,            # представляет ось времени с шагом в 10 дней
    xlab = "Follow-up days",
    ylab = "Survival Probability",
    pval = T,                      # печать p-значения логарифмического рангового критерия 
    pval.coord = c(40,.91),        # печать p-значения на этих координатах графика
    risk.table = T,                # печать таблицы рисков внизу 
    legend.title = "Gender",       # характеристики легенды
    legend.labs = c("Female","Male"),
    font.legend = 10, 
    palette = "Dark2",             # уточняем цветовую палитру 
    surv.median.line = "hv",       # рисуем горизонтальные и вертикальные линии по медианному выживанию
    ggtheme = theme_light()        # упрощаем фон графика
)

```


Мы можем также протестировать различия в выживаемости по источнику инфекции (источнику загрязнения).  

В данном случае логарифмический ранговый критерий дает достаточно доказательств различий вероятности выживания при `alpha= 0.005`. Вероятности выживания для пациентов, которые были заражены на похоронах, выше, чем вероятности выживания пациентов, которые заразились в других местах, что указывает на преимущество в выживаемости.

```{r}

linelistsurv_fit_source <-  survfit(
  Surv(futime, event) ~ source,
  data = linelist_surv
  )

# plot
ggsurvplot( 
  linelistsurv_fit_source,
  data = linelist_surv,
  size = 1, linetype = "strata",   # line types
  conf.int = T,
  surv.scale = "percent",  
  break.time.by = 10, 
  xlab = "Follow-up days",
  ylab= "Survival Probability",
  pval = T,
  pval.coord = c(40,.91),
  risk.table = T,
  legend.title = "Source of \ninfection",
  legend.labs = c("Funeral", "Other"),
  font.legend = 10,
  palette = c("#E7B800","#3E606F"),
  surv.median.line = "hv", 
  ggtheme = theme_light()
)

```

<!-- ======================================================= -->
## Регрессия Кокса {}

Регрессия пропорциональных рисков Кокса является одним из наиболее популярных методов регрессии для анализа выживаемости. Можно использовать и другие модели, поскольку модель Кокса требует *важных допущений*, которые необходимо верифицировать для правильного использования, например, допущение о пропорциональных моментных рисках: см. ссылки. 

В регрессии пропорциональных рисков Кокса мерой эффекта является **_коэффициент моментных рисков_** (HR), который представляет собой риск происшествия (или риск смерти в нашем примере), учитывая, что участник дожил до определенного времени. Как правило, нас интересует сравнение *независимых* групп по отношению к их моментным рискам, и мы используем отношение моментных рисков, корторое похоже на отношение шансов в плане создания множественной логистической регрессии. Функция `cox.ph()` из пакета **survival** используется для построения этой модели. Для тестирования допущения о пропорциональных моментных рисках при построении регрессии Кокса можно использовать функцию `cox.zph()` из пакета **survival**. 

<span style="color: black;">**_ПРИМЕЧАНИЕ:_** Вероятность должна лежать в диапазоне от 0 до 1. Однако моментный риск представляет собой ожидаемое число событий за единицу времени. 

* Если коэффициент моментного риска для предиктора близок к 1, то этот предиктор не влияет на выживаемость,
* Если коэффициент моментного риска менее 1, тогда предиктор является защитным (т.е. связан с улучшением выживаемости),
* А если коэффициент моментного риска больше 1, тогда предиктор связан с повышенным риском (или снижением выживаемости).</span> 

### Построение модели Кокса {.unnumbered}

Сначала мы можем построить модель для оценки влияния возраста и пола на выживаемость. Просто напечатав модель, мы получим информацию о:

  + оценочных коэффициентах регрессии `coef`, которые количественно выражают связь между предикторами и исходом,
  + их экспоненциальной функции (для интерпретируемости, `exp(coef)`), которая создает *коэффициент моментного риска*,
  + их стандартной ошибке `se(coef)`,
  + z-балле: на сколько стандартных ошибок расчетный коэффициент удален от 0,
  + и p-значение: вероятность того, что расчетный коэффициент мог бы быть 0.
  
Функция `summary()`, примененная к объекту модели Кокса даст вам больше информации, например, доверительный интервал оцененного коэффициента моментного риска и разные баллы тестов.

Эффект первой ковариаты `gender` (пол) представлен в первой строке. `genderm` (мужской) напечатан, что указывает на то, что первый уровень страты ("f"), т.е. группа женского пола, является референтной группой для пола. Таким образом, интерпретация тестового параметра относится к мужчинам по сравнению с женщинами. p-значение указывает на отсутствие достаточных доказательств влияния пола на ожидаемый моментный риск или связи между полом и смертностью от всех причин.

То же отсутствие доказательств отмечается в отношении возрастной группы.

```{r coxmodel_agesex}

#строим модель Кокса
linelistsurv_cox_sexage <-  survival::coxph(
              Surv(futime, event) ~ gender + age_cat_small, 
              data = linelist_surv
              )


#печать построенной модели
linelistsurv_cox_sexage


#сводная информация по модели
summary(linelistsurv_cox_sexage)

```


Было интересно выполнить модель и посмотреть на результаты, но первый взгляд на то, соблюдается ли предположение о пропорциональных моментных рисках, мог бы помочь сэкономить время.

```{r test_assumption}

test_ph_sexage <- survival::cox.zph(linelistsurv_cox_sexage)
test_ph_sexage

```


<span style="color: black;">**_ПРИМЕЧАНИЕ:_** Второй аргумент под названием *method* (метод) может быть задан при расчете модели Кокса, которая определяет как работать с одинаковыми результатами. *По умолчанию* используется "efron", а другие опции включают "breslow" и "exact".</span>

В другой модели мы добавляем дополнительные факторы риска, такие как источник инфекции и количество дней между датой возникновения заболевания и госпитализацией. На этот раз мы сначала проверяем предположение о пропорциональном моментном риске, прежде чем двигаться дальше.

В этой модели мы включили непрерывный предиктор (`days_onset_hosp`). В этом случае мы интерпретируем оценки параметров как увеличение ожидаемого логарифма относительного моментного риска на каждую единицу увеличения предиктора при постоянстве других предикторов. Сначала мы проверим предположение о пропорциональных моментных рисках.  

```{r coxmodel_fit_ph,  message=FALSE}

#строим модель
linelistsurv_cox <-  coxph(
                        Surv(futime, event) ~ gender + age_years+ source + days_onset_hosp,
                        data = linelist_surv
                        )


#тестируем модель пропорциональных рисков
linelistsurv_ph_test <- cox.zph(linelistsurv_cox)
linelistsurv_ph_test
```

Графическая верификация этого допущения может выполнена с помощью функции `ggcoxzph()` из пакета **survminer**. 

```{r}
survminer::ggcoxzph(linelistsurv_ph_test)

```


Результаты моделирования свидетельствуют о наличии отрицательной связи между продолжительностью госпитализации и смертностью от всех причин. Ожидаемый риск в 0,9 раза ниже у человека, поступившего на один день позже, чем у другого, при постоянном учете пола. Или, в более простом варианте, увеличение продолжительности госпитализации на одну единицу связано с уменьшением риска смерти на 10,7% (`coef *100`).

Полученные результаты свидетельствуют также о положительной связи между источником инфекции и смертностью от всех причин. То есть риск смерти (в 1,21 раза) повышается у пациентов, у которых источником инфекции были не похороны.


```{r coxmodel_summary,  message=FALSE}

#печатаем сводную информацию по модели
summary(linelistsurv_cox)

```


Мы можем верифицировать это отношение с помощью таблицы:  


```{r}
linelist_case_data %>% 
  tabyl(days_onset_hosp, outcome) %>% 
  adorn_percentages() %>%  
  adorn_pct_formatting()

```


Необходимо рассмотреть и исследовать, почему такая связь существует в данных. Одно из возможных объяснений может заключаться в том, что пациенты, прожившие достаточно долго, чтобы быть госпитализированными позже, изначально имели менее тяжелое заболевание. Другое, возможно, более вероятное объяснение состоит в том, что, поскольку мы использовали смоделированный фальшивый набор данных, эта закономерность не отражает реальности!  


<!-- ======================================================= -->

### Форест-графики {.unnumbered}

Затем мы можем визуализировать результаты модели Кокса, используя практичные форест-графики с помощью функции `ggforest()` из **пакета survminer**.

```{r forestp}

ggforest(linelistsurv_cox, data = linelist_surv)

```

<!-- ======================================================= -->
## Ковариаты, зависящие от времени, в моделях выживания {}

Некоторые из нижеследующих разделов были адаптированы с разрешения автора из превосходной книги [Введение в анализ выживаемости в R](https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html), написанной [Доктором Эмили Забор](https://www.emilyzabor.com/) 

В предыдущем разделе мы рассмотрели использование регрессии Кокса для изучения ассоциаций между интересующими нас ковариатами и результатами выживания. Однако эти анализы основаны на том, что ковариата измеряется на исходном уровне, то есть до начала периода отслеживания события.

Что произойдет, если вас интересует ковариата, которая измеряется **после** того, как началось время отслеживания? Или если у вас ковариата, которая может меняться со временем?

Например, вы работаете с клиническими данными, в которых повторяются измерения показателей больничных лабораторий, которые могут меняться с течением времени. Это является примером **Ковариаты, зависящей от времени**. Для решения этой задачи необходима специальная настройка, но, к счастью, модель Кокса очень гибкая, и этот тип данных также может быть смоделирован с помощью инструментов из пакета **survival**. 

### Настройка ковариаты, зависящей от времени {.unnumbered} 

Анализ ковариат, зависящих от времени, в R требует создания специального набора данных. Если интересно, см. более подробную статью об этом от автора пакета **survival** [Использование зависящих от времени ковариат и зависящих от времени коэффициентов в модели Кокса](https://cran.r-project.org/web/packages/survival/vignettes/timedep.pdf).

Для этого используем новый набор данных из пакета `SemiCompRisks` под названием `BMT`, который включает данные о 137 пациентах после пересадки костного мозга. Переменные, на которых мы сфокусируемся:  

* `T1`  - время (в днях) до смерти или последнего отслеживания  
* `delta1` - индикатор смерти; 1-умер, 0-жив  
* `TA` -  время (в днях) до острой реакции трансплантат против хозяина  
* `deltaA` -  индикатор острой реакции трансплантат против хозяина;  
  * 1 - развилась острая реакция трансплантат против хозяина  
  * 0 - никогда не было острой реакции трансплантат против хозяина

Мы загрузим этот набор данных из пакета **survival**, используя команду из **базового** R `data()`, которую можно использовать для загрузки данных, которые уже включены в пакет R, который загружается. Датафрейм `BMT` появится в рабочей среде R (environment).  

```{r}
data(BMT, package = "SemiCompRisks")
```

#### Добавляем уникальный идентификатор пациента {.unnumbered}  

В данных `BMT` нет столбца с уникальным ID, который необходим для создания такого типа набора данных, который нам нужен. Поэтому мы используем функцию `rowid_to_column()` из пакета **tidyverse** **tibble** для создания нового столбца с id под именем `my_id` (добавляет столбец в начале датафрейма с последовательными идентификаторами строк, начиная с 1). Назовем датафрейм `bmt`.  

```{r}
bmt <- rowid_to_column(BMT, "my_id")
```

Набор данных теперь выглядит так:  

```{r message=FALSE, echo=F}
DT::datatable(bmt, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

#### Расширяем строки по пациентам {.unnumbered}  

Далее используем функцию `tmerge()` с функциями-помощниками `event()` и `tdc()`, чтобы создать реструктурированный набор данных. Наша цель - реструктурировать набор данных, чтобы создать отдельную строку для каждого пациента в каждый временной интервал, когда у них отличаются значения `deltaA`. В этом случае у каждого пациента может быть не более двух строк в зависимости от того, развилась ли у него острая реакция "трансплантат против хозяина" за период сбора данных. Назовем наш новый показатель развития острой реакции трансплантат против хозяина `agvhd`.

- `tmerge()` создает длинный набор данных с несколькими временными интервалами для разных значений ковариат для каждого пациента
- `event()` создает новый индикатор события для новых созданных временных интервалов
- `tdc()` создает столбец зависящей от времени ковариаты, `agvhd`, по новым созданным временным интервалам

```{r}
td_dat <- 
  tmerge(
    data1 = bmt %>% select(my_id, T1, delta1), 
    data2 = bmt %>% select(my_id, T1, delta1, TA, deltaA), 
    id = my_id, 
    death = event(T1, delta1),
    agvhd = tdc(TA)
    )
```

Чтобы увидеть, что это даст, давайте рассмотрим данные по первым 5 пациентам.

Интересующие переменные в оригинальном наборе данных выглядели так:

```{r}
bmt %>% 
  select(my_id, T1, delta1, TA, deltaA) %>% 
  filter(my_id %in% seq(1, 5))
```

Новый набор данных для тех же пациентов выглядит так:

```{r}
td_dat %>% 
  filter(my_id %in% seq(1, 5))
```

Теперь у некоторых наших пациентов есть две строки в наборе данных, соответствующие интервалам, в которых они имеют разные значения нашей новой переменной, `agvhd`. Например, у Пациента 1 сейчас две строки со значением `agvhd` ноль с момента 0 до времени 67, и значение 1 с времени 67 до времени 2081. 

### Регрессия Кокса с ковариатами, зависящими от времени {.unnumbered} 

Теперь, когда мы переформатировали наши данные и добавили новую зависящую от времени переменную `aghvd`, давайте построим простую регрессию Кокса с одной переменной. Мы можем использовать ту же функцию `coxph()` как ранее, нам только нужно изменить нашу функцию `Surv()`, чтобы уточнить время начала и окончания каждого интервала, используя аргументы `time1 = ` и `time2 = `. 


```{r}
bmt_td_model = coxph(
  Surv(time = tstart, time2 = tstop, event = death) ~ agvhd, 
  data = td_dat
  )

summary(bmt_td_model)
```

Опять же, мы визуализируем результаты нашей модели Кокса, используя функцию `ggforest()` из **пакета survminer**.:

```{r}

ggforest(bmt_td_model, data = td_dat)

```

Как видно из форест-графика, доверительного интервала и значения p, в контексте нашей простой модели не наблюдается сильной связи между смертью и острой реакцией трансплантат против хозяина. 

<!-- ======================================================= -->
## Ресурсы {  }

[Анализ выживаемости Часть I: Основные концепции и первый анализ](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2394262/)

[Анализ выживаемости в R](https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html)

[Анализ выживаемости в исследованиях по инфекционным заболеваниям: Описание событий во времени](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2954271/)

[Глава по продвинутым моделям выживания от Принстона](https://data.princeton.edu/wws509/notes/c7.pdf)

[Использование ковариат, зависящих от времени, в модели Кокса](https://cran.r-project.org/web/packages/survival/vignettes/timedep.pdf)

[Шпаргалка по анализу выживаемости в R](https://publicifsv.sund.ku.dk/~ts/survival/survival-cheat.pdf)

[Шпаргалка по Survminer](https://paulvanderlaken.files.wordpress.com/2017/08/survminer_cheatsheet.pdf)

[Работа по разным мерам выживаемости для данных регистров рака с предоставлением Rcode в качестве дополнительных материалов](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6322561/)
