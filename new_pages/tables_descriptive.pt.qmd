# Tabelas descritivas {#tables-descriptive}

```{r out.width = c('75%'), fig.align='center', fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "descriptive_tables.png"))
```

Esta página demonstra o uso dos pacotes **janitor**, **dplyr**, **gtsummary**, **rstatix**, e R **base** para gerar um resumo dos dados e criar tabelas com estatísticas descritivas.

*Esta página explica como* criar\* as tabelas básicas e detalhadas, enquanto que a página [Tabelas para apresentações](#tables-presentation) descreve como formatar e imprimir essas tabelas de forma visualmente agradável.\*

Cada um destes pacotes tem vantagens e desvantagens em relação à simplicidade do código, acessibilidade dos resultados gerados, e qualidade da impressão destes resultados. Utilize esta página para decidir qual abordagem funciona melhor para a sua realidade.

Você tem várias opções para produzir tabelas simples e tabelas cruzadas (também conhecidas como tabelas de contingência). Entretanto, é necessário levar em consideração alguns fatores, como a simplicidade do código R utilizado; a capacidade de personalização deste código; a forma de geração dos resultados (para visualização no terminal do R, ou como uma tabela de dados (*data frame*), e/ou como uma imagem 'bonita' nos formatos .png/.jpeg/.html); e a facilidade de pós-processamento dos resultados gerados. Leve em consideração os pontos abaixo ao escolher uma ferramenta para atender as suas necessidades.

-   Use a função `tabyl()` do **janitor** para produzir e personalizar tabulações simples e tabulações cruzadas\
-   Use a função `get_summary_stats()` do **rstatix** para gerar tabelas com resumos estatísticos de diferentes colunas e/ou grupos de dados de forma fácil\
-   Use as funções `summarise()` e `count()` do **dplyr** para realizar análises estatísticas mais complexas, gerar tabelas de dados organizadas, ou preparar os dados para utilizar na função `ggplot()`\
-   Use a função `tbl_summary()` do **gtsummary** para produzir tabelas detalhadas prontas para publicação\
-   Use a função `table()` do R **base** se você não tiver acesso aos pacotes citados acima

<!-- ======================================================= -->

## Preparação

### Carregue os pacotes R {.unnumbered}

O código abaixo realiza o carregamento dos pacotes necessários para a análise dos dados. Neste manual, enfatizamos o uso da função `p_load()`, do **pacman**, que instala os pacotes, caso não estejam instalados, *e* os carrega no R para utilização. Também é possível carregar pacotes instalados utilizando a função `library()`, do r **base**. Para mais informações sobre os pacotes do R, veja a página [Introdução ao R](#basics).

```{r, warning=F, message=F}
pacman::p_load(
  rio,          # importa arquivos
  here,         # localiza arquivos
  skimr,        # gera visualização dos dados
  tidyverse,    # gestão dos dados + gráficos no ggplot2 
  gtsummary,    # resumo estatísticos e testes
  rstatix,      # resumo e testes estatísticos
  janitor,      # adiciona números absolutos e porcentagens às tabelas
  scales,       # facilmente converte proporções para porcentagens
  flextable     # converte tabelas para o formato de imagens
  )
```

### Importe os dados no R {.unnumbered}

Nós iremos importar o banco de dados de casos de uma simulação de epidemia de Ebola. Se você quiser acompanhar os passos abaixo, <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>clique aqui para fazer o download do banco de dados 'limpo'</a> (como arquivo .rds). Importe seus dados utilizando a função `import()` do pacote **rio** (esta função importa muitos tipos de arquivos, como .xlsx, .rds, .csv - veja a página [Importar e exportar](#importing) para detalhes).

```{r, echo=F}
# importe o banco de dados
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# importe o banco de dados limpo
linelist <- import("linelist_cleaned.rds")
```

As primeiras 50 linhas do banco de dados são mostradas abaixo.

```{r, message=FALSE, echo=F}
# mostre as linhas como tabela
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

## Explore seus dados

### Pacote **skimr** {.unnumbered}

Ao utilizar o pacote **skimr**, você pode obter um resumo detalhado e esteticamente agradável de cada variável do seu banco de dados. Leia mais sobre o **skimr** na sua [página no github](https://github.com/ropensci/skimr).

Abaixo, a função `skim()` é aplicada a todos os dados do objeto `linelist,` criado no código acima. Após execução do código, uma visão geral dos dados e um resumo de cada coluna (por classe) são gerados.

```{r}
## obtenha informações sobre cada variável no banco de dados
skim(linelist)
```

```{r  eval=F, echo=F}
# exclui a apresentação de dados com histogramas irregulares
skim_without_charts(linelist)
```

Você também pode usar a função `summary()`, do R **base**, para obter informações sobre o banco de dados inteiro, mas os resultados obtidos podem ser mais difíceis de visualizar do que utilizando o **skimr**. O resultado da análise com `summary()` não é mostrado abaixo, visando poupar espaço na página.

```{r, eval=F}
## obtenha informações sobre cada coluna no banco de dados
summary(linelist)
```

### Resumos estatísticos {.unnumbered}

Você pode utilizar as funções do R **base** para obter resumos estatísticos de uma coluna com dados numéricos. Boa parte das análises estatísticas mais úteis com este tipo de coluna pode ser obtido utilizando a função `summary()`, como mostrado abaixo. Observe que o nome da tabela de dados e da coluna (linelist) precisam ser especificados como mostrado abaixo.

```{r}
summary(linelist$age_years)
```

Você pode obter e salvar uma parte específica da análise utilizando o indexador com colchetes [ ]:

```{r}
summary(linelist$age_years)[[2]] # obtém apenas o resultado da análise no índice [2]
# alternativa equivalente ao indexador [2], utilizando o nome do campo:
# summary(linelist$age_years)[["1st Qu."]]  
```

Você pode obter estatísticas individuais com outras funções do R **base**, como `max()`, `min()`, `median()`, `mean()`, `quantile()`, `sd()`, e `range()`. Veja a página [Introdução ao R](#basics) para uma lista completa.

[***CUIDADO:*** Caso seus dados contenham campos em branco, o R quer que você saiba disso e irá gerar `NA` na análise. Isso só não irá ocorrer caso você 'peça' para o R ignorar esses campos em branco nas funções matemáticas acima. Isso pode ser realizado com o argumento]{style="color: orange;"}`na.rm = TRUE`[.]{style="color: orange;"}

Você pode usar a função `get_summary_stats()`, do **rstatix**, para obter o resumo estatístico *em formato de quadro de dados (data frame)*. Isso pode ser útil na execução de comandos posteriores ou para criação de gráficos com os valores. Veja a página [Testes estatísticos simples](#stat-tests) para mais detalhes do pacote **rstatix** e suas funções.

```{r}
linelist %>% 
  get_summary_stats(
    age, wt_kg, ht_cm, ct_blood, temp,  # variáveis para realizar o cálculo
    type = "common")                    # tipo do resumo estatístico a ser gerado

```

## **Pacote janitor** {#tbl_janitor}

O pacote **janitor** contém a função `tabyl()`, que gera tabulações simples e tabulações cruzadas que podem ser modificadas com funções auxiliares para mostrarem porcentagens, proporções, contagens, etc.

Abaixo, nós utilizamos as funções do **janitor** no banco de dados `linelist`, criado anteriormente, e visualizamos o resultado da análise. Se necessário, é possível salvar as tabelas geradas utilizando o operador `<-`, e atribuindo elas a um novo objeto no R.

### Básico do tabyl {.unnumbered}

O uso do `tabyl()`, no modo padrão, em uma coluna específica produz uma tabela com os valores únicos desta coluna, suas contagens, e "porcentagens" (proporções, na realidade). Como as proporções podem ter muitos dígitos, é possível ajustar o número de casas decimais com a função `adorn_rounding()`, descrita abaixo.

```{r}
linelist %>% tabyl(age_cat)
```

Como observado acima, se existirem campos em branco na coluna analisada, eles são mostrados em uma linha chamada `<NA>`. Você pode omitir estes campos com o atributo `show_na = FALSE`. Se não existirem campos em branco, essa linha não irá aparecer. Se estes campos existirem, todas as proporções são geradas como 'brutas' (coluna 'percent' gerada, em que a quantidade de campos `NA` está inclusa no denominador) e 'válidas' (coluna 'valid_percent', onde a quantidade de campos `NA` não é considerada no cálculo).

Se a coluna for um fator (da classe Factor) e apenas alguns níveis dessa classe estiverem presentes em seus dados, todos os níveis desta classe serão mostrados na tabela de análise. Você pode omitir essa característica ao usar o atributo `show_missing_levels = FALSE`. Leia mais na página [Fatores](#factors).

### Tabulação cruzada (tabela de contingência) {.unnumbered}

As quantidades absolutas das tabulações cruzadas são obtidas ao adicionarmos uma ou mais variáveis dentro da função `tabyl()`. Observe que agora apenas os números absolutos são obtidos - proporções e porcentagens podem ser adicionadas à análise com etapas adicionais mostradas abaixo.

```{r}
linelist %>% tabyl(age_cat, gender)
```

### Personalizando o tabyl {#tbl_adorn .unnumbered}

Use as funções "adorn", do **janitor**, para adicionar ao resultado da análise as colunas de números absolutos assim como converter para proporções, percentuais, ou ajustar o formato de gerado. Você utilizar essas funções nas tabelas geradas pelo tabyl frequentemente.

+--------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Função                   | Resultado                                                                                                                                                                                                              |
+==========================+========================================================================================================================================================================================================================+
| `adorn_totals()`         | Adiciona uma linha/coluna com os totais (`where =` "row", "col", or "both"). "row": linhas; "col": colunas; "both": ambas. Atribua ao campo `name =` o nome "Total".                                                   |
+--------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `adorn_percentages()`    | Converte contagens absolutas para proporções, escolhendo o `denominator =` "row", "col", or "all".                                                                                                                     |
+--------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `adorn_pct_formatting()` | Converte proporções para percentuais. Especifique o número de casas decimais com o atributo `digits =`. Remova o símbolo "%" com o atributo `affix_sign = FALSE`.                                                      |
+--------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `adorn_rounding()`       | Arredonde as proporções utilizando `digits =` nº de casas decimais. Para arredondar percentuais, utilize a função `adorn_pct_formatting()` com `digits =`.                                                             |
+--------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `adorn_ns()`             | Adicione a tabela as quantidades absolutas com as proporções ou porcentagens. Utilize o atributo `position =` "rear" para mostrar as quantidades em parênteses, ou "front" para colocar as porcentagens em parênteses. |
+--------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `adorn_title()`          | Adiciona títulos à tabela gerada através dos argumentos `row_name =` e/ou `col_name =`                                                                                                                                 |
+--------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Preste atenção na ordem em que você utiliza estas funções. Abaixo estão alguns exemplos:

Uma tabela simples com porcentagens no lugar das proporções, que são padrão.

```{r}
linelist %>%               # fonte dos dados
  tabyl(age_cat) %>%       # tabula números absolutos e proporções por idade
  adorn_pct_formatting()   # converte as proporções para porcentagens
```

Uma tabela cruzada com os números absolutos e porcentagens de cada linha.

```{r}
linelist %>%                                  
  tabyl(age_cat, gender) %>%                  # contagens absolutas e proporções cruzando idade e gênero
  adorn_totals(where = "row") %>%             # adiciona uma linha chamada 'Total', com os totais
  adorn_percentages(denominator = "row") %>%  # converte os números absolutos para proporções
  adorn_pct_formatting(digits = 1)            # converte as proporções para porcentagens
```

O código abaixo modifica uma tabela cruzada de dados de forma que as quantidades absolutas e os percentuais sejam mostrados.

```{r}
linelist %>%                                  # fonte dos dados
  tabyl(age_cat, gender) %>%                  # geração da tabela cruzada
  adorn_totals(where = "row") %>%             # adiciona uma linha "Total", com os totais
  adorn_percentages(denominator = "col") %>%  # converte as quantidades absolutas para proporções
  adorn_pct_formatting() %>%                  # converte as proporções para porcentagens
  adorn_ns(position = "front") %>%            # mostra os dados como: "n° absoluto (porcentagem)"
  adorn_title(                                # nomeia os títulos das colunas e linhas
    row_name = "Age Category",
    col_name = "Gender")
```

### Convertendo a tabela do tabyl para uma imagem {.unnumbered}

Por padrão, o tabyl vai gerar uma tabela 'crua' no seu console do R.

Adicionalmente, você pode obter a tabela no tabyl e utiliza-la nas funções do pacote **flextable**, ou outros pacotes similares, para gerar uma tabela no formato de imagem no RStudio Viewer, que pode ser exportada nos formatos .png, .jpeg, .html, etc. Isto é discutido na página [Tabelas para apresentação](#tables-presentation). Observe que, caso você gere a tabela desta forma e utilize a função `adorn_titles()`, você precisa aplicar o atributo `placement = "combined"`.

```{r}
linelist %>%                                  # fonte dos dados
  tabyl(age_cat, gender) %>%                  # geração da tabela cruzada
  adorn_totals(where = "row") %>%             # adiciona uma linha "Total", com os totais
  adorn_percentages(denominator = "col") %>%  # converte as quantidades absolutas para proporções
  adorn_pct_formatting() %>%                  # converte as proporções para porcentagens
  adorn_ns(position = "front") %>% 
  adorn_title(
    row_name = "Age Category",
    col_name = "Gender",
    placement = "combined") %>% # isto é necessário para gerar a tabela como imagem
  flextable::flextable() %>%    # converte a tabela em imagem
  flextable::autofit()          # formata a tabela em linha por coluna

```

### Personalizando outras tabelas com funções 'adorn' {.unnumbered}

Você pode utilizar as funções `adorn_*()`, do pacote **janitor**, em outras tabelas, como as criadas pelas funções `summarise()` e `count()` do pacote **dplyr**, ou `table()` do R **base**. Simplesmente aplique a tabela gerada à função desejada do pacote **janitor**. Por exemplo:

```{r}
linelist %>% 
  count(hospital) %>%   # função do pacote dplyr
  adorn_totals()        # função do pacote janitor
```

### Salvando a tabela do tabyl {.unnumbered}

Se você converteu a tabela para uma imagem 'bonita' utilizando um pacote como **flextable**, você pode salvar ela com as funções desse pacote - utilizando as funções `save_as_html()`, `save_as_word()`, `save_as_ppt()`, e `save_as_image()` do **flextable** (discutido em detalhes na página [Tabelas para apresentação](#tables-presentation)). No código abaixo, a tabela é salva em um documento Word, onde poderá ser editada manualmente.

```{r, eval=F}
linelist %>%
  tabyl(age_cat, gender) %>% 
  adorn_totals(where = "col") %>% 
  adorn_percentages(denominator = "col") %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front") %>% 
  adorn_title(
    row_name = "Faixa-Etária",
    col_name = "Gênero",
    placement = "combined") %>% 
  flextable::flextable() %>%                     # converte para imagem
  flextable::autofit() %>%                       # garante apenas uma linha por coluna
  flextable::save_as_docx(path = "tabyl.docx")   # salva a imagem como um documento Word no endereço do documento (filepath)
```

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "tabyl_word.png"))
```

### Análises estatísticas {#janitor_age_out_stats .unnumbered}

Como mostrado abaixo, você pode aplicar testes estatísticos nas tabelas dos tabyls, como `chisq.test()` ou `fisher.test()` do pacote **stats**. Observe que campos em branco não são permitidos, devendo serem excluídos do tabyl com o atributo `show_na = FALSE`.

```{r, warning=F, message=F}
age_by_outcome <- linelist %>% 
  tabyl(age_cat, outcome, show_na = FALSE) 

chisq.test(age_by_outcome)
```

Veja a página [Testes estatísticos simples](#stat-tests) para mais códigos e dicas sobre estatística.

### Outras dicas {.unnumbered}

-   Utilize o argumento `na.rm = TRUE` para excluir campos em brancos de qualquer um dos cálculos acima.\
-   Se utilizar qualquer função `adorn_*()` em tabelas criadas com outra função além do `tabyl()`, você pode especificar a(s) coluna(s) para aplicar o "adorn", como em `adorn_percentage(,,,c(cases,deaths))` (onde a porcentagem será adicionada somente no quarto argumento da análise). Como a sintaxe não é simples, considere utilizar a função `summarise()` em seu lugar.\
-   Você pode obter mais detalhes na [página do janitor](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html) e nesse [resumo do tabyl](https://cran.r-project.org/web/packages/janitor/vignettes/tabyls.html).

## **Pacote dplyr**

**dplyr** faz parte dos pacotes **tidyverse**, sendo uma ferramenta de gestão de dados muito comum. Criar tabelas com as funções `summarise()` e `count()` do **dplyr** é uma abordagem útil para obter resumos estatísticos, resumos *por grupos*, ou para utilizá-las no `ggplot()`.

A função `summarise()` cria uma *nova tabela resumo dos dados.* Se os dados *não são agrupados*, esta função gera uma tabela de dados de uma linha com os resumos estatísticos desejados do banco de dados inteiro. Se os dados são *agrupados*, a nova tabela terá um linha por *grupo* (veja a página [Agrupando dados](#grouping)).

Dentro dos parênteses da função `summarise()`, você pode incluir os nomes de cada nova coluna, seguido pelo sinal de igual e uma função estatística a ser utilizada.

[***DICA:*** A função `summarise` pode ser escrita na forma do inglês britânico e americano (`summarise()` e `summarize()`).]{style="color: darkgreen;"}

### Obtendo as quantidades absolutas {.unnumbered}

A função mais simples para utilizar dentro de `summarise()` é a função `n()`. Não insira nada dentro dos parênteses para a função contar o total de linhas.

```{r}
linelist %>%                 # inicia com o banco de dados 'linelist'
  summarise(n_rows = n())    # gera uma nova tabela com uma coluna contendo o número de linhas
```

Esta análise é mais interessante se agruparmos os dados antes.

```{r}
linelist %>% 
  group_by(age_cat) %>%     # agrupe os dados por valores únicos da coluna 'age_cat'
  summarise(n_rows = n())   # gera o número de linhas *por grupo*
```

O código acima pode ser encurtado ao utilizar a função `count()` em vez de `summarise()` e `n()`. A função `count()` faz o seguinte:

1)  Agrupa os dados de acordo com as colunas escolhidas\
2)  Gera um resumo destes grupos utilizando a função `n()` (criando a coluna `n`)\
3)  Desagrupa os dados

```{r}
linelist %>% 
  count(age_cat)
```

Você pode mudar o nome da coluna resultante `n` para um diferente, ao especificar o novo nome com o atributo `name =`.

Os resultados das contagens de duas ou mais colunas usadas para agrupar os dados são gerados no formato "longo", com as contagens na coluna `n`. Veja a página sobre [Pivotando dados](#pivoting) para aprender sobre as tabelas nos formatos "longos" e "amplos".

```{r}
linelist %>% 
  count(age_cat, outcome)
```

### Mostre todos os níveis da classe *factor* {.unnumbered}

Se você estiver tabelando uma coluna da classe *factor*, é possível fazer com que *todos* os níveis dessa classe sejam mostrados (não apenas os níveis presentes nos dados) ao adicionar o atributo `.drop = FALSE` dentro das funções `summarise()` ou `count()`.

Está técnica é útil para padronizar suas tabelas/gráficos. Por exemplo, se você estiver criando figuras para diferentes sub-grupos, ou precisar criar um mesmo tipo de figura para relatórios de rotina. Em cada uma dessas circuntâncias, os valores nos dados podem variar, mas é possível definir níveis que continuem constantes.

Veja a página sobre [Fatores](#factors) para mais informações.

### Proporções {#tbl_dplyr_prop .unnumbered}

Colunas com proporções podem ser criadas ao canalizar (*pipe*) a tabela gerada para a função `mutate()`. A partir disso, as proporções podem ser calculadas através da divisão das quantidades absolutas geradas na coluna de contagem (`n` por padrão), divididos pela soma (`sum()`) de todas as contagens nessa coluna.

Observe que, neste caso, utilizar a função `sum()` dentro do `mutate()` irá gerar a soma da coluna `n` inteira, e utilizá-la como denominador no cálculo das proporções. Como explicado [na página de agrupamento de dados](#group_summarise), *se* `sum()` for utilizada em dados *agrupados* (por exemplo, se o `mutate()` for imediatamente seguido pela função `group_by()`), as somas serão realizadas *por grupos*. Como dito acima, a função `count()` termina as suas ações realizando o *desagrupamento* dos dados. Assim, neste cenário, nós obtemos as proporções da coluna inteira, e não apenas dos grupos.

Para facilmente mostrar os percentuais, é possível incorporar a proporção gerada dentro da função `percent()`, do pacote **scales** (tenha em mente que isso converte a porcentagem para a classe character).

```{r}
age_summary <- linelist %>% 
  count(age_cat) %>%                     # agrupe e conte por gênero (produz a coluna 'n'), finaliza desagrupando os dados
  mutate(                                # cria a porcentagem da coluna - observe o denominador
    percent = scales::percent(n / sum(n))) 

# print
age_summary
```

Abaixo, um método para calcular proporções *dentro* dos grupos é mostrado. Esta metodologia utiliza os diferentes níveis de agrupamento e desagrupamento de dados. Primeiro, os dados são agrupados de acordo com o `outcome`, utilizando a função `group_by()`. Então, a função `count()` é aplicada. Essa função realiza mais agrupamentos dos dados utilizando a variável `age_cat`, e gera contagens para cada combinação `outcome`-`age-cat`. Lembre-se que, ao finalizar o processo, a função `count()` também *desagrupa* os grupos `age_cat`. Assim, o único grupo de dados restante é o agrupamento inicial pelo `outcome`. Assim, a etapa final em que as proporções são calculadas (denominador `sum(n)`) é realizada com o grupo `outcome`.

```{r}
age_by_outcome <- linelist %>%                  # inicie com os dados do linelist
  group_by(outcome) %>%                         # agrupe por outcome 
  count(age_cat) %>%                            # agrupe e conte por age_cat, e então remova os grupos age_cat
  mutate(percent = scales::percent(n / sum(n))) # calcule as porcentagem - repare que o denominador é o grupo outcome
```

```{r, echo=F}
DT::datatable(age_by_outcome, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```

### Visualização dos dados {.unnumbered}

Utilizar a função `ggplot()` com os dados de uma tabela no formato "longo", como a mostrada acima, é relativamente simples. Esses dados, no formato "longo", são facilmente aceitos pelo `ggplot()`. Veja mais exemplos nas páginas [básico do ggplot](#ggplot-basics) e [dicas do ggplot](#ggplot-tips).

```{r, warning=F, message=F}
linelist %>%                      # inicie com a linelist
  count(age_cat, outcome) %>%     # agrupe e tabule as contagens utilizando duas variáveis
  ggplot()+                       # utilize a tabulação gerada no ggplot
    geom_col(                     # crie um gráfico de barras
      mapping = aes(   
        x = outcome,              # mapeie o grupo outcome para o eixo x
        fill = age_cat,           # mapeie o grupo age_cat para o fill
        y = n))                   # mapeie as contagens (coluna 'n') para o eixo y
```

### Resumo estatístico {.unnumbered}

Uma das principais vantagens do pacote **dplyr** e da função `summarise()` é a habilidade deles gerarem resumos estatísticos mais avançados, como `median()`, `mean()`, `max()`, `min()`, `sd()` (desvio padrão), e percentis. Você também pode utilizar a função `sum()` para contar o número de linhas que cumprem certos critérios lógicos. Como mostrado acima, essas informações podem ser obtidas com todo o banco de dados, ou por grupos.

A sintaxe é a mesma - dentro dos parênteses da função `summarise()`, você adiciona os nomes de cada nova coluna resumo, seguido pelos sinais de igual e a função estatística a ser realizada. Dentro da função estatística, escolha a(s) coluna(s) para serem utilizadas no cálculo, e qualquer outro argumento relevante (exemplo: `na.rm = TRUE` para boa parte das funções matemáticas).

Como dito acima, a função `sum()` também pode ser utilizada para obter o número de linhas que cumprem certos critérios lógicos. São contadas apenas as linhas que forem verdade (`TRUE`) para os critérios em parênteses. Por exemplo:

-   `sum(age_years < 18, na.rm=T)`\
-   `sum(gender == "male", na.rm=T)`\
-   `sum(response %in% c("Likely", "Very Likely"))`

Abaixo, os dados do `linelist` são analisados para avaliar os dias entre o início dos sintomas e a admissão no hospital (coluna `days_onset_hosp`), de acordo com o hospital.

```{r}
summary_table <- linelist %>%                                        # inicie com o linelist, salvando os novos dados como um novo objeto
  group_by(hospital) %>%                                             # agrupe todos os cálculos por hospital
  summarise(                                                         # apenas as colunas abaixo serão geradas
    cases       = n(),                                                # n° de casos por grupo
    delay_max   = max(days_onset_hosp, na.rm = T),                    # tempo máximo entre o ínicio dos sintomas e a admissão
    delay_mean  = round(mean(days_onset_hosp, na.rm=T), digits = 1),  # tempo médio, arredondado
    delay_sd    = round(sd(days_onset_hosp, na.rm = T), digits = 1),  # desvio padrão do intervalo de tempo, arredondado
    delay_3     = sum(days_onset_hosp >= 3, na.rm = T),               # n° de acsos com intervalo igual ou maior à 3 dias
    pct_delay_3 = scales::percent(delay_3 / cases)                    # gera nova coluna convertendo o delay_3 em porcentagem
  )

summary_table  # exporte a tabela
```

Algumas dicas:

-   Use a função `sum()` com uma expressão lógica para quantificar linhas que cumprem certos critérios (`==`)\

-   Repare no uso do argumento `na.rm = TRUE` dentro de funções matemáticas como `sum()`. Seu uso impede que `NA` seja gerado caso existam campos em branco\

-   Use a função `percent()`, do pacote **scales**, para facilmente obter as porcentagens

    -   Escolha `accuracy =` para 0.1 ou 0.01 para garantir 1 ou 2 vírgulas decimais, respectivamente\

-   Use a função `round()`, do pacote R **base**, para arredondar e especificar quantidade de casas decimais\

-   Para obter dados estatísticos do banco de dados completo, utilize a função `summarise()` sem a função `group_by()`\

-   Você pode criar colunas para realizar cálculos futuros (ex.: como denominadores), que podem ser, posteriormente, retiradas da sua tabela de dados com a função `select()`.

### Estatísticas condicionais {.unnumbered}

Você pode querer realizar *análises estatísticas condicionais* - por exemplo, a quantidade de linhas que cumprem certos critérios. Isto pode ser feito ao utilizar os colchetes `[ ]` para especificar os grupos desejados dentro de uma coluna. No código abaixo, a temperatura máxima dos pacientes com e sem febre é obtida. Entranto, neste caso, é melhor criar uma nova coluna utilizando as funções `group_by()` e `pivot_wider()` (como demonstrado [abaixo](#tbls_pivot_wider)).

```{r}
linelist %>% 
  group_by(hospital) %>% 
  summarise(
    max_temp_fvr = max(temp[fever == "yes"], na.rm = T),
    max_temp_no = max(temp[fever == "no"], na.rm = T)
  )
```

### Unindo colunas {.unnumbered}

A função `str_glue()`, do pacote **stringr**, é útil para combinar valores de diferentes colunas em uma nova coluna. Geralmente, essa função é aplicada *após* utilizar a função `summarise()`.

Na página sobre [Caracteres e strings](#characters-strings), várias opções para combinar colunas são discutidas, incluindo as funções `unite()` e `paste0()`. Entretanto, nós recomendamos a função `str_glue()` por ser mais flexível do que `unite()` e possuir uma sintaxe mais simples do que `paste0()`.

Abaixo, a tabela `summary_table` (criada acima) é modificada de forma que as colunas `delay_mean` e `delay_sd` sejam combinadas. A nova coluna é gerada com os dados formatados utilizando parênteses, e as colunas utilizadas são removidas.

Então, para tornar a coluna mais apresentável, uma linha com os totais é adicionada com a função `adorn_totals()`, do pacote **janitor** (que ignora colunas não-numéricas). Finalmente, nós utilizamos a função `select()`, do pacote **dplyr**, para reordenar as colunas e renomeá-las como desejado.

Também é possível utilizar as funções do **flextable** para exportar a tabela para Word, .png, .jpeg, .html, Powerpoint, RMarkdown, etc.! (veja a página [Tabelas para apresentações](#tables-presentation)).

```{r}
summary_table %>% 
  mutate(delay = str_glue("{delay_mean} ({delay_sd})")) %>%  # crie uma nova coluna ao combinar e formatar valores de outras colunas
  select(-c(delay_mean, delay_sd)) %>%                       # remova as duas colunas utilizadas   
  adorn_totals(where = "row") %>%                            # adiciona uma linha com os totais
  select(                                                    # reorganize e renomeie as colunas
    "Nome do Hospital"   = hospital,
    "Casos"           = cases,
    "Atraso máximo"       = delay_max,
    "Média (dp)"       = delay,
    "Atraso 3+ dias"   = delay_3,
    "% atrasos 3+ dias" = pct_delay_3
    )
```

#### Percentis {.unnumbered}

O cálculo dos *percentis* e quantis no **dplyr** merece uma menção especial. Para obter os quantis, utilize a função `quantile()` com os intervalos padrões, ou especifique os valores alterando o atributo `probs =`.

```{r}
# obtenha os percentis padrões da variável age (0%, 25%, 50%, 75%, 100%)
linelist %>% 
  summarise(age_percentiles = quantile(age_years, na.rm = TRUE))

# obtenha os percentis em diferentes níveis da mesma variável (5%, 50%, 75%, 98%)
linelist %>% 
  summarise(
    age_percentiles = quantile(
      age_years,
      probs = c(.05, 0.5, 0.75, 0.98), 
      na.rm=TRUE)
    )
```

Se você quiser obter os quantis *por grupos*, é mais viável utilizar a função `group_by()` e criar novas colunas, uma vez que isso irá gerar dados mais claros em relação ao método acima, onde seriam obtidos resultados longos e menos úteis. Desta forma, experimente essa abordagem: crie um coluna para cada nível de quantil desejado.

```{r}
# obtenha os valores de percentis nos níveis desejados de acordo com a variável age (5%, 50%, 75%, 98%), agrupando os dados por hospital
linelist %>% 
  group_by(hospital) %>% 
  summarise(
    p05 = quantile(age_years, probs = 0.05, na.rm=T),
    p50 = quantile(age_years, probs = 0.5, na.rm=T),
    p75 = quantile(age_years, probs = 0.75, na.rm=T),
    p98 = quantile(age_years, probs = 0.98, na.rm=T)
    )
```

Enquanto a função `summarise()` do **dplyr** certamente possibilita mais controle das alterações, todos os resumos estatísticos de que precisa podem ser produzidos com a função `get_summary_stat()`, do pacote **rstatix**. Ao ser utilizado em dados agrupados, esta função vai retornar percentis de 0%, 25%, 50%, 75%, e 100%. Se utilizado em dados não agrupados, você pode especificar os percentis com o atributo `probs = c(.05, .5, .75, .98)`.

```{r}
linelist %>% 
  group_by(hospital) %>% 
  rstatix::get_summary_stats(age, type = "quantile")
```

```{r}
linelist %>% 
  rstatix::get_summary_stats(age, type = "quantile")
```

### Obtenha um resumo dos dados agregados {.unnumbered}

*Se* você iniciar sua análise com *dados* agregados, ao utilizar a função `n()` você irá obter o número de *linhas*, não a soma das contagens agregadas. Para obter as somas, use a função `sum()` na coluna de contagens.

Por exemplo, suponha que você está iniciando com a tabela de contagens abaixo, chamada `linelist_agg` - ela mostra no formato "longo" as contagens do número de casos por `outcome` e `gender`.

Para fins de exemplificação, abaixo, nós criamos uma tabela de dados com a quantidade de casos por `outcome` e `gender` dos dados do `linelist` (campos em branco foram removidos para facilitar o entendimento).

```{r}
linelist_agg <- linelist %>% 
  drop_na(gender, outcome) %>% 
  count(outcome, gender)

linelist_agg
```

Para somar as contagens (da coluna `n`) por grupo, você pode usar a função `summarise()` e ajustar a nova coluna para ser igual à `sum(n, na.rm=T)`. Para adicionar um elemento condicional à essa operação, você pode selecionar, na coluna de contagem (`n`), uma parte dos dados utilizando os colchetes [ ].

```{r}
linelist_agg %>% 
  group_by(outcome) %>% 
  summarise(
    total_cases  = sum(n, na.rm=T),
    male_cases   = sum(n[gender == "m"], na.rm=T),
    female_cases = sum(n[gender == "f"], na.rm=T))
```

### `across()` em mais de uma coluna {.unnumbered}

Você pode utilizar a função `summarise()` em mais de uma coluna utilizado a função `across()`. Isto torna o trabalho mais fácil quando você quer obter a mesma estatística de muitas colunas. Coloque `across()` dentro de `summarise()` e especifique o seguinte:

-   `.cols =` vetor com o nome das colunas `c()` ou funções auxiliares do "tidyselect" (explicado abaixo)\
-   `.fns =` a função a ser aplicada (sem parênteses) - você pode fornecer múltiplas funções dentro de uma `list()`

Abaixo, a função `mean()` é aplicada para diferentes colunas numéricas. Um vetor com as colunas é dado explicitamente para o atributo `.cols =` e uma função simples (`mean`) é especificada (sem parênteses) em `.fns =`. Quaisquer argumentos adicionais para a função (por ex.: `na.rm=TRUE`) são colocados após `.fns =`, separados por uma vírgula.

Pode ser difícil acertar a ordem dos parênteses e vírgulas ao utilizar `across()`. Lembre que, dentro do `across()`, você deve incluir as colunas, as funções, e qualquer argumento extra que seja necessário para as funções.

```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm),  # colunas utilizadas
                   .fns = mean,                               # função aplicada
                   na.rm=T))                                  # argumentos extras
```

Funções múltiplas podem ser executadas de uma vez. Abaixo, o atributo `.fns =` recebe as funções `mean` e `sd` dentro de uma `list()`. Você tem a oportunidade de escolher nomes das características (ex.: "mean" e "sd") que serão colocadas inseridas ao nome das novas colunas.

```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm), # colunas
                   .fns = list("mean" = mean, "sd" = sd),    # múltiplas funções
                   na.rm=T))                                 # argumentos extras
```

Aqui são as funções auxiliares "tidyselect", que você pode utilizar em `.cols =` para selecionar colunas:

-   `everything()` - todas as outras colunas não mencionadas\
-   `last_col()` - a última coluna\
-   `where()` - aplica uma função à todas as colunas, e seleciona apenas aquelas que são verdadeiras (TRUE)\
-   `starts_with()` - seleciona colunas cujos nomes iniciam com determinado prefixo. Exemplo: `starts_with("date")`
-   `ends_with()` - seleciona colunas cujos normes terminam com determinado sufixo. Exemplo: `ends_with("_end")`\
-   `contains()` - colunas que contêm determinada sequência de caracteres. Exemplo: `contains("time")`
-   `matches()` - aplica a sintaxe de uma expressão regular (regex). Exemplo: `contains("[pt]al")`\
-   `num_range()` -
-   `any_of()` - seleciona colunas com certos nomes. Útil caso o nome buscado não exista. Exemplo: `any_of(date_onset, date_death, cardiac_arrest)`

Por exemplo, para obter a média de cada coluna numérica, use a função `where()` e aplique a função `as.numeric()` (sem os parêntesese) para escolher as colunas numéricas, e então obtenha a média com `mean`. Tudo isso dentro da função `across()`.

```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(
    .cols = where(is.numeric),  # all numeric columns in the data frame
    .fns = mean,
    na.rm=T))
```

### Utilizando o pivot_wider() {#tbls_pivot_wider .unnumbered}

Se você preferir sua tabela no formato "largo", você pode transformar ela utilizando a função `pivot_wider()`, do pacote **tidyr**. Você provavelmente precisará renomear as colunas com a função `rename()`. Para mais informações, veja a página sobre [Pivoteando os dados](#pivoting).

O exemplo abaixo utiliza a tabela `age_by_outcome` com formato "longo", da [seção de proporções](#tbl_dplyr_prop). Para faciliar o entendimento, nós criamos essa tabela novamente, e mostramos como é seu formato "longo":

```{r}
age_by_outcome <- linelist %>%                  # inicie com o linelist
  group_by(outcome) %>%                         # agrupe por outcome 
  count(age_cat) %>%                            # agrupe e conte por age_cat, e então remova o agrupamento age_cat
  mutate(percent = scales::percent(n / sum(n))) # calcule a porcentagem - observe que o denominador é o grupo outcome
```

```{r, echo=F}
DT::datatable(age_by_outcome, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Para realizar o pivoteamento para a tabela criada fique no formato "largo", nós criamos as novas colunas a partir dos *valores* na coluna existente `age_cat` (ao configurar `names_from = age_cat`). Nós também especificamos que os valores da nova tabela virão da coluna existente `n`, utilizando o atributo `values_from = n`. As colunas não mencionadas no nosso comando de pivoteamento (`outcome`) continuarão sem alterações na extremidade esquerda da tabela final.

```{r}
age_by_outcome %>% 
  select(-percent) %>%   # para não complicar, mantenha apenas as contagens
  pivot_wider(names_from = age_cat, values_from = n)  
```

### Adicionando as linhas com os totais {#tbl_dplyr_totals .unnumbered}

Quando a função `summarise()` é utilizada em dados agrupados, a linha com os "totais" não é produzida automaticamente. Abaixo, duas abordagens para adicionar esta linha são mostrados:

#### **Função** `adorn_totals()` do pacote janitor {.unnumbered}

Se sua tabela contém apenas contagens ou proporções/porcentagens, que podem ser somados para obter os totais, então é possível realizar essa soma utilizando a função `adorn_totals()`, do pacote **janitor**, como descrito na seção acima. Observe que esta função consegue somar apenas as colunas numéricas - se você quiser calcular outros resumos estatísticos, veja a próxima abordagem com o pacote **dplyr**.

Abaixo, os dados do `linelist` são agrupados por gênero e resumidos em uma tabela que descreve o número de casos com evolução conhecida (outcome), mortes (deaths) ou recuperados (recovered). Ao canalizar a tabela para a função `adorn_totals()`, uma linha com os totais é adicionada no final para refletir a soma de cada coluna. As próximas funções `adorn_*()` ajustam o design, como comentado no código.

```{r}
linelist %>% 
  group_by(gender) %>%
  summarise(
    known_outcome = sum(!is.na(outcome)),           # N° de linhas em que o outcome não é desconhecido
    n_death  = sum(outcome == "Death", na.rm=T),    # N° de linhas em que o outcome é Death
    n_recover = sum(outcome == "Recover", na.rm=T), # N° de linhas em que o outcome é Recovered
  ) %>% 
  adorn_totals() %>%                                # Adiciona a linha 'total' (soma de cada coluna numérica)
  adorn_percentages("col") %>%                      # Obtenha as proporções
  adorn_pct_formatting() %>%                        # Converta as proporções para porcentagens
  adorn_ns(position = "front")                      # mostra % e n° absolutos juntos (com n° absoluto na frente)
```

#### Uso da função `summarise()` nos dados "totais" seguido por `bind_rows()` {.unnumbered}

Se sua tabela consistir for feita de resumos estatísticos como `median()`, `mean()`, etc, a função`adorn_totals()` utilizada acima *não* será suficiente. Assim, para obter o resumo estatístico de todo o banco de dados, você precisa calcular eles com uma função `summarise()` separada e, então, conectar os resultados à tabela resumo inicial. Para fazer essa conexão, você pode usar a função `bind_rows()`, do pacote **dplyr**, descrito na página [Agrupando dados](#grouping). Abaixo está um exemplo:

Você pode criar uma tabela resumo com os resultados da intersecção *por hospital*, com as funções `group_by()` e `summarise()` da seguinte forma:

```{r, warning=F, message=F}
by_hospital <- linelist %>% 
  filter(!is.na(outcome) & hospital != "Missing") %>%  # Remova os casos sem resultado (outcome) ou nome do hospital
  group_by(hospital, outcome) %>%                      # Agrupe os dados
  summarise(                                           # Crie um novo resumo com as colunas com os indicadores de interesse
    N = n(),                                           # N° de linhas por grupo hospital-outcome     
    ct_value = median(ct_blood, na.rm=T))              # Obtenha a média dos valores CT por grupo
  
by_hospital # exporte a tabela
```

Para obter os totais, execute a mesma função `summarise()`, mas com os dados agrupados apenas por outcome (não por hospital), da seguinte forma:

```{r}
totals <- linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Agrupado apenas por outcome, não por hospital    
      summarise(
        N = n(),                                       # Essas estatísticas são apenas por outcome
        ct_value = median(ct_blood, na.rm=T))

totals # exporte a tabela gerada
```

Agora, nós podemos unir as duas tabelas geradas. Observe que a tabela `by_hospital` tem 4 colunas, enquanto a tabela `totals` tem 3 colunas. Ao utilizar a função `bind_rows()`, as colunas são combinadas por nome, onde cada espaço extra (linhas a mais) são preenchidos com `NA` (ex.: na coluna `hospital` os campos das duas novas linhas de `totals`). Após unir as linhas, nós iremos converter esses espaços em branco para "Total" utilizando a função `replace_na()` (veja a página [Limpando os dados e funções essenciais](#cleaning)).

```{r}
table_long <- bind_rows(by_hospital, totals) %>% 
  mutate(hospital = replace_na(hospital, "Total"))
```

Aqui está a nova tabela com as linhas "Total" no final.

```{r, message=FALSE, echo=F}
DT::datatable(table_long, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```

Esta tabela está no formato "longo/comprido", que pode ser o desejado. *Opcionalmente*, você pode *mudar* essa tabela para o formato *largo*, de forma a torná-la mais fácil de interpretar. Veja a seção acima sobre como transformar a tabela para o formato "largo", ou na página [Pivoteando dados](#pivoting). Você também pode adicionar mais colunas, e ajustá-las de forma que considere mais agradável. Segue o código:

```{r}
table_long %>% 
  
  # Muda para o formato amplo e formata a tabela
  ########################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # Mude de "longo" para "largo"
    values_from = c(ct_value, N),                       # novos valores provenientes das colunas ct e de contagen (n)
    names_from = outcome) %>%                           # novos nomes das colunas proveniente dos outcomes
  mutate(                                              # adiciona novas colunas
    N_Known = N_Death + N_Recover,                               # casos com evolução (outcome) conhecido
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # percentual de casos que evoluíram para óbito (até 1ª casa decimal)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # percentual de casos que recuperaram (até a 1ª casa decimal)
  select(                                              # Reordena as colunas
    hospital, N_Known,                                   # Coluna introdutórias
    N_Recover, Pct_Recover, ct_value_Recover,            # Colunas dos recuperados
    N_Death, Pct_Death, ct_value_Death)  %>%             # Colunas de óbitos
  arrange(N_Known)                                  # Organize as linhas do menor para o maior (linha com totais por último)

```

Após isso, você pode exportar essa tabela como uma imagem - abaixo, o resultado é exportado com o pacote **flextable**. Para mais detalhes sobre esse exemplo, e sobre como produzir uma imagem dessa forma, leia a página [Tabelas para apresentações](#tables-descriptive).

```{r echo=FALSE, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}

linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds")) 

border_style = officer::fp_border(color="black", width=1)

pacman::p_load(
  rio,            # importar/exportar
  here,           # endereço dos arquivos
  flextable,      # gera imagens a partir de tabelas 
  officer,        # funções auxiliares para tabelas
  tidyverse)      # gestão dos dados, resumos, e visualização

table <- linelist %>% 
  # filtros
  ########
  #filter(!is.na(outcome) & hospital != "Missing") %>%  # Exclui os casos com campos em branco nas colunas outcome ou hospital
  
  # Obtenha um resumo de valores por grupos hospital-outcome
  ###############################################
  group_by(hospital, outcome) %>%                      # Agrupe os dados
  summarise(                                           # Crie novas colunas com resumos de indicadores de interesse
    N = n(),                                            # N° de linhas por grupo hospital-outcome     
    ct_value = median(ct_blood, na.rm=T)) %>%           # Obtenha os valores médios de CT por grupo
  
  # adiciona a linha com os totais
  ############
  bind_rows(                                           # Junte a tabela anterior com essa mini-tabela com totais
    linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Agrupado apenas por outcome, não por hospital    
      summarise(
        N = n(),                                       # N° de linhas do banco de dados inteiro     
        ct_value = median(ct_blood, na.rm=T))) %>%     # Valores médios do CT do banco de dados inteiro
  
  # Transforme a tabela para o formato amplo e faça formatações
  ########################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # Transforme de "longo" para "largo"
    values_from = c(ct_value, N),                       # novos valores das colunas ct e de contagens (n)
    names_from = outcome) %>%                           # novos nomes das colunas dos outcomes
  mutate(                                              # Adicione novas colunas
    N_Known = N_Death + N_Recover,                               # casos com evolução conhecida
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # percentual de casos que evoluíram para óbito (até 1ª casa decimal)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # percentual de casos que se recupararam (até a 1ª casa decimal)
  select(                                              # reordene as colunas
    hospital, N_Known,                                   # Colunas iniciais
    N_Recover, Pct_Recover, ct_value_Recover,            # Colunas com recuperados
    N_Death, Pct_Death, ct_value_Death)  %>%             # Colunas com os óbitos
  arrange(N_Known) %>%                                 # Ordene as linhas do menor para o maior (com a linha "Total" por último)

  # formatando a tabela
  ############
  flextable() %>% 
  add_header_row(
    top = TRUE,                # Novo cabeçalho vai acima do cabeçalho existente
    values = c("Hospital",     # Os valores do cabeçalho estão abaixo
               "Total cases with known outcome", 
               "Recovered",    # Este será o título para esta e as próximas duas colunas
               "",
               "",
               "Died",         # Este será o título para esta e as próximas duas colunas
               "",             # Deixe em branco, uma vez que será unida com os "Death"
               "")) %>% 
    set_header_labels(         # Renomeie as colunas na linha original com os títulos
      hospital = "", 
      N_Known = "",                  
      N_Recover = "Total",
      Pct_Recover = "% of cases",
      ct_value_Recover = "Median CT values",
      N_Death = "Total",
      Pct_Death = "% of cases",
      ct_value_Death = "Median CT values")  %>% 
  merge_at(i = 1, j = 3:5, part = "header") %>% # Una as colunas 3 a 5 de forma horizontal na nova linha de cabeçalho
  merge_at(i = 1, j = 6:8, part = "header") %>%  
  border_remove() %>%  
  theme_booktabs() %>% 
  vline(part = "all", j = 2, border = border_style) %>%   # na coluna 2 
  vline(part = "all", j = 5, border = border_style) %>%   # na coluna 5
  merge_at(i = 1:2, j = 1, part = "header") %>% 
  merge_at(i = 1:2, j = 2, part = "header") %>% 
  width(j=1, width = 2.7) %>% 
  width(j=2, width = 1.5) %>% 
  width(j=c(4,5,7,8), width = 1) %>% 
  flextable::align(., align = "center", j = c(2:8), part = "all") %>% 
  bg(., part = "body", bg = "gray95")  %>% 
  colformat_num(., j = c(4,7), digits = 1) %>% 
  bold(i = 1, bold = TRUE, part = "header") %>% 
  bold(i = 6, bold = TRUE, part = "body")


table
```

## **Pacote gtsummary** {#tbl_gt}

Se você quer exportar seu resumo estatístico em um gráfico 'bonito', pronto para publicação, você pode usar o pacote **gtsummary** e sua função `tbl_summary()`. Em um primeiro momento, o código pode parecer complexo, mas as tabelas geradas são lindas e exportadas para o seu painel do RStudio Viewer como uma imagem HTML. Veja um tutorial mais detalhado [aqui](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html).

Você também pode adicionar os resultados dos testes estatísticos nas tabelas geradas pelo **gtsummary**. Este processo está decrito na seção do **gtsummary**, da página [testes estatísticos simples](#stat-tests).

Para introduzir a função `tbl_summary()`, nós vamos primeiro demostrar seu funcionamento básico, que produz uma tabela bonita e extensa. Então, examinaremos em detalhes como fazer ajustes finos e tabelas mais customizadas.

### Tabela resumo {.unnumbered}

O comportamento padrão do `tbl_summary()` é incrível - ele utiliza as colunas fornecidas e cria uma tabela resumo em apenas um comando. Esta função realiza as estatísticas apropriadas de acordo com a classe da coluna: média e intervalo interquartil (IQR) para colunas numéricas, e contagens (%) para colunas categóricas. Valores em branco são convertidos para "Unknown". Notas de rodapé são adicionadas para explicar as estatísticas utilizadas, enquanto a quantidade total N é mostrada no topo.

```{r, warning=F, message=F}

# Use a função abaixo para que a tabela saia em portugês

theme_gtsummary_language("pt")

linelist %>% 
  select(age_years, gender, outcome, fever, temp, hospital) %>%  # mantenha apenas as colunas de interesse
  tbl_summary()                                                  # função no modo padrão
```

### Ajustes {.unnumbered}

Agora iremos explicar como esta função funciona e como fazer ajustes. Os argumentos chave estão detalhados abaixo:

**`by =`**\
Você pode estratificar a sua tabela utilizando uma coluna (ex.: `outcome`), ao criar uma tabela de duas vias.

**`statistic =`**\
Use as equações para especificar quais estatísticas mostrar e como mostrá-las. Existem dois lados para essa equação, separados por um til `~`. Do lado direito, entre aspas, é colocado o teste estatístico desejado, e no lado esquerdo são colocadas as colunas em que esse teste será aplicado.

-   O lado direito da equação utiliza a sintaxe da função `str_glue()`, do pacote **stringr** (veja mais em [Caractéres e Strings](#characters-strings)), com o texto a ser mostrado entre aspas e o teste estatístico dentro de colchetes encaracolados `{ }`. Você pode incluir estatísticas como "n" (para contagens), "N" (para denominador), "mean" (média), "median" (mediana), "sd" (desvio padrão), "max" (valor máximo), "min" (valor mínimo), percentis "p\#\#" como "p25", ou percentual do total como "p". Utilize o comando `?tbl_summary` para mais detalhes.\
-   No lado esquerdo da equação, você pode especificar colunas por nome (ex.: `age` ou `c(age, gender)`) ou utilizando funções auxiliares como `all_continuous()`, `all_categorical()`, `contains()`, `starts_with()`, etc.

Uma exemplo simples da equação `statistic =` é mostrado abaixo, onde apenas a média da coluna `age_years` é obtida:

```{r}
linelist %>% 
  select(age_years) %>%         # mantenha apenas as colunas de interesse
  tbl_summary(                  # crie uma tabela resumo
    statistic = age_years ~ "{mean}") # calcule a média de idades (age)
```

Uma equação um pouco mais complexa é obtida `"({min}, {max})"`, incorporando os valores mínimos e máximos dentro de parênteses e separados por vírgula:

```{r}
linelist %>% 
  select(age_years) %>%                       # mantenha apenas as colunas de interesse
  tbl_summary(                                # crie uma tabela resumo
    statistic = age_years ~ "({min}, {max})") # calcule o min e max da idade (age)
```

Você também pode utilizar uma sintaxe diferente para colunas distintas ou diferentes tipos de colunas. Em um exemplo mais complexo, mostrado abaixo, o argumento dado à `statistic =` é uma **list** (list) indicando que para todas as colunas com valores contínuos, a tabela deve gerar a média com o desvio padrão em parênteses, enquanto que, para colunas categóricas, ela deve gerar o n, o denominador, e o percentual.

**`digits =`**\
Ajuste a quantidade de dígitos e de arredondamento. Opcionalmente, isto pode ser limitado à colunas contínuas apenas (como mostrado abaixo).

**`label =`**\
Ajuste como o rótulo da coluna deve ser mostrado. Forneça o nome da coluna e o rótulo desejado, separado por um til `~`. O padrão do rótulo é o nome da coluna.

**`missing_text =`**\
Ajuste como os campos em branco são mostrados. A opção padrão é "Unknown".

**`type =`**\
Isto é utilizado para ajustar quantos níveis das estatísticas são mostradas. A sintaxe é similar ao atributo `statistic =`, pois você fornece uma equação com colunas no lado esquerdo, e um valor no lado direito. Dois cenários comuns incluem:

-   `type = all_categorical() ~ "categorical"` Força colunas dicotômicas (ex.: `fever` sim/não) a mostrar todos os níveis em vez de apenas a linha "sim"\
-   `type = all_continuous() ~ "continuous2"` Permite a realização de estatísticas em múltiplas linha ("multi-line") por variável, como mostrado em seção posterior

No exemplo abaixo, cada um desses argumentos é utilizado para modificar a tabela resumo original:

```{r}
linelist %>% 
  select(age_years, gender, outcome, fever, temp, hospital) %>% # utilize apenas as colunas de interesse
  tbl_summary(     
    by = outcome,                                               # estratifique a tabela inteira pelo outcome
    statistic = list(all_continuous() ~ "{mean} ({sd})",        # estatísticas e formatação para colunas contínuas
                     all_categorical() ~ "{n} / {N} ({p}%)"),   # estatísticas e formatação para colunas categóricas
    digits = all_continuous() ~ 1,                              # arredondamento para colunas contínuas
    type   = all_categorical() ~ "categorical",                 # force todos os níveis de colunas categóricas a serem mostrados
    label  = list(                                              # mostre etiquetas de acordo com o nome das colunas
      outcome   ~ "Outcome",                           
      age_years ~ "Age (years)",
      gender    ~ "Gender",
      temp      ~ "Temperature",
      hospital  ~ "Hospital"),
    missing_text = "Missing"                                    # como valores em branco devem ser mostrados
  )
```

### Estatísticas de múltiplas linhas ("multi-line") para variáveis contínuas {.unnumbered}

Se você quiser obter múltiplas linhas de estatísticas para variáveis contínuas, é possível indicar isto ao ajustar o atributo `type =` para "continuous2". É possível combinar todos os elementos mostrados anteriormente em uma tabela, ao escolher quais estatísticas quer mostrar. Para fazer isso, é necessário 'dizer' para a função que você quer a tabela de volta ao inserir seu tipo como "continous2". A quantidade de campos em braco é mostrado como "Unknown".

```{r}
linelist %>% 
  select(age_years, temp) %>%                      # mantenha apenas colunas de interesse
  tbl_summary(                                     # crie tabelas resumo
    type = all_continuous() ~ "continuous2",       # indique que você quer obter mais de uma estatística
    statistic = all_continuous() ~ c(
      "{mean} ({sd})",                             # linha 1: média e desvio padrão
      "{median} ({p25}, {p75})",                   # linha 2: média e IQR
      "{min}, {max}")                              # linha 3: min e max
    )
```

Existem diversas formas de modificar essas tabelas, como adicionar valores do p, ajustar cores e títulos, etc. Muitas destas modificações estão descritas na documentação (digite `?tbl_summary` no Console), e algumas destas são mostradas na seção sobre [testes estatísticos](#stat-tests).


## Pacote R **base**

Você pode usar a função `table()` para tabular e realizar tabulações cruzadas das colunas. Diferente das opções acima, você precisa especificar o quadro de dados cada vez que o nome de uma coluna é apontado, como mostrado abaixo.

[***CUIDADO:*** `NA` valores em branco **não** serão tabulados a não ser que você coloque o argumento `useNA = "always"` (que também pode ser ajustado para "no" ou "ifany").]{style="color: orange;"}

[***DICA:*** É possível usar o `%$%` do pacote **magrittr** para remover a necessidade de repetir a quantidade de vezes que o quadro de dados é chamado dentro das funções do pacote R **base**. Por exemplo, o código abaixo poderia ser reescrito como `linelist %$% table(outcome, useNA = "always")`]{style="color: darkgreen;"}

```{r}
table(linelist$outcome, useNA = "always")
```

Múltiplas colunas podem ser utilizadas para tabulação cruzada ao listá-las uma após a outra, separadas por vírgulas. Opcionalmente, você pode dar um "nome" a cada coluna, como em `Outcome = linelist$outcome`.

```{r}
age_by_outcome <- table(linelist$age_cat, linelist$outcome, useNA = "always") # salve a tabela como objeto
age_by_outcome   # exporte a tabela
```

### Proporções {.unnumbered}

Para obter proporções, utilize a tabela acima na função `prop.table()`. Use o argumento `margins =` para especificar caso você queira que as proporções sejam calculadas das linhas (1), colunas (2), ou da tabela inteira (3). No código abaixo, encadeamos ("piped") a tabela com a função `round()`, do R **base**, especificando 2 dígitos.

```{r}
# obtenhas as proporções da tabela definida acima, por linhas, arredondado
prop.table(age_by_outcome, 1) %>% round(2)
```

### Totais {.unnumbered}

Para adicionar colunas e linhas com totais, passe a tabela gerada para a função `addmargins()`. Isto funciona para contagens e proporções.

```{r}
addmargins(age_by_outcome)
```

### Converta para um quadro de dados {.unnumbered}

Converter um objeto `table()` diretamente para um quadro de dado (*data frame*)s não é simples. Uma possível abordagem é mostrada abaixo:

1)  Crie a tabela, *sem utilizar* `useNA = "always"`. Em vez disso, converta os valores `NA` para "(Missing)" com a função `fct_explicit_na()`, do pacote **forcats**.\
2)  Adicione os totais (opcional) ao aplicar a tabela na função `addmargins()`\
3)  Utilize a tabela na função do R **base** `as.data.frame.matrix()`\
4)  Transforme a tabela utilizando a função do pacote **tibble,** `rownames_to_column()`, especificando o nome da primeira coluna\
5)  Exporte, Visualize, ou exporte como desejado. Neste exemplo, nós utilizamos a função `flextable()`, do pacote **flextable**, como descrito na página [Tabelas para apresentação](#tables-presentation). Isto irá exportar a tabela para o RStudio viewer como uma linda imagem HTML.

```{r, warning=F, message=F}
table(fct_explicit_na(linelist$age_cat), fct_explicit_na(linelist$outcome)) %>% 
  addmargins() %>% 
  as.data.frame.matrix() %>% 
  tibble::rownames_to_column(var = "Age Category") %>% 
  flextable::flextable()
```

<!-- ======================================================= -->

## Recursos extras

Muitas das informações desta página foram adaptadas destes recursos e tutoriais online:

[gtsummary](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html)

[dplyr](https://dplyr.tidyverse.org/articles/grouping.html)
