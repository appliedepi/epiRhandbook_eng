# Daten verknüpfen { }

```{r, out.width=c("50%"), fig.show="hold", echo=F}
knitr::include_graphics(here::here("images", "left-join.gif"))
```

*Oben: ein animiertes Beispiel für eine linke Verknüpfung ([Bildquelle](https://github.com/gadenbuie/tidyexplain/tree/master/images))*

Diese Seite beschreibt, wie du Datenrahmen "verbinden", "abgleichen", "verknüpfen", "binden" und anderweitig kombinieren kannst.

Es ist ungewöhnlich, dass deine epidemiologische Analyse oder dein Arbeitsablauf nicht mehrere Datenquellen und die Verknüpfung mehrerer Datensätze umfasst. Vielleicht musst du Labordaten mit klinischen Ergebnissen verknüpfen oder Google-Mobilitätsdaten mit Trends bei Infektionskrankheiten oder sogar einen Datensatz, der sich in einem Stadium der Analyse befindet, mit einer transformierten Version seiner selbst.

Auf dieser Seite zeigen wir dir den Code, um:

- Führen Sie *trittbei* von zwei Datenrahmen, so dass Zeilen auf der Grundlage gemeinsamer Werte in Bezeichnerspalten zusammengeführt werden
- Verbinde zwei Datenrahmen basierend auf *probabilistischen* (wahrscheinlichen) Übereinstimmungen zwischen Werten
- Erweitern Sie einen Datenrahmen direkt um *binden.* oder ("Anhängen") von Zeilen oder Spalten aus einem anderen Datenrahmen

<!-- ======================================================= -->

## Vorbereitung { }

### Pakete laden {.unnumbered}

Dieser Codechunk zeigt das Laden der Pakete, die für die Analysen benötigt werden. In diesem Handbuch betonen wir `p_load()` von **pacman**, der das Paket bei Bedarf installiert *und* lädt es zur Verwendung. Du kannst installierte Pakete auch laden mit `library()` von **base**R. Siehe die Seite über [R-Grundlagen] für weitere Informationen über R-Pakete.

```{r}
pacman::p_load(
  rio,            # import and export
  here,           # locate files 
  tidyverse,      # data management and visualisation
  RecordLinkage,  # probabilistic matches
  fastLink        # probabilistic matches
)
```

### Daten importieren {.unnumbered}

Zunächst importieren wir die bereinigte Liste der Fälle aus einer simulierten Ebola-Epidemie. Wenn du mitmachen willst, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>klicke, um die "saubere" Liste herunterzuladen</a> (als .rds-Datei). Importiere Daten mit dem `import()` Funktion aus der **rio**Paket (sie verarbeitet viele Dateitypen wie .xlsx, .csv, .rds - siehe die [Import und Export] Seite für Details).

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import case linelist 
linelist <- import("linelist_cleaned.rds")
```

Die ersten 50 Zeilen der Linienliste werden unten angezeigt.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

### Beispiel-Datensätze {.unnumbered}

Im folgenden Abschnitt über das Verbinden werden wir die folgenden Datensätze verwenden:

1) Eine "Miniatur"-Version des Falls `linelist`, die nur die Spalten `case_id`, `date_onset`, und `hospital`, und nur die ersten 10 Zeilen
2) Ein separater Datenrahmen namens `hosp_info`, der mehr Details über jedes Krankenhaus enthält

Im Abschnitt über das probabilistische Matching werden wir zwei verschiedene kleine Datensätze verwenden. Den Code zur Erstellung dieser Datensätze findest du in diesem Abschnitt.

#### "Miniatur"-Fall-Lineliste {#joins\_llmini .unnumbered}

Hier ist die Miniatur-Fallliste, die nur 10 Zeilen und nur Spalten enthält `case_id`, `date_onset`, und `hospital`.

```{r}
linelist_mini <- linelist %>%                 # start with original linelist
  select(case_id, date_onset, hospital) %>%   # select columns
  head(10)                                    # only take the first 10 rows
```

```{r, message=FALSE, echo=F}
DT::datatable(linelist_mini, rownames = FALSE, options = list(pageLength = nrow(10)))
```

#### Datenrahmen für Krankenhausinformationen {#joins\_hosp\_info .unnumbered}

Im Folgenden findest du den Code zur Erstellung eines separaten Datenrahmens mit zusätzlichen Informationen über sieben Krankenhäuser (Einzugsgebiet und Versorgungsstufe). Beachte, dass der Name "Militärkrankenhaus" zu zwei verschiedenen Krankenhäusern gehört - das eine ist ein Krankenhaus der Primärebene mit 10000 Einwohnern und das andere ein Krankenhaus der Sekundärebene mit 50280 Einwohnern.

```{r}
# Make the hospital information data frame
hosp_info = data.frame(
  hosp_name     = c("central hospital", "military", "military", "port", "St. Mark's", "ignace", "sisters"),
  catchment_pop = c(1950280, 40500, 10000, 50280, 12000, 5000, 4200),
  level         = c("Tertiary", "Secondary", "Primary", "Secondary", "Secondary", "Primary", "Primary")
)
```

Hier ist dieser Datenrahmen:

```{r, message=FALSE, echo=F}
# display the hospital data as a table
DT::datatable(hosp_info, rownames = FALSE, options = list(pageLength = nrow(hosp_info)))
```

<!-- ======================================================= -->

### Vor-Reinigung {.unnumbered}

Herkömmliche (nicht-probabilistische) Verknüpfungen unterscheiden Groß- und Kleinschreibung und erfordern exakte Zeichenübereinstimmungen zwischen den Werten in den beiden Datenrahmen. Um einige der Bereinigungsschritte zu veranschaulichen, die du vor einem Join durchführen musst, bereinigen und richten wir die `linelist_mini` und `hosp_info` Datensätze bereinigen und abgleichen.

**Unterschiede erkennen**

Wir brauchen die Werte der `hosp_name` Spalte in der `hosp_info` Datenrahmens mit den Werten der `hospital` Spalte in der `linelist_mini` Datenrahmens anzupassen.

Hier sind die Werte in der `linelist_mini` Datenrahmen, gedruckt mit dem **Basis** R-Funktion `unique()`:

```{r}
unique(linelist_mini$hospital)
```

und hier sind die Werte in der `hosp_info` Datenrahmen:

```{r}
unique(hosp_info$hosp_name)
```

Du kannst sehen, dass einige der Krankenhäuser zwar in beiden Datenrahmen vorhanden sind, es aber viele Unterschiede in der Schreibweise gibt.

**Werte abgleichen**

Wir beginnen mit dem Bereinigen der Werte in der `hosp_info`Datenrahmen. Wie im Abschnitt [Datenbereinigung und Kernfunktionen] erklärt, können wir Werte mit logischen Kriterien neu kodieren, indem wir**dplyr**'s `case_when()` Funktion. Für die vier Krankenhäuser, die in beiden Datenrahmen vorhanden sind, ändern wir die Werte, um sie an die Werte in `linelist_mini`. Für die anderen Krankenhäuser belassen wir die Werte so, wie sie sind (`TRUE ~ hosp_name`).

<span style="color: orange;">***VORSICHT!*** Normalerweise sollte man beim Reinigen eine neue Spalte erstellen (z.B. `hosp_name_clean`), aber zur Veranschaulichung zeigen wir die Änderung der alten Spalte</span>

```{r}
hosp_info <- hosp_info %>% 
  mutate(
    hosp_name = case_when(
      # criteria                         # new value
      hosp_name == "military"          ~ "Military Hospital",
      hosp_name == "port"              ~ "Port Hospital",
      hosp_name == "St. Mark's"        ~ "St. Mark's Maternity Hospital (SMMH)",
      hosp_name == "central hospital"  ~ "Central Hospital",
      TRUE                             ~ hosp_name
      )
    )
```

Die Namen der Krankenhäuser, die in beiden Datenrahmen vorkommen, werden angeglichen. Es gibt zwei Krankenhäuser in `hosp_info` die nicht in den `linelist_mini` - Wir werden uns mit diesen später in der Verknüpfung befassen.

```{r}
unique(hosp_info$hosp_name)
```

Vor einer Verknüpfung ist es oft am einfachsten, eine Spalte ganz in Klein- oder Großbuchstaben umzuwandeln. Wenn du alle Werte in einer Spalte in Groß- oder Kleinbuchstaben umwandeln musst, verwende `mutate()` und verpacke die Spalte mit einer der folgenden Funktionen aus **stringr**ein, wie es auf der Seite über [Zeichen und Zeichenketten].

`str_to_upper()`  
`str_to_upper()`  
`str_to_title()`

<!-- ======================================================= -->

## **dplyr** verbindet { }

Die **dplyr** Paket bietet mehrere verschiedene Join-Funktionen. **dplyr** ist enthalten in der **tidyverse** Paket enthalten. Diese Verknüpfungsfunktionen werden im Folgenden mit einfachen Anwendungsfällen beschrieben.

Vielen Dank an [https://github.com/gadenbuie](https://github.com/gadenbuie/tidyexplain/tree/master/images) für die informativen Gifs!

<!-- ======================================================= -->

### Allgemeine Syntax {.unnumbered}

Die Join-Befehle können als eigenständige Befehle ausgeführt werden, um zwei Datenrahmen zu einem neuen Objekt zu verbinden, oder sie können innerhalb einer Pipe-Kette verwendet werden (`%>%`) verwendet werden, um einen Datenrahmen mit einem anderen zusammenzuführen, während dieser bereinigt oder anderweitig verändert wird.

In dem folgenden Beispiel wird die Funktion `left_join()` als eigenständiger Befehl verwendet, um einen neuen `joined_data` Datenrahmen zu erstellen. Die Eingaben sind die Datenrahmen 1 und 2 (`df1` und `df2`). Der erste aufgelistete Datenrahmen ist der Basisdatenrahmen, und der zweite ist mit dem *zu* verbunden.

Das dritte Argument `by = ` gibst du die Spalten in jedem Datenrahmen an, die zum Ausrichten der Zeilen in den beiden Datenrahmen verwendet werden sollen. Wenn die Namen dieser Spalten unterschiedlich sind, gibst du sie in einer `c()` Vektor an, wie unten gezeigt, wobei die Zeilen auf der Grundlage gemeinsamer Werte zwischen den Spalten abgeglichen werden `ID` in `df1` und der Spalte `identifier` in `df2`.

```{r, eval=F}
# Join based on common values between column "ID" (first data frame) and column "identifier" (second data frame)
joined_data <- left_join(df1, df2, by = c("ID" = "identifier"))
```

Wenn die `by` Spalten in beiden Datenrahmen genau denselben Namen haben, kannst du nur diesen einen Namen in Anführungszeichen angeben.

```{r, eval=F}
# Joint based on common values in column "ID" in both data frames
joined_data <- left_join(df1, df2, by = "ID")
```

Wenn du die Datenrahmen auf der Grundlage gemeinsamer Werte in mehreren Feldern verbindest, führe diese Felder in der Spalte `c()` Vektor auf. In diesem Beispiel werden Zeilen verbunden, wenn die Werte in drei Spalten in jedem Datensatz genau übereinstimmen.

```{r, eval=F}
# join based on same first name, last name, and age
joined_data <- left_join(df1, df2, by = c("name" = "firstname", "surname" = "lastname", "Age" = "age"))
```

Die Join-Befehle können auch innerhalb einer Pipe-Kette ausgeführt werden. Dadurch wird der Datenrahmen, der über die Pipeline übertragen wird, geändert.

Im folgenden Beispiel, `df1` wird durch die Pipes geleitet, `df2` wird mit ihr verbunden, und `df` wird so verändert und neu definiert.

```{r, eval=F}
df1 <- df1 %>%
  filter(date_onset < as.Date("2020-03-05")) %>% # miscellaneous cleaning 
  left_join(df2, by = c("ID" = "identifier"))    # join df2 to df1
```

<span style="color: orange;">***VORSICHT!*** Bei der Verknüpfung wird zwischen Groß- und Kleinschreibung unterschieden! Deshalb ist es sinnvoll, alle Werte vor der Verknüpfung in Klein- oder Großbuchstaben umzuwandeln. Siehe die Seite über Zeichen/Strings.</span>

<!-- ======================================================= -->

### Linke und rechte Fugen {.unnumbered}

**Eine linke oder rechte Verknüpfung wird üblicherweise verwendet, um einem Datenrahmen Informationen hinzuzufügen** - Die neuen Informationen werden nur den Zeilen hinzugefügt, die bereits im Basisdatensatz vorhanden sind. Diese Verknüpfungen sind in der Epidemiologie üblich, da sie dazu verwendet werden, Informationen aus einem Datensatz in einen anderen einzufügen.

Bei der Verwendung dieser Verknüpfungen ist die Reihenfolge, in der die Datenrahmen im Befehl geschrieben werden, wichtig\*.

- In einer *linken Verknüpfung* ist die *erste* geschriebene Datenrahmen ist die Basislinie
- In einem *rechten Verknüpfung* ist die *zweite* geschriebene Datenrahmen ist die Basislinie

**Alle Zeilen des Basisdatenrahmens werden beibehalten.** Die Informationen in dem anderen (sekundären) Datenrahmen werden mit dem Basisdatenrahmen verbunden *nur dann verbunden, wenn es eine Übereinstimmung über die Identifikatorspalte(n*. Darüber hinaus:

- Zeilen im sekundären Datenrahmen, die nicht übereinstimmen, werden gelöscht.
- Wenn es viele Basislinienzeilen gibt, die mit einer Zeile im sekundären Datenrahmen übereinstimmen (viele-zu-eins), werden die sekundären Informationen zu *jeder übereinstimmenden Grundlinienzeile*.
- Wenn eine Baseline-Zeile mit mehreren Zeilen im sekundären Datenrahmen übereinstimmt (one-to-many), werden alle Kombinationen angegeben, das heißt *neue Zeilen können zu deinem zurückgegebenen Datenrahmen hinzugefügt werden!*

Animierte Beispiele für linke und rechte Joins ([Bildquelle](https://github.com/gadenbuie/tidyexplain/tree/master/images))

```{r, out.width=c("50%"), fig.show="hold", echo=F}
knitr::include_graphics(here::here("images", "left-join.gif"))
knitr::include_graphics(here::here("images", "right-join.gif"))
```

**Beispiel**

Nachfolgend ist die Ausgabe einer `left_join()` von `hosp_info` (sekundärer Datenrahmen, [hier ansehen](#joins_hosp_info)) *in* `linelist_mini` (Basisdatenrahmen, [hier ansehen](#joins_llmini)). Das Original `linelist_mini` hat ` nrow(linelist_mini)` Zeilen. Das geänderte `linelist_mini` wird angezeigt. Beachte das Folgende:

- Zwei neue Spalten, `catchment_pop` und `level` wurden auf der linken Seite von `linelist_mini`
- Alle ursprünglichen Zeilen des Basisdatenrahmens `linelist_mini` werden beibehalten
- Alle Originalzeilen des `linelist_mini` für "Militärkrankenhaus" werden dupliziert, weil sie mit *zwei* Zeilen im sekundären Datenrahmen übereinstimmen, sodass beide Kombinationen zurückgegeben werden
- Die Join-Identifier-Spalte des sekundären Datensatzes (`hosp_name`) ist verschwunden, weil sie mit der Bezeichnerspalte im primären Datensatz (`hospital`)
- Wenn eine Basiszeile mit keiner Sekundärzeile übereinstimmte (z. B. wenn `hospital` "Sonstige" oder "Fehlend" ist), `NA` (leer) füllt die Spalten aus dem sekundären Datenrahmen aus
- Zeilen im sekundären Datenrahmen, die nicht mit dem Basisdatenrahmen übereinstimmen ("Schwestern" und "Ignace"-Krankenhäuser), wurden gelöscht

```{r, eval=F}
linelist_mini %>% 
  left_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r, message=FALSE, echo=F}
linelist_mini %>% 
  left_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 11))
```

#### "Soll ich eine rechte oder eine linke Verknüpfung verwenden?" {.unnumbered}

Um die obige Frage zu beantworten, frage dich: "Welcher Datenrahmen sollte alle seine Zeilen behalten?" - nimm diesen als Grundlage. A *linke Verknüpfung* behält alle Zeilen des ersten Datenrahmens bei, die im Befehl geschrieben wurden, während eine *rechte Verknüpfung* alle Zeilen des zweiten Datenrahmens beibehält.

Die beiden folgenden Befehle erzielen das gleiche Ergebnis - 10 Zeilen von `hosp_info` verbundenen *in* a `linelist_mini` Basislinie, aber sie verwenden unterschiedliche Joins. Das Ergebnis ist, dass die Reihenfolge der Spalten unterschiedlich ist, je nachdem, ob `hosp_info` von rechts (im linken Join) oder von links (im rechten Join) eintrifft. Auch die Reihenfolge der Zeilen kann sich entsprechend verschieben. Diese beiden Folgen können jedoch nachträglich behoben werden, indem du `select()` um Spalten neu zu ordnen oder `arrange()` um Zeilen zu sortieren.

```{r, eval=F}
# The two commands below achieve the same data, but with differently ordered rows and columns
left_join(linelist_mini, hosp_info, by = c("hospital" = "hosp_name"))
right_join(hosp_info, linelist_mini, by = c("hosp_name" = "hospital"))
```

Hier ist das Ergebnis von `hosp_info` in `linelist_mini` über einen Left Join (neue Spalten kommen von rechts)

```{r, message=FALSE, echo=F}
left_join(linelist_mini, hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 11))
```

Hier ist das Ergebnis von `hosp_info` in `linelist_mini` über einen Right Join (neue Spalten von links kommend)

```{r, message=FALSE, echo=F}
right_join(hosp_info, linelist_mini, by = c("hosp_name" = "hospital")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 11))
```

Überlege auch, ob dein Anwendungsfall innerhalb einer Rohrkette liegt (`%>%`). Wenn der Datensatz in den Pipes die Baseline ist, wirst du wahrscheinlich einen Left Join verwenden, um Daten hinzuzufügen.

<!-- ======================================================= -->

### Vollständiger Join {.unnumbered}

**Ein Vollanschluss ist die *inklusive* der Verknüpfungen** - gibt er alle Zeilen aus beiden Datenrahmen zurück.

Wenn es in einem Datenrahmen Zeilen gibt, die im anderen nicht vorhanden sind (weil keine Übereinstimmung gefunden wurde), werden diese in den Datenrahmen aufgenommen und verlängern sich. `NA` Fehlende Werte werden verwendet, um entstandene Lücken aufzufüllen. Achte beim Zusammenführen genau auf die Anzahl der Spalten und Zeilen, um die Groß- und Kleinschreibung zu beachten und exakte Zeichenübereinstimmungen zu vermeiden.

Der "Basis"-Datenrahmen ist derjenige, der zuerst in den Befehl geschrieben wird. Wenn du dies änderst, hat das keinen Einfluss darauf, welche Datensätze aus der Verknüpfung zurückgegeben werden, aber es kann sich auf die Reihenfolge der Spalten und Zeilen auswirken und darauf, welche Bezeichnungsspalten beibehalten werden.

```{r, out.width=c("50%"), fig.show="hold", echo=F}
knitr::include_graphics(here::here("images", "full-join.gif"))
```

Animiertes Beispiel für einen vollständigen Join ([Bildquelle](https://github.com/gadenbuie/tidyexplain/tree/master/images))

**Beispiel**

Nachfolgend ist die Ausgabe einer `full_join()` von `hosp_info` (ursprünglich ` nrow(hosp_info)`, [hier ansehen](#joins_hosp_info)) *in* `linelist_mini` (ursprünglich ` nrow(linelist_mini)`, [hier ansehen](#joins_llmini)). Beachte das Folgende:

- Alle Zeilen der Grundlinie werden beibehalten (`linelist_mini`)
- Zeilen in der Sekundärdatei, die nicht mit der Basislinie übereinstimmen, werden beibehalten ("ignace" und "sisters"), mit Werten in den entsprechenden Spalten der Basislinie `case_id` und `onset` mit fehlenden Werten aufgefüllt
- Ebenso werden die Zeilen im Basisdatenrahmen, die nicht mit den sekundären Daten übereinstimmen ("Andere" und "Fehlende"), beibehalten und mit sekundären Spalten ` catchment_pop` und `level` mit fehlenden Werten aufgefüllt
- Im Falle von Eins-zu-Viel- oder Viele-zu-Eins-Übereinstimmungen (z. B. Zeilen für "Militärkrankenhaus") werden alle möglichen Kombinationen zurückgegeben (was den endgültigen Datenrahmen verlängert)
- Nur die Identifizierungsspalte aus der Grundlinie wird beibehalten (`hospital`)

```{r, eval=F}
linelist_mini %>% 
  full_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r, message=FALSE, echo=F}
linelist_mini %>% 
  full_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 15))
```

<!-- ======================================================= -->

### Innere Verknüpfung {.unnumbered}

**Ein innerer Join ist die am meisten *restriktivste* der Verknüpfungen** - er gibt nur Zeilen mit Übereinstimmungen in beiden Datenrahmen zurück.  
Das bedeutet, dass die Anzahl der Zeilen im Basisdatenrahmen tatsächlich *verringern*. Die Anpassung des "Basisdatenrahmens" (der in der Funktion an erster Stelle steht) hat keinen Einfluss darauf, welche Zeilen zurückgegeben werden, aber sie wirkt sich auf die Reihenfolge der Spalten und Zeilen aus und darauf, welche Kennzeichnungsspalten beibehalten werden.

```{r, out.width=c("50%"), fig.show="hold", echo=F}
knitr::include_graphics(here::here("images", "inner-join.gif"))
```

Animiertes Beispiel für eine innere Verknüpfung ([Bildquelle](https://github.com/gadenbuie/tidyexplain/tree/master/images))

**Beispiel**

Nachfolgend ist die Ausgabe einer `inner_join()` von `linelist_mini` (Baseline) mit `hosp_info` (sekundär). Beachte das Folgende:

- Basiszeilen, die nicht mit den Sekundärdaten übereinstimmen, werden entfernt (Zeilen, in denen `hospital` "Fehlt" oder "Andere" ist)
- Ebenso werden Zeilen aus dem sekundären Datenrahmen entfernt, die keine Übereinstimmung mit der Baseline haben (Zeilen, bei denen `hosp_name` "Schwestern" oder "nicht vorhanden" ist)
- Nur die Identifikatorspalte aus der Baseline wird beibehalten (`hospital`)

```{r, eval=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r, message=FALSE, echo=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 12))
```

<!-- ======================================================= -->

### Semi join {.unnumbered}

Ein Semi-Join ist ein "filternder Join", der einen anderen Datensatz verwendet *nicht um Zeilen oder Spalten hinzuzufügen, sondern um eine Filterung durchzuführen*.

A **Semi-Join behält alle Beobachtungen im Basisdaten-Frame, die eine Übereinstimmung im sekundären Daten-Frame haben** (es werden jedoch weder neue Spalten hinzugefügt noch Zeilen für Mehrfachübereinstimmungen dupliziert). Lies mehr über diese "filternden" Joins [hier](https://towardsdatascience.com/level-up-with-semi-joins-in-r-a068426096e0).

```{r, out.width=c("50%"), fig.show="hold", echo=F}
knitr::include_graphics(here::here("images", "semi-join.gif"))
```

Animiertes Beispiel für einen Semi Join ([Bildquelle](https://github.com/gadenbuie/tidyexplain/tree/master/images))

Der folgende Code gibt zum Beispiel Zeilen aus der `hosp_info` Datenrahmen zurück, die Übereinstimmungen haben in `linelist_mini` basierend auf dem Namen des Krankenhauses.

```{r}
hosp_info %>% 
  semi_join(linelist_mini, by = c("hosp_name" = "hospital"))
```

<!-- ======================================================= -->

### Anti join {.unnumbered}

**Der Anti-Join ist ein weiterer "filternder Join", der Zeilen im Basisdatenrahmen zurückgibt, die *nicht* die keine Übereinstimmung im sekundären Datenrahmen haben.**

Lies mehr über das Filtern von Joins [hier](https://towardsdatascience.com/level-up-with-semi-joins-in-r-a068426096e0).

Häufige Szenarien für einen Anti-Join sind die Identifizierung von Datensätzen, die in einem anderen Datenrahmen nicht vorhanden sind, die Behebung von Rechtschreibfehlern in einem Join (Überprüfung von Datensätzen, die *haben sollten* übereinstimmen sollten), und die Überprüfung von Datensätzen, die nach einem anderen Join ausgeschlossen wurden.

**Wie bei `right_join()` und `left_join()` ist die *Basislinie* Datenrahmen (an erster Stelle) ist wichtig**. Die zurückgegebenen Zeilen stammen nur aus dem Basisdatenrahmen. In der Grafik unten siehst du, dass die Zeile im sekundären Datenrahmen (lila Zeile 4) nicht zurückgegeben wird, obwohl sie nicht mit der Basislinie übereinstimmt.

```{r, out.width=c("50%"), fig.show="hold", echo=F}
knitr::include_graphics(here::here("images", "anti-join.gif"))
```

Animiertes Beispiel für einen Anti-Join ([Bildquelle](https://github.com/gadenbuie/tidyexplain/tree/master/images))

#### Einfach `anti_join()` Beispiel {.unnumbered}

Ein einfaches Beispiel: Wir finden die `hosp_info` Krankenhäuser, die keine Fälle haben, die in `linelist_mini`. Wir listen auf `hosp_info` als erstes auf, als Basisdatenrahmen. Die Krankenhäuser, die nicht in der `linelist_mini` sind, werden zurückgegeben.

```{r, eval=F}
hosp_info %>% 
  anti_join(linelist_mini, by = c("hosp_name" = "hospital"))
```

```{r, message=FALSE, echo=F}
hosp_info %>% 
  anti_join(linelist_mini, by = c("hosp_name" = "hospital")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 12))
```

#### Komplexe `anti_join()` Beispiel {.unnumbered}

Ein weiteres Beispiel: Nehmen wir an, wir haben eine `inner_join()` zwischen `linelist_mini` und `hosp_info`. Dies liefert nur eine Teilmenge der ursprünglichen `linelist_mini` Datensätze zurück, da einige nicht in `hosp_info`.

```{r, eval=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r, message=FALSE, echo=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 8))
```

Zur Überprüfung der `linelist_mini` Datensätze zu überprüfen, die beim Inner Join ausgeschlossen wurden, können wir einen Anti-Join mit denselben Einstellungen durchführen (`linelist_mini` wie in der Baseline).

```{r, eval=F}
linelist_mini %>% 
  anti_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r, message=FALSE, echo=F}
linelist_mini %>% 
  anti_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 8))
```

Um die `hosp_info` Datensätze zu sehen, die im Inner Join ausgeschlossen wurden, können wir auch einen Anti-Join mit `hosp_info` als Basisdatenrahmen durchführen.

<!-- ======================================================= -->

## Probabalistischer Abgleich { }

Wenn du keinen eindeutigen Identifikator hast, der allen Datensätzen gemeinsam ist, kannst du einen probabilistischen Abgleichsalgorithmus verwenden. Dieser findet Übereinstimmungen zwischen Datensätzen auf der Grundlage von Ähnlichkeiten (z. B. Jaro-Winkler String-Distanz oder numerische Distanz).  Nachfolgend ein einfaches Beispiel, das das Paket **fastLink** .

**Pakete laden**

```{r}
pacman::p_load(
  tidyverse,      # data manipulation and visualization
  fastLink        # record matching
  )
```

Hier sind zwei kleine Beispieldatensätze, anhand derer wir das probabilistische Matching demonstrieren wollen (`cases` und `test_results`):

Hier ist der Code, mit dem die Datensätze erstellt wurden:

```{r}
# make datasets

cases <- tribble(
  ~gender, ~first,      ~middle,     ~last,        ~yr,   ~mon, ~day, ~district,
  "M",     "Amir",      NA,          "Khan",       1989,  11,   22,   "River",
  "M",     "Anthony",   "B.",        "Smith",      1970, 09, 19,      "River", 
  "F",     "Marialisa", "Contreras", "Rodrigues",  1972, 04, 15,      "River",
  "F",     "Elizabeth", "Casteel",   "Chase",      1954, 03, 03,      "City",
  "M",     "Jose",      "Sanchez",   "Lopez",      1996, 01, 06,      "City",
  "F",     "Cassidy",   "Jones",      "Davis",     1980, 07, 20,      "City",
  "M",     "Michael",   "Murphy",     "O'Calaghan",1969, 04, 12,      "Rural", 
  "M",     "Oliver",    "Laurent",    "De Bordow" , 1971, 02, 04,     "River",
  "F",      "Blessing",  NA,          "Adebayo",   1955,  02, 14,     "Rural"
)

results <- tribble(
  ~gender,  ~first,     ~middle,     ~last,          ~yr, ~mon, ~day, ~district, ~result,
  "M",      "Amir",     NA,          "Khan",         1989, 11,   22,  "River", "positive",
  "M",      "Tony",   "B",         "Smith",          1970, 09,   19,  "River", "positive",
  "F",      "Maria",    "Contreras", "Rodriguez",    1972, 04,   15,  "Cty",   "negative",
  "F",      "Betty",    "Castel",   "Chase",        1954,  03,   30,  "City",  "positive",
  "F",      "Andrea",   NA,          "Kumaraswamy",  2001, 01,   05,  "Rural", "positive",      
  "F",      "Caroline", NA,          "Wang",         1988, 12,   11,  "Rural", "negative",
  "F",      "Trang",    NA,          "Nguyen",       1981, 06,   10,  "Rural", "positive",
  "M",      "Olivier" , "Laurent",   "De Bordeaux",  NA,   NA,   NA,  "River", "positive",
  "M",      "Mike",     "Murphy",    "O'Callaghan",  1969, 04,   12,  "Rural", "negative",
  "F",      "Cassidy",  "Jones",     "Davis",        1980, 07,   02,  "City",  "positive",
  "M",      "Mohammad", NA,          "Ali",          1942, 01,   17,  "City",  "negative",
  NA,       "Jose",     "Sanchez",   "Lopez",        1995, 01,   06,  "City",  "negative",
  "M",      "Abubakar", NA,          "Abullahi",     1960, 01,   01,  "River", "positive",
  "F",      "Maria",    "Salinas",   "Contreras",    1955, 03,   03,  "River", "positive"
  )

```

**Die `cases` Datensatz hat 9 Datensätze** von Patienten, die auf Testergebnisse warten.

```{r, message=FALSE, echo=F}
# display the hospital data as a table
DT::datatable(cases, rownames = FALSE, options = list(pageLength = nrow(cases), scrollX=T), class = 'white-space: nowrap')
```

**Die `test_results` Datensatz** hat 14 Datensätze und enthält die Spalte `result` die wir zu den Datensätzen in `cases` basierend auf dem probabilistischen Abgleich der Datensätze.

```{r, message=FALSE, echo=F}
# display the hospital data as a table
DT::datatable(results, rownames = FALSE, options = list(pageLength = nrow(results), scrollX=T), class = 'white-space: nowrap')
```

### Probabilistischer Abgleich {.unnumbered}

Die `fastLink()` Funktion aus dem **fastLink** Paket kann verwendet werden, um einen Matching-Algorithmus anzuwenden. Hier sind die grundlegenden Informationen. Du kannst mehr Details lesen, indem du `?fastLink` in deiner Konsole eingibst.

- Definiere die beiden Datenrahmen für den Vergleich mit Argumenten `dfA = ` und `dfB = `
- In `varnames = ` gib alle Spaltennamen an, die für den Abgleich verwendet werden sollen. Sie müssen alle in beiden `dfA` und `dfB`.
- Unter `stringdist.match = ` geben Sie Spalten aus denen in `varnames` auf den String "Abstand" ausgewertet werden.
- In `numeric.match = ` werden die Spalten von denen in `varnames` auf numerischen Abstand ausgewertet werden.
- Fehlende Werte werden ignoriert
- Standardmäßig wird jede Zeile in einem der beiden Datenrahmen mit höchstens einer Zeile im anderen Datenrahmen abgeglichen. Wenn du alle ausgewerteten Übereinstimmungen sehen willst, setze `dedupe.matches = FALSE`. Die Deduplizierung wird mit der linearen Zuordnungslösung von Winkler durchgeführt.

*Tipp: Teile eine Datumsspalte in drei separate numerische Spalten auf, indem du `day()`, `month()`, und `year()` von **lubridate** Paket*

Der Standardschwellenwert für Übereinstimmungen ist 0,94 (`threshold.match = `), aber du kannst ihn höher oder niedriger einstellen. Wenn du den Schwellenwert festlegst, solltest du bedenken, dass ein höherer Schwellenwert zu mehr falsch-negativen Übereinstimmungen führen kann (Zeilen, die nicht übereinstimmen, obwohl sie eigentlich übereinstimmen sollten) und dass ein niedrigerer Schwellenwert zu mehr falsch-positiven Übereinstimmungen führen kann.

Im Folgenden werden die Daten anhand der String-Distanz für die Spalten Name und Bezirk und anhand der numerischen Distanz für Jahr, Monat und Tag der Geburt abgeglichen. Als Schwellenwert für die Übereinstimmung wurde eine Wahrscheinlichkeit von 95 % festgelegt.

```{r, message=F, warning=F}
fl_output <- fastLink::fastLink(
  dfA = cases,
  dfB = results,
  varnames = c("gender", "first", "middle", "last", "yr", "mon", "day", "district"),
  stringdist.match = c("first", "middle", "last", "district"),
  numeric.match = c("yr", "mon", "day"),
  threshold.match = 0.95)
```

**Überprüfung Spiele**

Wir haben das Objekt definiert, das von `fastLink()` als `fl_output`. Es ist von der Klasse `list` und enthält mehrere Datenrahmen, in denen die Ergebnisse des Abgleichs festgehalten werden. Einer dieser Datenrahmen ist `matches` Er enthält die wahrscheinlichsten Übereinstimmungen aus `cases` und `results`. Du kannst auf diesen "Matches"-Datenrahmen zugreifen mit `fl_output$matches`. Unten wird er gespeichert als `my_matches` gespeichert, damit du später leichter darauf zugreifen kannst.

Wenn `my_matches` gedruckt wird, siehst du zwei Spaltenvektoren: die Paare von Zeilennummern/Indizes (auch "rownames" genannt) in `cases` ("inds.a") und in `results` ("inds.b"), die die besten Übereinstimmungen darstellen. Wenn eine Zeilennummer aus einem Datenrahmen fehlt, wurde in dem anderen Datenrahmen keine Übereinstimmung mit der angegebenen Übereinstimmungsschwelle gefunden.

```{r}
# print matches
my_matches <- fl_output$matches
my_matches
```

Dinge, die du beachten solltest:

- Es gab Übereinstimmungen trotz leichter Unterschiede in der Schreibweise der Namen und der Geburtsdaten:
  - "Tony B. Smith" wurde mit "Anthony B. Smith" abgeglichen.
  - "Maria Rodriguez" mit "Marialisa Rodrigues" abgeglichen
  - "Betty Chase" mit "Elizabeth Chase" abgeglichen
  - "Olivier Laurent De Bordeaux" mit "Oliver Laurent De Bordow" abgeglichen (fehlendes Geburtsdatum ignoriert)
- Eine Zeile von `cases` (für "Blessing Adebayo", Zeile 9) hatte keine gute Übereinstimmung in `results` und ist daher nicht vorhanden in `my_matches`.

**Join basierend auf den probabilistischen Übereinstimmungen**

Um diese Übereinstimmungen für den Join zu verwenden `results` zu `cases` zu verbinden, ist eine Strategie:

1) Nutze `left_join()` zum Verbinden `my_matches` zu `cases` (passende rownames in `cases` zu "inds.a" in `my_matches`)
2) Verwenden Sie dann eine andere `left_join()` um zu verbinden `results` zu `cases` (passend zu der neu erworbenen "inds.b" in `cases` zu rownames in `results`)

Vor der Verknüpfung sollten wir die drei Datenrahmen bereinigen:

- Beide `dfA` und `dfB` sollten ihre Zeilennummern ("rowname") in eine richtige Spalte umgewandelt werden.
- Sowohl die Spalten in `my_matches` werden in Klassenzeichen umgewandelt, so dass sie mit den Zeichenrownamen verbunden werden können

```{r}
# Clean data prior to joining
#############################

# convert cases rownames to a column 
cases_clean <- cases %>% rownames_to_column()

# convert test_results rownames to a column
results_clean <- results %>% rownames_to_column()  

# convert all columns in matches dataset to character, so they can be joined to the rownames
matches_clean <- my_matches %>%
  mutate(across(everything(), as.character))



# Join matches to dfA, then add dfB
###################################
# column "inds.b" is added to dfA
complete <- left_join(cases_clean, matches_clean, by = c("rowname" = "inds.a"))

# column(s) from dfB are added 
complete <- left_join(complete, results_clean, by = c("inds.b" = "rowname"))
```

Wie mit dem obigen Code ausgeführt, wird der resultierende Datenrahmen `complete` enthalten *alle* Spalten aus beiden `cases` und `results`. Viele werden mit den Suffixen ".x" und ".y" angehängt, weil die Spaltennamen sonst doppelt vorkommen würden.

```{r, message=FALSE, echo=F}
DT::datatable(complete, rownames = FALSE, options = list(pageLength = nrow(complete), scrollX=T), class = 'white-space: nowrap')
```

Alternativ kannst du auch nur die "ursprünglichen" 9 Datensätze in `cases` mit der/den neuen Spalte(n) aus `results` zu erhalten, verwende `select()` auf `results` vor den Joins ein, so dass es nur rownames und die Spalten enthält, die du hinzufügen willst `cases` hinzufügen willst (z.B. die Spalte `result`).

```{r}
cases_clean <- cases %>% rownames_to_column()

results_clean <- results %>%
  rownames_to_column() %>% 
  select(rowname, result)    # select only certain columns 

matches_clean <- my_matches %>%
  mutate(across(everything(), as.character))

# joins
complete <- left_join(cases_clean, matches_clean, by = c("rowname" = "inds.a"))
complete <- left_join(complete, results_clean, by = c("inds.b" = "rowname"))
```

```{r, message=FALSE, echo=F}
DT::datatable(complete, rownames = FALSE, options = list(pageLength = nrow(complete), scrollX=T), class = 'white-space: nowrap')
```

Wenn du einen der beiden Datensätze nur auf die übereinstimmenden Zeilen beschränken willst, kannst du die folgenden Codes verwenden:

```{r}
cases_matched <- cases[my_matches$inds.a,]  # Rows in cases that matched to a row in results
results_matched <- results[my_matches$inds.b,]  # Rows in results that matched to a row in cases
```

Oder, um nur die übereinstimmenden Zeilen zu sehen **nicht** übereinstimmen:

```{r}
cases_not_matched <- cases[!rownames(cases) %in% my_matches$inds.a,]  # Rows in cases that did NOT match to a row in results
results_not_matched <- results[!rownames(results) %in% my_matches$inds.b,]  # Rows in results that did NOT match to a row in cases
```

### Probabilistische Deduplizierung {.unnumbered}

Der probabilistische Abgleich kann auch zur Deduplizierung eines Datensatzes verwendet werden. Weitere Methoden zur Deduplizierung findest du auf der Seite zur Deduplizierung.

Hier haben wir mit der `cases` Datensatz, nennen ihn aber jetzt `cases_dup` da er 2 zusätzliche Zeilen enthält, die Duplikate der vorherigen Zeilen sein könnten:
Siehe "Tony" mit "Anthony", und "Marialisa Rodrigues" mit "Maria Rodriguez".

```{r, echo=F}
## Add duplicates
#cases_dup <- rbind(cases, cases[sample(1:nrow(cases), 3, replace = FALSE),])

cases_dup <- tribble(
  ~gender, ~first,      ~middle,     ~last,        ~yr,   ~mon, ~day, ~district,
  "M",     "Amir",      NA,          "Khan",       1989,  11,   22,   "River",
  "M",     "Anthony",   "B.",        "Smith",      1970, 09, 19,      "River", 
  "F",     "Marialisa", "Contreras", "Rodrigues",  1972, 04, 15,      "River",
  "F",     "Elizabeth", "Casteel",   "Chase",      1954, 03, 03,      "City",
  "M",     "Jose",      "Sanchez",   "Lopez",      1996, 01, 06,      "City",
  "F",     "Cassidy",   "Jones",      "Davis",     1980, 07, 20,      "City",
  "M",     "Michael",   "Murphy",     "O'Calaghan",1969, 04, 12,      "Rural", 
  "M",     "Oliver",    "Laurent",    "De Bordow" , 1971, 02, 04,     "River",
  "F",      "Blessing",  NA,          "Adebayo",   1955,  02, 14,     "Rural",
  "M",     "Tony",   "B.",        "Smith",         1970, 09, 19,      "River", 
  "F",     "Maria",  "Contreras", "Rodriguez",     1972, 04, 15,      "River",
)

```

```{r, message=FALSE, echo=F}
DT::datatable(cases_dup, rownames = FALSE, options = list(pageLength = nrow(cases_dup)))
```

Führe  aus. `fastLink()` wie zuvor, aber vergleiche die `cases_dup` Datenrahmen mit sich selbst. Wenn die beiden bereitgestellten Datenrahmen identisch sind, geht die Funktion davon aus, dass du die Duplikate entfernen willst. Beachte, dass wir nicht angeben `stringdist.match = ` oder `numeric.match = ` wie wir es zuvor getan haben.

```{r, message=F, warning=F}
## Run fastLink on the same dataset
dedupe_output <- fastLink(
  dfA = cases_dup,
  dfB = cases_dup,
  varnames = c("gender", "first", "middle", "last", "yr", "mon", "day", "district")
)
```

Jetzt kannst du die potenziellen Duplikate mit `getMatches()`. Gib den Datenrahmen als beides an `dfA = ` und `dfB = ` an, und stellen Sie die Ausgabe der `fastLink()` Funktion als `fl.out = `. `fl.out` muss von der Klasse sein `fastLink.dedupe` sein, oder in anderen Worten, das Ergebnis von `fastLink()`.

```{r}
## Run getMatches()
cases_dedupe <- getMatches(
  dfA = cases_dup,
  dfB = cases_dup,
  fl.out = dedupe_output)
```

In der Spalte ganz rechts siehst du die doppelten IDs - die letzten beiden Zeilen sind als wahrscheinliche Duplikate der Zeilen 2 und 3 gekennzeichnet.

```{r, message=FALSE, echo=F}
DT::datatable(cases_dedupe, rownames = FALSE, options = list(pageLength = nrow(cases_dedupe)))
```

Um die Zeilennummern der Zeilen zu ermitteln, die wahrscheinlich Duplikate sind, kannst du die Anzahl der Zeilen pro eindeutigem Wert in der `dedupe.ids` Spalte zählen und dann filtern, um nur die Zeilen mit mehr als einem Wert zu erhalten. In diesem Fall bleiben also die Zeilen 2 und 3 übrig.

```{r}
cases_dedupe %>% 
  count(dedupe.ids) %>% 
  filter(n > 1)
```

Um die ganzen Zeilen mit den wahrscheinlichen Duplikaten zu prüfen, gibst du die Zeilennummer in diesen Befehl ein:

```{r}
# displays row 2 and all likely duplicates of it
cases_dedupe[cases_dedupe$dedupe.ids == 2,]   
```

## Binden und Ausrichten

Eine andere Methode, um zwei Datenrahmen zu kombinieren, ist das "Binden" der beiden. Du kannst dir das auch als "Anhängen" oder "Hinzufügen" von Zeilen oder Spalten vorstellen.

In diesem Abschnitt geht es auch darum, wie du die Reihenfolge der Zeilen eines Datenrahmens an die Reihenfolge des anderen Datenrahmens anpasst. Dieses Thema wird weiter unten im Abschnitt über das Binden von Spalten behandelt.

### Zeilen binden {.unnumbered}

Um Zeilen eines Datenrahmens mit dem Boden eines anderen Datenrahmens zu verbinden, verwendest du `bind_rows()` von **dplyr**. Sie ist sehr umfassend, d.h. jede Spalte, die in einem der beiden Datenrahmen vorhanden ist, wird in der Ausgabe berücksichtigt. Ein paar Hinweise:

- Anders als bei der **Basis** R-Version `row.bind()`, **dplyr**'s `bind_rows()` verlangt nicht, dass die Reihenfolge der Spalten in beiden Datenrahmen gleich ist. Solange die Spaltennamen identisch geschrieben sind, werden sie korrekt ausgerichtet.
- Du kannst optional das Argument `.id = `. Gib einen Spaltennamen an. Dadurch wird eine neue Spalte erzeugt, die dazu dient, zu identifizieren, aus welchem Datenrahmen jede Zeile ursprünglich stammt.
- Du kannst verwenden `bind_rows()` auf eine `list`von ähnlich strukturierten Datenrahmen verwenden, um sie zu einem Datenrahmen zusammenzufassen. Ein Beispiel findest du im Kapitel [Iteration, Schleifen und Listen] Seite, bei dem es um den Import von mehreren Zeilenlisten mit**purrr**.

Ein gängiges Beispiel für die Zeilenbindung ist die Bindung einer "Gesamt"-Zeile an eine beschreibende Tabelle, die mit **dplyr**'s `summarise()` Funktion. Im Folgenden erstellen wir eine Tabelle mit den Fallzahlen und dem Median der CT-Werte nach Krankenhaus mit einer Gesamtzeile.

Die Funktion `summarise()` wird auf die nach Krankenhaus gruppierten Daten angewendet, um einen zusammenfassenden Datenrahmen nach Krankenhaus zu erstellen. Aber die Funktion `summarise()` erzeugt nicht automatisch eine "Summen"-Zeile, also erstellen wir sie, indem wir die Daten zusammenfassen *wieder* aber die Daten werden nicht nach Krankenhaus gruppiert. So entsteht ein zweiter Datenrahmen mit nur einer Zeile. Wir können diese Datenrahmen dann miteinander verbinden, um die endgültige Tabelle zu erhalten.

Weitere Beispiele dieser Art findest du in der [Beschreibende Tabellen] und [Tabellen für die Präsentation] Seiten.

```{r}
# Create core table
###################
hosp_summary <- linelist %>% 
  group_by(hospital) %>%                        # Group data by hospital
  summarise(                                    # Create new summary columns of indicators of interest
    cases = n(),                                  # Number of rows per hospital-outcome group     
    ct_value_med = median(ct_blood, na.rm=T))     # median CT value per group
```

Hier ist die `hosp_summary` Datenrahmen:

```{r, message=FALSE, echo=F}
DT::datatable(hosp_summary, rownames = FALSE, options = list(pageLength = nrow(10)))
```

Erstelle einen Datenrahmen mit der "Gesamt"-Statistik (*nicht gruppiert nach Krankenhaus*). Dies wird nur eine Zeile ergeben.

```{r}
# create totals
###############
totals <- linelist %>% 
  summarise(
    cases = n(),                               # Number of rows for whole dataset     
    ct_value_med = median(ct_blood, na.rm=T))  # Median CT for whole dataset
```

Und darunter ist das `totals` Datenrahmen. Beachte, dass es nur zwei Spalten gibt. Diese Spalten sind auch in `hosp_summary` enthalten, aber es gibt eine Spalte in `hosp_summary` die nicht in `totals` (`hospital`).

```{r, message=FALSE, echo=F}
DT::datatable(totals, rownames = FALSE, options = list(pageLength = nrow(10)))
```

Jetzt können wir die Zeilen zusammenbinden mit `bind_rows()`.

```{r}
# Bind data frames together
combined <- bind_rows(hosp_summary, totals)
```

Jetzt können wir uns das Ergebnis ansehen. Du siehst, dass in der letzten Zeile eine leere `NA` Wert für die Spalte ausgefüllt wird `hospital` die nicht in `hosp_summary`. Wie in den [Tabellen für die Präsentation] Seite erklärt wird, kannst du diese Zelle mit "Gesamt" ausfüllen, indem du`replace_na()`.

```{r, message=FALSE, echo=F}
DT::datatable(combined, rownames = FALSE, options = list(pageLength = nrow(10)))
```

### Spalten binden {.unnumbered}

Es gibt eine ähnliche **dplyr** Funktion `bind_cols()` die du verwenden kannst, um zwei Datenrahmen seitlich zu kombinieren. Beachte, dass die Zeilen aneinander angepasst werden *nach Position* (nicht wie bei einem *join* oben) - zum Beispiel wird die 12. Zeile in jedem Datenrahmen ausgerichtet.

In einem Beispiel verbinden wir mehrere Übersichtstabellen miteinander. Dazu zeigen wir auch, wie man die Reihenfolge der Zeilen in einem Datenrahmen so anordnet, dass sie der Reihenfolge in einem anderen Datenrahmen entspricht, mit `match()`.

Hier definieren wir `case_info` als einen zusammenfassenden Datenrahmen mit der Anzahl der Fälle und der Anzahl der Todesfälle, aufgeschlüsselt nach Krankenhäusern.

```{r}
# Case information
case_info <- linelist %>% 
  group_by(hospital) %>% 
  summarise(
    cases = n(),
    deaths = sum(outcome == "Death", na.rm=T)
  )
```

```{r, message=FALSE, echo=F}
DT::datatable(case_info, rownames = FALSE, options = list(pageLength = nrow(10)))
```

Und nehmen wir an, dass hier ein anderer Datenrahmen ist `contact_fu` der Informationen über den Prozentsatz der exponierten Kontakte enthält, die untersucht und "weiterverfolgt" wurden, wiederum nach Krankenhaus.

```{r}
contact_fu <- data.frame(
  hospital = c("St. Mark's Maternity Hospital (SMMH)", "Military Hospital", "Missing", "Central Hospital", "Port Hospital", "Other"),
  investigated = c("80%", "82%", NA, "78%", "64%", "55%"),
  per_fu = c("60%", "25%", NA, "20%", "75%", "80%")
)
```

```{r, message=FALSE, echo=F}
DT::datatable(contact_fu, rownames = FALSE, options = list(pageLength = nrow(10)))
```

Die Krankenhäuser sind zwar dieselben, aber in jedem Datenrahmen in einer anderen Reihenfolge. Die einfachste Lösung wäre die Verwendung eines `left_join()` auf die `hospital` Spalte zu verwenden, aber du könntest auch `bind_cols()` mit einem zusätzlichen Schritt.

#### Verwende `match()` um die Bestellung auszurichten {.unnumbered}

Da die Reihenfolgen unterschiedlich sind, kann eine einfache `bind_cols()` Befehl dazu führen, dass die Daten nicht übereinstimmen. Um dies zu beheben, können wir verwenden `match()` von **Basis** R, um die Zeilen eines Datenrahmens in der gleichen Reihenfolge wie in einem anderen auszurichten. Wir gehen bei diesem Ansatz davon aus, dass es in beiden Datenrahmen keine doppelten Werte gibt.

Wenn wir `match()` verwenden, lautet die Syntax `match(TARGET ORDER VECTOR, DATA FRAME COLUMN TO CHANGE)` wobei das erste Argument die gewünschte Reihenfolge ist (entweder ein eigenständiger Vektor oder in diesem Fall eine Spalte in einem Datenrahmen) und das zweite Argument die Spalte im Datenrahmen, die neu geordnet werden soll. Die Ausgabe von `match()` ist ein Zahlenvektor, der die korrekte Positionsreihenfolge angibt. Du kannst mehr lesen mit `?match`.

```{r}
match(case_info$hospital, contact_fu$hospital)
```

Du kannst diesen numerischen Vektor verwenden, um den Datenrahmen neu zu ordnen - platziere ihn in Untermengenklammern `[ ]` *vor dem Komma*. Lies mehr über **Basis**R Klammer-Subset-Syntax in den [R-Grundlagen] Seite. Der folgende Befehl erstellt einen neuen Datenrahmen, der als der alte Datenrahmen definiert ist, in dem die Zeilen im obigen numerischen Vektor geordnet sind.

```{r}
contact_fu_aligned <- contact_fu[match(case_info$hospital, contact_fu$hospital),]
```

```{r, message=FALSE, echo=F}
DT::datatable(contact_fu_aligned, rownames = FALSE, options = list(pageLength = nrow(10)))
```

Jetzt können wir die Spalten des Datenrahmens in der richtigen Zeilenreihenfolge miteinander verbinden. Beachte, dass einige Spalten doppelt vorhanden sind und mit dem folgenden Befehl bereinigt werden müssen `rename()`. Lies mehr über `bind_rows()` [hier](https://dplyr.tidyverse.org/reference/bind.html).

```{r}
bind_cols(case_info, contact_fu)
```

A **Basis** R Alternative zu `bind_cols` ist `cbind()` die den gleichen Vorgang durchführt.

<!-- ======================================================= -->

## Ressourcen { }

Die [tidyverse Seite über Verbindungen](https://dplyr.tidyverse.org/reference/join.html)

Die [R for Data Science Seite über relationale Daten](https://r4ds.had.co.nz/relational-data.html)

Th [tidyverse Seite auf dplyr](https://dplyr.tidyverse.org/reference/bind.html) über Bindung

Eine Vignette auf [fastLink](https://github.com/kosukeimai/fastLink) auf der Github-Seite des Pakets

Veröffentlichung zur Beschreibung der Methodik von [fastLink](https://imai.fas.harvard.edu/research/files/linkage.pdf)

Die Veröffentlichung beschreibt [RecordLinkage Paket](https://journal.r-project.org/archive/2010/RJ-2010-017/RJ-2010-017.pdf)


