# Epidemische Kurven { }

```{r, out.width=c("75%"), echo=F, message=F}
knitr::include_graphics(here::here("images", "epicurve_top.png"))
```

Eine Epidemiekurve (auch "Epikurve" genannt) ist ein epidemiologisches Kerndiagramm, das typischerweise verwendet wird, um das zeitliche Muster des Auftretens von Krankheiten in einer Gruppe oder Epidemie von Fällen zu visualisieren.

Die Analyse der Epikurve kann zeitliche Trends, Ausreißer, das Ausmaß des Ausbruchs, den wahrscheinlichsten Zeitraum der Exposition und die Zeitintervalle zwischen den Fallgenerationen aufzeigen und sogar dabei helfen, die Art der Übertragung einer noch nicht identifizierten Krankheit zu bestimmen (z. B. Punktquelle, kontinuierliche gemeinsame Quelle, Ausbreitung von Mensch zu Mensch). Eine Online-Lektion zur Interpretation von Epi-Kurven findest du auf der Website der [US CDC](https://www.cdc.gov/training/quicklearns/epimode/index.html).

Auf dieser Seite zeigen wir die Erstellung von Epidemiekurven mit dem **ggplot2** Paket, das erweiterte Anpassungsmöglichkeiten bietet.

Außerdem werden spezielle Anwendungsfälle behandelt, wie z. B.:

- Plotten von aggregierten Zähldaten
- Facettieren oder Small-Multiples erzeugen
- Gleitende Durchschnitte anwenden
- Aufzeigen, welche Daten "vorläufig" sind oder mit Verzögerungen gemeldet werden müssen
- Überlagerung der kumulativen Fallinzidenz mit einer zweiten Achse

Die **Inzidenz2** Paket bietet eine alternative Herangehensweise mit einfacheren Befehlen, wurde aber zum Zeitpunkt der Erstellung dieses Artikels überarbeitet und war noch nicht stabil. Sobald es stabil ist, wird es diesem Kapitel wieder hinzugefügt.

<!-- ======================================================= -->

## Vorbereitung

### Pakete {.unnumbered}

Dieser Codechunk zeigt das Laden der Pakete, die für die Analysen benötigt werden. In diesem Handbuch betonen wir `p_load()` von **pacman**, der das Paket bei Bedarf installiert *und* lädt es zur Verwendung. Du kannst installierte Pakete auch laden mit `library()` von **base**R. Siehe die Seite über [R-Grundlagen] für weitere Informationen über R-Pakete.

```{r, message=F, warning=F}
pacman::p_load(
  rio,          # file import/export
  here,         # relative filepaths 
  lubridate,    # working with dates/epiweeks
  aweek,        # alternative package for working with dates/epiweeks
  incidence2,   # epicurves of linelist data
  i2extras,     # supplement to incidence2
  stringr,      # search and manipulate character strings
  forcats,      # working with factors
  RColorBrewer, # Color palettes from colorbrewer2.org
  tidyverse     # data management + ggplot2 graphics
) 
```

### Daten importieren {.unnumbered}

In diesem Abschnitt werden zwei Beispieldatensätze verwendet:

- Eine Liste von Einzelfällen aus einer simulierten Epidemie
- Aggregierte Zählungen nach Krankenhaus aus der gleichen simulierten Epidemie

Die Datensätze werden mit der Methode `import()` Funktion aus der **rio**Paket. Siehe die Seite über [Import und Export] für verschiedene Möglichkeiten, Daten zu importieren.

```{r, echo=F, message=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the counts data into R
count_data <- linelist %>% 
  group_by(hospital, date_hospitalisation) %>% 
  summarize(n_cases = dplyr::n()) %>% 
  filter(date_hospitalisation > as.Date("2013-06-01")) %>% 
  ungroup()
```

**Fall-Lineliste**

Wir importieren den Datensatz der Fälle aus einer simulierten Ebola-Epidemie. Wenn du die Daten herunterladen möchtest, um Schritt für Schritt vorzugehen, lies die Anleitung im [Handbuch und Daten herunterladen] Seite. Wir gehen davon aus, dass sich die Datei im Arbeitsverzeichnis befindet, also werden in diesem Dateipfad keine Unterordner angegeben.

```{r, eval=F}
linelist <- import("linelist_cleaned.xlsx")
```

Die ersten 50 Zeilen werden unten angezeigt.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

**Fallzahlen aggregiert nach Krankenhaus**

Für die Zwecke des Handbuchs wird der Datensatz der wöchentlich aggregierten Fallzahlen nach Krankenhaus aus den `linelist` mit dem folgenden Code erstellt.

```{r, eval=F}
# import the counts data into R
count_data <- linelist %>% 
  group_by(hospital, date_hospitalisation) %>% 
  summarize(n_cases = dplyr::n()) %>% 
  filter(date_hospitalisation > as.Date("2013-06-01")) %>% 
  ungroup()
```

Die ersten 50 Zeilen werden unten angezeigt:

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(count_data, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Parameter einstellen {.unnumbered}

Für die Erstellung eines Berichts möchtest du vielleicht bearbeitbare Parameter wie das Datum, für das die Daten aktuell sind (das "Datumsdatum"), festlegen. Du kannst dann auf das Objekt `data_date` in deinem Code referenzieren, wenn du Filter oder dynamische Beschriftungen anwendest.

```{r set_parameters}
## set the report date for the report
## note: can be set to Sys.Date() for the current date
data_date <- as.Date("2015-05-15")
```

### Daten überprüfen {.unnumbered}

Überprüfe, ob jede relevante Datumsspalte der Klasse Datum angehört und einen geeigneten Wertebereich hat. Du kannst dies einfach mit `hist()` für Histogramme, oder `range()` mit `na.rm=TRUE`, oder mit `ggplot()` wie unten.

```{r, out.width=c("50%", "50%", "50%"), fig.show="hold", warning=F, message=F}
# check range of onset dates
ggplot(data = linelist)+
  geom_histogram(aes(x = date_onset))
```

<!-- ======================================================= -->

## Epikurven mit ggplot2 { }

verwenden `ggplot()` um deine Epikurve zu erstellen, bietet Flexibilität und Anpassungsmöglichkeiten, erfordert aber mehr Aufwand und Verständnis dafür, wie `ggplot()` funktioniert.

Du musst *manuell* die Aggregation der Fälle nach Zeit (in Wochen, Monaten usw.) steuern *und* die Abstände der Beschriftungen auf der Datumsachse. Dies muss sorgfältig gesteuert werden.

Diese Beispiele verwenden eine Teilmenge der `linelist` Datensatzes - nur die Fälle aus dem Zentralkrankenhaus.

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r}
central_data <- linelist %>% 
  filter(hospital == "Central Hospital")
```

```{r, eval=F, echo=F}
detach("package:tidyverse", unload=TRUE)
library(tidyverse)
```

Zur Erstellung einer Epikurve mit `ggplot()` zu erstellen, gibt es drei Hauptelemente:

- Ein Histogramm, in dem die Fälle der Linienliste in "Bins" zusammengefasst werden, die sich durch bestimmte "Break"-Punkte unterscheiden
- Skalen für die Achsen und ihre Beschriftungen
- Themen für das Erscheinungsbild des Plots, einschließlich Titel, Beschriftungen, Beschriftungen usw.

### Fallkästen festlegen {.unnumbered}

Hier zeigen wir dir, wie du die Fälle in Histogramm-Bins ("Balken") zusammenfasst. Es ist wichtig zu wissen, dass die Aggregation von Fällen in Histogramm-Bins **nicht** nicht unbedingt die gleichen Intervalle sind wie die Daten, die auf der x-Achse erscheinen.

Im Folgenden findest du den vielleicht einfachsten Code, um tägliche und wöchentliche Epikurven zu erstellen.

In der übergreifenden `ggplot()` Befehl wird der Datensatz an `data = `. Auf dieser Grundlage wird die Geometrie eines Histogramms mit einem `+`. Innerhalb der `geom_histogram()` bilden wir die Ästhetik so ab, dass die Spalte `date_onset` auf die x-Achse abgebildet wird. Auch innerhalb der `geom_histogram()` aber *nicht* innerhalb `aes()` setzen wir die `binwidth =` der Histogramm-Bins, in Tagen. Wenn diese **ggplot2**Syntax verwirrend ist, lies die Seite über [ggplot-Grundlagen].

<span style="color: orange;">***VORSICHT!*** Das Plotten wöchentlicher Fälle mit Hilfe von `binwidth = 7` beginnt der erste 7-Tage-Bin mit dem ersten Fall, der ein beliebiger Wochentag sein kann! Um bestimmte Wochen zu erstellen, siehe Abschnitt unten.</span>

```{r ggplot_simple, out.width=c("50%", "50%"), fig.show="hold", warning=F, message=F}
# daily 
ggplot(data = central_data) +          # set data
  geom_histogram(                      # add histogram
    mapping = aes(x = date_onset),     # map date column to x-axis
    binwidth = 1)+                     # cases binned by 1 day 
  labs(title = "Central Hospital - Daily")                # title

# weekly
ggplot(data = central_data) +          # set data 
  geom_histogram(                      # add histogram
      mapping = aes(x = date_onset),   # map date column to x-axis
      binwidth = 7)+                   # cases binned every 7 days, starting from first case (!) 
  labs(title = "Central Hospital - 7-day bins, starting at first case") # title
```

Der erste Fall in diesem Datensatz des Zentralkrankenhauses hat seine Symptome am ersten Tag gezeigt:

```{r}
format(min(central_data$date_onset, na.rm=T), "%A %d %b, %Y")
```

**Um die Histogramm-Bin-Breaks manuell festzulegen, tippe auf *nicht* verwenden Sie die `binwidth = ` Argument und übergibt stattdessen einen Vektor von Daten an `breaks = `.**

Erstelle den Datumsvektor mit der Option **Basis** R-Funktion `seq.Date()`. Diese Funktion erwartet Argumente `to = `, `from = `, und `by = `. Der folgende Befehl liefert zum Beispiel monatliche Daten, die am 15. Januar beginnen und am 28. Juni enden.

```{r}
monthly_breaks <- seq.Date(from = as.Date("2014-02-01"),
                           to = as.Date("2015-07-15"),
                           by = "months")

monthly_breaks   # print
```

Dieser Vektor kann geliefert werden an `geom_histogram()` als `breaks = `:

```{r, warning=F, message=F}
# monthly 
ggplot(data = central_data) +  
  geom_histogram(
    mapping = aes(x = date_onset),
    breaks = monthly_breaks)+         # provide the pre-defined vector of breaks                    
  labs(title = "Monthly case bins")   # title
```

Eine einfache wöchentliche Datumsfolge kann zurückgegeben werden, indem man `by = "week"`. Zum Beispiel:

```{r}
weekly_breaks <- seq.Date(from = as.Date("2014-02-01"),
                          to = as.Date("2015-07-15"),
                          by = "week")
```

Eine Alternative zur Angabe eines bestimmten Start- und Enddatums ist es, zu schreiben *dynamischen* Code so zu schreiben, dass die wöchentlichen Bins beginnen *der Montag vor dem ersten Fall*. **Wir werden diese Datumsvektoren in den folgenden Beispielen verwenden.**

```{r}
# Sequence of weekly Monday dates for CENTRAL HOSPITAL
weekly_breaks_central <- seq.Date(
  from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 1), # monday before first case
  to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 1), # monday after last case
  by   = "week")
```

Packen wir den ziemlich entmutigenden Code oben aus:

- Der "von"-Wert (frühestes Datum der Sequenz) wird wie folgt erstellt: Der minimale Datumswert (`min()` mit `na.rm=TRUE`) in der Spalte `date_onset` wird gefüttert mit `floor_date()` von der **lubridate** Paket. `floor_date()` auf "Woche" gesetzt, gibt das Startdatum der "Woche" dieses Falls zurück, da der Starttag jeder Woche ein Montag ist (`week_start = 1`).
- Ebenso wird der "bis"-Wert (Enddatum der Folge) mit der umgekehrten Funktion erstellt `ceiling_date()` erstellt, um den Montag zurückzugeben *nach* dem letzten Fall.
- Das "by"-Argument von `seq.Date()` kann auf eine beliebige Anzahl von Tagen, Wochen oder Monaten gesetzt werden.
- verwenden `week_start = 7` für Sonntagswochen

Da wir diese Datumsvektoren auf dieser Seite durchgängig verwenden werden, definieren wir auch einen für den gesamten Ausbruch (der obige ist nur für das Central Hospital).

```{r}
# Sequence for the entire outbreak
weekly_breaks_all <- seq.Date(
  from = floor_date(min(linelist$date_onset, na.rm=T),   "week", week_start = 1), # monday before first case
  to   = ceiling_date(max(linelist$date_onset, na.rm=T), "week", week_start = 1), # monday after last case
  by   = "week")
```

Diese `seq.Date()` Ausgaben können verwendet werden, um Histogramm-Bin-Breaks zu erstellen, aber auch die Breaks für die Datumsbeschriftungen, die unabhängig von den Bins sein können. Mehr über die Datumsbeschriftungen erfährst du in späteren Abschnitten.

<span style="color: darkgreen;">***TIPP:*** Für eine einfachere `ggplot()` Befehl zu verwenden, speichere die Bin-Breaks und die Datumslabel-Breaks im Voraus als benannte Vektoren und gib ihre Namen einfach an `breaks = `.</span>

### Wöchentliches Epikurvenbeispiel {.unnumbered}

**Im Folgenden findest du einen detaillierten Beispielcode, um wöchentliche Epikurven für Montagswochen zu erstellen, mit ausgerichteten Balken, Datumsbeschriftungen und vertikalen Gitternetzlinien.** Dieser Abschnitt ist für Nutzer gedacht, die den Code schnell brauchen. Um die einzelnen Aspekte (Themen, Datumsbeschriftungen usw.) im Detail zu verstehen, lies die folgenden Abschnitte. Zu beachten:

- Die *Histogramm-Bin-Breaks* sind definiert mit `seq.Date()` wie oben erklärt, um am Montag vor dem frühesten Fall zu beginnen und am Montag nach dem letzten Fall zu enden
- Das Intervall von *Datumsangaben* wird festgelegt durch `date_breaks =` innerhalb von `scale_x_date()`
- Der Abstand der kleinen vertikalen Rasterlinien zwischen den Datumsbeschriftungen wird festgelegt auf `date_minor_breaks = `
- Wir verwenden `closed = "left"` in der `geom_histogram()` um sicherzustellen, dass die Daten in den richtigen Behältern gezählt werden
- `expand = c(0,0)` in der x- und y-Skala entfernt überschüssigen Platz auf jeder Seite der Achsen, wodurch auch sichergestellt wird, dass die Datumsbeschriftungen mit dem ersten Balken beginnen.

```{r, warning=F, message=F}
# TOTAL MONDAY WEEK ALIGNMENT
#############################
# Define sequence of weekly breaks
weekly_breaks_central <- seq.Date(
      from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 1), # Monday before first case
      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 1), # Monday after last case
      by   = "week")    # bins are 7-days 


ggplot(data = central_data) + 
  
  # make histogram: specify bin break points: starts the Monday before first case, end Monday after last case
  geom_histogram(
    
    # mapping aesthetics
    mapping = aes(x = date_onset),  # date column mapped to x-axis
    
    # histogram bin breaks
    breaks = weekly_breaks_central, # histogram bin breaks defined previously
      
    closed = "left",  # count cases from start of breakpoint
    
    # bars
    color = "darkblue",     # color of lines around bars
    fill = "lightblue"      # color of fill within bars
  )+ 
    
  # x-axis labels
  scale_x_date(
    expand            = c(0,0),           # remove excess x-axis space before and after case bars
    date_breaks       = "4 weeks",        # date labels and major vertical gridlines appear every 3 Monday weeks
    date_minor_breaks = "week",           # minor vertical lines appear every Monday week
    date_labels       = "%a\n%d %b\n%Y")+ # date labels format
  
  # y-axis
  scale_y_continuous(
    expand = c(0,0))+             # remove excess y-axis space below 0 (align histogram flush with x-axis)
  
  # aesthetic themes
  theme_minimal()+                # simplify plot background
  
  theme(
    plot.caption = element_text(hjust = 0,        # caption on left side
                                face = "italic"), # caption in italics
    axis.title = element_text(face = "bold"))+    # axis titles in bold
  
  # labels including dynamic caption
  labs(
    title    = "Weekly incidence of cases (Monday weeks)",
    subtitle = "Note alignment of bars, vertical gridlines, and axis labels on Monday weeks",
    x        = "Week of symptom onset",
    y        = "Weekly incident cases reported",
    caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```

#### Sonntagswochen {.unnumbered}

Um die obige Darstellung für Sonntagswochen zu erreichen, sind ein paar Änderungen erforderlich, denn die `date_breaks = "weeks"` nur für Montagswochen funktionieren.

- Die Haltepunkte der *Histogramm-Bins* müssen auf Sonntage gesetzt werden (`week_start = 7`)
- Innerhalb von `scale_x_date()` sollten die ähnlichen Datumsunterbrechungen zur Verfügung gestellt werden `breaks =` und `minor_breaks = ` um sicherzustellen, dass die Datumsbeschriftungen und vertikalen Rasterlinien an Sonntagen ausgerichtet sind.

Zum Beispiel kann die `scale_x_date()` Befehl für Sonntagswochen könnte zum Beispiel so aussehen:

```{r, eval=F}
scale_x_date(
    expand = c(0,0),
    
    # specify interval of date labels and major vertical gridlines
    breaks = seq.Date(
      from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7), # Sunday before first case
      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7), # Sunday after last case
      by   = "4 weeks"),
    
    # specify interval of minor vertical gridline 
    minor_breaks = seq.Date(
      from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7), # Sunday before first case
      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7), # Sunday after last case
      by   = "week"),
   
    # date label format
    #date_labels = "%a\n%d %b\n%Y")+         # day, above month abbrev., above 2-digit year
    label = scales::label_date_short())+ # automatic label formatting

```

### Gruppieren/Färben nach Wert {.unnumbered}

Die Histogrammbalken können nach Gruppen gefärbt und "gestapelt" werden. Um die Gruppierungsspalte zu bestimmen, nimmst du die folgenden Änderungen vor. Siehe die [ggplot Grundlagen] Seite für Details.

- Innerhalb der ästhetischen Histogramm-Zuordnung `aes()` ordnen Sie den Spaltennamen dem `group = ` und `fill = ` Argumente
- Entfernen Sie alle `fill = ` Argument *außerhalb von* von `aes()` da sie diejenige innerhalb von
- Argumente *innen* `aes()` wird angewendet *nach Gruppen*, während jede *außerhalb* für alle Balken gelten (z.B. kannst du immer noch `color = ` außen, damit jeder Balken den gleichen Rand hat)

Hier ist, was die `aes()` Befehl aussehen würde, um die Balken nach Geschlecht zu gruppieren und einzufärben:

```{r, eval=F}
aes(x = date_onset, group = gender, fill = gender)
```

Hier wird sie angewendet:

```{r, warning=F, message=F}
ggplot(data = linelist) +     # begin with linelist (many hospitals)
  
  # make histogram: specify bin break points: starts the Monday before first case, end Monday after last case
  geom_histogram(
    mapping = aes(
      x = date_onset,
      group = hospital,       # set data to be grouped by hospital
      fill = hospital),       # bar fill (inside color) by hospital
    
    # bin breaks are Monday weeks
    breaks = weekly_breaks_all,   # sequence of weekly Monday bin breaks for whole outbreak, defined in previous code       
    
    closed = "left",          # count cases from start of breakpoint

    # Color around bars
    color = "black")
```

### Farben anpassen {.unnumbered}

- Zu *manuell* die Füllung für jede Gruppe einzustellen, verwendest du `scale_fill_manual()` (beachte: `scale_color_manual()` ist unterschiedlich!).
  - Verwende die `values = ` Argument, um einen Vektor von Farben anzuwenden.
  - verwenden `na.value = ` um eine Farbe anzugeben für `NA` Werte.
  - Verwende die `labels = ` Argument, um den Text der Legendenelemente zu ändern. Um sicher zu gehen, solltest du einen benannten Vektor angeben, wie `c("old" = "new", "old" = "new")` oder passe die Werte in den Daten selbst an.
  - Verwende `name = ` um der Legende einen passenden Titel zu geben
- Weitere Tipps zu Farbskalen und Paletten findest du auf der Seite über [ggplot-Grundlagen].

```{r, warning=F, message=F}
ggplot(data = linelist)+           # begin with linelist (many hospitals)
  
  # make histogram
  geom_histogram(
    mapping = aes(x = date_onset,
        group = hospital,          # cases grouped by hospital
        fill = hospital),          # bar fill by hospital
    
    # bin breaks
    breaks = weekly_breaks_all,    # sequence of weekly Monday bin breaks, defined in previous code
    
    closed = "left",               # count cases from start of breakpoint

    # Color around bars
    color = "black")+              # border color of each bar
  
  # manual specification of colors
  scale_fill_manual(
    values = c("black", "orange", "grey", "beige", "blue", "brown"),
    labels = c("St. Mark's Maternity Hospital (SMMH)" = "St. Mark's"),
    name = "Hospital") # specify fill colors ("values") - attention to order!
```

### Reihenfolge der Ebenen anpassen {.unnumbered}

Die Reihenfolge, in der gruppierte Balken gestapelt werden, lässt sich am besten anpassen, indem du die Gruppierungsspalte als Klasse Faktor klassifizierst. Dann kannst du die Reihenfolge der Faktorebenen (und ihre Beschriftung) festlegen. Siehe die Seite über [Faktoren] oder [ggplot-Tipps] für Details.

Bevor du den Plot erstellst, verwende die `fct_relevel()` Funktion von **forcats**Paket, um die Gruppierungsspalte in einen Klassenfaktor umzuwandeln und die Reihenfolge der Ebenen manuell anzupassen, wie auf der Seite über [Faktoren].

```{r}
# load forcats package for working with factors
pacman::p_load(forcats)

# Define new dataset with hospital as factor
plot_data <- linelist %>% 
  mutate(hospital = fct_relevel(hospital, c("Missing", "Other"))) # Convert to factor and set "Missing" and "Other" as top levels to appear on epicurve top

levels(plot_data$hospital) # print levels in order
```

Im folgenden Diagramm unterscheidet sich nur die Spalte `hospital` wie oben konsolidiert wurde, und wir verwenden `guides()` um die Reihenfolge der Legende umzukehren, so dass "Missing" unten in der Legende steht.

```{r, warning=F, message=F}
ggplot(plot_data) +                     # Use NEW dataset with hospital as re-ordered factor
  
  # make histogram
  geom_histogram(
    mapping = aes(x = date_onset,
        group = hospital,               # cases grouped by hospital
        fill = hospital),               # bar fill (color) by hospital
    
    breaks = weekly_breaks_all,         # sequence of weekly Monday bin breaks for whole outbreak, defined at top of ggplot section
    
    closed = "left",                    # count cases from start of breakpoint

    color = "black")+                   # border color around each bar
    
  # x-axis labels
  scale_x_date(
    expand            = c(0,0),           # remove excess x-axis space before and after case bars
    date_breaks       = "3 weeks",        # labels appear every 3 Monday weeks
    date_minor_breaks = "week",           # vertical lines appear every Monday week
    label = scales::label_date_short()) + # efficient label formatting
  
  # y-axis
  scale_y_continuous(
    expand = c(0,0))+                   # remove excess y-axis space below 0
  
  # manual specification of colors, ! attention to order
  scale_fill_manual(
    values = c("grey", "beige", "black", "orange", "blue", "brown"),
    labels = c("St. Mark's Maternity Hospital (SMMH)" = "St. Mark's"),
    name = "Hospital")+ 
  
  # aesthetic themes
  theme_minimal()+                      # simplify plot background
  
  theme(
    plot.caption = element_text(face = "italic", # caption on left side in italics
                                hjust = 0), 
    axis.title = element_text(face = "bold"))+   # axis titles in bold
  
  # labels
  labs(
    title    = "Weekly incidence of cases by hospital",
    subtitle = "Hospital as re-ordered factor",
    x        = "Week of symptom onset",
    y        = "Weekly cases")
```

<span style="color: darkgreen;">***TIPP:*** Um nur die Reihenfolge der Legende umzukehren, füge Folgendes hinzu **ggplot2** Befehl hinzu: `guides(fill = guide_legend(reverse = TRUE))`.</span>

### Legende anpassen {.unnumbered}

Mehr über Legenden und Skalen findest du in den [ggplot-Tipps] Seite. Hier sind ein paar Highlights:

- Bearbeite den Titel der Legende entweder in der Skalenfunktion oder mit `labs(fill = "Legend title")` (wenn du die Funktion `color = ` Ästhetik verwendest, dann verwende `labs(color = "")`)
- `theme(legend.title = element_blank())` keinen Legendentitel zu haben
- `theme(legend.position = "top")` ("unten", "links", "rechts", oder "keine", um die Legende zu entfernen)
- `theme(legend.direction = "horizontal")` horizontale Legende
- `guides(fill = guide_legend(reverse = TRUE))` um die Reihenfolge der Legende umzukehren

### Balken nebeneinander {.unnumbered}

Die nebeneinander liegende Anzeige von Gruppenleisten (im Gegensatz zur gestapelten Anzeige) wird in `geom_histogram()` mit `position = "dodge"` außerhalb von `aes()`.

Wenn es mehr als zwei Wertegruppen gibt, kann es schwierig werden, diese zu lesen. Erwäge stattdessen eine facettierte Darstellung (kleine Vielfache). Um die Lesbarkeit in diesem Beispiel zu verbessern, wurden fehlende Geschlechterwerte entfernt.

```{r, warning=F, message=F}
ggplot(central_data %>% drop_na(gender))+   # begin with Central Hospital cases dropping missing gender
    geom_histogram(
        mapping = aes(
          x = date_onset,
          group = gender,         # cases grouped by gender
          fill = gender),         # bars filled by gender
        
        # histogram bin breaks
        breaks = weekly_breaks_central,   # sequence of weekly dates for Central outbreak - defined at top of ggplot section
        
        closed = "left",          # count cases from start of breakpoint
        
        color = "black",          # bar edge color
        
        position = "dodge")+      # SIDE-BY-SIDE bars
                      
  
  # The labels on the x-axis
  scale_x_date(expand            = c(0,0),          # remove excess x-axis space below and after case bars
               date_breaks       = "3 weeks",       # labels appear every 3 Monday weeks
               date_minor_breaks = "week",          # vertical lines appear every Monday week
               label = scales::label_date_short())+ # efficient date labels
  
  # y-axis
  scale_y_continuous(expand = c(0,0))+             # removes excess y-axis space between bottom of bars and the labels
  
  #scale of colors and legend labels
  scale_fill_manual(values = c("brown", "orange"),  # specify fill colors ("values") - attention to order!
                    na.value = "grey" )+     

  # aesthetic themes
  theme_minimal()+                                               # a set of themes to simplify plot
  theme(plot.caption = element_text(face = "italic", hjust = 0), # caption on left side in italics
        axis.title = element_text(face = "bold"))+               # axis titles in bold
  
  # labels
  labs(title    = "Weekly incidence of cases, by gender",
       subtitle = "Subtitle",
       fill     = "Gender",                                      # provide new title for legend
       x        = "Week of symptom onset",
       y        = "Weekly incident cases reported")
```

### Achsengrenzen {.unnumbered}

Es gibt zwei Möglichkeiten, den Umfang der Achsenwerte zu begrenzen.

Die bevorzugte Methode ist die Verwendung des Befehls `coord_cartesian()` zu verwenden, der akzeptiert `xlim = c(min, max)` und `ylim = c(min, max)` (wobei du die Mindest- und Höchstwerte angibst). Dies wirkt wie ein "Zoom", ohne tatsächlich Daten zu entfernen, was für Statistiken und zusammenfassende Maße wichtig ist.

Alternativ kannst du maximale und minimale Datumswerte festlegen, indem du `limits = c()` in `scale_x_date()`. Zum Beispiel:

```{r, eval=F}
scale_x_date(limits = c(as.Date("2014-04-01"), NA)) # sets a minimum date but leaves the maximum open.  
```

Wenn du möchtest, dass die x-Achse bis zu einem bestimmten Datum reicht (z. B. dem aktuellen Datum), auch wenn keine neuen Fälle gemeldet wurden, kannst du das verwenden:

```{r, eval=F}
scale_x_date(limits = c(NA, Sys.Date()) # ensures date axis will extend until current date  
```

<span style="color: red;">***GEFAHR!*** Sei vorsichtig, wenn du die Skalenbrüche oder Grenzen der y-Achse einstellst (z.B. 0 bis 30 mal 5: `seq(0, 30, 5)`). Solche statischen Zahlen können deinen Plot zu kurz abschneiden, wenn sich die Daten ändern und die Grenze überschreiten!</span>

### Datumsachsenbeschriftungen/Gitterlinien {.unnumbered}

<span style="color: darkgreen;">***TIPP:*** Denke daran, dass die Datums-Achse **Beschriftungen** unabhängig von der Aggregation der Daten zu Balken sind, aber visuell kann es wichtig sein, die Bins, die Datumsbeschriftungen und die vertikalen Gitterlinien auszurichten.</span>

An **die Datumsbeschriftungen und Gitterlinien zu ändern** verwenden Sie `scale_x_date()` auf eine der folgenden Arten:

- **Wenn deine Histogramm-Bins Tage, Montagswochen, Monate oder Jahre sind**:
  - Verwende `date_breaks = ` um das Intervall der Beschriftungen und der Hauptgitterlinien anzugeben (z.B. "Tag", "Woche", "3 Wochen", "Monat" oder "Jahr")
  - verwenden `date_minor_breaks = ` um den Abstand der kleinen vertikalen Gitternetzlinien (zwischen den Datumsbeschriftungen) festzulegen
  - hinzufügen `expand = c(0,0)` um die Beschriftungen am ersten Balken zu beginnen
  - verwenden `date_labels = ` um das Format der Datumsbeschriftungen festzulegen - siehe die Seite Datumsangaben für Tipps (mit `\n` für eine neue Zeile)
- **Wenn deine Histogramm-Bins Sonntagswochen sind**:
  - Verwende `breaks = ` und `minor_breaks = ` indem du eine Folge von Datumsumbrüchen für jede
  - Du kannst trotzdem verwenden `date_labels = ` und `expand = ` für die Formatierung verwenden, wie oben beschrieben

Einige Anmerkungen:

- Im Abschnitt über die Eröffnung von ggplot findest du Anweisungen, wie du eine Datumsfolge mit `seq.Date()`.
- Siehe [diese Seite](https://rdrr.io/r/base/strptime.html)oder die [Arbeiten mit Datumsangaben] Seite für Tipps zum Erstellen von Datumsetiketten.

#### Vorführungen {.unnumbered}

Nachfolgend findest du eine Demonstration von Plots, bei denen die Bins und die Plotbeschriftungen/Gitterlinien ausgerichtet und nicht ausgerichtet sind:

```{r, fig.show="hold", class.source="fold-hide", warning=F, message=F}
# 7-day bins + Monday labels
#############################
ggplot(central_data) +
  geom_histogram(
    mapping = aes(x = date_onset),
    binwidth = 7,                 # 7-day bins with start at first case
    color = "darkblue",
    fill = "lightblue") +
  
  scale_x_date(
    expand = c(0,0),                     # remove excess x-axis space below and after case bars
    date_breaks = "3 weeks",             # Monday every 3 weeks
    date_minor_breaks = "week",          # Monday weeks
    label = scales::label_date_short())+ # automatic label formatting
  
  scale_y_continuous(
    expand = c(0,0))+              # remove excess space under x-axis, make flush
  
  labs(
    title = "MISALIGNED",
    subtitle = "! CAUTION: 7-day bars start Thursdays at first case\nDate labels and gridlines on Mondays\nNote how ticks don't align with bars")



# 7-day bins + Months
#####################
ggplot(central_data) +
  geom_histogram(
    mapping = aes(x = date_onset),
    binwidth = 7,
    color = "darkblue",
    fill = "lightblue") +
  
  scale_x_date(
    expand = c(0,0),                     # remove excess x-axis space below and after case bars
    date_breaks = "months",              # 1st of month
    date_minor_breaks = "week",          # Monday weeks
    label = scales::label_date_short())+ # automatic label formatting
  
  scale_y_continuous(
    expand = c(0,0))+                 # remove excess space under x-axis, make flush 
  
  labs(
    title = "MISALIGNED",
    subtitle = "! CAUTION: 7-day bars start Thursdays with first case\nMajor gridlines and date labels at 1st of each month\nMinor gridlines weekly on Mondays\nNote uneven spacing of some gridlines and ticks unaligned with bars")


# TOTAL MONDAY ALIGNMENT: specify manual bin breaks to be mondays
#################################################################
ggplot(central_data) + 
  geom_histogram(
    mapping = aes(x = date_onset),
    
    # histogram breaks set to 7 days beginning Monday before first case
    breaks = weekly_breaks_central,    # defined earlier in this page
    
    closed = "left",                   # count cases from start of breakpoint
    
    color = "darkblue",
    
    fill = "lightblue") + 
  
  scale_x_date(
    expand = c(0,0),                     # remove excess x-axis space below and after case bars
    date_breaks = "4 weeks",             # Monday every 4 weeks
    date_minor_breaks = "week",          # Monday weeks 
    label = scales::label_date_short())+ # label formatting
  
  scale_y_continuous(
    expand = c(0,0))+                  # remove excess space under x-axis, make flush 
  
  labs(
    title = "ALIGNED Mondays",
    subtitle = "7-day bins manually set to begin Monday before first case (28 Apr)\nDate labels and gridlines on Mondays as well")


# TOTAL MONDAY ALIGNMENT WITH MONTHS LABELS:
############################################
ggplot(central_data) + 
  geom_histogram(
    mapping = aes(x = date_onset),
    
    # histogram breaks set to 7 days beginning Monday before first case
    breaks = weekly_breaks_central,    # defined earlier in this page
    
    closed = "left",                   # count cases from start of breakpoint
    
    color = "darkblue",
    
    fill = "lightblue") + 
  
  scale_x_date(
    expand = c(0,0),                     # remove excess x-axis space below and after case bars
    date_breaks = "months",              # Monday every 4 weeks
    date_minor_breaks = "week",          # Monday weeks 
    label = scales::label_date_short())+ # label formatting
  
  scale_y_continuous(
    expand = c(0,0))+                  # remove excess space under x-axis, make flush 
  
  theme(panel.grid.major = element_blank())+  # Remove major gridlines (fall on 1st of month)
          
  labs(
    title = "ALIGNED Mondays with MONTHLY labels",
    subtitle = "7-day bins manually set to begin Monday before first case (28 Apr)\nDate labels on 1st of Month\nMonthly major gridlines removed")


# TOTAL SUNDAY ALIGNMENT: specify manual bin breaks AND labels to be Sundays
############################################################################
ggplot(central_data) + 
  geom_histogram(
    mapping = aes(x = date_onset),
    
    # histogram breaks set to 7 days beginning Sunday before first case
    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7),
                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7),
                      by   = "7 days"),
    
    closed = "left",                    # count cases from start of breakpoint

    color = "darkblue",
    
    fill = "lightblue") + 
  
  scale_x_date(
    expand = c(0,0),
    # date label breaks and major gridlines set to every 3 weeks beginning Sunday before first case
    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7),
                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7),
                      by   = "3 weeks"),
    
    # minor gridlines set to weekly beginning Sunday before first case
    minor_breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7),
                            to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7),
                            by   = "7 days"),
    
    label = scales::label_date_short())+ # label formatting
  
  scale_y_continuous(
    expand = c(0,0))+                # remove excess space under x-axis, make flush 
  
  labs(title = "ALIGNED Sundays",
       subtitle = "7-day bins manually set to begin Sunday before first case (27 Apr)\nDate labels and gridlines manually set to Sundays as well")

```

### Aggregierte Daten {.unnumbered}

Oftmals beginnt man mit aggregierten Zählungen von Einrichtungen, Bezirken usw., anstatt mit einer Linienliste. Du kannst eine Epikurve erstellen mit `ggplot()` erstellen, aber der Code wird etwas anders aussehen. In diesem Abschnitt wird die `count_data` Datensatz, der zuvor im Abschnitt Datenvorbereitung importiert wurde. Dieser Datensatz ist der `linelist` auf die Anzahl der Tageskrankenhäuser aggregiert. Die ersten 50 Zeilen werden unten angezeigt.

```{r, message=FALSE, warning=F, echo=F}
# display the linelist data as a table
DT::datatable(head(count_data, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

#### Tägliche Zählungen aufzeichnen {.unnumbered}

Wir können eine tägliche Epikurve aus diesen *täglichen Zählungen*. Hier sind die Unterschiede zum Code:

- Innerhalb des ästhetischen Mappings `aes()` gibst du an `y = ` als Zählspalte an (in diesem Fall lautet der Spaltenname `n_cases`)
- Füge das Argument `stat = "identity"` innerhalb von `geom_histogram()` ein, das angibt, dass die Balkenhöhe die `y = ` Wert sein soll und nicht die Anzahl der Zeilen, wie es der Standard ist
- Füge das Argument `width = ` hinzu, um vertikale weiße Linien zwischen den Balken zu vermeiden. Setze für tägliche Daten den Wert 1. Für wöchentliche Zähldaten setze den Wert auf 7. Bei monatlichen Zähldaten sind weiße Linien ein Problem (jeder Monat hat eine unterschiedliche Anzahl von Tagen) - überlege dir, ob du die x-Achse in einen kategorialen geordneten Faktor (Monate) umwandeln und mit `geom_col()`.

```{r, message=FALSE, warning=F}
ggplot(data = count_data)+
  geom_histogram(
   mapping = aes(x = date_hospitalisation, y = n_cases),
   stat = "identity",
   width = 1)+                # for daily counts, set width = 1 to avoid white space between bars
  labs(
    x = "Date of report", 
    y = "Number of cases",
    title = "Daily case incidence, from daily count data")
```

#### Wöchentliche Zählungen aufzeichnen {.unnumbered}

Wenn deine Daten bereits Fallzahlen nach Wochen sind, könnten sie wie dieser Datensatz aussehen (genannt `count_data_weekly`):

```{r, warning=F, message=F, echo=F}
# Create weekly dataset with epiweek column
count_data_weekly <- count_data %>%
  mutate(epiweek = lubridate::floor_date(date_hospitalisation, "week")) %>% 
  group_by(hospital, epiweek, .drop=F) %>% 
  summarize(n_cases_weekly = sum(n_cases, na.rm=T))   
```

Die ersten 50 Zeilen der `count_data_weekly` werden unten angezeigt. Du kannst sehen, dass die Zählungen zu Wochen zusammengefasst wurden. Jede Woche wird nach dem ersten Tag der Woche (standardmäßig Montag) angezeigt.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(count_data_weekly, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Stelle nun so dar, dass `x = ` die Spalte epiweek. Denke daran, hinzuzufügen `y = ` die Zählungsspalte zum ästhetischen Mapping hinzuzufügen, und füge `stat = "identity"` wie oben erklärt.

```{r, warning=F, message=F}
ggplot(data = count_data_weekly)+
  
  geom_histogram(
    mapping = aes(
      x = epiweek,           # x-axis is epiweek (as class Date)
      y = n_cases_weekly,    # y-axis height in the weekly case counts
      group = hospital,      # we are grouping the bars and coloring by hospital
      fill = hospital),
    stat = "identity")+      # this is also required when plotting count data
     
  # labels for x-axis
  scale_x_date(
    date_breaks = "2 months",      # labels every 2 months 
    date_minor_breaks = "1 month", # gridlines every month
    label = scales::label_date_short())+ # label formatting
     
  # Choose color palette (uses RColorBrewer package)
  scale_fill_brewer(palette = "Pastel2")+ 
  
  theme_minimal()+
  
  labs(
    x = "Week of onset", 
    y = "Weekly case incidence",
    fill = "Hospital",
    title = "Weekly case incidence, from aggregated count data by hospital")
```

### Gleitende Durchschnitte {.unnumbered}

Siehe die Seite über [Gleitende Durchschnitte] für eine detaillierte Beschreibung und verschiedene Optionen. Im Folgenden findest du eine Option für die Berechnung gleitender Durchschnitte mit dem Paket**Schieber**. Bei diesem Ansatz, *wird der gleitende Durchschnitt im Datensatz berechnet, bevor er gezeichnet wird*:

1) Aggregiere die Daten je nach Bedarf zu Zählungen (täglich, wöchentlich usw.) (siehe [Daten gruppieren] Seite)
2) Erstelle eine neue Spalte, die den gleitenden Durchschnitt enthält, der mit `slide_index()` von **Schieber** Paket
3) Zeichne den gleitenden Durchschnitt als `geom_line()` über (nach) dem Epikurvenhistogramm

Siehe das hilfreiche Online [Vignette für die **Slider** Paket](https://cran.r-project.org/web/packages/slider/vignettes/slider.html)

```{r, warning=F, message=F}
# load package
pacman::p_load(slider)  # slider used to calculate rolling averages

# make dataset of daily counts and 7-day moving average
#######################################################
ll_counts_7day <- linelist %>%    # begin with linelist
  
  ## count cases by date
  count(date_onset, name = "new_cases") %>%   # name new column with counts as "new_cases"
  drop_na(date_onset) %>%                     # remove cases with missing date_onset
  
  ## calculate the average number of cases in 7-day window
  mutate(
    avg_7day = slider::slide_index(    # create new column
      new_cases,                       # calculate based on value in new_cases column
      .i = date_onset,                 # index is date_onset col, so non-present dates are included in window 
      .f = ~mean(.x, na.rm = TRUE),    # function is mean() with missing values removed
      .before = 6,                     # window is the day and 6-days before
      .complete = FALSE),              # must be FALSE for unlist() to work in next step
    avg_7day = unlist(avg_7day))       # convert class list to class numeric


# plot
######
ggplot(data = ll_counts_7day) +  # begin with new dataset defined above 
    geom_histogram(              # create epicurve histogram
      mapping = aes(
        x = date_onset,          # date column as x-axis
        y = new_cases),          # height is number of daily new cases
        stat = "identity",       # height is y value
        fill="#92a8d1",          # cool color for bars
        colour = "#92a8d1",      # same color for bar border
        )+ 
    geom_line(                   # make line for rolling average
      mapping = aes(
        x = date_onset,          # date column for x-axis
        y = avg_7day,            # y-value set to rolling average column
        lty = "7-day \nrolling avg"), # name of line in legend
      color="red",               # color of line
      size = 1) +                # width of line
    scale_x_date(                # date scale
      date_breaks = "1 month",
      label = scales::label_date_short(), # label formatting
      expand = c(0,0)) +
    scale_y_continuous(          # y-axis scale
      expand = c(0,0),
      limits = c(0, NA)) +       
    labs(
      x="",
      y ="Number of confirmed cases",
      fill = "Legend")+ 
    theme_minimal()+
    theme(legend.title = element_blank())  # removes title of legend
```

### Facettieren/Klein-Multiplikatoren {.unnumbered}

Wie bei anderen ggplots kannst du facettierte Plots ("kleine Vielfache") erstellen. Wie in den [ggplot-Tipps] Seite dieses Handbuchs erklärt, kannst du entweder`facet_wrap()` oder `facet_grid()`. Hier demonstrieren wir mit `facet_wrap()`. Für Epikurven, `facet_wrap()` ist in der Regel einfacher, da du wahrscheinlich nur eine Spalte facettieren musst.

Die allgemeine Syntax lautet `facet_wrap(rows ~ cols)` wobei links von der Tilde (~) der Name einer Spalte steht, die auf die "Zeilen" der facettierten Darstellung verteilt werden soll, und rechts von der Tilde der Name einer Spalte, die auf die "Spalten" der facettierten Darstellung verteilt werden soll. Am einfachsten ist es, nur einen Spaltennamen rechts von der Tilde zu verwenden: `facet_wrap(~age_cat)`.

**Freie Achsen**  
Du musst entscheiden, ob die Skalen der Achsen für jede Facette auf die gleichen Dimensionen "fixiert" (Standard) oder "frei" (d. h. sie ändern sich je nach den Daten innerhalb der Facette) sind. Dies tust du mit der Option `scales = ` Argument innerhalb von `facet_wrap()` indem du "free\_x" oder "free\_y" oder "free" angibst.

**Anzahl der Spalten und Zeilen der Facetten**  
Dies kann angegeben werden mit `ncol = ` und `nrow = ` innerhalb von `facet_wrap()`.

**Reihenfolge der Paneele**  
Um die Reihenfolge des Erscheinungsbildes zu ändern, änderst du die zugrunde liegende Reihenfolge der Ebenen der Faktorsäule, die zur Erstellung der Facetten verwendet wird.

**Ästhetik**  
Schriftgröße und -art, Streifenfarbe usw. können über `theme()` mit Argumenten wie:

- `strip.text = element_text()` (Größe, Farbe, Gesicht, Winkel...)
- `strip.background = element_rect()` (z. B. element\_rect(fill="grey"))
- `strip.position = ` (Position des Streifens "unten", "oben", "links", oder "rechts")

**Streifenbeschriftungen**  
Die Beschriftungen der Facettenplots können über die "Beschriftungen" der Spalte als Faktor oder durch die Verwendung eines "Beschriftungsgeräts" geändert werden.

Erstelle einen Beschrifter wie diesen, indem du die Funktion `as_labeller()` von **ggplot2**. Dann gib den Labeller an die `labeller = ` Argument von `facet_wrap()` wie unten gezeigt.

```{r, class.source="fold-show"}
my_labels <- as_labeller(c(
     "0-4"   = "Ages 0-4",
     "5-9"   = "Ages 5-9",
     "10-14" = "Ages 10-14",
     "15-19" = "Ages 15-19",
     "20-29" = "Ages 20-29",
     "30-49" = "Ages 30-49",
     "50-69" = "Ages 50-69",
     "70+"   = "Over age 70"))
```

**Ein Beispiel für eine facettierte Darstellung** - facettiert nach Spalte `age_cat`.

```{r, warning=F, message=F}
# make plot
###########
ggplot(central_data) + 
  
  geom_histogram(
    mapping = aes(
      x = date_onset,
      group = age_cat,
      fill = age_cat),    # arguments inside aes() apply by group
      
    color = "black",      # arguments outside aes() apply to all data
        
    # histogram breaks
    breaks = weekly_breaks_central, # pre-defined date vector (see earlier in this page)
    closed = "left" # count cases from start of breakpoint
    )+  
                      
  # The labels on the x-axis
  scale_x_date(
    expand            = c(0,0),          # remove excess x-axis space below and after case bars
    date_breaks       = "2 months",      # labels appear every 2 months
    date_minor_breaks = "1 month",       # vertical lines appear every 1 month 
    label = scales::label_date_short())+ # label formatting
  
  # y-axis
  scale_y_continuous(expand = c(0,0))+                       # removes excess y-axis space between bottom of bars and the labels
  
  # aesthetic themes
  theme_minimal()+                                           # a set of themes to simplify plot
  theme(
    plot.caption = element_text(face = "italic", hjust = 0), # caption on left side in italics
    axis.title = element_text(face = "bold"),
    legend.position = "bottom",
    strip.text = element_text(face = "bold", size = 10),
    strip.background = element_rect(fill = "grey"))+         # axis titles in bold
  
  # create facets
  facet_wrap(
    ~age_cat,
    ncol = 4,
    strip.position = "top",
    labeller = my_labels)+             
  
  # labels
  labs(
    title    = "Weekly incidence of cases, by age category",
    subtitle = "Subtitle",
    fill     = "Age category",                                      # provide new title for legend
    x        = "Week of symptom onset",
    y        = "Weekly incident cases reported",
    caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```

Siehe dies [Link](https://ggplot2.tidyverse.org/reference/labellers.html) für weitere Informationen über Etikettierer.

#### Gesamtepidemie im Facettenhintergrund {.unnumbered}

Um die Gesamtzahl der Epidemien im Hintergrund der einzelnen Facetten anzuzeigen, füge die Funktion `gghighlight()` mit leeren Klammern zum ggplot hinzu. Diese ist aus dem Paket **gghighlight**. Beachte, dass das Maximum der y-Achse in allen Facetten jetzt auf dem Höhepunkt der gesamten Epidemie basiert. Weitere Beispiele für dieses Paket findest du in den [ggplot Tipps] Seite.

```{r, warning=F, message=F}
ggplot(central_data) + 
  
  # epicurves by group
  geom_histogram(
    mapping = aes(
      x = date_onset,
      group = age_cat,
      fill = age_cat),  # arguments inside aes() apply by group
    
    color = "black",    # arguments outside aes() apply to all data
    
    # histogram breaks
    breaks = weekly_breaks_central, # pre-defined date vector (see earlier in this page)
    
    closed = "left", # count cases from start of breakpoint
    )+     # pre-defined date vector (see top of ggplot section)                
  
  # add grey epidemic in background to each facet
  gghighlight::gghighlight()+
  
  # labels on x-axis
  scale_x_date(
    expand            = c(0,0),          # remove excess x-axis space below and after case bars
    date_breaks       = "2 months",      # labels appear every 2 months
    date_minor_breaks = "1 month",       # vertical lines appear every 1 month 
    label = scales::label_date_short())+ # label formatting
  
  # y-axis
  scale_y_continuous(expand = c(0,0))+  # removes excess y-axis space below 0
  
  # aesthetic themes
  theme_minimal()+                                           # a set of themes to simplify plot
  theme(
    plot.caption = element_text(face = "italic", hjust = 0), # caption on left side in italics
    axis.title = element_text(face = "bold"),
    legend.position = "bottom",
    strip.text = element_text(face = "bold", size = 10),
    strip.background = element_rect(fill = "white"))+        # axis titles in bold
  
  # create facets
  facet_wrap(
    ~age_cat,                          # each plot is one value of age_cat
    ncol = 4,                          # number of columns
    strip.position = "top",            # position of the facet title/strip
    labeller = my_labels)+             # labeller defines above
  
  # labels
  labs(
    title    = "Weekly incidence of cases, by age category",
    subtitle = "Subtitle",
    fill     = "Age category",                                      # provide new title for legend
    x        = "Week of symptom onset",
    y        = "Weekly incident cases reported",
    caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```

#### Eine Facette mit Daten {.unnumbered}

Wenn du ein einziges Facettenfeld haben möchtest, das alle Daten enthält, duplizierst du den gesamten Datensatz und behandelst die Duplikate als einen Facettenwert. Eine "Helfer"-Funktion `CreateAllFacet()` unten kann dir dabei helfen (dank dieser [Blogbeitrag](https://stackoverflow.com/questions/18933575/easily-add-an-all-facet-to-facet-wrap-in-ggplot2)). Wenn sie ausgeführt wird, verdoppelt sich die Anzahl der Zeilen und es gibt eine neue Spalte namens `facet` in der die duplizierten Zeilen den Wert "alle" haben und die ursprünglichen Zeilen den Wert der Facettenspalte. Jetzt musst du nur noch die Facettierung der `facet` Spalte.

Hier ist die Hilfsfunktion. Führe sie aus, damit sie für dich verfügbar ist.

```{r}
# Define helper function
CreateAllFacet <- function(df, col){
     df$facet <- df[[col]]
     temp <- df
     temp$facet <- "all"
     merged <-rbind(temp, df)
     
     # ensure the facet value is a factor
     merged[[col]] <- as.factor(merged[[col]])
     
     return(merged)
}
```

Wende nun die Hilfsfunktion auf den Datensatz an, und zwar auf die Spalte `age_cat`:

```{r}
# Create dataset that is duplicated and with new column "facet" to show "all" age categories as another facet level
central_data2 <- CreateAllFacet(central_data, col = "age_cat") %>%
  
  # set factor levels
  mutate(facet = fct_relevel(facet, "all", "0-4", "5-9",
                             "10-14", "15-19", "20-29",
                             "30-49", "50-69", "70+"))

# check levels
table(central_data2$facet, useNA = "always")
```

Bemerkenswerte Änderungen an der `ggplot()` Befehls sind:

- Die verwendeten Daten sind jetzt central\_data2 (doppelte Anzahl von Zeilen, mit neuer Spalte "facet")
- Der Labeller muss aktualisiert werden, falls er verwendet wird
- Optional: Um vertikal gestapelte Facetten zu erhalten, wird die Facettenspalte auf die Zeilenseite der Gleichung verschoben und auf der rechten Seite durch "." ersetzt (`facet_wrap(facet~.)`), und `ncol = 1`. Möglicherweise musst du auch die Breite und Höhe des gespeicherten png-Plotbildes anpassen (siehe `ggsave()`in [ggplot-Tipps]).

```{r, fig.height=12, fig.width=5, warning=F, message=F}
ggplot(central_data2) + 
  
  # actual epicurves by group
  geom_histogram(
        mapping = aes(
          x = date_onset,
          group = age_cat,
          fill = age_cat),  # arguments inside aes() apply by group
        color = "black",    # arguments outside aes() apply to all data
        
        # histogram breaks
        breaks = weekly_breaks_central, # pre-defined date vector (see earlier in this page)
        
        closed = "left", # count cases from start of breakpoint
        )+    # pre-defined date vector (see top of ggplot section)
                     
  # Labels on x-axis
  scale_x_date(
    expand            = c(0,0),          # remove excess x-axis space below and after case bars
    date_breaks       = "2 months",      # labels appear every 2 months
    date_minor_breaks = "1 month",       # vertical lines appear every 1 month 
    label = scales::label_date_short())+ # automatic label formatting
  
  # y-axis
  scale_y_continuous(expand = c(0,0))+  # removes excess y-axis space between bottom of bars and the labels
  
  # aesthetic themes
  theme_minimal()+                                           # a set of themes to simplify plot
  theme(
    plot.caption = element_text(face = "italic", hjust = 0), # caption on left side in italics
    axis.title = element_text(face = "bold"),
    legend.position = "bottom")+               
  
  # create facets
  facet_wrap(facet~. ,                            # each plot is one value of facet
             ncol = 1)+            

  # labels
  labs(title    = "Weekly incidence of cases, by age category",
       subtitle = "Subtitle",
       fill     = "Age category",                                      # provide new title for legend
       x        = "Week of symptom onset",
       y        = "Weekly incident cases reported",
       caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```

## Vorläufige Daten

Die aktuellsten Daten in den Epikurven sollten oft als vorläufig gekennzeichnet werden oder unterliegen Verzögerungen bei der Berichterstattung. Dies kann durch Hinzufügen einer vertikalen Linie und/oder eines Rechtecks über eine bestimmte Anzahl von Tagen geschehen. Hier sind zwei Optionen:

1) Verwende `annotate()`:
  - Für eine Linie verwenden `annotate(geom = "segment")`. zur Verfügung stellen. `x`, `xend`, `y`, und `yend`. Größe und Linientyp anpassen (`lty`) und die Farbe an.
  - Für ein Rechteck verwende `annotate(geom = "rect")`. Gib xmin/xmax/ymin/ymax an. Passe Farbe und Alpha an.
2) Gruppiere die Daten nach vorläufigem Status und färbe diese Balken unterschiedlich

<span style="color: orange;">***VORSICHT!*** Du könntest versuchen `geom_rect()` ein Rechteck zu zeichnen, aber das Einstellen der Transparenz funktioniert nicht im Kontext einer Linienliste. Diese Funktion überlagert ein Rechteck für jede Beobachtung/Zeile! Verwende entweder einen sehr niedrigen Alphawert (z.B. 0,01) oder einen anderen Ansatz. </span>

### verwenden `annotate()` {.unnumbered}

- Unter `annotate(geom = "rect")`, die `xmin` und `xmax` Argumente müssen Eingaben der Klasse Date erhalten.
- Da diese Daten in wöchentlichen Balken aggregiert werden und der letzte Balken bis zum Montag nach dem letzten Datenpunkt reicht, kann der schattierte Bereich 4 Wochen umfassen
- Hier ist ein `annotate()` [Online-Beispiel](https://ggplot2.tidyverse.org/reference/annotate.html)

```{r, warning=F, message=F}
ggplot(central_data) + 
  
  # histogram
  geom_histogram(
    mapping = aes(x = date_onset),
    
    breaks = weekly_breaks_central,   # pre-defined date vector - see top of ggplot section
    
    closed = "left", # count cases from start of breakpoint
    
    color = "darkblue",
    
    fill = "lightblue") +

  # scales
  scale_y_continuous(expand = c(0,0))+
  scale_x_date(
    expand = c(0,0),                     # remove excess x-axis space below and after case bars
    date_breaks = "1 month",             # 1st of month
    date_minor_breaks = "1 month",       # 1st of month
    label = scales::label_date_short())+ # automatic label formatting
  
  # labels and theme
  labs(
    title = "Using annotate()\nRectangle and line showing that data from last 21-days are tentative",
    x = "Week of symptom onset",
    y = "Weekly case indicence")+ 
  theme_minimal()+
  
  # add semi-transparent red rectangle to tentative data
  annotate(
    "rect",
    xmin  = as.Date(max(central_data$date_onset, na.rm = T) - 21), # note must be wrapped in as.Date()
    xmax  = as.Date(Inf),                                          # note must be wrapped in as.Date()
    ymin  = 0,
    ymax  = Inf,
    alpha = 0.2,          # alpha easy and intuitive to adjust using annotate()
    fill  = "red")+
  
  # add black vertical line on top of other layers
  annotate(
    "segment",
    x     = max(central_data$date_onset, na.rm = T) - 21, # 21 days before last data
    xend  = max(central_data$date_onset, na.rm = T) - 21, 
    y     = 0,         # line begins at y = 0
    yend  = Inf,       # line to top of plot
    size  = 2,         # line size
    color = "black",
    lty   = "solid")+   # linetype e.g. "solid", "dashed"

  # add text in rectangle
  annotate(
    "text",
    x = max(central_data$date_onset, na.rm = T) - 15,
    y = 15,
    label = "Subject to reporting delays",
    angle = 90)
```

Die gleiche schwarze vertikale Linie kann mit dem folgenden Code erreicht werden, allerdings mit `geom_vline()` verlierst du jedoch die Möglichkeit, die Höhe zu kontrollieren:

```{r, eval=F}
geom_vline(xintercept = max(central_data$date_onset, na.rm = T) - 21,
           size = 2,
           color = "black")
```

### Farbe der Balken {.unnumbered}

Ein alternativer Ansatz könnte darin bestehen, die Farbe oder Darstellung der vorläufigen Datenbalken selbst anzupassen. Du könntest in der Phase der Datenvorbereitung eine neue Spalte erstellen und die Daten darin gruppieren, so dass die `aes(fill = )` der vorläufigen Daten eine andere Farbe oder einen anderen Alphawert haben kann als die anderen Balken.

```{r, message=F, warning=F}
# add column
############
plot_data <- central_data %>% 
  mutate(tentative = case_when(
    date_onset >= max(date_onset, na.rm=T) - 7 ~ "Tentative", # tenative if in last 7 days
    TRUE                                       ~ "Reliable")) # all else reliable

# plot
######
ggplot(plot_data, aes(x = date_onset, fill = tentative)) + 
  
  # histogram
  geom_histogram(
    breaks = weekly_breaks_central,   # pre-defined data vector, see top of ggplot page
    closed = "left", # count cases from start of breakpoint
    color = "black") +

  # scales
  scale_y_continuous(expand = c(0,0))+
  scale_fill_manual(values = c("lightblue", "grey"))+
  scale_x_date(
    expand = c(0,0),                     # remove excess x-axis space below and after case bars
    date_breaks = "3 weeks",             # Monday every 3 weeks
    date_minor_breaks = "week",          # Monday weeks 
    label = scales::label_date_short())+ # automatic label formatting
  
  # labels and theme
  labs(title = "Show days that are tentative reporting",
    subtitle = "")+ 
  theme_minimal()+
  theme(legend.title = element_blank())                 # remove title of legend
  
```

## Mehrstufige Datumsbeschriftungen

Wenn du mehrstufige Datumsbeschriftungen möchtest (z.B. Monat und Jahr) *ohne die unteren Beschriftungsebenen zu duplizieren* möchtest, ziehe eine der folgenden Methoden in Betracht:

Denke daran - du kannst Tools wie `\n` *innerhalb von* der `date_labels` oder `labels` Argumente, um Teile jedes Etiketts in eine neue Zeile darunter zu setzen. Die folgenden Codes helfen dir jedoch dabei, Jahre oder Monate (zum Beispiel) in eine untere Zeile zu setzen *und nur einmal*.

Die einfachste Methode ist, die `labels = ` Argument in `scale_x_date()` an die Funktion `label_date_short()` aus dem Paket **skaliert** (Hinweis: Vergiss nicht, leere Klammern () zu setzen, wie unten gezeigt). Diese Funktion konstruiert automatisch effiziente Datumsbeschriftungen (mehr dazu [hier](https://scales.r-lib.org/reference/label_date.html)). Ein zusätzlicher Vorteil dieser Funktion ist, dass sich die Beschriftungen automatisch anpassen, wenn sich deine Daten im Laufe der Zeit erweitern: von Tagen über Wochen und Monate bis hin zu Jahren.

```{r, warning=F}
ggplot(central_data) + 
  
  # histogram
  geom_histogram(
    mapping = aes(x = date_onset),
    breaks = weekly_breaks_central,   # pre-defined date vector - see top of ggplot section
    closed = "left",                  # count cases from start of breakpoint
    color = "darkblue",
    fill = "lightblue") +

  # y-axis scale as before 
  scale_y_continuous(expand = c(0,0))+
  
  # x-axis scale sets efficient date labels
  scale_x_date(
    expand = c(0,0),                      # remove excess x-axis space below and after case bars
    labels = scales::label_date_short())+ # auto efficient date labels
  
  # labels and theme
  labs(
    title = "Using label_date_short()\nTo make automatic and efficient date labels",
    x = "Week of symptom onset",
    y = "Weekly case indicence")+ 
  theme_minimal()
```

Eine zweite Möglichkeit ist die Verwendung von Facetten. Unten:

- Die Fallzahlen werden aus ästhetischen Gründen zu Wochen zusammengefasst. Weitere Informationen findest du auf der Seite Epicurves (Registerkarte Aggregierte Daten).
- A `geom_area()` Linie wird anstelle eines Histogramms verwendet, da der unten beschriebene Facettenansatz nicht gut mit Histogrammen funktioniert.

**Aggregieren zu wöchentlichen Zählungen**

```{r, out.width=c("50%", "50%"), fig.show="hold", warning=F, message=F}

# Create dataset of case counts by week
#######################################
central_weekly <- linelist %>%
  filter(hospital == "Central Hospital") %>%   # filter linelist
  mutate(week = lubridate::floor_date(date_onset, unit = "weeks")) %>%  
  count(week) %>%                              # summarize weekly case counts
  drop_na(week) %>%                            # remove cases with missing onset_date
  complete(                                    # fill-in all weeks with no cases reported
    week = seq.Date(
      from = min(week),   
      to   = max(week),
      by   = "week"),
    fill = list(n = 0))                        # convert new NA values to 0 counts
```

**Plots erstellen**

```{r, warning=F, message=F}
# plot with no facet box border
#################################
ggplot(central_weekly,
       aes(x = week, y = n)) +              # establish x and y for entire plot
  geom_line(stat = "identity",              # make line, line height is count number
            color = "#69b3a2") +            # line color
  geom_point(size=1, color="#69b3a2") +     # make points at the weekly data points
  geom_area(fill = "#69b3a2",               # fill area below line
            alpha = 0.4)+                   # fill transparency
  scale_x_date(date_labels="%b",            # date label format show month 
               date_breaks="month",         # date labels on 1st of each month
               expand=c(0,0)) +             # remove excess space
  scale_y_continuous(
    expand  = c(0,0))+                      # remove excess space below x-axis
  facet_grid(~lubridate::year(week),        # facet on year (of Date class column)
             space="free_x",                
             scales="free_x",               # x-axes adapt to data range (not "fixed")
             switch="x") +                  # facet labels (year) on bottom
  theme_bw() +
  theme(strip.placement = "outside",                  # facet label placement
          strip.background = element_blank(),         # no facet lable background
          panel.grid.minor.x = element_blank(),          
          panel.border = element_blank(),             # no border for facet panel
          panel.spacing=unit(0,"cm"))+                # No space between facet panels
  labs(title = "Nested year labels - points, shaded, no label border")
```

Die obige Technik zum Facettieren wurde angepasst von [dieser](https://stackoverflow.com/questions/44616530/axis-labels-on-two-lines-with-nested-x-variables-year-below-months) und [dies](https://stackoverflow.com/questions/20571306/multi-row-x-axis-labels-in-ggplot-line-chart) Beitrag auf stackoverflow.com.

<!-- ======================================================= -->

## Dual-axis { }

Obwohl es in der Datenvisualisierungs-Community heftige Diskussionen über die Sinnhaftigkeit von zwei Achsen gibt, wollen viele Epi-Betreuer/innen immer noch eine Epikurve oder ein ähnliches Diagramm mit einem Prozentwert sehen, der von einer zweiten Achse überlagert wird. Dies wird ausführlicher in den [ggplot-Tipps] Seite näher erläutert, aber ein Beispiel, das die**cowplot** Methode wird unten gezeigt:

- Es werden zwei verschiedene Plots erstellt, die dann mit **Kuhplot** Paket kombiniert.
- Die Diagramme müssen genau die gleiche x-Achse haben (Grenzen setzen), sonst stimmen die Daten und Beschriftungen nicht überein
- Jeder verwendet `theme_cowplot()` und bei einer wurde die y-Achse auf die rechte Seite der Grafik verschoben

```{r, warning=F, message=F}
#load package
pacman::p_load(cowplot)

# Make first plot of epicurve histogram
#######################################
plot_cases <- linelist %>% 
  
  # plot cases per week
  ggplot()+
  
  # create histogram  
  geom_histogram(
    
    mapping = aes(x = date_onset),
    
    # bin breaks every week beginning monday before first case, going to monday after last case
    breaks = weekly_breaks_all)+  # pre-defined vector of weekly dates (see top of ggplot section)
        
  # specify beginning and end of date axis to align with other plot
  scale_x_date(
    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # min/max of the pre-defined weekly breaks of histogram
  
  # labels
  labs(
      y = "Daily cases",
      x = "Date of symptom onset"
    )+
  theme_cowplot()


# make second plot of percent died per week
###########################################
plot_deaths <- linelist %>%                        # begin with linelist
  group_by(week = floor_date(date_onset, "week")) %>%  # create week column
  
  # summarise to get weekly percent of cases who died
  summarise(n_cases = n(),
            died = sum(outcome == "Death", na.rm=T),
            pct_died = 100*died/n_cases) %>% 
  
  # begin plot
  ggplot()+
  
  # line of weekly percent who died
  geom_line(                                # create line of percent died
    mapping = aes(x = week, y = pct_died),  # specify y-height as pct_died column
    stat = "identity",                      # set line height to the value in pct_death column, not the number of rows (which is default)
    size = 2,
    color = "black")+
  
  # Same date-axis limits as the other plot - perfect alignment
  scale_x_date(
    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # min/max of the pre-defined weekly breaks of histogram
  
  
  # y-axis adjustments
  scale_y_continuous(                # adjust y-axis
    breaks = seq(0,100, 10),         # set break intervals of percent axis
    limits = c(0, 100),              # set extent of percent axis
    position = "right")+             # move percent axis to the right
  
  # Y-axis label, no x-axis label
  labs(x = "",
       y = "Percent deceased")+      # percent axis label
  
  theme_cowplot()                   # add this to make the two plots merge together nicely
```

Jetzt benutzen **Kuhplot** um die beiden Diagramme zu überlagern. Es wurde auf die Ausrichtung der x-Achse, die Seite der y-Achse und die Verwendung von `theme_cowplot()`.

```{r, warning=F, message=F}
aligned_plots <- cowplot::align_plots(plot_cases, plot_deaths, align="hv", axis="tblr")
ggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])
```

## Kumulative Inzidenz {}

Wenn du mit einer Fallliste beginnst, erstelle eine neue Spalte, die die kumulative Anzahl der Fälle pro Tag eines Ausbruchs enthält, indem du `cumsum()` von **Basis** R:

```{r}
cumulative_case_counts <- linelist %>% 
  count(date_onset) %>%                # count of rows per day (returned in column "n")   
  mutate(                         
    cumulative_cases = cumsum(n)       # new column of the cumulative number of rows at each date
    )
```

Die ersten 10 Zeilen werden unten angezeigt:

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(cumulative_case_counts, 10), rownames = FALSE, options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )
```

Diese kumulative Spalte kann dann gegen folgende Werte aufgetragen werden `date_onset` dargestellt werden, indem `geom_line()`:

```{r, warning=F, message=F}
plot_cumulative <- ggplot()+
  geom_line(
    data = cumulative_case_counts,
    aes(x = date_onset, y = cumulative_cases),
    size = 2,
    color = "blue")

plot_cumulative
```

Sie kann auch über die Epikurve gelegt werden, mit zwei Achsen unter Verwendung der **Kuhplot**Methode, die oben und in den [ggplot-Tipps] Seite:

```{r, warning=F, message=F}
#load package
pacman::p_load(cowplot)

# Make first plot of epicurve histogram
plot_cases <- ggplot()+
  geom_histogram(          
    data = linelist,
    aes(x = date_onset),
    binwidth = 1)+
  labs(
    y = "Daily cases",
    x = "Date of symptom onset"
  )+
  theme_cowplot()

# make second plot of cumulative cases line
plot_cumulative <- ggplot()+
  geom_line(
    data = cumulative_case_counts,
    aes(x = date_onset, y = cumulative_cases),
    size = 2,
    color = "blue")+
  scale_y_continuous(
    position = "right")+
  labs(x = "",
       y = "Cumulative cases")+
  theme_cowplot()+
  theme(
    axis.line.x = element_blank(),
    axis.text.x = element_blank(),
    axis.title.x = element_blank(),
    axis.ticks = element_blank())
```

Benutze jetzt **Kuhplot** um die beiden Diagramme zu überlagern. Es wurde auf die Ausrichtung der x-Achse, die Seite der y-Achse und die Verwendung von `theme_cowplot()`.

```{r, warning=F, message=F}
aligned_plots <- cowplot::align_plots(plot_cases, plot_cumulative, align="hv", axis="tblr")
ggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])
```

<!-- ======================================================= -->

## Ressourcen { }


