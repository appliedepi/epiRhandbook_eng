
# Взаимодействие директорий { }  

На этой странице мы рассмотрим распространенные сценарии создания, взаимодействия, сохранения и импорта директорий (папок).  


## Подготовка  

### пакет **fs** {.unnumbered}  

Пакет **fs** - это пакет **tidyverse**, который способствует взаимодействиям директорий, улучшая некоторые **базовые** функции R. В разделах ниже мы часто будем использовать функции из **fs**.  

```{r}
pacman::p_load(
  fs,             # взаимодействия файлов/директорий
  rio,            # импорт/экспорт
  here,           # относительные пути к файлам
  tidyverse)      # управление данными и визуализация
```


### Печать директории в виде дерева дендрограмм {.unnumbered}  

Используем функцию `dir_tree()` из **fs**.  

Задайте путь к папке в `path = ` и определите, хотите ли вы показать только один уровень (`recurse = FALSE`) или все файлы на всех суб-уровнях (`recurse = TRUE`). Ниже мы используем `here()` в качестве сокращения для проекта R и уточняем подпапку "data", которая содержит все данные, используемые для этого руководства по R. Мы задаем отображение всех файлов в "data" и подпапках (например, "cache", "epidemic models", "population", "shp" и "weather").  


```{r}
fs::dir_tree(path = here("data"), recurse = TRUE)
```


## Список файлов в директории  

Чтобы указать только имена файлов в директории, вы можете использовать `dir()` из **базового** R. Например, эта команда создает список имен файлов из подпапки "population" в папке "data" проекта R. Относительный путь к файлу задается, используя `here()` (о которой вы можете больше прочитать на странице [Импорт и экспорт](importing.ru.qmd)).  

```{r}
# file names
dir(here("data", "gis", "population"))
```

Чтобы указать полные пути к файлам для файлов директории, вы можете использовать `dir_ls()` из **fs**. Альтернативой в **базовом** R является `list.files()`.  

```{r}
# file paths
dir_ls(here("data", "gis", "population"))
```

Чтобы получить всю информацию о метаданных для каждого файла в директории, (например, путь, дата изменения и т.п.) вы можете использовать `dir_info()` из **fs**.  

Это может быть особенно полезным, если вы хотите извлечь время последнего изменения из файла, например, если вы хотите импортировать наиболее последнюю версию файла. Для примера см. страницу [Импорт и экспорт](importing.ru.qmd).     

```{r, eval=F}
# file info
dir_info(here("data", "gis", "population"))
```

Вот выдан датафрейм. Пролистайте вправо, чтобы увидеть все столбцы.  

```{r, echo=F}
DT::datatable(dir_info(here("data", "gis", "population")), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

## Информация о файле  

Чтобы извлечь информацию о метаданных о конкретном файле, вы можете использовать `file_info()` из **fs** (или `file.info()` из **базового** R).  

```{r, eval=F}
file_info(here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, echo=F}
DT::datatable(file_info(here("data", "case_linelists", "linelist_cleaned.rds")), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Здесь мы используем `$`, чтобы индексировать результат и выдать только значение времени изменения `modification_time`.  

```{r}
file_info(here("data", "case_linelists", "linelist_cleaned.rds"))$modification_time
```




## Проверка существования  

### Объекты R {.unnumbered}  

Вы можете использовать `exists()` из **базового** R, чтобы проверить, существует ли объект R *внутри* R (задайте имя объекта в кавычках).  

```{r}
exists("linelist")
```

Обратите внимание, что некоторые **базовые** пакеты R используют общие имена объектов, такие как "data" фоново, они будут отражены как TRUE (ИСТИНА), если не уточнить `inherit = FALSE`. Это одна из причин, почему не стоит называть ваш набор данных "data".  

```{r}
exists("data")
exists("data", inherit = FALSE)
```

Если вы пишите функцию, вам следует использовать `missing()` из **базового** R, чтобы проверить наличие аргумента вместо `exists()`.  



### Директории {.unnumbered}  

Чтобы проверить, существует ли директория, задайте путь к файлу (и имя файла) в `is_dir()` из **fs**. Пролистайте вправо, чтобы увидеть, что напечатано `TRUE`.    

```{r}
is_dir(here("data"))
```

Альтернативой будет `file.exists()` из **базового** R.  


### Файлы {.unnumbered}  

Чтобы проверить, существует ли конкретный файл, используйте `is_file()` из **fs**. Пролистайте вправо, чтобы увидеть, что напечатано `TRUE`.  

```{r}
is_file(here("data", "case_linelists", "linelist_cleaned.rds"))
```

Альтернативой из **базового** R будет `file.exists()`.  



## Создание  

### Директории {.unnumbered}  

Чтобы создать новую директорию (папку), вы можете использовать `dir_create()` из **fs**. Если директория уже существует, она не будет перезаписана сверу, и не будет выдаваться ошибка. 

```{r, eval=F}
dir_create(here("data", "test"))
```

Альтернативой является `dir.create()` из **базового** R, которая выдаст ошибку, если директория уже существует. Наоборот, `dir_create()` в этом сценарии не выдаст никаких сообщений.  

### Файлы {.unnumbered}  

вы можете создать (пустой) файл с помощью `file_create()` из **fs**. Если файл уже существует, он не будет перезаписан или изменен.  

```{r, eval=F}
file_create(here("data", "test.rds"))
```

Альтернативой из **базового** R является `file.create()`. Но если файл уже существует, эта опция его обрезан. Если вы используете `file_create()`, файл останется неизменным.  


### Создание, если не существует {.unnumbered}  

В РАЗРАБОТКЕ  


## Удаление

### Объекты R {.unnumbered}  

Используйте `rm()` из **базового** R, чтобы удалить объект R.  

### Директории {.unnumbered}  

Используйте `dir_delete()` из **fs**. 


### Файлы {.unnumbered}  

Вы можете удалить файлы с помощью `file_delete()` из **fs**.  



## Выполнение других файлов  

### `source()` {.unnumbered}  

Чтобы выполнить один скрипт R из другого скрипта R, вы можете использовать команду `source()` (из **базового** R).

```{r, eval=F}
source(here("scripts", "cleaning_scripts", "clean_testing_data.R"))
```

Это эквивалентно просмотру приведенного выше скрипта R и нажатию кнопки "Source" в правом верхнем углу скрипта. Это приведет к выполнению скрипта, но сделает это незаметно (без вывода на консоль R), если это не предусмотрено специально. См. страницу [Интерактивная консоль], где есть примеры использования `source()` для взаимодействия с пользователем через консоль R в режиме вопросов и ответов.  

```{r, fig.align = "center", out.height = '300%', echo=F}
knitr::include_graphics(here::here("images", "source_button.png"))
```


### `render()` {.unnumbered}  

`render()` - вариация `source()`, наиболее часто используемая для скриптов R markdown. Вы задаете `input = `, который является файлом R markdown, а также `output_format = ` (как правило, "html_document", "pdf_document", "word_document", "") 

См. дополнительные детали на странице [Отчеты с помощью R Markdown](rmarkdown.ru.qmd). Также см. документацию по `render()` [тут](https://rmarkdown.rstudio.com/docs/reference/render.html) или введя `?render`.  



### Выполнение файлов в директории {.unnumbered}

Вы можете создать *цикл for* и использовать его для `source()` для каждого файла в директории, указанного в `dir()`. 

```{r, eval=F}
for(script in dir(here("scripts"), pattern = ".R$")) {   # для каждого имени скрипта в папке проекта R "scripts" (с расширением .R)
  source(here("scripts", script))                        # запрос файла с соответствующим именем, который существует в папке скриптов
}
```

Если вы хотите выполнить только определенные скрипты, вы можете определить их по имени следующим образом:  

```{r, eval=F}

scripts_to_run <- c(
     "epicurves.R",
     "demographic_tables.R",
     "survival_curves.R"
)

for(script in scripts_to_run) {
  source(here("scripts", script))
}

```



Вот [сравнение](https://cran.r-project.org/web/packages/fs/vignettes/function-comparisons.html) функций **fs** и **базового** R.  

### Импорт файлов в директорию  {.unnumbered}

По вопросам импорта и экспорта отдельных файлов см. страницу [Импорт и экспорт].  

Также см. на странице [Импорт и экспорт] методы автоматического импорта наиболее свежего файла на основе даты в имени файла *или* с помощью рассмотрения мета-данных файла.  

См. страницу [Итерации, циклы и списки] для примера с пакетом **purrr**, демонстрирующего:  

* Разделение датафрейма и сохранение его как нескольких файлов CSV  
* Разделения датафрейма и сохранения каждой части как отдельного листа в рабочей книге Excel  
* Импорта нескольких файлов CSV и объединения их в один датафрейм  
* Импорта рабочей книги Excel с несколькими листами и объединения их в один датафрейм  




## **базовый** R  

См. функции ниже `list.files()` и `dir()`, которые проводят те же операции создания списка файлов в указанной директории. Вы можете задать `ignore.case =` или конкретную последовательность, которую надо найти. 

```{r, eval=F}
list.files(path = here("data"))

list.files(path = here("data"), pattern = ".csv")
# dir(path = here("data"), pattern = ".csv")

list.files(path = here("data"), pattern = "evd", ignore.case = TRUE)

```

Если файл в настоящее время "открыт", он будет отображаться в вашей папкой с тильдой в начале, например, "~$hospital_linelists.xlsx".  


<!-- ======================================================= -->
## Ресурсы {  }

https://cran.r-project.org/web/packages/fs/vignettes/function-comparisons.html



