# Statistiques descriptives {#descriptive_stats}


Cette page démontre l'utilisation de **janitor**, **dplyr**, et **gtsummary** pour produire des tableaux et des statistiques descriptives, et pour effectuer des tests statistiques simples. Chacun de ces outils présente des avantages et des inconvénients dans les domaines de la simplicité du code, de l'accessibilité des résultats, de la qualité des résultats imprimés. Nous espérons que l'une de ces approches vous conviendra.  

<!-- ======================================================= -->
## Préparation { }


### Chargement des paquets {.unnumbered}

Ce morceau de code montre le chargement des paquets nécessaires aux analyses. Dans ce manuel, nous mettons l'accent sur `p_load()` de **pacman**, qui installe le paquet si nécessaire *et* le charge pour l'utiliser. Vous pouvez également charger les paquets installés avec `library()` de **base** R. Voir la page sur [R - les bases](#rbasics) pour plus d'informations sur les paquets R.  


```{r}
pacman::p_load(
  rio, # Importation de fichiers
  here, # Localisateur de fichiers
  skimr, # obtenir une vue d'ensemble des données
  tidyverse, # gestion des données + graphiques ggplot2, 
  gtsummary, # statistiques et tests sommaires
  janitor, # ajout de totaux et de pourcentages aux tableaux
  flextable, # conversion de tableaux en HTML
  corrr # analyse de corrélation pour les variables numériques
  )
```

### Importer des données {.unnumbered}

Nous importons le jeu de données des cas d'une épidémie d'Ebola simulée. Si vous voulez suivre, <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>cliquez pour télécharger la liste de lignes "propre"</a> (en tant que fichier .rds). Le jeu de données est importé à l'aide de la fonction `import()` du paquet **rio**. Voir la page [Importer et exporter des données](#import_export) pour les différentes manières d'importer des données.

```{r, echo=F}
# Importez la liste de lignes dans R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# Importez la liste de cas
linelist <- import("linelist_cleaned.xlsx")
```

Les 50 premières lignes de la linelist sont affichées ci-dessous.

```{r, message=FALSE, echo=F}
# affiche les données de la liste de diffusion sous forme de tableau
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```





<!-- ======================================================= -->
## Parcourir les données { }

### Paquet `skimr` {.unnumbered}

En utilisant le paquet **skimr**, vous pouvez obtenir un aperçu détaillé et esthétique de chacune des variables de votre ensemble de données. Pour en savoir plus sur **skimr**, consultez sa [page github](https://github.com/ropensci/skimr).  

Ci-dessous, la fonction `skim()` est appliquée à l'ensemble du cadre de données `linelist`. Une vue d'ensemble du cadre de données et un résumé de chaque colonne (par classe) sont produits.    

```{r eval=F}
## obtenir des informations sur chaque variable d'un ensemble de données 
skim(linelist)
```

```{r echo=F}
# Les histogrammes sparkline ne s'affichent pas correctement, il faut donc les éviter.
#skim_without_charts(linelist)
```

Vous pouvez également utiliser la fonction `summary()`, de **base** R, pour obtenir des informations sur un jeu de données entier, mais cette sortie peut être plus difficile à lire qu'en utilisant **skimr**.  

```{r, eval=F}
## obtenir des informations sur chaque colonne d'un ensemble de données 
summary(linelist)
```


### Statistiques sommaires {.unnumbered} 

Vous pouvez utiliser les fonctions R **base** pour renvoyer des statistiques sommaires sur une colonne numérique. Ces fonctions sont également souvent utilisées dans le cadre d'opérations de code plus complexes, par exemple pour regrouper et résumer des colonnes, ou pour référencer une valeur `max()` afin de calibrer la hauteur du graphique.  

Voir la page [R - les bases](#rbasics) pour une liste complète des opérateurs mathématiques tels que `max()`, `min()`, `median()`, `mean()`, `quantile()`, `sd()`, et `range()`.

<span style="color: orange ;">**_CAUTION:_** Si vos données contiennent des valeurs manquantes, R veut que vous le sachiez et renvoie donc `NA`, sauf si vous spécifiez aux fonctions mathématiques ci-dessus que vous voulez que R ignore les valeurs manquantes, via l'argument `na.rm = TRUE`.</span>.

Vous pouvez retourner la plupart des statistiques récapitulatives utiles pour une colonne numérique en utilisant `summary()`, comme ci-dessous. Notez que le dataframe doit également être spécifié comme indiqué ci-dessous.  

```{r}
summary(linelist$age_years)
```

Vous pouvez accéder à une partie spécifique et l'enregistrer avec des crochets d'indexation [ ] :  

```{r}
summary(linelist$age_years)[[2]]
```


<!-- ======================================================= -->
## Tableaux descriptifs {}

Vous avez plusieurs choix pour produire des tableaux récapitulatifs de tabulation et de tableaux croisés. Parmi les facteurs à prendre en compte, citons la simplicité et la facilité du code, la sortie souhaitée (imprimée sur la console R ou sous forme de joli HTML) et ce que vous pouvez faire des données par la suite. Considérez les idées ci-dessous lorsque vous choisissez l'outil adapté à votre situation.  

* Utilisez `tabyl()` de **janitor** pour produire et "orner" des tabulations et des tableaux croisés. 
  * Contre: nécessite un post-traitement (par exemple avec **flextable**) pour des tableaux prêts à être publiés. N'accepte pas les variables multiples (il faut utiliser **purrr** pour itérer).  
* Utilisez `count()` et `summarise()` de **dplyr** si vous préparez des données pour `ggplot()` ou si vous calculez des statistiques plus complexes.  
  * Contre: similaire au précédent mais nécessite encore plus de manipulations.  
* Utilisez `tbl_summary()` de **gtsummary** pour produire des tableaux détaillés prêts à être publiés.  
  * Contre: les manques ne sont pas automatiquement inclus dans les calculs de pourcentage. Pour utiliser pour le traçage, il faut extraire le tibble de la sortie de la liste. 


### **janitor** {.unnumbered}

Le paquetage **janitor** offre la fonction `tabyl()` qui produit des tableaux propres et des tableaux croisés, qui peuvent être "ornés" ou modifiés avec d'autres fonctions pour afficher des pourcentages, des proportions, etc.  

Ci-dessous, nous envoyons le cadre de données `linelist` aux fonctions **janitor** et nous imprimons le résultat. Si vous le souhaitez, vous pouvez également enregistrer les tableaux résultants avec l'opérateur d'affectation `<-`.  

#### Tabyl simple {.unnumbered}  

L'utilisation par défaut de `tabyl()` sur une colonne spécifique produit les valeurs uniques, les comptages, et les "pourcentages" par colonne (en fait les proportions). Les proportions peuvent avoir plusieurs chiffres. Vous pouvez ajuster cela avec `adorn_rounding()` comme décrit ci-dessous.   

```{r}
linelist %>% 
  tabyl(age_cat)
```
Comme vous pouvez le voir ci-dessus, s'il y a des valeurs manquantes, elles s'affichent dans une ligne étiquetée `<NA>`. Vous pouvez les supprimer avec `show_na = FALSE`. S'il n'y a pas de valeurs manquantes, cette ligne n'apparaîtra pas. S'il y a des valeurs manquantes, les proportions sont données à la fois sous forme brute (dénominateur incluant les comptes `NA`) et "valide" (dénominateur excluant les comptes `NA`).  

Si la colonne est Facteur de classe et que seuls certains niveaux sont présents dans vos données, ils apparaîtront quand même dans le tableau. Vous pouvez supprimer cette fonctionnalité avec `show_missing_levels = FALSE`.  

#### Tableaux croisés {.unnumbered}  

Les tableaux croisés sont obtenus en ajoutant un ou plusieurs tableaux supplémentaires dans `tabyl()`. Notez que seuls les comptes sont retournés - les proportions et les pourcentages peuvent être ajoutés avec des étapes supplémentaires.  

```{r}
linelist %>% 
  tabyl(age_cat, gender)
```
#### "Embellir" le tabyl {.unnumbered}  

Utilisez les fonctions "adorn" de **janitor** pour ajouter des totaux, convertir en proportions, en pourcentages ou ajuster l'affichage. Souvent, vous ferez passer le tabyle par plusieurs de ces fonctions.  


Fonction | Résultat                          
-------------------|--------------------------------
`adorn_totals()` | Ajoute les totaux (`where = ` "row", "col", ou "both"). Définissez `name =` pour "Total".  
`adorn_percentages()` | Convertit les comptes en proportions, avec `denominator = ` "row", "col", ou "all".  
`adorn_pct_formatting()` | Convertit les proportions en pourcentages. Spécifiez `digits =`. Supprimez "%" avec `affix_sign = F`.  
`adorn_rounding()` | Pour arrondir les nombres, les proportions à des places `digits =`. Pour arrondir les pourcentages, utilisez `adorn_pct_formatting()` comme ci-dessus.  
`adorn_ns()` | Ajoutez des comptes à un tableau de proportions ou de pourcentages. Indiquez `position =` "rear" pour les comptages entre parenthèses, ou "front" pour mettre le pourcentage entre parenthèses.  
`adorn_title()` | ajouter la chaîne `row_name =` et/ou `col_name =`  

Faites attention à l'ordre dans lequel vous appliquez les fonctions ci-dessus. Voici quelques exemples.  

Un simple tableau à sens unique avec des pourcentages au lieu des proportions par défaut.  

```{r}
linelist %>% # cas linelist
  tabyl(age_cat) %>% # tableau des effectifs et des proportions par catégorie d'âge
  adorn_pct_formatting() # Conversion des proportions en pourcentages
```
Un tableau croisé avec une ligne totale et des pourcentages de ligne.  

```{r}
linelist %>%                                  
  tabyl(age_cat, gender) %>% # comptes par âge et par sexe
  adorn_totals(where = "row") %>% # ajout du total de la ligne
  adorn_percentages(denominator = "row") %>% # convertit les comptages en proportions
  adorn_pct_formatting(digits = 1) # convertit les proportions en pourcentages
```
Un tableau croisé ajusté pour afficher à la fois les chiffres et les pourcentages.  

```{r}
linelist %>% # cas linelist
  tabyl(age_cat, gender) %>% # tableau croisé des comptes
  adorn_totals(where = "row") %>% # ajoute une ligne de total
  adorn_percentages(denominator = "col") %>% # Conversion en proportions
  adorn_pct_formatting() %>% # convertit en pourcentages
  adorn_ns(position = "front") %>% # affiche comme : "nombre (pourcentage)"
  adorn_title( # ajuster les titres
    row_name = "Catégorie d'âge",
    col_name = "Sexe")
```



#### Impression du tableau {.unnumbered}

Par défaut, le tabyl s'imprime brut dans la console R. Vous pouvez également passer le tabyl à l'utilisateur. Alternativement, vous pouvez passer le tabyl à **flextable** ou à un autre package pour l'imprimer en HTML dans la visionneuse RStudio. Notez que si vous utilisez `adorn_titles()`, vous devez spécifier `placement = "combined"` afin d'imprimer de cette manière.

```{r}
linelist %>%
  tabyl(age_cat, gender) %>% 
  adorn_totals(where = "col") %>% 
  adorn_percentages(denominator = "col") %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front") %>% 
  adorn_title(
    row_name = "Catégorie d'âge",
    col_name = "Sexe",
    placement = "combined") %>% # ceci est nécessaire pour imprimer en HTML 
  flextable::flextable() %>% # convertir en HTML
  flextable::autofit() # formatage à une ligne par ligne 

```
#### Utilisation sur d'autres tables {.unnumbered}  

Vous pouvez utiliser les fonctions `adorn_*()` de **janitor** sur d'autres tables, comme celles créées par `summarise()`, `count()`, ou `table()`.  


#### Enregistrement du tabyl {.unnumbered}  

Si vous convertissez le tableau en HTML avec un paquetage comme **flextable**, vous pouvez le sauvegarder avec les fonctions `save_as_html()`, `save_as_word()`, `save_as_ppt`, et `save_as_image()`, comme discuté plus en détail dans la page [Tableaux pour la présentation]. Ci-dessous, le tableau est enregistré comme un document Word dans lequel il peut être édité manuellement.  

```{r, eval=F}
linelist %>%
  tabyl(age_cat, gender) %>% 
  adorn_totals(where = "col") %>% 
  adorn_percentages(denominator = "col") %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front") %>% 
  adorn_title(
    row_name = "Catégorie d'âge",
    col_name = "Sexe",
    placement = "combined") %>% 
  flextable::flextable() %>% # convertit en flextable HTML
  flextable::autofit() %>% # garantit une seule ligne par ligne
  flextable::save_as_docx(path = "tabyl.docx") # Enregistrer comme document Word
```

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "tabyl_word.png"))
```

#### Statistiques {.unnumbered}  

Vous pouvez appliquer des tests statistiques sur les tabyles, comme `chisq.test()` ou `fisher.test()` de **stats** comme indiqué ci-dessous. Notez que les valeurs manquantes ne sont pas autorisées.  

```{r, warning=F, message=F}
age_by_outcome <- linelist %>% 
  tabyl(age_cat, outcome, show_na = FALSE) 

chisq.test(age_by_outcome)
```
#### Autres astuces {.unnumbered}  

* Incluez l'argument `na.rm = TRUE` pour exclure les valeurs manquantes de tous les calculs ci-dessus.  
* Si vous appliquez `adorn_XXX()` à des tables qui n'ont pas été créées par `tabyl()`, vous pouvez spécifier une ou plusieurs colonnes particulières à appliquer comme `adorn_percentage(,,,c(cas,décès))`. La syntaxe n'est pas simple. Pensez à utiliser `summarise()` à la place.  
* Vous pouvez lire plus de détails dans la [page janitor](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html) et la [vignette tabyl](https://cran.r-project.org/web/packages/janitor/vignettes/tabyls.html).  




### **dplyr** paquet {.unnumbered}  

**dplyr** fait partie des paquets **tidyverse** et est un outil de gestion de données extrêmement courant. La création de tableaux avec **dplyr** est utile si vous calculez des statistiques sommaires par groupe, ou si vous passez les résultats à `ggplot()` (qui attend des données "longues").  

#### Compteurs {.unnumbered}  

Comme expliqué dans la page [Travailler sur des données groupées](#grouping_data), vous pouvez utiliser la fonction **dplyr** `count()` pour retourner des comptages tabulés sur une ou plusieurs colonnes. La sortie retournée est dans un format "long" avec une colonne `n` pour contenir les comptes.  

```{r}
linelist %>% 
  count(age_cat)
```

Les tabulations de deux colonnes ou plus sont toujours retournées au format "long", avec les comptes dans la colonne `n`.  

```{r}
linelist %>% 
  count(age_cat, gender)
```

Pour afficher cette sortie de comptage par groupe avec `ggplot()`, c'est relativement simple. Voir d'autres exemples dans les pages [Tracer des données discrètes](#plot_discrete) et [Trucs et Astuces avec ggplot](#ggplot_tips).  

```{r, warning=F, message=F}
linelist %>% 
  count(outcome, age_cat) %>% 
  ggplot()+
    geom_bar(aes(x = outcome, fill = age_cat, y = n), stat = "identity")
```


#### Proportions au sein d'un groupe {.unnumbered}  

Vous pouvez calculer les proportions *dans les groupes* en ayant deux niveaux d'agrégation avant d'utiliser `mutate()`. Le tableau ci-dessous regroupe d'abord le cadre de données par `outcome`, puis regroupe à nouveau et compte par la colonne `age_cat`, obtenant la répartition de l'âge *par outcome*. Notez que vous pouvez ajouter d'autres stratifications en ajoutant des colonnes à la commande `group_by()`.  

```{r}
age_by_outcome <- linelist %>% 
  group_by(outcome) %>% # regrouper d'abord par résultat 
  count(age_cat) %>% # regroupe à nouveau et compte par sexe (produit la colonne "n")
  mutate(percent = scales::percent(n / sum(n))) # calculez le pourcentage - notez que le dénominateur est par groupe de résultats.
```

```{r, echo=F}
DT::datatable(age_by_outcome, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```

#### Pivot plus large {.unnumbered}

Si votre tableau **dplyr** est au format "long", vous pouvez le "pivoter" au format large en utilisant la fonction **tidyr** `pivot_wider()`. Vous aurez probablement besoin de redéfinir les noms des colonnes avec `rename()`. Pour plus d'informations, consultez la page [Restructurer les données](#pivoting_data).  

```{r}
age_by_outcome %>% 
  pivot_wider(names_from = age_cat, values_from = c(n, percent))  
```


#### Statistiques sommaires avec `summarise()` {.unnumbered}

Un des avantages de l'utilisation de **dplyr** pour créer votre tableau est la possibilité de calculer des statistiques comme `median()`, `max()`, `sd()`, dans le contexte de `summarise()`. Ces statistiques peuvent être calculées pour l'ensemble des données ou par groupe. 
`summarise()` crée un *nouveau* cadre de données de synthèse composé uniquement des colonnes que vous définissez dans `summarise()` (et des colonnes de regroupement éventuelles).  

Dans l'instruction summarise, fournissez le(s) nom(s) de chaque **nouvelle** colonne de synthèse, un signe égal, puis une fonction statistique à appliquer. Dans la fonction statistique, indiquez la colonne à traiter et tout argument pertinent (par exemple, `na.rm = TRUE`). Vous pouvez utiliser `sum()` pour compter le nombre de lignes qui répondent à un critère logique (utilisez les doubles égalités `==`).    

Ci-dessous, les données `linelist` sur le délai entre l'apparition des symptômes et l'admission à l'hôpital (colonne `days_onset_hosp`, en jours) sont résumées.  

```{r}
summary_table <- linelist %>% # Commence avec linelist, sauvegarde comme nouvel objet
  group_by(hospital) %>% # Regroupe tous les calculs par hôpital
  summarise( # seules ces colonnes de résumé seront retournées
    cases = n(), # nombre de lignes par groupe
    delay_3 = sum(days_onset_hosp >= 3, na.rm = T), # nombre de lignes avec le sexe masculin
    pct_delay_3 = scales::percent(delay_3 / cases), # conversion de la colonne précédemment définie en pourcentage 
    delay_mean = round(mean(days_onset_hosp, na.rm=T), digits = 1), # moyenne de la colonne des retards, par groupe et arrondie
    delay_sd = round(sd(days_onset_hosp, na.rm = T), digits = 1) # écart type des retards, par groupe et arrondi
  )

summary_table # imprimer
```


Quelques conseils :  

* Utilisez `sum()` avec une instruction logique à l'intérieur pour "compter" les lignes qui répondent à certains critères.  
* Notez l'utilisation de l'argument `na.rm = TRUE` dans les fonctions mathématiques comme `sum()`, sinon `NA` sera retourné s'il y a des valeurs manquantes.  
* Utilisez la fonction `percent()` du paquet **scales** pour convertir facilement en pourcentages.  
* Utilisez la fonction `round()` de **base** R pour spécifier les décimales.  
* Pour calculer ces statistiques sur l'ensemble des données, utilisez `summarise()` sans `group_by()`.  

Les percentiles méritent une mention spéciale. Pour retourner les percentiles, utilisez `quantile()` avec les valeurs par défaut ou spécifiez la ou les valeurs que vous souhaitez avec `probs = `.

```{r}
# obtient les valeurs par défaut du percentile de l'âge (0%, 25%, 50%, 75%, 100%)
linelist %>% 
  summarise(age_percentiles = quantile(age_years, na.rm = TRUE))

# obtenir les valeurs de percentile spécifiées de l'âge (5%, 50%, 75%, 98%)
linelist %>% 
  summarise(
    age_percentiles = quantile(
      age_years,
      probs = c(.05, 0.5, 0.75, 0.98), 
      na.rm=TRUE)
    )
```

Vous pouvez également utiliser `str_glue()` pour combiner des colonnes en une nouvelle colonne - généralement utilisé *après* la commande `summarise()`. Ci-dessous, le cadre de données `summary_table` créé ci-dessus est modifié de telle sorte que les colonnes `delay_mean` et `delay_sd` sont combinées et leurs anciennes colonnes supprimées. Ensuite, pour rendre la table plus présentable, une ligne de total est ajoutée avec `adorn_totals()` de **janitor** (qui ignore les colonnes non-numériques). Enfin, nous utilisons `rename()` de **dplyr** pour rendre les noms des colonnes plus jolis. Maintenant vous pouvez passer à **flextable** et imprimer vers Word, HTML, Powerpoint, etc. !  

```{r}
summary_table %>% 
  mutate(delay = str_glue("{delay_mean} ({delay_sd})")) %>% # combine et formate les autres valeurs
  select(-c(delay_mean, delay_sd)) %>% # supprimer deux anciennes colonnes   
  adorn_totals(where = "row") %>% # ajoute la ligne de total
  rename( # renomme les colonnes
    "Hospital Name" = hospital,
    "Cases" = cases,
    "Delay 3+ days" = delay_3,
    "% delay 3+ days" = pct_delay_3,
    "Mean (sd)" = delay)
```



#### Utilisation de `summarise()` sur des données agrégées {.unnumbered}  

*Si vous commencez avec des données agrégées*, utilisez `sum()` sur la colonne des comptes. Par exemple, disons que vous commencez avec le tableau de comptage ci-dessous, appelé `linelist_agg` - il montre au format "long" le nombre de cas par résultat et par sexe.  

```{r, echo=F}
linelist_agg <- linelist %>% 
  drop_na(gender, outcome) %>% 
  count(outcome, gender)
linelist_agg
```

Pour additionner les valeurs de comptage (dans la colonne `n`) par groupe, vous pouvez utiliser `sum(n, na.rm=T)`. Pour additionner ces valeurs par la colonne de regroupement *et à l'intérieur de celle-ci par un sous-ensemble spécifique*, vous pouvez utiliser la syntaxe des crochets de sous-ensemble [ ] sur la colonne de comptage comme ci-dessous :  

```{r}
linelist_agg %>% 
  group_by(outcome) %>% 
  summarise(
    total_cases = sum(n, na.rm=T),
    male_cases = sum(n[gender == "m"], na.rm=T),
    female_cases = sum(n[gender == "f"], na.rm=T))
```

<span style="color : darkgreen ;">**_TIP:_** La fonction summarise fonctionne avec l'orthographe britannique et américaine - `summarise()` et `summarize()` appellent la même fonction.</span>


#### Summarise `across()` plusieurs colonnes {.unnumbered}  

Vous pouvez utiliser le résumé sur plusieurs colonnes en utilisant `across()`. Cela vous facilite la vie lorsque vous souhaitez obtenir la même statistique pour plusieurs colonnes. Pour spécifier les colonnes sur lesquelles vous voulez opérer, vous pouvez soit.. :  

* Fournir un vecteur de noms de colonnes `c()`, soit  
* Utiliser les fonctions d'aide sémantique `select()` (expliquées ci-dessous) pour sélectionner les colonnes par critères.  

Ci-dessous, `mean()` est appliqué à des données groupées. Les colonnes sont spécifiées, une fonction est spécifiée (sans parenthèses), et enfin, tout argument supplémentaire pour la fonction (par exemple, `na.rm=TRUE`).  

Il peut être difficile de respecter l'ordre des parenthèses et des virgules lorsque vous utilisez `across()`. N'oubliez pas qu'à l'intérieur de `across()`, vous devez inclure les colonnes, les fonctions et tous les arguments supplémentaires nécessaires aux fonctions. 

```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm),
                   .fns = mean,
                   na.rm=T))
```

Voici les fonctions d'aide `select()` que vous pouvez placer *dans* `across()` :  


Ce sont des fonctions d'aide disponibles pour vous aider à spécifier des colonnes :  

* `everything()` - toutes les autres colonnes non mentionnées  
* `last_col()` - la dernière colonne  
* `where()` - applique une fonction à toutes les colonnes et sélectionne celles qui sont VRAIES.  
* `starts_with()` - correspond à un préfixe spécifié. Exemple : `starts_with("date")`.
* `ends_with()` - correspond à un suffixe spécifié. Exemple : `ends_with("_end")`  
* `contains()` - colonnes contenant une chaîne de caractères. Exemple : `contains("time")` 
* `matches()` - pour appliquer une expression régulière (regex). Exemple : `contains("[pt]al")`  
* `num_range()` - 
* `any_of()` - correspond si la colonne est nommée. Utile si le nom n'existe pas. Exemple : `any_of(date_onset, date_death, cardiac_arrest)`  


Par exemple, pour retourner la moyenne de chaque colonne numérique. La commande `where()` prend la place d'un vecteur de noms de colonnes `c()`. La fonction et les éventuels arguments supplémentaires se trouvent tous dans la commande `across()`.  

```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(.cols = where(is.numeric), .fns = mean, na.rm=T))
```




### **gtsummary** paquet {.unnumbered}  

Si vous souhaitez imprimer vos statistiques récapitulatives dans un joli graphique prêt à être publié, vous pouvez utiliser le package **gtsummary** et sa fonction `tbl_summary()`. Le code peut sembler complexe au début, mais les résultats sont très jolis et s'impriment dans votre panneau de visualisation RStudio sous forme de HTML. Lisez une [vignette ici](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html).    

Pour présenter `tbl_summary()`, nous allons d'abord montrer le comportement le plus basique, qui produit réellement un grand et beau tableau. Ensuite, nous examinerons en détail comment faire des ajustements et des tableaux plus adaptés. 



#### Tableau récapitulatif {.unnumbered}

Le comportement par défaut de `tbl_summary()` est assez incroyable - il prend les colonnes que vous fournissez et crée un tableau récapitulatif. La fonction imprime les statistiques appropriées à la classe de la colonne : la médiane et l'écart inter-quartile (IQR) pour les colonnes numériques, et les effectifs (%) pour les colonnes catégoriques ou binaires. Les valeurs manquantes sont converties en "Inconnu". Des notes de bas de page sont ajoutées en bas de page pour expliquer les statistiques, tandis que le N total est affiché en haut.  

```{r, warning=F, message=F}
linelist %>% 
  select(age_years, gender, outcome, fever, temp, hospital) %>% # conserve les colonnes d'intérêt
  tbl_summary() # par défaut tbl_summary()
```


Nous allons maintenant expliquer comment la fonction fonctionne et comment faire des ajustements. Les arguments clés sont détaillés ci-dessous : 

**`by = `**  
Vous pouvez stratifier votre tableau par une colonne (par exemple par `outcome`), en créant un tableau à 2 voies.  

**`statistic = `**  
Indiquez les statistiques à afficher et comment les afficher avec une équation. Il y a deux côtés à l'équation, séparés par un tilde `~`. À droite, entre guillemets, se trouve l'affichage statistique souhaité, et à gauche, les colonnes auxquelles cet affichage s'appliquera.  

* Le côté droit de l'équation utilise la syntaxe de `str_glue()` de **stringr** (voir [Caractères et chaînes de caractères](#character_strings)), avec la chaîne d'affichage désirée entre guillemets et les statistiques elles-mêmes entre crochets. Vous pouvez inclure des statistiques comme "n" (pour les comptes), "N" (pour le dénominateur), "mean", "median", "sd", "max", "min", les percentiles comme "p##" comme "p25", ou le pourcentage du total comme "p". Voir `?tbl_summary` pour plus de détails.  
* Pour le côté gauche de l'équation, vous pouvez spécifier les colonnes par leur nom (par exemple `age` ou `c(age, gender)`) ou en utilisant des aides comme `all_continuous()`, `all_categorical()`, `contains()`, `starts_with()`, etc.  

Un exemple simple d'équation `statistic = ` pourrait ressembler à ce qui suit, pour imprimer uniquement la moyenne de la colonne `age_years` :  

```{r}
linelist %>% 
  select(age_years) %>% # ne conserve que les colonnes d'intérêt 
  tbl_summary( # créer un tableau récapitulatif
    statistic = age_years ~ "{mean}") # Impression de la moyenne d'âge
```

Une équation légèrement plus complexe pourrait ressembler à ceci, en incorporant les valeurs max et min entre parenthèses et séparées par une virgule :  

```{r, eval=F}
statistic = age_years ~ "({min}, {max})"
```

Vous pouvez également différencier la syntaxe pour des colonnes ou des types de colonnes distincts. Dans l'exemple plus complexe ci-dessous, la valeur fournie à `statistc = ` est une **liste** indiquant que pour toutes les colonnes continues, la table doit imprimer la moyenne avec l'écart-type entre parenthèses, tandis que pour toutes les colonnes catégorielles, elle doit imprimer le n, le dénominateur et le pourcentage.  

**`digits = `**  
Ajuste les chiffres et les arrondis. En option, on peut spécifier que cela ne concerne que les colonnes continues (comme ci-dessous).  

**`label = `**  
Ajustez la façon dont le nom de la colonne doit être affiché. Fournissez le nom de la colonne et son étiquette souhaitée, séparés par un tilde. La valeur par défaut est le nom de la colonne.  

**`missing_text = `**  
Ajustez la façon dont les valeurs manquantes sont affichées. La valeur par défaut est "Inconnu".  

**`type = `**  
Ceci est utilisé pour ajuster le nombre de niveaux de statistiques affichés. La syntaxe est similaire à `statistic = ` en ce sens que vous fournissez une équation avec des colonnes à gauche et une valeur à droite. Voici deux scénarios courants :  

* `type = all_categorical() ~ "categorical"` Force les colonnes dichotomiques (par exemple, la fièvre) à afficher tous les niveaux au lieu de la seule ligne "oui".  
* `type = all_continuous() ~ "continuous2"` Permet d'afficher des statistiques sur plusieurs lignes par variable, comme indiqué dans une section ultérieure.  

Dans l'exemple ci-dessous, chacun de ces arguments est utilisé pour modifier le tableau récapitulatif d'origine :  

```{r}
linelist %>% 
  select(age_years, gender, outcome, fever, temp, hospital) %>% # ne conserve que les colonnes d'intérêt
  tbl_summary(     
    by = outcome, # stratifier la table entière par résultat
    statistic = list(all_continuous() ~ "{mean} ({sd})", # stats et format pour les colonnes continues
                     all_categorical() ~ "{n} / {N} ({p}%)"), # stats et format pour les colonnes catégorielles
    digits = all_continuous() ~ 1, # arrondi pour les colonnes continues
    type = all_categorical() ~ "categorical", # force l'affichage de tous les niveaux catégoriels
    label = list( # afficher les étiquettes pour les noms de colonnes
      outcome ~ "Résultat",                           
      age_years ~ "Age (années)",
      gender ~ "Sexe",
      temp ~ "Température",
      hospital ~ "Hôpital"),
    missing_text = "Missing" # comment les valeurs manquantes doivent être affichées
  )
```



#### Statistiques sur plusieurs lignes pour les variables continues {.unnumbered}  

Si vous souhaitez imprimer plusieurs lignes de statistiques pour des variables continues, vous pouvez l'indiquer en définissant le `type = ` à "continuous2".  Vous pouvez combiner tous les éléments présentés précédemment dans un seul tableau en choisissant les statistiques que vous souhaitez afficher. Pour cela, vous devez indiquer à la fonction que vous voulez récupérer un tableau en entrant le type comme "continuous2". Le nombre de valeurs manquantes est indiqué par "Inconnu".

```{r}
linelist %>% 
  select(age_years, temp) %>% # ne garde que les colonnes d'intérêt
  tbl_summary( # créer un tableau récapitulatif
    type = all_continuous() ~ "continuous2", # indique que vous voulez imprimer plusieurs statistiques 
    statistic = all_continuous() ~ c(
      "{mean} ({sd})", # ligne 1 : moyenne et écart-type
      "{median} ({p25}, {p75})", # ligne 2 : médiane et IQR
      "{min}, {max}")                              # ligne 3 : min et max
    )
```
Il existe de nombreuses autres façons de modifier ces tableaux, notamment en ajoutant des valeurs p, en ajustant la couleur et les titres, etc. Beaucoup d'entre elles sont décrites dans la documentation (entrez `?tbl_summary` dans Console), et certaines sont données dans la section sur les tests statistiques.  







### **base** R {.unnumbered}  

Vous pouvez utiliser la fonction `table()` pour faire des tableaux et des tableaux croisés de colonnes. Contrairement aux options ci-dessus, vous devez spécifier le dataframe, comme indiqué ci-dessous.  

<span style="color : orange ;">**_CAUTION:_** Les valeurs `NA` (manquantes) ne seront **pas** tabulées à moins que vous n'incluiez l'argument `useNA = "always"` (qui pourrait aussi être défini à "no" ou "ifany").</span>

```{r}
table(linelist$outcome, useNA = "always")
```

Plusieurs colonnes peuvent être croisées en les listant l'une après l'autre, séparées par des virgules. En option, vous pouvez attribuer à chaque colonne un "nom" comme `Outcome = linelist$outcome`.  

```{r}
age_by_outcome <- table(linelist$age_cat, linelist$outcome, useNA = "always") # enregistrer la table en tant qu'objet
age_by_outcome # imprimer le tableau
```
Pour retourner les proportions, passez le tableau ci-dessus à la fonction `prop.table()`. Utilisez l'argument `margins = ` pour spécifier si vous voulez que les proportions soient des lignes (1), des colonnes (2), ou du tableau entier (3). Pour plus de clarté, nous envoyons le tableau à la fonction `round()` de **base** R, en spécifiant 2 chiffres.   

```{r}
# obtient les proportions du tableau défini ci-dessus, par lignes, arrondies
prop.table(age_by_outcome, 1) %>% round(2)
```

Pour ajouter les totaux des lignes et des colonnes, passez le tableau à `addmargins()`. Cela fonctionne à la fois pour les comptages et les proportions.  

```{r}
addmargins(age_by_outcome)
```

Convertir un objet `table()` directement en un cadre de données n'est pas simple. Une approche est présentée ci-dessous :  

1) Créez la table, *sans utiliser* `useNA = "always"`. A la place, convertissez les valeurs `NA` en "(Missing)" avec `fct_explicit_na()` de **forcats**.  
2) Ajoutez les totaux (facultatif) en utilisant `addmargins()`.  
3) Passez le tableau dans la fonction R **base** `as.data.frame.matrix()`.  
4) Passez le tableau à la fonction **dplyr** `add_rownames()`, en spécifiant le nom de la première colonne.  
5) Imprimez, visualisez ou exportez comme vous le souhaitez. Dans cet exemple, nous utilisons `flextable()` du paquetage **flextable** comme décrit dans la page [Tableaux pour la présentation]. Cela va s'imprimer dans le panneau de visualisation de RStudio sous la forme d'un joli HTML.  

```{r, warning=F, message=F}
table(fct_explicit_na(linelist$age_cat), fct_explicit_na(linelist$outcome)) %>% 
  addmargins() %>% 
  as.data.frame.matrix() %>% 
  dplyr::add_rownames(var = "Age Category") %>% 
  flextable::flextable()
```





<!-- ======================================================= -->

## Tests statistiques simples { }


### **base** R {.unnumbered}

Vous pouvez utiliser les fonctions **base** R pour produire les résultats de tests statistiques. Les commandes sont relativement simples et les résultats s'imprimeront dans la Console R pour une visualisation simple. Cependant, les sorties sont généralement des listes et sont donc plus difficiles à manipuler si vous souhaitez utiliser les résultats dans des opérations de code ultérieures. 

#### Tests T {.unnumbered} 

**Syntaxe 1:** Le mieux est que vos colonnes numériques et catégorielles soient dans le même cadre de données. Fournissez la colonne numérique sur le côté gauche de l'équation et la colonne catégorielle sur le côté droit. Spécifiez l'ensemble de données à `data = `. En option, définissez `paired = TRUE`, et `conf.level = ` (0.95 par défaut), et `alternative = ` (soit "two.sided", "less", ou "greater"). Entrez `?t.test` pour plus de détails.  

```{r}
## comparer l'âge moyen par groupe de résultats avec un test t
t.test(age_years ~ outcome, data = linelist)
```

**Syntaxe 2:** Vous pouvez comparer deux vecteurs numériques distincts en utilisant cette syntaxe alternative. Par exemple, si les deux colonnes se trouvent dans des ensembles de données différents.  

```{r, eval=F}
t.test(df1$age_years, df2$age_years)
```

Effectuez un test t à un échantillon avec la moyenne connue/hypothétique de la population du côté droit de l'équation :  

```{r, eval=F}
t.test(linelist$age_years, mu = 45)
```

#### Test de Shapiro-Wilk {.unnumbered}  

```{r, eval=F}
shapiro.test(linelist$age_years)
```

#### Test de la somme des rangs de Wilcoxon {.unnumbered}

```{r wilcox_base}

## comparer la distribution des âges par groupe de résultats avec un test de wilcox
wilcox.test(age_years ~ outcome, data = linelist)

```

#### Test de Kruskal-wallis {.unnumbered}


```{r }

## comparez la distribution des âges par groupe de résultats avec un test de kruskal-wallis
kruskal.test(age_years ~ outcome, linelist)

```

#### Test du khi-deux {.unnumbered} 

```{r}

## comparer les proportions dans chaque groupe avec un test du chi-carré
chisq.test(linelist$gender, linelist$outcome)

```





### Paquet `gtsummary` {.unnumbered}

Utilisez **gtsummary** si vous cherchez à ajouter les résultats d'un test statistique à un joli tableau (décrit dans la section ci-dessus). L'exécution de tests statistiques de comparaison avec `tbl_summary` se fait en ajoutant la fonction `add_p` à une table et en spécifiant le test à utiliser. Il est possible d'obtenir des p-values corrigées pour les tests multiples en utilisant la fonction `add_q`. Exécutez `?tbl_summary` pour plus de détails.  

#### Test du chi-carré 

Comparez les proportions d'une variable catégorielle dans deux groupes. Le test statistique par défaut pour `add_p()` est d'effectuer un test d'indépendance du chi carré avec correction de continuité, mais si le nombre d'appels prévu est inférieur à 5, un test exact de Fisher est utilisé. 

```{r chi_gt}
linelist %>% 
  select(gender, outcome) %>% # garde les variables d'intérêt
  tbl_summary(by = outcome) %>% # produit un tableau récapitulatif et spécifie la variable de regroupement
  add_p() # spécifie le test à effectuer
```


#### T-tests {.unnumbered} 

Comparez la différence entre les moyennes d'une variable continue dans deux groupes. 
Par exemple, comparez l'âge moyen selon le résultat du patient. 

```{r ttest_gt}

linelist %>% 
  select(age_years, outcome) %>% # garde les variables d'intérêt
  tbl_summary( # produit un tableau récapitulatif
    statistic = age_years ~ "{mean} ({sd})", # spécifie les statistiques à afficher
    by = outcome) %>% # spécifie la variable de regroupement
  add_p(age_years ~ "t.test") # spécifier les tests à effectuer


```

#### Test de la somme des rangs de Wilcoxon{.unnumbered}

Comparez la distribution d'une variable continue dans deux groupes. La valeur par défaut est d'utiliser le test de la somme des rangs de Wilcoxon et la médiane (IQR) pour comparer deux groupes. Cependant, pour les données à distribution non normale ou la comparaison de plusieurs groupes, le test de Kruskal-wallis est plus approprié. 

```{r wilcox_gt}

linelist %>% 
  select(age_years, outcome) %>% # garde les variables d'intérêt
  tbl_summary( # produit un tableau récapitulatif
    statistic = age_years ~ "{median} ({p25}, {p75})", # spécifie la statistique à afficher (par défaut, on peut la supprimer)
    by = outcome) %>% # spécifie la variable de regroupement
  add_p(age_years ~ "wilcox.test") # spécifie le test à effectuer (par défaut, on peut laisser les parenthèses vides)


```

#### Test de Kruskal-wallis {.unnumbered}

Comparez la distribution d'une variable continue dans deux groupes ou plus, 
indépendamment du fait que les données soient normalement distribuées. 

```{r kruskal_gt}

linelist %>% 
  select(age_years, outcome) %>% # garde les variables d'intérêt
  tbl_summary( # produit un tableau récapitulatif
    statistic = age_years ~ "{median} ({p25}, {p75})", # spécifie la statistique à afficher (par défaut, on peut donc la supprimer)
    by = outcome) %>% # spécifie la variable de regroupement
  add_p(age_years ~ "kruskal.test") # spécifier le test à effectuer


```




<!-- ### paquet `dplyr` {.unnumbered} -->

<!-- L'exécution de tests statistiques dans `dplyr` seul est très dense, encore une fois parce qu'elle -->
<!-- ne s'inscrit pas dans le cadre de tidy-data. Elle nécessite l'utilisation de `purrr` pour créer --> <!--
<!-- une liste de dataframes pour chacun des sous-groupes que vous voulez comparer. Consultez la page sur [l'itération, les boucles et les listes] pour en savoir plus sur **purrr**.   -->

<!-- Une alternative plus facile peut être le paquet `rstatix`.  -->

<!-- #### T-tests {.unnumbered} -->

<!-- ``{r ttest_dplyr} -->

<!-- linelist %>% -->
<!-- ## ne garder que les variables d'intérêt -->
<!-- select(age, outcome) %>% -->
<!-- ## drop those missing outcome -->
<!-- filter(!is.na(outcome)) %>% -->
<!-- ## spécifier la variable de groupage -->
<!-- group_by(outcome) %>% -->
<!-- ## créer un sous-ensemble de données pour chaque groupe (sous forme de liste) -->
<!-- nest() %>% -->
<!-- ## étaler dans un format large -->
<!-- pivot_wider(names_from = résultat, values_from = données) %>% -->
<!-- mutate( -->
<!-- ## calculer l'âge moyen pour le groupe de décès -->
<!-- Death_mean = map(Death, ~mean(.x$age, na.rm = TRUE)), -->
<!-- ## calculer le sd parmi les morts -->
<!-- Death_sd = map(Death, ~sd(.x$age, na.rm = VRAI)), -->
<!-- ## calculer l'âge moyen pour le groupe de récupération -->
<!-- Recover_mean = map(Recover, ~mean(.x$age, na.rm = TRUE)), -->
<!-- ## calculer le sd parmi les récupérés -->
<!-- Recover_sd = map(Recover, ~sd(.x$age, na.rm = TRUE)), -->
<!-- ## en utilisant les deux ensembles de données groupées, comparer l'âge moyen avec un test t -->
<!-- ## garder seulement la valeur p.value -->
<!-- t_test = map2(Death, Recover, ~t.test(.x$age, .y$age)$p.value) -->
<!-- ) %>% -->
<!-- ## drop datasets -->
<!-- select(-Death, -Recover) %>% -->
<!-- ## retourner un jeu de données avec les médianes et la valeur p.value (drop missing) -->
<!-- unnest(cols = everything()) -->

<!-- ``` -->


<!-- #### Test de la somme des rangs de Wilcoxon {.unnumbered} -->

<!-- ```{r wilcox_dplyr} -->

<!-- linelist %>% -->
<!-- ## ne garder que les variables d'intérêt -->
<!-- select(age, outcome) %>% -->
<!-- ## drop those missing outcome -->
<!-- filter(!is.na(outcome)) %>% -->
<!-- ## spécifier la variable de groupage -->
<!-- group_by(outcome) %>% -->
<!-- ## créer un sous-ensemble de données pour chaque groupe (sous forme de liste) -->
<!-- nest() %>% -->
<!-- ## étaler dans un format large -->
<!-- pivot_wider(names_from = résultat, values_from = données) %>% -->
<!-- mutate( -->
<!-- ## calculer l'âge médian pour le groupe de décès -->
<!-- Death_median = map(Death, ~median(.x$age, na.rm = TRUE)), -->
<!-- ## calculer le sd parmi les morts -->
<!-- Death_iqr = map(Death, ~str_c( -->
<!-- quantile(.x$ âge, probs = c(0,25, 0,75), na.rm = VRAI), -->
<!-- effondrement = ", " -->
<!-- )), -->
<!-- ## calculer l'âge médian pour le groupe recover -->
<!-- Recover_median = map(Recover, ~median(.x$age, na.rm = VRAI)), -->
<!-- ## calculer le sd parmi les récupérés -->
<!-- Recover_iqr = map(Recover, ~str_c( -->
<!-- quantile(.x$ âge, probs = c(0.25, 0.75), na.rm = TRUE), -->
<!-- effondrement = ", " -->
<!-- )), -->
<!-- ## en utilisant les deux ensembles de données groupées, comparez la distribution des âges avec un test de wilcox -->
<!-- ## garder seulement la valeur p.value -->
<!-- wilcox = map2(Death, Recover, ~wilcox.test(.x$age, .y$age)$p.value) -->
<!-- ) %>% -->
<!-- ## drop datasets -->
<!-- select(-Death, -Recover) %>% -->
<!-- ## retourner un jeu de données avec les médianes et la valeur p.value (drop missing) -->
<!-- unnest(cols = everything()) -->

<!-- ``` -->

<!-- #### Test de Kruskal-wallis {.unnumbered} -->


<!-- ```{r kruskal_dplyr} -->

<!-- linelist %>% -->
<!-- ## ne garder que les variables d'intérêt -->
<!-- select(age, outcome) %>% -->
<!-- ## drop those missing outcome -->
<!-- filter(!is.na(outcome)) %>% -->
<!-- ## spécifier la variable de groupage -->
<!-- group_by(outcome) %>% -->
<!-- ## créer un sous-ensemble de données pour chaque groupe (sous forme de liste) -->
<!-- nest() %>% -->
<!-- ## étaler dans un format large -->
<!-- pivot_wider(names_from = résultat, values_from = données) %>% -->
<!-- mutate( -->
<!-- ## calculer l'âge médian pour le groupe de décès -->
<!-- Death_median = map(Death, ~median(.x$age, na.rm = TRUE)), -->
<!-- ## calculer le sd parmi les morts -->
<!-- Death_iqr = map(Death, ~str_c( -->
<!-- quantile(.x$ âge, probs = c(0,25, 0,75), na.rm = VRAI), -->
<!-- effondrement = ", " -->
<!-- )), -->
<!-- ## calculer l'âge médian pour le groupe recover -->
<!-- Recover_median = map(Recover, ~median(.x$age, na.rm = VRAI)), -->
<!-- ## calculer le sd parmi les récupérés -->
<!-- Recover_iqr = map(Recover, ~str_c( -->
<!-- quantile(.x$ âge, probs = c(0.25, 0.75), na.rm = TRUE), -->
<!-- effondrement = ", " -->
<!-- )), -->
<!-- ## en utilisant le jeu de données original comparer la distribution de l'âge avec un test de kruskal -->
<!-- ## garder uniquement la valeur p.value -->
<!-- kruskal = kruskal.test(linelist$age, linelist$outcome)$p.value -->
<!-- ) %>% -->
<!-- ## drop datasets -->
<!-- select(-Death, -Recover) %>% -->
<!-- ## retourner un jeu de données avec les médianes et la p.value (drop missing) -->
<!-- unnest(cols = everything()) -->

<!-- ``` -->

<!-- #### Test du khi-deux {.unnumbered} -->


<!-- ```{r} -->
<!-- linelist %>% -->
<!-- ## tout faire par sexe -->
<!-- group_by(outcome) %>% -->
<!-- ## compter la variable d'intérêt -->
<!-- count(gender) %>% -->
<!-- ## calculer la proportion -->
<!-- ## noter que le dénominateur est ici la somme de chaque sexe -->
<!-- mutate(pourcentage = n / somme(n) * 100) %>% -->
<!-- pivot_wider(names_from = outcome, values_from = c(n, percentage)) %>% -->
<!-- filter(!is.na(gender)) %>% -->
<!-- mutate(pval = chisq.test(linelist$gender, linelist$outcome)$p.value) -->



<!-- <!-- ======================================================= --> 

<!-- ## Corrélations -->

<!-- La corrélation entre les variables numériques peut être étudiée à l'aide de tidyverse -->
<!-- `corrr`. Il vous permet de calculer les corrélations en utilisant les coefficients de Pearson, de Kendall --> 
<!-- tau ou Spearman rho. Le package crée un tableau et dispose également d'une fonction pour -->
<!-- tracer automatiquement les valeurs.  -->

<!-- ``{r, warning=F, message=F} -->

<!-- correlation_tab <- linelist %>% -->
<!-- select(generation, age, ct_blood, days_onset_hosp, wt_kg, ht_cm) %>% # garder les variables numériques d'intérêt -->
<!-- correlate() # créer une table de corrélation (en utilisant pearson par défaut) -->

<!-- correlation_tab # print -->

<!-- ## supprimer les entrées dupliquées (le tableau ci-dessus est en miroir) -->
<!-- correlation_tab <- correlation_tab %>% -->
<!-- shave() -->

<!-- ## visualisation du tableau de corrélation -->
<!-- correlation_tab -->

<!-- ## tracer les corrélations -->
<!-- rplot(correlation_tab) -->
<!-- ``` -->


<!-- ======================================================= -->

## Ressources { }

La plupart des informations de cette page sont adaptées de ces ressources et vignettes en ligne :  

[gtsummary](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html)
[dplyr](https://dplyr.tidyverse.org/articles/grouping.html)
[corrr](https://corrr.tidymodels.org/articles/using-corrr.html)
[sthda correlation](http://www.sthda.com/english/wiki/correlation-test-between-two-variables-in-r)
