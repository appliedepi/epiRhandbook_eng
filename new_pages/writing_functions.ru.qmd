# Написание функций  


<!-- ======================================================= -->
## Подготовка {  }


### Загрузка пакетов {-}

Данный фрагмент кода показывает загрузку пакетов, требуемых для анализа. В данном руководстве мы подчеркиваем использование `p_load()` из **pacman**, которая устанавливает пакет, если необходимо, *и* загружает его для использования. Вы можете также загрузить установленные пакеты с помощью `library()` из **базового** R. См. дополнительную информацию о пакетах R на странице [Основы R](basics.ru.qmd).  

```{r, echo=F, warning=F, message=F}
pacman::p_load(
  rio,          # импорт файла
  here,         # путь к файлу
  skimr,        # получение обзора данных
  tidyverse,    # управление данными + графика ggplot2, 
  gtsummary,    # сводная статистика и тесты
  janitor,      # добавление итого и процентов к таблицам
  scales,       # легкая конвертация долей в проценты  
  flextable,     # конвертация таблиц в HTML
  purrr,          #облегчает функциональное программирование
  readr,          #для чтения csv файлов
  highcharter     #для создания объектов highchart и рисования конкретных графиков

  )
```

### Импорт данных {-}

Мы импортируем набор данных о случаях из имитированной эпидемии Эболы. Если вы хотите скачать данные, чтобы выполнять шаги параллельно, см. инструкции на странице [Скачивание руководства и данных](data_used.ru.qmd). Набор данных импортируется с помощью функции `import()` из пакета **rio**. См. страницу [Импорт и экспорт](importing.ru.qmd), где приводятся разные способы импорта данных.

Мы также используем в последней части этой страницы некоторые данные по гриппу H7N9 2013 года.

```{r, echo=F}
# import the linelists into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

flu_china <- rio::import(here::here("data", "case_linelists", "fluH7N9_China_2013.csv"))

```


## Функции  

Функции полезны в программировании, так как позволяют сделать код проще для понимания, короче и менее подверженным ошибкам (при условии отсутствия ошибок в самой функции).

Если вы дошли до этого руководства, значит, вы столкнулись с бесконечным количеством функций, поскольку в R каждая операция - это вызов функции,
`+, for, if, [, $, { …`. Например `x + y` - это то же самое, что`'+'(x, y)`

R - один из тех языков, которые предлагают наибольшие возможности для работы с функциями и предоставляют пользователю достаточно инструментов для их легкого написания. Мы не должны думать о функциях как о фиксированных на вершине или в конце цепочки программирования, R предлагает возможность использовать их как векторы и даже использовать их внутри других функций, списков...

Существует много очень продвинутых ресурсов по функциональному программированию, и мы приведем здесь лишь краткие практические примеры, которые помогут вам начать знакомство с функциональным программированием. Для более подробного ознакомления с функциональным программированием мы предлагаем вам посетить ссылки на источники.





## Зачем использовать функцию? 

Прежде чем ответить на этот вопрос, важно отметить, что вы уже получили советы по написанию своих первых функций на языке R на странице [Итерации, циклы и списки] данного руководства. На самом деле, использование "if/else" и циклов часто является ключевой частью многих наших функций, поскольку они позволяют легким образом расширить применение нашего кода, чтобы допускать несколько условий или проводить итерацию кода для повторяющихся задач.

- Я повторяю несколько раз один и тот же блок кода, чтобы применить его к другой переменной или данным?

- Избавление от него существенно сократит общий код и ускорит его выполнение?

- Возможно ли, что написанный мною код используется снова, но с другим значением во многих местах кода?

Если ответ на один из предыдущих вопросов "ДА", то, скорее всего, необходимо написать функцию

## Как R строит функции?

Функции в R имеют три основных компонента:

- `formals()` - это список аргументов, которые контролируют то, как мы можем вызвать функцию

- `body()` - код внутри функции, т.е. внутри квадратных скобок или после круглых скобок, смотря как мы его запишем

и,

- `environment()`, который помогает найти переменные функции и определяет, как функция находит значение.
 
Как только вы создали свою функцию, вы можете верифицировать каждый из этих компонентов, вызвав соответствующую функцию.
 

## Базовый синтаксис и структура

- Функцию необходимо правильно назвать, чтобы ее работа была понятна сразу после прочтения ее имени. Собственно, так уже сделано в большинстве базовых архитектур R. Такие функции, как  `mean()`, `print()`, `summary()` имеют очень понятные имена 

- Функции потребуются аргументы, такие как данные, с которыми нужно работать, и другие объекты, которые могут быть статическими значениями, среди прочих опций  

- И, наконец, функция выдает результат, исходя из своей основной задачи и переданных ей аргументов. Обычно мы используем встроенные функции, такие как `print()`, `return()`... для создания выходных данных. Выходными данными могут быть логическое значение, число, текст, датафрейм...по сути, любой объект R.

Вот так выглядит состав функции:

```{r, eval=FALSE}

function_name <- function(argument_1, argument_2, argument_3){
  
           function_task
  
           return(output)
}


```

Мы можем создать нашу первую функцию, которую назовем `contain_covid19()`. 

```{r}

contain_covid19 <- function(barrier_gest, wear_mask, get_vaccine){
  
                            if(barrier_gest == "yes" & wear_mask == "yes" & get_vaccine == "yes" ) 
       
                            return("success")
  
  else("please make sure all are yes, this pandemic has to end!")
}


```

Мы можем затем верифицировать компоненты нашей новой созданной функции.

```{r}

formals(contain_covid19)
body(contain_covid19)
environment(contain_covid19)

```


Теперь мы протестируем нашу функцию. Для вызова написанной нами функции необходимо использовать ее так же, как и все функции R, т.е. написать имя функции и добавить необходимые аргументы.

```{r}

contain_covid19(barrier_gest = "yes", wear_mask = "yes", get_vaccine = "yes")

```

Для надежности мы можем еще раз написать имя каждого аргумента. Но и без их указания код должен работать, поскольку R имеет в памяти расположение каждого аргумента. Поэтому, если значения аргументов расположены в правильном порядке, можно не писать имена аргументов при вызове функций.

```{r}

contain_covid19("yes", "yes", "yes")

```

Далее посмотрим, что произойдет, если одно из значений `"no"` (нет) или **не** `"yes"` (да).

```{r}

contain_covid19(barrier_gest = "yes", wear_mask = "yes", get_vaccine = "no")
```

Если мы зададим аргумент, который не распознан, мы получим ошибку: 

```{r, eval=F}
contain_covid19(barrier_gest = "sometimes", wear_mask = "yes", get_vaccine = "no")
```

`Error in contain_covid19(barrier_gest = "sometimes", wear_mask = "yes",  : 
  could not find function "contain_covid19"`


<span style="color: black;">**_ПРИМЕЧАНИЕ:_** Некоторые функции (в большинстве случаев очень короткие и простые) могут не требовать имени и могут использоваться напрямую в строке кода или внутри другой функции для выполнения быстрых задач. Их называют **анонимные функции** .</span>

Например, ниже приведена первая анонимная функция, которая сохраняет только текстовые переменные в наборе данных.


```{r, eval=F}
linelist %>% 
  dplyr::slice_head(n=10) %>%  #эквивалентно функции из базового R "head", возвращает первые n наблюдений набора данных
  select(function(x) is.character(x)) 
```
  
```{r, echo=F}
linelist %>% 
  dplyr::slice_head(n=10) %>%  #эквивалентно функции из базового R "head", возвращает первые n наблюдений набора данных
  select(function(x) is.character(x)) %>%  
DT::datatable(rownames = FALSE, filter="top", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )
```


Затем еще одна функция, которая выбирает каждое второе наблюдение из нашего набора данных (это может быть актуально, когда мы имеем продольные данные с большим количеством записей на пациента, например, после упорядочивания по дате или посещению).
В этом случае подходящей функцией вне dplyr будет `function (x) (x%%2 == 0)`, чтобы применить к вектору, содержащему все номера строк.


```{r, eval=F}
linelist %>%   
   slice_head(n=20) %>% 
   tibble::rownames_to_column() %>% # добавляем индексы каждого наблюдения как имена строк, чтобы четко видеть итоговый выбор
   filter(row_number() %%2 == 0)
```

```{r, echo=F}
linelist %>%   
   slice_head(n=20) %>% 
   tibble::rownames_to_column() %>%    # добавляем индексы каждого наблюдения как имена строк, чтобы четко видеть итоговый выбор
   filter(row_number() %%2 == 0) %>% 
DT::datatable(rownames = FALSE, filter="top", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )

```


Возможный код в базовом R для той же задачи может выглядеть так:

```{r, eval = F}

linelist_firstobs <- head(linelist, 20)

linelist_firstobs[base::Filter(function(x) (x%%2 == 0), seq(nrow(linelist_firstobs))),]
```

```{r, echo=F}

linelist_firstobs <- head(linelist, 20)

linelist_firstobs[base::Filter(function(x) (x%%2 == 0), seq(nrow(linelist_firstobs))),] %>% 
DT::datatable(rownames = FALSE, filter="top", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )

```


<span style="color: orange;">**_ВНИМАНИЕ:_** Хотя использование функций действительно может помочь нам в работе с кодом, тем не менее написание некоторых функций или исправление одной из них, если она не была тщательно продумана, написана адекватно и в результате возвращает ошибки, может занять много времени. Поэтому часто рекомендуется сначала написать код на языке R, убедиться, что он выполняет то, что мы задумали, а затем преобразовать его в функцию, состоящую из трех основных компонентов, перечисленных выше. </span>

## Примеры  

### Выдача таблиц долей для нескольких столбцов {.unnumbered}  

Да, во многих пакетах уже есть хорошие функции, позволяющие очень просто и красиво обобщать информацию. Но мы все же попробуем сделать свои собственные, в рамках наших первых шагов по освоению написания функций.

В этом примере мы хотим показать, как написание простой функции позволяет избежать многократного копирования одного и того же кода.

```{r}

proptab_multiple <- function(my_data, var_to_tab){
  
  #печать имен каждой интересующей переменной перед табуляцией
  print(var_to_tab)

  with(my_data,
       rbind( #связать результаты двух следующих функций по строкам
        #табуляция интересующей переменной: дает только числа
          table(my_data[[var_to_tab]], useNA = "no"),
          #расчет долей для каждой интересующей переменной и округление значения до 2 знаков после запятой
         round(prop.table(table(my_data[[var_to_tab]]))*100,2)
         )
       )
}


proptab_multiple(linelist, "gender")

proptab_multiple(linelist, "age_cat")

proptab_multiple(linelist, "outcome")


```

<span style="color: darkgreen;">**_СОВЕТ:_** Как было показано выше, очень важно комментировать свои функции так же, как это делается при общем программировании. Следует помнить, что цель функции - сделать код легко читаемым, более коротким и эффективным. Тогда можно понять, что делает функция, просто прочитав ее название, а более подробную информацию можно получить, прочитав комментарии.</span>


Второй вариант - использовать эту функцию внутри другой в цикле, чтобы провести процесс сразу:

```{r}


for(var_to_tab in c("gender","age_cat",  "outcome")){
  
  print(proptab_multiple(linelist, var_to_tab))
  
}

```

Более простой способ - использование "apply" из базового R вместо "цикла for", как выражено ниже:

```{r, include= FALSE, eval=FALSE}

base::lapply(linelist[,c("gender","age_cat", "outcome")], table)

```


<span style="color: darkgreen;">**_СОВЕТ:_** R часто определяется как функциональный язык программирования, и почти каждый раз, когда вы запускаете строку кода, вы используете некоторые встроенные функции. Хорошей привычкой для более комфортного написания функций является частое внутреннее рассмотрение того, как построены основные функции, которые вы используете ежедневно. Вы можете выбрать имя функции и затем использовать горячие клавиши `Ctrl+F2` или `fn+F2` или `Cmd+F2` (в зависимости от вашего компьютера) .</span>

## Использование **purrr**: написание функций, которые могут применяться итеративно

### Модификация класса нескольких столбцов в наборе данных {.unnumbered}  

Представим, что нужно поменять множество текстовых переменных в оригинальных данных `linelist` на класс "фактор"  для анализа и построения графиков. Вместо того, чтобы повторять один шаг несколько раз, мы можем использовать `lapply()`, чтобы применить это преобразование ко всем нужным переменным в одной строке кода.


<span style="color: orange;">**_ВНИМАНИЕ:_** `lapply()` выдает список, поэтому может потребовать дополнительной модификации в качестве последнего шага.</span>


```{r, include=FALSE}

linelist_factor1 <- linelist %>%
      lapply(
          function(x) if(is.character(x)) as.factor(x) else x) %>%
      as.data.frame() %>% 
      glimpse()

```


Тот же шаг можно сделать с помощью функции `map_if()` из пакета **purrr**

```{r}

linelist_factor2 <- linelist %>%
  purrr::map_if(is.character, as.factor)


linelist_factor2 %>%
        glimpse()

```


### Итеративное создание графиков для разных уровней переменной {.unnumbered}

Здесь мы построим круговую диаграмму, чтобы посмотреть распределение исходов пациентов в Китае во время вспышки заболевания H7N9 для каждой провинции. Вместо того чтобы повторять код для каждой из них, мы просто применим созданную нами функцию.

```{r}

#уточнение опций для использования в highchart
options(highcharter.theme =   highcharter::hc_theme_smpl(tooltip = list(valueDecimals = 2)))


#создаем функцию под названием "chart_outcome_province", которая берет в качестве аргумента набор данных и название провинции, по которой строится график распределения исходов.

chart_outcome_province <- function(data_used, prov){
  
  tab_prov <- data_used %>% 
    filter(province == prov,
           !is.na(outcome))%>% 
    group_by(outcome) %>% 
    count() %>%
    adorn_totals(where = "row") %>% 
    adorn_percentages(denominator = "col", )%>%
    mutate(
        perc_outcome= round(n*100,2))
  
  
  tab_prov %>%
    filter(outcome != "Total") %>% 
  highcharter::hchart(
    "pie", hcaes(x = outcome, y = perc_outcome),
    name = paste0("Distibution of the outcome in:", prov)
    )
  
}

chart_outcome_province(flu_china, "Shanghai")
chart_outcome_province(flu_china,"Zhejiang")
chart_outcome_province(flu_china,"Jiangsu")


```



### Итеративное создание таблиц для разных уровней переменной {.unnumbered}

Здесь мы создадим три показателя, которые сведем в таблицу, и хотим получить эту таблицу для каждой из провинций. Наши показатели - это задержка между началом заболевания и госпитализацией, процент выздоровления и средний возраст больных.

```{r}


indic_1 <- flu_china %>% 
  group_by(province) %>% 
  mutate(
    date_hosp= strptime(date_of_hospitalisation, format = "%m/%d/%Y"),
    date_ons= strptime(date_of_onset, format = "%m/%d/%Y"), 
    delay_onset_hosp= as.numeric(date_hosp - date_ons)/86400,
    mean_delay_onset_hosp = round(mean(delay_onset_hosp, na.rm=TRUE ), 0)) %>%
  select(province, mean_delay_onset_hosp)  %>% 
  distinct()
     

indic_2 <-  flu_china %>% 
            filter(!is.na(outcome)) %>% 
            group_by(province, outcome) %>% 
            count() %>%
            pivot_wider(names_from = outcome, values_from = n) %>% 
    adorn_totals(where = "col") %>% 
    mutate(
        perc_recovery= round((Recover/Total)*100,2))%>% 
  select(province, perc_recovery)
    
    
    
indic_3 <-  flu_china %>% 
            group_by(province) %>% 
            mutate(
                    median_age_cases = median(as.numeric(age), na.rm = TRUE)
            ) %>% 
  select(province, median_age_cases)  %>% 
  distinct()

#соединяем три набора данных с индикаторами

table_indic_all <- indic_1 %>% 
  dplyr::left_join(indic_2, by = "province") %>% 
        left_join(indic_3, by = "province")


#печатаем индикаторы в виде таблицы flextable


print_indic_prov <-  function(table_used, prov){
  
  #сначала немного преобразовываем датафрейм для легкости печати
  indic_prov <- table_used %>%
    filter(province==prov) %>%
    pivot_longer(names_to = "Indicateurs", cols = 2:4) %>% 
   mutate( indic_label = factor(Indicateurs,
   levels= c("mean_delay_onset_hosp","perc_recovery","median_age_cases"),
   labels=c("Mean delay onset-hosp","Percentage of recovery", "Median age of the cases"))
   ) %>% 
    ungroup(province) %>% 
    select(indic_label, value)
  

    tab_print <- flextable(indic_prov)  %>%
    theme_vanilla() %>% 
    flextable::fontsize(part = "body", size = 10) 
    
    
     tab_print <- tab_print %>% 
                  autofit()   %>%
                  set_header_labels( 
                indic_label= "Indicateurs", value= "Estimation") %>%
    flextable::bg( bg = "darkblue", part = "header") %>%
    flextable::bold(part = "header") %>%
    flextable::color(color = "white", part = "header") %>% 
    add_header_lines(values = paste0("Indicateurs pour la province de: ", prov)) %>% 
bold(part = "header")
 
 tab_print <- set_formatter_type(tab_print,
   fmt_double = "%.2f",
   na_str = "-")

tab_print 
    
}




print_indic_prov(table_indic_all, "Shanghai")
print_indic_prov(table_indic_all, "Jiangsu")


```


## Советы и наилучшие практики для хорошо работающих функций

Функциональное программирование призвано облегчить код и упростить его чтение. Оно не должно приводить к обратному. Приведенные ниже советы помогут вам получить чистый и легко читаемый код. 


### Именование и синтаксис {.unnumbered}

- Избегайте использования символов, которые легко могли бы быть уже заняты другими функциями, уже существующими в вашей среде

- Рекомендуется, чтобы имя функции было коротким и понятным для другого читателя

- Предпочтительно использовать глаголы в качестве имени функции и существительные для имен аргументов.


### Имена столбцов и оценка принципов аккуратности {.unnumbered}  

Если вы хотите знать, как ссылаться на *имена столбцов*, которые заданы в ваш код в виде аргументов, прочитайте это [руководство по программированию tidyverse](https://dplyr.tidyverse.org/articles/programming.html). Среди рассматриваемых тем - *оценка на предмет аккуратности* и использование *embrace* `{{ }}` "двойных фигурных скобок"

Например, вот краткий шаблон кода со страницы самоучителя, приведенного выше:  

```{r, eval=F}

var_summary <- function(data, var) {
  data %>%
    summarise(n = n(), min = min({{ var }}), max = max({{ var }}))
}
mtcars %>% 
  group_by(cyl) %>% 
  var_summary(mpg)

```


### Тестирование и работа с ошибками {.unnumbered}

Чем сложнее задача функции, тем выше вероятность возникновения ошибок. Поэтому иногда необходимо добавить некоторую верификацию внутри функции, чтобы быстро понять, откуда взялась ошибка, и найти способ ее устранения.

- Более чем рекомендуется ввести проверку на предмет отсутствия одного из аргументов с помощью `missing(argument)`. Эта простая проверка выдаст значение "TRUE" (ИСТИНА) или "FALSE" (ЛОЖЬ).

```{r , error=TRUE}

contain_covid19_missing <- function(barrier_gest, wear_mask, get_vaccine){
  
  if (missing(barrier_gest)) (print("please provide arg1"))
  if (missing(wear_mask)) print("please provide arg2")
  if (missing(get_vaccine)) print("please provide arg3")


  if (!barrier_gest == "yes" | wear_mask =="yes" | get_vaccine == "yes" ) 
       
       return ("you can do better")
  
  else("please make sure all are yes, this pandemic has to end!")
}


contain_covid19_missing(get_vaccine = "yes")

```


- Для других обнаружимых ошибок используйте `stop()`.

```{r, error=TRUE}

contain_covid19_stop <- function(barrier_gest, wear_mask, get_vaccine){
  
  if(!is.character(barrier_gest)) (stop("arg1 should be a character, please enter the value with `yes`, `no` or `sometimes"))
  
  if (barrier_gest == "yes" & wear_mask =="yes" & get_vaccine == "yes" ) 
       
       return ("success")
  
  else("please make sure all are yes, this pandemic has to end!")
}


contain_covid19_stop(barrier_gest=1, wear_mask="yes", get_vaccine = "no")

```

- Как мы видим, при выполнении большинства встроенных функций в определенных условиях могут появляться сообщения и предупреждения. Мы можем интегрировать их в наши написанные функции с помощью функций `message()` и `warning()`.

- Мы можем обрабатывать ошибки и с помощью функции `safely()`, которая принимает в качестве аргумента одну функцию и выполняет ее безопасным образом. Фактически функция будет выполняться без остановки, если встретит ошибку. `safely()` выдает в качестве выходного результата **список** с двумя объектами, которые являются результатами, а ошибка "пропускается".

Мы можем верифицировать первую, выполнив `mean()` в качестве функции, затем выполняем `safely()`.


```{r, warning=FALSE}

map(linelist, mean)
```


```{r, warning=FALSE}
safe_mean <- safely(mean)
linelist %>% 
  map(safe_mean)

```


Как говорилось ранее, подробное комментирование наших кодов является хорошим способом документирования нашей работы.  


<!-- ======================================================= -->
## Ресурсы


[R для науки о данных ссылка](https://r4ds.had.co.nz/functions.html)   

[Шпаргалка по продвинутому программированию R](https://www.rstudio.com/wp-content/uploads/2016/02/advancedR.pdf)

[Шпаргалка по пакету purr](https://purrr.tidyverse.org/)

[Видео-выступление Хэдли Викхэма на конференции ACM: радость функционального программирования (как работает map_dbl)](https://youtube.videoken.com/embed/bzUmK0Y07ck)