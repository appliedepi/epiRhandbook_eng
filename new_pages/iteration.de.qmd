# Iteration, Schleifen und Listen { }

Epidemiologen sehen sich oft mit wiederholten Analysen von Untergruppen wie Ländern, Bezirken oder Altersgruppen konfrontiert. Dies sind nur einige der vielen Situationen, in denen *Iteration*. Wenn du deine iterativen Operationen mit den folgenden Ansätzen kodierst, kannst du solche sich wiederholenden Aufgaben schneller erledigen, die Fehlerwahrscheinlichkeit verringern und die Codelänge reduzieren.

Auf dieser Seite werden zwei Ansätze für iterative Operationen vorgestellt - mit *for-Schleifen* und die Verwendung des Pakets **purrr**.

1) *for-Schleifen* iterieren den Code über eine Reihe von Eingaben, sind aber in R weniger verbreitet als in anderen Programmiersprachen. Trotzdem stellen wir sie hier als Lernwerkzeug und Referenz vor
2) Die **purrr** Paket ist das **tidyverse** Ansatz für iterative Operationen - er funktioniert, indem er eine Funktion auf viele Eingaben (Werte, Spalten, Datensätze usw.) "abbildet".

Auf dem Weg dorthin werden wir Beispiele zeigen wie:

- Importieren und Exportieren von mehreren Dateien
- Erstellen von Epikurven für mehrere Gerichtsbarkeiten
- T-Tests für mehrere Spalten in einem Datenrahmen durchführen

In der **purrr** [Abschnitt](#iter_purrr) werden wir auch einige Beispiele für die Erstellung und Handhabung von `lists`.

## Vorbereitung {  }

### Pakete laden {.unnumbered}

Dieser Codeabschnitt zeigt das Laden von Paketen, die für die Analysen benötigt werden. In diesem Handbuch betonen wir `p_load()` von **pacman**, der das Paket bei Bedarf installiert *und* lädt es zur Verwendung. Du kannst installierte Pakete auch laden mit `library()` von **base**R. Siehe die Seite über [R-Grundlagen] für weitere Informationen über R-Pakete.

```{r}
pacman::p_load(
     rio,         # import/export
     here,        # file locator
     purrr,       # iteration
     grates,      # scales in ggplot
     tidyverse    # data management and visualization
)
```

### Daten importieren {.unnumbered}

Wir importieren den Datensatz der Fälle aus einer simulierten Ebola-Epidemie. Wenn du mitmachen willst, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>klicke, um die "saubere" Linienliste herunterzuladen</a> (als .rds-Datei). Importiere Daten mit dem `import()` Funktion aus der **rio**Paket (sie verarbeitet viele Dateitypen wie .xlsx, .csv, .rds - siehe die [Import und Export] Seite für Details).

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import the linelist
linelist <- import("linelist_cleaned.rds")
```

Die ersten 50 Zeilen der Linienliste werden unten angezeigt.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

<!-- ======================================================= -->

## *for-Schleifen* {  }

### *for-Schleifen* in R {#iter\_loops .unnumbered}

*for-Schleifen* werden in R nicht besonders betont, sind aber in anderen Programmiersprachen üblich. Als Anfänger können sie hilfreich sein, um sie zu erlernen und zu üben, weil es einfacher ist, sie zu "erforschen", zu "entstören" und auf andere Weise genau zu verstehen, was bei jeder Iteration passiert, vor allem, wenn du noch nicht in der Lage bist, deine eigenen Funktionen zu schreiben.

Du kannst dich schnell durch *for-Schleifen* zum Iterieren mit gemappten Funktionen mit **purrr** (siehe [Abschnitt unten](#iter_purrr)).

### Kernkomponenten {.unnumbered}

A *for-Schleife* hat drei Hauptbestandteile:

1) Die **Reihenfolge** der Elemente, die durchlaufen werden sollen
2) Die **Operationen** die pro Position in der Sequenz durchzuführen sind
3) Die **Container** für die Ergebnisse (optional)

Die grundlegende Syntax lautet: `for (item in sequence) {do operations using item}`. Beachte die Klammern und die geschweiften Klammern. Die Ergebnisse können auf der Konsole ausgedruckt oder in einem Container-R-Objekt gespeichert werden.

Eine einfache *for-Schleife* Beispiel ist unten zu sehen.

```{r}
for (num in c(1,2,3,4,5)) {  # the SEQUENCE is defined (numbers 1 to 5) and loop is opened with "{"
  print(num + 2)             # The OPERATIONS (add two to each sequence number and print)
}                            # The loop is closed with "}"                            
                             # There is no "container" in this example
```

### Sequenz {.unnumbered}

Dies ist der "for"-Teil einer *for-Schleife* - Die Operationen werden "für" jedes Element in der Sequenz ausgeführt. Die Sequenz kann eine Reihe von Werten sein (z. B. Namen von Gerichtsbarkeiten, Krankheiten, Spaltennamen, Listenelementen usw.) oder eine Reihe von aufeinanderfolgenden Zahlen (z. B. 1,2,3,4,5). Jede Methode hat ihre eigenen Vorteile, die im Folgenden beschrieben werden.

Die Grundstruktur einer Sequenzanweisung ist `item in vector`.

- Du kannst jedes beliebige Zeichen oder Wort anstelle von "item" schreiben (z.B. "i", "num", "hosp", "district", etc.). Der Wert dieses "item" ändert sich bei jeder Iteration der Schleife, wobei jeder Wert im Vektor durchlaufen wird.
- Die *Vektor* kann aus Zeichenwerten, Spaltennamen oder einer Reihe von Zahlen bestehen - das sind die Werte, die sich bei jeder Iteration ändern werden. Du kannst sie innerhalb der *for-Schleife* Operationen mit dem Begriff "item" verwenden.

**Beispiel: Folge von Zeichenwerten**

In diesem Beispiel wird eine Schleife für jeden Wert in einem vordefinierten Zeichenvektor mit Krankenhausnamen ausgeführt.

```{r}
# make vector of the hospital names
hospital_names <- unique(linelist$hospital)
hospital_names # print
```

Wir haben den Begriff `hosp` gewählt, um die Werte aus dem Vektor `hospital_names`. Bei der ersten Iteration der Schleife wird der Wert von `hosp` sein ` hospital_names[[1]]`. Für die zweite Schleife ist er ` hospital_names[[2]]`. Und so weiter...

```{r, eval=F}
# a 'for loop' with character sequence

for (hosp in hospital_names){       # sequence
  
       # OPERATIONS HERE
  }
```

**Beispiel: Reihenfolge der Spaltennamen**

Dies ist eine Abwandlung der obigen Zeichenfolge, bei der die Namen eines bestehenden R-Objekts extrahiert und zum Vektor gemacht werden. Zum Beispiel die Spaltennamen eines Datenrahmens. Praktischerweise werden im Operationscode des *for-Schleife* können die Spaltennamen verwendet werden, um *indexieren* (Untermenge) ihres ursprünglichen Datenrahmens

Unten ist die Sequenz die `names()` (Spaltennamen) der `linelist` Datenrahmens. Unser "Element"-Name ist `col` der im weiteren Verlauf der Schleifen für jeden Spaltennamen stehen wird.

Für die Zwecke des Beispiels fügen wir den Code für die Operationen innerhalb der *for-Schleife* ein, der für jeden Wert in der Folge ausgeführt wird. In diesem Code werden die Sequenzwerte (Spaltennamen) verwendet, um *zu indizieren* (Teilmenge) `linelist`einer nach dem anderen. Wie im Kurs [R-Grundlagen] Seite beschrieben, werden doppelte Branches`[[ ]]` zum Subsumieren verwendet werden. Die resultierende Spalte wird an `is.na()` und dann an `sum()` um die Anzahl der fehlenden Werte in der Spalte zu ermitteln. Das Ergebnis wird auf der Konsole ausgegeben - eine Zahl für jede Spalte.

Ein Hinweis zur Indizierung mit Spaltennamen - wenn du auf die Spalte selbst verweist *schreibe nicht einfach "col"!* `col` steht nur für den Namen der Spalte! Um auf die gesamte Spalte zu verweisen, musst du den Spaltennamen als *Index* auf  verwenden. `linelist` über `linelist[[col]]`.

```{r}
for (col in names(linelist)){        # loop runs for each column in linelist; column name represented by "col" 
  
  # Example operations code - print number of missing values in column
  print(sum(is.na(linelist[[col]])))  # linelist is indexed by current value of "col"
     
}
```

**Zahlenreihenfolge**

Bei diesem Ansatz ist die Sequenz eine Reihe von aufeinanderfolgenden Zahlen. Der Wert des "Elements" ist also kein Zeichenwert (z. B. "Zentralkrankenhaus" oder "Datum\_Untergang"), sondern eine Zahl. Das ist nützlich, um eine Schleife durch Datenrahmen zu ziehen, denn du kannst die "item"-Nummer innerhalb der *for-Schleife* verwenden, um den Datenrahmen zu indizieren durch *Zeilennummer*.

Angenommen, du möchtest eine Schleife durch jede Zeile in deinem Datenrahmen ziehen und bestimmte Informationen extrahieren. Deine "Items" wären dann numerische Zeilennummern. Oft werden "Items" in diesem Fall geschrieben als `i`.

Die *for-Schleife* Prozess könnte mit folgenden Worten erklärt werden: "Für jedes Element in einer Folge von Zahlen von 1 bis zur Gesamtzahl der Zeilen in meinem Datenrahmen mache X". Bei der ersten Iteration der Schleife wird der Wert von "item" `i` 1 sein. Für die zweite Iteration, `i` 2 sein usw.

So sieht die Reihenfolge im Code aus: `for (i in 1:nrow(linelist)) {OPERATIONS CODE}` wo `i` für das "Element" steht und `1:nrow(linelist)` eine Folge von aufeinanderfolgenden Zahlen von 1 bis zur Anzahl der Zeilen in `linelist`.

```{r, eval=F}
for (i in 1:nrow(linelist)) {  # use on a data frame
  # OPERATIONS HERE
}  
```

Wenn die Folge aus Zahlen bestehen soll, du aber von einem Vektor (und nicht von einem Datenrahmen) ausgehst, verwende die Abkürzung `seq_along()` um eine Zahlenfolge für jedes Element des Vektors zurückzugeben. Zum Beispiel, `for (i in seq_along(hospital_names) {OPERATIONS CODE}`.

Der folgende Code gibt tatsächlich Zahlen zurück, die den Wert von `i` in ihrer jeweiligen Schleife.

```{r}
seq_along(hospital_names)  # use on a named vector
```

Ein Vorteil der Verwendung von Zahlen in der Sequenz ist, dass es einfach ist, auch die `i` Nummer als Index für eine *Container* zu indizieren, in dem die Schleifenausgänge gespeichert werden. Ein Beispiel dafür findest du im Abschnitt Operationen weiter unten.

### Vorgänge {.unnumbered}

Das ist der Code innerhalb der geschweiften Klammern `{ }` der *for-Schleife*. Du möchtest, dass dieser Code für jedes "Element" in der *Sequenz*. Achte deshalb darauf, dass jeder Teil deines Codes, der sich durch das "Item" ändert, korrekt kodiert ist, damit er sich tatsächlich ändert! Denke z.B. daran, dass du `[[ ]]` für die Indexierung.

Im folgenden Beispiel durchlaufen wir jede Zeile in der Datei `linelist`. Die `gender` und `age` Werte jeder Zeile werden zusammengeklebt und im Containerzeichenvektor gespeichert `cases_demographics`. Beachte, dass wir auch die Indexierung verwenden `[[i]]` verwenden, um die Schleifenausgabe an der richtigen Stelle im "Container"-Vektor zu speichern.

```{r}
# create container to store results - a character vector
cases_demographics <- vector(mode = "character", length = nrow(linelist))

# the for loop
for (i in 1:nrow(linelist)){
  
  # OPERATIONS
  # extract values from linelist for row i, using brackets for indexing
  row_gender  <- linelist$gender[[i]]
  row_age     <- linelist$age_years[[i]]    # don't forget to index!
     
  # combine gender-age and store in container vector at indexed location
  cases_demographics[[i]] <- str_c(row_gender, row_age, sep = ",") 

}  # end for loop


# display first 10 rows of container
head(cases_demographics, 10)
```

### Container {.unnumbered}

Manchmal sind die Ergebnisse deines *for-Schleife* auf der Konsole oder im Plots-Fenster von RStudio ausgegeben werden. In anderen Fällen möchtest du die Ergebnisse in einem "Container" zur späteren Verwendung speichern. Ein solcher Container kann ein Vektor, ein Datenrahmen oder sogar eine Liste sein.

Am effizientesten ist es, den Container für die Ergebnisse zu erstellen *zu ers, bevor* bevor man die *for-Schleife*. In der Praxis bedeutet das, dass du einen leeren Vektor, Datenrahmen oder eine Liste erstellst. Diese können mit folgenden Funktionen erstellt werden `vector()` für Vektoren oder Listen erstellt werden, oder mit `matrix()` und `data.frame()` für einen Datenrahmen.

**Leerer Vektor**

verwenden `vector()` und gib den `mode = ` basierend auf der erwarteten Klasse der Objekte, die du einfügen willst - entweder "double" (für Zahlen), "character" oder "logical". Du solltest auch die `length = ` im Voraus festlegen. Dies sollte die Länge deines *for-Schleife* Sequenz sein.

Angenommen, du möchtest den Median der Wartezeit bis zur Einlieferung für jedes Krankenhaus speichern. Du würdest "double" verwenden und die Länge auf die Anzahl der erwarteten Ausgaben (die Anzahl der einzelnen Krankenhäuser im Datensatz) setzen.

```{r}
delays <- vector(
  mode = "double",                            # we expect to store numbers
  length = length(unique(linelist$hospital))) # the number of unique hospitals in the dataset
```

**Leerer Datenrahmen**

Du kannst einen leeren Datenrahmen erstellen, indem du die Anzahl der Zeilen und Spalten wie folgt angibst:

```{r, eval=F}
delays <- data.frame(matrix(ncol = 2, nrow = 3))
```

**Leere Liste**

Du möchtest vielleicht einige Plots speichern, die von einem *for-Schleife* in einer Liste speichern. Eine Liste ist wie ein Vektor, enthält aber andere R-Objekte, die von verschiedenen Klassen sein können. Elemente in einer Liste können eine einzelne Zahl, ein Datenrahmen, ein Vektor und sogar eine andere Liste sein.

Du initialisierst eine leere Liste mit der gleichen `vector()` Befehl wie oben, aber mit `mode = "list"`. Gib die Länge der Liste an, wie du willst.

```{r, eval=F}
plots <- vector(mode = "list", length = 16)
```

### Drucken {.unnumbered}

Beachten Sie, dass Sie zum Drucken aus einer *for-Schleife* zu drucken, musst du wahrscheinlich explizit mit der Funktion `print()`.

In diesem Beispiel unten ist die Sequenz ein expliziter Zeichenvektor, der verwendet wird, um die Zeilenliste nach Krankenhaus zu unterteilen. Die Ergebnisse werden nicht in einem Container gespeichert, sondern auf der Konsole mit der Option `print()` Funktion.

```{r}
for (hosp in hospital_names){ 
     hospital_cases <- linelist %>% filter(hospital == hosp)
     print(nrow(hospital_cases))
}
```

### Testen deiner for-Schleife {.unnumbered}

Um deine Schleife zu testen, kannst du einen Befehl ausführen, der eine temporäre Zuweisung des "Elements" vornimmt, z. B. `i <- 10` oder `hosp <- "Central Hospital"`. Tu dies *außerhalb der Schleife* und führe dann nur deinen Operationscode aus (den Code innerhalb der geschweiften Klammern), um zu sehen, ob die erwarteten Ergebnisse erzielt werden.

### Schleifenplots {.unnumbered}

Um alle drei Komponenten (Container, Sequenz und Operationen) zusammenzubringen, wollen wir versuchen, für jedes Krankenhaus eine Epikurve zu zeichnen (siehe Seite über [Epidemie-Kurven]).

Wir können eine schöne Epikurve erstellen von *allen* der Fälle nach Geschlecht erstellen, indem wir die **Inzidenz2** Paket wie unten beschrieben:

```{r, warning=F, message=F}
# create 'incidence' object
outbreak <- incidence2::incidence(   
     x = linelist,                   # dataframe - complete linelist
     date_index = "date_onset",        # date column
     interval = "week",              # aggregate counts weekly
     groups = "gender")               # group values by gender
     #na_as_group = TRUE)             # missing gender is own group

# tracer la courbe d'épidémie
ggplot(outbreak, # nom de l'objet d'incidence
        aes(x = date_index, #aesthetiques et axes
            y = count, 
            fill = gender), # Fill colour of bars by gender
       color = "black"      # Contour colour of bars
       ) +  
     geom_col() + 
     facet_wrap(~gender) +
     theme_bw() + 
     labs(title = "Outbreak of all cases", #titre
          x = "Counts", 
          y = "Date", 
          fill = "Gender", 
          color = "Gender")


```

Um ein separates Diagramm für die Fälle eines jeden Krankenhauses zu erstellen, können wir diesen Epikurvencode in eine *for-Schleife*.

Zuerst speichern wir einen benannten Vektor mit den eindeutigen Namen der Krankenhäuser, `hospital_names`. Die *for-Schleife* wird für jeden dieser Namen einmal durchlaufen: `for (hosp in hospital_names)`. Jede Iteration der *for-Schleife* wird der aktuelle Krankenhausname aus dem Vektor dargestellt als `hosp` für die Verwendung innerhalb der Schleife.

Innerhalb der Schleifenoperationen kannst du den R-Code wie gewohnt schreiben, aber das "Item" (`hosp` in diesem Fall) mit dem Wissen, dass sich sein Wert ändern wird. Innerhalb dieser Schleife:

- A `filter()` wird angewendet auf `linelist`, so dass die Spalte `hospital` gleich dem aktuellen Wert von `hosp`
- Das Inzidenzobjekt wird auf der gefilterten Lineliste erstellt
- Der Plot für das aktuelle Krankenhaus wird erstellt, mit einem sich automatisch anpassenden Titel, der die `hosp`
- Das Diagramm für das aktuelle Krankenhaus wird zwischengespeichert und dann gedruckt
- Die Schleife geht dann weiter und wiederholt sich mit dem nächsten Krankenhaus in `hospital_names`

```{r, out.width="50%", message=F}
# make vector of the hospital names
hospital_names <- unique(linelist$hospital)

# for each name ("hosp") in hospital_names, create and print the epi curve
for (hosp in hospital_names) {
     
     # create incidence object specific to the current hospital
     outbreak_hosp <- incidence2::incidence(
          x = linelist %>% filter(hospital == hosp),   # linelist is filtered to the current hospital
          date_index = "date_onset",
          interval = "week", 
          groups = "gender"#,
          #na_as_group = TRUE
     )
     
      plot_hosp <- ggplot(outbreak_hosp, # incidence object name
                         aes(x = date_index, #axes
                             y = count, 
                             fill = gender), # fill colour by gender
                         color = "black"      # colour of bar contour
                         ) +  
          geom_col() + 
          facet_wrap(~gender) +
          theme_bw() + 
          labs(title = stringr::str_glue("Epidemic of cases admitted to {hosp}"), #title
               x = "Counts", 
               y = "Date", 
               fill = "Gender", 
               color = "Gender")
     
     # With older versions of R, remove the # before na_as_group and use this plot command instead.
    # plot_hosp <- plot(
#       outbreak_hosp,
#       fill = "gender",
#       color = "black",
#       title = stringr::str_glue("Epidemic of cases admitted to {hosp}")
#     )
     
     #print the plot for hospitals
     print(plot_hosp)
     
} # end the for loop when it has been run for every hospital in hospital_names 
```

### Verfolgen des Fortschritts einer Schleife {.unnumbered}

Eine Schleife mit vielen Iterationen kann viele Minuten oder sogar Stunden lang laufen. Daher kann es hilfreich sein, den Fortschritt auf der R-Konsole auszugeben. Die `if` Anweisung kann wie folgt platziert werden *innerhalb von* der Schleifenoperationen platziert werden, um jede 100ste Zahl zu drucken. Passe sie einfach so an, dass `i` das "Element" in deiner Schleife ist.

```{r, eval=F}
# loop with code to print progress every 100 iterations
for (i in seq_len(nrow(linelist))){

  # print progress
  if(i %% 100==0){    # The %% operator is the remainder
    print(i)

}
```

<!-- ======================================================= -->

## **purrr** und Listen {#iter\_purrr}

Ein weiterer Ansatz für iterative Operationen ist die **purrr** Paket - es ist die **tidyverse** Ansatz zur Iteration.

Wenn du dieselbe Aufgabe mehrmals ausführen musst, lohnt es sich wahrscheinlich, eine verallgemeinerte Lösung zu erstellen, die du für viele Eingaben verwenden kannst. So kannst du zum Beispiel Plots für mehrere Gerichtsbarkeiten erstellen oder viele Dateien importieren und kombinieren.

Es gibt noch ein paar andere Vorteile, die **purrr** - Du kannst es mit Rohren verwenden `%>%`, es behandelt Fehler besser als normal *for-Schleifen* und die Syntax ist sehr sauber und einfach! Wenn du eine *for-Schleife* verwendest, kannst du es wahrscheinlich klarer und prägnanter machen mit **purrr**!

Denke daran, dass **purrr** ist eine *funktionales Programmierwerkzeug*. Das heißt, die Operationen, die iterativ angewendet werden sollen, werden in *Funktionen*. Siehe die [Funktionen schreiben] Seite, um zu erfahren, wie du deine eigenen Funktionen schreiben kannst.

**purrr** basiert auch fast vollständig auf *Listen* und *Vektoren* - Betrachte es also als Anwendung einer Funktion auf jedes Element der Liste/des Vektors!

### Pakete laden {.unnumbered}

**purrr** ist Teil der **tidyverse** ist Teil von tidyverse, du musst also kein separates Paket installieren/laden.

```{r}
pacman::p_load(
     rio,            # import/export
     here,           # relative filepaths
     tidyverse,      # data mgmt and viz
     writexl,        # write Excel file with multiple sheets
     readxl          # import Excel with multiple sheets
)
```

### `map()` {.unnumbered}

Ein Kern **purrr** Funktion ist `map()` die eine Funktion auf jedes Eingabeelement einer Liste/eines Vektors, den du angibst, "abbildet" (anwendet).

Die grundlegende Syntax lautet `map(.x = SEQUENCE, .f = FUNCTION, OTHER ARGUMENTS)`. Ein bisschen ausführlicher:

- `.x = ` Sind die *Eingänge* auf denen die `.f` Funktion iterativ angewendet wird - z. B. ein Vektor von Zuständigkeitsnamen, Spalten in einem Datenrahmen oder eine Liste von Datenrahmen
- `.f = ` ist die *Funktion* die auf jedes Element der Tabelle anzuwenden ist. `.x` Inputs anzuwenden - es könnte eine Funktion sein wie `print()` sein, die bereits existiert, oder eine eigene Funktion, die du definierst. Die Funktion wird oft nach einer Tilde geschrieben `~` geschrieben (Details weiter unten).

Noch ein paar Hinweise zur Syntax:

- Wenn für die Funktion keine weiteren Argumente angegeben werden müssen, kann sie ohne Klammern und ohne Tilde geschrieben werden (z.B. `.f = mean`). Um Argumente anzugeben, die bei jeder Iteration den gleichen Wert haben, gibst du sie innerhalb von `map()` aber außerhalb der `.f = ` Argumentes, wie zum Beispiel das `na.rm = T` in `map(.x = my_list, .f = mean, na.rm=T)`.
- Du kannst `.x` (oder einfach `.`) *innerhalb von* der `.f = ` Funktion als Platzhalter für die `.x` Wert dieser Iteration
- Verwende die Tilde-Syntax (`~`), um eine bessere Kontrolle über die Funktion zu haben - schreibe die Funktion ganz normal mit Klammern, wie z. B: `map(.x = my_list, .f = ~mean(., na.rm = T))`. Verwende diese Syntax vor allem dann, wenn sich der Wert eines Arguments bei jeder Iteration ändert, oder wenn es sich um den Wert `.x` selbst ist (siehe Beispiele unten)

**Die Ausgabe der Verwendung von `map()` ist eine *Liste*** - Eine Liste ist eine Objektklasse wie ein Vektor, deren Elemente aber unterschiedliche Klassen haben können. Eine Liste wird also erzeugt durch `map()` erzeugte Liste kann also viele Datenrahmen, viele Vektoren, viele Einzelwerte oder sogar viele Listen enthalten! Es gibt alternative Versionen von `map()` die weiter unten erklärt werden und andere Arten von Ausgaben erzeugen (z. B. `map_dfr()` um einen Datenrahmen zu erzeugen, `map_chr()` um Zeichenvektoren zu erzeugen, und `map_dbl()` um numerische Vektoren zu erzeugen).

#### Beispiel - Excel-Tabellen importieren und kombinieren {#iter\_combined .unnumbered}

**Lass uns das anhand einer gängigen Aufgabe für Epidemiologen demonstrieren:** - 
 *Du möchtest eine Excel-Arbeitsmappe mit Falldaten importieren, aber die Daten sind auf verschiedene benannte Blätter in der Arbeitsmappe verteilt. Wie kannst du die Blätter effizient importieren und in einem Datenrahmen zusammenfassen?*

Nehmen wir an, wir erhalten die unten stehende Excel-Arbeitsmappe. Jedes Blatt enthält Fälle aus einem bestimmten Krankenhaus.

```{r, fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "hospital_linelists_excel_sheets.png"))
```

Hier ist ein Ansatz, bei dem `map()`:

1) `map()` Die Funktion `import()` so, dass sie für jedes Excel-Blatt ausgeführt wird
2) Kombiniere die importierten Datenrahmen zu einem einzigen mit `bind_rows()`
3) Behalte dabei den ursprünglichen Blattnamen für jede Zeile bei und speichere diese Information in einer neuen Spalte im endgültigen Datenrahmen

Zuerst müssen wir die Blattnamen extrahieren und speichern. Wir geben den Dateipfad der Excel-Arbeitsmappe an die Funktion `excel_sheets()` aus dem Paket **readxl**, das die Blattnamen extrahiert. Wir speichern sie in einem Zeichenvektor namens `sheet_names`.

```{r, echo=F}
sheet_names <- readxl::excel_sheets(here::here("data", "example", "hospital_linelists.xlsx"))

```

```{r, eval=F}
sheet_names <- readxl::excel_sheets("hospital_linelists.xlsx")
```

Hier sind die Namen:

```{r}
sheet_names
```

Jetzt haben wir diesen Vektor von Namen, `map()` können wir sie nacheinander an die Funktion `import()`. In diesem Beispiel wird die `sheet_names` sind `.x` und `import()` ist die Funktion `.f`.

Rückruf aus dem [Import und Export] Seite, dass bei der Verwendung in Excel-Arbeitsmappen ,`import()` das Argument akzeptieren kann `which = ` akzeptieren, das das zu importierende Blatt angibt. Innerhalb der `.f` Funktion `import()` stellen wir `which = .x` an, deren Wert sich bei jeder Iteration durch den Vektor ändert `sheet_names` - zuerst "Zentralkrankenhaus", dann "Militärkrankenhaus", usw.

Zu beachten ist - weil wir die `map()` verwendet haben, werden die Daten in jedem Excel-Blatt als ein separater Datenrahmen innerhalb einer Liste gespeichert. Wir möchten, dass jedes dieser Listenelemente (Datenrahmen) einen *Namen* haben, bevor wir also `sheet_names` an `map()` passieren wir es durch `set_names()` von **purrr**, wodurch sichergestellt wird, dass jedes Listenelement den richtigen Namen erhält.

Wir speichern die Ausgabeliste als `combined`.

```{r, echo=F}
combined <- sheet_names %>% 
  purrr::set_names() %>% 
  map(.f = ~import(here::here("data", "example", "hospital_linelists.xlsx"), which = .x))
```

```{r, eval=F}
combined <- sheet_names %>% 
  purrr::set_names() %>% 
  map(.f = ~import("hospital_linelists.xlsx", which = .x))
```

Wenn wir die Ausgabe überprüfen, sehen wir, dass die Daten aus jedem Excel-Blatt mit einem Namen in der Liste gespeichert sind. Das ist gut, aber wir sind noch nicht ganz fertig.

```{r, fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "sheets_as_list.png"))
```

Zum Schluss verwenden wir die Funktion `bind_rows()` (von **dplyr**), die eine Liste ähnlich strukturierter Datenrahmen akzeptiert und sie zu einem Datenrahmen kombiniert. Um eine neue Spalte aus dem Listenelement zu erstellen *Namen* zu erstellen, verwenden wir das Argument `.id = ` und geben ihm den gewünschten Namen für die neue Spalte.

Im Folgenden findest du die gesamte Befehlssequenz:

```{r, echo=F}
sheet_names <- readxl::excel_sheets(here::here("data", "example", "hospital_linelists.xlsx"))

combined <- sheet_names %>% 
  purrr::set_names() %>% 
  map(.f = ~import(here::here("data", "example", "hospital_linelists.xlsx"), which = .x)) %>% 
  bind_rows(.id = "origin_sheet")
```

```{r, eval=F}
sheet_names <- readxl::excel_sheets("hospital_linelists.xlsx")  # extract sheet names
 
combined <- sheet_names %>%                                     # begin with sheet names
  purrr::set_names() %>%                                        # set their names
  map(.f = ~import("hospital_linelists.xlsx", which = .x)) %>%  # iterate, import, save in list
  bind_rows(.id = "origin_sheet") # combine list of data frames, preserving origin in new column  
```

Und jetzt haben wir einen Datenrahmen mit einer Spalte, die das Ursprungsblatt enthält!

```{r, fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "sheets_as_df.png"))
```

Es gibt Variationen von `map()` die du kennen solltest. Zum Beispiel, `map_dfr()` einen Datenrahmen zurück, keine Liste. Wir hätten ihn also für die obige Aufgabe verwenden können und hätten keine Zeilen binden müssen. Aber dann hätten wir nicht erfassen können, aus welchem Blatt (Krankenhaus) die einzelnen Fälle stammen.

Andere Varianten sind `map_chr()`, `map_dbl()`. Diese Funktionen sind aus zwei Gründen sehr nützlich. Erstens wandeln sie die Ausgabe einer iterativen Funktion automatisch in einen Vektor (und nicht in eine Liste) um. Zweitens können sie explizit die Klasse steuern, in der die Daten zurückkommen - du stellst sicher, dass deine Daten als Zeichenvektor zurückkommen mit `map_chr()` oder als numerischer Vektor mit `map_dbl()`. Darauf kommen wir später in diesem Abschnitt zurück!

Die Funktionen `map_at()` und `map_if()` sind ebenfalls sehr nützlich für die Iteration - mit ihnen kannst du angeben, welche Elemente einer Liste du iterieren sollst! Sie funktionieren, indem sie einfach einen Vektor von Indizes/Namen anwenden (im Fall von `map_at()`) oder einen logischen Test (im Fall von `map_if()`).

Nehmen wir ein Beispiel, bei dem wir das erste Blatt der Krankenhausdaten nicht lesen wollten. Wir verwenden `map_at()` anstelle von `map()`, und geben die `.at = ` Argument an `c(-1)` an, was bedeutet *nicht* das erste Element von `.x`. Alternativ kannst du auch einen Vektor mit positiven Zahlen oder Namen an `.at = ` geben, um anzugeben, welche Elemente verwendet werden sollen.

```{r, echo=F}
sheet_names <- readxl::excel_sheets(here::here("data", "example", "hospital_linelists.xlsx"))

combined <- sheet_names %>% 
     purrr::set_names() %>% 
     # exclude the first sheet
     map_at(.f = ~import(here::here("data", "example", "hospital_linelists.xlsx"), which = .x),
            .at = c(-1))
```

```{r, eval=F}
sheet_names <- readxl::excel_sheets("hospital_linelists.xlsx")

combined <- sheet_names %>% 
     purrr::set_names() %>% 
     # exclude the first sheet
     map_at(.f = ~import( "hospital_linelists.xlsx", which = .x),
            .at = c(-1))
```

Beachte, dass der erste Blattname immer noch als Element der Ausgabeliste erscheint - aber es ist nur ein einstelliger Name (kein Datenrahmen). Du müsstest dieses Element entfernen, bevor du Zeilen bindest. Wie du Listenelemente entfernst und änderst, erfährst du in einem späteren Abschnitt.

### Datensatz aufteilen und exportieren {.unnumbered}

Im Folgenden geben wir ein Beispiel dafür, wie man einen Datensatz in Teile aufteilt und dann mit `map()` Iteration, um jeden Teil als separates Excel-Blatt oder als separate CSV-Datei zu exportieren.

#### Datensatz teilen {.unnumbered}

Nehmen wir an, wir haben den vollständigen Fall `linelist` als Datenrahmen und wollen nun für jedes Krankenhaus eine eigene Liste erstellen und diese als separate CSV-Datei exportieren. Im Folgenden führen wir die folgenden Schritte aus:

Verwende `group_split()` (von **dplyr**) zum Aufteilen der `linelist` Datenrahmen nach eindeutigen Werten in der Spalte `hospital`. Die Ausgabe ist eine Liste mit einem Datenrahmen pro Krankenhaus-Teilmenge.

```{r}
linelist_split <- linelist %>% 
     group_split(hospital)
```

Wir können `View(linelist_split)` ausführen und sehen, dass diese Liste 6 Datenrahmen ("Tibbles") enthält, die jeweils die Fälle eines Krankenhauses repräsentieren.

```{r, fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "purrr_linelist_split.png"))
```

Beachte jedoch, dass die Datenrahmen in der Liste standardmäßig keine Namen haben! Wir möchten, dass jeder Datenrahmen einen Namen hat und dass dieser Name beim Speichern der CSV-Datei verwendet wird.

Eine Möglichkeit, die Namen zu extrahieren, ist die Verwendung von `pull()` (aus **dplyr**) zum Extrahieren der `hospital` Spalte aus jedem Datenrahmen in der Liste zu extrahieren. Um sicherzugehen, wandeln wir die Werte dann in Zeichen um und verwenden dann `unique()` um den Namen für den jeweiligen Datenrahmen zu erhalten. Alle diese Schritte werden für jeden Datenrahmen über `map()`.

```{r}
names(linelist_split) <- linelist_split %>%   # Assign to names of listed data frames 
     # Extract the names by doing the following to each data frame: 
     map(.f = ~pull(.x, hospital)) %>%        # Pull out hospital column
     map(.f = ~as.character(.x)) %>%          # Convert to character, just in case
     map(.f = ~unique(.x))                    # Take the unique hospital name
```

Wir können nun sehen, dass jedes Listenelement einen Namen hat. Auf diese Namen kann man über `names(linelist_split)`.

```{r, fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "purrr_linelist_split_named.png"))
```

```{r}
names(linelist_split)
```

##### Mehr als eine `group_split()` Spalte {.unnumbered}

Wenn du die Zeilenliste aufteilen möchtest nach *mehr als eine Gruppierungsspalte* aufteilen möchtest, z. B. um eine Unterliste nach Krankenhaus UND Geschlecht zu erstellen, brauchst du einen anderen Ansatz für die Benennung der Listenelemente. Dazu musst du die eindeutigen "Gruppenschlüssel" mit `group_keys()` von **dplyr** - werden sie als Datenrahmen zurückgegeben. Dann kannst du die Gruppenschlüssel zu Werten kombinieren mit `unite()` zu Werten kombinieren, wie unten gezeigt, und diese Konglomeratnamen den `linelist_split`.

```{r}
# split linelist by unique hospital-gender combinations
linelist_split <- linelist %>% 
     group_split(hospital, gender)

# extract group_keys() as a dataframe
groupings <- linelist %>% 
     group_by(hospital, gender) %>%       
     group_keys()

groupings      # show unique groupings 
```

Nun fassen wir die Gruppierungen zusammen, trennen sie durch Bindestriche und weisen sie als Namen von Listenelementen in `linelist_split`. Dies erfordert einige zusätzliche Zeilen, da wir die `NA` durch "Fehlend", verwenden `unite()` von **dplyr** um die Spaltenwerte zusammenzufassen (durch Bindestriche getrennt) und dann in einen unbenannten Vektor zu konvertieren, damit er als Namen für `linelist_split`.

```{r, eval=F}
# Combine into one name value 
names(linelist_split) <- groupings %>% 
     mutate(across(everything(), replace_na, "Missing")) %>%  # replace NA with "Missing" in all columns
     unite("combined", sep = "-") %>%                         # Unite all column values into one
     setNames(NULL) %>% 
     as_vector() %>% 
     as.list()
```

#### Als Excel-Blätter exportieren {.unnumbered}

So exportieren Sie die Krankenhaus-Listen als *eine Excel-Arbeitsmappe mit einer Strichliste pro Blatt* können wir einfach die benannte Liste bereitstellen `linelist_split` an die `write_xlsx()` Funktion von der **writexl** Paket. Diese Funktion ermöglicht es, eine Excel-Arbeitsmappe mit mehreren Blättern zu speichern. Die Namen der Listenelemente werden automatisch als Blattnamen übernommen.

```{r, eval=F}
linelist_split %>% 
     writexl::write_xlsx(path = here("data", "hospital_linelists.xlsx"))
```

Du kannst jetzt die Excel-Datei öffnen und sehen, dass jedes Krankenhaus sein eigenes Blatt hat.

```{r, fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "purrr_export_sheets.png"))
```

#### Exportieren als CSV-Dateien {.unnumbered}

Dieser Befehl ist etwas komplizierter, aber du kannst auch jede krankenhausspezifische Linienliste als separate CSV-Datei exportieren, mit einem Dateinamen, der dem Krankenhaus entspricht.

Auch hier verwenden wir `map()`: Wir nehmen den Vektor der Listenelementnamen (siehe oben) und verwenden `map()` um durch sie zu iterieren, indem wir `export()` (aus dem **rio**Paket, siehe [Import und Export] Seite) auf den Datenrahmen in der Liste`linelist_split` der diesen Namen trägt. Wir verwenden den Namen auch, um einen eindeutigen Dateinamen zu erstellen. So funktioniert es:

- Wir beginnen mit dem Vektor der Zeichennamen, der an `map()` als `.x`
- Die `.f` Funktion ist `export()` die einen Datenrahmen und einen Dateipfad benötigt, in den geschrieben werden soll
- Die Eingabe `.x` (der Name des Krankenhauses) wird verwendet *innerhalb von* `.f` zu extrahieren/indizieren, um dieses spezifische Element von `linelist_split` Liste. Dies führt dazu, dass jeweils nur ein Datenrahmen an die `export()`.
- Zum Beispiel, wenn `map()` nach "Militärkrankenhaus" iteriert, dann `linelist_split[[.x]]` ist eigentlich `linelist_split[["Military Hospital"]]` und liefert somit das zweite Element von `linelist_split` - das alle Fälle aus dem Militärkrankenhaus enthält.
- Der Dateipfad, der an `export()` ist dynamisch durch die Verwendung von `str_glue()`(siehe [Zeichen und Zeichenketten] Seite):
  - `here()` wird verwendet, um die Basis des Dateipfads zu erhalten und den Ordner "data" anzugeben (beachte einfache Anführungszeichen, um die `str_glue()` doppelten Anführungszeichen)
- Dann ein Schrägstrich `/`, und dann wieder der `.x` das den aktuellen Krankenhausnamen ausgibt, um die Datei identifizierbar zu machen
- Schließlich die Erweiterung ".csv", die `export()` verwendet, um eine CSV-Datei zu erstellen

```{r, eval=F, message=F, warning=F}
names(linelist_split) %>%
     map(.f = ~export(linelist_split[[.x]], file = str_glue("{here('data')}/{.x}.csv")))
```

Jetzt kannst du sehen, dass jede Datei im Ordner "data" des R-Projekts "Epi\_R\_handbook" gespeichert wird!

```{r, fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "purrr_export_csv.png"))
```

### Benutzerdefinierte Funktionen {.unnumbered}

Vielleicht möchtest du deine eigene Funktion erstellen, die du an `map()`.

Nehmen wir an, wir wollen Epidemiekurven für die Fälle eines jeden Krankenhauses erstellen. Um dies zu tun, verwenden wir **purrr** unsere `.f` Funktion kann sein `ggplot()` und Erweiterungen mit `+` wie üblich. Da die Ausgabe von `map()` immer eine Liste ist, werden auch die Plots in einer Liste gespeichert. Da es sich um Plots handelt, können sie extrahiert und mit der Funktion `ggarrange()` Funktion aus der **ggpubr** Paket ([Dokumentation](https://rpkgs.datanovia.com/ggpubr/reference/ggarrange.html)).

```{r, message=F, warning=F}

# load package for plotting elements from list
pacman::p_load(ggpubr)

# map across the vector of 6 hospital "names" (created earlier)
# use the ggplot function specified
# output is a list with 6 ggplots

hospital_names <- unique(linelist$hospital)

my_plots <- map(
  .x = hospital_names,
  .f = ~ggplot(data = linelist %>% filter(hospital == .x)) +
                geom_histogram(aes(x = date_onset)) +
                labs(title = .x)
)

# print the ggplots (they are stored in a list)
ggarrange(plotlist = my_plots, ncol = 2, nrow = 3)
```

Wenn diese `map()` Code zu chaotisch aussieht, kannst du das gleiche Ergebnis erzielen, indem du deine spezifischen `ggplot()` Befehl als benutzerdefinierte Funktion speicherst, zum Beispiel unter dem Namen `make_epicurve())`. Diese Funktion wird dann innerhalb der `map()`. `.x` iterativ durch den Namen des Krankenhauses ersetzt und als `hosp_name` in der `make_epicurve()`Funktion. Siehe die Seite über [Funktionen schreiben].

```{r, eval=F}
# Create function
make_epicurve <- function(hosp_name){
  
  ggplot(data = linelist %>% filter(hospital == hosp_name)) +
    geom_histogram(aes(x = date_onset)) +
    theme_classic()+
    labs(title = hosp_name)
  
}
```

```{r, eval=F}
# mapping
my_plots <- map(hospital_names, ~make_epicurve(hosp_name = .x))

# print the ggplots (they are stored in a list)
ggarrange(plotlist = my_plots, ncol = 2, nrow = 3)
```

### Eine Funktion spaltenübergreifend abbilden {.unnumbered}

Ein weiterer häufiger Anwendungsfall ist die Zuordnung einer Funktion über mehrere Spalten hinweg. Im Folgenden werden wir `map()` die Funktion `t.test()` auf die numerischen Spalten des Datenrahmens `linelist` und vergleicht die numerischen Werte nach Geschlecht.

Erinnere dich an die Seite über [Einfache statistische Tests] dass`t.test()` Eingaben im Formelformat annehmen können, wie zum Beispiel `t.test(numeric column ~ binary column)`. In diesem Beispiel gehen wir wie folgt vor:

- Die numerischen Spalten von Interesse werden ausgewählt aus `linelist` - diese werden zu den `.x` Eingaben für `map()`
- Die Funktion `t.test()` wird als die `.f` Funktion, die auf jede numerische Spalte angewendet wird
- Innerhalb der Klammern von `t.test()`:
  - die erste `~` geht dem `.f` dass `map()` wird iteriert über `.x`
  - die `.x` steht für die aktuelle Spalte, die an die Funktion übergeben wird `t.test()`
  - die zweite `~` ist Teil der oben beschriebenen t-Test-Gleichung
  - die `t.test()` Funktion erwartet eine binäre Spalte auf der rechten Seite der Gleichung. Wir liefern den Vektor `linelist$gender` unabhängig und statisch (beachte, dass er nicht in der `select()`).

`map()` gibt eine Liste zurück. Die Ausgabe ist also eine Liste mit t-Testergebnissen - ein Listenelement für jede analysierte numerische Spalte.

```{r}
# Results are saved as a list
t.test_results <- linelist %>% 
  select(age, wt_kg, ht_cm, ct_blood, temp) %>%  # keep only some numeric columns to map across
  map(.f = ~t.test(.x ~ linelist$gender))        # t.test function, with equation NUMERIC ~ CATEGORICAL
```

So sieht die Liste aus `t.test_results` aussieht, wenn sie in RStudio geöffnet (betrachtet) wird. Wir haben die Teile hervorgehoben, die für die Beispiele auf dieser Seite wichtig sind.

- Oben kannst du sehen, dass die gesamte Liste den Namen `t.test_results` heißt und fünf Elemente hat. Diese fünf Elemente heißen `age`, `wt_km`, `ht_cm`, `ct_blood`, `temp` nach jeder Variable, die in einem t-Test verwendet wurde, mit `gender` von der `linelist`.
- Jedes dieser fünf Elemente ist selbst eine Liste, mit Elementen innerhalb dieser Listen wie `p.value` und `conf.int`. Einige dieser Elemente wie `p.value` sind einzelne Zahlen, während einige wie `estimate` aus zwei oder mehr Elementen bestehen (`mean in group f` und `mean in group m`).

```{r, out.height="150%", echo=F}
knitr::include_graphics(here::here("images", "purrr_ttest.png"))
```

Hinweis: Wenn du eine Funktion nur auf bestimmte Spalten in einem Datenrahmen anwenden willst, kannst du auch einfach die `mutate()` und `across()`verwenden, wie im Abschnitt [Reinigung von Daten und Kernfunktionen] Seite erklärt wird. Unten findest du ein Beispiel für die Anwendung`as.character()` nur auf die Spalten "Alter". Beachte die Platzierung der Klammern und Kommas.

```{r, eval=F}
# convert columns with column name containing "age" to class Character
linelist <- linelist %>% 
  mutate(across(.cols = contains("age"), .fns = as.character))  
```

### Auszug aus den Listen {.unnumbered}

Als `map()` eine Ausgabe der Klasse Liste erzeugt, werden wir einige Zeit damit verbringen, zu erörtern, wie man Daten aus Listen extrahiert, indem man die zugehörigen **purrr** Funktionen. Um dies zu demonstrieren, werden wir die Liste `t.test_results` aus dem vorherigen Abschnitt. Dies ist eine Liste mit 5 Listen - jede der 5 Listen enthält die Ergebnisse eines t-Tests zwischen einer Spalte aus `linelist` Datenrahmen und seiner binären Spalte `gender`. Das Bild im obigen Abschnitt zeigt dir die Listenstruktur.

#### Namen der Elemente {.unnumbered}

Um die Namen der Elemente selbst zu extrahieren, verwendest du einfach `names()` von **base** R. In diesem Fall verwenden wir `names()` auf `t.test_results` um die Namen jeder Teilliste zurückzugeben, d.h. die Namen der 5 Variablen, für die t-Tests durchgeführt wurden.

```{r}
names(t.test_results)
```

#### Elemente nach Name oder Position {.unnumbered}

Um Listenelemente nach Namen oder nach Position zu extrahieren, kannst du Klammern verwenden `[[ ]]`verwenden, wie es in den [R-Grundlagen] Seite beschrieben. Im Folgenden verwenden wir doppelte Klammern, um die Liste zu indizieren`t.tests_results` und zeigen das erste Element an, das die Ergebnisse des t-Tests auf `age`.

```{r}
t.test_results[[1]] # first element by position
t.test_results[[1]]["p.value"] # return element named "p.value" from first element  
```

Im Folgenden werden wir jedoch die Verwendung der einfachen und flexiblen **purrr** Funktionen `map()` und `pluck()` um die gleichen Ergebnisse zu erzielen.

#### `pluck()` {.unnumbered}

`pluck()` zieht Elemente nach Namen oder nach Position heraus. Um zum Beispiel die Ergebnisse des t-Tests für das Alter zu extrahieren, kannst du Folgendes verwenden `pluck()` wie folgt:

```{r}
t.test_results %>% 
  pluck("age")        # alternatively, use pluck(1)
```

Indexiere tiefere Ebenen, indem du die weiteren Ebenen mit Kommas angibst. Im Folgenden wird das Element mit dem Namen "p.value" aus der Liste extrahiert `age` innerhalb der Liste `t.test_results`. Du kannst auch Zahlen anstelle von Zeichennamen verwenden.

```{r}
t.test_results %>% 
  pluck("age", "p.value")
```

Du kannst solche inneren Elemente aus *allen* Elementen der ersten Ebene extrahieren, indem du `map()` um die `pluck()` Funktion über jedes Element der ersten Ebene ausführt. Der folgende Code extrahiert zum Beispiel die "p.value"-Elemente aus allen Listen innerhalb `t.test_results`. Die Liste der t-Testergebnisse ist die `.x` durch iteriert, `pluck()` ist die `.f` Funktion, die iteriert wird, und der Wert "p-value" wird der Funktion übergeben.

```{r}
t.test_results %>%
  map(pluck, "p.value")   # return every p-value
```

Als weitere Alternative, `map()` bietet eine Abkürzung, bei der du den Namen des Elements in Anführungszeichen schreiben kannst und er wird dann herausgepickt. Wenn du den `map()` verwendest, ist die Ausgabe eine Liste, während du bei der Verwendung von `map_chr()` ein benannter Zeichenvektor ist und wenn du `map_dbl()` ein benannter numerischer Vektor sein wird.

```{r}
t.test_results %>% 
  map_dbl("p.value")   # return p-values as a named numeric vector
```

Du kannst mehr darüber lesen `pluck()` in seinem **purrr** [Dokumentation](https://purrr.tidyverse.org/reference/pluck.html). Sie hat eine Geschwisterfunktion `chuck()` die einen Fehler anstelle von NULL zurückgibt, wenn ein Element nicht existiert.

### Liste in Datenrahmen umwandeln {.unnumbered}

Dies ist ein komplexes Thema - im Abschnitt Ressourcen findest du ausführlichere Anleitungen. Dennoch wollen wir dir zeigen, wie du die Liste der t-Testergebnisse in einen Datenrahmen umwandelst. Wir erstellen einen Datenrahmen mit Spalten für die Variable, ihren p-Wert und die Mittelwerte der beiden Gruppen (männlich und weiblich).

Hier sind einige der neuen Ansätze und Funktionen, die wir verwenden werden:

- Die Funktion `tibble()` wird verwendet, um ein Tibble (wie einen Datenrahmen) zu erstellen
  - Wir umgeben die `tibble()` Funktion mit geschweiften Klammern `{ }` um zu verhindern, dass die gesamte `t.test_results` nicht als erste Tibble-Spalte gespeichert wird
- Innerhalb von `tibble()` wird jede Spalte explizit erstellt, ähnlich der Syntax von `mutate()`:
  - Die `.` steht für `t.test_results`
  - Um eine Spalte mit den Namen der t-Test-Variablen (die Namen der einzelnen Listenelemente) zu erstellen, verwenden wir `names()` wie oben beschrieben
  - Um eine Spalte mit den p-Werten zu erstellen, verwenden wir `map_dbl()` wie oben beschrieben, um die `p.value` Elemente und wandeln sie in einen numerischen Vektor um

```{r}
t.test_results %>% {
  tibble(
    variables = names(.),
    p         = map_dbl(., "p.value"))
  }
```

Fügen wir nun Spalten hinzu, die die Mittelwerte für jede Gruppe (Männer und Frauen) enthalten.

Dazu müssten wir das Element `estimate` extrahieren, aber das enthält eigentlich *zwei* Elemente in sich (`mean in group f` und `mean in group m`). Er kann also nicht zu einem Vektor vereinfacht werden mit `map_chr()` oder `map_dbl()`. Stattdessen verwenden wir `map()`, die innerhalb von `tibble()` verwendet wird, erzeugt *eine Spalte der Klassenliste innerhalb der Tibble*! Ja, das ist möglich!

```{r}
t.test_results %>% 
  {tibble(
    variables = names(.),
    p = map_dbl(., "p.value"),
    means = map(., "estimate"))}
```

Sobald du diese Listenspalte hast, gibt es mehrere **tidyr** Funktionen (Teil von **tidyverse**), die dir helfen, diese "verschachtelten Listenspalten" zu "entschachteln" oder zu "entschachteln". Lies mehr über sie [hier]() oder indem du `vignette("rectangle")`. Kurz gefasst:

- `unnest_wider()` - gibt jedem Element einer Listenspalte eine eigene Spalte
- `unnest_longer()` - gibt jedem Element einer Listenspalte eine eigene Zeile
- `hoist()` - verhält sich wie `unnest_wider()` aber du gibst an, welche Elemente entnestet werden sollen

Im Folgenden übergeben wir das Tibble an `unnest_wider()` und geben dabei die `means` Spalte (die eine verschachtelte Liste ist). Das Ergebnis ist, dass `means` durch zwei neue Spalten ersetzt wird, die jeweils die beiden Elemente enthalten, die vorher in jeder `means` Zelle waren.

```{r}
t.test_results %>% 
  {tibble(
    variables = names(.),
    p = map_dbl(., "p.value"),
    means = map(., "estimate")
    )} %>% 
  unnest_wider(means)
```

### Listen verwerfen, behalten und verdichten {.unnumbered}

Weil die Arbeit mit **purrr** so oft mit Listen zu tun hat, werden wir uns kurz mit einigen **purrr** Funktionen, um Listen zu verändern. Im Abschnitt Ressourcen findest du weitere vollständige Tutorials zu **purrr** Funktionen.

- `list_modify()` hat viele Verwendungszwecke, einer davon kann das Entfernen eines Listenelements sein
- `keep()` behält die Elemente bei, die in `.p = ` übergebenen Elemente, oder wenn eine Funktion, die an `.p = ` zu TRUE ausgewertet wird
- `discard()` werden die Elemente entfernt, die in `.p` angegebenen Elemente entfernt, oder wenn eine Funktion, die an `.p = ` zu TRUE ausgewertet wird
- `compact()` Entfernt alle leeren Elemente

Hier sind einige Beispiele, die die `combined` Liste, die im obigen Abschnitt über [map() verwenden, um mehrere Dateien zu importieren und zu kombinieren](#iter_combined) erstellt wurde (sie enthält 6 Case-Linelist-Datenrahmen):

Elemente können nach Namen entfernt werden mit `list_modify()` und dem Setzen des Namens gleich `NULL`.

```{r, eval=F}
combined %>% 
  list_modify("Central Hospital" = NULL)   # remove list element by name
```

Du kannst auch Elemente nach Kriterien entfernen, indem du eine "Prädikat"-Gleichung für `.p = ` (eine Gleichung, die entweder TRUE oder FALSE ergibt). Setze eine Tilde `~` vor die Funktion und verwende `.x` um das Listenelement darzustellen. verwenden `keep()` werden die Listenelemente, die als TRUE ausgewertet werden, beibehalten. Umgekehrt, wenn du `discard()` werden die Listenelemente, die TRUE ergeben, entfernt.

```{r, eval=F}
# keep only list elements with more than 500 rows
combined %>% 
  keep(.p = ~nrow(.x) > 500)  
```

Im folgenden Beispiel werden Listenelemente verworfen, wenn ihre Klasse kein Datenrahmen ist.

```{r, eval=F}
# Discard list elements that are not data frames
combined %>% 
  discard(.p = ~class(.x) != "data.frame")
```

Deine Prädikatsfunktion kann auch auf Elemente/Spalten innerhalb jedes Listenelements verweisen. Im folgenden Beispiel werden Listenelemente, die den Mittelwert der Spalte `ct_blood` über 25 liegt, verworfen werden.

```{r, eval=F}
# keep only list elements where ct_blood column mean is over 25
combined %>% 
  discard(.p = ~mean(.x$ct_blood) > 25)  
```

Dieser Befehl würde alle leeren Listenelemente entfernen:

```{r, eval=F}
# Remove all empty list elements
combined %>% 
  compact()
```

### `pmap()` {.unnumbered}

DIESER ABSCHNITT BEFINDET SICH IM AUFBAU

## Funktionen anwenden

Die Familie der "apply"-Funktionen ist eine **Basis** R Alternative zu **purrr** für iterative Operationen. Du kannst mehr über sie lesen [hier](https://www.datacamp.com/community/tutorials/r-tutorial-apply-family).

<!-- ======================================================= -->

## Ressourcen { }

[für Schleifen mit Data Carpentry](https://datacarpentry.org/semester-biology/materials/for-loops-R/)

Die [R for Data Science Seite über Iteration](https://r4ds.had.co.nz/iteration.html#iteration)

[Vignette zum Schreiben/Lesen von Excel-Dateien](https://martinctc.github.io/blog/vignette-write-and-read-multiple-excel-files-with-purrr/)

Ein Schnurren [tutorial](https://jennybc.github.io/purrr-tutorial/index.html) von jennybc

Noch ein Schnurrer [tutorial](http://www.rebeccabarter.com/blog/2019-08-19_purrr/) von Rebecca Barter

Ein Schnurren [tutorial](http://zevross.com/blog/2019/06/11/the-power-of-three-purrr-poseful-iteration-in-r-with-map-pmap-and-imap/) zu map, pmap und imap

[purrr cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/master/pngs/thumbnails/purrr-cheatsheet-thumbs.png)

[purrr Tipps und Tricks](https://www.emilhvitfeldt.com/post/2018-01-08-purrr-tips-and-tricks/)

[Behalten und wegwerfen](https://hookedondata.org/going-off-the-map/#keep-and-discard)


