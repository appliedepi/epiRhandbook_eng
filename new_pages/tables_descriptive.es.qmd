# Tablas descriptivas {#descriptive-tables} 

```{r out.width = c('75%'), fig.align='center', fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "descriptive_tables.png"))
```


Esta página muestra el uso de **janitor**, **dplyr**, **gtsummary**, **rstatix** y R **base** para resumir datos y crear tablas con estadísticas descriptivas. 

En *esta página se explica cómo* crear* las tablas subyacentes, mientras que en la página [Tablas para  presentaciones](#tables-for-presentation) se explica cómo darles un buen formato e imprimirlas.* 

Cada uno de estos paquetes tiene ventajas y desventajas en cuanto a la simplicidad del código, la accesibilidad de los resultados y la calidad de los resultados impresos. Utiliza esta página para decidir qué enfoque se ajusta a tu situación. 

Tienes varias opciones para producir tablas de resumen de tabulación y tabulación cruzada. Algunos de los factores a tener en cuenta son la simplicidad del código, la posibilidad de personalización, la salida deseada (impresa en la consola de R, como dataframe, o como una imagen .png/.jpeg/.html "bonita"), y la facilidad de posprocesamiento. Ten en cuenta los siguientes puntos a la hora de elegir la herramienta para tu situación. 

* Utiliza `tabyl()` de **janitor** para producir y "adornar" tabulaciones y tabulaciones cruzadas 
* Utiliza `get_summary_stats()` de **rstatix** para generar fácilmente dataframes de estadísticas de resumen numérico para múltiples columnas y/o grupos 
* Utiliza `summarise()` y `count()` de **dplyr** para obtener estadísticas más complejas, ordenar las salidas de los dataframes o preparar los datos para `ggplot()` 
* Utiliza `tbl_summary`() de **gtsummary** para producir tablas detalladas listas para su publicación 
* Utiliza `table()` de R **base** si no tienes acceso a los paquetes anteriores 


<!-- ======================================================= -->
## Preparación  {#preparation-8}

### Cargar paquetes {.unnumbered}

Este trozo de código muestra la carga de los paquetes necesarios para los análisis. En este manual destacamos `p_load()` de **pacman**, que instala el paquete si es necesario *y* lo carga para su uso. También puedes cargar los paquetes instalados con `library()` de R **base**. Consulta la página sobre [Fundamentos de R](#r-basics) para obtener más información sobre los paquetes de R. 


```{r, warning=F, message=F}
pacman::p_load(
  rio,          # Importación de ficheros
  here,         # localizador de ficheros
  skimr,        # obtener una visión general de los datos
  tidyverse,    # gestión de datos + gráficos ggplot2 
  gtsummary,    # resumen estadístico y tests
  rstatix,      # resumen estadístico y pruebas estadísticas
  janitor,      # añadir totales y porcentajes a las tablas
  scales,       # convertir fácilmente proporciones en porcentajes  
  flextable     # convertir tablas en imágenes bonitas
  )
```

### Importar datos  {.unnumbered}

Importamos los datos de casos de una epidemia de ébola simulada. Si quieres seguir el proceso, [clica para descargar `linelist` "limpio"](https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds) (como archivo .rds). Importa los datos con la función `import()` del paquete **rio** (acepta muchos tipos de archivos como .xlsx, .rds, .csv - Mira la página de [importación y exportación](#import-and-export) para más detalles). 

```{r, echo=F}
# importar el listado de casos en R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# importar el listado de casos
linelist <- import("linelist_cleaned.rds")
```

A continuación se muestran las primeras 50 filas del listado.

```{r, message=FALSE, echo=F}
# mostrar los datos en forma de tabla
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```





<!-- ======================================================= -->
## Visualizar datos {#browse-data}

### Paquete **skimr** {.unnumbered}

Utilizando el paquete skimr, puedes obtener una visión detallada y estéticamente agradable de cada una de las variables de tu conjunto de datos. Lee más sobre **skimr** en su [página de github](https://github.com/ropensci/skimr). 

A continuación, se aplica la función `skim()` a todo el dataframe `linelist`. Se produce una visión general del dataframe y un resumen de cada columna (por tipo). 

```{r eval=F}
## obtener información sobre cada variable de un conjunto de datos 
skim(linelist)
```

```{r  echo=F}
# Los histogramas sparkline no se muestran correctamente, así que los evito.
skim_without_charts(linelist)
```



También puedes utilizar la función `summary()`, de R **base**, para obtener información completta sobre unos datos, pero esta salida puede ser más difícil de leer que utilizando **skimr**. Por eso no se muestra a continuación esta salida, para ahorrar espacio de la página.   

```{r, eval=F}
## obtener información sobre cada variable de un conjunto de datos 
summary(linelist)
```


### Estadísticas resumidas  {.unnumbered} 

Puedes utilizar las funciones de R **base** para producir estadísticas de resumen sobre una columna numérica. Puedes producir la mayoría de las estadísticas de resumen útiles para una columna numérica utilizando `summary()`, como se indica a continuación. Ten en cuenta que también debe especificarse el nombre del dataframe, como se muestra a continuación. 

```{r}
summary(linelist$age_years)
```

Puedes acceder y guardar una parte específica de la misma con los corchetes de índice `[ ]`: 

```{r}
summary(linelist$age_years)[[2]]            # devuelve sólo el 2º elemento
# equivalente, alternativa a la anterior por nombre de elemento
# summary(linelist$age_years)[["1st Qu."]]  
```

Puedes mostrar estadísticas individuales con funciones de R **base** como  `max()`, `min()`, `median()`, `mean()`, `quantile()`, `sd()`, y `range()`. Consulta la página de [Fundamentos de R](#r-basics) para obtener una lista completa. 

***PRECAUCIÓN:*** Si tus datos contienen valores faltantes, R quiere que lo sepas y por ello mostrará `NA` a menos que se especifique en las funciones matemáticas anteriores que quieres que R ignore los valores faltantes, mediante el argumento `na.rm = TRUE`. 

Puedes utilizar la función `get_summary_stats()` de **rstatix** para producir las estadísticas de resumen *en un formato de dataframe*. Esto puede ser útil para realizar operaciones posteriores o trazar los números. Consulta la página [Tests estadísticos simples](#simple-statistical-tests) para obtener más detalles sobre el paquete **rstatix** y sus funciones. 

```{r}
linelist %>% 
  get_summary_stats(
    age, wt_kg, ht_cm, ct_blood, temp,  # columnas para calcular
    type = "common")                    # estadísticas resumidas 

```





## paquete **janitor** {#tbl_janitor}  

Los paquetes **janitor** ofrecen la función `tabyl()` para producir tabulaciones y tabulaciones cruzadas, que pueden ser "adornadas" o modificadas con funciones de ayuda para mostrar porcentajes, proporciones, recuentos, etc. 

A continuación, enlazamos el dataframe `linelist` con pipe a las funciones de **limpieza** e imprimimos el resultado. Si lo deseas, también puedes guardar las tablas resultantes con el operador de asignación `<-`.  

### Tabyl simple {.unnumbered}  

El uso por defecto de `tabyl()` en una columna específica produce los valores únicos, los recuentos y sus proporciones por columna. Las proporciones pueden tener muchos dígitos. Puedes ajustar el número de decimales con `adorn_rounding()` como se describe a continuación. 

```{r}
linelist %>% tabyl(age_cat)
```
Como puedes ver arriba, si hay valores que faltan se muestran en una fila etiquetada como `NA`. Puedes suprimirlos con `show_na = FALSE`. Si no hay valores faltantes, esta fila no aparecerá. Si hay valores faltantes, todas las proporciones se dan como crudas (el denominador incluye los recuentos de `NA`) y "válidas" (el denominador excluye los recuentos de `NA`). 

Si la columna es de tipo factor y sólo hay ciertos niveles en sus datos, todos los niveles seguirán apareciendo en la tabla. Puedes suprimir esta característica especificando `show_missing_levels = FALSE`. Lee más en la página de [Factores](#factors). 

### Tabulación cruzada  {.unnumbered}  

Los recuentos de tabulación cruzada se consiguen añadiendo una o más columnas adicionales dentro de `tabyl()`. Ten en cuenta que ahora sólo se muestran los recuentos - Las proporciones y porcentajes se pueden añadir con los pasos adicionales que se muestran a continuación.  

```{r}
linelist %>% tabyl(age_cat, gender)
```

### "Adornando" el tabyl {#tbl_adorn .unnumbered}  

Utiliza las funciones de "adorno" de **janitor** para añadir totales o convertir a proporciones, porcentajes, o ajustar la visualización de otro modo. A menudo, enlazarás el tabyl con pipe a través de varias de estas funciones. 


Función            | Resultado                         
-------------------|--------------------------------
`adorn_totals()`   | Añade los totales (`where = ` "row", "col", o "both"). Establecer `name =` para el "Total".     
`adorn_percentages()` | Convierte los recuentos en proporciones, con `denominator = ` "row", "col", o "all"  
`adorn_pct_formatting()` | Convierte las proporciones en porcentajes. Especifica los `digits =`. Elimina el símbolo "%" con `affix_sign = FALSE`.  
`adorn_rounding()` | Para redondear proporciones a `digits =`. Para redondear porcentajes utiliza `adorn_pct_formatting()` con `digits =`.   
`adorn_ns()` | Añade recuentos a una tabla de proporciones o porcentajes. indica la `position =` "rear" para mostrar los recuentos entre paréntesis, o "front" para poner los porcentajes entre paréntesis.    
`adorn_title()` | Añade una cadena mediante los argumentos `row_name = ` y/o `col_name = ` 

Se consciente del orden en que se aplican las funciones anteriores. A continuación, algunos ejemplos. 

Una simple tabla unidireccional con porcentajes en lugar de las proporciones por defecto. 

```{r}
linelist %>%               # lista de casos
  tabyl(age_cat) %>%       # tabular recuentos y proporciones por categoría de edad
  adorn_pct_formatting()   # convertir proporciones en porcentajes
```

Una tabulación cruzada con un total de filas y porcentajes de filas.  

```{r}
linelist %>%                                  
  tabyl(age_cat, gender) %>%                  # recuentos por edad y sexo
  adorn_totals(where = "row") %>%             # añadir fila con totales
  adorn_percentages(denominator = "row") %>%  # convertir recuentos en proporciones
  adorn_pct_formatting(digits = 1)            # convertir proporciones en porcentajes
```

Una tabulación cruzada ajustada para que aparezcan tanto los recuentos como los porcentajes.   

```{r}
linelist %>%                                  # lista de casos
  tabyl(age_cat, gender) %>%                  # tabulación cruzada de recuentos
  adorn_totals(where = "row") %>%             # añadir una fila de totales
  adorn_percentages(denominator = "col") %>%  # convertir a proporciones
  adorn_pct_formatting() %>%                  # convertir a porcentajes
  adorn_ns(position = "front") %>%            # mostrar como: "casos (porcent)"
  adorn_title(                                # ajustar títulos
    row_name = "Age Category",
    col_name = "Gender")
```



### Impresión del tabyl {.unnumbered}

Por defecto, el tabyl se imprimirá en crudo en la consola de R. 

Alternativamente, puedes pasar el tabyl a **flextable** o un paquete similar para imprimirlo como una imagen "bonita" en el visor de RStudio, que podría exportarse como .png, .jpeg, .html, etc. Esto se discute en la página [Tablas para  presentaciones](#tables-for-presentation). Ten en cuenta que si imprimes de esta manera y utilizas `adorn_titles()`, debes especificar `placement = "combined"`. 

```{r}
linelist %>%
  tabyl(age_cat, gender) %>% 
  adorn_totals(where = "col") %>% 
  adorn_percentages(denominator = "col") %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front") %>% 
  adorn_title(
    row_name = "Age Category",
    col_name = "Gender",
    placement = "combined") %>% # esto es necesario para imprimir como imagen
  flextable::flextable() %>%    # convertir a imagen bonita
  flextable::autofit()          # formatear a una línea por fila  

```


### Uso en otras tablas {.unnumbered}  

Puedes utilizar las funciones `adorn_()` de **janitor** en otras tablas, como las creadas por `summarise()` y `count()` de **dplyr**, o `table()` de R **base**. Por ejemplo: 

```{r}
linelist %>% 
  count(hospital) %>%   # función dplyr
  adorn_totals()        # función janitor
```


### Guardar el tabyl  {.unnumbered}  

Si conviertes la tabla en una imagen "bonita" con un paquete como **flextable**, puedes guardarla con funciones de ese paquete - como `save_as_html()`, `save_as_word()`, `save_as_ppt()`, y `save_as_image()`  de **flextable** (como se discute más ampliamente en la página [Tablas para presentaciones](#tables-for-presentation)). A continuación, la tabla se guarda como un documento de Word, en el que se puede seguir editando a mano.  

```{r, eval=F}
linelist %>%
  tabyl(age_cat, gender) %>% 
  adorn_totals(where = "col") %>% 
  adorn_percentages(denominator = "col") %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front") %>% 
  adorn_title(
    row_name = "Age Category",
    col_name = "Gender",
    placement = "combined") %>% 
  flextable::flextable() %>%                     # convertir a imagen
  flextable::autofit() %>%                       # asegurar sólo una línea por fila
  flextable::save_as_docx(path = "tabyl.docx")   # guardar como documento Word en la carpeta
```

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "tabyl_word.png"))
```

### Estadísticas {#janitor_age_out_stats .unnumbered}  

Puedes aplicar a las tabyl tests estadísticos como `chisq.test()` o `fisher.test()` del paquete **stats**, como se muestra a continuación. Ten en cuenta que los valores faltantes no están permitidos, por lo que se excluyen de la tabulación con `show_na = FALSE`. 

```{r, warning=F, message=F}
age_by_outcome <- linelist %>% 
  tabyl(age_cat, outcome, show_na = FALSE) 

chisq.test(age_by_outcome)
```

Consulta la página sobre [Tests estadísticos sencillos](#simple-statistical-tests) para obtener más código y consejos sobre estadística. 

### Otros consejos  {.unnumbered}  

* Incluye el argumento `na.rm = TRUE` para excluir los valores faltantes de cualquiera de los cálculos anteriores. 
* Si aplicas cualquier función de ayuda `adorn_*()` a tablas no creadas por `tabyl()`, puedes especificar una(s) columna(s) particular(es) para aplicarlas como `adorn_percentage(,,,c(cases,deaths))` (especifícalos en el cuarto argumento sin nombre). La sintaxis no es sencilla. Considera la posibilidad de utilizar `summarise()` en su lugar. 
* Puedes leer más detalles en la [página de janitor](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html) y en esta [viñeta de tabyl](https://cran.r-project.org/web/packages/janitor/vignettes/tabyls.html). 




## paquete **dplyr** {#dplyr-package} 

**dplyr** forma parte de los paquetes **tidyverse** y es una herramienta de gestión de datos muy común. La creación de tablas con las funciones de **dplyr** `summarise()` y `count()` es un enfoque útil para calcular estadísticas de resumen, resumir *por grupos* o pasar tablas a `ggplot()`. 

`summarise()` crea un *nuevo dataframe de resumen*. Si los datos *no están agrupados*, se producirá un dataframe de una fila con las estadísticas de resumen especificadas de todo el dataframe. Si los datos están *agrupados*, el nuevo dataframe tendrá una fila por *grupo* (véase la página [Agrupar datos](#grouping-data)). 

Dentro del paréntesis de `summarise()`, se proporcionan los nombres de cada nueva columna de resumen, seguidos de un signo de igualdad y de una función estadística a aplicar. 

<span style="color: darkgreen;">***SUGERENCIA:*** La función summarise funciona tanto con la ortografía británica como con la estadounidense (summarise() y `summarize()`). </span>

### Obtener recuentos  {.unnumbered}  

La función más sencilla de aplicar dentro de `summarise()` es `n()`. Deja los paréntesis vacíos para contar el número de filas. 

```{r}
linelist %>%                 # comienza con linelist
  summarise(n_rows = n())    # devuelve un nuevo dataframe de resumen con la columna n_rows
```

Esto se vuelve más interesante si hemos agrupado los datos de antemano.  

```{r}
linelist %>% 
  group_by(age_cat) %>%     # agrupa los datos por valores únicos en la columna age_cat
  summarise(n_rows = n())   # devuelve el número de filas *por grupo
```

El comando anterior se puede acortar utilizando la función `count()` en su lugar. `count()` hace lo siguiente: 

1.  Agrupa los datos por las columnas que se le proporcionan 
2.  Los resume con `n()` (creando la columna `n`) 
3.  Desagrupa los datos 

```{r}
linelist %>% 
  count(age_cat)
```

Puedes cambiar el nombre de la columna de recuentos de la `n` por defecto a otra cosa especificando a `name = `. 

Los recuentos tabulados de dos o más columnas de agrupación se siguen devolviendo en formato "largo", con los recuentos en la columna `n`. Consulta la página sobre [Pivotar datos](#pivoting-data) para conocer los formatos de datos "long" y "wide". 

```{r}
linelist %>% 
  count(age_cat, outcome)
```


### Mostrar todos los niveles {.unnumbered}  
 
Si estás tabulando una columna de tipo *factor*, puedes asegurarte de que se muestren *todos* los niveles (no sólo los niveles con valores en los datos) añadiendo `.drop = FALSE` en el comando `summarise()` o `count()`. 

Esta técnica es útil para estandarizar sus tablas/gráficos. Por ejemplo, si está creando cifras para varios subgrupos, o creando repetidamente la cifra para informes de rutina. En cada una de estas circunstancias, la presencia de valores en los datos puede fluctuar, pero puedes definir niveles que permanezcan constantes. 

Para más información, consulta la página sobre [factores](#factors). 



### Proporciones {#tbl_dplyr_prop .unnumbered}  
 
Las proporciones pueden añadirse pasando la tabla por `mutate()` para crear una nueva columna. Define la nueva columna como la columna de recuentos (`n` por defecto) dividida por la `sum()` de la columna de recuentos (esto producirá una proporción). 

Ten en cuenta que en este caso, `sum()` en el comando `mutate()` producirá la suma de toda la columna `n` para utilizarla como denominador de la proporción. Como se explica en la página [Agrupar datos](#group_summarise), *si* `sum()` se utiliza en datos *agrupados* (por ejemplo, si el comando `mutate()` sigue inmediatamente a un comando `group_by()`), producirá sumas *por grupo*. Como se acaba de indicar, `count()` termina sus acciones *desagrupando*. Por lo tanto, en este escenario obtenemos proporciones de columnas completas. 

Para mostrar fácilmente los porcentajes, puedes envolver la proporción en la función `percent()` del paquete **scales** (Ten en cuenta que se convierte en tipo carácter). 

```{r}
age_summary <- linelist %>% 
  count(age_cat) %>%                     # agrupa y cuenta por sexo (produce la columna "n")
  mutate(                                # crea porcentaje de columna - mira el denominador
    percent = scales::percent(n / sum(n))) 

# imprime
age_summary
```

A continuación se presenta un método para calcular las proporciones *dentro de los grupos*. Se basa en diferentes niveles de agrupación de datos que se aplican y eliminan selectivamente. En primer lugar, los datos se agrupan en función del `outcome` mediante `group_by()`. A continuación, se aplica `count()`. Esta función agrupa además los datos por `age_cat` y devuelve los recuentos para cada combinación de `outcome`-`age-cat`. Es importante destacar que, al finalizar tu proceso, `count()` también *desagrupa* la agrupación `age_cat`, por lo que la única agrupación de datos que queda es la agrupación original por `outcome`. Por lo tanto, el paso final del cálculo de las proporciones (denominador sum(n)) sigue estando agrupado por `outcome`.  

```{r}
age_by_outcome <- linelist %>%                  # comienza con linelist
  group_by(outcome) %>%                         # agrupa por resultado 
  count(age_cat) %>%                            # agrupa y cuenta por age_cat, y luego elimina la agrupación age_cat
  mutate(percent = scales::percent(n / sum(n))) # calcula el porcentaje - observa que el denominador es por grupo de resultados
```

```{r, echo=F}
DT::datatable(age_by_outcome, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```




### Gráficas {.unnumbered}  

Mostrar una tabla "larga" como la anterior con `ggplot()` es relativamente sencillo. Los datos están naturalmente en formato "largo", que es aceptado naturalmente por `ggplot()`. Mira más ejemplos en las páginas [Conceptos básicos de ggplot](#ggplot-basics) y [consejos de ggplot](#ggplot-tips). 


```{r, warning=F, message=F}
linelist %>%                      # comienza con linelist
  count(age_cat, outcome) %>%     # agrupa y tabula los recuentos en dos columnas
  ggplot()+                       # pasa el nuevo data frame a ggplot
    geom_col(                     # crea un gráfico de barras
      mapping = aes(   
        x = outcome,              # asigna el resultado al eje x
        fill = age_cat,           # mapea age_cat al relleno
        y = n))                   # mapea la columna de recuentos `n` a la altura
```


### Estadísticas resumidas  {.unnumbered}  

Una de las principales ventajas de **dplyr** y de `summarise()` es la capacidad de producir resúmenes estadísticos más avanzados como `median()`, `mean()`, `max()`, `min()`, `sd()` (desviación estándar) y percentiles. También puedes utilizar `sum()` para mostrar el número de filas que cumplen ciertos criterios lógicos. Al igual que en el caso anterior, estas salidas pueden producirse para todo el conjunto de dataframes o por grupos. 

La sintaxis es la misma: dentro de los paréntesis de `summarise()` se proporcionan los nombres de cada nueva columna de resumen, seguidos de un signo de igualdad y de una función estadística para aplicar. Dentro de la función estadística, indica la(s) columna(s) con la(s) que se va a operar y cualquier argumento relevante (por ejemplo, `na.rm =` TRUE para la mayoría de las funciones matemáticas). 

También puedes utilizar `sum()` para mostrar el número de filas que cumplen un criterio lógico. La expresión que contiene se cuenta si se evalúa como `TRUE`. Por ejemplo: 

* `sum(age_years < 18, na.rm=T)`  
* `sum(gender == "male", na.rm=T)`  
* `sum(response %in% c("Likely", "Very Likely"))`   

A continuación, se resumen los datos de `linelist` para describir los días de retraso desde el inicio de los síntomas hasta el ingreso en el hospital (columna `days_onset_hosp`), por hospital. 

```{r}
summary_table <- linelist %>%                                        # comienza con linelist, y guarda como nuevo objeto
  group_by(hospital) %>%                                             # agrupa todos los cálculos por hospital
  summarise(                                                         # sólo se devolverán las siguientes columnas de resumen
    cases       = n(),                                                # número de filas por grupo
    delay_max   = max(days_onset_hosp, na.rm = T),                    # retraso máximo
    delay_mean  = round(mean(days_onset_hosp, na.rm=T), digits = 1),  # retraso medio, redondeado
    delay_sd    = round(sd(days_onset_hosp, na.rm = T), digits = 1),  # desviación estándar de los retrasos, redondeada
    delay_3     = sum(days_onset_hosp >= 3, na.rm = T),               # número de filas con retraso de 3 o más días
    pct_delay_3 = scales::percent(delay_3 / cases)                    # convierte la columna de retrasos definida anteriormente en porcentaje 
  )

summary_table  # print
```


Algunos consejos: 

* Utilizar `sum()` con una sentencia lógica para "contar" las filas que cumplen ciertos criterios (`==`) 
* Ten en cuenta el uso de `na.rm = TRUE` dentro de funciones matemáticas como `sum()`, de lo contrario se mostrará `NA` si hay algún valor faltante 
* Utiliza la función `percent()` del paquete **scales** para convertir fácilmente a porcentajes 
* Ajusta la `accuracy = ` (precisión) a 0,1 o 0,01 para garantizar 1 o 2 decimales respectivamente 
* Utilizar `round()` de R **base** para especificar los decimales 
* Para calcular estas estadísticas en todo el set de datos, utiliza `summarise()` sin `group_by()` 
* Puedes crear columnas para los propósitos de cálculos posteriores (por ejemplo, denominadores) que eventualmente se eliminan de tu dataframe con `select()`. 


### Estadísticas condicionales  {.unnumbered}  

Es posible que desees producir *estadísticas condicionales*, por ejemplo, el máximo de filas que cumplen ciertos criterios. Esto se puede hacer sub-configurando la columna con corchetes [ ]. El ejemplo siguiente devuelve la temperatura máxima de los pacientes clasificados con o sin fiebre. Sin embargo, ten en cuenta que puede ser más adecuado añadir otra columna al comando `group_by()` y `pivot_wider()` (como se demuestra [a continuación](#tbls_pivot_wider)). 


```{r}
linelist %>% 
  group_by(hospital) %>% 
  summarise(
    max_temp_fvr = max(temp[fever == "yes"], na.rm = T),
    max_temp_no = max(temp[fever == "no"], na.rm = T)
  )
```



### Pegar valores  {.unnumbered}  

La función `str_glue()` de **stringr** es útil para combinar valores de varias columnas en una nueva columna. En este contexto, se suele utilizar *después* del comando `summarise()`. 

En la página [Caracteres y cadenas](#characters-and-strings), se discuten varias opciones para combinar columnas, incluyendo `unite()`, y `paste0()`. En este caso de uso, abogamos por `str_glue()` porque es más flexible que `unite()` y tiene una sintaxis más sencilla que `paste0()`. 

A continuación, el dataframe de `summary_table` (creado anteriormente) se muta de manera que las columnas `delay_mean` y `delay_sd` se combinan, se añade el formato de paréntesis a la nueva columna y se eliminan sus respectivas columnas antiguas. 

Luego, para hacer la tabla más presentable, se añade una fila de totales con `adorn_totals()` de **janitor** (que ignora las columnas no numéricas). Por último, utilizamos `select()` de **dplyr** para reordenar y renombrar los nombres de las columnas. 

Ahora puedes pasar a **flextable** e imprimir la tabla a Word, .png, .jpeg, .html, Powerpoint, RMarkdown, etc. (ver la página de [Tablas para presentaciones](#tables-for-presentation)). 

```{r}
summary_table %>% 
  mutate(delay = str_glue("{delay_mean} ({delay_sd})")) %>%  # combina y formatea otros valores
  select(-c(delay_mean, delay_sd)) %>%                       # elimina dos columnas antiguas         
  adorn_totals(where = "row") %>%                            # añade el total de la fila
  select(                                                    # ordena y renombra las cols
    "Hospital Name"   = hospital,
    "Cases"           = cases,
    "Max delay"       = delay_max,
    "Mean (sd)"       = delay,
    "Delay 3+ days"   = delay_3,
    "% delay 3+ days" = pct_delay_3
    )
```

#### Percentiles {.unnumbered}  

Los *percentiles* y cuartiles en **dplyr** merecen una mención especial. Para mostrar los cuantiles, utiliza `quantile()` con los valores predeterminados o especifica el valor o los valores que deseas con `probs =`. 

```{r}
# obtiene valores de percentil de edad por defecto (0%, 25%, 50%, 75%, 100%)
linelist %>% 
  summarise(age_percentiles = quantile(age_years, na.rm = TRUE))

# obtiene valores de percentil de edad especificados manualmente (5%, 50%, 75%, 98%)
linelist %>% 
  summarise(
    age_percentiles = quantile(
      age_years,
      probs = c(.05, 0.5, 0.75, 0.98), 
      na.rm=TRUE)
    )
```

Si deseas mostrar cuantiles *por grupo*, puedes encontrar salidas largas y menos útiles si simplemente añades otra columna a `group_by()`. Por lo tanto, prueba este enfoque en su lugar: crea una columna para cada nivel de cuantil deseado. 

```{r}
# obtiene valores de percentil de edad especificados manualmente (5%, 50%, 75%, 98%)
linelist %>% 
  group_by(hospital) %>% 
  summarise(
    p05 = quantile(age_years, probs = 0.05, na.rm=T),
    p50 = quantile(age_years, probs = 0.5, na.rm=T),
    p75 = quantile(age_years, probs = 0.75, na.rm=T),
    p98 = quantile(age_years, probs = 0.98, na.rm=T)
    )
```

Aunque `summarise()` de **dplyr** ofrece ciertamente un control más fino, puedes encontrar que todas las estadísticas de resumen que necesitas pueden producirse con `get_summary_stat()` del paquete **rstatix**. Si se opera con datos agrupados, if mostrará 0%, 25%, 50%, 75% y 100%. Si se aplica a datos no agrupados, puedes especificar los percentiles con `probs = c(.05, .5, .75, .98)`. 


```{r}
linelist %>% 
  group_by(hospital) %>% 
  rstatix::get_summary_stats(age, type = "quantile")
```

```{r}
linelist %>% 
  rstatix::get_summary_stats(age, type = "quantile")
```



### Resumir datos agregados {.unnumbered}  
 
*Si comienza con datos agregados*, al utilizar `n()` devuelve el número de *filas*, no la suma de los recuentos agregados. Para obtener sumas, utiliza `sum()` en la columna de recuentos de los datos. 

Por ejemplo, digamos que se empieza con el dataframe de recuentos que se muestra a continuación, llamado `linelist_agg` - muestra en formato "largo" los recuentos de casos por resultado y género. 

A continuación creamos este dataframe de ejemplo de recuentos de casos de `linelist` por resultado y sexo (se eliminan los valores faltantes para mayor claridad). 

```{r}
linelist_agg <- linelist %>% 
  drop_na(gender, outcome) %>% 
  count(outcome, gender)

linelist_agg
```

Para sumar los recuentos (en la columna n) por grupo, puedes utilizar `summarise()` pero establecer la nueva columna igual a sum(n, na.rm=T)`. Para añadir un elemento condicional a la operación de suma, puedes utilizar la sintaxis del subconjunto [ ] en la columna de recuentos. 

```{r}
linelist_agg %>% 
  group_by(outcome) %>% 
  summarise(
    total_cases  = sum(n, na.rm=T),
    male_cases   = sum(n[gender == "m"], na.rm=T),
    female_cases = sum(n[gender == "f"], na.rm=T))
```




### `across()` varias columnas {.unnumbered}  

Puedes utilizar `summarise()` en varias columnas utilizando `across()`. Esto facilita la vida cuando se desea calcular las mismas estadísticas para muchas columnas. Escribe `across()` dentro de `summarise()` y especifica lo siguiente: 

* `.cols = ` como un vector de nombres de columnas `c()` o funciones de ayuda "tidyselect" (explicadas más adelante) 

* `.fns = ` la función a realizar (sin paréntesis) - puedes proporcionar varias dentro de una `list()`

A continuación, `mean()` se aplica a varias columnas numéricas. Se nombra explícitamente un vector de columnas a `.cols = ` y se especifica una única función `mean` (sin paréntesis) a `.fns = `. Cualquier argumento adicional para la función (por ejemplo, `na.rm=TRUE`) se proporciona después de `.fns = `, separado por una coma. 

Puede ser difícil conseguir el orden correcto de los paréntesis y las comas cuando se utiliza `across()`. Recuerda que dentro de `across()` debes incluir las columnas, las funciones y cualquier argumento extra necesario para las funciones. 

```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm),  # columnas
                   .fns = mean,                               # function
                   na.rm=T))                                  # argumentos extra
```

Se pueden ejecutar varias funciones a la vez. A continuación se proporcionan las funciones `mean` y `sd` a `.fns = ` dentro de una `list()`. Tienes la oportunidad de proporcionar nombres de caracteres (por ejemplo, "mean" y "sd") que se añaden en los nuevos nombres de columna.   

```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm), # columnas
                   .fns = list("mean" = mean, "sd" = sd),    # multiples functiones 
                   na.rm=T))                                 # argumentos extra
```

Aquí están esas funciones de ayuda "tidyselect" que puedes proporcionar a `.cols = ` para seleccionar columnas: 

* `everything()` - todas las demás columnas no mencionadas 
* `last_col()` - la última columna 
* `where()` - aplica una función a todas las columnas y selecciona las que son TRUE 
* `starts_with()` - coincide con un prefijo especificado. Ejemplo: `starts_with("date") `
* `ends_with()` - coincide con un sufijo especificado. Ejemplo: `ends_with("_end")` 
* `contains()` - columnas que contienen una cadena de caracteres. Ejemplo: `contains("time")`
* `matches()` - para aplicar una expresión regular (regex). Ejemplo: `contains("[pt]al")`
* `num_range()` - 
* `any_of()` - coincide con el nombre de la columna. Es útil si el nombre puede no existir. Ejemplo: `any_of(date_onset, date_death, cardiac_arrest)` 

Por ejemplo, para producir la media de cada columna numérica utiliza where() y proporciona la función `as.numeric()` (sin paréntesis). Todo esto queda dentro del comando `across()`. 

```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(
    .cols = where(is.numeric),  # todas las columnas numéricas del data frame
    .fns = mean,
    na.rm=T))
```


### Pivote más ancho  {#tbls_pivot_wider .unnumbered}

Si prefieres tu tabla en formato "ancho" puedes transformarla utilizando la función `pivot_wider()` de **tidyr**. Es probable que tengas que renombrar las columnas con `rename()`. Para más información, consulta la página sobre [Pivotar datos](#pivoting-data). 

El ejemplo siguiente comienza con la tabla "larga" `age_by_outcome` de la [sección de proporciones](#tbl_dplyr_prop). La creamos de nuevo y la imprimimos, para mayor claridad: 

```{r}
age_by_outcome <- linelist %>%                  # comienza con linelist
  group_by(outcome) %>%                         # agrupa por resultado 
  count(age_cat) %>%                            # agrupa y cuenta por age_cat, y luego elimina la agrupación age_cat
  mutate(percent = scales::percent(n / sum(n))) # calcula el porcentaje - observa que el denominador es por grupo de resultados
```

```{r, echo=F}
DT::datatable(age_by_outcome, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Para pivotar más ampliamente, creamos las nuevas columnas a partir de los *valores* de la columna existente `age_cat` (estableciendo `names_from = age_cat`). También especificamos que los nuevos valores de la tabla provendrán de la columna existente `n`, con `values_from = n`. Las columnas no mencionadas en nuestro comando de pivoteo (`outcome`) permanecerán sin cambios en el extremo izquierdo. 

```{r}
age_by_outcome %>% 
  select(-percent) %>%   # mantiene sólo los recuentos para simplificar
  pivot_wider(names_from = age_cat, values_from = n)  
```


### Total de filas {#tbl_dplyr_totals .unnumbered}  

Cuando `summarise()` opera con datos agrupados no produce automáticamente estadísticas "totales". A continuación, se presentan dos enfoques para añadir una fila de totales:  

#### adorn_totals() de **janitor** {.unnumbered}  

Si tu tabla consiste sólo en recuentos o proporciones/porcentajes que pueden sumarse en un total, entonces puedes añadir totales de *suma* usando `adorn_totals()` de **janitor** como se describe en la sección anterior. Ten en cuenta que esta función sólo puede sumar las columnas numéricas - si deseas calcular otras estadísticas de resumen total, mira el siguiente enfoque con **dplyr**. 

A continuación, `linelist` se agrupa por género y se resume en una tabla que describe el número de casos con resultado conocido, los fallecidos y los recuperados. Al pasar la tabla por `adorn_totals()` se añade una fila total en la parte inferior que refleja la suma de cada columna. Las funciones posteriores `adorn_*()` ajustan la visualización como se indica en el código. 

```{r}
linelist %>% 
  group_by(gender) %>%
  summarise(
    known_outcome = sum(!is.na(outcome)),           # Número de filas del grupo en las que no falta el resultado
    n_death  = sum(outcome == "Death", na.rm=T),    # Número de filas en el grupo donde el resultado es Death
    n_recover = sum(outcome == "Recover", na.rm=T), # Número de filas del grupo en las que el resultado es Recovered
  ) %>% 
  adorn_totals() %>%                                # Adorna fila total (sumas de cada columna numérica)
  adorn_percentages("col") %>%                      # Obtiene las proporciones de las columnas
  adorn_pct_formatting() %>%                        # Convierte las proporciones a porcentajes
  adorn_ns(position = "front")                      # Muestra % y recuentos (con los recuentos delante)
```

#### `summarise()` en los datos "totales" y luego `bind_rows()`  {.unnumbered}  

Si tu tabla consta de estadísticas de resumen como `median()`, `mean()`,, etc., el enfoque `adorn_totals()` mostrado anteriormente *no* será suficiente. En tu lugar, para obtener los estadísticos de resumen de todo el set de datos debe calcularlos con un comando `summarise()` separado y luego vincular los resultados a la tabla de resumen agrupada original. Para hacer el enlace puedes utilizar `bind_rows()` de **dplyr** descrito en la página de [unión de datos](#joining-data). A continuación se muestra un ejemplo: 

Se puede hacer una tabla resumen de resultados *por hospital* con `group_by()` y `summarise()` así: 

```{r, warning=F, message=F}
by_hospital <- linelist %>% 
  filter(!is.na(outcome) & hospital != "Missing") %>%  # Elimina los casos en los que falta el resultado o el hospital
  group_by(hospital, outcome) %>%                      # Agrupa los datos
  summarise(                                           # Crea nuevas columnas de resumen de los indicadores de interés
    N = n(),                                            # Número de filas por grupo de hospital-resultado    
    ct_value = median(ct_blood, na.rm=T))               # Valor mediano de CT por grupo
  
by_hospital # print table
```

Para obtener los totales, ejecuta el mismo comando `summarise()` pero agrupando los datos sólo por resultado (no por hospital), de la siguiente manera:   

```{r}
totals <- linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Agrupado sólo por resultado, no por hospital        
      summarise(
        N = n(),                                       # Estas estadísticas son ahora sólo por resultado     
        ct_value = median(ct_blood, na.rm=T))

totals # imprimir tabla
```

Podemos unir estos dos dataframes. Ten en cuenta que `by_hospital` tiene 4 columnas, mientras que `totals` tiene 3 columnas. Al utilizar `bind_rows()`, las columnas se combinan por nombre, y cualquier espacio extra se rellena con `NA` (por ejemplo, los valores de la columna `hospital` para las dos nuevas filas de `totals`). Después de enlazar las filas, convertimos estos espacios vacíos en "Total" utilizando `replace_na()` (véase la página de [limpieza de datos y funciones básicas](#cleaning-data-and-core-functions)).  

```{r}
table_long <- bind_rows(by_hospital, totals) %>% 
  mutate(hospital = replace_na(hospital, "Total"))
```

Aquí está la nueva tabla con las filas "Total" en la parte inferior. 

```{r, message=FALSE, echo=F}
DT::datatable(table_long, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```

Esta tabla tiene un formato "largo", que puede ser lo que quieres. *Opcionalmente*, puedes *pivotar* esta tabla *más ampliamente* para hacerla más legible. Mira la sección sobre pivoteo más amplio arriba, y la página [Pivotar datos](#pivoting-data). También puedes añadir más columnas, y organizarla de forma agradable. Este código está abajo.   

```{r}
table_long %>% 
  
  # Pivotar más ancho y formato
  #############################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # Pivota de largo a ancho
    values_from = c(ct_value, N),                       # los nuevos valores proceden de las columnas ct y count
    names_from = outcome) %>%                           # los nuevos nombres de columna proceden de outcomes
  mutate(                                              # Añade nuevas columnas
    N_Known = N_Death + N_Recover,                               # número con resultado conocido
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # porcentaje de casos que murieron (a 1 decimal)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # porcentaje de casos que se recuperaron (a 1 decimal)
  select(                                              # Reordena las columnas
    hospital, N_Known,                                   # columnas iniciales
    N_Recover, Pct_Recover, ct_value_Recover,            # columnas de recuperados
    N_Death, Pct_Death, ct_value_Death)  %>%             # columnas de fallecidos
  arrange(N_Known)                                  # Ordenar las filas de menor a mayor (fila Total en la parte inferior)

```

Y luego puedes imprimir esto muy bien como una imagen - abajo está la salida impresa con **flextable**. Puedes leer más en profundidad sobre este ejemplo y cómo lograr esta tabla "bonita" en la página [Tablas para presentaciones](#tables-for-presentation). 

```{r echo=FALSE, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}

linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds")) 

border_style = officer::fp_border(color="black", width=1)

pacman::p_load(
  rio,            # importar/exportar
  here,           # rutas de archivos
  flextable,      # hacer imágenes bonitas de tablas 
  officer,        # funciones de ayuda para tablas
  tidyverse)      # gestión, resumen y visualización de datos

table <- linelist %>% 
  # Filtro
  ########
  #filter(!is.na(outcome) & hospital != "Missing") %>%  # Elimina los casos en los que falta el resultado o el hospital
  
  # Obtener valores de resumen por grupo hospital-resultado
  #########################################################
  group_by(hospital, outcome) %>%                      # Agrupa los datos
  summarise(                                           # Crea nuevas columnas de resumen de indicadores de interés
    N = n(),                                            # Número de filas por grupo hospital-resultado    
    ct_value = median(ct_blood, na.rm=T)) %>%           # valor mediano de CT por grupo
  
  # añadir totales
  ################
  bind_rows(                                           # Une la tabla anterior con esta mini-tabla de totales
    linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Agrupado sólo por resultado, no por hospital    
      summarise(
        N = n(),                                       # Número de filas de todo el conjunto de datos     
        ct_value = median(ct_blood, na.rm=T))) %>%     # Mediana de CT para todo el conjunto de datos
  
  # Pivotar ancho y formato
  #########################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # Pivota de largo a ancho
    values_from = c(ct_value, N),                       # los nuevos valores proceden de las columnas ct y count
    names_from = outcome) %>%                           # los nuevos nombres de columna proceden de outcomes
  mutate(                                              # Añadir nuevas columnas
    N_Known = N_Death + N_Recover,                               # número con resultado conocido
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # porcentaje de casos que fallecieron (a 1 decimal)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # porcentaje de casos que se recuperaron (a 1 decimal)
  select(                                              # Reordenar columnas
    hospital, N_Known,                                   # Columnas iniciales
    N_Recover, Pct_Recover, ct_value_Recover,            # Columnas de recuperados
    N_Death, Pct_Death, ct_value_Death)  %>%             # Columnas de fallecidos
  arrange(N_Known) %>%                                 # Ordena las filas de menor a mayor (fila Total al final)

  # Formato
  ############
  flextable() %>% 
  add_header_row(
    top = TRUE,                # El nuevo encabezado va encima de la fila de encabezado existente
    values = c("Hospital",     # Valores de cabecera para cada columna a continuación
               "Total cases with known outcome", 
               "Recovered",    # Este será el encabezado de nivel superior para esta columna y las dos siguientes
               "",
               "",
               "Died",         # Este será el encabezado de nivel superior para esta columna y las dos siguientes
               "",             # Dejar en blanco, ya que se fusionará con "Died"
               "")) %>% 
    set_header_labels(         # Cambia el nombre de las columnas en la fila de cabecera original
      hospital = "", 
      N_Known = "",                  
      N_Recover = "Total",
      Pct_Recover = "% of cases",
      ct_value_Recover = "Median CT values",
      N_Death = "Total",
      Pct_Death = "% of cases",
      ct_value_Death = "Median CT values")  %>% 
  merge_at(i = 1, j = 3:5, part = "header") %>% # Combina horizontalmente las columnas 3 a 5 en la nueva fila de cabecera
  merge_at(i = 1, j = 6:8, part = "header") %>%  
  border_remove() %>%  
  theme_booktabs() %>% 
  vline(part = "all", j = 2, border = border_style) %>%   # at column 2 
  vline(part = "all", j = 5, border = border_style) %>%   # at column 5
  merge_at(i = 1:2, j = 1, part = "header") %>% 
  merge_at(i = 1:2, j = 2, part = "header") %>% 
  width(j=1, width = 2.7) %>% 
  width(j=2, width = 1.5) %>% 
  width(j=c(4,5,7,8), width = 1) %>% 
  flextable::align(., align = "center", j = c(2:8), part = "all") %>% 
  bg(., part = "body", bg = "gray95")  %>% 
  colformat_num(., j = c(4,7), digits = 1) %>% 
  bold(i = 1, bold = TRUE, part = "header") %>% 
  bold(i = 6, bold = TRUE, part = "body")


table
```



## Paquete **gtsummary** {#tbl_gt}   

Si deseas imprimir tus estadísticas de resumen en un gráfico bonito y listo para tu publicación, puedes utilizar el paquete **gtsummary** y tu función `tbl_summary`(). El código puede parecer complejo al principio, pero los resultados se ven muy bien y se imprimen en tu panel de RStudio Viewer como una imagen HTML. Lea [esta viñeta](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html). 

También puedes añadir los resultados de las pruebas estadísticas a las tablas de gtsummary. Este proceso se describe en la sección **gtsummary de la** página [Tests estadísticos simples](#stats_gt). 

Para introducir `tbl_summary`() mostraremos primero el comportamiento más básico, que realmente produce una tabla grande y bonita. Luego, examinaremos en detalle cómo hacer ajustes y tablas más a medida. 



### Tabla resumen  {.unnumbered}

El comportamiento por defecto de `tbl_summary`() es bastante increíble: toma las columnas que proporcionas y crea una tabla de resumen en un solo comando. La función imprime las estadísticas apropiadas para el tipo de columna: mediana y rango intercuartil (IQR) para las columnas numéricas, y recuentos (%) para las columnas categóricas. Los valores faltantes se convierten en "Missing". Se añaden notas a pie de página para explicar las estadísticas, mientras que el N total se muestra en la parte superior. 

```{r, warning=F, message=F}
linelist %>% 
  select(age_years, gender, outcome, fever, temp, hospital) %>%  # mantiene sólo las columnas de interés
  tbl_summary()                                                  # por defecto
```


### Ajustes  {.unnumbered}  

Ahora explicaremos cómo trabaja la función y cómo hacer los ajustes. Los argumentos clave se detallan a continuación: 

**`by = `**
Puedes estratificar tu tabla por una columna (por ejemplo, por resultado), creando una tabla de dos vías. 

**`statistic = ` **
Usa una ecuación para especificar qué estadísticas mostrar y cómo mostrarlas. La ecuación tiene dos lados, separados por una tilde `~`. En el lado derecho, entre comillas, está la visualización estadística deseada, y en el izquierdo están las columnas a las que se aplicará esa visualización. 

* El lado derecho de la ecuación utiliza la sintaxis de `str_glue()` de **stringr** (véase [Caracteres y cadenas](#characters-and-strings)), con la cadena de visualización deseada entre comillas y los propios estadísticos entre llaves. Puedes incluir estadísticas como "n" (para los recuentos), "N" (para el denominador), "mean", "median", "sd", "max", "min", percentiles como "p##" como "p25", o porcentaje del total como "p". Consulta `?tbl_summary` para obtener más detalles. 
* Para el lado izquierdo de la ecuación, puedes especificar las columnas por su nombre (por ejemplo, `age` o `c(age, gender)`) o utilizando ayudantes como `all_continuous()`, `all_categorical()`, `contains()`, `starts_with()`, etc.  

Un ejemplo sencillo de una ecuación `statistic = ` podría ser como el siguiente, para imprimir sólo la media de la columna `age_years`:

```{r}
linelist %>% 
  select(age_years) %>%         # mantiene sólo las columnas de interés 
  tbl_summary(                  # crea tabla resumen
    statistic = age_years ~ "{mean}") # imprime la media de edad
```

Una ecuación un poco más compleja podría tener el aspecto de `"({min}, {max})"`, incorporando los valores máximo y mínimo entre paréntesis y separados por una coma: 

```{r}
linelist %>% 
  select(age_years) %>%                       # conserva sólo las columnas de interés  
  tbl_summary(                                # crea tabla resumen
    statistic = age_years ~ "({min}, {max})") # imprime min y max de edad
```

También puedes diferenciar la sintaxis para columnas separadas o tipos de columnas. En el ejemplo más complejo de abajo, el valor proporcionado a  `statistc = ` es una **lista** que indica que para todas las columnas continuas la tabla debe imprimir la media con la desviación estándar entre paréntesis, mientras que para todas las columnas categóricas debe imprimir el n, el denominador y el porcentaje. 

**`digits = `**  
Ajusta los dígitos y el redondeo. Opcionalmente, se puede especificar que sea sólo para columnas continuas (como a continuación). 

**`label = `**  
Ajustar cómo debe mostrarse el nombre de la columna. Proporciona el nombre de la columna y la etiqueta deseada separados por una tilde. El valor por defecto es el nombre de la columna. 

**`missing_text = `**  
Ajustar cómo se muestran los valores faltantes. El valor por defecto es "Unknown". 

**`type = `** 
Se utiliza para ajustar cuántos niveles de la estadística se muestran. La sintaxis es similar a `statistic = ` en el sentido de que se proporciona una ecuación con columnas a la izquierda y un valor a la derecha. Dos escenarios comunes incluyen: 

* `type = all_categorical() ~ "categorical"`  Fuerza a las columnas dicotómicas (por ejemplo, `fever` sí/no) a mostrar todos los niveles en lugar de sólo la fila "sí"

* `type = all_continuous() ~ "continuous2"` Permite estadísticas de varias líneas por variable, como se muestra en una sección posterior 

En el siguiente ejemplo, cada uno de estos argumentos se utiliza para modificar la tabla resumen original: 

```{r}
linelist %>% 
  select(age_years, gender, outcome, fever, temp, hospital) %>% # conserva sólo las columnas de interés
  tbl_summary(     
    by = outcome,                                               # estratifica toda la tabla por resultado
    statistic = list(all_continuous() ~ "{mean} ({sd})",        # estadísticas y formato de las columnas continuas
                     all_categorical() ~ "{n} / {N} ({p}%)"),   # estadísticas y formato para columnas categóricas
    digits = all_continuous() ~ 1,                              # redondeo para columnas continuas
    type   = all_categorical() ~ "categorical",                 # fuerza la visualización de todos los niveles categóricos
    label  = list(                                              # muestra las etiquetas de las columnas
      outcome   ~ "Outcome",                           
      age_years ~ "Age (years)",
      gender    ~ "Gender",
      temp      ~ "Temperature",
      hospital  ~ "Hospital"),
    missing_text = "Missing"                                    # cómo deben mostrarse los valores perdidos
  )
```



### Estadísticas de varias líneas para variables continuas  {.unnumbered}  

Si deseas imprimir varias líneas de estadísticas para variables continuas, puedes indicarlo estableciendo `type = ` a "continuous2". Puedes combinar todos los elementos mostrados anteriormente en una tabla eligiendo qué estadísticas quiere mostrar. Para ello, debes indicar a la función que deseas obtener una tabla escribiendo el tipo como "continuous2". El número de valores faltantes se muestra como "Desconocido". 


```{r}
linelist %>% 
  select(age_years, temp) %>%                      # conserva sólo las columnas de interés
  tbl_summary(                                     # crea tabla resumen
    type = all_continuous() ~ "continuous2",       # indica que quieres imprimir múltiples estadísticas  
    statistic = all_continuous() ~ c(
      "{mean} ({sd})",                             # línea 1: media y DE
      "{median} ({p25}, {p75})",                   # línea 2: mediana y RIQ
      "{min}, {max}")                               # línea 3: mín. y máx.
    )
```
Hay muchas otras formas de modificar estas tablas, incluyendo la adición de valores p, el ajuste del color y los títulos, etc. Muchas de ellas se describen en la documentación (escribe `?tbl_summary` en la Consola), y algunas se dan en la sección de [Tests estadísticos sencillos](https://epirhandbook.com/simple-statistical-tests.html).







## R **base**   {#base-r-1}

Puedes utilizar la función `table()` para tabular y cruzar las columnas. A diferencia de las opciones anteriores, debes especificar el dataframe cada vez que haga referencia a un nombre de columna, como se muestra a continuación. 

<span style="color: orange;">***ATENCIÓN:*** Los valores `NA` (missing) **no** se tabularán a menos que se incluya el argumento `useNA = "always"` (que también podría establecerse como "no" o "ifany"). .</span>

<span style="color: darkgreen;">***CONSEJO:*** Puedes utilizar el `%$%` de **magrittr** para eliminar la necesidad de repetir las llamadas al dataframe dentro de las funciones de R **base**. Por ejemplo, lo siguiente podría escribirse `linelist %$% table(outcome, useNA = "always")`  </span>

```{r}
table(linelist$outcome, useNA = "always")
```

Se pueden cruzar varias columnas enumerándolas una tras otra, separadas por comas. Opcionalmente, se puede asignar a cada columna un "nombre" como `Outcome = linelist$outcome`.  

```{r}
age_by_outcome <- table(linelist$age_cat, linelist$outcome, useNA = "always") # guarda la tabla como objeto
age_by_outcome   # imprime la tabla
```

### Proporciones  {.unnumbered}  

Para producir las proporciones, pasa la tabla anterior a la función `prop.table()`. Utiliza el argumento `margins = ` para especificar si deseas que las proporciones sean de filas (1), de columnas (2) o de toda la tabla (3). Para mayor claridad, eniazamos la tabla con pipe a la función `round()` de R **base**, especificando 2 dígitos. 

```{r}
# obtiene las proporciones de la tabla definida anteriormente, por filas, redondeadas
prop.table(age_by_outcome, 1) %>% round(2)
```

### Totales {.unnumbered}  

Para añadir los totales de filas y columnas, pasa la tabla a `addmargins()`. Esto funciona tanto para recuentos como para proporciones. 

```{r}
addmargins(age_by_outcome)
```

### Convertir en dataframe  {.unnumbered}  

Convertir un objeto `table()` directamente en un dataframe no es sencillo. A continuación se muestra un enfoque: 

1)  Crea la tabla, *sin utilizar* `useNA = "always"`. En su lugar, convierte los valores `NA` en "(Missing)" con `fct_explicit_na()` de **forcats**. 
2)  Añade los totales (opcional) pasando por `addmargins()` 
3)  Pipe a la función R **base** `as.data.frame.matrix()` 
4)  Enviar la tabla a la función `rownames_to_column()` de **tibble**, especificando el nombre de la primera columna 
5)  Imprime, visualiza o exporta según desees. En este ejemplo utilizamos `flextable()` del paquete **flextable** como se describe en la página [Tablas para presentaciones](#tables-for-presentation). Esto imprimirá en el panel de visualización de RStudio como una bonita imagen HTML. 


```{r, warning=F, message=F}
table(fct_explicit_na(linelist$age_cat), fct_explicit_na(linelist$outcome)) %>% 
  addmargins() %>% 
  as.data.frame.matrix() %>% 
  tibble::rownames_to_column(var = "Age Category") %>% 
  flextable::flextable()
```




<!-- ======================================================= -->

## Recursos  {#resources-10}

Gran parte de la información de esta página está adaptada de estos recursos y viñetas en línea: 

[gtsummary](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html)  

[dplyr](https://dplyr.tidyverse.org/articles/grouping.html)

