# Beschreibende Tabellen { }

```{r, out.width=c("75%"), fig.align="center", fig.show="hold", echo=F}
knitr::include_graphics(here::here("images", "descriptive_tables.png"))
```

Diese Seite demonstriert die Verwendung von **Hausmeister**, **dplyr**, **gtsummary**, **rstatix**, und **base** R, um Daten zusammenzufassen und Tabellen mit deskriptiven Statistiken zu erstellen.

*Diese Seite beschreibt, wie man *erstellen*die zugrundeliegenden Tabellen, während die [Tabellen für die Präsentation] Seite beschreibt, wie man sie schön formatiert und druckt.*

Jedes dieser Pakete hat Vor- und Nachteile in Bezug auf die Einfachheit des Codes, die Zugänglichkeit der Ausgaben und die Qualität der gedruckten Ausgaben. Nutze diese Seite, um zu entscheiden, welcher Ansatz für dein Szenario geeignet ist.

Bei der Erstellung von tabellarischen und Kreuztabellen hast du mehrere Möglichkeiten. Einige der zu berücksichtigenden Faktoren sind die Einfachheit des Codes, die Anpassbarkeit, die gewünschte Ausgabe (auf der R-Konsole, als Datenrahmen oder als "hübsches" .png/.jpeg/.html-Bild) und die einfache Nachbearbeitung. Beachte die folgenden Punkte, wenn du das richtige Tool für deine Situation auswählst.

- Verwende `tabyl()` von **Hausmeister** um Tabellen und Kreuztabellen zu erstellen und zu "verzieren".
- Verwende `get_summary_stats()` von **rstatix** zur einfachen Erstellung von Datenrahmen mit numerischen zusammenfassenden Statistiken für mehrere Spalten und/oder Gruppen
- Verwende `summarise()` und `count()` von **dplyr** für komplexere Statistiken, saubere Datenrahmenausgaben oder die Vorbereitung von Daten für `ggplot()`
- Verwende `tbl_summary()` von **gtsummary** um detaillierte, veröffentlichungsreife Tabellen zu erstellen
- Verwende `table()` von **Basis** R, wenn du keinen Zugang zu den oben genannten Paketen hast

<!-- ======================================================= -->

## Vorbereitung {  }

### Pakete laden {.unnumbered}

Dieser Codechunk zeigt das Laden der Pakete, die für die Analysen benötigt werden. In diesem Handbuch betonen wir `p_load()` von **pacman**, der das Paket bei Bedarf installiert *und* lädt es zur Verwendung. Du kannst installierte Pakete auch laden mit `library()` von **base**R. Siehe die Seite über [R-Grundlagen] für weitere Informationen über R-Pakete.

```{r, warning=F, message=F}
pacman::p_load(
  rio,          # File import
  here,         # File locator
  skimr,        # get overview of data
  tidyverse,    # data management + ggplot2 graphics 
  gtsummary,    # summary statistics and tests
  rstatix,      # summary statistics and statistical tests
  janitor,      # adding totals and percents to tables
  scales,       # easily convert proportions to percents  
  flextable     # converting tables to pretty images
  )
```

### Daten importieren {.unnumbered}

Wir importieren den Datensatz der Fälle aus einer simulierten Ebola-Epidemie. Wenn du mitmachen willst, <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>klicke, um die "saubere" Linienliste herunterzuladen</a> (als .rds-Datei). Importiere deine Daten mit der `import()` Funktion aus der **rio**Paket (sie akzeptiert viele Dateitypen wie .xlsx, .rds, .csv - siehe die [Import und Export] Seite für Details).

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import the linelist
linelist <- import("linelist_cleaned.rds")
```

Die ersten 50 Zeilen der Linienliste werden unten angezeigt.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

## Daten durchsuchen {  }

### **skimr** Paket {.unnumbered}

Durch die Verwendung des **skimr** Paket kannst du einen detaillierten und ästhetisch ansprechenden Überblick über alle Variablen in deinem Datensatz erhalten. Lies mehr über **skimr** auf seiner [github-Seite](https://github.com/ropensci/skimr).

Unten, die Funktion `skim()` wird auf die gesamte `linelist` Datenrahmen angewendet. Es wird ein Überblick über den Datenrahmen und eine Zusammenfassung jeder Spalte (nach Klasse) erstellt.

```{r, eval=F}
## get information about each variable in a dataset 
skim(linelist)
```

```{r, echo=F}
# sparkline histograms not showing correctly, so avoiding them.
skim_without_charts(linelist)
```

Du kannst auch die `summary()` Funktion, von **Basis** R, um Informationen über einen ganzen Datensatz zu erhalten, aber diese Ausgabe kann schwieriger zu lesen sein als die Verwendung von **skimr**. Deshalb wird die Ausgabe unten nicht angezeigt, um Platz zu sparen.

```{r, eval=F}
## get information about each column in a dataset 
summary(linelist)
```

### Zusammenfassende Statistik {.unnumbered}

Du kannst verwenden **Basis** R-Funktionen verwenden, um zusammenfassende Statistiken für eine numerische Spalte zu erstellen. Die meisten nützlichen Statistiken für eine numerische Spalte erhältst du mit `summary()` wie unten beschrieben. Beachte, dass auch der Name des Datenrahmens angegeben werden muss, wie unten gezeigt.

```{r}
summary(linelist$age_years)
```

Du kannst auf einen bestimmten Teil davon mit Indexklammern zugreifen und ihn speichern []:

```{r}
summary(linelist$age_years)[[2]]            # return only the 2nd element
# equivalent, alternative to above by element name
# summary(linelist$age_years)[["1st Qu."]]  
```

Du kannst einzelne Statistiken zurückgeben mit **Basis** R-Funktionen wie `max()`, `min()`, `median()`, `mean()`, `quantile()`, `sd()`, und `range()`. Siehe die [R-Grundlagen] Seite für eine vollständige Liste.

<span style="color: orange;">***VORSICHT!*** Wenn deine Daten fehlende Werte enthalten, möchte R, dass du das weißt, und gibt daher `NA` zurück, es sei denn, du gibst bei den oben genannten mathematischen Funktionen an, dass R fehlende Werte ignorieren soll. `na.rm = TRUE`.</span>

Du kannst die `get_summary_stats()` Funktion von **rstatix** um zusammenfassende Statistiken zurückzugeben *in einem Datenrahmenformat*. Das kann hilfreich sein, um spätere Operationen oder Plots mit den Zahlen durchzuführen. Siehe die [Einfache statistische Tests] Seite für weitere Informationen über die**rstatix** Paket und seine Funktionen.

```{r}
linelist %>% 
  get_summary_stats(
    age, wt_kg, ht_cm, ct_blood, temp,  # columns to calculate for
    type = "common")                    # summary stats to return

```

## **Hausmeister** Paket {#tbl\_janitor}

Die **Hausmeister** Pakete bietet die `tabyl()` Funktion, um Tabellen und Kreuztabellen zu erstellen, die mit Hilfsfunktionen "verziert" oder modifiziert werden können, um Prozente, Proportionen, Zählungen usw. anzuzeigen.

Nachfolgend leiten wir die `linelist` Datenrahmen an **Hausmeister** Funktionen und drucke das Ergebnis aus. Falls gewünscht, kannst du die resultierenden Tabellen auch mit dem Zuweisungsoperator speichern `<-`.

### Einfache Tabelle {.unnumbered}

Die standardmäßige Verwendung von `tabyl()` auf eine bestimmte Spalte erzeugt die eindeutigen Werte, Zählungen und spaltenweisen "Prozentsätze" (eigentlich Proportionen). Die Proportionen können viele Ziffern haben. Du kannst die Anzahl der Nachkommastellen mit `adorn_rounding()` wie unten beschrieben.

```{r}
linelist %>% tabyl(age_cat)
```

Wie du oben sehen kannst, werden fehlende Werte in einer Zeile mit der Aufschrift `<NA>`. Du kannst sie unterdrücken mit `show_na = FALSE`. Wenn es keine fehlenden Werte gibt, wird diese Zeile nicht angezeigt. Wenn es fehlende Werte gibt, werden alle Proportionen sowohl als Rohwerte (Nenner inklusive `NA` Zählungen) und "gültig" (Nenner schließt die `NA` Zählungen).

Wenn es sich bei der Spalte um einen Klassenfaktor handelt und nur bestimmte Stufen in deinen Daten vorhanden sind, werden trotzdem alle Stufen in der Tabelle angezeigt. Du kannst diese Funktion unterdrücken, indem du angibst `show_missing_levels = FALSE`. Lies mehr über die [Faktoren] Seite.

### Kreuztabellen {.unnumbered}

Kreuztabellen werden erstellt, indem eine oder mehrere zusätzliche Spalten innerhalb der `tabyl()`. Beachte, dass jetzt nur Zählungen zurückgegeben werden - Proportionen und Prozentsätze können mit zusätzlichen Schritten hinzugefügt werden (siehe unten).

```{r}
linelist %>% tabyl(age_cat, gender)
```

###  Die Tabelle "schmücken" {#tbl\_adorn .unnumbered}

Verwende **Hausmeister** Funktionen von janitor, um Summen zu addieren, in Proportionen oder Prozente umzurechnen oder die Anzeige anderweitig anzupassen. Oft wirst du die Tabelle durch mehrere dieser Funktionen leiten.

| Funktion | Ergebnis                                                                                                          | 
| -------- | ----------------------------------------------------------------------------------------------------------------- |
| `adorn_totals()`         | Addiert die Summen (`where = ` "Zeile", "Spalte" oder "beide"). einstellen `name =` für "Gesamt".                                                                                              | 
| `adorn_percentages()`         | Konvertiere Zählungen in Proportionen, mit `denominator = ` "Zeile", "Spalte" oder "alle"                                                                       | 
| `adorn_pct_formatting()`         | Konvertiert Proportionen in Prozentwerte. Angeben `digits =`. Entferne das "%"-Symbol mit `affix_sign = FALSE`.                                                                | 
| `adorn_rounding()`         | So runden Sie Proportionen auf `digits =` Stellen. Um Prozente zu runden, verwende `adorn_pct_formatting()` mit `digits = `.                                                                                   | 
| `adorn_ns()`         | Füge Zählungen zu einer Tabelle mit Proportionen oder Prozentsätzen hinzu. Gib  an. `position =` "hinten" an, um die Zählungen in Klammern darzustellen, oder "vorne", um die Prozentsätze in Klammern zu setzen.                              | 
| `adorn_title()`         | String über Argumente hinzufügen `row_name = ` und/oder `col_name = `                                                                                 | 

Achte auf die Reihenfolge, in der du die oben genannten Funktionen anwendest. Im Folgenden findest du einige Beispiele.

Eine einfache einseitige Tabelle mit Prozenten anstelle der Standardproportionen.

```{r}
linelist %>%               # case linelist
  tabyl(age_cat) %>%       # tabulate counts and proportions by age category
  adorn_pct_formatting()   # convert proportions to percents
```

Eine Kreuztabelle mit einer Gesamtzeile und prozentualen Zeilenanteilen.

```{r}
linelist %>%                                  
  tabyl(age_cat, gender) %>%                  # counts by age and gender
  adorn_totals(where = "row") %>%             # add total row
  adorn_percentages(denominator = "row") %>%  # convert counts to proportions
  adorn_pct_formatting(digits = 1)            # convert proportions to percents
```

Eine Kreuztabelle, die so angepasst ist, dass sowohl Zählungen als auch Prozentsätze angezeigt werden.

```{r}
linelist %>%                                  # case linelist
  tabyl(age_cat, gender) %>%                  # cross-tabulate counts
  adorn_totals(where = "row") %>%             # add a total row
  adorn_percentages(denominator = "col") %>%  # convert to proportions
  adorn_pct_formatting() %>%                  # convert to percents
  adorn_ns(position = "front") %>%            # display as: "count (percent)"
  adorn_title(                                # adjust titles
    row_name = "Age Category",
    col_name = "Gender")
```

### Drucken der Tabelle {.unnumbered}

Standardmäßig wird die Tabellenspalte als Rohdaten auf der R-Konsole ausgegeben.

Alternativ kannst du das Tabyl auch an **flextable**oder ein ähnliches Paket übergeben, um es als "hübsches" Bild im RStudio Viewer auszudrucken, das als .png, .jpeg, .html, etc. exportiert werden kann. Dies wird auf der Seite [Tabellen für die Präsentation]. Beachte, dass du beim Drucken auf diese Weise und mit`adorn_titles()` verwenden, müssen Sie angeben `placement = "combined"`.

```{r}
linelist %>%
  tabyl(age_cat, gender) %>% 
  adorn_totals(where = "col") %>% 
  adorn_percentages(denominator = "col") %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front") %>% 
  adorn_title(
    row_name = "Age Category",
    col_name = "Gender",
    placement = "combined") %>% # this is necessary to print as image
  flextable::flextable() %>%    # convert to pretty image
  flextable::autofit()          # format to one line per row 

```

### Verwendung auf anderen Tischen {.unnumbered}

Du kannst verwenden **Hausmeister**'s `adorn_*()` Funktionen auf andere Tabellen, wie zum Beispiel die von `summarise()` und `count()` von **dplyr**, oder `table()` von **Basis** R. Verlege den Tisch einfach in die gewünschte **Hausmeister** Funktion. Zum Beispiel:

```{r}
linelist %>% 
  count(hospital) %>%   # dplyr function
  adorn_totals()        # janitor function
```

### Speichern der Tabelle {.unnumbered}

Wenn du die Tabelle in ein "hübsches" Bild umwandelst mit einem Paket wie **flextable** umwandelst, kannst du sie mit Funktionen aus diesem Paket speichern - wie `save_as_html()`, `save_as_word()`, `save_as_ppt()`, und `save_as_image()` von **flextable**(wie ausführlicher im Abschnitt [Tabellen für die Präsentation] Seite). Nachfolgend wird die Tabelle als Word-Dokument gespeichert, in dem sie von Hand weiter bearbeitet werden kann.

```{r, eval=F}
linelist %>%
  tabyl(age_cat, gender) %>% 
  adorn_totals(where = "col") %>% 
  adorn_percentages(denominator = "col") %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front") %>% 
  adorn_title(
    row_name = "Age Category",
    col_name = "Gender",
    placement = "combined") %>% 
  flextable::flextable() %>%                     # convert to image
  flextable::autofit() %>%                       # ensure only one line per row
  flextable::save_as_docx(path = "tabyl.docx")   # save as Word document to filepath
```

```{r, out.width="50%", fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "tabyl_word.png"))
```

### Statistik {#janitor\_age\_out\_stats .unnumbered}

Du kannst statistische Tests auf Tabulatoren anwenden, wie `chisq.test()` oder `fisher.test()` aus dem **stats** Paket, wie unten gezeigt. Beachte, dass fehlende Werte nicht erlaubt sind, daher werden sie in der Tabelle mit `show_na = FALSE`.

```{r, warning=F, message=F}
age_by_outcome <- linelist %>% 
  tabyl(age_cat, outcome, show_na = FALSE) 

chisq.test(age_by_outcome)
```

Siehe die Seite über [Einfache statistische Tests] für weiteren Code und Tipps zur Statistik.

### Andere Tipps {.unnumbered}

- Das Argument einbeziehen `na.rm = TRUE` ein, um fehlende Werte von den oben genannten Berechnungen auszuschließen.
- Wenn du eine `adorn_*()` Hilfsfunktionen auf Tabellen angewendet werden, die nicht von `tabyl()` erstellt wurden, können Sie bestimmte Spalten angeben, auf die sie angewendet werden sollen, wie `adorn_percentage(,,,c(cases,deaths))` (gib sie im 4. unbenannten Argument an). Die Syntax ist nicht einfach. Verwende zum Beispiel `summarise()` stattdessen.
- Du kannst mehr Details in der [Hausmeister-Seite](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html) und dieser [tabellarische Vignette](https://cran.r-project.org/web/packages/janitor/vignettes/tabyls.html).

## **dplyr** Paket

**dplyr** ist Teil der **tidyverse** Pakets und ist ein weit verbreitetes Werkzeug zur Datenverwaltung. Tabellen erstellen mit **dplyr** Funktionen `summarise()` und `count()` ist ein nützlicher Ansatz, um zusammenfassende Statistiken zu berechnen, zusammenzufassen *nach Gruppen* oder Tabellen zu übergeben `ggplot()`.

`summarise()` erstellt eine *neuen, zusammenfassenden Datenrahmen*. Wenn die Daten *nicht gruppiert* wird ein einzeiliger Datenrahmen mit den angegebenen zusammenfassenden Statistiken des gesamten Datenrahmens zurückgegeben. Wenn die Daten *gruppiert* gruppiert, enthält der neue Datenrahmen eine Zeile pro *Gruppe*(siehe [Daten gruppieren] Seite).

Innerhalb der `summarise()` Klammern gibst du die Namen jeder neuen Summenspalte an, gefolgt von einem Gleichheitszeichen und einer statistischen Funktion, die angewendet werden soll.

<span style="color: darkgreen;">***TIPP:*** Die Funktion "Zusammenfassen" funktioniert sowohl mit der britischen als auch mit der amerikanischen Rechtschreibung (`summarise()` und `summarize()`).</span>

### Zählungen erhalten {.unnumbered}

Die einfachste Funktion zur Anwendung innerhalb `summarise()` ist `n()`. Lass die Klammern leer, um die Anzahl der Zeilen zu zählen.

```{r}
linelist %>%                 # begin with linelist
  summarise(n_rows = n())    # return new summary dataframe with column n_rows
```

Noch interessanter wird es, wenn wir die Daten vorher gruppiert haben.

```{r}
linelist %>% 
  group_by(age_cat) %>%     # group data by unique values in column age_cat
  summarise(n_rows = n())   # return number of rows *per group*
```

Der obige Befehl kann verkürzt werden, indem man die `count()` Funktion stattdessen verwenden. `count()` macht das Folgende:

1) Sie gruppiert die Daten nach den übergebenen Spalten
2) Fasst sie zusammen mit `n()` (Erstellen von Spalten `n`)
3) Hebt die Gruppierung der Daten auf

```{r}
linelist %>% 
  count(age_cat)
```

Du kannst den Namen der Zählspalte von der Standardeinstellung ändern `n` in einen anderen Namen ändern, indem du ihn mit `name = `.

Tabellarische Zählungen von zwei oder mehr Gruppierungsspalten werden weiterhin im "langen" Format zurückgegeben, wobei die Zählungen in der `n`Spalte. Siehe die Seite über [Pivotierung von Daten] um mehr über "lange" und "breite" Datenformate zu erfahren.

```{r}
linelist %>% 
  count(age_cat, outcome)
```

### Alle Levels anzeigen {.unnumbered}

Wenn du eine Spalte der Klasse tabellierst *Faktor* kannst du sicherstellen, dass *alle* Ebenen angezeigt werden (nicht nur die Ebenen mit Werten in den Daten), indem du `.drop = FALSE` in die `summarise()` oder `count()` Befehl ein.

Diese Technik ist nützlich, um deine Tabellen/Diagramme zu standardisieren. Zum Beispiel, wenn du Zahlen für mehrere Untergruppen erstellst oder die Zahl wiederholt für Routineberichte erstellst. In jedem dieser Fälle kann das Vorhandensein von Werten in den Daten schwanken, aber du kannst Ebenen definieren, die konstant bleiben.

Siehe die Seite über [Faktoren] für weitere Informationen.

### Proportionen {#tbl\_dplyr\_prop .unnumbered}

Proportionen können hinzugefügt werden, indem die Tabelle mit der Pipeline `mutate()` um eine neue Spalte zu erstellen. Definiere die neue Spalte als Zählspalte (`n` standardmäßig) geteilt durch die `sum()` der Zählspalte (dies ergibt ein Verhältnis).

Beachte, dass in diesem Fall, `sum()` in der `mutate()` Befehl die Summe der gesamten Spalte zurückgegeben wird `n` als Nenner für die Proportionen zurück. Wie erklärt [auf der Seite Daten gruppieren](#group_summarise), *wenn* `sum()` verwendet wird in *gruppiert* Daten (z. B. wenn die `mutate()` unmittelbar auf eine `group_by()` Befehl), gibt es Summen zurück *nach Gruppe*. Wie oben bereits erwähnt, `count()` beendet seine Aktionen durch *die Gruppierung aufhebt*. In diesem Szenario erhalten wir also volle Spaltenproportionen.

Um Prozentwerte einfach darzustellen, kannst du die Proportionen in die Funktion einpacken `percent()` aus dem Paket **skaliert** (beachte, dass dies in Klassenzeichen umgewandelt wird).

```{r}
age_summary <- linelist %>% 
  count(age_cat) %>%                     # group and count by gender (produces "n" column)
  mutate(                                # create percent of column - note the denominator
    percent = scales::percent(n / sum(n))) 

# print
age_summary
```

Im Folgenden findest du eine Methode zur Berechnung der Proportionen *innerhalb von Gruppen*. Sie beruht auf verschiedenen Ebenen der Datengruppierung, die selektiv angewendet und entfernt werden. Zunächst werden die Daten gruppiert nach `outcome` über `group_by()`. Dann, `count()` angewendet. Diese Funktion gruppiert die Daten weiter nach `age_cat` und gibt die Anzahl für jede `outcome`\-
`age-cat` Kombination. Wichtig ist, dass er seinen Prozess abschließt, `count()` auch *die Gruppierungauf* die `age_cat` Gruppierung auf, so dass die einzige verbleibende Datengruppierung die ursprüngliche Gruppierung nach `outcome`. Der letzte Schritt der Berechnung der Proportionen (Nenner `sum(n)`) wird immer noch gruppiert durch `outcome`.

```{r}
age_by_outcome <- linelist %>%                  # begin with linelist
  group_by(outcome) %>%                         # group by outcome 
  count(age_cat) %>%                            # group and count by age_cat, and then remove age_cat grouping
  mutate(percent = scales::percent(n / sum(n))) # calculate percent - note the denominator is by outcome group
```

```{r, echo=F}
DT::datatable(age_by_outcome, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```

### Plotten {.unnumbered}

Um eine "lange" Tabellenausgabe wie oben mit `ggplot()` ist relativ einfach. Die Daten liegen natürlich im "langen" Format vor, das von der `ggplot()`. Weitere Beispiele findest du auf den Seiten [ggplot Grundlagen] und [ggplot Tipps].

```{r, warning=F, message=F}
linelist %>%                      # begin with linelist
  count(age_cat, outcome) %>%     # group and tabulate counts by two columns
  ggplot()+                       # pass new data frame to ggplot
    geom_col(                     # create bar plot
      mapping = aes(   
        x = outcome,              # map outcome to x-axis
        fill = age_cat,           # map age_cat to the fill
        y = n))                   # map the counts column `n` to the height
```

### Zusammenfassende Statistiken {.unnumbered}

Ein großer Vorteil von **dplyr** und `summarise()` ist die Möglichkeit, erweiterte statistische Zusammenfassungen wie `median()`, `mean()`, `max()`, `min()`, `sd()` (Standardabweichung) und Perzentile. Du kannst auch verwenden `sum()` kannst du auch die Anzahl der Zeilen ausgeben, die bestimmte logische Kriterien erfüllen. Wie oben beschrieben, können diese Ausgaben für den gesamten Datensatz oder nach Gruppen erstellt werden.

Die Syntax ist dieselbe - innerhalb der `summarise()` Klammern gibst du die Namen jeder neuen zusammenfassenden Spalte an, gefolgt von einem Gleichheitszeichen und einer statistischen Funktion, die angewendet werden soll. Innerhalb der statistischen Funktion gibst du die Spalte(n) an, die bearbeitet werden soll(en), sowie alle relevanten Argumente (z. B. `na.rm = TRUE` für die meisten mathematischen Funktionen).

Du kannst auch Folgendes verwenden `sum()` verwenden, um die Anzahl der Zeilen zurückzugeben, die ein logisches Kriterium erfüllen. Der Ausdruck darin wird gezählt, wenn er den Wert `TRUE`. Zum Beispiel:

- `sum(age_years < 18, na.rm=T)`
- `sum(gender == "male", na.rm=T)`
- `sum(response %in% c("Likely", "Very Likely"))`

Unten, `linelist` werden die Daten zusammengefasst, um die Zeitspanne zwischen dem Auftreten der Symptome und der Krankenhausaufnahme zu beschreiben (Spalte `days_onset_hosp`), nach Krankenhaus.

```{r}
summary_table <- linelist %>%                                        # begin with linelist, save out as new object
  group_by(hospital) %>%                                             # group all calculations by hospital
  summarise(                                                         # only the below summary columns will be returned
    cases       = n(),                                                # number of rows per group
    delay_max   = max(days_onset_hosp, na.rm = T),                    # max delay
    delay_mean  = round(mean(days_onset_hosp, na.rm=T), digits = 1),  # mean delay, rounded
    delay_sd    = round(sd(days_onset_hosp, na.rm = T), digits = 1),  # standard deviation of delays, rounded
    delay_3     = sum(days_onset_hosp >= 3, na.rm = T),               # number of rows with delay of 3 or more days
    pct_delay_3 = scales::percent(delay_3 / cases)                    # convert previously-defined delay column to percent 
  )

summary_table  # print
```

Einige Tipps:

- Verwende `sum()` mit einer logischen Anweisung, um Zeilen zu "zählen", die bestimmte Kriterien erfüllen (`==`)
- Beachte die Verwendung von `na.rm = TRUE` innerhalb mathematischer Funktionen wie `sum()`, sonst `NA` wird bei fehlenden Werten zurückgegeben
- Verwenden Sie die Funktion `percent()` aus der **Skalen** Paket, um einfach in Prozente umzurechnen
  - einstellen `accuracy = ` auf 0,1 oder 0,01, um 1 bzw. 2 Nachkommastellen zu erhalten
- verwenden `round()` von **Basis** R zur Angabe von Dezimalzahlen
- Um diese Statistiken für den gesamten Datensatz zu berechnen, verwende `summarise()` ohne `group_by()`
- Du kannst Spalten für spätere Berechnungen (z. B. Nenner) erstellen, die du dann mit `select()`.

### Bedingte Statistik {.unnumbered}

Du möchtest vielleicht zurückkehren *bedingte Statistik* - z. B. das Maximum der Zeilen, die bestimmte Kriterien erfüllen. Das kannst du erreichen, indem du die Spalte mit Klammern unterteilst `[ ]`. Das folgende Beispiel gibt die Höchsttemperatur für Patienten mit oder ohne Fieber an. Beachte jedoch, dass es sinnvoller sein kann, eine weitere Spalte in die Tabelle einzufügen. `group_by()` Befehl und `pivot_wider()` (wie gezeigt [unten](#tbls_pivot_wider)).

```{r}
linelist %>% 
  group_by(hospital) %>% 
  summarise(
    max_temp_fvr = max(temp[fever == "yes"], na.rm = T),
    max_temp_no = max(temp[fever == "no"], na.rm = T)
  )
```

### Zusammenkleben {.unnumbered}

Die Funktion `str_glue()` von **stringr** ist nützlich, um Werte aus mehreren Spalten in einer neuen Spalte zu kombinieren. In diesem Zusammenhang wird dies typischerweise verwendet *nach* der `summarise()` Befehl.

Im [Zeichen und Zeichenketten] werden verschiedene Optionen für die Kombination von Spalten besprochen, darunter`unite()`, und `paste0()`. In diesem Anwendungsfall plädieren wir für `str_glue()` weil sie flexibler ist als `unite()` und eine einfachere Syntax hat als `paste0()`.

Unten, die `summary_table` Datenrahmen (oben erstellt) so verändert, dass die Spalten `delay_mean` und `delay_sd` kombiniert werden, die neue Spalte mit Klammern formatiert wird und die entsprechenden alten Spalten entfernt werden.

Um die Tabelle ansehnlicher zu machen, wird eine Summenzeile hinzugefügt mit `adorn_totals()` von **Hausmeister** (der nicht-numerische Spalten ignoriert). Zum Schluss verwenden wir `select()` von **dplyr** um die Spalten neu zu ordnen und in schönere Spaltennamen umzubenennen.

Jetzt kannst du an **flextable**übergeben und die Tabelle in Word, .png, .jpeg, .html, Powerpoint, RMarkdown, etc. ausgeben! (siehe die [Tabellen für Präsentationen] Seite).

```{r}
summary_table %>% 
  mutate(delay = str_glue("{delay_mean} ({delay_sd})")) %>%  # combine and format other values
  select(-c(delay_mean, delay_sd)) %>%                       # remove two old columns   
  adorn_totals(where = "row") %>%                            # add total row
  select(                                                    # order and rename cols
    "Hospital Name"   = hospital,
    "Cases"           = cases,
    "Max delay"       = delay_max,
    "Mean (sd)"       = delay,
    "Delay 3+ days"   = delay_3,
    "% delay 3+ days" = pct_delay_3
    )
```

#### Perzentile {.unnumbered}

*Perzentile* und Quantile in **dplyr** verdienen eine besondere Erwähnung. Um Quantile zurückzugeben, verwendest du `quantile()` mit den Standardwerten oder gib den/die gewünschten Wert(e) mit `probs = `.

```{r}
# get default percentile values of age (0%, 25%, 50%, 75%, 100%)
linelist %>% 
  summarise(age_percentiles = quantile(age_years, na.rm = TRUE))

# get manually-specified percentile values of age (5%, 50%, 75%, 98%)
linelist %>% 
  summarise(
    age_percentiles = quantile(
      age_years,
      probs = c(.05, 0.5, 0.75, 0.98), 
      na.rm=TRUE)
    )
```

Wenn du Quantile zurückgeben möchtest *nach Gruppe* zurückgeben willst, kannst du lange und weniger nützliche Ausgaben erhalten, wenn du einfach eine weitere Spalte zu `group_by()`. Versuche stattdessen diesen Ansatz: Erstelle eine Spalte für jedes gewünschte Quantilniveau.

```{r}
# get manually-specified percentile values of age (5%, 50%, 75%, 98%)
linelist %>% 
  group_by(hospital) %>% 
  summarise(
    p05 = quantile(age_years, probs = 0.05, na.rm=T),
    p50 = quantile(age_years, probs = 0.5, na.rm=T),
    p75 = quantile(age_years, probs = 0.75, na.rm=T),
    p98 = quantile(age_years, probs = 0.98, na.rm=T)
    )
```

Während **dplyr** `summarise()` bietet zwar eine bessere Kontrolle, aber du wirst feststellen, dass du alle benötigten Statistiken mit dplyr erstellen kannst. `get_summary_stat()` aus dem **rstatix** Paket. Bei gruppierten Daten liefert if die Werte 0%, 25%, 50%, 75% und 100%. Bei der Anwendung auf nicht gruppierte Daten kannst du die Perzentile mit `probs = c(.05, .5, .75, .98)`.

```{r}
linelist %>% 
  group_by(hospital) %>% 
  rstatix::get_summary_stats(age, type = "quantile")
```

```{r}
linelist %>% 
  rstatix::get_summary_stats(age, type = "quantile")
```

### Aggregierte Daten zusammenfassen {.unnumbered}

*Wenn du mit aggregierten Daten beginnst* verwenden `n()` die Anzahl der *Zeilen* zurück, nicht die Summe der aggregierten Zählungen. Um Summen zu erhalten, verwende `sum()` für die Zählspalte der Daten.

Nehmen wir zum Beispiel an, du beginnst mit dem unten stehenden Datenrahmen mit den Zählungen, genannt `linelist_agg` - Er zeigt im "langen" Format die Fallzahlen nach Ergebnis und Geschlecht.

Im Folgenden erstellen wir diesen Beispieldatenrahmen aus `linelist` Fallzahlen nach Ergebnis und Geschlecht (fehlende Werte wurden der Übersichtlichkeit halber entfernt).

```{r}
linelist_agg <- linelist %>% 
  drop_na(gender, outcome) %>% 
  count(outcome, gender)

linelist_agg
```

Um die Zahlen zu summieren (in der Spalte `n`) nach Gruppe zu summieren, kannst du verwenden `summarise()` aber setze die neue Spalte gleich `sum(n, na.rm=T)`. Um der Summenoperation ein bedingtes Element hinzuzufügen, kannst du die Untermengenklammer verwenden [] Syntax für die Zählspalte verwenden.

```{r}
linelist_agg %>% 
  group_by(outcome) %>% 
  summarise(
    total_cases  = sum(n, na.rm=T),
    male_cases   = sum(n[gender == "m"], na.rm=T),
    female_cases = sum(n[gender == "f"], na.rm=T))
```

### `across()` Mehrere Spalten {.unnumbered}

Du kannst `summarise()` über mehrere Spalten hinweg mit `across()`. Das macht das Leben einfacher, wenn du dieselbe Statistik für viele Spalten berechnen willst. Platziere `across()` innerhalb von `summarise()` ein und gib Folgendes an:

- `.cols = ` entweder als einen Vektor von Spaltennamen `c()` oder als "tidyselect"-Hilfsfunktionen (unten erklärt)
- `.fns = ` die auszuführende Funktion (ohne Klammern) - du kannst mehrere innerhalb einer `list()`

Unten, `mean()` wird auf mehrere numerische Spalten angewendet. Ein Vektor von Spalten wird explizit benannt, um `.cols = ` und eine einzelne Funktion `mean` wird angegeben (ohne Klammern), um `.fns = `. Alle zusätzlichen Argumente für die Funktion (z. B. `na.rm=TRUE`) werden nach `.fns = ` angegeben und durch ein Komma getrennt.

Es kann schwierig sein, die richtige Reihenfolge von Klammern und Kommas zu finden, wenn man `across()`. Denke daran, dass innerhalb von `across()` die Spalten, die Funktionen und alle zusätzlichen Argumente, die für die Funktionen benötigt werden, enthalten musst.

```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm),  # columns
                   .fns = mean,                               # function
                   na.rm=T))                                  # extra arguments
```

Es können mehrere Funktionen auf einmal ausgeführt werden. Unterhalb der Funktionen `mean` und `sd` werden zur Verfügung gestellt `.fns = ` innerhalb einer `list()`. Du hast die Möglichkeit, Zeichennamen anzugeben (z. B. "mean" und "sd"), die an die neuen Spaltennamen angehängt werden.

```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm), # columns
                   .fns = list("mean" = mean, "sd" = sd),    # multiple functions 
                   na.rm=T))                                 # extra arguments
```

Hier sind die "tidyselect"-Hilfsfunktionen, die du zur Verfügung stellen kannst `.cols = ` um Spalten auszuwählen:

- `everything()`  - alle anderen nicht genannten Spalten
- `last_col()`    - die letzte Spalte
- `where()`       - wendet eine Funktion auf alle Spalten an und wählt diejenigen aus, die TRUE sind
- `starts_with()` - mit einem bestimmten Präfix übereinstimmen. Beispiel: `starts_with("date")`
- `ends_with()`   - passt zu einem bestimmten Suffix. Beispiel: `ends_with("_end")`
- `contains()`    - Spalten, die eine Zeichenkette enthalten. Beispiel: `contains("time")`
- `matches()`     - Einen regulären Ausdruck (regex) anwenden. Beispiel: `contains("[pt]al")`
- `num_range()`   -

- `any_of()`      - passt, wenn die Spalte benannt ist. Nützlich, wenn der Name möglicherweise nicht existiert. Beispiel: `any_of(date_onset, date_death, cardiac_arrest)`

Um zum Beispiel den Mittelwert jeder numerischen Spalte zurückzugeben, verwende `where()` und gib die Funktion `as.numeric()` (ohne Klammern). All dies bleibt innerhalb der `across()` Befehl.

```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(
    .cols = where(is.numeric),  # all numeric columns in the data frame
    .fns = mean,
    na.rm=T))
```

### Drehpunkt breiter {#tbls\_pivot\_wider .unnumbered}

Wenn du deine Tabelle im "breiten" Format bevorzugst, kannst du sie mit der Funktion **tidyr** `pivot_wider()` Funktion. Wahrscheinlich musst du die Spalten umbenennen mit `rename()`. Weitere Informationen findest du auf der Seite über [Pivotierung von Daten].

Das folgende Beispiel beginnt mit der "langen" Tabelle `age_by_outcome` aus der [Abschnitt Proportionen](#tbl_dplyr_prop). Wir erstellen sie noch einmal und drucken sie aus, um sie zu verdeutlichen:

```{r}
age_by_outcome <- linelist %>%                  # begin with linelist
  group_by(outcome) %>%                         # group by outcome 
  count(age_cat) %>%                            # group and count by age_cat, and then remove age_cat grouping
  mutate(percent = scales::percent(n / sum(n))) # calculate percent - note the denominator is by outcome group
```

```{r, echo=F}
DT::datatable(age_by_outcome, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Um weiter zu schwenken, erstellen wir die neuen Spalten aus den *Werten* in der bestehenden Spalte `age_cat` (durch Setzen von `names_from = age_cat`). Wir legen auch fest, dass die neuen Tabellenwerte aus der bestehenden Spalte stammen sollen `n` stammen, mit `values_from = n`. Die Spalten, die in unserem Pivot-Befehl nicht erwähnt werden (`outcome`) bleiben auf der linken Seite unverändert.

```{r}
age_by_outcome %>% 
  select(-percent) %>%   # keep only counts for simplicity
  pivot_wider(names_from = age_cat, values_from = n)  
```

### Zeilen gesamt {#tbl\_dplyr\_totals .unnumbered}

Wenn `summarise()` mit gruppierten Daten arbeitet, erstellt es nicht automatisch eine "Gesamtstatistik". Im Folgenden werden zwei Ansätze zum Hinzufügen einer Summenzeile vorgestellt:

#### **Hausmeister**'s `adorn_totals()` {.unnumbered}

Wenn deine Tabelle nur aus Zählungen oder Anteilen/Prozenten besteht, die zu einer Gesamtsumme summiert werden können, dann kannst du Folgendes hinzufügen *Summe* Summen mit **Hausmeister**'s `adorn_totals()` wie im obigen Abschnitt beschrieben. Beachte, dass diese Funktion nur die numerischen Spalten summieren kann - wenn du andere Gesamtzusammenfassungsstatistiken berechnen willst, siehe den nächsten Ansatz mit **dplyr**.

Unten, `linelist` nach Geschlecht gruppiert und in einer Tabelle zusammengefasst, in der die Anzahl der Fälle mit bekanntem Ausgang, der Todesfälle und der wiedergefundenen Fälle beschrieben wird. Wenn du die Tabelle auf `adorn_totals()` fügt unten eine Gesamtzeile hinzu, die die Summe der einzelnen Spalten wiedergibt. Die weitere `adorn_*()` Funktionen passen die Anzeige wie im Code angegeben an.

```{r}
linelist %>% 
  group_by(gender) %>%
  summarise(
    known_outcome = sum(!is.na(outcome)),           # Number of rows in group where outcome is not missing
    n_death  = sum(outcome == "Death", na.rm=T),    # Number of rows in group where outcome is Death
    n_recover = sum(outcome == "Recover", na.rm=T), # Number of rows in group where outcome is Recovered
  ) %>% 
  adorn_totals() %>%                                # Adorn total row (sums of each numeric column)
  adorn_percentages("col") %>%                      # Get column proportions
  adorn_pct_formatting() %>%                        # Convert proportions to percents
  adorn_ns(position = "front")                      # display % and counts (with counts in front)
```

#### `summarise()` auf "Gesamt" Daten und dann `bind_rows()` {.unnumbered}

Wenn deine Tabelle aus zusammenfassenden Statistiken besteht, wie z. B. `median()`, `mean()`, usw., wird die `adorn_totals()` oben gezeigte Ansatz wird *nicht* nicht ausreichen. Um zusammenfassende Statistiken für den gesamten Datensatz zu erhalten, musst du sie stattdessen mit einem separaten `summarise()` Befehl berechnen und die Ergebnisse dann mit der ursprünglichen gruppierten Übersichtstabelle verbinden. Um die Verknüpfung durchzuführen, kannst du Folgendes verwenden `bind_rows()` from **dplyr**s, die im Abschnitt [Daten verknüpfen] Seite beschrieben. Unten findest du ein Beispiel:

Du kannst eine zusammenfassende Tabelle der Ergebnisse erstellen *nach Krankenhaus* mit `group_by()` und `summarise()` wie hier:

```{r, warning=F, message=F}
by_hospital <- linelist %>% 
  filter(!is.na(outcome) & hospital != "Missing") %>%  # Remove cases with missing outcome or hospital
  group_by(hospital, outcome) %>%                      # Group data
  summarise(                                           # Create new summary columns of indicators of interest
    N = n(),                                            # Number of rows per hospital-outcome group     
    ct_value = median(ct_blood, na.rm=T))               # median CT value per group
  
by_hospital # print table
```

Um die Gesamtzahlen zu erhalten, führe dieselbe `summarise()` Befehl aus, aber gruppiere die Daten nur nach dem Ergebnis (nicht nach dem Krankenhaus), etwa so:

```{r}
totals <- linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Grouped only by outcome, not by hospital    
      summarise(
        N = n(),                                       # These statistics are now by outcome only     
        ct_value = median(ct_blood, na.rm=T))

totals # print table
```

Wir können diese beiden Datenrahmen miteinander verbinden. Beachte, dass `by_hospital` 4 Spalten hat, während `totals` 3 Spalten hat. Durch die Verwendung von `bind_rows()` werden die Spalten nach Namen kombiniert und jeder zusätzliche Platz wird mit `NA` aufgefüllt (z.B. die Spalte `hospital` Werte für die beiden neuen `totals` Zeilen). Nach dem Binden der Zeilen wandeln wir diese Leerzeichen in "Total" um, indem wir `replace_na()`(siehe [Datenbereinigung und Kernfunktionen] Seite).

```{r}
table_long <- bind_rows(by_hospital, totals) %>% 
  mutate(hospital = replace_na(hospital, "Total"))
```

Hier ist die neue Tabelle mit den "Gesamt"-Zeilen am unteren Rand.

```{r, message=FALSE, echo=F}
DT::datatable(table_long, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```

Diese Tabelle hat ein "langes" Format, was vielleicht das ist, was du willst. *Wahlweise* kannst du *drehen* diese Tabelle *breiter*um sie besser lesbar zu machen. Siehe den Abschnitt über breiteres Pivoting weiter oben und die [Pivotieren von Daten] Seite. Du kannst auch weitere Spalten hinzufügen und sie schön anordnen. Dieser Code steht unten.

```{r}
table_long %>% 
  
  # Pivot wider and format
  ########################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # Pivot from long to wide
    values_from = c(ct_value, N),                       # new values are from ct and count columns
    names_from = outcome) %>%                           # new column names are from outcomes
  mutate(                                              # Add new columns
    N_Known = N_Death + N_Recover,                               # number with known outcome
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # percent cases who died (to 1 decimal)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # percent who recovered (to 1 decimal)
  select(                                              # Re-order columns
    hospital, N_Known,                                   # Intro columns
    N_Recover, Pct_Recover, ct_value_Recover,            # Recovered columns
    N_Death, Pct_Death, ct_value_Death)  %>%             # Death columns
  arrange(N_Known)                                  # Arrange rows from lowest to highest (Total row at bottom)

```

Und dann kannst du das Ganze schön als Bild ausdrucken - unten ist die Ausgabe, die mit **flextable**. Du kannst mehr über dieses Beispiel und wie du diese "hübsche" Tabelle erreichst, in der [Tabellen für die Präsentation] Seite.

```{r, echo=FALSE, fig.show="hold", message=FALSE, warning=FALSE, out.width=c("50%", "50%")}

linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds")) 

border_style = officer::fp_border(color="black", width=1)

pacman::p_load(
  rio,            # import/export
  here,           # file pathways
  flextable,      # make pretty images of tables 
  officer,        # helper functions for tables
  tidyverse)      # data management, summary, and visualization

table <- linelist %>% 
  # filter
  ########
  #filter(!is.na(outcome) & hospital != "Missing") %>%  # Remove cases with missing outcome or hospital
  
  # Get summary values per hospital-outcome group
  ###############################################
  group_by(hospital, outcome) %>%                      # Group data
  summarise(                                           # Create new summary columns of indicators of interest
    N = n(),                                            # Number of rows per hospital-outcome group     
    ct_value = median(ct_blood, na.rm=T)) %>%           # median CT value per group
  
  # add totals
  ############
  bind_rows(                                           # Bind the previous table with this mini-table of totals
    linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Grouped only by outcome, not by hospital    
      summarise(
        N = n(),                                       # Number of rows for whole dataset     
        ct_value = median(ct_blood, na.rm=T))) %>%     # Median CT for whole dataset
  
  # Pivot wider and format
  ########################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # Pivot from long to wide
    values_from = c(ct_value, N),                       # new values are from ct and count columns
    names_from = outcome) %>%                           # new column names are from outcomes
  mutate(                                              # Add new columns
    N_Known = N_Death + N_Recover,                               # number with known outcome
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # percent cases who died (to 1 decimal)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # percent who recovered (to 1 decimal)
  select(                                              # Re-order columns
    hospital, N_Known,                                   # Intro columns
    N_Recover, Pct_Recover, ct_value_Recover,            # Recovered columns
    N_Death, Pct_Death, ct_value_Death)  %>%             # Death columns
  arrange(N_Known) %>%                                 # Arrange rows from lowest to highest (Total row at bottom)

  # formatting
  ############
  flextable() %>% 
  add_header_row(
    top = TRUE,                # New header goes on top of existing header row
    values = c("Hospital",     # Header values for each column below
               "Total cases with known outcome", 
               "Recovered",    # This will be the top-level header for this and two next columns
               "",
               "",
               "Died",         # This will be the top-level header for this and two next columns
               "",             # Leave blank, as it will be merged with "Died"
               "")) %>% 
    set_header_labels(         # Rename the columns in original header row
      hospital = "", 
      N_Known = "",                  
      N_Recover = "Total",
      Pct_Recover = "% of cases",
      ct_value_Recover = "Median CT values",
      N_Death = "Total",
      Pct_Death = "% of cases",
      ct_value_Death = "Median CT values")  %>% 
  merge_at(i = 1, j = 3:5, part = "header") %>% # Horizontally merge columns 3 to 5 in new header row
  merge_at(i = 1, j = 6:8, part = "header") %>%  
  border_remove() %>%  
  theme_booktabs() %>% 
  vline(part = "all", j = 2, border = border_style) %>%   # at column 2 
  vline(part = "all", j = 5, border = border_style) %>%   # at column 5
  merge_at(i = 1:2, j = 1, part = "header") %>% 
  merge_at(i = 1:2, j = 2, part = "header") %>% 
  width(j=1, width = 2.7) %>% 
  width(j=2, width = 1.5) %>% 
  width(j=c(4,5,7,8), width = 1) %>% 
  flextable::align(., align = "center", j = c(2:8), part = "all") %>% 
  bg(., part = "body", bg = "gray95")  %>% 
  colformat_num(., j = c(4,7), digits = 1) %>% 
  bold(i = 1, bold = TRUE, part = "header") %>% 
  bold(i = 6, bold = TRUE, part = "body")


table
```

## **gtsummary** Paket {#tbl\_gt}

Wenn du deine zusammenfassenden Statistiken in einer hübschen, veröffentlichungsreifen Grafik ausdrucken möchtest, kannst du das **gtsummary** Paket und seine Funktion `tbl_summary()`. Der Code kann auf den ersten Blick komplex erscheinen, aber die Ausgaben sehen sehr schön aus und werden in deinem RStudio-Viewer-Panel als HTML-Bild ausgegeben. Lies eine [Vignette hier](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html).

Du kannst auch die Ergebnisse von statistischen Tests in **gtsummary** Tabellen hinzufügen. Dieser Vorgang wird im Abschnitt **gtsummary** Abschnitt der [Einfache statistische Tests](#stats_gt) Seite.

Zur Einführung `tbl_summary()` zeigen wir zunächst das grundlegendste Verhalten, das tatsächlich eine große und schöne Tabelle erzeugt. Dann werden wir im Detail untersuchen, wie man Anpassungen und mehr maßgeschneiderte Tabellen macht.

### Zusammenfassende Tabelle {.unnumbered}

Das Standardverhalten von `tbl_summary()` ist ziemlich unglaublich - sie nimmt die von dir angegebenen Spalten und erstellt in einem Befehl eine zusammenfassende Tabelle. Die Funktion gibt Statistiken aus, die der Spaltenklasse entsprechen: Median und Interquartilsbereich (IQR) für numerische Spalten und Zählwerte (%) für kategorische Spalten. Fehlende Werte werden in "Unbekannt" umgewandelt. Zur Erläuterung der Statistiken werden unten Fußnoten eingefügt, während oben die Gesamtzahl der N angezeigt wird.

```{r, warning=F, message=F}
linelist %>% 
  select(age_years, gender, outcome, fever, temp, hospital) %>%  # keep only the columns of interest
  tbl_summary()                                                  # default
```

### Anpassungen {.unnumbered}

Jetzt erklären wir dir, wie die Funktion funktioniert und wie du Anpassungen vornehmen kannst. Die wichtigsten Argumente werden im Folgenden erläutert:

**`by = `**  
Du kannst deine Tabelle nach einer Spalte stratifizieren (z. B. nach `outcome`), um eine 2-Wege-Tabelle zu erstellen.

**`statistic = `**  
Verwende eine Gleichung, um festzulegen, welche Statistiken angezeigt werden sollen und wie sie dargestellt werden sollen. Die Gleichung hat zwei Seiten, die durch eine Tilde getrennt sind `~`. Auf der rechten Seite steht in Anführungszeichen die gewünschte Statistikanzeige und auf der linken Seite die Spalten, für die diese Anzeige gelten soll.

- Die rechte Seite der Gleichung verwendet die Syntax von `str_glue()` von **stringr**(siehe [Zeichen und Zeichenketten]), wobei der gewünschte Anzeige-String in Anführungszeichen und die Statistik selbst in geschweiften Klammern steht. Du kannst Statistiken wie "n" (für Zähler), "N" (für Nenner), "mean", "median", "sd", "max", "min", Perzentile als "p##" wie "p25" oder Prozent der Gesamtzahl als "p" angeben. Siehe`?tbl_summary` für Details.
- Für die linke Seite der Gleichung kannst du Spalten mit Namen angeben (z. B. `age` oder `c(age, gender)`) oder mit Hilfsmitteln wie `all_continuous()`, `all_categorical()`, `contains()`, `starts_with()`, usw.

Ein einfaches Beispiel für eine `statistic = ` Gleichung könnte wie folgt aussehen, um nur den Mittelwert der Spalte `age_years`:

```{r}
linelist %>% 
  select(age_years) %>%         # keep only columns of interest 
  tbl_summary(                  # create summary table
    statistic = age_years ~ "{mean}") # print mean of age
```

Eine etwas komplexere Gleichung könnte wie folgt aussehen `"({min}, {max})"` wobei die Maximal- und Minimalwerte in Klammern stehen und durch ein Komma getrennt sind:

```{r}
linelist %>% 
  select(age_years) %>%                       # keep only columns of interest 
  tbl_summary(                                # create summary table
    statistic = age_years ~ "({min}, {max})") # print min and max of age
```

Du kannst die Syntax auch für einzelne Spalten oder Spaltentypen differenzieren. In dem komplexeren Beispiel unten wird der Wert, der für `statistc = ` ist eine **Liste** die angibt, dass die Tabelle für alle kontinuierlichen Spalten den Mittelwert mit der Standardabweichung in Klammern und für alle kategorialen Spalten das n, den Nenner und die Prozentzahl ausgeben soll.

**`digits = `**  
Passe die Ziffern und Rundungen an. Optional kann festgelegt werden, dass dies nur für fortlaufende Spalten gilt (siehe unten).

**`label = `**  
Lege fest, wie der Spaltenname angezeigt werden soll. Gib den Spaltennamen und die gewünschte Bezeichnung durch eine Tilde getrennt an. Die Vorgabe ist der Spaltenname.

**`missing_text = `**  
Lege fest, wie fehlende Werte angezeigt werden. Die Standardeinstellung ist "Unbekannt".

**`type = `**  
Hier kannst du einstellen, wie viele Ebenen der Statistik angezeigt werden sollen. Die Syntax ist ähnlich wie bei `statistic = ` dass du eine Gleichung mit Spalten auf der linken Seite und einem Wert auf der rechten Seite angibst. Zwei häufige Szenarien sind:

- `type = all_categorical() ~ "categorical"` Du erzwingst dichotome Spalten (z. B. `fever` ja/nein) alle Ebenen statt nur die Zeile "ja" anzeigen
- `type = all_continuous() ~ "continuous2"` Ermöglicht mehrzeilige Statistiken pro Variable, wie in einem späteren Abschnitt gezeigt

In dem folgenden Beispiel wird jedes dieser Argumente verwendet, um die ursprüngliche Übersichtstabelle zu ändern:

```{r}
linelist %>% 
  select(age_years, gender, outcome, fever, temp, hospital) %>% # keep only columns of interest
  tbl_summary(     
    by = outcome,                                               # stratify entire table by outcome
    statistic = list(all_continuous() ~ "{mean} ({sd})",        # stats and format for continuous columns
                     all_categorical() ~ "{n} / {N} ({p}%)"),   # stats and format for categorical columns
    digits = all_continuous() ~ 1,                              # rounding for continuous columns
    type   = all_categorical() ~ "categorical",                 # force all categorical levels to display
    label  = list(                                              # display labels for column names
      outcome   ~ "Outcome",                           
      age_years ~ "Age (years)",
      gender    ~ "Gender",
      temp      ~ "Temperature",
      hospital  ~ "Hospital"),
    missing_text = "Missing"                                    # how missing values should display
  )
```

### Mehrzeilige Statistiken für kontinuierliche Variablen {.unnumbered}

Wenn du mehrere Statistikzeilen für kontinuierliche Variablen ausdrucken möchtest, kannst du dies angeben, indem du die Option `type = ` auf "kontinuierlich2" setzt.  Du kannst alle zuvor angezeigten Elemente in einer Tabelle zusammenfassen, indem du auswählst, welche Statistiken du anzeigen möchtest. Dazu musst du der Funktion mitteilen, dass du eine Tabelle zurückbekommen möchtest, indem du den Typ als "continuous2" eingibst. Die Anzahl der fehlenden Werte wird als "Unbekannt" angezeigt.

```{r}
linelist %>% 
  select(age_years, temp) %>%                      # keep only columns of interest
  tbl_summary(                                     # create summary table
    type = all_continuous() ~ "continuous2",       # indicate that you want to print multiple statistics 
    statistic = all_continuous() ~ c(
      "{mean} ({sd})",                             # line 1: mean and SD
      "{median} ({p25}, {p75})",                   # line 2: median and IQR
      "{min}, {max}")                              # line 3: min and max
    )
```

Es gibt noch viele andere Möglichkeiten, diese Tabellen zu verändern, wie z. B. das Hinzufügen von p-Werten, das Anpassen von Farben und Überschriften usw. Viele dieser Möglichkeiten werden in der Dokumentation beschrieben (gib `?tbl_summary` in der Konsole), und einige sind im Abschnitt über [Statistische Tests](https://epirhandbook.com/simple-statistical-tests.html).

## **Basis** R

Du kannst die Funktion `table()` verwenden, um Spalten zu tabellieren und Kreuztabellen zu erstellen. Anders als bei den obigen Optionen musst du den Datenrahmen jedes Mal angeben, wenn du auf einen Spaltennamen verweist, wie unten gezeigt.

<span style="color: orange;">***VORSICHT!*** `NA` (fehlende) Werte werden **nicht** tabelliert, es sei denn, du gibst das Argument `useNA = "always"` (das auch auf "no" oder "ifany" gesetzt werden kann).</span>

<span style="color: darkgreen;">***TIPP:*** Du kannst die `%$%` von **magrittr** um die Notwendigkeit von wiederholten Datenrahmenaufrufen innerhalb von **Basis** Funktionen zu vermeiden. Zum Beispiel könnte das folgende geschrieben werden `linelist %$% table(outcome, useNA = "always")` </span>

```{r}
table(linelist$outcome, useNA = "always")
```

Mehrere Spalten können kreuztabelliert werden, indem du sie nacheinander auflistest, getrennt durch Kommas. Optional kannst du jeder Spalte einen "Namen" geben, z. B. `Outcome = linelist$outcome`.

```{r}
age_by_outcome <- table(linelist$age_cat, linelist$outcome, useNA = "always") # save table as object
age_by_outcome   # print table
```

### Proportionen {.unnumbered}

Um Proportionen zurückzugeben, übergibt man die obige Tabelle an die Funktion `prop.table()`. Verwende die `margins = ` gibst du an, ob du die Proportionen der Zeilen (1), der Spalten (2) oder der gesamten Tabelle (3) haben möchtest. Der Übersichtlichkeit halber leiten wir die Tabelle in die `round()` Funktion von **Basis** R, unter Angabe von 2 Ziffern.

```{r}
# get proportions of table defined above, by rows, rounded
prop.table(age_by_outcome, 1) %>% round(2)
```

### Summen {.unnumbered}

Um Zeilen- und Spaltensummen zu addieren, übergibst du die Tabelle an `addmargins()`. Das funktioniert sowohl für Zählungen als auch für Proportionen.

```{r}
addmargins(age_by_outcome)
```

### In Datenrahmen umwandeln {.unnumbered}

Konvertieren einer `table()` Objekt direkt in einen Datenrahmen umzuwandeln, ist nicht ganz einfach. Ein Ansatz wird im Folgenden gezeigt:

1) Erstelle die Tabelle, *ohne Verwendung von* `useNA = "always"`. Stattdessen konvertieren `NA` Werte in "(Missing)" mit `fct_explicit_na()` von **forcats**.
2) Addiere die Summen (optional), indem du auf `addmargins()`
3) Rohrleitung zu den **Basis** R-Funktion `as.data.frame.matrix()`
4) Übertrage die Tabelle in die **tibble** Funktion `rownames_to_column()` und gibt den Namen für die erste Spalte an
5) Drucken, Anzeigen oder Exportieren nach Wunsch. In diesem Beispiel verwenden wir `flextable()` aus Paket **flextable**wie im Abschnitt [Tabellen für die Präsentation] Seite beschrieben. Dies wird im RStudio-Viewer-Fenster als hübsches HTML-Bild ausgedruckt.

```{r, warning=F, message=F}
table(fct_explicit_na(linelist$age_cat), fct_explicit_na(linelist$outcome)) %>% 
  addmargins() %>% 
  as.data.frame.matrix() %>% 
  tibble::rownames_to_column(var = "Age Category") %>% 
  flextable::flextable()
```

<!-- ======================================================= -->

## Ressourcen {  }

Ein Großteil der Informationen auf dieser Seite wurde aus diesen Ressourcen und Vignetten online übernommen:

[gtsummary](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html)

[dplyr](https://dplyr.tidyverse.org/articles/grouping.html)


