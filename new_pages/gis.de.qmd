# GIS-Grundlagen { }

```{r, out.width=c("100%", "100%"), echo=F}
knitr::include_graphics(here::here("images", "gis_head_image.png"))
```

<!-- ======================================================= -->

## Übersicht {  }

Räumliche Aspekte deiner Daten können eine Menge Einblicke in die Situation des Ausbruchs geben und Fragen beantworten wie:

- Wo sind die aktuellen Krankheitsherde?
- Wie haben sich die Hotspots im Laufe der Zeit verändert?
- Wie sieht es mit dem Zugang zu Gesundheitseinrichtungen aus? Sind irgendwelche Verbesserungen nötig?

Der aktuelle Schwerpunkt dieser GIS-Seite liegt auf den Bedürfnissen angewandter Epidemiologen bei der Reaktion auf Ausbrüche. Wir werden grundlegende Methoden der räumlichen Datenvisualisierung erkunden, indem wir **tmap** und **ggplot2** Pakete. Wir werden auch einige der grundlegenden Methoden zur Verwaltung und Abfrage von Geodaten mit dem **sf** Paket. Zum Schluss werden wir kurz auf die Konzepte von *räumlichen Statistik* wie räumliche Beziehungen, räumliche Autokorrelation und räumliche Regression mit Hilfe des **spdep** Paket.

## Schlüsselbegriffe {}

Im Folgenden stellen wir einige wichtige Begriffe vor. Für eine gründliche Einführung in GIS und räumliche Analysen empfehlen wir dir, eines der längeren Tutorials oder Kurse zu besuchen, die im Abschnitt Referenzen aufgeführt sind.

**Geografisches Informationssystem (GIS)** - Ein GIS ist ein Rahmen oder eine Umgebung zum Sammeln, Verwalten, Analysieren und Visualisieren von räumlichen Daten.

### GIS-Software {.unnumbered}

Einige gängige GIS-Software ermöglicht eine Point-and-Click-Interaktion für die Kartenerstellung und räumliche Analyse. Diese Tools haben den Vorteil, dass du keinen Code lernen musst und dass du Symbole und Funktionen einfach manuell auswählen und auf einer Karte platzieren kannst. Hier sind zwei beliebte Programme:

**ArcGIS** - Eine kommerzielle GIS-Software, die von der Firma ESRI entwickelt wurde und sehr beliebt, aber ziemlich teuer ist.

**QGIS** - Eine kostenlose Open-Source-GIS-Software, die fast alles kann, was ArcGIS auch kann. Du kannst [QGIS hier herunterladen](https://qgis.org/en/site/forusers/download.html)

Die Verwendung von R als GIS kann anfangs etwas einschüchternd wirken, da es anstelle von "Zeigen und Klicken" eine "Befehlszeilenschnittstelle" hat (du musst programmieren, um das gewünschte Ergebnis zu erhalten). Dies ist jedoch ein großer Vorteil, wenn du immer wieder Karten erstellen oder eine Analyse erstellen musst, die reproduzierbar ist.

### Räumliche Daten {.unnumbered}

Die beiden wichtigsten Formen von Geodaten, die in GIS verwendet werden, sind Vektor- und Rasterdaten:

**Vektordaten** - Vektordaten sind das gebräuchlichste Format für Geodaten im GIS und bestehen aus geometrischen Merkmalen wie Scheitelpunkten und Pfaden. Vektorielle Geodaten können in drei weit verbreitete Typen unterteilt werden:

- *Punkte* - Ein Punkt besteht aus einem Koordinatenpaar (x,y), das einen bestimmten Ort in einem Koordinatensystem darstellt. Punkte sind die grundlegendste Form von Geodaten und können verwendet werden, um einen Fall (z. B. die Wohnung eines Patienten) oder einen Ort (z. B. ein Krankenhaus) auf einer Karte zu kennzeichnen.

- *Linien* - Eine Linie besteht aus zwei miteinander verbundenen Punkten. Linien haben eine bestimmte Länge und können z. B. Straßen oder Flüsse kennzeichnen.

- *Polygone* - Ein Polygon besteht aus mindestens drei Liniensegmenten, die durch Punkte verbunden sind. Polygone haben sowohl eine Länge (d.h. den Umfang der Fläche) als auch ein Flächenmaß. Polygone können verwendet werden, um ein Gebiet (z. B. ein Dorf) oder eine Struktur (z. B. die tatsächliche Fläche eines Krankenhauses) festzuhalten.

**Rasterdaten** - Ein alternatives Format für räumliche Daten, Rasterdaten, ist eine Matrix aus Zellen (z. B. Pixel), wobei jede Zelle Informationen wie Höhe, Temperatur, Neigung, Waldbedeckung usw. enthält. Oft handelt es sich dabei um Luftaufnahmen, Satellitenbilder usw. Rasterdaten können auch als "Basiskarten" unter Vektordaten verwendet werden.

### Visualisierung räumlicher Daten {.unnumbered}

Um räumliche Daten auf einer Karte visuell darstellen zu können, benötigt die GIS-Software ausreichende Informationen darüber, wo die verschiedenen Merkmale im Verhältnis zueinander liegen sollen. Wenn du Vektordaten verwendest, was bei den meisten Anwendungsfällen der Fall ist, werden diese Informationen in der Regel in einem Shapefile gespeichert:

**Shapefiles** - Ein Shapefile ist ein gängiges Datenformat zur Speicherung von "Vektor"-Geodaten, die aus Linien, Punkten oder Polygonen bestehen. Ein einzelnes Shapefile ist eigentlich eine Sammlung von mindestens drei Dateien - .shp, .shx und .dbf. Alle diese Unterdateien müssen sich in einem bestimmten Verzeichnis (Ordner) befinden, damit das Shapefile gelesen werden kann. Die zugehörigen Dateien können in einem ZIP-Ordner komprimiert werden, um sie per E-Mail zu versenden oder von einer Website herunterzuladen.

Das Shapefile enthält Informationen über die Merkmale selbst und darüber, wo sie auf der Erdoberfläche zu finden sind. Das ist wichtig, denn während die Erde ein Globus ist, sind Karten in der Regel zweidimensional. Die Entscheidung, wie räumliche Daten "geglättet" werden, kann einen großen Einfluss auf das Aussehen und die Interpretation der resultierenden Karte haben.

**Koordinatenreferenzsysteme (CRS)** - Ein CRS ist ein koordinatenbasiertes System, das verwendet wird, um geografische Merkmale auf der Erdoberfläche zu lokalisieren. Es hat ein paar wichtige Komponenten:

- *Koordinatensystem* - Es gibt viele verschiedene Koordinatensysteme, also stelle sicher, dass du weißt, aus welchem System deine Koordinaten stammen. Üblich sind Breiten- und Längengrade, aber du kannst auch [UTM](https://www.maptools.com/tutorials/utm/quick_guide) Koordinaten.

- *Einheiten* - Kenne die Einheiten für dein Koordinatensystem (z.B. Dezimalgrad, Meter)

- *Datum* - Eine bestimmte modellierte Version der Erde. Sie wurden im Laufe der Jahre überarbeitet. Stelle also sicher, dass deine Kartenebenen das gleiche Datum verwenden.

- *Projektion* - Ein Verweis auf die mathematische Gleichung, die verwendet wurde, um die wirklich runde Erde auf eine flache Oberfläche (Karte) zu projizieren.

Denke daran, dass du räumliche Daten auch zusammenfassen kannst, ohne die unten gezeigten Kartierungswerkzeuge zu verwenden. Manchmal reicht eine einfache Tabelle nach Geografie (z. B. Bezirk, Land usw.)!

## Erste Schritte mit GIS

Es gibt ein paar wichtige Dinge, die du für die Erstellung einer Karte brauchst und an die du denken musst. Dazu gehören:

- A **Datensatz** -- kann in einem räumlichen Datenformat vorliegen (z. B. Shapefiles, wie oben beschrieben) oder auch in einem nicht-räumlichen Format (z. B. als csv-Datei).

- Wenn dein Datensatz nicht in einem räumlichen Format vorliegt, brauchst du außerdem eine **Referenzdatensatz**. Referenzdaten bestehen aus der räumlichen Darstellung der Daten und den zugehörigen **Attributen** Dazu gehört auch Material mit Standort- und Adressinformationen zu bestimmten Merkmalen.
  
  - Wenn du mit vordefinierten geografischen Grenzen arbeitest (z. B. Verwaltungsregionen), sind Referenz-Shapefiles oft frei verfügbar und können von einer Regierungsbehörde oder einer Datenaustauschorganisation heruntergeladen werden. Im Zweifelsfall ist es ratsam, bei Google nach "[Regionen] Shapefile"
  
  - Wenn du Adressinformationen, aber keine Längen- und Breitengrade hast, musst du eventuell eine **Geokodierungsmaschine** verwenden, um die räumlichen Referenzdaten für deine Datensätze zu erhalten.

- Eine Idee über **wie du die Daten präsentieren willst** die Informationen in deinen Datensätzen für dein Zielpublikum darstellen willst. Es gibt viele verschiedene Arten von Karten, und es ist wichtig, dass du dir überlegst, welche Art von Karte am besten zu deinen Bedürfnissen passt.

### Arten von Karten zur Visualisierung deiner Daten {.unnumbered}

**Choropleth-Karte** - Eine Art von thematischer Karte, bei der Farben, Schattierungen oder Muster verwendet werden, um geografische Regionen im Verhältnis zu ihrem Wert eines Attributs darzustellen. Ein größerer Wert kann zum Beispiel durch eine dunklere Farbe dargestellt werden als ein kleinerer Wert. Diese Art von Karte ist besonders nützlich, um eine Variable und ihre Veränderungen in bestimmten Regionen oder geopolitischen Gebieten zu veranschaulichen.

```{r, out.width="50%", fig.align="center", fig.show="hold", echo=F}
knitr::include_graphics(here::here("images", "gis_choropleth.png"))
```

**Heatmap zur Falldichte** - eine Art von thematischer Karte, bei der Farben verwendet werden, um die Intensität eines Wertes darzustellen, aber keine definierten Regionen oder geopolitischen Grenzen zur Gruppierung von Daten verwendet werden. Diese Art von Karte wird in der Regel zur Darstellung von "Hot Spots" oder Gebieten mit einer hohen Dichte oder Konzentration von Punkten verwendet.

```{r, fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "gis_heatmap.png"))
```

**Punktdichtekarte** - ein thematischer Kartentyp, der Punkte verwendet, um Attributwerte in deinen Daten darzustellen. Diese Art von Karte eignet sich am besten, um die Streuung deiner Daten zu visualisieren und visuell nach Clustern zu suchen.

```{r, fig.align="center", echo=F}
# dot density img here
```

**Proportionale Symbolkarte (Karte mit abgestuften Symbolen)** - Eine thematische Karte, die einer Choroplethenkarte ähnelt, bei der jedoch der Wert eines Attributs nicht mit einer Farbe, sondern mit einem Symbol (in der Regel einem Kreis) im Verhältnis zum Wert angegeben wird. So kann zum Beispiel ein größerer Wert durch ein größeres Symbol angezeigt werden als ein kleinerer Wert. Diese Art von Karte eignet sich am besten, wenn du die Größe oder Menge deiner Daten über geografische Regionen hinweg visualisieren willst.

```{r, fig.align="center", echo=F}
# proportional symbols img here
```

Du kannst auch mehrere verschiedene Arten von Visualisierungen kombinieren, um komplexe geografische Muster darzustellen. Zum Beispiel sind die Fälle (Punkte) in der Karte unten nach der nächstgelegenen Gesundheitseinrichtung eingefärbt (siehe Legende). Die großen roten Kreise zeigen *Einzugsgebiete von Gesundheitseinrichtungen* Die großen roten Kreise zeigen die Einzugsgebiete der Gesundheitseinrichtungen in einem bestimmten Radius an, die hellroten Punkte die Fälle, die außerhalb eines Einzugsgebiets lagen:

```{r, fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "gis_hf_catchment.png"))
```

Hinweis: Der Hauptfokus dieser GIS-Seite liegt auf dem Kontext der Reaktion auf Ausbrüche vor Ort. Daher wird der Inhalt der Seite die grundlegenden räumlichen Datenmanipulationen, Visualisierungen und Analysen abdecken.

<!-- ======================================================= -->

## Vorbereitung {  }

### Pakete laden {.unnumbered}

Dieser Codeabschnitt zeigt das Laden von Paketen, die für die Analysen benötigt werden. In diesem Handbuch betonen wir `p_load()` von **pacman**, der das Paket bei Bedarf installiert *und* lädt es zur Verwendung. Du kannst installierte Pakete auch laden mit `library()` von **base**R. Siehe die Seite über [R-Grundlagen] für weitere Informationen über R-Pakete.

```{r}
pacman::p_load(
  rio,           # to import data
  here,          # to locate files
  tidyverse,     # to clean, handle, and plot the data (includes ggplot2 package)
  sf,            # to manage spatial data using a Simple Feature format
  tmap,          # to produce simple maps, works for both interactive and static maps
  janitor,       # to clean column names
  OpenStreetMap, # to add OSM basemap in ggplot map
  spdep          # spatial statistics
  )
```

Einen Überblick über alle R-Pakete, die sich mit räumlichen Daten befassen, findest du auf der [CRAN "Spatial Task View"](https://cran.r-project.org/web/views/Spatial.html).

### Beispielhafte Falldaten {.unnumbered}

Zu Demonstrationszwecken arbeiten wir mit einer Zufallsstichprobe von 1000 Fällen aus der simulierten Ebola-Epidemie `linelist` Datenrahmen arbeiten (aus rechnerischen Gründen ist es einfacher, in diesem Handbuch mit weniger Fällen zu arbeiten). Wenn du mitmachen willst, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>klicke hier, um die "saubere" Linienliste herunterzuladen</a> (als .rds-Datei).

Da wir eine Stichprobe der Fälle nehmen, können deine Ergebnisse etwas anders aussehen als hier gezeigt, wenn du die Codes selbst ausführst.

Importiere Daten mit dem `import()` Funktion aus dem **rio**Paket (sie verarbeitet viele Dateitypen wie .xlsx, .csv, .rds - siehe die [Import und Export] Seite für Details).

```{r, echo=F}
# import clean case linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))  
```

```{r, eval=F}
# import clean case linelist
linelist <- import("linelist_cleaned.rds")  
```

Als nächstes wählen wir eine Zufallsstichprobe von 1000 Zeilen mit `sample()` aus **Basis** R.

```{r}
# generate 1000 random row numbers, from the number of rows in linelist
sample_rows <- sample(nrow(linelist), 1000)

# subset linelist to keep only the sample rows, and all columns
linelist <- linelist[sample_rows,]
```

Jetzt wollen wir das umwandeln `linelist` der Klasse dataframe, in ein Objekt der Klasse "sf" (spatial features) umwandeln. Da die Zeilenliste zwei Spalten "lon" und "lat" enthält, die den Längen- und Breitengrad des Wohnorts eines jeden Falles angeben, ist das ganz einfach.

Wir verwenden das Paket **sf** (räumliche Merkmale) und seine Funktion `st_as_sf()` um das neue Objekt zu erstellen, rufen wir `linelist_sf`. Dieses neue Objekt sieht im Wesentlichen genauso aus wie die Linelist, aber die Spalten `lon` und `lat` wurden als Koordinatenspalten bezeichnet, und es wurde ein Koordinatenreferenzsystem (CRS) für die Anzeige der Punkte zugewiesen. 4326 identifiziert unsere Koordinaten als basierend auf dem [World Geodetic System 1984 (WGS84)](https://gisgeography.com/wgs84-world-geodetic-system/) - das der Standard für GPS-Koordinaten ist.

```{r}
# Create sf object
linelist_sf <- linelist %>%
     sf::st_as_sf(coords = c("lon", "lat"), crs = 4326)
```

So ist das ursprüngliche `linelist` Datenrahmen aussieht. In dieser Demonstration verwenden wir nur die Spalte `date_onset` und `geometry` (die aus den obigen Feldern für Längen- und Breitengrad gebildet wurde und die letzte Spalte im Datenrahmen ist).

```{r}
DT::datatable(head(linelist_sf, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Shapefiles der Verwaltungsgrenzen {.unnumbered}

**Sierra Leone: Shapefiles der Verwaltungsgrenzen**

Im Vorfeld haben wir alle administrativen Grenzen für Sierra Leone vom Humanitarian Data Exchange (HDX) heruntergeladen [Website hier](https://data.humdata.org/dataset/sierra-leone-all-ad-min-level-boundaries). Alternativ kannst du diese und alle anderen Beispieldaten für dieses Handbuch auch über unser R-Paket herunterladen, wie in der [Handbuch und Daten herunterladen] Seite erklärt wird.

Jetzt machen wir Folgendes, um das Admin Level 3 Shapefile in R zu speichern:

1) Importiere das Shapefile
2) Bereinige die Spaltennamen
3) Zeilen filtern, um nur Bereiche von Interesse zu erhalten

Um ein Shapefile zu importieren, verwenden wir die `read_sf()` Funktion von **sf**. Sie erhält den Dateipfad über `here()`. - in unserem Fall befindet sich die Datei innerhalb unseres R-Projekts in den Unterordnern "data", "gis" und "shp" mit dem Dateinamen "sle_adm3.shp" (siehe Seiten über [Importieren und Exportieren] und [R-Projekte] für weitere Informationen). Du musst deinen eigenen Dateipfad angeben.

```{r, echo=F}
sle_adm3_raw <- sf::read_sf(here("data", "gis", "shp", "sle_adm3.shp"))
```

Als nächstes verwenden wir `clean_names()` aus dem **Hausmeister** Paket, um die Spaltennamen des Shapefiles zu standardisieren. Wir verwenden auch `filter()` um nur die Zeilen zu behalten, deren admin2name "Western Area Urban" oder "Western Area Rural" lautet.

```{r}
# ADM3 level clean
sle_adm3 <- sle_adm3_raw %>%
  janitor::clean_names() %>% # standardize column names
  filter(admin2name %in% c("Western Area Urban", "Western Area Rural")) # filter to keep certain areas
```

Unten kannst du sehen, wie das Shapefile nach dem Import und der Bereinigung aussieht. *Scrolle nach rechts* um zu sehen, dass es Spalten mit Verwaltungsebene 0 (Land), Verwaltungsebene 1, Verwaltungsebene 2 und schließlich Verwaltungsebene 3 gibt. Jede Ebene hat einen Zeichennamen und einen eindeutigen Bezeichner "pcode". Der pcode erweitert sich mit jeder aufsteigenden Verwaltungsebene, z.B. SL (Sierra Leone) -> SL04 (Western) -> SL0410 (Western Area Rural) -> SL040101 (Koya Rural).

```{r, message=FALSE, echo=F}
# display the shapefile as a table
DT::datatable(head(sle_adm3, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Bevölkerungsdaten {.unnumbered}

**Sierra Leone: Bevölkerung nach ADM3**

Diese Daten können wiederum von HDX heruntergeladen werden (Link [hier](https://data.humdata.org/dataset/sierra-leone-population)) oder über unser **epirhandbook**R-Paket, wie auf der [auf dieser Seite][Handbuch und Daten herunterladen]. Wir verwenden`import()` um die .csv-Datei zu laden. Wir übergeben die importierte Datei auch an `clean_names()` um die Syntax der Spaltennamen zu standardisieren.

```{r}
# Population by ADM3
sle_adm3_pop <- import(here("data", "gis", "population", "sle_admpop_adm3_2020.csv")) %>%
  janitor::clean_names()
```

So sieht die Bevölkerungsdatei aus. Scrolle nach rechts, um zu sehen, dass jedes Bundesland Spalten mit `male` Bevölkerung, `female` bevölkerung, `total` Bevölkerung und die Aufteilung der Bevölkerung in Spalten nach Altersgruppen.

```{r, message=FALSE, echo=F}
# display the population as a table
DT::datatable(head(sle_adm3_pop, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Gesundheitseinrichtungen {.unnumbered}

**Sierra Leone: Daten zu Gesundheitseinrichtungen von OpenStreetMap**

Auch hier haben wir die Standorte der Gesundheitseinrichtungen von HDX heruntergeladen [hier](https://data.humdata.org/dataset/hotosm_sierra_leone_health_facilities)oder über die Anweisungen im [Handbuch und Daten herunterladen] Seite.

Wir importieren das Shapefile der Anlagenpunkte mit `read_sf()` ein, bereinigen erneut die Spaltennamen und filtern dann nur die Punkte, die entweder als "Krankenhaus", "Klinik" oder "Ärzte" gekennzeichnet sind.

```{r}
# OSM health facility shapefile
sle_hf <- sf::read_sf(here("data", "gis", "shp", "sle_hf.shp")) %>% 
  janitor::clean_names() %>%
  filter(amenity %in% c("hospital", "clinic", "doctors"))
```

Hier ist der resultierende Datenrahmen - *nach rechts scrollen* um den Namen der Einrichtung zu sehen und `geometry` Koordinaten.

```{r, message=FALSE, echo=F}
# display the population as a table
DT::datatable(head(sle_hf, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

## Koordinaten einzeichnen {  }

Der einfachste Weg, X-Y-Koordinaten (Längen-/Breitengrad, Punkte) zu zeichnen, ist in diesem Fall, sie als Punkte direkt aus dem Feld `linelist_sf` Objekt zu zeichnen, das wir im Vorbereitungsabschnitt erstellt haben.

Das Paket **tmap** bietet einfache Mapping-Funktionen für den statischen ("Plot"-Modus) und den interaktiven ("View"-Modus) mit nur wenigen Zeilen Code. Das **tmap** Syntax ist ähnlich wie die von **ggplot2** Die Befehle werden mit den folgenden Worten aneinander gehängt `+`. Lesen Sie mehr Details in diesem [Vignette](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html).

1) Stellen Sie die **tmap** Modus. In diesem Fall verwenden wir den "Plot"-Modus, der statische Ausgaben erzeugt.

```{r, warning=F, message=F}
tmap_mode("plot") # choose either "view" or "plot"
```

Unten sind die Punkte einzeln aufgetragen.`tm_shape()` wird mit dem `linelist_sf` Objekten. Wir fügen dann Punkte über `tm_dots()` und geben dabei die Größe und Farbe an. Weil `linelist_sf` ein sf-Objekt ist, haben wir die beiden Spalten mit den Längen- und Breitenkoordinaten und dem Koordinatenreferenzsystem (CRS) bereits festgelegt:

```{r, warning=F, message=F}
# Just the cases (points)
tm_shape(linelist_sf) + tm_dots(size=0.08, col='blue')
```

Die Punkte allein sagen uns aber nicht viel. Deshalb sollten wir auch die Verwaltungsgrenzen abbilden:

Auch hier verwenden wir `tm_shape()` (siehe [Dokumentation](https://www.rdocumentation.org/packages/tmap/versions/3.3/topics/tm_shape)), aber statt des Shapefiles der Fallpunkte stellen wir das Shapefile der Verwaltungsgrenzen (Polygone) zur Verfügung.

Mit der `bbox = ` Argument (bbox steht für "bounding box") können wir die Koordinatengrenzen angeben. Zuerst zeigen wir die Kartenanzeige ohne `bbox` und dann mit ihr.

```{r, out.width=c("50%", "50%"), fig.show="hold", warning=F, message=F}
# Just the administrative boundaries (polygons)
tm_shape(sle_adm3) +               # admin boundaries shapefile
  tm_polygons(col = "#F7F7F7")+    # show polygons in light grey
  tm_borders(col = "#000000",      # show borders with color and line weight
             lwd = 2) +
  tm_text("admin3name")            # column text to display for each polygon


# Same as above, but with zoom from bounding box
tm_shape(sle_adm3,
         bbox = c(-13.3, 8.43,    # corner
                  -13.2, 8.5)) +  # corner
  tm_polygons(col = "#F7F7F7") +
  tm_borders(col = "#000000", lwd = 2) +
  tm_text("admin3name")

```

Und jetzt beide Punkte und Polygone zusammen:

```{r, warning=F, message=FALSE}
# All together
tm_shape(sle_adm3, bbox = c(-13.3, 8.43, -13.2, 8.5)) +     #
  tm_polygons(col = "#F7F7F7") +
  tm_borders(col = "#000000", lwd = 2) +
  tm_text("admin3name")+
tm_shape(linelist_sf) +
  tm_dots(size=0.08, col='blue', alpha = 0.5) +
  tm_layout(title = "Distribution of Ebola cases")   # give title to map

```

Einen guten Vergleich der Mapping-Optionen in R findest du hier [Blog-Beitrag](https://rstudio-pubs-static.s3.amazonaws.com/324400_69a673183ba449e9af4011b1eeb456b9.html).

<!-- ======================================================= -->

## Spatial joins {}

Du bist vielleicht vertraut mit *beitreten*von Daten aus einem Datensatz mit einem anderen vertraut. Mehrere Methoden werden im Abschnitt [Daten verknüpfen] Seite dieses Handbuchs beschrieben. Eine räumliche Verknüpfung dient einem ähnlichen Zweck, nutzt aber die räumlichen Beziehungen aus. Anstatt sich auf gemeinsame Werte in den Spalten zu verlassen, um Beobachtungen korrekt abzugleichen, kannst du ihre räumlichen Beziehungen nutzen, z. B. wenn ein Merkmal*innerhalb von* einem anderen liegt, oder *der nächstgelegene Nachbar* zu einem anderen, oder innerhalb einer *Puffer* eines bestimmten Radius von einem anderen, usw.

Die **sf** Paket bietet verschiedene Methoden für räumliche Verknüpfungen. Weitere Informationen über die st\_join-Methode und räumliche Join-Typen findest du in dieser [Referenz](https://r-spatial.github.io/sf/reference/geos_binary_pred.html).

### Punkte im Polygon {.unnumbered}

**Räumliche Zuordnung von Verwaltungseinheiten zu Fällen**

Hier ergibt sich ein interessantes Rätsel: Die Fallliste enthält keine Informationen über die Verwaltungseinheiten der Fälle. Obwohl es ideal ist, solche Informationen während der ersten Datenerhebungsphase zu sammeln, können wir den einzelnen Fällen auch Verwaltungseinheiten auf der Grundlage ihrer räumlichen Beziehungen zuweisen (d. h. ein Punkt schneidet ein Polygon).

Im Folgenden werden wir unsere Fallstandorte (Punkte) mit den ADM3-Grenzen (Polygone) räumlich überschneiden:

1) Beginne mit der Lineliste (Punkte)
2) Räumliche Verknüpfung mit den Grenzen, wobei die Art der Verknüpfung auf "st\_intersects" eingestellt wird
3) Verwende `select()` um nur bestimmte Spalten der neuen Verwaltungsgrenzen zu behalten

```{r, warning=F, message=F}
linelist_adm <- linelist_sf %>%
  
  # join the administrative boundary file to the linelist, based on spatial intersection
  sf::st_join(sle_adm3, join = st_intersects)
```

Alle Spalten von `sle_adms` wurden der Zeilenliste hinzugefügt! Jeder Fall hat jetzt Spalten, in denen die Verwaltungsebene angegeben ist, in die er fällt. In diesem Beispiel wollen wir nur zwei der neuen Spalten beibehalten (Verwaltungsebene 3), also müssen wir `select()` die alten Spaltennamen und nur die beiden zusätzlichen von Interesse:

```{r, warning=F, message=F}
linelist_adm <- linelist_sf %>%
  
  # join the administrative boundary file to the linelist, based on spatial intersection
  sf::st_join(sle_adm3, join = st_intersects) %>% 
  
  # Keep the old column names and two new admin ones of interest
  select(names(linelist_sf), admin3name, admin3pcod)
```

Unten siehst du die ersten zehn Fälle und ihre Zuständigkeiten der Verwaltungsebene 3 (ADM3), die auf der Grundlage der räumlichen Schnittpunkte mit den Polygonformen festgelegt wurden.

```{r, warning=F, message=F}
# Now you will see the ADM3 names attached to each case
linelist_adm %>% select(case_id, admin3name, admin3pcod)
```

Jetzt können wir unsere Fälle nach Verwaltungseinheiten beschreiben - etwas, das wir vor der räumlichen Verknüpfung nicht tun konnten!

```{r, warning=F, message=F}
# Make new dataframe containing counts of cases by administrative unit
case_adm3 <- linelist_adm %>%          # begin with linelist with new admin cols
  as_tibble() %>%                      # convert to tibble for better display
  group_by(admin3pcod, admin3name) %>% # group by admin unit, both by name and pcode 
  summarise(cases = n()) %>%           # summarize and count rows
  arrange(desc(cases))                     # arrange in descending order

case_adm3
```

Wir können auch ein Balkendiagramm der Fallzahlen nach Verwaltungseinheit erstellen.

In diesem Beispiel beginnen wir die `ggplot()` mit dem `linelist_adm` an, damit wir Faktor-Funktionen wie `fct_infreq()`anwenden, die die Balken nach Häufigkeit ordnet (siehe Seite über [Faktoren] für Tipps).

```{r, warning=F, message=F}
ggplot(
    data = linelist_adm,                       # begin with linelist containing admin unit info
    mapping = aes(
      x = fct_rev(fct_infreq(admin3name))))+ # x-axis is admin units, ordered by frequency (reversed)
  geom_bar()+                                # create bars, height is number of rows
  coord_flip()+                              # flip X and Y axes for easier reading of adm units
  theme_classic()+                           # simplify background
  labs(                                      # titles and labels
    x = "Admin level 3",
    y = "Number of cases",
    title = "Number of cases, by adminstative unit",
    caption = "As determined by a spatial join, from 1000 randomly sampled cases from linelist"
  )
```

<!-- ======================================================= -->

### Nächster Nachbar {.unnumbered}

**Suche nach der nächstgelegenen Gesundheitseinrichtung / dem Einzugsgebiet**

Es kann nützlich sein, zu wissen, wo sich die Gesundheitseinrichtungen in Bezug auf die Krankheitsherde befinden.

Wir können die *st\_nearest\_feature* Join-Methode aus der `st_join()` Funktion (**sf** Paket), um die nächstgelegene Gesundheitseinrichtung für einzelne Fälle zu visualisieren.

1) Wir beginnen mit der Shapefile-Lineliste `linelist_sf`
2) Wir verbinden räumlich mit `sle_hf` die Standorte von Gesundheitseinrichtungen und Kliniken (Punkte)

```{r, warning=F, message=F}
# Closest health facility to each case
linelist_sf_hf <- linelist_sf %>%                  # begin with linelist shapefile  
  st_join(sle_hf, join = st_nearest_feature) %>%   # data from nearest clinic joined to case data 
  select(case_id, osm_id, name, amenity) %>%       # keep columns of interest, including id, name, type, and geometry of healthcare facility
  rename("nearest_clinic" = "name")                # re-name for clarity
```

Wir sehen unten (die ersten 50 Zeilen), dass jeder Fall nun Daten über die nächstgelegene Klinik/das nächstgelegene Krankenhaus hat

```{r, message=FALSE, echo=F}
DT::datatable(head(linelist_sf_hf, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Wir können sehen, dass "Den Clinic" die nächstgelegene Gesundheitseinrichtung für etwa 30 % der Fälle ist.

```{r}
# Count cases by health facility
hf_catchment <- linelist_sf_hf %>%   # begin with linelist including nearest clinic data
  as.data.frame() %>%                # convert from shapefile to dataframe
  count(nearest_clinic,              # count rows by "name" (of clinic)
        name = "case_n") %>%         # assign new counts column as "case_n"
  arrange(desc(case_n))              # arrange in descending order

hf_catchment                         # print to console
```

Um die Ergebnisse zu visualisieren, können wir **tmap** - verwenden, diesmal im interaktiven Modus zur leichteren Betrachtung

```{r, warning=F, message=F}
tmap_mode("view")   # set tmap mode to interactive  

# plot the cases and clinic points 
tm_shape(linelist_sf_hf) +            # plot cases
  tm_dots(size=0.08,                  # cases colored by nearest clinic
          col='nearest_clinic') +    
tm_shape(sle_hf) +                    # plot clinic facilities in large black dots
  tm_dots(size=0.3, col='black', alpha = 0.4) +      
  tm_text("name") +                   # overlay with name of facility
tm_view(set.view = c(-13.2284, 8.4699, 13), # adjust zoom (center coords, zoom)
        set.zoom.limits = c(13,14))+
tm_layout(title = "Cases, colored by nearest clinic")
```

### Puffer {.unnumbered}

Wir können auch untersuchen, wie viele Fälle innerhalb von 2,5 km (~30 Minuten) Fußweg von der nächsten Gesundheitseinrichtung entfernt sind.

*Hinweis: Für genauere Entfernungsberechnungen ist es besser, dein sf-Objekt auf das jeweilige lokale Kartenprojektionssystem wie UTM (Erde projiziert auf eine ebene Fläche) zu projizieren. In diesem Beispiel halten wir uns der Einfachheit halber an das geografische Koordinatensystem World Geodetic System (WGS84) (die Erde wird als kugelförmige / runde Fläche dargestellt, daher sind die Einheiten in Dezimalgraden). Wir verwenden eine allgemeine Umrechnung von: 1 Dezimalgrad = ~111km.*

Weitere Informationen über Kartenprojektionen und Koordinatensysteme findest du hier [Esri-Artikel](https://www.esri.com/arcgis-blog/products/arcgis-pro/mapping/gcs_vs_pcs/). Diese [Blog](http://www.geo.hunter.cuny.edu/~jochen/gtech201/lectures/lec6concepts/map%20coordinate%20systems/how%20to%20choose%20a%20projection.htm) spricht über verschiedene Arten von Kartenprojektionen und wie man eine geeignete Projektion je nach Interessengebiet und Kontext deiner Karte/Analyse auswählen kann.

**Erste** erstellst du einen kreisförmigen Puffer mit einem Radius von ~2,5 km um jede Gesundheitseinrichtung. Dies geschieht mit der Funktion `st_buffer()` von **tmap**. Da die Einheit der Karte in Längen- und Breitengraden angegeben ist, wird "0,02" so interpretiert. Wenn dein Kartenkoordinatensystem in Metern angegeben ist, muss die Zahl in Metern angegeben werden.

```{r, warning=F, message=F}
sle_hf_2k <- sle_hf %>%
  st_buffer(dist=0.02)       # decimal degrees translating to approximately 2.5km 
```

Unten stellen wir die Pufferzonen selbst dar, mit dem :

```{r, warning=F, message=F}
tmap_mode("plot")
# Create circular buffers
tm_shape(sle_hf_2k) +
  tm_borders(col = "black", lwd = 2)+
tm_shape(sle_hf) +                    # plot clinic facilities in large red dots
  tm_dots(size=0.3, col='black')      
```

\**Zweite* schneiden wir diese Puffer mit den Fällen (Punkten), indem wir `st_join()` und der Verknüpfungsart von *st\_intersects*. Das heißt, die Daten aus den Puffern werden mit den Punkten verbunden, die sie schneiden.

```{r, warning=F, message=F}
# Intersect the cases with the buffers
linelist_sf_hf_2k <- linelist_sf_hf %>%
  st_join(sle_hf_2k, join = st_intersects, left = TRUE) %>%
  filter(osm_id.x==osm_id.y | is.na(osm_id.y)) %>%
  select(case_id, osm_id.x, nearest_clinic, amenity.x, osm_id.y)
```

Jetzt können wir die Ergebnisse zählen: ` nrow(linelist_sf_hf_2k[is.na(linelist_sf_hf_2k$osm_id.y),])` von 1000 Fällen haben sich mit keinem Puffer gekreuzt (dieser Wert fehlt) und leben somit mehr als 30 Minuten Fußweg von der nächsten Gesundheitseinrichtung entfernt.

```{r}
# Cases which did not get intersected with any of the health facility buffers
linelist_sf_hf_2k %>% 
  filter(is.na(osm_id.y)) %>%
  nrow()
```

Wir können die Ergebnisse so visualisieren, dass die Fälle, die sich mit keinem Puffer überschnitten haben, rot erscheinen.

```{r, out.width="100%", warning=F, message=F}
tmap_mode("view")

# First display the cases in points
tm_shape(linelist_sf_hf) +
  tm_dots(size=0.08, col='nearest_clinic') +

# plot clinic facilities in large black dots
tm_shape(sle_hf) +                    
  tm_dots(size=0.3, col='black')+   

# Then overlay the health facility buffers in polylines
tm_shape(sle_hf_2k) +
  tm_borders(col = "black", lwd = 2) +

# Highlight cases that are not part of any health facility buffers
# in red dots  
tm_shape(linelist_sf_hf_2k %>%  filter(is.na(osm_id.y))) +
  tm_dots(size=0.1, col='red') +
tm_view(set.view = c(-13.2284,8.4699, 13), set.zoom.limits = c(13,14))+

# add title  
tm_layout(title = "Cases by clinic catchment area")

```

### Andere räumliche Verknüpfungen {.unnumbered}

Alternative Werte für das Argument `join` umfassen (aus dem [Dokumentation](https://r-spatial.github.io/sf/reference/st_join.html))

- st\_contains\_properly
- st\_beinhaltet
- st\_abgedeckt\_von
- st\_bedeckt
- st\_Kreuze
- st\_disjoint
- st\_equals\_exact
- st\_equals
- st\_ist\_innerhalb\_der\_Entfernung
- st\_nearest\_feature
- st\_overlaps
- st\_touches
- st\_innerhalb

## Choropleth-Karten {}

Choropleth-Karten können nützlich sein, um deine Daten nach vordefinierten Gebieten zu visualisieren, in der Regel Verwaltungseinheiten oder Gesundheitsgebiete. Bei der Bekämpfung von Krankheitsausbrüchen kann dies z.B. helfen, die Ressourcen gezielt für bestimmte Gebiete mit hohen Erkrankungsraten einzusetzen.

Nachdem wir allen Fällen die Namen der Verwaltungseinheiten zugewiesen haben (siehe Abschnitt über räumliche Verknüpfungen oben), können wir mit der Zuordnung der Fallzahlen zu den einzelnen Gebieten beginnen (Choroplethenkarten).

Da wir auch Bevölkerungsdaten nach ADM3 haben, können wir diese Informationen in die *case\_adm3* Tabelle hinzufügen, die wir zuvor erstellt haben.

Wir beginnen mit dem im vorherigen Schritt erstellten Datenrahmen `case_adm3` erstellt wurde, der eine zusammenfassende Tabelle für jede Verwaltungseinheit und die Anzahl der Fälle enthält.

1) Die Bevölkerungsdaten `sle_adm3_pop` werden mit einer `left_join()` from **dplyr** auf der Grundlage gemeinsamer Werte in allen Spalten `admin3pcod` in der `case_adm3` Datenrahmen, und Spalte `adm_pcode` im `sle_adm3_pop`Datenrahmen. Siehe Seite über [Verbinden von Daten]).
2) `select()` wird auf den neuen Datenrahmen angewendet, um nur die nützlichen Spalten zu behalten - `total` ist die Gesamtbevölkerung
3) Die Fälle pro 10.000 Einwohner werden als neue Spalte mit `mutate()`

```{r}
# Add population data and calculate cases per 10K population
case_adm3 <- case_adm3 %>% 
     left_join(sle_adm3_pop,                             # add columns from pop dataset
               by = c("admin3pcod" = "adm3_pcode")) %>%  # join based on common values across these two columns
     select(names(case_adm3), total) %>%                 # keep only important columns, including total population
     mutate(case_10kpop = round(cases/total * 10000, 3)) # make new column with case rate per 10000, rounded to 3 decimals

case_adm3                                                # print to console for viewing
```

Verbinde diese Tabelle mit dem ADM3-Polygonshapefile für die Kartierung

```{r, warning=F, message=F}
case_adm3_sf <- case_adm3 %>%                 # begin with cases & rate by admin unit
  left_join(sle_adm3, by="admin3pcod") %>%    # join to shapefile data by common column
  select(objectid, admin3pcod,                # keep only certain columns of interest
         admin3name = admin3name.x,           # clean name of one column
         admin2name, admin1name,
         cases, total, case_10kpop,
         geometry) %>%                        # keep geometry so polygons can be plotted
  drop_na(objectid) %>%                       # drop any empty rows
  st_as_sf()                                  # convert to shapefile

```

Kartierung der Ergebnisse

```{r, message=F, warning=F}
# tmap mode
tmap_mode("plot")               # view static map

# plot polygons
tm_shape(case_adm3_sf) + 
        tm_polygons("cases") +  # color by number of cases column
        tm_text("admin3name")   # name display
```

Wir können auch die Inzidenzraten abbilden

```{r, warning=F, message=F}
# Cases per 10K population
tmap_mode("plot")             # static viewing mode

# plot
tm_shape(case_adm3_sf) +                # plot polygons
  tm_polygons("case_10kpop",            # color by column containing case rate
              breaks=c(0, 10, 50, 100), # define break points for colors
              palette = "Purples"       # use a purple color palette
              ) +
  tm_text("admin3name")                 # display text

```

## Kartierung mit ggplot2

Wenn du bereits vertraut bist mit der Verwendung von **ggplot2** kennst, kannst du stattdessen dieses Paket verwenden, um statische Karten deiner Daten zu erstellen. Die `geom_sf()` Funktion zeichnet verschiedene Objekte, je nachdem, welche Merkmale (Punkte, Linien oder Polygone) in deinen Daten enthalten sind. Du kannst zum Beispiel Folgendes verwenden `geom_sf()` in einer `ggplot()` mit `sf` Daten mit Polygongeometrie, um eine Choroplethenkarte zu erstellen.

Um zu veranschaulichen, wie das funktioniert, können wir mit dem ADM3-Polygone-Shapefile beginnen, das wir zuvor verwendet haben. Wir erinnern uns, dass dies die Regionen der Verwaltungsebene 3 in Sierra Leone sind:

```{r}
sle_adm3
```

Wir können die `left_join()` Funktion von **dplyr** um die Daten, die wir dem Shapefile-Objekt zuordnen möchten, hinzuzufügen. In diesem Fall werden wir die Funktion `case_adm3` Datenrahmen verwenden, den wir zuvor erstellt haben, um die Fallzahlen nach Verwaltungsregionen zusammenzufassen; wir können jedoch jeden Datenrahmen auf die gleiche Weise abbilden.

```{r}
sle_adm3_dat <- sle_adm3 %>% 
  inner_join(case_adm3, by = "admin3pcod") # inner join = retain only if in both data objects

select(sle_adm3_dat, admin3name.x, cases) # print selected variables to console
```

Um ein Säulendiagramm der Fallzahlen nach Region zu erstellen, verwende **ggplot2** zu erstellen, könnten wir dann Folgendes aufrufen `geom_col()` wie folgt aufrufen:

```{r, fig.align="center"}
ggplot(data=sle_adm3_dat) +
  geom_col(aes(x=fct_reorder(admin3name.x, cases, .desc=T),   # reorder x axis by descending 'cases'
               y=cases)) +                                  # y axis is number of cases by region
  theme_bw() +
  labs(                                                     # set figure text
    title="Number of cases, by administrative unit",
    x="Admin level 3",
    y="Number of cases"
  ) + 
  guides(x=guide_axis(angle=45))                            # angle x-axis labels 45 degrees to fit better

```

Wenn wir Folgendes verwenden wollen **ggplot2** verwenden, um stattdessen eine Choropleth-Karte der Fallzahlen zu erstellen, können wir eine ähnliche Syntax verwenden, um die `geom_sf()` Funktion:

```{r, fig.align="center"}
ggplot(data=sle_adm3_dat) + 
  geom_sf(aes(fill=cases))    # set fill to vary by case count variable

```

Wir können dann das Aussehen unserer Karte mit einer Grammatik anpassen, die für alle Fälle einheitlich ist. **ggplot2** ist, zum Beispiel:

```{r, fig.align="center"}
ggplot(data=sle_adm3_dat) +                           
  geom_sf(aes(fill=cases)) +						
  scale_fill_continuous(high="#54278f", low="#f2f0f7") +    # change color gradient
  theme_bw() +
  labs(title = "Number of cases, by administrative unit",   # set figure text
       subtitle = "Admin level 3"
  )
```

Für R-Benutzer, die mit der Arbeit mit **ggplot2**, `geom_sf()` bietet eine einfache und direkte Implementierung, die für einfache Kartenvisualisierungen geeignet ist. Um mehr zu erfahren, lies die [geom\_sf() Vignette](https://ggplot2.tidyverse.org/reference/ggsf.html) oder die [ggplot2-Buch](https://ggplot2-book.org/maps.html).

<!-- ======================================================= -->

## Basiskarten { }

### OpenStreetMap {.unnumbered}

Im Folgenden beschreiben wir, wie man eine Basiskarte für eine **ggplot2** Karte mit OpenStreetMap-Features erstellt. Alternative Methoden sind die Verwendung von **ggmap** das eine kostenlose Registrierung bei Google erfordert ([Details](https://www.earthdatascience.org/courses/earth-analytics/lidar-raster-data-r/ggmap-basemap/)).

[**OpenStreetMap**](https://en.wikipedia.org/wiki/OpenStreetMap) ist ein gemeinschaftliches Projekt zur Erstellung einer frei bearbeitbaren Karte der Welt. Die zugrundeliegenden Geodaten (z. B. die Standorte von Städten, Straßen, Naturmerkmalen, Flughäfen, Schulen, Krankenhäusern, Straßen usw.) werden als das wichtigste Ergebnis des Projekts angesehen.

Zuerst laden wir die **OpenStreetMap** Paket, aus dem wir unsere Basiskarte beziehen.

Dann erstellen wir das Objekt `map` an, das wir mit der Funktion `openmap()` von **OpenStreetMap** Paket ([Dokumentation](https://www.rdocumentation.org/packages/OpenStreetMap/versions/0.3.4/topics/openmap)). Wir bieten das Folgende:

- `upperLeft` und `lowerRight` Zwei Koordinatenpaare, die die Grenzen der Basiskachel angeben
  - In diesem Fall haben wir die Maximal- und Minimalwerte aus den Zeilen der Linienliste eingegeben, damit die Karte dynamisch auf die Daten reagieren kann
- `zoom = ` (bei Null wird sie automatisch ermittelt)
- `type =` welche Art von Basiskarte - wir haben hier mehrere Möglichkeiten aufgelistet und der Code verwendet derzeit die erste (`[1]`) "osm"
- `mergeTiles = ` Wir haben TRUE gewählt, damit die Basisdateien alle zu einer einzigen zusammengeführt werden

```{r, message=FALSE, warning=FALSE}
# load package
pacman::p_load(OpenStreetMap)

# Fit basemap by range of lat/long coordinates. Choose tile type
map <- OpenStreetMap::openmap(
  upperLeft = c(max(linelist$lat, na.rm=T), max(linelist$lon, na.rm=T)),   # limits of basemap tile
  lowerRight = c(min(linelist$lat, na.rm=T), min(linelist$lon, na.rm=T)),
  zoom = NULL,
  type = c("osm", "stamen-toner", "stamen-terrain", "stamen-watercolor", "esri","esri-topo")[1])
```

Wenn wir diese Basiskarte jetzt plotten, indem wir `autoplot.OpenStreetMap()` von **OpenStreetMap** Paket, siehst du, dass die Einheiten auf den Achsen nicht die Koordinaten für Breiten- und Längengrade sind. Es wird ein anderes Koordinatensystem verwendet. Um die Fallwohnungen (die in Lat/Long gespeichert sind) korrekt anzuzeigen, muss dies geändert werden.

```{r, warning=F, message=F}
autoplot.OpenStreetMap(map)
```

Deshalb wollen wir die Karte mit dem Befehl "Latitude/Longitude" in Latitude/Longitude umwandeln. `openproj()` Funktion von **OpenStreetMap** Paket. Wir liefern die Basiskarte `map` und geben auch das gewünschte Koordinatenreferenzsystem (CRS) an. Wir tun dies, indem wir die Zeichenkette "proj.4" für die WGS 1984-Projektion angeben, aber du kannst das CRS auch auf andere Weise angeben. (siehe [diese Seite](https://www.earthdatascience.org/courses/earth-analytics/spatial-data-r/understand-epsg-wkt-and-other-crs-definition-file-types/) um besser zu verstehen, was eine proj.4-Zeichenkette ist)

```{r, warning=F, message=F}
# Projection WGS84
map_latlon <- openproj(map, projection = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
```

Wenn wir nun die Grafik erstellen, sehen wir, dass die Achsen Breiten- und Längengradkoordinaten enthalten. Das Koordinatensystem wurde umgewandelt. Jetzt werden unsere Fälle korrekt dargestellt, wenn sie überlagert werden!

```{r, warning=F, message=F}
# Plot map. Must use "autoplot" in order to work with ggplot
autoplot.OpenStreetMap(map_latlon)
```

Siehe die Tutorials [hier](http://data-analytics.net/cep/Schedule_files/geospatial.html) und [hier](https://www.rdocumentation.org/packages/OpenStreetMap/versions/0.3.4/topics/autoplot.OpenStreetMap) für weitere Informationen.

## Konturierte Dichte Heatmaps {}

Im Folgenden wird beschrieben, wie du eine konturierte Dichte-Heatmap von Fällen über einer Basiskarte erstellst, beginnend mit einer Linienliste (eine Zeile pro Fall).

1) Erstelle eine Basiskarte aus OpenStreetMap, wie oben beschrieben
2) Plotten der Fälle aus `linelist` unter Verwendung der Spalten für Längen- und Breitengrad
3) Konvertiere die Punkte in eine Dichte-Heatmap mit `stat_density_2d()` von **ggplot2**,

Wenn wir eine Basiskarte mit Längen- und Breitenkoordinaten haben, können wir unsere Fälle anhand der Längen- und Breitenkoordinaten ihres Wohnorts aufzeichnen.

Aufbauend auf der Funktion `autoplot.OpenStreetMap()` um die Basiskarte zu erstellen, **ggplot2** Funktionen einfach hinzufügen, wie zum Beispiel mit `geom_point()` unten gezeigt:

```{r, warning=F, message=F}
# Plot map. Must be autoplotted to work with ggplot
autoplot.OpenStreetMap(map_latlon)+                 # begin with the basemap
  geom_point(                                       # add xy points from linelist lon and lat columns 
    data = linelist,                                
    aes(x = lon, y = lat),
    size = 1, 
    alpha = 0.5,
    show.legend = FALSE) +                          # drop legend entirely
  labs(x = "Longitude",                             # titles & labels
       y = "Latitude",
       title = "Cumulative cases")

```

Die obige Karte könnte schwierig zu interpretieren sein, vor allem wenn sich die Punkte überschneiden. Deshalb kannst du stattdessen eine 2D-Dichtekarte erstellen, indem du die **ggplot2** Funktion `stat_density_2d()`. Du verwendest immer noch die Breiten- und Längenkoordinaten der Lineliste, aber es wird eine 2D-Kernel-Dichte-Schätzung durchgeführt und die Ergebnisse werden mit Höhenlinien dargestellt - wie eine topografische Karte. Lies die vollständige [Dokumentation hier](https://ggplot2.tidyverse.org/reference/geom_density_2d.html).

```{r, warning=F, message=F}
# begin with the basemap
autoplot.OpenStreetMap(map_latlon)+
  
  # add the density plot
  ggplot2::stat_density_2d(
        data = linelist,
        aes(
          x = lon,
          y = lat,
          fill = ..level..,
          alpha = ..level..),
        bins = 10,
        geom = "polygon",
        contour_var = "count",
        show.legend = F) +                          
  
  # specify color scale
  scale_fill_gradient(low = "black", high = "red")+
  
  # labels 
  labs(x = "Longitude",
       y = "Latitude",
       title = "Distribution of cumulative cases")

```

<!-- ======================================================= -->

### Zeitreihen-Heatmap {.unnumbered}

Die obige Dichte-Heatmap zeigt *kumulierte Fälle*. Wir können den Ausbruch über Zeit und Raum hinweg untersuchen, indem wir die Heatmap anhand der *Monat des Symptomausbruchs* die aus der Linienliste abgeleitet wurde.

Wir beginnen im `linelist` und erstellen eine neue Spalte mit dem Jahr und dem Monat des Beginns. Die `format()` Funktion von **Basis** R ändert, wie ein Datum angezeigt wird. In diesem Fall wollen wir "JJJJ-MM".

```{r, warning=F, message=F}
# Extract month of onset
linelist <- linelist %>% 
  mutate(date_onset_ym = format(date_onset, "%Y-%m"))

# Examine the values 
table(linelist$date_onset_ym, useNA = "always")
```

Jetzt führen wir die Facettierung einfach über **ggplot2** auf die Dichte-Heatmap anwenden. `facet_wrap()` wird angewendet, wobei die neue Spalte als Zeile verwendet wird. Der Übersichtlichkeit halber setzen wir die Anzahl der Facettenspalten auf 3.

```{r, warning=F, message=F}
# packages
pacman::p_load(OpenStreetMap, tidyverse)

# begin with the basemap
autoplot.OpenStreetMap(map_latlon)+
  
  # add the density plot
  ggplot2::stat_density_2d(
        data = linelist,
        aes(
          x = lon,
          y = lat,
          fill = ..level..,
          alpha = ..level..),
        bins = 10,
        geom = "polygon",
        contour_var = "count",
        show.legend = F) +                          
  
  # specify color scale
  scale_fill_gradient(low = "black", high = "red")+
  
  # labels 
  labs(x = "Longitude",
       y = "Latitude",
       title = "Distribution of cumulative cases over time")+
  
  # facet the plot by month-year of onset
  facet_wrap(~ date_onset_ym, ncol = 4)               

```

<!-- DER ABSCHNITT ZUR RÄUMLICHEN STATISTIK IST IN ENTWICKLUNG --> 

## Räumliche Statistik

Bisher haben wir uns vor allem mit der Visualisierung von räumlichen Daten beschäftigt. In einigen Fällen bist du vielleicht auch an der Verwendung von *räumlichen Statistiken* um die räumlichen Beziehungen der Attribute in deinen Daten zu quantifizieren. Dieser Abschnitt gibt dir einen kurzen Überblick über die wichtigsten Konzepte der räumlichen Statistik und schlägt dir einige Ressourcen vor, die du nutzen kannst, wenn du umfassendere räumliche Analysen durchführen möchtest.

### Räumliche Beziehungen {.unnumbered}

Bevor wir eine räumliche Statistik berechnen können, müssen wir die Beziehungen zwischen den Merkmalen in unseren Daten beschreiben. Es gibt viele Möglichkeiten, räumliche Beziehungen zu konzeptualisieren, aber ein einfaches und allgemein anwendbares Modell ist das der *Adjazenz* - Das heißt, dass wir eine geografische Beziehung zwischen Gebieten erwarten, die eine gemeinsame Grenze haben oder "benachbart" sind.

Wir können die Adjazenzbeziehungen zwischen den Polygonen der Verwaltungsregionen in der `sle_adm3` Daten, die wir verwenden, mit dem **spdep** Paket verwendet haben. Wir werden angeben *Königin* contiguity, was bedeutet, dass Regionen Nachbarn sind, wenn sie mindestens einen Punkt entlang ihrer Grenzen teilen. Die Alternative wäre *Turm* In unserem Fall, mit unregelmäßigen Polygonen, ist die Unterscheidung trivial, aber in manchen Fällen kann die Wahl zwischen Dame und Turm einflussreich sein.

```{r}
sle_nb <- spdep::poly2nb(sle_adm3_dat, queen=T) # create neighbors 
sle_adjmat <- spdep::nb2mat(sle_nb)    # create matrix summarizing neighbor relationships
sle_listw <- spdep::nb2listw(sle_nb)   # create listw (list of weights) object -- we will need this later

sle_nb
round(sle_adjmat, digits = 2)
```

Die oben abgebildete Matrix zeigt die Beziehungen zwischen den 9 Regionen in unserem `sle_adm3` Daten. Ein Wert von 0 bedeutet, dass zwei Regionen nicht benachbart sind, während jeder Wert ungleich 0 auf eine Nachbarschaftsbeziehung hinweist. Die Werte in der Matrix sind so skaliert, dass jede Region eine Gesamtzeilengewichtung von 1 hat.

Ein besserer Weg, diese Nachbarschaftsbeziehungen zu visualisieren, ist, sie grafisch darzustellen:

```{r, fig.align="center", results="hide"}
plot(sle_adm3_dat$geometry) +                                           # plot region boundaries
  spdep::plot.nb(sle_nb,as(sle_adm3_dat, 'Spatial'), col='grey', add=T) # add neighbor relationships
```

Wir haben einen Adjazenzansatz verwendet, um benachbarte Polygone zu identifizieren; die von uns identifizierten Nachbarn werden manchmal auch als **kontiguitätsbasierte Nachbarn**. Dies ist jedoch nur eine Möglichkeit, um die Regionen auszuwählen, von denen erwartet wird, dass sie in einer geografischen Beziehung stehen. Die gebräuchlichsten alternativen Ansätze zur Identifizierung geografischer Beziehungen erzeugen **entfernungsbasierte Nachbarn**; kurz gesagt, sind dies:

- **K-Nächste Nachbarn** - Basierend auf dem Abstand zwischen den Zentren (dem geografisch gewichteten Mittelpunkt jeder Polygonregion) wählst du die *n* nächstgelegenen Regionen als Nachbarn aus. Es kann auch ein Schwellenwert für die maximale Entfernung festgelegt werden. In **spdep** kannst du verwenden `knearneigh()` (siehe [Dokumentation](https://r-spatial.github.io/spdep/reference/knearneigh.html)).

- **Abstand Schwelle Nachbarn** - Wähle alle Nachbarn innerhalb eines Entfernungsschwellenwerts aus. In **spdep** können diese Nachbarschaftsbeziehungen identifiziert werden mit `dnearneigh()` (siehe [Dokumentation](https://www.rdocumentation.org/packages/spdep/versions/1.1-7/topics/dnearneigh)).

### Räumliche Autokorrelation {.unnumbered}

Das oft zitierte erste Gesetz der Geografie von Tobler besagt, dass "alles mit allem zusammenhängt, aber nahe Dinge mehr als entfernte Dinge". In der Epidemiologie bedeutet das oft, dass das Risiko für eine bestimmte gesundheitliche Auswirkung in einer bestimmten Region den benachbarten Regionen ähnlicher ist als den weit entfernten. Dieses Konzept ist formalisiert worden als **räumliche Autokorrelation** - die statistische Eigenschaft, dass sich geografische Merkmale mit ähnlichen Werten im Raum anhäufen. Statistische Maße der räumlichen Autokorrelation können verwendet werden, um *das Ausmaß der räumlichen Anhäufung zu quantifizieren* in deinen Daten zu quantifizieren, *zu lokalisieren, wo die Clusterbildung auftritt* und *gemeinsame Muster der räumlichen Autokorrelation zu identifizieren* zwischen verschiedenen Variablen in deinen Daten. Dieser Abschnitt gibt einen Überblick über einige gängige Maße der räumlichen Autokorrelation und wie man sie in R berechnet.

**Moran's I** - Dies ist eine globale zusammenfassende Statistik der Korrelation zwischen dem Wert einer Variablen in einer Region und den Werten derselben Variablen in den benachbarten Regionen. Die Moran's I-Statistik reicht in der Regel von -1 bis 1. Ein Wert von 0 bedeutet, dass es keine räumliche Korrelation gibt, während Werte, die näher bei 1 oder -1 liegen, auf eine stärkere räumliche Autokorrelation (ähnliche Werte liegen nahe beieinander) bzw. räumliche Streuung (unähnliche Werte liegen nahe beieinander) hinweisen.

Als Beispiel berechnen wir eine Moran's I-Statistik, um die räumliche Autokorrelation in den Ebola-Fällen zu quantifizieren, die wir zuvor kartiert haben (zur Erinnerung: Es handelt sich um eine Teilmenge der Fälle der simulierten Epidemie `linelist` Datenrahmen). Die **spdep** Paket hat eine Funktion, `moran.test`, die diese Berechnung für uns durchführen kann:

```{r}
moran_i <-spdep::moran.test(sle_adm3_dat$cases,    # numeric vector with variable of interest
                            listw=sle_listw)       # listw object summarizing neighbor relationships

moran_i                                            # print results of Moran's I test
```

Die Ausgabe der Funktion `moran.test()` Funktion zeigt uns eine Moran-I-Statistik von ` round(moran_i$estimate[1],2)`. Dies deutet auf das Vorhandensein einer räumlichen Autokorrelation in unseren Daten hin - insbesondere darauf, dass Regionen mit einer ähnlichen Anzahl von Ebola-Fällen wahrscheinlich nahe beieinander liegen. Der p-Wert, den die `moran.test()` wird durch den Vergleich mit dem Erwartungswert bei der Nullhypothese, dass keine räumliche Autokorrelation vorliegt, ermittelt und kann verwendet werden, wenn du die Ergebnisse eines formalen Hypothesentests angeben musst.

**Lokaler Moran's I** - Wir können die oben berechnete (globale) Moran's I-Statistik zerlegen, um zu ermitteln *lokalisierte* räumliche Autokorrelation zu identifizieren, d.h. um bestimmte Cluster in unseren Daten zu erkennen. Diese Statistik, die manchmal auch als **Lokaler Indikator der räumlichen Assoziation (LISA)** Statistik genannt wird, fasst das Ausmaß der räumlichen Autokorrelation um jede einzelne Region herum zusammen. Sie kann nützlich sein, um "heiße" und "kalte" Punkte auf der Karte zu finden.

Um ein Beispiel zu zeigen, können wir die lokale Moran's I für die oben verwendeten Ebola-Fallzahlen berechnen und kartieren. `local_moran()` Funktion von **spdep**:

```{r, fig.align="center"}
# calculate local Moran's I
local_moran <- spdep::localmoran(                  
  sle_adm3_dat$cases,                              # variable of interest
  listw=sle_listw                                  # listw object with neighbor weights
)

# join results to sf data
sle_adm3_dat<- cbind(sle_adm3_dat, local_moran)    

# plot map
ggplot(data=sle_adm3_dat) +
  geom_sf(aes(fill=Ii)) +
  theme_bw() +
  scale_fill_gradient2(low="#2c7bb6", mid="#ffffbf", high="#d7191c",
                       name="Local Moran's I") +
  labs(title="Local Moran's I statistic for Ebola cases",
       subtitle="Admin level 3 regions, Sierra Leone")

```

**Getis-Ord Gi\*** - Dies ist eine weitere Statistik, die häufig für die Hotspot-Analyse verwendet wird. Die Beliebtheit dieser Statistik ist zum großen Teil auf ihre Verwendung im Hotspot-Analyse-Tool in ArcGIS zurückzuführen. Sie basiert auf der Annahme, dass der Unterschied im Wert einer Variable zwischen benachbarten Regionen in der Regel einer Normalverteilung folgt. Sie verwendet einen z-Score-Ansatz, um Regionen zu identifizieren, die im Vergleich zu ihren Nachbarn signifikant höhere (Hot Spot) oder niedrigere (Cold Spot) Werte für eine bestimmte Variable aufweisen.

Wir können die Gi\*-Statistik berechnen und abbilden, indem wir die `localG()` Funktion von **spdep**:

```{r}
# Perform local G analysis
getis_ord <- spdep::localG(
  sle_adm3_dat$cases,
  sle_listw
)

# join results to sf data
sle_adm3_dat$getis_ord <- as.numeric(getis_ord)

# plot map
ggplot(data=sle_adm3_dat) +
  geom_sf(aes(fill=getis_ord)) +
  theme_bw() +
  scale_fill_gradient2(low="#2c7bb6", mid="#ffffbf", high="#d7191c",
                       name="Gi*") +
  labs(title="Getis-Ord Gi* statistic for Ebola cases",
       subtitle="Admin level 3 regions, Sierra Leone")

```

Wie du sehen kannst, sieht die Karte von Getis-Ord Gi\* etwas anders aus als die Karte von Local Moran's, die ich zuvor erstellt habe. Das liegt daran, dass die Methoden zur Berechnung dieser beiden Statistiken leicht unterschiedlich sind. Welche du verwenden solltest, hängt von deinem speziellen Anwendungsfall und der Forschungsfrage ab.

**Lee's L-Test** - Dies ist ein statistischer Test für bivariate räumliche Korrelationen. Er ermöglicht es dir zu prüfen, ob das räumliche Muster für eine bestimmte Variable *x* mit dem räumlichen Muster einer anderen Variable übereinstimmt, *y* von der angenommen wird, dass sie in einem räumlichen Zusammenhang steht mit *x*.

Als Beispiel wollen wir prüfen, ob das räumliche Muster der Ebola-Fälle aus der simulierten Epidemie mit dem räumlichen Muster der Bevölkerung korreliert ist. Zu Beginn brauchen wir eine `population` Variable in unserer `sle_adm3` Daten. Wir können die `total` Variable aus dem `sle_adm3_pop` Datenrahmen verwenden, den wir zuvor geladen haben.

```{r}
sle_adm3_dat <- sle_adm3_dat %>% 
  rename(population = total)                          # rename 'total' to 'population'
```

Wir können die räumlichen Muster der beiden Variablen schnell nebeneinander visualisieren, um zu sehen, ob sie ähnlich aussehen:

```{r, fig.align="center", warning=F, message=F}
tmap_mode("plot")

cases_map <- tm_shape(sle_adm3_dat) + tm_polygons("cases") + tm_layout(main.title="Cases")
pop_map <- tm_shape(sle_adm3_dat) + tm_polygons("population") + tm_layout(main.title="Population")

tmap_arrange(cases_map, pop_map, ncol=2)   # arrange into 2x1 facets
```

Optisch scheinen die Muster unähnlich zu sein. Wir können die `lee.test()` Funktion in **spdep** um statistisch zu prüfen, ob das Muster der räumlichen Autokorrelation in den beiden Variablen zusammenhängt. Die L-Statistik liegt nahe bei 0, wenn keine Korrelation zwischen den Mustern besteht, nahe bei 1, wenn eine starke positive Korrelation besteht (d. h. die Muster sind ähnlich), und nahe bei -1, wenn eine starke negative Korrelation besteht (d. h. die Muster sind invers).

```{r, warning=F, message=F}
lee_test <- spdep::lee.test(
  x=sle_adm3_dat$cases,          # variable 1 to compare
  y=sle_adm3_dat$population,     # variable 2 to compare
  listw=sle_listw                # listw object with neighbor weights
)

lee_test
```

Die obige Ausgabe zeigt, dass die Lee's L-Statistik für unsere beiden Variablen wie folgt lautet ` round(lee_test$estimate[1],2)` ist, was auf eine schwache negative Korrelation hinweist. Dies bestätigt unsere visuelle Einschätzung, dass das Muster der Fälle und die Bevölkerung nicht miteinander zusammenhängen, und liefert den Beweis dafür, dass das räumliche Muster der Fälle nicht ausschließlich auf die Bevölkerungsdichte in Hochrisikogebieten zurückzuführen ist.

Die Lee-L-Statistik kann nützlich sein, um diese Art von Rückschlüssen auf die Beziehung zwischen räumlich verteilten Variablen zu ziehen, aber auch, um die Art der Beziehung zwischen zwei Variablen genauer zu beschreiben oder um Störfaktoren auszugleichen, *räumliche Regression* Techniken benötigt. Diese werden im folgenden Abschnitt kurz beschrieben.

### Räumliche Regression {.unnumbered}

Vielleicht möchtest du statistische Rückschlüsse auf die Beziehungen zwischen den Variablen in deinen räumlichen Daten ziehen. In diesen Fällen ist es sinnvoll, Folgendes zu berücksichtigen *räumliche Regression* zu berücksichtigen, d. h. Regressionsansätze, die die räumliche Organisation der Einheiten in deinen Daten explizit berücksichtigen. Einige Gründe, warum du räumliche Regressionsmodelle anstelle von Standardregressionsmodellen wie GLMs in Betracht ziehen solltest, sind:

- Standardregressionsmodelle gehen davon aus, dass die Residuen unabhängig voneinander sind. Beim Vorhandensein von starken *räumlicher Autokorrelation* sind die Residuen eines Standardregressionsmodells wahrscheinlich auch räumlich autokorreliert und verstoßen somit gegen diese Annahme. Dies kann zu Problemen bei der Interpretation der Modellergebnisse führen, so dass ein räumliches Modell vorzuziehen ist.

- Regressionsmodelle gehen in der Regel auch davon aus, dass der Effekt einer Variable *x* über alle Beobachtungen hinweg konstant ist. Im Fall von *räumlicher Heterogenität* können die Effekte, die wir schätzen wollen, räumlich variieren, und wir sind daran interessiert, diese Unterschiede zu quantifizieren. In diesem Fall bieten räumliche Regressionsmodelle mehr Flexibilität bei der Schätzung und Interpretation von Effekten.

Die Einzelheiten der räumlichen Regressionsansätze würden den Rahmen dieses Handbuchs sprengen. Dieser Abschnitt gibt stattdessen einen Überblick über die gebräuchlichsten räumlichen Regressionsmodelle und ihre Anwendungen und verweist auf weiterführende Literatur, wenn du dich mit diesem Thema näher befassen möchtest.

**Räumliche Fehlermodelle** - Diese Modelle gehen davon aus, dass die Fehlerterme zwischen den räumlichen Einheiten korreliert sind. In diesem Fall würden die Daten die Annahmen eines Standard-OLS-Modells verletzen. Räumliche Fehlermodelle werden manchmal auch bezeichnet als **simultane autoregressive (SAR) Modelle**. Sie können mit Hilfe der folgenden Methode angepasst werden `errorsarlm()` Funktion in der **spatialreg** Paket (räumliche Regressionsfunktionen, die früher ein Teil von **spdep**).

**Spatial Lag Modelle** - Diese Modelle gehen davon aus, dass die abhängige Variable für eine Region *i* nicht nur von den Werten der unabhängigen Variablen in *i* beeinflusst, sondern auch von den Werten dieser Variablen in den benachbarten Regionen *i*. Wie räumliche Fehlermodelle werden auch räumliche Lag-Modelle manchmal beschrieben als **simultane autoregressive (SAR) Modelle**.  Sie können mit Hilfe der folgenden Methode angepasst werden `lagsarlm()` Funktion in der **spatialreg** Paket.

Das **spdep** Paket enthält mehrere nützliche Diagnosetests, um zwischen Standard-OLS-, Spatial Lag- und Spatial Error-Modellen zu entscheiden. Diese Tests, genannt *Lagrange-Multiplikator-Diagnosen* genannt, können verwendet werden, um die Art der räumlichen Abhängigkeit in deinen Daten zu ermitteln und das am besten geeignete Modell zu wählen. Die Funktion `lm.LMtests()` kann verwendet werden, um alle Lagrange-Multiplikator-Tests zu berechnen. Anselin (1988) stellt außerdem ein nützliches Flussdiagramm zur Verfügung, mit dem du anhand der Ergebnisse der Lagrange-Multiplikator-Tests entscheiden kannst, welches räumliche Regressionsmodell du verwenden möchtest:

```{r, fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "gis_lmflowchart.jpg"))
```

**Bayessche hierarchische Modelle** - Bayes'sche Ansätze werden häufig für einige Anwendungen in der räumlichen Analyse verwendet, am häufigsten für [Kartierung von Krankheiten](https://pubmed.ncbi.nlm.nih.gov/15690999/). Sie werden bevorzugt, wenn die Falldaten spärlich verteilt sind (z. B. bei einem seltenen Ergebnis) oder statistisch "verrauscht" sind, da sie dazu verwendet werden können, "geglättete" Schätzungen des Krankheitsrisikos zu erstellen, indem sie den zugrunde liegenden latenten räumlichen Prozess berücksichtigen. Dies kann die Qualität der Schätzungen verbessern. Sie ermöglichen es außerdem, komplexe räumliche Korrelationsmuster, die in den Daten vorhanden sein können, im Voraus zu spezifizieren (durch die Wahl des Priors), wodurch räumlich abhängige und nicht abhängige Variationen sowohl in den unabhängigen als auch in den abhängigen Variablen berücksichtigt werden können. In R können Bayes'sche hierarchische Modelle mit der Funktion **CARbayes** Paket angepasst werden (siehe [Vignette](https://cran.r-project.org/web/packages/CARBayes/vignettes/CARBayes.pdf)) oder R-INLA (siehe [Website](https://www.r-inla.org/home) und [Lehrbuch](https://becarioprecario.bitbucket.io/inla-gitbook/)). R kann auch verwendet werden, um externe Software aufzurufen, die Bayes'sche Schätzungen vornimmt, z. B. JAGS oder WinBUGS.

<!-- ======================================================= -->

## Ressourcen {  }

- R Simple Features und sf-Paket [Vignette](https://cran.r-project.org/web/packages/sf/vignettes/sf1.html)

- R tmap Paket [Vignette](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html)

- ggmap: [Räumliche Visualisierung mit ggplot2](https://journal.r-project.org/archive/2013-1/kahle-wickham.pdf)

- [Einführung in die Erstellung von Karten mit R, Überblick über verschiedene Pakete](https://bookdown.org/nicohahn/making_maps_with_r5/docs/introduction.html)

- Räumliche Daten in R [(EarthLab-Kurs)](https://www.earthdatascience.org/courses/earth-analytics/spatial-data-r/)

- Angewandte raumbezogene Datenanalyse in R [Lehrbuch](https://link.springer.com/book/10.1007/978-1-4614-7618-4)

- **SpatialEpiApp** - a [Shiny-App, die als R-Paket heruntergeladen werden kann](https://github.com/Paula-Moraga/SpatialEpiApp) heruntergeladen werden kann. Damit kannst du deine eigenen Daten bereitstellen und Kartierungen, Clusteranalysen und räumliche Statistiken durchführen.

- Eine Einführung in die räumliche Ökonometrie in R [Workshop](http://www.econ.uiuc.edu/~lab/workshop/Spatial_in_R.html)


