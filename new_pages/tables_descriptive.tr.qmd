# Tanımlayıcı tablolar  { }

```{r out.width = c('75%'), fig.align='center', fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "descriptive_tables.png"))
```

Bu sayfa, verileri özetlemek ve tanımlayıcı istatistiklerle tablolar oluşturmak için **janitor, dplyr, gtsummary, rstatix ve temel R'ın** kullanımını göstermektedir. 

Bu sayfa, temel tabloların nasıl oluşturulacağını, sunum için tablolar sayfası ise tabloların nasıl güzel bir şekilde biçimlendirileceğini ve yazdırılacağını kapsar.

Bu paketlerin her birinin kod dilinin basitliği, çıktıların erişilebilirliği, basılı çıktıların kalitesi alanlarında avantajları ve dezavantajları vardır. Senaryonuz için hangi yaklaşımın işe yaradığına karar vermek için bu sayfayı kullanın.

Tablolama ve çapraz tablo özet tabloları için  birkaç seçeneğiniz vardır. Göz önünde bulundurulması gereken faktörlerden bazıları, kod basitliği, özelleştirilebilirlik, istenen çıktı (veri çerçevesi olarak veya "güzel" yani .png/.jpeg/.html görüntüsü olarak R konsoluna yazdırılabilir) ve çıktı sonrası işleme kolaylığıdır. Durumunuz için aracı seçerken aşağıdaki noktaları göz önünde bulundurun.

• Tabloları ve çapraz tabloları oluşturmak ve “süslemek” için janitor’dan **tabyl()** kullanın

• Birden çok sütun ve/veya grup için sayısal özet istatistiklerin veri çerçevelerini kolayca oluşturmak için rstatix'ten **get_summary_stats()** kullanın

• Daha karmaşık istatistikler, düzenli veri çerçevesi çıktıları veya ggplot() için veri hazırlamak için dplyr'den **summarise()** ve **count()** kullanın

• Ayrıntılı ve yayına hazır tablolar oluşturmak için gtsummary'den tbl_summary() kullanın
• Yukarıdaki paketlere erişiminiz yoksa, temel R'dan table() kullanın 



<!-- ======================================================= -->
## Hazırlık {  }


### Paketleri yükleme {.unnumbered}

Bu kod bloğu, analizler için gerekli olan paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran ve kullanım için yükleyen pacman'ın p_load() fonksiyonu vurgulanmaktadır. Ayrıca, temel R'dan library() ile kurulu paketleri yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için R’ın temelleri sayfasına bakabilirsiniz.


```{r, warning=F, message=F}
pacman::p_load(
  rio,          # Dosya içeri aktarımı
  here,         # Dosyaların tespit edilmesi 
  skimr,        # Verinin gözden geçirilmesi 
  tidyverse,    # Veri yönetimi + ggplot2 grafikleri  
  gtsummary,    # Özet istatistikler ve testler
  rstatix,      # Özet istatistikler ve istatistik testler
  janitor,      # Toplamların ve yüzdelerin eklenmesi 
  scales,       # Yüzdelerin oranlara kolayca çevrilmesi 
  flextable     # Tabloların “güzel” resimlere dönüştürülmesi 
  )

```

### Verinin içeri aktarımı  {.unnumbered}

Simüle edilmiş bir Ebola salgını veri setini içe aktarıyoruz. Devam etmek istiyorsanız, “temiz” satır listesini (.rds dosyası olarak) indirmek için tıklayın <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>click to download the "clean" linelist</a> . Verilerinizi rio paketinden import() fonksiyonuyla içe aktarın (.xlsx, .rds, .csv gibi birçok dosya türünü kabul eder - ayrıntılar için İçe Aktarma ve Dışa Aktarma sayfasına bakın).

```{r, echo=F}
# satır listesini içe aktar
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# satır listesini içe aktar
linelist <- import("linelist_cleaned.rds")
```

The first 50 rows of the linelist are displayed below.

```{r, message=FALSE, echo=F}
# satır listesini tablo olarak göster
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```





<!-- ======================================================= -->
## Verileri gözden geçirme {  }

### **skimr** paketi {.unnumbered}

skimr paketini kullanarak, veri tabaınızdaki değişkenlerin her biri için ayrıntılı ve estetik bir genel bakış elde edebilirsiniz. github sayfasında [github](https://github.com/ropensci/skimr). **skimr** hakkında daha fazla bilgi edinin.

Aşağıda, 'skim()'fonksiyonu tüm satır listesi veri çerçevesine uygulanır. Veri çerçevesine genel bir bakış ve her sütunun (sınıfa göre) bir özeti çıkarılır.


```{r eval=F}
## veritabanındaki her değişken için bilgiyi edin 
skim(linelist)
```

```{r  echo=F}
# sparkline (mini grafik) histogramları doğru gösterilmiyor, bu yüzden onlardan kaçının.
skim_without_charts(linelist)
```


Tüm bir veri tabanı hakkında bilgi almak için temel R'dan summary() fonksiyonunu da kullanabilirsiniz, ancak bu çıktıyı okumak skimr çıktısından daha zor olabilir. Bu nedenle, sayfa sayısından tasarruf etmek için çıktı aşağıda gösterilmemiştir.

```{r, eval=F}
## veritabanındaki her sütun için bilgiyi edin  
summary(linelist)
```


### Özet İstatistikleri {.unnumbered} 

Sayısal bir sütunda özet istatistikleri göstermek için temel R işlevlerini kullanabilirsiniz. Bir sayısal sütun için yararlı özet istatistiklerin çoğunu aşağıdaki gibi summary() kullanarak elde edebilirsiniz. Veri çerçevesi adının da aşağıda gösterildiği gibi belirtilmesi gerektiğini unutmayın.  

```{r}
summary(linelist$age_years)
```

Dizin parantezleri [ ] ile veri çerçevesinin belirli bir bölümüne erişebilir ve kaydedebilirsiniz: 

```{r}
summary(linelist$age_years)[[2]]            # yalnızca ikinci ögeyi göster
# eşdeğeri, eleman adı için yukarıdakine alternatif olarak 
# summary(linelist$age_years)[["1st Qu."]]  
```

max(), min(), median(), ortalama(), quantile(), sd() ve range() gibi temel R işlevleriyle istatistikleri tek tek elde edebilirsiniz. Tam bir liste için R’ın temelleri sayfasına bakabilirsiniz.

<span style="color: orange;">**_UYARI:_** Verileriniz eksik değerler içeriyorsa, R bunu belirtmenizi ister. Bu nedenle, na.rm = TRUE argümanı aracılığıyla R'nin eksik değerleri yok saymasını belirtmediğiniz sürece komut NA değerini verir.`na.rm = TRUE`.</span>


Özet istatistikleri bir veri çerçevesi biçiminde döndürmek için rstatix'teki get_summary_stats() fonkisyonunu kullanabilirsiniz. Bu fonksiyon, sonraki işlemleri gerçekleştirmek veya istatistiklerle çizim yapmak için yardımcı olabilir. rstatix paketi ve işlevleri hakkında daha fazla ayrıntı için Temel istatistiksel testler sayfasına bakın.

```{r}
linelist %>% 
  get_summary_stats(
    age, wt_kg, ht_cm, ct_blood, temp,  # hesaplanacak sütunlar
    type = "common")                    # döndürülecek özet istatistikler

```





## **janitor** paketi {#tbl_janitor}  

janitor paketleri, yüzdeleri, oranları, sayıları vb. görüntülemek için yardımcı işlevlerin uygulandığı tablolar ve çapraz tablolar oluşturmak için tabyl() fonksiyonunu sunar.

Aşağıda, sıra listesi veri çerçevesini janitor fonksiyonlarına aktarıyoruz ve sonucu yazdırıyoruz. İstenirse, sonuç tablolarını <- atama operatörü ile de kaydedebilirsiniz.

### Basit tabyl {.unnumbered}  

'tabyl()' öğesinin belirli bir sütunda varsayılan kullanımı, değerler, sayılar ve sütun bazında "yüzdeler" (oranlar) oluşturur. Oranlar çok basamaklı olabilir. Aşağıda açıklandığı gibi 'adorn_rounding()' ile ondalık basamak sayısını ayarlayabilirsiniz.  

```{r}
linelist %>% tabyl(age_cat)
```
Yukarıda gördüğünüz gibi, eksik değerler varsa, <NA> etiketli bir satırda görüntülenirler. Bunların gösterimini show_na = FALSE ile kapatabilirsiniz. Eksik değer yoksa bu satır görünmez. Eksik değerler varsa, tüm oranlar hem ham olarak (paydadaki NA sayıları dahil) hem de “geçerli” (paydadaki NA sayıları hariç) formda verilir.

Sütun sınıfı faktörse ve verilerinizde yalnızca belirli düzeyler varsa, tüm düzeyler tabloda görünmeye devam eder. show_missing_levels = FALSE belirterek bu özelliği kapatabilirsiniz. Faktörler sayfasında daha fazla bilgiye ulaşabilirsiniz. 


### Çapraz tablolar {.unnumbered}  

Çapraz tablolar, tabyl() içinde bir veya daha fazla ek sütun eklenerek elde edilir. Çıktıda yalnızca sayıların elde edildiğini unutmayın - oranlar ve yüzdeler, aşağıda gösterilen ek adımlarla eklenebilir.

```{r}
linelist %>% tabyl(age_cat, gender)
```

### tabyl'in "süslenmesi" {#tbl_adorn .unnumbered}  

Toplamları eklemek veya oranlara, yüzdelere dönüştürme işlemi veya ekranı başka bir şekilde ayarlamak için **janitor** “adorn” fonkisyonlarını kullanın. Tabloyu bu fonksiyonlardan birkaçından geçirebilirsiniz.

Fonksiyon          | Çıktı                          
-------------------|--------------------------------
`adorn_totals()`   | Toplamların eklenmesi (where = “row”, “col”, veya “both”). name = “Total” için.  
`adorn_percentages()` | Sayımların orana dönüştürülmesi denominator = “row”, “col”, veya “all”  
`adorn_pct_formatting()` | Oranların yüzdelere çevrimi. digits = belirtilmelidir. “%” sembolü bu argüman ile uzaklaştırılır.  `affix_sign = FALSE`.  
`adorn_rounding()` | Oranların digits =  sayıda basamağa yuvarlanması. Yüzdelerin yuvarlanması için   `adorn_pct_formatting()`.  
`adorn_ns()` | Oranlar veya yüzdeler tablosuna sayıları ekleyin. Sayıları parantez içinde göstermek için position = "rear" veya yüzdeleri parantez içinde koymak için "front" belirtin. 
`adorn_title()` | DEğişkenler aracılığıyla dize (string)eklenmesi row_name = and/or col_name =   

Yukarıdaki işlevleri uyguladığınız sıra önemlidir. Aşağıda bazı örnekler verilmiştir.

Varsayılan oranlar yerine yüzdeleri olan basit, tek yönlü bir tablo örneği: 

```{r}
linelist %>%               # vaka satır listesi 
  tabyl(age_cat) %>%       # sayıları-oranları yaşa göre tablo haline getirin
  adorn_pct_formatting()   # oranları yüzdelere çevir

```

Toplam satır ve satır yüzdelerini içeren bir çapraz tablo.
```{r}
linelist %>%                                  
  tabyl(age_cat, gender) %>%                  # yaş ve cinsiyete göre sayılar
  adorn_totals(where = "row") %>%             # toplam satırı ekle
  adorn_percentages(denominator = "row") %>%  # sayıları oranlara dönüştür
  adorn_pct_formatting(digits = 1)            # oranları yüzdelere çevir

```

Hem sayıların hem de yüzdelerin görüntülenmesi için ayarlanmış bir çapraz tablo.

```{r}
linelist %>%                                  # vaka listesi
  tabyl(age_cat, gender) %>%                  # çapraz tablo sayıları
  adorn_totals(where = "row") %>%             # toplam satırı ekle
  adorn_percentages(denominator = "col") %>%  # oranlara dönüştürmek
  adorn_pct_formatting() %>%                  # yüzdeye dönüştür
  adorn_ns(position = "front") %>%            # "sayı (yüzde)" olarak görüntüleme
  adorn_title(                                # başlıkların ayarlanması 
    row_name = "Age Category",
    col_name = "Gender")

```



### tabyl çıktısının alınması {.unnumbered}

Varsayılan olarak tabyl, R konsolunuza ham formda yazdıracaktır.

Alternatif olarak, RStudio Viewer'da .png, .jpeg, .html, vb. olarak dışa aktarılabilen bir resim olarak yazdırmak için tabyl'i flextable veya benzeri bir pakete geçirebilirsiniz. Bu işlem, Sunum için tablolar sayfasında tartışılmaktadır. Bu şekilde yazdırıyorsanız ve adorn_titles() kullanıyorsanız, place = argümanını "combined" belirtmeniz gerektiğini unutmayın. 


```{r}
linelist %>%
  tabyl(age_cat, gender) %>% 
  adorn_totals(where = "col") %>% 
  adorn_percentages(denominator = "col") %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front") %>% 
  adorn_title(
    row_name = "Age Category",
    col_name = "Gender",
    placement = "combined") %>% # resim olarak yazdırmak için bu gereklidir
  flextable::flextable() %>%    # güzel görüntüye dönüştür
  flextable::autofit()          # satır başına bir satıra biçimlendir


```


### Diğer tablolarda kullanımı  {.unnumbered}  

janitor adorn_*() işlevlerini, dplyr'den summarise() ve count() veya temel R'dan table() tarafından oluşturulanlar diğer tabloları da kullanabilirsiniz. Tabloyu istenen janitor fonksiyonuna yönlendirmeniz yeterlidir. Örneğin:  

```{r}
linelist %>% 
  count(hospital) %>%   # dplyr fonksiyonu
  adorn_totals()        # janitor fonksiyonu
```


### tabyl kaydedilmesi  {.unnumbered}  

Tabloyu flextable gibi bir paketle "güzel" bir resme dönüştürürseniz, o paketteki fonksiyonlarla kaydedebilirsiniz  (flextable'da save_as_html(), save_as_word(), save_as_ppt() ve save_as_image() gibi fonksiyonlar bulunmaktadır. Sunum için tablolar sayfasında kapsamlı bir şekilde tartışılmıştır. Aşağıdaki tablo, elle düzenlenebilen bir Word belgesi olarak kaydedilmiştir: 

```{r, eval=F}
linelist %>%
  tabyl(age_cat, gender) %>% 
  adorn_totals(where = "col") %>% 
  adorn_percentages(denominator = "col") %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front") %>% 
  adorn_title(
    row_name = "Age Category",
    col_name = "Gender",
    placement = "combined") %>% 
 flextable::flextable() %>%                     # resme dönüştür
  flextable::autofit() %>%                       # satır başına yalnızca bir satır
  flextable::save_as_docx(path = "tabyl.docx")   # dosya yoluna Word belgesi kaydet

```

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "tabyl_word.png"))
```

### İstatistikler {#janitor_age_out_stats .unnumbered}  

Aşağıda gösterildiği gibi, stats paketinden chisq.test() veya fisher.test() gibi fonksiyonlarla tablolar üzerinde istatistiksel testler uygulayabilirsiniz. Bu işlem, eksik değerlere izin verilmez, bu nedenle show_na = FALSE ile tablodan hariç tutulurlar. 

```{r, warning=F, message=F}
age_by_outcome <- linelist %>% 
  tabyl(age_cat, outcome, show_na = FALSE) 

chisq.test(age_by_outcome)
```

Daha fazla kod ve istatistiklerle ilgili ipuçları için [Temel istatistik testleri](stat_tests.tr.qmd) sayfasına bakın. 

### Diğer ipuçları {.unnumbered}  

•	Yukarıdaki hesaplamalardan herhangi birinden eksik değerleri hariç tutmak için na.rm = TRUE değişkenini kullanın.

•	tabyl() tarafından oluşturulmamış tablolara herhangi bir adorn_*() yardımcı fonksiyonu uyguluyorsanız, bunları adorn_percentage(,,,c(cases,deaths)) sintaksıyla belirli sütunlara uygulayabilirsiniz. (Sütunlar 4. değişken olarak belirtilmedir.). Sintaksı basit değil, bu nedenle bu işlem yerine summarise() kullanmayı düşünün.

•	Daha fazla ayrıntıyı janitor sayfasından ve tabyl gösteriminden okuyabilirsiniz.
[janitor sayfası](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html) ve [tabyl göstergesi](https://cran.r-project.org/web/packages/janitor/vignettes/tabyls.html).  



## **dplyr** paketi   

dplyr, tidyverse paketlerinin bir parçasıdır ve çok yaygın bir veri yönetimi aracıdır. 

dplyr’ın summarise() ve count() fonksiyonları tablolar oluşturmak, istatistikleri hesaplamak, gruba göre özetlemek veya tabloları ggplot()'a geçirmek için kullanışlı bir yaklaşımdır. 

summarise(), yeni bir özet veri çerçevesi oluşturur. Veriler gruplandırılmamışsa, tüm veri çerçevesinin belirtilen özet istatistiklerini içeren tek satırlık bir veri çerçevesi oluşturur. Veriler gruplandırılmışsa, yeni veri çerçevesinde grup başına bir satır oluşturacaktır (bkz. Verilerin gruplandırması sayfası).

summarise() fonksiyonunun parantezleri içinde, her yeni özet sütununun adını ve ardından bir eşittir işareti ve uygulanacak istatistiksel işlevi argüman olarak belirtmelisiniz.

: 


<span style="color: darkgreen;">**_İPUCU:_** Özetleme işlevi hem İngiliz hem de Amerikan İngilizcesi ile yazılabilir. (summarise() and summarize()).</span>

### Gözlem sayılarını elde etme  {.unnumbered}  

summarise() içinde uygulanacak en basit fonksiyon n()'dir. Satır sayısını elde etmek için parantezleri boş bırakın.  

```{r}
linelist %>%                 # satır listesiyle başla
  summarise(n_rows = n())    # n_rows sütunu ile özet veri çerçevesi elde edilir

```

Verileri önceden gruplandırıldığında bu daha ilginç sonuçlar elde edilir.

```{r}
linelist %>% 
  group_by(age_cat) %>%     # verileri age_cat sütunundaki değerlere göre gruplandır
  summarise(n_rows = n())   # *grup başına* satır sayısı elde edilir

```

Yukarıdaki komut, count() işlevi kullanılarak kısaltılabilir. count() şunları yapar:
  
1. Verileri belirlenen sütunlara göre gruplandırır
2. Verileri n() ile özetler (n sütunu oluşturur)
3. Verileri gruplarını çözer 


```{r}
linelist %>% 
  count(age_cat)
```

Sayılar sütununun adını varsayılan n'den name =  değişkeniyle değiştirebilirsiniz. 

İki veya daha fazla gruplandırma sütunundaki sayılar "uzun" biçimde tablo halinde döndürülür. n sütununda gözlem sayıları bulunmaktadır.  "Uzun" ve "geniş" veri biçimleri hakkında bilgi edinmek için verileri pivotlama sayfasına bakın. 

```{r}
linelist %>% 
  count(age_cat, outcome)
```


### Tüm seviyelerin gösterimi {.unnumbered}  

Bir sınıf faktörü sütunu oluştururken, summarise() veya count() komutuna .drop = FALSE argümanını ekleyerek (yalnızca verilerde değerleri olan seviyeleri değil) tüm seviyelerin gösterebilirsiniz. 

Bu teknik, tablolarınızı/grafiklerinizi standart hale getirmek için kullanışlıdır. Özellikle, birden fazla alt grup için grafik oluştururken ya da rutin raporlar için tekrarlayan grafiklerr oluştururken faydalıdır. Bu koşulların her birinde, verilerdeki değerler değişse de sabit kalan seviyeler tanımlayabilirsiniz.

Daha fazla bilgi için [Faktörler] sayfasına bakın.



### Oranlar {#tbl_dplyr_prop .unnumbered}  

Oranlar, yeni bir sütun oluşturmak için tablonun mutate() fonksiyonuna yönlendirmesi ile elde edilebilir. Yeni sütun, sayım sütununun (varsayılan olarak n) sayım sütununun toplamının elde edildiği sum()’a bölünmesiyle oluşturulur (bu işlem bir oran verir).

Bu durumda, mutate() komutundaki sum() öğesinin, oranın paydası olarak kullanılmak üzere tüm n sütununun toplamını vereceğini unutmayın. Verileri gruplandırılması sayfasında açıklandığı gibi, gruplandırılmış verilerde sum() fonksiyonu kullanılıyorsa (örneğin, mutate() fonksiyonu group_by() komutunu takip ediyorsa), gruba göre toplamlar elde edilir. Yukarıda belirtildiği gibi, count() fonksiyonu grupları çözerek görevini tamamlar. Böylece, bu senaryoda tam sütun oranlarını elde ederiz.

Yüzdeleri kolayca görüntülemek için, scales paketinden percent() fonksiyonunu kullanabilirsiniz (bu fonksiyonda verinin sınıf karakterine dönüştürüldüğünü unutmayın).


```{r}
age_summary <- linelist %>% 
  count(age_cat) %>%                     # cinsiyete göre grupla ve say ("n" sütunu oluşur)
  mutate(                                # sütunun yüzdesini oluştur – paydaya dikkat edin 
    percent = scales::percent(n / sum(n))) 

# çıktı al 
age_summary
```

Aşağıda gruplar içindeki oranları hesaplamak için bir yöntem gösterilmiştir. Seçici olarak uygulanan farklı veri gruplama düzeylerine dayanan bir yöntemdir. İlk olarak, veriler group_by() aracılığıyla sonuca göre gruplandırılır. Ardından, count() uygulanır. Bu fonksiyon, verileri age_cat'e göre gruplandırır ve her sonuç-age_cat kombinasyonu için gözlem sayılarını verir. Daha önemlisi, count() aynı zamanda age_cat gruplandırmasını da çözer, bu nedenle geriye kalan tek veri gruplaması sonuca göre orijinal gruplandırmadır. Bu nedenle, oranları hesaplamada son adımı (payda sum(n)) hala sonuca göre gruplandırılmıştır. 

```{r}
age_by_outcome <- linelist %>%                  # satır listesiyle başla
  group_by(outcome) %>%                         # sonuca göre gruplandır
  count(age_cat) %>%                            # age_cat ile gruplandır ve say ve ardından age_cat gruplamasını kaldır 
  mutate(percent = scales::percent(n / sum(n))) # yüzdeyi hesapla - paydanın sonuç grubuna göre olduğuna dikkat edin

```

```{r, echo=F}
DT::datatable(age_by_outcome, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```




### Grafikleştirme {.unnumbered}  

Yukarıdaki gibi "uzun" bir tablo ggplot() ile rahatça görüntülenebilir. Veriler ggplot() tarafından doğal olarak kabul edilen “uzun” formattadır. ggplot temelleri ve ggplot ipuçları sayfalarındaki diğer örneklere bakın.

```{r, warning=F, message=F}
linelist %>%                      # satır listesiyle başlama
  count(age_cat, outcome) %>%     # sayıları iki sütuna göre gruplandırın ve tablolaştırın
  ggplot()+                       # yeni veri çerçevesini ggplot'a geçir
    geom_col(                     # sütun grafiği oluştur
      mapping = aes(   
        x = outcome,              # sonucu x eksenine eşle
        fill = age_cat,           # age_cat'i dolguya eşle
        y = n))                   # sayım sütununu `n` yüksekliğe eşle
```


### Özet istatistiği {.unnumbered}  

dplyr ve summarise()'in önemli bir avantajı, median(), mean(), max(), min(), sd() (standart sapma) ve yüzdelikler gibi daha ileri istatistik özetleri oluşturma yeteneğidir. Belirli mantık kriterlerini karşılayan satır sayılarını elde etmek için sum() fonksiyonuna da kullanabilirsiniz. Yukarıdaki gibi, bu çıktılar tüm veri çerçevesi için veya belli grup gruplar için oluşturulabilir.

Sintaks aynıdır - summarise() parantezleri içinde yeni özet sütunlarının adları, ardından bir eşittir işareti ve uygulanacak istatistiksel fonksiyonlar yazılmalıdır. İstatistiksel fonksiyon içinde, üzerinde çalışılacak sütunları ve ilgili argümanlar yazılmalıdır (örneğin, çoğu matematiksel fonksiyon için na.rm = DOĞRU).

Mantıksal bir ölçütü karşılayan satır sayısını elde etmek için sum()'u da kullanabilirsiniz. İçindeki ifade TRUE olarak değerlendirilirse sayıma girer. Örneğin:


* `sum(age_years < 18, na.rm=T)`  
* `sum(gender == "male", na.rm=T)`  
* `sum(response %in% c("Likely", "Very Likely"))`  

Aşağıda, satır listesi verilerinde, semptom başlangıcından hastaneye kabule kadar geçen gün gecikmesi değişkeni (sütun days_onset_hosp) özetlenmiştir.  

```{r}
summary_table <- linelist %>%                                        # linelist ile başlayın, yeni nesne olarak kaydedin
  group_by(hospital) %>%                                             # tüm hesaplamaları hastaneye göre gruplandır
  summarise(                                                         # yalnızca aşağıdaki özet sütunları elde edilecek
    cases       = n(),                                                # grup başına satır sayısı
    delay_max   = max(days_onset_hosp, na.rm = T),                    # maksimum gecikme
    delay_mean  = round(mean(days_onset_hosp, na.rm=T), digits = 1),  # ortalama gecikme, yuvarlanmış
    delay_sd    = round(sd(days_onset_hosp, na.rm = T), digits = 1),  # gecikmelerin standart sapması, yuvarlanmış
    delay_3     = sum(days_onset_hosp >= 3, na.rm = T),               # 3 veya daha fazla gün gecikmeli satır sayısı
    pct_delay_3 = scales::percent(delay_3 / cases)                    # önceden tanımlanmış gecikme sütununu yüzdeye dönüştür
  )

summary_table  # yazdır
```


Bazı ipuçları

• Belirli ölçütleri karşılayan (==) satırları "saymak" için bir mantıksal ifadeyle sum() kullanın
• sum() gibi matematiksel fonksiyonlarda na.rm = TRUE kullanımına dikkat edin, aksi takdirde eksik değerler varsa NA elde edilir. 
• Yüzdelere kolayca dönüştürmek için scales paketindeki percent() işlevini kullanın
• Sırasıyla 1 veya 2 ondalık basamak sağlamak için accuracy =  argümanını 0,1 veya 0,01 olarak ayarlayın
• Ondalık sayıları belirtmek için temel R’dan round() fonksiyonunu kullanın
• Bu istatistikleri tüm veri kümesinde hesaplamak için, group_by() olmadan summarise() kullanın.
• Daha sonraki hesaplamalar için (örneğin payda oluşturmak için) veri çerçevenizden select() ile seçebileceğiniz sütunlar oluşturabilirsiniz. 



### Koşullu istatistikler {.unnumbered}  

Koşullu istatistikleri elde etmek isteyebilirsiniz - ör. belirli ölçütleri karşılayan maksimum satır sayısı elde edilebilir. Bu işlem, sütun parantez [ ] ile alt kümelere ayrılarak gerçekleştirilebilir. Aşağıdaki örnek, ateşi olan veya olmayan hastalar için maksimum vücut sıcaklığını verir. Ancak unutmayın - group_by()ve pivot_wider() komutlarıyla (aşağıda gösterildiği gibi) başka bir sütun eklemek daha uygun olabilir. (#tbls_pivot_wider)).  


```{r}
linelist %>% 
  group_by(hospital) %>% 
  summarise(
    max_temp_fvr = max(temp[fever == "yes"], na.rm = T),
    max_temp_no = max(temp[fever == "no"], na.rm = T)
  )
```



### Hepsini birleştirmek {.unnumbered}  

stringr'den str_glue() fonksiyonu, birkaç sütundaki değerleri yeni bir sütunda birleştirmek için kullanışlıdır. Genellikle bu fonksiyon summarise() komutundan sonra kullanılır.

Karakterler ve dizeler sayfasında, unite() ve paste0() dahil olmak üzere sütunları birleştirmek için çeşitli seçenekler tartışılmaktadır. Bu kullanım örneğinde, unite()'den daha esnek olduğu ve paste0()'dan daha basit sözdizimine sahip olduğu için str_glue() vurgulanmıştır.

Aşağıdaki örnekte, summary_table veri çerçevesinde, delay_mean ve delay_sd sütunları birleştirilecek, yeni sütuna parantez biçimlendirmesi eklenecek ve ilgili eski sütunlar kaldırılacaktır.

Ardından, tabloyu daha anlaşılır hale getirmek için, janitor’dan adorn_totals() ile toplam bir satır eklenir (bu fonksiyon sayısal olmayan sütunları yok sayar). Son olarak, hem yeniden sıralamak hem de sütunları yeniden adlandırmak için dplyr'den select() kullanıyoruz.

Artık flextable'a geçebilir ve tablonun çıktısını Word, .png, .jpeg, .html, Powerpoint, RMarkdown, vb.'ye alabilirsiniz! (Sunum için tablolar sayfasına bakınız).


```{r}
summary_table %>% 
  mutate(delay = str_glue("{delay_mean} ({delay_sd})")) %>%  # diğer değerleri birleştir ve biçimlendir
  select(-c(delay_mean, delay_sd)) %>%                       # iki eski sütunu sil  
  adorn_totals(where = "row") %>%                            # toplam satırı ekle
  select(                                                    # sütunları sırala ve yeniden adlandır
    "Hospital Name"   = hospital,
    "Cases"           = cases,
    "Max delay"       = delay_max,
    "Mean (sd)"       = delay,
    "Delay 3+ days"   = delay_3,
    "% delay 3+ days" = pct_delay_3
    )
```

#### Yüzdelikler {.unnumbered}  

Burada dplyr'deki yüzdelikler ve çeyrekliklere özel olarak değinilecektir. Yüzdelikleri döndürmek için, 'quantile()' fonksiyonunu varsayılanlarla kullanın veya istediğiniz değeri/değerleri 'probs =' değişkeni ile belirtin.

```{r}
# yaşın varsayılan yüzdelik değerlerini alın (%0, %25, %50, %75, %100)
linelist %>% 
  summarise(age_percentiles = quantile(age_years, na.rm = TRUE))

# manuel olarak belirtilen yaş yüzdelik değerlerini alın (%5, %50, %75, %98)
linelist %>% 
  summarise(
    age_percentiles = quantile(
      age_years,
      probs = c(.05, 0.5, 0.75, 0.98), 
      na.rm=TRUE)
    )
```

Yüzdelikleri gruplara göre elde etmek istiyorsanız, group_by() öğesine basitçe başka bir sütun eklerseniz, uzun ve kullanışsız çıktılarla karşılaşabilirsiniz. Bu nedenle, bunun yerine istenen her yüzdelik düzeyi için bir sütun oluşturma yöntemini kullanın. 

```{r}
#   manuel olarak belirtilen yaş yüzdelik değerlerini alın (%5, %50, %75, %98)
linelist %>% 
  group_by(hospital) %>% 
  summarise(
    p05 = quantile(age_years, probs = 0.05, na.rm=T),
    p50 = quantile(age_years, probs = 0.5, na.rm=T),
    p75 = quantile(age_years, probs = 0.75, na.rm=T),
    p98 = quantile(age_years, probs = 0.98, na.rm=T)
    )
```

dplyr summarise() fonksiyonu kesinlikle daha iyi kontrol sağlarken, ihtiyacınız olan tüm özet istatistiklerin rstatix paketinden get_summary_stat() ile elde edebilirsiniz. Gruplandırılmış veriler üzerinde çalışıyorsanız, %0, %25, %50, %75 ve %100 değerlerini elde edebilirsiniz. Gruplandırılmamış verilere uygularsanız, yüzdelikleri probs = c(.05, .5, .75, .98) değişkeni ile belirtebilirsiniz. 


```{r}
linelist %>% 
  group_by(hospital) %>% 
  rstatix::get_summary_stats(age, type = "quantile")
```

```{r}
linelist %>% 
  rstatix::get_summary_stats(age, type = "quantile")
```



### Birleştirilmiş verileri özetleyin {.unnumbered}  

*Birleştirilmiş verilerle başlarsanız*, n() fonksiyonunu kullandığınızda, toplanan sayıların toplamını değil, satır sayısını elde edersiniz. Toplamları almak için verilerin sayımlar sütununda sum() öğesini kullanın.
Örneğin, linelist_agg adında sayım veri çerçevesiyle başladığınızı varsayalım- vaka sayıları sonuca ve cinsiyete göre "uzun" biçimde gösterilir. 
Aşağıda, sonuca ve cinsiyete göre satır listesi vaka sayılarının örnek veri çerçevesini oluşturuyoruz (Anlaşılması için eksik değerler kaldırıldı).


```{r}
linelist_agg <- linelist %>% 
  drop_na(gender, outcome) %>% 
  count(outcome, gender)

linelist_agg
```

Sayıları (n sütunundaki) gruba göre toplamak için summarise()'i kullanabilirsiniz, ancak yeni sütunu sum(n, na.rm=T) değerine eşitlemeniz gerekmektedir. Toplam işlemine koşullu öğe eklemek için, sayımlar sütunundaki alt küme ayracını [ ] kullanabilirsiniz.

```{r}
linelist_agg %>% 
  group_by(outcome) %>% 
  summarise(
    total_cases  = sum(n, na.rm=T),
    male_cases   = sum(n[gender == "m"], na.rm=T),
    female_cases = sum(n[gender == "f"], na.rm=T))
```




### `across()` birden çok sütun arasından   {.unnumbered}  

summarise() fonksiyonunu across() kullanarak birden çok sütuna uygulayabilirsiniz. Bu şekilde birçok sütun için aynı istatistikleri hesaplayabilirsiniz . summarise() fonksiyonu içine across() fonksiyonunu yerleştirin ve aşağıdakileri belirtin:

* `.cols = ` sütun adlarının bir vektörü olarak .cols = c() veya "tidyselect" yardımcı işlevleri (aşağıda açıklanmıştır)
* `.fns = `gerçekleştirilecek fonksiyon (parantez yok) - bir liste içinde birden çok fonksiyon belirtebilirsiniz. 

Aşağıda, mean() birkaç sayısal sütuna uygulanmıştır. Bir sütun vektörü .cols =  argümanı olarak belirtilir ve .fns = olarak tek bir fonksiyon- bu durumda (parantez olmadan) ortalama belirtilir. İşlev için ek argümanlar (ör. na.rm=TRUE), .fns = argümanından sonra virgülle ayrılmış olarak yazılır.

Across() kullanılırken parantez ve virgüllerin sırasını doğru yapmak zor olabilir. Across() içinde, sütunları, fonksiyonları ve fonkisyonlar için gereken fazladan argümanları dahil etmeniz gerektiğini unutmayın.


```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm),  # sütunlar
                   .fns = mean,                               # fonksiyon
                   na.rm=T))                                  # ekstra değişkenler
```

Aynı anda birden fazla fonksiyon çalıştırılabilir. Aşağıda, bir liste list() içinde .fns = için mean ve sd fonkisyonları sağlanır. Yeni sütunları istediğimiz gibbi adlandırabiliriz (örneğin, "ortalama" ve "sd"). 

```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm), # sütunlar
                   .fns = list("mean" = mean, "sd" = sd),    # çoklu fonksiyon 
                   na.rm=T))                                 # ekstra değişkenler
```

Sütunları seçmek için .cols = argümanı için sağlayabileceğiniz "tidyselect" yardımcı işlevleri şunlardır:

•	everything() - belirtilmeyen diğer tüm sütunlar
•	last_col() – son sütun
•	where() - tüm sütunlara bir fonksiyonu uygular ve DOĞRU olanları seçer
•	starts_with() - belirli bir ön-ekle eşleşir. Örnek: starts_with("date") 
•	ends_with() - belirli bir son-ekle eşleşir. Örnek:ends_with("_end")
•	contains() - bir karakter dizisi içeren sütunlar. Örnek:contains("time") 
•	matches() - regüler bir ifade (regex) uygulamak için. Örnek:contains("[pt]al")
•	num_range() - 
•	any_of() – sütun adlandırılmışsa eşleşir. Ad mevcut değilse kullanışlıdır. Örnek:
•	any_of(date_onset, date_death, cardiac_arrest) 

Örneğin, her sayısal sütunun ortalamasını elde etmek için where() fonksiyonunu kullanın ve içinde is.numeric’i parentez olmadan kullanın. Bütün bunlar across() komutu içinde kalır.


```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(
    .cols = where(is.numeric),  # veri çerçevesindeki tüm sayısal sütunlar
    .fns = mean,
    na.rm=T))
```


### Pivot genişletme {#tbls_pivot_wider .unnumbered}

Tablonuzu "geniş" biçimde oluşturmayı tercih ederseniz, tidyr pivot_wider() fonksiyonunu kullanarak dönüştürebilirsiniz. Sütunları rename() ile yeniden adlandırmanız gerekebilir. Daha fazla bilgi için Verilerin pivotlanması sayfasına bakın.

Aşağıdaki örnek, oranlar bölümündeki "uzun" tablodur ve age_by_outcome ile başlamaktadır. 
  

```{r}
age_by_outcome <- linelist %>%                  # satır listesiyle başla
  group_by(outcome) %>%                         # sonuca göre gruplandır
  count(age_cat) %>%                            # age_cat ile gruplandırın ve sayın ve ardından age_cat gruplamasını kaldırın
  mutate(percent = scales::percent(n / sum(n))) # yüzdeyi hesapla - paydanın sonuç grubuna göre olduğuna dikkat edin

```

```{r, echo=F}
DT::datatable(age_by_outcome, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Daha geniş bir tablo halinde özetlemek için ScriptTo ile, mevcut age_cat sütunundaki değerlerden name_from = age_cat ayarını yaparak yeni sütunlar yaratırız. Yeni tablo değerleri mevcut n sütunundan, value_from = n ile elde edilecektir. Pivotlama komutumuzda (çıktı) belirtilmeyen sütunlar, en sol tarafta değişmeden kalacaktır.

```{r}
age_by_outcome %>% 
  select(-percent) %>%   # basit gösterim için sadece sayımlar 
  pivot_wider(names_from = age_cat, values_from = n)  
```


### Toplam satırlar {#tbl_dplyr_totals .unnumbered}  

summarise () işlevi, gruplanmış veriler üzerinde çalıştığında, otomatik olarak "toplam" istatistikler üretmez. Aşağıda, toplam satır eklemeye yönelik iki yaklaşım sunulmaktadır:

#### **janitor**'ün `adorn_totals()` fonskiyonu {.unnumbered}  

Tablonuz yalnızca toplamda elde edilebilecek sayılardan veya orantılardan/yüzdelerden oluşuyorsa, yukarıdaki bölümde açıklandığı gibi janitor adorn_totals() fonksiyonunu kullanarak toplamları ekleyebilirsiniz. Bu fonkisyonun yalnızca sayısal sütunları toplayabileceğine dikkat edin - diğer toplam özet istatistiklerini hesaplamak istiyorsanız dplyr ile sonraki yaklaşıma bakın.

Aşağıda, satır listesi cinsiyete göre gruplandırılmıştır ve sonucu bilinen, ölen ve iyileşen vakaların sayısını açıklayan bir tabloda özetlenmiştir. Tabloyu adorn_totals()'a yönlendirmek, tablonun altına her sütunun toplamını yansıtan bir toplam satır ekler. Diğer adorn_*() işlevleri, kodda belirtildiği gibi ekranı ayarlar.


```{r}
linelist %>% 
  group_by(gender) %>%
  summarise(
    known_outcome = sum(!is.na(outcome)),           # Sonucun eksik olmadığı gruptaki satır sayısı
    n_death  = sum(outcome == "Death", na.rm=T),    # Sonucun ölüm olduğu gruptaki satır sayısı
    n_recover = sum(outcome == "Recover", na.rm=T), # Sonucun hayatta kalma olduğu gruptaki satır sayısı
  ) %>% 
  adorn_totals() %>%                                # Toplam satırı (her sayısal sütunun toplamı)
  adorn_percentages("col") %>%                      # Sütun oranlarını al
  adorn_pct_formatting() %>%                        # Oranları yüzdelere dönüştür
  adorn_ns(position = "front")                      # % ve sayıları göster (sayılar önde)

```

#### Toplam veride summarise() sonrasında bind_rows() fonksiyonu {.unnumbered}  

Tablonuz median(), mean() vb. özet istatistiklerden oluşuyorsa, yukarıda gösterilen adorn_totals() yaklaşımı yeterli olmayacaktır. Bunun yerine, tüm veri kümesi için özet istatistikleri elde etmek için ayrı bir summarise() komutu kullanarak hesaplamanız ve ardından sonuçları orijinal gruplandırılmış özet tablosuna eklemeniz gerekir. Birleştirmeyi yapmak için, Verilerin birleştirilmesi sayfasında açıklanan dplyr’dan bind_rows() fonksiyonunu kullanabilirsiniz. Aşağıda bir örnek verilmiştir:

group_by() ve summarise() ile hastane bazında sonuçların özetini şu şekilde çıkarabilirsiniz:


```{r, warning=F, message=F}
by_hospital <- linelist %>% 
  filter(!is.na(outcome) & hospital != "Missing") %>%  # Eksik sonuç veya hastane verisi olan vakaları sil
  group_by(hospital, outcome) %>%                      # Veriyi grupla 
  summarise(                                           # İlgilenilen göstergelerin yeni özet sütunları oluşturun
    N = n(),                                            # Hastane-sonuç grubu başına satır sayısı
    ct_value = median(ct_blood, na.rm=T))               # by_hospital grubu başına medyan CT değeri

by_hospital # tabloyu yazdır  

```

Toplamları almak için summarise() komutunu çalıştırın, ancak verileri yalnızca sonuca göre (hastaneye göre değil) şu şekilde gruplandırın: 

```{r}
totals <- linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Hastaneye göre değil, yalnızca sonuca göre gruplandırılmış  
      summarise(
        N = n(),                                       # Bu istatistikler artık sadece sonuca göre     
        ct_value = median(ct_blood, na.rm=T))

totals # tabloyu yazdır
```

Bu iki veri çerçevesini birbirine bağlayabiliriz. by_hospital'in 4 sütunu, toplamların ise 3 sütunu olduğunu unutmayın. bind_rows() kullanılarak, sütunlar ada göre birleştirilir ve fazladan boşluklar NA ifadesi ile doldurulur (örneğin, iki yeni toplam satırı için sütun hastane değerleri). Satırları bağladıktan sonra, bu boş alanları replace_na() kullanarak "toplam"a dönüştürürüz (bkz. Veri temizliği ve çekirdek fonksiyonlar sayfaları).

```{r}
table_long <- bind_rows(by_hospital, totals) %>% 
  mutate(hospital = replace_na(hospital, "Total"))
```

Altta "Toplam" satırları olan yeni tablo yer almaktadır.

```{r, message=FALSE, echo=F}
DT::datatable(table_long, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```

Bu tablo, istediğiniz gibi “uzun” biçimdedir. İsteğe bağlı olarak, tabloyu daha okunabilir hale getirmek için bu tabloyu daha geniş forma pivotlayabilirsiniz. Yukarıdaki daha geniş pivotlama ile ilgili bölüme ve Verilerin pivotlanması sayfasına bakın. Ayrıca daha fazla sütun ekleyebilir ve düzenleyebilirsiniz. İlgili kod aşağıdadır.

```{r}
table_long %>% 
  
  # Daha geniş pivotlama ve formatlama 

    mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # Uzundan genişe pivotlama
    values_from = c(ct_value, N),                       # yeni değerler ct ve count sütunlarından alınmıştır
    names_from = outcome) %>%                           # sonuçlardan yeni sütun adları 
  mutate(                                              # Yeni sütunlar ekle
    N_Known = N_Death + N_Recover,                               # sonucu bilinen sayı
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # ölen vakaların yüzdesi (1 ondalık basamağa kadar)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # iyileşenlerin yüzdesi (1 ondalık basamağa kadar)
  select(                                              # Sütunları yeniden sırala
    hospital, N_Known,                                   # Giriş sütunları
    N_Recover, Pct_Recover, ct_value_Recover,            # İyileşenlerin sütunları
    N_Death, Pct_Death, ct_value_Death)  %>%             # Ölen vakaların sütunları
  arrange(N_Known)                                  # Satırları en düşükten en yükseğe doğru düzenleyin (Toplam satır en altta)


```

Daha sonra bu tablo daha “güzel” bir şekilde yazdırabilir. Aşağıda flextable ile elde edilen çıktı yer almaktadır. Bu "güzel" tablonun nasıl elde edileceği hakkında daha ayrıntılı bilgiyi Sunum için Tablolar sayfasından okuyabilirsiniz.  

```{r echo=FALSE, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}

linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds")) 

border_style = officer::fp_border(color="black", width=1)

pacman::p_load(
  rio,            # içe/dışa aktar
  here,           # dosya yolakları
  flextable,      # tabloların güzel resimlerini yapmak 
  officer,        # tablolar için yardımcı işlevler
  tidyverse)      # veri yönetimi, özet ve görselleştirme

table <- linelist %>% 
  # filtre
  ########
  filter(!is.na(outcome) & hospital != "Missing") %>%  # Eksik sonuç veya hastane olan vakaları kaldırın
  
  # Hastane sonuç grubu başına özet değerleri alın
  ###############################################
  group_by(hospital, outcome) %>%                      # verileri gruplama
  summarise(                                           # İlgilenilen göstergelerin yeni özet sütunları oluşturun
    N = n(),                                            # Hastane-sonuç grubu başına satır sayısı     
    ct_value = median(ct_blood, na.rm=T)) %>%           # grup başına medyan CT değeri
  
  # toplamları ekle
  ############
  bind_rows(                                           # Önceki tabloyu bu mini toplamlar tablosuyla birleştirin
    linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Hastaneye göre değil, yalnızca sonuca göre gruplandırılmış  
      summarise(
        N = n(),                                       # Tüm veri kümesi için satır sayısı    
        ct_value = median(ct_blood, na.rm=T))) %>%     # Tüm veri seti için medyan CT
  
  # Daha geniş döndür ve biçimlendir
  ########################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # Uzundan genişe dön
    values_from = c(ct_value, N),                       # yeni değerler ct ve count sütunlarından alınmıştır
    names_from = outcome) %>%                           # yeni sütun adları sonuçlardan
  mutate(                                              # yeni sütunları ekle
    N_Known = N_Death + N_Recover,                               # sonucu bilinen sayı
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # ölen vakaların yüzdesi (1 ondalık basamağa kadar)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # iyileşen yüzde (1 ondalık basamağa kadar)
  select(                                              # Sütunları yeniden sırala
    hospital, N_Known,                                   # Giriş sütunları
    N_Recover, Pct_Recover, ct_value_Recover,            # kurtarılan sütunlar
    N_Death, Pct_Death, ct_value_Death)  %>%             # Ölüm sütunları
  arrange(N_Known) %>%                                 # Satırları en düşükten en yükseğe doğru düzenleyin (Toplam satır en altta)

  # formatlama
  ############
  flextable() %>% 
  add_header_row(
    top = TRUE,                # Yeni başlık, mevcut başlık satırının üstüne gider
    values = c("Hospital",     # Aşağıdaki her sütun için başlık değerleri
               "Total cases with known outcome", 
               "Recovered",    # Bu, bunun ve sonraki iki sütunun en üst düzey başlığı olacaktır.
               "",
               "",
               "Died",         # Bu, bunun ve sonraki iki sütunun en üst düzey başlığı olacaktır.
               "",             # "Öldü" ile birleştirileceği için boş bırakın
               "")) %>% 
    set_header_labels(         # Orijinal başlık satırındaki sütunları yeniden adlandırın
      hospital = "", 
      N_Known = "",                  
      N_Recover = "Total",
      Pct_Recover = "% of cases",
      ct_value_Recover = "Median CT values",
      N_Death = "Total",
      Pct_Death = "% of cases",
      ct_value_Death = "Median CT values")  %>% 
  merge_at(i = 1, j = 3:5, part = "header") %>% # Yeni başlık satırında 3 ile 5 arasındaki sütunları yatay olarak birleştir
  merge_at(i = 1, j = 6:8, part = "header") %>%  
  border_remove() %>%  
  theme_booktabs() %>% 
  vline(part = "all", j = 2, border = border_style) %>%   # sütun 2 de
  vline(part = "all", j = 5, border = border_style) %>%   # sütun 5 de
  merge_at(i = 1:2, j = 1, part = "header") %>% 
  merge_at(i = 1:2, j = 2, part = "header") %>% 
  width(j=1, width = 2.7) %>% 
  width(j=2, width = 1.5) %>% 
  width(j=c(4,5,7,8), width = 1) %>% 
  flextable::align(., align = "center", j = c(2:8), part = "all") %>% 
  bg(., part = "body", bg = "gray95")  %>% 
  colformat_num(., j = c(4,7), digits = 1) %>% 
  bold(i = 1, bold = TRUE, part = "header") %>% 
  bold(i = 6, bold = TRUE, part = "body")


table
```



## **gtsummary** paketi {#tbl_gt}   

Özet istatistiklerinizi yayına hazır bir grafikte yazdırmak istiyorsanız, gtsummary paketini ve onun tbl_summary() fonksiyonunu kullanabilirsiniz. Kod ilk başta karmaşık görünebilir, ancak çıktıları güzel görünür ve RStudio Viewer panelinize HTML görüntüsü olarak yazdırılır. [gösterimi burada](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html).  

Ayrıca istatistiksel testlerin sonuçlarını gtsummary tablolarına ekleyebilirsiniz. Bu işlem, Basit istatistik testleri sayfasının gtsummary bölümünde açıklanmıştır.[Basit istatistiksel testler](#stats_gt) sayfası.

tbl_summary()'yi tanıtmak için öncelikle büyük ve güzel tablolar oluşturan en temel işlevlerini göstereceğiz. Daha sonra düzenlemelerin ve özel tablolar yapımını detaylı olarak inceleyeceğiz.   


### Özet tablosu {.unnumbered}

tbl_summary()'nin varsayılan fonksiyonuyla belirtilen sütunları alır ve tek komutta bir özet tablo oluşturur. İşlev, sütun sınıfına uygun istatistikleri yazdırır: sayısal sütunlar için medyan ve çeyrekler arası aralık (IQR) ve kategorik sütunlar için gözlem sayısı (%) istatistiklerini verir. Eksik değerler “Bilinmeyen” ifadesnie dönüştürülür. İstatistikleri açıklamak için en alta dipnotlar eklenirken, toplam N üstte gösterilir.

```{r, warning=F, message=F}
linelist %>% 
  select(age_years, gender, outcome, fever, temp, hospital) %>%  # sadece ilgilenilen sütunları tut
  tbl_summary()                                                  # varsayılan
```


### Ayarlar {.unnumbered}  

Şimdi fonksiyonun nasıl çalıştığını ve ayarlamaların nasıl yapıldığını anlatacağız. Temel değişkenler aşağıda detaylandırılmıştır: 

**`by = `**  
2 yönlü bir tablo oluşturarak tablonuzu bir sütuna göre (örn. sonuca göre) tabakalandırabilirsiniz.

**`statistic = `**  
Hangi istatistiklerin gösterileceğini ve nasıl görüntüleneceğini belirtmek için denklem kullanın. Denklemin bir tilde ~ işareti ile ayrılmış iki tarafı vardır. Sağ tarafta istenen istatistiksel hesap, sol tarafta ise bu hesabın uygulanacağı sütunlar yer almaktadır.

• Denklemin sağ tarafındaki stringr'den str_glue() sintaksına (bkz. “n” (sayılar için), “N” (payda için), “mean”, “median”, “sd”, “max”, “min”, yüzdelikleri ( “p##” olarak; örneğin p25, toplamın yüzdeliği p) dahil edebilirsiniz. Ayrıntılar için ?tbl_summary komutunu uygulayın.

• Denklemin sol tarafı için sütunları ada göre (örn. yaş veya c(yaş, cinsiyet)) veya all_continuous(), all_categorical(), include(), start_with(), vb. gibi yardımcıları kullanarak belirtebilirsiniz.

Basit bir statistics = denklemi örneği, yalnızca age_years sütununun ortalamasını yazdırmak için aşağıdaki gibi görünebilir: 


```{r}
linelist %>% 
  select(age_years) %>%         # yalnızca ilgilenilen sütunları tut
  tbl_summary(                  # özet tablo oluştur
    statistic = age_years ~ "{mean}") # yaş ortalamasını yazdır

```

Biraz daha karmaşık gibi görünebilen denklem "({min}, {maks})", maksimum ve minimum değerleri parantez içine alır ve virgülle ayırır:

```{r}
linelist %>% 
  select(age_years) %>%                       # yalnızca ilgilenilen sütunları tut 
  tbl_summary(                                # özet tablo oluştur
    statistic = age_years ~ "({min}, {max})") # yaşın en küçük ve en büyük değerlerini yazdır
```

Ayrı sütunlar veya sütun türleri için sintaksı de farklılaştırabilirsiniz. Aşağıdaki daha karmaşık örnekte, statistic = argümanına sağlanan değer, tablonun tüm sürekli sayısal sütunlar için parantez içinde standart sapma ile ortalamayı, tüm kategorik sütunlar için ise n, payda ve yüzdeyi yazdırması gerektiğini belirten bir listedir. 

**digits =**
Rakamları ve yuvarlamayı ayarlayın. İsteğe bağlı olarak, bu yalnızca sürekli sütunlar için belirtilebilir (aşağıdaki gibi).

**label=**
Sütun adının nasıl görüntüleneceğini ayarlayın. Bir tilde ~ ile ayrılmış sütun adını ve istenen etiketi sağlayın. Varsayılan, sütun adıdır.

**Missing_text=**
Eksik değerlerin nasıl görüntüleneceğini ayarlayın. Varsayılan ifade "Bilinmeyen"dir.

**type =**
Bu argüman, istatistiklerin hangi  düzeyinin gösterileceğini ayarlamak için kullanılır. Sintaksı, statistic = değişkeni ile benzerdir, çünkü solda sütunlar ve sağda değer içeren bir denklem oluşturursunuz. İki yaygın senaryo şunları içerir:

• type = all_categorical() ~ "categorical" İkili sütunları (örn. ateş evet/hayır) yalnızca “evet” satırı yerine tüm seviyeleri göstermeye zorlar

• type = all_continuous() ~ "continuous2" Daha sonraki bir bölümde gösterildiği gibi, değişken başına çok satırlı istatistiklere izin verir

Aşağıdaki örnekte, bu bağımsız değişkenlerin her biri orijinal özet tablosunu değiştirmek için kullanılır: 


```{r}
linelist %>% 
  select(age_years, gender, outcome, fever, temp, hospital) %>% # yalnızca ilgilenilen sütunları tut
  tbl_summary(     
    by = outcome,                                               # tüm tabloyu sonuca göre katmanlandır
    statistic = list(all_continuous() ~ "{mean} ({sd})",        # sürekli sütunlar için istatistikler ve biçim
                     all_categorical() ~ "{n} / {N} ({p}%)"),   # kategorik sütunlar için istatistikler ve biçim
    digits = all_continuous() ~ 1,                              # sürekli sütunlar için yuvarlama
    type   = all_categorical() ~ "categorical",                 # tüm kategorik seviyeleri görüntülemeye zorla
    label  = list(                                              # sütun adları için etiketleri göster
      outcome   ~ "Outcome",                           
      age_years ~ "Age (years)",
      gender    ~ "Gender",
      temp      ~ "Temperature",
      hospital  ~ "Hospital"),
    missing_text = "Missing"                                    # eksik değerler nasıl gösterilmelidir
  )

```



### Sürekli değişkenler için çok satırlı istatistikler {.unnumbered}  

Sürekli değişkenler için birden çok istatistik satırı yazdırmak istiyorsanız, bunu type = değişkenini  "continuous2" olarak ayarlayarak belirtebilirsiniz. Hangi istatistikleri göstermek istediğinizi seçerek, daha önce gösterilen tüm öğeleri tek bir tabloda birleştirebilirsiniz. Bunun için type argümanına “continuous2” girerek tabloyu geri almak istediğinizi fonksiyona belirtmeniz gerekir. Eksik değerlerin sayısı “Bilinmeyen” olarak gösterilir.

```{r}
linelist %>% 
  select(age_years, temp) %>%                      # yalnızca ilgilenilen sütunları tut
  tbl_summary(                                     # özet tablo oluştur
    type = all_continuous() ~ "continuous2",       # birden fazla istatistik yazdırmak istediğinizi belirtin
    statistic = all_continuous() ~ c(
      "{mean} ({sd})",                             # 1. satır: ortalama ve SD
      "{median} ({p25}, {p75})",                   # 2. satır: medyan ve IQR
      "{min}, {max}")                              # satır 3: min ve maks
    )

```
Bu tabloları p değerleri eklenerek, renk ve başlıkları ayarlayarak vb. gibi birçok başka şekilde değiştirilebilir. Bu işlemler çoğu belgelerde açıklanmıştır (Konsol'a ?tbl_summary komutunu girin) ve diğer işlemler ise istatistiksel testler bölümünde açıklanmıştır.[istatistiksel testler](https://epirhandbook.com/simple-statistical-tests.html).  







## R **tabanı**    

Sütunları tablolamak ve çapraz tablo oluşturmak için table() fonkisyonunu kullanabilirsiniz. Yukarıdaki seçeneklerden farklı olarak, aşağıda gösterildiği gibi bir sütun adına her başvurduğunuzda veri çerçevesini belirtmelisiniz.

<span style="color: orange;">**_Uyarı:_** NA (eksik) değerler, useNA = "always" (aynı zamanda "hayır" veya "eğer" olarak da ayarlanabilir) değişkenini eklemediğiniz sürece tablo haline getirilmeyecektir.</span>

<span style="color: darkgreen;">**_İPUCU:_** Baz fonksiyonlarda tekrarlanan veri çerçevesi belirtme ihtiyacını ortadan kaldırmak için magrittr'den %$% operatörünü kullanabilirsiniz. Örneğin aşağıdaki satır listesi  tablosunu inceleyin (çıktı, useNA = "always")</span>

```{r}
table(linelist$outcome, useNA = "always")
```

Birden çok sütun, virgülle ayrılmış şekilde ardışık olarak listelenerek çapraz tablo haline getirilebilir. İsteğe bağlı olarak, her sütuna Outcome = linelist$outcome değişkeni gösterildiği gibi bir ad atayabilirsiniz.

```{r}
age_by_outcome <- table(linelist$age_cat, linelist$outcome, useNA = "always") # tabloyu nesne olarak kaydet
age_by_outcome   # tabloyu yazdır
```

### Oranlar {.unnumbered}  

Oranları elde etmek için yukarıdaki tabloyu prop.table() aktarın geçirin. Oranların (1) satırlardan mı, (2) sütunlardan mı yoksa tüm tablodan mı (3) olmasını istediğinizi belirtmek için margins = argümanını kullanın. Kolay anlaşılmasını sağlamak için, 2 basamak belirterek tabloyu temel R’daki round() fonksiyonuna yönlendiririz.   

```{r}
# yukarıda tanımlanan tablo oranlarını, satırlara göre, yuvarlanmış olarak alın
prop.table(age_by_outcome, 1) %>% round(2)
```

### Toplamlar {.unnumbered}  

Satır ve sütun toplamlarını eklemek için tabloyu addmargins() fonksiyonuna iletin. Bu fonksiyon hem sayılar hem de oranlar için geçerlidir.
"
```{r}
addmargins(age_by_outcome)
```

### Veri çerçevesine dönüştürmek  {.unnumbered}  

Bir tablo() nesnesini doğrudan bir veri çerçevesine dönüştürmek kolay değildir. Bir yaklaşım aşağıda gösterilmiştir:

1. tabloyu useNA = "always" değişkenini kullanmadan oluşturun. Bunun yerine forcats'tan fct_explicit_na() fonksiyonu ile NA değerlerini “(Missing)”e dönüştürün.
2. Toplamları (isteğe bağlı) addmargins() fonkisyonuna yönlendirerek ekleyin
3. Temel R fonksiyonuna tünelleme için  as.data.frame.matrix() fonksiyonunu kullanın 
4. İlk sütunun adını belirterek tabloyu rownames_to_column() tibble fonksiyonuna aktarın
5. Tabloyu istediğiniz gibi yazdırın, görüntüleyin veya dışa aktarın. Bu örnekte, Sunum için tablolar sayfasında açıklandığı gibi flextable paketinden flextable() fonksiyonu kullanılmıştır. Bu şekilde tablo RStudio görüntüleyici bölmesine HTML görüntüsü olarak yazdırılacaktır.
  

```{r, warning=F, message=F}
table(fct_explicit_na(linelist$age_cat), fct_explicit_na(linelist$outcome)) %>% 
  addmargins() %>% 
  as.data.frame.matrix() %>% 
  tibble::rownames_to_column(var = "Age Category") %>% 
  flextable::flextable()
```




<!-- ======================================================= -->

## Kaynaklar {  }

Bu sayfadaki bilgilerin çoğu şu kaynaklardan ve çevrimiçi görüntülerden uyarlanmıştır:

[gtsummary](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html)  

[dplyr](https://dplyr.tidyverse.org/articles/grouping.html)

