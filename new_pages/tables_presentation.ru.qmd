
# Таблицы для презентации { }  


```{r echo=FALSE, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}

linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds")) 

border_style = officer::fp_border(color="black", width=1)

pacman::p_load(
  rio,            # импорт/экспорт
  here,           # путь к файлу
  flextable,      # создать таблицы HTML 
  officer,        # функции помощника для таблиц
  tidyverse)      # управление данными, выводы и визуализация 

table <- linelist %>% 
  # Фильтр
  ########
  #filter(!is.na(outcome) & hospital != "Missing") %>%  # Удаление случаев с отсутствующими исходами или больницами
  
  # Получение суммарных значений по группе больница - исход
  ###############################################
  group_by(hospital, outcome) %>%                      # Сгруппировать данные
  summarise(                                           # Создать новые сводные колонки по интересующим показателям
    N = n(),                                            # Количество строк для каждой группы исходов по больнице     
    ct_value = median(ct_blood, na.rm=T)) %>%           # медианное значение CT для каждой группы
  
  # добавить итого
  ############
  bind_rows(                                           # Связать предыдущую таблицу с этой мини-таблицей итогов
    linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Группировка только по исходам, но не по больницам    
      summarise(
        N = n(),                                       # Количество строк для всего набора данных     
        ct_value = median(ct_blood, na.rm=T))) %>%     # Медиана CT по всему набору данных
  
  # Поворот по ширине и форматирование
  ########################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # Поворот от длины к ширине
    values_from = c(ct_value, N),                       # новые значения из столбцов ct и count (подсчет)
    names_from = outcome) %>%                           # новые названия столбцов из исходов
  mutate(                                              # Добавить новые колонки 
    N_Known = N_Death + N_Recover,                               # количество с известным исходом
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # процент умерших (с точностью до десятичной дроби)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # процент выздоровевших (с точностью до десятичной дроби)
  select(                                              # Переупорядочить столбцы
    hospital, N_Known,                                   # Вводные столбцы
    N_Recover, Pct_Recover, ct_value_Recover,            # Столбцы выздоровевших
    N_Death, Pct_Death, ct_value_Death)  %>%             # Столбцы со смертельным исходом
  arrange(N_Known) %>%                                 # Упорядочить строки от низшей к высшей (итоговая строка внизу)

  # форматирование
  ############
  flextable() %>% 
  add_header_row(
    top = TRUE,                # Новый заголовок располагается поверх существующей строки заголовков
    values = c("Hospital",     # Значения заголовков для каждого столбца ниже
               "Total cases with known outcome", 
               "Recovered",    # Это будет заголовок верхнего уровня для этого и двух следующих столбцов
               "",
               "",
               "Died",         # Это будет заголовок верхнего уровня для этого и двух следующих столбцов
               "",             # Оставить пустым, так как он будет объединен с "Умершие"
               "")) %>% 
    set_header_labels(         # Переименовать столбцы в исходной строке заголовка
      hospital = "", 
      N_Known = "",                  
      N_Recover = "Total",
      Pct_Recover = "% of cases",
      ct_value_Recover = "Median CT values",
      N_Death = "Total",
      Pct_Death = "% of cases",
      ct_value_Death = "Median CT values")  %>% 
  merge_at(i = 1, j = 3:5, part = "header") %>% # Горизонтальное объединение столбцов 3 - 5 в новой строке заголовка
  merge_at(i = 1, j = 6:8, part = "header") %>%  
  border_remove() %>%  
  theme_booktabs() %>% 
  vline(part = "all", j = 2, border = border_style) %>%   # в столбце 2 
  vline(part = "all", j = 5, border = border_style) %>%   # в столбце 5
  merge_at(i = 1:2, j = 1, part = "header") %>% 
  merge_at(i = 1:2, j = 2, part = "header") %>% 
  width(j=1, width = 2.7) %>% 
  width(j=2, width = 1.5) %>% 
  width(j=c(4,5,7,8), width = 1) %>% 
  flextable::align(., align = "center", j = c(2:8), part = "all") %>% 
  bg(., part = "body", bg = "gray95")  %>% 
  #bg(., j=c(1:8), i= ~ hospital == "Military Hospital", part = "body", bg = "#91c293") %>% 
  bg(j = 7, i = ~ Pct_Death >= 55, part = "body", bg = "red") %>% 
  colformat_num(., j = c(4,7), digits = 1) %>%
  bold(i = 1, bold = TRUE, part = "header") %>% 
  bold(i = 7, bold = TRUE, part = "body")

table
```


На этой странице показано, как с помощью пакета **flextable** преобразовать блоки сводных данных в таблицы, готовые для презентации. Такие таблицы можно вставлять в слайды Powerpoint, HTML-страницы, документы PDF или Word и т.д.  

Следует понимать, что *перед* использованием пакета **flextable** необходимо создать сводную таблицу в виде блока данных. Используйте методы со страниц [Описательные таблицы](tables_descriptive.ru.qmd) и [Поворот данных](pivoting.ru.qmd) такие как табуляция, перекрестная табуляция, поворот и вычисление описательной статистики. Полученный датафрейм можно передать в пакет **flextable** для форматирования на экране.   

Существует множество других пакетов R, которые могут быть использованы для создания таблиц для представления информации, но на этой странице мы остановились на пакете **flextable**. Пример с использованием пакета **knitr** и его функции `kable()` можно найти на странице [Отслеживание контактов](contact_tracing.ru.qmd). Аналогичным образом пакет **DT** освещен на странице [Информационные панели с Shiny](shiny_basics.ru.qmd). Другие пакеты, такие как **GT** и **huxtable**, упоминаются на странице [Рекомендованные пакеты](packages_suggested.ru.qmd).  



<!-- ======================================================= -->
## Подготовка {  }

### Загрузка пакетов {.unnumbered} 

Установите и загрузите пакет **flextable**. В данном руководстве мы делаем акцент на `p_load()` из пакета **pacman**, которая при необходимости устанавливает пакет **и** загружает его для использования. Также можно загружать пакеты с помощью `library()` из **base** R. Более подробную информацию о пакетах R см. на странице [Основы R](basics.ru.qmd).  

```{r}
pacman::p_load(
  rio,            # импорт/экспорт
  here,           # путь к файлу
  flextable,      # создать таблицу HTML 
  officer,        # функция помощника для таблиц
  tidyverse)      # управление данными, выводы и визуализация

```

### Импорт данных {.unnumbered}  

Для начала мы импортируем очищенный построчный список случаев из смоделированной эпидемии лихорадки Эбола. Если вы хотите проследить за ходом работы, <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>щелкните мышью, чтобы загрузить "чистый" построчный список </a> (в виде файла .rds). Импорт данных с помощью функции `import()` из пакета **rio** (она работает со многими типами файлов, такими как .xlsx, .csv, .rds - подробнее см. на странице [Импорт и экспорт](importing.ru.qmd)). 


```{r, echo=F}
# импорт построчного списка в R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# импорт построчного списка 
linelist <- import("linelist_cleaned.rds")
```

Первые 50 строк построчного списка отображаются ниже.

```{r, message=FALSE, echo=F}
# отображение данных построчного списка в виде таблицы
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Подготовка таблицы {.unnumbered}  

Ниже приведен пример из страницы [Описательные таблицы](tables_descriptive.ru.qmd) преобразования построчного списка случаев в датафрейм, содержащий сводные данные об исходах и значениях CT по больницам, со строкой "Итого" в нижней части. Результат сохраняется в формате `table`.  
*Перед* началом использования пакета**flextable** необходимо *создать* таблицу в виде блока данных. О том, как создать датафрейм с помощью таких пакетов, как **janitor** и **dplyr**, читайте на страницах [Описательные таблицы] и [Поворот данных]. Вы должны расположить содержимое в строках и столбцах так, как вы хотите его отобразить. Затем датафрейм будет передан в **flextable** для его отображения с использованием цветов, заголовков, шрифтов и т.д. 
  
Ниже приведен пример из страницы [Описательные таблицы](tables_descriptive.ru.qmd) преобразования `построчного списка` в датафрейм, содержащий сводные данные об исходах и значениях CT по больницам, с итоговой строкой внизу. Выходные данные сохраняются в формате `table`. 

```{r message=FALSE, warning=FALSE}
table <- linelist %>% 
  
  # Получение суммарных значений по группам исходов в больнице
  ###############################################
  group_by(hospital, outcome) %>%                      # Сгруппировать данные
  summarise(                                           # Создать новые сводные столбцы по интересующим показателям
    N = n(),                                            # Количество строк в каждой группе исходов по больнице     
    ct_value = median(ct_blood, na.rm=T)) %>%           # медианное значение СТ в каждой группе
  
  # добавить итого
  ############
  bind_rows(                                           # Связать предыдущую таблицу с этой мини-таблицей итогов
    linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Группировка только по исходам, но не по больницам    
      summarise(
        N = n(),                                       # Количество строк для всего набора данных     
        ct_value = median(ct_blood, na.rm=T))) %>%     # Медиана CT для всего набора данных
  
  # Поворот по ширине и форматирование
  ########################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # Поворот от длины к ширине
    values_from = c(ct_value, N),                       # новые значения из столбцов ct и count (подсчет)
    names_from = outcome) %>%                           # новые названия столбцов взяты из исходов
  mutate(                                              # Добавить новые столбцы
    N_Known = N_Death + N_Recover,                               # количество с известным исходом
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # процент умерших (с точностью до десятичной дроби)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # процент выздоровевших (с точностью до десятичной дроби)
  select(                                              # Переупорядочить столбцы
    hospital, N_Known,                                   # Вводные столбцы
    N_Recover, Pct_Recover, ct_value_Recover,            # Столбцы выздоровевших
    N_Death, Pct_Death, ct_value_Death)  %>%             # Столбцы со смертельным исходом
  arrange(N_Known)                                    # Расположите строки от нижней к верхней (итоговая строка внизу)

table  # печать

```




<!-- ======================================================= -->
## Базовая таблица flextable {  }

### Создать flextable {.unnumbered}  

Для создания и управления объектами **flextable** мы сначала пропускаем датафрейм через функцию `flextable()`. Результат сохраняем под именем `my_table`.  

```{r}

my_table <- flextable(table) 
my_table

```

После этого мы можем последовательно пропустить объект `my_table` через другие функции форматирования **flextable**.  

На этой странице для наглядности мы будем сохранять таблицу на промежуточных шагах под именем `my_table`, добавляя понемногу функции **flextable**. Если вы хотите увидеть *весь* код от начала до конца, написанный одним блоком, посетите раздел [Весь код полностью](#tbl_pres_all) ниже. 

Общий синтаксис каждой строки кода **flextable** выглядит следующим образом:

* `function(table, i = X, j = X, part = "X")`, где:
  * Функция "function" может быть одной из множества различных функций, таких как `width()` для определения ширины столбцов, `bg()` для установки цвета фона, `align()` для установки выравнивания текста по центру/вправо/влево и т.д. 
  * `table = ` это название блока данных, хотя оно не обязательно, если датафрейм по каналу передается в функцию.  
  * `part = ` указывает, к какой части таблицы применяется функция. Например, "заголовок", "тело" или "все". 
  * `i = ` задает *строку*, к которой следует применить функцию, где 'X' - номер строки. Если строк несколько, например, с первой по третью, то можно указать: `i = c(1:3)`. Обратите внимание, что если выбрано значение 'body', то первый ряд начинается из-под раздела заголовка.
  * `j = ` указывает *столбец*, к которому следует применить функцию, где 'x' - номер или название столбца. Если столбцов несколько, например, пятый и шестой, то можно указать: `j = c(5,6)`. 
  
Полный список функций форматирования **flextable** можно найти [здесь](https://davidgohel.github.io/flextable/reference/index.html) или просмотреть всю информацию, введя `?flextable`.


### Ширина столбца {.unnumbered}

Мы можем использовать функцию `autofit()`, которая красиво растягивает таблицу так, что в каждой ячейке остается только одна строка текста. Функция `qflextable()` является удобным сокращением для `flextable()` и `autofit()`.  

```{r}

my_table %>% autofit()

```

Однако это не всегда уместно, особенно если в ячейках содержатся очень длинные значения, в результате чего таблица может не поместиться на странице. 

Вместо этого мы можем задать ширину с помощью функции `width()`. Чтобы понять, какое значение ширины следует задать, нужно немного поиграть. В приведенном ниже примере мы задаем разную ширину для столбца 1, столбца 2 и столбцов с 4 по 8. 

```{r}

my_table <- my_table %>% 
  width(j=1, width = 2.7) %>% 
  width(j=2, width = 1.5) %>% 
  width(j=c(4,5,7,8), width = 1)

my_table
  
```

### Заголовки столбцов {.unnumbered}

Мы хотим получить более четкие заголовки для облегчения интерпретации содержимого таблицы.

Для этой таблицы мы хотим добавить второй слой заголовков, чтобы столбцы, охватывающие одни и те же подгруппы, можно было сгруппировать вместе. Для этого мы используем функцию `add_header_row()` с `top = TRUE`. Мы указываем новое название каждого столбца в `values = `, оставляя пустые значения `""` для столбцов, которые, как мы знаем, будут объединены позже.  

Мы также переименовываем названия заголовков в теперь уже втором заголовке в отдельной команде `set_header_labels()`.  

Наконец, чтобы "объединить" определенные заголовки столбцов в верхнем заголовке, мы используем команду `merge_at()` для объединения заголовков столбцов в строке верхнего заголовка.  

```{r}
my_table <- my_table %>% 
  
  add_header_row(
    top = TRUE,                # Новый заголовок располагается поверх существующей строки заголовков
    values = c("Hospital",     # Значения заголовков для каждого столбца ниже
               "Total cases with known outcome", 
               "Recovered",    # Это будет заголовок верхнего уровня для этого и двух следующих столбцов
               "",
               "",
               "Died",         # Это будет заголовок верхнего уровня для этого и двух следующих столбцов
               "",             # Оставить пустым, так как он будет объединен с "Умершие"
               "")) %>% 
    
  set_header_labels(         # Переименование столбцов в исходной строке заголовка
      hospital = "", 
      N_Known = "",                  
      N_Recover = "Total",
      Pct_Recover = "% of cases",
      ct_value_Recover = "Median CT values",
      N_Death = "Total",
      Pct_Death = "% of cases",
      ct_value_Death = "Median CT values")  %>% 
  
  merge_at(i = 1, j = 3:5, part = "header") %>% # Горизонтальное объединение столбцов 3 - 5 в новой строке заголовка
  merge_at(i = 1, j = 6:8, part = "header")     # Горизонтальное объединение столбцов 6-8 в новой строке заголовка

my_table  # print

```

### Границы и фон {.unnumbered}  

С помощью различных функций **flextable** можно настроить границы, внутренние линии и т.д. Часто проще начать с удаления всех существующих границ с помощью функции `border_remove()`.  

Затем можно применить стандартные темы границ, передав таблицу в функции `theme_box()`, `theme_booktabs()` или `theme_alafoli()`.  

Добавить вертикальные и горизонтальные линии можно с помощью различных функций. `hline()` и `vline()` добавляют линии в указанную строку или столбец соответственно. В каждой из них необходимо указать `part=` либо как "все", либо как "тело", либо как "заголовок". Для вертикальных строк следует указать столбец в `j = `, а для горизонтальных - строку в `i = `. Другие функции, такие как `vline_right()`, `vline_left()`, `hline_top()` и `hline_bottom()`, добавляют линии только к внешним сторонам.  

Во всех этих функциях сам стиль линии должен быть указан в `border = ` и должен быть результатом отдельной команды, использующей функцию `fp_border()` из пакета **officer**. Эта функция позволяет определить ширину и цвет линии. Ее можно задать над командами таблицы, как показано ниже.  

```{r}
# определить стиль для линии границы
border_style = officer::fp_border(color="black", width=1)

# добавить линии границ в таблицу
my_table <- my_table %>% 

  # удалить все существующие границы
  border_remove() %>%  
  
  # добавить горизонтальные линии с помощью заранее заданной настройки темы
  theme_booktabs() %>% 
  
  # добавить вертикальные линии для разделения разделов Выздоровевшие и  Умершие
  vline(part = "all", j = 2, border = border_style) %>%   # at column 2 
  vline(part = "all", j = 5, border = border_style)       # at column 5

my_table
```

### Шрифт и выравнивание {.unnumbered}

Мы выравниваем по центру все столбцы, кроме крайнего левого, с названиями больниц, используя функцию `align()` из **flextable**.

```{r}
my_table <- my_table %>% 
   flextable::align(align = "center", j = c(2:8), part = "all") 
my_table
```

Кроме того, мы можем увеличить размер шрифта заголовка и изменить его на полужирный. Мы также можем выделить жирным шрифтом итоговую строку.  

```{r}

my_table <-  my_table %>%  
  fontsize(i = 1, size = 12, part = "header") %>%   # настроить размер шрифта заголовка
  bold(i = 1, bold = TRUE, part = "header") %>%     # настроить полужирный шрифт заголовка
  bold(i = 7, bold = TRUE, part = "body")           # скорректировать полужирный шрифт итогового ряда (ряд 7 тела таблицы)

my_table

```


Мы можем обеспечить отображение в столбцах пропорций только одного десятичного знака с помощью функции `colformat_num()`. Заметим, что это можно было бы сделать и на этапе управления данными с помощью функции `round()`. 

```{r}
my_table <- colformat_num(my_table, j = c(4,7), digits = 1)
my_table
```

### Объединение ячеек {.unnumbered}  

Точно так же, как мы объединяем ячейки по горизонтали в строке заголовка, мы можем объединять ячейки по вертикали, используя функцию `merge_at()` и указывая строки (`i`) и столбцы (`j`). Здесь мы объединяем значения "Больница" и "Всего случаев с известным исходом" по вертикали, чтобы дать им больше места.   

```{r}
my_table <- my_table %>% 
  merge_at(i = 1:2, j = 1, part = "header") %>% 
  merge_at(i = 1:2, j = 2, part = "header")

my_table
```

### Цвнт фонаr {.unnumbered}

Чтобы отличить содержимое таблицы от заголовков, мы можем добавить дополнительное форматирование. Например, изменить цвет фона. В данном примере мы изменим цвет фона таблицы на серый.

```{r}
my_table <- my_table %>% 
    bg(part = "body", bg = "gray95")  

my_table 
```


<!-- ======================================================= -->
## Условное форматирование {  }

Мы можем выделить все значения в столбце, которые удовлетворяют определенному правилу, например, где более 55% случаев умерли. Просто подставьте критерий в аргумент `i = ` или `j = `, предваряя его тильдой `~`. Ссылайтесь на столбец в блоке данных, а не на отображаемые значения заголовка.  

```{r}

my_table %>% 
  bg(j = 7, i = ~ Pct_Death >= 55, part = "body", bg = "red") 

```



Или мы можем выделить всю строку, удовлетворяющую определенному критерию, например, интересующую нас больницу. Для этого достаточно удалить спецификацию столбца (`j`), чтобы критерии распространялись на все столбцы.


```{r}

my_table %>% 
  bg(., i= ~ hospital == "Military Hospital", part = "body", bg = "#91c293") 

```

## Весь код полностью {#tbl_pres_all}  


Ниже мы покажем весь код полностью из приведенных выше разделов.  

```{r}  

border_style = officer::fp_border(color="black", width=1)

pacman::p_load(
  rio,            # импорт/экспорт
  here,           # путь к файлу
  flextable,      # создать таблицы HTML 
  officer,        # функции помощника для таблиц
  tidyverse)      # управление данными, выводы и визуализация 

table <- linelist %>% 

  # Получение суммарных значений по группам исходов в больнице
  ###############################################
  group_by(hospital, outcome) %>%                      # Сгруппировать данные
  summarise(                                           # Создание новых сводных столбцов по интересующим показателям
    N = n(),                                            # Количество строк в каждой группе исходов по больнице     
    ct_value = median(ct_blood, na.rm=T)) %>%           # медианное значение СТ в каждой группе
  
  # добавить итого
  ############
  bind_rows(                                           # Связать предыдущую таблицу с этой мини-таблицей итогов
    linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Группировка только по исходам, но не по больницам    
      summarise(
        N = n(),                                       # Количество строк для всего набора данных     
        ct_value = median(ct_blood, na.rm=T))) %>%     # Медиана CT для всего набора данных
  
  # Поворот по ширине и формирование
  ########################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # Поворот из длинной в широкую
    values_from = c(ct_value, N),                       # новые значения из столбцов ct и count (подсчет)
    names_from = outcome) %>%                           # новые названия столбцов взяты из исходов
  mutate(                                              # Добавить новые столбцы
    N_Known = N_Death + N_Recover,                               # количество с известным исходом
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # процент умерших (с точностью до десятичной дроби)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # процент выздоровевших (с точностью до десятичной дроби)
  select(                                              # Переупорядочить столбцы
    hospital, N_Known,                                   # Вводные столбцы
    N_Recover, Pct_Recover, ct_value_Recover,            # Столбцы выздоровевших 
    N_Death, Pct_Death, ct_value_Death)  %>%             # Столбцы умерших
  arrange(N_Known) %>%                                 # Расположите строки от нижней к верхней (итоговая строка внизу)

  # форматирование
  ############
  flextable() %>%              # таблица подается сверху
  add_header_row(
    top = TRUE,                # Новый заголовок располагается поверх существующей строки заголовков
    values = c("Hospital",     # Значения заголовков для каждого столбца ниже
               "Total cases with known outcome", 
               "Recovered",    # Это будет заголовок верхнего уровня для этого и двух следующих столбцов
               "",
               "",
               "Died",         # Это будет заголовок верхнего уровня для этого и двух следующих столбцов
               "",             # Оставить пустым, так как он будет объединен с "Умершими"
               "")) %>% 
    set_header_labels(         # Переименовать столбцы в исходной строке заголовка
      hospital = "", 
      N_Known = "",                  
      N_Recover = "Total",
      Pct_Recover = "% of cases",
      ct_value_Recover = "Median CT values",
      N_Death = "Total",
      Pct_Death = "% of cases",
      ct_value_Death = "Median CT values")  %>% 
  merge_at(i = 1, j = 3:5, part = "header") %>% # Горизонтальное объединение столбцов 3 - 5 в новую строку заголовка
  merge_at(i = 1, j = 6:8, part = "header") %>%  
  border_remove() %>%  
  theme_booktabs() %>% 
  vline(part = "all", j = 2, border = border_style) %>%   # в столбце 2 
  vline(part = "all", j = 5, border = border_style) %>%   # в столбце 5
  merge_at(i = 1:2, j = 1, part = "header") %>% 
  merge_at(i = 1:2, j = 2, part = "header") %>% 
  width(j=1, width = 2.7) %>% 
  width(j=2, width = 1.5) %>% 
  width(j=c(4,5,7,8), width = 1) %>% 
  flextable::align(., align = "center", j = c(2:8), part = "all") %>% 
  bg(., part = "body", bg = "gray95")  %>% 
  bg(., j=c(1:8), i= ~ hospital == "Military Hospital", part = "body", bg = "#91c293") %>% 
  colformat_num(., j = c(4,7), digits = 1) %>%
  bold(i = 1, bold = TRUE, part = "header") %>% 
  bold(i = 7, bold = TRUE, part = "body")

table
```


<!-- ======================================================= -->
## Сохранение вашей таблицы {  }

Таблица может быть интегрирована в выходные данные различными способами. 

### Сохранить одну таблицу {.unnumbered}

Таблицы можно экспортировать в Word, PowerPoint или HTML, а также в виде файлов изображений (PNG). Для этого воспользуйтесь одной из следующих функций:

* `save_as_docx()`  
* `save_as_pptx()`  
* `save_as_image()`  
* `save_as_html()`  

Например, ниже мы сохраняем нашу таблицу в виде документа word. Обратите внимание на синтаксис первого аргумента - вы можете просто указать имя объекта flextable, например `my_table`, или дать ему " название", как показано ниже (название - "my table"). Если название задано, то оно будет отображаться как заголовок таблицы в Word. Мы также демонстрируем код для сохранения изображения в формате PNG.  

```{r message=FALSE, warning=FALSE, eval=F}
# Отредактируйте `my table` так, как это необходимо для названия таблицы.  
save_as_docx("my table" = my_table, path = "file.docx")

save_as_image(my_table, path = "file.png")
```

Обратите внимание, что для сохранения таблицы flextable в виде изображения требуются пакеты `webshot` или `webshot2`. Изображения могут получиться с прозрачным фоном.

Если вы хотите просмотреть "живую" версию **flextable** в формате предполагаемого документа, используйте `print()` и укажите в `preview =` одно из следующих значений. Документ будет "всплывать", открываясь на вашем компьютере в указанной программе, но не будет сохранен. Это может быть полезно для проверки, поместится ли таблица на одной странице/слайде, или для быстрого копирования ее в другой документ, можно использовать метод печати с аргументом предпросмотра, установленным в "pptx" или "docx".  

```{r, eval=F}
print(my_table, preview = "docx") # пример документа Word
print(my_table, preview = "pptx") # пример Powerpoint
```

### Печать таблицы в R markdown {.unnumbered}  

Эта таблица может быть интегрирована в автоматизированный документ, выходной документ в R markdown, если объект таблицы вызывается в фрагменте R markdown. Это означает, что таблица может быть обновлена в рамках отчета, в котором данные могут измениться, так что цифры могут быть обновлены.

Подробнее см. на странице [Отчеты с помощью R Markdown](rmarkdown.ru.qmd) данного руководства. 

<!-- ======================================================= -->
## Ресурсы {  }

Полная версия книги **flextable** находится здесь: https://ardata-fr.github.io/flextable-book/.
Сайт Github находится [здесь](https://davidgohel.github.io/flextable/)  
Руководство по всем функциям **flextable** можно найти [здесь](https://davidgohel.github.io/flextable/reference/index.html)

Галерея примеров красивых таблиц **flextable** с кодом доступна [здесь](https://ardata-fr.github.io/flextable-gallery/gallery/)  
