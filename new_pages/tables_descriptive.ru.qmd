# Описательные таблицы { }

```{r out.width = c('75%'), fig.align='center', fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "descriptive_tables.png"))
```

На данной странице демонстрируется использование **janitor**, **dplyr**, **gtsummary**, **rstatix** и **базового** R для обобщения данных и создания таблиц с описательной статистикой. 

*Эта страница рассматривает, как *создавать* базовые таблицы, а страница [Таблицы для презентации](tables_presentation.ru.qmd) рассматривает, как их красиво форматировать и печатать.*  

У каждого из этих пакетов есть преимущества и недостатки в плане простоты кода, доступности выходных данных, качества печати выходных данных. С помощью информации на этой странице вы можете решить, какой подход работает в вашем сценарии.  


У вас есть несколько вариантов при проведении табуляции и кросс-табуляции с помощью обобщающих таблиц. Некоторые из факторов, которые нужно принять во внимание, включают простоту кода, его адаптируемость, желаемые выходные данные (печать в консоли R, как датафрейм, либо "красивые" изображения .png/.jpeg/.html), а также простоту последующей обработки. При выборе инструмента для своей ситуации рассмотрите указанные ниже аспекты.

* Используйте `tabyl()` из **janitor** для подготовки и "оформления" таблиц табуляциии и кросс-табуляции  
* Используйте `get_summary_stats()` из **rstatix**, чтобы легко сгенерировать датафреймы числовой сводной статистики для нескольких столбцов и/или групп  
* Используйте `summarise()` и `count()` из **dplyr** для более сложной статистики, получения выходных данных в формате аккуратных данных, либо подготовки данных для `ggplot()`  
* Используйте `tbl_summary()` из **gtsummary** для подготовки детальных готовых к публикации таблиц  
* Используйте `table()` из **базового** R, если у вас нет доступа к указанным выше пакетам  


<!-- ======================================================= -->
## Подготовка {  }


### Загрузка пакетов {.unnumbered}

Этот фрагмент кода показывает загрузку пакетов для анализа. В этом руководстве мы подчеркиваем использование `p_load()` из **pacman**, которая устанавливает пакет, если необходимо, *и* загружает его для использования. Вы можете также загрузить установленные пакеты с помощью `library()` из **базового** R. См. страницу [Основы R](basics.ru.qmd) для получения более подробной информации о пакетах R.  


```{r, warning=F, message=F}
pacman::p_load(
  rio,          # импорт файлов
  here,         # путь к файлу
  skimr,        # получение обзора данных
  tidyverse,    # управление данными + графика ggplot2 
  gtsummary,    # сводная статистика и тесты
  rstatix,      # сводная статистика и статистические тесты
  janitor,      # добавление итогов и процентов к таблицам
  scales,       # простая конвертация долей в проценты  
  flextable     # конвертация таблиц в красивые рисунки
  )
```

### Импорт данных {.unnumbered}

Мы импортируем набор данных о случаях имитированной эпидемии Эболы. Если вы хотите выполнять действия параллельно, <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>кликните, чтобы скачать "чистый" построчный список</a> (как .rds файл). Импортируйте ваши данные с помощью функции `import()` из пакета **rio** (она работает с разными файлами, такими как .xlsx, .rds, .csv - см. детали на странице [Импорт и экспорт](importing.ru.qmd)).  

```{r, echo=F}
# импорт построчного списка в R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# импорт построчного списка
linelist <- import("linelist_cleaned.rds")
```

Первые 50 строк построчного списка отображены ниже.

```{r, message=FALSE, echo=F}
# отображаем данные построчного списка в виде таблицы
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```





<!-- ======================================================= -->
## Просмотр данных {  }

### пакет **skimr** {.unnumbered}

С помощью пакета **skimr** вы можете получить детальную информацию и эстетически приятный обзор по каждой переменной в вашем наборе данных. Более подробно о **skimr** можно прочитать на [странице github](https://github.com/ropensci/skimr).  

Ниже функция `skim()` применяется ко всему датафрейму `linelist`. Создается обзор датафрейма и сводная информация по каждому столбцу (по классам).    

```{r eval=F}
## получаем информацию о каждой переменной в наборе данных 
skim(linelist)
```

```{r  echo=F}
# гистограммы спарклайн не отображаются корректно, поэтому избегайте их.
skim_without_charts(linelist)
```



Вы можете также использовать функцию `summary()` из **базового** R, чтобы получить информацию о всем наборе данных, но такие выходные данные может быть сложнее прочитать, чем при использовании **skimr**. Поэтому выходной результат не приводится ниже в целях экономии пространства на странице.  

```{r, eval=F}
## получаем информацию о каждом столбце в наборе данных 
summary(linelist)
```


### Сводная статистика {.unnumbered} 

Вы можете использовать функции **базового** R для получения сводной статистики по числовому столбцу. Вы можете получить наиболее важную сводную статистику для числового столбца, используя `summary()`, как показано ниже. Обратите внимание, что необходимо уточнять набор данных, как это сделано ниже.  

```{r}
summary(linelist$age_years)
```

Вы можете получить доступ и сохранить конкретную часть с помощью индексных квадратных скобок [ ]:  

```{r}
summary(linelist$age_years)[[2]]            # выдать только 2-й элемент
# эквивалент, альтернатива указанному выше по имени элемента
# summary(linelist$age_years)[["1st Qu."]]  
```

Вы можете получить отдельные статистические показатели с помощью **базовых** функций R, таких как `max()` (максимум), `min()` (минимум), `median()` (медиана), `mean()` (среднее значение), `quantile()` (квантиль), `sd()` (стандартное отклонение) и `range()` (диапазон). См. полный список на странице [Основы R](basics.ru.qmd).  

<span style="color: orange;">**_ВНИМАНИЕ:_** Если ваши данные содержат отсутствующие значения, R хочет, чтобы вы это знали, поэтому выдаст `NA`, если только вы не укажете в указанных выше математических фукнциях, что вы хотите, чтобы R игнорировал отсутствующие значения, с помощью аргумента `na.rm = TRUE`.</span>


Вы можете использовать функцию `get_summary_stats()` из **rstatix**, чтобы получить сводную статистику *в формате датафрейма*. Это может быть полезным для проведения последующих операций или составления графика с числами. См. страницу [Простые статистические тесты](stat_tests.ru.qmd) для получения дополнительной информации о пакете **rstatix** и его функциях.  

```{r}
linelist %>% 
  get_summary_stats(
    age, wt_kg, ht_cm, ct_blood, temp,  # столбцы, для которых нужен расчет
    type = "common")                    # получаемая сводная статистика

```





## пакет **janitor** {#tbl_janitor}  

Пакет **janitor** предлагает функцию `tabyl()` для создания табуляций и кросс-табуляций, которые могут быть "оформлены" или модифицированы с помощью функций-помощников, чтобы отображать проценты, доли, подсчет количества и т.п.  

Ниже мы передаем датафрейм `linelist` в функции **janitor** и печатаем результат. Если нужно, вы можете также сохранить получившиеся в результате таблицы с помощью оператора присваивания `<-`.  

### Простая таблица tabyl {.unnumbered}  

Использование `tabyl()` по умолчанию применительно к конретному столбцу создает уникальные значения, подсчеты и постолбцовые "проценты" (на самом деле доли). Доли могут иметь много десятичных знаков. Вы можете откорректировать количество знаков после запятой с помощью `adorn_rounding()`, как описано ниже.   

```{r}
linelist %>% tabyl(age_cat)
```
Как вы видите выше, если есть отсутствующие значения, они отображаются в строке, подписанной как `<NA>`. Вы можете их заблокировать с помощью `show_na = FALSE`. Если нет отсутствующих значений, эта строка не будет появляться. Если есть отсутствующие значения, все доли будут приведены как сырые (знаменатель включает количество `NA`) и "валидные" (знаменатель исключает количество `NA`).  

Если столбец относится к классу Фактор и только некоторые уровни присутствуют в ваших данных, все уровни все равно будут отображены в таблице. Вы можете заблокировать этот параметр, уточнив `show_missing_levels = FALSE`. Более детально читайте об этом на странице [Факторы](factors.ru.qmd).  

### Кросс-табуляция {.unnumbered}  

Подсчет в кросс-табуляции достигается путем добавления одного или более дополнительных столбцов внутри `tabyl()`. Обратите внимание, чтор теперь будет выдан только подсчет, а проценты можно добавить с помощью дополнительных шагов, указанных ниже.  

```{r}
linelist %>% tabyl(age_cat, gender)
```

### "Оформление" таблицы tabyl {#tbl_adorn .unnumbered}  

Используйте функции "adorn" ("оформление") из **janitor**, чтобы добавить итого или конвертировать в доли, проценты, либо как-то иначе откорректировать отображение. Часто необходимо составить канал для таблицы tabyl и применить к ней несколько из этих функций.  


Функция            | Результат                          
-------------------|--------------------------------
`adorn_totals()`   | Добавляет итого (`where = ` "row", "col", or "both"). Установите `name =` для "Total" (Итого).  
`adorn_percentages()` | Конвертирует количество в доли, с знаменателем `denominator = ` "row" (строка), "col" (столбец), или "all" (все)  
`adorn_pct_formatting()` | Конвертирует доли в проценты. Укажите `digits =`. Удалите символ "%" с помощью `affix_sign = FALSE`.  
`adorn_rounding()` | Чтобы округлить пропорции до нужного количества десятичных знаков `digits =`. Чтобы округлить проценты, используйте `adorn_pct_formatting()` с `digits = `.  
`adorn_ns()` | Добавить подсчет абсолютного количества в таблицу долей или процентов. Укажите `position =` "rear", чтобы показать абсолютное количество в скобках, либо "front", чтобы проценты были в скобках.  
`adorn_title()` | Добавить последовательность с помощью аргументов `row_name = `(имя строки) и/или `col_name = ` (имя столбца)  

Обращайте внимание на порядок применения этих функций. Ниже приведены некоторые примеры.  

Простая одновходовая таблица с процентами вместо долей по умолчанию.  

```{r}
linelist %>%               # построчный список случаев
  tabyl(age_cat) %>%       # табуляция абсолютного количества и долей по возрастной категории
  adorn_pct_formatting()   # конвертация долей в проценты
```

Кросс-табуляция со строкой итого и процентами по строке  

```{r}
linelist %>%                                  
  tabyl(age_cat, gender) %>%                  # подсчет по возрасту и полу
  adorn_totals(where = "row") %>%             # добавляем строку итого
  adorn_percentages(denominator = "row") %>%  # конвертируем количество в доли
  adorn_pct_formatting(digits = 1)            # конвертируем доли в проценты
```

Скорректированная кросс-табуляция, чтобы отобразить и абсолютное количество и проценты.  

```{r}
linelist %>%                                  # построчный список случаев
  tabyl(age_cat, gender) %>%                  # кросс-табуляция абсолютного количества
  adorn_totals(where = "row") %>%             # добавляем строку итого
  adorn_percentages(denominator = "col") %>%  # конвертируем в доли
  adorn_pct_formatting() %>%                  # конвертируем в проценты
  adorn_ns(position = "front") %>%            # отображаем как: "абсолютное количество (процент)"
  adorn_title(                                # корректируем заголовки
    row_name = "Age Category",
    col_name = "Gender")
```



### Печать таблицы tabyl {.unnumbered}

По умолчанию таблица tabyl будет напечатана в сыром виде на вашей консоли R.  

Альтернативно, вы можете передать таблицу tabyl в **flextable**  или аналогичный пакет, чтобы распечатать "красивое" изображение на панели просмотра RStudio (Viewer), которое можно экспортировать как .png, .jpeg, .html, и т.п. Это обсуждается на странице [Таблицы для презентации](tables_presentation.ru.qmd). Обратите внимание, что при печати таким образом и использовании `adorn_titles()`, вам нужно задать `placement = "combined"`.

```{r}
linelist %>%
  tabyl(age_cat, gender) %>% 
  adorn_totals(where = "col") %>% 
  adorn_percentages(denominator = "col") %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front") %>% 
  adorn_title(
    row_name = "Age Category",
    col_name = "Gender",
    placement = "combined") %>% # необходимо для печати как картинки
  flextable::flextable() %>%    # конвертирует в красивую картинку
  flextable::autofit()          # формат на одну линию на строку 

```


### Применение к другим таблицам {.unnumbered}  

Вы можете использовать функции `adorn_*()` из **janitor** для других таблиц, например, созданных с помощью `summarise()` и `count()` из **dplyr**, либо `table()` из **базового** R. Просто передайте таблицу в соответствующую функцию из **janitor**. Например:  

```{r}
linelist %>% 
  count(hospital) %>%   # функция dplyr
  adorn_totals()        # функция janitor
```


### Сохранение таблицы tabyl {.unnumbered}  

Если вы конвертируете таблицу в "красивый" рисунок с помощью такого пакета, как **flextable**, вы можете ее сохранить с помощью функций из этого пакета - например, `save_as_html()`, `save_as_word()`, `save_as_ppt()` и `save_as_image()` из **flextable** (более подробно объясняется на странице [Таблицы для презентации](tables_presentation.ru.qmd)). Ниже таблица сохраняется как документ Word, в котором ее можно дополнительно редактировать вручную.  

```{r, eval=F}
linelist %>%
  tabyl(age_cat, gender) %>% 
  adorn_totals(where = "col") %>% 
  adorn_percentages(denominator = "col") %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front") %>% 
  adorn_title(
    row_name = "Age Category",
    col_name = "Gender",
    placement = "combined") %>% 
  flextable::flextable() %>%                     # конвертируем в изображение
  flextable::autofit() %>%                       # проверяем, что только одна линия на строку
  flextable::save_as_docx(path = "tabyl.docx")   # сохраняем как документ Word по указанному пути к файлу
```

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "tabyl_word.png"))
```

### Статистика {#janitor_age_out_stats .unnumbered}  

Вы можете применять статистические тесты к таблицам tabyl, например, `chisq.test()` или `fisher.test()` из пакета **stats**, как показано ниже. Обратите внимание, что отсутствующие значения не разрешены, поэтому они исключены из таблицы tabyl с помощью `show_na = FALSE`.  

```{r, warning=F, message=F}
age_by_outcome <- linelist %>% 
  tabyl(age_cat, outcome, show_na = FALSE) 

chisq.test(age_by_outcome)
```

Дополнительные примеры кода и советы по статистике приведены на странице [Простые статистические тесты](stat_tests.ru.qmd).  

### Другие советы {.unnumbered}  

* Включайте аргумент `na.rm = TRUE`, чтобы исключить отсутствующие значения из любого указанного выше расчета.  
* При применении любой функции-помощника `adorn_*()` к таблицам, которые были созданы не с помощью `tabyl()`, вы можете уточнить конкретные столбцы, к которым нужно применить, например, `adorn_percentage(,,,c(cases,deaths))` (уточните их в 4м неименованном аргументе). Синтаксис непростой. Рассмотрите возможность вместо этого использовать `summarise()`.  
* Более подробно вы можете прочитать на [странице по janitor](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html) и в этой [виньетке по tabyl](https://cran.r-project.org/web/packages/janitor/vignettes/tabyls.html).  




## пакет **dplyr**   

**dplyr** является частью пакетов **tidyverse** и очень часто используемым инструментом управления данными. Создание таблиц с помощью функций из **dplyr** `summarise()` и `count()` является очень полезным подходом к рассчету сводной статистики, обобщения *по группе* или для передачи таблиц в `ggplot()`. 

`summarise()` создает *новый сводный датафрейм*. Если данные *не группированы*, она выдаст датафрейм с одной строкой с указанной сводной статистикой по всему датафрейму. Если данные *сгруппированы*, новый датафрейм будет содержать по одной строке на *группу* (см. страницу [Группирование данных])(grouping.ru.qmd).  

Внутри скобок в `summarise()` вы задаете имена каждого нового сводного столбца, за которыми следует знак равно и статистическая функция, которую нужно применить.  

<span style="color: darkgreen;">**_СОВЕТ:_** Функция summarise (обобщить) работает и в британском и американском написании (`summarise()` и `summarize()`).</span>

### Сделать подсчет количества {.unnumbered}  

Самая простая функция, которую можно применить в `summarise()` - это `n()`. Оставьте скобки пустыми, чтобы подсчитать количество строк.  

```{r}
linelist %>%                 # начинаем с построчного списка
  summarise(n_rows = n())    # выдает новый сводный датафрейм со столбцом n_rows
```

Это становится более интересным, если у нас данные были до этого сгруппированы.  

```{r}
linelist %>% 
  group_by(age_cat) %>%     # группируем данные по уникальным значениям в столбце age_cat
  summarise(n_rows = n())   # выдает количество строк *в группе*
```

Указанную выше команду можно сократить, используя функцию `count()`. `count()` выполняет следующие действия:  

1) Группирует данные по заданным ей столбцам  
2) Обобщает их с помощью `n()` (создает столбец `n`)  
3) Разгруппирует данные  

```{r}
linelist %>% 
  count(age_cat)
```

Вы можете изменить имя столбца с подсчетом со значения по умолчанию `n` на что-либо другое, задав это имя в аргумент `name = `.  

Табуляция подсчетов по двум или более столбцам группирования выдается в "длинном" формате с количеством, указанным в столбце `n`. См. страницу [Поворот данных](pivoting.ru.qmd) , чтобы больше узнать о "длинном" и "широком" формате данных.  

```{r}
linelist %>% 
  count(age_cat, outcome)
```


### Показать все уровни {.unnumbered}  

Если вы делаете табуляцию по столбцу с классом *фактор*, вы можете убедиться, что показаны *все* уровни (а не только уровни со значениями в данных), добавив `.drop = FALSE` в команду `summarise()` или `count()`.  

Этот прием полезен для стандартизации ваших таблиц/графиков. Например, если вы создаете рисунки по нескольким подгруппам, либо постоянно создаете рисунок для рутинных отчетов. В каждом случае наличие значения в данных может колебаться, но вы можете определить уровни, которые будут оставаться постоянными.  

См. дополнительную информацию на странице [Факторы](factors.ru.qmd).  




### Доли {#tbl_dplyr_prop .unnumbered}  

Доли могут быть добавлены с помощью передачи таблицы в функцию `mutate()`, чтобы создать новый столбец. Определите новый столбец как столбец с подсчетом (`n` по умолчанию), разделенный на сумму столбца подсчета количества `sum()` (это выдаст вам долю).  

Обратите внимание, что в этом случае `sum()` в команде `mutate()` выдаст сумму всего столбца `n` для использования в качестве знаменателя при расчете доли. Как объяснялось на странице [Группирование данных](grouping.ru.qmd#group_summarise), *если* используется `sum()` для *группированных* данных (например, если `mutate()` идет непосредственно после команды `group_by()`), она выдаст суммы *по группам*. Как указано чуть выше, `count()` завершает свои действия *разгруппированием*. Таким образом, в этом сценарии мы получим доли по полным столбцам. 

Чтобы легко отобразить проценты, вы можете обернуть долю в функцию `percent()` из пакета **scales** (обратите внимание, что это конвертирует в текстовый класс).  

```{r}
age_summary <- linelist %>% 
  count(age_cat) %>%                     # группируем и считаем по полу (создает столбец "n")
  mutate(                                # создаем процент столбца - обратите внимание на знаменатель
    percent = scales::percent(n / sum(n))) 

# печать
age_summary
```

Ниже приведен метод расчета долей *внутри групп*. Он полагается на разные уровни группирования данных, которые селективно применяются и снимаются. Сначала данные группируются по исходу `outcome` с помощью `group_by()`. Затем применяется `count()`. Эта функция далее группирует данные по `age_cat` и выдает подсчет для каждой комбинации исхода-возрастной категории `outcome`-`age-cat`. Что важно - после того как процесс завершен, `count()` также *разгруппирует* группирование по возрастным категориям `age_cat`, так что единственным оставшимся группированием будет оригинальное группирование по исходам `outcome`. Таким образом, последний шаг расчета долей (знаменатель `sum(n)`) все еще имеет группирование по исходу `outcome`.

```{r}
age_by_outcome <- linelist %>%                  # начинаем с построчного списка
  group_by(outcome) %>%                         # группируем по исходу 
  count(age_cat) %>%                            # группируем и считаем по age_cat, а затем снимаем группировку age_cat
  mutate(percent = scales::percent(n / sum(n))) # рассчитываем процент - обратите внимание, что знаменатель по группе исхода
```

```{r, echo=F}
DT::datatable(age_by_outcome, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```




### Построение графика {.unnumbered}  

Отобразить "длинную" выходную таблицу, как показано выше, с помощью `ggplot()` достаточно просто. Данные естественным образом находятся в "длинном" формате, который естественно воспринимается `ggplot()`. См. дополнительные примепры на страницах [Основы ggplot](ggplot_basics.ru.qmd) и [Советы по использованию ggplot]((ggplot_basics.ru.qmd)).  

```{r, warning=F, message=F}
linelist %>%                      # начинаем с построчного списка
  count(age_cat, outcome) %>%     # группируем и считаем количество по двум столбцам
  ggplot()+                       # передаем новый датафрейм в ggplot
    geom_col(                     # создаем столбчатую диаграмму
      mapping = aes(   
        x = outcome,              # строим исход по оси x
        fill = age_cat,           # age_cat отражаем в заливке
        y = n))                   # строим столбец подсчета `n` по высоте
```


### Сводная статистика {.unnumbered}  

Одним из важных преимуществ **dplyr** и `summarise()` является способность выдать более продвинутые статистические сводные данные, такие как `median()` (медиана), `mean()` (среднее), `max()` (максимум), `min()` (минимум), `sd()` (стандартное отклонение) и процентили. Вы также можете использовать `sum()`, чтобы получить количество строк, которые соответствуют определенным логическим критериям. Как указано выше, эти выходные данные мы можем получить по всему датафрейму или по группам.  

Синтаксис тот же - внутри скобок `summarise()` вы задаете имена каждого нового сводного столбца, после чего идет знак равно и статистическая функция, которую нужно применить. Внутри статистической функции задайте столбец(столбцы), с которыми нужно проделать операцию и любые необходимые аргументы (например, `na.rm = TRUE` для большинства математических функций). 

Вы также можете использовать `sum()`, чтобы выдать количество строк, которые соответствуют логическим критериям. Выражение внутри считается, если оно оценено как `TRUE` (ИСТИНА). Например:  

* `sum(age_years < 18, na.rm=T)`  
* `sum(gender == "male", na.rm=T)`  
* `sum(response %in% c("Likely", "Very Likely"))`  

Ниже данные `linelist` обобщаются, чтобы описать дни задержки от появления симптомов до госпитализации (столбец `days_onset_hosp`), по больницам.  

```{r}
summary_table <- linelist %>%                                        # начинаем с построчного списка, сохраняем как новый объект
  group_by(hospital) %>%                                             # группируем все расчеты по больницам
  summarise(                                                         # выдаются только указанные ниже сводные столбцы
    cases       = n(),                                                # количество строк на группу
    delay_max   = max(days_onset_hosp, na.rm = T),                    # максимальная задержка
    delay_mean  = round(mean(days_onset_hosp, na.rm=T), digits = 1),  # средняя задержка, округленная
    delay_sd    = round(sd(days_onset_hosp, na.rm = T), digits = 1),  # стандартное отклонение задержек, округленное
    delay_3     = sum(days_onset_hosp >= 3, na.rm = T),               # количество строк с задержкой 3 или более дня
    pct_delay_3 = scales::percent(delay_3 / cases)                    # конвертирует ранее установленный столбец задержки в проценты 
  )

summary_table  # печать
```


Некоторые советы:  

* Используйте `sum()` с логическим утверждением, чтобы "посчитать" строки, которые соответствуют определенным критериям (`==`)  
* Обратите внимание на использование аргумента `na.rm = TRUE` внутри математических функций, таких как `sum()`, иначе `NA` будут выданы, если есть отсутствующие значения  
* Используйте функцию `percent()` из пакета **scales**, чтобы легко конвертировать в проценты  
  * Установите точность `accuracy = ` на 0.1 или 0.01, чтобы было 1 или два знака после запятой, соответственно  
* Используйте `round()` из **базового** R, чтобы уточнить количество десятичных знаков  
* Чтобы рассчитать эти статистические показатели для всего набора данных, используйте `summarise()` без `group_by()`  
* Вы можете создать столбцы в целях расчетов позднее (например, знаменатели), которые вы в конечном идее удалите из датафрейма с помощью `select()`.  


### Статистика по условиям {.unnumbered}  

Вам может потребоваться *статистика по условиям* - например, максимум строк, которые соответствуют определенным критериям. Это можно сделать, определив подмножество столбца с помощью квадратных скобок `[ ]`. Пример ниже выдает максимальную температуру для пациентов, классифицированных как имеющих и не имеющих повышенную температуру. Однако имейте ввиду, что может быть лучше добавить еще один столбец в команду `group_by()` и `pivot_wider()` (как показано [ниже](#tbls_pivot_wider)).  


```{r}
linelist %>% 
  group_by(hospital) %>% 
  summarise(
    max_temp_fvr = max(temp[fever == "yes"], na.rm = T),
    max_temp_no = max(temp[fever == "no"], na.rm = T)
  )
```



### Склеивание {.unnumbered}  

Функция `str_glue()` из **stringr** является полезной для объединения значений из нескольких столбцов в один новый столбец. В этом контексте она, как правило, используется *после* команды `summarise()`.

На странице [Текст и последовательности](characters_strings.ru.qmd) обсуждаются разные спомобы объединения столбцов, включая `unite()` и `paste0()`. В данном применении мы предлагаем использовать `str_glue()`, поскольку она более гибкая, чем `unite()`, и имеет более простой синтаксис, чем `paste0()`.  

Ниже датафрейм `summary_table` (созданный выше) изменяется таким образом, что столбцы `delay_mean` и `delay_sd` объединяются, добавляется форматирование со скобками для нового столбца, а соответствующие старые столбцы удаляются.  

Затем, чтобы сделать таблицу более презентабельной, добавляется строка итого с помощью `adorn_totals()` из **janitor** (которая игнорирует нечисловые столбцы). Наконец, мы используем `select()` из **dplyr**, чтобы изменить порядок и сменить имена столбцов на более хорошие.  

Теперь вы можете передать в **flextable** и напечататьт таблицу в Word, .png, .jpeg, .html, Powerpoint, RMarkdown и т.п.! (См. страницу [Таблицы для презентации](tables_presentation.ru.qmd)).  

```{r}
summary_table %>% 
  mutate(delay = str_glue("{delay_mean} ({delay_sd})")) %>%  # объединяем и форматируем другие значения
  select(-c(delay_mean, delay_sd)) %>%                       # удаляем два старых столбца   
  adorn_totals(where = "row") %>%                            # добавляем строку итого
  select(                                                    # упорядочиваем и переименовываем столбцы
    "Hospital Name"   = hospital,
    "Cases"           = cases,
    "Max delay"       = delay_max,
    "Mean (sd)"       = delay,
    "Delay 3+ days"   = delay_3,
    "% delay 3+ days" = pct_delay_3
    )
```

#### Процентили {.unnumbered}  

*Процентили* и квантили в **dplyr** заслуживают отдельного упоминания. Чтобы получить квантили, используйте `quantile()` с аргументами по умолчанию, либо уточните значение(я), которое(ые) вы хотите с помощью `probs = `.

```{r}
# получаем значения процентилей возраста по умолчанию (0%, 25%, 50%, 75%, 100%)
linelist %>% 
  summarise(age_percentiles = quantile(age_years, na.rm = TRUE))

# получаем уточненные вручную значения процентилей возраста (5%, 50%, 75%, 98%)
linelist %>% 
  summarise(
    age_percentiles = quantile(
      age_years,
      probs = c(.05, 0.5, 0.75, 0.98), 
      na.rm=TRUE)
    )
```

Если вы хотите получить квантили *по группе*, вы можете получить длинные и менее полезные выходные данные, если вы просто добавите еще один столбец в `group_by()`. Поэтому вместо этого попробуйте такой подход - создайте столбец для каждого нужного уровня квантиля.  

```{r}
# получите уточненные вручную значения процентилей возраста (5%, 50%, 75%, 98%)
linelist %>% 
  group_by(hospital) %>% 
  summarise(
    p05 = quantile(age_years, probs = 0.05, na.rm=T),
    p50 = quantile(age_years, probs = 0.5, na.rm=T),
    p75 = quantile(age_years, probs = 0.75, na.rm=T),
    p98 = quantile(age_years, probs = 0.98, na.rm=T)
    )
```

Хотя функция `summarise()` из **dplyr** однозначно предлагает более детальный контроль, вы можете увидеть, что необходимую вам статистику можно подготовить и с помощью `get_summary_stat()` из пакета **rstatix**. При работе с сгруппированными данными, она выдаст 0%, 25%, 50%, 75% и 100%. При применении к негруппированным данным, вы можете уточнить процентили с помощью `probs = c(.05, .5, .75, .98)`.  


```{r}
linelist %>% 
  group_by(hospital) %>% 
  rstatix::get_summary_stats(age, type = "quantile")
```

```{r}
linelist %>% 
  rstatix::get_summary_stats(age, type = "quantile")
```



### Обобщение агрегированных данных {.unnumbered}  

*Если вы начинаете с агрегированных данных*, использование `n()` выдаст количество *строк*, а не сумму агрегированных подсчетов. Чтобы получить суммы, примените `sum()` к столбцу с подсчетом в данных.  

Например, представим, что вы начинаете с датафреймом подсчета ниже, который называется `linelist_agg` - он отображает в "длинном" формате подсчет случаев по исходу и полу.  

Ниже мы создаем этот пример датафрейма с подсчетом случаев из `linelist` по исходу и полу (для ясности отсутствующие значения удаляются).  

```{r}
linelist_agg <- linelist %>% 
  drop_na(gender, outcome) %>% 
  count(outcome, gender)

linelist_agg
```

Чтобы сложить количества (в столбце `n`) по группам, вы можете использовать `summarise()`, но установить новый столбец равным `sum(n, na.rm=T)`. Чтобы добавить элемент условия к операции суммы, вы можете использовать синтаксис квадратных скобок подмножества [ ] для столбца с подсчетом.  

```{r}
linelist_agg %>% 
  group_by(outcome) %>% 
  summarise(
    total_cases  = sum(n, na.rm=T),
    male_cases   = sum(n[gender == "m"], na.rm=T),
    female_cases = sum(n[gender == "f"], na.rm=T))
```




### `across()` по нескольким столбцам {.unnumbered}  

Вы можете применить `summarise()` к нескольким столбцам, используя `across()`. Это упростит жизнь, если вы хотите рассчитать одинаковые статистические показатели для нескольких столбцов. Поставьте `across()` внутри `summarise()` и уточните следующее:  

* `.cols = ` как либо вектор имен столбцов `c()` или функции-помощники "tidyselect" (объясняется ниже)  
* `.fns = ` выполняемая функция (без скобок) - вы можете указать несколько внутри `list()`

Ниже среднее значение `mean()` применяется к нескольким числовым столбцам. Вектор столбцов записывается в `.cols = `, а одна функция `mean` (среднее значение) указывается (без скобок) в `.fns = `. Любые дополнительные аргументы для функции (например, `na.rm=TRUE`) задаются после `.fns = `, отделенные запятой.  

При использовании `across()` может быть сложно указать скобки и запятые в правильном порядке. Помните, что внутри `across()` вы должны включить столбцы, функции, а также дополнительные аргументы, необходимые функциям. 

```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm),  # столбцы
                   .fns = mean,                               # функция
                   na.rm=T))                                  # дополнительные аргументы
```

Несколько функций можно выполнять одновременно. Ниже в `.fns = ` указываются функции `mean` (среднее) и `sd` (стандартное отклонение) внутри `list()`. У вас есть возможность задать текстовые имена (например, "mean" и "sd"), которые будут добавлены к новым названиям столбцов.  

```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm), # столбцы
                   .fns = list("mean" = mean, "sd" = sd),    # несколько функций 
                   na.rm=T))                                 # дополнительные аргументы
```

Вот функции-помощники "tidyselect", которые вы можете указать в `.cols = `, чтобы выбрать столбцы:  

* `everything()`  - все остальные не упомянутые столбцы  
* `last_col()`    - последний столбец  
* `where()`       - применяет функцию ко всем столбцам и выбирает те, которые оценены как TRUE (ИСТИНА)  
* `starts_with()` - ищет совпадение с установленным префиксом. Пример: `starts_with("date")`
* `ends_with()`   - ищет совпадение с установленным суффиксом. Пример: `ends_with("_end")`  
* `contains()`    - столбцы, содержащие текстовую последовательностоь. Пример: `contains("time")` 
* `matches()`     - чтобы применить регулярное выражение (regex). Пример: `contains("[pt]al")`  
* `num_range()`   - 
* `any_of()`      - ищет совпадение, если столбец именованный. Полезно, если имя не существует. Пример: `any_of(date_onset, date_death, cardiac_arrest)`  


Например, чтобы выдать среднее значение каждого числового столбца, используйте `where()` и задайте функцию `as.numeric()` (без скобок). Все это остается внутри команды `across()`.  

```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(
    .cols = where(is.numeric),  # все числовые столбцы в датафрейме
    .fns = mean,
    na.rm=T))
```


### Поворот горизонтально {#tbls_pivot_wider .unnumbered}

Если вы предпочитаете таблицу в "широком" формате, вы можете ее преобразовать, используя функцию `pivot_wider()` из**tidyr**. Вам, скорее всего, нужно будет переименовать столбцы с помощью `rename()`. Дополнительную информацию см. на странице [Поворот данных].  

Пример ниже начинается с "длинной" таблицы `age_by_outcome` из [раздела доли](#tbl_dplyr_prop). Мы создаем ее снова и печатаем, для ясности:  

```{r}
age_by_outcome <- linelist %>%                  # начинаем с построчного списка
  group_by(outcome) %>%                         # группируем по исходу 
  count(age_cat) %>%                            # группируем и считаем по age_cat, а затем снимаем группировку age_cat
  mutate(percent = scales::percent(n / sum(n))) # рассчитываем процент - обратите внимание, что знаменатель по группе исходов
```

```{r, echo=F}
DT::datatable(age_by_outcome, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Чтобы повернуть горизонтально, мы создаем новые столбцы из *значений* в существующем столбце `age_cat` (установив `names_from = age_cat`). Мы также уточняем, что новые значения таблицы будут взяты из существующего столбца `n`, с `values_from = n`. Столбцы, не упомянутые в нашей команде поворота (`outcome`) останутся неизменными в левой стороне.  

```{r}
age_by_outcome %>% 
  select(-percent) %>%   # сохраняем только подсчет количества для простоты
  pivot_wider(names_from = age_cat, values_from = n)  
```


### Строки Итого {#tbl_dplyr_totals .unnumbered}  

Когда `summarise()` применяется к группированным данным, она не создает автоматически статистические показатели "итого". Ниже представлены два подхода к добавлению строки "итого":  

#### `adorn_totals()` из **janitor** {.unnumbered}  

Если ваша таблица состоит только из абсолютного количества или долей/процентов, которые могут быть суммированы в "итого", тогда вы можете добавить *сложение* итогов, используя функцию `adorn_totals()` из **janitor**, как описано в разделе выше. Обратите внимание, что эта функция может выдавать сумму только по числовым столбцам - если вы хотите посчитать другую итоговую сводную статистику, см. следующий подход с использованием **dplyr**.  

Ниже `linelist` группируется по полу и обобщается в таблицу, которая описывает количество случаев с известным исходом, смертью и выздоровлением. Передав таблицу в `adorn_totals()`, мы добавляем строку итого внузи, отражающую сумму каждого столбца. Дальнейшие функции `adorn_*()` корректируют отображение, как указывают примечания к коду.  

```{r}
linelist %>% 
  group_by(gender) %>%
  summarise(
    known_outcome = sum(!is.na(outcome)),           # Количество строк в группе, где исход не отсутствует
    n_death  = sum(outcome == "Death", na.rm=T),    # Количество строк в группе, где исход - смерть
    n_recover = sum(outcome == "Recover", na.rm=T), # Количество строк в группе, где исход - выздоровление
  ) %>% 
  adorn_totals() %>%                                # оформаляем строку итого (сумма каждого числового столбца)
  adorn_percentages("col") %>%                      # получаем доли по столбцам
  adorn_pct_formatting() %>%                        # конвертируем доли в проценты
  adorn_ns(position = "front")                      # отображаем % и абсолютное количество (с абсолютным количеством сначала)
```

#### `summarise()` к данным "итого" и затем связывание строк `bind_rows()` {.unnumbered}  

Если ваша таблица состоит из сводной статистики, такой как `median()`, `mean()` и т.п., подход `adorn_totals()`, показанный выше, *не* будет достаточным. Вместо этого, чтобы получить сводную статистику для всего набора данных, вам нужно рассчитать их с помощью отдельной команды `summarise()` и затем привязать результаты к оригинальной сгруппированной суммарной таблице. Чтобы сделать это связывание, вы можете использовать `bind_rows()` из **dplyr**, как описано на странице [Объединение данных]. Ниже приведен пример:  

Вы делаете суммарную таблицу исходов *по больнице* с помощью `group_by()` и `summarise()` следующим образом:  

```{r, warning=F, message=F}
by_hospital <- linelist %>% 
  filter(!is.na(outcome) & hospital != "Missing") %>%  # удаляем случаи с отсутствующим исходом или больницей
  group_by(hospital, outcome) %>%                      # группируем данные
  summarise(                                           # создаем новые сводные столбцы интересующих индикаторов
    N = n(),                                            # количество строк на группу больница-исход     
    ct_value = median(ct_blood, na.rm=T))               # медианное значение CT на группу
  
by_hospital # печать таблицы
```

Чтобы получить итого, выполните ту же команду `summarise()`, но сгруппируйте данные только по исходу (не по больнице), следующим образом:  

```{r}
totals <- linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # группируем только по исходу, не по больнице    
      summarise(
        N = n(),                                       # Эти статистические показатели теперь представлены только по исходу     
        ct_value = median(ct_blood, na.rm=T))

totals # печать таблицы
```

Мы можем связать эти два датафрейма вместе. Обратите внимание, что у `by_hospital` 4 столбца, а у `totals` 3 столбца. Используя `bind_rows()`, столбцы связываются по имени, а любое лишнее пространство заполняется `NA` (например, значения столбца `hospital` для двух новых строк итого `totals`). После связывания строк мы конвертируем эти пустые места в итого "Total",  используя `replace_na()` (см. страницу [Вычистка данных и ключевые функции]).  

```{r}
table_long <- bind_rows(by_hospital, totals) %>% 
  mutate(hospital = replace_na(hospital, "Total"))
```

Вот новая таблица со строками "Итого" внизу.  

```{r, message=FALSE, echo=F}
DT::datatable(table_long, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```

Эта таблица представлена в "длинном" формате, который может вам подходить. *Опционально*, вы можете *повернуть* эту таблицу *горизонтально*, чтобы сделать ее более читабельной. См. раздел по повороту горизонтально выше, а также страницу [Поворот данных]. Вы можете также добавить дополнительные столбцы и красиво их упорядочить. Код приведен ниже.  

```{r}
table_long %>% 
  
  # Поворот горизонтально и форматирование
  ########################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # Поворот из длинной в широкую
    values_from = c(ct_value, N),                       # новые значения из столбцов ct и подсчет
    names_from = outcome) %>%                           # новые имена столбцов из исходов (outcomes)
  mutate(                                              # добавляем новые столбцы
    N_Known = N_Death + N_Recover,                               # количество с известным исходом
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # процент умерших случаев (1 знак после запятой)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # процент выздоровевших (1 знак после запятой)
  select(                                              # Переупорядочиваем столбцы
    hospital, N_Known,                                   # вводные столбцы
    N_Recover, Pct_Recover, ct_value_Recover,            # столбцы выздоровевших
    N_Death, Pct_Death, ct_value_Death)  %>%             # столбцы смерти
  arrange(N_Known)                                  # Упорядочиваем строки от наименьшего к наибольшему (строка Итого внизу)

```

Затем вы можете это красиво напечатать в виде изображения - ниже представлены выходные данные с помощью **flextable**. Вы можете более детально прочитать об этом примере и о том, как делать такую "красивую" таблицу на странице [Таблицы для презентации].  

```{r echo=FALSE, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}

linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds")) 

border_style = officer::fp_border(color="black", width=1)

pacman::p_load(
  rio,            # импорт/экспорт
  here,           # путь к файлу
  flextable,      # создаем красивые изображения таблиц 
  officer,        # функции-помощники для таблиц
  tidyverse)      # управление данными, сводные данные и визуализация

table <- linelist %>% 
  # фильтр
  ########
  #filter(!is.na(outcome) & hospital != "Missing") %>%  # удаляет случаи с отсутствующим исходом или больницей
  
  # получаем сводные значения по группе больница-исход
  ###############################################
  group_by(hospital, outcome) %>%                      # группируем данные
  summarise(                                           # создаем новые сводные столбцы интересующих индикаторов
    N = n(),                                            # количество строк на группу больница-исход     
    ct_value = median(ct_blood, na.rm=T)) %>%           # медианное значение CT для группы
  
  # добавляем итого
  ############
  bind_rows(                                           # связываем предыдущую таблицу с этой мини-таблицей итого
    linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # группируем только по исходу, не по больнице    
      summarise(
        N = n(),                                       # количество строк для всего набора данных     
        ct_value = median(ct_blood, na.rm=T))) %>%     # медианное CT для всего набора данных
  
  # поворачиваем горизонтально и форматируем
  ########################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # поворачиваем из длинной в широкую
    values_from = c(ct_value, N),                       # новые значения из столбцов ct и подсчет
    names_from = outcome) %>%                           # новые имена столбцов из исходов (outcomes)
  mutate(                                              # добавляем новые столбцы
    N_Known = N_Death + N_Recover,                               # количество с известным исходом
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # процент умерших случаев (1 знак после запятой)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # процент выздоровевших (1 знак после запятой)
  select(                                              # Переупорядочиваем столбцы
    hospital, N_Known,                                   # Вводные столбцы
    N_Recover, Pct_Recover, ct_value_Recover,            # Столбцы выздоровевших
    N_Death, Pct_Death, ct_value_Death)  %>%             # Стобцы смерти
  arrange(N_Known) %>%                                 # Упорядочиваем строки от наименьшего к наибольшему (строка Итого внизу)

  # форматирование
  ############
  flextable() %>% 
  add_header_row(
    top = TRUE,                # новый заголовок над строкой существующего заголовка
    values = c("Hospital",     # значения заголовка для каждого столбца ниже
               "Total cases with known outcome", 
               "Recovered",    # это будет заголовок верхнего уровня для этого и двух следующих столбцов
               "",
               "",
               "Died",         # это будет заголовок верхнего уровня для этого и двух следующих столбцов
               "",             # оставьте пустым, так как будет объединен с "Died"
               "")) %>% 
    set_header_labels(         # Переименовываем столбцы в оригинальной строке заголовка
      hospital = "", 
      N_Known = "",                  
      N_Recover = "Total",
      Pct_Recover = "% of cases",
      ct_value_Recover = "Median CT values",
      N_Death = "Total",
      Pct_Death = "% of cases",
      ct_value_Death = "Median CT values")  %>% 
  merge_at(i = 1, j = 3:5, part = "header") %>% # горизонтально объединяем столбцы с 3 по 5 в новой строке заголовка
  merge_at(i = 1, j = 6:8, part = "header") %>%  
  border_remove() %>%  
  theme_booktabs() %>% 
  vline(part = "all", j = 2, border = border_style) %>%   # на столбце 2 
  vline(part = "all", j = 5, border = border_style) %>%   # на столбце 5
  merge_at(i = 1:2, j = 1, part = "header") %>% 
  merge_at(i = 1:2, j = 2, part = "header") %>% 
  width(j=1, width = 2.7) %>% 
  width(j=2, width = 1.5) %>% 
  width(j=c(4,5,7,8), width = 1) %>% 
  flextable::align(., align = "center", j = c(2:8), part = "all") %>% 
  bg(., part = "body", bg = "gray95")  %>% 
  colformat_num(., j = c(4,7), digits = 1) %>% 
  bold(i = 1, bold = TRUE, part = "header") %>% 
  bold(i = 6, bold = TRUE, part = "body")


table
```



## Пакет **gtsummary** {#tbl_gt}   

Если вы хотите распечатать свою сводную статистику в виде красивой и готовой к публикации графики, вы можете использовать пакет **gtsummary** и его функцию `tbl_summary()`. Код может сначала показаться сложным, но выходные данные выглядят очень красиво и печатаются в вашей панели просмотра RStudio Viewer в виде изображения HTML. Прочитайте [виньетку тут](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html).    

Вы можете также добавить результаты статистических тестов в таблицы **gtsummary**. Этот процесс описывается в разделе **gtsummary** на странице [Простые статистические тесты](#stats_gt).  

Чтобы представить `tbl_summary()` мы сначала покажем наиболее базовое поведение, которое на самом деле создает большую и красивую таблицу. Затем мы детально рассмотрим, как вносить корректировки и делать более адаптированные под потребности таблицы. 



### Суммарная таблица {.unnumbered}

Поведение `tbl_summary()` по умолчанию на самом деле весьма невероятное - она берет заданные вами столбцы и создает суммарную таблицу в рамках одной команды. Функция печатает статистические показатели, подходящие для класса столбца: медиану и межквартильный диапазон (IQR) для числовых столбцов, и абсолютное количество (%) для категориальных столбцов. Отсутствующие значения конвертируются в "Unknown". Внизу добавляются примечания, объясняющие статистику, а итого N показывается наверху.  

```{r, warning=F, message=F}
linelist %>% 
  select(age_years, gender, outcome, fever, temp, hospital) %>%  # сохраняем только интересующие столбцы
  tbl_summary()                                                  # по умолчанию
```


### Корректировки {.unnumbered}  

Теперь мы объясним, как работает функция и как вносить корректировки. Ключевые аргументы представлены ниже: 

**`by = `**  
Вы можете стратифицировать свою таблицу по столбцу (например, по `outcome`), создав двухвходовую таблицу.  

**`statistic = `**  
Используйте уравнения, чтобы уточнить, какие статистические показатели показать и как их отобразить. В уравнении две стороны, разделенные тильдой `~`. Справа в кавычках представлено желаемое статистическое отображение, а слева - столбцы, к которым будет применяться это отображение.  

* Правая сторона уравнения использует синтаксис `str_glue()` из **stringr** (см. [Текст и последовательности]), где желаемое отображение последовательности представлено в кавычках, а сами статистические показатели в фигурных скобках. Вы можете включить такие статистические показатели, как "n" (для подсчета количества), "N" (для знаменателя), "mean" (среднее), "median" (медиана), "sd" (стандартное отклонение), "max" (максимум), "min" (минимум), процентили в виде "p##", например, "p25", или процент от общего как "p". См. детали в `?tbl_summary`.  
* Для левой стороны уравнения вы можете указать столбцы по имени (например, `age` или `c(age, gender)`), либо использовать функции-помощники, такие как `all_continuous()`, `all_categorical()`, `contains()`, `starts_with()` и т.п.  

Простой пример уравнения `statistic = ` может выглядеть следующим образом, он печатает только среднее значение по столбцу `age_years`:  

```{r}
linelist %>% 
  select(age_years) %>%         # сохраняем только интересующие столбцы 
  tbl_summary(                  # создаем суммарную таблицу
    statistic = age_years ~ "{mean}") # печать среднего значения по возрасту
```

Чуть более сложное уравнение может выглядеть как `"({min}, {max})"`, включая максимальное и минимальное значения внутри скобок, разделенное запятой:  

```{r}
linelist %>% 
  select(age_years) %>%                       # сохраняем только интересующие столбцы 
  tbl_summary(                                # создаем суммарную таблицу
    statistic = age_years ~ "({min}, {max})") # печать минимума и максимума по возрасту
```

Вы можете также дифференцировать синтаксис для отдельных столбцов или типов столбцов. В более сложном примере ниже, значение, указанное в `statistc = `, является **списком**, указывающим, что для всех непрерывных столбцов таблица должна напечатать среднее значение со стандартным отклонением в скобках, а для категориальных столбцов - напечатать n, знаменатель и процент.  

**`digits = `**  
Корректирует количество знаков и округление. Опционально, можно задать только для непрерывных столбцов (как ниже).  

**`label = `**  
Корректирует то, как должно отображаться имя столбца. Задайте имя столбца и желаемую подпись через тильду. По умолчанию будет имя столбца.  

**`missing_text = `**  
Корректирует, как отображаются отсутствующие значения. По умолчанию - "Unknown".  

**`type = `**  
Используется для корректирования того, сколько уровней статистических показателей показывать. Синтаксис похож на `statistic = ` в том, что вы задаете уравнение со столбцами слева и значением справа. Два частых сценария включают:  

* `type = all_categorical() ~ "categorical"` заставляет бинарные столбцы (например, `fever` да/нет) показывать все уровни, а не только строки “yes” (да)  
* `type = all_continuous() ~ "continuous2"` разрешает статистические показатели на несколько строк для переменной, как показано в более позднем разделе  

В примере ниже каждый из этих аргументов используется для модификации оригинальной суммарной таблицы:  

```{r}
linelist %>% 
  select(age_years, gender, outcome, fever, temp, hospital) %>% # сохраняем только интересующие столбцы
  tbl_summary(     
    by = outcome,                                               # стратифицируем всю таблицу по исходам
    statistic = list(all_continuous() ~ "{mean} ({sd})",        # статистика и формат для непрерывных столбцов
                     all_categorical() ~ "{n} / {N} ({p}%)"),   # статистика и формат для категориальных столбцов
    digits = all_continuous() ~ 1,                              # округление для непрерывных столбцов
    type   = all_categorical() ~ "categorical",                 # заставляет отображать все категориальные уровни
    label  = list(                                              # отображает подписи для имен столбцов
      outcome   ~ "Outcome",                           
      age_years ~ "Age (years)",
      gender    ~ "Gender",
      temp      ~ "Temperature",
      hospital  ~ "Hospital"),
    missing_text = "Missing"                                    # как должны отображаться отсутствующие значения
  )
```



### Статистические показатели на нескольких строках для непрерывных переменных {.unnumbered}  

Если вы хотите напечатать несколько строк статистики для непрерывных переменных, вы можете это указать путем установки `type = ` на "continuous2".  Вы можете объединить все ранее показанные элементы в одну таблицу, выбрав, какие статистические показатели вы хотите показать. Чтобы это сделать, вам нужно сказать функции, что вы хотите получить назад таблицу, введя тип как “continuous2”. Количество отсутствующих значений показано как "Unknown".

```{r}
linelist %>% 
  select(age_years, temp) %>%                      # сохраняем только интересующие столбцы
  tbl_summary(                                     # создаем суммарную таблицу
    type = all_continuous() ~ "continuous2",       # указываем, что мы хотим напечатать несколько статистических показателей 
    statistic = all_continuous() ~ c(
      "{mean} ({sd})",                             # строка 1: среднее и стандартное отклонение
      "{median} ({p25}, {p75})",                   # строка 2: медиана и межквартильный диапазон IQR
      "{min}, {max}")                              # строка 3: минимум и максимум
    )
```
Существует множество другие способов для модификации этих таблиц, включая добавление p-значений, корректировку цвета и заголовков и т.п. Многие из них описаны в документации (введите `?tbl_summary` в консоли), а некоторые приведены в разделе [статистические тесты](https://epirhandbook.com/simple-statistical-tests.html).  







## **базовый** R   

Вы можете использовать функцию `table()`, чтобы выполнить табуляцию и кросс-табуляцию столбцов. В отличие от указанных выше вариантов, здесь нужно уточнять датафрейм каждый раз, когда вы ссылаетесь на имя столбца, как показано ниже.  

<span style="color: orange;">**_ВНИМАНИЕ:_** `NA` (отсутствующие) значения **не** будут подсчитаны в табуляции, если вы не включите аргумент `useNA = "always"` (который может также быть задан как "no" или "ifany").</span>

<span style="color: darkgreen;">**_СОВЕТ:_** Вы можете использовать `%$%` из **magrittr**, чтобы снять необходимость постоянного указания датафрейма в **базовых** функциях. Например, представленный ниже код можно записать как `linelist %$% table(outcome, useNA = "always")` </span>

```{r}
table(linelist$outcome, useNA = "always")
```

Кросс-табуляцию нескольких столбцов можно сделать, указав их один за другим, отделив запятыми. Опционально вы можете также присвоить каждому столбцу "имя", как `Outcome = linelist$outcome`.  

```{r}
age_by_outcome <- table(linelist$age_cat, linelist$outcome, useNA = "always") # сохраняем таблицу как объект
age_by_outcome   # печать таблицы
```

### Доли {.unnumbered}  

Чтобы получить доли, передайте указанную выше таблицу в функцию `prop.table()`. Используйте аргумент `margins = ` для уточнения того, хотите ли вы доли от строк (1), столбцов (2), либо всей таблицы (3). Для ясности мы передаем таблицу в функцию `round()` из **базового** R, уточнив 2 знака.   

```{r}
# получаем доли по определенной выше таблице по строкам, округленно
prop.table(age_by_outcome, 1) %>% round(2)
```

### Итого {.unnumbered}  

Чтобы добавить строки и таблицы "итого", передайте таблицу в `addmargins()`. Это работает и для абсолютного количества, и для долей.  

```{r}
addmargins(age_by_outcome)
```

### Конвертация в датафрейм {.unnumbered}  

Конвертация объекта `table()` напрямую в датафрейм не такая простая. Один из подходов продемонстрирован ниже:  

1) Создаем таблицу *без использования* `useNA = "always"`. Вместо этого конвертируем значения `NA` в "(Missing)" с помощью `fct_explicit_na()` из **forcats**.  
2) Добавляем итого (опционально), передав в `addmargins()`  
3) Передаем в функцию **базового** R `as.data.frame.matrix()`  
4) Передаем таблицу в функцию из **tibble** `rownames_to_column()`, уточнив имя для первого столбца  
5) Печатаем, просматриваем или экспортируем по желанию. В этом примере мы используем `flextable()` из пакета **flextable**, как описано на странице [Таблицы для презентации]. Это напечатает в панели просмотра RStudio viewer красивое изображение в формате HTML.  

```{r, warning=F, message=F}
table(fct_explicit_na(linelist$age_cat), fct_explicit_na(linelist$outcome)) %>% 
  addmargins() %>% 
  as.data.frame.matrix() %>% 
  tibble::rownames_to_column(var = "Age Category") %>% 
  flextable::flextable()
```




<!-- ======================================================= -->

## Ресурсы {  }

Значительная часть информации на данной странице взята из следующих онлайн ресурсов и виньеток:  

[gtsummary](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html)  

[dplyr](https://dplyr.tidyverse.org/articles/grouping.html)

