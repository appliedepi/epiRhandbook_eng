# Простые статистические тесты { }


На этой странице мы демонстрируем, как проводить простые статистические тесты, используя **базовый** R, **rstatix** и **gtsummary**.  

* T-тест  
* Критерий Шапиро-Уилка  
* Критерий ранговой суммы Уилкоксона  
* Критерий Крускала-Уоллиса  
* Критерий хи-квадрат  
* Корреляции между числовыми переменными  

...могут проводиться и многие другие тесты, но мы показываем только эти часто используемые тесты и даем ссылки на дополнительную документацию.  

Каждый из указанных пакетов имеет свои преимущества и недостатки:  

* Используйте функции **базового** R, чтобы напечатать статистические выходные данные в консоли R  
* Используйте функции **rstatix**, чтобы выдать результаты в датафрейме, либо если вы хотите рассчитать тесты по группам  
* Используйте **gtsummary**, если вы хотите быстро напечатать готовые к публикации таблицы  



<!-- ======================================================= -->
## Подготовка {  }


### Загрузка пакетов {.unnumbered}

Данный фрагмент кода показывает загрузку пакетов, необходимых для анализа. В данном руководстве мы фокусируемся на использовании `p_load()` из пакета **pacman**, которая устанавливает пакет, если необходимо, *и* загружает его для использования. Вы можете также загрузить установленные пакеты с помощью `library()` из **базового** R. См. страницу [Основы R](basics.ru.qmd) для получения дополнительной информации о пакетах R.  


```{r}
pacman::p_load(
  rio,          # импорт файлов
  here,         # путь к файлу
  skimr,        # получение обзора данных
  tidyverse,    # управление данными + графики ggplot2, 
  gtsummary,    # сводная статистика и тесты
  rstatix,      # статистика
  corrr,        # анализ корреляции числовых переменных
  janitor,      # добавление итого и процентов в таблицы
  flextable     # конвертация таблиц в HTML
  )
```

### Импорт данных {.unnumbered}

Мы импортируем набор данных о случаях из имитированной эпидемии Эболы. Если вы хотите выполнять действия параллельно, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>кликните, чтобы скачать "чистый" построчный список</a> (как .rds файл). Импортируйте ваши данные с помощью функции `import()` из пакета **rio** (она работает со многими типами файлов, такими как .xlsx, .rds, .csv - см. детали на странице [Импорт и экспорт](importing.ru.qmd)).  


```{r, echo=F}
# импорт построчного списка в R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# импорт построчного списка
linelist <- import("linelist_cleaned.rds")
```

Первые 50 строк построчного списка отображены ниже.

```{r, message=FALSE, echo=F}
# отображаем данные построчного списка в виде таблицы
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```





## **базовый** R {}

Вы можете использовать функции **базового** R для проведения статистических тестов. Команды относительно просты, а результаты будут напечатаны для просмотра в консоли R. Однако выходные данные, как правило, являются списками, поэтому с ними слложнее работать, если вы хотите использовать результаты в дальнейших операциях. 

### T-тесты {.unnumbered} 

[t-тест](https://en.wikipedia.org/wiki/Student%27s_t-test), также называемый "t-тест Стьюдента", как правило, используется для определения того, есть ли значительная разница между средними значениями какой-либо числовой переменной между двумя группами. Здесь мы покажем синтаксис для выполнения этого теста в зависимости от того, находятся ли столбцы в том же датафрейме.

**Синтаксис 1:** Это синтаксис, если ваш числовой и категориальный столбец находятся в одном датафрейме. Укажите числовой столбец в левой части уровнения, а категориальный столбец - в правой части. Укажите набор данных в `data = `. Опционально, установите `paired = TRUE` и `conf.level = ` (0.95 по умолчанию), а также `alternative = ` (либо "two.sided", "less", либо "greater"). Для получения детальной информации введите `?t.test`.  

```{r}
## сравниваем средний возраст по группе исходов с помощью t-теста
t.test(age_years ~ gender, data = linelist)
```

**Синтаксис 2:** Вы можете сравнить два числовых вектора, используя этот альтернативный синтаксис. Например, если два столбца находятся в разных наборах данных.  

```{r, eval=F}
t.test(df1$age_years, df2$age_years)
```

Вы можете также использовать t-тест, чтобы определить, отличается ли среднее значение выборки значительным образом от какого-то конкретного значения. Здесь мы проведем одновыборочный t-тест с известным/построенным на основе гипотезы популяционным средним значением `mu = `:  

```{r, eval=F}
t.test(linelist$age_years, mu = 45)
```

### Критерий Шапиро-Уилка {.unnumbered}  

[Критерий Шапиро-Уилка](https://en.wikipedia.org/wiki/Shapiro%E2%80%93Wilk_test) может использоваться для определения того, была ли взята выборка из популяции с нормальным распределением (это допущение для многих других тестов и анализа, например, для t-теста). Однако, его можно использовать только на выборке от 3 до 5000 наблюдений. Для более крупных выборок может быть полезным [квантиль-квантиль график](https://ggplot2.tidyverse.org/reference/geom_qq.html). 


```{r, eval=F}
shapiro.test(linelist$age_years)
```

### Критерий ранговой суммы Уилкоксона {.unnumbered}

Критерий ранговой суммы Уилкоксона, также называемый [U тест Манна-Уитни](https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test), часто используется, чтобы помочь определить, относятся ли две числовых выборки к тому же распределению, когда их популяции не являются нормально распределенными или имеют неравную дисперсию.

```{r wilcox_base}

## сравниваем возрастное распределение по группе исходов с помощью теста Уилкоксона
wilcox.test(age_years ~ outcome, data = linelist)

```


### Критерий Крускала-Уоллиса {.unnumbered}


[Критерий Крускала-Уоллиса](https://en.wikipedia.org/wiki/Kruskal%E2%80%93Wallis_one-way_analysis_of_variance) является расширением Критерия ранговой суммы Уилкоксона, который может использоватьсядля тестировния различий в распределении более, чем двух выборок. Когда используются только две выборки, результаты идентичны Критерию ранговой суммы Уилкоксона. 

```{r }

## сравниваем возрастное распределение по группе исходов с помощью Критерия Крускала-Уоллиса
kruskal.test(age_years ~ outcome, linelist)

```

### Критерий хи-квадрат {.unnumbered} 

[Критерий хи-квадрат Пирсона](https://en.wikipedia.org/wiki/Chi-squared_test) используется при тестировании значительных отличий между категорияльными группами. 

```{r}

## сравниваем доли в каждой группе с помощью критерия хи-квадрат
chisq.test(linelist$gender, linelist$outcome)

```



## Пакет **rstatix** {}

Пакет **rstatix** предлагает способность выполнять статистические тесты и извлекать результаты в структуре, удобной для каналов. Результаты автоматически представляются в датафрейме, так что вы можете проводить с результатами последующие операции. Также легко группировать данные, которые передаются в функции, чтобы статистические показатели считались для каждой группы.  


### Сводная статистика {.unnumbered}  

Функция `get_summary_stats()` является быстрым способом выдачи сводной статистики. Просто передайте ваш набор данных в эту функцию и задайте столбцы для анализа. Если не указаны столбцы, статистика считается для всех столбцов.  

По умолчанию выдаетсыя полный диапазон сводной статистики: n, max (максимум), min (минимум), median (медиана), 25%ile (25 процентиль), 75%ile (75 процентиль), IQR (межквартильный диапазон), median absolute deviation (mad) (медианное абсолютное отклонение), mean (среднее), standard deviation (стандартное отклонение), standard error (стандартная ошибка), а также confidence interval of the mean (доверительный интервал от среднего). 


```{r}
linelist %>%
  rstatix::get_summary_stats(age, temp)
```

Вы можете указать подмножество сводной статистике, которое вам нужно, задав одно из следующих значений в `type = `: "full", "common", "robust", "five_number", "mean_sd", "mean_se", "mean_ci", "median_iqr", "median_mad", "quantile", "mean", "median", "min", "max".  

Можно использовать также для группированных данных, так чтобы выдавалась строка для каждой группы-переменной:  

```{r}
linelist %>%
  group_by(hospital) %>%
  rstatix::get_summary_stats(age, temp, type = "common")
```

Вы также можете использовать **rstatix** для проведения статистических тестов:  

### T-тест {.unnumbered}  

Используйте синтаксис формулы, чтобы уточнить числовой и категориальный столбцы:  

```{r}
linelist %>% 
  t_test(age_years ~ gender)
```

Или используйте `~ 1` и уточните `mu = ` для одновыборочного t-теста. Это также можно сделать по группе.  

```{r}
linelist %>% 
  t_test(age_years ~ 1, mu = 30)
```

Если применимо, статистические тесты можно выполнять по группе, как показано ниже:  

```{r}
linelist %>% 
  group_by(gender) %>% 
  t_test(age_years ~ 1, mu = 18)
```

### Критерий Шапиро-Уилка {.unnumbered}  

Как указано выше, размер выборки должен быть от 3 до 5000.  

```{r}
linelist %>% 
  head(500) %>%            # первые 500 строк построчного списка случаев, только в целях примера
  shapiro_test(age_years)
```

### Критерий ранговой суммы Уилкоксона {.unnumbered}  

```{r}
linelist %>% 
  wilcox_test(age_years ~ gender)
```


### Критерий Крускала-Уоллиса {.unnumbered}  

Также известен как U-тест Манна-Уитни.  

```{r}
linelist %>% 
  kruskal_test(age_years ~ outcome)
```


### Критерий хи-квадрат {.unnumbered}  

Функция критерия хи-квадрата принимает таблицу, поэтому сначала создадим кросс-табуляцию. Существует много способов создания кросс-табуляции (см. [Описательные таблицы](tables_descriptive.ru.qmd)), но здесь мы используем `tabyl()` из **janitor** и удаляем самый левый столбец подписей значений до того, как передаем в `chisq_test()`.  

```{r}
linelist %>% 
  tabyl(gender, outcome) %>% 
  select(-1) %>% 
  chisq_test()

```

С помощью пакета **rstatix** можно выполнить еще много функций и провести статистические тесты с этими функциями. См. документацию по **rstatix** [онлайн тут](https://github.com/kassambara/rstatix) или введите ?rstatix.  





## пакет `gtsummary` {#stats_gt}

Используйте **gtsummary**, если вы хотите добавить результаты статистического теста в красивую таблицу, которая была создана с помощью. этого пакета (как описано в разделе **gtsummary** страницы [Описательные таблицы](tables_descriptive.ru.qmd#tbl_gt)).  

Проведение статистических тестов сравнения с `tbl_summary` делается путем добавления функции 
`add_p` к таблице и уточнения, какой тест использовать. Возможно откорректировать p-значения для множественного тестирования, используя функцию
`add_q`. Детали можно получить с помощью `?tbl_summary`.  

### Критерий хи-квадрат {.unnumbered}

Сравнтие доли категориальной переменной в двух группах. Статистическим тестом по умолчанию для `add_p()` при применении к категориальной переменной является критерий хи-квадрат независимости с корректировкой непрерывности, но если ожидаемое количество вызовов ниже 5, то используется точный критерий Фишера. 

```{r chi_gt}
linelist %>% 
  select(gender, outcome) %>%    # сохраняем интересующие переменные
  tbl_summary(by = outcome) %>%  # создаем суммарную таблицу и уточняем переменную группирования
  add_p()                        # уточняем, какой тест провести
```


### T-тесты {.unnumbered} 

Сравниваем разницу средних значений непрерывной переменной в двух группах. 
Например, сравниваем средний возраст по исходам пациентов. 

```{r ttest_gt}

linelist %>% 
  select(age_years, outcome) %>%             # сохраняем интересующие переменные
  tbl_summary(                               # создаем суммарную таблицу
    statistic = age_years ~ "{mean} ({sd})", # уточняем, какую статистику показать
    by = outcome) %>%                        # уточняем переменную группирования
  add_p(age_years ~ "t.test")                # уточняем, какие тесты провести


```

### Критерий ранговой суммы Уилкоксона {.unnumbered}

Сравниваем распределение непрерывной переменной в двух группах. По умолчанию 
используется Критерий ранговой суммы Уилкоксона и медиана (IQR) при сравнении двух групп. 
Однако для не-нормально распределенных данных или при сравнении нескольких групп 
более подходящим будет Критерий Крускала-Уоллиса. 

```{r wilcox_gt}

linelist %>% 
  select(age_years, outcome) %>%                       # сохраняем интересующие переменные
  tbl_summary(                                         # создаем суммарную таблицу
    statistic = age_years ~ "{median} ({p25}, {p75})", # уточняем, какую статистику показать (по умолчанию, так что можно удалить)
    by = outcome) %>%                                  # уточняем переменную группирования
  add_p(age_years ~ "wilcox.test")                     # уточняем, какой тест провести (по умолчанию, так что можно оставить скобки пустыми)


```

### Критерий Крускала-Уоллиса {.unnumbered}

Сравниваем распределение непрерывной переменной в двух или более группах, 
вне зависимости от того, имеют ли данные нормальное распределение. 

```{r kruskal_gt}

linelist %>% 
  select(age_years, outcome) %>%                       # сохраняем интересующие переменные
  tbl_summary(                                         # создаем суммарную таблицу
    statistic = age_years ~ "{median} ({p25}, {p75})", # уточняем, какую статистику показать (по умолчанию, так что можно удалить)
    by = outcome) %>%                                  # уточняем переменную группирования
  add_p(age_years ~ "kruskal.test")                    # уточняем, какой тест провести


```




<!-- ## пакет `dplyr` {} -->

<!-- Проведение статистических тестов только в `dplyr` сложно, поскольку они  -->
<!-- не укладываются в рамки аккуратных данных. Требуется использовать `purrr`, чтобы создать  -->
<!-- список датафреймов для каждой из подгрупп, которые вы хотите сравнить. См. страницу [Итерация, циклы и списки], чтобы узнать больше о **purrr**.   -->

<!-- Более простой альтернативой может быть пакет `rstatix`.  -->

<!-- ### T-тесты {.unnumbered}  -->

<!-- ```{r ttest_dplyr} -->

<!-- linelist %>%  -->
<!--   ## сохраняем только интересующие переменные -->
<!--   select(age, outcome) %>%  -->
<!--   ## удаляем тех, у кого отсутствует исход  -->
<!--   filter(!is.na(outcome)) %>%  -->
<!--   ## уточняем переменную группирования -->
<!--   group_by(outcome) %>%  -->
<!--   ## создаем подмножество данных для каждой группы (как список) -->
<!--   nest() %>%  -->
<!--   ## превращаем в широкий формат -->
<!--   pivot_wider(names_from = outcome, values_from = data) %>%  -->
<!--   mutate( -->
<!--     ## рассчитываем средний возраст для группы умерших -->
<!--     Death_mean = map(Death, ~mean(.x$age, na.rm = TRUE)), -->
<!--     ## рассчитываем стандартное отклонение среди умерших  -->
<!--     Death_sd = map(Death, ~sd(.x$age, na.rm = TRUE)), -->
<!--     ## рассчитываем средний возраст для группы выздоровевших -->
<!--     Recover_mean = map(Recover, ~mean(.x$age, na.rm = TRUE)),  -->
<!--     ## рассчитываем стандартное отклонение среди выздоровевших  -->
<!--     Recover_sd = map(Recover, ~sd(.x$age, na.rm = TRUE)), -->
<!--     ## используя оба группированных набора данных, сравниваем средний возраст с помощью t-теста -->
<!--     ## сохраняем только p.value -->
<!--     t_test = map2(Death, Recover, ~t.test(.x$age, .y$age)$p.value) -->
<!--   ) %>%  -->
<!--   ## убираем наборы данных  -->
<!--   select(-Death, -Recover) %>%  -->
<!--   ## выдает набор данных с медианами и  p.значениями (удаляем отсутствующие) -->
<!--   unnest(cols = everything()) -->

<!-- ``` -->


<!-- ### Критерий ранговой суммы Уилкоксона {.unnumbered} -->

<!-- ```{r wilcox_dplyr} -->

<!-- linelist %>%  -->
<!--   ## сохраняем только интересующие переменные -->
<!--   select(age, outcome) %>%  -->
<!--   ## удаляем тех, у кого отсутствует исход  -->
<!--   filter(!is.na(outcome)) %>%  -->
<!--   ## уточняем переменную группирования -->
<!--   group_by(outcome) %>%  -->
<!--   ## создаем подмножество данных для каждой группы (как список) -->
<!--   nest() %>%  -->
<!--   ## превращаем в широкий формат  -->
<!--   pivot_wider(names_from = outcome, values_from = data) %>%  -->
<!--   mutate( -->
<!--     ## рассчитываем средний возраст для группы умерших -->
<!--     Death_median = map(Death, ~median(.x$age, na.rm = TRUE)), -->
<!--     ## рассчитываем стандартное отклонение среди умерших  -->
<!--     Death_iqr = map(Death, ~str_c( -->
<!--       quantile(.x$age, probs = c(0.25, 0.75), na.rm = TRUE),  -->
<!--       collapse = ", " -->
<!--       )), -->
<!--     ## рассчитываем медианный возраст для группы выздоровевших -->
<!--     Recover_median = map(Recover, ~median(.x$age, na.rm = TRUE)),  -->
<!--     ## рассчитываем стандартное отклонение среди выздоровевших  -->
<!--     Recover_iqr = map(Recover, ~str_c( -->
<!--       quantile(.x$age, probs = c(0.25, 0.75), na.rm = TRUE),  -->
<!--       collapse = ", " -->
<!--       )), -->
<!--     ## используя оба группированных набора данных, сравниваем распределение возраста с помощью теста Уилкоксона -->
<!--     ## сохраняем только p.значение -->
<!--     wilcox = map2(Death, Recover, ~wilcox.test(.x$age, .y$age)$p.value) -->
<!--   ) %>%  -->
<!--   ## убираем наборы данных  -->
<!--   select(-Death, -Recover) %>%  -->
<!--   ## выдает набор данных с медианами и  p.значениями (удаляем отсутствующие) -->
<!--   unnest(cols = everything()) -->

<!-- ``` -->

<!-- ### Критерий Крускала-Уоллиса {.unnumbered} -->


<!-- ```{r kruskal_dplyr} -->

<!-- linelist %>%  -->
<!--   ## сохраняем только интересующие переменные -->
<!--   select(age, outcome) %>%  -->
<!--   ## удаляем тех, у кого отсутствует исход  -->
<!--   filter(!is.na(outcome)) %>%  -->
<!--   ## уточняем переменную группирования -->
<!--   group_by(outcome) %>%  -->
<!--   ## создаем подмножество данных для каждой группы (как список) -->
<!--   nest() %>%  -->
<!--   ## превращаем в широкий формат -->
<!--   pivot_wider(names_from = outcome, values_from = data) %>%  -->
<!--   mutate( -->
<!--     ## рассчитываем медианный возраст для группы умерших -->
<!--     Death_median = map(Death, ~median(.x$age, na.rm = TRUE)), -->
<!--     ## рассчитываем стандартное отклонение среди умерших  -->
<!--     Death_iqr = map(Death, ~str_c( -->
<!--       quantile(.x$age, probs = c(0.25, 0.75), na.rm = TRUE),  -->
<!--       collapse = ", " -->
<!--       )), -->
<!--     ## рассчитываем медианный возраст для группы выздоровевших -->
<!--     Recover_median = map(Recover, ~median(.x$age, na.rm = TRUE)),  -->
<!--     ## рассчитываем стандартное отклонение среди выздоровевших  -->
<!--     Recover_iqr = map(Recover, ~str_c( -->
<!--       quantile(.x$age, probs = c(0.25, 0.75), na.rm = TRUE),  -->
<!--       collapse = ", " -->
<!--       )), -->
<!--     ## используя оригинальный набор данных, сравниваем распределение возрастов с помощью критерия Крускала -->
<!--     ## сохраняем только p.значение -->
<!--     kruskal = kruskal.test(linelist$age, linelist$outcome)$p.value -->
<!--   ) %>%  -->
<!--   ## убираем наборы данных  -->
<!--   select(-Death, -Recover) %>%  -->
<!--   ## выдает набор данных с медианами и  p.значениями (удаляем отсутствующие) -->
<!--   unnest(cols = everything()) -->

<!-- ``` -->

<!-- ### Критерий хи-квадрат {.unnumbered}  -->


<!-- ```{r} -->
<!-- linelist %>%  -->
<!--   ## делаем все по полу  -->
<!--   group_by(outcome) %>%  -->
<!--   ## подсчет по интересующей переменной -->
<!--   count(gender) %>%  -->
<!--   ## рассчитываем долю  -->
<!--   ## обратите внимание, что здесь знаменатель - сумма по каждому полу -->
<!--   mutate(percentage = n / sum(n) * 100) %>%  -->
<!--   pivot_wider(names_from = outcome, values_from = c(n, percentage)) %>%  -->
<!--   filter(!is.na(gender)) %>%  -->
<!--   mutate(pval = chisq.test(linelist$gender, linelist$outcome)$p.value) -->
<!-- ``` -->


<!-- ======================================================= -->

## Корреляции 

Корреляцию между числовыми переменными можно изучить с помощью пакета **tidyverse**  
**corrr**. Он позволяет вам рассчитать корреляции, используя коэффициент Пирсона, тау Кендалла
или коэффициент корреляции Спирмена. Пакет создает таблицу, а также имеет функцию по 
автоматическому построению графика значений. 

```{r, warning=F, message=F}

correlation_tab <- linelist %>% 
  select(generation, age, ct_blood, days_onset_hosp, wt_kg, ht_cm) %>%   # сохраняем интересующие числовые переменные
  correlate()      # создаем таблицу корреляции (используя по умолчанию коэффициент Пирсона)

correlation_tab    # печать

## удаляем дублирующиеся записи (зеркало таблицы выше) 
correlation_tab <- correlation_tab %>% 
  shave()

## просмотр таблицы корреляции 
correlation_tab

## график корреляций 
rplot(correlation_tab)
```


<!-- ======================================================= -->

## Ресурсы {  }

Многая информация на этой странице была взята из следующих онлайн ресурсов и виньеток:  

[gtsummary](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html)
[dplyr](https://dplyr.tidyverse.org/articles/grouping.html)
[corrr](https://corrr.tidymodels.org/articles/using-corrr.html)
[корреляция sthda](http://www.sthda.com/english/wiki/correlation-test-between-two-variables-in-r)
