# Versionskontrolle und Zusammenarbeit mit Git und Github

Dieses Kapitel gibt einen Überblick über die Verwendung von Git für die Zusammenarbeit mit anderen.
Ausführlichere Anleitungen können
findest du am Ende des Kapitels im Abschnitt Ressourcen.

## Was ist Git?

Git ist eine **Versionskontrolle** Software, die es ermöglicht, Änderungen in einer
Ordner. Sie kann wie die Option "Änderungen verfolgen" in Word, LibreOffice oder
Google Docs, aber für alle Arten von Dateien. Sie ist eine der leistungsfähigsten
und meistgenutzten Optionen für die Versionskontrolle.

**Warum habe ich noch nie davon gehört? -
** Während Menschen mit einem Entwickler
lernen routinemäßig den Umgang mit Versionskontrollprogrammen (Git,
Mercurial, Subversion oder andere), lernen nur wenige von uns aus
quantitativen Disziplinen werden diese Fähigkeiten gelehrt. Daher haben die meisten Epidemiologen nie
während ihres Studiums nie etwas davon gehört und müssen es spontan lernen.

**Warte, ich habe von Github gehört, ist das dasselbe?** - Nicht genau, aber du
aber man benutzt sie oft zusammen und wir zeigen dir, wie das geht. Kurz und gut:

- **Git** ist das Versionskontrollsystem, ein Stück Software. Du kannst es benutzen
  lokal auf deinem Computer oder zum Synchronisieren eines Ordners mit einem
  Host **Website**. Standardmäßig verwendet man ein Terminal, um Git
  Anweisungen in der Kommandozeile einzugeben.

- Du kannst eine **Git-Client/Schnittstelle** verwenden, um die Kommandozeile zu umgehen und
  die gleichen Aktionen auszuführen (zumindest für die einfachen, sehr häufigen
  Aktionen).

- Wenn du deinen Ordner in einem **Host-Website** zu
  mit anderen zusammenzuarbeiten, kannst du ein Konto bei Github erstellen,
  Gitlab, Bitbucket oder anderen erstellen.

So kannst du den Client/die Schnittstelle nutzen **Github Desktop** verwenden, das die
**Git** im Hintergrund, um deine Dateien zu verwalten, sowohl lokal auf deinem
Computer, als auch aus der Ferne auf einem **Github** Server.

## Warum die Kombination aus Git und Github?

verwenden **Git** erleichtert:

1) Archivierung dokumentierter Versionen mit inkrementellen Änderungen, damit du
  leicht zu jedem früheren Zustand zurückkehren kannst
2) Mit parallelen *Zweige* d.h. Entwicklungs-/"Arbeits"-Versionen mit
  strukturierte Wege, um die Änderungen nach der Überprüfung zu integrieren

Dies kann lokal auf deinem Computer geschehen, auch wenn du nicht zusammenarbeitest.
mit anderen Personen zusammenarbeitest. Hast du schon einmal:

- bereut, dass du einen Abschnitt des Codes gelöscht hast, nur um festzustellen, dass zwei
  Monate später feststellst, dass du ihn tatsächlich brauchst?

- auf ein Projekt zurückkommen, das auf Eis lag, und versuchen, es
  zu erinnern, ob du diese knifflige Änderung in einem der Projekte vorgenommen hast
  Modellen vorgenommen hast?

- hatte eine *Datei model\_1.R* und eine weitere Datei *model\_1\_test.R* und eine Datei
  *model\_1\_not\_working.R* um Dinge auszuprobieren?

- hatte eine Datei *report.Rmd*, eine Datei *report\_full.Rmd*, eine Datei
  *report\_true\_final.Rmd*, eine Datei *report\_final\_20210304.Rmd*, eine Datei
  *report\_final\_20210402.Rmd* und deine Archivierungsfähigkeiten verflucht?

Git hilft dir bei all dem und ist allein schon deshalb wert, dass du es lernst.

Noch leistungsfähiger wird es jedoch, wenn es mit einem Online-Repository verwendet wird
wie Github zur Unterstützung **gemeinschaftliche Projekte**. Das erleichtert die Arbeit:

- Zusammenarbeit: Andere können überprüfen, kommentieren und
  Änderungen annehmen/ablehnen

- Teile deinen Code, deine Daten und Ergebnisse und fordere Feedback ein
  von der Öffentlichkeit (oder privat, mit deinem Team)

und vermeidet:

- "Ups, ich habe vergessen, die letzte Version zu schicken und jetzt musst du
  jetzt musst du die Arbeit von zwei Tagen an dieser neuen Datei wiederholen.

- Mina, Henry und Oumar arbeiteten alle gleichzeitig an einem Skript und
  müssen ihre Änderungen manuell zusammenführen

- Zwei Personen versuchen, dieselbe Datei auf Dropbox und Sharepoint zu ändern
  und dies führt zu einem Synchronisierungsfehler.

### Das klingt kompliziert, ich bin kein Programmierer {-}

Das kann es auch sein. Beispiele für fortgeschrittene Anwendungen können ziemlich beängstigend sein. Allerdings sind viele
wie bei R oder sogar Excel musst du kein Experte sein, um die Vorteile zu nutzen.
Vorteile des Tools zu nutzen. Das Erlernen einer *einer kleinen Anzahl von Funktionen und Begriffen*
kannst du deine Änderungen nachverfolgen, deine Dateien online synchronisieren
synchronisieren und mit deinen Kollegen zusammenarbeiten - und das in kürzester Zeit.
Zeit.

Aufgrund der Lernkurve ist der Notfallkontext vielleicht nicht die beste Zeit
um diese Werkzeuge zu lernen. Aber das Lernen kann schrittweise erfolgen. Sobald du dir
ein paar Begriffe gelernt hast, kann dein Arbeitsablauf ziemlich effizient und schnell sein.
Wenn du nicht an einem Projekt arbeitest, bei dem die Zusammenarbeit mit anderen
durch Git eine Notwendigkeit ist, **ist es eigentlich ein guter Zeitpunkt, um sich
es sicher zu benutzen** bevor du in die Zusammenarbeit einsteigst.

## Einrichtung

### Git installieren {.unnumbered}

*Git* ist der Motor hinter den Kulissen auf deinem Computer, der die
Änderungen, Zweige (Versionen), Zusammenführungen und Rückgängigmachen verfolgt. **Du musst zuerst
installieren *Git* von [https://git-scm.com/downloads](https://git-scm.com/downloads).**

### Installiere eine Schnittstelle (optional, aber empfohlen) {.unnumbered}

Git hat eine eigene Befehlssprache, die in einen Befehl eingegeben werden kann
Terminal eingegeben werden können. Allerdings gibt es viele Clients/Schnittstellen und als Nicht-Entwickler kannst du in deinem
wirst du im täglichen Gebrauch selten *benötigen* direkt mit Git zu arbeiten und
Schnittstellen bieten in der Regel nette Visualisierungstools für Dateiänderungen oder Zweige.

Es gibt viele Optionen für alle Betriebssysteme, von einsteigerfreundlich bis komplex.
Gute Optionen für Anfänger sind das RStudio Git-Fenster und
[Github Desktop](https://desktop.github.com/) die wir in diesem Artikel vorstellen werden.
diesem Kapitel vorstellen.
Zu den mittleren (leistungsfähigeren, aber komplexeren) Optionen gehören Source Tree,
Gitkracken, Smart Git und andere.

Kurze Erklärung auf [Git-Clients](https:/happygitwithr.com/git-client.html#git-client).

*Hinweis: Da alle Schnittstellen Git intern nutzen, kannst du mehrere dieser Clients ausprobieren.
ausprobieren, bei einem bestimmten Projekt von einer zur anderen wechseln, die Konsole punktuell nutzen
für eine Aktion, die deine Schnittstelle nicht unterstützt, oder sogar eine beliebige Anzahl von
Aktionen online auf Github durchführen.*

Wie unten erwähnt, musst du gelegentlich Git-Befehle in eine
Terminal wie dem RStudio-Terminalfenster (ein Reiter neben dem R
Konsole) oder das Git-Bash-Terminal eingeben.

### Github-Konto {.unnumbered}

Registriere dich für ein kostenloses Konto bei [github.de](github.com).

Möglicherweise wird dir die Einrichtung einer Zwei-Faktor-Authentifizierung mit einer App auf
deinem Telefon einzurichten. Lies mehr im Github [Hilfe
Dokumente](https://docs.github.com/en/github/authenticating-to-github/securing-your-account-with-two-factor-authentication-2fa).

Wenn du Github Desktop verwendest, kannst du deine Gitub-Anmeldedaten eingeben, nachdem du
Installation wie folgt eingeben
[Schritte](https://docs.github.com/en/desktop/installing-and-configuring-github-desktop/authenticating-to-github).
Wenn du das nicht tust, werden die Anmeldedaten später abgefragt, wenn du versuchst
ein Projekt von Github zu klonen.

## Vokabular, Konzepte und grundlegende Funktionen

Wie beim Erlernen von R gibt es ein paar Vokabeln, die du dir merken musst, um
Git zu verstehen. Hier sind die [Grundlagen, damit du
loslegen](https://www.freecodecamp.org/news/an-introduction-to-git-for-absolute-beginners-86fa1d32ff71/)
/ [Interaktives Lernprogramm](learngitbranching.js.org). In der nächsten
Abschnitten werden wir zeigen, wie man Schnittstellen nutzt, aber es ist gut
aber es ist gut, das Vokabular und die Konzepte im Kopf zu haben, um dein mentales Modell aufzubauen,
und weil du sie sowieso brauchst, wenn du Schnittstellen verwendest.

### Repository {.unnumbered}

A Git *Repository* ("*repo*") ist ein Ordner, in dem alle
Unterordner und Dateien für dein Projekt (Daten, Code, Bilder usw.) und
ihre Änderungshistorie. Wenn du anfängst, die Änderungen im
Repository zu verfolgen, erstellt Git einen versteckten Ordner, der
alle Tracking-Informationen enthält. Ein typisches Git-Repository ist
dein *R-Projekt*Ordner (siehe Handbuchseite zu [R-Projekte]).

Wir werden zeigen, wie man (*initialisieren*) ein Git Repository
von Github, Github Desktop oder Rstudio in der nächsten
Abschnitten.

### Commits {.unnumbered}

A *begehen* ist eine **Schnappschuss** des Projekts zu einem bestimmten Zeitpunkt.
Wenn du eine Änderung am Projekt vornimmst, machst du einen neuen Commit
um die Änderungen (das Delta) zu verfolgen, die an deinem
Dateien. Vielleicht hast du zum Beispiel einige Codezeilen bearbeitet und eine
zugehörigen Datensatz aktualisiert. Sobald deine Änderungen gespeichert sind, kannst du sie bündeln
Änderungen in einem "Commit" zusammenfassen.

Jede Übertragung hat eine eindeutige ID (eine *Hash*). Für Zwecke der Versionskontrolle,
kannst du dein Projekt auf der Grundlage von Commits in der Zeit zurückverfolgen, also ist es am besten
am besten, sie relativ klein und zusammenhängend zu halten. Du wirst auch eine kurze
Beschreibung der Änderungen an, die sogenannte "Commit-Nachricht".

*Gestufte Änderungen*? Eine Änderung wird in die Liste der *Bereitstellungsbereich*
als Vorbereitung für den nächsten Commit. Die Idee ist, dass du fein säuberlich
entscheiden kannst, welche Änderungen in einem bestimmten Commit enthalten sein sollen. Zum Beispiel, wenn du
in einem Skript an der Modellspezifikation gearbeitet hast, und später an einer Figur in
einem anderen Skript arbeitest, wäre es sinnvoll, zwei verschiedene Commits zu haben (es wäre einfacher
für den Fall, dass du die Änderungen an der Figur, aber nicht am Modell rückgängig machen willst).

### Zweige {.unnumbered}

Ein Zweig stellt eine *unabhängige Linie* von Änderungen in deinem Repo, ein
parallele, alternative Version deiner Projektdateien.

Zweige sind nützlich, um Änderungen zu testen, bevor sie in die
die *Hauptprogramm* Zweig, der normalerweise die primäre/endgültige/"Live"-Version von
deines Projekts. Wenn du mit dem Experimentieren in einem Zweig fertig bist, kannst du die
die Änderungen in deinen *Hauptprojekt* Zweig, indem du *zusammenführt* oder ihn löschen, wenn
die Änderungen nicht so erfolgreich waren.

*Hinweis: Du musst nicht mit anderen Personen zusammenarbeiten, um Zweige zu verwenden,
noch brauchst du ein entferntes Online-Repository.*

### Lokale und entfernte Repositories {.unnumbered}

An *klonen* ist es, eine Kopie eines Git-Repositorys an einem anderen Ort zu erstellen.

Du kannst zum Beispiel *klonen* ein Online-Repository *von* Github lokal auf
deinem Computer, oder beginne mit einem lokalen Repository und klone
es online *auf* Github.

Wenn du ein Repository geklont hast, befinden sich die Projektdateien in
zwei Orten:

- dem *LOKAL* Repository auf deinem physischen Computer. Diese
  nimmst du die tatsächlichen Änderungen an den Dateien/Codes vor.

- die *FERN*, Online-Repository: die Versionen deiner Projektdateien
  im Github-Repository (oder in jedem anderen Web
  Host).

Um diese Repositories zu synchronisieren, werden wir weitere Funktionen verwenden. In der Tat,
anders als Sharepoint, Dropbox oder andere Synchronisierungssoftware, bietet Git
Git nicht automatisch dein lokales Repository oder das, was online ist,
oder andersherum. Du entscheidest selbst, wann und wie du synchronisierst.

- `git fetch` lädt die neuen Änderungen aus dem entfernten Projektarchiv herunter, aber nicht
  ändert dein lokales Projektarchiv nicht. Stell dir vor, du überprüfst den Status des entfernten Projektarchivs.

- `git pull` lädt die neuen Änderungen aus den entfernten Repositories herunter
  und aktualisiert dein lokales Repository.

- Wenn du einen oder mehrere lokale Commits gemacht hast, kannst du
  `git push` die Commits an das Remote-Repository übertragen. Dies sendet deine
  Änderungen an Github, so dass andere Leute sie sehen und ziehen können, wenn
  sie wollen.

## Los geht's: ein neues Repository erstellen

Es gibt viele Möglichkeiten, neue Repositories zu erstellen. Du kannst es über die
Konsole, über Github oder über eine Schnittstelle.

Es gibt zwei allgemeine Ansätze für die Einrichtung:

- Erstelle ein neues R-Projekt aus einem bestehenden oder neuen Github-Repository
  (*bevorzugt für Anfänger*), oder
- Erstelle ein Github-Repository für ein bestehendes R-Projekt

### Start-up Dateien {.unnumbered}

Wenn du ein neues Repository erstellst, kannst du optional folgende Dateien erstellen
alle unten aufgeführten Dateien erstellen oder sie zu einem späteren Zeitpunkt zu deinem Projektarchiv hinzufügen.
Sie befinden sich normalerweise im Stammordner des Projektarchivs.

- A *README* Datei ist eine Datei, die jemand lesen kann, um zu verstehen, warum
  dein Projekt existiert und was sie sonst noch wissen sollten, um es zu benutzen. Sie
  wird anfangs leer sein, aber du solltest sie später vervollständigen.

- A *.gitignore* Datei ist eine Textdatei, in der jede Zeile Folgendes enthält
  Ordner oder Dateien, die Git ignorieren soll (Änderungen nicht verfolgen). Lesen
  mehr darüber und sehen Sie Beispiele
  [hier](https://www.freecodecamp.org/news/gitignore-what-is-it-and-how-to-add-to-repo/).

- Du kannst eine *Lizenz* für deine Arbeit wählen, so dass andere Menschen
  wissen, unter welchen Bedingungen sie dein Werk nutzen oder vervielfältigen dürfen. Für mehr
  Informationen findest du in der [Creative Commons
  Lizenzen](https://creativecommons.org/licenses/).

### Erstelle ein neues Repository in Github {.unnumbered}

Um ein neues Repository zu erstellen, logge dich bei Github ein und suche nach dem grünen
Schaltfläche, um ein neues Repository zu erstellen. Dieses nun leere Repository kann
lokal auf deinen Computer geklont werden (siehe nächster Abschnitt).

```{r, echo=F, fig.align="center"}
knitr::include_graphics(here::here("images", "github_new.png"))
```

Du musst wählen, ob du dein Repository als **öffentlich** (sichtbar für
jeder im Internet) oder **privat** (nur sichtbar für diejenigen mit
Erlaubnis). Das hat wichtige Auswirkungen, wenn deine Daten sensibel sind.
Wenn dein Repository privat ist, wirst du einige Quoten in den erweiterten
besonderen Umständen, z.B. wenn du Github benutzt *Aktionen* zu
deinen Code automatisch in der Cloud auszuführen.

### Klonen aus einem Github-Repository {.unnumbered}

Du kannst *klonen* ein bestehendes Github-Repository klonen, um ein
ein neues lokales R-Projekt auf deinem Computer zu erstellen.

Das Github-Repository kann ein bereits bestehendes sein und enthält
Inhalt enthält, oder ein leeres Repository, das du gerade erstellt hast. In diesem
letzteren Fall erstellst du im Wesentlichen das Github-Repository und lokale R
Projekt zur gleichen Zeit (siehe Anleitung oben).

*Hinweis* Wenn du keine Mitwirkungsrechte an einem Github-Repository hast, kannst du es nicht nutzen,
ist es möglich, zuerst *forken* das Repository zu deinem Profil zu forken, und dann
mit den anderen Aktionen fort. Das Forking wird am Ende dieses Artikels erklärt
Kapitels erklärt, aber wir empfehlen, dass du zuerst die anderen Abschnitte liest.

Schritt 1: Navigiere in Github zu dem Repository, klicke auf das grüne "**Code**"
Taste und kopiere den **HTTPS-Klon-URL** (siehe Bild unten)

```{r, echo=F, out.width="100%", out.height="100%", fig.align="center"}
knitr::include_graphics(here::here("images", "github_clone.png"))
```

Der nächste Schritt kann in jeder Schnittstelle durchgeführt werden. Wir illustrieren das mit
Rstudio und Github Desktop.

#### In Rstudio {.unnumbered}

Starten Sie in RStudio ein neues R-Projekt, indem Sie auf *Datei > Neues Projekt >
Versionskontrolle > Git*

- Wenn du zur Eingabe der "Repository URL" aufgefordert wirst, füge die HTTPS-URL von
  Github ein.
- Gib dem R-Projekt einen kurzen, informativen Namen.
- Wähle aus, wo das neue R Projekt lokal gespeichert werden soll\\
- Aktiviere "In neuer Sitzung öffnen" und klicke auf "Projekt erstellen".

Du befindest dich jetzt in einem neuen, lokalen RStudio-Projekt, das ein Klon des
Github-Repository ist. Dieses lokale Projekt und das Github-Repository sind jetzt
verknüpft.

#### In Github Desktop {.unnumbered}

- Klicken Sie auf *Datei > Klonen eines Repositorys*

- Wähle die Registerkarte URL

- Füge die HTTPS-URL von Github in das erste Feld ein

- Wähle den Ordner, in dem du dein lokales Repository haben möchtest

- Klicke auf "CLONE"

```{r, echo=F, out.width="100%", out.height="100%", fig.align="center"}
knitr::include_graphics(here::here("images", "github_clone_desktop.png"))
```

### Neues Github Repo aus bestehendem R Projekt {.unnumbered}

Ein alternatives Einrichtungsszenario ist, dass du ein bestehendes R-Projekt hast
mit Inhalt hast und ein Github-Repository dafür erstellen möchtest.

1) Erstelle ein neues, leeres Github-Repository für das Projekt (siehe
  Anweisungen oben)\\
2) Klone dieses Repository lokal (siehe HTTPS-Anleitung oben)\\
3) Kopiere den gesamten Inhalt aus deinem bereits bestehenden R
  Projekt (Codes, Daten usw.) in dieses neue, leere, lokale Repository (z.B. durch Kopieren und Einfügen).\\
4) Öffne dein neues Projekt in RStudio und gehe zum Git-Fenster. Die neuen Dateien sollten
  als Datei-Änderungen registriert werden, die nun von Git verfolgt werden. Daher kannst du
  diese Änderungen bündeln als *commit* und *push* sie auf Github hoch.
  Sobald *veröffentlicht* wird das Repository auf Github alle Dateien enthalten.

Details zu diesem Prozess findest du im Abschnitt über den Github-Workflow weiter unten.

### Wie sieht es jetzt aus? {.unnumbered}

#### In RStudio {-}

Sobald du ein Github-Repository in ein neues R-Projekt geklont hast,
siehst du jetzt in RStudio eine Registerkarte "Git". Diese Registerkarte erscheint im gleichen RStudio-Fenster
wie deine R-Umgebung:

```{r, echo=F, out.width="75%", out.height="75%", fig.align="center"}
knitr::include_graphics(here::here("images", "Git_console.png"))
```

Bitte beachte die eingekreisten Schaltflächen in der obigen Abbildung, denn sie werden
später referenziert werden (von links nach rechts):

- Schaltfläche zu *übertragen* die gespeicherten Dateiänderungen in die lokale
  Zweig übertragen (es wird ein neues Fenster geöffnet)
- Blauer Pfeil zu *ziehen* (aktualisiere deine lokale Version des Zweigs mit
  alle Änderungen, die an der Remote/Github-Version des Zweigs vorgenommen wurden)
- Grüner Pfeil zu *pushen* (sendet alle Commits/Änderungen für dein lokales
  Version des Zweigs an die Remote/Github-Version des Zweigs)
- Die Registerkarte Git in RStudio
- Schaltfläche zum Erstellen eines NEUEN Zweigs mit dem angezeigten lokalen Zweig
  rechts als Basis angezeigt wird. *Du willst fast immer von einem Zweig abzweigen
  dem Hauptzweig abzweigen (nachdem du den Hauptzweig zum ersten Mal aktualisiert hast)*
- Der Zweig, in dem du gerade arbeitest
- Änderungen, die du am Code oder anderen Dateien vorgenommen hast, werden unten angezeigt

#### Im Github Desktop {-}

Github Desktop ist eine unabhängige Anwendung, mit der du deine
alle deine Repositories verwalten kannst. Wenn du sie öffnest, kannst du über die Oberfläche
das Repository auswählen, an dem du arbeiten möchtest, und dann die grundlegenden Git
Aktionen auszuführen.

```{r, echo=F, out.width="75%", out.height="75%", fig.align="center"}
knitr::include_graphics(here::here("images", "github_desktop_interface.png"))
```

## Git + Github Arbeitsablauf

### Prozess-Übersicht {.unnumbered}

Sobald du die Einrichtung abgeschlossen hast (wie oben beschrieben), hast du eine
Github Repo, das verbunden ist (*geklont*) mit einem lokalen R-Projekt verbunden ist. Die
*wichtigste* Zweig (der standardmäßig erstellt wird) ist die sogenannte "Live"-Version von
*aller* der Dateien. Wenn du Änderungen vornehmen willst, ist es eine gute
Praxis, eine *neuen Zweig* von der *Haupt* Zweig (wie "Mach eine
Kopie"). Dies ist ein typischer Arbeitsablauf in Git, denn das Erstellen eines Zweigs ist
einfach und schnell ist.

Ein typischer Arbeitsablauf sieht wie folgt aus:

1. Vergewissere dich, dass dein lokales Repository aktuell ist, aktualisiere es, wenn
  nicht

2. Gehe zu dem Zweig, an dem du vorher gearbeitet hast, oder erstelle einen neuen
  Zweig, um einige Dinge auszuprobieren

3. Bearbeite die Dateien lokal auf deinem Computer, erstelle eine oder mehrere
  Übertragungen in diesen Zweig

4. Aktualisiere die Remote-Version des Zweigs mit deinen Änderungen (push)

5. Wenn du mit deinem Zweig zufrieden bist, kannst du den Online-Zweig zusammenführen
  Version des Arbeitszweigs in den Online-"Hauptzweig" zusammenführen, um
  die Änderungen zu übertragen

Andere Teammitglieder machen vielleicht dasselbe mit ihren eigenen Zweigen,
oder vielleicht auch Commits in deinen Arbeitszweig einbringen.

Im Folgenden gehen wir den oben beschriebenen Prozess Schritt für Schritt genauer durch.
Hier ist ein Schema, das wir entwickelt haben - es hat das Format einer zweiseitigen
Tabelle, damit Epidemiologen sie besser verstehen können.

```{r, echo=F, out.height="150%", out.width="100%", fig.align="center"}
knitr::include_graphics(here::here("images", "github_table.png"))
```

Hier ist [ein weiteres Diagramm](https://build5nines.com/introduction-to-git-version-control-workflow/).

*Hinweis: Bis vor kurzem wurde der Begriff "Master"-Zweig verwendet, aber jetzt ist er
als "Hauptzweig" bezeichnet.*

```{r, echo=F, out.width="100%", out.height="100%", fig.align="center"}
knitr::include_graphics(here::here("images", "GitHub-Flow.png"))
```

Bild
[Quelle](https://build5nines.com/introduction-to-git-version-control-workflow/)

## Einen neuen Zweig erstellen

Wenn du einen Zweig auswählst, an dem du arbeiten möchtest, **setzt Git dein Arbeitsverzeichnis zurück
so zurück, wie es war, als du das letzte Mal in diesem Zweig**.

### Im Git-Fenster von Rstudio {.unnumbered}

Vergewissere dich, dass du dich im "Haupt"-Zweig befindest, und klicke dann auf das lila Symbol, um
um einen neuen Zweig zu erstellen (siehe Bild oben).

- Du wirst aufgefordert, deinen Zweig mit einem Wort zu benennen, das die
  Namen zu benennen (bei Bedarf kannst du Unterstriche verwenden).
- Du wirst sehen, dass du dich lokal immer noch in demselben R-Projekt befindest, aber
  du arbeitest nicht mehr am "Hauptzweig".
- Sobald der neue Zweig erstellt ist, wird er auch auf der Github-Website angezeigt
  als Zweig.

Du kannst Zweige im Git-Fenster in Rstudio anzeigen lassen, nachdem du auf "History" geklickt hast.

```{r, echo=F, out.width="100%", out.height="100%", fig.align="center"}
knitr::include_graphics(here::here("images", "github_rstudio_branchs.png"))
```

### In Github Desktop {.unnumbered}

Der Prozess ist sehr ähnlich, du wirst aufgefordert, deinen Branch anzugeben
einen Namen zu geben. Danach wirst du aufgefordert, deinen Zweig auf Github zu veröffentlichen, um
damit der neue Zweig auch im Remote-Repository erscheint.

```{r, echo=F, out.width="100%", out.height="100%", fig.align="center"}
knitr::include_graphics(here::here("images", "github_desktop_new_branch.png"))
```

### In der Konsole {.unnumbered}

Was tatsächlich hinter den Kulissen passiert, ist, dass du eine neue
Zweig mit `git branch` anlegst und dann den Zweig mit
`git checkout` (*z.B..* Git mitteilen, dass deine nächsten Commits dort stattfinden werden).
Von deinem Git-Repository aus:

```{bash, eval=FALSE}
git branch my-new-branch  # Create the new branch branch
git checkout my-new-branch # Go to the branch
git checkout -b my-new-branch # Both at once (shortcut)
```

Weitere Informationen zur Verwendung der Konsole findest du im Abschnitt über
Git-Befehle am Ende.

## Änderungen committen

Jetzt kannst du den Code bearbeiten, neue Dateien hinzufügen, Datensätze aktualisieren usw.

Jede deiner Änderungen wird nachverfolgt, *sobald die jeweilige Datei
gespeichert*. Geänderte Dateien erscheinen in der Registerkarte RStudio Git auf Github
Desktop, oder mit dem Befehl `git status` im Terminal (siehe unten).

Immer, wenn du wesentliche Änderungen vornimmst (z. B. Hinzufügen oder Aktualisieren eines Abschnitts von
Code), pausiere und *Übertragen* diese Änderungen. Stell dir einen Commit als einen "Batch" vor
von Änderungen, die einem gemeinsamen Zweck dienen. Du kannst immer weiter
eine Datei weiter überarbeiten, nachdem du Änderungen an ihr vorgenommen hast.

*Hinweise zu Commits*: Generell ist es besser, kleine Commits zu machen, die
die leicht rückgängig gemacht werden können, wenn ein Problem auftritt, zusammen zu committen
Änderungen, die einem gemeinsamen Zweck dienen. Um dies zu erreichen, musst du
feststellen, dass *solltest du dich oft verpflichten*. Am Anfang wirst du wahrscheinlich
vergessen, dich oft zu verpflichten, aber dann setzt die Gewohnheit ein.

### In Rstudio {.unnumbered}

Das folgende Beispiel zeigt, dass sich das R Markdown-Skript "collaboration.Rmd" seit der letzten Übertragung geändert hat,
und mehrere PNG-Bilder hinzugefügt wurden.

```{r, echo=F, fig.align="center"}
knitr::include_graphics(here::here("images", "github_tracking2.png"))
```

Du fragst dich vielleicht, was die gelben, blauen, grünen und roten Quadrate neben den
den Dateinamen stehen. Hier ist ein Schnappschuss aus dem [RStudio
Cheatsheet](https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf)
das ihre Bedeutung erklärt. Beachte, dass Änderungen mit gelben "?" noch
staged, committed und pushed werden können.

```{r, echo=F, fig.align="center"}
knitr::include_graphics(here::here("images", "github_tracking.png"))
```

- Drücke auf die Schaltfläche "Commit" in der Registerkarte Git, wodurch sich ein neues
  Fenster (siehe unten)

- Klicke auf einen Dateinamen in der oberen linken Box

- Überprüfe die Änderungen, die du an der Datei vorgenommen hast (unten grün hervorgehoben)
  oder rot)

- "Stage" die Datei, wodurch die Änderungen in den Commit aufgenommen werden. Mach
  dies, indem du das Kästchen neben dem Dateinamen aktivierst. Alternativ kannst du
  kannst du auch mehrere Dateinamen markieren und dann auf "Bühne" klicken.

- Schreibe eine kurze, aber aussagekräftige Commit-Nachricht (erforderlich)

- Drücke die Schaltfläche "Commit". Es erscheint ein Pop-up-Fenster, das den Erfolg anzeigt
  oder eine Fehlermeldung.

Jetzt kannst du weitere Änderungen und Übertragungen vornehmen, so oft du willst

```{r, echo=F, out.width="100%", out.height="200%", fig.align="center"}
knitr::include_graphics(here::here("images", "github_commit.png"))
```

### In Github Desktop {.unnumbered}

Auf der linken Seite siehst du die Liste der Dateien, die geändert wurden. Wenn
du eine Textdatei auswählst, siehst du eine Zusammenfassung der Änderungen, die vorgenommen wurden
im rechten Bereich (diese Ansicht funktioniert nicht bei komplexeren Dateien wie .docs oder .xlsx).

Um die Änderungen zu aktivieren, musst du nur das kleine Kästchen neben dem Dateinamen anklicken. Wenn du
die Dateien ausgewählt hast, die du zu diesem Commit hinzufügen willst, gibst du den Commit
einen Namen, optional eine Beschreibung und klicke dann auf die Schaltfläche **Übertragen**
Schaltfläche.

```{r, echo=F, fig.align="center"}
knitr::include_graphics(here::here("images", "github_desktop_commit.png"))
```

### In der Konsole {.unnumbered}

Die beiden Funktionen, die hinter den Kulissen verwendet werden, sind `git add` zum Auswählen/Bühnenbild
Dateien und `git commit` um die Übergabe tatsächlich durchzuführen.

```{bash, eval=FALSE}
git status # see the changes 

git add new_pages/collaboration.Rmd  # select files to commit (= stage the changes)

git commit -m "Describe commit from Github Desktop" # commit the changes with a message

git log  # view information on past commits
```

### Eine vorherige Übertragung ändern {.unnumbered}

Was passiert, wenn du einige Änderungen festlegst, weiterarbeitest und feststellst
dass du Änderungen vorgenommen hast, die (deiner Meinung nach) zum letzten Commit "gehören".
Keine Angst! Du kannst diese Änderungen an deinen vorherigen Commit anhängen.

In Rstudio sollte es ziemlich offensichtlich sein, denn es gibt eine Funktion zum Ändern der vorherigen Übertragung.
in der gleichen Zeile wie die Schaltfläche COMMIT.

Aus einem unklaren Grund wurde diese Funktion nicht implementiert
nicht als solche in Github Desktop implementiert, aber es gibt eine (konzeptionell umständliche, aber einfache)
Umgehungsmöglichkeit. Wenn du einen Commit gemacht hast **aber nicht gepusht** deine Änderungen noch nicht veröffentlicht,
erscheint eine Schaltfläche "UNDO" direkt unter der Schaltfläche COMMIT. Klicke sie an und
und deine Übergabe wird rückgängig gemacht (aber deine bereitgestellten Dateien und deine Übergabemeldung bleiben erhalten).
Speichere deine Änderungen, füge ggf. neue Dateien zur Übergabe hinzu und übertrage sie erneut.

In der Konsole:

```{bash, eval=FALSE}
git add [YOUR FILES] # Stage your new changes

git commit --amend  # Amend the previous commit

git commit --amend -m "An updated commit message"  # Amend the previous commit AND update the commit message
```

*Hinweis: Denke nach, bevor du Commits änderst, die bereits öffentlich sind und mit deinen Mitstreitern geteilt werden*.

## Änderungen auf Github hochziehen und pushen

"Erst PULL, dann PUSH"

Es ist eine gute Praxis *abzurufen* und *ziehen* bevor du mit der Arbeit an
die Version des Zweigs auf deinem lokalen Computer zu aktualisieren mit
alle Änderungen, die in der Remote/Github-Version vorgenommen wurden.

PULL oft. Zögere nicht. *Ziehe immer, bevor du schiebst*.

Wenn deine Änderungen vorgenommen und festgeschrieben wurden und du mit dem Ergebnis zufrieden bist
Stand deines Projekts zufrieden bist, kannst du *pushen* deine Commits hoch
auf die Remote/Github-Version deines Zweigs.

Wiederhole das Ganze, während du an dem Repository arbeitest.

**Hinweis:** Es ist viel einfacher, Änderungen rückgängig zu machen, die zwar bestätigt wurden, aber nicht
(d.h. sie sind noch lokal), als Änderungen rückgängig zu machen, die in die Datenbank übertragen wurden.
Repository übertragen wurden (und vielleicht schon von jemand anderem übernommen wurden).
zu pushen, wenn du mit der Einführung von Änderungen an der Aufgabe fertig bist, die
an der du gearbeitet hast.

#### In Rstudio {.unnumbered}

*PULL* - Klicke zunächst auf das "Pull"-Symbol (Abwärtspfeil), das die Daten abruft und
gleichzeitig zieht.

*PUSH* - Du klickst auf das grüne "Pull"-Symbol (Pfeil nach oben). Du wirst möglicherweise gefragt
deinen Github-Benutzernamen und dein Passwort einzugeben. Das erste Mal, dass du
gefragt wirst, musst du eventuell zwei Git-Befehlszeilen in das Feld *Terminal*:

- **git config --global user.email
  "[you@example.com](mailto:you@example.com){.email}"** (dein Github
  E-Mail Adresse), und\\
- **git config --global user.name "Dein Github-Benutzername"**

Wie du diese Befehle eingibst, erfährst du im folgenden Abschnitt
über Git-Befehle.

***TIPP:*** Du wirst zu oft nach deinem Passwort gefragt? Siehe diese Kapitel
10 \& 11 dieses
[Tutorials](https://happygitwithr.com/credential-caching.html#credential-caching)
um mit einem SSH-Schlüssel eine Verbindung zu einem Repository herzustellen (mehr
komplizierter)

#### Im Github Desktop {.unnumbered}

Klicke auf die Schaltfläche "Fetch origin", um zu prüfen, ob es neue Commits gibt auf
dem entfernten Repository gibt.

```{r, echo=F, fig.align="center"}
knitr::include_graphics(here::here("images", "github_desktop_fetch_button.png"))
```

Wenn Git neue Commits im Remote-Repository findet, wird die Schaltfläche
in eine "Pull"-Schaltfläche umgewandelt. Da derselbe Button für Push und
pull verwendet wird, kannst du deine Änderungen nicht pushen, wenn du nicht vorher pullst.

```{r, echo=F, fig.align="center"}
knitr::include_graphics(here::here("images", "github_desktop_pull_button.png"))
```

Auf der Registerkarte "Verlauf" (neben der Registerkarte "Änderungen") kannst du alle
Commits (deine und andere) sehen. Das ist eine gute Möglichkeit, sich mit der
was deine Mitstreiter gemacht haben. Du kannst die Commit-Nachricht lesen, die
Beschreibung lesen, wenn es eine gibt, und den Code der beiden Dateien vergleichen, indem du
die *diff* fenster.

```{r, echo=F, fig.align="center"}
knitr::include_graphics(here::here("images", "github_desktop_history.png"))
```

Sobald alle Remote-Änderungen gezogen wurden und mindestens eine lokale Änderung
übertragen wurden, kannst du sie mit einem Klick auf die gleiche Schaltfläche übertragen.

```{r, echo=F, fig.align="center"}
knitr::include_graphics(here::here("images", "github_desktop_push_button.png"))
```

#### Konsole {.unnumbered}

Ohne Überraschung sind die Befehle *fetch*, *ziehen* und *schieben*.

```{bash, eval=FALSE}
git fetch  # are there new commits in the remote directory?
git pull   # Bring remote commits into your local branch
git push   # Puch local commits of this branch to the remote branch
```

### Ich möchte ziehen, aber ich muss vor Ort arbeiten {.unnumbered}

Das kann manchmal passieren:
Du hast einige Änderungen an deinem lokalen Repository vorgenommen, aber das Remote
Repository hat Commits, die du nicht gezogen hast.

Git verweigert das Pulling, weil es deine Änderungen überschreiben könnte.
Es gibt verschiedene Strategien, um deine Änderungen zu behalten,
gut beschrieben in [Glückliches Git mit R](https://happygitwithr.com/pull-tricky.html),
Die zwei wichtigsten davon sind:

- Änderungen übertragen, entfernte Änderungen abrufen, sie einfügen, Konflikte lösen
  falls nötig (siehe Abschnitt unten), und pushen alles online
- `stash` deine Änderungen, die du sozusagen beiseite legst, ziehst, entsorgst
  (wiederherstellen) und dann committen, alle Konflikte lösen und pushen.

Wenn die Dateien, die von den entfernten Änderungen betroffen sind, und die Dateien, die
nicht überschneiden, kann Git Konflikte automatisch lösen.

In Github Desktop kann dies mit Schaltflächen geschehen. Um einen Stash zu erstellen, gehst du zu *Branch > Stash all changes*.

```{r, echo=F, fig.align="center"}
knitr::include_graphics(here::here("images", "github_desktop_stash.png"))
```

## Zweig in Main zusammenführen

Wenn du die Änderungen abgeschlossen hast, kannst du den Prozess der
diese Änderungen mit dem Hauptzweig zusammenzuführen. Das hängt von deiner Situation ab,
kann das schnell gehen, oder du musst die Änderungen bewusst überprüfen und genehmigen
schritte mit Teamkollegen.

### Lokal auf dem Github Desktop {.unnumbered}

Du kannst Zweige lokal mit Github Desktop zusammenführen. Gehe zuerst zu
(checkout) den Zweig, der der Empfänger der Commits sein wird, also den
Zweig, den du aktualisieren willst. Dann gehst du in das Menü *Zweig > Zusammenführen in
aktuellen Zweig* und klicke darauf. In einem Feld kannst du den Zweig auswählen, den du
aus dem du importieren möchtest.

```{r, echo=F, fig.align="center"}
knitr::include_graphics(here::here("images", "github_desktop_merge.png"))
```

### In der Konsole {.unnumbered}

Gehe zuerst zurück zu dem Zweig, der die Änderungen erhalten soll.
Das ist normalerweise *master* aber es kann auch ein anderer Zweig sein. Dann führe deine
Arbeitszweig in master ein.

```{bash, eval=FALSE}
git checkout master  # Go back to master (or to the branch you want to move your )
git merge this_fancy_new_branch
```

[Diese
Seite](https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging)
zeigt ein fortgeschrittenes Beispiel für Verzweigungen und erklärt ein wenig, was
was hinter den Kulissen passiert.

### In Github: Einreichen von Pull Requests {.unnumbered}

Es ist zwar durchaus möglich, zwei Zweige lokal zusammenzuführen, oder ohne
jemanden zu informieren, kann eine Fusion von mehreren Personen diskutiert oder untersucht werden.
Personen diskutiert oder untersucht werden, bevor sie in den Hauptzweig integriert werden. Zur Unterstützung der
Prozess zu unterstützen, bietet Github einige Diskussionsfunktionen rund um den Merge: die
**Pull-Anfrage**.

Ein Pull Request (ein "PR") ist eine Anfrage, einen Zweig in einen anderen zusammenzuführen.
(mit anderen Worten, eine Anfrage, die *dass dein Arbeitszweig in den "Hauptzweig" gezogen wird*).
Ein Pull Request umfasst normalerweise mehrere Commits. Ein Pull-Request ist in der Regel der Beginn einer Diskussion und Überprüfung
Prozess, bevor er akzeptiert und der Zweig zusammengeführt wird. Zum Beispiel,
kannst du Pull Request Diskussionen lesen auf [dplyr's
github](https://github.com/tidyverse/dplyr/pulls).

Du kannst einen Pull Request (PR) direkt über die Website einreichen (als
unten abgebildet) oder über Github Desktop einreichen.

- Gehe zum Github Repository (online)
- Sieh dir den Reiter "Pull Requests" an und klicke auf die Schaltfläche "New pull request".
- Wähle aus dem Dropdown-Menü aus, dass dein Zweig mit dem Hauptzweig zusammengeführt werden soll
- Schreibe einen detaillierten Pull Request-Kommentar und klicke auf "Pull Request erstellen
  Anfrage".

In der Abbildung unten wurde der Zweig "Wälder" ausgewählt, um zusammengeführt zu werden
in "main" zusammengeführt wird:

```{r, echo=F, out.width="100%", out.height="150%", fig.align="center"}
knitr::include_graphics(here::here("images", "github_pull_request2.png"))
```

Jetzt solltest du den Pull Request sehen können (Beispielbild unten):

- Überprüfe den Reiter "Geänderte Dateien", um zu sehen, wie der "Haupt"-Zweig aussehen würde
  sich ändern würde, wenn der Zweig zusammengeführt würde.\\
- Auf der rechten Seite kannst du eine Überprüfung durch Mitglieder deines Teams anfordern, indem du
  ihre Github ID markierst. Wenn du möchtest, kannst du das Repository
  so einstellen, dass nur eine zustimmende Überprüfung erforderlich ist, um das Projekt in
  main.\\
- Sobald der Pull Request genehmigt ist, wird eine Schaltfläche zum
  "Pull Request zusammenführen" aktiv werden. Klicke darauf.\\
- Wenn du fertig bist, lösche deinen Zweig wie unten beschrieben.

```{r, echo=F, out.width="100%", out.height="200%", fig.align="center"}
knitr::include_graphics(here::here("images", "github_pull_request.png"))
```

### Konflikte auflösen {.unnumbered}

Wenn zwei Personen dieselbe(n) Zeile(n) gleichzeitig ändern, wird ein
Merge-Konflikt entstehen. Git weigert sich nämlich, eine Entscheidung zu treffen über
welche Version beibehalten werden soll, aber es hilft dir, herauszufinden, wo die
Konflikt ist. **KEINE PANIK**. Die meiste Zeit ist es ganz einfach
zu beheben.

Zum Beispiel auf Github:

```{r, echo=F, out.width="100%", out.height="200%", fig.align="center"}
knitr::include_graphics(here::here("images", "github_conflict2.png"))
```

Nachdem das Zusammenführen einen Konflikt ausgelöst hat, öffne die Datei in deinem bevorzugten Editor.
Der Konflikt wird durch eine Reihe von Zeichen angezeigt:

```{r, echo=F, out.width="100%", out.height="200%", fig.align="center"}
knitr::include_graphics(here::here("images", "github_conflict3.png"))
```

Der Text zwischen *\<\<\<\<\<\<\< KOPF* und *\=======
* kommt von deinem
lokalen Repository, und diejenige zwischen *\=======
* und *\>>>>>>>* von der
dem anderen Zweig (das kann origin, master oder ein beliebiger Zweig von
deiner Wahl sein).

Du musst entscheiden, welche Version des Codes du bevorzugst (oder sogar eine
(oder schreibe sogar eine dritte, die die Änderungen beider Seiten enthält), lösche den Rest
und entferne alle Markierungen, die Git hinzugefügt hat *(\<\<\<\<\<\<\< HEAD, =======,
\>>>>>>> origin/master/ihr\_Zweig\_name*).

Dann speicherst du die Datei, stellst sie bereit und übergibst sie: Das ist der Commit
der die zusammengeführte Version "offiziell" macht. Vergiss nicht, anschließend zu pushen.

Je öfter du und deine Mitstreiter ziehen und pushen, desto kleiner ist die
Konflikte werden kleiner.

*Hinweis: Wenn du mit der Konsole gut zurechtkommst, gibt es weitere [fortgeschrittene
Zusammenführen
Optionen](https://git-scm.com/book/en/v2/Git-Tools-Advanced-Merging)
(z. B. Leerzeichen ignorieren, einem Mitspieler Priorität geben usw.).*

### Deinen Zweig löschen {.unnumbered}

Wenn ein Zweig in Master zusammengeführt wurde und nicht mehr benötigt wird, kannst du
löschen.

#### Github + Rstudio

Gehe zum Repository auf Github und klicke auf die Schaltfläche, um alle
Zweige anzuzeigen (neben dem Dropdown-Menü zur Auswahl der Zweige). Finde nun deine
Zweig und klicke auf das Papierkorbsymbol neben ihm. Lies mehr Details zum Löschen
einer Verzweigung
[hier](https://docs.github.com/en/free-pro-team@latest/github/collaborating-with-issues-and-pull-requests/creating-and-deleting-branches-within-your-repository#deleting-a-branch).

Achte darauf, dass du den Zweig auch lokal auf deinem Computer löschst. Dies wird
nicht automatisch geschehen.

- Vergewissere dich in RStudio, dass du dich im Hauptzweig befindest
- Wechsle zur Eingabe von Git-Befehlen im "Terminal" von RStudio (der Reiter
  neben der R-Konsole) und gib ein: **git branch -d
  branch\_name** wobei "branch\_name" der Name deines zu bearbeitenden Zweigs ist
  gelöscht werden soll
- Aktualisiere deinen Git-Tab und der Zweig sollte verschwunden sein

#### In Github Desktop

Checke einfach den Zweig aus, den du löschen möchtest, und gehe in das Menü
*Zweig > Löschen*.

### Forking {.unnumbered}

Du kannst ein Projekt forken, wenn du dazu beitragen möchtest, aber
aber nicht die Rechte dazu hast, oder wenn du einfach
wenn du es für deinen persönlichen Gebrauch verändern willst. A
kurze Beschreibung des Forkings findest du [hier](https://guides.github.com/activities/forking/).

Auf Github klickst du auf die Schaltfläche "Fork":

```{r, echo=F, out.width="100%", out.height="200%", fig.align="center"}
knitr::include_graphics(here::here("images", "github_fork_1.png"))
```

Dadurch wird das ursprüngliche Repository geklont, aber in deinem eigenen Profil. Also jetzt,
gibt es zwei Versionen des Repositorys **auf Github**: die ursprüngliche Version,
das du nicht ändern kannst, und die geklonte Version in deinem Profil.

Dann kannst du damit fortfahren, deine Version des Online-Repositorys lokal zu klonen
auf deinem Computer klonen, indem du eine der in den vorherigen Abschnitten beschriebenen Methoden anwendest.
Dann kannst du einen neuen Zweig erstellen, Änderungen vornehmen, sie übertragen und pushen
*in dein entferntes Projektarchiv*.

Wenn du mit dem Ergebnis zufrieden bist, kannst du einen Pull Request erstellen
von Github oder Github Desktop aus erstellen, um die Konversation mit dem
Eigentümern/Maintainern des ursprünglichen Repository zu beginnen.

**Was ist, wenn du neuere Commits aus dem offiziellen Repository benötigst?**

Stell dir vor, jemand nimmt eine wichtige Änderung am offiziellen Repository vor,
die du in deine geklonte Version aufnehmen möchtest.
Es ist möglich, deinen Fork mit dem offiziellen Projektarchiv zu synchronisieren.
Dazu musst du das Terminal benutzen, aber es ist nicht allzu kompliziert.
Du musst dir das nur merken:

- *Upstream* = das offizielle Repository, das du nicht verändern konntest
- *Herkunft* = deine Version des Repositorys in deinem Github-Profil

Du kannst lesen [dieses Tutorial](https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork) oder unten nachlesen:

Zuerst gibst du in deinem Git-Terminal (innerhalb deines Repo) ein:

```{bash, eval=FALSE}
git remote -v
```

Wenn du das Upstream-Repository noch nicht konfiguriert hast, solltest du
zwei Zeilen sehen, beginnend mit *origin*. Sie zeigen das Remote Repo
das `fetch` und `push` zeige auf. Denke daran, *Ursprung* ist der konventionelle
Nickname für deine eigene Version des Repositorys auf Github. Zum Beispiel:

```{r, echo=F, out.width="100%", out.height="200%", fig.align="center"}
knitr::include_graphics(here::here("images", "github_fork_2.png"))
```

Jetzt fügst du ein neues Remote-Repository hinzu:

```{bash, eval=FALSE}
git remote add upstream https://github.com/appliedepi/epirhandbook_eng.git
```

Hier ist die Adresse die Adresse, die Github generiert, wenn du klonst
ein Repository klonst (siehe Abschnitt zum Klonen). Jetzt hast du vier Remote-Zeiger:

```{r, echo=F, out.width="100%", out.height="200%", fig.align="center"}
knitr::include_graphics(here::here("images", "github_fork_3.png"))
```

Wenn du nun die Änderungen aus dem Repository abrufen willst, musst du
dem Original (*Upstream*) Repository zu finden, musst du einfach (*checkout*) zu
den Zweig, den du aktualisieren willst, und gib ihn ein:

```{bash, eval=FALSE}
git fetch upstream # Get the new commits from the remote repository
git checkout the_branch_you_want_to_update
git merge upstream/the_branch_you_want_to_update  # Merge the upstream branch into your branch.
git push # Update your own version of the remote repo
```

Wenn es Konflikte gibt, musst du sie lösen, wie erklärt
im Abschnitt Konflikte lösen.

**Zusammenfassung** Forking ist Klonen, aber auf der Github-Server-Seite.
Der Rest der Aktionen sind typische Arbeitsabläufe für die Zusammenarbeit
(clone, push, pull, commit, merge, pull requests einreichen...).

*Hinweis: Forking ist zwar ein Konzept und kein Git-Befehl, aber es gibt es auch auf anderen Webhosts, wie [Bitbucket](https://www.atlassian.com/git/tutorials/comparing-workflows/forking-workflow).*

```{r, echo=F, out.width="100%", out.height="200%", fig.align="center"}
knitr::include_graphics(here::here("images", "github_fork_4.png"))
```

## Was wir gelernt haben

Du hast gelernt, wie man:

- Git einzurichten, um Änderungen in deinen Ordnern zu verfolgen,
- verbinde dein lokales Repository mit einem entfernten Online-Repository,
- übertrage die Änderungen,
- synchronisiere deine lokalen und entfernten Repositories.

Das alles sollte für die meisten deiner Bedürfnisse ausreichen, da
Epidemiologen. Wir haben in der Regel nicht so fortschrittliche Anwendungen wie Entwickler.

Du solltest jedoch wissen, dass Git mehr Möglichkeiten zur Vereinfachung bietet, wenn du weiter gehen willst (oder musst).
Commit-Historien, das Zurücknehmen eines oder mehrerer Commits, Cherry-Pick-Commits, etc.
Einiges davon mag sich wie reine Zauberei anhören, aber jetzt kennst du die Grundlagen,
ist es einfacher, darauf aufzubauen.

Beachte, dass das Git-Fenster in Rstudio und Github Desktop zwar gut für
Einsteiger / den täglichen Gebrauch in unserer Branche gut geeignet sind, bieten sie keine
Schnittstelle zu einigen der fortgeschrittenen Git-Funktionen.
Einige umfassendere Schnittstellen ermöglichen es dir, mit Point-and-Click mehr zu tun
(meist auf Kosten eines komplexeren Layouts).

Denke daran, dass du jedes Tool an jedem Punkt nutzen kannst, um dein Repository zu verfolgen,
kannst du ganz einfach eine Schnittstelle installieren, um sie einmal auszuprobieren,
oder um gelegentlich eine weniger häufige komplexe Aufgabe zu erledigen,
während du für den Rest der Zeit eine vereinfachte Schnittstelle bevorzugst (z. B. mit
Github Desktop die meiste Zeit und wechsle für bestimmte Aufgaben zu SourceTree oder Gitbash).

## Git-Befehle {#git}

### Empfohlenes Lernen {.unnumbered}

Um Git-Befehle in einem interaktiven Tutorial zu lernen, siehe [diese
Website](https://learngitbranching.js.org/).

### Wo du Befehle eingeben kannst {.unnumbered}

Du gibst die Befehle in einer Git-Shell ein.

*Option 1* Du kannst ein neues Terminal in RStudio öffnen. Diese Registerkarte befindet sich neben
der R-Konsole. Wenn du dort keinen Text eingeben kannst, klicke auf das
Dropdown-Menü unter "Terminal" und wähle "Neues Terminal". Tippe den
Befehle in das blinkende Feld vor dem Dollarzeichen "$" ein.

```{r, echo=F, out.width="100%", out.height="200%", fig.align="center"}
knitr::include_graphics(here::here("images", "github_terminal.png"))
```

*Option 2* Du kannst auch eine *Shell* (ein Terminal zur Eingabe von Befehlen) öffnen, indem du
auf das blaue "Zahnrad"-Symbol auf der Registerkarte Git (neben dem RStudio
Umgebung). Wähle "Shell" aus dem Dropdown-Menü. Ein neues Fenster wird
geöffnet, in dem du die Befehle nach dem Dollarzeichen "$" eingeben kannst.

*Option 3* Klicke mit der rechten Maustaste, um "Git Bash hier" zu öffnen, was dasselbe öffnen wird
Art von Terminal, oder öffnen Sie *Git Bash* in deiner Anwendungsliste.
[Weitere einsteigerfreundliche Informationen zu Git Bash](https://happygitwithr.com/shell.html),
wie du sie findest und einige Bash-Befehle, die du brauchst.

### Beispielhafte Befehle {.unnumbered}

Im Folgenden stellen wir dir ein paar gängige Git-Befehle vor. Wenn du sie verwendest, solltest du Folgendes beachten
welcher Zweig aktiv (ausgecheckt) ist, denn das ändert die Aktion!

In den folgenden Befehlen, <Name> für einen Zweignamen.
\<commit\_hash> steht für die Hash-ID eines bestimmten
Commit. <Zahl> steht für eine Zahl. Gib nicht die
\< oder > Symbole ein.

| Git-Befehl | Aktion                                                                                     | 
| ---------- | ------------------------------------------------------------------------------------------ |
| `git branch <name>`           | Erstelle einen neuen Zweig mit dem Namen <Name>                                                  | 
| `git checkout <name>`           | Wechsle den aktuellen Zweig zu <Name>                                                            | 
| `git checkout -b <name>`           | Shortcut zum Erstellen eines neuen Zweigs *und* zu ihm zu wechseln                                                 | 
| `git status`           | Unverfolgte Änderungen sehen                                                               | 
| `git add <file>`           | Eine Datei in Szene setzen                                                                 | 
| `git commit -m <message>`           | Übertrage die aktuell bereitgestellten Änderungen in den aktuellen Zweig mit der Nachricht | 
| `git fetch`           | Commits vom entfernten Repository abrufen                                                  | 
| `git pull`           | Commits aus dem entfernten Repository in den aktuellen Zweig ziehen                        | 
| `git push`           | Lokale Commits in das entfernte Verzeichnis verschieben                                    | 
| `git switch`           | Eine Alternative zu `git checkout` die schrittweise in Git eingeführt wird                                                                       | 
| `git merge <name>`           | Zusammenführen <Name> Zweig in den aktuellen Zweig                                                                            | 
| `git rebase <name>`           | Commits aus dem aktuellen Zweig anhängen an <Name> Zweig                                               | 

<!-- ======================================================= -->

## Ressourcen

Vieles auf dieser Seite wurde beeinflusst durch [dieses "Happy Git mit R"
Website](https://happygitwithr.com/) von Jenny Bryan. Es gibt eine sehr hilfreiche
dieser Website gibt es einen sehr hilfreichen Abschnitt, der dir bei der Fehlersuche in Git und
R-bezogenen Fehlern.

Die [Github.com Dokumentation und Start
Leitfaden](https://docs.github.com/en/github).

Das RStudio ["IDE"
Spickzettel](https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf)
das Tipps zu Git mit RStudio enthält.

[https://ohi-science.org/news/github-going-back-in-time](https://ohi-science.org/news/github-going-back-in-time)

**Git-Befehle für Anfänger**

Eine [interaktive
Lernprogramm](learngitbranching.js.org) zum Lernen
Git-Befehle.

[https://www.freecodecamp.org/news/an-introduction-to-git-for-absolute-beginners-86fa1d32ff71/](https://www.freecodecamp.org/news/an-introduction-to-git-for-absolute-beginners-86fa1d32ff71/):
Gut geeignet, um die absoluten Grundlagen zu lernen, um Änderungen in einem Ordner auf
deinem eigenen Computer.

Schöne Schemata, um Verzweigungen zu verstehen:
[https://speakerdeck.com/alicebartlett/git-for-humans](https://speakerdeck.com/alicebartlett/git-for-humans)

**Tutorien zu grundlegenden und fortgeschrittenen Themen**

[https://tutorialzine.com/2016/06/learn-git-in-30-minutes](https://tutorialzine.com/2016/06/learn-git-in-30-minutes)

[https://dzone.com/articles/git-tutorial-commands-and-operations-in-git](https://dzone.com/articles/git-tutorial-commands-and-operations-in-git)
[https://swcarpentry.github.io/git-novice/](https://swcarpentry.github.io/git-novice/) (kurzer Kurs)
[https://rsjakob.gitbooks.io/git/content/chapter1.html](https://rsjakob.gitbooks.io/git/content/chapter1.html)

Die [Pro Git Buch](https://git-scm.com/book/en/v2) gilt als offizielle Referenz.
Während einige Kapitel in Ordnung sind, ist es normalerweise ein bisschen *technisch*. Es ist wahrscheinlich eine gute Ressource
wenn du Git schon ein bisschen benutzt hast und etwas genauer lernen willst
was passiert und wie du weiter vorgehen kannst.


