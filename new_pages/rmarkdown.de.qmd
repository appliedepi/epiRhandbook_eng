# Berichte mit R Markdown { }

```{r, out.width="100%", fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "markdown/rmarkdown_overview.png"))
```

R Markdown ist ein weit verbreitetes Werkzeug zur Erstellung automatisierter, reproduzierbarer und veröffentlichungswürdiger Ergebnisse wie z. B. Berichte. Es kann statische oder interaktive Ausgaben in Word, PDF, HTML, PowerPoint und anderen Formaten erstellen.

Ein R Markdown-Skript verbindet R-Code und Text so, dass das Skript tatsächlich *dein Ausgabedokument wird*. Du kannst ein komplettes formatiertes Dokument erstellen, einschließlich narrativem Text (der sich dynamisch auf Basis deiner Daten ändern kann), Tabellen, Abbildungen, Aufzählungszeichen/Zahlen, Bibliografien usw.

Solche Dokumente können routinemäßig aktualisiert werden (z. B. tägliche Überwachungsberichte) und/oder für Teilmengen von Daten erstellt werden (z. B. Berichte für jedes Bundesland).

Andere Seiten in diesem Handbuch behandeln dieses Thema ausführlicher:

- Die Seite [Organisieren von Routineberichten] zeigt dir, wie du deine Berichtsproduktion mit automatisch erstellten Ordnern mit Zeitstempeln routinieren kannst.
- Die Seite [Dashboards mit R Markdown] wird erklärt, wie man einen R Markdown-Bericht als Dashboard formatiert.

Bemerkenswert ist, dass die [R4Epis](https://r4epis.netlify.app/) Projekt hat Vorlagen für R Markdown-Skripte für häufige Ausbrüche und Erhebungsszenarien entwickelt, die an MSF-Projektstandorten auftreten.

<!-- ======================================================= -->

## Vorbereitung {  }

**Hintergrund zu R Markdown**

Um einige der Konzepte und Pakete zu erklären:

- **Markdown** ist eine "Sprache", die es dir ermöglicht, ein Dokument in einfachem Text zu schreiben, das in HTML und andere Formate umgewandelt werden kann. Sie ist nicht spezifisch für R. Dateien, die in Markdown geschrieben sind, haben die Endung ".md".
- **R Markdown**: ist eine Variante von Markdown, die *spezifisch für R ist* - Sie ermöglicht es dir, ein Dokument mit Markdown zu schreiben, um Text zu erzeugen *und R-Code einzubetten und dessen Ausgaben anzuzeigen*. R Markdown-Dateien haben die Erweiterung ".Rmd".
- **rmarkdown - das Paket** rmarkdown: Dieses Paket wird von R verwendet, um die .Rmd-Datei in die gewünschte Ausgabe zu verwandeln. Der Schwerpunkt liegt auf der Umwandlung der Markdown (Text)-Syntax, daher brauchen wir auch...
- **knitr** Dieses R-Paket liest die Code-Bausteine, führt sie aus und fügt sie wieder in das Dokument ein. So werden neben dem Text auch Tabellen und Diagramme eingefügt.
- **Pandoc** Schließlich konvertiert Pandoc die Ausgabe in Word/Pdf/Powerpoint usw. Es ist eine von R getrennte Software, wird aber automatisch mit RStudio installiert.

Zusammenfassend lässt sich sagen, dass der Prozess, der passiert *im Hintergrund* (du musst nicht alle diese Schritte kennen!) besteht darin, die .Rmd-Datei an **knitr** ein, das die R-Code-Bausteine ausführt und eine neue .md-Datei (Markdown) erstellt, die den R-Code und die gerenderte Ausgabe enthält. Die .md-Datei wird dann von pandoc verarbeitet, um das fertige Produkt zu erstellen: ein Microsoft Word-Dokument, eine HTML-Datei, ein Powerpoint-Dokument, ein PDF usw.

```{r, out.width="100%", fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "markdown/0_rmd.png"))
```

(Quelle: [https://rmarkdown.rstudio.com/authoring\_quick\_tour.html](https://rmarkdown.rstudio.com/authoring_quick_tour.html)):

**Installation**

Um eine R Markdown-Ausgabe zu erstellen, musst du Folgendes installiert haben:

- Die **rmarkdown** Paket (**knitr** wird ebenfalls automatisch installiert)
- Pandoc, das mit RStudio installiert werden sollte. Wenn du RStudio nicht verwendest, kannst du Pandoc hier herunterladen: [http://pandoc.org](http://pandoc.org).
- Wenn du eine PDF-Ausgabe erzeugen möchtest (was etwas schwieriger ist), musst du LaTeX installieren. Für R Markdown-Benutzer, die LaTeX noch nicht installiert haben, empfehlen wir die Installation von TinyTeX ([https://yihui.name/tinytex/](https://yihui.name/tinytex/)). Du kannst die folgenden Befehle verwenden:

```{r, eval=F}
pacman::p_load(tinytex)     # install tinytex package
tinytex::install_tinytex()  # R command to install TinyTeX software
```

<!-- ======================================================= -->

## Erste Schritte {  }

### Installiere das R-Paket rmarkdown {.unnumbered}

Installiere das **rmarkdown** R-Paket. In diesem Handbuch betonen wir `p_load()` von **pacman**, der das Paket bei Bedarf installiert *und* lädt es zur Verwendung. Du kannst installierte Pakete auch laden mit `library()` von **base**R. Siehe die Seite über [R-Grundlagen] für weitere Informationen über R-Pakete.

```{r, eval=F}
pacman::p_load(rmarkdown)
```

### Starten einer neuen Rmd-Datei {.unnumbered}

Öffne in RStudio eine neue R-Markdown-Datei. Beginne mit "Datei", dann "Neue Datei" und "R-Markdown...".

```{r, out.width="50%", fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "markdown/1_gettingstarted.png"))
```

R Studio bietet dir einige Ausgabeoptionen zur Auswahl an. Im folgenden Beispiel wählen wir "HTML", weil wir ein HTML-Dokument erstellen wollen. Der Titel und die Autorennamen sind nicht wichtig. Wenn der gewünschte Ausgabedokumenttyp nicht dabei ist, ist das kein Problem - du kannst einfach einen beliebigen Typ auswählen und ihn später im Skript ändern.

```{r, out.width="50%", fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "markdown/1_gettingstartedB.png"))
```

Dadurch wird ein neues .Rmd-Skript geöffnet.

### Wichtig zu wissen {.unnumbered}

**Das Arbeitsverzeichnis**

Das Arbeitsverzeichnis einer Markdown-Datei befindet sich dort, wo die Rmd-Datei selbst gespeichert ist. Wenn sich das R-Projekt zum Beispiel im `~/Documents/projectX ` und die Rmd-Datei selbst befindet sich in einem Unterordner `~/Documents/projectX/markdownfiles/markdown.Rmd` befindet, wird der Code `read.csv("data.csv")` im Markdown nach einer csv-Datei im Ordner `markdownfiles` Ordner und nicht im Stammordner des Projekts, in dem Skripte innerhalb von Projekten normalerweise automatisch suchen würden.

Um auf Dateien an anderer Stelle zu verweisen, musst du entweder den vollständigen Dateipfad angeben oder die **hier** Paket. Die **hier**Paket setzt das Arbeitsverzeichnis auf den Stammordner des R-Projekts und wird im Detail in der [R-Projekte] und  erklärt.      [Import und Export]       Seiten dieses Handbuchs erklärt. Um zum Beispiel eine Datei namens "data.csv" aus dem Paket`projectX` Ordner zu importieren, würde der Code lauten `import(here("data.csv"))`.

Beachte, dass die Verwendung von `setwd()` in R Markdown-Skripten nicht empfohlen wird - sie gilt nur für den Codechunk, in dem sie geschrieben ist.

**Arbeiten auf einem Laufwerk statt auf deinem Computer**

Da es bei R Markdown zu Problemen mit Pandoc kommen kann, wenn es auf einem freigegebenen Netzlaufwerk ausgeführt wird, wird empfohlen, den Ordner auf deinem lokalen Rechner zu erstellen, z. B. in einem Projekt unter "Eigene Dateien". Wenn du Git verwendest (sehr empfehlenswert!), wirst du damit vertraut sein. Weitere Informationen findest du auf den Handbuchseiten zu [R auf Netzlaufwerken] und [Fehler und Hilfe].

<!-- ======================================================= -->

## R Markdown Komponenten {  }

Ein R Markdown-Dokument kann in RStudio genauso bearbeitet werden wie ein Standard-R-Skript. Wenn du ein neues R Markdown-Skript startest, versucht RStudio dir zu helfen, indem es eine Vorlage anzeigt, die die verschiedenen Abschnitte eines R Markdown-Skripts erklärt.

Das folgende Bild wird angezeigt, wenn du ein neues Rmd-Skript startest, das eine HTML-Ausgabe erzeugen soll (wie im vorherigen Abschnitt).

```{r, out.width="100%", fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "markdown/2_defaultRMD.png"))
```

Wie du sehen kannst, besteht eine Rmd-Datei aus drei grundlegenden Komponenten: YAML, Markdown-Text und R-Code-Bausteine.

Diese werden *erstellt und werden zu deiner Dokumentenausgabe*. Siehe das Diagramm unten:

```{r, out.width="100%", out.height="150%", fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "markdown/rmarkdown_translation.png"))
```

### YAML-Metadaten {.unnumbered}

Die so genannten "YAML-Metadaten" oder einfach nur "YAML" befinden sich am Anfang des R Markdown-Dokuments. In diesem Abschnitt des Skripts wird deiner Rmd-Datei mitgeteilt, welche Art von Ausgabe erzeugt werden soll, welche Formatierung gewünscht wird und welche anderen Metadaten wie Titel, Autor und Datum des Dokuments angegeben werden sollen. Es gibt noch weitere Verwendungszwecke, die hier nicht erwähnt werden (aber im Abschnitt "Eine Ausgabe erzeugen"). Beachte, dass die Einrückung wichtig ist; Tabulatoren werden nicht akzeptiert, Leerzeichen hingegen schon.

Dieser Abschnitt muss mit einer Zeile beginnen, die nur drei Bindestriche enthält `---` und muss mit einer Zeile mit drei Bindestrichen enden `---`. YAML-Parameter kommen in `key:value` Paaren. Die Platzierung von Doppelpunkten in YAML ist wichtig - die `key:value` Paare werden durch Doppelpunkte getrennt (nicht durch Gleichheitszeichen!).

Die YAML sollte mit den Metadaten für das Dokument beginnen. Die Reihenfolge dieser primären YAML-Parameter (nicht eingerückt) spielt keine Rolle. Zum Beispiel:

```yaml
title: "My document"
author: "Me"
date: "`r Sys.Date()`"
```

Du kannst R-Code in YAML-Werten verwenden, indem du ihn als Inline-Code schreibst (mit vorangestelltem `r` innerhalb von Back-Ticks), aber auch innerhalb von Anführungszeichen (siehe obiges Beispiel für `date: `).

In der obigen Abbildung sehen wir, dass die YAML-Datei Folgendes enthält, weil wir angeklickt haben, dass die Standardausgabe eine HTML-Datei sein soll `output: html_document`. Wir können dies aber auch ändern und sagen `powerpoint_presentation` oder `word_document` oder sogar `pdf_document`.

### Text {.unnumbered}

Dies ist der Text deines Dokuments, einschließlich der Titel und Überschriften. Er ist in der Sprache "Markdown" geschrieben, die in vielen verschiedenen Programmen verwendet wird.

Im Folgenden findest du die wichtigsten Methoden, um diesen Text zu schreiben. Eine ausführlichere Dokumentation findest du im R Markdown "Cheatsheet" auf der [RStudio-Website](https://rstudio.com/resources/cheatsheets/).

#### Neue Zeilen {.unnumbered}

Einzigartig in R Markdown: Um eine neue Zeile zu beginnen, gibst du ein *zwei Leerzeichen*\* am Ende der vorherigen Zeile und dann Enter/Return.

#### Fall {.unnumbered}

Umfasse deinen normalen Text mit diesen Zeichen, um zu ändern, wie er in der Ausgabe erscheint.

- Unterstriche (`_text_`) oder einzelne Sternchen (`*text*`) zu *kursiv zu setzen*
- Doppelte Sternchen (`**text**`) für **fetten Text**
- Rückwärtshaken (`text`), um Text als Code anzuzeigen

Das tatsächliche Aussehen der Schriftart kann durch die Verwendung bestimmter Vorlagen (die in den YAML-Metadaten angegeben werden; siehe Beispieltabs) festgelegt werden.

#### Farbe {.unnumbered}

Es gibt keinen einfachen Mechanismus, um die Farbe von Text in R Markdown zu ändern. Ein Workaround, *WENN deine Ausgabe eine HTML-Datei ist* ist es, eine HTML-Zeile in den Markdown-Text einzufügen. Der folgende HTML-Code druckt eine Textzeile in fetter roter Schrift.

```md
<span style="color: red;">**_DANGER:_** This is a warning.</span>  
```

<span style="color: red;">***GEFAHR!*** Dies ist eine Warnung.</span>

#### Titel und Überschriften {.unnumbered}

Ein Rautensymbol in einem Textteil eines R Markdown-Skripts erzeugt eine Überschrift. Das ist etwas anderes als in einem Stück R-Code im Skript, in dem ein Raute-Symbol ein Mechanismus zum Kommentieren/Annotieren/Deaktivieren ist, wie in einem normalen R-Skript.

Verschiedene Überschriftenebenen werden mit einer unterschiedlichen Anzahl von Rautensymbolen am Anfang einer neuen Zeile festgelegt. Ein Rautensymbol ist ein Titel oder eine erste Überschrift. Zwei Rautensymbole sind eine Überschrift der zweiten Ebene. Überschriften der dritten und vierten Ebene können mit immer mehr Rautensymbolen erstellt werden.

```md
# First-level heading / title

## Second level heading  

### Third-level heading
```

#### Aufzählungszeichen und Nummerierung {.unnumbered}

Verwende Sternchen (`*`), um eine Aufzählungsliste zu erstellen. Beende den vorherigen Satz, gib zwei Leerzeichen ein, Enter/Return *zweimal* und beginne dann deine Aufzählungspunkte. Füge ein Leerzeichen zwischen dem Sternchen und deinem Aufzählungstext ein. Nach jedem Aufzählungszeichen gibst du zwei Leerzeichen ein und dann Enter/Return. Unteraufzählungen funktionieren genauso, werden aber eingerückt. Zahlen funktionieren genauso, aber statt eines Sternchens schreibst du 1), 2), usw. So könnte der Text deines R Markdown-Skripts aussehen.

```md
Here are my bullets (there are two spaces after this colon):  

* Bullet 1 (followed by two spaces and Enter/Return)  
* Bullet 2 (followed by two spaces and Enter/Return)  
  * Sub-bullet 1 (followed by two spaces and Enter/Return)  
  * Sub-bullet 2 (followed by two spaces and Enter/Return)  
  
```

#### Text auskommentieren {.unnumbered}

Du kannst R Markdown-Text auskommentieren, genauso wie du das "#" verwenden kannst, um eine Zeile R-Code in einem R Chunk auszukommentieren. Markiere einfach den Text und drücke Strg+Umschalt+c (Cmd+Umschalt+c für Mac). Der Text ist dann von Pfeilen umgeben und wird grün. Er wird nicht in deiner Ausgabe erscheinen.

```{r, out.width="100%", fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "markdown/rmarkdown_hide_text.png"))
```

### Code-Blöcke {.unnumbered}

Die Abschnitte des Skripts, in denen der R-Code ausgeführt wird, werden "Chunks" genannt. Hier kannst du Pakete laden, Daten importieren und die eigentliche Datenverwaltung und Visualisierung durchführen. Da es viele Code-Chunks geben kann, können sie dir helfen, deinen R-Code in Teile zu gliedern, die vielleicht mit Text durchsetzt sind. Zu beachten:
Diese "Chunks" haben eine etwas andere Hintergrundfarbe als der erzählende Teil des Dokuments.

Jeder Chunk wird mit einer Zeile eröffnet, die mit drei Back-Ticks beginnt, und geschweiften Klammern, die Parameter für den Chunk enthalten (`{ }`). Der Chunk endet mit drei weiteren Back-Ticks.

Du kannst einen neuen Chunk erstellen, indem du ihn selbst eintippst, die Tastenkombination "Strg + Alt + i" (bzw. Cmd + Shift + r beim Mac) verwendest oder auf das grüne Symbol "Neuen Codechunk einfügen" oben in deinem Skripteditor klickst.

Einige Hinweise zum Inhalt der geschweiften Klammern `{ }`:

- Sie beginnen mit "r", um anzuzeigen, dass der Sprachname innerhalb des Chunks R ist.
- Nach dem "r" kannst du optional einen "Namen" für den Chunk schreiben - das ist nicht notwendig, kann dir aber helfen, deine Arbeit zu organisieren. Wenn du deine Chunks benennst, solltest du IMMER eindeutige Namen verwenden, sonst beschwert sich R, wenn du versuchst zu rendern.
- Die geschweiften Klammern können auch andere Optionen enthalten, z. B. `tag=value` geschrieben werden, wie zum Beispiel:
- `eval = FALSE` um den R-Code nicht auszuführen
- `echo = FALSE` um den R-Quellcode des Chunks nicht im Ausgabedokument zu drucken
- `warning = FALSE` um Warnungen, die durch den R-Code erzeugt werden, nicht zu drucken
- `message = FALSE` um keine vom R-Code erzeugten Meldungen zu drucken
- `include =` entweder TRUE/FALSE, ob Chunk-Ausgaben (z. B. Plots) in das Dokument aufgenommen werden sollen
- `out.width = ` und `out.height =` - bieten mit Stil `out.width = "75%"`
- `fig.align = "center"` anpassen, wie eine Abbildung auf der Seite ausgerichtet ist
- `fig.show='hold'` wenn dein Stück mehrere Zahlen druckt und du willst, dass sie nebeneinander gedruckt werden (Paar mit `out.width = c("33%", "67%")`. Kann auch gesetzt werden als `fig.show='asis'` setzen, um sie unterhalb des Codes anzuzeigen, der sie erzeugt, `'hide'` zu verbergen, oder `'animate'` mehrere zu einer Animation zu verketten.
- Ein Chunk-Header muss in *einer Zeile*
- Versuche, Punkte, Unterstriche und Leerzeichen zu vermeiden. Verwende stattdessen Bindestriche ( - ), wenn du ein Trennzeichen brauchst.

Lies ausführlicher über die **knitr** Optionen [hier](https://yihui.org/knitr/options/).

Einige der oben genannten Optionen kannst du per Mausklick über die Einstellungsschaltflächen oben rechts im Chunk konfigurieren. Hier kannst du angeben, welche Teile des Chunks das gerenderte Dokument enthalten soll, nämlich den Code, die Ausgaben und die Warnungen. Die Einstellungen werden in den geschweiften Klammern angegeben, z. B. `echo=FALSE` wenn du angibst, dass du "nur die Ausgaben anzeigen" möchtest.

```{r, out.width="80%", fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "markdown/3_chunk.png"))
```

Außerdem gibt es oben rechts in jedem Chunk zwei Pfeile, mit denen du den Code innerhalb eines Chunks oder den gesamten Code in den vorherigen Chunks ausführen kannst. Fahre mit dem Mauszeiger über sie, um zu sehen, was sie bewirken.

Damit globale Optionen auf alle Chunks im Skript angewendet werden, kannst du sie in deinem allerersten R-Code-Chunk im Skript einrichten. Damit zum Beispiel nur die Ausgaben für jeden Codechunk angezeigt werden und nicht der Code selbst, kannst du diesen Befehl in den R-Codechunk einfügen:

```{r, eval=F}
knitr::opts_chunk$set(echo = FALSE) 
```

#### R-Code im Text {.unnumbered}

Du kannst auch minimalen R-Code in Backticks einfügen. Innerhalb der Back-Ticks beginnst du den Code mit "r" und einem Leerzeichen, damit RStudio weiß, dass es sich um R-Code handelt. Siehe das Beispiel unten.

Das folgende Beispiel zeigt mehrere Überschriftenebenen, Aufzählungszeichen und verwendet R-Code für das aktuelle Datum (`Sys.Date()`) in ein gedrucktes Datum umgewandelt.

```{r, out.width="80%", fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "markdown/2_text.png"))
```

Das obige Beispiel ist einfach (Anzeige des aktuellen Datums), aber mit der gleichen Syntax kannst du auch Werte anzeigen, die durch komplexeren R-Code erzeugt wurden (z. B. zur Berechnung von Minimum, Median und Maximum einer Spalte). Du kannst auch R-Objekte oder Werte einbinden, die zuvor in R-Code-Blöcken erstellt wurden.

Das folgende Skript berechnet zum Beispiel den Anteil der Fälle, die jünger als 18 Jahre sind, indem es **tidyverse** Funktionen, und erstellt die Objekte `less18`, `total`, und `less18prop`. Dieser dynamische Wert wird in den nachfolgenden Text eingefügt. Wir sehen, wie es aussieht, wenn es in einem Word-Dokument gestrickt ist.

```{r, out.width="100%", fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "markdown/3_chunktext.png"))
```

### Bilder {.unnumbered}

Du kannst Bilder auf zwei Arten in dein R Markdown einfügen:

```{r, eval=F}
![]("path/to/image.png")  
```

Wenn das oben genannte nicht funktioniert, versuche es mit `knitr::include_graphics()`

```{r, eval=F}
knitr::include_graphics("path/to/image.png")
```

(denk daran, dass dein Dateipfad mit der Option **hier** Paket)

```{r, eval=F}
knitr::include_graphics(here::here("path", "to", "image.png"))
```

### Tische {.unnumbered}

Erstelle eine Tabelle mit Bindestrichen ( -) und Balken ( |). Die Anzahl der Bindestriche vor/zwischen den Balken bestimmt die Anzahl der Leerzeichen in der Zelle, bevor der Text umbrochen wird.

```md
Column 1 |Column  2 |Column 3
---------|----------|--------
Cell A   |Cell B    |Cell C
Cell D   |Cell E    |Cell F
```

Der obige Code erzeugt die unten stehende Tabelle:

| Spalte 1 | Spalte 2 | Spalte 3 | 
| -------- | -------- | -------- |
| Zelle A  | Zelle B  | Zelle C  | 
| Zelle D  | Zelle E  | Zelle F  | 

### Tabellierte Abschnitte {.unnumbered}

Für HTML-Ausgaben kannst du die Abschnitte in "Registerkarten" anordnen. Füge einfach `.tabset` in die geschweiften Klammern `{ }` die gesetzt werden *nach einer Überschrift*. Alle Unterüberschriften unter dieser Überschrift (bis zu einer weiteren Überschrift der gleichen Ebene) werden als Registerkarten angezeigt, durch die der Benutzer klicken kann. Mehr lesen [hier](https://bookdown.org/yihui/rmarkdown-cookbook/html-tabs.html)

```{r, out.width="100%", fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "markdown/tabbed_script.png"))
knitr::include_graphics(here::here("images", "markdown/tabbed_view.gif"))

```

Du kannst eine zusätzliche Option hinzufügen `.tabset-pills` nach `.tabset` hinzufügen, um den Tabs selbst ein "geflochtenes" Aussehen zu geben. Beachte, dass die Strg+f-Suchfunktion bei der Anzeige der HTML-Ausgabe mit Registerkarten nur die "aktiven" Registerkarten durchsucht, nicht die versteckten Registerkarten.

<!-- ======================================================= -->

## Dateistruktur {}

Es gibt verschiedene Möglichkeiten, dein R Markdown und die dazugehörigen R Skripte zu strukturieren. Jede hat Vor- und Nachteile:

- Eigenständiger R Markdown - alles, was für den Bericht benötigt wird, wird in den R Markdown importiert oder erstellt
  - Andere Dateien als Quelle - Du kannst externe R-Skripte mit der `source()` Befehl ausführen und ihre Ausgaben in der Rmd-Datei verwenden.
  - Child-Skripte - ein alternativer Mechanismus für `source()`
- eine "runfile" zu verwenden - Befehle in einem R-Skript auszuführen *vor der* vor dem Rendern des R Markdowns

### Eigenständiges Rmd {.unnumbered}

Für einen relativ einfachen Bericht kannst du dein R Markdown-Skript so organisieren, dass es "in sich geschlossen" ist und keine externen Skripte einbezieht.

Alles, was du zum Ausführen des R Markdown-Skripts brauchst, wird in die Rmd-Datei importiert oder erstellt, einschließlich aller Code-Bausteine und des Ladens von Paketen. Dieser "in sich geschlossene" Ansatz eignet sich, wenn du nicht viele Daten verarbeiten musst (z. B. wenn du eine saubere oder halbwegs saubere Datendatei einbringst) und das Rendern des R Markdowns nicht zu lange dauert.

In diesem Szenario könnte ein logischer Aufbau des R Markdown-Skripts so aussehen:

1) Global setzen **knitr** Optionen
2) Pakete laden
3) Daten importieren
4) Daten verarbeiten
5) Ausgaben produzieren (Tabellen, Diagramme usw.)
6) Speichern der Ergebnisse, falls zutreffend (.csv, .png, etc.)

#### Quelle andere Dateien {.unnumbered}

Eine Variante des "in sich geschlossenen" Ansatzes besteht darin, dass R Markdown-Codeabschnitte andere R-Skripte "quellen" (ausführen) lassen. Dadurch wird dein R Markdown-Skript weniger unübersichtlich, einfacher und leichter zu organisieren. Es kann auch hilfreich sein, wenn du die endgültigen Zahlen am Anfang des Berichts anzeigen möchtest. Bei diesem Ansatz fasst das endgültige R Markdown-Skript einfach die vorverarbeiteten Ausgaben in einem Dokument zusammen.

Eine Möglichkeit, dies zu tun, besteht darin, die R-Skripte (Dateipfad und -name mit Erweiterung) an den **Basis** R-Befehl `source()`.

```{r, eval=F}
source("your-script.R", local = knitr::knit_global())
# or sys.source("your-script.R", envir = knitr::knit_global())
```

Beachten Sie, dass bei der Verwendung von `source()` *innerhalb von* der R Markdown, werden die externen Dateien trotzdem ausgeführt *während des Renderns deiner Rmd-Datei*. Jedes Skript wird also jedes Mal ausgeführt, wenn du den Bericht renderst. Daher ist es wichtig, dass diese `source()` Befehle *innerhalb von* R Markdown zu verwenden, beschleunigt die Laufzeit nicht und hilft auch nicht bei der Fehlersuche, da beim Erstellen des R Markdowns immer noch Fehler ausgegeben werden.

Eine Alternative ist die Verwendung der `child = ` **knitr** Option. MEHR ZU TUN ERKLÄREN

Du musst dir über verschiedene R *Umgebungen*. Objekte, die in einer Umgebung erstellt werden, stehen nicht unbedingt in der Umgebung zur Verfügung, die von R Markdown verwendet wird.

### Runfile {.unnumbered}

Bei diesem Ansatz wird das R-Skript verwendet, das die `render()` Befehl(e) enthält, um Objekte vorzubearbeiten, die in den R-Markdown einfließen.

Du kannst zum Beispiel die Pakete laden, die Daten laden und bereinigen und sogar die gewünschten Diagramme erstellen, bevor du `render()`. Diese Schritte können im R-Skript oder in anderen Skripten ausgeführt werden, die als Quelle dienen. Solange diese Befehle in der gleichen RStudio-Sitzung ausgeführt und die Objekte in der Umgebung gespeichert werden, können die Objekte innerhalb des Rmd-Inhalts aufgerufen werden. Der R-Markdown selbst wird dann nur noch für den letzten Schritt verwendet - um die Ausgabe mit allen vorverarbeiteten Objekten zu erzeugen. So ist es viel einfacher, Fehler zu beheben, wenn etwas schief geht.

Dieser Ansatz ist aus den folgenden Gründen hilfreich:

- Informativere Fehlermeldungen - diese Meldungen werden aus dem R-Skript generiert, nicht aus dem R-Markdown. R Markdown-Fehlermeldungen sagen dir in der Regel, bei welchem Chunk ein Problem aufgetreten ist, aber nicht, bei welcher Zeile.
- Falls zutreffend, kannst du lange Verarbeitungsschritte vor dem `render()` Befehls ausführen - sie werden dann nur einmal ausgeführt.

In dem folgenden Beispiel haben wir ein separates R-Skript, in dem wir eine Vorverarbeitung `data` Objekt in die R-Umgebung einfügen und dann die "create\_output.Rmd" mit `render()`.

```{r, eval=F}
data <- import("datafile.csv") %>%       # Load data and save to environment
  select(age, hospital, weight)          # Select limited columns

rmarkdown::render(input = "create_output.Rmd")   # Create Rmd file
```

### Ordnerstruktur {.unnumbered}

Der Workflow betrifft auch die allgemeine Ordnerstruktur, z. B. einen "Output"-Ordner für erstellte Dokumente und Zahlen und "Data"- oder "Input"-Ordner für bereinigte Daten. Wir gehen hier nicht weiter ins Detail, aber sieh dir die [Organisieren von Routineberichten] Seite.

## Das Dokument erstellen

Du kannst das Dokument auf die folgenden Arten erstellen:

- Manuell durch Drücken der Schaltfläche "Stricken" oben im RStudio-Skripteditor (schnell und einfach)
- Führe die `render()` Befehl (wird außerhalb des R Markdown-Skripts ausgeführt)

### Option 1: Schaltfläche "Stricken {.unnumbered}

Wenn du die Rmd-Datei geöffnet hast, drückst du auf das Symbol/den Button "Stricken" oben in der Datei.

R Studio zeigt den Fortschritt in einer Registerkarte "R Markdown" neben deiner R-Konsole an. Das Dokument wird automatisch geöffnet, wenn es fertig ist.

Das Dokument wird im selben Ordner wie dein R Markdown-Skript und unter demselben Dateinamen (abgesehen von der Erweiterung) gespeichert. Das ist natürlich nicht ideal für die Versionskontrolle (es wird bei jedem Stricken überschrieben, es sei denn, du verschiebst es manuell), da du die Datei dann eventuell selbst umbenennen musst (z. B. um ein Datum hinzuzufügen).

Das ist die RStudio-Verknüpfungstaste für die `render()` Funktion von **rmarkdown**. Dieser Ansatz ist nur mit einem in sich geschlossenen R-Markdown kompatibel, bei dem alle benötigten Komponenten in der Datei vorhanden sind oder von dort bezogen werden.

```{r, out.width="90%", fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "markdown/4_progress.png"))
```

### Option 2: `render()` Befehl {.unnumbered}

Eine andere Möglichkeit, deine R Markdown-Ausgabe zu erzeugen, ist die Ausführung des `render()` Funktion (aus dem **rmarkdown** Paket). Du musst diesen Befehl ausführen *außerhalb von* dem R Markdown-Skript ausführen - also entweder in einem separaten R-Skript (oft "run file" genannt) oder als eigenständiger Befehl in der R-Konsole.

```{r, eval=F}
rmarkdown::render(input = "my_report.Rmd")
```

Wie bei "knit" speichern die Standardeinstellungen die Rmd-Ausgabe im gleichen Ordner wie das Rmd-Skript und mit dem gleichen Dateinamen (außer der Dateierweiterung). Wenn du zum Beispiel "mein\_bericht.rmd" strickst, wird daraus "mein\_bericht.docx", wenn du in ein Word-Dokument strickst. Wenn du jedoch `render()` hast du die Möglichkeit, andere Einstellungen zu verwenden. `render()` kann unter anderem folgende Argumente akzeptieren:

- `output_format = ` Das ist das Ausgabeformat, in das konvertiert werden soll (z. B. `"html_document"`, `"pdf_document"`, `"word_document"`, oder `"all"`). Du kannst dies auch in der YAML innerhalb des R Markdown-Skripts angeben.
- `output_file = ` Dies ist der Name der Ausgabedatei (und der Dateipfad). Diese kann über R-Funktionen wie `here()` oder  erstellt werden. `str_glue()` wie unten gezeigt.
- `output_dir = ` Dies ist ein Ausgabeverzeichnis (Ordner) zum Speichern der Datei. So kannst du ein anderes Verzeichnis wählen als das, in dem die Rmd-Datei gespeichert wird.
- `output_options = ` Du kannst eine Liste von Optionen angeben, die die Optionen in der Skript-YAML überschreiben (z.B. )
- `output_yaml = ` Du kannst den Pfad zu einer .yml-Datei angeben, die YAML-Spezifikationen enthält
- `params = ` Siehe den Abschnitt über Parameter weiter unten
- Siehe die vollständige Liste [hier](https://pkgs.rstudio.com/rmarkdown/reference/render.html)

Um die Versionskontrolle zu verbessern, speichert der folgende Befehl zum Beispiel die Ausgabedatei in einem Unterordner "outputs" mit dem aktuellen Datum im Dateinamen. Um den Dateinamen zu erstellen, muss die Funktion `str_glue()` aus dem **stringr**Paket wird verwendet, um statische Strings (einfach geschrieben) mit dynamischem R-Code (in geschweiften Klammern geschrieben) zu verbinden. Wenn heute zum Beispiel der 10. April 2021 ist, lautet der Dateiname "Report_2021-04-10.docx". Siehe die Seite über [Zeichen und Zeichenketten] für weitere Details über`str_glue()`.

```{r, eval=F}
rmarkdown::render(
  input = "create_output.Rmd",
  output_file = stringr::str_glue("outputs/Report_{Sys.Date()}.docx")) 
```

Während die Datei gerendert wird, zeigt dir die RStudio-Konsole den Rendering-Fortschritt bis zu 100 % und eine abschließende Meldung an, dass das Rendering abgeschlossen ist.

### Optionen 3: **reportfactory**  Paket {.unnumbered}

Das R-Paket **reportfactory** bietet eine alternative Methode zum Organisieren und Kompilieren von R Markdown-Berichten *für Szenarien, in denen du routinemäßig Berichte erstellst (z.B. täglich, wöchentlich...).* Es erleichtert die Kompilierung mehrerer R Markdown-Dateien und die Organisation ihrer Ergebnisse. Im Wesentlichen stellt es eine "Fabrik" zur Verfügung, von der aus du die R Markdown-Berichte ausführen kannst. Du erhältst automatisch Ordner mit Datums- und Zeitstempeln für die Ausgaben und hast eine "leichte" Versionskontrolle.

Mehr über diesen Arbeitsablauf erfährst du auf der Seite über [Organisieren von Routineberichten].

<!-- ======================================================= -->

## Parametrisierte Berichte {  }

Mit Hilfe von Parametern kannst du einen Bericht dynamisch gestalten, so dass er mit bestimmten Einstellungen ausgeführt werden kann (z. B. mit einem bestimmten Datum oder Ort oder mit bestimmten Strickoptionen). Im Folgenden konzentrieren wir uns auf die Grundlagen, aber es gibt noch mehr [Details online](https://bookdown.org/yihui/rmarkdown/parameterized-reports.html) über parametrisierte Berichte.

Nehmen wir die Ebola-Lineliste als Beispiel und sagen wir, wir wollen jeden Tag einen Standard-Überwachungsbericht für jedes Krankenhaus erstellen. Wir zeigen, wie man dies mit Hilfe von Parametern erreichen kann.

*Wichtig: Dynamische Berichte sind auch ohne die formale Parameterstruktur möglich (ohne `params:`), indem du einfache R-Objekte in einem angrenzenden R-Skript verwendest. Dies wird am Ende dieses Abschnitts erklärt.*

### Parameter setzen {.unnumbered}

Du hast mehrere Möglichkeiten, um Parameterwerte für deine R Markdown-Ausgabe festzulegen.

#### Option 1: Parameter innerhalb von YAML festlegen {.unnumbered}

Bearbeite die YAML und füge eine `params: ` mit eingerückten Anweisungen für jeden Parameter, den du definieren willst. In diesem Beispiel erstellen wir Parameter `date` und `hospital` an, für die wir Werte festlegen. Diese Werte können sich jedes Mal ändern, wenn der Bericht ausgeführt wird. Wenn du die Schaltfläche "Stricken" verwendest, um die Ausgabe zu erstellen, haben die Parameter diese Standardwerte. Ebenso, wenn du die Schaltfläche `render()` verwendest, haben die Parameter diese Standardwerte, es sei denn, du hast in der `render()` Befehl angegeben.

```yaml
---
title: Surveillance report
output: html_document
params:
 date: 2021-04-10
 hospital: Central Hospital
---
```

Im Hintergrund sind diese Parameterwerte in einer Nur-Lese-Liste namens `params`. So kannst du die Parameterwerte in den R-Code einfügen, wie du ein anderes R-Objekt/einen anderen Wert in deiner Umgebung einfügen würdest. Gib einfach ein `params$` gefolgt von dem Parameternamen ein. Zum Beispiel `params$hospital` für den Namen des Krankenhauses (standardmäßig "Zentralkrankenhaus").

Beachte, dass Parameter auch Werte enthalten können `true` oder `false` enthalten können, und daher können diese in deine **knitr** Optionen für einen R-Chunk enthalten. Du kannst zum Beispiel festlegen `{r, eval=params$run}` anstelle von `{r, eval=FALSE}` setzen, und nun hängt es vom Wert eines Parameters ab, ob der Chunk läuft oder nicht `run:`.

Beachte, dass Parameter, die Datumsangaben sind, als String eingegeben werden. Also für `params$date` im R-Code interpretiert werden kann, muss er wahrscheinlich mit `as.Date()` oder einer ähnlichen Funktion in die Klasse Date umgewandelt werden.

#### Option 2: Parameter innerhalb von `render()` {.unnumbered}

Wie bereits erwähnt, können Sie alternativ zum Drücken der Schaltfläche "Stricken" die Ausgabe mit dem Befehl `render()` Funktion in einem separaten Skript auszuführen. Im letzteren Fall kannst du die Parameter, die in diesem Rendering verwendet werden sollen, in der `params = ` Argument von `render()`.

Beachten Sie, dass alle hier angegebenen Parameterwerte *überschreiben* ihre Standardwerte, wenn sie in die YAML geschrieben werden. Wir schreiben die Werte in Anführungszeichen, da sie in diesem Fall als Zeichen/String-Werte definiert werden sollten.

Der folgende Befehl rendert "surveillance\_report.Rmd", gibt einen dynamischen Ausgabedateinamen und -ordner an und stellt eine `list()` von zwei Parametern und deren Werten an das Argument `params = `.

```{r, eval=F}
rmarkdown::render(
  input = "surveillance_report.Rmd",  
  output_file = stringr::str_glue("outputs/Report_{Sys.Date()}.docx"),
  params = list(date = "2021-04-10", hospital  = "Central Hospital"))
```

#### Option 3: Parameter über eine grafische Benutzeroberfläche festlegen {.unnumbered}

Wenn du ein interaktiveres Gefühl haben möchtest, kannst du auch die grafische Benutzeroberfläche (GUI) verwenden, um manuell Werte für Parameter auszuwählen. Dazu klickst du auf das Dropdown-Menü neben der Schaltfläche "Stricken" und wählst "Mit Parametern stricken".

Es erscheint ein Pop-up-Fenster, in das du die Werte für die Parameter eingeben kannst, die in der YAML des Dokuments festgelegt sind.

```{r, out.width="50%", fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "markdown/5_parametersGUI.png"))
```

Das Gleiche kannst du mit einer `render()` Befehl erreichen, indem du `params = "ask"` wie unten gezeigt.

```{r, eval=F}
rmarkdown::render(
  input = "surveillance_report.Rmd",  
  output_file = stringr::str_glue("outputs/Report_{Sys.Date()}.docx"),
  params = "ask")
```

Bei der Eingabe von Werten in dieses Pop-up-Fenster können jedoch Fehler und Rechtschreibfehler auftreten. Vielleicht möchtest du die Werte, die über Dropdown-Menüs eingegeben werden können, einschränken. Das kannst du tun, indem du in der YAML mehrere Spezifikationen für jeden `params: ` Eintrag hinzufügst.

- `label: ` ist wie der Titel für dieses bestimmte Dropdown-Menü
- `value: ` ist der Standardwert (Startwert)
- `input: ` eingestellt auf `select` für das Dropdown-Menü
- `choices: ` Gib die in Frage kommenden Werte in das Dropdown-Menü ein

Im Folgenden werden diese Angaben für die `hospital` Parameter.

```yaml
---
title: Surveillance report
output: html_document
params:
 date: 2021-04-10
 hospital: 
  label: "Town:"
  value: Central Hospital
  input: select
  choices: [Central Hospital, Military Hospital, Port Hospital, St. Mark's Maternity Hospital (SMMH)]
---
```

Beim Stricken (entweder über die Schaltfläche "Stricken mit Parametern" oder durch `render()`), enthält das Pop-up-Fenster Dropdown-Optionen, aus denen du auswählen kannst.

```{r, out.width="50%", fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "markdown/5_parametersGUIB.png"))
```

### Parametrisiertes Beispiel {.unnumbered}

Der folgende Code erstellt Parameter für `date` und `hospital` die in R Markdown als Parameter verwendet werden `params$date` und `params$hospital` verwendet werden.

In der resultierenden Berichtsausgabe siehst du, wie die Daten nach dem spezifischen Krankenhaus gefiltert werden und der Titel der Grafik auf das richtige Krankenhaus und Datum verweist. Wir verwenden hier die Datei "linelist\_cleaned.rds", aber es wäre besonders sinnvoll, wenn die Lineliste selbst auch einen Datumsstempel enthielte, um sie an das parametrisierte Datum anzupassen.

```{r, out.width="100%", fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "markdown/6_Rmdexample.png"))
```

Wenn du das strickst, erhältst du die endgültige Ausgabe mit der Standardschriftart und dem Standardlayout.

```{r, out.width="80%", fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "markdown/6_RmdexampleB.png"))
```

### Parametrisierung ohne `params` {.unnumbered}

Wenn du eine R Markdown-Datei mit `render()` aus einem separaten Skript wiedergibst, kannst du die Auswirkungen der Parametrisierung auch ohne die Verwendung der `params:` Funktionalität.

Zum Beispiel kann in der *R-Skript* das die `render()` Befehl enthält, kannst du einfach definieren `hospital` und `date` als zwei R-Objekte (Werte) vor dem `render()` Befehl. Im R Markdown müsstest du nicht mit einem `params:` Abschnitt in der YAML zu haben, und wir würden uns auf die `date` Objekt verweisen, anstatt `params$date` und `hospital` statt `params$hospital`.

```{r, eval=F}
# This is a R script that is separate from the R Markdown

# define R objects
hospital <- "Central Hospital"
date <- "2021-04-10"

# Render the R markdown
rmarkdown::render(input = "create_output.Rmd") 
```

Wenn du diesen Ansatz verfolgst, kannst du nicht "mit Parametern stricken", die GUI verwenden oder Strickoptionen in die Parameter aufnehmen. Allerdings ermöglicht es einen einfacheren Code, was von Vorteil sein kann.

<!-- ======================================================= -->

## Schleifenberichte {  }

Es kann sein, dass wir einen Bericht mehrmals ausführen und dabei die Eingabeparameter variieren möchten, um einen Bericht für jede Gerichtsbarkeit/Einheit zu erstellen. Dies kann mit den Tools für *Iteration*die auf der Seite über Iteration ausführlich erklärt werden .      [Iteration, Schleifen und Listen]. Zu den Optionen gehören die**purrr** Paket, oder die Verwendung eines *for-Schleife* wie unten erklärt.

Im Folgenden verwenden wir eine einfache *for-Schleife* um einen Überwachungsbericht für alle Krankenhäuser von Interesse zu erstellen. Dies geschieht mit einem einzigen Befehl (anstatt die Krankenhausparameter manuell einzeln zu ändern). Der Befehl zum Erstellen der Berichte muss in einem separaten Skript enthalten sein *außerhalb von* dem Bericht Rmd. Dieses Skript enthält auch definierte Objekte zum "Durchschleifen" - das heutige Datum und einen Vektor von Krankenhausnamen zum Durchschleifen.

```{r, eval=F}
hospitals <- c("Central Hospital",
                "Military Hospital", 
                "Port Hospital",
                "St. Mark's Maternity Hospital (SMMH)") 
```

Diese Werte geben wir dann einzeln in die `render()` eine Schleife ein, die den Befehl für jeden Wert in der Liste einmal ausführt `hospitals` Vektor. Der Buchstabe `i` steht für die Indexposition (1 bis 4) des Krankenhauses, das gerade in dieser Iteration verwendet wird, so dass `hospital_list[1]` wäre "Zentralkrankenhaus". Diese Information wird an zwei Stellen in der `render()` Befehl:

1) An den Dateinamen, so dass der Dateiname der ersten Iteration, wenn sie am 10. April 2021 erstellt wird, "Bericht\_Zentralkrankenhaus\_2021-04-10.docx" wäre und im Unterordner "output" des Arbeitsverzeichnisses gespeichert würde.
2) An `params = ` so dass die Rmd den Krankenhausnamen intern verwendet, wenn die `params$hospital` Wert aufgerufen wird (z. B. um den Datensatz nur auf ein bestimmtes Krankenhaus zu filtern). In diesem Beispiel würden vier Dateien erstellt werden - eine für jedes Krankenhaus.

```{r, eval=F}
for(i in 1:length(hospitals)){
  rmarkdown::render(
    input = "surveillance_report.Rmd",
    output_file = str_glue("output/Report_{hospitals[i]}_{Sys.Date()}.docx"),
    params = list(hospital  = hospitals[i]))
}       
```

<!-- In dem Szenario, in dem du f nicht diese strenge Form der Parametrisierung verwendest, sondern Objekte in der Umgebung speicherst, wie am Ende des Abschnitts Parametrisierung besprochen, würde die Renderfunktion wie folgt aussehen: -->

<!-- ```md -->

<!-- for(i in 1:length(hospital_list)){ -->

<!-- rmarkdown::render("ueberwachungs_bericht.Rmd", -->

<!-- }        -->

<!-- ``` -->

<!-- ======================================================= -->

## Vorlagen

Mit Hilfe einer Dokumentvorlage, die alle gewünschten Formatierungen enthält, kannst du das Aussehen der Rmd-Ausgabe anpassen. Du kannst zum Beispiel eine MS Word- oder Powerpoint-Datei erstellen, die Seiten/Folien mit den gewünschten Abmessungen, Wasserzeichen, Hintergründen und Schriftarten enthält.

### Word-Dokumente {.unnumbered}

Um eine Vorlage zu erstellen, fängst du ein neues Word-Dokument an (oder verwendest eine bestehende Ausgabe mit der für dich passenden Formatierung) und bearbeitest die Schriftarten, indem du die Stile definierst. Unter Stil verweisen die Überschriften 1, 2 und 3 auf die verschiedenen Markdown-Kopfebenen (`# Header 1`, `## Header 2` und `### Header 3` bzw.). Klicke mit der rechten Maustaste auf die Formatvorlage und klicke auf "Ändern", um die Formatierung der Schrift und des Absatzes zu ändern (z. B. kannst du vor bestimmten Formatvorlagen Seitenumbrüche einfügen, um die Abstände zu verbessern). Andere Aspekte des Word-Dokuments wie Ränder, Seitengröße, Überschriften usw. können wie in einem normalen Word-Dokument geändert werden, in dem du direkt arbeitest.

```{r, out.width="100%", fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "markdown/7_template.png"))
```

### Powerpoint-Dokumente {.unnumbered}

Erstelle wie oben einen neuen Foliensatz oder verwende eine vorhandene PowerPoint-Datei mit der gewünschten Formatierung. Zur weiteren Bearbeitung klickst du auf "Ansicht" und "Folienmaster". Hier kannst du das Aussehen der "Master"-Folie ändern, indem du die Textformatierung in den Textfeldern sowie die Hintergrund- und Seitenabmessungen für die gesamte Seite bearbeitest.

```{r, out.width="100%", fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "markdown/8_ppttemplate.png"))
```

Leider ist die Bearbeitung von Powerpoint-Dateien etwas weniger flexibel:

- Eine Überschrift der ersten Ebene (`# Header 1`) wird automatisch zum Titel einer neuen Folie,
- A `## Header 2` Text wird nicht als Untertitel, sondern als Text im Haupttextfeld der Folie angezeigt (es sei denn, du findest eine Möglichkeit, die Masteransicht zu ändern).
- Ausgegebene Diagramme und Tabellen werden automatisch in neue Folien eingefügt. Du musst sie kombinieren, z. B. mit dem **Patchwork** Funktion verwenden, um ggplots zu kombinieren, damit sie auf der gleichen Seite angezeigt werden. Siehe dies [Blogbeitrag](https://mattherman.info/blog/ppt-patchwork/) über die Verwendung der **Patchwork** Paket, um mehrere Bilder auf einer Folie zu platzieren.

Siehe die [**Offizier** Paket](https://davidgohel.github.io/officer/) für ein Tool, mit dem du tiefergehend mit Powerpoint-Präsentationen arbeiten kannst.

### Vorlagen in die YAML einbinden {.unnumbered}

Sobald eine Vorlage erstellt wurde, können die Details dazu in der YAML des Rmd unter der Zeile "Ausgabe" und unter der Angabe des Dokumententyps (der in einer eigenen Zeile steht) hinzugefügt werden. Hinweis `reference_doc` kann für Powerpoint-Folienvorlagen verwendet werden.

Am einfachsten ist es, die Vorlage in demselben Ordner zu speichern, in dem sich auch die Rmd-Datei befindet (wie im Beispiel unten), oder in einem Unterordner darin.

```yaml
---
title: Surveillance report
output: 
 word_document:
  reference_docx: "template.docx"
params:
 date: 2021-04-10
 hospital: Central Hospital
template:
 
---
```

### Formatieren von HTML-Dateien {.unnumbered}

HTML-Dateien verwenden keine Vorlagen, aber die Stile können in der YAML konfiguriert werden. HTML-Dateien sind interaktive Dokumente, die besonders flexibel sind. Wir behandeln hier einige grundlegende Optionen.

- Inhaltsverzeichnisse: Wir können ein Inhaltsverzeichnis einfügen mit `toc: true` hinzufügen und außerdem festlegen, dass es beim Scrollen sichtbar bleibt ("schwebt"), mit `toc_float: true`.

- Themes: Wir können auf einige vorgefertigte Themes zurückgreifen, die aus der Bootswatch-Themenbibliothek stammen. Im folgenden Beispiel verwenden wir cerulean. Weitere Optionen sind: journal, flatly, darkly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex und yeti.

- Hervorheben: Mit dieser Einstellung wird das Aussehen von hervorgehobenem Text (z. B. Code innerhalb von angezeigten Abschnitten) geändert. Unterstützt werden die Stile default, tango, pygments, kate, monochrome, espresso, zenburn, haddock, breezedark und textmate.

Hier ist ein Beispiel dafür, wie du die oben genannten Optionen in die YAML integrieren kannst.

```yaml
---
title: "HTML example"
output:
  html_document:
    toc: true
    toc_float: true
    theme: cerulean
    highlight: kate
    
---
```

Unten findest du zwei Beispiele für HTML-Ausgaben, die beide ein fließendes Inhaltsverzeichnis haben, aber unterschiedliche Themen- und Hervorhebungsstile auswählen:

```{r, out.width="100%", fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "markdown/9_html.png"))
```

## Dynamischer Inhalt

In einer HTML-Ausgabe kann der Inhalt deines Berichts dynamisch sein. Im Folgenden findest du einige Beispiele:

### Tabellen {.unnumbered}

In einem HTML-Bericht kannst du Datenrahmen / Tibbles so ausgeben, dass der Inhalt dynamisch ist, mit Filtern und Bildlaufleisten. Es gibt mehrere Pakete, die diese Möglichkeit bieten.

Um dies zu tun mit dem **DT** Paket, wie es in diesem Handbuch verwendet wird, kannst du einen Codeabschnitt wie den folgenden einfügen:

```{r, out.width="100%", fig.align="center", echo=F}
knitr::include_graphics(here::here("images", "markdown/10_dynamictable.png"))
```

Die Funktion `datatable()` gibt den angegebenen Datenrahmen als dynamische Tabelle für den Leser aus. Du kannst die `rownames = FALSE` setzen, um die ganz linke Seite der Tabelle zu vereinfachen. `filter = "top"` bietet einen Filter über jede Spalte. In der `option()` Argument gibst du eine Liste mit anderen Spezifikationen an. Im Folgenden geben wir zwei an: `pageLength = 5` die Anzahl der angezeigten Zeilen auf 5 festlegen (die restlichen Zeilen können durch Blättern mit Pfeilen angezeigt werden), und `scrollX=TRUE` aktiviert eine Bildlaufleiste am unteren Rand der Tabelle (für Spalten, die zu weit nach rechts reichen).

Wenn dein Datensatz sehr groß ist, solltest du nur die obersten X Zeilen anzeigen, indem du den Datenrahmen in `head()`.

### HTML-Widgets {.unnumbered}

[HTML Widgets für R](http://www.htmlwidgets.org/) sind eine spezielle Klasse von R-Paketen, die durch die Verwendung von JavaScript-Bibliotheken mehr Interaktivität ermöglichen. Du kannst sie in HTML-R-Markdown-Ausgaben einbetten.

Einige gängige Beispiele für diese Widgets sind:

- Plotly (wird auf dieser Handbuchseite und in der [Interaktive Plots] Seite)
- visNetwork (verwendet in den [Übertragungsketten] Seite dieses Handbuchs)
- Merkblatt (verwendet in den [GIS-Grundlagen] Seite dieses Handbuchs)
- dygraphs (nützlich für die interaktive Darstellung von Zeitreihendaten)
- DT (`datatable()`) (um dynamische Tabellen mit Filter, Sortierung usw. anzuzeigen)

Die `ggplotly()` Funktion von **plotly**ist besonders einfach zu benutzen. Siehe die [Interaktive Plots] Seite.

## Ressourcen {  }

Weitere Informationen erhältst du über:

- [https://bookdown.org/yihui/rmarkdown/](https://bookdown.org/yihui/rmarkdown/)
- [https://rmarkdown.rstudio.com/articles\_intro.html](https://rmarkdown.rstudio.com/articles_intro.html)

Eine gute Erklärung von Markdown vs. Knitr vs. Rmarkdown findest du hier: [https://stackoverflow.com/questions/40563479/relationship-between-r-markdown-knitr-pandoc-and-bookdown](https://stackoverflow.com/questions/40563479/relationship-between-r-markdown-knitr-pandoc-and-bookdown)


