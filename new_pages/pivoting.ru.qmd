
<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Поворот данных {}

```{r, warning=F, message=F, out.height = c('50%'), fig.align="center", fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "pivoting", "Pivoting_500x500.png"))

#knitr::include_graphics(here::here("images", "pivoting", "pivot_longer_new.png"))
#knitr::include_graphics(here::here("images", "pivoting", "pivot_bar.png"))
#knitr::include_graphics(here::here("images", "pivoting", "pivot_wider_new.png"))
```



В управлении данными можно рассматривать английское понятие *pivoting* (поворот), как один из двух процессов:  

1. Создание *сводных таблиц - pivot tables*, которые являются статистическими таблицами, резюмирующими данные более детальной таблицы  
2. Преобразование таблицы из **длинного** (вертикального) в **широкий** (горизонтальный) формат, либо наоборот. 

**На этой странице мы сфокусируемся на втором определении.** Первое значение - важный шаг в анализе данных, и он рассматривается в других главах на страницах [Группировании данных](grouping.ru.qmd) и [Описательные таблицы](tables_descriptive.ru.qmd). 

На данной странице мы рассматриваем форматы данных. Будет полезно понимать идею "аккуратных данных", в которой у каждой переменной есть свой столбец, у каждого наблюдения есть свой ряд, а у каждого значения есть собственная ячейка. Более подробно вы можете почитать об этой теме [в этой онлайн главе R for Data Science](https://r4ds.had.co.nz/tidy-data.html). 





## Подготовка  

### Загрузка пакетов {.unnumbered}  

Данный фрагмент кода показывает загрузку пакетов, необходимых для анализа. В данном руководстве мы фокусируемся на использовании `p_load()` из пакета **pacman**, которая устанавливает пакет, если необходимо, *и* загружает его для использования. Вы можете также загрузить установленные пакеты с помощью `library()` из **базового** R. См. страницу [Основы R](basics.ru.qmd) для получения дополнительной информации о пакетах R.  

```{r}
pacman::p_load(
  rio,          # Импорт файла
  here,         # Место расположения файла
  kableExtra,   # Построение и манипуляции со сложными таблицами
  tidyverse)    # Управление данными + графика ggplot2
```



### Импорт данных {.unnumbered}


### Данные о количестве случаев малярии {-}  

На данной странице мы будем использовать выдуманный набор данных с ежедневным количеством случаев малярии в разбивке по организациям и возрастным группам. Если вы хотите параллельно выполнять все шаги, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/malaria_facility_count_data.rds' class='download-button'>кликните сюда, чтобы скачать (в виде файла .rds)<span></a>. Импортируйте данные с помощью функции `import()` из пакета **rio** (он работает с множеством типов файлов, таких как .xlsx, .csv, .rds - см. детальную информацию на странице [Импорт и экспорт](importing.ru.qmd)).  

```{r, echo=F}
count_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) %>% 
  as_tibble()
```

```{r, eval=F}
# Импорт данных
count_data <- import("malaria_facility_count_data.rds")
```

Первые 50 строк отображены ниже.

```{r, message=FALSE, echo=F}
# отображаем построчный список данных в виде таблицы
DT::datatable(head(count_data, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


### Построчный список случаев {-}  

Дальше на этой странице мы будем также использовать набор данных по случаям из имитационной эпидемии Эболы. Если вы хотите выполнять действия параллельно, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>кликните, чтобы скачать "чистый" построчный список</a> (as .rds file). Импортируйте данные с помощью функции `import()` из пакета **rio** (он работает с множеством типов файлов, таких как .xlsx, .rds, .csv - см. детальную информацию на странице [Импорт и экспорт](importing.ru.qmd)).  

```{r, echo=F}
# импорт построчного списка в R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```


```{r, eval=F}
# импорт вашего набора данных
linelist <- import("linelist_cleaned.xlsx")
```







<!-- ======================================================= -->
## Из широкой в длинную {}

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "pivoting", "pivot_longer_new.png"))
```


<!-- ======================================================= -->
### "Широкий" формат {.unnumbered}

Данные часто вводятся и хранятся в "широком" формате - где характеристики или ответы субъекта хранятся в одной строке. Хотя это может быть полезно для презентации, это не очень подходит для некоторых типов анализа.  

Давайте возьмем набор данных `count_data`, испортированный в разделе Подготовка, в качестве примера. Вы можете видеть, что каждая строка представляет собой "день организации". Фактическое количество случаев (в самом правом столбце) хранится в "широком" формате таким образом, что информация для каждой возрастной группы в конкретный день в организации хранится в одной строке.  

```{r, echo=F}
DT::datatable(count_data, rownames = FALSE, options = list(pageLength = 5, scrollX=T) )
```

Каждое наблюдение в наборе данных относится к количеству случаев малярии в одной из 65 медицинских организаций в конкретную дату и варьируется от ` count_data$data_date %>% min()` до ` count_data$data_date %>% max()`. Эти организации расположены в одной провинции `Province` (Север) и в четырех районах `District` (Spring, Bolo, Dingo и Barnard). Набор данных дает общее количество случаев малярии, а также количество по трем возрастным группам - <4 лет, 5-14 лет и 15 лет и старше.

"Широкие" данные, такие как эти, не соответствуют стандартам "аккуратных данных", поскольку заголовки столбцов на самом деле не представляют собой "переменные" - они представляют собой *значения* гипотетической переменной "возрастная группа". 


Этот формат может быть полезен для представления информации в таблице, либо для ввода данных (например, в Excel) из форм регистрации случаев. Однако на этапе анализа эти данные, как правило, следует трансформировать в более "длинный" формат в соответствии со стандартами "аккуратных данных". Пакет построения графиков в R **ggplot2**, например, лучше всего работает с данными в "длинном" формате.  


Визуализация *общего* количества случаев малярии со временем не представляет собой сложности с данными в текущем формате:

```{r, warning=F, message=F}
ggplot(count_data) +
  geom_col(aes(x = data_date, y = malaria_tot), width = 1)
```

А если бы мы хотели отобразить относительный вклад каждой возрастной группы в это общее количество? В таком случае нам нужно убедиться, что интересующая переменная (возрастная группа) появляется в наборе данных в одном столбце, который можно указать в аргументе эстетики `aes()` в `{ggplot2}`.




<!-- ======================================================= -->
### `pivot_longer()` {.unnumbered}

Функция `pivot_longer()` из **tidyr** поворачивает данные "вертикально". **tidyr** является частью пакетов R **tidyverse**.  

Она принимает диапазон столбцов для трансформации (указываются в `cols = `). Следовательно, она может работать только над частью набора данных. Это полезно для данных по малярии, так как нам нужно повернуть только столбцы с количеством случаев.  

В этом процессе у вас в итоге получится два "новых" столбца - один с категориями (раньше были именами столбцов), и один - с соответствующими значениям (например, количеством случаев). Вы можете принять имена по умолчанию для этих новых столбцов, либо вы можете указать собственные имена в `names_to = ` и `values_to = `, соответственно.  

Давайте посмотрим `pivot_longer()` в действии... 



### Стандартный поворот {.unnumbered}  

Мы хотим использовать функцию `pivot_longer()` из **tidyr**, чтобы конвертировать "широкие" данные в "длинный" формат. В частности, чтобы конвертировать четыре числовых столбца с данными по количеству случаев малярии в два новых столбца: один, содержащий *возрастные группы*, и один, содержащий соответствующие *значения*.  

```{r, eval=F}
df_long <- count_data %>% 
  pivot_longer(
    cols = c(`malaria_rdt_0-4`, `malaria_rdt_5-14`, `malaria_rdt_15`, `malaria_tot`)
  )

df_long
```

Обратите внимание, что в новом созданном датафрейме (`df_long`) больше строк (12,152 по сравнению с 3,038); он стал *длиннее*. По сути он стал в четыре раза длиннее, поскольку каждая строка оригинального набора данных теперь представляет собой четыре строки в df_long, по одной для каждого из наблюдений по количеству случаев (<4 лет, 5-14 лет, 15+ лет, и итого).

Кроме того, что набор данных стал длиннее, в нем стало меньше столбцов (8 против 10), поскольку те данные, которые раньше хранились в четырех столбцах (те, которые начинались с префикса `malaria_`), теперь хранятся в двух. 

Поскольку имена этих четырех столбцов все начинаются с префикса `malaria_`, мы могли бы использовать удобную функцию из "tidyselect" `starts_with()`, чтобы добиться того же результата (см. страницу [Вычистка данных и ключевые функции](cleaning.ru.qmd) для получения информации о других подобных функциях-помощниках).  

```{r}
# задайте столбец с помощью функции-помощника tidyselect
count_data %>% 
  pivot_longer(
    cols = starts_with("malaria_")
  )
```

либо по позиции: 

```{r, eval=F}
# задайте столбцы по позиции
count_data %>% 
  pivot_longer(
    cols = 6:9
  )
```

либо по именованному диапазону:

```{r, eval=F}
# задайте диапазон последовательных столбцов
count_data %>% 
  pivot_longer(
    cols = `malaria_rdt_0-4`:malaria_tot
  )
```



Этим двум новым столбцам даются имена по умолчанию `name` и `value`, но мы можем их поменять, чтобы задать более осмысленные имена, которые помогут запомнить, что хранится в этих столбцах, используя аргументы `names_to` и `values_to`. Давайте использовать имена `age_group` и `counts`:

```{r}
df_long <- 
  count_data %>% 
  pivot_longer(
    cols = starts_with("malaria_"),
    names_to = "age_group",
    values_to = "counts"
  )

df_long
```

Теперь мы можем передать этот новый набор данных в `{ggplot2}`, и отложить новый столбец `count` по оси y, а новый столбец `age_group` указать в аргументе `fill = ` (внутренняя заливка столбца). Это позволит отобразить подсчет случаев малярии в виде столбчатой диаграммы с накоплением по возрастным группам:

```{r, warning=F, message=F}
ggplot(data = df_long) +
  geom_col(
    mapping = aes(x = data_date, y = counts, fill = age_group),
    width = 1
  )
```

Рассмотрите этот новый график и сравните его с графиком, который мы создали ранее - *что пошло не так?*  

Мы столкнулись с частой проблемой при работе с данными эпиднадзора - мы также включили общее количество случаев из столбца `malaria_tot`, поэтому высота каждого столбика на графике в два раза выше, чем должна быть. 

Мы можем решить эту проблему рядом способов. Мы просто отфильтруем это общее количество из набора данных, прежде чем передать его в `ggplot()`:

```{r, warning=F, message=F}
df_long %>% 
  filter(age_group != "malaria_tot") %>% 
  ggplot() +
  geom_col(
    aes(x = data_date, y = counts, fill = age_group),
    width = 1
  )
```

Альтернативно мы могли бы исключить эту переменную при выполнении `pivot_longer()`, оставив ее в наборе данных как отдельную переменную. См. как значения "расширяются", чтобы заполнить эти новые строки. 

```{r, warning=F, message=F}
count_data %>% 
  pivot_longer(
    cols = `malaria_rdt_0-4`:malaria_rdt_15,   # не включает столбец итого
    names_to = "age_group",
    values_to = "counts"
  )
```





### Поворот данных нескольких классов {.unnumbered}

Приведенный выше пример хорошо работает в тех ситуациях, где все столбцы, которые вы хотите "повернуть вертикально", относятся к одному классу (текстовый, числовой, логический...). 

Однако может быть много случаев, когда вы, как прикладной эпидемиолог, будете работать с данными, которые были подготовлены неспециалистами и которые следуют своей нестандартной логике - как сказал Хэдли Уикэм (ссылаясь на Толстого) в своей [знаковой статье](https://vita.had.co.nz/papers/tidy-data.pdf) по поводу принципов **Аккуратных данных**: "Как и семьи, аккуратные данные все одинаковы, но хаотичные данные хаотичны по-своему."

Одной из частых проблем, с которой вы можете столкнуться, будет необходимость поворачивать столбцы, которые содержат разные классы данных. Такой поворот приведет к тому, что эти разные типы данных будут храниться в одном столбце, что не очень хорошо. Существует ряд подходов, которые можно выбрать, чтобы разобраться с созданным хаосом, но есть важный шаг, который вы можете предпринять, используя `pivot_longer()`, чтобы избежать создания такой ситуации.

Представьте ситуацию, в которой у вас есть ряд наблюдений с разными временными отрезками для каждого из трех пунктов A, B и C. Такими пунктами могут быть отдельные люди (например, контакты случая Эболы, которые отслеживаются каждый день в течение 21 дня) или отдаленные сельские медицинские пункты, в которых идет мониторинг раз в год, чтобы убедиться, что они все еще работают. Давайте используем пример с отслеживанием контактов. Представьте, что данные хранятся следующим образом:


```{r, message=FALSE, echo=F}

df <- 
  tibble::tribble(
     ~id,   ~obs1_date, ~obs1_status,   ~obs2_date, ~obs2_status,   ~obs3_date, ~obs3_status,
     "A", "2021-04-23",    "Healthy", "2021-04-24",    "Healthy", "2021-04-25",     "Unwell",
     "B", "2021-04-23",    "Healthy", "2021-04-24",    "Healthy", "2021-04-25",    "Healthy",
     "C", "2021-04-23",    "Missing", "2021-04-24",    "Healthy", "2021-04-25",    "Healthy"
     ) 

DT::datatable(df, rownames = FALSE)

```

Как видите, данные несколько запутаны. В каждой строке хранится информация об одном элементе, но при этом временной ряд с течением времени уходит все дальше и дальше вправо. Кроме того, классы столбцов чередуются между датой и текстовыми значениями.  

Один из особенно плохих примеров, с которым столкнулся автор руководства, включал данные по эпиднадзору за холерой, в которых 8 столбцов наблюдений добавлялись *каждый день* в течение __4 лет__. Даже просто открытие этого Excel файла с данными требовало >10 минут на моем ноутбуке!

Чтобы работать с этими данными, нам нужно преобразовать датафрейм в длинный формат, но при этом сохранить разделение между столбцом `date` (дата) и текстовым столбцом `character` (статус) для каждого наблюдения для каждого пункта. Если мы этого не сделаем, у нас может получиться смесь типов переменных в одном столбце (а это большое табу для управления данными и аккуратных данных):

```{r}
df %>% 
  pivot_longer(
    cols = -id,
    names_to = c("observation")
  )

```

Выше поворот данных привел к слиянию *дат* и *текста* в один столбец значений `value`. R отреагирует путем конвертации всего столбца в текстовый класс, и польза от дат будет потеряна.  

Чтобы предотвратить такую ситуацию, мы можем воспользоваться структурой синтаксиса оригинальных имен столбцов. Существует общая структура именования с номером наблюдения, нижним подчеркиванием и либо "статусом", либо "датой". Мы можем использовать этот синтаксис, чтобы сохранить эти два типа данных в разных столбцах после поворота. 

Мы это делаем следующим образом:  

* Указываем текстовый вектор в аргументе `names_to = `, где второй пункт (`".value"` ). Это особое условие указывает на то, что повернутые столбцы будут разделены в зависимости от символа в их имени...  
* Вы также должны указать "разделяющий" символ в аргументе `names_sep = `. В данном случае это нижнее подчеркивание "_".  

Таким образом, именование и разделение новых столбцов основано на нижнем подчеркивании в существующих именах переменных.  

```{r}

df_long <- 
  df %>% 
  pivot_longer(
    cols = -id,
    names_to = c("observation", ".value"),
    names_sep = "_"
  )

df_long

```

__Последние штрихи__:

Обратите внимание, что столбец дата `date` в настоящее время относится к *текстовому* классу - мы можем легко конвертировать его в правильный класс даты, используя функции `mutate()` и `as_date()`, описанные на странице [Работа с датами](dates.ru.qmd).  

Нам может быть также необходимо конвертировать столбец наблюдение `observation` в числовой  формат `numeric`, убрав префикс "obs" и конвертации в числовой класс. Мы можем это сделать с помощью `str_remove_all()` из пакета **stringr** (см. страницу [Текст и последовательности](characters_strings.ru.qmd)).  

```{r}

df_long <- 
  df_long %>% 
  mutate(
    date = date %>% lubridate::as_date(),
    observation = 
      observation %>% 
      str_remove_all("obs") %>% 
      as.numeric()
  )

df_long

```

Теперь мы можем начать работать с данными в этом формате, например, построив описательную мозаичную тепловую карту:  

```{r}
ggplot(data = df_long, mapping = aes(x = date, y = id, fill = status)) +
  geom_tile(colour = "black") +
  scale_fill_manual(
    values = 
      c("Healthy" = "lightgreen", 
        "Unwell" = "red", 
        "Missing" = "orange")
  )

```





<!-- ======================================================= -->
## Из длинной в широкую {}

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "pivoting", "pivot_wider_new.png"))
```


В некоторых случаях нам может быть необходимо конвертировать набор данных в широкий формат. Для этого мы можем использовать функцию `pivot_wider()`.

Типичный пример применения - когда мы хотим трансформировать результаты анализа в формат, который более удобен для читателя (например, [Таблицы для презентации][Таблицы для презентации]). Как правило, это требует трансформации набора данных, в котором информация об одном субъекте распределена на несколько строк, в формат, где информация хранится в одной строке.

### Данные {.unnumbered}

Для данного раздела страницы мы будем использовать построчный список случаев (см. раздел [Подготовка](#pivot_prep)), который содержит по одной строке на случай.  

Here are the first 50 rows:  

```{r, message=FALSE, echo=F}
# отображает данные построчного списка в виде таблицы
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


Представим, что нам нужно узнать количество лиц в разных возрастных группах по полу:

```{r}
df_wide <- 
  linelist %>% 
  count(age_cat, gender)

df_wide
```

Это даст нам длинный набор данных, который хорошо подходит для подготовки визуализаций в **ggplot2**, но не очень подходит для презентации в виде таблицы:

```{r}
ggplot(df_wide) +
  geom_col(aes(x = age_cat, y = n, fill = gender))
```

### Горизонтальный поворот {.unnumbered}  

Следовательно, мы можем использовать `pivot_wider()`, чтобы преобразовать данные в более подходящий формат, чтобы включить в виде таблиц в наши отчеты.  

Аргумент `names_from` определяет столбец, *из которого* генерируются новые *имена* столбца, а аргумент `values_from` уточняет столбец, *из которого* нужно взять *значения* для заполнения ячеек. Аргумент `id_cols = ` является опциональным, но через него может быть задан вектор имен столбцов, которые не нужно поворачивать, и он таким образом определит каждую строку.  

```{r}
table_wide <- 
  df_wide %>% 
  pivot_wider(
    id_cols = age_cat,
    names_from = gender,
    values_from = n
  )

table_wide
```

Эта таблица гораздо более удобна для читателя, следовательно, она больше подходит для включения в наши отчеты. Вы можете проводить конвертацию в красивую таблицу с помощью ряда пакетов, включая **flextable** и **knitr**. Этот процесс более детально рассматривается на странице [Таблицы для презентации].  

```{r}
table_wide %>% 
  janitor::adorn_totals(c("row", "col")) %>% # добавляем итого по строкам и столбцам
  knitr::kable() %>% 
  kableExtra::row_spec(row = 10, bold = TRUE) %>% 
  kableExtra::column_spec(column = 5, bold = TRUE) 
```

---


<!-- ======================================================= -->
## Заполнение 

В некоторых ситуациях после поворота `pivot`, и еще чаще после связывания `bind`, у нас остаются пробелы в некоторых ячейках, которые нам нужно заполнить.  

<!-- ======================================================= -->
### Данные {.unnumbered}

Например, возьмем два набора данных, каждый с наблюдениями для номера измерений, названия организации, а также количеством случаев на этот момент. Однако во втором наборе данных есть также переменная `Year`. 

```{r}
df1 <- 
  tibble::tribble(
       ~Measurement, ~Facility, ~Cases,
                  1,  "Hosp 1",     66,
                  2,  "Hosp 1",     26,
                  3,  "Hosp 1",      8,
                  1,  "Hosp 2",     71,
                  2,  "Hosp 2",     62,
                  3,  "Hosp 2",     70,
                  1,  "Hosp 3",     47,
                  2,  "Hosp 3",     70,
                  3,  "Hosp 3",     38,
       )

df1 

df2 <- 
  tibble::tribble(
    ~Year, ~Measurement, ~Facility, ~Cases,
     2000,            1,  "Hosp 4",     82,
     2001,            2,  "Hosp 4",     87,
     2002,            3,  "Hosp 4",     46
  )

df2
```


Когда мы проводим `bind_rows()`, чтобы соединить два набора данных, переменная `Year` заполняется `NA` для тех строк, по которым не было предварительной информации (т..е первый набор данных):


```{r}
df_combined <- 
  bind_rows(df1, df2) %>% 
  arrange(Measurement, Facility)

df_combined

```

<!-- ======================================================= -->
### `fill()` {.unnumbered}

В данном случае `Year` является полезной переменной для включения, особенно если мы хотим изучить тренды со временем. Следовательно, мы используем `fill()`, чтобы *заполнить* эти пустые ячейки, указав столбец для заполнения и направление (в данном случае **up - вверх**):

```{r}
df_combined %>% 
  fill(Year, .direction = "up")
```

Альтернативно, мы можем сменить порядок данных, чтобы заполнять в направлении вниз:

```{r}
df_combined <- 
  df_combined %>% 
  arrange(Measurement, desc(Facility))

df_combined

df_combined <- 
  df_combined %>% 
  fill(Year, .direction = "down")

df_combined
```

Теперь у нас есть полезный набор данных для построения графика:

```{r}
ggplot(df_combined) +
  aes(Year, Cases, fill = Facility) +
  geom_col()
```

Но этот набор данных в меньшей степени подходит для презентации в виде таблицы, поэтому давайте попрактикуем конвертацию этого длинного неаккуратного датафрейма в широкий аккуратный датафрейм:

```{r}
df_combined %>% 
  pivot_wider(
    id_cols = c(Measurement, Facility),
    names_from = "Year",
    values_from = "Cases"
  ) %>% 
  arrange(Facility) %>% 
  janitor::adorn_totals(c("row", "col")) %>% 
  knitr::kable() %>% 
  kableExtra::row_spec(row = 5, bold = TRUE) %>% 
  kableExtra::column_spec(column = 5, bold = TRUE) 
```

Примечание: В данном случае нам нужно было уточнить, что нужно включать только три переменных `Facility`, `Year` и `Cases`, поскольку дополнительная переменная `Measurement` мешала бы созданию таблицы:

```{r}
df_combined %>% 
  pivot_wider(
    names_from = "Year",
    values_from = "Cases"
  ) %>% 
  knitr::kable()
```

## Ресурсы  

Вот полезный [самоучитель](https://datacarpentry.org/r-socialsci/03-dplyr-tidyr/index.html)

