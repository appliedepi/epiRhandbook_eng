# Coğrafi Bilgi Sistemleri (CBS) Temelleri { }  

```{r, out.width=c('100%', '100%'), echo=F}
knitr::include_graphics(here::here("images", "gis_head_image.png"))
```

<!-- ======================================================= -->
## Genel Bakış { }

Verilerinizin uzamsal yönleri, salgının durumuna ilişkin pek çok içgörü sağlayabilir ve aşağıdaki gibi soruları yanıtlayabilir:

* Mevcut hastalık noktaları nerede?
* Kümelenme noktaları zaman içinde nasıl değişti?
* Sağlık tesislerine ulaşım nasıl? Herhangi bir iyileştirme gerekli mi?

Bu CBS sayfasının mevcut odak noktası, salgın yanıtında uygulamalı epidemiyologların ihtiyaçlarını ele almaktır. **tmap** ve **ggplot2** paketlerini kullanarak temel mekansal veri görselleştirme yöntemlerini keşfedeceğiz. Ayrıca **sf** paketi ile bazı temel uzamsal veri yönetimi ve sorgulama yöntemlerini de inceleyeceğiz. Son olarak, **spdep** paketini kullanarak uzamsal ilişkiler, uzamsal otokorelasyon ve uzamsal regresyon gibi *mekansal istatistik* kavramlarına kısaca değineceğiz.



## Anahtar terimler {}

Aşağıda bazı temel terminolojiyi tanıtıyoruz. CBS ve mekansal analize kapsamlı bir giriş için, Referanslar bölümünde listelenen daha uzun öğreticilerden veya kurslardan birini incelemenizi öneririz.

**Coğrafi Bilgi Sistemi (CBS)** - CBS, mekansal verileri toplamak, yönetmek, analiz etmek ve görselleştirmek için bir çerçeve veya ortamdır.

### CBS yazılımı {.unnumbered}

Bazı popüler CBS yazılımları, harita geliştirme ve mekansal analiz için işaretle ve tıkla etkileşimine izin verir. Bu araçlar, kod öğrenmeye gerek olmaması ve simgeleri ve özellikleri bir haritaya manuel olarak seçme ve yerleştirme kolaylığı gibi avantajlarla birlikte gelir. İşte iki popüler olan:

**ArcGIS** - ESRI şirketi tarafından geliştirilen, çok popüler ancak oldukça pahalı olan ticari bir CBS yazılımı

**QGIS** - ArcGIS'in yapabileceği hemen hemen her şeyi yapabilen ücretsiz bir açık kaynaklı CBS yazılımı. [QGIS'i buradan indirebilirsiniz](https://qgis.org/en/site/forusers/download.html)

R'ı bir CBS olarak kullanmak, "işaretle ve tıkla" yerine bir "komut satırı arayüzüne" sahip olduğundan (istenen sonucu elde etmek için kodlamanız gerekir) ilk başta daha korkutucu görünebilir. Ancak, tekrar tekrar haritalar üretmeniz veya tekrarlanabilir bir analiz oluşturmanız gerekiyorsa bu büyük bir avantajdır.

### Mekansal veri {.unnumbered}

CBS'de kullanılan iki temel konumsal veri biçimi vektör ve hücresel(raster) veridir:

**Vektör Verileri** - CBS'de kullanılan en yaygın konumsal veri biçimi olan vektör verileri, köşelerin ve yolların geometrik özelliklerinden oluşur. Vektör uzamsal verileri ayrıca yaygın olarak kullanılan üç türe ayrılabilir:

  * *Noktalar* - Bir nokta, bir koordinat sistemindeki belirli bir konumu temsil eden bir koordinat çiftinden (x,y) oluşur. Noktalar, uzamsal verilerin en temel biçimidir ve bir durumu (yani hasta evi) veya bir konumu (yani hastaneyi) bir harita üzerinde belirtmek için kullanılabilir.

  * *Çizgiler* - Çizgi, birbirine bağlı iki noktadan oluşur. Çizgilerin bir uzunluğu vardır ve yollar veya nehirler gibi şeyleri belirtmek için kullanılabilir.

  * *Çokgenler* - Çokgen, noktalarla birbirine bağlanan en az üç doğru parçasından oluşur. Çokgen özellikleri bir uzunluğa (yani alanın çevresi) ve ayrıca bir alan ölçümüne sahiptir. Çokgenler bir alanı (yani bir köyü) veya bir yapıyı (yani bir hastanenin gerçek alanını) belirtmek için kullanılabilir.

**Hücresel Veri** - Uzamsal veriler için alternatif bir format olan hücresel veriler, her hücrenin yükseklik, sıcaklık, eğim, orman örtüsü vb. gibi bilgileri içeren bir hücre matrisidir (örneğin pikseller). Bunlar genellikle hava fotoğrafları, uydu görüntüler, vb. Rasterler (yani hücresel haritalar), vektör verilerinin altında “temel haritalar” olarak da kullanılabilir.

### Uzamsal verileri görselleştirme {.unnumbered}

Bir harita üzerinde uzamsal verileri görsel olarak temsil etmek için, CBS yazılımı, farklı özelliklerin birbiriyle ilişkili olarak nerede olması gerektiği hakkında yeterli bilgi sağlamanızı gerektirir. Çoğu kullanım durumu için geçerli olan vektör verilerini kullanıyorsanız, bu bilgiler genellikle bir şekil dosyasında depolanır:

**Shapefiles** - Shapefile, çizgilerden, noktalardan veya çokgenlerden oluşan "vektör" uzamsal verileri depolamak için yaygın bir veri biçimidir. Tek bir şekil dosyası aslında en az üç dosyadan oluşan bir koleksiyondur - .shp, .shx ve .dbf. Şekil dosyasının okunabilmesi için tüm bu alt bileşen dosyalarının belirli bir dizinde (klasörde) bulunması gerekir. Bu ilişkili dosyalar, e-posta yoluyla gönderilmek veya bir web sitesinden indirilmek üzere bir ZIP klasörüne sıkıştırılabilir.

Şekil dosyası, özelliklerin kendileri ve bunların Dünya yüzeyinde nereye yerleştirileceği hakkında bilgi içerecektir. Bu önemlidir, çünkü Dünya bir küre iken, haritalar tipik olarak iki boyutludur; uzamsal verilerin nasıl "düzleştirileceğine" ilişkin seçimler, ortaya çıkan haritanın görünümü ve yorumlanması üzerinde büyük bir etkiye sahip olabilir.

**Koordinat Referans Sistemleri (CRS)** - CRS, Dünya yüzeyindeki coğrafi özellikleri konumlandırmak için kullanılan koordinat tabanlı bir sistemdir. Birkaç temel bileşeni vardır:

  * *Koordinat Sistemi* - Birçok farklı koordinat sistemi vardır, bu nedenle koordinatlarınızın hangi sistemden olduğunu bildiğinizden emin olun. Enlem/boylam dereceleri yaygındır, ancak [UTM](https://www.maptools.com/tutorials/utm/quick_guide) koordinatlarını da görebilirsiniz.
  
 * *Birimler* - Koordinat sisteminiz için birimlerin ne olduğunu öğrenin (ör. ondalık dereceler, metreler)

  * *Datum* - Dünya'nın belirli bir modellenmiş versiyonu. Bunlar yıllar içinde revize edilmiştir, bu nedenle harita katmanlarınızın aynı veriyi kullandığından emin olun. Özellikle herhangi bir konum verisi elde edilirken yatay ve düşey konumunu tanımlamak için başlangıç alınan bir referans yüzeyi gereklidir. Yer'in şeklini ve boyutunu tanımlayan bu yüzeye Datum adı verilmektedir.

  * *Projeksiyon* - Gerçekten yuvarlak olan dünyayı düz bir yüzeye (harita) yansıtmak için kullanılan matematiksel denklem.

Aşağıda gösterilen haritalama araçlarını kullanmadan uzamsal verileri özetleyebileceğinizi unutmayın. Bazen coğrafyaya göre (ör. ilçe, ülke vb.) basit bir tablo yeterlidir!



## CBS'yi kullanmaya başlama

Bir harita yapmak için sahip olmanız ve düşünmeniz gereken birkaç önemli öğe var. Bunlar şunları içerir:

  * Bir **veri kümesi** -- bu, uzamsal bir veri biçiminde olabilir (yukarıda belirtildiği gibi şekil dosyaları gibi) veya uzamsal bir biçimde olmayabilir (örneğin sadece bir csv olarak).
  
  * Veri kümeniz uzamsal biçimde değilse ayrıca bir **referans veri kümesine** ihtiyacınız olacaktır. Referans verileri, verilerin uzamsal temsilinden ve belirli özelliklerin konum ve adres bilgilerini içeren materyali içeren ilgili **niteliklerden** oluşur.
  
    + Önceden tanımlanmış coğrafi sınırlarla (örneğin, idari bölgeler) çalışıyorsanız, referans şekil dosyaları genellikle bir devlet kurumundan veya veri paylaşım kuruluşundan ücretsiz olarak indirilebilir. Şüpheye düştüğünüzde,  Google "[bölgeler] şekil dosyası" başlamak için iyi bir yerdir.
    
    + Adres bilginiz varsa ancak enlem ve boylam yoksa, kayıtlarınız için uzamsal referans verilerini almak için bir **coğrafi kodlama motoru** kullanmanız gerekebilir.
    
  * Veri kümelerinizdeki bilgileri hedef kitlenize **nasıl sunmak istediğiniz** hakkında fikriniz olmalı. Birçok farklı harita türü vardır ve ihtiyaçlarınıza en uygun harita türünü düşünmek önemlidir.

### Verilerinizi görselleştirmek için harita türleri {.unnumbered}

**Choropleth haritası** - coğrafi bölgeleri bir öznitelik değerine göre temsil etmek için renklerin, gölgelerin veya desenlerin kullanıldığı bir tür tematik haritadır. Örneğin, daha büyük bir değer, daha küçük bir değerden daha koyu bir renkle gösterilebilir. Bu harita türü, bir değişkeni ve onun tanımlanmış bölgeler veya jeopolitik alanlar arasında nasıl değiştiğini görselleştirirken özellikle kullanışlıdır.

```{r, out.width = '50%', fig.align = "center", fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "gis_choropleth.png"))
```

**Vaka yoğunluğu ısı haritası** - renklerin bir değerin yoğunluğunu temsil etmek için kullanıldığı, ancak verileri gruplamak için tanımlanmış bölgeleri veya jeopolitik sınırları kullanmadığı bir tür tematik haritadır. Bu harita türü tipik olarak "sıcak noktaları" veya yüksek yoğunluklu veya nokta yoğunluğuna sahip alanları göstermek için kullanılır.

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "gis_heatmap.png"))
```

**Nokta yoğunluğu haritası** - verilerinizdeki öznitelik değerlerini temsil etmek için noktaları kullanan tematik bir harita türüdür. Bu tür harita en iyi, verilerinizin dağılımını görselleştirmek ve kümeleri görsel olarak taramak için kullanılır.

```{r, fig.align = "center", echo=F}
# nokta yoğunluğu fotoğrafı buraya
```

**Oransal semboller haritası (dereceli semboller haritası)** - bir choropleth haritasına benzer bir tematik harita, ancak bir özelliğin değerini belirtmek için renk kullanmak yerine, değere göre bir sembol (genellikle bir daire) kullanır. Örneğin, daha büyük bir değer, daha küçük bir değerden daha büyük bir sembolle gösterilebilir. Bu harita türü en iyi, coğrafi bölgelerdeki verilerinizin boyutunu veya miktarını görselleştirmek istediğinizde kullanılır.

```{r, fig.align = "center", echo=F}
# orantısal semboller fotoğrafı buraya
```

Karmaşık coğrafi kalıpları göstermek için birkaç farklı görselleştirme türünü de birleştirebilirsiniz. Örneğin aşağıdaki haritadaki vakalar (noktalar) en yakın sağlık kuruluşuna göre renklendirilmiştir (bkz. lejand). Büyük kırmızı daireler, belirli bir yarıçaptaki *sağlık tesisi hizmet alanlarını* ve herhangi bir hizmet alanı dışında kalan parlak kırmızı vaka noktalarını gösterir:

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "gis_hf_catchment.png"))
```

Not: Bu CBS sayfasının birincil odak noktası, saha salgın yanıtı bağlamına dayanmaktadır. Bu nedenle sayfanın içeriği, temel uzamsal veri manipülasyonlarını, görselleştirmeleri ve analizleri kapsayacaktır.


<!-- ======================================================= -->
## Hazırlık {  }

### Paketleri yükleyin {.unnumbered}

Bu kod parçası, analizler için gereken paketlerin yüklenmesini gösterir. Bu el kitabında, gerekirse paketi kuran *ve* kullanım için yükleyen **pacman**'dan `p_load()` vurgusunu yapıyoruz. R tabanından `library()` ile kurulu paketleri de yükleyebilirsiniz. R paketleri hakkında daha fazla bilgi için [R basics] sayfasına bakabilirsiniz.

```{r}
pacman::p_load(
  rio,           # verileri içe aktarmak için
  here,          # dosyaları bulmak için
  tidyverse,     # verileri temizlemek, işlemek ve çizmek için (ggplot2 paketini içerir)
  sf,            # Basit Özellik formatı kullanarak uzamsal verileri yönetmek için
  tmap,          # basit haritalar üretmek için hem etkileşimli hem de statik haritalar için çalışır
  janitor,       # sütun adlarını temizlemek için
  OpenStreetMap, # ggplot haritasına OSM altlık haritası eklemek için
  spdep          # mekansal istatistik
  ) 
                  
```

[CRAN "Uzamsal Görev Görünümü"nde](https://cran.r-project.org/web/views/Spatial.html) uzamsal verilerle ilgilenen tüm R paketlerinin bir özetini görebilirsiniz.


### Örnek vaka verileri {.unnumbered}

Gösteri amacıyla, simüle edilmiş Ebola salgını "satır listesi" veri çerçevesinden rastgele 1000 vakalık bir örneklemle çalışacağız (hesaplamalı olarak, daha az vakayla çalışmak bu el kitabında daha kolaydır). Takip etmek isterseniz, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>"clean" dosyasını indirmek için tıklayın.</a> (.rds dosyası olarak).

Vakaların rastgele bir örneğini aldığımız için, kodları kendi başınıza çalıştırdığınızda sonuçlarınız burada gösterilenden biraz farklı görünebilir.

**rio** paketinden `import()` fonksiyonuyla verileri içe aktarın (.xlsx, .csv, .rds gibi birçok dosya türünü işler - ayrıntılar için [İçe aktarma ve dışa aktarma] sayfasına bakın).

```{r, echo=F}
# temizlenmiş vaka satır listesini içe aktarmak
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))  
```

```{r, eval=F}
# temizlenmiş vaka satır listesini içe aktarmak
linelist <- import("linelist_cleaned.rds")  
```

Daha sonra R **tabanı**ndan `sample()` kullanarak 1000 satırlık rastgele bir örnek seçiyoruz.

```{r}
# satır listesindeki satır sayısından 1000 rastgele satır numarası üretmek
sample_rows <- sample(nrow(linelist), 1000)

# yalnızca örnek satırları ve tüm sütunları tutmak için alt küme satır listesi üretmek
linelist <- linelist[sample_rows,]
```

Şimdi sınıf veri çerçevesi olan bu 'linelist'i "sf" (uzaysal özellikler) sınıfının bir nesnesine dönüştürmek istiyoruz. Satır listesinin, her vakanın ikametgahının enlem ve boylamını temsil eden iki sütun "boy" ve "en" olduğu göz önüne alındığında, bu kolay olacaktır.

**sf** (uzaysal özellikler) paketini ve onun 'st_as_sf()' fonksiyonunu 'linelist_sf' dediğimiz yeni nesneyi yaratmak için kullanırız. Bu yeni nesne, esasen satır listesiyle aynı görünüyor, ancak "boy" ve "enlem" sütunları koordinat sütunları olarak belirlenmiş ve noktalar görüntülendiğinde bir koordinat referans sistemi (CRS) atanmıştır. 4326, koordinatlarımızı, GPS koordinatları için standart olan [World Geodetic System 1984 (WGS84)](https://gisgeography.com/wgs84-world-geodetic-system/) temelinde tanımlar.

```{r}
# sf nesnesi oluşturmk
linelist_sf <- linelist %>%
     sf::st_as_sf(coords = c("lon", "lat"), crs = 4326)
```

Orijinal "satır listesi" veri çerçevesi bu şekilde görünür. Bu gösterimde, yalnızca "date_onset" ve "geometry" (yukarıdaki boylam ve enlem alanlarından oluşturulan ve veri çerçevesindeki son sütun olan) sütununu kullanacağız.

```{r}
DT::datatable(head(linelist_sf, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Yönetici sınır şekil dosyaları {.unnumbered}

**Sierra Leone: Yönetici sınır şekil dosyaları**

Sierra Leone için tüm idari sınırları önceden İnsani Veri Değişimi'nden (HDX) [web sitesi burada](https://data.humdata.org/dataset/sierra-leone-all-ad-min-level-boundaries) indirdik. ). Alternatif olarak, bu el kitabı için bunları ve diğer tüm örnek verileri [El kitabını ve verileri indir] sayfasında açıklandığı gibi R paketimiz aracılığıyla indirebilirsiniz.

Şimdi Admin Level 3 şekil dosyasını R'a kaydetmek için aşağıdakileri yapacağız:

1) Şekil dosyasını içe aktarın
2) Sütun adlarını temizleyin
3) Yalnızca ilgi alanlarını korumak için satırları filtreleyin

Bir şekil dosyasını içe aktarmak için **sf**'den `read_sf()` fonksiyonunu kullanırız. Dosya yolu `here()` ile sağlanır. - bizim durumumuzda dosya, "data", "gis" ve "shp" alt klasörlerinde "sle_adm3.shp" dosya adıyla R projemizin içindedir (daha fazla bilgi için [İçe aktarma ve dışa aktarma] ve [R projeleri] sayfalarına bakabilirsiniz). Kendi dosya yolunuzu sağlamanız gerekecek.

```{r, echo=F}
sle_adm3_raw <- sf::read_sf(here("data", "gis", "shp", "sle_adm3.shp"))
```


Daha sonra, şekil dosyasının sütun adlarını standartlaştırmak için **janitor** paketinden `clean_names()` kullanıyoruz. Ayrıca sadece "Western Area Urban" veya "Western Area Rural" admin2name ile satırları tutmak için `filter()` kullanırız.

```{r}
# ADM3 seviyesi temizlik 
sle_adm3 <- sle_adm3_raw %>%
  janitor::clean_names() %>% # sütun isimlerini standardize etmek
  filter(admin2name %in% c("Western Area Urban", "Western Area Rural")) # belirli alanları tutmak için filtrelemek
```

Aşağıda, içe aktarma ve temizleme işleminden sonra şekil dosyasının nasıl göründüğünü görebilirsiniz. *sağa doğru kaydırın* yönetici düzeyi 0 (ülke), yönetici düzeyi 1, yönetici düzeyi 2 ve son olarak yönetici düzeyi 3 olan sütunların nasıl olduğunu görmek için her düzeyin bir karakter adı ve benzersiz bir "pcode" tanımlayıcısı vardır. Pcode, artan her yönetici düzeyiyle birlikte genişler; SL (Sierra Leone) -> SL04 (Batı) -> SL0410 (Batı Bölgesi Kırsal) -> SL040101 (Koya Kırsal).

```{r message=FALSE, echo=F}
#şekil dosyasını tablo olarak göstermek
DT::datatable(head(sle_adm3, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



### Nüfus verileri {.unnumbered}

**Sierra Leone: ADM3'e göre nüfus**

Bu veriler tekrar HDX'ten (bağlantı [buradan](https://data.humdata.org/dataset/sierra-leone-population)) veya [bu sayfada] açıklandığı gibi **epirhandbook** R paketimizden indirilebilir. [El kitabını ve verileri indirin]. .csv dosyasını yüklemek için `import()` kullanıyoruz. Ayrıca, sütun adı sözdizimini standartlaştırmak için içe aktarılan dosyayı `clean_names()` öğesine iletiyoruz.

```{r}
# ADM3'e göre nüfus
sle_adm3_pop <- import(here("data", "gis", "population", "sle_admpop_adm3_2020.csv")) %>%
  clean_names()
```

Popülasyon dosyası böyle görünüyor. Her yetki alanında "erkek" nüfus, "kadın" nüfus, "toplam" nüfus ve yaş grubuna göre nüfus dökümü sütunlarının nasıl olduğunu görmek için sağa kaydırın.

```{r message=FALSE, echo=F}
# nüfusu tablo olarak göstermek
DT::datatable(head(sle_adm3_pop, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


### Sağlık Tesisleri {.unnumbered}

**Sierra Leone: OpenStreetMap'ten alınan sağlık tesisi verileri**

Yine sağlık tesislerinin konumlarını HDX [buradan](https://data.humdata.org/dataset/hotosm_sierra_leone_health_facilities) veya [el kitabını ve verileri indir] sayfasındaki talimatlar aracılığıyla indirdik.

Tesis noktaları şekil dosyasını `read_sf()` ile içe aktarıyoruz, sütun adlarını tekrar temizliyoruz ve ardından yalnızca "hastane", "klinik" veya "doktorlar" olarak etiketlenmiş noktaları tutmak için filtreliyoruz.


```{r}
# OSM sağlık tesisi şekil dosyası
sle_hf <- sf::read_sf(here("data", "gis", "shp", "sle_hf.shp")) %>% 
  clean_names() %>%
  filter(amenity %in% c("hospital", "clinic", "doctors"))
```

İşte ortaya çıkan veri çerçevesi - tesis adını ve "geometri" koordinatlarını görmek için *sağa kaydırın*.

```{r message=FALSE, echo=F}
# nüfusu tablo olarak göstermek
DT::datatable(head(sle_hf, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```





<!-- ======================================================= -->
## Koordinatları grafikleştirme{ }

Bu durumda X-Y koordinatlarını (boylam/enlem, noktalar) çizmenin en kolay yolu, bunları doğrudan hazırlık bölümünde oluşturduğumuz `linelist_sf` nesnesinden nokta olarak çizmektir.

**tmap** paketi, hem statik ("çizim" modu) hem de etkileşimli ("görünüm" modu) için yalnızca birkaç satır kodla basit eşleme yetenekleri sunar. **tmap** sözdizimi **ggplot2**'ninkine benzerdir, öyle ki komutlar `+' ile birbirine eklenir. Bu [gösterimde](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html) daha fazla ayrıntı okuyabilirsiniz.


1) **tmap** modunu ayarlayın. Bu durumda statik çıktılar üreten "plot" modunu kullanacağız.

```{r, warning = F, message=F}
tmap_mode("plot") # "görünüm" veya "grafik"i seçin
```

Aşağıda, noktalar tek başına çizilir.`tm_shape()``,`linelist_sf` nesneleri ile sağlanır. Daha sonra boyut ve rengi belirterek `tm_dots()` aracılığıyla noktalar ekliyoruz. "linelist_sf" bir sf nesnesi olduğundan, enlem/boylam koordinatlarını ve koordinat referans sistemini (CRS) içeren iki sütunu zaten belirledik: 


```{r, warning = F, message=F}
# noktalar sadece vakalar
tm_shape(linelist_sf) + tm_dots(size=0.08, col='blue')
```

Yalnız, puanlar bize fazla bir şey söylemez. Dolayısıyla idari sınırları da haritalandırmalıyız:

Yine `tm_shape()` kullanıyoruz
(bkz. [dokümantasyon] https://www.rdocumentation.org/packages/tmap/versions/3.3/topics/tm_shape)) ancak vaka noktaları şekil dosyası sağlamak yerine, idari sınır şekil dosyası (çokgenler) sağlıyoruz.

`bbox = ` değişkeniyle (bbox "sınırlayıcı kutu" anlamına gelir) koordinat sınırlarını belirleyebiliriz. Önce harita gösterimini `bbox` olmadan ve sonra onunla birlikte gösteriyoruz.  

```{r, out.width = c('50%', '50%'), fig.show='hold', warning=F, message=F}
# Çokgenler sadece idari sınırlar
tm_shape(sle_adm3) +               # yönetici sınırları şekil dosyası
  tm_polygons(col = "#F7F7F7")+    # çokgenleri açık gri olarak göster
  tm_borders(col = "#000000",      # renk ve çizgi ağırlığı ile sınırları göster
             lwd = 2) +
  tm_text("admin3name")            # her çokgen için görüntülenecek sütun metni


# Yukarıdakiyle aynı, ancak sınırlayıcı kutudan yakınlaştırma ile
tm_shape(sle_adm3,
         bbox = c(-13.3, 8.43,    # corner
                  -13.2, 8.5)) +  # corner
  tm_polygons(col = "#F7F7F7") +
  tm_borders(col = "#000000", lwd = 2) +
  tm_text("admin3name")

```


Ve şimdi hem noktalar hem de çokgenler birlikte:

```{r, warning=F, message=FALSE}
# Hepsi birlikte
tm_shape(sle_adm3, bbox = c(-13.3, 8.43, -13.2, 8.5)) +     
  tm_polygons(col = "#F7F7F7") +
  tm_borders(col = "#000000", lwd = 2) +
  tm_text("admin3name")+
tm_shape(linelist_sf) +
  tm_dots(size=0.08, col='blue', alpha = 0.5) +
  tm_layout(title = "Distribution of Ebola cases")   # haritaya isim vermek

```


R'daki eşleme seçeneklerinin iyi bir karşılaştırmasını okumak için bu [blog gönderisine](https://rstudio-pubs-static.s3.amazonaws.com/324400_69a673183ba449e9af4011b1eeb456b9.html) bakabilirsiniz.




<!-- ============================================ ========= -->
## Mekansal birleşimler {}

Verileri bir veri kümesinden diğerine *birleştirmeye* aşina olabilirsiniz. Bu el kitabının [Birleştirme verileri] sayfasında çeşitli yöntemler tartışılmaktadır. Bir uzamsal birleşim benzer bir amaca hizmet eder, ancak uzamsal ilişkilerden yararlanır. Gözlemleri doğru bir şekilde eşleştirmek için sütunlardaki ortak değerlere güvenmek yerine, bir özelliğin bir diğerinin *içinde* olması veya bir diğerine *en yakın komşu* olması veya belirli bir yarıçapın *tampon* içinde olması gibi uzamsal ilişkilerini kullanabilirsiniz. 


**sf** paketi, uzamsal birleşimler için çeşitli yöntemler sunar. Bu [başvuruda](https://r-spatial.github.io/sf/reference/geos_binary_pred.html) st_join yöntemi ve uzamsal birleştirme türleri hakkında daha fazla belgeye bakabilirsiniz.


### Çokgendeki noktalar {.unnumbered}
**Mekansal olarak vakalara idari birimler atama**

İşte ilginç bir muamma: vakaların satır listesi, vakaların idari birimleri hakkında herhangi bir bilgi içermiyor. İlk veri toplama aşamasında bu tür bilgileri toplamak ideal olsa da, uzamsal ilişkilerine dayalı olarak bireysel vakalara idari birimler de atayabiliriz (yani nokta bir çokgenle kesişir).

Aşağıda, durum konumlarımızı (noktaları) ADM3 sınırları (poligonlar) ile uzamsal olarak keseceğiz:

1) Satır listesi(puan) ile başlayın
2) Sınırlara uzamsal birleştirme, birleştirme türünü "st_intersects" olarak ayarlayın
3) Yeni yönetim sınırı sütunlarından yalnızca belirli bir kısmını tutmak için `select()` kullanın

```{r, warning=F, message=F}
linelist_adm <- linelist_sf %>%
  
  # idari sınır dosyasını uzamsal kesişime dayalı olarak satır listesine ekleyin
  sf::st_join(sle_adm3, join = st_intersects)
```

'sle_adms'deki tüm sütunlar satır listesine eklendi! Artık her vaka, içinde bulunduğu idari seviyeleri detaylandıran sütunlara sahiptir. Bu örnekte, yeni sütunlardan yalnızca ikisini (yönetici düzeyi 3) tutmak istiyoruz, bu nedenle eski sütun adlarını ve yalnızca iki ek ilgiyi "select()" yapıyoruz: 

```{r, warning=F, message=F}
linelist_adm <- linelist_sf %>%
  
  # idari sınır dosyasını uzamsal kesişime dayalı olarak satır listesine ekleyin
  sf::st_join(sle_adm3, join = st_intersects) %>% 
  
  # Eski sütun adlarını ve ilgilendiğiniz iki yeni yönetici adlarını saklayın
  select(names(linelist_sf), admin3name, admin3pcod)
```

Aşağıda, yalnızca görüntüleme amacıyla, noktanın çokgen şekilleriyle uzamsal olarak kesiştiği yere bağlı olarak ilk on vakayı ve bunların admin seviyesi 3 (ADM3) yargı yetkilerini görebilirsiniz. 

```{r, warning=F, message=F}
# Şimdi her bir vakaya eklenmiş ADM3 adlarını göreceksiniz.
linelist_adm %>% select(case_id, admin3name, admin3pcod)
```

Şimdi durumlarımızı idari birime göre tanımlayabiliriz - uzaysal birleşmeden önce yapamadığımız bir şey!

```{r, warning=F, message=F}
# İdari birime göre vaka sayılarını içeren yeni veri çerçevesi yapın
case_adm3 <- linelist_adm %>%          # yeni yönetici sütunlarına sahip satır listesiyle başlayın
  as_tibble() %>%                      # daha iyi görüntü için tibble'a dönüştürün
  group_by(admin3pcod, admin3name) %>% # admin birimine göre gruplandır, hem ada hem de pkoda göre
  summarise(cases = n()) %>%           # satırları özetle ve say
  arrange(desc(cases))                     # azalan sırada düzenle

case_adm3
```

Ayrıca idari birime göre vaka sayımlarının bir çubuk grafiğini de oluşturabiliriz.

Bu örnekte, ggplot()'a 'linelist_adm' ile başlıyoruz, böylece çubukları frekansa göre sıralayan 'fct_infreq()' gibi faktör fonksiyonlarını uygulayabiliriz (ipuçları için [Faktörler] sayfasına bakınız).

```{r, warning=F, message=F}
ggplot(
    data = linelist_adm,                       # yönetici birimi bilgilerini içeren satır listesiyle başlayın
    mapping = aes(
      x = fct_rev(fct_infreq(admin3name))))+ # x ekseni, frekansa göre sıralanmış (tersine çevrilmiş) yönetici birimleridir
   geom_bar()+                      # çubuk oluştur, yükseklik satır sayısıdır
   coord_flip()+ # adm birimlerinin daha kolay okunması için X ve Y eksenlerini çevirin
   theme_classic()+ # arka planı basitleştirir
   labs( # başlık ve etiket
    x = "Admin level 3",
    y = "Number of cases",
    title = "Number of cases, by adminstative unit",
    caption = "As determined by a spatial join, from 1000 randomly sampled cases from linelist"
  )
```


<!-- ======================================================= -->
### En yakın komşu {.unnumbered}

**En yakın sağlık kuruluşunu / toplanma alanını bulma**

Hastalık sıcak noktaları ile ilgili olarak sağlık tesislerinin nerede olduğunu bilmek faydalı olabilir.

Bireysel vakalara en yakın sağlık tesisini görselleştirmek için `st_join()` fonksiyonundan (**sf** paketi) *st_nearest_feature* birleştirme yöntemini kullanabiliriz.

1) Satır listesinin şekil dosyası `linelist_sf` ile başlıyoruz
2) Sağlık tesislerinin ve kliniklerin konumları olan `sle_hf` ile mekansal olarak birleştiriyoruz (puan)

```{r, warning=F, message=F}
# Her vakaya en yakın sağlık kuruluşu
linelist_sf_hf <- linelist_sf %>%                  # satır listesini şekil dosyası ile başla
  st_join(sle_hf, join = st_nearest_feature) %>%   # vaka verilerine en yakın klinikten alınan veriler
  select(case_id, osm_id, name, amenity) %>%       # sağlık tesisinin adı, türü ve geometrisi dahil olmak üzere ilgili sütunları tutmak
  rename("nearest_clinic" = "name")                # netlik için yeniden adlandırın
```

Aşağıda (ilk 50 satır) her vakanın artık en yakın klinik/hastaneye ait verileri olduğunu görebiliriz.

```{r message=FALSE, echo=F}
DT::datatable(head(linelist_sf_hf, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


Vakaların yaklaşık %30'u için en yakın sağlık kuruluşunun "Den Clinic" olduğunu görebiliyoruz.

```{r}
# Sağlık kuruluşuna göre vaka sayıları
hf_catchment <- linelist_sf_hf %>%   # en yakın klinik verilerini içeren satır listesiyle başlayın
  as.data.frame() %>%                # şekil dosyasından veri çerçevesine dönüştür
  count(nearest_clinic,              # satırları "ad" ile sayın (kliniğin)
        name = "case_n") %>%         # yeni sayım sütununu "case_n" olarak ata
  arrange(desc(case_n))              # azalan sırada düzenlemek

hf_catchment                         # konsola yazdırmak
```

Sonuçları görselleştirmek için **tmap** kullanabiliriz - bu sefer daha kolay görüntüleme için etkileşimli mod

```{r, warning=F, message=F}
tmap_mode("view")   # tmap modunu etkileşimli olarak ayarla

# vakaları ve klinik noktaları çizin 
tm_shape(linelist_sf_hf) +            # vaka grafikleri
  tm_dots(size=0.08,                  # en yakın klinik tarafından renklendirilen vakalar
          col='nearest_clinic') +    
tm_shape(sle_hf) +                    # klinik tesisleri büyük siyah noktalarla çizin
  tm_dots(size=0.3, col='black', alpha = 0.4) +      
  tm_text("name") +                   # tesis adı ile üzerine bindirme
tm_view(set.view = c(-13.2284, 8.4699, 13), # yakınlaştırmayı ayarla (merkez kodları, yakınlaştırma)
        set.zoom.limits = c(13,14))+
tm_layout(title = "Cases, colored by nearest clinic")
```


### Tamponlar {.unnumbered}

Ayrıca en yakın sağlık kuruluşuna 2,5 km (~30 dakika) yürüme mesafesinde kaç vaka bulunduğunu da keşfedebiliriz.

*Not: Daha doğru mesafe hesaplamaları için, sf nesnenizi UTM (düzlemsel bir yüzeye yansıtılan Dünya) gibi ilgili yerel harita projeksiyon sistemine yeniden yansıtmak daha iyidir. Bu örnekte, basit olması için Dünya Jeodezi Sistemi (WGS84) Coğrafi koordinat sistemine bağlı kalacağız (Dünya küresel / yuvarlak bir yüzeyde temsil edilir, bu nedenle birimler ondalık derece cinsindendir). Genel bir dönüşüm kullanacağız: 1 ondalık derece = ~111km.*

Bu [esri makalesinde](https://www.esri.com/arcgis-blog/products/arcgis-pro/mapping/gcs_vs_pcs/) harita projeksiyonları ve koordinat sistemleri hakkında daha fazla bilgi bulabilirsiniz. Bu [blog](http://www.geo.hunter.cuny.edu/~jochen/gtech201/lectures/lec6concepts/map%20coordinate%20systems/how%20to%20choose%20a%20projection.htm) harita projeksiyonu ve ilgi alanına ve haritanızın / analizinizin içeriğine bağlı olarak uygun bir projeksiyonun nasıl seçilebileceği gibi farklı türlerden bahsetmektedir.


**İlkin**, her sağlık tesisinin çevresinde ~2,5 km yarıçaplı dairesel bir tampon oluşturun. Bu, **tmap**'teki `st_buffer()` fonksiyonuyla yapılır. Haritanın birimi enlem/boylam ondalık derece cinsinden olduğundan, "0,02" bu şekilde yorumlanır. Harita koordinat sisteminiz metre cinsinden ise sayının metre cinsinden verilmesi gerekir.

```{r, warning=F, message=F}
sle_hf_2k <- sle_hf %>%
  st_buffer(dist=0.02)       # ondalık derece, yaklaşık 2,5 km'ye eşittir 
```

Aşağıda, tampon bölgeleri şu şekilde çiziyoruz:

```{r, warning=F, message=F}
tmap_mode("plot")
# Create circular buffers
tm_shape(sle_hf_2k) +
  tm_borders(col = "black", lwd = 2)+
tm_shape(sle_hf) +                    # klinik tesislerini büyük kırmızı noktalarla çizin
  tm_dots(size=0.3, col='black')      
```


**İkinci olarak*, bu arabellekleri 'st_join()' ve *st_intersects* birleştirme türünü kullanarak durumlar (noktalar) ile kesiştiririz. Yani tamponlardan gelen veriler kesiştikleri noktalara birleştirilir.

```{r, warning=F, message=F}
# Vakaları arabelleklerle kesiştirin
linelist_sf_hf_2k <- linelist_sf_hf %>%
  st_join(sle_hf_2k, join = st_intersects, left = TRUE) %>%
  filter(osm_id.x==osm_id.y | is.na(osm_id.y)) %>%
  select(case_id, osm_id.x, nearest_clinic, amenity.x, osm_id.y)
```

Şimdi sonuçları sayabiliriz: ` nrow(linelist_sf_hf_2k[is.na(linelist_sf_hf_2k$osm_id.y),])` 1000 vakadan herhangi biri arabellekle kesişmedi (bu değer eksik) ve bu yüzden en yakın sağlık kuruluşundan 30 dakikadan fazla yürüyün.

```{r}
# Sağlık tesisi tamponlarından herhangi biriyle kesişmeyen vakalar
linelist_sf_hf_2k %>% 
  filter(is.na(osm_id.y)) %>%
  nrow()
```

Sonuçları, herhangi bir arabellekle kesişmeyen vakaların kırmızı görüneceği şekilde görselleştirebiliriz.

```{r, out.width = '100%', warning=F, message=F}
tmap_mode("view")

# İlk önce vakaları puan olarak görüntüleyin
tm_shape(linelist_sf_hf) +
  tm_dots(size=0.08, col='nearest_clinic') +

# klinik tesisleri büyük siyah noktalarla çizin
tm_shape(sle_hf) +                    
  tm_dots(size=0.3, col='black')+   

# Ardından sağlık tesisi arabelleklerini çoklu çizgilerle kaplayın
tm_shape(sle_hf_2k) +
  tm_borders(col = "black", lwd = 2) +

# Herhangi bir sağlık tesisi tamponunun parçası olmayan vakaları vurgulayın
# kırmızı noktalarda
tm_shape(linelist_sf_hf_2k %>%  filter(is.na(osm_id.y))) +
  tm_dots(size=0.1, col='red') +
tm_view(set.view = c(-13.2284,8.4699, 13), set.zoom.limits = c(13,14))+

# Başlık ekleyin
tm_layout(title = "Cases by clinic catchment area")

```



### Diğer uzamsal birleşimler {.unnumbered}

"Birleştirme" bağımsız değişkeni için alternatif değerler şunları içerir ([belgelerden](https://r-spatial.github.io/sf/reference/st_join.html))
* st_contains_properly  
* st_contains  
* st_covered_by  
* st_covers  
* st_crosses  
* st_disjoint  
* st_equals_exact  
* st_equals  
* st_is_within_distance  
* st_nearest_feature  
* st_overlaps  
* st_touches  
* st_within  





## Choropleth haritaları {}


Choropleth haritaları, verilerinizi önceden tanımlanmış alan, genellikle idari birim veya sağlık alanı ile görselleştirmek için faydalı olabilir. Salgın müdahalesinde bu, örneğin yüksek insidans oranlarına sahip belirli alanlar için kaynak tahsisinin hedeflenmesine yardımcı olabilir.

Artık tüm vakalara atanan idari birim adlarına sahip olduğumuza göre (yukarıdaki uzamsal birleştirmeler bölümüne bakın), vaka sayılarını alana göre eşleştirmeye başlayabiliriz (choropleth haritaları).

ADM3'e göre popülasyon verisi de elimizde olduğundan, bu bilgiyi daha önce oluşturulan *case_adm3* tablosuna ekleyebiliriz.

Her bir idari birimin ve vaka sayısının bir özet tablosu olan önceki 'case_adm3' adımında oluşturulan veri çerçevesi ile başlıyoruz.

1) "sle_adm3_pop" popülasyon verileri, "case_adm3" veri çerçevesindeki "admin3pcod" sütunundaki ve "sle_adm3_pop içindeki "adm_pcode" sütunundaki ortak değerler temelinde **dplyr**'den bir "left_join()" kullanılarak birleştirilir `. [Birleştirme verileri] ile ilgili sayfaya bakın).
2) Yalnızca yararlı sütunları tutmak için yeni veri çerçevesine "select()" uygulanır - "toplam" toplam nüfustur
3) 10.000 nüfus başına vaka sayısı, `mutate()` ile yeni bir sütun olarak hesaplanır.

```{r}
# Nüfus verilerini ekleyin ve 10.000 nüfus başına vakaları hesaplayın
case_adm3 <- case_adm3 %>% 
     left_join(sle_adm3_pop,                             # pop veri kümesinden sütunlar ekle
               by = c("admin3pcod" = "adm3_pcode")) %>%  # bu iki sütundaki ortak değerlere dayalı olarak birleştir
     select(names(case_adm3), total) %>%                 # toplam nüfus da dahil olmak üzere yalnızca önemli sütunları tut
     mutate(case_10kpop = round(cases/total * 10000, 3)) # 3 ondalık basamağa yuvarlanmış 10.000 başına büyük/küçük harf oranıyla yeni sütun oluştur

case_adm3                                                # izlemek için konsola yazdır
```

Eşleme için bu tabloya ADM3 çokgen şekil dosyasıyla katılın

```{r, warning=F, message=F}
case_adm3_sf <- case_adm3 %>%                 #vakalarla başlayın ve yönetici birimine göre puan verin
  left_join(sle_adm3, by="admin3pcod") %>%    # ortak sütunla şekil dosyası verilerine katıl
  select(objectid, admin3pcod,                # yalnızca belirli ilgi sütunlarını tut
         admin3name = admin3name.x,           # bir sütunun adını temizle
         admin2name, admin1name,
         cases, total, case_10kpop,
         geometry) %>%                        # geometriyi koru, böylece çokgenler çizilebilir
  drop_na(objectid) %>%                       # drop empty rows
  st_as_sf()                                  # şekil dosyasına çevir

```


Sonuçların haritalanması

```{r, message=F, warning=F}
# tmap modu
tmap_mode("plot")               # statik haritayı görüntüle

# poligonları çiz
tm_shape(case_adm3_sf) + 
        tm_polygons("cases") +  # vaka sayısına göre renk sütunu
        tm_text("admin3name")   # ismi göster
```

İnsidans oranlarını da haritalayabiliriz

```{r, warning=F, message=F}
# 10.000 nüfus başına vakalar
tmap_mode("plot")             # statik görüntüleme modu

# çizim
tm_shape(case_adm3_sf) +                # polygonlqrı çiz
  tm_polygons("case_10kpop",            # vaka oranını içeren sütuna göre renklendir
              breaks=c(0, 10, 50, 100), # renkler için kırılma noktaları tanımlayın
              palette = "Purples"       # mor renk paleti kullanın
              ) +
  tm_text("admin3name")                 # metni göster

```

## ggplot2 ile haritalandırma
**ggplot2** kullanımına zaten aşina iseniz, verilerinizin statik haritalarını oluşturmak için bu paketi kullanabilirsiniz. 'geom_sf()' fonksiyonu, verilerinizdeki hangi özelliklerin (noktalar, çizgiler veya çokgenler) olduğuna bağlı olarak farklı nesneler çizecektir. Örneğin, bir choropleth haritası oluşturmak için çokgen geometrili "sf" verilerini kullanarak bir "ggplot()" içinde "geom_sf()" kullanabilirsiniz.

Bunun nasıl çalıştığını göstermek için daha önce kullandığımız ADM3 çokgen şekil dosyasıyla başlayabiliriz. Bunların Sierra Leone'deki Yönetici Düzey 3 bölgeleri olduğunu hatırlayın:

```{r}
sle_adm3
```

Eşlemek istediğimiz verileri şekil dosyası nesnesine eklemek için **dplyr**'deki `left_join()` fonksiyonunu kullanabiliriz. Bu durumda, daha önce oluşturduğumuz 'case_adm3' veri çerçevesini, idari bölgelere göre vaka sayılarını özetlemek için kullanacağız; ancak, bir veri çerçevesinde depolanan herhangi bir veriyi eşlemek için aynı yaklaşımı kullanabiliriz.

```{r}
sle_adm3_dat <- sle_adm3 %>% 
  inner_join(case_adm3, by = "admin3pcod") # iç birleştirme = yalnızca her iki veri nesnesinde de tutuluyorsa

select(sle_adm3_dat, admin3name.x, cases) # seçili değişkenleri konsola yazdır
```

Bölgeye göre vaka sayımlarının sütun grafiğini yapmak için, **ggplot2** kullanarak, `geom_col()`u şu şekilde çağırabiliriz:

```{r, fig.align = "center"}
ggplot(data=sle_adm3_dat) +
  geom_col(aes(x=fct_reorder(admin3name.x, cases, .desc=T),   # 'vakaları' azaltarak x eksenini yeniden sıralayın
               y=cases)) +                                  # y ekseni bölgeye göre vaka sayısıdır
  theme_bw() +
  labs(                                                     # şekil metnini ayarla
    title="Number of cases, by administrative unit",
    x="Admin level 3",
    y="Number of cases"
  ) + 
  guides(x=guide_axis(angle=45))                            # açı x ekseni etiketleri daha iyi sığdırmak için 45 derecedir

```

Bunun yerine vaka sayımlarının bir choropleth haritası yapmak için **ggplot2** kullanmak istiyorsak, `geom_sf()` fonksiyonunu çağırmak için benzer sözdizimini kullanabiliriz:

```{r, fig.align = "center"}
ggplot(data=sle_adm3_dat) + 
  geom_sf(aes(fill=cases))    # dolguyu vaka sayısı değişkenine göre değiştirecek şekilde ayarla

```

Ardından, **ggplot2** genelinde tutarlı olan dilbilgisini kullanarak haritamızın görünümünü özelleştirebiliriz, örneğin:

```{r, fig.align = "center"}
ggplot(data=sle_adm3_dat) +                           
  geom_sf(aes(fill=cases)) +						
  scale_fill_continuous(high="#54278f", low="#f2f0f7") +    # renk derecesini değiştir
  theme_bw() +
  labs(title = "Number of cases, by administrative unit",   # şekil metnini ayarla
       subtitle = "Admin level 3"
  )
```

**ggplot2** ile rahat çalışan R kullanıcıları için, `geom_sf()`, temel harita görselleştirmeleri için uygun olan basit ve doğrudan bir uygulama sunar. Daha fazla bilgi edinmek için [geom_sf() gösterimi](https://ggplot2.tidyverse.org/reference/ggsf.html) veya [ggplot2 kitabını](https://ggplot2-book.org/maps.html) okuyabilirsiniz.



<!-- ======================================================= -->
## Altlık Haritalar{ }

### OpenStreetMap {.unnumbered}

Aşağıda, OpenStreetMap özelliklerini kullanarak **ggplot2** haritası için bir altlık haritanın nasıl elde edileceğini açıklıyoruz. Alternatif yöntemler arasında, Google'a ücretsiz kayıt gerektiren **ggmap** kullanımı yer almaktadır ([detaylar](https://www.earthdatascience.org/courses/earth-analytics/lidar-raster-data-r/ggmap-basemap/)) .

[**OpenStreetMap**](https://en.wikipedia.org/wiki/OpenStreetMap), ücretsiz düzenlenebilir bir dünya haritası oluşturmaya yönelik ortak bir projedir. Temel coğrafi konum verileri (örneğin şehirlerin konumları, yollar, doğal özellikler, havaalanları, okullar, hastaneler, yollar vb.), projenin birincil çıktısı olarak kabul edilir.

Öncelikle altlık haritamızı alacağımız **OpenStreetMap** paketini yüklüyoruz.

Ardından, **OpenStreetMap** paketinden ([dosyalar](https://www.rdocumentation.org/packages/OpenStreetMap/versions/0.3.4/konular/openmap) 'openmap()' fonksiyonunu kullanarak tanımladığımız 'harita' nesnesini oluşturuyoruz). Aşağıdakileri sağlıyoruz:

* 'upperLeft' ve 'lowRight' altlık harita döşemesinin sınırlarını belirten iki koordinat çifti
  * Bu durumda, satır listesinin satırlarından max ve min'i koyuyoruz, böylece harita verilere dinamik olarak yanıt verecek
* `zoom =` (null ise otomatik olarak belirlenir)
* `type =` hangi tür altlık harita - burada birkaç olasılık listeledik ve kod şu anda ilkini (`[1]`) "osm" kullanıyor
* `mergeTiles =` DOĞRU seçtik, böylece temel döşemeler tek bir yerde birleştirildi.

```{r, message=FALSE, warning=FALSE}
# paketi yükle
pacman::p_load(OpenStreetMap)

# Enlem/boylam koordinat aralığına göre altlık haritayı sığdır. Döşeme türünü seç.
map <- openmap(
  upperLeft = c(max(linelist$lat, na.rm=T), max(linelist$lon, na.rm=T)),   # altlık harita döşemelerinin sınırı
  lowerRight = c(min(linelist$lat, na.rm=T), min(linelist$lon, na.rm=T)),
  zoom = NULL,
  type = c("osm", "stamen-toner", "stamen-terrain", "stamen-watercolor", "esri","esri-topo")[1])
```

Bu altlık haritasını **OpenStreetMap** paketinden `autoplot.OpenStreetMap()` kullanarak şimdi çizersek, eksenlerdeki birimlerin enlem/boylam koordinatları olmadığını görürsünüz. Farklı bir koordinat sistemi kullanıyor. Vaka konutlarını (enlem/boylamda depolanan) doğru bir şekilde görüntülemek için bunun değiştirilmesi gerekir.

```{r, warning=F, message=F}
autoplot.OpenStreetMap(map)
```

Bu nedenle **OpenStreetMap** paketindeki `openproj()` fonksiyonu ile haritayı enlem/boylam şekline dönüştürmek istiyoruz. Altlık harita olarak 'map'i ve ayrıca istediğimiz Koordinat Referans Sistemini (CRS) sağlıyoruz. Bunu, WGS 1984 projeksiyonu için "proj.4" karakter dizisini sağlayarak yapıyoruz, ancak CRS'yi başka şekillerde de sağlayabilirsiniz. (bir proj.4 dizesinin ne olduğunu anlamak için bkz. [bu sayfa](https://www.earthdatascience.org/courses/earth-analytics/spatial-data-r/understand-epsg-wkt-and-other-crs-definition-file-types/)

```{r, warning=F, message=F}
# WGS84 projeksiyonu
map_latlon <- openproj(map, projection = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
```

Şimdi grafiği oluşturduğumuzda eksenler boyunca enlem ve boylam koordinatları olduğunu görüyoruz. Koordinat sistemi dönüştürüldü. Artık vakalarımız üst üste bindirilirse doğru şekilde çizilecek!

```{r, warning=F, message=F}
# Grafik haritası. ggplot ile çalışmak için "autoplot" kullanılmalıdır
autoplot.OpenStreetMap(map_latlon)
```

Daha fazla bilgi için Eğitimlere [buradan](http://data-analytics.net/cep/Schedule_files/geospatial.html) ve [buradan](https://www.rdocumentation.org/packages/OpenStreetMap/versions/0.3.4/) bakın Konular/autoplot.OpenStreetMap) ulaşabilirsiniz.


## Konturlu yoğunluk ısı haritaları {}

Aşağıda, bir satır listesiyle (vaka başına bir satır) başlayarak, bir altlık harita üzerinde vakaların konturlu bir yoğunluk ısı haritasının nasıl elde edileceğini açıklıyoruz.

1) Yukarıda açıklandığı gibi OpenStreetMap'ten altlık harita döşemesi oluşturun
2) Enlem ve boylam sütunlarını kullanarak durumları 'linelist'ten çizin
3) Noktaları **ggplot2**'den `stat_density_2d()` ile bir yoğunluk ısı haritasına dönüştürün,

Enlem/boylam koordinatlarına sahip bir altlık haritamız olduğunda, yerleşim yerlerinin enlem/boylam koordinatlarını kullanarak durumlarımızı en üste çizebiliriz.

Altlık haritayı oluşturmak için "autoplot.OpenStreetMap()" fonksiyonunu temel alan **ggplot2** fonksiyonları, aşağıda "geom_point()" ile gösterildiği gibi, kolayca en üste eklenecektir:

```{r, warning=F, message=F}
# Grafik haritası. ggplot ile çalışmak için "autoplot" kullanılmalıdır
autoplot.OpenStreetMap(map_latlon)+                 # altlık haritası ile başla
  geom_point(                                       # satır listesinin enlem ve boylam sütunlarından xy noktaları ekleyin 
    data = linelist,                                
    aes(x = lon, y = lat),
    size = 1, 
    alpha = 0.5,
    show.legend = FALSE) +                          # göstergeleri tamamen bırak
  labs(x = "Longitude",                             # başlıklar ve etiketler
       y = "Latitude",
       title = "Cumulative cases")

```

Yukarıdaki haritanın yorumlanması zor olabilir, özellikle de noktalar çakışıyorsa. Bunun yerine **ggplot2** `stat_density_2d()` fonksiyonunu kullanarak 2 boyutlu bir yoğunluk haritası çizebilirsiniz. Hala satır listesi enlem/boylam koordinatlarını kullanıyorsunuz, ancak 2B çekirdek yoğunluğu tahmini yapılıyor ve sonuçlar kontur çizgileriyle - bir topografik harita gibi - gösteriliyor. [Belgelerin tamamını buradan okuyabilirsiniz](https://ggplot2.tidyverse.org/reference/geom_density_2d.html)

```{r, warning=F, message=F}
# altlık haritası ile başla
autoplot.OpenStreetMap(map_latlon)+
  
  # yoğunluk grafiğine ekle
  ggplot2::stat_density_2d(
        data = linelist,
        aes(
          x = lon,
          y = lat,
          fill = ..level..,
          alpha = ..level..),
        bins = 10,
        geom = "polygon",
        contour_var = "count",
        show.legend = F) +                          
  
  # renk dağılımını belirle
  scale_fill_gradient(low = "black", high = "red")+
  
  # etiketler 
  labs(x = "Longitude",
       y = "Latitude",
       title = "Distribution of cumulative cases")

```



<!-- ======================================================= -->
### Zaman serisi ısı haritası {.unnumbered}

Yukarıdaki yoğunluk ısı haritası *kümülatif durumları* gösterir. Satır listesinden türetilen *semptom başlangıç ayına* dayalı olarak ısı haritasını şekillendirerek salgını zaman ve mekan içinde inceleyebiliriz.

Başlangıç Yılı ve Ayı ile yeni bir sütun oluşturarak "satır listesi" ile başlıyoruz. R **tabanı**ndaki 'format()' fonksiyonu, bir tarihin görüntülenme şeklini değiştirir. Bu durumda "YYYY-AA" istiyoruz.

```{r, warning=F, message=F}
# başlangıç ayını dışa aktar
linelist <- linelist %>% 
  mutate(date_onset_ym = format(date_onset, "%Y-%m"))

# Değerleri inceleyin
table(linelist$date_onset_ym, useNA = "always")
```

Şimdi, yoğunluk ısı haritasına **ggplot2** aracılığıyla yüzey oluşturmayı tanıtıyoruz. Yeni sütun satır olarak kullanılarak `facet_wrap()` uygulanır. Anlaşılır olması için yüzey sütunlarının sayısını 3 olarak ayarladık.

```{r, warning=F, message=F}
# paketler
pacman::p_load(OpenStreetMap, tidyverse)

# altlık haritası ile başlayın
autoplot.OpenStreetMap(map_latlon)+
  
  # yoğunluk grafiği ekleyin
  ggplot2::stat_density_2d(
        data = linelist,
        aes(
          x = lon,
          y = lat,
          fill = ..level..,
          alpha = ..level..),
        bins = 10,
        geom = "polygon",
        contour_var = "count",
        show.legend = F) +                          
  
  # renk dağılımını belirle
  scale_fill_gradient(low = "black", high = "red")+
  
  # etiketler 
  labs(x = "Longitude",
       y = "Latitude",
       title = "Distribution of cumulative cases over time")+
  
  # grafiği başlangıç ayı-yılına göre şekillendirin
  facet_wrap(~ date_onset_ym, ncol = 4)               

```

<!-- MEKANSAL İSTATİSTİK BÖLÜMÜ GELİŞTİRİLİYORmuş :)-->
## Mekansal istatistikler
Şimdiye kadarki tartışmalarımızın çoğu, mekansal verilerin görselleştirilmesine odaklandı. Bazı durumlarda, verilerinizdeki özniteliklerin uzamsal ilişkilerini ölçmek için *mekansal istatistikler* kullanmak da ilginizi çekebilir. Bu bölüm uzamsal istatistikteki bazı temel kavramlara çok kısa bir genel bakış sunacak ve daha kapsamlı uzamsal analizler yapmak istiyorsanız keşfetmenize yardımcı olacak bazı kaynaklar önerecektir.

### Mekansal ilişkiler {.unnumbered}

Herhangi bir uzamsal istatistiği hesaplamadan önce, verilerimizdeki özellikler arasındaki ilişkileri belirlememiz gerekir. Mekansal ilişkileri kavramsallaştırmanın birçok yolu vardır, ancak kullanımı basit ve yaygın olarak uygulanabilir bir model *bitişiklik* modelidir. Bu modelde, bir sınırı veya “komşuluğu” paylaşan alanlar arasında coğrafi bir ilişki beklemekteyiz.

**spdep** paketi ile kullandığımız `sle_adm3` datasında yönetim bölgesi poligonları arasındaki komşuluk ilişkilerini ölçebiliyoruz. *vezir* bitişikliğini belirleyeceğiz, bu, bölgelerin sınırları boyunca en az bir noktayı paylaştıkları takdirde komşu olacağı anlamına gelmektedir. Alternatif olarak, bölgelerin bir kenarı paylaşmasını gerektiren *kale* bitişikliği olacaktır - bizim durumumuzda, düzensiz çokgenlerle, ayrım önemsizdir, ancak bazı durumlarda vezir ve kale arasındaki seçim etkili olabilir.

```{r}
sle_nb <- spdep::poly2nb(sle_adm3_dat, queen=T) # komşuluklar yaratın 
sle_adjmat <- spdep::nb2mat(sle_nb)    # komşu ilişkilerini özetleyen matris oluşturun
sle_listw <- spdep::nb2listw(sle_nb)   # listw (ağırlık listesi) nesnesi oluştur -- buna daha sonra ihtiyacımız olacak

sle_nb
round(sle_adjmat, digits = 2)
```

Yukarıda yazdırılan matris, 'sle_adm3' verilerimizdeki 9 bölge arasındaki ilişkileri göstermektedir. 0 puan, iki bölgenin komşu olmadığını gösterirken, 0 dışında herhangi bir değer, bir komşu ilişkisini gösterir. Matristeki değerler, her bölgenin toplam satır ağırlığı 1 olacak şekilde ölçeklendirilir.

Bu komşu ilişkileri görselleştirmenin daha iyi bir yolu, onları çizmektir:
```{r, fig.align='center', results='hide'}
plot(sle_adm3_dat$geometry) +                                           # alan sınırlarını grafikleştir
  spdep::plot.nb(sle_nb,as(sle_adm3_dat, 'Spatial'), col='grey', add=T) # komşuluk ilişkileri ekle
```

Komşu çokgenleri tanımlamak için bir bitişiklik yaklaşımı kullandık; tanımladığımız komşulara bazen **bitişiklik tabanlı komşular** da denir. Ancak bu, coğrafi bir ilişkiye sahip olması beklenen bölgeleri seçmenin sadece bir yoludur. Coğrafi ilişkileri belirlemeye yönelik en yaygın alternatif yaklaşımı **mesafeye dayalı komşular** oluşturur; kısaca bunlar:
  
  * **K-en yakın komşular** - Merkezler (her çokgen bölgesinin coğrafi ağırlıklı merkezi) arasındaki mesafeye bağlı olarak, komşu olarak *n* en yakın bölgeleri seçin. Bir maksimum mesafe yakınlık eşiği de belirtilebilir. **spdep**'te "knearneigh()" kullanabilirsiniz (bkz. [belgeler](https://r-spatial.github.io/spdep/reference/knearneigh.html)).
  
  * **Mesafe eşiği komşuları** - Bir mesafe eşiği içindeki tüm komşuları seçin. **spdep**'te, bu komşu ilişkiler "dnearneigh()" kullanılarak tanımlanabilir (bkz. [belgeler](https://www.rdocumentation.org/packages/spdep/versions/1.1-7/topics/dnearneigh)) .

### Mekansal otokorelasyon {.unnumbered}

Tobler'in sık sık alıntılanan birinci coğrafya yasası, "her şey diğer her şeyle ilişkilidir, ancak yakın şeyler uzaktaki şeylerden daha fazla ilişkilidir" der. Epidemiyolojide bu genellikle, belirli bir bölgedeki belirli bir sağlık sonucu riskinin, uzaktaki bölgelere kıyasla komşu bölgelere daha benzer olduğu anlamına gelir. Bu kavram, **uzaysal otokorelasyon** olarak resmileştirilmiştir. Benzer değerlere sahip coğrafi özelliklerin uzayda bir araya toplandığı istatistiksel özellik olarak tanımlanır. Uzamsal otokorelasyonun istatistiksel ölçüleri, verilerinizdeki *mekansal kümelemenin kapsamını* ölçmek, *kümelemenin nerede gerçekleştiğini* belirlemek ve verilerinizdeki farklı değişkenler arasındaki *paylaşılan uzamsal otokorelasyon modellerini belirlemek* için kullanılabilir. Bu bölüm, bazı yaygın uzamsal otokorelasyon ölçülerine ve bunların R'da nasıl hesaplanacağına genel bir bakış sunar.

**Moran'ın İ İstatistiği** - Bu, bir bölgedeki bir değişkenin değeri ile komşu bölgelerdeki aynı değişkenin değerleri arasındaki korelasyonun genel bir özet istatistiğidir. Moran'ın I istatistiği tipik olarak -1 ile 1 arasındadır. 0 değeri uzamsal korelasyon modeli olmadığını gösterirken 1 veya -1'e yakın değerler sırasıyla daha güçlü uzamsal otokorelasyonu (benzer değerler birbirine yakındır) veya uzamsal dağılımı (benzersiz değerler birbirine yakındır) gösterir.

Örnek olarak, daha önce haritalandırdığımız Ebola vakalarındaki uzamsal otokorelasyonu ölçmek için Moran'ın İ istatistiğini hesaplayacağız (unutmayın, bu simüle edilmiş salgın "satır listesi" veri çerçevesinden vakaların bir alt kümesidir). **spdep** paketinde bu hesaplamayı bizim için yapabilen "moran.test" fonskiyonu vardır:

```{r}
moran_i <-spdep::moran.test(sle_adm3_dat$cases,    # ilgilenilen değişken içim sayısal vektör
                            listw=sle_listw)       # komşu ilişkilerini özetleyen listw nesnesi

moran_i                                            # yazdırma sonuçları
```

'moran.test()' fonksiyonunun çıktısı bize 'round(moran_i$estimate[1],2)' Moran I istatistiğini gösterir. Bu, verilerimizde uzamsal otokorelasyonun varlığını gösterir - özellikle, benzer sayıda Ebola vakası olan bölgelerin birbirine yakın olması muhtemeldir. "moran.test()" tarafından sağlanan p değeri, uzaysal otokorelasyonun olmadığı sıfır hipotezi altındaki beklentiyle karşılaştırılarak oluşturulur ve resmi bir hipotez testinin sonuçlarını bildirmeniz gerekiyorsa kullanılabilir.

**Yerel Moran I** - *yerelleştirilmiş* uzamsal otokorelasyonu tanımlamak için yukarıda hesaplanan (küresel) Moran I istatistiğini ayrıştırabiliriz; bu durum verilerimizdeki belirli kümeleri tanımlamamızı sağlar. Bazen **Yerel Mekansal İlişki Göstergesi (LISA)** istatistiği olarak adlandırılan bu istatistik, her bir bölge etrafındaki mekansal otokorelasyonun kapsamını özetler. Haritada "sıcak" ve "soğuk" noktaları bulmak için faydalı olabilir.

Bir örnek göstermek için, yukarıda kullanılan Ebola vaka sayıları için Yerel Moran'ın I istatistiğini **spdep**'ten `local_moran()` fonksiyonuyla hesaplayabilir ve eşleyebiliriz:
```{r, fig.align='center'}
# yereli hesapla
local_moran <- spdep::localmoran(                  
  sle_adm3_dat$cases,                              # ilgi değişkeni
  listw=sle_listw                                  # komşu ağırlıkları ile listw nesnesi
)

# sf verilerine sonuçları birleştirme
sle_adm3_dat<- cbind(sle_adm3_dat, local_moran)    

# harita grafiği
ggplot(data=sle_adm3_dat) +
  geom_sf(aes(fill=Ii)) +
  theme_bw() +
  scale_fill_gradient2(low="#2c7bb6", mid="#ffffbf", high="#d7191c",
                       name="Local Moran's I") +
  labs(title="Local Moran's I statistic for Ebola cases",
       subtitle="Admin level 3 regions, Sierra Leone")

```

**Getis-Ord Gi\** - Bu, etkin nokta analizi için yaygın olarak kullanılan başka bir istatistiktir. Bu istatistiğin popülaritesi büyük ölçüde ArcGIS'teki Sıcak Nokta Analizi aracındaki kullanımıyla ilgilidir. Tipik olarak, komşu bölgeler arasındaki bir değişkenin değerindeki farkın normal bir dağılım izlemesi gerektiği varsayımına dayanır. Komşularına kıyasla, belirli bir değişkenin önemli ölçüde daha yüksek (sıcak nokta) veya önemli ölçüde daha düşük (soğuk nokta) değerlerine sahip bölgeleri belirlemek için bir z-skoru yaklaşımı kullanır.

**spdep**'teki `localG()` fonksiyonunu kullanarak *Gi* istatistiğini hesaplayabilir ve eşleyebiliriz:

```{r}
# Yerel G analizi gerçekleştir
getis_ord <- spdep::localG(
  sle_adm3_dat$cases,
  sle_listw
)

# sf verisine sonuçları ekleme
sle_adm3_dat$getis_ord <- as.numeric(getis_ord)

# harita grafiği
ggplot(data=sle_adm3_dat) +
  geom_sf(aes(fill=getis_ord)) +
  theme_bw() +
  scale_fill_gradient2(low="#2c7bb6", mid="#ffffbf", high="#d7191c",
                       name="Gi*") +
  labs(title="Getis-Ord Gi* statistic for Ebola cases",
       subtitle="Admin level 3 regions, Sierra Leone")

```

Gördüğünüz gibi *Getis-Ord Gi* haritası daha önce hazırladığımız Yerel Moran'ın İ haritasından biraz farklı görünüyor. Bu, iki istatistiği hesaplamak için kullanılan yöntemin biraz farklı olduğunu yansıtır; hangisini kullanmanız gerektiği, özel kullanım durumunuza ve ilgilendiğiniz araştırma sorusuna bağlıdır.

**Lee's L testi** - İki değişkenli uzamsal korelasyon için istatistiksel bir testtir. Belirli bir *x* değişkeni için uzamsal kalıbın, uzamsal olarak *x* ile ilişkili olduğu varsayılan başka bir değişken olan *y*'nin uzamsal kalıbına benzer olup olmadığını test etmenizi sağlar.

Bir örnek vermek gerekirse, simüle edilmiş salgındaki Ebola vakalarının mekansal düzeninin, nüfusun mekansal düzeniyle ilişkili olup olmadığını test edelim. Başlamak için, 'sle_adm3' verilerimizde bir 'population' değişkenine ihtiyacımız var. Daha önce yüklediğimiz 'sle_adm3_pop' veri çerçevesinden 'total' değişkenini kullanabiliriz.

```{r}
sle_adm3_dat <- sle_adm3_dat %>% 
  rename(population = total)                          # toplamı nüfus olarak yeniden adlandır
```

Benzer görünüp görünmediklerini görmek için iki değişkenin uzamsal modellerini yan yana hızlı bir şekilde görselleştirebiliriz:
```{r, fig.align='center', warning=F, message=F}
tmap_mode("plot")

cases_map <- tm_shape(sle_adm3_dat) + tm_polygons("cases") + tm_layout(main.title="Cases")
pop_map <- tm_shape(sle_adm3_dat) + tm_polygons("population") + tm_layout(main.title="Population")

tmap_arrange(cases_map, pop_map, ncol=2)   # 2x1 yönlerine göre düzenleyin
```

Görsel olarak, desenler farklı görünüyor. İki değişkendeki uzamsal otokorelasyon modelinin ilişkili olup olmadığını istatistiksel olarak test etmek için **spdep** içindeki `lee.test()` fonksiyonunu kullanabiliriz. Modeller arasında korelasyon yoksa L istatistiği 0'a yakın, güçlü bir pozitif korelasyon varsa 1'e yakın (yani modeller benzer) ve güçlü bir negatif korelasyon varsa -1'e yakındır (örn. desenler terstir).

```{r, warning=F, message=F}
lee_test <- spdep::lee.test(
  x=sle_adm3_dat$cases,          # karşılaştırılacak değişken 1
  y=sle_adm3_dat$population,     # karşılaştırılacak değişken 2
  listw=sle_listw                # komşu ağırlıkları ile listw nesnesi
)

lee_test
```

Yukarıdaki çıktı, iki değişkenimiz için Lee'nin L istatistiğinin, zayıf negatif korelasyonu gösteren `round(lee_test$estimate[1],2)' olduğunu göstermektedir. Vaka ve nüfus düzeninin birbiriyle ilişkili olmadığına dair görsel değerlendirmemizi doğrular ve vakaların mekânsal düzeninin kesinlikle yüksek riskli bölgelerdeki nüfus yoğunluğunun bir sonucu olmadığına dair kanıt sağlar.

Lee L istatistiği, uzamsal olarak dağılmış değişkenler arasındaki ilişki hakkında bu tür çıkarımlar yapmak için faydalı olabilir; ancak, iki değişken arasındaki ilişkinin doğasını daha ayrıntılı olarak tanımlamak veya kafa karıştırıcı duruma göre ayarlamak için *uzaysal regresyon* tekniklerine ihtiyaç duyulacaktır. Bunlar aşağıdaki bölümde kısaca açıklanmıştır.

### Mekansal regresyon {.unnumbered}

Uzamsal verilerinizdeki değişkenler arasındaki ilişkiler hakkında istatistiksel çıkarımlar yapmak isteyebilirsiniz. Bu durumlarda, *uzaysal regresyon* tekniklerini, yani verilerinizdeki birimlerin uzamsal organizasyonunu açıkça dikkate alan regresyon yaklaşımlarını anlamak yararlıdır. Genel Lineer Modeller (GLM) gibi standart regresyon modelleri yerine uzamsal regresyon modellerini dikkate almanız gerekebilecek bazı nedenler şunlardır:

  * Standart regresyon modelleri, artıkların birbirinden bağımsız olduğunu varsayar. Güçlü bir *uzaysal otokorelasyon* varlığında, standart bir regresyon modelinin artıklarının da uzaysal olarak otokorelasyona sahip olması muhtemeldir, dolayısıyla bu varsayımı ihlal eder. Bu, model sonuçlarının yorumlanmasında sorunlara yol açabilir, bu durumda uzamsal bir model tercih edilir.
  
  * Regresyon modelleri ayrıca tipik olarak *x* değişkeninin etkisinin tüm gözlemlerde sabit olduğunu varsayar. *Mekansal heterojenlik* durumunda, tahmin etmek istediğimiz etkiler uzaya göre değişebilir ve bu farklılıkları ölçmekle ilgilenebiliriz. Bu durumda, uzamsal regresyon modelleri, etkileri tahmin etmek ve yorumlamak için daha fazla esneklik sunar.
  
Mekansal regresyon yaklaşımlarının ayrıntıları bu el kitabının kapsamı dışındadır. Bu bölüm bunun yerine en yaygın uzamsal regresyon modellerine ve kullanımlarına genel bir bakış sunacak ve bu alanı daha fazla araştırmak isterseniz kullanılabilecek referanslara yönlendirecektir.

**Uzamsal hata modelleri** - Bu modeller, uzamsal birimler arasındaki hata terimlerinin ilişkili olduğunu varsayar; bu durumda veriler, standart bir "Ordinary Least Squares (OLS)" modelinin varsayımlarını ihlal eder. Uzamsal hata modellerine bazen **eşzamanlı otoregresif (SAR) modeller** de denir. **spatialreg** paketindeki 'errorsarlm()' fonksiyonu kullanılarak sığdırılabilirler (eskiden **spdep**'in bir parçası olan uzamsal regresyon fonksiyonları).

**Uzamsal gecikme modelleri** - Bu modeller, *i* bölgesi için bağımlı değişkenin yalnızca *i* içindeki bağımsız değişkenlerin değerinden değil, aynı zamanda *i*'ye komşu bölgelerdeki bu değişkenlerin değerlerinden de etkilendiğini varsayar. Uzamsal hata modelleri gibi, uzaysal gecikme modelleri de bazen **eşzamanlı otoregresif (SAR) modeller** olarak tanımlanır. **spatialreg** paketindeki `lagsarlm()` fonskiyonu kullanılarak sığdırılabilirler.

**spdep** paketi, standart OLS, uzamsal gecikme ve uzamsal hata modelleri arasında karar vermek için birkaç faydalı tanı testi içerir. *Lagrange Çarpanı teşhisleri* olarak adlandırılan bu testler, verilerinizdeki uzamsal bağımlılığın türünü belirlemek ve hangi modelin en uygun olduğunu seçmek için kullanılabilir. `lm.LMtests()` fonksiyonu, tüm Lagrange Çarpan testlerini hesaplamak için kullanılabilir. Anselin (1988) ayrıca Lagrange Çarpan testlerinin sonuçlarına dayanarak hangi uzaysal regresyon modelinin kullanılacağına karar vermek için kullanışlı bir akış şeması aracı sağlar:

```{r, fig.align='center', echo=F}
knitr::include_graphics(here::here("images", "gis_lmflowchart.jpg"))
```

**Bayesin hiyerarşik modelleri** - Bayes yaklaşımları, uzaysal analizdeki bazı uygulamalar için yaygın olarak kullanılır, en yaygın olarak [hastalık haritalama](https://pubmed.ncbi.nlm.nih.gov/15690999/). Vaka verilerinin seyrek olarak dağıtıldığı (örneğin, nadir bir sonuç durumunda) veya istatistiksel olarak "gürültülü" olduğu durumlarda tercih edilirler, çünkü altta yatan gizli mekansal verileri hesaba katarak hastalık riskinin "düzeltilmiş" tahminlerini oluşturmak için kullanılabilirler. Bu, tahminlerin kalitesini artırabilir. Bunlar ayrıca, hem bağımsız hem de bağımlı değişkenlerde uzamsal olarak bağımlı ve bağımsız varyasyonu açıklayabilen, verilerde bulunabilen karmaşık uzamsal korelasyon modellerinin araştırmacı tarafından önceden belirlenmesine (önceki seçim yoluyla) izin verir. R'da, Bayesin hiyerarşik modelleri **CARbayes** paketi kullanılarak sığdırılabilir (bkz. [gösterim](https://cran.r-project.org/web/packages/CARBayes/vignettes/CARBayes.pdf)) veya R -INLA (bkz. [web sitesi](https://www.r-inla.org/home) ve [ders kitabı](https://becarioprecario.bitbucket.io/inla-gitbook/)). R ayrıca JAGS veya WinBUGS gibi Bayes tahmini yapan harici yazılımları çağırmak için de kullanılabilir.

<!--Konu çok teknikti çevirirken çoğu yeri anlamadım. Sonraki çevirilerde alanın uzmanı birisi bir göz atsa faydası olur. ============================================= ========= -->
## Kaynaklar {  }

* R'ın Basit Özellikleri ve sf paketi [gösterim](https://cran.r-project.org/web/packages/sf/vignettes/sf1.html)


* R tmap paketi [gösterim](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html)


* ggmap: [ggplot2 ile Mekansal Görselleştirme](https://journal.r-project.org/archive/2013-1/kahle-wickham.pdf)


* [R ile harita oluşturmaya giriş, farklı paketlere genel bakış](https://bookdown.org/nicohahn/making_maps_with_r5/docs/introduction.html)

* R'da Mekansal Veriler [(EarthLab kursu)](https://www.earthdatascience.org/courses/earth-analytics/spatial-data-r/)

* R'da Uygulamalı Uzamsal Veri Analizi [ders kitabı](https://link.springer.com/book/10.1007/978-1-4614-7618-4)

* **SpatialEpiApp** - [R paketi olarak indirilebilen bir Shiny uygulaması](https://github.com/Paula-Moraga/SpatialEpiApp), kendi verilerinizi sağlamanıza ve haritalama, küme analizi ve mekansal istatistikleri sağlar.


* R'da Mekansal Ekonometriye Giriş [atölye](http://www.econ.uiuc.edu/~lab/workshop/Spatial_in_R.html)
