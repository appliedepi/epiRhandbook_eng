
# Таблица данных { }  
     
Данное руководство фокусируется на "глагольных" функциях **dplyr** и операторе канала из пакета **magrittr** `%>%` как методах вычистки и группирования данных, но пакет**data.table** предлагает альтернативный метод, с которым вы можете столкнуться в ходе своей работы с R.  



<!-- ======================================================= -->
## Введение в таблицы данных {  }

Таблица данных - это двумерная структура данных, подобная датафрейму, позволяющая выполнять сложные операции группирования. Синтаксис data.table построен таким образом, что операции могут выполняться для строк, столбцов и групп. 

Структура - **DT[i, j, by]**, разделенная на 3 части; аргументы **i, j** и **by**. Аргумент **i** позволяет взять подмножество требуемых строк, аргумент **j** позволяет работать со столбцами, а аргумент **by** позволяет работать со столбцами по группам.
  
На этой странице мы рассмотрим следующие темы:  

* Импорт данных и использование `fread()` и `fwrite()`
* Выбор и фильтрация строк, используя аргумент **i**
* Использование функций-помощников `%like%`, `%chin%`, `%between%` 
* Выбор и расчет по столбцам, используя аргумент **j**
* Расчет по группам, используя аргумент **by**
* Добавление и обновление данных в таблицах данных с помощью `:=`

<!-- ======================================================= -->
## Загрузка пакетов и импорт данных { }

### Загрузка пакетов {.unnumbered}  

Используя функцию `p_load()` из **pacman**, мы загружаем (и устанавливаем при необходимости) пакеты, требуемые для данного анализа.
     
     
```{r}
pacman::p_load(
  rio,        # импорт данных
  data.table, # группирование и вычистка данных
  tidyverse,  # позволяет использовать функцию оператора канала (%>%) в этой главе
  here 
  ) 
```


### Импорт данных {.unnumbered}

На данной странице мы рассмотрим некоторые ключевые функции **data.table**, используя построчный список, на который мы ссылались в других главах этого руководства.

Мы импортируем набор данных о случаях из смоделированной эпидемии лихорадки Эбола. Если вы хотите загрузить данные, чтобы выполнять действия параллельно, см. инструкции в разделе [Скачивание руководства и данных](data_used.ru.qmd). Набор данных импортируется с помощью функции `import()` из пакета **rio**. См. страницу [Импорт и экспорт](importing.ru.qmd), где приведены разные способы импорта данных. С этого момента мы будем использовать `data.table()`, чтобы конвертировать датафрейм в таблицу данных.

```{r}
linelist <- rio::import(here("data", "linelist_cleaned.xlsx")) %>% data.table()
```

Функция `fread()` используется напрямую для импорта обычных файлов с разделителями, таких как файлы .csv, напрямую в формат таблицы данных. Эта функция и ее парная функция, `fwrite()`, используемая для записи таблиц данных в виде обычных файлов с разделителями, являются очень быстрыми и вычислительно эффективными вариантами для больших баз данных.


Первыу 20 строк `linelist`:  

```{r message=FALSE, echo=F, eval=FALSE}
DT::datatable(head(linelist,20), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Команды базового R, такие как `dim()`, которые используются для датафреймов, могут также использоваться для таблиц данных

```{r}
dim(linelist) #дает количество строк и столбцов в таблице данных
```


<!-- ======================================================= -->
## Аргумент i: выбор и фильтрация строк{ }
     
Вспоминая структуру **DT[i, j, by]**, мы можем фильтровать строки, используя либо номера строк, либо логические выражения. Аргумент i является первым, поэтому можно использовать синтаксис **DT[i]** или **DT[i,]**. 

В первом примере извлекаются первые 5 строк таблицы данных, во втором примере подмножество случаев 18 лет и старше, в третьем примере подмножество случаев 18 лет и старше, но не диагностированных в Central Hospital:


```{r, eval=F}
linelist[1:5] #выдает с 1й по 5ю строки
linelist[age >= 18] #подмножество случаев, равных или старше 18 лет
linelist[age >= 18 & hospital != "Central Hospital"] #подмножество случаев, равных или старше 18 лет, но не диагностированных в Central Hospital

```

Использование .N в аргументе i означает общее количество строк в таблице данных. Это может быть использовано для подмножества по номерам строк: 

```{r, eval=F}
linelist[.N] #выдает последнюю строку
linelist[15:.N] #выдает с 15й по последнюю строки
```


### Использование функций-помощников для фильтра {.unnumbered}  

В таблице данных используются вспомогательные функции, которые упрощают выделение подмножества строк. Функция `%like%` испольузется, чтобы сопоставить набор символов в столбце, `%chin%` используется для сопоставления по конкретному знаку, а функция-помощник `%between%` используется, чтобы сопоставить числовые столбцы с заранее указанным диапазоном.

В следующем примере мы:
*  фильтруем строки, где в переменной больницы есть “Hospital”
*  фильтруем строки, где исход “Recover” (выздоровел) или “Death” (смерть)
*  фильтруем строки в возрастном диапазоне 40-60

```{r, eval=F}
linelist[hospital %like% "Hospital"] #фильтруем строки, где в переменной больницы есть “Hospital”
linelist[outcome %chin% c("Recover", "Death")] #фильтруем строки, где исход “Recover” (выздоровел) или “Death” (смерть)
linelist[age %between% c(40, 60)] #фильтруем строки в возрастном диапазоне 40-60

#%between% должен принять вектор длины 2, а %chin% может принять векторы длины >= 1

```

## Аргумент j: выбор и расчет по столбцам{ }

Используя структуру **DT[i, j, by]**, мы можем выбирать столбцы с помощью чисел или имен. Аргумент **j** является вторым, поэтому используется синтаксис **DT[, j]**. Для облегчения вычислений над аргументом **j** столбец оборачивается с помощью либо `list()`, либо `.()`. 


### Выбор столбцов {.unnumbered} 

Первый пример извлекает первый, третий и пятый столбцы таблицы данных, второй пример выбирает все столбцы, кроме столбцов рост, вес и пол. В третьем примере используется обертка `.()`, чтобы выбрать столбцы **case_id** и **outcome**.


```{r, eval=F}
linelist[ , c(1,3,5)]
linelist[ , -c("gender", "age", "wt_kg", "ht_cm")]
linelist[ , list(case_id, outcome)] #linelist[ , .(case_id, outcome)] работает столь же хорошо

```

### Расчет по столбцам {.unnumbered} 

Комбинируя аргументы **i** и **j**, можно фильтровать строки и вычислять по столбцам. Использование **.N** в аргументе **j** также представляет общее количество строк в таблице данных и может быть полезно для возврата количества строк после фильтрации строк.

В следующем примере мы:
* Считаем количества случаев пребывания в стационаре более 7 дней
* Считаем средний возраст больных, умерших в military hospital
* Считаем стандартное отклонение, медиану, средний возраст пациентов, выздоровевших в central hospital

```{r}
linelist[days_onset_hosp > 7 , .N]
linelist[hospital %like% "Military" & outcome %chin% "Death", .(mean(age, na.rm = T))] #na.rm = T удаляет значения N/A
linelist[hospital == "Central Hospital" & outcome == "Recover", 
                 .(mean_age = mean(age, na.rm = T),
                   median_age = median(age, na.rm = T),
                   sd_age = sd(age, na.rm = T))] #Этот синтаксис не использует функции-помощники, но работает так же хорошо

```

Помните, что использование обертки .() в аргументе j упрощает расчет, выдает таблицу данных и позволяет именовать столбцы.

## Аргумент by: расчет по группам{ }

Аргумент **by** - третий аргумент в структуре **DT[i, j, by]**. Аргумент **by** принимает и синтаксис текстового вектора, и `list()` или `.()`. Использование синтаксиса `.()` в аргументе **by** позволяет на ходу переименовывать столбцы.

В следующем примере мы:	
* группируем количество случаев по больнице
* в случаях 18 лет и старше, рассчитываем средний рост и вес случаев по полу и в зависимости от того, они выздоровели или умерли
* в случаях госпитализации, продолжавшейся более 7 дней, подсчитывается количество случаев в зависимости от месяца госпитализации и больницы, в которую они были госпитализированы


```{r}
linelist[, .N, .(hospital)] #количество случаев по больнице
linelist[age > 18, .(mean_wt = mean(wt_kg, na.rm = T),
                             mean_ht = mean(ht_cm, na.rm = T)), .(gender, outcome)] #NA представляют категории, где данные отсутствуют
linelist[days_onset_hosp > 7, .N, .(month = month(date_hospitalisation), hospital)]

```

Data.table также позволяет связывать выражения в цепочку следующим образом:

```{r}

linelist[, .N, .(hospital)][order(-N)][1:3] #1-я выбирает все случаи по больницам, 2-я упорядочивает случаи в порядке убывания, 3-я выделяет 3 больницы с наибольшим количеством случаев


```

В этих примерах мы исходим из того, что строка в таблице данных равна новому случаю, поэтому для представления количества строк в таблице данных можно использовать **.N**. Другой полезной функцией для представления количества уникальных случаев является `uniqueN()`, которая выдает количество уникальных значений при заданных входных данных. Это показано ниже:

```{r}

linelist[, .(uniqueN(gender))] #помните .() в аргументе j выдаст таблицу данных

```

Ответом будет 3, так как уникальные значения в столбце пол - это m, f и N/A. Сравните с функцией базового R `unique()`, которая выдает все уникальные значения в заданных входных данных:

```{r}

linelist[, .(unique(gender))]
```

Чтобы найти количество уникальных случаев в заданном месяце, мы напишем следующее:

```{r}

linelist[, .(uniqueN(case_id)), .(month = month(date_hospitalisation))]

```

## Добавление и обновление таблиц данных { }

Оператор `:=` используется, чтобы добавить или обновить данные в таблице данных. Добавление столбцов в вашу таблицу данных можно сделать следующим образом:

```{r}

linelist[, adult := age >= 18] #добавляет один столбец
linelist[, c("child", "wt_lbs") := .(age < 18, wt_kg*2.204)] #для добавления нескольких столбцов требуется синтаксис c("") и list() или .()
linelist[, `:=` (bmi_in_range = (bmi > 16 & bmi < 40),
                         no_infector_source_data = is.na(infector) | is.na(source))] #этот метод использует := в качестве функционального оператора `:=`
linelist[, adult := NULL] #удаляет столбец

```


Дальнейшие сложные агрегации выходят за рамки этой вводной главы, но идея состоит в том, чтобы предоставить популярную и жизнеспособную альтернативу **dplyr** для группирования и вычистки данных. Пакет **data.table** является замечательным пакетом, который позволяет использовать удобный и читаемый код.


## Ресурсы {  }

Вот некоторые полезные ресурсы для информации:
* https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html
* https://github.com/Rdatatable/data.table
* https://s3.amazonaws.com/assets.datacamp.com/img/blog/data+table+cheat+sheet.pdf
* https://www.machinelearningplus.com/data-manipulation/datatable-in-r-complete-guide/
* https://www.datacamp.com/community/tutorials/data-table-r-tutorial

Вы можете выполнить любую резюмирующую функцию для группированных данных; см. шпаргалку для получения дополнительной информации:
https://s3.amazonaws.com/assets.datacamp.com/blog_assets/datatable_Cheat_Sheet_R.pdf




