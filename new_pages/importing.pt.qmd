# Importar e exportar {#importing}


```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Import_Export_1500x500.png"))
```



Nesta página descrevemos formas de localizar, importar e exportar arquivos:  

* Utilização do pacote **rio** para flexivelmente `import()` e `export()` muitos tipos de arquivos  
* Uso do pacote **here** para localizar arquivos relativos a uma raiz de projeto R - para evitar complicações de caminhos de arquivos que são específicos de um computador  
* Cenários específicos de importação, como por exemplo:  
  * Planilhas específicas do Excel  
  * Cabeçalhos confusos e linhas para pular  
  * Planilhas do Google  
  * A partir de dados postados em websites  
  * Com APIs  
  * Importação do arquivo *mais recente*  
* Entrada manual de dados  
* Tipos de arquivos específicos de R, como RDS e RData  
* Exportar / salvar arquivos e gráficos

```{r, include=FALSE}
pacman::p_load(
  rio,            # import/export
  here,           # file pathways
  tidyverse)      # data management, summary, and visualization
```


<!-- ======================================================= -->
## Visão geral

Quando você importa um "conjunto de dados" para o R, você geralmente está criando um novo objeto do tipo *data frame* em seu ambiente R e definindo-o como um arquivo importado (por exemplo, Excel, CSV, TSV, RDS) que está localizado em suas pastas em um determinado caminho/endereço de arquivo.  

Você pode importar/exportar muitos tipos de arquivos, inclusive aqueles criados por outros programas estatísticos (SAS, STATA, SPSS). Você também pode se conectar a bancos de dados relacionais.  

R tem até seus próprios formatos de dados:  

* Um arquivo RDS (.rds) armazena um único objeto R, como um data frame. Estes são úteis para armazenar dados limpos, pois eles mantêm as classes de colunas R. Leia mais em [esta seção](#import_rds).    
* Um arquivo RData (.Rdata) pode ser usado para armazenar vários objetos, ou mesmo um espaço de trabalho R completo. Leia mais em [esta seção](#import_rdata).  

<!-- ======================================================= -->
## O pacote **rio** {}  

O pacote R que recomendamos é: **rio**. O nome "rio" é uma abreviação de "R I/O" (input/output ).

Suas funções `import()` e `export()` podem lidar com muitos tipos diferentes de arquivos (por exemplo, .xlsx, .csv, .rds, .tsv). Quando você fornece um caminho de arquivo para qualquer uma destas funções (incluindo a extensão do arquivo como ".csv"), **rio** lerá a extensão e utilizará a ferramenta correta para importar ou exportar o arquivo.  

A alternativa ao uso do **rio** é usar funções de muitos outros pacotes, cada um dos quais é específico para um tipo de arquivo. Por exemplo, `read.csv()` (R **base** ), `read.xlsx()` (**openxlsx** pacote), e `write_csv()` (**readr** pacakge), etc. Estas alternativas podem ser difíceis de lembrar, enquanto que utilizar `import()` e `export()` de **rio*** é fácil.  

As funções do **rio** `import()` e `export()` utilizam o pacote e função apropriados para um determinado arquivo, com base em sua extensão. Veja no final desta página uma tabela completa de quais pacotes/funções **rio** utilizam em segundo plano. Ele também pode ser utilizado para importar arquivos STATA, SAS e SPSS, entre dezenas de outros tipos de arquivos.  

A importação/exportação de *shapefiles* (para mapas) requer outros pacotes, conforme detalhado na página sobre [GIS básico](#gis).   


## O pacote **here** {#here}

O pacote **here** e sua função `here()` tornam fácil dizer a R onde encontrar e salvar seus arquivos - em essência, ele constrói os caminhos dos arquivos.  

Utilizado em conjunto com um projeto R, **here** permite descrever a localização dos arquivos em seu projeto R em relação ao diretório *root do projeto R* (a pasta de nível superior). Isto é útil quando o projeto R pode ser compartilhado ou acessado por várias pessoas/computadores. Ele evita complicações devido aos caminhos exclusivos dos arquivos em diferentes computadores (por exemplo, `"C:/Users/Laura/Documents...'', "iniciando" o caminho do arquivo em um lugar comum a todos os usuários (a raiz do projeto R).  

É assim como `here()` funciona dentro de um projeto R:  

* Quando o pacote **here** é carregado pela primeira vez dentro do projeto R, ele coloca um pequeno arquivo chamado ".here" na pasta raiz de seu projeto R como um "*benchmark*" ou "âncora".  
* Em seus scripts, para referenciar um arquivo nas subpastas do projeto R, você utiliza a função `here()` para construir o caminho do arquivo *em relação a essa âncora*.
* Para construir o caminho do arquivo, escreva os nomes das pastas além da raiz, entre aspas, separados por vírgulas, finalmente terminando com o nome do arquivo e a extensão do arquivo, como mostrado abaixo  
* Caminhos de arquivos com a função 'here()`  podem ser utilizados tanto para importação quanto para exportação  

Por exemplo, abaixo, a função `import()` está sendo fornecida um caminho de arquivo construído com `here()`.   

```{r, eval=F}
linelist <- import(here("data", "linelists", "ebola_linelist.xlsx"))
```

O comando `here("data", "linelists", "ebola_linelist.xlsx")` está na verdade fornecendo o caminho completo do arquivo que é *único para o computador do usuário*:  

```
"C:/Users/Laura/Documents/my_R_project/data/linelists/ebola_linelist.xlsx"
```

A beleza é que o comando R utilizando `here()` pode ser executado com sucesso em qualquer computador que acesse o projeto R.  


<span style="color: darkgreen;">**_DICA:_**  Se você não tiver certeza de onde a raiz ".here" está definida, execute a função `here()` com parênteses vazios.</span>  

Leia mais sobre o pacote **here** [neste link](https://here.r-lib.org/).  



<!-- ======================================================= -->
## Caminhos dos arquivos

Ao importar ou exportar dados, você deve fornecer um caminho para o arquivo. Você pode fazer isso de três maneiras:  

1) *Recomendado:* fornecer um caminho de arquivo "relativo" com o pacote **here**
2) Fornecer o caminho "completo" / "absoluto" do arquivo  
3) Seleção manual do arquivo  



### Caminhos 'relativo' dos arquivos {.unnumbered}

No R, os caminhos de arquivo "relativos" consistem no caminho de arquivo *relativo à* raiz de um projeto R. Eles permitem caminhos de arquivo mais simples que podem funcionar em computadores diferentes (por exemplo, se o projeto R estiver em um drive compartilhado ou for enviado por e-mail). Como descrito [acima](#here), os caminhos de arquivo relativos são facilitados pelo uso do pacote **here**.  

Um exemplo de um caminho de arquivo relativo construído com `here()` está abaixo. Supomos que o trabalho esteja em um projeto R que contém uma subpasta "dados" e dentro dela uma subpasta "linelists", na qual há o arquivo .xlsx de interesse.    

```{r, eval=F}
linelist <- import(here("dados", "linelists", "ebola_linelist.xlsx"))
```



### Caminhos 'absoluto' dos arquivos {.unnumbered}  

Caminhos de arquivo absolutos ou "completos" podem ser fornecidos para funções como `import()` mas são "frágeis", pois são exclusivos para o computador específico do usuário e portanto *não são recomendados*. 

Abaixo está um exemplo de um caminho de arquivo absoluto, onde no computador de Laura há uma pasta "analises", uma subpasta "dados" e dentro dela uma subpasta "linelists", na qual há o arquivo .xlsx de interesse.  

```{r, eval=F}
linelist <- import("C:/Users/Laura/Documents/analises/dados/linelists/ebola_linelist.xlsx")
```

Algumas coisas a serem observadas sobre os caminhos absolutos dos arquivos:  

* **Evite o uso de caminhos de arquivo absolutos**, pois eles quebrarão se o script for executado em um computador diferente.
* Utilize barras normais (`/`), como no exemplo acima (nota: este é *NÃO* o padrão para caminhos de arquivos do Windows)  
* Os caminhos de arquivos que começam com barras duplas (por exemplo, "//...") provavelmente **não serão reconhecidos por R** e produzirão um erro. Considere mover seu trabalho para uma unidade  "nomeado" ou " com letras" que comece com uma letra (por exemplo, "J:" ou "C:"). Consulte a página em [Interações do diretório](#directories) para obter mais detalhes sobre este assunto.  

Um cenário onde caminhos de arquivo absolutos podem ser apropriados é quando você deseja importar um arquivo de um drive compartilhado que tenha o mesmo caminho de arquivo completo para todos os usuários.  

<span style="color: darkgreen;">**_DICA:_** Para converter rapidemente todas as barras invertidas `\` em barras normais `/`, destaque o código de interesse, use Ctrl+f (no Windows), selecione a caixa de opção "Em seleção" (*In selection*), e depois usar a funcionalidade de substituição para convertê-los.</span>  



<!-- ======================================================= -->
### Selecionando um arquivo manualmente {.unnumbered}

Você pode importar dados manualmente por meio de um destes métodos:  

1) Painel Ambiente (*Environment*) do RStudio, clique em "Importar Dados"  (*Import Dataset*), e selecione o tipo de dado
2) Clique em File / Import Dataset / (selecione o tipo de dados)  
3) Para seleção manual por código, utilize o comando do R *base* `file.choose()` (deixando os parênteses vazios) para acionar a aparência de uma janela **pop-up** que permite ao usuário selecionar manualmente o arquivo de seu computador. Por exemplo:  

```{r import_choose, eval=F}
# Seleção manual de um arquivo. Quando este comando for executado, uma janela POP-UP aparecerá. 
# O caminho do arquivo selecionado será fornecido ao comando import().

my_data <- import(file.choose())
```

<span style="color: darkgreen;">**_DICA:_** A **janela pop-up window** pode aparecer ATRÁS di seu RStudio.</span>



## Importar dados

Utilizar `import()` para importar um conjunto de dados é bastante simples. Basta fornecer o caminho para o arquivo (incluindo o nome do arquivo e a extensão do arquivo) entre aspas. Se utilizar `here()` para construir o caminho do arquivo, siga as instruções acima. Abaixo estão alguns exemplos:  

Importar um arquivo csv que está localizado em seu "diretório de trabalho" ou na pasta raiz do projeto R:  

```{r, eval=F}
linelist <- import("linelist_cleaned.csv")
```


Importação da primeira planilha de uma pasta de trabalho do Excel que está localizada nas subpastas "dados" e "linelists" do projeto R (o caminho do arquivo construído utilizando `here()`):  

```{r, eval=F}
linelist <- import(here("dados", "linelists", "linelist_cleaned.xlsx"))
```

Importação de um  "quadro de dados" ( referido nesse livro como *data frame*)(um arquivo .rds) usando um caminho de arquivo absoluto:  

```{r, eval=F}
linelist <- import("C:/Users/Laura/Documents/tuberculosis/data/linelists/linelist_cleaned.rds")
```



### Planilhas específicas do Excel {.unnumbered}

Por padrão, se você fornecer uma pasta de trabalho Excel (.xlsx) para a função `import()`, a primeira planilha da pasta de trabalho será importada. Se você quiser importar uma **aba** (*sheet*) específica, inclua o nome da planilha ao `which = ` argument. Por exemplo:  

```{r eval=F}
my_data <- import("my_excel_file.xlsx", which = "Sheetname")
```

Se utilizar o método `here()` para fornecer um caminho relativo para `import()`, você ainda pode indicar uma aba específica adicionando o `which = ` argumento depois dos parênteses de fechamento da função `here()`.      

```{r import_sheet_here, eval=F}
# Demonstração: importação de uma planilha específica do Excel ao utilizar caminhos relativos com o pacote 'here'.  

linelist_raw <- import(here("data", "linelist.xlsx"), which = "Sheet1")`  
```

Para *exportar* um *data frame* do R para uma planilha específica do Excel e ter o resto da pasta de trabalho do Excel inalterado, você terá que importar, editar e exportar com um pacote alternativo criado para este propósito, como **openxlsx***. Veja mais informações na página em [Interações do diretório](#directories) ou [nesta página do github](https://ycphs.github.io/openxlsx/).

Se sua pasta de trabalho Excel for .xlsb (pasta de trabalho Excel em formato binário) você talvez não consiga importá-la usando **rio**. Considere a possibilidade de salvá-la como .xlsx, ou usando um pacote como **readxlsb*** que é construído para [este propósito](https://cran.r-project.org/web/packages/readxlsb/vignettes/read-xlsb-workbook.html).  


<!-- ======================================================= -->
### Valores faltantes {#import_missing .unnumbered} 

Você pode querer designar que valor(es) em seu conjunto de dados que deve(m) ser considerado(s) como ausente(s)/faltante(s). Como explicado na página em [Dados faltantes](#missing-data), o valor em R para dados ausentes é `NA`, mas talvez o conjunto de dados que você deseja importar utilize 99, "Ausente", ou apenas espaço vazio de caracteres "" em vez disso.  

Utilize o `na = ` argumento para `import()` e forneça o(s) valor(es) entre aspas (mesmo que sejam números). Você pode especificar múltiplos valores incluindo-os dentro de um vetor, utilizando `c()` como mostrado abaixo.  

Aqui, o valor "99" no conjunto de dados importados é considerado ausente e convertido para `NA` em R.

```{r, eval=F}
linelist <- import(here("data", "my_linelist.xlsx"), na = "99")
```

Qualquer um dos valores "Missing", "" (célula vazia), ou "" (espaço único) no conjunto de dados importados são convertidos para `NA` no R.  

```{r, eval=F}
linelist <- import(here("data", "my_linelist.csv"), na = c("Missing", "", " "))
```


<!-- ======================================================= -->
### Pular linhas {.unnumbered} 

Às vezes, você pode querer evitar a importação de uma linha específica de dados. Você pode fazer isso com o argumento `skip = ` se utilizar `import()` de **rio** em um arquivo .xlsx ou .csv. Forneça o número de linhas que você deseja pular. 

```{r, eval=F}
linelist_raw <- import("linelist_raw.xlsx", skip = 1)  # Não importa a linha de cabeçalho
```

Infelizmente 'skip = 'aceita apenas um valor inteiro, *não* um intervalo (por exemplo, "2:10" não funciona). Para pular a importação de linhas específicas que não são consecutivas do topo, considere importar várias vezes e utilizar `bind_rows()` a partir de **dplyr***. Veja o exemplo abaixo de pular apenas a linha 2.  


### Como lidar com uma segunda linha de cabeçalho {.unnumbered}  

Às vezes, seus dados podem ter uma *segunda* linha de cabeçalho, por exemplo, se for uma linha de "dicionário de dados", como mostrado abaixo. Esta situação pode ser problemática porque pode resultar na importação de todas as colunas como a classe "caractere".

```{r, echo=F}
# HIDDEN FROM READER
####################
# Create second header row of "data dictionary" and insert into row 2. Save as new dataframe.
linelist_2headers <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds")) %>%         
        mutate(across(everything(), as.character)) %>% 
        add_row(.before = 1,
                #row_num = "000",
                case_id = "case identification number assigned by MOH",
                generation = "transmission chain generation number",
                date_infection = "estimated date of infection, mm/dd/yyyy",
                date_onset = "date of symptom onset, YYYY-MM-DD",
                date_hospitalisation = "date of initial hospitalization, mm/dd/yyyy",
                date_outcome = "date of outcome status determination",
                outcome = "either 'Death' or 'Recovered' or 'Unknown'",
                gender = "either 'm' or 'f' or 'unknown'",
                hospital = "Name of hospital of first admission",
                lon = "longitude of residence, approx",
                lat = "latitude of residence, approx",
                infector = "case_id of infector",
                source = "context of known transmission event",
                age = "age number",
                age_unit = "age unit, either 'years' or 'months' or 'days'",
                fever = "presence of fever on admission, either 'yes' or 'no'",
                chills = "presence of chills on admission, either 'yes' or 'no'",
                cough = "presence of cough on admission, either 'yes' or 'no'",
                aches = "presence of aches on admission, either 'yes' or 'no'",
                vomit = "presence of vomiting on admission, either 'yes' or 'no'",
                time_admission = "time of hospital admission HH:MM")
```

Abaixo está um exemplo deste tipo de conjunto de dados (sendo a primeira linha o dicionário de dados).  

```{r message=FALSE, echo=F}
# Exibe a linelist como uma tabela
DT::datatable(head(linelist_2headers, 5), rownames = FALSE, filter="top", options = list(pageLength = 4, scrollX=T), class = 'white-space: nowrap' )
```

#### Remover uma segunda linha de cabeçalho {.unnumbered}  

Para ignorar a segunda linha de cabeçalho, você provavelmente precisará importar os dados duas vezes.  

1) Importar os dados para armazenar os nomes corretos das colunas  
2) Importar os dados novamente, pulando as primeiras *duas* fileiras (cabeçalho e segunda fileira)  
3) Ligar os nomes corretos no campo de dados reduzido

O argumento exato usado para ligar os nomes corretos das colunas depende do tipo de arquivo de dados (.csv, .tsv, .xlsx, etc.). Isto porque **rio** está usando uma função diferente para os diferentes tipos de arquivo (ver tabela acima).  

**Para arquivos Excel:** (`col_names = `)  

```{r, eval=F}
# importe a primeira vez; salve o nome das colunas
linelist_raw_names <- import("linelist_raw.xlsx") %>% names()  # Salva o nome veradeiro das colunas

# Importe uma segunda vez; pule a segunda linha e designe os nomes das colunas para o argumento col_names =
linelist_raw <- import("linelist_raw.xlsx",
                       skip = 2,
                       col_names = linelist_raw_names
                       ) 
```

**Para arquivos CSV:** (`col.names = `)  

```{r, eval=F}
# importe a primeira vez; salve o nome das colunas
linelist_raw_names <- import("linelist_raw.csv") %>% names() # salve o nome verdadeiro das colunas

# note que o argumento para arquivos csv é 'col.names = '
linelist_raw <- import("linelist_raw.csv",
                       skip = 2,
                       col.names = linelist_raw_names
                       ) 
```

**Opção de Backup ** - atribuir/sobreescrever cabeçalhos usando a função 'colnames()' do base

```{r, eval=F}
# assign/overwrite headers using the base 'colnames()' function
colnames(linelist_raw) <- linelist_raw_names
```


#### Fazendo um dicionário de dados {.unnumbered}  

Bônus! Se você tiver uma segunda linha que seja um dicionário de dados, você pode facilmente criar um dicionário de dados adequado a partir dele. Esta dica é adaptada a partir deste [post](https://alison.rbind.io/post/2018-02-23-read-multiple-header-rows/).    


```{r}
dict <- linelist_2headers %>%             # começa: linelist com um dicionário como a primeira linha
  head(1) %>%                             # mantenha apenas os nomes das colunas e a primeira linha com o dicionário               
  pivot_longer(cols = everything(),       # faça o pivotamento de todas as coluna spara o formato "longo" 
               names_to = "Column",       # nomeie as colunas
               values_to = "Description")
```


```{r message=FALSE, echo=F}
DT::datatable(dict, rownames = FALSE, filter="top", options = list(pageLength = 4, scrollX=T), class = 'white-space: nowrap' )
```



#### Combinar duas linhas de cabeçalho {.unnumbered}  

Em alguns casos, quando seu conjunto de dados brutos tiver *duas* linhas de cabeçalho (ou mais especificamente, a segunda linha de dados é um cabeçalho secundário), você pode querer "combiná-las" ou adicionar os valores da segunda linha de cabeçalho à primeira linha de cabeçalho.  

O comando abaixo definirá os nomes das colunas do *data frame* como a combinação (colando em conjunto) dos primeiros cabeçalhos (verdadeiros) com o valor imediatamente abaixo (na primeira linha). 

```{r, eval=F}
names(my_data) <- paste(names(my_data), my_data[1, ], sep = "_")
```



<!-- ======================================================= -->
### Planilhas do Google {.unnumbered}

Você pode importar dados de uma planilha on-line do Google com o pacote **googlesheet4** e autenticando seu acesso à planilha.  


```{r, eval=F}
pacman::p_load("googlesheets4")
```

Abaixo, uma planilha de demonstração do Google é importada e salva. Este comando pode solicitar a confirmação da autenticação de sua conta Google. Siga as instruções e pop-ups em seu navegador de internet para conceder permissões aos pacotes Tidyverse API para editar, criar e excluir suas planilhas no Google Drive.  


A planilha abaixo é "visualizável para qualquer pessoa com o link" e você pode tentar importá-la.  

```{r, eval=F}
Gsheets_demo <- read_sheet("https://docs.google.com/spreadsheets/d/1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY/edit#gid=0")
```

A planilha também pode ser importada usando apenas a identificação da planilha, uma parte mais curta da URL:  

```{r, eval=F}
Gsheets_demo <- read_sheet("1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY")
```

Outro pacote, **googledrive** oferece funções úteis para escrever, editar e excluir planilhas do Google. Por exemplo, utilizando as funções `gs4_create()` e `sheet_write()` encontradas neste pacote. 

Aqui estão alguns outros tutoriais on-line úteis:  
[tutorial básico de importação de planilhas do Google](https://arbor-analytics.com/post/getting-your-data-into-r-from-google-sheets/)  
[tutorial mais detalhado](https://googlesheets4.tidyverse.org/articles/googlesheets4.html)  
[interação entre as googlesheets4 e tidyverse](https://googlesheets4.tidyverse.org/articles/articles/drive-and-sheets.html)  



## Múltiplos arquivos- importar, exportar, dividir, combinar  

Veja a página em [Iteração, loops e listas](#iteration) para exemplos de como importar e combinar vários arquivos, ou vários arquivos de pastas de trabalho Excel. Essa página também tem exemplos de como dividir um data frame em partes e exportar cada uma separadamente, ou como planilhas nomeadas em uma pasta de trabalho do Excel.  




<!-- ======================================================= -->
## Importar do GitHub {#import_github}

A importação de dados diretamente do Github para R pode ser muito fácil ou pode exigir alguns passos - dependendo do tipo de arquivo. Abaixo estão algumas abordagens:  

### Arquivos CSV {.unnumbered}  

Pode ser fácil importar um arquivo .csv diretamente do Github para R com um comando R.  

1) Vá até o repositório Github, localize o arquivo de interesse e clique sobre ele  
3) Clique no botão "Raw" (você verá então os dados "brutos" do csv, como mostrado abaixo)  
4) Copiar a URL (endereço web)  
5) Colocar a URL entre aspas dentro do comando `import()` no R  

```{r, out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_csv_raw.png"))
```

### Arquivo XLSX {.unnumbered}  

Talvez você não consiga visualizar os dados "Raw" de alguns arquivos (por exemplo, .xlsx, .rds, .nwk, .shp)  

1) Vá até o repositório Github, localize o arquivo de interesse e clique sobre ele  
2) Clique no botão "Download", como mostrado abaixo  
3) Salve o arquivo em seu computador, e importe-o para o R  


```{r , out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_xlsx.png"))
```

### Shapefiles {.unnumbered} 

Os shapefiles têm muitos sub-componentes, cada um com uma extensão de arquivo diferente. Um arquivo terá a extensão ".shp", mas outros podem ter ".dbf", ".prj", etc.  Para baixar um shapefile do Github, você precisará baixar cada um dos arquivos de subcomponentes individualmente, e salvá-los na *mesma* pasta  em seu computador. No Github, clique em cada arquivo individualmente e faça o download deles clicando no botão "Download".  

Uma vez salvo em seu computador, você pode importar o shapefile como mostrado na página [GIS básico](#gis) utilizando `st_read()` do pacote **sf**. Você só precisa fornecer o caminho do arquivo e o nome do arquivo ".shp" - desde que os outros arquivos relacionados estejam dentro da mesma pasta em seu computador.  

Abaixo, você pode ver como o shapefile "sle_adm3" consiste de muitos arquivos - cada um dos quais deve ser baixado do Github.  

```{r , out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_shp.png"))
```





<!-- ======================================================= -->
## Inserir dados munualmente {}

### Inserção por linhas {.unnumbered}  

Utilize a função `tribble` do pacote **tibble** do tidyverse ([referência online tibble](https://tibble.tidyverse.org/reference/tribble.html)).  
  
Observe como os cabeçalhos das colunas começam com um *til* (`~`).  Observe também que cada coluna deve conter apenas uma classe de dados (caractere, numérico, etc.). Você pode utilizar abas, espaçamento e novas linhas para tornar a entrada de dados mais intuitiva e legível. Os espaços não importam entre os valores, mas cada linha é representada por uma nova linha de código. Por exemplo: 

```{r import_manual_row}
# Crie um conjunto de dados manualmente por linha
manual_entry_rows <- tibble::tribble(
  ~colA, ~colB,
  "a",   1,
  "b",   2,
  "c",   3
  )
```

A agora nós exibimos o novo *data frame*::  

```{r, echo=F}
# exibe o novo data frame
DT::datatable(manual_entry_rows)
```


### Inserção por colunas {.unnumbered}  

Como um data frame consiste em vetores (colunas verticais), a abordagem **base** para a criação manual de data frames no R espera que você defina cada coluna e depois as vincule juntas. Isto pode ser contra-intuitivo em epidemiologia, pois geralmente pensamos em nossos dados em linhas (como acima). 

```{r import_manual_col}
# definir cada vetor (coluna vertical) separadamente, cada um com seu próprio nome
PatientID <- c(235, 452, 778, 111)
Treatment <- c("Yes", "No", "Yes", "Yes")
Death     <- c(1, 0, 1, 0)
```

<span style="color: orange;">**_CUIDADO:_** Todos os vetores devem ter o mesmo comprimento (mesmo número de valores).</span>

The vectors can then be bound together using the function `data.frame()`:  

```{r}
# combine as colunas em um *data frame*, referenciando os nomes dos vetores
manual_entry_cols <- data.frame(PatientID, Treatment, Death)
```

E agora vamos vizualizar o novo conjunto de dados:

```{r, echo=F}
# exibe o novo data frame
DT::datatable(manual_entry_cols)
```




### Colando a partir da área de transferência {.unnumbered}  

Se você copiar dados de outro lugar e os tem na "área de transferência" (*clipboard*), você pode tentar uma das duas maneiras abaixo:  

Do pacote **clipr***, você pode utilizar `read_clip_tbl()` para importar como um data frame, ou apenas `read_clip()` para importar como um vetor de caracteres. Em ambos os casos, deixe os parênteses vazios.     

```{r, eval=F}
linelist <- clipr::read_clip_tbl()  # importa a área de transferência atual como uma data frame
linelist <- clipr::read_clip()      # importa como um vetor de caracteres
```
Você também pode exportar facilmente para a área de transferência do seu sistema com **clipr***. Veja a seção abaixo sobre Exportação.  


Alternativamente, você pode utilizar a função `read.table()` do R **base**  com `file = "clipboard")` para importar como um *data frame*:  

```{r, eval=F}
df_from_clipboard <- read.table(
  file = "clipboard",  # specify this as "clipboard"
  sep = "t",           # separator could be tab, or commas, etc.
  header=TRUE)         # if there is a header row
```



## Importar o arquivo mais recente

Muitas vezes você pode receber atualizações diárias de seus conjuntos de dados. Neste caso, você vai querer escrever o código que importa o arquivo mais recente. A seguir, apresentamos duas formas de abordar este assunto:  

* Selecionando o arquivo com base na data no nome do arquivo  
* Seleção do arquivo com base nos metadados do arquivo (última modificação)  


### Datas no nome de um arquivo {.unnumbered}  

Esta abordagem depende de três premissas:  

1) Você confia nas datas nos nomes dos arquivos  
2) As datas são numéricas e aparecem em *geralmente* no mesmo formato (por exemplo, ano, mês e dia)  
3) Não há outros números no nome do arquivo  

Explicaremos cada passo e, no final, mostraremos a combinação deles.  

Primeiro, utilize `dir()` do R **base** para extrair apenas os nomes dos arquivos para cada arquivo na pasta de interesse. Consulte a página em [Interações de diretório](#directories) para obter mais detalhes sobre `dir()`. Neste exemplo, a pasta de interesse é a pasta "linelists" dentro da pasta "exemplo" dentro de "data" dentro do projeto R.

```{r}
linelist_filenames <- dir(here("data", "example", "linelists")) # pega o nome dos arquivos da pasta
linelist_filenames                                              # exibe 
```

Uma vez que você tenha este vetor de nomes, você pode extrair as datas a partir deles aplicando `str_extract()` de **stringr** utilizando esta expressão regular. Ela extrai quaisquer números no nome do arquivo (incluindo quaisquer outros caracteres no meio, tais como traços ou cortes). Você pode ler mais sobre **stringr*** na página [Strings e caracteres](#characters-strings).  

```{r}
linelist_dates_raw <- stringr::str_extract(linelist_filenames, "[0-9].*[0-9]") # extrai números e quaisquer caracteres no meio
linelist_dates_raw  # print
```

Assumindo que as datas são escritas geralmente no mesmo formato (por exemplo, Ano e depois Mês e depois Dia) e os anos têm 4 dígitos, você pode utilizar **lubridate**'s funções flexíveis de conversão (`ymd()`, `dmy()`, ou `mdy()`) para convertê-las em datas. Para estas funções, os traços, espaços ou cortes não importam, apenas a ordem dos números. Leia mais na página [Trabalhando com datas](#dates).  

```{r}
linelist_dates_clean <- lubridate::ymd(linelist_dates_raw)
linelist_dates_clean
```


A função do R **base** `which.max()` pode então ser utilizada para retornar a posição do índice (por exemplo, 1º, 2º, 3º, ...) do valor máximo da data. O último arquivo é corretamente identificado como o 6º arquivo - "case_linelist_2020-10-08.xlsx".  

```{r}
index_latest_file <- which.max(linelist_dates_clean)
index_latest_file
```

Se nós condensarmos todos esses comandos, o cógico compelto deve parecer com o abaixo. Observe que o `.` na ultima linha é um marcador para o objeto pipe naquele ponta da sequência de pipes. Naquele ponto o valor é implesmente o número 6. Isso é colocado entre cochetes para extrair o sexto elemnto do vetor de nomes do arquivo produzido por `dir()`.    

```{r}
# carrega os pacotes
pacman::p_load(
tidyverse,           # manipulação  de dados
  stringr,           # trabalha com strings/caravteres
  lubridate,         # trabalha com datas
  rio,               # importar / exportar
  here,              # caminhos relativos dos arquivos
  fs)                # interações entre diretórios

# extrai o nome do arquivo mais recente
latest_file <- dir(here("data", "example", "linelists")) %>%  # nomes dos aequivos da subpasta "linelists"         
  str_extract("[0-9].*[0-9]") %>%                  # extrai as datas (números)
  ymd() %>%                                        # converte números pra datas (assumindo o formato ano-mês-dia)
  which.max() %>%                                  # pega o índice da maior data (arquivo mais recente) 
  dir(here("data", "example", "linelists"))[[.]]              # retorna o nome do arquivo da linelist mais recente

latest_file  # mostra o nome do arquivo do artigo mais recente
```

Você pode agora usar esse nome para finalizar o caminho relativo do arquivo, com `here()`:  

```{r, eval=F}
here("dados", "example", "linelists", latest_file) 
```

E agora você pode importar o arquivo mais recente:

```{r, eval=F}
# importar
import(here("dados", "example", "linelists", latest_file)) # import 
```

 

### Use as informações do arquivo {.unnumbered}  

Se seus arquivos não tiverem datas em seus nomes (ou se você não confiar nessas datas), você pode tentar extrair a data da última modificação dos metadados do arquivo. Use funções do pacote **fs** para examinar as informações dos metadados de cada arquivo, que incluem o tempo da última modificação e o caminho do arquivo.  

Abaixo, fornecemos a pasta de interesse para **fs**'s `dir_info()`. Neste caso, a pasta de interesse está no projeto R na pasta "dados", na subpasta "exemplo" e em sua subpasta "linelists".  O resultado é um *data frame* com uma linha por arquivo e colunas para `modification_time', `path', etc. Você pode ver um exemplo visual disto na página em [interações de diretório](#directories).    

Podemos ordenar este *data frame* de arquivos pela coluna `modification_time`, e então manter apenas a linha superior/última linha (arquivo) com a função do R **base*** `head()`. Então podemos extrair o caminho do arquivo deste último arquivo somente com a função **dplyr*** `pull()` na coluna `path`. Finalmente, podemos passar este caminho de arquivo para `import()`. O arquivo importado é salvo como `latest_file`.   

```{r, eval=F}
latest_file <- dir_info(here("dados", "examplo", "linelists")) %>%  # coleta dados sobre todos os arquivos no diretório
  arrange(desc(modification_time)) %>%      # classifica por data da última modificação
  head(1) %>%                               # mantém apenas o arquivo modificado por último
  pull(path) %>%                            # extrai apenas o endereço do arquivo
  import()                                  # importa o arquivo

```



<!-- ======================================================= -->
## APIs {#import_api}

Uma "Interface de Programação Automatizada" (API) pode ser usada para solicitar dados diretamente de um website. As APIs são um conjunto de regras que permitem que uma aplicação de software interaja com outra. O cliente (você) envia uma "solicitação" e recebe uma "resposta" contendo o conteúdo. Os pacotes R **httr** e **jsonlite*** podem facilitar este processo. 

Cada website habilitado para API terá sua própria documentação e especificações para se familiarizar. Alguns sites estão disponíveis publicamente e podem ser acessados por qualquer pessoa. Outros, tais como plataformas com IDs de usuário e credenciais, requerem autenticação para acessar seus dados. 

Não é preciso dizer que é necessário ter uma conexão com a Internet para importar dados via API. Daremos breves exemplos de uso de APIs para importar dados e conectá-lo a outros recursos.  

*Note: lembre-se que os dados podem ser *postados* em um website sem API, o que pode ser mais fácil de ser recuperado. Por exemplo, um arquivo CSV postado pode ser acessível simplesmente fornecendo a URL do site para `import()` como descrito na seção sobre [importação de Github](#import_github).*   


### Requisição HTTP {.unnumbered}  

A troca de API é mais comumente feita através de uma solicitação HTTP. HTTP é o Protocolo de Transferência de Hipertexto, e é o formato subjacente de uma solicitação/resposta entre um cliente e um servidor. A entrada e saída exata pode variar dependendo do tipo de API, mas o processo é o mesmo - uma "Solicitação" (geralmente Solicitação HTTP) do usuário, muitas vezes contendo uma consulta, seguida por uma "Resposta", contendo informações de status sobre a solicitação e possivelmente o conteúdo solicitado.  

Aqui estão alguns componentes de uma solicitação *HTTP*:  

* A URL do endpoint da API  
* O "Método" (ou "Verbo")  
* Cabeçalhos  
* Corpo  

O "método" de solicitação HTTP é a ação que você deseja realizar. Os dois métodos HTTP mais comuns são `GET` e `POST`, mas outros poderiam incluir `PUT`, `DELETE`, `PATCH`, etc. Ao importar dados para R, é mais provável que você utilize `GET`.  

Após sua solicitação, seu computador receberá uma "resposta" em um formato similar ao que você enviou, incluindo URL, status HTTP (Status 200 é o que você quer!), tipo de arquivo, tamanho e o conteúdo desejado. Você precisará então analisar esta resposta e transformá-la em um data frame funcional dentro de seu ambiente R.


### Pacotes {.unnumbered}  

O pacote **httr** funciona bem para lidar com solicitações HTTP em R. Ele requer pouco conhecimento prévio de APIs Web e pode ser usado por pessoas menos familiarizadas com a terminologia de desenvolvimento de software. Além disso, se a resposta HTTP for .json, você pode usar **jsonlite** para analisar a resposta.  

```{r, eval=F}
# carrega pacotes
pacman::p_load(httr, jsonlite, tidyverse)
```


### Dados públicos {.unnumbered}  

Abaixo é um exemplo de uma solicitação de HTTP, originalmente de um tutorial do [the Trafford Data Lab](https://www.trafforddatalab.io/open_data_companion/#A_quick_introduction_to_APIs). Esse site têm vários outros recursos para aprender esse tema e exercícios sobre API.

Cenário: nós queremos importar uma lista de restaurantes fast food na cidade de Trafford, Reino Unido. Os dados podem ser acessados pela API da Food Standards Agency, que disponibiliza dados e classificações acerca de hiigiene alimentar no Reino Unido.

OAqui estão os parâmetros para a nossa solicitação:

* HTTP verb: GET  
* API endpoint URL: http://api.ratings.food.gov.uk/Establishments  
* Parâmetros selecionados: name, address, longitude, latitude, businessTypeId, ratingKey, localAuthorityId  
* Cabeçalho: “x-api-version”, 2  
* Formato(s) dos dados: JSON, XML  
* Documentação: http://api.ratings.food.gov.uk/help  

O código no R seria como seguinte:

```{r, eval=F, warning=F, message=F}
# prepare a solicitação
path <- "http://api.ratings.food.gov.uk/Establishments"
request <- GET(url = path,
             query = list(
               localAuthorityId = 188,
               BusinessTypeId = 7844,
               pageNumber = 1,
               pageSize = 5000),
             add_headers("x-api-version" = "2"))

# cheque para algum erro no servidor ("200" é bom!)
request$status_code

# submita a solicitação, separe a resposta, e converta para um data frame  

response <- content(request, as = "text", encoding = "UTF-8") %>%
  fromJSON(flatten = TRUE) %>%
  pluck("establishments") %>%
  as_tibble()
```

Agora você pode limpar e utilizar o *data frame* `resposta` (*response*), que contém uma linha por estabelecimento de fast food.  

### Autenticação necessária {.unnumbered}  

Algumas APIs requerem autenticação - para que você possa provar quem você é, para que possa acessar dados restritos. Para importar estes dados, você pode precisar primeiro usar um método POST para fornecer um nome de usuário, senha, ou código. Isto retornará um token de acesso, que pode ser usado para solicitações posteriores do método GET para recuperar os dados desejados.  

Abaixo está um exemplo de consulta de dados do *Go.Data*, que é uma ferramenta de investigação de surtos. *Go.Data* usa uma API para todas as interações entre o front-end da web e os aplicativos smartphone usados para a coleta de dados. O *Go.Data* é usado em todo o mundo. Como os dados do surto são sensíveis e você só deve ser capaz de acessar os dados para *seu* surto, a autenticação é necessária.  

Abaixo estão alguns exemplos de código R usando **httr** e **jsonlite** para conexão com a API *Go.Data* para importar dados sobre o acompanhamento de contato de seu surto.  


```{r, eval=F}
# configure as credenciais para a autorização 
url <- "https://godatasampleURL.int/"           # instânica url Go.Data válida
username <- "username"                          # nome de usuário do Go.Data válido
password <- "password"                          # senha do Go.Data válida
outbreak_id <- "xxxxxx-xxxx-xxxx-xxxx-xxxxxxx"  # ID do surto do Go.Data outbreak válida

# obtenha o token de acesso
url_request <- paste0(url,"api/oauth/token?access_token=123") # defina a solicitação da url base 

# prepare a solicitação
response <- POST(
  url = url_request,  
  body = list(
    username = username,    # use o nome de usuario e senha salvos acima para autorizar 
    password = password),                                       
    encode = "json")

# execute a rolicitação e separe a resposta 
content <-
  content(response, as = "text") %>%
  fromJSON(flatten = TRUE) %>%          # flatten nested JSON
  glimpse()

# Salve o token de acesso da resposta 
access_token <- content$access_token    #  salve o token de acesso para permitir as chamadas subsequentes abaixo 

# importat os contatos dos surtos 
# Use o token de access 
response_contacts <- GET(
  paste0(url,"api/outbreaks/",outbreak_id,"/contacts"),          # OBTENHA (GET) a solicitação
  add_headers(
    Authorization = paste("Bearer", access_token, sep = " ")))

json_contacts <- content(response_contacts, as = "text")         # converta para texto JSON

contacts <- as_tibble(fromJSON(json_contacts, flatten = TRUE))   # "achate" o JSON para um tibble
```

<span style="color: orange;">**_CUIDADO:_** Se você estiver importando grandes quantidades de dados de um API que requeira autenticação, poderá haver um intervalo de tempo. Para evitar isto, recupere o access_token novamente antes de cada solicitação GET API e tente usar filtros ou limites na consulta.

<span style="color: darkgreen;">**_DICA:_** A função `fromJSON()` no pacote **jsonlite** não desalinha totalmente na primeira vez em que é executada, então você provavelmente ainda terá itens de lista em seu tibble resultante. Você precisará des-nidificar ainda mais para certas variáveis; dependendo de como seu .json está aninhado. Para ver mais informações sobre isto, veja a documentação do pacote **jsonlite**, como a função [`flatten()`](https://rdrr.io/cran/jsonlite/man/flatten.html). </span>


Para mais detalhes, Veja a documentação em [LoopBack Explorer](https://loopback.io/doc/en/lb4/index.html), a página [Rastreamento de Contatos](#contact-tracing) ou dicas de API em [Go.Data Github repository](https://worldhealthorganization.github.io/godata/api-docs)

Você pode ler mais sobre o pacote *httr* [aqui](https://httr.r-lib.org/articles/quickstart.html)  

Esta seção também foi informada por [este tutorial](https://www.dataquest.io/blog/r-api-tutorial/) e [este tutorial](https://medium.com/@traffordDataLab/querying-apis-in-r-39029b73d5f1). 




<!-- ======================================================= -->
## Exportar {}  

### Com  o pacote **rio**  {.não numerado}
Com **rio***, você pode utilizar a função `export()` de uma forma muito semelhante à `import()`. Primeiro dê o nome do objeto R que você deseja salvar (por exemplo, `linelist`) e depois, entre aspas, coloque o caminho do arquivo onde você deseja salvar o arquivo, incluindo o nome do arquivo desejado e a extensão do arquivo. Por exemplo, o nome do objeto R:  

Isto salva o data frame `linelist` como uma pasta de trabalho do Excel para a pasta raiz do diretório de trabalho/R do projeto:  

```{r, eval=F}
export(linelist, "my_linelist.xlsx") # will save to working directory
```

Você poderia salvar o mesmo *data frame* que um arquivo csv, alterando a extensão. Por exemplo, nós também o salvamos em um caminho de arquivo construído com `aqui()`:  

```{r, eval=F}
export(linelist, here("data", "clean", "my_linelist.csv"))
```


### Para a área de transferência {.unnumbered}

Para exportar um data frame para a "área de transferência" do seu computador (para depois colar em outro software como Excel, Google Spreadsheets, etc.) você pode utilizar `write_clip()` do pacote **clipr***.   

```{r, eval=F}
# exporte a linelist para a área de transferência do seu sistema
clipr::write_clip(linelist)
```




## Arquivos RDS  {#import_rds}

Junto com .csv, .xlsx, etc., você também pode exportar/vendar *data frame* R como arquivos .rds. Este é um formato de arquivo específico para R, e é muito útil se você souber que irá trabalhar com os dados exportados novamente em R. 

As classes de colunas são armazenadas, de modo que você não terá que limpar novamente quando for importado (com um arquivo Excel ou mesmo um arquivo CSV isto pode ser uma dor de cabeça!). É também um arquivo menor, que é útil para exportação e importação se seu conjunto de dados for grande.  

Por exemplo, se você trabalha em uma equipe de Epidemiologia e precisa enviar arquivos para uma equipe GIS para mapeamento, e eles usam R também, basta enviar-lhes o arquivo .rds! Então todas as classes de colunas são mantidas e têm menos trabalho a fazer.  

```{r, eval=F}
export(linelist, here("data", "clean", "my_linelist.rds"))
```



<!-- ======================================================= -->
## Arquivos e listas Rdata  {#import_rdata}

Arquivos do tipo `.Rdata`  cpode armazenar múltiplos objetos R - por exemplo, múltiplos *data frames*, resultados de modelos, listas, etc. Isto pode ser muito útil para consolidar ou compartilhar muitos de seus dados para um determinado projeto.  

No exemplo abaixo, múltiplos objetos R são armazenados dentro do arquivo exportado "my_objects.Rdata":  

```{r, eval=F}
rio::export(my_list, my_dataframe, my_vector, "my_objects.Rdata")
```

Nota: se você estiver tentando *importar* uma lista, utilize `import_list()` de **rio** para importá-la com a estrutura e o conteúdo original completo.  

```{r, eval=F}
rio::import_list("my_list.Rdata")
```







<!-- ======================================================= -->
## Salvando gráficos {} 

Instruções em como salvar gráficos, incluindo os criados pelo pacote `ggplot()`, são discutidos com profundidado na página [ggplot basics](#ggplot-basics).  

Em resumo, execute o código `ggsave("my_plot_filepath_and_name.png")` após exibir o seu gráfico. Você pode  prover um objeto de gráfico para o argumento `plot = `, ou especificar o endereço de salvamento (com extensão de arquivo desejada) para salvar o último gráfico exibido. Você pode tamb[ém controlar o tamanho e qualidade por meio dos argumentos: `width = `, `height = `, `units = ` e `dpi = `.  

Como salvar um gráfico de redes, como uma árvore de transmissão, é discutido na página [Cadeias de Transmissão](#transmission-chains). 


<!-- ======================================================= -->
## Recursos{} 

O [Manual de Importação/Exportação de Dados R](https://cran.r-project.org/doc/manuals/r-release/R-data.html)  
[R 4 Capítulo de ciência dos dados sobre importação de dados](https://r4ds.had.co.nz/data-import.html#data-import)  
[documentação ggsave()](https://ggplot2.tidyverse.org/reference/ggsave.html)  


Abaixo está uma tabela, extraída do **rio** online [vinheta](https://cran.r-project.org/web/packages/rio/vignettes/rio.html). Para cada tipo de dado ele mostra: a extensão de arquivo esperada, o pacote **rio*** utilizado para importar ou exportar os dados, e se esta funcionalidade está incluída na versão instalada padrão do **rio**.  




Formato                     | Extensão típica | Pacote de Importação   | Pacote de exportação | Instalado por padrão
---------------------------_|-----------------|------------------------|----------------------|---------------------
Dados separados por vírgulas | .csv | data.table `fread()` | data.table |	Sim
Dados separados por Pipe |	.psv | data.table `fread()` | data.table | Sim
Dados separados por Tab .tsv | data.table `fread()` | data.table | Sim
SAS | .sas7bdat | haven | haven | Sim
SPSS | .sav | haven | haven | Sim
Stata | .dta | haven | haven | Sim
SAS | XPORT | .xpt | haven | haven | Sim
SPSS Portable | .por | haven | | Sim
Excel | .xls | readxl | | Sim
Excel | .xlsx | readxl | openxlsx | Sim
R syntax | .R	| base | base | Sim
Objetos R salvos | .RData, .rda | base | base | Sim
Objetos R seriados | .rds | base | base | Sim
Epiinfo | .rec | foreign | | Sim
Minitab | .mtp | foreign | | Sim
Systat | .syd |	foreign | | Sim
“XBASE” | database files | .dbf | foreign | foreign | Sim
Weka Attribute-Relation File Format | .arff | foreign | foreign | Sim
Dados no formato de intercâmbio| .dif | utils | | Sim
Dados Fortran da | no recognized extension | utils | | Sim
Dados no formato largura fixa | .fwf | utils | utils | Sim
dados separados por vírgulas gzip  | .csv.gz | utils | utils | v
CSVY (CSV + YAML metadata header) | .csvy | csvy | csvy | Não
EViews | .wf1 |hexView | | Não
Formato de intercâmbio Feather R/Python  | .feather | feather | feather | Não
Fast Storage | .fst | fst |	fst | Não
JSON | .json | jsonlite | jsonlite | Não
Matlab | .mat | rmatio | rmatio | Não
Planilhas OpenDocument | .ods | readODS | readODS | Não
Tabelas HTML  | .html | xml2 | xml2 | Não
Documentos Shallow XML  | .xml | xml2 | xml2 | Não
YAML | .yml | yaml | yaml	| Não
Padrão da área de transferência é tsv | |  clipr | clipr | Não



