# ggplot-Tipps {}

Auf dieser Seite zeigen wir dir Tipps und Tricks, mit denen du deine ggplots scharf und schick machen kannst. Siehe die Seite über [ggplot-Grundlagen] für die Grundlagen.

Es gibt eine Reihe umfangreicher [**ggplot2** Tutorials](https://ggplot2.tidyverse.org/) die im Abschnitt Ressourcen verlinkt sind. Du kannst auch Folgendes herunterladen [Datenvisualisierung mit ggplot Cheatsheet](https://rstudio.com/resources/cheatsheets/) von der RStudio-Website herunterladen. Wir empfehlen dir dringend, dich von den folgenden Seiten inspirieren zu lassen [R-Grafik-Galerie](https://www.r-graph-gallery.com/) und [Data-to-viz](https://www.data-to-viz.com/caveats.html).

<!-- ======================================================= -->

## Vorbereitung {}

### Pakete laden {.unnumbered}

Dieser Codeabschnitt zeigt das Laden von Paketen, die für die Analysen benötigt werden. In diesem Handbuch betonen wir `p_load()` von **pacman**, der das Paket bei Bedarf installiert *und* lädt es zur Verwendung. Du kannst installierte Pakete auch laden mit `library()` von **base**R. Siehe die Seite über [R-Grundlagen] für weitere Informationen über R-Pakete.

```{r}
pacman::p_load(
  tidyverse,      # includes ggplot2 and other
  rio,            # import/export
  here,           # file locator
  stringr,        # working with characters   
  scales,         # transform numbers
  ggrepel,        # smartly-placed labels
  gghighlight,    # highlight one part of plot
  RColorBrewer    # color scales
)
```

### Daten importieren {.unnumbered}

Auf dieser Seite importieren wir den Datensatz der Fälle einer simulierten Ebola-Epidemie. Wenn du mitmachen willst, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>klicke, um die "saubere" Liste herunterzuladen</a> (als .rds-Datei). Importiere Daten mit dem `import()` Funktion aus der **rio**Paket (sie verarbeitet viele Dateitypen wie .xlsx, .csv, .rds - siehe die [Import und Export] Seite für Details).

```{r, echo=F}
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

```

```{r, eval=F}
linelist <- rio::import("linelist_cleaned.rds")
```

Die ersten 50 Zeilen der Linienliste werden unten angezeigt.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

## Skalen für Farbe, Füllung, Achsen, etc. {#ggplot\_tips\_colors}

In **ggplot2** wenn die Ästhetik der geplotteten Daten (z. B. Größe, Farbe, Form, Füllung, Plot-Achse) auf Spalten in den Daten abgebildet wird, kann die genaue Darstellung mit dem entsprechenden Befehl "scale" angepasst werden. In diesem Abschnitt erklären wir einige gängige Skalenanpassungen.

### Farbschemata

Eine Sache, die anfangs schwer zu verstehen sein kann, ist die **ggplot2** ist die Steuerung von Farbschemata. In diesem Abschnitt geht es um die Farbe von *Plot-Objekten* (Geometrien/Formen) wie Punkte, Balken, Linien, Kacheln, etc. Um die Farbe von Zubehörtext, Titeln oder Hintergrundfarbe anzupassen, siehe den [Themen](#ggplot_basics_themes)Abschnitt der [ggplot Grundlagen] Seite.

Um die "Farbe" von *Plot-Objekten* einzustellen, musst du entweder die `color = ` Ästhetik (die *Äußere* Farbe) oder die `fill = ` Ästhetik (die *Innenraum* Farbe). Eine Ausnahme von diesem Muster ist `geom_point()` wo du wirklich nur die Farbe der `color = ` die die Farbe des Punktes (innen und außen) bestimmt.

Beim Einstellen von Farbe oder Füllung kannst du von R erkannte Farbnamen verwenden wie `"red"` (siehe [vollständige Liste](http://sape.inf.usi.ch/quick-reference/ggplot2/colour) oder eingeben `?colors`), oder eine bestimmte Hex-Farbe wie `"#ff0505"`.

```{r, warning=F, message=F}
# histogram - 
ggplot(data = linelist, mapping = aes(x = age))+       # set data and axes
  geom_histogram(              # display histogram
    binwidth = 7,                # width of bins
    color = "red",               # bin line color
    fill = "lightblue")          # bin interior color (fill) 
```

Wie in den [ggplot Grundlagen] Abschnitt auf[Daten auf den Plot abbilden](#ggplot_basics_mapping) Ästhetik, wie zum Beispiel `fill = ` und `color = ` können entweder definiert werden *außerhalb von* einer `mapping = aes()` Anweisung oder *innerhalb von* einer Anweisung. Wenn *außerhalb* der `aes()` ist, sollte der zugewiesene Wert statisch sein (z. B. `color = "blue"`) und gilt für *alle* Daten, die mit dem Geom gezeichnet werden. Wenn *innerhalb* steht, sollte die Ästhetik auf eine Spalte abgebildet werden, wie `color = hospital` und der Ausdruck wird durch den Wert für diese Zeile in den Daten verändert. Ein paar Beispiele:

```{r, out.width=c("50%", "50%"), fig.show="hold", warning=F, message=F}
# Static color for points and for line
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     
  geom_point(color = "purple")+
  geom_vline(xintercept = 50, color = "orange")+
  labs(title = "Static color for points and line")

# Color mapped to continuous column
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     
  geom_point(mapping = aes(color = temp))+         
  labs(title = "Color mapped to continuous column")

# Color mapped to discrete column
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     
  geom_point(mapping = aes(color = gender))+         
  labs(title = "Color mapped to discrete column")

# bar plot, fill to discrete column, color to static value
ggplot(data = linelist, mapping = aes(x = hospital))+     
  geom_bar(mapping = aes(fill = gender), color = "yellow")+         
  labs(title = "Fill mapped to discrete column, static color")

```

### Skalen {#ggplot\_tips\_scales .unnumbered}

Sobald du eine Spalte einem ästhetischen Plot zuordnest (z.B. `x = `, `y = `, `fill = `, `color = `...), erhält dein Diagramm eine Skala/Legende. Wie du oben siehst, kann die Skala je nach Klasse der zugewiesenen Spalte kontinuierlich, diskret, datumsbezogen usw. sein. Wenn du den Spalten mehrere Ästhetiken zugewiesen hast, hat dein Diagramm mehrere Skalen.

Du kannst die Skalen mit den entsprechenden `scales_()` Funktion steuern. Die Skalenfunktionen von **ggplot()** haben 3 Teile, die wie folgt geschrieben sind: `scale_AESTHETIC_METHOD()`.

1) Der erste Teil, `scale_()`, ist fest.
2) Der zweite Teil, die ÄSTHETIK, sollte die Ästhetik sein, für die du den Maßstab anpassen willst (`_fill_`, `_shape_`, `_color_`, `_size_`, `_alpha_`...) - Die Optionen hier umfassen auch `_x_` und `_y_`.
3) Der dritte Teil, die METHODE, wird entweder `_discrete()`, `continuous()`, `_date()`, `_gradient()`, oder `_manual()` abhängig von der Klasse der Spalte und *wie* du sie steuern willst. Es gibt noch weitere, aber diese sind die am häufigsten verwendeten.

Achte darauf, dass du die richtige Funktion für die Skala verwendest! Sonst scheint dein Skalenbefehl nichts zu verändern. Wenn du mehrere Skalen hast, kannst du mehrere Skalenfunktionen verwenden, um sie anzupassen! Zum Beispiel:

### Skalenargumente {.unnumbered}

Jede Art von Skala hat ihre eigenen Argumente, obwohl es einige Überschneidungen gibt. Abfrage der Funktion wie `?scale_color_discrete` in der R-Konsole ab, um die Dokumentation der Funktionsargumente zu sehen.

Für kontinuierliche Skalen, verwende `breaks = ` um eine Folge von Werten mit `seq()` (nimm `to = `, `from = `, und `by = ` wie im folgenden Beispiel gezeigt. einstellen `expand = c(0,0)` ein, um den Füllraum um die Achsen zu eliminieren (dies kann bei jedem `_x_` oder `_y_` Skala.

Bei diskreten Skalen kannst du die Reihenfolge der Darstellung der Ebenen mit `breaks = ` und wie die Werte angezeigt werden, mit der `labels = ` Argument. Gib für jedes dieser Argumente einen Zeichenvektor an (siehe Beispiel unten). Du kannst auch `NA` einfach durch Setzen von `na.translate = FALSE`.

Die Feinheiten der Datumsskalen werden ausführlicher im Abschnitt [Epidemie-Kurven] Seite.

### Manuelle Anpassungen {.unnumbered}

Einer der nützlichsten Tricks ist die Verwendung von "manuellen" Skalierungsfunktionen, um Farben explizit nach deinen Wünschen zuzuweisen. Das sind Funktionen mit der Syntax `scale_xxx_manual()` (z.B.. `scale_colour_manual()` oder `scale_fill_manual()`). Jedes der unten genannten Argumente wird im folgenden Codebeispiel demonstriert.

- Weisen Sie den Datenwerten Farben zu mit dem `values = ` Argument
- Festlegen einer Farbe für `NA` mit `na.value = `
- Ändern Sie, wie die Werte sind *geschrieben werden* in der Legende mit der Option `labels = ` Argument
- Ändere den Titel der Legende mit `name = `

Im Folgenden erstellen wir ein Balkendiagramm und zeigen, wie es standardmäßig aussieht und dann mit drei angepassten Skalen - der kontinuierlichen y-Achsenskala, der diskreten x-Achsenskala und der manuellen Anpassung der Füllung (innere Balkenfarbe).

```{r, warning=F, message=F}
# BASELINE - no scale adjustment
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = outcome, fill = gender))+
  labs(title = "Baseline - no scale adjustments")

# SCALES ADJUSTED
ggplot(data = linelist)+
  
  geom_bar(mapping = aes(x = outcome, fill = gender), color = "black")+
  
  theme_minimal()+                   # simplify background
  
  scale_y_continuous(                # continuous scale for y-axis (counts)
    expand = c(0,0),                 # no padding
    breaks = seq(from = 0,
                 to = 3000,
                 by = 500))+
  
  scale_x_discrete(                   # discrete scale for x-axis (gender)
    expand = c(0,0),                  # no padding
    drop = FALSE,                     # show all factor levels (even if not in data)
    na.translate = FALSE,             # remove NA outcomes from plot
    labels = c("Died", "Recovered"))+ # Change display of values
    
  
  scale_fill_manual(                  # Manually specify fill (bar interior color)
    values = c("m" = "violetred",     # reference values in data to assign colors
               "f" = "aquamarine"),
    labels = c("m" = "Male",          # re-label the legend (use "=" assignment to avoid mistakes)
              "f" = "Female",
              "Missing"),
    name = "Gender",                  # title of legend
    na.value = "grey"                 # assign a color for missing values
  )+
  labs(title = "Adjustment of scales") # Adjust the title of the fill legend
```

### Kontinuierliche Achsenskalen {.unnumbered}

Wenn die Daten den Achsen zugeordnet werden, können auch diese mit Skalenbefehlen angepasst werden. Ein gängiges Beispiel ist die Anpassung der Anzeige einer Achse (z. B. der y-Achse), die auf eine Spalte mit kontinuierlichen Daten abgebildet wird.

Wir können die Brüche oder die Anzeige der Werte im ggplot anpassen, indem wir `scale_y_continuous()`. Wie oben erwähnt, verwende das Argument `breaks = ` eine Reihe von Werten an, die als "Unterbrechungen" entlang der Skala dienen sollen. Das sind die Werte, bei denen die Zahlen angezeigt werden. Zu diesem Argument kannst du eine `c()` Vektor angeben, der die gewünschten Unterbrechungswerte enthält, oder du kannst eine reguläre Zahlenfolge angeben, indem du die **Basis** R-Funktion `seq()`. Diese `seq()` Funktion akzeptiert `to = `, `from = `, und `by = `.

```{r, warning=F, message=F, out.width=c("50%", "50%"), fig.show="hold"}
# BASELINE - no scale adjustment
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = outcome, fill = gender))+
  labs(title = "Baseline - no scale adjustments")

# 
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = outcome, fill = gender))+
  scale_y_continuous(
    breaks = seq(
      from = 0,
      to = 3000,
      by = 100)
  )+
  labs(title = "Adjusted y-axis breaks")

```

#### Prozente anzeigen {.unnumbered}

Wenn deine ursprünglichen Datenwerte Proportionen sind, kannst du sie ganz einfach als Prozentwerte mit "%" anzeigen, indem du `labels = scales::percent` in deinem Skalenbefehl einfügst, wie unten gezeigt.

Eine Alternative wäre, die Werte in Zeichen umzuwandeln und am Ende ein "%"-Zeichen hinzuzufügen. Dieser Ansatz führt jedoch zu Komplikationen, weil deine Daten dann keine kontinuierlichen numerischen Werte mehr sind.

```{r, warning=F, message=F, out.width=c("50%", "50%"), fig.show="hold"}
# Original y-axis proportions
#############################
linelist %>%                                   # start with linelist
  group_by(hospital) %>%                       # group data by hospital
  summarise(                                   # create summary columns
    n = n(),                                     # total number of rows in group
    deaths = sum(outcome == "Death", na.rm=T),   # number of deaths in group
    prop_death = deaths/n) %>%                   # proportion deaths in group
  ggplot(                                      # begin plotting
    mapping = aes(
      x = hospital,
      y = prop_death))+ 
  geom_col()+
  theme_minimal()+
  labs(title = "Display y-axis original proportions")



# Display y-axis proportions as percents
########################################
linelist %>%         
  group_by(hospital) %>% 
  summarise(
    n = n(),
    deaths = sum(outcome == "Death", na.rm=T),
    prop_death = deaths/n) %>% 
  ggplot(
    mapping = aes(
      x = hospital,
      y = prop_death))+
  geom_col()+
  theme_minimal()+
  labs(title = "Display y-axis as percents (%)")+
  scale_y_continuous(
    labels = scales::percent                    # display proportions as percents
  )

```

#### Log-Skala {.unnumbered}

Um eine kontinuierliche Achse in eine logarithmische Skala umzuwandeln, füge `trans = "log2"` an den Befehl scale an. Für das Beispiel erstellen wir einen Datenrahmen mit Regionen und ihren jeweiligen `preparedness_index` und kumulativen Fallwerten.

```{r}
plot_data <- data.frame(
  region = c("A", "B", "C", "D", "E", "F", "G", "H", "I"),
  preparedness_index = c(8.8, 7.5, 3.4, 3.6, 2.1, 7.9, 7.0, 5.6, 1.0),
  cases_cumulative = c(15, 45, 80, 20, 21, 7, 51, 30, 1442)
)

plot_data
```

Die kumulierten Fälle in der Region "I" sind dramatisch höher als in allen anderen Regionen. In solchen Fällen kannst du die y-Achse mit einer logarithmischen Skala darstellen, damit der Leser die Unterschiede zwischen den Regionen mit weniger kumulativen Fällen erkennen kann.

```{r, warning=F, message=F, out.width=c("50%", "50%"), fig.show="hold"}
# Original y-axis
preparedness_plot <- ggplot(data = plot_data,  
       mapping = aes(
         x = preparedness_index,
         y = cases_cumulative))+
  geom_point(size = 2)+            # points for each region 
  geom_text(
    mapping = aes(label = region),
    vjust = 1.5)+                  # add text labels
  theme_minimal()

preparedness_plot                  # print original plot


# print with y-axis transformed
preparedness_plot+                   # begin with plot saved above
  scale_y_continuous(trans = "log2") # add transformation for y-axis
```

### Steigungsskalen {.unnumbered}

Die Skalierung von Füllverläufen kann zusätzliche Nuancen enthalten. Die Standardeinstellungen sind in der Regel recht ansprechend, aber vielleicht möchtest du die Werte, Abgrenzungen usw. anpassen.

Um zu zeigen, wie man eine kontinuierliche Farbskala anpasst, verwenden wir einen Datensatz aus der [Kontaktverfolgung] Seite, der das Alter der Fälle und ihrer Ausgangsfälle enthält.

```{r, warning=F, message=F}
case_source_relationships <- rio::import(here::here("data", "godata", "relationships_clean.rds")) %>% 
  select(source_age, target_age) 
```

Im Folgenden erstellen wir ein "Raster" für die Wärmekacheldichte. Wir erklären nicht, wie das geht (siehe den Link im Absatz oben), sondern konzentrieren uns darauf, wie wir die Farbskala anpassen können. Lies mehr über die `stat_density2d()` **ggplot2** Funktion [hier](https://ggplot2.tidyverse.org/reference/geom_density_2d.html). Beachte, wie die `fill` Skala ist *kontinuierlich*.

```{r, warn=F, message=F}
trans_matrix <- ggplot(
    data = case_source_relationships,
    mapping = aes(x = source_age, y = target_age))+
  stat_density2d(
    geom = "raster",
    mapping = aes(fill = after_stat(density)),
    contour = FALSE)+
  theme_minimal()
```

Jetzt zeigen wir einige Variationen der Füllskala:

```{r, out.width=c("50%", "50%"), fig.show="hold", warning=F, message=F}
trans_matrix
trans_matrix + scale_fill_viridis_c(option = "plasma")
```

Jetzt zeigen wir einige Beispiele, wie du die Haltepunkte der Skala anpassen kannst:

- `scale_fill_gradient()` nimmt zwei Farben an (hoch/niedrig)
- `scale_fill_gradientn()` akzeptiert einen Vektor beliebiger Länge von Farben zu `values = ` (Zwischenwerte werden interpoliert)
- verwenden [`scales::rescale()`](https://www.rdocumentation.org/packages/scales/versions/0.4.1/topics/rescale) kannst du einstellen, wie die Farben entlang des Farbverlaufs positioniert werden; der Vektor der Positionen wird so skaliert, dass er zwischen 0 und 1 liegt.

```{r, out.width=c("50%", "50%"), fig.show="hold", warning=F, message=F}
trans_matrix + 
  scale_fill_gradient(     # 2-sided gradient scale
    low = "aquamarine",    # low value
    high = "purple",       # high value
    na.value = "grey",     # value for NA
    name = "Density")+     # Legend title
  labs(title = "Manually specify high/low colors")

# 3+ colors to scale
trans_matrix + 
  scale_fill_gradientn(    # 3-color scale (low/mid/high)
    colors = c("blue", "yellow","red") # provide colors in vector
  )+
  labs(title = "3-color scale")

# Use of rescale() to adjust placement of colors along scale
trans_matrix + 
  scale_fill_gradientn(    # provide any number of colors
    colors = c("blue", "yellow","red", "black"),
    values = scales::rescale(c(0, 0.05, 0.07, 0.10, 0.15, 0.20, 0.3, 0.5)) # positions for colors are rescaled between 0 and 1
    )+
  labs(title = "Colors not evenly positioned")

# use of limits to cut-off values that get fill color
trans_matrix + 
  scale_fill_gradientn(    
    colors = c("blue", "yellow","red"),
    limits = c(0, 0.0002))+
  labs(title = "Restrict value limits, resulting in grey space")

```

### Paletten {.unnumbered}

#### Colorbrewer und Viridis {.unnumbered}

Wenn du generell vordefinierte Paletten möchtest, kannst du die `scale_xxx_brewer` oder `scale_xxx_viridis_y` Funktionen verwenden.

Die "Brauer"-Funktionen können aus [colorbrewer.org](colorbrewer.org) Paletten beziehen.

Die "viridis"-Funktionen basieren auf den viridis-Paletten (farbenblind), die "Farbkarten bieten, die sowohl in Farbe als auch in Schwarz-Weiß einheitlich wahrgenommen werden. Sie sind so konzipiert, dass sie auch von Menschen mit Farbenblindheit wahrgenommen werden können." (mehr dazu [hier](https://ggplot2.tidyverse.org/reference/scale_viridis.html) und [hier](https://bids.github.io/colormap/)). Lege fest, ob die Palette diskret, kontinuierlich oder gebündelt ist, indem du dies am Ende der Funktion angibst (z. B. ist diskret `scale_xxx_viridis_d`).

Es ist ratsam, dass du deinen Plot auf diese Weise testest [Farbenblindheitssimulator](https://www.color-blindness.com/coblis-color-blindness-simulator/). Wenn du ein rot/grünes Farbschema hast, versuche stattdessen ein "heiß-kaltes" (rot-blaues) Schema, wie beschrieben [hier](https://www.visualisingdata.com/2019/08/five-ways-to-design-for-red-green-colour-blindness/#:~:text=The%20pink%2Dred%20through%20to,green%20hues%20used%20by%20default.)

Hier ist ein Beispiel aus den [ggplot Grundlagen] Seite, das verschiedene Farbschemata verwendet.

```{r, out.width=c("50%"), fig.show="hold", warning=F, message=F}
symp_plot <- linelist %>%                                         # begin with linelist
  select(c(case_id, fever, chills, cough, aches, vomit)) %>%     # select columns
  pivot_longer(                                                  # pivot longer
    cols = -case_id,                                  
    names_to = "symptom_name",
    values_to = "symptom_is_present") %>%
  mutate(                                                        # replace missing values
    symptom_is_present = replace_na(symptom_is_present, "unknown")) %>% 
  ggplot(                                                        # begin ggplot!
    mapping = aes(x = symptom_name, fill = symptom_is_present))+
  geom_bar(position = "fill", col = "black") +                    
  theme_classic() +
  theme(legend.position = "bottom")+
  labs(
    x = "Symptom",
    y = "Symptom status (proportion)"
  )

symp_plot  # print with default colors

#################################
# print with manually-specified colors
symp_plot +
  scale_fill_manual(
    values = c("yes" = "black",         # explicitly define colours
               "no" = "white",
               "unknown" = "grey"),
    breaks = c("yes", "no", "unknown"), # order the factors correctly
    name = ""                           # set legend to no title

  ) 

#################################
# print with viridis discrete colors
symp_plot +
  scale_fill_viridis_d(
    breaks = c("yes", "no", "unknown"),
    name = ""
  )


```

<!-- ======================================================= -->

## Reihenfolge der diskreten Variablen ändern {}

Die Reihenfolge der diskreten Variablen zu ändern, ist für Menschen, die sich noch nicht so gut auskennen, oft schwer zu verstehen. `ggplot2` Graphen. Dabei ist es ganz einfach zu verstehen, wie man das macht, wenn man weiß, wie `ggplot2` diskrete Variablen unter der Haube behandelt. Wenn eine diskrete Variable verwendet wird, wird sie im Allgemeinen automatisch in eine `factor` Typ umgewandelt, der die Faktoren standardmäßig in alphabetischer Reihenfolge anordnet. Um dies zu ändern, musst du die Faktoren einfach in der Reihenfolge anordnen, in der sie im Diagramm erscheinen sollen. Ausführlichere Informationen über die Neuordnung `factor` Objekten findest du im Abschnitt über die Faktoren in diesem Leitfaden.

Wir können ein gängiges Beispiel mit Altersgruppen betrachten - standardmäßig wird die Altersgruppe 5-9 in der Mitte der Altersgruppen platziert (in alphanumerischer Reihenfolge), aber wir können sie hinter die Altersgruppe 0-4 des Diagramms verschieben, indem wir die Faktoren neu ordnen.

```{r, warning=F, message=F}
ggplot(
  data = linelist %>% drop_na(age_cat5),                         # remove rows where age_cat5 is missing
  mapping = aes(x = fct_relevel(age_cat5, "5-9", after = 1))) +  # relevel factor

  geom_bar() +
  
  labs(x = "Age group", y = "Number of hospitalisations",
       title = "Total hospitalisations by age group") +
  
  theme_minimal()


```

#### **ggthemr** {.unnnumbered}

Erwäge auch die Verwendung der **ggthemr** Paket zu verwenden. Du kannst dieses Paket von Github herunterladen, indem du die Anweisungen befolgst [hier](https://github.com/Mikata-Project/ggthemr). Es bietet Paletten, die ästhetisch sehr ansprechend sind, aber sei dir bewusst, dass diese in der Regel eine maximale Anzahl von Werten haben, die dich einschränken können, wenn du mehr als 7 oder 8 Farben möchtest.

## Konturlinien

Konturdiagramme sind hilfreich, wenn du viele Punkte hast, die sich gegenseitig überdecken könnten ("Overplotting"). Die oben verwendeten Fallquellendaten werden wieder geplottet, aber einfacher mit `stat_density2d()` und `stat_density2d_filled()` um diskrete Konturenebenen zu erzeugen - wie bei einer topografischen Karte. Lies mehr über die Statistiken [hier](https://ggplot2.tidyverse.org/reference/geom_density_2d.html).

```{r, out.width=c("50%"), fig.show="hold", warning=F, message=F}
case_source_relationships %>% 
  ggplot(aes(x = source_age, y = target_age))+
  stat_density2d()+
  geom_point()+
  theme_minimal()+
  labs(title = "stat_density2d() + geom_point()")


case_source_relationships %>% 
  ggplot(aes(x = source_age, y = target_age))+
  stat_density2d_filled()+
  theme_minimal()+
  labs(title = "stat_density2d_filled()")

```

## Marginale Verteilungen

Um die Verteilungen an den Rändern eines `geom_point()` Streudiagramms anzuzeigen, kannst du die **ggExtra** Paket und seine Funktion `ggMarginal()`. Speichere deinen ursprünglichen ggplot als Objekt und übergebe es dann an `ggMarginal()` wie unten gezeigt. Hier sind die wichtigsten Argumente:

- Du musst die `type = ` entweder als "Histogramm", "Dichte" "Boxplot", "Geige" oder "Densigramm" angeben.
- Standardmäßig werden Randdiagramme für beide Achsen angezeigt. Du kannst einstellen `margins = ` auf "x" oder "y" einstellen, wenn du nur eine Achse möchtest.
- Andere optionale Argumente sind `fill = ` (Balkenfarbe), `color = ` (Linienfarbe), `size = ` (Plotgröße relativ zur Randgröße, d.h. eine größere Zahl macht den Randplot kleiner).
- Du kannst weitere achsenspezifische Argumente an `xparams = ` und `yparams = `. Du kannst zum Beispiel verschiedene Histogramm-Bin-Größen angeben, wie unten gezeigt.

Die Randdiagramme können Gruppen widerspiegeln (Spalten, die zu `color = ` in deinem `ggplot()` kartierten Ästhetik). Wenn dies der Fall ist, setze die `ggMarginal()` Argument `groupColour = ` oder `groupFill = ` an `TRUE`, wie unten gezeigt.

Lies mehr unter [diese Vignette](https://cran.r-project.org/web/packages/ggExtra/vignettes/ggExtra.html), im [R Graph Galerie](https://www.r-graph-gallery.com/277-marginal-histogram-for-ggplot2.html) oder in der R-Dokumentation der Funktion `?ggMarginal`.

```{r, message=FALSE, warning=FALSE}
# Install/load ggExtra
pacman::p_load(ggExtra)

# Basic scatter plot of weight and age
scatter_plot <- ggplot(data = linelist)+
  geom_point(mapping = aes(y = wt_kg, x = age)) +
  labs(title = "Scatter plot of weight and age")
```

Um marginale Histogramme hinzuzufügen, verwenden Sie `type = "histogram"`. Sie können optional einstellen `groupFill = TRUE` setzen, um gestapelte Histogramme zu erhalten.

```{r, message=FALSE, warning=FALSE}
# with histograms
ggMarginal(
  scatter_plot,                     # add marginal histograms
  type = "histogram",               # specify histograms
  fill = "lightblue",               # bar fill
  xparams = list(binwidth = 10),    # other parameters for x-axis marginal
  yparams = list(binwidth = 5))     # other parameters for y-axis marginal
```

Marginaler Dichteplot mit gruppierten/gefärbten Werten:

```{r, message=FALSE, warning=FALSE}

# Scatter plot, colored by outcome
# Outcome column is assigned as color in ggplot. groupFill in ggMarginal set to TRUE
scatter_plot_color <- ggplot(data = linelist %>% drop_na(gender))+
  geom_point(mapping = aes(y = wt_kg, x = age, color = gender)) +
  labs(title = "Scatter plot of weight and age")+
  theme(legend.position = "bottom")

ggMarginal(scatter_plot_color, type = "density", groupFill = TRUE)
```

Stellen Sie die `size = ` ein, um die relative Größe der Randdarstellung anzupassen. Je kleiner die Zahl, desto größer die Randdarstellung. Du stellst auch `color = `. Unten siehst du einen marginalen Boxplot, mit einer Demonstration der `margins = ` Argument, damit es nur auf einer Achse erscheint:

```{r, message=FALSE, warning=FALSE}
# with boxplot 
ggMarginal(
  scatter_plot,
  margins = "x",      # only show x-axis marginal plot
  type = "boxplot")   
```

<!-- ======================================================= -->

## Intelligente Beschriftung {}

Unter **ggplot2** ist es auch möglich, Plots mit Text zu versehen. Dies hat jedoch den Nachteil, dass die Textbeschriftungen oft mit den Datenpunkten in einem Diagramm kollidieren und dadurch unübersichtlich oder schwer zu lesen sind. Im Basispaket gibt es keine ideale Lösung für dieses Problem, aber es gibt eine **ggplot2** Add-on, bekannt als **ggrepel** das den Umgang mit diesem Problem sehr einfach macht!

Die **ggrepel** Paket bietet zwei neue Funktionen, `geom_label_repel()` und `geom_text_repel()`, die ersetzen `geom_label()` und `geom_text()`. Verwende diese Funktionen einfach anstelle der Basisfunktionen, um saubere Beschriftungen zu erzeugen. Bilde innerhalb der Funktion die Ästhetik ab `aes()` wie immer, aber füge das Argument `label = ` ein, das du mit einem Spaltennamen versiehst, der die Werte enthält, die du anzeigen möchtest (z. B. Patienten-ID oder Name usw.). Du kannst auch komplexere Beschriftungen erstellen, indem du Spalten und Zeilenumbrüche kombinierst (`\n`) innerhalb von `str_glue()` wie unten gezeigt.

Ein paar Tipps:

- Verwende `min.segment.length = 0` um immer Liniensegmente zu zeichnen, oder `min.segment.length = Inf` um sie nie zu zeichnen
- verwenden `size = ` außerhalb von `aes()` um die Textgröße einzustellen
- verwenden `force = ` änderst du den Grad der Abstoßung zwischen Beschriftungen und ihren jeweiligen Punkten (Standard ist 1).
- einbeziehen `fill = ` innerhalb von `aes()` um das Etikett nach dem Wert zu färben
  - Ein Buchstabe "a" kann in der Legende erscheinen - hinzufügen `guides(fill = guide_legend(override.aes = aes(color = NA)))+` um ihn zu entfernen

Siehst du, das ist sehr detailliert [Tutorium](https://ggrepel.slowkow.com/articles/examples.html) für mehr.

```{r, warning=F, message=F}
pacman::p_load(ggrepel)

linelist %>%                                               # start with linelist
  group_by(hospital) %>%                                   # group by hospital
  summarise(                                               # create new dataset with summary values per hospital
    n_cases = n(),                                           # number of cases per hospital
    delay_mean = round(mean(days_onset_hosp, na.rm=T),1),    # mean delay per hospital
  ) %>% 
  ggplot(mapping = aes(x = n_cases, y = delay_mean))+      # send data frame to ggplot
  geom_point(size = 2)+                                    # add points
  geom_label_repel(                                        # add point labels
    mapping = aes(
      label = stringr::str_glue(
        "{hospital}\n{n_cases} cases, {delay_mean} days")  # how label displays
      ), 
    size = 3,                                              # text size in labels
    min.segment.length = 0)+                               # show all line segments                
  labs(                                                    # add axes labels
    title = "Mean delay to admission, by hospital",
    x = "Number of cases",
    y = "Mean delay (days)")
```

Du kannst nur eine Teilmenge der Datenpunkte beschriften - indem du Standard `ggplot()` Syntax verschiedene `data = ` für jeden `geom` Ebene des Plots zu verwenden. Unten sind alle Fälle aufgezeichnet, aber nur einige wenige sind beschriftet.

```{r, warning=F, message=FALSE}

ggplot()+
  # All points in grey
  geom_point(
    data = linelist,                                   # all data provided to this layer
    mapping = aes(x = ht_cm, y = wt_kg),
    color = "grey",
    alpha = 0.5)+                                              # grey and semi-transparent
  
  # Few points in black
  geom_point(
    data = linelist %>% filter(days_onset_hosp > 15),  # filtered data provided to this layer
    mapping = aes(x = ht_cm, y = wt_kg),
    alpha = 1)+                                                # default black and not transparent
  
  # point labels for few points
  geom_label_repel(
    data = linelist %>% filter(days_onset_hosp > 15),  # filter the data for the labels
    mapping = aes(
      x = ht_cm,
      y = wt_kg,
      fill = outcome,                                          # label color by outcome
      label = stringr::str_glue("Delay: {days_onset_hosp}d")), # label created with str_glue()
    min.segment.length = 0) +                                  # show line segments for all
  
  # remove letter "a" from inside legend boxes
  guides(fill = guide_legend(override.aes = aes(color = NA)))+
  
  # axis labels
  labs(
    title = "Cases with long delay to admission",
    y = "weight (kg)",
    x = "height(cm)")
```

<!-- ======================================================= -->

## Zeit-Achsen {}

Die Arbeit mit Zeitachsen in ggplot kann entmutigend erscheinen, ist aber mit ein paar Schlüsselfunktionen sehr einfach. Denke daran, dass du bei der Arbeit mit Zeit oder Datum sicherstellen solltest, dass die richtigen Variablen als Datums- oder Datetime-Klasse formatiert sind - siehe die [Arbeiten mit Daten] Seite für weitere Informationen dazu, oder [Epidemische Kurven] Seite (Abschnitt ggplot) für Beispiele.

Der nützlichste Satz von Funktionen für die Arbeit mit Daten in `ggplot2` sind die Skalierungsfunktionen (`scale_x_date()`, `scale_x_datetime()` und ihre verwandten Funktionen für die y-Achse). Mit diesen Funktionen kannst du festlegen, wie oft du Achsenbeschriftungen haben willst und wie du die Achsenbeschriftungen formatieren willst. Wie du Daten formatieren kannst, erfährst du in der *Arbeiten mit Datumsangaben* noch einmal nach! Du kannst die `date_breaks` und `date_labels` Argumente verwenden, um festzulegen, wie die Daten aussehen sollen:

1. `date_breaks` Ermöglicht es dir, festzulegen, wie oft Achsenbrüche auftreten - du kannst hier eine Zeichenkette übergeben (z. B. `"3 months"`, oder "`2 days"`)

2. `date_labels` kannst du festlegen, in welchem Format das Datum angezeigt werden soll. Du kannst diesen Argumenten einen Datumsformat-String übergeben (z. B. `"%b-%d-%Y"`):

```{r, warning=F, message=F}
# make epi curve by date of onset when available
ggplot(linelist, aes(x = date_onset)) +
  geom_histogram(binwidth = 7) +
  scale_x_date(
    # 1 break every 1 month
    date_breaks = "1 months",
    # labels should show month then date
    date_labels = "%b %d"
  ) +
  theme_classic()

```

Eine einfache Lösung für effiziente Datumsbeschriftungen auf der x-Achse ist die Zuweisung des `labels = ` Argument in `scale_x_date()` an die Funktion `label_date_short()` aus dem Paket **skaliert**. Diese Funktion konstruiert automatisch effiziente Datumsetiketten (mehr dazu [hier](https://scales.r-lib.org/reference/label_date.html)). Ein zusätzlicher Vorteil dieser Funktion ist, dass sich die Beschriftungen automatisch anpassen, wenn deine Daten im Laufe der Zeit wachsen - von Tagen über Wochen bis hin zu Monaten und Jahren.

Ein vollständiges Beispiel findest du auf der Epicurves-Seite unter [mehrstufige Datumsetiketten](https://epirhandbook.com/en/epidemic-curves.html#multi-level-date-labels) aber ein kurzes Beispiel ist unten als Referenz dargestellt:

```{r, eval=T, warning=F}
ggplot(linelist, aes(x = date_onset)) +
  geom_histogram(binwidth = 7) +
  scale_x_date(
    labels = scales::label_date_short()  # automatically efficient date labels
  )+
  theme_classic()

```

<!-- ======================================================= -->

## Hervorhebung {}

Das Hervorheben bestimmter Elemente in einem Diagramm ist eine nützliche Methode, um die Aufmerksamkeit auf ein bestimmtes Beispiel einer Variable zu lenken und gleichzeitig Informationen über die Streuung des gesamten Datensatzes zu liefern. In der Basisversion ist dies nicht so einfach möglich **ggplot2** möglich ist, gibt es ein externes Paket, das dabei helfen kann, nämlich **gghighlight**. Es ist einfach in der ggplot-Syntax zu verwenden.

Die **gghighlight** Paket verwendet die `gghighlight()` Funktion, um diesen Effekt zu erzielen. Um diese Funktion zu nutzen, übergibst du eine logische Anweisung an die Funktion - das kann ziemlich flexible Ergebnisse haben, aber hier zeigen wir ein Beispiel für die Altersverteilung der Fälle in unserer Zeilenliste und heben sie nach Ergebnis hervor.

```{r, warning=F, message=F}
# load gghighlight
library(gghighlight)

# replace NA values with unknown in the outcome variable
linelist <- linelist %>%
  mutate(outcome = replace_na(outcome, "Unknown"))

# produce a histogram of all cases by age
ggplot(
  data = linelist,
  mapping = aes(x = age_years, fill = outcome)) +
  geom_histogram() + 
  gghighlight::gghighlight(outcome == "Death")     # highlight instances where the patient has died.

```

Das funktioniert auch gut mit Facettenfunktionen - so kann der Nutzer Facettenplots erstellen, bei denen die Hintergrunddaten hervorgehoben werden, die nicht auf die Facette zutreffen! Unten zählen wir die Fälle nach Woche und stellen die Epidemiekurven nach Krankenhaus dar (`color = ` und `facet_wrap()` gesetzt auf `hospital` Spalte).

```{r, warning=F, message=F}

# produce a histogram of all cases by age
linelist %>% 
  count(week = lubridate::floor_date(date_hospitalisation, "week"),
        hospital) %>% 
  ggplot()+
  geom_line(aes(x = week, y = n, color = hospital))+
  theme_minimal()+
  gghighlight::gghighlight() +                      # highlight instances where the patient has died
  facet_wrap(~hospital)                              # make facets by outcome

```

## Plotten mehrerer Datensätze

Beachte, dass es schwierig sein kann, die Achsen von mehreren Datensätzen in einem Diagramm richtig auszurichten. Ziehe eine der folgenden Strategien in Betracht:

- Führe die Daten vor dem Plotten zusammen und konvertiere sie in das "lange" Format mit einer Spalte, die den Datensatz widerspiegelt.
- Verwende **cowplot** oder ein ähnliches Paket, um zwei Plots zu kombinieren (siehe unten)

<!-- ======================================================= -->

## Plots kombinieren {}

Zwei Pakete, die für die Kombination von Plots sehr nützlich sind, sind **cowplot** und **Patchwork**. Auf dieser Seite werden wir uns hauptsächlich auf Folgendes konzentrieren **Cowplot** mit gelegentlicher Verwendung von **Patchwork**.

Hier ist die Online [Einführung in Cowplot](https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html). Du kannst die ausführlichere Dokumentation für jede Funktion online lesen [hier](https://www.rdocumentation.org/packages/cowplot/versions/1.1.1). Im Folgenden gehen wir auf einige der häufigsten Anwendungsfälle und Funktionen ein.

Die **cowplot** Paket arbeitet zusammen mit **ggplot2** - Im Wesentlichen verwendest du es, um ggplots und ihre Legenden zu zusammengesetzten Zahlen anzuordnen und zu kombinieren. Es kann auch **Basis** R-Grafiken.

```{r}
pacman::p_load(
  tidyverse,      # data manipulation and visualisation
  cowplot,        # combine plots
  patchwork       # combine plots
)
```

Während die Facettierung (beschrieben in den [ggplot Grundlagen] Seite beschrieben) ist zwar ein praktischer Ansatz zum Plotten, aber manchmal ist es nicht möglich, mit diesem relativ restriktiven Ansatz die gewünschten Ergebnisse zu erzielen. In diesem Fall kannst du Plots kombinieren, indem du sie zu einem größeren Plot zusammenfügst. Es gibt drei bekannte Pakete, die sich dafür hervorragend eignen -**cowplot**, **gridExtra** und **Patchwork**. Diese Pakete tun jedoch weitgehend dasselbe, daher konzentrieren wir uns auf **cowplot** für diesen Abschnitt.

### `plot_grid()` {.unnumbered}

Die **Kuhplot** Paket hat eine ziemlich große Bandbreite an Funktionen, aber am einfachsten lässt es sich durch die Verwendung von `plot_grid()`. Damit kannst du vordefinierte Diagramme in einem Raster anordnen. Wir können ein weiteres Beispiel mit dem Malaria-Datensatz durcharbeiten - hier können wir die Gesamtzahl der Fälle nach Bezirken darstellen und auch die Epidemiekurve im Zeitverlauf zeigen.

```{r, warning=F, message=F}
malaria_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) 

# bar chart of total cases by district
p1 <- ggplot(malaria_data, aes(x = District, y = malaria_tot)) +
  geom_bar(stat = "identity") +
  labs(
    x = "District",
    y = "Total number of cases",
    title = "Total malaria cases by district"
  ) +
  theme_minimal()

# epidemic curve over time
p2 <- ggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +
  geom_col(width = 1) +
  labs(
    x = "Date of data submission",
    y =  "number of cases"
  ) +
  theme_minimal()

cowplot::plot_grid(p1, p2,
                  # 1 column and two rows - stacked on top of each other
                   ncol = 1,
                   nrow = 2,
                   # top plot is 2/3 as tall as second
                   rel_heights = c(2, 3))


```

### Kombiniere Legenden {.unnumbered}

Wenn deine Plots die gleiche Legende haben, ist es relativ einfach, sie zu kombinieren. Verwende einfach die **cowplot** um die Plots zu kombinieren, aber entferne die Legende von einem der Plots (de-duplicate).

Wenn deine Plots unterschiedliche Legenden haben, musst du einen anderen Ansatz wählen:

1) Erstelle und speichere deine Plots *ohne Legenden* mit `theme(legend.position = "none")`
2) Extrahiere die Legenden aus jedem Plot mit `get_legend()` wie unten gezeigt - *aber extrahiere die Legenden aus den geänderten Plots, um die Legende tatsächlich anzuzeigen*
3) Kombiniere die Legenden in einem Legenden-Panel
4) Kombiniere die Plots und das Legenden-Panel

Zur Veranschaulichung zeigen wir die beiden Diagramme getrennt und dann in einem Raster mit ihren eigenen Legenden angeordnet (hässliche und ineffiziente Platznutzung):

```{r, out.width=c("50%"), fig.show="hold", warning=F, message=F}
p1 <- linelist %>% 
  mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>% 
  count(hospital, outcome) %>% 
  ggplot()+
  geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+
  scale_fill_brewer(type = "qual", palette = 4, na.value = "grey")+
  coord_flip()+
  theme_minimal()+
  labs(title = "Cases by outcome")


p2 <- linelist %>% 
  mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>% 
  count(hospital, age_cat) %>% 
  ggplot()+
  geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+
  scale_fill_brewer(type = "qual", palette = 1, na.value = "grey")+
  coord_flip()+
  theme_minimal()+
  theme(axis.text.y = element_blank())+
  labs(title = "Cases by age")

```

So sehen die beiden Diagramme aus, wenn sie mit `plot_grid()` ohne ihre Legenden zu kombinieren:

```{r, warning=F, message=F}
cowplot::plot_grid(p1, p2, rel_widths = c(0.3))
```

Und jetzt zeigen wir, wie wir die Legenden kombinieren. Im Wesentlichen definieren wir jeden Plot wie folgt *ohne* seine Legende (`theme(legend.position = "none"`), und dann definieren wir die Legende für jeden Plot *separat* unter Verwendung der `get_legend()` Funktion von **cowplot**. Wenn wir die Legende aus dem gespeicherten Plot extrahieren, müssen wir Folgendes hinzufügen `+` die Legende wieder einfügen, einschließlich der Angabe der Platzierung ("rechts") und kleinerer Anpassungen für die Ausrichtung der Legenden und ihrer Titel. Dann fügen wir die Legenden vertikal zusammen und kombinieren dann die beiden Plots mit den neu kombinierten Legenden. Voila!

```{r, warning=F, message=F}

# Define plot 1 without legend
p1 <- linelist %>% 
  mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>% 
  count(hospital, outcome) %>% 
  ggplot()+
  geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+
  scale_fill_brewer(type = "qual", palette = 4, na.value = "grey")+
  coord_flip()+
  theme_minimal()+
  theme(legend.position = "none")+
  labs(title = "Cases by outcome")


# Define plot 2 without legend
p2 <- linelist %>% 
  mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>% 
  count(hospital, age_cat) %>% 
  ggplot()+
  geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+
  scale_fill_brewer(type = "qual", palette = 1, na.value = "grey")+
  coord_flip()+
  theme_minimal()+
  theme(
    legend.position = "none",
    axis.text.y = element_blank(),
    axis.title.y = element_blank()
  )+
  labs(title = "Cases by age")


# extract legend from p1 (from p1 + legend)
leg_p1 <- cowplot::get_legend(p1 +
                                theme(legend.position = "right",        # extract vertical legend
                                      legend.justification = c(0,0.5))+ # so legends  align
                                labs(fill = "Outcome"))                 # title of legend
# extract legend from p2 (from p2 + legend)
leg_p2 <- cowplot::get_legend(p2 + 
                                theme(legend.position = "right",         # extract vertical legend   
                                      legend.justification = c(0,0.5))+  # so legends align
                                labs(fill = "Age Category"))             # title of legend

# create a blank plot for legend alignment
#blank_p <- patchwork::plot_spacer() + theme_void()

# create legends panel, can be one on top of the other (or use spacer commented above)
legends <- cowplot::plot_grid(leg_p1, leg_p2, nrow = 2, rel_heights = c(.3, .7))

# combine two plots and the combined legends panel
combined <- cowplot::plot_grid(p1, p2, legends, ncol = 3, rel_widths = c(.4, .4, .2))

combined  # print


```

Diese Lösung wurde gelernt von [diesem Beitrag](https://stackoverflow.com/questions/52060601/ggplot-multiple-legends-arrangement) mit einer kleinen Korrektur zum Ausrichten von Legenden aus [diesem Beitrag](https://github.com/wilkelab/cowplot/issues/33).

<span style="color: darkgreen;">***TIPP:*** Lustige Anmerkung - die "Kuh" in **Kuhplot** kommt vom Namen des Erfinders - Claus O. Wilke.</span>

### Inset Plots {.unnumbered}

Du kannst einen Plot in einen anderen einfügen, indem du **cowplot**. Hier sind einige Dinge, die du beachten solltest:

- Definiere die Haupthandlung mit `theme_half_open()` von **Kuhplot** Es ist vielleicht am besten, wenn die Legende entweder oben oder unten steht.
- Definiere den Insetplot. Am besten ist es, wenn du einen Plot hast, für den du keine Legende brauchst. Du kannst Plot-Themelemente entfernen mit `element_blank()` wie unten gezeigt.
- Kombiniere sie durch Anwendung von `ggdraw()` auf den Hauptplot anwendet und dann `draw_plot()` auf den Inset-Plot anwenden und die Koordinaten (x und y der linken unteren Ecke), die Höhe und die Breite als Anteil des gesamten Hauptplots angeben.

```{r, out.width=c("100%"), fig.show="hold", warning=F, message=F}

# Define main plot
main_plot <- ggplot(data = linelist)+
  geom_histogram(aes(x = date_onset, fill = hospital))+
  scale_fill_brewer(type = "qual", palette = 1, na.value = "grey")+ 
  theme_half_open()+
  theme(legend.position = "bottom")+
  labs(title = "Epidemic curve and outcomes by hospital")


# Define inset plot
inset_plot <- linelist %>% 
  mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>% 
  count(hospital, outcome) %>% 
  ggplot()+
    geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+
    scale_fill_brewer(type = "qual", palette = 4, na.value = "grey")+
    coord_flip()+
    theme_minimal()+
    theme(legend.position = "none",
          axis.title.y = element_blank())+
    labs(title = "Cases by outcome") 


# Combine main with inset
cowplot::ggdraw(main_plot)+
     draw_plot(inset_plot,
               x = .6, y = .55,    #x = .07, y = .65,
               width = .4, height = .4)

```

Diese Technik wird in diesen beiden Vignetten näher erläutert:

[Wilke Labor](https://wilkelab.org/cowplot/articles/drawing_with_on_plots.html)  
[draw\_plot() Dokumentation](https://www.rdocumentation.org/packages/cowplot/versions/1.1.1/topics/draw_plot)

<!-- ======================================================= -->

## Zwei Achsen {}

Eine sekundäre y-Achse ist oft eine gewünschte Ergänzung zu einer `ggplot2` Diagramm. Obwohl es in der Datenvisualisierungs-Community eine heftige Debatte über die Sinnhaftigkeit solcher Diagramme gibt und sie oft nicht empfohlen werden, kann es sein, dass dein Manager sie trotzdem haben möchte. Im Folgenden stellen wir eine Methode vor, um sie zu erreichen: mit der **cowplot** Paket, um zwei separate Diagramme zu kombinieren.

Bei diesem Ansatz werden zwei separate Diagramme erstellt - eines mit einer y-Achse auf der linken und eines mit einer y-Achse auf der rechten Seite. Beide verwenden eine bestimmte `theme_cowplot()` und müssen die gleiche x-Achse haben. In einem dritten Befehl werden die beiden Diagramme dann ausgerichtet und übereinander gelegt. Die Funktionalitäten von **cowplot**, von denen dies nur eine ist, werden in diesem Artikel ausführlich beschrieben [Seite](https://wilkelab.org/cowplot/articles/aligning_plots.html).

Um diese Technik zu demonstrieren, werden wir die Epidemiekurve mit einer Linie überlagern, die den wöchentlichen Prozentsatz der Patienten darstellt, die gestorben sind. Wir verwenden dieses Beispiel, weil die Ausrichtung der Daten auf der X-Achse komplexer ist als z. B. die Ausrichtung eines Balkendiagramms mit einer anderen Darstellung. Einige Dinge sind zu beachten:

- Die Epikurve und die Linie werden vor der Darstellung in Wochen aggregiert *und* die `date_breaks` und `date_labels` identisch sind - wir tun dies, damit die x-Achsen der beiden Diagramme gleich sind, wenn sie übereinander gelegt werden.
- Die y-Achse wird für Diagramm 2 mit der Taste `position = ` Argument von `scale_y_continuous()`.
- Beide Diagramme verwenden die `theme_cowplot()`

Es gibt ein weiteres Beispiel für diese Technik in der [Epidemie-Kurven] Seite - das Überlagern der kumulativen Inzidenz mit der Epikurve.

**Plot 1 erstellen**  
Dies ist im Wesentlichen die Epikurve. Wir verwenden `geom_area()` nur zur Veranschaulichung der Anwendung (Fläche unter einer Linie, standardmäßig)

```{r, warning=F, message=F}
pacman::p_load(cowplot)            # load/install cowplot

p1 <- linelist %>%                 # save plot as object
     count(
       epiweek = lubridate::floor_date(date_onset, "week")) %>% 
     ggplot()+
          geom_area(aes(x = epiweek, y = n), fill = "grey")+
          scale_x_date(
               date_breaks = "month",
               date_labels = "%b")+
     theme_cowplot()+
     labs(
       y = "Weekly cases"
     )

p1                                      # view plot 
```

**Plot 2 erstellen**  
Erstelle das zweite Diagramm, das den wöchentlichen Prozentsatz der verstorbenen Fälle darstellt.

```{r, warning=F, message=F}

p2 <- linelist %>%         # save plot as object
     group_by(
       epiweek = lubridate::floor_date(date_onset, "week")) %>% 
     summarise(
       n = n(),
       pct_death = 100*sum(outcome == "Death", na.rm=T) / n) %>% 
     ggplot(aes(x = epiweek, y = pct_death))+
          geom_line()+
          scale_x_date(
               date_breaks = "month",
               date_labels = "%b")+
          scale_y_continuous(
               position = "right")+
          theme_cowplot()+
          labs(
            x = "Epiweek of symptom onset",
            y = "Weekly percent of deaths",
            title = "Weekly case incidence and percent deaths"
          )

p2     # view plot
```

Jetzt richten wir den Plot mit der Funktion `align_plots()` und geben dabei die horizontale und vertikale Ausrichtung an ("hv", kann auch "h", "v", "none" sein). Mit "tblr" legen wir auch die Ausrichtung aller Achsen fest (oben, unten, links und rechts). Die Ausgabe ist eine Liste der Klasse (2 Elemente).

Dann zeichnen wir die beiden Diagramme zusammen mit `ggdraw()` (aus **Kuhplot**) und referenzieren die beiden Teile der `aligned_plots` Objekts.

```{r, warning=F, message=F}
aligned_plots <- cowplot::align_plots(p1, p2, align="hv", axis="tblr")         # align the two plots and save them as list
aligned_plotted <- ggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])  # overlay them and save the visual plot
aligned_plotted                                                                # print the overlayed plots

```

<!-- ### Statistische Transformation {.unnumbered} -->

<!-- Eine andere Möglichkeit ist, dass die zweite Achse eine direkte Transformation der zweiten Achse ist.  -->

<!-- Die Unterschiede in den Achsenwerten sind rein kosmetischer Natur - wenn du zwei verschiedene Variablen in einem Diagramm mit unterschiedlichen Skalen für die y-Achse darstellen willst, funktioniert das nicht ohne etwas Arbeit hinter den Kulissen. Um diesen Effekt zu erzielen, musst du eine deiner Variablen in den Daten umwandeln und die gleiche Umwandlung *umgekehrt* anwenden, wenn du die Achsenbeschriftungen festlegst. Auf dieser Grundlage kannst du die Transformation entweder explizit angeben (z. B. Variable a ist etwa 10x so groß wie Variable b) oder sie im Code berechnen (z. B. wie groß das Verhältnis zwischen den Maximalwerten der einzelnen Datensätze ist). -->

<!-- Die Syntax zum Hinzufügen einer zweiten Achse ist sehr einfach! Wenn du eine `scale_xxx_xxx()` Funktion aufrufst (z.B. `scale_y_continuous()`), benutze das Argument `sec.axis`, um die Funktion `sec_axis()` aufzurufen. Mit dem Argument `trans` in dieser Funktion kannst du die Beschriftungstransformation für die Achse angeben - gib dies in der Standard-Syntax von tidyverse an.  -->

<!-- Wenn wir z.B. die Anzahl der positiven RDTs im Malaria-Datensatz für Einrichtung 1 anzeigen wollen und dabei die 0-4-Jährigen und alle Fälle im Diagramm darstellen wollen: -->

<!-- ```{r, , warning=F, message=F} -->

<!-- # nimm Malaria-Daten von Einrichtung 1 -->

<!-- malaria_facility_1 <- malaria_data %>% -->

<!-- filter(standort_name == "Einrichtung 1") -->

<!-- # berechne das Verhältnis zwischen malaria_rdt_0-4 und malaria_tot -->

<!-- tf_ratio <- max(malaria_facility_1$malaria_tot, na.rm = T) / max(malaria_facility_1$`malaria_rdt_0-4`, na.rm = T) -->

<!-- # Transformiere die Werte im Datensatz -->

<!-- malaria_facility_1 <- malaria_facility_1 %>% --> -->

<!-- mutate(malaria_rdt_0_4_tf = `malaria_rdt_0-4` * tf_ratio) -->

<!-- # zeichne das Diagramm mit zwei Achsen -->

<!-- ggplot(malaria_facility_1, aes(x = data_date)) + -->

<!-- geom_line(aes(y = malaria_tot, col = "Total cases")) + -->

<!-- geom_line(aes(y = malaria_rdt_0_4_tf, col = "Cases: 0-4 years old")) + -->

<!-- scale_y_continuous( -->

<!-- name = "Fälle insgesamt", -->

<!-- sec.axis = sec_axis(trans = ~ . / tf_ratio, name = "Cases: 0-4 years old") -->

<!-- ) + -->

<!-- labs(x = "Datum der Datenerhebung") + -->

<!-- theme_minimal() + -->

<!-- theme(legend.title = element_blank()) -->

<!-- ``` -->

<!-- ## Sparklines -->

<!-- IM AUFBAU -->

<!-- (vielleicht nach Tabellen für die Präsentationsseite verschieben) -->

## Pakete, die dir helfen

Es gibt einige wirklich tolle R-Pakete, die speziell dafür entwickelt wurden, dir bei der Navigation zu helfen **ggplot2**:

### Zeigen-und-Klicken **ggplot2** mit **equisse**  {.unnumbered}

"Mit diesem Addin kannst du deine Daten interaktiv erkunden, indem du sie mit dem ggplot2-Paket visualisierst. Es ermöglicht dir, Balkenplots, Kurven, Streudiagramme, Histogramme, Boxplots und sf-Objekte zu zeichnen und dann die Grafik zu exportieren oder den Code abzurufen, um die Grafik zu reproduzieren."

Installiere das Addin und starte es dann über das RStudio-Menü oder mit `esquisse::esquisser()`.

Siehe die [Github-Seite](https://github.com/dreamRs/esquisse)

[Dokumentation](https://dreamrs.github.io/esquisse/index.html)

## Sonstiges

### Numerische Anzeige {.unnumbered}

Du kannst die wissenschaftliche Notation deaktivieren, indem du diesen Befehl vor dem Plotten ausführst.

```{r, eval=F}
options(scipen=999)
```

Oder wende `number_format()` aus dem **Waage** Paket auf einen bestimmten Wert oder eine bestimmte Spalte, wie unten gezeigt.

Funktionen aus dem Paket verwenden **skaliert** um die Darstellung von Zahlen einfach anzupassen. Sie können auf die Spalten in deinem Datenrahmen angewendet werden, werden aber in diesem Beispiel nur für einzelne Zahlen angezeigt.

```{r}
scales::number(6.2e5)
scales::number(1506800.62,  accuracy = 0.1,)
scales::comma(1506800.62, accuracy = 0.01)
scales::comma(1506800.62, accuracy = 0.01,  big.mark = "." , decimal.mark = ",")
scales::percent(0.1)
scales::dollar(56)
scales::scientific(100000)
```

## Ressourcen

Inspiration
[ggplot Diagramm-Galerie](https://www.tidyverse.org/blog/2018/07/ggplot2-3-0-0/)

Präsentation von Daten
Europäisches Zentrum für die Prävention und die Kontrolle von Krankheiten [Leitlinien für die Präsentation von Überwachungsdaten](https://ecdc.europa.eu/sites/portal/files/documents/Guidelines%20for%20presentation%20of%20surveillance%20data-final-with-cover-for-we....pdf)

Facetten und Etikettierer
[Verwendung von Etikettierern für Facettenstreifen](http://www.cookbook-r.com/Graphs/Facets_\(ggplot2\)/#modifying-facet-label-text)
[Etikettierer](https://ggplot2.tidyverse.org/reference/labellers.html)

Bestellung mit Faktoren anpassen
[fct\_reorder](https://forcats.tidyverse.org/reference/fct_reorder.html)  
[fct\_inorder](https://forcats.tidyverse.org/reference/fct_inorder.html)  
[Wie man einen Boxplot neu anordnet](https://cmdlinetips.com/2019/02/how-to-reorder-a-boxplot-in-r/)  
[Eine Variable in ggplot2 neu anordnen](https://www.r-graph-gallery.com/267-reorder-a-variable-in-ggplot2.html)  
[R für Datenwissenschaft - Faktoren](https://r4ds.had.co.nz/factors.html)

Legenden  
[Reihenfolge der Legenden anpassen](https://stackoverflow.com/questions/38425908/reverse-stacking-order-without-affecting-legend-order-in-ggplot2-bar-charts)

Beschriftungen
[Ausrichtung der Beschriftung](https://stackoverflow.com/questions/64701500/left-align-ggplot-caption)

Beschriftungen  
[ggrepel](https://ggrepel.slowkow.com/articles/examples.html)

Cheatsheets  
[Schönes Plotten mit ggplot2](http://zevross.com/blog/2014/08/04/beautiful-plotting-in-r-a-ggplot2-cheatsheet-3/)

<!-- TO DO - Under construction -->

<!-- * Gerade horizontale, vertikale oder andere Linie -->

<!-- Du kannst auch gerade Linien mit `geom_hline()` (horizontal), `geom_vline()` (vertikal) oder `geom_abline()` (mit angegebenem y-Abschnitt und Steigung) zu deinem Plot hinzufügen -->

<!-- Benutze die Option `label_wrap_gen` in facet_wrap, um mehrere Streifenlinien zu haben -->

<!-- Etiketten und Farben der Streifen -->

<!-- Vertikale Anpassung des Achsentextes -->

<!-- Drehung -->

<!-- Beschriftungen -->

<!-- Bereich begrenzen mit limit() und coord_cartesian(), ylim(), oder scale_x_continuous() -->

<!-- theme_classic() -->

<!-- expand = c(0,0) -->

<!-- coord_flip() -->

<!-- tick marks -->

<!-- ggrepel -->

<!-- Animationen -->

<!-- Entfernen -->

<!-- Titel entfernen -->

<!-- fill = oder color = in labs() verwenden -->

<!-- Reihenfolge umdrehen / Reihenfolge nicht umdrehen -->

<!-- Standort verschieben -->

<!-- Farbe? theme(legend.title = element_text(colour="chocolate", size=16, face="bold"))+ scale_color_discrete(name="Diese Farbe heißt Schokolade!?") -->

<!-- Farbe der Kästchen hinter den Punkten in der Legende -->

<!-- theme(legend.key=element_rect(fill='pink')) oder fill = NA verwenden, um sie zu entfernen. http://zevross.com/blog/2014/08/04/beautiful-plotting-in-r-a-ggplot2-cheatsheet-3/ -->

<!-- Größe der Symbole in der Legende ändern nur guide(colour = guide_legend(override.aes = list(size=4))) -->

<!-- Schalte eine Ebene in der Legende aus -->

<!-- geom_text(data=nmmaps, aes(date, temp, label=round(temp)), size=4) -->

<!-- geom_text(data=nmmaps, aes(date, temp, label=round(temp), size=4), show_guide=FALSE) -->

<!-- Erzwinge eine Legende, auch wenn kein aes() vorhanden ist.  -->

<!-- ggplot(nmmaps, aes(x=date, y=o3))+ -->

<!-- geom_line(aes(color="Wichtige Linie"))+ -->

<!-- geom_point(aes(color="Meine Punkte")) -->

<!-- Steuere die Form in der Legende mit Hilfslinien - eine Liste mit Linientyp und Form -->

<!-- ggplot(nmmaps, aes(x=date, y=o3))+geom_line(aes(color="Wichtige Linie"))+ -->

<!-- geom_point(aes(color="Punktwerte"))+ -->

<!-- scale_colour_manual(name='', values=c('Wichtige Linie'='grau', 'Punktwerte'='rot'), guide='legend') + -->

<!-- guides(colour = guide_legend(override.aes = list(linetype=c(1,0) -->

<!-- , shape=c(NA, 16)))) -->


